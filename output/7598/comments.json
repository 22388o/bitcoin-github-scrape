[
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/218617610",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/7598#issuecomment-218617610",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/7598",
    "id": 218617610,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxODYxNzYxMA==",
    "user": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-05-11T23:14:50Z",
    "updated_at": "2016-05-11T23:14:50Z",
    "author_association": "CONTRIBUTOR",
    "body": "Needs rebase.\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/218617610/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/220112886",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/7598#issuecomment-220112886",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/7598",
    "id": 220112886,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyMDExMjg4Ng==",
    "user": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?u=b7dd63827227d69794b5fe28797b1bd107b930dd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-05-18T18:15:35Z",
    "updated_at": "2016-05-18T18:15:35Z",
    "author_association": "MEMBER",
    "body": "rebased\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/220112886/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/220868794",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/7598#issuecomment-220868794",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/7598",
    "id": 220868794,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyMDg2ODc5NA==",
    "user": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-05-23T01:13:10Z",
    "updated_at": "2016-05-23T01:13:10Z",
    "author_association": "CONTRIBUTOR",
    "body": "utACK 4dc94d1036576fe988a066fdabc047350ccddda9 +/- whitespace.\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/220868794/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/223053821",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/7598#issuecomment-223053821",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/7598",
    "id": 223053821,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyMzA1MzgyMQ==",
    "user": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?u=b7dd63827227d69794b5fe28797b1bd107b930dd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-01T16:46:24Z",
    "updated_at": "2016-06-01T16:46:24Z",
    "author_association": "MEMBER",
    "body": "Fix two bugs identified by @sdaftuar \n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/223053821/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/223078058",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/7598#issuecomment-223078058",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/7598",
    "id": 223078058,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyMzA3ODA1OA==",
    "user": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-01T18:11:08Z",
    "updated_at": "2016-06-01T18:11:08Z",
    "author_association": "MEMBER",
    "body": "ACK\n\nVerified that the old code and new code produce identical blocks (calling CreateNewBlock every 100 transactions, over two weeks of data from February).\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/223078058/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225939045",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/7598#issuecomment-225939045",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/7598",
    "id": 225939045,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyNTkzOTA0NQ==",
    "user": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?u=8cdd8653982252593843d7369ecfebe432b89768&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-14T16:32:54Z",
    "updated_at": "2016-06-14T16:32:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "utAck -- apologies for line noise on the time thing, wasn't highly related to this.\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225939045/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64160653",
    "pull_request_review_id": null,
    "id": 64160653,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MTYwNjUz",
    "diff_hunk": "@@ -71,231 +71,299 @@ int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParam\n     return nNewTime - nOldTime;\n }\n \n-CBlockTemplate* CreateNewBlock(const CChainParams& chainparams, const CScript& scriptPubKeyIn)\n+BlockAssembler::BlockAssembler(const CChainParams& _chainparams)\n+    : chainparams(_chainparams)\n {\n-    // Create new block\n-    std::unique_ptr<CBlockTemplate> pblocktemplate(new CBlockTemplate());\n+   // Largest block you're willing to create:",
    "path": "src/miner.cpp",
    "position": null,
    "original_position": 10,
    "commit_id": "c2dd5a3c39156749e8ee24772d1fcb01404f2b6f",
    "original_commit_id": "4dc94d1036576fe988a066fdabc047350ccddda9",
    "user": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Nit: whitespace.\n",
    "created_at": "2016-05-23T01:09:46Z",
    "updated_at": "2016-06-01T16:45:43Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r64160653",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64160653"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r64160653"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64160653/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 77,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64160685",
    "pull_request_review_id": null,
    "id": 64160685,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MTYwNjg1",
    "diff_hunk": "@@ -71,231 +71,299 @@ int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParam\n     return nNewTime - nOldTime;\n }\n \n-CBlockTemplate* CreateNewBlock(const CChainParams& chainparams, const CScript& scriptPubKeyIn)\n+BlockAssembler::BlockAssembler(const CChainParams& _chainparams)\n+    : chainparams(_chainparams)\n {\n-    // Create new block\n-    std::unique_ptr<CBlockTemplate> pblocktemplate(new CBlockTemplate());\n+   // Largest block you're willing to create:\n+    nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n+    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n+    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+\n+    // Minimum block size you want to create; block will be filled with free transactions\n+    // until there are no more or the block reaches this size:\n+    nBlockMinSize = GetArg(\"-blockminsize\", DEFAULT_BLOCK_MIN_SIZE);\n+    nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);\n+}\n+\n+void BlockAssembler::resetBlock()\n+{\n+    inBlock.clear();\n+\n+    // Reserve space for coinbase tx\n+    nBlockSize = 1000;\n+    nBlockSigOps = 100;\n+\n+    // These counters do not include coinbase tx\n+    nBlockTx = 0;\n+    nFees = 0;\n+\n+    lastFewTxs = 0;\n+    blockFinished = false;\n+}\n+\n+CBlockTemplate* BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n+{\n+    resetBlock();\n+\n+    pblocktemplate.reset(new CBlockTemplate());\n+\n     if(!pblocktemplate.get())\n         return NULL;\n-    CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n-\n-    // Create coinbase tx\n-    CMutableTransaction txNew;\n-    txNew.vin.resize(1);\n-    txNew.vin[0].prevout.SetNull();\n-    txNew.vout.resize(1);\n-    txNew.vout[0].scriptPubKey = scriptPubKeyIn;\n+    pblock = &pblocktemplate->block; // pointer for convenience\n \n     // Add dummy coinbase tx as first transaction\n     pblock->vtx.push_back(CTransaction());\n     pblocktemplate->vTxFees.push_back(-1); // updated at end\n     pblocktemplate->vTxSigOps.push_back(-1); // updated at end\n \n-    // Largest block you're willing to create:\n-    unsigned int nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n-    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n-    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+    LOCK2(cs_main, mempool.cs);",
    "path": "src/miner.cpp",
    "position": 64,
    "original_position": 64,
    "commit_id": "c2dd5a3c39156749e8ee24772d1fcb01404f2b6f",
    "original_commit_id": "4dc94d1036576fe988a066fdabc047350ccddda9",
    "user": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "The old code deliberately unlocks before calling TestBlockValidity...I'm not actually sure its worth anything, but just noting that there is actually a behavior change here.\n",
    "created_at": "2016-05-23T01:10:42Z",
    "updated_at": "2016-06-01T16:45:43Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r64160685",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64160685"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r64160685"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64160685/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 119,
    "original_line": 119,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64463769",
    "pull_request_review_id": null,
    "id": 64463769,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0NDYzNzY5",
    "diff_hunk": "@@ -71,231 +71,299 @@ int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParam\n     return nNewTime - nOldTime;\n }\n \n-CBlockTemplate* CreateNewBlock(const CChainParams& chainparams, const CScript& scriptPubKeyIn)\n+BlockAssembler::BlockAssembler(const CChainParams& _chainparams)\n+    : chainparams(_chainparams)\n {\n-    // Create new block\n-    std::unique_ptr<CBlockTemplate> pblocktemplate(new CBlockTemplate());\n+   // Largest block you're willing to create:\n+    nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n+    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n+    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+\n+    // Minimum block size you want to create; block will be filled with free transactions\n+    // until there are no more or the block reaches this size:\n+    nBlockMinSize = GetArg(\"-blockminsize\", DEFAULT_BLOCK_MIN_SIZE);\n+    nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);\n+}\n+\n+void BlockAssembler::resetBlock()\n+{\n+    inBlock.clear();\n+\n+    // Reserve space for coinbase tx\n+    nBlockSize = 1000;\n+    nBlockSigOps = 100;\n+\n+    // These counters do not include coinbase tx\n+    nBlockTx = 0;\n+    nFees = 0;\n+\n+    lastFewTxs = 0;\n+    blockFinished = false;\n+}\n+\n+CBlockTemplate* BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n+{\n+    resetBlock();\n+\n+    pblocktemplate.reset(new CBlockTemplate());\n+\n     if(!pblocktemplate.get())\n         return NULL;\n-    CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n-\n-    // Create coinbase tx\n-    CMutableTransaction txNew;\n-    txNew.vin.resize(1);\n-    txNew.vin[0].prevout.SetNull();\n-    txNew.vout.resize(1);\n-    txNew.vout[0].scriptPubKey = scriptPubKeyIn;\n+    pblock = &pblocktemplate->block; // pointer for convenience\n \n     // Add dummy coinbase tx as first transaction\n     pblock->vtx.push_back(CTransaction());\n     pblocktemplate->vTxFees.push_back(-1); // updated at end\n     pblocktemplate->vTxSigOps.push_back(-1); // updated at end\n \n-    // Largest block you're willing to create:\n-    unsigned int nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n-    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n-    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+    LOCK2(cs_main, mempool.cs);",
    "path": "src/miner.cpp",
    "position": 64,
    "original_position": 64,
    "commit_id": "c2dd5a3c39156749e8ee24772d1fcb01404f2b6f",
    "original_commit_id": "4dc94d1036576fe988a066fdabc047350ccddda9",
    "user": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Are you sure?\n",
    "created_at": "2016-05-24T20:03:08Z",
    "updated_at": "2016-06-01T16:45:43Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r64463769",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64463769"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r64463769"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64463769/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 119,
    "original_line": 119,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64494596",
    "pull_request_review_id": null,
    "id": 64494596,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0NDk0NTk2",
    "diff_hunk": "@@ -71,231 +71,299 @@ int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParam\n     return nNewTime - nOldTime;\n }\n \n-CBlockTemplate* CreateNewBlock(const CChainParams& chainparams, const CScript& scriptPubKeyIn)\n+BlockAssembler::BlockAssembler(const CChainParams& _chainparams)\n+    : chainparams(_chainparams)\n {\n-    // Create new block\n-    std::unique_ptr<CBlockTemplate> pblocktemplate(new CBlockTemplate());\n+   // Largest block you're willing to create:\n+    nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n+    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n+    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+\n+    // Minimum block size you want to create; block will be filled with free transactions\n+    // until there are no more or the block reaches this size:\n+    nBlockMinSize = GetArg(\"-blockminsize\", DEFAULT_BLOCK_MIN_SIZE);\n+    nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);\n+}\n+\n+void BlockAssembler::resetBlock()\n+{\n+    inBlock.clear();\n+\n+    // Reserve space for coinbase tx\n+    nBlockSize = 1000;\n+    nBlockSigOps = 100;\n+\n+    // These counters do not include coinbase tx\n+    nBlockTx = 0;\n+    nFees = 0;\n+\n+    lastFewTxs = 0;\n+    blockFinished = false;\n+}\n+\n+CBlockTemplate* BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n+{\n+    resetBlock();\n+\n+    pblocktemplate.reset(new CBlockTemplate());\n+\n     if(!pblocktemplate.get())\n         return NULL;\n-    CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n-\n-    // Create coinbase tx\n-    CMutableTransaction txNew;\n-    txNew.vin.resize(1);\n-    txNew.vin[0].prevout.SetNull();\n-    txNew.vout.resize(1);\n-    txNew.vout[0].scriptPubKey = scriptPubKeyIn;\n+    pblock = &pblocktemplate->block; // pointer for convenience\n \n     // Add dummy coinbase tx as first transaction\n     pblock->vtx.push_back(CTransaction());\n     pblocktemplate->vTxFees.push_back(-1); // updated at end\n     pblocktemplate->vTxSigOps.push_back(-1); // updated at end\n \n-    // Largest block you're willing to create:\n-    unsigned int nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n-    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n-    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+    LOCK2(cs_main, mempool.cs);",
    "path": "src/miner.cpp",
    "position": 64,
    "original_position": 64,
    "commit_id": "c2dd5a3c39156749e8ee24772d1fcb01404f2b6f",
    "original_commit_id": "4dc94d1036576fe988a066fdabc047350ccddda9",
    "user": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Oh, oops, I thought the deliberate scoping had a purpose, but it looks like it does absolutely nothing.\n",
    "created_at": "2016-05-24T23:45:18Z",
    "updated_at": "2016-06-01T16:45:43Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r64494596",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64494596"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r64494596"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64494596/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 119,
    "original_line": 119,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65414446",
    "pull_request_review_id": null,
    "id": 65414446,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NDE0NDQ2",
    "diff_hunk": "@@ -71,231 +71,304 @@ int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParam\n     return nNewTime - nOldTime;\n }\n \n-CBlockTemplate* CreateNewBlock(const CChainParams& chainparams, const CScript& scriptPubKeyIn)\n+BlockAssembler::BlockAssembler(const CChainParams& _chainparams)\n+    : chainparams(_chainparams)\n {\n-    // Create new block\n-    std::unique_ptr<CBlockTemplate> pblocktemplate(new CBlockTemplate());\n+    // Largest block you're willing to create:\n+    nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n+    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n+    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+\n+    // Minimum block size you want to create; block will be filled with free transactions\n+    // until there are no more or the block reaches this size:\n+    nBlockMinSize = GetArg(\"-blockminsize\", DEFAULT_BLOCK_MIN_SIZE);\n+    nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);\n+}\n+\n+void BlockAssembler::resetBlock()\n+{",
    "path": "src/miner.cpp",
    "position": 22,
    "original_position": 22,
    "commit_id": "c2dd5a3c39156749e8ee24772d1fcb01404f2b6f",
    "original_commit_id": "c2dd5a3c39156749e8ee24772d1fcb01404f2b6f",
    "user": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This doesn't seem to reset at least pblock. What's the point of having a reset independent from the constructor?\n",
    "created_at": "2016-06-01T18:16:30Z",
    "updated_at": "2016-06-01T18:16:30Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r65414446",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65414446"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r65414446"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65414446/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 89,
    "original_line": 89,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66991998",
    "pull_request_review_id": null,
    "id": 66991998,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTkxOTk4",
    "diff_hunk": "@@ -71,231 +71,304 @@ int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParam\n     return nNewTime - nOldTime;\n }\n \n-CBlockTemplate* CreateNewBlock(const CChainParams& chainparams, const CScript& scriptPubKeyIn)\n+BlockAssembler::BlockAssembler(const CChainParams& _chainparams)\n+    : chainparams(_chainparams)\n {\n-    // Create new block\n-    std::unique_ptr<CBlockTemplate> pblocktemplate(new CBlockTemplate());\n+    // Largest block you're willing to create:\n+    nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n+    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n+    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+\n+    // Minimum block size you want to create; block will be filled with free transactions\n+    // until there are no more or the block reaches this size:\n+    nBlockMinSize = GetArg(\"-blockminsize\", DEFAULT_BLOCK_MIN_SIZE);\n+    nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);\n+}\n+\n+void BlockAssembler::resetBlock()\n+{\n+    inBlock.clear();\n+\n+    // Reserve space for coinbase tx\n+    nBlockSize = 1000;\n+    nBlockSigOps = 100;\n+\n+    // These counters do not include coinbase tx\n+    nBlockTx = 0;\n+    nFees = 0;\n+\n+    lastFewTxs = 0;\n+    blockFinished = false;\n+}\n+\n+CBlockTemplate* BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n+{\n+    resetBlock();\n+\n+    pblocktemplate.reset(new CBlockTemplate());\n+\n     if(!pblocktemplate.get())\n         return NULL;\n-    CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n-\n-    // Create coinbase tx\n-    CMutableTransaction txNew;\n-    txNew.vin.resize(1);\n-    txNew.vin[0].prevout.SetNull();\n-    txNew.vout.resize(1);\n-    txNew.vout[0].scriptPubKey = scriptPubKeyIn;\n+    pblock = &pblocktemplate->block; // pointer for convenience\n \n     // Add dummy coinbase tx as first transaction\n     pblock->vtx.push_back(CTransaction());\n     pblocktemplate->vTxFees.push_back(-1); // updated at end\n     pblocktemplate->vTxSigOps.push_back(-1); // updated at end\n \n-    // Largest block you're willing to create:\n-    unsigned int nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n-    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n-    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+    LOCK2(cs_main, mempool.cs);\n+    CBlockIndex* pindexPrev = chainActive.Tip();\n+    nHeight = pindexPrev->nHeight + 1;\n+\n+    pblock->nVersion = ComputeBlockVersion(pindexPrev, chainparams.GetConsensus());\n+    // -regtest only: allow overriding block.nVersion with\n+    // -blockversion=N to test forking scenarios\n+    if (chainparams.MineBlocksOnDemand())\n+        pblock->nVersion = GetArg(\"-blockversion\", pblock->nVersion);\n+\n+    pblock->nTime = GetAdjustedTime();\n+    const int64_t nMedianTimePast = pindexPrev->GetMedianTimePast();\n+\n+    nLockTimeCutoff = (STANDARD_LOCKTIME_VERIFY_FLAGS & LOCKTIME_MEDIAN_TIME_PAST)\n+                       ? nMedianTimePast\n+                       : pblock->GetBlockTime();\n+\n+    addPriorityTxs();\n+    addScoreTxs();\n+\n+    nLastBlockTx = nBlockTx;\n+    nLastBlockSize = nBlockSize;\n+    LogPrintf(\"CreateNewBlock(): total size %u txs: %u fees: %ld sigops %d\\n\", nBlockSize, nBlockTx, nFees, nBlockSigOps);\n+\n+    // Create coinbase transaction.\n+    CMutableTransaction coinbaseTx;\n+    coinbaseTx.vin.resize(1);\n+    coinbaseTx.vin[0].prevout.SetNull();\n+    coinbaseTx.vout.resize(1);\n+    coinbaseTx.vout[0].scriptPubKey = scriptPubKeyIn;\n+    coinbaseTx.vout[0].nValue = nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus());\n+    coinbaseTx.vin[0].scriptSig = CScript() << nHeight << OP_0;\n+    pblock->vtx[0] = coinbaseTx;\n+    pblocktemplate->vTxFees[0] = -nFees;\n+\n+    // Fill in header\n+    pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n+    UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev);",
    "path": "src/miner.cpp",
    "position": 101,
    "original_position": 101,
    "commit_id": "c2dd5a3c39156749e8ee24772d1fcb01404f2b6f",
    "original_commit_id": "c2dd5a3c39156749e8ee24772d1fcb01404f2b6f",
    "user": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I think that this is fine to leave as-is, but I suspect that the time should ideally be set by the client (e.g. if the block takes a long time to be found say 70 minutes than the client would have had to update their timestamp in their block).\n\nThis could cause a real problem at the halving if there is a sudden reduction in hashpower and mining time goes up past the two hour threshold and all mining clients using this code need to be manually kicked to get a new timestamp. Not setting it at all would cause miners trying to use it to fail always so they would have to be aware of setting it to get anything at all.\n\nIf the code is being refactored than this may be an appropriate time to drop it, or at least mark it for future deprecation as I bet someone is relying on it.\n",
    "created_at": "2016-06-14T15:19:15Z",
    "updated_at": "2016-06-14T15:19:15Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r66991998",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66991998"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r66991998"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66991998/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 156,
    "original_line": 156,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66992624",
    "pull_request_review_id": null,
    "id": 66992624,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTkyNjI0",
    "diff_hunk": "@@ -71,231 +71,304 @@ int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParam\n     return nNewTime - nOldTime;\n }\n \n-CBlockTemplate* CreateNewBlock(const CChainParams& chainparams, const CScript& scriptPubKeyIn)\n+BlockAssembler::BlockAssembler(const CChainParams& _chainparams)\n+    : chainparams(_chainparams)\n {\n-    // Create new block\n-    std::unique_ptr<CBlockTemplate> pblocktemplate(new CBlockTemplate());\n+    // Largest block you're willing to create:\n+    nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n+    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n+    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+\n+    // Minimum block size you want to create; block will be filled with free transactions\n+    // until there are no more or the block reaches this size:\n+    nBlockMinSize = GetArg(\"-blockminsize\", DEFAULT_BLOCK_MIN_SIZE);\n+    nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);\n+}\n+\n+void BlockAssembler::resetBlock()\n+{\n+    inBlock.clear();\n+\n+    // Reserve space for coinbase tx\n+    nBlockSize = 1000;\n+    nBlockSigOps = 100;\n+\n+    // These counters do not include coinbase tx\n+    nBlockTx = 0;\n+    nFees = 0;\n+\n+    lastFewTxs = 0;\n+    blockFinished = false;\n+}\n+\n+CBlockTemplate* BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n+{\n+    resetBlock();\n+\n+    pblocktemplate.reset(new CBlockTemplate());\n+\n     if(!pblocktemplate.get())\n         return NULL;\n-    CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n-\n-    // Create coinbase tx\n-    CMutableTransaction txNew;\n-    txNew.vin.resize(1);\n-    txNew.vin[0].prevout.SetNull();\n-    txNew.vout.resize(1);\n-    txNew.vout[0].scriptPubKey = scriptPubKeyIn;\n+    pblock = &pblocktemplate->block; // pointer for convenience\n \n     // Add dummy coinbase tx as first transaction\n     pblock->vtx.push_back(CTransaction());\n     pblocktemplate->vTxFees.push_back(-1); // updated at end\n     pblocktemplate->vTxSigOps.push_back(-1); // updated at end\n \n-    // Largest block you're willing to create:\n-    unsigned int nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n-    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n-    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+    LOCK2(cs_main, mempool.cs);\n+    CBlockIndex* pindexPrev = chainActive.Tip();\n+    nHeight = pindexPrev->nHeight + 1;\n+\n+    pblock->nVersion = ComputeBlockVersion(pindexPrev, chainparams.GetConsensus());\n+    // -regtest only: allow overriding block.nVersion with\n+    // -blockversion=N to test forking scenarios\n+    if (chainparams.MineBlocksOnDemand())\n+        pblock->nVersion = GetArg(\"-blockversion\", pblock->nVersion);\n+\n+    pblock->nTime = GetAdjustedTime();\n+    const int64_t nMedianTimePast = pindexPrev->GetMedianTimePast();\n+\n+    nLockTimeCutoff = (STANDARD_LOCKTIME_VERIFY_FLAGS & LOCKTIME_MEDIAN_TIME_PAST)\n+                       ? nMedianTimePast\n+                       : pblock->GetBlockTime();\n+\n+    addPriorityTxs();\n+    addScoreTxs();\n+\n+    nLastBlockTx = nBlockTx;\n+    nLastBlockSize = nBlockSize;\n+    LogPrintf(\"CreateNewBlock(): total size %u txs: %u fees: %ld sigops %d\\n\", nBlockSize, nBlockTx, nFees, nBlockSigOps);\n+\n+    // Create coinbase transaction.\n+    CMutableTransaction coinbaseTx;\n+    coinbaseTx.vin.resize(1);\n+    coinbaseTx.vin[0].prevout.SetNull();\n+    coinbaseTx.vout.resize(1);\n+    coinbaseTx.vout[0].scriptPubKey = scriptPubKeyIn;\n+    coinbaseTx.vout[0].nValue = nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus());\n+    coinbaseTx.vin[0].scriptSig = CScript() << nHeight << OP_0;\n+    pblock->vtx[0] = coinbaseTx;\n+    pblocktemplate->vTxFees[0] = -nFees;\n+\n+    // Fill in header\n+    pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n+    UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev);",
    "path": "src/miner.cpp",
    "position": 101,
    "original_position": 101,
    "commit_id": "c2dd5a3c39156749e8ee24772d1fcb01404f2b6f",
    "original_commit_id": "c2dd5a3c39156749e8ee24772d1fcb01404f2b6f",
    "user": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "(of course this is not a correctness thing, just a potential network edge case if users improperly program against this -- I'm well aware this has been the way this code worked for a long time)\n",
    "created_at": "2016-06-14T15:22:09Z",
    "updated_at": "2016-06-14T15:22:09Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r66992624",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66992624"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r66992624"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66992624/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 156,
    "original_line": 156,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66993642",
    "pull_request_review_id": null,
    "id": 66993642,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTkzNjQy",
    "diff_hunk": "@@ -71,231 +71,304 @@ int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParam\n     return nNewTime - nOldTime;\n }\n \n-CBlockTemplate* CreateNewBlock(const CChainParams& chainparams, const CScript& scriptPubKeyIn)\n+BlockAssembler::BlockAssembler(const CChainParams& _chainparams)\n+    : chainparams(_chainparams)\n {\n-    // Create new block\n-    std::unique_ptr<CBlockTemplate> pblocktemplate(new CBlockTemplate());\n+    // Largest block you're willing to create:\n+    nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n+    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n+    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+\n+    // Minimum block size you want to create; block will be filled with free transactions\n+    // until there are no more or the block reaches this size:\n+    nBlockMinSize = GetArg(\"-blockminsize\", DEFAULT_BLOCK_MIN_SIZE);\n+    nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);\n+}\n+\n+void BlockAssembler::resetBlock()\n+{\n+    inBlock.clear();\n+\n+    // Reserve space for coinbase tx\n+    nBlockSize = 1000;\n+    nBlockSigOps = 100;\n+\n+    // These counters do not include coinbase tx\n+    nBlockTx = 0;\n+    nFees = 0;\n+\n+    lastFewTxs = 0;\n+    blockFinished = false;\n+}\n+\n+CBlockTemplate* BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n+{\n+    resetBlock();\n+\n+    pblocktemplate.reset(new CBlockTemplate());\n+\n     if(!pblocktemplate.get())\n         return NULL;\n-    CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n-\n-    // Create coinbase tx\n-    CMutableTransaction txNew;\n-    txNew.vin.resize(1);\n-    txNew.vin[0].prevout.SetNull();\n-    txNew.vout.resize(1);\n-    txNew.vout[0].scriptPubKey = scriptPubKeyIn;\n+    pblock = &pblocktemplate->block; // pointer for convenience\n \n     // Add dummy coinbase tx as first transaction\n     pblock->vtx.push_back(CTransaction());\n     pblocktemplate->vTxFees.push_back(-1); // updated at end\n     pblocktemplate->vTxSigOps.push_back(-1); // updated at end\n \n-    // Largest block you're willing to create:\n-    unsigned int nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n-    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n-    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+    LOCK2(cs_main, mempool.cs);\n+    CBlockIndex* pindexPrev = chainActive.Tip();\n+    nHeight = pindexPrev->nHeight + 1;\n+\n+    pblock->nVersion = ComputeBlockVersion(pindexPrev, chainparams.GetConsensus());\n+    // -regtest only: allow overriding block.nVersion with\n+    // -blockversion=N to test forking scenarios\n+    if (chainparams.MineBlocksOnDemand())\n+        pblock->nVersion = GetArg(\"-blockversion\", pblock->nVersion);\n+\n+    pblock->nTime = GetAdjustedTime();\n+    const int64_t nMedianTimePast = pindexPrev->GetMedianTimePast();\n+\n+    nLockTimeCutoff = (STANDARD_LOCKTIME_VERIFY_FLAGS & LOCKTIME_MEDIAN_TIME_PAST)\n+                       ? nMedianTimePast\n+                       : pblock->GetBlockTime();\n+\n+    addPriorityTxs();\n+    addScoreTxs();\n+\n+    nLastBlockTx = nBlockTx;\n+    nLastBlockSize = nBlockSize;\n+    LogPrintf(\"CreateNewBlock(): total size %u txs: %u fees: %ld sigops %d\\n\", nBlockSize, nBlockTx, nFees, nBlockSigOps);\n+\n+    // Create coinbase transaction.\n+    CMutableTransaction coinbaseTx;\n+    coinbaseTx.vin.resize(1);\n+    coinbaseTx.vin[0].prevout.SetNull();\n+    coinbaseTx.vout.resize(1);\n+    coinbaseTx.vout[0].scriptPubKey = scriptPubKeyIn;\n+    coinbaseTx.vout[0].nValue = nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus());\n+    coinbaseTx.vin[0].scriptSig = CScript() << nHeight << OP_0;\n+    pblock->vtx[0] = coinbaseTx;\n+    pblocktemplate->vTxFees[0] = -nFees;\n+\n+    // Fill in header\n+    pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n+    UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev);",
    "path": "src/miner.cpp",
    "position": 101,
    "original_position": 101,
    "commit_id": "c2dd5a3c39156749e8ee24772d1fcb01404f2b6f",
    "original_commit_id": "c2dd5a3c39156749e8ee24772d1fcb01404f2b6f",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "There is never a requirement to update the time: the constraints are:\n- block.nTime >= median(block.prev^(n).nTime, n=1..11) [which never changes if no block is found to work on top of]\n- block.nTime <= realtime + 120 minutes [which never goes from valid to invalid as time passes]\n",
    "created_at": "2016-06-14T15:27:02Z",
    "updated_at": "2016-06-14T15:27:03Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r66993642",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66993642"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r66993642"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66993642/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 156,
    "original_line": 156,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66993861",
    "pull_request_review_id": null,
    "id": 66993861,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTkzODYx",
    "diff_hunk": "@@ -71,231 +71,304 @@ int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParam\n     return nNewTime - nOldTime;\n }\n \n-CBlockTemplate* CreateNewBlock(const CChainParams& chainparams, const CScript& scriptPubKeyIn)\n+BlockAssembler::BlockAssembler(const CChainParams& _chainparams)\n+    : chainparams(_chainparams)\n {\n-    // Create new block\n-    std::unique_ptr<CBlockTemplate> pblocktemplate(new CBlockTemplate());\n+    // Largest block you're willing to create:\n+    nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n+    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n+    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+\n+    // Minimum block size you want to create; block will be filled with free transactions\n+    // until there are no more or the block reaches this size:\n+    nBlockMinSize = GetArg(\"-blockminsize\", DEFAULT_BLOCK_MIN_SIZE);\n+    nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);\n+}\n+\n+void BlockAssembler::resetBlock()\n+{\n+    inBlock.clear();\n+\n+    // Reserve space for coinbase tx\n+    nBlockSize = 1000;\n+    nBlockSigOps = 100;\n+\n+    // These counters do not include coinbase tx\n+    nBlockTx = 0;\n+    nFees = 0;\n+\n+    lastFewTxs = 0;\n+    blockFinished = false;\n+}\n+\n+CBlockTemplate* BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n+{\n+    resetBlock();\n+\n+    pblocktemplate.reset(new CBlockTemplate());\n+\n     if(!pblocktemplate.get())\n         return NULL;\n-    CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n-\n-    // Create coinbase tx\n-    CMutableTransaction txNew;\n-    txNew.vin.resize(1);\n-    txNew.vin[0].prevout.SetNull();\n-    txNew.vout.resize(1);\n-    txNew.vout[0].scriptPubKey = scriptPubKeyIn;\n+    pblock = &pblocktemplate->block; // pointer for convenience\n \n     // Add dummy coinbase tx as first transaction\n     pblock->vtx.push_back(CTransaction());\n     pblocktemplate->vTxFees.push_back(-1); // updated at end\n     pblocktemplate->vTxSigOps.push_back(-1); // updated at end\n \n-    // Largest block you're willing to create:\n-    unsigned int nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n-    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n-    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+    LOCK2(cs_main, mempool.cs);\n+    CBlockIndex* pindexPrev = chainActive.Tip();\n+    nHeight = pindexPrev->nHeight + 1;\n+\n+    pblock->nVersion = ComputeBlockVersion(pindexPrev, chainparams.GetConsensus());\n+    // -regtest only: allow overriding block.nVersion with\n+    // -blockversion=N to test forking scenarios\n+    if (chainparams.MineBlocksOnDemand())\n+        pblock->nVersion = GetArg(\"-blockversion\", pblock->nVersion);\n+\n+    pblock->nTime = GetAdjustedTime();\n+    const int64_t nMedianTimePast = pindexPrev->GetMedianTimePast();\n+\n+    nLockTimeCutoff = (STANDARD_LOCKTIME_VERIFY_FLAGS & LOCKTIME_MEDIAN_TIME_PAST)\n+                       ? nMedianTimePast\n+                       : pblock->GetBlockTime();\n+\n+    addPriorityTxs();\n+    addScoreTxs();\n+\n+    nLastBlockTx = nBlockTx;\n+    nLastBlockSize = nBlockSize;\n+    LogPrintf(\"CreateNewBlock(): total size %u txs: %u fees: %ld sigops %d\\n\", nBlockSize, nBlockTx, nFees, nBlockSigOps);\n+\n+    // Create coinbase transaction.\n+    CMutableTransaction coinbaseTx;\n+    coinbaseTx.vin.resize(1);\n+    coinbaseTx.vin[0].prevout.SetNull();\n+    coinbaseTx.vout.resize(1);\n+    coinbaseTx.vout[0].scriptPubKey = scriptPubKeyIn;\n+    coinbaseTx.vout[0].nValue = nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus());\n+    coinbaseTx.vin[0].scriptSig = CScript() << nHeight << OP_0;\n+    pblock->vtx[0] = coinbaseTx;\n+    pblocktemplate->vTxFees[0] = -nFees;\n+\n+    // Fill in header\n+    pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n+    UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev);",
    "path": "src/miner.cpp",
    "position": 101,
    "original_position": 101,
    "commit_id": "c2dd5a3c39156749e8ee24772d1fcb01404f2b6f",
    "original_commit_id": "c2dd5a3c39156749e8ee24772d1fcb01404f2b6f",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In any case, that's a mining protocol suggestion (ntime rolling is used in many places anyway), not something that affects the internal mining code.\n",
    "created_at": "2016-06-14T15:28:09Z",
    "updated_at": "2016-06-14T15:28:09Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r66993861",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66993861"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r66993861"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66993861/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 156,
    "original_line": 156,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66995099",
    "pull_request_review_id": null,
    "id": 66995099,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk1MDk5",
    "diff_hunk": "@@ -71,231 +71,304 @@ int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParam\n     return nNewTime - nOldTime;\n }\n \n-CBlockTemplate* CreateNewBlock(const CChainParams& chainparams, const CScript& scriptPubKeyIn)\n+BlockAssembler::BlockAssembler(const CChainParams& _chainparams)\n+    : chainparams(_chainparams)\n {\n-    // Create new block\n-    std::unique_ptr<CBlockTemplate> pblocktemplate(new CBlockTemplate());\n+    // Largest block you're willing to create:\n+    nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n+    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n+    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+\n+    // Minimum block size you want to create; block will be filled with free transactions\n+    // until there are no more or the block reaches this size:\n+    nBlockMinSize = GetArg(\"-blockminsize\", DEFAULT_BLOCK_MIN_SIZE);\n+    nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);\n+}\n+\n+void BlockAssembler::resetBlock()\n+{\n+    inBlock.clear();\n+\n+    // Reserve space for coinbase tx\n+    nBlockSize = 1000;\n+    nBlockSigOps = 100;\n+\n+    // These counters do not include coinbase tx\n+    nBlockTx = 0;\n+    nFees = 0;\n+\n+    lastFewTxs = 0;\n+    blockFinished = false;\n+}\n+\n+CBlockTemplate* BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n+{\n+    resetBlock();\n+\n+    pblocktemplate.reset(new CBlockTemplate());\n+\n     if(!pblocktemplate.get())\n         return NULL;\n-    CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n-\n-    // Create coinbase tx\n-    CMutableTransaction txNew;\n-    txNew.vin.resize(1);\n-    txNew.vin[0].prevout.SetNull();\n-    txNew.vout.resize(1);\n-    txNew.vout[0].scriptPubKey = scriptPubKeyIn;\n+    pblock = &pblocktemplate->block; // pointer for convenience\n \n     // Add dummy coinbase tx as first transaction\n     pblock->vtx.push_back(CTransaction());\n     pblocktemplate->vTxFees.push_back(-1); // updated at end\n     pblocktemplate->vTxSigOps.push_back(-1); // updated at end\n \n-    // Largest block you're willing to create:\n-    unsigned int nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n-    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n-    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+    LOCK2(cs_main, mempool.cs);\n+    CBlockIndex* pindexPrev = chainActive.Tip();\n+    nHeight = pindexPrev->nHeight + 1;\n+\n+    pblock->nVersion = ComputeBlockVersion(pindexPrev, chainparams.GetConsensus());\n+    // -regtest only: allow overriding block.nVersion with\n+    // -blockversion=N to test forking scenarios\n+    if (chainparams.MineBlocksOnDemand())\n+        pblock->nVersion = GetArg(\"-blockversion\", pblock->nVersion);\n+\n+    pblock->nTime = GetAdjustedTime();\n+    const int64_t nMedianTimePast = pindexPrev->GetMedianTimePast();\n+\n+    nLockTimeCutoff = (STANDARD_LOCKTIME_VERIFY_FLAGS & LOCKTIME_MEDIAN_TIME_PAST)\n+                       ? nMedianTimePast\n+                       : pblock->GetBlockTime();\n+\n+    addPriorityTxs();\n+    addScoreTxs();\n+\n+    nLastBlockTx = nBlockTx;\n+    nLastBlockSize = nBlockSize;\n+    LogPrintf(\"CreateNewBlock(): total size %u txs: %u fees: %ld sigops %d\\n\", nBlockSize, nBlockTx, nFees, nBlockSigOps);\n+\n+    // Create coinbase transaction.\n+    CMutableTransaction coinbaseTx;\n+    coinbaseTx.vin.resize(1);\n+    coinbaseTx.vin[0].prevout.SetNull();\n+    coinbaseTx.vout.resize(1);\n+    coinbaseTx.vout[0].scriptPubKey = scriptPubKeyIn;\n+    coinbaseTx.vout[0].nValue = nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus());\n+    coinbaseTx.vin[0].scriptSig = CScript() << nHeight << OP_0;\n+    pblock->vtx[0] = coinbaseTx;\n+    pblocktemplate->vTxFees[0] = -nFees;\n+\n+    // Fill in header\n+    pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n+    UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev);",
    "path": "src/miner.cpp",
    "position": 101,
    "original_position": 101,
    "commit_id": "c2dd5a3c39156749e8ee24772d1fcb01404f2b6f",
    "original_commit_id": "c2dd5a3c39156749e8ee24772d1fcb01404f2b6f",
    "user": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "\ud83d\udc4d\n\nhad misread the constraints to have blocks as more time dependent.\n",
    "created_at": "2016-06-14T15:33:34Z",
    "updated_at": "2016-06-14T15:33:35Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r66995099",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66995099"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r66995099"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66995099/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 156,
    "original_line": 156,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66997894",
    "pull_request_review_id": null,
    "id": 66997894,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk3ODk0",
    "diff_hunk": "@@ -71,231 +71,304 @@ int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParam\n     return nNewTime - nOldTime;\n }\n \n-CBlockTemplate* CreateNewBlock(const CChainParams& chainparams, const CScript& scriptPubKeyIn)\n+BlockAssembler::BlockAssembler(const CChainParams& _chainparams)\n+    : chainparams(_chainparams)\n {\n-    // Create new block\n-    std::unique_ptr<CBlockTemplate> pblocktemplate(new CBlockTemplate());\n+    // Largest block you're willing to create:\n+    nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n+    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n+    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+\n+    // Minimum block size you want to create; block will be filled with free transactions\n+    // until there are no more or the block reaches this size:\n+    nBlockMinSize = GetArg(\"-blockminsize\", DEFAULT_BLOCK_MIN_SIZE);\n+    nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);\n+}\n+\n+void BlockAssembler::resetBlock()\n+{\n+    inBlock.clear();\n+\n+    // Reserve space for coinbase tx\n+    nBlockSize = 1000;\n+    nBlockSigOps = 100;\n+\n+    // These counters do not include coinbase tx\n+    nBlockTx = 0;\n+    nFees = 0;\n+\n+    lastFewTxs = 0;\n+    blockFinished = false;\n+}\n+\n+CBlockTemplate* BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n+{\n+    resetBlock();\n+\n+    pblocktemplate.reset(new CBlockTemplate());\n+\n     if(!pblocktemplate.get())\n         return NULL;\n-    CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n-\n-    // Create coinbase tx\n-    CMutableTransaction txNew;\n-    txNew.vin.resize(1);\n-    txNew.vin[0].prevout.SetNull();\n-    txNew.vout.resize(1);\n-    txNew.vout[0].scriptPubKey = scriptPubKeyIn;\n+    pblock = &pblocktemplate->block; // pointer for convenience\n \n     // Add dummy coinbase tx as first transaction\n     pblock->vtx.push_back(CTransaction());\n     pblocktemplate->vTxFees.push_back(-1); // updated at end\n     pblocktemplate->vTxSigOps.push_back(-1); // updated at end\n \n-    // Largest block you're willing to create:\n-    unsigned int nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n-    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n-    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+    LOCK2(cs_main, mempool.cs);\n+    CBlockIndex* pindexPrev = chainActive.Tip();\n+    nHeight = pindexPrev->nHeight + 1;\n+\n+    pblock->nVersion = ComputeBlockVersion(pindexPrev, chainparams.GetConsensus());\n+    // -regtest only: allow overriding block.nVersion with\n+    // -blockversion=N to test forking scenarios\n+    if (chainparams.MineBlocksOnDemand())\n+        pblock->nVersion = GetArg(\"-blockversion\", pblock->nVersion);\n+\n+    pblock->nTime = GetAdjustedTime();\n+    const int64_t nMedianTimePast = pindexPrev->GetMedianTimePast();\n+\n+    nLockTimeCutoff = (STANDARD_LOCKTIME_VERIFY_FLAGS & LOCKTIME_MEDIAN_TIME_PAST)\n+                       ? nMedianTimePast\n+                       : pblock->GetBlockTime();\n+\n+    addPriorityTxs();\n+    addScoreTxs();\n+\n+    nLastBlockTx = nBlockTx;\n+    nLastBlockSize = nBlockSize;\n+    LogPrintf(\"CreateNewBlock(): total size %u txs: %u fees: %ld sigops %d\\n\", nBlockSize, nBlockTx, nFees, nBlockSigOps);\n+\n+    // Create coinbase transaction.\n+    CMutableTransaction coinbaseTx;\n+    coinbaseTx.vin.resize(1);\n+    coinbaseTx.vin[0].prevout.SetNull();\n+    coinbaseTx.vout.resize(1);\n+    coinbaseTx.vout[0].scriptPubKey = scriptPubKeyIn;\n+    coinbaseTx.vout[0].nValue = nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus());\n+    coinbaseTx.vin[0].scriptSig = CScript() << nHeight << OP_0;\n+    pblock->vtx[0] = coinbaseTx;\n+    pblocktemplate->vTxFees[0] = -nFees;\n+\n+    // Fill in header\n+    pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n+    UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev);\n+    pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock, chainparams.GetConsensus());\n+    pblock->nNonce         = 0;\n+    pblocktemplate->vTxSigOps[0] = GetLegacySigOpCount(pblock->vtx[0]);\n+\n+    CValidationState state;\n+    if (!TestBlockValidity(state, chainparams, *pblock, pindexPrev, false, false)) {\n+        throw std::runtime_error(strprintf(\"%s: TestBlockValidity failed: %s\", __func__, FormatStateMessage(state)));\n+    }\n \n-    // How much of the block should be dedicated to high-priority transactions,\n-    // included regardless of the fees they pay\n-    unsigned int nBlockPrioritySize = GetArg(\"-blockprioritysize\", DEFAULT_BLOCK_PRIORITY_SIZE);\n-    nBlockPrioritySize = std::min(nBlockMaxSize, nBlockPrioritySize);\n+    return pblocktemplate.release();\n+}\n \n-    // Minimum block size you want to create; block will be filled with free transactions\n-    // until there are no more or the block reaches this size:\n-    unsigned int nBlockMinSize = GetArg(\"-blockminsize\", DEFAULT_BLOCK_MIN_SIZE);\n-    nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);\n+bool BlockAssembler::isStillDependent(CTxMemPool::txiter iter)\n+{\n+    BOOST_FOREACH(CTxMemPool::txiter parent, mempool.GetMemPoolParents(iter))\n+    {\n+        if (!inBlock.count(parent)) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n \n-    // Collect memory pool transactions into the block\n-    CTxMemPool::setEntries inBlock;\n-    CTxMemPool::setEntries waitSet;\n \n-    // This vector will be sorted into a priority queue:\n-    vector<TxCoinAgePriority> vecPriority;\n-    TxCoinAgePriorityCompare pricomparer;\n-    std::map<CTxMemPool::txiter, double, CTxMemPool::CompareIteratorByHash> waitPriMap;\n-    typedef std::map<CTxMemPool::txiter, double, CTxMemPool::CompareIteratorByHash>::iterator waitPriIter;\n-    double actualPriority = -1;\n \n-    std::priority_queue<CTxMemPool::txiter, std::vector<CTxMemPool::txiter>, ScoreCompare> clearedTxs;\n+bool BlockAssembler::TestForBlock(CTxMemPool::txiter iter)\n+{\n+    if (nBlockSize + iter->GetTxSize() >= nBlockMaxSize) {\n+        // If the block is so close to full that no more txs will fit\n+        // or if we've tried more than 50 times to fill remaining space\n+        // then flag that the block is finished\n+        if (nBlockSize >  nBlockMaxSize - 100 || lastFewTxs > 50) {\n+             blockFinished = true;\n+             return false;\n+        }\n+        // Once we're within 1000 bytes of a full block, only look at 50 more txs\n+        // to try to fill the remaining space.\n+        if (nBlockSize > nBlockMaxSize - 1000) {\n+            lastFewTxs++;\n+        }\n+        return false;\n+    }\n+\n+    if (nBlockSigOps + iter->GetSigOpCount() >= MAX_BLOCK_SIGOPS) {\n+        // If the block has room for no more sig ops then\n+        // flag that the block is finished\n+        if (nBlockSigOps > MAX_BLOCK_SIGOPS - 2) {\n+            blockFinished = true;\n+            return false;\n+        }\n+        // Otherwise attempt to find another tx with fewer sigops\n+        // to put in the block.\n+        return false;\n+    }\n+\n+    // Must check that lock times are still valid\n+    // This can be removed once MTP is always enforced\n+    // as long as reorgs keep the mempool consistent.\n+    if (!IsFinalTx(iter->GetTx(), nHeight, nLockTimeCutoff))\n+        return false;\n+\n+    return true;\n+}\n+\n+void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\n+{\n+    pblock->vtx.push_back(iter->GetTx());\n+    pblocktemplate->vTxFees.push_back(iter->GetFee());\n+    pblocktemplate->vTxSigOps.push_back(iter->GetSigOpCount());\n+    nBlockSize += iter->GetTxSize();\n+    ++nBlockTx;\n+    nBlockSigOps += iter->GetSigOpCount();\n+    nFees += iter->GetFee();\n+    inBlock.insert(iter);\n+\n     bool fPrintPriority = GetBoolArg(\"-printpriority\", DEFAULT_PRINTPRIORITY);\n-    uint64_t nBlockSize = 1000;\n-    uint64_t nBlockTx = 0;\n-    unsigned int nBlockSigOps = 100;\n-    int lastFewTxs = 0;\n-    CAmount nFees = 0;\n+    if (fPrintPriority) {\n+        double dPriority = iter->GetPriority(nHeight);\n+        CAmount dummy;\n+        mempool.ApplyDeltas(iter->GetTx().GetHash(), dPriority, dummy);\n+        LogPrintf(\"priority %.1f fee %s txid %s\\n\",\n+                  dPriority,\n+                  CFeeRate(iter->GetModifiedFee(), iter->GetTxSize()).ToString(),\n+                  iter->GetTx().GetHash().ToString());\n+    }\n+}\n \n+void BlockAssembler::addScoreTxs()\n+{\n+    std::priority_queue<CTxMemPool::txiter, std::vector<CTxMemPool::txiter>, ScoreCompare> clearedTxs;\n+    CTxMemPool::setEntries waitSet;\n+    CTxMemPool::indexed_transaction_set::index<mining_score>::type::iterator mi = mempool.mapTx.get<mining_score>().begin();\n+    CTxMemPool::txiter iter;\n+    while (!blockFinished && (mi != mempool.mapTx.get<mining_score>().end() || !clearedTxs.empty()))\n     {\n-        LOCK2(cs_main, mempool.cs);\n-        CBlockIndex* pindexPrev = chainActive.Tip();\n-        const int nHeight = pindexPrev->nHeight + 1;\n-        pblock->nTime = GetAdjustedTime();\n-        const int64_t nMedianTimePast = pindexPrev->GetMedianTimePast();\n-\n-        pblock->nVersion = ComputeBlockVersion(pindexPrev, chainparams.GetConsensus());\n-        // -regtest only: allow overriding block.nVersion with\n-        // -blockversion=N to test forking scenarios\n-        if (chainparams.MineBlocksOnDemand())\n-            pblock->nVersion = GetArg(\"-blockversion\", pblock->nVersion);\n-\n-        int64_t nLockTimeCutoff = (STANDARD_LOCKTIME_VERIFY_FLAGS & LOCKTIME_MEDIAN_TIME_PAST)\n-                                ? nMedianTimePast\n-                                : pblock->GetBlockTime();\n-\n-        bool fPriorityBlock = nBlockPrioritySize > 0;\n-        if (fPriorityBlock) {\n-            vecPriority.reserve(mempool.mapTx.size());\n-            for (CTxMemPool::indexed_transaction_set::iterator mi = mempool.mapTx.begin();\n-                 mi != mempool.mapTx.end(); ++mi)\n-            {\n-                double dPriority = mi->GetPriority(nHeight);\n-                CAmount dummy;\n-                mempool.ApplyDeltas(mi->GetTx().GetHash(), dPriority, dummy);\n-                vecPriority.push_back(TxCoinAgePriority(dPriority, mi));\n-            }\n-            std::make_heap(vecPriority.begin(), vecPriority.end(), pricomparer);\n+        // If no txs that were previously postponed are available to try\n+        // again, then try the next highest score tx\n+        if (clearedTxs.empty()) {\n+            iter = mempool.mapTx.project<0>(mi);\n+            mi++;\n+        }\n+        // If a previously postponed tx is available to try again, then it\n+        // has higher score than all untried so far txs\n+        else {\n+            iter = clearedTxs.top();\n+            clearedTxs.pop();\n         }\n \n-        CTxMemPool::indexed_transaction_set::index<mining_score>::type::iterator mi = mempool.mapTx.get<mining_score>().begin();\n-        CTxMemPool::txiter iter;\n-\n-        while (mi != mempool.mapTx.get<mining_score>().end() || !clearedTxs.empty())\n-        {\n-            bool priorityTx = false;\n-            if (fPriorityBlock && !vecPriority.empty()) { // add a tx from priority queue to fill the blockprioritysize\n-                priorityTx = true;\n-                iter = vecPriority.front().second;\n-                actualPriority = vecPriority.front().first;\n-                std::pop_heap(vecPriority.begin(), vecPriority.end(), pricomparer);\n-                vecPriority.pop_back();\n-            }\n-            else if (clearedTxs.empty()) { // add tx with next highest score\n-                iter = mempool.mapTx.project<0>(mi);\n-                mi++;\n-            }\n-            else {  // try to add a previously postponed child tx\n-                iter = clearedTxs.top();\n-                clearedTxs.pop();\n-            }\n+        // If tx already in block, skip  (added by addPriorityTxs)\n+        if (inBlock.count(iter)) {\n+            continue;\n+        }\n+\n+        // If tx is dependent on other mempool txs which haven't yet been included\n+        // then put it in the waitSet\n+        if (isStillDependent(iter)) {\n+            waitSet.insert(iter);\n+            continue;\n+        }\n \n-            if (inBlock.count(iter))\n-                continue; // could have been added to the priorityBlock\n+        // If the fee rate is below the min fee rate for mining, then we're done\n+        // adding txs based on score (fee rate)\n+        if (iter->GetModifiedFee() < ::minRelayTxFee.GetFee(iter->GetTxSize()) && nBlockSize >= nBlockMinSize) {\n+            return;\n+        }\n \n-            const CTransaction& tx = iter->GetTx();\n+        // If this tx fits in the block add it, otherwise keep looping\n+        if (TestForBlock(iter)) {\n+            AddToBlock(iter);\n \n-            bool fOrphan = false;\n-            BOOST_FOREACH(CTxMemPool::txiter parent, mempool.GetMemPoolParents(iter))\n+            // This tx was successfully added, so\n+            // add transactions that depend on this one to the priority queue to try again\n+            BOOST_FOREACH(CTxMemPool::txiter child, mempool.GetMemPoolChildren(iter))\n             {\n-                if (!inBlock.count(parent)) {\n-                    fOrphan = true;\n-                    break;\n+                if (waitSet.count(child)) {\n+                    clearedTxs.push(child);\n+                    waitSet.erase(child);\n                 }\n             }\n-            if (fOrphan) {\n-                if (priorityTx)\n-                    waitPriMap.insert(std::make_pair(iter,actualPriority));\n-                else\n-                    waitSet.insert(iter);\n-                continue;\n-            }\n+        }\n+    }\n+}\n \n-            unsigned int nTxSize = iter->GetTxSize();\n-            if (fPriorityBlock &&\n-                (nBlockSize + nTxSize >= nBlockPrioritySize || !AllowFree(actualPriority))) {\n-                fPriorityBlock = false;\n-                waitPriMap.clear();\n-            }\n-            if (!priorityTx &&\n-                (iter->GetModifiedFee() < ::minRelayTxFee.GetFee(nTxSize) && nBlockSize >= nBlockMinSize)) {\n-                break;\n-            }\n-            if (nBlockSize + nTxSize >= nBlockMaxSize) {\n-                if (nBlockSize >  nBlockMaxSize - 100 || lastFewTxs > 50) {\n-                    break;\n-                }\n-                // Once we're within 1000 bytes of a full block, only look at 50 more txs\n-                // to try to fill the remaining space.\n-                if (nBlockSize > nBlockMaxSize - 1000) {\n-                    lastFewTxs++;\n-                }\n-                continue;\n-            }\n+void BlockAssembler::addPriorityTxs()\n+{\n+    // How much of the block should be dedicated to high-priority transactions,\n+    // included regardless of the fees they pay\n+    unsigned int nBlockPrioritySize = GetArg(\"-blockprioritysize\", DEFAULT_BLOCK_PRIORITY_SIZE);\n+    nBlockPrioritySize = std::min(nBlockMaxSize, nBlockPrioritySize);\n \n-            if (!IsFinalTx(tx, nHeight, nLockTimeCutoff))\n-                continue;\n+    if (nBlockPrioritySize == 0) {\n+        return;\n+    }\n \n-            unsigned int nTxSigOps = iter->GetSigOpCount();\n-            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS) {\n-                if (nBlockSigOps > MAX_BLOCK_SIGOPS - 2) {\n-                    break;\n-                }\n-                continue;\n-            }\n+    // This vector will be sorted into a priority queue:\n+    vector<TxCoinAgePriority> vecPriority;\n+    TxCoinAgePriorityCompare pricomparer;\n+    std::map<CTxMemPool::txiter, double, CTxMemPool::CompareIteratorByHash> waitPriMap;\n+    typedef std::map<CTxMemPool::txiter, double, CTxMemPool::CompareIteratorByHash>::iterator waitPriIter;\n+    double actualPriority = -1;\n \n-            CAmount nTxFees = iter->GetFee();\n-            // Added\n-            pblock->vtx.push_back(tx);\n-            pblocktemplate->vTxFees.push_back(nTxFees);\n-            pblocktemplate->vTxSigOps.push_back(nTxSigOps);\n-            nBlockSize += nTxSize;\n-            ++nBlockTx;\n-            nBlockSigOps += nTxSigOps;\n-            nFees += nTxFees;\n-\n-            if (fPrintPriority)\n-            {\n-                double dPriority = iter->GetPriority(nHeight);\n-                CAmount dummy;\n-                mempool.ApplyDeltas(tx.GetHash(), dPriority, dummy);\n-                LogPrintf(\"priority %.1f fee %s txid %s\\n\",\n-                          dPriority , CFeeRate(iter->GetModifiedFee(), nTxSize).ToString(), tx.GetHash().ToString());\n-            }\n+    vecPriority.reserve(mempool.mapTx.size());\n+    for (CTxMemPool::indexed_transaction_set::iterator mi = mempool.mapTx.begin();\n+         mi != mempool.mapTx.end(); ++mi)\n+    {\n+        double dPriority = mi->GetPriority(nHeight);\n+        CAmount dummy;\n+        mempool.ApplyDeltas(mi->GetTx().GetHash(), dPriority, dummy);\n+        vecPriority.push_back(TxCoinAgePriority(dPriority, mi));\n+    }\n+    std::make_heap(vecPriority.begin(), vecPriority.end(), pricomparer);",
    "path": "src/miner.cpp",
    "position": 407,
    "original_position": 407,
    "commit_id": "c2dd5a3c39156749e8ee24772d1fcb01404f2b6f",
    "original_commit_id": "c2dd5a3c39156749e8ee24772d1fcb01404f2b6f",
    "user": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "nit: Unless there is a reason I am missing, it would be good to refactor this to use std::priority_queue like addScoreTxs for consistency. (std::priority_queue is also safer to use for preserving heap invariants)\n",
    "created_at": "2016-06-14T15:45:53Z",
    "updated_at": "2016-06-14T15:46:31Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r66997894",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66997894"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r66997894"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66997894/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 327,
    "original_line": 327,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67006098",
    "pull_request_review_id": null,
    "id": 67006098,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MDA2MDk4",
    "diff_hunk": "@@ -71,231 +71,304 @@ int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParam\n     return nNewTime - nOldTime;\n }\n \n-CBlockTemplate* CreateNewBlock(const CChainParams& chainparams, const CScript& scriptPubKeyIn)\n+BlockAssembler::BlockAssembler(const CChainParams& _chainparams)\n+    : chainparams(_chainparams)\n {\n-    // Create new block\n-    std::unique_ptr<CBlockTemplate> pblocktemplate(new CBlockTemplate());\n+    // Largest block you're willing to create:\n+    nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n+    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n+    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+\n+    // Minimum block size you want to create; block will be filled with free transactions\n+    // until there are no more or the block reaches this size:\n+    nBlockMinSize = GetArg(\"-blockminsize\", DEFAULT_BLOCK_MIN_SIZE);\n+    nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);\n+}\n+\n+void BlockAssembler::resetBlock()\n+{\n+    inBlock.clear();\n+\n+    // Reserve space for coinbase tx\n+    nBlockSize = 1000;\n+    nBlockSigOps = 100;\n+\n+    // These counters do not include coinbase tx\n+    nBlockTx = 0;\n+    nFees = 0;\n+\n+    lastFewTxs = 0;\n+    blockFinished = false;\n+}\n+\n+CBlockTemplate* BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n+{\n+    resetBlock();\n+\n+    pblocktemplate.reset(new CBlockTemplate());\n+\n     if(!pblocktemplate.get())\n         return NULL;\n-    CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n-\n-    // Create coinbase tx\n-    CMutableTransaction txNew;\n-    txNew.vin.resize(1);\n-    txNew.vin[0].prevout.SetNull();\n-    txNew.vout.resize(1);\n-    txNew.vout[0].scriptPubKey = scriptPubKeyIn;\n+    pblock = &pblocktemplate->block; // pointer for convenience\n \n     // Add dummy coinbase tx as first transaction\n     pblock->vtx.push_back(CTransaction());\n     pblocktemplate->vTxFees.push_back(-1); // updated at end\n     pblocktemplate->vTxSigOps.push_back(-1); // updated at end\n \n-    // Largest block you're willing to create:\n-    unsigned int nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n-    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n-    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+    LOCK2(cs_main, mempool.cs);\n+    CBlockIndex* pindexPrev = chainActive.Tip();\n+    nHeight = pindexPrev->nHeight + 1;\n+\n+    pblock->nVersion = ComputeBlockVersion(pindexPrev, chainparams.GetConsensus());\n+    // -regtest only: allow overriding block.nVersion with\n+    // -blockversion=N to test forking scenarios\n+    if (chainparams.MineBlocksOnDemand())\n+        pblock->nVersion = GetArg(\"-blockversion\", pblock->nVersion);\n+\n+    pblock->nTime = GetAdjustedTime();\n+    const int64_t nMedianTimePast = pindexPrev->GetMedianTimePast();\n+\n+    nLockTimeCutoff = (STANDARD_LOCKTIME_VERIFY_FLAGS & LOCKTIME_MEDIAN_TIME_PAST)\n+                       ? nMedianTimePast\n+                       : pblock->GetBlockTime();\n+\n+    addPriorityTxs();\n+    addScoreTxs();\n+\n+    nLastBlockTx = nBlockTx;\n+    nLastBlockSize = nBlockSize;\n+    LogPrintf(\"CreateNewBlock(): total size %u txs: %u fees: %ld sigops %d\\n\", nBlockSize, nBlockTx, nFees, nBlockSigOps);\n+\n+    // Create coinbase transaction.\n+    CMutableTransaction coinbaseTx;\n+    coinbaseTx.vin.resize(1);\n+    coinbaseTx.vin[0].prevout.SetNull();\n+    coinbaseTx.vout.resize(1);\n+    coinbaseTx.vout[0].scriptPubKey = scriptPubKeyIn;\n+    coinbaseTx.vout[0].nValue = nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus());\n+    coinbaseTx.vin[0].scriptSig = CScript() << nHeight << OP_0;\n+    pblock->vtx[0] = coinbaseTx;\n+    pblocktemplate->vTxFees[0] = -nFees;\n+\n+    // Fill in header\n+    pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n+    UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev);\n+    pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock, chainparams.GetConsensus());\n+    pblock->nNonce         = 0;\n+    pblocktemplate->vTxSigOps[0] = GetLegacySigOpCount(pblock->vtx[0]);\n+\n+    CValidationState state;\n+    if (!TestBlockValidity(state, chainparams, *pblock, pindexPrev, false, false)) {\n+        throw std::runtime_error(strprintf(\"%s: TestBlockValidity failed: %s\", __func__, FormatStateMessage(state)));\n+    }\n \n-    // How much of the block should be dedicated to high-priority transactions,\n-    // included regardless of the fees they pay\n-    unsigned int nBlockPrioritySize = GetArg(\"-blockprioritysize\", DEFAULT_BLOCK_PRIORITY_SIZE);\n-    nBlockPrioritySize = std::min(nBlockMaxSize, nBlockPrioritySize);\n+    return pblocktemplate.release();\n+}\n \n-    // Minimum block size you want to create; block will be filled with free transactions\n-    // until there are no more or the block reaches this size:\n-    unsigned int nBlockMinSize = GetArg(\"-blockminsize\", DEFAULT_BLOCK_MIN_SIZE);\n-    nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);\n+bool BlockAssembler::isStillDependent(CTxMemPool::txiter iter)\n+{\n+    BOOST_FOREACH(CTxMemPool::txiter parent, mempool.GetMemPoolParents(iter))\n+    {\n+        if (!inBlock.count(parent)) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n \n-    // Collect memory pool transactions into the block\n-    CTxMemPool::setEntries inBlock;\n-    CTxMemPool::setEntries waitSet;\n \n-    // This vector will be sorted into a priority queue:\n-    vector<TxCoinAgePriority> vecPriority;\n-    TxCoinAgePriorityCompare pricomparer;\n-    std::map<CTxMemPool::txiter, double, CTxMemPool::CompareIteratorByHash> waitPriMap;\n-    typedef std::map<CTxMemPool::txiter, double, CTxMemPool::CompareIteratorByHash>::iterator waitPriIter;\n-    double actualPriority = -1;\n \n-    std::priority_queue<CTxMemPool::txiter, std::vector<CTxMemPool::txiter>, ScoreCompare> clearedTxs;\n+bool BlockAssembler::TestForBlock(CTxMemPool::txiter iter)\n+{\n+    if (nBlockSize + iter->GetTxSize() >= nBlockMaxSize) {\n+        // If the block is so close to full that no more txs will fit\n+        // or if we've tried more than 50 times to fill remaining space\n+        // then flag that the block is finished\n+        if (nBlockSize >  nBlockMaxSize - 100 || lastFewTxs > 50) {\n+             blockFinished = true;\n+             return false;\n+        }\n+        // Once we're within 1000 bytes of a full block, only look at 50 more txs\n+        // to try to fill the remaining space.\n+        if (nBlockSize > nBlockMaxSize - 1000) {\n+            lastFewTxs++;\n+        }\n+        return false;\n+    }\n+\n+    if (nBlockSigOps + iter->GetSigOpCount() >= MAX_BLOCK_SIGOPS) {\n+        // If the block has room for no more sig ops then\n+        // flag that the block is finished\n+        if (nBlockSigOps > MAX_BLOCK_SIGOPS - 2) {\n+            blockFinished = true;\n+            return false;\n+        }\n+        // Otherwise attempt to find another tx with fewer sigops\n+        // to put in the block.\n+        return false;\n+    }\n+\n+    // Must check that lock times are still valid\n+    // This can be removed once MTP is always enforced\n+    // as long as reorgs keep the mempool consistent.\n+    if (!IsFinalTx(iter->GetTx(), nHeight, nLockTimeCutoff))\n+        return false;\n+\n+    return true;\n+}\n+\n+void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\n+{\n+    pblock->vtx.push_back(iter->GetTx());\n+    pblocktemplate->vTxFees.push_back(iter->GetFee());\n+    pblocktemplate->vTxSigOps.push_back(iter->GetSigOpCount());\n+    nBlockSize += iter->GetTxSize();\n+    ++nBlockTx;\n+    nBlockSigOps += iter->GetSigOpCount();\n+    nFees += iter->GetFee();\n+    inBlock.insert(iter);\n+\n     bool fPrintPriority = GetBoolArg(\"-printpriority\", DEFAULT_PRINTPRIORITY);\n-    uint64_t nBlockSize = 1000;\n-    uint64_t nBlockTx = 0;\n-    unsigned int nBlockSigOps = 100;\n-    int lastFewTxs = 0;\n-    CAmount nFees = 0;\n+    if (fPrintPriority) {\n+        double dPriority = iter->GetPriority(nHeight);\n+        CAmount dummy;\n+        mempool.ApplyDeltas(iter->GetTx().GetHash(), dPriority, dummy);\n+        LogPrintf(\"priority %.1f fee %s txid %s\\n\",\n+                  dPriority,\n+                  CFeeRate(iter->GetModifiedFee(), iter->GetTxSize()).ToString(),\n+                  iter->GetTx().GetHash().ToString());\n+    }\n+}\n \n+void BlockAssembler::addScoreTxs()\n+{\n+    std::priority_queue<CTxMemPool::txiter, std::vector<CTxMemPool::txiter>, ScoreCompare> clearedTxs;\n+    CTxMemPool::setEntries waitSet;\n+    CTxMemPool::indexed_transaction_set::index<mining_score>::type::iterator mi = mempool.mapTx.get<mining_score>().begin();\n+    CTxMemPool::txiter iter;\n+    while (!blockFinished && (mi != mempool.mapTx.get<mining_score>().end() || !clearedTxs.empty()))",
    "path": "src/miner.cpp",
    "position": 218,
    "original_position": 218,
    "commit_id": "c2dd5a3c39156749e8ee24772d1fcb01404f2b6f",
    "original_commit_id": "c2dd5a3c39156749e8ee24772d1fcb01404f2b6f",
    "user": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "nit: could be `!(blockFinished || (mi == mempool.mapTx.get<mining_score>().end() && clearedTxs.empty()))` via demorgan's which is (maybe?) a bit easier to read.\n",
    "created_at": "2016-06-14T16:30:06Z",
    "updated_at": "2016-06-14T16:30:06Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r67006098",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67006098"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/7598#discussion_r67006098"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/7598"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67006098/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 250,
    "original_line": 250,
    "side": "RIGHT"
  }
]