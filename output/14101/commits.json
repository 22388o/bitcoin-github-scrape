[
  {
    "sha": "749ba35e7c9fbc21dbea27fd1be102b91313d132",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NDliYTM1ZTdjOWZiYzIxZGJlYTI3ZmQxYmUxMDJiOTEzMTNkMTMy",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-08-29T15:50:04Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-08-29T16:52:25Z"
      },
      "message": "scripted-diff: Pass node into p2p_segwit acceptance tests\n\n-BEGIN VERIFY SCRIPT-\nsed -i --regexp-extended -e 's/(test_witness_block|test_transaction_acceptance)\\((self\\.nodes\\[.\\])\\.rpc/\\1(\\2/g' test/functional/p2p_segwit.py\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "5bb58bbb1fa25b7297c1b68055eedc729ccbf851",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5bb58bbb1fa25b7297c1b68055eedc729ccbf851"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/749ba35e7c9fbc21dbea27fd1be102b91313d132",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/749ba35e7c9fbc21dbea27fd1be102b91313d132",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/749ba35e7c9fbc21dbea27fd1be102b91313d132",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/749ba35e7c9fbc21dbea27fd1be102b91313d132/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "888acefa5ee1908a6225f0a53869e21e698d9502",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/888acefa5ee1908a6225f0a53869e21e698d9502",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/888acefa5ee1908a6225f0a53869e21e698d9502"
      }
    ],
    "stats": {
      "total": 214,
      "additions": 107,
      "deletions": 107
    },
    "files": [
      {
        "sha": "82eacc84f4b02726e32616a81666410c86ff4537",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 107,
        "deletions": 107,
        "changes": 214,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/749ba35e7c9fbc21dbea27fd1be102b91313d132/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/749ba35e7c9fbc21dbea27fd1be102b91313d132/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=749ba35e7c9fbc21dbea27fd1be102b91313d132",
        "patch": "@@ -349,7 +349,7 @@ def test_unnecessary_witness_before_segwit_activation(self):\n         self.update_witness_block_with_transactions(block, [tx])\n         # Sending witness data before activation is not allowed (anti-spam\n         # rule).\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n         wait_until(lambda: 'reject' in self.test_node.last_message and self.test_node.last_message[\"reject\"].reason ==  b\"unexpected-witness\")\n \n         # But it should not be permanently marked bad...\n@@ -380,20 +380,20 @@ def test_block_relay(self):\n \n         self.test_node.announce_block_and_wait_for_getdata(block1, use_header=False)\n         assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block1, True)\n+        test_witness_block(self.nodes[0], self.test_node, block1, True)\n \n         block2 = self.build_next_block(version=4)\n         block2.solve()\n \n         self.test_node.announce_block_and_wait_for_getdata(block2, use_header=True)\n         assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block2, True)\n+        test_witness_block(self.nodes[0], self.test_node, block2, True)\n \n         block3 = self.build_next_block(version=(VB_TOP_BITS | (1 << 15)))\n         block3.solve()\n         self.test_node.announce_block_and_wait_for_getdata(block3, use_header=True)\n         assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block3, True)\n+        test_witness_block(self.nodes[0], self.test_node, block3, True)\n \n         # Check that we can getdata for witness blocks or regular blocks,\n         # and the right thing happens.\n@@ -423,7 +423,7 @@ def test_block_relay(self):\n             # This gives us a witness commitment.\n             assert(len(block.vtx[0].wit.vtxinwit) == 1)\n             assert(len(block.vtx[0].wit.vtxinwit[0].scriptWitness.stack) == 1)\n-            test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+            test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n             # Now try to retrieve it...\n             rpc_block = self.nodes[0].getblock(block.hash, False)\n             non_wit_block = self.test_node.request_block(block.sha256, 2)\n@@ -640,11 +640,11 @@ def test_witness_tx_relay_before_segwit_activation(self):\n         # its from)\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n         assert_equal(len(self.nodes[1].getrawmempool()), 0)\n-        test_transaction_acceptance(self.nodes[0].rpc, self.old_node, tx, with_witness=True, accepted=False)\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=True, accepted=False)\n+        test_transaction_acceptance(self.nodes[0], self.old_node, tx, with_witness=True, accepted=False)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=True, accepted=False)\n \n         # But eliminating the witness should fix it\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=False, accepted=True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=False, accepted=True)\n \n         # Cleanup: mine the first transaction and update utxo\n         self.nodes[0].generate(1)\n@@ -674,7 +674,7 @@ def test_standardness_v0(self):\n         p2sh_tx.rehash()\n \n         # Mine it on test_node to create the confirmed output.\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, p2sh_tx, with_witness=True, accepted=True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_tx, with_witness=True, accepted=True)\n         self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n \n@@ -689,7 +689,7 @@ def test_standardness_v0(self):\n \n         # This is always accepted, since the mempool policy is to consider segwit as always active\n         # and thus allow segwit outputs\n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx, with_witness=True, accepted=True)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, tx, with_witness=True, accepted=True)\n \n         # Now create something that looks like a P2PKH output. This won't be spendable.\n         script_pubkey = CScript([OP_0, hash160(witness_hash)])\n@@ -701,7 +701,7 @@ def test_standardness_v0(self):\n         tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n         tx2.rehash()\n \n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx2, with_witness=True, accepted=True)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, tx2, with_witness=True, accepted=True)\n \n         # Now update self.utxo for later tests.\n         tx3 = CTransaction()\n@@ -723,7 +723,7 @@ def test_standardness_v0(self):\n             tx3.vout = [tx3_out]\n             tx3.rehash()\n             assert_equal(self.nodes[0].testmempoolaccept([bytes_to_hex_str(tx3.serialize_with_witness())]), [{'txid': tx3.hash, 'allowed': True}])\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, with_witness=True, accepted=True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx3, with_witness=True, accepted=True)\n \n         self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n@@ -760,10 +760,10 @@ def test_p2sh_witness(self):\n         tx.rehash()\n \n         # Verify mempool acceptance and block validity\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=False, accepted=True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=False, accepted=True)\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True, with_witness=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True, with_witness=True)\n         sync_blocks(self.nodes)\n \n         # Now test attempts to spend the output.\n@@ -777,12 +777,12 @@ def test_p2sh_witness(self):\n         # will require a witness to spend a witness program regardless of\n         # segwit activation.  Note that older bitcoind's that are not\n         # segwit-aware would also reject this for failing CLEANSTACK.\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, spend_tx, with_witness=False, accepted=False)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, spend_tx, with_witness=False, accepted=False)\n \n         # Try to put the witness script in the script_sig, should also fail.\n         spend_tx.vin[0].script_sig = CScript([p2wsh_pubkey, b'a'])\n         spend_tx.rehash()\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, spend_tx, with_witness=False, accepted=False)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, spend_tx, with_witness=False, accepted=False)\n \n         # Now put the witness script in the witness, should succeed after\n         # segwit activates.\n@@ -792,15 +792,15 @@ def test_p2sh_witness(self):\n         spend_tx.wit.vtxinwit[0].scriptWitness.stack = [b'a', witness_program]\n \n         # Verify mempool acceptance\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, spend_tx, with_witness=True, accepted=True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, spend_tx, with_witness=True, accepted=True)\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [spend_tx])\n \n         # If we're after activation, then sending this with witnesses should be valid.\n         # This no longer works before activation, because SCRIPT_VERIFY_WITNESS\n         # is always set.\n         # TODO: rewrite this test to make clear that it only works after activation.\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Update self.utxo\n         self.utxo.pop(0)\n@@ -821,7 +821,7 @@ def test_witness_commitments(self):\n         assert(msg_witness_block(block).serialize() != msg_block(block).serialize())\n \n         # This empty block should be valid.\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Try to tweak the nonce\n         block_2 = self.build_next_block()\n@@ -832,7 +832,7 @@ def test_witness_commitments(self):\n         assert(block_2.vtx[0].vout[-1] != block.vtx[0].vout[-1])\n \n         # This should also be valid.\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block_2, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block_2, accepted=True)\n \n         # Now test commitments with actual transactions\n         tx = CTransaction()\n@@ -864,7 +864,7 @@ def test_witness_commitments(self):\n         block_3.rehash()\n         block_3.solve()\n \n-        test_witness_block(self.nodes[0].rpc, self.test_node, block_3, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block_3, accepted=False)\n \n         # Add a different commitment with different nonce, but in the\n         # right location, and with some funds burned(!).\n@@ -878,7 +878,7 @@ def test_witness_commitments(self):\n         block_3.rehash()\n         assert(len(block_3.vtx[0].vout) == 4)  # 3 OP_returns\n         block_3.solve()\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block_3, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block_3, accepted=True)\n \n         # Finally test that a block with no witness transactions can\n         # omit the commitment.\n@@ -890,7 +890,7 @@ def test_witness_commitments(self):\n         block_4.vtx.append(tx3)\n         block_4.hashMerkleRoot = block_4.calc_merkle_root()\n         block_4.solve()\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block_4, with_witness=False, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block_4, with_witness=False, accepted=True)\n \n         # Update available utxo's for use in later test.\n         self.utxo.pop(0)\n@@ -930,11 +930,11 @@ def test_block_malleability(self):\n         # Change the nonce -- should not cause the block to be permanently\n         # failed\n         block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ser_uint256(1)]\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Changing the witness reserved value doesn't change the block hash\n         block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ser_uint256(0)]\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n     @subtest\n     def test_witness_block_size(self):\n@@ -998,7 +998,7 @@ def test_witness_block_size(self):\n         # limit\n         assert(len(block.serialize(True)) > 2 * 1024 * 1024)\n \n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Now resize the second transaction to make the block fit.\n         cur_length = len(block.vtx[-1].wit.vtxinwit[0].scriptWitness.stack[0])\n@@ -1008,7 +1008,7 @@ def test_witness_block_size(self):\n         block.solve()\n         assert(get_virtual_size(block) == MAX_BLOCK_BASE_SIZE)\n \n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Update available utxo's\n         self.utxo.pop(0)\n@@ -1071,7 +1071,7 @@ def test_extra_witness_data(self):\n         self.update_witness_block_with_transactions(block, [tx])\n \n         # Extra witness data should not be allowed.\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Try extra signature data.  Ok if we're not spending a witness output.\n         block.vtx[1].wit.vtxinwit = []\n@@ -1080,7 +1080,7 @@ def test_extra_witness_data(self):\n         add_witness_commitment(block)\n         block.solve()\n \n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Now try extra witness/signature data on an input that DOES require a\n         # witness\n@@ -1096,7 +1096,7 @@ def test_extra_witness_data(self):\n         self.update_witness_block_with_transactions(block, [tx2])\n \n         # This has extra witness data, so it should fail.\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Now get rid of the extra witness, but add extra scriptSig data\n         tx2.vin[0].scriptSig = CScript([OP_TRUE])\n@@ -1108,7 +1108,7 @@ def test_extra_witness_data(self):\n         block.solve()\n \n         # This has extra signature data for a witness input, so it should fail.\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Now get rid of the extra scriptsig on the witness input, and verify\n         # success (even with extra scriptsig data in the non-witness input)\n@@ -1117,7 +1117,7 @@ def test_extra_witness_data(self):\n         add_witness_commitment(block)\n         block.solve()\n \n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Update utxo for later tests\n         self.utxo.pop(0)\n@@ -1147,14 +1147,14 @@ def test_max_witness_push_length(self):\n         tx2.rehash()\n \n         self.update_witness_block_with_transactions(block, [tx, tx2])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Now reduce the length of the stack element\n         tx2.wit.vtxinwit[0].scriptWitness.stack[0] = b'a' * (MAX_SCRIPT_ELEMENT_SIZE)\n \n         add_witness_commitment(block)\n         block.solve()\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Update the utxo for later tests\n         self.utxo.pop()\n@@ -1188,7 +1188,7 @@ def test_max_witness_program_length(self):\n \n         self.update_witness_block_with_transactions(block, [tx, tx2])\n \n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Try again with one less byte in the witness program\n         witness_program = CScript([b'a' * 520] * 19 + [OP_DROP] * 62 + [OP_TRUE])\n@@ -1203,7 +1203,7 @@ def test_max_witness_program_length(self):\n         tx2.rehash()\n         block.vtx = [block.vtx[0]]\n         self.update_witness_block_with_transactions(block, [tx, tx2])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         self.utxo.pop()\n         self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n@@ -1227,7 +1227,7 @@ def test_witness_input_length(self):\n \n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Try various ways to spend tx that should all break.\n         # This \"broken\" transaction serializer will not normalize\n@@ -1262,15 +1262,15 @@ def serialize_with_witness(self):\n \n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx2])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Now try using a too short vtxinwit\n         tx2.wit.vtxinwit.pop()\n         tx2.wit.vtxinwit.pop()\n \n         block.vtx = [block.vtx[0]]\n         self.update_witness_block_with_transactions(block, [tx2])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Now make one of the intermediate witnesses be incorrect\n         tx2.wit.vtxinwit.append(CTxInWitness())\n@@ -1279,13 +1279,13 @@ def serialize_with_witness(self):\n \n         block.vtx = [block.vtx[0]]\n         self.update_witness_block_with_transactions(block, [tx2])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Fix the broken witness and the block should be accepted.\n         tx2.wit.vtxinwit[5].scriptWitness.stack = [b'a', witness_program]\n         block.vtx = [block.vtx[0]]\n         self.update_witness_block_with_transactions(block, [tx2])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         self.utxo.pop()\n         self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n@@ -1314,11 +1314,11 @@ def test_tx_relay_after_segwit_activation(self):\n         # Verify that unnecessary witnesses are rejected.\n         self.test_node.announce_tx_and_wait_for_getdata(tx)\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=True, accepted=False)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=True, accepted=False)\n \n         # Verify that removing the witness succeeds.\n         self.test_node.announce_tx_and_wait_for_getdata(tx)\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=False, accepted=True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=False, accepted=True)\n \n         # Now try to add extra witness data to a valid witness tx.\n         witness_program = CScript([OP_TRUE])\n@@ -1343,24 +1343,24 @@ def test_tx_relay_after_segwit_activation(self):\n \n         # Node will not be blinded to the transaction\n         self.std_node.announce_tx_and_wait_for_getdata(tx3)\n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx3, True, False, b'tx-size')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, tx3, True, False, b'tx-size')\n         self.std_node.announce_tx_and_wait_for_getdata(tx3)\n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx3, True, False, b'tx-size')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, tx3, True, False, b'tx-size')\n \n         # Remove witness stuffing, instead add extra witness push on stack\n         tx3.vout[0] = CTxOut(tx2.vout[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE]))\n         tx3.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)]), witness_program]\n         tx3.rehash()\n \n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx2, with_witness=True, accepted=True)\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, with_witness=True, accepted=False)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx2, with_witness=True, accepted=True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx3, with_witness=True, accepted=False)\n \n         # Get rid of the extra witness, and verify acceptance.\n         tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n         # Also check that old_node gets a tx announcement, even though this is\n         # a witness transaction.\n         self.old_node.wait_for_inv([CInv(1, tx2.sha256)])  # wait until tx2 was inv'ed\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, with_witness=True, accepted=True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx3, with_witness=True, accepted=True)\n         self.old_node.wait_for_inv([CInv(1, tx3.sha256)])\n \n         # Test that getrawtransaction returns correct witness information\n@@ -1400,7 +1400,7 @@ def test_segwit_versions(self):\n             tx.rehash()\n             block = self.build_next_block()\n             self.update_witness_block_with_transactions(block, [tx])\n-            test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+            test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n             self.utxo.pop(0)\n             for i in range(NUM_SEGWIT_VERSIONS):\n                 self.utxo.append(UTXO(tx.sha256, i, split_value))\n@@ -1417,8 +1417,8 @@ def test_segwit_versions(self):\n             tx.vin = [CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\")]\n             tx.vout = [CTxOut(self.utxo[0].nValue - 1000, script_pubkey)]\n             tx.rehash()\n-            test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx, with_witness=True, accepted=False)\n-            test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=True, accepted=True)\n+            test_transaction_acceptance(self.nodes[1], self.std_node, tx, with_witness=True, accepted=False)\n+            test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=True, accepted=True)\n             self.utxo.pop(0)\n             temp_utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n \n@@ -1437,8 +1437,8 @@ def test_segwit_versions(self):\n         tx2.rehash()\n         # Gets accepted to test_node, because standardness of outputs isn't\n         # checked with fRequireStandard\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx2, with_witness=True, accepted=True)\n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx2, with_witness=True, accepted=False)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx2, with_witness=True, accepted=True)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, tx2, with_witness=True, accepted=False)\n         temp_utxo.pop()  # last entry in temp_utxo was the output we just spent\n         temp_utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n \n@@ -1454,15 +1454,15 @@ def test_segwit_versions(self):\n         tx3.rehash()\n         # Spending a higher version witness output is not allowed by policy,\n         # even with fRequireStandard=false.\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, with_witness=True, accepted=False)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx3, with_witness=True, accepted=False)\n         self.test_node.sync_with_ping()\n         with mininode_lock:\n             assert(b\"reserved for soft-fork upgrades\" in self.test_node.last_message[\"reject\"].reason)\n \n         # Building a block with the transaction must be valid, however.\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx2, tx3])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n         sync_blocks(self.nodes)\n \n         # Add utxo to our list\n@@ -1480,7 +1480,7 @@ def test_premature_coinbase_witness_spend(self):\n         # This next line will rehash the coinbase and update the merkle\n         # root, and solve.\n         self.update_witness_block_with_transactions(block, [])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         spend_tx = CTransaction()\n         spend_tx.vin = [CTxIn(COutPoint(block.vtx[0].sha256, 0), b\"\")]\n@@ -1494,13 +1494,13 @@ def test_premature_coinbase_witness_spend(self):\n         sync_blocks(self.nodes)\n         block2 = self.build_next_block()\n         self.update_witness_block_with_transactions(block2, [spend_tx])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block2, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block2, accepted=False)\n \n         # Advancing one more block should allow the spend.\n         self.nodes[0].generate(1)\n         block2 = self.build_next_block()\n         self.update_witness_block_with_transactions(block2, [spend_tx])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block2, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block2, accepted=True)\n         sync_blocks(self.nodes)\n \n     @subtest\n@@ -1532,7 +1532,7 @@ def test_uncompressed_pubkey(self):\n         # Confirm it in a block.\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Now try to spend it. Send it to a P2WSH output, which we'll\n         # use in the next test.\n@@ -1551,11 +1551,11 @@ def test_uncompressed_pubkey(self):\n         tx2.rehash()\n \n         # Should fail policy test.\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx2, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx2, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n         # But passes consensus.\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx2])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Test 2: P2WSH\n         # Try to spend the P2WSH output created in last test.\n@@ -1571,11 +1571,11 @@ def test_uncompressed_pubkey(self):\n         sign_p2pk_witness_input(witness_program, tx3, 0, SIGHASH_ALL, tx2.vout[0].nValue, key)\n \n         # Should fail policy test.\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx3, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n         # But passes consensus.\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx3])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Test 3: P2SH(P2WSH)\n         # Try to spend the P2SH output created in the last test.\n@@ -1588,10 +1588,10 @@ def test_uncompressed_pubkey(self):\n         sign_p2pk_witness_input(witness_program, tx4, 0, SIGHASH_ALL, tx3.vout[0].nValue, key)\n \n         # Should fail policy test.\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx4, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx4, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx4])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Test 4: Uncompressed pubkeys should still be valid in non-segwit\n         # transactions.\n@@ -1603,10 +1603,10 @@ def test_uncompressed_pubkey(self):\n         tx5.vin[0].scriptSig = CScript([signature, pubkey])\n         tx5.rehash()\n         # Should pass policy and consensus.\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx5, True, True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx5, True, True)\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx5])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n         self.utxo.append(UTXO(tx5.sha256, 0, tx5.vout[0].nValue))\n \n     @subtest\n@@ -1626,11 +1626,11 @@ def test_signature_version_1(self):\n         tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, script_pubkey))\n         tx.rehash()\n \n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=True, accepted=True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=True, accepted=True)\n         # Mine this transaction in preparation for following tests.\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n         sync_blocks(self.nodes)\n         self.utxo.pop(0)\n \n@@ -1647,19 +1647,19 @@ def test_signature_version_1(self):\n                 # Too-large input value\n                 sign_p2pk_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue + 1, key)\n                 self.update_witness_block_with_transactions(block, [tx])\n-                test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n+                test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n                 # Too-small input value\n                 sign_p2pk_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue - 1, key)\n                 block.vtx.pop()  # remove last tx\n                 self.update_witness_block_with_transactions(block, [tx])\n-                test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n+                test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n                 # Now try correct value\n                 sign_p2pk_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue, key)\n                 block.vtx.pop()\n                 self.update_witness_block_with_transactions(block, [tx])\n-                test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+                test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n                 prev_utxo = UTXO(tx.sha256, 0, tx.vout[0].nValue)\n \n@@ -1683,7 +1683,7 @@ def test_signature_version_1(self):\n \n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         block = self.build_next_block()\n         used_sighash_single_out_of_bounds = False\n@@ -1725,15 +1725,15 @@ def test_signature_version_1(self):\n             # Test the block periodically, if we're close to maxblocksize\n             if (get_virtual_size(block) > MAX_BLOCK_BASE_SIZE - 1000):\n                 self.update_witness_block_with_transactions(block, [])\n-                test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+                test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n                 block = self.build_next_block()\n \n         if (not used_sighash_single_out_of_bounds):\n             self.log.info(\"WARNING: this test run didn't attempt SIGHASH_SINGLE with out-of-bounds index value\")\n         # Test the transactions we've added to the block\n         if (len(block.vtx) > 1):\n             self.update_witness_block_with_transactions(block, [])\n-            test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+            test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Now test witness version 0 P2PKH transactions\n         pubkeyhash = hash160(pubkey)\n@@ -1755,7 +1755,7 @@ def test_signature_version_1(self):\n         tx2.vin[0].scriptSig = CScript([signature, pubkey])\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx, tx2])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Move the signature to the witness.\n         block.vtx.pop()\n@@ -1765,7 +1765,7 @@ def test_signature_version_1(self):\n         tx2.rehash()\n \n         self.update_witness_block_with_transactions(block, [tx2])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         temp_utxos.pop(0)\n \n@@ -1786,7 +1786,7 @@ def test_signature_version_1(self):\n             index += 1\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         for i in range(len(tx.vout)):\n             self.utxo.append(UTXO(tx.sha256, i, tx.vout[i].nValue))\n@@ -1808,7 +1808,7 @@ def test_non_standard_witness_blinding(self):\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n         tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, script_pubkey))\n         tx.rehash()\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, False, True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx, False, True)\n         self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n \n@@ -1825,18 +1825,18 @@ def test_non_standard_witness_blinding(self):\n         tx2.rehash()\n         # This will be rejected due to a policy check:\n         # No witness is allowed, since it is not a witness program but a p2sh program\n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx2, True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, tx2, True, False, b'bad-witness-nonstandard')\n \n         # If we send without witness, it should be accepted.\n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx2, False, True)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, tx2, False, True)\n \n         # Now create a new anyone-can-spend utxo for the next test.\n         tx3 = CTransaction()\n         tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), CScript([p2sh_program])))\n         tx3.vout.append(CTxOut(tx2.vout[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE])))\n         tx3.rehash()\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx2, False, True)\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, False, True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx2, False, True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx3, False, True)\n \n         self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n@@ -1872,7 +1872,7 @@ def test_non_standard_witness(self):\n             tx.vout.append(CTxOut(outputvalue, CScript([OP_HASH160, p2sh, OP_EQUAL])))\n         tx.rehash()\n         txid = tx.sha256\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=False, accepted=True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=False, accepted=True)\n \n         self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n@@ -1897,45 +1897,45 @@ def test_non_standard_witness(self):\n         # Testing native P2WSH\n         # Witness stack size, excluding witnessScript, over 100 is non-standard\n         p2wsh_txs[0].wit.vtxinwit[0].scriptWitness.stack = [pad] * 101 + [scripts[0]]\n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, p2wsh_txs[0], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[0], True, False, b'bad-witness-nonstandard')\n         # Non-standard nodes should accept\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, p2wsh_txs[0], True, True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, p2wsh_txs[0], True, True)\n \n         # Stack element size over 80 bytes is non-standard\n         p2wsh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]\n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, p2wsh_txs[1], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[1], True, False, b'bad-witness-nonstandard')\n         # Non-standard nodes should accept\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, p2wsh_txs[1], True, True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, p2wsh_txs[1], True, True)\n         # Standard nodes should accept if element size is not over 80 bytes\n         p2wsh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 80] * 100 + [scripts[1]]\n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, p2wsh_txs[1], True, True)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[1], True, True)\n \n         # witnessScript size at 3600 bytes is standard\n         p2wsh_txs[2].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, scripts[2]]\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, p2wsh_txs[2], True, True)\n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, p2wsh_txs[2], True, True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, p2wsh_txs[2], True, True)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[2], True, True)\n \n         # witnessScript size at 3601 bytes is non-standard\n         p2wsh_txs[3].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, pad, scripts[3]]\n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, p2wsh_txs[3], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[3], True, False, b'bad-witness-nonstandard')\n         # Non-standard nodes should accept\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, p2wsh_txs[3], True, True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, p2wsh_txs[3], True, True)\n \n         # Repeating the same tests with P2SH-P2WSH\n         p2sh_txs[0].wit.vtxinwit[0].scriptWitness.stack = [pad] * 101 + [scripts[0]]\n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, p2sh_txs[0], True, False, b'bad-witness-nonstandard')\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, p2sh_txs[0], True, True)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[0], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[0], True, True)\n         p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]\n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, p2sh_txs[1], True, False, b'bad-witness-nonstandard')\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, p2sh_txs[1], True, True)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[1], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[1], True, True)\n         p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 80] * 100 + [scripts[1]]\n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, p2sh_txs[1], True, True)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[1], True, True)\n         p2sh_txs[2].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, scripts[2]]\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, p2sh_txs[2], True, True)\n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, p2sh_txs[2], True, True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[2], True, True)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[2], True, True)\n         p2sh_txs[3].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, pad, scripts[3]]\n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, p2sh_txs[3], True, False, b'bad-witness-nonstandard')\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, p2sh_txs[3], True, True)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[3], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[3], True, True)\n \n         self.nodes[0].generate(1)  # Mine and clean up the mempool of non-standard node\n         # Valid but non-standard transactions in a block should be accepted by standard node\n@@ -2011,7 +2011,7 @@ def test_witness_sigops(self):\n \n         block_1 = self.build_next_block()\n         self.update_witness_block_with_transactions(block_1, [tx])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block_1, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block_1, accepted=True)\n \n         tx2 = CTransaction()\n         # If we try to spend the first n-1 outputs from tx, that should be\n@@ -2028,7 +2028,7 @@ def test_witness_sigops(self):\n \n         block_2 = self.build_next_block()\n         self.update_witness_block_with_transactions(block_2, [tx2])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block_2, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block_2, accepted=False)\n \n         # Try dropping the last input in tx2, and add an output that has\n         # too many sigops (contributing to legacy sigop count).\n@@ -2041,14 +2041,14 @@ def test_witness_sigops(self):\n         tx2.rehash()\n         block_3 = self.build_next_block()\n         self.update_witness_block_with_transactions(block_3, [tx2])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block_3, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block_3, accepted=False)\n \n         # If we drop the last checksig in this output, the tx should succeed.\n         block_4 = self.build_next_block()\n         tx2.vout[-1].scriptPubKey = CScript([OP_CHECKSIG] * (checksig_count - 1))\n         tx2.rehash()\n         self.update_witness_block_with_transactions(block_4, [tx2])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block_4, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block_4, accepted=True)\n \n         # Reset the tip back down for the next test\n         sync_blocks(self.nodes)\n@@ -2064,7 +2064,7 @@ def test_witness_sigops(self):\n         tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_program_justright]\n         tx2.rehash()\n         self.update_witness_block_with_transactions(block_5, [tx2])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block_5, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block_5, accepted=True)\n \n         # TODO: test p2sh sigop counting\n "
      }
    ]
  },
  {
    "sha": "b4d33096734d787b0e1d754064039cbb64ce8d61",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNGQzMzA5NjczNGQ3ODdiMGUxZDc1NDA2NDAzOWNiYjY0Y2U4ZDYx",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-08-29T16:21:15Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-08-29T16:52:25Z"
      },
      "message": "scripted-diff: Use named arguments in feature_block\n\n-BEGIN VERIFY SCRIPT-\nsed -i --regexp-extended -e \"s/sync_blocks\\((.*?), (True|False), (1.?), /sync_blocks(\\1, success=\\2, reject_code=\\3, reject_reason=/g\" ./test/functional/feature_block.py\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "436b014496b3350dcea2aacd67e8da50fc1176bc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/436b014496b3350dcea2aacd67e8da50fc1176bc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b4d33096734d787b0e1d754064039cbb64ce8d61",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4d33096734d787b0e1d754064039cbb64ce8d61",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b4d33096734d787b0e1d754064039cbb64ce8d61",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4d33096734d787b0e1d754064039cbb64ce8d61/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "749ba35e7c9fbc21dbea27fd1be102b91313d132",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/749ba35e7c9fbc21dbea27fd1be102b91313d132",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/749ba35e7c9fbc21dbea27fd1be102b91313d132"
      }
    ],
    "stats": {
      "total": 76,
      "additions": 38,
      "deletions": 38
    },
    "files": [
      {
        "sha": "e81ea12d0f835caba1cac39485f9afc78b8e1a93",
        "filename": "test/functional/feature_block.py",
        "status": "modified",
        "additions": 38,
        "deletions": 38,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4d33096734d787b0e1d754064039cbb64ce8d61/test/functional/feature_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4d33096734d787b0e1d754064039cbb64ce8d61/test/functional/feature_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_block.py?ref=b4d33096734d787b0e1d754064039cbb64ce8d61",
        "patch": "@@ -169,7 +169,7 @@ def run_test(self):\n         self.log.info(\"Reject a block where the miner creates too much coinbase reward\")\n         self.move_tip(6)\n         b9 = self.next_block(9, spend=out[4], additional_coinbase_value=1)\n-        self.sync_blocks([b9], False, 16, b'bad-cb-amount', reconnect=True)\n+        self.sync_blocks([b9], success=False, reject_code=16, reject_reason=b'bad-cb-amount', reconnect=True)\n \n         # Create a fork that ends in a block with too much fee (the one that causes the reorg)\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -181,7 +181,7 @@ def run_test(self):\n         self.sync_blocks([b10], False)\n \n         b11 = self.next_block(11, spend=out[4], additional_coinbase_value=1)\n-        self.sync_blocks([b11], False, 16, b'bad-cb-amount', reconnect=True)\n+        self.sync_blocks([b11], success=False, reject_code=16, reject_reason=b'bad-cb-amount', reconnect=True)\n \n         # Try again, but with a valid fork first\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -194,7 +194,7 @@ def run_test(self):\n         b13 = self.next_block(13, spend=out[4])\n         self.save_spendable_output()\n         b14 = self.next_block(14, spend=out[5], additional_coinbase_value=1)\n-        self.sync_blocks([b12, b13, b14], False, 16, b'bad-cb-amount', reconnect=True)\n+        self.sync_blocks([b12, b13, b14], success=False, reject_code=16, reject_reason=b'bad-cb-amount', reconnect=True)\n \n         # New tip should be b13.\n         assert_equal(node.getbestblockhash(), b13.hash)\n@@ -213,7 +213,7 @@ def run_test(self):\n         self.log.info(\"Reject a block with too many checksigs\")\n         too_many_checksigs = CScript([OP_CHECKSIG] * (MAX_BLOCK_SIGOPS))\n         b16 = self.next_block(16, spend=out[6], script=too_many_checksigs)\n-        self.sync_blocks([b16], False, 16, b'bad-blk-sigops', reconnect=True)\n+        self.sync_blocks([b16], success=False, reject_code=16, reject_reason=b'bad-blk-sigops', reconnect=True)\n \n         # Attempt to spend a transaction created on a different fork\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -222,7 +222,7 @@ def run_test(self):\n         self.log.info(\"Reject a block with a spend from a re-org'ed out tx\")\n         self.move_tip(15)\n         b17 = self.next_block(17, spend=txout_b3)\n-        self.sync_blocks([b17], False, 16, b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b17], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n \n         # Attempt to spend a transaction created on a different fork (on a fork this time)\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -235,7 +235,7 @@ def run_test(self):\n         self.sync_blocks([b18], False)\n \n         b19 = self.next_block(19, spend=out[6])\n-        self.sync_blocks([b19], False, 16, b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b19], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n \n         # Attempt to spend a coinbase at depth too low\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -244,7 +244,7 @@ def run_test(self):\n         self.log.info(\"Reject a block spending an immature coinbase.\")\n         self.move_tip(15)\n         b20 = self.next_block(20, spend=out[7])\n-        self.sync_blocks([b20], False, 16, b'bad-txns-premature-spend-of-coinbase')\n+        self.sync_blocks([b20], success=False, reject_code=16, reject_reason=b'bad-txns-premature-spend-of-coinbase')\n \n         # Attempt to spend a coinbase at depth too low (on a fork this time)\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -257,7 +257,7 @@ def run_test(self):\n         self.sync_blocks([b21], False)\n \n         b22 = self.next_block(22, spend=out[5])\n-        self.sync_blocks([b22], False, 16, b'bad-txns-premature-spend-of-coinbase')\n+        self.sync_blocks([b22], success=False, reject_code=16, reject_reason=b'bad-txns-premature-spend-of-coinbase')\n \n         # Create a block on either side of MAX_BLOCK_BASE_SIZE and make sure its accepted/rejected\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -286,7 +286,7 @@ def run_test(self):\n         tx.vout = [CTxOut(0, script_output)]\n         b24 = self.update_block(24, [tx])\n         assert_equal(len(b24.serialize()), MAX_BLOCK_BASE_SIZE + 1)\n-        self.sync_blocks([b24], False, 16, b'bad-blk-length', reconnect=True)\n+        self.sync_blocks([b24], success=False, reject_code=16, reject_reason=b'bad-blk-length', reconnect=True)\n \n         b25 = self.next_block(25, spend=out[7])\n         self.sync_blocks([b25], False)\n@@ -304,7 +304,7 @@ def run_test(self):\n         # update_block causes the merkle root to get updated, even with no new\n         # transactions, and updates the required state.\n         b26 = self.update_block(26, [])\n-        self.sync_blocks([b26], False, 16, b'bad-cb-length', reconnect=True)\n+        self.sync_blocks([b26], success=False, reject_code=16, reject_reason=b'bad-cb-length', reconnect=True)\n \n         # Extend the b26 chain to make sure bitcoind isn't accepting b26\n         b27 = self.next_block(27, spend=out[7])\n@@ -316,7 +316,7 @@ def run_test(self):\n         b28.vtx[0].vin[0].scriptSig = b'\\x00' * 101\n         b28.vtx[0].rehash()\n         b28 = self.update_block(28, [])\n-        self.sync_blocks([b28], False, 16, b'bad-cb-length', reconnect=True)\n+        self.sync_blocks([b28], success=False, reject_code=16, reject_reason=b'bad-cb-length', reconnect=True)\n \n         # Extend the b28 chain to make sure bitcoind isn't accepting b28\n         b29 = self.next_block(29, spend=out[7])\n@@ -352,7 +352,7 @@ def run_test(self):\n         too_many_multisigs = CScript([OP_CHECKMULTISIG] * (MAX_BLOCK_SIGOPS // 20))\n         b32 = self.next_block(32, spend=out[9], script=too_many_multisigs)\n         assert_equal(get_legacy_sigopcount_block(b32), MAX_BLOCK_SIGOPS + 1)\n-        self.sync_blocks([b32], False, 16, b'bad-blk-sigops', reconnect=True)\n+        self.sync_blocks([b32], success=False, reject_code=16, reject_reason=b'bad-blk-sigops', reconnect=True)\n \n         # CHECKMULTISIGVERIFY\n         self.log.info(\"Accept a block with the max number of OP_CHECKMULTISIGVERIFY sigops\")\n@@ -365,7 +365,7 @@ def run_test(self):\n         self.log.info(\"Reject a block with too many OP_CHECKMULTISIGVERIFY sigops\")\n         too_many_multisigs = CScript([OP_CHECKMULTISIGVERIFY] * (MAX_BLOCK_SIGOPS // 20))\n         b34 = self.next_block(34, spend=out[10], script=too_many_multisigs)\n-        self.sync_blocks([b34], False, 16, b'bad-blk-sigops', reconnect=True)\n+        self.sync_blocks([b34], success=False, reject_code=16, reject_reason=b'bad-blk-sigops', reconnect=True)\n \n         # CHECKSIGVERIFY\n         self.log.info(\"Accept a block with the max number of OP_CHECKSIGVERIFY sigops\")\n@@ -378,7 +378,7 @@ def run_test(self):\n         self.log.info(\"Reject a block with too many OP_CHECKSIGVERIFY sigops\")\n         too_many_checksigs = CScript([OP_CHECKSIGVERIFY] * (MAX_BLOCK_SIGOPS))\n         b36 = self.next_block(36, spend=out[11], script=too_many_checksigs)\n-        self.sync_blocks([b36], False, 16, b'bad-blk-sigops', reconnect=True)\n+        self.sync_blocks([b36], success=False, reject_code=16, reject_reason=b'bad-blk-sigops', reconnect=True)\n \n         # Check spending of a transaction in a block which failed to connect\n         #\n@@ -395,12 +395,12 @@ def run_test(self):\n         txout_b37 = b37.vtx[1]\n         tx = self.create_and_sign_transaction(out[11], 0)\n         b37 = self.update_block(37, [tx])\n-        self.sync_blocks([b37], False, 16, b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b37], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n \n         # attempt to spend b37's first non-coinbase tx, at which point b37 was still considered valid\n         self.move_tip(35)\n         b38 = self.next_block(38, spend=txout_b37)\n-        self.sync_blocks([b38], False, 16, b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b38], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n \n         # Check P2SH SigOp counting\n         #\n@@ -492,7 +492,7 @@ def run_test(self):\n         tx.rehash()\n         new_txs.append(tx)\n         self.update_block(40, new_txs)\n-        self.sync_blocks([b40], False, 16, b'bad-blk-sigops', reconnect=True)\n+        self.sync_blocks([b40], success=False, reject_code=16, reject_reason=b'bad-blk-sigops', reconnect=True)\n \n         # same as b40, but one less sigop\n         self.log.info(\"Accept a block with the max number of P2SH sigops\")\n@@ -555,7 +555,7 @@ def run_test(self):\n         self.block_heights[b45.sha256] = self.block_heights[self.tip.sha256] + 1\n         self.tip = b45\n         self.blocks[45] = b45\n-        self.sync_blocks([b45], False, 16, b'bad-cb-missing', reconnect=True)\n+        self.sync_blocks([b45], success=False, reject_code=16, reject_reason=b'bad-cb-missing', reconnect=True)\n \n         self.log.info(\"Reject a block with no transactions\")\n         self.move_tip(44)\n@@ -570,7 +570,7 @@ def run_test(self):\n         self.tip = b46\n         assert 46 not in self.blocks\n         self.blocks[46] = b46\n-        self.sync_blocks([b46], False, 16, b'bad-blk-length', reconnect=True)\n+        self.sync_blocks([b46], success=False, reject_code=16, reject_reason=b'bad-blk-length', reconnect=True)\n \n         self.log.info(\"Reject a block with invalid work\")\n         self.move_tip(44)\n@@ -593,7 +593,7 @@ def run_test(self):\n         b49 = self.next_block(49)\n         b49.hashMerkleRoot += 1\n         b49.solve()\n-        self.sync_blocks([b49], False, 16, b'bad-txnmrklroot', reconnect=True)\n+        self.sync_blocks([b49], success=False, reject_code=16, reject_reason=b'bad-txnmrklroot', reconnect=True)\n \n         self.log.info(\"Reject a block with incorrect POW limit\")\n         self.move_tip(44)\n@@ -607,15 +607,15 @@ def run_test(self):\n         b51 = self.next_block(51)\n         cb2 = create_coinbase(51, self.coinbase_pubkey)\n         b51 = self.update_block(51, [cb2])\n-        self.sync_blocks([b51], False, 16, b'bad-cb-multiple', reconnect=True)\n+        self.sync_blocks([b51], success=False, reject_code=16, reject_reason=b'bad-cb-multiple', reconnect=True)\n \n         self.log.info(\"Reject a block with duplicate transactions\")\n         # Note: txns have to be in the right position in the merkle tree to trigger this error\n         self.move_tip(44)\n         b52 = self.next_block(52, spend=out[15])\n         tx = self.create_tx(b52.vtx[1], 0, 1)\n         b52 = self.update_block(52, [tx, tx])\n-        self.sync_blocks([b52], False, 16, b'bad-txns-duplicate', reconnect=True)\n+        self.sync_blocks([b52], success=False, reject_code=16, reject_reason=b'bad-txns-duplicate', reconnect=True)\n \n         # Test block timestamps\n         #  -> b31 (8) -> b33 (9) -> b35 (10) -> b39 (11) -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15)\n@@ -682,7 +682,7 @@ def run_test(self):\n         assert_equal(len(b56.vtx), 3)\n         b56 = self.update_block(56, [tx1])\n         assert_equal(b56.hash, b57.hash)\n-        self.sync_blocks([b56], False, 16, b'bad-txns-duplicate', reconnect=True)\n+        self.sync_blocks([b56], success=False, reject_code=16, reject_reason=b'bad-txns-duplicate', reconnect=True)\n \n         # b57p2 - a good block with 6 tx'es, don't submit until end\n         self.move_tip(55)\n@@ -702,7 +702,7 @@ def run_test(self):\n         assert_equal(b56p2.hash, b57p2.hash)\n         assert_equal(len(b56p2.vtx), 6)\n         b56p2 = self.update_block(\"b56p2\", [tx3, tx4])\n-        self.sync_blocks([b56p2], False, 16, b'bad-txns-duplicate', reconnect=True)\n+        self.sync_blocks([b56p2], success=False, reject_code=16, reject_reason=b'bad-txns-duplicate', reconnect=True)\n \n         self.move_tip(\"57p2\")\n         self.sync_blocks([b57p2], True)\n@@ -727,15 +727,15 @@ def run_test(self):\n         tx.vout.append(CTxOut(0, b\"\"))\n         tx.calc_sha256()\n         b58 = self.update_block(58, [tx])\n-        self.sync_blocks([b58], False, 16, b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b58], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n \n         # tx with output value > input value\n         self.log.info(\"Reject a block with a transaction with outputs > inputs\")\n         self.move_tip(57)\n         b59 = self.next_block(59)\n         tx = self.create_and_sign_transaction(out[17], 51 * COIN)\n         b59 = self.update_block(59, [tx])\n-        self.sync_blocks([b59], False, 16, b'bad-txns-in-belowout', reconnect=True)\n+        self.sync_blocks([b59], success=False, reject_code=16, reject_reason=b'bad-txns-in-belowout', reconnect=True)\n \n         # reset to good chain\n         self.move_tip(57)\n@@ -759,7 +759,7 @@ def run_test(self):\n         b61.vtx[0].rehash()\n         b61 = self.update_block(61, [])\n         assert_equal(b60.vtx[0].serialize(), b61.vtx[0].serialize())\n-        self.sync_blocks([b61], False, 16, b'bad-txns-BIP30', reconnect=True)\n+        self.sync_blocks([b61], success=False, reject_code=16, reject_reason=b'bad-txns-BIP30', reconnect=True)\n \n         # Test tx.isFinal is properly rejected (not an exhaustive tx.isFinal test, that should be in data-driven transaction tests)\n         #\n@@ -776,7 +776,7 @@ def run_test(self):\n         assert(tx.vin[0].nSequence < 0xffffffff)\n         tx.calc_sha256()\n         b62 = self.update_block(62, [tx])\n-        self.sync_blocks([b62], False, 16, b'bad-txns-nonfinal')\n+        self.sync_blocks([b62], success=False, reject_code=16, reject_reason=b'bad-txns-nonfinal')\n \n         # Test a non-final coinbase is also rejected\n         #\n@@ -790,7 +790,7 @@ def run_test(self):\n         b63.vtx[0].vin[0].nSequence = 0xDEADBEEF\n         b63.vtx[0].rehash()\n         b63 = self.update_block(63, [])\n-        self.sync_blocks([b63], False, 16, b'bad-txns-nonfinal')\n+        self.sync_blocks([b63], success=False, reject_code=16, reject_reason=b'bad-txns-nonfinal')\n \n         #  This checks that a block with a bloated VARINT between the block_header and the array of tx such that\n         #  the block is > MAX_BLOCK_BASE_SIZE with the bloated varint, but <= MAX_BLOCK_BASE_SIZE without the bloated varint,\n@@ -824,7 +824,7 @@ def run_test(self):\n         tx.vin.append(CTxIn(COutPoint(b64a.vtx[1].sha256, 0)))\n         b64a = self.update_block(\"64a\", [tx])\n         assert_equal(len(b64a.serialize()), MAX_BLOCK_BASE_SIZE + 8)\n-        self.sync_blocks([b64a], False, 1, b'error parsing message')\n+        self.sync_blocks([b64a], success=False, reject_code=1, reject_reason=b'error parsing message')\n \n         # bitcoind doesn't disconnect us for sending a bloated block, but if we subsequently\n         # resend the header message, it won't send us the getdata message again. Just\n@@ -866,7 +866,7 @@ def run_test(self):\n         tx1 = self.create_and_sign_transaction(out[20], out[20].vout[0].nValue)\n         tx2 = self.create_and_sign_transaction(tx1, 1)\n         b66 = self.update_block(66, [tx2, tx1])\n-        self.sync_blocks([b66], False, 16, b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b66], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n \n         # Attempt to double-spend a transaction created in a block\n         #\n@@ -881,7 +881,7 @@ def run_test(self):\n         tx2 = self.create_and_sign_transaction(tx1, 1)\n         tx3 = self.create_and_sign_transaction(tx1, 2)\n         b67 = self.update_block(67, [tx1, tx2, tx3])\n-        self.sync_blocks([b67], False, 16, b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b67], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n \n         # More tests of block subsidy\n         #\n@@ -900,7 +900,7 @@ def run_test(self):\n         b68 = self.next_block(68, additional_coinbase_value=10)\n         tx = self.create_and_sign_transaction(out[20], out[20].vout[0].nValue - 9)\n         b68 = self.update_block(68, [tx])\n-        self.sync_blocks([b68], False, 16, b'bad-cb-amount', reconnect=True)\n+        self.sync_blocks([b68], success=False, reject_code=16, reject_reason=b'bad-cb-amount', reconnect=True)\n \n         self.log.info(\"Accept a block claiming the correct subsidy in the coinbase transaction\")\n         self.move_tip(65)\n@@ -924,7 +924,7 @@ def run_test(self):\n         tx.vin.append(CTxIn(COutPoint(bogus_tx.sha256, 0), b\"\", 0xffffffff))\n         tx.vout.append(CTxOut(1, b\"\"))\n         b70 = self.update_block(70, [tx])\n-        self.sync_blocks([b70], False, 16, b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b70], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n \n         # Test accepting an invalid block which has the same hash as a valid one (via merkle tree tricks)\n         #\n@@ -949,7 +949,7 @@ def run_test(self):\n         assert_equal(b72.sha256, b71.sha256)\n \n         self.move_tip(71)\n-        self.sync_blocks([b71], False, 16, b'bad-txns-duplicate', reconnect=True)\n+        self.sync_blocks([b71], success=False, reject_code=16, reject_reason=b'bad-txns-duplicate', reconnect=True)\n \n         self.move_tip(72)\n         self.sync_blocks([b72], True)\n@@ -987,7 +987,7 @@ def run_test(self):\n         tx = self.create_and_sign_transaction(out[22], 1, CScript(a))\n         b73 = self.update_block(73, [tx])\n         assert_equal(get_legacy_sigopcount_block(b73), MAX_BLOCK_SIGOPS + 1)\n-        self.sync_blocks([b73], False, 16, b'bad-blk-sigops', reconnect=True)\n+        self.sync_blocks([b73], success=False, reject_code=16, reject_reason=b'bad-blk-sigops', reconnect=True)\n \n         # b74/75 - if we push an invalid script element, all prevous sigops are counted,\n         #          but sigops after the element are not counted.\n@@ -1011,7 +1011,7 @@ def run_test(self):\n         a[MAX_BLOCK_SIGOPS + 4] = 0xff\n         tx = self.create_and_sign_transaction(out[22], 1, CScript(a))\n         b74 = self.update_block(74, [tx])\n-        self.sync_blocks([b74], False, 16, b'bad-blk-sigops', reconnect=True)\n+        self.sync_blocks([b74], success=False, reject_code=16, reject_reason=b'bad-blk-sigops', reconnect=True)\n \n         self.move_tip(72)\n         b75 = self.next_block(75)\n@@ -1160,7 +1160,7 @@ def run_test(self):\n         b89a = self.next_block(\"89a\", spend=out[32])\n         tx = self.create_tx(tx1, 0, 0, CScript([OP_TRUE]))\n         b89a = self.update_block(\"89a\", [tx])\n-        self.sync_blocks([b89a], False, 16, b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b89a], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n \n         self.log.info(\"Test a re-org of one week's worth of blocks (1088 blocks)\")\n "
      }
    ]
  },
  {
    "sha": "fa782a308dbe7bc579c122f63c1c65666fc85e91",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTc4MmEzMDhkYmU3YmM1NzljMTIyZjYzYzFjNjU2NjZmYzg1ZTkx",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-08-29T16:42:46Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-08-29T17:06:02Z"
      },
      "message": "qa: Use named args in some tests",
      "tree": {
        "sha": "b243c96fd5a847162757b293f9e08b0bc559bd74",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b243c96fd5a847162757b293f9e08b0bc559bd74"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa782a308dbe7bc579c122f63c1c65666fc85e91",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGcBAABCgAGBQJbhtJ6AAoJEM4rdWl+aaVI/7sL/0/lFRwXWyonhpdNrnfPAc4k\n/9BxKjeO108Cq+O9WEPzmp2ckZQDG+0yPsKCuBK3vQjaFDz/qDqN92b2oL78InmR\noPMBxr0tRKWDt1LZu3AadJQelEh+cn+Lf3H1kN/bLu/Hr3/5L1lQ8J2gfFwobXm5\nYSd5EuZCRc/tgSQASbag14h53y0eoPAhYYu4ZxaMLq/xH7nzayDGzEUtvZGpPSlA\nGz7hEFJ0XjfsB91FduiWBUhHVVKIospUTtlMdSgX+y03AsGun3x24jUuNKFkp7Za\n7ULS3zp1iw/UQxlIzGp1a/+LTSIKDr9HzgFfW+CYDZohYejmmLJlWfQSgHbj+VVj\nzhHfFj5Es3qL4VNywBhPRKkvYvUIzrLFplXE0IsdV+RgV4JihtiiQBDIgsxXBX+P\ncssEuYmF8oy/Ouh3uaPM+p7RNHLGIOlEUwXT/sPgWP7cSoADIUKQCoQZI+M7BbR+\ni/Ncz0b7zhzDoWc570kguo65zoZimDP74WjfhX9c2A==\n=zIDA\n-----END PGP SIGNATURE-----",
        "payload": "tree b243c96fd5a847162757b293f9e08b0bc559bd74\nparent b4d33096734d787b0e1d754064039cbb64ce8d61\nauthor MarcoFalke <falke.marco@gmail.com> 1535560966 -0400\ncommitter MarcoFalke <falke.marco@gmail.com> 1535562362 -0400\n\nqa: Use named args in some tests\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa782a308dbe7bc579c122f63c1c65666fc85e91",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa782a308dbe7bc579c122f63c1c65666fc85e91",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa782a308dbe7bc579c122f63c1c65666fc85e91/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b4d33096734d787b0e1d754064039cbb64ce8d61",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4d33096734d787b0e1d754064039cbb64ce8d61",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b4d33096734d787b0e1d754064039cbb64ce8d61"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 13,
      "deletions": 13
    },
    "files": [
      {
        "sha": "b675cd882f641b8447b3b9a8aba978e30aacff3c",
        "filename": "test/functional/mining_basic.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa782a308dbe7bc579c122f63c1c65666fc85e91/test/functional/mining_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa782a308dbe7bc579c122f63c1c65666fc85e91/test/functional/mining_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_basic.py?ref=fa782a308dbe7bc579c122f63c1c65666fc85e91",
        "patch": "@@ -188,7 +188,7 @@ def chain_tip(b_hash, *, status='headers-only', branchlen=1):\n         # Should ask for the block from a p2p node, if they announce the header as well:\n         node.add_p2p_connection(P2PDataStore())\n         node.p2p.wait_for_getheaders(timeout=5)  # Drop the first getheaders\n-        node.p2p.send_blocks_and_test(blocks=[block], rpc=node)\n+        node.p2p.send_blocks_and_test(blocks=[block], node=node)\n         # Must be active now:\n         assert chain_tip(block.hash, status='active', branchlen=0) in node.getchaintips()\n "
      },
      {
        "sha": "8036f65d81c4de65d152c7d4dca7219662dbe4a8",
        "filename": "test/functional/p2p_invalid_block.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa782a308dbe7bc579c122f63c1c65666fc85e91/test/functional/p2p_invalid_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa782a308dbe7bc579c122f63c1c65666fc85e91/test/functional/p2p_invalid_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_block.py?ref=fa782a308dbe7bc579c122f63c1c65666fc85e91",
        "patch": "@@ -42,7 +42,7 @@ def run_test(self):\n         # Save the coinbase for later\n         block1 = block\n         tip = block.sha256\n-        node.p2p.send_blocks_and_test([block1], node, True)\n+        node.p2p.send_blocks_and_test([block1], node, success=True)\n \n         self.log.info(\"Mature the block.\")\n         node.generate(100)\n@@ -79,7 +79,7 @@ def run_test(self):\n         assert_equal(orig_hash, block2.rehash())\n         assert(block2_orig.vtx != block2.vtx)\n \n-        node.p2p.send_blocks_and_test([block2], node, False, False, 16, b'bad-txns-duplicate')\n+        node.p2p.send_blocks_and_test([block2], node, success=False, request_block=False, reject_code=16, reject_reason=b'bad-txns-duplicate')\n \n         self.log.info(\"Test very broken block.\")\n \n@@ -92,7 +92,7 @@ def run_test(self):\n         block3.rehash()\n         block3.solve()\n \n-        node.p2p.send_blocks_and_test([block3], node, False, False, 16, b'bad-cb-amount')\n+        node.p2p.send_blocks_and_test([block3], node, success=False, request_block=False, reject_code=16, reject_reason=b'bad-cb-amount')\n \n if __name__ == '__main__':\n     InvalidBlockRequestTest().main()"
      },
      {
        "sha": "45dc2928d335ea449fb8faee3299897bff10fd6c",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa782a308dbe7bc579c122f63c1c65666fc85e91/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa782a308dbe7bc579c122f63c1c65666fc85e91/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=fa782a308dbe7bc579c122f63c1c65666fc85e91",
        "patch": "@@ -119,7 +119,7 @@ def get_virtual_size(witness_block):\n     vsize = int((3 * base_size + total_size + 3) / 4)\n     return vsize\n \n-def test_transaction_acceptance(rpc, p2p, tx, with_witness, accepted, reason=None):\n+def test_transaction_acceptance(node, p2p, tx, with_witness, accepted, reason=None):\n     \"\"\"Send a transaction to the node and check that it's accepted to the mempool\n \n     - Submit the transaction over the p2p interface\n@@ -129,13 +129,13 @@ def test_transaction_acceptance(rpc, p2p, tx, with_witness, accepted, reason=Non\n         tx_message = msg_witness_tx(tx)\n     p2p.send_message(tx_message)\n     p2p.sync_with_ping()\n-    assert_equal(tx.hash in rpc.getrawmempool(), accepted)\n+    assert_equal(tx.hash in node.getrawmempool(), accepted)\n     if (reason is not None and not accepted):\n         # Check the rejection reason as well.\n         with mininode_lock:\n             assert_equal(p2p.last_message[\"reject\"].reason, reason)\n \n-def test_witness_block(rpc, p2p, block, accepted, with_witness=True, reason=None):\n+def test_witness_block(node, p2p, block, accepted, with_witness=True, reason=None):\n     \"\"\"Send a block to the node and check that it's accepted\n \n     - Submit the block over the p2p interface\n@@ -145,7 +145,7 @@ def test_witness_block(rpc, p2p, block, accepted, with_witness=True, reason=None\n     else:\n         p2p.send_message(msg_block(block))\n     p2p.sync_with_ping()\n-    assert_equal(rpc.getbestblockhash() == block.hash, accepted)\n+    assert_equal(node.getbestblockhash() == block.hash, accepted)\n     if (reason is not None and not accepted):\n         # Check the rejection reason as well.\n         with mininode_lock:"
      },
      {
        "sha": "034e83aaae643ead1fb91a84531fd41265844ec1",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa782a308dbe7bc579c122f63c1c65666fc85e91/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa782a308dbe7bc579c122f63c1c65666fc85e91/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=fa782a308dbe7bc579c122f63c1c65666fc85e91",
        "patch": "@@ -482,7 +482,7 @@ def on_reject(self, message):\n         self.reject_code_received = message.code\n         self.reject_reason_received = message.reason\n \n-    def send_blocks_and_test(self, blocks, rpc, success=True, request_block=True, reject_code=None, reject_reason=None, timeout=60):\n+    def send_blocks_and_test(self, blocks, node, *, success=True, request_block=True, reject_code=None, reject_reason=None, timeout=60):\n         \"\"\"Send blocks to test node and test whether the tip advances.\n \n          - add all blocks to our block_store\n@@ -508,16 +508,16 @@ def send_blocks_and_test(self, blocks, rpc, success=True, request_block=True, re\n             wait_until(lambda: blocks[-1].sha256 in self.getdata_requests, timeout=timeout, lock=mininode_lock)\n \n         if success:\n-            wait_until(lambda: rpc.getbestblockhash() == blocks[-1].hash, timeout=timeout)\n+            wait_until(lambda: node.getbestblockhash() == blocks[-1].hash, timeout=timeout)\n         else:\n-            assert rpc.getbestblockhash() != blocks[-1].hash\n+            assert node.getbestblockhash() != blocks[-1].hash\n \n         if reject_code is not None:\n             wait_until(lambda: self.reject_code_received == reject_code, lock=mininode_lock)\n         if reject_reason is not None:\n             wait_until(lambda: self.reject_reason_received == reject_reason, lock=mininode_lock)\n \n-    def send_txs_and_test(self, txs, rpc, success=True, expect_disconnect=False, reject_code=None, reject_reason=None):\n+    def send_txs_and_test(self, txs, node, *, success=True, expect_disconnect=False, reject_code=None, reject_reason=None):\n         \"\"\"Send txs to test node and test whether they're accepted to the mempool.\n \n          - add all txs to our tx_store\n@@ -541,7 +541,7 @@ def send_txs_and_test(self, txs, rpc, success=True, expect_disconnect=False, rej\n         else:\n             self.sync_with_ping()\n \n-        raw_mempool = rpc.getrawmempool()\n+        raw_mempool = node.getrawmempool()\n         if success:\n             # Check that all txs are now in the mempool\n             for tx in txs:"
      }
    ]
  }
]