[
  {
    "sha": "114b5812f6283f2325fc31e186b26c6d76f9551a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMTRiNTgxMmY2MjgzZjIzMjVmYzMxZTE4NmIyNmM2ZDc2Zjk1NTFh",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-10-29T06:11:24Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-11-13T17:15:20Z"
      },
      "message": "Prevector type",
      "tree": {
        "sha": "6c04a7ee882b7d8a291bb9507ddd5cf17e23f704",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6c04a7ee882b7d8a291bb9507ddd5cf17e23f704"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/114b5812f6283f2325fc31e186b26c6d76f9551a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/114b5812f6283f2325fc31e186b26c6d76f9551a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/114b5812f6283f2325fc31e186b26c6d76f9551a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/114b5812f6283f2325fc31e186b26c6d76f9551a/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4f09b77c7fa50afc19d4458c9dd05219c82a298d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4f09b77c7fa50afc19d4458c9dd05219c82a298d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4f09b77c7fa50afc19d4458c9dd05219c82a298d"
      }
    ],
    "stats": {
      "total": 942,
      "additions": 874,
      "deletions": 68
    },
    "files": [
      {
        "sha": "1cec0d4d61fbe2085757b9e6aaffd15533660f98",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/114b5812f6283f2325fc31e186b26c6d76f9551a/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/114b5812f6283f2325fc31e186b26c6d76f9551a/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=114b5812f6283f2325fc31e186b26c6d76f9551a",
        "patch": "@@ -125,6 +125,7 @@ BITCOIN_CORE_H = \\\n   policy/fees.h \\\n   policy/policy.h \\\n   pow.h \\\n+  prevector.h \\\n   primitives/block.h \\\n   primitives/transaction.h \\\n   protocol.h \\"
      },
      {
        "sha": "bc0a26317416c48b2f521d6c1c5d5a3d3f9eeb6d",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/114b5812f6283f2325fc31e186b26c6d76f9551a/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/114b5812f6283f2325fc31e186b26c6d76f9551a/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=114b5812f6283f2325fc31e186b26c6d76f9551a",
        "patch": "@@ -64,6 +64,7 @@ BITCOIN_TESTS =\\\n   test/pmt_tests.cpp \\\n   test/policyestimator_tests.cpp \\\n   test/pow_tests.cpp \\\n+  test/prevector_tests.cpp \\\n   test/reverselock_tests.cpp \\\n   test/rpc_tests.cpp \\\n   test/sanity_tests.cpp \\"
      },
      {
        "sha": "450537d059c20580d6b7e512babdd9d1927cc4a5",
        "filename": "src/core_memusage.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/114b5812f6283f2325fc31e186b26c6d76f9551a/src/core_memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/114b5812f6283f2325fc31e186b26c6d76f9551a/src/core_memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_memusage.h?ref=114b5812f6283f2325fc31e186b26c6d76f9551a",
        "patch": "@@ -10,7 +10,7 @@\n #include \"memusage.h\"\n \n static inline size_t RecursiveDynamicUsage(const CScript& script) {\n-    return memusage::DynamicUsage(*static_cast<const std::vector<unsigned char>*>(&script));\n+    return memusage::DynamicUsage(*static_cast<const CScriptBase*>(&script));\n }\n \n static inline size_t RecursiveDynamicUsage(const COutPoint& out) {"
      },
      {
        "sha": "daa92a00970003be2d3e214cccaedd15102125c0",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/114b5812f6283f2325fc31e186b26c6d76f9551a/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/114b5812f6283f2325fc31e186b26c6d76f9551a/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=114b5812f6283f2325fc31e186b26c6d76f9551a",
        "patch": "@@ -8,6 +8,7 @@\n \n #include \"crypto/ripemd160.h\"\n #include \"crypto/sha256.h\"\n+#include \"prevector.h\"\n #include \"serialize.h\"\n #include \"uint256.h\"\n #include \"version.h\"\n@@ -118,6 +119,13 @@ inline uint160 Hash160(const std::vector<unsigned char>& vch)\n     return Hash160(vch.begin(), vch.end());\n }\n \n+/** Compute the 160-bit hash of a vector. */\n+template<unsigned int N>\n+inline uint160 Hash160(const prevector<N, unsigned char>& vch)\n+{\n+    return Hash160(vch.begin(), vch.end());\n+}\n+\n /** A writer stream (for serialization) that computes a 256-bit hash. */\n class CHashWriter\n {"
      },
      {
        "sha": "49760e64c78cd293a7720f036778a101aed042f9",
        "filename": "src/memusage.h",
        "status": "modified",
        "additions": 9,
        "deletions": 1,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/114b5812f6283f2325fc31e186b26c6d76f9551a/src/memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/114b5812f6283f2325fc31e186b26c6d76f9551a/src/memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/memusage.h?ref=114b5812f6283f2325fc31e186b26c6d76f9551a",
        "patch": "@@ -46,7 +46,9 @@ template<typename X> static inline size_t DynamicUsage(const X * const &v) { ret\n static inline size_t MallocUsage(size_t alloc)\n {\n     // Measured on libc6 2.19 on Linux.\n-    if (sizeof(void*) == 8) {\n+    if (alloc == 0) {\n+        return 0;\n+    } else if (sizeof(void*) == 8) {\n         return ((alloc + 31) >> 4) << 4;\n     } else if (sizeof(void*) == 4) {\n         return ((alloc + 15) >> 3) << 3;\n@@ -74,6 +76,12 @@ static inline size_t DynamicUsage(const std::vector<X>& v)\n     return MallocUsage(v.capacity() * sizeof(X));\n }\n \n+template<unsigned int N, typename X, typename S, typename D>\n+static inline size_t DynamicUsage(const prevector<N, X, S, D>& v)\n+{\n+    return MallocUsage(v.allocated_memory());\n+}\n+\n template<typename X, typename Y>\n static inline size_t DynamicUsage(const std::set<X, Y>& s)\n {"
      },
      {
        "sha": "3e80ef5d336458807903451403c9aec463fc90c5",
        "filename": "src/prevector.h",
        "status": "added",
        "additions": 486,
        "deletions": 0,
        "changes": 486,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/114b5812f6283f2325fc31e186b26c6d76f9551a/src/prevector.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/114b5812f6283f2325fc31e186b26c6d76f9551a/src/prevector.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/prevector.h?ref=114b5812f6283f2325fc31e186b26c6d76f9551a",
        "patch": "@@ -0,0 +1,486 @@\n+#ifndef _BITCOIN_PREVECTOR_H_\n+#define _BITCOIN_PREVECTOR_H_\n+\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <string.h>\n+\n+#include <iterator>\n+\n+#pragma pack(push, 1)\n+/** Implements a drop-in replacement for std::vector<T> which stores up to N\n+ *  elements directly (without heap allocation). The types Size and Diff are\n+ *  used to store element counts, and can be any unsigned + signed type.\n+ *\n+ *  Storage layout is either:\n+ *  - Direct allocation:\n+ *    - Size _size: the number of used elements (between 0 and N)\n+ *    - T direct[N]: an array of N elements of type T\n+ *      (only the first _size are initialized).\n+ *  - Indirect allocation:\n+ *    - Size _size: the number of used elements plus N + 1\n+ *    - Size capacity: the number of allocated elements\n+ *    - T* indirect: a pointer to an array of capacity elements of type T\n+ *      (only the first _size are initialized).\n+ *\n+ *  The data type T must be movable by memmove/realloc(). Once we switch to C++,\n+ *  move constructors can be used instead.\n+ */\n+template<unsigned int N, typename T, typename Size = uint32_t, typename Diff = int32_t>\n+class prevector {\n+public:\n+    typedef Size size_type;\n+    typedef Diff difference_type;\n+    typedef T value_type;\n+    typedef value_type& reference;\n+    typedef const value_type& const_reference;\n+    typedef value_type* pointer;\n+    typedef const value_type* const_pointer;\n+\n+    class iterator {\n+        T* ptr;\n+    public:\n+        typedef Diff difference_type;\n+        typedef T value_type;\n+        typedef T* pointer;\n+        typedef T& reference;\n+        typedef std::random_access_iterator_tag iterator_category;\n+        iterator(T* ptr_) : ptr(ptr_) {}\n+        T& operator*() const { return *ptr; }\n+        T* operator->() const { return ptr; }\n+        T& operator[](size_type pos) { return ptr[pos]; }\n+        const T& operator[](size_type pos) const { return ptr[pos]; }\n+        iterator& operator++() { ptr++; return *this; }\n+        iterator& operator--() { ptr--; return *this; }\n+        iterator operator++(int) { iterator copy(*this); ++(*this); return copy; }\n+        iterator operator--(int) { iterator copy(*this); --(*this); return copy; }\n+        difference_type friend operator-(iterator a, iterator b) { return (&(*a) - &(*b)); }\n+        iterator operator+(size_type n) { return iterator(ptr + n); }\n+        iterator& operator+=(size_type n) { ptr += n; return *this; }\n+        iterator operator-(size_type n) { return iterator(ptr - n); }\n+        iterator& operator-=(size_type n) { ptr -= n; return *this; }\n+        bool operator==(iterator x) const { return ptr == x.ptr; }\n+        bool operator!=(iterator x) const { return ptr != x.ptr; }\n+        bool operator>=(iterator x) const { return ptr >= x.ptr; }\n+        bool operator<=(iterator x) const { return ptr <= x.ptr; }\n+        bool operator>(iterator x) const { return ptr > x.ptr; }\n+        bool operator<(iterator x) const { return ptr < x.ptr; }\n+    };\n+\n+    class reverse_iterator {\n+        T* ptr;\n+    public:\n+        typedef Diff difference_type;\n+        typedef T value_type;\n+        typedef T* pointer;\n+        typedef T& reference;\n+        typedef std::bidirectional_iterator_tag iterator_category;\n+        reverse_iterator(T* ptr_) : ptr(ptr_) {}\n+        T& operator*() { return *ptr; }\n+        const T& operator*() const { return *ptr; }\n+        T* operator->() { return ptr; }\n+        const T* operator->() const { return ptr; }\n+        reverse_iterator& operator--() { ptr++; return *this; }\n+        reverse_iterator& operator++() { ptr--; return *this; }\n+        reverse_iterator operator++(int) { reverse_iterator copy(*this); ++(*this); return copy; }\n+        reverse_iterator operator--(int) { reverse_iterator copy(*this); --(*this); return copy; }\n+        bool operator==(reverse_iterator x) const { return ptr == x.ptr; }\n+        bool operator!=(reverse_iterator x) const { return ptr != x.ptr; }\n+    };\n+\n+    class const_iterator {\n+        const T* ptr;\n+    public:\n+        typedef Diff difference_type;\n+        typedef const T value_type;\n+        typedef const T* pointer;\n+        typedef const T& reference;\n+        typedef std::random_access_iterator_tag iterator_category;\n+        const_iterator(const T* ptr_) : ptr(ptr_) {}\n+        const_iterator(iterator x) : ptr(&(*x)) {}\n+        const T& operator*() const { return *ptr; }\n+        const T* operator->() const { return ptr; }\n+        const T& operator[](size_type pos) const { return ptr[pos]; }\n+        const_iterator& operator++() { ptr++; return *this; }\n+        const_iterator& operator--() { ptr--; return *this; }\n+        const_iterator operator++(int) { const_iterator copy(*this); ++(*this); return copy; }\n+        const_iterator operator--(int) { const_iterator copy(*this); --(*this); return copy; }\n+        difference_type friend operator-(const_iterator a, const_iterator b) { return (&(*a) - &(*b)); }\n+        const_iterator operator+(size_type n) { return const_iterator(ptr + n); }\n+        const_iterator& operator+=(size_type n) { ptr += n; return *this; }\n+        const_iterator operator-(size_type n) { return const_iterator(ptr - n); }\n+        const_iterator& operator-=(size_type n) { ptr -= n; return *this; }\n+        bool operator==(const_iterator x) const { return ptr == x.ptr; }\n+        bool operator!=(const_iterator x) const { return ptr != x.ptr; }\n+        bool operator>=(const_iterator x) const { return ptr >= x.ptr; }\n+        bool operator<=(const_iterator x) const { return ptr <= x.ptr; }\n+        bool operator>(const_iterator x) const { return ptr > x.ptr; }\n+        bool operator<(const_iterator x) const { return ptr < x.ptr; }\n+    };\n+\n+    class const_reverse_iterator {\n+        const T* ptr;\n+    public:\n+        typedef Diff difference_type;\n+        typedef const T value_type;\n+        typedef const T* pointer;\n+        typedef const T& reference;\n+        typedef std::bidirectional_iterator_tag iterator_category;\n+        const_reverse_iterator(T* ptr_) : ptr(ptr_) {}\n+        const_reverse_iterator(reverse_iterator x) : ptr(&(*x)) {}\n+        const T& operator*() const { return *ptr; }\n+        const T* operator->() const { return ptr; }\n+        const_reverse_iterator& operator--() { ptr++; return *this; }\n+        const_reverse_iterator& operator++() { ptr--; return *this; }\n+        const_reverse_iterator operator++(int) { const_reverse_iterator copy(*this); ++(*this); return copy; }\n+        const_reverse_iterator operator--(int) { const_reverse_iterator copy(*this); --(*this); return copy; }\n+        bool operator==(const_reverse_iterator x) const { return ptr == x.ptr; }\n+        bool operator!=(const_reverse_iterator x) const { return ptr != x.ptr; }\n+    };\n+\n+private:\n+    size_type _size;\n+    union {\n+        char direct[sizeof(T) * N];\n+        struct {\n+            size_type capacity;\n+            char* indirect;\n+        };\n+    } _union;\n+\n+    T* direct_ptr(difference_type pos) { return reinterpret_cast<T*>(_union.direct) + pos; }\n+    const T* direct_ptr(difference_type pos) const { return reinterpret_cast<const T*>(_union.direct) + pos; }\n+    T* indirect_ptr(difference_type pos) { return reinterpret_cast<T*>(_union.indirect) + pos; }\n+    const T* indirect_ptr(difference_type pos) const { return reinterpret_cast<const T*>(_union.indirect) + pos; }\n+    bool is_direct() const { return _size <= N; }\n+\n+    void change_capacity(size_type new_capacity) {\n+        if (new_capacity <= N) {\n+            if (!is_direct()) {\n+                T* indirect = indirect_ptr(0);\n+                T* src = indirect;\n+                T* dst = direct_ptr(0);\n+                memcpy(dst, src, size() * sizeof(T));\n+                free(indirect);\n+                _size -= N + 1;\n+            }\n+        } else {\n+            if (!is_direct()) {\n+                _union.indirect = static_cast<char*>(realloc(_union.indirect, ((size_t)sizeof(T)) * new_capacity));\n+                _union.capacity = new_capacity;\n+            } else {\n+                char* new_indirect = static_cast<char*>(malloc(((size_t)sizeof(T)) * new_capacity));\n+                T* src = direct_ptr(0);\n+                T* dst = reinterpret_cast<T*>(new_indirect);\n+                memcpy(dst, src, size() * sizeof(T));\n+                _union.indirect = new_indirect;\n+                _union.capacity = new_capacity;\n+                _size += N + 1;\n+            }\n+        }\n+    }\n+\n+    T* item_ptr(difference_type pos) { return is_direct() ? direct_ptr(pos) : indirect_ptr(pos); }\n+    const T* item_ptr(difference_type pos) const { return is_direct() ? direct_ptr(pos) : indirect_ptr(pos); }\n+\n+public:\n+    void assign(size_type n, const T& val) {\n+        clear();\n+        if (capacity() < n) {\n+            change_capacity(n);\n+        }\n+        while (size() < n) {\n+            _size++;\n+            new(static_cast<void*>(item_ptr(size() - 1))) T(val);\n+        }\n+    }\n+\n+    template<typename InputIterator>\n+    void assign(InputIterator first, InputIterator last) {\n+        size_type n = last - first;\n+        clear();\n+        if (capacity() < n) {\n+            change_capacity(n);\n+        }\n+        while (first != last) {\n+            _size++;\n+            new(static_cast<void*>(item_ptr(size() - 1))) T(*first);\n+            ++first;\n+        }\n+    }\n+\n+    prevector() : _size(0) {}\n+\n+    explicit prevector(size_type n) : _size(0) {\n+        resize(n);\n+    }\n+\n+    explicit prevector(size_type n, const T& val = T()) : _size(0) {\n+        change_capacity(n);\n+        while (size() < n) {\n+            _size++;\n+            new(static_cast<void*>(item_ptr(size() - 1))) T(val);\n+        }\n+    }\n+\n+    template<typename InputIterator>\n+    prevector(InputIterator first, InputIterator last) : _size(0) {\n+        size_type n = last - first;\n+        change_capacity(n);\n+        while (first != last) {\n+            _size++;\n+            new(static_cast<void*>(item_ptr(size() - 1))) T(*first);\n+            ++first;\n+        }\n+    }\n+\n+    prevector(const prevector<N, T, Size, Diff>& other) : _size(0) {\n+        change_capacity(other.size());\n+        const_iterator it = other.begin();\n+        while (it != other.end()) {\n+            _size++;\n+            new(static_cast<void*>(item_ptr(size() - 1))) T(*it);\n+            ++it;\n+        }\n+    }\n+\n+    prevector& operator=(const prevector<N, T, Size, Diff>& other) {\n+        if (&other == this) {\n+            return *this;\n+        }\n+        resize(0);\n+        change_capacity(other.size());\n+        const_iterator it = other.begin();\n+        while (it != other.end()) {\n+            _size++;\n+            new(static_cast<void*>(item_ptr(size() - 1))) T(*it);\n+            ++it;\n+        }\n+        return *this;\n+    }\n+\n+    size_type size() const {\n+        return is_direct() ? _size : _size - N - 1;\n+    }\n+\n+    bool empty() const {\n+        return size() == 0;\n+    }\n+\n+    iterator begin() { return iterator(item_ptr(0)); }\n+    const_iterator begin() const { return const_iterator(item_ptr(0)); }\n+    iterator end() { return iterator(item_ptr(size())); }\n+    const_iterator end() const { return const_iterator(item_ptr(size())); }\n+\n+    reverse_iterator rbegin() { return reverse_iterator(item_ptr(size() - 1)); }\n+    const_reverse_iterator rbegin() const { return const_reverse_iterator(item_ptr(size() - 1)); }\n+    reverse_iterator rend() { return reverse_iterator(item_ptr(-1)); }\n+    const_reverse_iterator rend() const { return const_reverse_iterator(item_ptr(-1)); }\n+\n+    size_t capacity() const {\n+        if (is_direct()) {\n+            return N;\n+        } else {\n+            return _union.capacity;\n+        }\n+    }\n+\n+    T& operator[](size_type pos) {\n+        return *item_ptr(pos);\n+    }\n+\n+    const T& operator[](size_type pos) const {\n+        return *item_ptr(pos);\n+    }\n+\n+    void resize(size_type new_size) {\n+        while (size() > new_size) {\n+            item_ptr(size() - 1)->~T();\n+            _size--;\n+        }\n+        if (new_size > capacity()) {\n+            change_capacity(new_size);\n+        }\n+        while (size() < new_size) {\n+            _size++;\n+            new(static_cast<void*>(item_ptr(size() - 1))) T();\n+        }\n+    }\n+\n+    void reserve(size_type new_capacity) {\n+        if (new_capacity > capacity()) {\n+            change_capacity(new_capacity);\n+        }\n+    }\n+\n+    void shrink_to_fit() {\n+        change_capacity(size());\n+    }\n+\n+    void clear() {\n+        resize(0);\n+    }\n+\n+    iterator insert(iterator pos, const T& value) {\n+        size_type p = pos - begin();\n+        size_type new_size = size() + 1;\n+        if (capacity() < new_size) {\n+            change_capacity(new_size + (new_size >> 1));\n+        }\n+        memmove(item_ptr(p + 1), item_ptr(p), (size() - p) * sizeof(T));\n+        _size++;\n+        new(static_cast<void*>(item_ptr(p))) T(value);\n+        return iterator(item_ptr(p));\n+    }\n+\n+    void insert(iterator pos, size_type count, const T& value) {\n+        size_type p = pos - begin();\n+        size_type new_size = size() + count;\n+        if (capacity() < new_size) {\n+            change_capacity(new_size + (new_size >> 1));\n+        }\n+        memmove(item_ptr(p + count), item_ptr(p), (size() - p) * sizeof(T));\n+        _size += count;\n+        for (size_type i = 0; i < count; i++) {\n+            new(static_cast<void*>(item_ptr(p + i))) T(value);\n+        }\n+    }\n+\n+    template<typename InputIterator>\n+    void insert(iterator pos, InputIterator first, InputIterator last) {\n+        size_type p = pos - begin();\n+        difference_type count = last - first;\n+        size_type new_size = size() + count;\n+        if (capacity() < new_size) {\n+            change_capacity(new_size + (new_size >> 1));\n+        }\n+        memmove(item_ptr(p + count), item_ptr(p), (size() - p) * sizeof(T));\n+        _size += count;\n+        while (first != last) {\n+            new(static_cast<void*>(item_ptr(p))) T(*first);\n+            ++p;\n+            ++first;\n+        }\n+    }\n+\n+    iterator erase(iterator pos) {\n+        (*pos).~T();\n+        memmove(&(*pos), &(*pos) + 1, ((char*)&(*end())) - ((char*)(1 + &(*pos))));\n+        _size--;\n+        return pos;\n+    }\n+\n+    iterator erase(iterator first, iterator last) {\n+        iterator p = first;\n+        char* endp = (char*)&(*end());\n+        while (p != last) {\n+            (*p).~T();\n+            _size--;\n+            ++p;\n+        }\n+        memmove(&(*first), &(*last), endp - ((char*)(&(*last))));\n+        return first;\n+    }\n+\n+    void push_back(const T& value) {\n+        size_type new_size = size() + 1;\n+        if (capacity() < new_size) {\n+            change_capacity(new_size + (new_size >> 1));\n+        }\n+        new(item_ptr(size())) T(value);\n+        _size++;\n+    }\n+\n+    void pop_back() {\n+        _size--;\n+    }\n+\n+    T& front() {\n+        return *item_ptr(0);\n+    }\n+\n+    const T& front() const {\n+        return *item_ptr(0);\n+    }\n+\n+    T& back() {\n+        return *item_ptr(size() - 1);\n+    }\n+\n+    const T& back() const {\n+        return *item_ptr(size() - 1);\n+    }\n+\n+    void swap(prevector<N, T, Size, Diff>& other) {\n+        if (_size & other._size & 1) {\n+            std::swap(_union.capacity, other._union.capacity);\n+            std::swap(_union.indirect, other._union.indirect);\n+        } else {\n+            std::swap(_union, other._union);\n+        }\n+        std::swap(_size, other._size);\n+    }\n+\n+    ~prevector() {\n+        clear();\n+        if (!is_direct()) {\n+            free(_union.indirect);\n+            _union.indirect = NULL;\n+        }\n+    }\n+\n+    bool operator==(const prevector<N, T, Size, Diff>& other) const {\n+        if (other.size() != size()) {\n+            return false;\n+        }\n+        const_iterator b1 = begin();\n+        const_iterator b2 = other.begin();\n+        const_iterator e1 = end();\n+        while (b1 != e1) {\n+            if ((*b1) != (*b2)) {\n+                return false;\n+            }\n+            ++b1;\n+            ++b2;\n+        }\n+        return true;\n+    }\n+\n+    bool operator!=(const prevector<N, T, Size, Diff>& other) const {\n+        return !(*this == other);\n+    }\n+\n+    bool operator<(const prevector<N, T, Size, Diff>& other) const {\n+        if (size() < other.size()) {\n+            return true;\n+        }\n+        if (size() > other.size()) {\n+            return false;\n+        }\n+        const_iterator b1 = begin();\n+        const_iterator b2 = other.begin();\n+        const_iterator e1 = end();\n+        while (b1 != e1) {\n+            if ((*b1) < (*b2)) {\n+                return true;\n+            }\n+            if ((*b2) < (*b1)) {\n+                return false;\n+            }\n+            ++b1;\n+            ++b2;\n+        }\n+        return false;\n+    }\n+\n+    size_t allocated_memory() const {\n+        if (is_direct()) {\n+            return 0;\n+        } else {\n+            return ((size_t)(sizeof(T))) * _union.capacity;\n+        }\n+    }\n+};\n+#pragma pack(pop)\n+\n+#endif"
      },
      {
        "sha": "c5d8a64a6d6ab91f9994b6497473392013f7bc53",
        "filename": "src/primitives/transaction.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/114b5812f6283f2325fc31e186b26c6d76f9551a/src/primitives/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/114b5812f6283f2325fc31e186b26c6d76f9551a/src/primitives/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.h?ref=114b5812f6283f2325fc31e186b26c6d76f9551a",
        "patch": "@@ -74,7 +74,7 @@ class CTxIn\n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n         READWRITE(prevout);\n-        READWRITE(scriptSig);\n+        READWRITE(*(CScriptBase*)(&scriptSig));\n         READWRITE(nSequence);\n     }\n \n@@ -119,7 +119,7 @@ class CTxOut\n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n         READWRITE(nValue);\n-        READWRITE(scriptPubKey);\n+        READWRITE(*(CScriptBase*)(&scriptPubKey));\n     }\n \n     void SetNull()"
      },
      {
        "sha": "f7eae3d79c1a70db008fcd0d5ef9eaca6bd5d7eb",
        "filename": "src/qt/paymentrequestplus.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/114b5812f6283f2325fc31e186b26c6d76f9551a/src/qt/paymentrequestplus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/114b5812f6283f2325fc31e186b26c6d76f9551a/src/qt/paymentrequestplus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentrequestplus.cpp?ref=114b5812f6283f2325fc31e186b26c6d76f9551a",
        "patch": "@@ -201,7 +201,7 @@ QList<std::pair<CScript,CAmount> > PaymentRequestPlus::getPayTo() const\n         const unsigned char* scriptStr = (const unsigned char*)details.outputs(i).script().data();\n         CScript s(scriptStr, scriptStr+details.outputs(i).script().size());\n \n-        result.append(make_pair(s, details.outputs(i).amount()));\n+        result.append(std::make_pair(s, details.outputs(i).amount()));\n     }\n     return result;\n }"
      },
      {
        "sha": "e0853fef4e7cde88c8aab863bb4e1c5de77513c3",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/114b5812f6283f2325fc31e186b26c6d76f9551a/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/114b5812f6283f2325fc31e186b26c6d76f9551a/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=114b5812f6283f2325fc31e186b26c6d76f9551a",
        "patch": "@@ -1032,7 +1032,7 @@ class CTransactionSignatureSerializer {\n         // Serialize the script\n         if (nInput != nIn)\n             // Blank out other inputs' signatures\n-            ::Serialize(s, CScript(), nType, nVersion);\n+            ::Serialize(s, CScriptBase(), nType, nVersion);\n         else\n             SerializeScriptCode(s, nType, nVersion);\n         // Serialize the nSequence"
      },
      {
        "sha": "9c77ed9fc19dbf67766513a2fe89fcc1c7e5ceed",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/114b5812f6283f2325fc31e186b26c6d76f9551a/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/114b5812f6283f2325fc31e186b26c6d76f9551a/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=114b5812f6283f2325fc31e186b26c6d76f9551a",
        "patch": "@@ -205,9 +205,9 @@ bool CScript::IsPayToScriptHash() const\n {\n     // Extra-fast test for pay-to-script-hash CScripts:\n     return (this->size() == 23 &&\n-            this->at(0) == OP_HASH160 &&\n-            this->at(1) == 0x14 &&\n-            this->at(22) == OP_EQUAL);\n+            (*this)[0] == OP_HASH160 &&\n+            (*this)[1] == 0x14 &&\n+            (*this)[22] == OP_EQUAL);\n }\n \n bool CScript::IsPushOnly(const_iterator pc) const"
      },
      {
        "sha": "3650957fc9bfff678aea994dadcb37a0705a8576",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 9,
        "deletions": 5,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/114b5812f6283f2325fc31e186b26c6d76f9551a/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/114b5812f6283f2325fc31e186b26c6d76f9551a/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=114b5812f6283f2325fc31e186b26c6d76f9551a",
        "patch": "@@ -7,6 +7,7 @@\n #define BITCOIN_SCRIPT_SCRIPT_H\n \n #include \"crypto/common.h\"\n+#include \"prevector.h\"\n \n #include <assert.h>\n #include <climits>\n@@ -354,8 +355,10 @@ class CScriptNum\n     int64_t m_value;\n };\n \n+typedef prevector<28, unsigned char> CScriptBase;\n+\n /** Serialized script, used inside transaction inputs and outputs */\n-class CScript : public std::vector<unsigned char>\n+class CScript : public CScriptBase\n {\n protected:\n     CScript& push_int64(int64_t n)\n@@ -376,9 +379,10 @@ class CScript : public std::vector<unsigned char>\n     }\n public:\n     CScript() { }\n-    CScript(const CScript& b) : std::vector<unsigned char>(b.begin(), b.end()) { }\n-    CScript(const_iterator pbegin, const_iterator pend) : std::vector<unsigned char>(pbegin, pend) { }\n-    CScript(const unsigned char* pbegin, const unsigned char* pend) : std::vector<unsigned char>(pbegin, pend) { }\n+    CScript(const CScript& b) : CScriptBase(b.begin(), b.end()) { }\n+    CScript(const_iterator pbegin, const_iterator pend) : CScriptBase(pbegin, pend) { }\n+    CScript(std::vector<unsigned char>::const_iterator pbegin, std::vector<unsigned char>::const_iterator pend) : CScriptBase(pbegin, pend) { }\n+    CScript(const unsigned char* pbegin, const unsigned char* pend) : CScriptBase(pbegin, pend) { }\n \n     CScript& operator+=(const CScript& b)\n     {\n@@ -611,7 +615,7 @@ class CScript : public std::vector<unsigned char>\n     void clear()\n     {\n         // The default std::vector::clear() does not release memory.\n-        std::vector<unsigned char>().swap(*this);\n+        CScriptBase().swap(*this);\n     }\n };\n "
      },
      {
        "sha": "90f557fc608726aeabb6ea82a985a9a643e8d0f3",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/114b5812f6283f2325fc31e186b26c6d76f9551a/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/114b5812f6283f2325fc31e186b26c6d76f9551a/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=114b5812f6283f2325fc31e186b26c6d76f9551a",
        "patch": "@@ -16,7 +16,7 @@\n \n using namespace std;\n \n-typedef vector<unsigned char> valtype;\n+typedef std::vector<unsigned char> valtype;\n \n TransactionSignatureCreator::TransactionSignatureCreator(const CKeyStore* keystoreIn, const CTransaction* txToIn, unsigned int nInIn, int nHashTypeIn) : BaseSignatureCreator(keystoreIn), txTo(txToIn), nIn(nInIn), nHashType(nHashTypeIn), checker(txTo, nIn) {}\n \n@@ -118,7 +118,7 @@ bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& fromPu\n         bool fSolved =\n             SignStep(creator, subscript, scriptSig, subType) && subType != TX_SCRIPTHASH;\n         // Append serialized subscript whether or not it is completely signed:\n-        scriptSig << static_cast<valtype>(subscript);\n+        scriptSig << valtype(subscript.begin(), subscript.end());\n         if (!fSolved) return false;\n     }\n "
      },
      {
        "sha": "5fe7fc1f3583cb83369b1cd5e36fa2baf2f8eb2a",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 119,
        "deletions": 38,
        "changes": 157,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/114b5812f6283f2325fc31e186b26c6d76f9551a/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/114b5812f6283f2325fc31e186b26c6d76f9551a/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=114b5812f6283f2325fc31e186b26c6d76f9551a",
        "patch": "@@ -20,7 +20,7 @@\n #include <utility>\n #include <vector>\n \n-class CScript;\n+#include \"prevector.h\"\n \n static const unsigned int MAX_SIZE = 0x02000000;\n \n@@ -49,26 +49,26 @@ inline T* NCONST_PTR(const T* val)\n  * @note These functions avoid the undefined case of indexing into an empty\n  * vector, as well as that of indexing after the end of the vector.\n  */\n-template <class T, class TAl>\n-inline T* begin_ptr(std::vector<T,TAl>& v)\n+template <typename V>\n+inline typename V::value_type* begin_ptr(V& v)\n {\n     return v.empty() ? NULL : &v[0];\n }\n /** Get begin pointer of vector (const version) */\n-template <class T, class TAl>\n-inline const T* begin_ptr(const std::vector<T,TAl>& v)\n+template <typename V>\n+inline const typename V::value_type* begin_ptr(const V& v)\n {\n     return v.empty() ? NULL : &v[0];\n }\n /** Get end pointer of vector (non-const version) */\n-template <class T, class TAl>\n-inline T* end_ptr(std::vector<T,TAl>& v)\n+template <typename V>\n+inline typename V::value_type* end_ptr(V& v)\n {\n     return v.empty() ? NULL : (&v[0] + v.size());\n }\n /** Get end pointer of vector (const version) */\n-template <class T, class TAl>\n-inline const T* end_ptr(const std::vector<T,TAl>& v)\n+template <typename V>\n+inline const typename V::value_type* end_ptr(const V& v)\n {\n     return v.empty() ? NULL : (&v[0] + v.size());\n }\n@@ -391,6 +391,12 @@ class CFlatData\n         pbegin = (char*)begin_ptr(v);\n         pend = (char*)end_ptr(v);\n     }\n+    template <unsigned int N, typename T, typename S, typename D>\n+    explicit CFlatData(prevector<N, T, S, D> &v)\n+    {\n+        pbegin = (char*)begin_ptr(v);\n+        pend = (char*)end_ptr(v);\n+    }\n     char* begin() { return pbegin; }\n     const char* begin() const { return pbegin; }\n     char* end() { return pend; }\n@@ -485,6 +491,20 @@ template<typename C> unsigned int GetSerializeSize(const std::basic_string<C>& s\n template<typename Stream, typename C> void Serialize(Stream& os, const std::basic_string<C>& str, int, int=0);\n template<typename Stream, typename C> void Unserialize(Stream& is, std::basic_string<C>& str, int, int=0);\n \n+/**\n+ * prevector\n+ * prevectors of unsigned char are a special case and are intended to be serialized as a single opaque blob.\n+ */\n+template<unsigned int N, typename T> unsigned int GetSerializeSize_impl(const prevector<N, T>& v, int nType, int nVersion, const unsigned char&);\n+template<unsigned int N, typename T, typename V> unsigned int GetSerializeSize_impl(const prevector<N, T>& v, int nType, int nVersion, const V&);\n+template<unsigned int N, typename T> inline unsigned int GetSerializeSize(const prevector<N, T>& v, int nType, int nVersion);\n+template<typename Stream, unsigned int N, typename T> void Serialize_impl(Stream& os, const prevector<N, T>& v, int nType, int nVersion, const unsigned char&);\n+template<typename Stream, unsigned int N, typename T, typename V> void Serialize_impl(Stream& os, const prevector<N, T>& v, int nType, int nVersion, const V&);\n+template<typename Stream, unsigned int N, typename T> inline void Serialize(Stream& os, const prevector<N, T>& v, int nType, int nVersion);\n+template<typename Stream, unsigned int N, typename T> void Unserialize_impl(Stream& is, prevector<N, T>& v, int nType, int nVersion, const unsigned char&);\n+template<typename Stream, unsigned int N, typename T, typename V> void Unserialize_impl(Stream& is, prevector<N, T>& v, int nType, int nVersion, const V&);\n+template<typename Stream, unsigned int N, typename T> inline void Unserialize(Stream& is, prevector<N, T>& v, int nType, int nVersion);\n+\n /**\n  * vector\n  * vectors of unsigned char are a special case and are intended to be serialized as a single opaque blob.\n@@ -499,13 +519,6 @@ template<typename Stream, typename T, typename A> void Unserialize_impl(Stream&\n template<typename Stream, typename T, typename A, typename V> void Unserialize_impl(Stream& is, std::vector<T, A>& v, int nType, int nVersion, const V&);\n template<typename Stream, typename T, typename A> inline void Unserialize(Stream& is, std::vector<T, A>& v, int nType, int nVersion);\n \n-/**\n- * others derived from vector\n- */\n-extern inline unsigned int GetSerializeSize(const CScript& v, int nType, int nVersion);\n-template<typename Stream> void Serialize(Stream& os, const CScript& v, int nType, int nVersion);\n-template<typename Stream> void Unserialize(Stream& is, CScript& v, int nType, int nVersion);\n-\n /**\n  * pair\n  */\n@@ -587,6 +600,96 @@ void Unserialize(Stream& is, std::basic_string<C>& str, int, int)\n \n \n \n+/**\n+ * prevector\n+ */\n+template<unsigned int N, typename T>\n+unsigned int GetSerializeSize_impl(const prevector<N, T>& v, int nType, int nVersion, const unsigned char&)\n+{\n+    return (GetSizeOfCompactSize(v.size()) + v.size() * sizeof(T));\n+}\n+\n+template<unsigned int N, typename T, typename V>\n+unsigned int GetSerializeSize_impl(const prevector<N, T>& v, int nType, int nVersion, const V&)\n+{\n+    unsigned int nSize = GetSizeOfCompactSize(v.size());\n+    for (typename prevector<N, T>::const_iterator vi = v.begin(); vi != v.end(); ++vi)\n+        nSize += GetSerializeSize((*vi), nType, nVersion);\n+    return nSize;\n+}\n+\n+template<unsigned int N, typename T>\n+inline unsigned int GetSerializeSize(const prevector<N, T>& v, int nType, int nVersion)\n+{\n+    return GetSerializeSize_impl(v, nType, nVersion, T());\n+}\n+\n+\n+template<typename Stream, unsigned int N, typename T>\n+void Serialize_impl(Stream& os, const prevector<N, T>& v, int nType, int nVersion, const unsigned char&)\n+{\n+    WriteCompactSize(os, v.size());\n+    if (!v.empty())\n+        os.write((char*)&v[0], v.size() * sizeof(T));\n+}\n+\n+template<typename Stream, unsigned int N, typename T, typename V>\n+void Serialize_impl(Stream& os, const prevector<N, T>& v, int nType, int nVersion, const V&)\n+{\n+    WriteCompactSize(os, v.size());\n+    for (typename prevector<N, T>::const_iterator vi = v.begin(); vi != v.end(); ++vi)\n+        ::Serialize(os, (*vi), nType, nVersion);\n+}\n+\n+template<typename Stream, unsigned int N, typename T>\n+inline void Serialize(Stream& os, const prevector<N, T>& v, int nType, int nVersion)\n+{\n+    Serialize_impl(os, v, nType, nVersion, T());\n+}\n+\n+\n+template<typename Stream, unsigned int N, typename T>\n+void Unserialize_impl(Stream& is, prevector<N, T>& v, int nType, int nVersion, const unsigned char&)\n+{\n+    // Limit size per read so bogus size value won't cause out of memory\n+    v.clear();\n+    unsigned int nSize = ReadCompactSize(is);\n+    unsigned int i = 0;\n+    while (i < nSize)\n+    {\n+        unsigned int blk = std::min(nSize - i, (unsigned int)(1 + 4999999 / sizeof(T)));\n+        v.resize(i + blk);\n+        is.read((char*)&v[i], blk * sizeof(T));\n+        i += blk;\n+    }\n+}\n+\n+template<typename Stream, unsigned int N, typename T, typename V>\n+void Unserialize_impl(Stream& is, prevector<N, T>& v, int nType, int nVersion, const V&)\n+{\n+    v.clear();\n+    unsigned int nSize = ReadCompactSize(is);\n+    unsigned int i = 0;\n+    unsigned int nMid = 0;\n+    while (nMid < nSize)\n+    {\n+        nMid += 5000000 / sizeof(T);\n+        if (nMid > nSize)\n+            nMid = nSize;\n+        v.resize(nMid);\n+        for (; i < nMid; i++)\n+            Unserialize(is, v[i], nType, nVersion);\n+    }\n+}\n+\n+template<typename Stream, unsigned int N, typename T>\n+inline void Unserialize(Stream& is, prevector<N, T>& v, int nType, int nVersion)\n+{\n+    Unserialize_impl(is, v, nType, nVersion, T());\n+}\n+\n+\n+\n /**\n  * vector\n  */\n@@ -677,28 +780,6 @@ inline void Unserialize(Stream& is, std::vector<T, A>& v, int nType, int nVersio\n \n \n \n-/**\n- * others derived from vector\n- */\n-inline unsigned int GetSerializeSize(const CScript& v, int nType, int nVersion)\n-{\n-    return GetSerializeSize((const std::vector<unsigned char>&)v, nType, nVersion);\n-}\n-\n-template<typename Stream>\n-void Serialize(Stream& os, const CScript& v, int nType, int nVersion)\n-{\n-    Serialize(os, (const std::vector<unsigned char>&)v, nType, nVersion);\n-}\n-\n-template<typename Stream>\n-void Unserialize(Stream& is, CScript& v, int nType, int nVersion)\n-{\n-    Unserialize(is, (std::vector<unsigned char>&)v, nType, nVersion);\n-}\n-\n-\n-\n /**\n  * pair\n  */"
      },
      {
        "sha": "d92b7ec62ec476af0f4205f4b0eb4c6f58e08d71",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/114b5812f6283f2325fc31e186b26c6d76f9551a/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/114b5812f6283f2325fc31e186b26c6d76f9551a/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=114b5812f6283f2325fc31e186b26c6d76f9551a",
        "patch": "@@ -186,7 +186,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n     tx.vin[0].prevout.hash = hash;\n-    tx.vin[0].scriptSig = CScript() << (std::vector<unsigned char>)script;\n+    tx.vin[0].scriptSig = CScript() << std::vector<unsigned char>(script.begin(), script.end());\n     tx.vout[0].nValue -= 1000000;\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));"
      },
      {
        "sha": "01a45b540d512f4f27c45c8c209013951b1660bd",
        "filename": "src/test/prevector_tests.cpp",
        "status": "added",
        "additions": 217,
        "deletions": 0,
        "changes": 217,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/114b5812f6283f2325fc31e186b26c6d76f9551a/src/test/prevector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/114b5812f6283f2325fc31e186b26c6d76f9551a/src/test/prevector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/prevector_tests.cpp?ref=114b5812f6283f2325fc31e186b26c6d76f9551a",
        "patch": "@@ -0,0 +1,217 @@\n+// Copyright (c) 2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <vector>\n+#include \"prevector.h\"\n+#include \"random.h\"\n+\n+#include \"serialize.h\"\n+#include \"streams.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(PrevectorTests, TestingSetup)\n+\n+template<unsigned int N, typename T>\n+class prevector_tester {\n+    typedef std::vector<T> realtype;\n+    realtype real_vector;\n+\n+    typedef prevector<N, T> pretype;\n+    pretype pre_vector;\n+\n+    typedef typename pretype::size_type Size;\n+\n+    void test() {\n+        const pretype& const_pre_vector = pre_vector;\n+        BOOST_CHECK_EQUAL(real_vector.size(), pre_vector.size());\n+        BOOST_CHECK_EQUAL(real_vector.empty(), pre_vector.empty());\n+        for (Size s = 0; s < real_vector.size(); s++) {\n+             BOOST_CHECK(real_vector[s] == pre_vector[s]);\n+             BOOST_CHECK(&(pre_vector[s]) == &(pre_vector.begin()[s]));\n+             BOOST_CHECK(&(pre_vector[s]) == &*(pre_vector.begin() + s));\n+             BOOST_CHECK(&(pre_vector[s]) == &*((pre_vector.end() + s) - real_vector.size()));\n+        }\n+        // BOOST_CHECK(realtype(pre_vector) == real_vector);\n+        BOOST_CHECK(pretype(real_vector.begin(), real_vector.end()) == pre_vector);\n+        BOOST_CHECK(pretype(pre_vector.begin(), pre_vector.end()) == pre_vector);\n+        size_t pos = 0;\n+        BOOST_FOREACH(const T& v, pre_vector) {\n+             BOOST_CHECK(v == real_vector[pos++]);\n+        }\n+        BOOST_REVERSE_FOREACH(const T& v, pre_vector) {\n+             BOOST_CHECK(v == real_vector[--pos]);\n+        }\n+        BOOST_FOREACH(const T& v, const_pre_vector) {\n+             BOOST_CHECK(v == real_vector[pos++]);\n+        }\n+        BOOST_REVERSE_FOREACH(const T& v, const_pre_vector) {\n+             BOOST_CHECK(v == real_vector[--pos]);\n+        }\n+        CDataStream ss1(SER_DISK, 0);\n+        CDataStream ss2(SER_DISK, 0);\n+        ss1 << real_vector;\n+        ss2 << pre_vector;\n+        BOOST_CHECK_EQUAL(ss1.size(), ss2.size());\n+        for (Size s = 0; s < ss1.size(); s++) {\n+            BOOST_CHECK_EQUAL(ss1[s], ss2[s]);\n+        }\n+    }\n+\n+public:\n+    void resize(Size s) {\n+        real_vector.resize(s);\n+        BOOST_CHECK_EQUAL(real_vector.size(), s);\n+        pre_vector.resize(s);\n+        BOOST_CHECK_EQUAL(pre_vector.size(), s);\n+        test();\n+    }\n+\n+    void reserve(Size s) {\n+        real_vector.reserve(s);\n+        BOOST_CHECK(real_vector.capacity() >= s);\n+        pre_vector.reserve(s);\n+        BOOST_CHECK(pre_vector.capacity() >= s);\n+        test();\n+    }\n+\n+    void insert(Size position, const T& value) {\n+        real_vector.insert(real_vector.begin() + position, value);\n+        pre_vector.insert(pre_vector.begin() + position, value);\n+        test();\n+    }\n+\n+    void insert(Size position, Size count, const T& value) {\n+        real_vector.insert(real_vector.begin() + position, count, value);\n+        pre_vector.insert(pre_vector.begin() + position, count, value);\n+        test();\n+    }\n+\n+    template<typename I>\n+    void insert_range(Size position, I first, I last) {\n+        real_vector.insert(real_vector.begin() + position, first, last);\n+        pre_vector.insert(pre_vector.begin() + position, first, last);\n+        test();\n+    }\n+\n+    void erase(Size position) {\n+        real_vector.erase(real_vector.begin() + position);\n+        pre_vector.erase(pre_vector.begin() + position);\n+        test();\n+    }\n+\n+    void erase(Size first, Size last) {\n+        real_vector.erase(real_vector.begin() + first, real_vector.begin() + last);\n+        pre_vector.erase(pre_vector.begin() + first, pre_vector.begin() + last);\n+        test();\n+    }\n+\n+    void update(Size pos, const T& value) {\n+        real_vector[pos] = value;\n+        pre_vector[pos] = value;\n+        test();\n+    }\n+\n+    void push_back(const T& value) {\n+        real_vector.push_back(value);\n+        pre_vector.push_back(value);\n+        test();\n+    }\n+\n+    void pop_back() {\n+        real_vector.pop_back();\n+        pre_vector.pop_back();\n+        test();\n+    }\n+\n+    void clear() {\n+        real_vector.clear();\n+        pre_vector.clear();\n+    }\n+\n+    void assign(Size n, const T& value) {\n+        real_vector.assign(n, value);\n+        pre_vector.assign(n, value);\n+    }\n+\n+    Size size() {\n+        return real_vector.size();\n+    }\n+\n+    Size capacity() {\n+        return pre_vector.capacity();\n+    }\n+\n+    void shrink_to_fit() {\n+        pre_vector.shrink_to_fit();\n+        test();\n+    }\n+};\n+\n+BOOST_AUTO_TEST_CASE(PrevectorTestInt)\n+{\n+    for (int j = 0; j < 64; j++) {\n+        prevector_tester<8, int> test;\n+        for (int i = 0; i < 2048; i++) {\n+            int r = insecure_rand();\n+            if ((r % 4) == 0) {\n+                test.insert(insecure_rand() % (test.size() + 1), insecure_rand());\n+            }\n+            if (test.size() > 0 && ((r >> 2) % 4) == 1) {\n+                test.erase(insecure_rand() % test.size());\n+            }\n+            if (((r >> 4) % 8) == 2) {\n+                int new_size = std::max<int>(0, std::min<int>(30, test.size() + (insecure_rand() % 5) - 2));\n+                test.resize(new_size);\n+            }\n+            if (((r >> 7) % 8) == 3) {\n+                test.insert(insecure_rand() % (test.size() + 1), 1 + (insecure_rand() % 2), insecure_rand());\n+            }\n+            if (((r >> 10) % 8) == 4) {\n+                int del = std::min<int>(test.size(), 1 + (insecure_rand() % 2));\n+                int beg = insecure_rand() % (test.size() + 1 - del);\n+                test.erase(beg, beg + del);\n+            }\n+            if (((r >> 13) % 16) == 5) {\n+                test.push_back(insecure_rand());\n+            }\n+            if (test.size() > 0 && ((r >> 17) % 16) == 6) {\n+                test.pop_back();\n+            }\n+            if (((r >> 21) % 32) == 7) {\n+                int values[4];\n+                int num = 1 + (insecure_rand() % 4);\n+                for (int i = 0; i < num; i++) {\n+                    values[i] = insecure_rand();\n+                }\n+                test.insert_range(insecure_rand() % (test.size() + 1), values, values + num);\n+            }\n+            if (((r >> 26) % 32) == 8) {\n+                int del = std::min<int>(test.size(), 1 + (insecure_rand() % 4));\n+                int beg = insecure_rand() % (test.size() + 1 - del);\n+                test.erase(beg, beg + del);\n+            }\n+            r = insecure_rand();\n+            if (r % 32 == 9) {\n+                test.reserve(insecure_rand() % 32);\n+            }\n+            if ((r >> 5) % 64 == 10) {\n+                test.shrink_to_fit();\n+            }\n+            if (test.size() > 0) {\n+                test.update(insecure_rand() % test.size(), insecure_rand());\n+            }\n+            if (((r >> 11) & 1024) == 11) {\n+                test.clear();\n+            }\n+            if (((r >> 21) & 512) == 12) {\n+                test.assign(insecure_rand() % 32, insecure_rand());\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "e36aca8dfaab2751108f41ad4ec692e51a6b94d9",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/114b5812f6283f2325fc31e186b26c6d76f9551a/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/114b5812f6283f2325fc31e186b26c6d76f9551a/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=114b5812f6283f2325fc31e186b26c6d76f9551a",
        "patch": "@@ -25,7 +25,7 @@ using namespace std;\n static std::vector<unsigned char>\n Serialize(const CScript& s)\n {\n-    std::vector<unsigned char> sSerialized(s);\n+    std::vector<unsigned char> sSerialized(s.begin(), s.end());\n     return sSerialized;\n }\n \n@@ -339,8 +339,8 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     // SignSignature doesn't know how to sign these. We're\n     // not testing validating signatures, so just create\n     // dummy signatures that DO include the correct P2SH scripts:\n-    txTo.vin[3].scriptSig << OP_11 << OP_11 << static_cast<vector<unsigned char> >(oneAndTwo);\n-    txTo.vin[4].scriptSig << static_cast<vector<unsigned char> >(fifteenSigops);\n+    txTo.vin[3].scriptSig << OP_11 << OP_11 << vector<unsigned char>(oneAndTwo.begin(), oneAndTwo.end());\n+    txTo.vin[4].scriptSig << vector<unsigned char>(fifteenSigops.begin(), fifteenSigops.end());\n \n     BOOST_CHECK(::AreInputsStandard(txTo, coins));\n     // 22 P2SH sigops for all inputs (1 for vin[0], 6 for vin[3], 15 for vin[4]\n@@ -362,7 +362,7 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     txToNonStd1.vin.resize(1);\n     txToNonStd1.vin[0].prevout.n = 5;\n     txToNonStd1.vin[0].prevout.hash = txFrom.GetHash();\n-    txToNonStd1.vin[0].scriptSig << static_cast<vector<unsigned char> >(sixteenSigops);\n+    txToNonStd1.vin[0].scriptSig << vector<unsigned char>(sixteenSigops.begin(), sixteenSigops.end());\n \n     BOOST_CHECK(!::AreInputsStandard(txToNonStd1, coins));\n     BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txToNonStd1, coins), 16U);\n@@ -374,7 +374,7 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     txToNonStd2.vin.resize(1);\n     txToNonStd2.vin[0].prevout.n = 6;\n     txToNonStd2.vin[0].prevout.hash = txFrom.GetHash();\n-    txToNonStd2.vin[0].scriptSig << static_cast<vector<unsigned char> >(twentySigops);\n+    txToNonStd2.vin[0].scriptSig << vector<unsigned char>(twentySigops.begin(), twentySigops.end());\n \n     BOOST_CHECK(!::AreInputsStandard(txToNonStd2, coins));\n     BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txToNonStd2, coins), 20U);"
      },
      {
        "sha": "0059e4a998ef2dc9148fc1490d59ef0765d7ce72",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/114b5812f6283f2325fc31e186b26c6d76f9551a/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/114b5812f6283f2325fc31e186b26c6d76f9551a/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=114b5812f6283f2325fc31e186b26c6d76f9551a",
        "patch": "@@ -260,7 +260,7 @@ class TestBuilder\n \n     TestBuilder& PushRedeem()\n     {\n-        DoPush(static_cast<std::vector<unsigned char> >(scriptPubKey));\n+        DoPush(std::vector<unsigned char>(scriptPubKey.begin(), scriptPubKey.end()));\n         return *this;\n     }\n \n@@ -892,7 +892,7 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n     combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSigCopy, scriptSig);\n     BOOST_CHECK(combined == scriptSigCopy || combined == scriptSig);\n     // dummy scriptSigCopy with placeholder, should always choose non-placeholder:\n-    scriptSigCopy = CScript() << OP_0 << static_cast<vector<unsigned char> >(pkSingle);\n+    scriptSigCopy = CScript() << OP_0 << vector<unsigned char>(pkSingle.begin(), pkSingle.end());\n     combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSigCopy, scriptSig);\n     BOOST_CHECK(combined == scriptSig);\n     combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSig, scriptSigCopy);"
      },
      {
        "sha": "ea2b9b795f0231a0ba2b19bd40c39ec7040a3f88",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/114b5812f6283f2325fc31e186b26c6d76f9551a/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/114b5812f6283f2325fc31e186b26c6d76f9551a/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=114b5812f6283f2325fc31e186b26c6d76f9551a",
        "patch": "@@ -20,7 +20,7 @@ using namespace std;\n static std::vector<unsigned char>\n Serialize(const CScript& s)\n {\n-    std::vector<unsigned char> sSerialized(s);\n+    std::vector<unsigned char> sSerialized(s.begin(), s.end());\n     return sSerialized;\n }\n "
      },
      {
        "sha": "e0f3e3aa04cae9e5759c561e2e1167e678295176",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/114b5812f6283f2325fc31e186b26c6d76f9551a/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/114b5812f6283f2325fc31e186b26c6d76f9551a/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=114b5812f6283f2325fc31e186b26c6d76f9551a",
        "patch": "@@ -113,19 +113,19 @@ bool CWalletDB::WriteMasterKey(unsigned int nID, const CMasterKey& kMasterKey)\n bool CWalletDB::WriteCScript(const uint160& hash, const CScript& redeemScript)\n {\n     nWalletDBUpdated++;\n-    return Write(std::make_pair(std::string(\"cscript\"), hash), redeemScript, false);\n+    return Write(std::make_pair(std::string(\"cscript\"), hash), *(const CScriptBase*)(&redeemScript), false);\n }\n \n bool CWalletDB::WriteWatchOnly(const CScript &dest)\n {\n     nWalletDBUpdated++;\n-    return Write(std::make_pair(std::string(\"watchs\"), dest), '1');\n+    return Write(std::make_pair(std::string(\"watchs\"), *(const CScriptBase*)(&dest)), '1');\n }\n \n bool CWalletDB::EraseWatchOnly(const CScript &dest)\n {\n     nWalletDBUpdated++;\n-    return Erase(std::make_pair(std::string(\"watchs\"), dest));\n+    return Erase(std::make_pair(std::string(\"watchs\"), *(const CScriptBase*)(&dest)));\n }\n \n bool CWalletDB::WriteBestBlock(const CBlockLocator& locator)\n@@ -421,7 +421,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n         else if (strType == \"watchs\")\n         {\n             CScript script;\n-            ssKey >> script;\n+            ssKey >> *(CScriptBase*)(&script);\n             char fYes;\n             ssValue >> fYes;\n             if (fYes == '1')\n@@ -575,7 +575,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             uint160 hash;\n             ssKey >> hash;\n             CScript script;\n-            ssValue >> script;\n+            ssValue >> *(CScriptBase*)(&script);\n             if (!pwallet->LoadCScript(script))\n             {\n                 strErr = \"Error reading wallet database: LoadCScript failed\";"
      }
    ]
  }
]