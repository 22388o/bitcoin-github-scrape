[
  {
    "sha": "5fee401fe14aa6459428a26a82f764db70a6a0b9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZmVlNDAxZmUxNGFhNjQ1OTQyOGEyNmE4MmY3NjRkYjcwYTZhMGI5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-01-04T22:39:45Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-02-24T12:41:04Z"
      },
      "message": "CAddrMan: stochastic address manager\n\nDesign goals:\n * Only keep a limited number of addresses around, so that addr.dat does not grow without bound.\n * Keep the address tables in-memory, and occasionally write the table to addr.dat.\n * Make sure no (localized) attacker can fill the entire table with his nodes/addresses.\n\nSee comments in addrman.h for more detailed information.",
      "tree": {
        "sha": "7920219dabcdd335a7432aa05081d168c98dbf06",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7920219dabcdd335a7432aa05081d168c98dbf06"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5fee401fe14aa6459428a26a82f764db70a6a0b9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5fee401fe14aa6459428a26a82f764db70a6a0b9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5fee401fe14aa6459428a26a82f764db70a6a0b9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5fee401fe14aa6459428a26a82f764db70a6a0b9/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8c12851ed497797684588e09637d80a5abd5725e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c12851ed497797684588e09637d80a5abd5725e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8c12851ed497797684588e09637d80a5abd5725e"
      }
    ],
    "stats": {
      "total": 1431,
      "additions": 1181,
      "deletions": 250
    },
    "files": [
      {
        "sha": "8cecc45506f41395a1ec0caa53601d4e2f9798ab",
        "filename": "bitcoin-qt.pro",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5fee401fe14aa6459428a26a82f764db70a6a0b9/bitcoin-qt.pro",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5fee401fe14aa6459428a26a82f764db70a6a0b9/bitcoin-qt.pro",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bitcoin-qt.pro?ref=5fee401fe14aa6459428a26a82f764db70a6a0b9",
        "patch": "@@ -101,6 +101,7 @@ HEADERS += src/qt/bitcoingui.h \\\n     src/qt/aboutdialog.h \\\n     src/qt/editaddressdialog.h \\\n     src/qt/bitcoinaddressvalidator.h \\\n+    src/addrman.h \\\n     src/base58.h \\\n     src/bignum.h \\\n     src/checkpoints.h \\\n@@ -174,6 +175,7 @@ SOURCES += src/qt/bitcoin.cpp src/qt/bitcoingui.cpp \\\n     src/net.cpp \\\n     src/irc.cpp \\\n     src/checkpoints.cpp \\\n+    src/addrman.cpp \\\n     src/db.cpp \\\n     src/json/json_spirit_writer.cpp \\\n     src/json/json_spirit_value.cpp \\"
      },
      {
        "sha": "2ef666cf2c183806c2c1a55116379f887e4cb28f",
        "filename": "src/addrman.cpp",
        "status": "added",
        "additions": 506,
        "deletions": 0,
        "changes": 506,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=5fee401fe14aa6459428a26a82f764db70a6a0b9",
        "patch": "@@ -0,0 +1,506 @@\n+// Copyright (c) 2012 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"addrman.h\"\n+\n+using namespace std;\n+\n+int CAddrInfo::GetTriedBucket(const std::vector<unsigned char> &nKey) const\n+{\n+    CDataStream ss1(SER_GETHASH);\n+    std::vector<unsigned char> vchKey = GetKey();\n+    ss1 << nKey << vchKey;\n+    uint64 hash1 = Hash(ss1.begin(), ss1.end()).Get64();\n+\n+    CDataStream ss2(SER_GETHASH);\n+    std::vector<unsigned char> vchGroupKey = GetGroup();\n+    ss2 << nKey << vchGroupKey << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP);\n+    uint64 hash2 = Hash(ss2.begin(), ss2.end()).Get64();\n+    return hash2 % ADDRMAN_TRIED_BUCKET_COUNT;\n+}\n+\n+int CAddrInfo::GetNewBucket(const std::vector<unsigned char> &nKey, const CNetAddr& src) const\n+{\n+    CDataStream ss1(SER_GETHASH);\n+    std::vector<unsigned char> vchGroupKey = GetGroup();\n+    std::vector<unsigned char> vchSourceGroupKey = src.GetGroup();\n+    ss1 << nKey << vchGroupKey << vchSourceGroupKey;\n+    uint64 hash1 = Hash(ss1.begin(), ss1.end()).Get64();\n+\n+    CDataStream ss2(SER_GETHASH);\n+    ss2 << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP);\n+    uint64 hash2 = Hash(ss2.begin(), ss2.end()).Get64();\n+    return hash2 % ADDRMAN_NEW_BUCKET_COUNT;\n+}\n+\n+bool CAddrInfo::IsTerrible(int64 nNow) const\n+{\n+    if (nLastTry && nLastTry >= nNow-60) // never remove things tried the last minute\n+        return false;\n+\n+    if (nTime > nNow + 10*60) // came in a flying DeLorean\n+        return true;\n+\n+    if (nTime==0 || nNow-nTime > ADDRMAN_HORIZON_DAYS*86400) // not seen in over a month\n+        return true;\n+\n+    if (nLastSuccess==0 && nAttempts>=ADDRMAN_RETRIES) // tried three times and never a success\n+        return true;\n+\n+    if (nNow-nLastSuccess > ADDRMAN_MIN_FAIL_DAYS*86400 && nAttempts>=ADDRMAN_MAX_FAILURES) // 10 successive failures in the last week\n+        return true;\n+\n+    return false;\n+}\n+\n+double CAddrInfo::GetChance(int64 nNow) const\n+{\n+    double fChance = 1.0;\n+\n+    int64 nSinceLastSeen = nNow - nTime;\n+    int64 nSinceLastTry = nNow - nLastTry;\n+\n+    if (nSinceLastSeen < 0) nSinceLastSeen = 0;\n+    if (nSinceLastTry < 0) nSinceLastTry = 0;\n+\n+    fChance *= 600.0 / (600.0 + nSinceLastSeen);\n+\n+    // deprioritize very recent attempts away\n+    if (nSinceLastTry < 60*10)\n+        fChance *= 0.01;\n+\n+    // deprioritize 50% after each failed attempt\n+    for (int n=0; n<nAttempts; n++)\n+        fChance /= 1.5;\n+\n+    return fChance;\n+}\n+\n+CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int *pnId)\n+{\n+    std::map<CNetAddr, int>::iterator it = mapAddr.find(addr);\n+    if (it == mapAddr.end())\n+        return NULL;\n+    if (pnId)\n+        *pnId = (*it).second;\n+    std::map<int, CAddrInfo>::iterator it2 = mapInfo.find((*it).second);\n+    if (it2 != mapInfo.end())\n+        return &(*it2).second;\n+    return NULL;\n+}\n+\n+CAddrInfo* CAddrMan::Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId)\n+{\n+    int nId = nIdCount++;\n+    mapInfo[nId] = CAddrInfo(addr, addrSource);\n+    mapAddr[addr] = nId;\n+    mapInfo[nId].nRandomPos = vRandom.size();\n+    vRandom.push_back(nId);\n+    if (pnId)\n+        *pnId = nId;\n+    return &mapInfo[nId];\n+}\n+\n+void CAddrMan::SwapRandom(int nRndPos1, int nRndPos2)\n+{\n+    if (nRndPos1 == nRndPos2)\n+        return;\n+\n+    int nId1 = vRandom[nRndPos1];\n+    int nId2 = vRandom[nRndPos2];\n+\n+    mapInfo[nId1].nRandomPos = nRndPos2;\n+    mapInfo[nId2].nRandomPos = nRndPos1;\n+\n+    vRandom[nRndPos1] = nId2;\n+    vRandom[nRndPos2] = nId1;\n+}\n+\n+int CAddrMan::SelectTried(int nKBucket)\n+{\n+    std::vector<int> &vTried = vvTried[nKBucket];\n+\n+    // random shuffle the first few elements (using the entire list)\n+    // find the least recently tried among them\n+    int64 nOldest = -1;\n+    for (int i=0; i<ADDRMAN_TRIED_ENTRIES_INSPECT_ON_EVICT && i<vTried.size(); i++)\n+    {\n+        int nPos = GetRandInt(vTried.size() - i) + i;\n+        int nTemp = vTried[nPos];\n+        vTried[nPos] = vTried[i];\n+        vTried[i] = nTemp;\n+        if (nOldest == -1 || mapInfo[nTemp].nLastSuccess < mapInfo[nOldest].nLastSuccess)\n+           nOldest = nTemp;\n+    }\n+\n+    return nOldest;\n+}\n+\n+int CAddrMan::ShrinkNew(int nUBucket)\n+{\n+    std::set<int> &vNew = vvNew[nUBucket];\n+\n+    // first look for deletable items\n+    for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n+    {\n+        CAddrInfo &info = mapInfo[*it];\n+        if (info.IsTerrible())\n+        {\n+            if (--info.nRefCount == 0)\n+            {\n+                SwapRandom(info.nRandomPos, vRandom.size()-1);\n+                vRandom.pop_back();\n+                mapAddr.erase(info);\n+                mapInfo.erase(*it);\n+                nNew--;\n+            }\n+            vNew.erase(it);\n+            return 0;\n+        }\n+    }\n+\n+    // otherwise, select four randomly, and pick the oldest of those to replace\n+    int n[4] = {GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size())};\n+    int nI = 0;\n+    int nOldest = -1;\n+    for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n+    {\n+        if (nI == n[0] || nI == n[1] || nI == n[2] || nI == n[3])\n+        {\n+            if (nOldest == -1 || mapInfo[*it].nTime < mapInfo[nOldest].nTime)\n+                nOldest = *it;\n+        }\n+        nI++;\n+    }\n+    CAddrInfo &info = mapInfo[nOldest];\n+    if (--info.nRefCount == 0) \n+    {\n+        SwapRandom(info.nRandomPos, vRandom.size()-1);\n+        vRandom.pop_back();\n+        mapAddr.erase(info);\n+        mapInfo.erase(nOldest);\n+        nNew--;\n+    }\n+    vNew.erase(nOldest);\n+\n+    return 1;\n+}\n+\n+void CAddrMan::MakeTried(CAddrInfo& info, int nId, int nOrigin)\n+{\n+    // remove the entry from all new buckets\n+    for (std::vector<std::set<int> >::iterator it = vvNew.begin(); it != vvNew.end(); it++)\n+    {\n+        if ((*it).erase(nId))\n+            info.nRefCount--;\n+    }\n+    nNew--;\n+\n+    // what tried bucket to move the entry to\n+    int nKBucket = info.GetTriedBucket(nKey);\n+    std::vector<int> &vTried = vvTried[nKBucket];\n+\n+    // first check whether there is place to just add it\n+    if (vTried.size() < ADDRMAN_TRIED_BUCKET_SIZE)\n+    {\n+        vTried.push_back(nId);\n+        nTried++;\n+        info.fInTried = true;\n+        return;\n+    }\n+\n+    // otherwise, find an item to evict\n+    int nPos = SelectTried(nKBucket);\n+\n+    // find which new bucket it belongs to\n+    int nUBucket = mapInfo[vTried[nPos]].GetNewBucket(nKey);\n+    std::set<int> &vNew = vvNew[nUBucket];\n+\n+    // remove the to-be-replaced tried entry from the tried set\n+    CAddrInfo& infoOld = mapInfo[vTried[nPos]];\n+    infoOld.fInTried = false;\n+    infoOld.nRefCount = 1;\n+    // do not update nTried, as we are going to move something else there immediately\n+\n+    // check whether there is place in that one, \n+    if (vNew.size() < ADDRMAN_NEW_BUCKET_SIZE)\n+    {\n+        // if so, move it back there\n+        vNew.insert(vTried[nPos]);\n+    } else {\n+        // otherwise, move it to the new bucket nId came from (there is certainly place there)\n+        vvNew[nOrigin].insert(vTried[nPos]);\n+    }\n+    nNew++;\n+\n+    vTried[nPos] = nId;\n+    // we just overwrote an entry in vTried; no need to update nTried\n+    info.fInTried = true;\n+    return;\n+}\n+\n+void CAddrMan::Good_(const CService &addr, int64 nTime)\n+{\n+//    printf(\"Good: addr=%s\\n\", addr.ToString().c_str());\n+\n+    int nId;\n+    CAddrInfo *pinfo = Find(addr, &nId);\n+\n+    // if not found, bail out\n+    if (!pinfo)\n+        return;\n+\n+    CAddrInfo &info = *pinfo;\n+\n+    // check whether we are talking about the exact same CService (including same port)\n+    if (info != addr)\n+        return;\n+\n+    // update info\n+    info.nLastSuccess = nTime;\n+    info.nLastTry = nTime;\n+    info.nTime = nTime;\n+    info.nAttempts = 0;\n+\n+    // if it is already in the tried set, don't do anything else\n+    if (info.fInTried)\n+        return;\n+\n+    // find a bucket it is in now\n+    int nRnd = GetRandInt(vvNew.size());\n+    int nUBucket = -1;\n+    for (int n = 0; n < vvNew.size(); n++)\n+    {\n+        int nB = (n+nRnd) % vvNew.size();\n+        std::set<int> &vNew = vvNew[nB];\n+        if (vNew.count(nId))\n+        {\n+            nUBucket = nB;\n+            break;\n+        }\n+    }\n+\n+    // if no bucket is found, something bad happened;\n+    // TODO: maybe re-add the node, but for now, just bail out\n+    if (nUBucket == -1) return;\n+\n+    printf(\"Moving %s to tried\\n\", addr.ToString().c_str());\n+\n+    // move nId to the tried tables\n+    MakeTried(info, nId, nUBucket);\n+}\n+\n+bool CAddrMan::Add_(const CAddress &addr, const CNetAddr& source, int64 nTimePenalty)\n+{\n+    if (!addr.IsRoutable())\n+        return false;\n+\n+    bool fNew = false;\n+    int nId;\n+    CAddrInfo *pinfo = Find(addr, &nId);\n+\n+    if (pinfo)\n+    {\n+        // periodically update nTime\n+        bool fCurrentlyOnline = (GetAdjustedTime() - addr.nTime < 24 * 60 * 60);\n+        int64 nUpdateInterval = (fCurrentlyOnline ? 60 * 60 : 24 * 60 * 60);\n+        if (addr.nTime && (!pinfo->nTime || pinfo->nTime < addr.nTime - nUpdateInterval - nTimePenalty))\n+            pinfo->nTime = max((int64)0, addr.nTime - nTimePenalty);\n+\n+        // add services\n+        pinfo->nServices |= addr.nServices;\n+\n+        // do not update if no new information is present\n+        if (!addr.nTime || pinfo->nTime && addr.nTime <= pinfo->nTime)\n+            return false;\n+\n+        // do not update if the entry was already in the \"tried\" table\n+        if (pinfo->fInTried)\n+            return false;\n+\n+        // do not update if the max reference count is reached\n+        if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)\n+            return false;\n+\n+        // stochastic test: previous nRefCount == N: 2^N times harder to increase it\n+        int nFactor = 1;\n+        for (int n=0; n<pinfo->nRefCount; n++)\n+            nFactor *= 2;\n+        if (nFactor > 1 && (GetRandInt(nFactor) != 0))\n+            return false;\n+    } else {\n+        pinfo = Create(addr, source, &nId);\n+        pinfo->nTime = max((int64)0, (int64)pinfo->nTime - nTimePenalty);\n+//        printf(\"Added %s [nTime=%fhr]\\n\", pinfo->ToString().c_str(), (GetAdjustedTime() - pinfo->nTime) / 3600.0);\n+        nNew++;\n+        fNew = true;\n+    }\n+\n+    int nUBucket = pinfo->GetNewBucket(nKey, source);\n+    std::set<int> &vNew = vvNew[nUBucket];\n+    if (!vNew.count(nId))\n+    {\n+        pinfo->nRefCount++;\n+        if (vNew.size() == ADDRMAN_NEW_BUCKET_SIZE)\n+            ShrinkNew(nUBucket);\n+        vvNew[nUBucket].insert(nId);\n+    }\n+    return fNew;\n+}\n+\n+void CAddrMan::Attempt_(const CService &addr, int64 nTime)\n+{\n+    CAddrInfo *pinfo = Find(addr);\n+\n+    // if not found, bail out\n+    if (!pinfo)\n+        return;\n+\n+    CAddrInfo &info = *pinfo;\n+\n+    // check whether we are talking about the exact same CService (including same port)\n+    if (info != addr)\n+        return;\n+\n+    // update info\n+    info.nLastTry = nTime;\n+    info.nAttempts++;\n+}\n+\n+CAddress CAddrMan::Select_(int nUnkBias)\n+{\n+    if (size() == 0)\n+        return CAddress();\n+\n+    double nCorTried = sqrt(nTried) * (100.0 - nUnkBias);\n+    double nCorNew = sqrt(nNew) * nUnkBias;\n+    if ((nCorTried + nCorNew)*GetRandInt(1<<30)/(1<<30) < nCorTried)\n+    {\n+        // use a tried node\n+        double fChanceFactor = 1.0;\n+        while(1)\n+        {\n+            int nKBucket = GetRandInt(vvTried.size());\n+            std::vector<int> &vTried = vvTried[nKBucket];\n+            if (vTried.size() == 0) continue;\n+            int nPos = GetRandInt(vTried.size());\n+            CAddrInfo &info = mapInfo[vTried[nPos]];\n+            if (GetRandInt(1<<30) < fChanceFactor*info.GetChance()*(1<<30))\n+                return info;\n+            fChanceFactor *= 1.2;\n+        }\n+    } else {\n+        // use an new node\n+        double fChanceFactor = 1.0;\n+        while(1)\n+        {\n+            int nUBucket = GetRandInt(vvNew.size());\n+            std::set<int> &vNew = vvNew[nUBucket];\n+            if (vNew.size() == 0) continue;\n+            int nPos = GetRandInt(vNew.size());\n+            std::set<int>::iterator it = vNew.begin();\n+            while (nPos--)\n+                it++;\n+            CAddrInfo &info = mapInfo[*it];\n+            if (GetRandInt(1<<30) < fChanceFactor*info.GetChance()*(1<<30))\n+                return info;\n+            fChanceFactor *= 1.2;\n+        }\n+    }\n+}\n+\n+#ifdef DEBUG_ADDRMAN\n+int CAddrMan::Check_()\n+{\n+    std::set<int> setTried;\n+    std::map<int, int> mapNew;\n+\n+    if (vRandom.size() != nTried + nNew) return -7;\n+\n+    for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n+    {\n+        int n = (*it).first;\n+        CAddrInfo &info = (*it).second;\n+        if (info.fInTried)\n+        {\n+\n+            if (!info.nLastSuccess) return -1;\n+            if (info.nRefCount) return -2;\n+            setTried.insert(n);\n+        } else {\n+            if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS) return -3;\n+            if (!info.nRefCount) return -4;\n+            mapNew[n] = info.nRefCount;\n+        }\n+        if (mapAddr[info] != n) return -5;\n+        if (info.nRandomPos<0 || info.nRandomPos>=vRandom.size() || vRandom[info.nRandomPos] != n) return -14;\n+        if (info.nLastTry < 0) return -6;\n+        if (info.nLastSuccess < 0) return -8;\n+    }\n+\n+    if (setTried.size() != nTried) return -9;\n+    if (mapNew.size() != nNew) return -10;\n+\n+    for (int n=0; n<vvTried.size(); n++)\n+    {\n+        std::vector<int> &vTried = vvTried[n];\n+        for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++)\n+        {\n+            if (!setTried.count(*it)) return -11;\n+            setTried.erase(*it);\n+        }\n+    }\n+\n+    for (int n=0; n<vvNew.size(); n++)\n+    {\n+        std::set<int> &vNew = vvNew[n];\n+        for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n+        {\n+            if (!mapNew.count(*it)) return -12;\n+            if (--mapNew[*it] == 0)\n+                mapNew.erase(*it);\n+        }\n+    }\n+\n+    if (setTried.size()) return -13;\n+    if (mapNew.size()) return -15;\n+\n+    return 0;\n+}\n+#endif\n+\n+void CAddrMan::GetAddr_(std::vector<CAddress> &vAddr)\n+{\n+    int nNodes = ADDRMAN_GETADDR_MAX_PCT*vRandom.size()/100;\n+    if (nNodes > ADDRMAN_GETADDR_MAX)\n+        nNodes = ADDRMAN_GETADDR_MAX;\n+\n+    // perform a random shuffle over the first nNodes elements of vRandom (selecting from all)\n+    for (int n = 0; n<nNodes; n++)\n+    {\n+        int nRndPos = GetRandInt(vRandom.size() - n) + n;\n+        SwapRandom(n, nRndPos);\n+        vAddr.push_back(mapInfo[vRandom[n]]);\n+    }\n+}\n+\n+void CAddrMan::Connected_(const CService &addr, int64 nTime)\n+{\n+    CAddrInfo *pinfo = Find(addr);\n+\n+    // if not found, bail out\n+    if (!pinfo)\n+        return;\n+\n+    CAddrInfo &info = *pinfo;\n+\n+    // check whether we are talking about the exact same CService (including same port)\n+    if (info != addr)\n+        return;\n+\n+    // update info\n+    int64 nUpdateInterval = 20 * 60;\n+    if (nTime - info.nTime > nUpdateInterval)\n+        info.nTime = nTime;\n+}"
      },
      {
        "sha": "350ecb270973de9d8aab8ad8ebb74f8c88470989",
        "filename": "src/addrman.h",
        "status": "added",
        "additions": 499,
        "deletions": 0,
        "changes": 499,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=5fee401fe14aa6459428a26a82f764db70a6a0b9",
        "patch": "@@ -0,0 +1,499 @@\n+// Copyright (c) 2012 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef _BITCOIN_ADDRMAN\n+#define _BITCOIN_ADDRMAN 1\n+\n+#include \"netbase.h\"\n+#include \"protocol.h\"\n+#include \"util.h\"\n+\n+\n+#include <map>\n+#include <vector>\n+\n+#include <openssl/rand.h>\n+\n+\n+// Extended statistics about a CAddress\n+class CAddrInfo : public CAddress\n+{\n+private:\n+    // where knowledge about this address first came from\n+    CNetAddr source;\n+\n+    // last succesfull connection by us\n+    int64 nLastSuccess;\n+\n+    // last try whatsoever by us:\n+    // int64 CAddress::nLastTry\n+\n+    // connection attempts since last succesful attempt\n+    int nAttempts;\n+\n+    // reference count in new sets (memory only)\n+    int nRefCount;\n+\n+    // in tried set? (memory only)\n+    bool fInTried;\n+\n+    // position in vRandom\n+    int nRandomPos;\n+\n+    friend class CAddrMan;\n+\n+public:\n+\n+    IMPLEMENT_SERIALIZE(\n+        CAddress* pthis = (CAddress*)(this);\n+        READWRITE(*pthis);\n+        READWRITE(source);\n+        READWRITE(nLastSuccess);\n+        READWRITE(nAttempts);\n+    )\n+\n+    void Init()\n+    {\n+        nLastSuccess = 0;\n+        nLastTry = 0;\n+        nAttempts = 0;\n+        nRefCount = 0;\n+        fInTried = false;\n+        nRandomPos = -1;\n+    }\n+\n+    CAddrInfo(const CAddress &addrIn, const CNetAddr &addrSource) : CAddress(addrIn)\n+    {\n+        Init();\n+    }\n+\n+    CAddrInfo() : CAddress(), source()\n+    {\n+        Init();\n+    }\n+\n+    // Calculate in which \"tried\" bucket this entry belongs\n+    int GetTriedBucket(const std::vector<unsigned char> &nKey) const;\n+\n+    // Calculate in which \"new\" bucket this entry belongs, given a certain source\n+    int GetNewBucket(const std::vector<unsigned char> &nKey, const CNetAddr& src) const;\n+\n+    // Calculate in which \"new\" bucket this entry belongs, using its default source\n+    int GetNewBucket(const std::vector<unsigned char> &nKey) const\n+    {\n+        return GetNewBucket(nKey, source);\n+    }\n+\n+    // Determine whether the statistics about this entry are bad enough so that it can just be deleted\n+    bool IsTerrible(int64 nNow = GetAdjustedTime()) const;\n+\n+    // Calculate the relative chance this entry should be given when selecting nodes to connect to\n+    double GetChance(int64 nNow = GetAdjustedTime()) const;\n+\n+};\n+\n+// Stochastic address manager\n+//\n+// Design goals:\n+//  * Only keep a limited number of addresses around, so that addr.dat and memory requirements do not grow without bound.\n+//  * Keep the address tables in-memory, and asynchronously dump the entire to able in addr.dat.\n+//  * Make sure no (localized) attacker can fill the entire table with his nodes/addresses.\n+//\n+// To that end:\n+//  * Addresses are organized into buckets.\n+//    * Address that have not yet been tried go into 256 \"new\" buckets.\n+//      * Based on the address range (/16 for IPv4) of source of the information, 32 buckets are selected at random\n+//      * The actual bucket is chosen from one of these, based on the range the address itself is located.\n+//      * One single address can occur in up to 4 different buckets, to increase selection chances for addresses that\n+//        are seen frequently. The chance for increasing this multiplicity decreases exponentially.\n+//      * When adding a new address to a full bucket, a randomly chosen entry (with a bias favoring less recently seen\n+//        ones) is removed from it first.\n+//    * Addresses of nodes that are known to be accessible go into 64 \"tried\" buckets.\n+//      * Each address range selects at random 4 of these buckets.\n+//      * The actual bucket is chosen from one of these, based on the full address.\n+//      * When adding a new good address to a full bucket, a randomly chosen entry (with a bias favoring less recently\n+//        tried ones) is evicted from it, back to the \"new\" buckets.\n+//    * Bucket selection is based on cryptographic hashing, using a randomly-generated 256-bit key, which should not\n+//      be observable by adversaries.\n+//    * Several indexes are kept for high performance. Defining DEBUG_ADDRMAN will introduce frequent (and expensive)\n+//      consistency checks for the entire datastructure.\n+\n+// total number of buckets for tried addresses\n+#define ADDRMAN_TRIED_BUCKET_COUNT 64\n+\n+// maximum allowed number of entries in buckets for tried addresses\n+#define ADDRMAN_TRIED_BUCKET_SIZE 64\n+\n+// total number of buckets for new addresses\n+#define ADDRMAN_NEW_BUCKET_COUNT 256\n+\n+// maximum allowed number of entries in buckets for new addresses\n+#define ADDRMAN_NEW_BUCKET_SIZE 64\n+\n+// over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread\n+#define ADDRMAN_TRIED_BUCKETS_PER_GROUP 4\n+\n+// over how many buckets entries with new addresses originating from a single group are spread\n+#define ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP 32\n+\n+// in how many buckets for entries with new addresses a single address may occur\n+#define ADDRMAN_NEW_BUCKETS_PER_ADDRESS 4\n+\n+// how many entries in a bucket with tried addresses are inspected, when selecting one to replace\n+#define ADDRMAN_TRIED_ENTRIES_INSPECT_ON_EVICT 4\n+\n+// how old addresses can maximally be\n+#define ADDRMAN_HORIZON_DAYS 30\n+\n+// after how many failed attempts we give up on a new node\n+#define ADDRMAN_RETRIES 3\n+\n+// how many successive failures are allowed ...\n+#define ADDRMAN_MAX_FAILURES 10\n+\n+// ... in at least this many days\n+#define ADDRMAN_MIN_FAIL_DAYS 7\n+\n+// the maximum percentage of nodes to return in a getaddr call\n+#define ADDRMAN_GETADDR_MAX_PCT 23\n+\n+// the maximum number of nodes to return in a getaddr call\n+#define ADDRMAN_GETADDR_MAX 2500\n+\n+class CAddrMan\n+{\n+private:\n+    // critical section to protect the inner data structures\n+    mutable CCriticalSection cs;\n+\n+    // secret key to randomize bucket select with\n+    std::vector<unsigned char> nKey;\n+\n+    // last used nId\n+    int nIdCount;\n+\n+    // table with information about all nId's\n+    std::map<int, CAddrInfo> mapInfo;\n+\n+    // find an nId based on its network address\n+    std::map<CNetAddr, int> mapAddr;\n+\n+    // randomly-ordered vector of all nId's\n+    std::vector<int> vRandom;\n+\n+    // number of \"tried\" entries\n+    int nTried;\n+\n+    // list of \"tried\" buckets\n+    std::vector<std::vector<int> > vvTried;\n+\n+    // number of (unique) \"new\" entries\n+    int nNew;\n+\n+    // list of \"new\" buckets\n+    std::vector<std::set<int> > vvNew;\n+\n+protected:\n+\n+    // Find an entry.\n+    CAddrInfo* Find(const CNetAddr& addr, int *pnId = NULL);\n+\n+    // find an entry, creating it if necessary.\n+    // nTime and nServices of found node is updated, if necessary.\n+    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = NULL);\n+\n+    // Swap two elements in vRandom.\n+    void SwapRandom(int nRandomPos1, int nRandomPos2);\n+\n+    // Return position in given bucket to replace.\n+    int SelectTried(int nKBucket);\n+\n+    // Remove an element from a \"new\" bucket.\n+    // This is the only place where actual deletes occur.\n+    // They are never deleted while in the \"tried\" table, only possibly evicted back to the \"new\" table.\n+    int ShrinkNew(int nUBucket);\n+ \n+    // Move an entry from the \"new\" table(s) to the \"tried\" table\n+    // @pre vvUnkown[nOrigin].count(nId) != 0\n+    void MakeTried(CAddrInfo& info, int nId, int nOrigin);\n+\n+    // Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n+    void Good_(const CService &addr, int64 nTime);\n+\n+    // Add an entry to the \"new\" table.\n+    bool Add_(const CAddress &addr, const CNetAddr& source, int64 nTimePenalty);\n+\n+    // Mark an entry as attempted to connect.\n+    void Attempt_(const CService &addr, int64 nTime);\n+\n+    // Select an address to connect to.\n+    // nUnkBias determines how much to favor new addresses over tried ones (min=0, max=100)\n+    CAddress Select_(int nUnkBias);\n+\n+#ifdef DEBUG_ADDRMAN\n+    // Perform consistency check. Returns an error code or zero.\n+    int Check_();\n+#endif\n+\n+    // Select several addresses at once.\n+    void GetAddr_(std::vector<CAddress> &vAddr);\n+\n+    // Mark an entry as currently-connected-to.\n+    void Connected_(const CService &addr, int64 nTime);\n+\n+public:\n+\n+    IMPLEMENT_SERIALIZE\n+    (({\n+        // serialized format:\n+        // * version byte (currently 0)\n+        // * nKey\n+        // * nNew\n+        // * nTried\n+        // * number of \"new\" buckets\n+        // * all nNew addrinfo's in vvNew\n+        // * all nTried addrinfo's in vvTried\n+        // * for each bucket:\n+        //   * number of elements\n+        //   * for each element: index\n+        //\n+        // Notice that vvTried, mapAddr and vVector are never encoded explicitly;\n+        // they are instead reconstructed from the other information.\n+        //\n+        // vvNew is serialized, but only used if ADDRMAN_UNKOWN_BUCKET_COUNT didn't change,\n+        // otherwise it is reconstructed as well.\n+        //\n+        // This format is more complex, but significantly smaller (at most 1.5 MiB), and supports\n+        // changes to the ADDRMAN_ parameters without breaking the on-disk structure.\n+        CRITICAL_BLOCK(cs)\n+        {\n+            unsigned char nVersion = 0;\n+            READWRITE(nVersion);\n+            READWRITE(nKey);\n+            READWRITE(nNew);\n+            READWRITE(nTried);\n+\n+            CAddrMan *am = const_cast<CAddrMan*>(this);\n+            if (fWrite)\n+            {\n+                int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT;\n+                READWRITE(nUBuckets);\n+                std::map<int, int> mapUnkIds;\n+                int nIds = 0;\n+                for (std::map<int, CAddrInfo>::iterator it = am->mapInfo.begin(); it != am->mapInfo.end(); it++)\n+                {\n+                    if (nIds == nNew) break; // this means nNew was wrong, oh ow\n+                    mapUnkIds[(*it).first] = nIds;\n+                    CAddrInfo &info = (*it).second;\n+                    if (info.nRefCount)\n+                    {\n+                        READWRITE(info);\n+                        nIds++;\n+                    }\n+                }\n+                nIds = 0;\n+                for (std::map<int, CAddrInfo>::iterator it = am->mapInfo.begin(); it != am->mapInfo.end(); it++)\n+                {\n+                    if (nIds == nTried) break; // this means nTried was wrong, oh ow\n+                    CAddrInfo &info = (*it).second;\n+                    if (info.fInTried)\n+                    {\n+                        READWRITE(info);\n+                        nIds++;\n+                    }\n+                }\n+                for (std::vector<std::set<int> >::iterator it = am->vvNew.begin(); it != am->vvNew.end(); it++)\n+                {\n+                    const std::set<int> &vNew = (*it);\n+                    int nSize = vNew.size();\n+                    READWRITE(nSize);\n+                    for (std::set<int>::iterator it2 = vNew.begin(); it2 != vNew.end(); it2++)\n+                    {\n+                        int nIndex = mapUnkIds[*it2];\n+                        READWRITE(nIndex);\n+                    }\n+                }\n+            } else {\n+                int nUBuckets = 0;\n+                READWRITE(nUBuckets);\n+                am->nIdCount = 0;\n+                am->mapInfo.clear();\n+                am->mapAddr.clear();\n+                am->vRandom.clear();\n+                am->vvTried = std::vector<std::vector<int> >(ADDRMAN_TRIED_BUCKET_COUNT, std::vector<int>(0));\n+                am->vvNew = std::vector<std::set<int> >(ADDRMAN_NEW_BUCKET_COUNT, std::set<int>());\n+                for (int n = 0; n < am->nNew; n++)\n+                {\n+                    CAddrInfo &info = am->mapInfo[n];\n+                    READWRITE(info);\n+                    am->mapAddr[info] = n;\n+                    info.nRandomPos = vRandom.size();\n+                    am->vRandom.push_back(n);\n+                    if (nUBuckets != ADDRMAN_NEW_BUCKET_COUNT)\n+                    {\n+                        am->vvNew[info.GetNewBucket(am->nKey)].insert(n);\n+                        info.nRefCount++;\n+                    }\n+                }\n+                am->nIdCount = am->nNew;\n+                int nLost = 0;\n+                for (int n = 0; n < am->nTried; n++)\n+                {\n+                    CAddrInfo info;\n+                    READWRITE(info);\n+                    std::vector<int> &vTried = am->vvTried[info.GetTriedBucket(am->nKey)];\n+                    if (vTried.size() < ADDRMAN_TRIED_BUCKET_SIZE)\n+                    {\n+                        info.nRandomPos = vRandom.size();\n+                        info.fInTried = true;\n+                        am->vRandom.push_back(am->nIdCount);\n+                        am->mapInfo[am->nIdCount] = info;\n+                        am->mapAddr[info] = am->nIdCount;\n+                        vTried.push_back(am->nIdCount);\n+                        am->nIdCount++;\n+                    } else {\n+                        nLost++;\n+                    }\n+                }\n+                am->nTried -= nLost;\n+                for (int b = 0; b < nUBuckets; b++)\n+                {\n+                    std::set<int> &vNew = am->vvNew[b];\n+                    int nSize = 0;\n+                    READWRITE(nSize);\n+                    for (int n = 0; n < nSize; n++)\n+                    {\n+                        int nIndex = 0;\n+                        READWRITE(nIndex);\n+                        CAddrInfo &info = am->mapInfo[nIndex];\n+                        if (nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS)\n+                        {\n+                            info.nRefCount++;\n+                            vNew.insert(nIndex);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    });)\n+\n+    CAddrMan() : vRandom(0), vvTried(ADDRMAN_TRIED_BUCKET_COUNT, std::vector<int>(0)), vvNew(ADDRMAN_NEW_BUCKET_COUNT, std::set<int>())\n+    {\n+         nKey.resize(32);\n+         RAND_bytes(&nKey[0], 32);\n+\n+         nIdCount = 0;\n+         nTried = 0;\n+         nNew = 0;\n+    }\n+\n+    // Return the number of (unique) addresses in all tables.\n+    int size()\n+    {\n+        return vRandom.size();\n+    }\n+\n+    // Consistency check\n+    void Check()\n+    {\n+#ifdef DEBUG_ADDRMAN\n+        CRITICAL_BLOCK(cs)\n+        {\n+            int err;\n+            if ((err=Check_()))\n+                printf(\"ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\\n\", err);\n+        }\n+#endif\n+    }\n+\n+    // Add a single address.\n+    bool Add(const CAddress &addr, const CNetAddr& source, int64 nTimePenalty = 0)\n+    {\n+        bool fRet = false;\n+        CRITICAL_BLOCK(cs)\n+        {\n+            Check();\n+            fRet |= Add_(addr, source, nTimePenalty);\n+            Check();\n+        }\n+        if (fRet)\n+            printf(\"Added %s from %s: %i tried, %i new\\n\", addr.ToStringIPPort().c_str(), source.ToString().c_str(), nTried, nNew);\n+        return fRet;\n+    }\n+\n+    // Add multiple addresses.\n+    bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64 nTimePenalty = 0)\n+    {\n+        int nAdd = 0;\n+        CRITICAL_BLOCK(cs)\n+        {\n+            Check();\n+            for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n+                nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n+            Check();\n+        }\n+        if (nAdd)\n+            printf(\"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString().c_str(), nTried, nNew);\n+        return nAdd > 0;\n+    }\n+\n+    // Mark an entry as accessible.\n+    void Good(const CService &addr, int64 nTime = GetAdjustedTime())\n+    {\n+        CRITICAL_BLOCK(cs)\n+        {\n+            Check();\n+            Good_(addr, nTime);\n+            Check();\n+        }\n+    }\n+\n+    // Mark an entry as connection attempted to.\n+    void Attempt(const CService &addr, int64 nTime = GetAdjustedTime())\n+    {\n+        CRITICAL_BLOCK(cs)\n+        {\n+            Check();\n+            Attempt_(addr, nTime);\n+            Check();\n+        }\n+    }\n+\n+    // Choose an address to connect to.\n+    // nUnkBias determines how much \"new\" entries are favored over \"tried\" ones (0-100).\n+    CAddress Select(int nUnkBias = 50)\n+    {\n+        CAddress addrRet;\n+        CRITICAL_BLOCK(cs)\n+        {\n+            Check();\n+            addrRet = Select_(nUnkBias);\n+            Check();\n+        }\n+        return addrRet;\n+    }\n+\n+    // Return a bunch of addresses, selected at random.\n+    std::vector<CAddress> GetAddr()\n+    {\n+        Check();\n+        std::vector<CAddress> vAddr;\n+        CRITICAL_BLOCK(cs)\n+            GetAddr_(vAddr);\n+        Check();\n+        return vAddr;\n+    }\n+\n+    // Mark an entry as currently-connected-to.\n+    void Connected(const CService &addr, int64 nTime = GetAdjustedTime())\n+    {\n+        CRITICAL_BLOCK(cs)\n+        {\n+            Check();\n+            Connected_(addr, nTime);\n+            Check();\n+        }\n+    }\n+};\n+\n+#endif"
      },
      {
        "sha": "645f725153271049853d564a962702851cbff925",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 23,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=5fee401fe14aa6459428a26a82f764db70a6a0b9",
        "patch": "@@ -621,52 +621,77 @@ bool CAddrDB::WriteAddress(const CAddress& addr)\n     return Write(make_pair(string(\"addr\"), addr.GetKey()), addr);\n }\n \n+bool CAddrDB::WriteAddrman(const CAddrMan& addrman)\n+{\n+    return Write(string(\"addrman\"), addrman);\n+}\n+\n bool CAddrDB::EraseAddress(const CAddress& addr)\n {\n     return Erase(make_pair(string(\"addr\"), addr.GetKey()));\n }\n \n-bool CAddrDB::LoadAddresses()\n+bool CAddrDB::LoadAddresses(bool &fUpdate)\n {\n-    CRITICAL_BLOCK(cs_mapAddresses)\n+    bool fAddrMan = false;\n+    if (Read(string(\"addrman\"), addrman))\n     {\n-        // Get cursor\n-        Dbc* pcursor = GetCursor();\n-        if (!pcursor)\n+        printf(\"Loaded %i addresses\\n\", addrman.size());\n+        fAddrMan = true;\n+    }\n+\n+    vector<CAddress> vAddr;\n+\n+    // Get cursor\n+    Dbc* pcursor = GetCursor();\n+    if (!pcursor)\n+        return false;\n+\n+    loop\n+    {\n+        // Read next record\n+        CDataStream ssKey;\n+        CDataStream ssValue;\n+        int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n+        if (ret == DB_NOTFOUND)\n+            break;\n+        else if (ret != 0)\n             return false;\n \n-        loop\n+        // Unserialize\n+        string strType;\n+        ssKey >> strType;\n+        if (strType == \"addr\")\n         {\n-            // Read next record\n-            CDataStream ssKey;\n-            CDataStream ssValue;\n-            int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n-            if (ret == DB_NOTFOUND)\n-                break;\n-            else if (ret != 0)\n-                return false;\n-\n-            // Unserialize\n-            string strType;\n-            ssKey >> strType;\n-            if (strType == \"addr\")\n+            if (fAddrMan)\n+                fUpdate = true;\n+            else\n             {\n                 CAddress addr;\n                 ssValue >> addr;\n-                mapAddresses.insert(make_pair(addr.GetKey(), addr));\n+                vAddr.push_back(addr);\n             }\n+\n         }\n-        pcursor->close();\n+    }\n+    pcursor->close();\n \n-        printf(\"Loaded %d addresses\\n\", mapAddresses.size());\n+    if (!fAddrMan)\n+    {\n+        addrman.Add(vAddr, CNetAddr(\"0.0.0.0\"));\n+        printf(\"Loaded %i addresses\\n\", addrman.size());\n     }\n \n     return true;\n }\n \n bool LoadAddresses()\n {\n-    return CAddrDB(\"cr+\").LoadAddresses();\n+    bool fUpdate = false;\n+    bool fRet = CAddrDB(\"cr+\").LoadAddresses(fUpdate);\n+    if (fUpdate)\n+        CDB::Rewrite(\"addr.dat\", \"\\004addr\");\n+    return fRet;\n }\n \n "
      },
      {
        "sha": "81f7a98c3392bc88489b0cb373f690a073b88068",
        "filename": "src/db.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.h?ref=5fee401fe14aa6459428a26a82f764db70a6a0b9",
        "patch": "@@ -16,6 +16,7 @@\n class CAccount;\n class CAccountingEntry;\n class CAddress;\n+class CAddrMan;\n class CBlockLocator;\n class CDiskBlockIndex;\n class CDiskTxPos;\n@@ -307,7 +308,8 @@ class CAddrDB : public CDB\n public:\n     bool WriteAddress(const CAddress& addr);\n     bool EraseAddress(const CAddress& addr);\n-    bool LoadAddresses();\n+    bool WriteAddrman(const CAddrMan& addr);\n+    bool LoadAddresses(bool &fUpdate);\n };\n \n bool LoadAddresses();"
      },
      {
        "sha": "2b21f6d5937226a640f95f0b3f06dc41b412d545",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=5fee401fe14aa6459428a26a82f764db70a6a0b9",
        "patch": "@@ -543,7 +543,7 @@ bool AppInit2(int argc, char* argv[])\n             CAddress addr(CService(strAddr, GetDefaultPort(), fAllowDNS));\n             addr.nTime = 0; // so it won't relay unless successfully connected\n             if (addr.IsValid())\n-                AddAddress(addr);\n+                addrman.Add(addr, CNetAddr(\"127.0.0.1\"));\n         }\n     }\n "
      },
      {
        "sha": "09bacc165884ba4586322893e827fddaf609c229",
        "filename": "src/irc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/irc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/irc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/irc.cpp?ref=5fee401fe14aa6459428a26a82f764db70a6a0b9",
        "patch": "@@ -341,7 +341,7 @@ void ThreadIRCSeed2(void* parg)\n                 if (DecodeAddress(pszName, addr))\n                 {\n                     addr.nTime = GetAdjustedTime();\n-                    if (AddAddress(addr, 51 * 60))\n+                    if (addrman.Add(addr, addrConnect, 51 * 60))\n                         printf(\"IRC got new address: %s\\n\", addr.ToString().c_str());\n                     nGotIRCAddresses++;\n                 }"
      },
      {
        "sha": "a8fabc3535eab7929ec1ec2b02407dacd9b8f134",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 53,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=5fee401fe14aa6459428a26a82f764db70a6a0b9",
        "patch": "@@ -2155,11 +2155,18 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             }\n \n             // Get recent addresses\n-            if (pfrom->nVersion >= 31402 || mapAddresses.size() < 1000)\n+            if (pfrom->nVersion >= 31402 || addrman.size() < 1000)\n             {\n                 pfrom->PushMessage(\"getaddr\");\n                 pfrom->fGetAddr = true;\n             }\n+            addrman.Good(pfrom->addr);\n+        } else {\n+            if (((CNetAddr)pfrom->addr) == (CNetAddr)addrFrom)\n+            {\n+                addrman.Add(addrFrom, addrFrom);\n+                addrman.Good(addrFrom);\n+            }\n         }\n \n         // Ask the first connected node for block updates\n@@ -2205,7 +2212,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         vRecv >> vAddr;\n \n         // Don't want addr from older versions unless seeding\n-        if (pfrom->nVersion < 31402 && mapAddresses.size() > 1000)\n+        if (pfrom->nVersion < 31402 && addrman.size() > 1000)\n             return true;\n         if (vAddr.size() > 1000)\n         {\n@@ -2214,8 +2221,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         }\n \n         // Store the new addresses\n-        CAddrDB addrDB;\n-        addrDB.TxnBegin();\n         int64 nNow = GetAdjustedTime();\n         int64 nSince = nNow - 10 * 60;\n         BOOST_FOREACH(CAddress& addr, vAddr)\n@@ -2227,7 +2232,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                 continue;\n             if (addr.nTime <= 100000000 || addr.nTime > nNow + 10 * 60)\n                 addr.nTime = nNow - 5 * 24 * 60 * 60;\n-            AddAddress(addr, 2 * 60 * 60, &addrDB);\n             pfrom->AddAddressKnown(addr);\n             if (addr.nTime > nSince && !pfrom->fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n             {\n@@ -2259,7 +2263,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                 }\n             }\n         }\n-        addrDB.TxnCommit();  // Save addresses (it's ok if this fails)\n+        addrman.Add(vAddr, pfrom->addr, 2 * 60 * 60);\n         if (vAddr.size() < 1000)\n             pfrom->fGetAddr = false;\n     }\n@@ -2500,25 +2504,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n     else if (strCommand == \"getaddr\")\n     {\n-        // Nodes rebroadcast an addr every 24 hours\n         pfrom->vAddrToSend.clear();\n-        int64 nSince = GetAdjustedTime() - 3 * 60 * 60; // in the last 3 hours\n-        CRITICAL_BLOCK(cs_mapAddresses)\n-        {\n-            unsigned int nCount = 0;\n-            BOOST_FOREACH(const PAIRTYPE(vector<unsigned char>, CAddress)& item, mapAddresses)\n-            {\n-                const CAddress& addr = item.second;\n-                if (addr.nTime > nSince)\n-                    nCount++;\n-            }\n-            BOOST_FOREACH(const PAIRTYPE(vector<unsigned char>, CAddress)& item, mapAddresses)\n-            {\n-                const CAddress& addr = item.second;\n-                if (addr.nTime > nSince && GetRand(nCount) < 2500)\n-                    pfrom->PushAddress(addr);\n-            }\n-        }\n+        vector<CAddress> vAddr = addrman.GetAddr();\n+        BOOST_FOREACH(const CAddress &addr, vAddr)\n+            pfrom->PushAddress(addr);\n     }\n \n \n@@ -2760,35 +2749,6 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n             nLastRebroadcast = GetTime();\n         }\n \n-        // Clear out old addresses periodically so it's not too much work at once\n-        static int64 nLastClear;\n-        if (nLastClear == 0)\n-            nLastClear = GetTime();\n-        if (GetTime() - nLastClear > 10 * 60 && vNodes.size() >= 3)\n-        {\n-            nLastClear = GetTime();\n-            CRITICAL_BLOCK(cs_mapAddresses)\n-            {\n-                CAddrDB addrdb;\n-                int64 nSince = GetAdjustedTime() - 14 * 24 * 60 * 60;\n-                for (map<vector<unsigned char>, CAddress>::iterator mi = mapAddresses.begin();\n-                     mi != mapAddresses.end();)\n-                {\n-                    const CAddress& addr = (*mi).second;\n-                    if (addr.nTime < nSince)\n-                    {\n-                        if (mapAddresses.size() < 1000 || GetTime() > nLastClear + 20)\n-                            break;\n-                        addrdb.EraseAddress(addr);\n-                        mapAddresses.erase(mi++);\n-                    }\n-                    else\n-                        mi++;\n-                }\n-            }\n-        }\n-\n-\n         //\n         // Message: addr\n         //"
      },
      {
        "sha": "40ce1dcdca001fbc71b615f5cfde9c481ea24812",
        "filename": "src/makefile.linux-mingw",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/makefile.linux-mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/makefile.linux-mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.linux-mingw?ref=5fee401fe14aa6459428a26a82f764db70a6a0b9",
        "patch": "@@ -45,6 +45,7 @@ HEADERS = $(wildcard *.h)\n OBJS= \\\n     obj/checkpoints.o \\\n     obj/netbase.o \\\n+    obj/addrman.o \\\n     obj/crypter.o \\\n     obj/key.o \\\n     obj/db.o \\"
      },
      {
        "sha": "f7dfcc74c1575ffd42e43d45dfe1ffee1cf62fb4",
        "filename": "src/makefile.mingw",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/makefile.mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/makefile.mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.mingw?ref=5fee401fe14aa6459428a26a82f764db70a6a0b9",
        "patch": "@@ -43,6 +43,7 @@ HEADERS = $(wildcard *.h)\n OBJS= \\\n     obj/checkpoints.o \\\n     obj/netbase.o \\\n+    obj/addrman.o \\\n     obj/crypter.o \\\n     obj/key.o \\\n     obj/db.o \\"
      },
      {
        "sha": "8790d92ce4b48ca14bf75f4441806ec2d3e3aa32",
        "filename": "src/makefile.osx",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/makefile.osx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/makefile.osx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.osx?ref=5fee401fe14aa6459428a26a82f764db70a6a0b9",
        "patch": "@@ -60,6 +60,7 @@ CFLAGS=-mmacosx-version-min=10.5 -arch i386 -O3 \\\n OBJS= \\\n     obj/checkpoints.o \\\n     obj/netbase.o \\\n+    obj/addrman.o \\\n     obj/crypter.o \\\n     obj/key.o \\\n     obj/db.o \\"
      },
      {
        "sha": "8d354602d44e547b204d0d4ef72b4c35ea0a3d95",
        "filename": "src/makefile.unix",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.unix?ref=5fee401fe14aa6459428a26a82f764db70a6a0b9",
        "patch": "@@ -91,6 +91,7 @@ xCXXFLAGS=-pthread -Wextra -Wno-sign-compare -Wno-char-subscripts -Wno-invalid-o\n OBJS= \\\n     obj/checkpoints.o \\\n     obj/netbase.o \\\n+    obj/addrman.o \\\n     obj/crypter.o \\\n     obj/key.o \\\n     obj/db.o \\"
      },
      {
        "sha": "08edafb399ce5684af6e49698262ff1e1404c1ff",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 86,
        "deletions": 164,
        "changes": 250,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=5fee401fe14aa6459428a26a82f764db70a6a0b9",
        "patch": "@@ -9,6 +9,7 @@\n #include \"net.h\"\n #include \"init.h\"\n #include \"strlcpy.h\"\n+#include \"addrman.h\"\n \n #ifdef WIN32\n #include <string.h>\n@@ -49,11 +50,10 @@ static CNode* pnodeLocalHost = NULL;\n uint64 nLocalHostNonce = 0;\n array<int, THREAD_MAX> vnThreadsRunning;\n static SOCKET hListenSocket = INVALID_SOCKET;\n+CAddrMan addrman;\n \n vector<CNode*> vNodes;\n CCriticalSection cs_vNodes;\n-map<vector<unsigned char>, CAddress> mapAddresses;\n-CCriticalSection cs_mapAddresses;\n map<CInv, CDataStream> mapRelay;\n deque<pair<int64, CInv> > vRelayExpiration;\n CCriticalSection cs_mapRelay;\n@@ -279,86 +279,9 @@ void ThreadGetMyExternalIP(void* parg)\n \n \n \n-bool AddAddress(CAddress addr, int64 nTimePenalty, CAddrDB *pAddrDB)\n-{\n-    if (!addr.IsRoutable())\n-        return false;\n-    if ((CService)addr == (CService)addrLocalHost)\n-        return false;\n-    addr.nTime = max((int64)0, (int64)addr.nTime - nTimePenalty);\n-    bool fUpdated = false;\n-    bool fNew = false;\n-    CAddress addrFound = addr;\n-\n-    CRITICAL_BLOCK(cs_mapAddresses)\n-    {\n-        map<vector<unsigned char>, CAddress>::iterator it = mapAddresses.find(addr.GetKey());\n-        if (it == mapAddresses.end())\n-        {\n-            // New address\n-            printf(\"AddAddress(%s)\\n\", addr.ToString().c_str());\n-            mapAddresses.insert(make_pair(addr.GetKey(), addr));\n-            fUpdated = true;\n-            fNew = true;\n-        }\n-        else\n-        {\n-            addrFound = (*it).second;\n-            if ((addrFound.nServices | addr.nServices) != addrFound.nServices)\n-            {\n-                // Services have been added\n-                addrFound.nServices |= addr.nServices;\n-                fUpdated = true;\n-            }\n-            bool fCurrentlyOnline = (GetAdjustedTime() - addr.nTime < 24 * 60 * 60);\n-            int64 nUpdateInterval = (fCurrentlyOnline ? 60 * 60 : 24 * 60 * 60);\n-            if (addrFound.nTime < addr.nTime - nUpdateInterval)\n-            {\n-                // Periodically update most recently seen time\n-                addrFound.nTime = addr.nTime;\n-                fUpdated = true;\n-            }\n-        }\n-    }\n-    // There is a nasty deadlock bug if this is done inside the cs_mapAddresses\n-    // CRITICAL_BLOCK:\n-    // Thread 1:  begin db transaction (locks inside-db-mutex)\n-    //            then AddAddress (locks cs_mapAddresses)\n-    // Thread 2:  AddAddress (locks cs_mapAddresses)\n-    //             ... then db operation hangs waiting for inside-db-mutex\n-    if (fUpdated)\n-    {\n-        if (pAddrDB)\n-            pAddrDB->WriteAddress(addrFound);\n-        else\n-            CAddrDB().WriteAddress(addrFound);\n-    }\n-    return fNew;\n-}\n-\n void AddressCurrentlyConnected(const CService& addr)\n {\n-    CAddress *paddrFound = NULL;\n-\n-    CRITICAL_BLOCK(cs_mapAddresses)\n-    {\n-        // Only if it's been published already\n-        map<vector<unsigned char>, CAddress>::iterator it = mapAddresses.find(addr.GetKey());\n-        if (it != mapAddresses.end())\n-            paddrFound = &(*it).second;\n-    }\n-\n-    if (paddrFound)\n-    {\n-        int64 nUpdateInterval = 20 * 60;\n-        if (paddrFound->nTime < GetAdjustedTime() - nUpdateInterval)\n-        {\n-            // Periodically update most recently seen time\n-            paddrFound->nTime = GetAdjustedTime();\n-            CAddrDB addrdb;\n-            addrdb.WriteAddress(*paddrFound);\n-        }\n-    }\n+    addrman.Connected(addr);\n }\n \n \n@@ -505,13 +428,11 @@ CNode* ConnectNode(CAddress addrConnect, int64 nTimeout)\n     }\n \n     /// debug print\n-    printf(\"trying connection %s lastseen=%.1fhrs lasttry=%.1fhrs\\n\",\n+    printf(\"trying connection %s lastseen=%.1fhrs\\n\",\n         addrConnect.ToString().c_str(),\n-        (double)(addrConnect.nTime - GetAdjustedTime())/3600.0,\n-        (double)(addrConnect.nLastTry - GetAdjustedTime())/3600.0);\n+        (double)(addrConnect.nTime - GetAdjustedTime())/3600.0);\n \n-    CRITICAL_BLOCK(cs_mapAddresses)\n-        mapAddresses[addrConnect.GetKey()].nLastTry = GetAdjustedTime();\n+    addrman.Attempt(addrConnect);\n \n     // Connect\n     SOCKET hSocket;\n@@ -1125,12 +1046,15 @@ void MapPort(bool /* unused fMapPort */)\n \n \n \n-\n-static const char *strDNSSeed[] = {\n-    \"bitseed.xf2.org\",\n-    \"dnsseed.bluematt.me\",\n-    \"seed.bitcoin.sipa.be\",\n-    \"dnsseed.bitcoin.dashjr.org\",\n+// DNS seeds\n+// Each pair gives a source name and a seed name.\n+// The first name is used as information source for addrman.\n+// The second name should resolve to a list of seed addresses.\n+static const char *strDNSSeed[][2] = {\n+    {\"xf2.org\", \"bitseed.xf2.org\"},\n+    {\"bluematt.me\", \"dnsseed.bluematt.me\"},\n+    {\"bitcoin.sipa.be\", \"seed.bitcoin.sipa.be\"},\n+    {\"dashjr.org\", \"dnsseed.bitcoin.dashjr.org\"},\n };\n \n void ThreadDNSAddressSeed(void* parg)\n@@ -1163,22 +1087,18 @@ void ThreadDNSAddressSeed2(void* parg)\n \n         for (int seed_idx = 0; seed_idx < ARRAYLEN(strDNSSeed); seed_idx++) {\n             vector<CNetAddr> vaddr;\n-            if (LookupHost(strDNSSeed[seed_idx], vaddr))\n+            vector<CAddress> vAdd;\n+            if (LookupHost(strDNSSeed[seed_idx][1], vaddr))\n             {\n-                CAddrDB addrDB;\n-                addrDB.TxnBegin();\n-                BOOST_FOREACH (CNetAddr& ip, vaddr)\n+                BOOST_FOREACH(CNetAddr& ip, vaddr)\n                 {\n-                    if (ip.IsRoutable())\n-                    {\n-                        CAddress addr(CService(ip, GetDefaultPort()), NODE_NETWORK);\n-                        addr.nTime = 0;\n-                        AddAddress(addr, 0, &addrDB);\n-                        found++;\n-                    }\n+                    CAddress addr = CAddress(CService(ip, GetDefaultPort()));\n+                    addr.nTime = 0;\n+                    vAdd.push_back(addr);\n+                    found++;\n                 }\n-                addrDB.TxnCommit();  // Save addresses (it's ok if this fails)\n             }\n+            addrman.Add(vAdd, CNetAddr(strDNSSeed[seed_idx][0], true));\n         }\n     }\n \n@@ -1277,7 +1197,37 @@ unsigned int pnSeed[] =\n     0xc461d84a, 0xb2dbe247,\n };\n \n+void DumpAddresses()\n+{\n+    CAddrDB adb;\n+    adb.WriteAddrman(addrman);\n+}\n \n+void ThreadDumpAddress2(void* parg)\n+{\n+    vnThreadsRunning[THREAD_DUMPADDRESS]++;\n+    while (!fShutdown)\n+    {\n+        DumpAddresses();\n+        vnThreadsRunning[THREAD_DUMPADDRESS]--;\n+        Sleep(100000);\n+        vnThreadsRunning[THREAD_DUMPADDRESS]++;\n+    }\n+    vnThreadsRunning[THREAD_DUMPADDRESS]--;\n+}\n+\n+void ThreadDumpAddress(void* parg)\n+{\n+    IMPLEMENT_RANDOMIZE_STACK(ThreadDumpAddress(parg));\n+    try\n+    {\n+        ThreadDumpAddress2(parg);\n+    }\n+    catch (std::exception& e) {\n+        PrintException(&e, \"ThreadDumpAddress()\");\n+    }\n+    printf(\"ThreadDumpAddress exiting\\n\");\n+}\n \n void ThreadOpenConnections(void* parg)\n {\n@@ -1326,6 +1276,8 @@ void ThreadOpenConnections2(void* parg)\n     int64 nStart = GetTime();\n     loop\n     {\n+        int nOutbound = 0;\n+\n         vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n         Sleep(500);\n         vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n@@ -1335,7 +1287,7 @@ void ThreadOpenConnections2(void* parg)\n         // Limit outbound connections\n         loop\n         {\n-            int nOutbound = 0;\n+            nOutbound = 0;\n             CRITICAL_BLOCK(cs_vNodes)\n                 BOOST_FOREACH(CNode* pnode, vNodes)\n                     if (!pnode->fInbound)\n@@ -1353,16 +1305,11 @@ void ThreadOpenConnections2(void* parg)\n \n         bool fAddSeeds = false;\n \n-        CRITICAL_BLOCK(cs_mapAddresses)\n-        {\n-            // Add seed nodes if IRC isn't working\n-            bool fTOR = (fUseProxy && addrProxy.GetPort() == 9050);\n-            if (mapAddresses.empty() && (GetTime() - nStart > 60 || fTOR) && !fTestNet)\n-                fAddSeeds = true;\n-        }\n-\n-        if (fAddSeeds)\n+        // Add seed nodes if IRC isn't working\n+        bool fTOR = (fUseProxy && addrProxy.GetPort() == 9050);\n+        if (addrman.size()==0 && (GetTime() - nStart > 60 || fTOR) && !fTestNet)\n         {\n+            std::vector<CAddress> vAdd;\n             for (int i = 0; i < ARRAYLEN(pnSeed); i++)\n             {\n                 // It'll only connect to one or two seed nodes because once it connects,\n@@ -1374,8 +1321,9 @@ void ThreadOpenConnections2(void* parg)\n                 memcpy(&ip, &pnSeed[i], sizeof(ip));\n                 CAddress addr(CService(ip, GetDefaultPort()));\n                 addr.nTime = GetTime()-GetRand(nOneWeek)-nOneWeek;\n-                AddAddress(addr);\n+                vAdd.push_back(addr);\n             }\n+            addrman.Add(vAdd, CNetAddr(\"127.0.0.1\"));\n         }\n \n         //\n@@ -1393,59 +1341,28 @@ void ThreadOpenConnections2(void* parg)\n \n         int64 nANow = GetAdjustedTime();\n \n-        CRITICAL_BLOCK(cs_mapAddresses)\n+        int nTries = 0;\n+        loop\n         {\n-            BOOST_FOREACH(const PAIRTYPE(vector<unsigned char>, CAddress)& item, mapAddresses)\n-            {\n-                const CAddress& addr = item.second;\n-                if (!addr.IsIPv4() || !addr.IsValid() || setConnected.count(addr.GetGroup()))\n-                    continue;\n-                int64 nSinceLastSeen = nANow - addr.nTime;\n-                int64 nSinceLastTry = nANow - addr.nLastTry;\n-\n-                // Randomize the order in a deterministic way, putting the standard port first\n-                int64 nRandomizer = (uint64)(nStart * 4951 + addr.nLastTry * 9567851 + addr.GetHash()) % (2 * 60 * 60);\n-                if (addr.GetPort() != GetDefaultPort())\n-                    nRandomizer += 2 * 60 * 60;\n-\n-                // Last seen  Base retry frequency\n-                //   <1 hour   10 min\n-                //    1 hour    1 hour\n-                //    4 hours   2 hours\n-                //   24 hours   5 hours\n-                //   48 hours   7 hours\n-                //    7 days   13 hours\n-                //   30 days   27 hours\n-                //   90 days   46 hours\n-                //  365 days   93 hours\n-                int64 nDelay = (int64)(3600.0 * sqrt(fabs((double)nSinceLastSeen) / 3600.0) + nRandomizer);\n-\n-                // Fast reconnect for one hour after last seen\n-                if (nSinceLastSeen < 60 * 60)\n-                    nDelay = 10 * 60;\n-\n-                // Limit retry frequency\n-                if (nSinceLastTry < nDelay)\n-                    continue;\n+            // use an nUnkBias between 10 (no outgoing connections) and 90 (8 outgoing connections)\n+            CAddress addr = addrman.Select(10 + min(nOutbound,8)*10);\n \n-                // If we have IRC, we'll be notified when they first come online,\n-                // and again every 24 hours by the refresh broadcast.\n-                if (nGotIRCAddresses > 0 && vNodes.size() >= 2 && nSinceLastSeen > 24 * 60 * 60)\n-                    continue;\n+            // if we selected an invalid address, restart\n+            if (!addr.IsIPv4() || !addr.IsValid() || setConnected.count(addr.GetGroup()) || addr == addrLocalHost)\n+                break;\n \n-                // Only try the old stuff if we don't have enough connections\n-                if (vNodes.size() >= 8 && nSinceLastSeen > 24 * 60 * 60)\n-                    continue;\n+            nTries++;\n \n-                // If multiple addresses are ready, prioritize by time since\n-                // last seen and time since last tried.\n-                int64 nScore = min(nSinceLastTry, (int64)24 * 60 * 60) - nSinceLastSeen - nRandomizer;\n-                if (nScore > nBest)\n-                {\n-                    nBest = nScore;\n-                    addrConnect = addr;\n-                }\n-            }\n+            // only consider very recently tried nodes after 30 failed attempts\n+            if (nANow - addr.nLastTry < 600 && nTries < 30)\n+                continue;\n+\n+            // do not allow non-default ports, unless after 50 invalid addresses selected already\n+            if (addr.GetPort() != GetDefaultPort() && nTries < 50)\n+                continue;\n+\n+            addrConnect = addr;\n+            break;\n         }\n \n         if (addrConnect.IsValid())\n@@ -1811,6 +1728,10 @@ void StartNode(void* parg)\n     if (!CreateThread(ThreadMessageHandler, NULL))\n         printf(\"Error: CreateThread(ThreadMessageHandler) failed\\n\");\n \n+    // Dump network addresses\n+    if (!CreateThread(ThreadDumpAddress, NULL))\n+        printf(\"Error; CreateThread(ThreadDumpAddress) failed\\n\");\n+\n     // Generate coins in the background\n     GenerateBitcoins(fGenerateBitcoins, pwalletMain);\n }\n@@ -1840,10 +1761,11 @@ bool StopNode()\n     if (fHaveUPnP && vnThreadsRunning[THREAD_UPNP] > 0) printf(\"ThreadMapPort still running\\n\");\n     if (vnThreadsRunning[THREAD_DNSSEED] > 0) printf(\"ThreadDNSAddressSeed still running\\n\");\n     if (vnThreadsRunning[THREAD_ADDEDCONNECTIONS] > 0) printf(\"ThreadOpenAddedConnections still running\\n\");\n+    if (vnThreadsRunning[THREAD_DUMPADDRESS] > 0) printf(\"ThreadDumpAddresses still running\\n\");\n     while (vnThreadsRunning[THREAD_MESSAGEHANDLER] > 0 || vnThreadsRunning[THREAD_RPCSERVER] > 0)\n         Sleep(20);\n     Sleep(50);\n-\n+    DumpAddresses();\n     return true;\n }\n "
      },
      {
        "sha": "6fd494487cc5eddc47b83d15a56b28ab3c1a6026",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=5fee401fe14aa6459428a26a82f764db70a6a0b9",
        "patch": "@@ -16,6 +16,7 @@\n \n #include \"netbase.h\"\n #include \"protocol.h\"\n+#include \"addrman.h\"\n \n class CAddrDB;\n class CRequestTracker;\n@@ -31,7 +32,6 @@ static const unsigned int PUBLISH_HOPS = 5;\n \n bool RecvLine(SOCKET hSocket, std::string& strLine);\n bool GetMyExternalIP(CNetAddr& ipRet);\n-bool AddAddress(CAddress addr, int64 nTimePenalty=0, CAddrDB *pAddrDB=NULL);\n void AddressCurrentlyConnected(const CService& addr);\n CNode* FindNode(const CNetAddr& ip);\n CNode* FindNode(const CService& ip);\n@@ -79,6 +79,7 @@ enum threadId\n     THREAD_UPNP,\n     THREAD_DNSSEED,\n     THREAD_ADDEDCONNECTIONS,\n+    THREAD_DUMPADDRESS,\n \n     THREAD_MAX\n };\n@@ -89,11 +90,10 @@ extern uint64 nLocalServices;\n extern CAddress addrLocalHost;\n extern uint64 nLocalHostNonce;\n extern boost::array<int, THREAD_MAX> vnThreadsRunning;\n+extern CAddrMan addrman;\n \n extern std::vector<CNode*> vNodes;\n extern CCriticalSection cs_vNodes;\n-extern std::map<std::vector<unsigned char>, CAddress> mapAddresses;\n-extern CCriticalSection cs_mapAddresses;\n extern std::map<CInv, CDataStream> mapRelay;\n extern std::deque<std::pair<int64, CInv> > vRelayExpiration;\n extern CCriticalSection cs_mapRelay;"
      },
      {
        "sha": "baf7c412a0f586deee7929b1616a4cda1157ad01",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 3,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=5fee401fe14aa6459428a26a82f764db70a6a0b9",
        "patch": "@@ -519,15 +519,22 @@ bool CNetAddr::GetIn6Addr(struct in6_addr* pipv6Addr) const\n std::vector<unsigned char> CNetAddr::GetGroup() const\n {\n     std::vector<unsigned char> vchRet;\n-    int nClass = 0; // 0=IPv6, 1=IPv4, 255=unroutable\n+    int nClass = 0; // 0=IPv6, 1=IPv4, 254=local, 255=unroutable\n     int nStartByte = 0;\n     int nBits = 16;\n \n-    // for unroutable addresses, each address is considered different\n+    // all local addresses belong to the same group\n+    if (IsLocal())\n+    {\n+        nClass = 254;\n+        nBits = 0;\n+    }\n+\n+    // all unroutable addresses belong to the same group\n     if (!IsRoutable())\n     {\n         nClass = 255;\n-        nBits = 128;\n+        nBits = 0;\n     }\n     // for IPv4 addresses, '1' + the 16 higher-order bits of the IP\n     // includes mapped IPv4, SIIT translated IPv4, and the well-known prefix"
      },
      {
        "sha": "613c47f042a6c66cb119d7ef8b071bc35d5207a2",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=5fee401fe14aa6459428a26a82f764db70a6a0b9",
        "patch": "@@ -94,7 +94,7 @@ class CAddress : public CService\n         unsigned int nTime;\n \n         // memory only\n-        unsigned int nLastTry;\n+        int64 nLastTry;\n };\n \n class CInv"
      },
      {
        "sha": "783e7069e9c86c1840e2596e7af0ec3c85131798",
        "filename": "src/uint256.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5fee401fe14aa6459428a26a82f764db70a6a0b9/src/uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uint256.h?ref=5fee401fe14aa6459428a26a82f764db70a6a0b9",
        "patch": "@@ -348,6 +348,10 @@ class base_uint\n         return sizeof(pn);\n     }\n \n+    uint64 Get64(int n=0) const\n+    {\n+        return pn[2*n] | (uint64)pn[2*n+1] << 32;\n+    }\n \n     unsigned int GetSerializeSize(int nType=0, int nVersion=PROTOCOL_VERSION) const\n     {"
      }
    ]
  }
]