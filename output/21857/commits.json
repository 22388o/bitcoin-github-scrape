[
  {
    "sha": "5cee909b883b22f8813ed9e1619e7dea28331759",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1Y2VlOTA5Yjg4M2IyMmY4ODEzZWQ5ZTE2MTllN2RlYTI4MzMxNzU5",
    "commit": {
      "author": {
        "name": "J0hn",
        "email": "songjh.john@gmail.com",
        "date": "2021-03-28T13:51:38Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-03-28T13:51:38Z"
      },
      "message": "Merge pull request #1 from bitcoin/master\n\nFixed the bug of bitcoin",
      "tree": {
        "sha": "53c31b7f8fd2b33490cb8fca315f31ea395c639f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/53c31b7f8fd2b33490cb8fca315f31ea395c639f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5cee909b883b22f8813ed9e1619e7dea28331759",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgYInqCRBK7hj4Ov3rIwAAdHIIAGS2OzgLFqnQNfbP80vXvCfd\nNYfXDfqjj19RVzNxjV5GbV0p6Vf6tPNMF8lvgaaN0qhtLUdeQUfmpawLVG3+wVIg\nq0Bn4ocFhUN0Y6riCZUehiwelMnC96rsqbPu8bYtNMCUYqK6lQB39Qi53CZD5KmW\nXg6QLkObFe7RPB1wA2+ss/ZaICOyC0wzAtV5WpiuMv0xaRh3SgvmLd0Vmu19YsG3\n2kK4qlKzaJ0bDV4iXOmD0pM6PHrHUHIMHoB0XTSmcZosdpw0zrPmCN/9rn6URdhJ\nBOELlqw1QvXpnlONQY+lAuc6h3R4IUcKrH+8zI+bc/4lmwh7WAsMlY8pYPh7ze4=\n=BS/+\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 53c31b7f8fd2b33490cb8fca315f31ea395c639f\nparent 1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05\nparent e658b0e49bee257e197dd8ca37ee3ffa73092d92\nauthor J0hn <songjh.john@gmail.com> 1616939498 +0100\ncommitter GitHub <noreply@github.com> 1616939498 +0100\n\nMerge pull request #1 from bitcoin/master\n\nFixed the bug of bitcoin"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5cee909b883b22f8813ed9e1619e7dea28331759",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5cee909b883b22f8813ed9e1619e7dea28331759",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5cee909b883b22f8813ed9e1619e7dea28331759/comments",
    "author": {
      "login": "Rqcker",
      "id": 20661419,
      "node_id": "MDQ6VXNlcjIwNjYxNDE5",
      "avatar_url": "https://avatars.githubusercontent.com/u/20661419?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Rqcker",
      "html_url": "https://github.com/Rqcker",
      "followers_url": "https://api.github.com/users/Rqcker/followers",
      "following_url": "https://api.github.com/users/Rqcker/following{/other_user}",
      "gists_url": "https://api.github.com/users/Rqcker/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Rqcker/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Rqcker/subscriptions",
      "organizations_url": "https://api.github.com/users/Rqcker/orgs",
      "repos_url": "https://api.github.com/users/Rqcker/repos",
      "events_url": "https://api.github.com/users/Rqcker/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Rqcker/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05"
      },
      {
        "sha": "e658b0e49bee257e197dd8ca37ee3ffa73092d92",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e658b0e49bee257e197dd8ca37ee3ffa73092d92",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e658b0e49bee257e197dd8ca37ee3ffa73092d92"
      }
    ],
    "stats": {
      "total": 7479,
      "additions": 4837,
      "deletions": 2642
    },
    "files": [
      {
        "sha": "097874b17af0f2d60e3a5cd09ea8c103dc9d7007",
        "filename": ".appveyor.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/.appveyor.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/.appveyor.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.appveyor.yml?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -10,7 +10,7 @@ environment:\n   QT_DOWNLOAD_URL: 'https://github.com/sipsorcery/qt_win_binary/releases/download/qt598x64_vs2019_v1681/qt598_x64_vs2019_1681.zip'\n   QT_DOWNLOAD_HASH: '00cf7327818c07d74e0b1a4464ffe987c2728b00d49d4bf333065892af0515c3'\n   QT_LOCAL_PATH: 'C:\\Qt5.9.8_x64_static_vs2019'\n-  VCPKG_TAG: '2020.11-1'\n+  VCPKG_TAG: '75522bb1f2e7d863078bcd06322348f053a9e33f'\n install:\n # Disable zmq test for now since python zmq library on Windows would cause Access violation sometimes.\n # - cmd: pip install zmq"
      },
      {
        "sha": "e881e587bffed73d54ae5d9e5dd626bfeff07b80",
        "filename": ".cirrus.yml",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/.cirrus.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/.cirrus.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.cirrus.yml?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -180,3 +180,11 @@ task:\n     CI_USE_APT_INSTALL: \"no\"\n     PACKAGE_MANAGER_INSTALL: \"echo\"  # Nothing to do\n     FILE_ENV: \"./ci/test/00_setup_env_mac_host.sh\"\n+\n+task:\n+  name: 'ARM64 Android APK [bionic]'\n+  << : *GLOBAL_TASK_TEMPLATE\n+  container:\n+    image: ubuntu:bionic\n+  env:\n+    FILE_ENV: \"./ci/test/00_setup_env_android.sh\""
      },
      {
        "sha": "be62c3e6a96e936a9a65d9de293dc0a983056e28",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -78,6 +78,7 @@ COVERAGE_INFO = $(COV_TOOL_WRAPPER) baseline.info \\\n dist-hook:\n \t-$(GIT) archive --format=tar HEAD -- src/clientversion.cpp | $(AMTAR) -C $(top_distdir) -xf -\n \n+if TARGET_WINDOWS\n $(BITCOIN_WIN_INSTALLER): all-recursive\n \t$(MKDIR_P) $(top_builddir)/release\n \tSTRIPPROG=\"$(STRIP)\" $(INSTALL_STRIP_PROGRAM) $(BITCOIND_BIN) $(top_builddir)/release\n@@ -90,6 +91,10 @@ $(BITCOIN_WIN_INSTALLER): all-recursive\n \t  echo error: could not build $@\n \t@echo built $@\n \n+deploy: $(BITCOIN_WIN_INSTALLER)\n+endif\n+\n+if TARGET_DARWIN\n $(OSX_APP)/Contents/PkgInfo:\n \t$(MKDIR_P) $(@D)\n \t@echo \"APPL????\" > $@\n@@ -133,7 +138,7 @@ $(OSX_BACKGROUND_IMAGE): $(OSX_BACKGROUND_IMAGE).png $(OSX_BACKGROUND_IMAGE)@2x.\n \ttiffutil -cathidpicheck $^ -out $@\n \n deploydir: $(OSX_DMG)\n-else\n+else !BUILD_DARWIN\n APP_DIST_DIR=$(top_builddir)/dist\n APP_DIST_EXTRAS=$(APP_DIST_DIR)/.background/$(OSX_BACKGROUND_IMAGE) $(APP_DIST_DIR)/.DS_Store $(APP_DIST_DIR)/Applications\n \n@@ -160,15 +165,11 @@ $(APP_DIST_DIR)/$(OSX_APP)/Contents/MacOS/Bitcoin-Qt: $(OSX_APP_BUILT) $(OSX_PAC\n \tINSTALLNAMETOOL=$(INSTALLNAMETOOL) OTOOL=$(OTOOL) STRIP=$(STRIP) $(PYTHON) $(OSX_DEPLOY_SCRIPT) $(OSX_APP) $(OSX_VOLNAME) -translations-dir=$(QT_TRANSLATION_DIR)\n \n deploydir: $(APP_DIST_EXTRAS)\n-endif\n+endif !BUILD_DARWIN\n \n-if TARGET_DARWIN\n appbundle: $(OSX_APP_BUILT)\n deploy: $(OSX_DMG)\n endif\n-if TARGET_WINDOWS\n-deploy: $(BITCOIN_WIN_INSTALLER)\n-endif\n \n $(BITCOIN_QT_BIN): FORCE\n \t$(MAKE) -C src qt/$(@F)"
      },
      {
        "sha": "cce06e2ffffee99899ab743ee098d45a11ef3af0",
        "filename": "build-aux/m4/bitcoin_qt.m4",
        "status": "modified",
        "additions": 67,
        "deletions": 44,
        "changes": 111,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/build-aux/m4/bitcoin_qt.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/build-aux/m4/bitcoin_qt.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_qt.m4?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -111,9 +111,7 @@ AC_DEFUN([BITCOIN_QT_CONFIGURE],[\n   dnl For Qt5, we can check a header to find out whether Qt is build\n   dnl statically. When Qt is built statically, some plugins must be linked into\n   dnl the final binary as well.\n-  dnl With Qt5, languages moved into core and the WindowsIntegration plugin was\n-  dnl added.\n-  dnl _BITCOIN_QT_CHECK_STATIC_PLUGINS does a quick link-check and appends the\n+  dnl _BITCOIN_QT_CHECK_STATIC_PLUGIN does a quick link-check and appends the\n   dnl results to QT_LIBS.\n   BITCOIN_QT_CHECK([\n   TEMP_CPPFLAGS=$CPPFLAGS\n@@ -122,20 +120,46 @@ AC_DEFUN([BITCOIN_QT_CONFIGURE],[\n   CXXFLAGS=\"$PIC_FLAGS $CXXFLAGS\"\n   _BITCOIN_QT_IS_STATIC\n   if test \"x$bitcoin_cv_static_qt\" = xyes; then\n-    _BITCOIN_QT_FIND_STATIC_PLUGINS\n+    _BITCOIN_QT_CHECK_STATIC_LIBS\n+\n+    if test \"x$qt_plugin_path\" != x; then\n+      if test -d \"$qt_plugin_path/platforms\"; then\n+        QT_LIBS=\"$QT_LIBS -L$qt_plugin_path/platforms\"\n+      fi\n+      if test -d \"$qt_plugin_path/styles\"; then\n+        QT_LIBS=\"$QT_LIBS -L$qt_plugin_path/styles\"\n+      fi\n+      if test -d \"$qt_plugin_path/accessible\"; then\n+        QT_LIBS=\"$QT_LIBS -L$qt_plugin_path/accessible\"\n+      fi\n+      if test -d \"$qt_plugin_path/platforms/android\"; then\n+        QT_LIBS=\"$QT_LIBS -L$qt_plugin_path/platforms/android -lqtfreetype -lEGL\"\n+      fi\n+    fi\n+\n     AC_DEFINE(QT_STATICPLUGIN, 1, [Define this symbol if qt plugins are static])\n     if test \"x$TARGET_OS\" != xandroid; then\n-      _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(QMinimalIntegrationPlugin)],[-lqminimal])\n+      _BITCOIN_QT_CHECK_STATIC_PLUGIN([QMinimalIntegrationPlugin], [-lqminimal])\n       AC_DEFINE(QT_QPA_PLATFORM_MINIMAL, 1, [Define this symbol if the minimal qt platform exists])\n     fi\n     if test \"x$TARGET_OS\" = xwindows; then\n-      _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(QWindowsIntegrationPlugin)],[-lqwindows])\n+      dnl Linking against wtsapi32 is required. See #17749 and\n+      dnl https://bugreports.qt.io/browse/QTBUG-27097.\n+      AX_CHECK_LINK_FLAG([-lwtsapi32], [QT_LIBS=\"$QT_LIBS -lwtsapi32\"], [AC_MSG_ERROR([could not link against -lwtsapi32])])\n+      _BITCOIN_QT_CHECK_STATIC_PLUGIN([QWindowsIntegrationPlugin], [-lqwindows])\n       AC_DEFINE(QT_QPA_PLATFORM_WINDOWS, 1, [Define this symbol if the qt platform is windows])\n     elif test \"x$TARGET_OS\" = xlinux; then\n-      _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(QXcbIntegrationPlugin)],[-lqxcb -lxcb-static])\n+      dnl workaround for https://bugreports.qt.io/browse/QTBUG-74874\n+      AX_CHECK_LINK_FLAG([-lxcb-shm], [QT_LIBS=\"-lxcb-shm $QT_LIBS\"], [AC_MSG_ERROR([could not link against -lxcb-shm])])\n+      _BITCOIN_QT_CHECK_STATIC_PLUGIN([QXcbIntegrationPlugin], [-lqxcb])\n       AC_DEFINE(QT_QPA_PLATFORM_XCB, 1, [Define this symbol if the qt platform is xcb])\n     elif test \"x$TARGET_OS\" = xdarwin; then\n-      _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(QCocoaIntegrationPlugin)],[-lqcocoa])\n+      AX_CHECK_LINK_FLAG([[-framework Carbon]],[QT_LIBS=\"$QT_LIBS -framework Carbon\"],[AC_MSG_ERROR(could not link against Carbon framework)])\n+      AX_CHECK_LINK_FLAG([[-framework IOSurface]],[QT_LIBS=\"$QT_LIBS -framework IOSurface\"],[AC_MSG_ERROR(could not link against IOSurface framework)])\n+      AX_CHECK_LINK_FLAG([[-framework Metal]],[QT_LIBS=\"$QT_LIBS -framework Metal\"],[AC_MSG_ERROR(could not link against Metal framework)])\n+      AX_CHECK_LINK_FLAG([[-framework QuartzCore]],[QT_LIBS=\"$QT_LIBS -framework QuartzCore\"],[AC_MSG_ERROR(could not link against QuartzCore framework)])\n+      _BITCOIN_QT_CHECK_STATIC_PLUGIN([QCocoaIntegrationPlugin], [-lqcocoa])\n+      _BITCOIN_QT_CHECK_STATIC_PLUGIN([QMacStylePlugin], [-lqmacstyle])\n       AC_DEFINE(QT_QPA_PLATFORM_COCOA, 1, [Define this symbol if the qt platform is cocoa])\n     elif test \"x$TARGET_OS\" = xandroid; then\n       QT_LIBS=\"-Wl,--export-dynamic,--undefined=JNI_OnLoad -lqtforandroid -ljnigraphics -landroid -lqtfreetype -lQt5EglSupport $QT_LIBS\"\n@@ -284,51 +308,50 @@ AC_DEFUN([_BITCOIN_QT_IS_STATIC],[\n     ])\n ])\n \n-dnl Internal. Check if the link-requirements for static plugins are met.\n+dnl Internal. Check if the link-requirements for a static plugin are met.\n+dnl\n+dnl _BITCOIN_QT_CHECK_STATIC_PLUGIN(PLUGIN, LIBRARIES)\n+dnl --------------------------------------------------\n+dnl\n dnl Requires: INCLUDES and LIBS must be populated as necessary.\n-dnl Inputs: $1: A series of Q_IMPORT_PLUGIN().\n+dnl Inputs: $1: A static plugin name.\n dnl Inputs: $2: The libraries that resolve $1.\n dnl Output: QT_LIBS is prepended or configure exits.\n-AC_DEFUN([_BITCOIN_QT_CHECK_STATIC_PLUGINS],[\n-  AC_MSG_CHECKING(for static Qt plugins: $2)\n+AC_DEFUN([_BITCOIN_QT_CHECK_STATIC_PLUGIN], [\n+  AC_MSG_CHECKING([for $1 ($2)])\n   CHECK_STATIC_PLUGINS_TEMP_LIBS=\"$LIBS\"\n   LIBS=\"$2${qt_lib_suffix} $QT_LIBS $LIBS\"\n   AC_LINK_IFELSE([AC_LANG_PROGRAM([[\n-    #define QT_STATICPLUGIN\n-    #include <QtPlugin>\n-    $1]],\n-    [[return 0;]])],\n-    [AC_MSG_RESULT(yes); QT_LIBS=\"$2${qt_lib_suffix} $QT_LIBS\"],\n-    [AC_MSG_RESULT(no); BITCOIN_QT_FAIL(Could not resolve: $2)])\n+      #include <QtPlugin>\n+      Q_IMPORT_PLUGIN($1)\n+    ]])],\n+    [AC_MSG_RESULT([yes]); QT_LIBS=\"$2${qt_lib_suffix} $QT_LIBS\"],\n+    [AC_MSG_RESULT([no]); BITCOIN_QT_FAIL([$1 not found.])])\n   LIBS=\"$CHECK_STATIC_PLUGINS_TEMP_LIBS\"\n ])\n \n-dnl Internal. Find paths necessary for linking qt static plugins\n-dnl Inputs: qt_plugin_path. optional.\n-dnl Outputs: QT_LIBS is appended\n-AC_DEFUN([_BITCOIN_QT_FIND_STATIC_PLUGINS],[\n-    if test \"x$qt_plugin_path\" != x; then\n-      QT_LIBS=\"$QT_LIBS -L$qt_plugin_path/platforms\"\n-      if test -d \"$qt_plugin_path/accessible\"; then\n-        QT_LIBS=\"$QT_LIBS -L$qt_plugin_path/accessible\"\n-      fi\n-      if test -d \"$qt_plugin_path/platforms/android\"; then\n-        QT_LIBS=\"$QT_LIBS -L$qt_plugin_path/platforms/android -lqtfreetype -lEGL\"\n-      fi\n-      PKG_CHECK_MODULES([QTFONTDATABASE], [Qt5FontDatabaseSupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5FontDatabaseSupport${qt_lib_suffix} $QT_LIBS\"])\n-      PKG_CHECK_MODULES([QTEVENTDISPATCHER], [Qt5EventDispatcherSupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5EventDispatcherSupport${qt_lib_suffix} $QT_LIBS\"])\n-      PKG_CHECK_MODULES([QTTHEME], [Qt5ThemeSupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5ThemeSupport${qt_lib_suffix} $QT_LIBS\"])\n-      PKG_CHECK_MODULES([QTDEVICEDISCOVERY], [Qt5DeviceDiscoverySupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5DeviceDiscoverySupport${qt_lib_suffix} $QT_LIBS\"])\n-      PKG_CHECK_MODULES([QTACCESSIBILITY], [Qt5AccessibilitySupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5AccessibilitySupport${qt_lib_suffix} $QT_LIBS\"])\n-      PKG_CHECK_MODULES([QTFB], [Qt5FbSupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5FbSupport${qt_lib_suffix} $QT_LIBS\"])\n-      if test \"x$TARGET_OS\" = xlinux; then\n-        PKG_CHECK_MODULES([QTXCBQPA], [Qt5XcbQpa], [QT_LIBS=\"$QTXCBQPA_LIBS $QT_LIBS\"])\n-      elif test \"x$TARGET_OS\" = xdarwin; then\n-        PKG_CHECK_MODULES([QTCLIPBOARD], [Qt5ClipboardSupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5ClipboardSupport${qt_lib_suffix} $QT_LIBS\"])\n-        PKG_CHECK_MODULES([QTGRAPHICS], [Qt5GraphicsSupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5GraphicsSupport${qt_lib_suffix} $QT_LIBS\"])\n-        PKG_CHECK_MODULES([QTCGL], [Qt5CglSupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5CglSupport${qt_lib_suffix} $QT_LIBS\"])\n-      fi\n-    fi\n+dnl Internal. Check Qt static libs with PKG_CHECK_MODULES.\n+dnl\n+dnl _BITCOIN_QT_CHECK_STATIC_LIBS\n+dnl -----------------------------\n+dnl\n+dnl Inputs: no inputs.\n+dnl Outputs: QT_LIBS is prepended.\n+AC_DEFUN([_BITCOIN_QT_CHECK_STATIC_LIBS], [\n+  PKG_CHECK_MODULES([QTFONTDATABASE], [Qt5FontDatabaseSupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5FontDatabaseSupport${qt_lib_suffix} $QT_LIBS\"])\n+  PKG_CHECK_MODULES([QTEVENTDISPATCHER], [Qt5EventDispatcherSupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5EventDispatcherSupport${qt_lib_suffix} $QT_LIBS\"])\n+  PKG_CHECK_MODULES([QTTHEME], [Qt5ThemeSupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5ThemeSupport${qt_lib_suffix} $QT_LIBS\"])\n+  PKG_CHECK_MODULES([QTDEVICEDISCOVERY], [Qt5DeviceDiscoverySupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5DeviceDiscoverySupport${qt_lib_suffix} $QT_LIBS\"])\n+  PKG_CHECK_MODULES([QTACCESSIBILITY], [Qt5AccessibilitySupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5AccessibilitySupport${qt_lib_suffix} $QT_LIBS\"])\n+  PKG_CHECK_MODULES([QTFB], [Qt5FbSupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5FbSupport${qt_lib_suffix} $QT_LIBS\"])\n+  if test \"x$TARGET_OS\" = xlinux; then\n+    PKG_CHECK_MODULES([QTXCBQPA], [Qt5XcbQpa], [QT_LIBS=\"$QTXCBQPA_LIBS $QT_LIBS\"])\n+  elif test \"x$TARGET_OS\" = xdarwin; then\n+    PKG_CHECK_MODULES([QTCLIPBOARD], [Qt5ClipboardSupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5ClipboardSupport${qt_lib_suffix} $QT_LIBS\"])\n+    PKG_CHECK_MODULES([QTGRAPHICS], [Qt5GraphicsSupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5GraphicsSupport${qt_lib_suffix} $QT_LIBS\"])\n+  elif test \"x$TARGET_OS\" = xwindows; then\n+    PKG_CHECK_MODULES([QTWINDOWSUIAUTOMATION], [Qt5WindowsUIAutomationSupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5WindowsUIAutomationSupport${qt_lib_suffix} $QT_LIBS\"])\n+  fi\n ])\n \n dnl Internal. Find Qt libraries using pkg-config."
      },
      {
        "sha": "aba5607eb60279c9bb0663673b6c1e0f71d10bc9",
        "filename": "build_msvc/bitcoin_config.h",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/build_msvc/bitcoin_config.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/build_msvc/bitcoin_config.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/bitcoin_config.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -92,9 +92,9 @@\n    don't. */\n #define HAVE_DECL_BSWAP_64 0\n \n-/* Define to 1 if you have the declaration of `daemon', and to 0 if you don't.\n+/* Define to 1 if you have the declaration of `fork', and to 0 if you don't.\n    */\n-#define HAVE_DECL_DAEMON 0\n+#define HAVE_DECL_FORK 0\n \n /* Define to 1 if you have the declaration of `htobe16', and to 0 if you\n    don't. */\n@@ -132,6 +132,10 @@\n    don't. */\n #define HAVE_DECL_LE64TOH 0\n \n+/* Define to 1 if you have the declaration of `setsid', and to 0 if you don't.\n+   */\n+#define HAVE_DECL_SETSID 0\n+\n /* Define to 1 if you have the declaration of `strerror_r', and to 0 if you\n    don't. */\n #define HAVE_DECL_STRERROR_R 0\n@@ -177,9 +181,6 @@\n /* Define to 1 if you have the <miniupnpc/miniupnpc.h> header file. */\n #define HAVE_MINIUPNPC_MINIUPNPC_H 1\n \n-/* Define to 1 if you have the <miniupnpc/miniwget.h> header file. */\n-#define HAVE_MINIUPNPC_MINIWGET_H 1\n-\n /* Define to 1 if you have the <miniupnpc/upnpcommands.h> header file. */\n #define HAVE_MINIUPNPC_UPNPCOMMANDS_H 1\n "
      },
      {
        "sha": "87cf8538f622742efaf82f8d9edf582f044e37ef",
        "filename": "ci/test/00_setup_env.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/ci/test/00_setup_env.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/ci/test/00_setup_env.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env.sh?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -65,7 +65,7 @@ export BASE_OUTDIR=${BASE_OUTDIR:-$BASE_SCRATCH_DIR/out/$HOST}\n export BASE_BUILD_DIR=${BASE_BUILD_DIR:-$BASE_SCRATCH_DIR/build}\n export PREVIOUS_RELEASES_DIR=${PREVIOUS_RELEASES_DIR:-$BASE_ROOT_DIR/releases/$HOST}\n export SDK_URL=${SDK_URL:-https://bitcoincore.org/depends-sources/sdks}\n-export DOCKER_PACKAGES=${DOCKER_PACKAGES:-build-essential libtool autotools-dev automake pkg-config bsdmainutils curl ca-certificates ccache python3 rsync git procps}\n+export DOCKER_PACKAGES=${DOCKER_PACKAGES:-build-essential libtool autotools-dev automake pkg-config bsdmainutils curl ca-certificates ccache python3 rsync git procps bison}\n export GOAL=${GOAL:-install}\n export DIR_QA_ASSETS=${DIR_QA_ASSETS:-${BASE_SCRATCH_DIR}/qa-assets}\n export PATH=${BASE_ROOT_DIR}/ci/retry:$PATH"
      },
      {
        "sha": "8b872faec5c8a8cff56b8b24b08f3d7885f475e4",
        "filename": "ci/test/00_setup_env_android.sh",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/ci/test/00_setup_env_android.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/ci/test/00_setup_env_android.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_android.sh?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -0,0 +1,17 @@\n+#!/usr/bin/env bash\n+#\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+export LC_ALL=C.UTF-8\n+\n+export CONTAINER_NAME=ci_android\n+export PACKAGES=\"clang llvm unzip openjdk-8-jdk gradle\"\n+\n+export ANDROID_API_LEVEL=28\n+export ANDROID_BUILD_TOOLS_VERSION=28.0.3\n+export ANDROID_NDK_VERSION=21.1.6352462\n+export ANDROID_TOOLS_URL=https://dl.google.com/android/repository/commandlinetools-linux-6609375_latest.zip\n+\n+export BITCOIN_CONFIG=\"--disable-ccache\"\n\\ No newline at end of file"
      },
      {
        "sha": "07e7c2dc275cbb3cd128b9781c08e76a87abbd54",
        "filename": "ci/test/00_setup_env_i686_centos.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/ci/test/00_setup_env_i686_centos.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/ci/test/00_setup_env_i686_centos.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_i686_centos.sh?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -9,7 +9,7 @@ export LC_ALL=C.UTF-8\n export HOST=i686-pc-linux-gnu\n export CONTAINER_NAME=ci_i686_centos_8\n export DOCKER_NAME_TAG=centos:8\n-export DOCKER_PACKAGES=\"gcc-c++ glibc-devel.x86_64 libstdc++-devel.x86_64 glibc-devel.i686 libstdc++-devel.i686 ccache libtool make git python3 python3-zmq which patch lbzip2 dash rsync coreutils\"\n+export DOCKER_PACKAGES=\"gcc-c++ glibc-devel.x86_64 libstdc++-devel.x86_64 glibc-devel.i686 libstdc++-devel.i686 ccache libtool make git python3 python3-zmq which patch lbzip2 dash rsync coreutils bison\"\n export GOAL=\"install\"\n export BITCOIN_CONFIG=\"--enable-zmq --with-gui=qt5 --enable-reduce-exports --with-boost-process\"\n export CONFIG_SHELL=\"/bin/dash\""
      },
      {
        "sha": "6ce38124472a69564edfab07e90696a72c53cca6",
        "filename": "ci/test/00_setup_env_mac.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/ci/test/00_setup_env_mac.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/ci/test/00_setup_env_mac.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_mac.sh?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -9,7 +9,7 @@ export LC_ALL=C.UTF-8\n export CONTAINER_NAME=ci_macos_cross\n export DOCKER_NAME_TAG=ubuntu:20.04  # Check that Focal can cross-compile to macos (Focal is used in the gitian build as well)\n export HOST=x86_64-apple-darwin18\n-export PACKAGES=\"cmake imagemagick librsvg2-bin libz-dev libtiff-tools libtinfo5 python3-dev python3-setuptools xorriso\"\n+export PACKAGES=\"cmake imagemagick librsvg2-bin libz-dev libtiff-tools libtinfo5 python3-setuptools xorriso\"\n export XCODE_VERSION=11.3.1\n export XCODE_BUILD_ID=11C505\n export RUN_UNIT_TESTS=false"
      },
      {
        "sha": "3bfeb2d67fe5bc9bcfced22adae568446af002f9",
        "filename": "ci/test/05_before_script.sh",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/ci/test/05_before_script.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/ci/test/05_before_script.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/05_before_script.sh?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -22,6 +22,20 @@ if [ -n \"$XCODE_VERSION\" ] && [ ! -f \"$OSX_SDK_PATH\" ]; then\n   DOCKER_EXEC curl --location --fail \"${SDK_URL}/${OSX_SDK_BASENAME}\" -o \"$OSX_SDK_PATH\"\n fi\n \n+if [ -n \"$ANDROID_TOOLS_URL\" ]; then\n+  ANDROID_TOOLS_PATH=$DEPENDS_DIR/sdk-sources/android-tools.zip\n+  ANDROID_HOME=\"$DEPENDS_DIR\"/SDKs/android\n+  ANDROID_NDK_HOME=${ANDROID_HOME}/ndk/${ANDROID_NDK_VERSION}\n+\n+  DOCKER_EXEC curl --location --fail \"${ANDROID_TOOLS_URL}\" -o \"$ANDROID_TOOLS_PATH\"\n+  DOCKER_EXEC mkdir -p \"${ANDROID_HOME}/cmdline-tools\"\n+  DOCKER_EXEC unzip -o \"$ANDROID_TOOLS_PATH\" -d \"${ANDROID_HOME}/cmdline-tools\"\n+  DOCKER_EXEC \"yes | ${ANDROID_HOME}/cmdline-tools/tools/bin/sdkmanager --install \\\"build-tools;${ANDROID_BUILD_TOOLS_VERSION}\\\" \\\"platform-tools\\\" \\\"platforms;android-${ANDROID_API_LEVEL}\\\" \\\"ndk;${ANDROID_NDK_VERSION}\\\"\"\n+\n+  MAKE_COMMAND=\"ANDROID_SDK=${ANDROID_HOME} ANDROID_NDK=${ANDROID_NDK_HOME} make $MAKEJOBS -C depends HOST=aarch64-linux-android ANDROID_API_LEVEL=${ANDROID_API_LEVEL} ANDROID_TOOLCHAIN_BIN=${ANDROID_HOME}/ndk/${ANDROID_NDK_VERSION}/toolchains/llvm/prebuilt/linux-x86_64/bin/ $DEP_OPTS\"\n+  DOCKER_EXEC \"$MAKE_COMMAND\" HOST=aarch64-linux-android\n+fi\n+\n if [[ ${USE_MEMORY_SANITIZER} == \"true\" ]]; then\n   # Use BDB compiled using install_db4.sh script to work around linking issue when using BDB\n   # from depends. See https://github.com/bitcoin/bitcoin/pull/18288#discussion_r433189350 for"
      },
      {
        "sha": "a42cd6cee1430ae5f13ec9162d06c2b15f6c9606",
        "filename": "ci/test/06_script_a.sh",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/ci/test/06_script_a.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/ci/test/06_script_a.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/06_script_a.sh?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -6,6 +6,14 @@\n \n export LC_ALL=C.UTF-8\n \n+if [ -n \"$ANDROID_TOOLS_URL\" ]; then\n+  DOCKER_EXEC make distclean || true\n+  DOCKER_EXEC ./autogen.sh\n+  DOCKER_EXEC ./configure $BITCOIN_CONFIG --prefix=$DEPENDS_DIR/aarch64-linux-android || ( (DOCKER_EXEC cat config.log) && false)\n+  DOCKER_EXEC \"cd src/qt && make $MAKEJOBS && ANDROID_HOME=${ANDROID_HOME} ANDROID_NDK_HOME=${ANDROID_NDK_HOME} make apk\"\n+  exit 0\n+fi\n+\n BITCOIN_CONFIG_ALL=\"--enable-suppress-external-warnings --disable-dependency-tracking --prefix=$DEPENDS_DIR/$HOST --bindir=$BASE_OUTDIR/bin --libdir=$BASE_OUTDIR/lib\"\n if [ -z \"$NO_WERROR\" ]; then\n   BITCOIN_CONFIG_ALL=\"${BITCOIN_CONFIG_ALL} --enable-werror\""
      },
      {
        "sha": "9ac2643374f25b8ecbb637d58269fa336ad1aefc",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 30,
        "deletions": 8,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -734,6 +734,21 @@ case $host in\n    *android*)\n      dnl make sure android stays above linux for hosts like *linux-android*\n      TARGET_OS=android\n+     case $host in\n+       *x86_64*)\n+          ANDROID_ARCH=x86_64\n+          ;;\n+        *aarch64*)\n+          ANDROID_ARCH=arm64-v8a\n+          ;;\n+        *armv7a*)\n+          ANDROID_ARCH=armeabi-v7a\n+          ;;\n+        *i686*)\n+          ANDROID_ARCH=i686\n+          ;;\n+        *) AC_MSG_ERROR(\"Could not determine Android arch\") ;;\n+      esac\n      ;;\n    *linux*)\n      TARGET_OS=linux\n@@ -866,11 +881,16 @@ if test x$use_hardening != xno; then\n   dnl Use CHECK_LINK_FLAG & --fatal-warnings to ensure we won't use the flag in this case.\n   AX_CHECK_LINK_FLAG([-fcf-protection=full],[HARDENED_CXXFLAGS=\"$HARDENED_CXXFLAGS -fcf-protection=full\"],, [[$LDFLAG_WERROR]])\n \n-  dnl stack-clash-protection does not work properly when building for Windows.\n-  dnl We use the test case from https://gcc.gnu.org/bugzilla/show_bug.cgi?id=90458\n-  dnl to determine if it can be enabled.\n-  AX_CHECK_COMPILE_FLAG([-fstack-clash-protection],[HARDENED_CXXFLAGS=\"$HARDENED_CXXFLAGS -fstack-clash-protection\"],[],[\"-O0\"],\n-    [AC_LANG_SOURCE([[class D {public: unsigned char buf[32768];}; int main() {D d; return 0;}]])])\n+  case $host in\n+    *mingw*)\n+      dnl stack-clash-protection doesn't currently work, and likely should just be skipped for Windows.\n+      dnl See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=90458 for more details.\n+      ;;\n+    *)\n+      AX_CHECK_COMPILE_FLAG([-fstack-clash-protection],[HARDENED_CXXFLAGS=\"$HARDENED_CXXFLAGS -fstack-clash-protection\"])\n+      ;;\n+  esac\n+\n \n   dnl When enable_debug is yes, all optimizations are disabled.\n   dnl However, FORTIFY_SOURCE requires that there is some level of optimization, otherwise it does nothing and just creates a compiler warning.\n@@ -922,8 +942,9 @@ AC_CHECK_DECLS([getifaddrs, freeifaddrs],,,\n )\n AC_CHECK_DECLS([strnlen])\n \n-dnl Check for daemon(3), unrelated to --with-daemon (although used by it)\n-AC_CHECK_DECLS([daemon])\n+dnl These are used for daemonization in bitcoind\n+AC_CHECK_DECLS([fork])\n+AC_CHECK_DECLS([setsid])\n \n AC_CHECK_DECLS([pipe2])\n \n@@ -1345,7 +1366,7 @@ fi\n dnl Check for libminiupnpc (optional)\n if test x$use_upnp != xno; then\n   AC_CHECK_HEADERS(\n-    [miniupnpc/miniwget.h miniupnpc/miniupnpc.h miniupnpc/upnpcommands.h miniupnpc/upnperrors.h],\n+    [miniupnpc/miniupnpc.h miniupnpc/upnpcommands.h miniupnpc/upnperrors.h],\n     [AC_CHECK_LIB([miniupnpc], [upnpDiscover], [MINIUPNPC_LIBS=-lminiupnpc], [have_miniupnpc=no])],\n     [have_miniupnpc=no]\n   )\n@@ -1843,6 +1864,7 @@ AC_SUBST(HAVE_BUILTIN_PREFETCH)\n AC_SUBST(HAVE_MM_PREFETCH)\n AC_SUBST(HAVE_STRONG_GETAUXVAL)\n AC_SUBST(HAVE_WEAK_GETAUXVAL)\n+AC_SUBST(ANDROID_ARCH)\n AC_CONFIG_FILES([Makefile src/Makefile doc/man/Makefile share/setup.nsi share/qt/Info.plist test/config.ini])\n AC_CONFIG_FILES([contrib/devtools/split-debug.sh],[chmod +x contrib/devtools/split-debug.sh])\n AM_COND_IF([HAVE_DOXYGEN], [AC_CONFIG_FILES([doc/Doxyfile])])"
      },
      {
        "sha": "1fa850af1a7cf5902bc1993334d3f56b7be59dcf",
        "filename": "contrib/devtools/README.md",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/devtools/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/devtools/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/README.md?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -7,7 +7,8 @@ clang-format-diff.py\n \n A script to format unified git diffs according to [.clang-format](../../src/.clang-format).\n \n-Requires `clang-format`, installed e.g. via `brew install clang-format` on macOS.\n+Requires `clang-format`, installed e.g. via `brew install clang-format` on macOS,\n+or `sudo apt install clang-format` on Debian/Ubuntu.\n \n For instance, to format the last commit with 0 lines of context,\n the script should be called from the git root folder as follows."
      },
      {
        "sha": "436f179d61e6dd12e924226308d880776a8fdbed",
        "filename": "contrib/devtools/symbol-check.py",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/devtools/symbol-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/devtools/symbol-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/symbol-check.py?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -73,6 +73,8 @@\n 'ld-linux-riscv64-lp64d.so.1', # 64-bit RISC-V dynamic linker\n # bitcoin-qt only\n 'libxcb.so.1', # part of X11\n+'libxkbcommon.so.0', # keyboard keymapping\n+'libxkbcommon-x11.so.0', # keyboard keymapping\n 'libfontconfig.so.1', # font support\n 'libfreetype.so.6', # font parsing\n 'libdl.so.2' # programming interface to dynamic linker\n@@ -98,10 +100,15 @@\n 'CoreGraphics', # 2D rendering\n 'CoreServices', # operating system services\n 'CoreText', # interface for laying out text and handling fonts.\n+'CoreVideo', # video processing\n 'Foundation', # base layer functionality for apps/frameworks\n 'ImageIO', # read and write image file formats.\n 'IOKit', # user-space access to hardware devices and drivers.\n+'IOSurface', # cross process image/drawing buffers\n 'libobjc.A.dylib', # Objective-C runtime library\n+'Metal', # 3D graphics\n+'Security', # access control and authentication\n+'QuartzCore', # animation\n }\n \n PE_ALLOWED_LIBRARIES = {\n@@ -116,12 +123,15 @@\n 'dwmapi.dll', # desktop window manager\n 'GDI32.dll', # graphics device interface\n 'IMM32.dll', # input method editor\n+'NETAPI32.dll',\n 'ole32.dll', # component object model\n 'OLEAUT32.dll', # OLE Automation API\n 'SHLWAPI.dll', # light weight shell API\n+'USERENV.dll',\n 'UxTheme.dll',\n 'VERSION.dll', # version checking\n 'WINMM.dll', # WinMM audio API\n+'WTSAPI32.dll',\n }\n \n class CPPFilt(object):"
      },
      {
        "sha": "28b5f57489d27f05e9633edd21d9d5a0f3196e47",
        "filename": "contrib/devtools/test-security-check.py",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/devtools/test-security-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/devtools/test-security-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/test-security-check.py?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -5,6 +5,7 @@\n '''\n Test script for security-check.py\n '''\n+import os\n import subprocess\n import unittest\n \n@@ -19,6 +20,10 @@ def write_testcode(filename):\n     }\n     ''')\n \n+def clean_files(source, executable):\n+    os.remove(source)\n+    os.remove(executable)\n+\n def call_security_check(cc, source, executable, options):\n     subprocess.run([cc,source,'-o',executable] + options, check=True)\n     p = subprocess.run(['./contrib/devtools/security-check.py',executable], stdout=subprocess.PIPE, universal_newlines=True)\n@@ -44,6 +49,8 @@ def test_ELF(self):\n         self.assertEqual(call_security_check(cc, source, executable, ['-Wl,-znoexecstack','-fstack-protector-all','-Wl,-zrelro','-Wl,-z,now','-pie','-fPIE', '-Wl,-z,separate-code']),\n                 (0, ''))\n \n+        clean_files(source, executable)\n+\n     def test_PE(self):\n         source = 'test1.c'\n         executable = 'test1.exe'\n@@ -61,6 +68,8 @@ def test_PE(self):\n         self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--nxcompat','-Wl,--dynamicbase','-Wl,--high-entropy-va','-pie','-fPIE']),\n             (0, ''))\n \n+        clean_files(source, executable)\n+\n     def test_MACHO(self):\n         source = 'test1.c'\n         executable = 'test1'\n@@ -80,6 +89,8 @@ def test_MACHO(self):\n         self.assertEqual(call_security_check(cc, source, executable, ['-Wl,-pie','-Wl,-bind_at_load','-fstack-protector-all']),\n             (0, ''))\n \n+        clean_files(source, executable)\n+\n if __name__ == '__main__':\n     unittest.main()\n "
      },
      {
        "sha": "106dfd2c5a3da1f17719c7e75477ce6ce2246a7a",
        "filename": "contrib/devtools/test-symbol-check.py",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/devtools/test-symbol-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/devtools/test-symbol-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/test-symbol-check.py?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -5,18 +5,17 @@\n '''\n Test script for symbol-check.py\n '''\n+import os\n import subprocess\n import unittest\n \n def call_symbol_check(cc, source, executable, options):\n     subprocess.run([cc,source,'-o',executable] + options, check=True)\n     p = subprocess.run(['./contrib/devtools/symbol-check.py',executable], stdout=subprocess.PIPE, universal_newlines=True)\n+    os.remove(source)\n+    os.remove(executable)\n     return (p.returncode, p.stdout.rstrip())\n \n-def get_machine(cc):\n-    p = subprocess.run([cc,'-dumpmachine'], stdout=subprocess.PIPE, universal_newlines=True)\n-    return p.stdout.rstrip()\n-\n class TestSymbolChecks(unittest.TestCase):\n     def test_ELF(self):\n         source = 'test1.c'"
      },
      {
        "sha": "52e2a0514a02dcb117fe0fb2d18ca22322287094",
        "filename": "contrib/gitian-descriptors/gitian-linux.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/gitian-descriptors/gitian-linux.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/gitian-descriptors/gitian-linux.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-linux.yml?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -11,6 +11,7 @@ packages:\n - \"autoconf\"\n - \"automake\"\n - \"binutils\"\n+- \"bison\"\n - \"bsdmainutils\"\n - \"ca-certificates\"\n - \"curl\""
      },
      {
        "sha": "c37ad5b842570044f4c9a696cf14a3dc822b3f9d",
        "filename": "contrib/gitian-descriptors/gitian-osx.yml",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/gitian-descriptors/gitian-osx.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/gitian-descriptors/gitian-osx.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-osx.yml?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -23,7 +23,6 @@ packages:\n - \"imagemagick\"\n - \"libz-dev\"\n - \"python3\"\n-- \"python3-dev\"\n - \"python3-setuptools\"\n - \"fonts-tuffy\"\n - \"xorriso\""
      },
      {
        "sha": "4228532cb1d6ead1e758fbfe57609cd3bbcb54fe",
        "filename": "contrib/guix/manifest.scm",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/guix/manifest.scm",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/guix/manifest.scm",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/manifest.scm?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -3,6 +3,7 @@\n              (gnu packages autotools)\n              (gnu packages base)\n              (gnu packages bash)\n+             (gnu packages bison)\n              (gnu packages cdrom)\n              (gnu packages check)\n              (gnu packages cmake)\n@@ -219,6 +220,7 @@ chain for \" target \" development.\"))\n         autoconf\n         automake\n         pkg-config\n+        bison\n         ;; Scripting\n         perl\n         python-3"
      },
      {
        "sha": "013a1a607027cd715043b7f13fe5580e044adb18",
        "filename": "contrib/init/bitcoind.openrc",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/init/bitcoind.openrc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/init/bitcoind.openrc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/init/bitcoind.openrc?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -60,16 +60,17 @@ start_pre() {\n \t\"${BITCOIND_PIDDIR}\"\n \n \tcheckpath -f \\\n-\t-o ${BITCOIND_USER}:${BITCOIND_GROUP} \\\n+\t-o \"${BITCOIND_USER}:${BITCOIND_GROUP}\" \\\n \t-m 0660 \\\n-\t${BITCOIND_CONFIGFILE}\n+\t\"${BITCOIND_CONFIGFILE}\"\n \n \tcheckconfig || return 1\n }\n \n checkconfig()\n {\n-\tif ! grep -qs '^rpcpassword=' \"${BITCOIND_CONFIGFILE}\" ; then\n+\tif grep -qs '^rpcuser=' \"${BITCOIND_CONFIGFILE}\" && \\\n+\t\t! grep -qs '^rpcpassword=' \"${BITCOIND_CONFIGFILE}\" ; then\n \t\teerror \"\"\n \t\teerror \"ERROR: You must set a secure rpcpassword to run bitcoind.\"\n \t\teerror \"The setting must appear in ${BITCOIND_CONFIGFILE}\""
      },
      {
        "sha": "93de353bb4eb0dac87ca6c83106fb64e71ab3df6",
        "filename": "contrib/init/bitcoind.service",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/init/bitcoind.service",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/init/bitcoind.service",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/init/bitcoind.service?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -18,7 +18,7 @@ After=network-online.target\n Wants=network-online.target\n \n [Service]\n-ExecStart=/usr/bin/bitcoind -daemon \\\n+ExecStart=/usr/bin/bitcoind -daemonwait \\\n                             -pid=/run/bitcoind/bitcoind.pid \\\n                             -conf=/etc/bitcoin/bitcoin.conf \\\n                             -datadir=/var/lib/bitcoind\n@@ -33,6 +33,7 @@ ExecStartPre=/bin/chgrp bitcoin /etc/bitcoin\n Type=forking\n PIDFile=/run/bitcoind/bitcoind.pid\n Restart=on-failure\n+TimeoutStartSec=infinity\n TimeoutStopSec=600\n \n # Directory creation and permissions"
      },
      {
        "sha": "fcc5a378e2cc8f5dba2b627e531234d77992b621",
        "filename": "contrib/testgen/README.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/testgen/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/testgen/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/testgen/README.md?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -4,5 +4,5 @@ Utilities to generate test vectors for the data-driven Bitcoin tests.\n \n Usage:\n \n-    PYTHONPATH=../../test/functional/test_framework ./gen_key_io_test_vectors.py valid 50 > ../../src/test/data/key_io_valid.json\n-    PYTHONPATH=../../test/functional/test_framework ./gen_key_io_test_vectors.py invalid 50 > ../../src/test/data/key_io_invalid.json\n+    PYTHONPATH=../../test/functional/test_framework ./gen_key_io_test_vectors.py valid 70 > ../../src/test/data/key_io_valid.json\n+    PYTHONPATH=../../test/functional/test_framework ./gen_key_io_test_vectors.py invalid 70 > ../../src/test/data/key_io_invalid.json"
      },
      {
        "sha": "74918cfb048ad85c55dd049285960f8009369c1b",
        "filename": "contrib/testgen/gen_key_io_test_vectors.py",
        "status": "modified",
        "additions": 53,
        "deletions": 31,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/testgen/gen_key_io_test_vectors.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/contrib/testgen/gen_key_io_test_vectors.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/testgen/gen_key_io_test_vectors.py?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -3,19 +3,19 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n '''\n-Generate valid and invalid base58 address and private key test vectors.\n+Generate valid and invalid base58/bech32(m) address and private key test vectors.\n \n Usage:\n-    PYTHONPATH=../../test/functional/test_framework ./gen_key_io_test_vectors.py valid 50 > ../../src/test/data/key_io_valid.json\n-    PYTHONPATH=../../test/functional/test_framework ./gen_key_io_test_vectors.py invalid 50 > ../../src/test/data/key_io_invalid.json\n+    PYTHONPATH=../../test/functional/test_framework ./gen_key_io_test_vectors.py valid 70 > ../../src/test/data/key_io_valid.json\n+    PYTHONPATH=../../test/functional/test_framework ./gen_key_io_test_vectors.py invalid 70 > ../../src/test/data/key_io_invalid.json\n '''\n # 2012 Wladimir J. van der Laan\n # Released under MIT License\n import os\n from itertools import islice\n from base58 import b58encode_chk, b58decode_chk, b58chars\n import random\n-from segwit_addr import bech32_encode, decode_segwit_address, convertbits, CHARSET\n+from segwit_addr import bech32_encode, decode_segwit_address, convertbits, CHARSET, Encoding\n \n # key types\n PUBKEY_ADDRESS = 0\n@@ -32,6 +32,7 @@\n OP_0 = 0x00\n OP_1 = 0x51\n OP_2 = 0x52\n+OP_3 = 0x53\n OP_16 = 0x60\n OP_DUP = 0x76\n OP_EQUAL = 0x87\n@@ -44,6 +45,7 @@\n script_suffix = (OP_EQUAL,)\n p2wpkh_prefix = (OP_0, 20)\n p2wsh_prefix = (OP_0, 32)\n+p2tr_prefix = (OP_1, 32)\n \n metadata_keys = ['isPrivkey', 'chain', 'isCompressed', 'tryCaseFlip']\n # templates for valid sequences\n@@ -54,40 +56,58 @@\n   ((SCRIPT_ADDRESS,),         20, (),   (False, 'main',    None,  None), script_prefix, script_suffix),\n   ((PUBKEY_ADDRESS_TEST,),    20, (),   (False, 'test',    None,  None), pubkey_prefix, pubkey_suffix),\n   ((SCRIPT_ADDRESS_TEST,),    20, (),   (False, 'test',    None,  None), script_prefix, script_suffix),\n+  ((PUBKEY_ADDRESS_TEST,),    20, (),   (False, 'signet',  None,  None), pubkey_prefix, pubkey_suffix),\n+  ((SCRIPT_ADDRESS_TEST,),    20, (),   (False, 'signet',  None,  None), script_prefix, script_suffix),\n   ((PUBKEY_ADDRESS_REGTEST,), 20, (),   (False, 'regtest', None,  None), pubkey_prefix, pubkey_suffix),\n   ((SCRIPT_ADDRESS_REGTEST,), 20, (),   (False, 'regtest', None,  None), script_prefix, script_suffix),\n   ((PRIVKEY,),                32, (),   (True,  'main',    False, None), (),            ()),\n   ((PRIVKEY,),                32, (1,), (True,  'main',    True,  None), (),            ()),\n   ((PRIVKEY_TEST,),           32, (),   (True,  'test',    False, None), (),            ()),\n   ((PRIVKEY_TEST,),           32, (1,), (True,  'test',    True,  None), (),            ()),\n+  ((PRIVKEY_TEST,),           32, (),   (True,  'signet',  False, None), (),            ()),\n+  ((PRIVKEY_TEST,),           32, (1,), (True,  'signet',  True,  None), (),            ()),\n   ((PRIVKEY_REGTEST,),        32, (),   (True,  'regtest', False, None), (),            ()),\n   ((PRIVKEY_REGTEST,),        32, (1,), (True,  'regtest', True,  None), (),            ())\n ]\n # templates for valid bech32 sequences\n bech32_templates = [\n-  # hrp, version, witprog_size, metadata, output_prefix\n-  ('bc',    0, 20, (False, 'main',    None, True), p2wpkh_prefix),\n-  ('bc',    0, 32, (False, 'main',    None, True), p2wsh_prefix),\n-  ('bc',    1,  2, (False, 'main',    None, True), (OP_1, 2)),\n-  ('tb',    0, 20, (False, 'test',    None, True), p2wpkh_prefix),\n-  ('tb',    0, 32, (False, 'test',    None, True), p2wsh_prefix),\n-  ('tb',    2, 16, (False, 'test',    None, True), (OP_2, 16)),\n-  ('bcrt',  0, 20, (False, 'regtest', None, True), p2wpkh_prefix),\n-  ('bcrt',  0, 32, (False, 'regtest', None, True), p2wsh_prefix),\n-  ('bcrt', 16, 40, (False, 'regtest', None, True), (OP_16, 40))\n+  # hrp, version, witprog_size, metadata, encoding, output_prefix\n+  ('bc',    0, 20, (False, 'main',    None, True), Encoding.BECH32,  p2wpkh_prefix),\n+  ('bc',    0, 32, (False, 'main',    None, True), Encoding.BECH32,  p2wsh_prefix),\n+  ('bc',    1, 32, (False, 'main',    None, True), Encoding.BECH32M, p2tr_prefix),\n+  ('bc',    2,  2, (False, 'main',    None, True), Encoding.BECH32M, (OP_2, 2)),\n+  ('tb',    0, 20, (False, 'test',    None, True), Encoding.BECH32,  p2wpkh_prefix),\n+  ('tb',    0, 32, (False, 'test',    None, True), Encoding.BECH32,  p2wsh_prefix),\n+  ('tb',    1, 32, (False, 'test',    None, True), Encoding.BECH32M, p2tr_prefix),\n+  ('tb',    3, 16, (False, 'test',    None, True), Encoding.BECH32M, (OP_3, 16)),\n+  ('tb',    0, 20, (False, 'signet',  None, True), Encoding.BECH32,  p2wpkh_prefix),\n+  ('tb',    0, 32, (False, 'signet',  None, True), Encoding.BECH32,  p2wsh_prefix),\n+  ('tb',    1, 32, (False, 'signet',  None, True), Encoding.BECH32M, p2tr_prefix),\n+  ('tb',    3, 32, (False, 'signet',  None, True), Encoding.BECH32M, (OP_3, 32)),\n+  ('bcrt',  0, 20, (False, 'regtest', None, True), Encoding.BECH32,  p2wpkh_prefix),\n+  ('bcrt',  0, 32, (False, 'regtest', None, True), Encoding.BECH32,  p2wsh_prefix),\n+  ('bcrt',  1, 32, (False, 'regtest', None, True), Encoding.BECH32M, p2tr_prefix),\n+  ('bcrt', 16, 40, (False, 'regtest', None, True), Encoding.BECH32M, (OP_16, 40))\n ]\n # templates for invalid bech32 sequences\n bech32_ng_templates = [\n-  # hrp, version, witprog_size, invalid_bech32, invalid_checksum, invalid_char\n-  ('tc',    0, 20, False, False, False),\n-  ('tb',   17, 32, False, False, False),\n-  ('bcrt',  3,  1, False, False, False),\n-  ('bc',   15, 41, False, False, False),\n-  ('tb',    0, 16, False, False, False),\n-  ('bcrt',  0, 32, True,  False, False),\n-  ('bc',    0, 16, True,  False, False),\n-  ('tb',    0, 32, False, True,  False),\n-  ('bcrt',  0, 20, False, False, True)\n+  # hrp, version, witprog_size, encoding, invalid_bech32, invalid_checksum, invalid_char\n+  ('tc',    0, 20, Encoding.BECH32,  False, False, False),\n+  ('bt',    1, 32, Encoding.BECH32M, False, False, False),\n+  ('tb',   17, 32, Encoding.BECH32M, False, False, False),\n+  ('bcrt',  3,  1, Encoding.BECH32M, False, False, False),\n+  ('bc',   15, 41, Encoding.BECH32M, False, False, False),\n+  ('tb',    0, 16, Encoding.BECH32,  False, False, False),\n+  ('bcrt',  0, 32, Encoding.BECH32,  True,  False, False),\n+  ('bc',    0, 16, Encoding.BECH32,  True,  False, False),\n+  ('tb',    0, 32, Encoding.BECH32,  False, True,  False),\n+  ('bcrt',  0, 20, Encoding.BECH32,  False, False, True),\n+  ('bc',    0, 20, Encoding.BECH32M, False, False, False),\n+  ('tb',    0, 32, Encoding.BECH32M, False, False, False),\n+  ('bcrt',  0, 20, Encoding.BECH32M, False, False, False),\n+  ('bc',    1, 32, Encoding.BECH32,  False, False, False),\n+  ('tb',    2, 16, Encoding.BECH32,  False, False, False),\n+  ('bcrt', 16, 20, Encoding.BECH32,  False, False, False),\n ]\n \n def is_valid(v):\n@@ -127,8 +147,9 @@ def gen_valid_bech32_vector(template):\n     hrp = template[0]\n     witver = template[1]\n     witprog = bytearray(os.urandom(template[2]))\n-    dst_prefix = bytearray(template[4])\n-    rv = bech32_encode(hrp, [witver] + convertbits(witprog, 8, 5))\n+    encoding = template[4]\n+    dst_prefix = bytearray(template[5])\n+    rv = bech32_encode(encoding, hrp, [witver] + convertbits(witprog, 8, 5))\n     return rv, dst_prefix + witprog\n \n def gen_valid_vectors():\n@@ -186,22 +207,23 @@ def gen_invalid_bech32_vector(template):\n     hrp = template[0]\n     witver = template[1]\n     witprog = bytearray(os.urandom(template[2]))\n+    encoding = template[3]\n \n     if no_data:\n-        rv = bech32_encode(hrp, [])\n+        rv = bech32_encode(encoding, hrp, [])\n     else:\n         data = [witver] + convertbits(witprog, 8, 5)\n-        if template[3] and not no_data:\n+        if template[4] and not no_data:\n             if template[2] % 5 in {2, 4}:\n                 data[-1] |= 1\n             else:\n                 data.append(0)\n-        rv = bech32_encode(hrp, data)\n+        rv = bech32_encode(encoding, hrp, data)\n \n-    if template[4]:\n+    if template[5]:\n         i = len(rv) - random.randrange(1, 7)\n         rv = rv[:i] + random.choice(CHARSET.replace(rv[i], '')) + rv[i + 1:]\n-    if template[5]:\n+    if template[6]:\n         i = len(hrp) + 1 + random.randrange(0, len(rv) - len(hrp) - 4)\n         rv = rv[:i] + rv[i:i + 4].upper() + rv[i + 4:]\n "
      },
      {
        "sha": "a1d4a99084d8aa783155a0b94eb60d1a09489efd",
        "filename": "depends/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/depends/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/depends/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/README.md?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -54,7 +54,7 @@ The paths are automatically configured and no other options are needed unless ta\n \n Common linux dependencies:\n \n-    sudo apt-get install make automake cmake curl g++-multilib libtool binutils-gold bsdmainutils pkg-config python3 patch\n+    sudo apt-get install make automake cmake curl g++-multilib libtool binutils-gold bsdmainutils pkg-config python3 patch bison\n \n For linux ARM cross compilation:\n "
      },
      {
        "sha": "710f43959c07f4d72b13d1c0bbb3846a0266bf06",
        "filename": "depends/packages/libxcb.mk",
        "status": "modified",
        "additions": 5,
        "deletions": 10,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/depends/packages/libxcb.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/depends/packages/libxcb.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/libxcb.mk?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -15,25 +15,20 @@ $(package)_config_opts += --disable-composite --disable-damage --disable-dpms\n $(package)_config_opts += --disable-dri2 --disable-dri3 --disable-glx\n $(package)_config_opts += --disable-present --disable-randr --disable-record\n $(package)_config_opts += --disable-render --disable-resource --disable-screensaver\n-$(package)_config_opts += --disable-shape --disable-shm --disable-sync\n+$(package)_config_opts += --disable-shape --disable-sync\n $(package)_config_opts += --disable-xevie --disable-xfixes --disable-xfree86-dri\n-$(package)_config_opts += --disable-xinerama --disable-xinput --disable-xkb\n+$(package)_config_opts += --disable-xinerama --disable-xinput\n $(package)_config_opts += --disable-xprint --disable-selinux --disable-xtest\n $(package)_config_opts += --disable-xv --disable-xvmc\n endef\n \n define $(package)_preprocess_cmds\n-  cp -f $(BASEDIR)/config.guess $(BASEDIR)/config.sub build-aux &&\\\n+  cp -f $(BASEDIR)/config.guess $(BASEDIR)/config.sub build-aux && \\\n   sed \"s/pthread-stubs//\" -i configure\n endef\n \n-# Don't install xcb headers to the default path in order to work around a qt\n-# build issue: https://bugreports.qt.io/browse/QTBUG-34748\n-# When using qt's internal libxcb, it may end up finding the real headers in\n-# depends staging. Use a non-default path to avoid that.\n-\n define $(package)_config_cmds\n-  $($(package)_autoconf) --includedir=$(host_prefix)/include/xcb-shared\n+  $($(package)_autoconf)\n endef\n \n define $(package)_build_cmds\n@@ -45,5 +40,5 @@ define $(package)_stage_cmds\n endef\n \n define $(package)_postprocess_cmds\n-  rm -rf share/man share/doc lib/*.la\n+  rm -rf share lib/*.la\n endef"
      },
      {
        "sha": "8c6c56545f0758b4cf7f8a1ecff82388e724ee82",
        "filename": "depends/packages/libxkbcommon.mk",
        "status": "added",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/depends/packages/libxkbcommon.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/depends/packages/libxkbcommon.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/libxkbcommon.mk?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -0,0 +1,32 @@\n+package=libxkbcommon\n+$(package)_version=0.8.4\n+$(package)_download_path=https://xkbcommon.org/download/\n+$(package)_file_name=$(package)-$($(package)_version).tar.xz\n+$(package)_sha256_hash=60ddcff932b7fd352752d51a5c4f04f3d0403230a584df9a2e0d5ed87c486c8b\n+$(package)_dependencies=libxcb\n+\n+define $(package)_set_vars\n+$(package)_config_opts = --enable-option-checking --disable-dependency-tracking\n+$(package)_config_opts += --disable-static --disable-docs\n+endef\n+\n+define $(package)_preprocess_cmds\n+  cp -f $(BASEDIR)/config.guess $(BASEDIR)/config.sub build-aux\n+endef\n+\n+define $(package)_config_cmds\n+  $($(package)_autoconf)\n+endef\n+\n+define $(package)_build_cmds\n+  $(MAKE)\n+endef\n+\n+define $(package)_stage_cmds\n+  $(MAKE) DESTDIR=$($(package)_staging_dir) install\n+endef\n+\n+define $(package)_postprocess_cmds\n+  rm lib/*.la\n+endef\n+"
      },
      {
        "sha": "99f5b0a8dbcf2c903e1c3d07e78221912d572d02",
        "filename": "depends/packages/miniupnpc.mk",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/depends/packages/miniupnpc.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/depends/packages/miniupnpc.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/miniupnpc.mk?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1,9 +1,9 @@\n package=miniupnpc\n-$(package)_version=2.0.20180203\n+$(package)_version=2.2.2\n $(package)_download_path=https://miniupnp.tuxfamily.org/files/\n $(package)_file_name=$(package)-$($(package)_version).tar.gz\n-$(package)_sha256_hash=90dda8c7563ca6cd4a83e23b3c66dbbea89603a1675bfdb852897c2c9cc220b7\n-$(package)_patches=dont_use_wingen.patch\n+$(package)_sha256_hash=888fb0976ba61518276fe1eda988589c700a3f2a69d71089260d75562afd3687\n+$(package)_patches=dont_leak_info.patch\n \n define $(package)_set_vars\n $(package)_build_opts=CC=\"$($(package)_cc)\"\n@@ -13,9 +13,7 @@ $(package)_build_env+=CFLAGS=\"$($(package)_cflags) $($(package)_cppflags)\" AR=\"$\n endef\n \n define $(package)_preprocess_cmds\n-  mkdir dll && \\\n-  sed -e 's|MINIUPNPC_VERSION_STRING \\\"version\\\"|MINIUPNPC_VERSION_STRING \\\"$($(package)_version)\\\"|' -e 's|OS/version|$(host)|' miniupnpcstrings.h.in > miniupnpcstrings.h && \\\n-  patch -p1 < $($(package)_patch_dir)/dont_use_wingen.patch\n+  patch -p1 < $($(package)_patch_dir)/dont_leak_info.patch\n endef\n \n define $(package)_build_cmds"
      },
      {
        "sha": "810068b686d0c5bf0a5965df4f73d5bac29ddc19",
        "filename": "depends/packages/packages.mk",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/depends/packages/packages.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/depends/packages/packages.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/packages.mk?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1,10 +1,8 @@\n packages:=boost libevent\n \n-qt_packages = zlib\n-\n qrencode_packages = qrencode\n \n-qt_linux_packages:=qt expat libxcb xcb_proto libXau xproto freetype fontconfig\n+qt_linux_packages:=qt expat libxcb xcb_proto libXau xproto freetype fontconfig libxkbcommon\n qt_android_packages=qt\n \n qt_darwin_packages=qt"
      },
      {
        "sha": "ee6796e2add188a27fed8ac6919e2463013c1b0f",
        "filename": "depends/packages/qt.mk",
        "status": "modified",
        "additions": 25,
        "deletions": 30,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/depends/packages/qt.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/depends/packages/qt.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/qt.mk?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1,23 +1,22 @@\n PACKAGE=qt\n-$(package)_version=5.9.8\n-$(package)_download_path=https://download.qt.io/official_releases/qt/5.9/$($(package)_version)/submodules\n-$(package)_suffix=opensource-src-$($(package)_version).tar.xz\n+$(package)_version=5.12.10\n+$(package)_download_path=https://download.qt.io/official_releases/qt/5.12/$($(package)_version)/submodules\n+$(package)_suffix=everywhere-src-$($(package)_version).tar.xz\n $(package)_file_name=qtbase-$($(package)_suffix)\n-$(package)_sha256_hash=9b9dec1f67df1f94bce2955c5604de992d529dde72050239154c56352da0907d\n-$(package)_dependencies=zlib\n-$(package)_linux_dependencies=freetype fontconfig libxcb\n+$(package)_sha256_hash=8088f174e6d28e779516c083b6087b6a9e3c8322b4bc161fd1b54195e3c86940\n+$(package)_linux_dependencies=freetype fontconfig libxcb libxkbcommon\n $(package)_qt_libs=corelib network widgets gui plugins testlib\n-$(package)_patches=fix_qt_pkgconfig.patch mac-qmake.conf fix_configure_mac.patch fix_no_printer.patch\n-$(package)_patches+= fix_rcc_determinism.patch fix_riscv64_arch.patch xkb-default.patch no-xlib.patch\n+$(package)_patches=fix_qt_pkgconfig.patch mac-qmake.conf fix_no_printer.patch no-xlib.patch\n $(package)_patches+= fix_android_qmake_conf.patch fix_android_jni_static.patch dont_hardcode_pwd.patch\n-$(package)_patches+= freetype_back_compat.patch drop_lrelease_dependency.patch fix_powerpc_libpng.patch\n-$(package)_patches+= fix_mingw_cross_compile.patch fix_qpainter_non_determinism.patch\n+$(package)_patches+= drop_lrelease_dependency.patch no_sdk_version_check.patch\n+$(package)_patches+= fix_qpainter_non_determinism.patch fix_lib_paths.patch fix_android_pch.patch\n+$(package)_patches+= fix_bigsur_drawing.patch\n \n $(package)_qttranslations_file_name=qttranslations-$($(package)_suffix)\n-$(package)_qttranslations_sha256_hash=fb5a47799754af73d3bf501fe513342cfe2fc37f64e80df5533f6110e804220c\n+$(package)_qttranslations_sha256_hash=e1de58ed108b7e0a138815ea60fd46a2c4e1fc31396a707e5630e92de79c53de\n \n $(package)_qttools_file_name=qttools-$($(package)_suffix)\n-$(package)_qttools_sha256_hash=a97556eb7b2f30252cdd8a598c396cfce2b2f79d2bae883af6d3b26a2cdcc63c\n+$(package)_qttools_sha256_hash=b0cfa6e7aac41b7c61fc59acc04843d7a98f9e1840370611751bcfc1834a636c\n \n $(package)_extra_sources  = $($(package)_qttranslations_file_name)\n $(package)_extra_sources += $($(package)_qttools_file_name)\n@@ -26,6 +25,7 @@ define $(package)_set_vars\n $(package)_config_opts_release = -release\n $(package)_config_opts_release += -silent\n $(package)_config_opts_debug = -debug\n+$(package)_config_opts_debug += -optimized-tools\n $(package)_config_opts += -bindir $(build_prefix)/bin\n $(package)_config_opts += -c++std c++1z\n $(package)_config_opts += -confirm-license\n@@ -49,7 +49,6 @@ $(package)_config_opts += -no-mtdev\n $(package)_config_opts += -no-openssl\n $(package)_config_opts += -no-openvg\n $(package)_config_opts += -no-reduce-relocations\n-$(package)_config_opts += -no-qml-debug\n $(package)_config_opts += -no-sctp\n $(package)_config_opts += -no-securetransport\n $(package)_config_opts += -no-sql-db2\n@@ -63,17 +62,15 @@ $(package)_config_opts += -no-sql-sqlite\n $(package)_config_opts += -no-sql-sqlite2\n $(package)_config_opts += -no-system-proxies\n $(package)_config_opts += -no-use-gold-linker\n-$(package)_config_opts += -no-xinput2\n $(package)_config_opts += -nomake examples\n $(package)_config_opts += -nomake tests\n $(package)_config_opts += -opensource\n-$(package)_config_opts += -optimized-tools\n $(package)_config_opts += -pkg-config\n $(package)_config_opts += -prefix $(host_prefix)\n $(package)_config_opts += -qt-libpng\n $(package)_config_opts += -qt-pcre\n $(package)_config_opts += -qt-harfbuzz\n-$(package)_config_opts += -system-zlib\n+$(package)_config_opts += -qt-zlib\n $(package)_config_opts += -static\n $(package)_config_opts += -v\n $(package)_config_opts += -no-feature-bearermanagement\n@@ -94,10 +91,10 @@ $(package)_config_opts += -no-feature-printdialog\n $(package)_config_opts += -no-feature-printer\n $(package)_config_opts += -no-feature-printpreviewdialog\n $(package)_config_opts += -no-feature-printpreviewwidget\n-$(package)_config_opts += -no-feature-regularexpression\n $(package)_config_opts += -no-feature-sessionmanager\n $(package)_config_opts += -no-feature-socks5\n $(package)_config_opts += -no-feature-sql\n+$(package)_config_opts += -no-feature-sqlmodel\n $(package)_config_opts += -no-feature-statemachine\n $(package)_config_opts += -no-feature-syntaxhighlighter\n $(package)_config_opts += -no-feature-textbrowser\n@@ -115,6 +112,8 @@ $(package)_config_opts += -no-feature-xml\n $(package)_config_opts_darwin = -no-dbus\n $(package)_config_opts_darwin += -no-opengl\n $(package)_config_opts_darwin += -pch\n+$(package)_config_opts_darwin += -no-feature-corewlan\n+$(package)_config_opts_darwin += -device-option QMAKE_MACOSX_DEPLOYMENT_TARGET=$(OSX_MIN_VERSION)\n \n ifneq ($(build_os),darwin)\n $(package)_config_opts_darwin += -xplatform macx-clang-linux\n@@ -129,13 +128,13 @@ endif\n # for macOS on Apple Silicon (ARM) see https://bugreports.qt.io/browse/QTBUG-85279\n $(package)_config_opts_arm_darwin += -device-option QMAKE_APPLE_DEVICE_ARCHS=arm64\n \n-$(package)_config_opts_linux  = -qt-xkbcommon-x11\n-$(package)_config_opts_linux += -qt-xcb\n+$(package)_config_opts_linux = -qt-xcb\n $(package)_config_opts_linux += -no-xcb-xlib\n $(package)_config_opts_linux += -no-feature-xlib\n $(package)_config_opts_linux += -system-freetype\n $(package)_config_opts_linux += -fontconfig\n $(package)_config_opts_linux += -no-opengl\n+$(package)_config_opts_linux += -no-feature-vulkan\n $(package)_config_opts_linux += -dbus-runtime\n $(package)_config_opts_arm_linux += -platform linux-g++ -xplatform bitcoin-linux-g++\n $(package)_config_opts_i686_linux  = -xplatform linux-g++-32\n@@ -167,6 +166,7 @@ $(package)_config_opts_android += -no-fontconfig\n $(package)_config_opts_android += -L $(host_prefix)/lib\n $(package)_config_opts_android += -I $(host_prefix)/include\n $(package)_config_opts_android += -pch\n+$(package)_config_opts_android += -no-feature-vulkan\n \n $(package)_config_opts_aarch64_android += -android-arch arm64-v8a\n $(package)_config_opts_armv7a_android += -android-arch armeabi-v7a\n@@ -220,21 +220,18 @@ endef\n # 8. Adjust a regex in toolchain.prf, to accommodate Guix's usage of\n # CROSS_LIBRARY_PATH. See #15277.\n define $(package)_preprocess_cmds\n-  patch -p1 -i $($(package)_patch_dir)/freetype_back_compat.patch && \\\n-  patch -p1 -i $($(package)_patch_dir)/fix_powerpc_libpng.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/drop_lrelease_dependency.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/dont_hardcode_pwd.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/fix_qt_pkgconfig.patch && \\\n-  patch -p1 -i $($(package)_patch_dir)/fix_configure_mac.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/fix_no_printer.patch && \\\n-  patch -p1 -i $($(package)_patch_dir)/fix_rcc_determinism.patch && \\\n-  patch -p1 -i $($(package)_patch_dir)/xkb-default.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/fix_android_qmake_conf.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/fix_android_jni_static.patch && \\\n-  patch -p1 -i $($(package)_patch_dir)/fix_riscv64_arch.patch && \\\n+  patch -p1 -i $($(package)_patch_dir)/fix_android_pch.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/no-xlib.patch && \\\n-  patch -p1 -i $($(package)_patch_dir)/fix_mingw_cross_compile.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/fix_qpainter_non_determinism.patch &&\\\n+  patch -p1 -i $($(package)_patch_dir)/no_sdk_version_check.patch && \\\n+  patch -p1 -i $($(package)_patch_dir)/fix_lib_paths.patch && \\\n+  patch -p1 -i $($(package)_patch_dir)/fix_bigsur_drawing.patch && \\\n   sed -i.old \"s|updateqm.commands = \\$$$$\\$$$$LRELEASE|updateqm.commands = $($(package)_extract_dir)/qttools/bin/lrelease|\" qttranslations/translations/translations.pro && \\\n   mkdir -p qtbase/mkspecs/macx-clang-linux &&\\\n   cp -f qtbase/mkspecs/macx-clang/qplatformdefs.h qtbase/mkspecs/macx-clang-linux/ &&\\\n@@ -247,8 +244,8 @@ define $(package)_preprocess_cmds\n   sed -i.old \"s|QMAKE_CFLAGS           += |!host_build: QMAKE_CFLAGS            = $($(package)_cflags) $($(package)_cppflags) |\" qtbase/mkspecs/win32-g++/qmake.conf && \\\n   sed -i.old \"s|QMAKE_CXXFLAGS         += |!host_build: QMAKE_CXXFLAGS            = $($(package)_cxxflags) $($(package)_cppflags) |\" qtbase/mkspecs/win32-g++/qmake.conf && \\\n   sed -i.old \"0,/^QMAKE_LFLAGS_/s|^QMAKE_LFLAGS_|!host_build: QMAKE_LFLAGS            = $($(package)_ldflags)\\n&|\" qtbase/mkspecs/win32-g++/qmake.conf && \\\n-  sed -i.old \"s|QMAKE_CC                = clang|QMAKE_CC                = $($(package)_cc)|\" qtbase/mkspecs/common/clang.conf && \\\n-  sed -i.old \"s|QMAKE_CXX               = clang++|QMAKE_CXX               = $($(package)_cxx)|\" qtbase/mkspecs/common/clang.conf && \\\n+  sed -i.old \"s|QMAKE_CC                = \\$$$$\\$$$${CROSS_COMPILE}clang|QMAKE_CC                = $($(package)_cc)|\" qtbase/mkspecs/common/clang.conf && \\\n+  sed -i.old \"s|QMAKE_CXX               = \\$$$$\\$$$${CROSS_COMPILE}clang++|QMAKE_CXX               = $($(package)_cxx)|\" qtbase/mkspecs/common/clang.conf && \\\n   sed -i.old \"s/LIBRARY_PATH/(CROSS_)?\\0/g\" qtbase/mkspecs/features/toolchain.prf\n endef\n \n@@ -258,8 +255,6 @@ define $(package)_config_cmds\n   export PKG_CONFIG_PATH=$(host_prefix)/share/pkgconfig  && \\\n   cd qtbase && \\\n   ./configure $($(package)_config_opts) && \\\n-  echo \"host_build: QT_CONFIG ~= s/system-zlib/zlib\" >> mkspecs/qconfig.pri && \\\n-  echo \"CONFIG += force_bootstrap\" >> mkspecs/qconfig.pri && \\\n   cd .. && \\\n   $(MAKE) -C qtbase sub-src-clean && \\\n   qtbase/bin/qmake -o qttranslations/Makefile qttranslations/qttranslations.pro && \\"
      },
      {
        "sha": "acb02020a80b2424fe6080a0b64b8ac54d33df62",
        "filename": "depends/packages/zlib.mk",
        "status": "removed",
        "additions": 0,
        "deletions": 31,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/depends/packages/zlib.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/depends/packages/zlib.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/zlib.mk?ref=1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05",
        "patch": "@@ -1,31 +0,0 @@\n-package=zlib\n-$(package)_version=1.2.11\n-$(package)_download_path=https://www.zlib.net\n-$(package)_file_name=$(package)-$($(package)_version).tar.gz\n-$(package)_sha256_hash=c3e5e9fdd5004dcb542feda5ee4f0ff0744628baf8ed2dd5d66f8ca1197cb1a1\n-\n-define $(package)_set_vars\n-$(package)_config_opts= CC=\"$($(package)_cc)\"\n-$(package)_config_opts+=CFLAGS=\"$($(package)_cflags) $($(package)_cppflags) -fPIC\"\n-$(package)_config_opts+=RANLIB=\"$($(package)_ranlib)\"\n-$(package)_config_opts+=AR=\"$($(package)_ar)\"\n-$(package)_config_opts_darwin+=AR=\"$($(package)_libtool)\"\n-$(package)_config_opts_darwin+=ARFLAGS=\"-o\"\n-$(package)_config_opts_android+=CHOST=$(host)\n-endef\n-\n-# zlib has its own custom configure script that takes in options like CC,\n-# CFLAGS, RANLIB, AR, and ARFLAGS from the environment rather than from\n-# command-line arguments.\n-define $(package)_config_cmds\n-  env $($(package)_config_opts) ./configure --static --prefix=$(host_prefix)\n-endef\n-\n-define $(package)_build_cmds\n-  $(MAKE) libz.a\n-endef\n-\n-define $(package)_stage_cmds\n-  $(MAKE) DESTDIR=$($(package)_staging_dir) install\n-endef\n-"
      },
      {
        "sha": "512f9c50ea8d7fbca35004e92756236721e0919c",
        "filename": "depends/patches/miniupnpc/dont_leak_info.patch",
        "status": "added",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/miniupnpc/dont_leak_info.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/miniupnpc/dont_leak_info.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/miniupnpc/dont_leak_info.patch?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -0,0 +1,32 @@\n+commit 8815452257437ba36607d0e2381c01142d1c7bb0\n+Author: fanquake <fanquake@gmail.com>\n+Date:   Thu Nov 19 10:51:19 2020 +0800\n+\n+    Don't leak OS and miniupnpc version info in User-Agent\n+\n+diff --git a//minisoap.c b/minisoap.c\n+index 7860667..775580b 100644\n+--- a/minisoap.c\n++++ b/minisoap.c\n+@@ -90,7 +90,7 @@ int soapPostSubmit(SOCKET fd,\n+ \theaderssize = snprintf(headerbuf, sizeof(headerbuf),\n+                        \"POST %s HTTP/%s\\r\\n\"\n+ \t                   \"Host: %s%s\\r\\n\"\n+-\t\t\t\t\t   \"User-Agent: \" OS_STRING \", \" UPNP_VERSION_STRING \", MiniUPnPc/\" MINIUPNPC_VERSION_STRING \"\\r\\n\"\n++\t\t\t\t\t   \"User-Agent: \" UPNP_VERSION_STRING \"\\r\\n\"\n+ \t                   \"Content-Length: %d\\r\\n\"\n+ \t\t\t\t\t   \"Content-Type: text/xml\\r\\n\"\n+ \t\t\t\t\t   \"SOAPAction: \\\"%s\\\"\\r\\n\"\n+diff --git a/miniwget.c b/miniwget.c\n+index d5b7970..05aeb9c 100644\n+--- a/miniwget.c\n++++ b/miniwget.c\n+@@ -444,7 +444,7 @@ miniwget3(const char * host,\n+                  \"GET %s HTTP/%s\\r\\n\"\n+ \t\t\t     \"Host: %s:%d\\r\\n\"\n+ \t\t\t\t \"Connection: Close\\r\\n\"\n+-\t\t\t\t \"User-Agent: \" OS_STRING \", \" UPNP_VERSION_STRING \", MiniUPnPc/\" MINIUPNPC_VERSION_STRING \"\\r\\n\"\n++\t\t\t\t \"User-Agent: \" UPNP_VERSION_STRING \"\\r\\n\"\n+ \n+ \t\t\t\t \"\\r\\n\",\n+ \t\t\t   path, httpversion, host, port);"
      },
      {
        "sha": "a1cc9b50d1509379b121ba3f228821cced0485f9",
        "filename": "depends/patches/miniupnpc/dont_use_wingen.patch",
        "status": "removed",
        "additions": 0,
        "deletions": 26,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/depends/patches/miniupnpc/dont_use_wingen.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/depends/patches/miniupnpc/dont_use_wingen.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/miniupnpc/dont_use_wingen.patch?ref=1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05",
        "patch": "@@ -1,26 +0,0 @@\n-commit e8077044df239bcf0d9e9980b0e1afb9f1f5c446\n-Author: fanquake <fanquake@gmail.com>\n-Date:   Tue Aug 18 20:50:19 2020 +0800\n-\n-    Don't use wingenminiupnpcstrings when generating miniupnpcstrings.h\n-\n-    The wingenminiupnpcstrings tool is used on Windows to generate version\n-    information. This information is irrelevant for us, and trying to use\n-    wingenminiupnpcstrings would cause builds to fail, so just don't use it.\n-\n-    We should be able to drop this once we are using 2.1 or later. See\n-    upstream commit: 9663c55c61408fdcc39a82987d2243f816b22932.\n-\n-diff --git a/Makefile.mingw b/Makefile.mingw\n-index 574720e..fcc17bb 100644\n---- a/Makefile.mingw\n-+++ b/Makefile.mingw\n-@@ -74,7 +74,7 @@ wingenminiupnpcstrings:\twingenminiupnpcstrings.o\n-\n- wingenminiupnpcstrings.o:\twingenminiupnpcstrings.c\n-\n--miniupnpcstrings.h: miniupnpcstrings.h.in wingenminiupnpcstrings\n-+miniupnpcstrings.h: miniupnpcstrings.h.in\n- \twingenminiupnpcstrings $< $@\n-\n- minixml.o:\tminixml.c minixml.h"
      },
      {
        "sha": "9b918af77c464278eb796f20fcf7bc67d04e3dad",
        "filename": "depends/patches/qt/drop_lrelease_dependency.patch",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/drop_lrelease_dependency.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/drop_lrelease_dependency.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/drop_lrelease_dependency.patch?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -14,7 +14,7 @@ diff --git a/qttranslations/translations/translations.pro b/qttranslations/trans\n index 694544c..eff339d 100644\n --- a/qttranslations/translations/translations.pro\n +++ b/qttranslations/translations/translations.pro\n-@@ -109,3 +109,2 @@ updateqm.commands = $$LRELEASE ${QMAKE_FILE_IN} -qm ${QMAKE_FILE_OUT}\n+@@ -107,3 +107,2 @@ updateqm.commands = $$LRELEASE ${QMAKE_FILE_IN} -qm ${QMAKE_FILE_OUT}\n  silent:updateqm.commands = @echo lrelease ${QMAKE_FILE_IN} && $$updateqm.commands\n -updateqm.depends = $$LRELEASE_EXE\n  updateqm.name = LRELEASE ${QMAKE_FILE_IN}"
      },
      {
        "sha": "f891da6ddf9f7dd11c56d98fb7f2285fbc62d834",
        "filename": "depends/patches/qt/fix_android_jni_static.patch",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/fix_android_jni_static.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/fix_android_jni_static.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/fix_android_jni_static.patch?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1,6 +1,6 @@\n --- old/qtbase/src/plugins/platforms/android/androidjnimain.cpp\n +++ new/qtbase/src/plugins/platforms/android/androidjnimain.cpp\n-@@ -890,6 +890,14 @@\n+@@ -897,6 +897,14 @@\n          __android_log_print(ANDROID_LOG_FATAL, \"Qt\", \"registerNatives failed\");\n          return -1;\n      }"
      },
      {
        "sha": "bed6e4bb635975e748a95c88cdb790510a0f3893",
        "filename": "depends/patches/qt/fix_android_pch.patch",
        "status": "added",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/fix_android_pch.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/fix_android_pch.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/fix_android_pch.patch?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -0,0 +1,10 @@\n+--- old/qtbase/mkspecs/common/android-base-head.conf\n++++ new/qtbase/mkspecs/common/android-base-head.conf\n+@@ -73,6 +73,6 @@ CROSS_COMPILE = $$NDK_TOOLCHAIN_PATH/bin/$$NDK_TOOLS_PREFIX-\n+ QMAKE_PCH_OUTPUT_EXT    = .gch\n+\n+ QMAKE_CFLAGS_PRECOMPILE       = -x c-header -c ${QMAKE_PCH_INPUT} -o ${QMAKE_PCH_OUTPUT}\n+-QMAKE_CFLAGS_USE_PRECOMPILE   = -include ${QMAKE_PCH_OUTPUT_BASE}\n++QMAKE_CFLAGS_USE_PRECOMPILE   = -include-pch ${QMAKE_PCH_OUTPUT}\n+ QMAKE_CXXFLAGS_PRECOMPILE     = -x c++-header -c ${QMAKE_PCH_INPUT} -o ${QMAKE_PCH_OUTPUT}\n+ QMAKE_CXXFLAGS_USE_PRECOMPILE = $$QMAKE_CFLAGS_USE_PRECOMPILE"
      },
      {
        "sha": "3a8753fd1d74c88116e65ec019d70d8ed4772582",
        "filename": "depends/patches/qt/fix_android_qmake_conf.patch",
        "status": "modified",
        "additions": 7,
        "deletions": 17,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/fix_android_qmake_conf.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/fix_android_qmake_conf.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/fix_android_qmake_conf.patch?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1,20 +1,10 @@\n --- old/qtbase/mkspecs/android-clang/qmake.conf\n +++ new/qtbase/mkspecs/android-clang/qmake.conf\n-@@ -30,7 +30,7 @@\n-     QMAKE_CFLAGS += -target mips64el-none-linux-android\n+@@ -47,7 +47,7 @@ ANDROID_STDCPP_PATH = $$ANDROID_SOURCES_CXX_STL_LIBDIR/libc++_shared.so\n+ ANDROID_USE_LLVM = true\n  \n- QMAKE_CFLAGS += -gcc-toolchain $$NDK_TOOLCHAIN_PATH\n--QMAKE_LINK    = $$QMAKE_CXX $$QMAKE_CFLAGS -Wl,--exclude-libs,libgcc.a\n-+QMAKE_LINK    = $$QMAKE_CXX $$QMAKE_CFLAGS -Wl,--exclude-libs,libgcc.a -nostdlib++\n- QMAKE_CFLAGS += -DANDROID_HAS_WSTRING --sysroot=$$NDK_ROOT/sysroot \\\n-                 -isystem $$NDK_ROOT/sysroot/usr/include/$$NDK_TOOLS_PREFIX \\\n-                 -isystem $$NDK_ROOT/sources/cxx-stl/llvm-libc++/include \\\n-@@ -40,7 +40,7 @@\n- ANDROID_SOURCES_CXX_STL_LIBDIR = $$NDK_ROOT/sources/cxx-stl/llvm-libc++/libs/$$ANDROID_TARGET_ARCH\n- \n- ANDROID_STDCPP_PATH = $$ANDROID_SOURCES_CXX_STL_LIBDIR/libc++_shared.so\n--ANDROID_CXX_STL_LIBS = -lc++\n-+ANDROID_CXX_STL_LIBS = -lc++_shared\n- \n- QMAKE_ARM_CFLAGS_RELEASE                   = -Oz\n- QMAKE_ARM_CFLAGS_RELEASE_WITH_DEBUGINFO    = -g -Oz\n+ exists($$ANDROID_SOURCES_CXX_STL_LIBDIR/libc++.so): \\\n+-    ANDROID_CXX_STL_LIBS = -lc++\n++    ANDROID_CXX_STL_LIBS = -lc++_shared\n+ else: \\\n+     ANDROID_CXX_STL_LIBS = $$ANDROID_SOURCES_CXX_STL_LIBDIR/libc++.so.$$replace(ANDROID_PLATFORM, \"android-\", \"\")"
      },
      {
        "sha": "98c0c6be30142fc4e592cab441ce8f14796cc657",
        "filename": "depends/patches/qt/fix_bigsur_drawing.patch",
        "status": "added",
        "additions": 31,
        "deletions": 0,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/fix_bigsur_drawing.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/fix_bigsur_drawing.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/fix_bigsur_drawing.patch?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -0,0 +1,31 @@\n+Fix GUI stuck on Big Sur\n+\n+See:\n+ - https://github.com/bitcoin-core/gui/issues/249\n+ - https://github.com/bitcoin/bitcoin/pull/21495\n+ - https://bugreports.qt.io/browse/QTBUG-87014\n+\n+We should be able to drop this once we are using one of the following versions:\n+ - Qt 5.12.11 or later, see upstream commit: c5d904639dbd690a36306e2b455610029704d821\n+ - Qt 5.15.3 or later, see upstream commit: 2cae34354bd41ae286258c7a6b3653b746e786ae\n+\n+--- a/qtbase/src/plugins/platforms/cocoa/qnsview_drawing.mm\n++++ b/qtbase/src/plugins/platforms/cocoa/qnsview_drawing.mm\n+@@ -95,8 +95,15 @@\n+     // by AppKit at a point where we've already set up other parts of the platform plugin\n+     // based on the presence of layers or not. Once we've rewritten these parts to support\n+     // dynamically picking up layer enablement we can let AppKit do its thing.\n+-    return QMacVersion::buildSDK() >= QOperatingSystemVersion::MacOSMojave\n+-        && QMacVersion::currentRuntime() >= QOperatingSystemVersion::MacOSMojave;\n++\n++    if (QMacVersion::currentRuntime() >= QOperatingSystemVersion::MacOSBigSur)\n++        return true; // Big Sur always enables layer-backing, regardless of SDK\n++\n++    if (QMacVersion::currentRuntime() >= QOperatingSystemVersion::MacOSMojave\n++        && QMacVersion::buildSDK() >= QOperatingSystemVersion::MacOSMojave)\n++        return true; // Mojave and Catalina enable layers based on the app's SDK\n++\n++    return false; // Prior versions needed explicitly enabled layer backing\n+ }\n+ \n+ - (BOOL)layerExplicitlyRequested"
      },
      {
        "sha": "0d7dd647debca93eb5383ee72f6d4db573dabaac",
        "filename": "depends/patches/qt/fix_configure_mac.patch",
        "status": "removed",
        "additions": 0,
        "deletions": 50,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/depends/patches/qt/fix_configure_mac.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/depends/patches/qt/fix_configure_mac.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/fix_configure_mac.patch?ref=1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05",
        "patch": "@@ -1,50 +0,0 @@\n---- old/qtbase/mkspecs/features/mac/sdk.prf\t2018-02-08 10:24:48.000000000 -0800\n-+++ new/qtbase/mkspecs/features/mac/sdk.prf\t2018-03-23 10:38:56.000000000 -0700\n-@@ -8,21 +8,21 @@\n- defineReplace(xcodeSDKInfo) {\n-     info = $$1\n-     equals(info, \"Path\"): \\\n--        info = --show-sdk-path\n-+        infoarg = --show-sdk-path\n-     equals(info, \"PlatformPath\"): \\\n--        info = --show-sdk-platform-path\n-+        infoarg = --show-sdk-platform-path\n-     equals(info, \"SDKVersion\"): \\\n--        info = --show-sdk-version\n-+        infoarg = --show-sdk-version\n-     sdk = $$2\n-     isEmpty(sdk): \\\n-         sdk = $$QMAKE_MAC_SDK\n- \n-     isEmpty(QMAKE_MAC_SDK.$${sdk}.$${info}) {\n--        QMAKE_MAC_SDK.$${sdk}.$${info} = $$system(\"/usr/bin/xcrun --sdk $$sdk $$info 2>/dev/null\")\n-+        QMAKE_MAC_SDK.$${sdk}.$${info} = $$system(\"/usr/bin/xcrun --sdk $$sdk $$infoarg 2>/dev/null\")\n-         # --show-sdk-platform-path won't work for Command Line Tools; this is fine\n-         # only used by the XCTest backend to testlib\n--        isEmpty(QMAKE_MAC_SDK.$${sdk}.$${info}):if(!isEmpty(QMAKE_XCODEBUILD_PATH)|!equals(info, \"--show-sdk-platform-path\")): \\\n--            error(\"Could not resolve SDK $$info for \\'$$sdk\\'\")\n-+        isEmpty(QMAKE_MAC_SDK.$${sdk}.$${info}):if(!isEmpty(QMAKE_XCODEBUILD_PATH)|!equals(infoarg, \"--show-sdk-platform-path\")): \\\n-+            error(\"Could not resolve SDK $$info for \\'$$sdk\\' using $$infoarg\")\n-         cache(QMAKE_MAC_SDK.$${sdk}.$${info}, set stash, QMAKE_MAC_SDK.$${sdk}.$${info})\n-     }\n-\n---- old/qtbase/configure\t2018-02-08 10:24:48.000000000 -0800\n-+++ new/qtbase/configure\t2018-03-23 05:42:29.000000000 -0700\n-@@ -232,8 +232,13 @@\n- \n-     sdk=$(getSingleQMakeVariable \"QMAKE_MAC_SDK\" \"$1\")\n-     if [ -z \"$sdk\" ]; then echo \"QMAKE_MAC_SDK must be set when building on Mac\" >&2; exit 1; fi\n--    sysroot=$(/usr/bin/xcrun --sdk $sdk --show-sdk-path 2>/dev/null)\n--    if [ -z \"$sysroot\" ]; then echo \"Failed to resolve SDK path for '$sdk'\" >&2; exit 1; fi\n-+    sysroot=$(getSingleQMakeVariable \"QMAKE_MAC_SDK_PATH\" \"$1\")\n-+\n-+    echo \"sysroot pre-configured as $sysroot\";\n-+    if [ -z \"$sysroot\" ]; then\n-+       sysroot=$(/usr/bin/xcrun --sdk $sdk --show-sdk-path 2>/dev/null)\n-+       if [ -z \"$sysroot\" ]; then echo \"Failed to resolve SDK path for '$sdk'\" >&2; exit 1; fi\n-+    fi\n- \n-     case \"$sdk\" in\n-         macosx*)\n-\n-"
      },
      {
        "sha": "d1a15373f44d9fd9028f578ed658ddb1582dcbd8",
        "filename": "depends/patches/qt/fix_lib_paths.patch",
        "status": "added",
        "additions": 193,
        "deletions": 0,
        "changes": 193,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/fix_lib_paths.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/fix_lib_paths.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/fix_lib_paths.patch?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -0,0 +1,193 @@\n+--- old/qtbase/mkspecs/common/mac.conf\n++++ new/qtbase/mkspecs/common/mac.conf\n+@@ -14,7 +14,6 @@\n+ \n+ QMAKE_RESOURCE          = /Developer/Tools/Rez\n+ QMAKE_EXTENSION_SHLIB   = dylib\n+-QMAKE_EXTENSIONS_AUX_SHLIB = tbd\n+ QMAKE_LIBDIR            =\n+ \n+ # sdk.prf will prefix the proper SDK sysroot\n+\n+--- old/qtbase/mkspecs/features/qmake_use.prf\n++++ new/qtbase/mkspecs/features/qmake_use.prf\n+@@ -22,6 +22,8 @@\n+         !defined(QMAKE_LIBS_$$nu, var): \\\n+             error(\"Library '$$lower($$replace(nu, _, -))' is not defined.\")\n+ \n++        QMAKE_LIBDIR += $$eval(QMAKE_LIBDIR_$$nu)\n++\n+         debug: \\\n+             LIBS$${suffix} += $$eval(QMAKE_LIBS_$${nu}_DEBUG) $$eval(QMAKE_LIBS_$$nu)\n+         else: \\\n+\n+--- old/qtbase/mkspecs/features/qt_configure.prf\n++++ new/qtbase/mkspecs/features/qt_configure.prf\n+@@ -526,98 +526,23 @@\n+     return($$sysrootified)\n+ }\n+ \n+-# libs-var, libs, in-paths, out-paths-var\n++# libs-var, libs, in-paths\n+ defineTest(qtConfResolveLibs) {\n+-    ret = true\n+-    paths = $$3\n+-    out =\n+-    copy = false\n+-    for (l, 2) {\n+-        $$copy {\n+-            copy = false\n+-            out += $$l\n+-        } else: equals(l, \"-s\") {\n+-            # em++ flag to link libraries from emscripten-ports; passed on literally.\n+-            copy = true\n+-            out += $$l\n+-        } else: contains(l, \"^-L.*\") {\n+-            lp = $$replace(l, \"^-L\", )\n+-            gcc: lp = $$qtGccSysrootifiedPath($$lp)\n+-            !exists($$lp/.) {\n+-                qtLog(\"Library path $$val_escape(lp) is invalid.\")\n+-                ret = false\n+-            } else {\n+-                paths += $$lp\n+-            }\n+-        } else: contains(l, \"^-l.*\") {\n+-            lib = $$replace(l, \"^-l\", )\n+-            lcan =\n+-            integrity:contains(lib, \"^.*\\\\.a\") {\n+-                # INTEGRITY compiler searches for exact filename\n+-                # if -l argument has .a suffix\n+-                lcan += $${lib}\n+-            } else: contains(lib, \"^:.*\") {\n+-                # Use exact filename when -l:filename syntax is used.\n+-                lib ~= s/^://\n+-                lcan += $${lib}\n+-            } else: unix {\n+-                # Under UNIX, we look for actual shared libraries, in addition\n+-                # to static ones.\n+-                shexts = $$QMAKE_EXTENSION_SHLIB $$QMAKE_EXTENSIONS_AUX_SHLIB\n+-                for (ext, shexts) {\n+-                    lcan += $${QMAKE_PREFIX_SHLIB}$${lib}.$${ext}\n+-                }\n+-                lcan += \\\n+-                    $${QMAKE_PREFIX_STATICLIB}$${lib}.$${QMAKE_EXTENSION_STATICLIB}\n+-            } else {\n+-                # Under Windows, we look only for static libraries, as even for DLLs\n+-                # one actually links against a static import library.\n+-                mingw {\n+-                    lcan += \\\n+-                        # MinGW supports UNIX-style library naming in addition to\n+-                        # the MSVC style.\n+-                        lib$${lib}.dll.a lib$${lib}.a \\\n+-                        # Fun fact: prefix-less libraries are also supported.\n+-                        $${lib}.dll.a $${lib}.a\n+-                }\n+-                lcan += $${lib}.lib\n+-            }\n+-            l = $$qtConfFindInPathList($$lcan, $$paths $$EXTRA_LIBDIR $$QMAKE_DEFAULT_LIBDIRS)\n+-            isEmpty(l) {\n+-                qtLog(\"None of [$$val_escape(lcan)] found in [$$val_escape(paths)] and global paths.\")\n+-                ret = false\n+-            } else {\n+-                out += $$l\n+-            }\n+-        } else {\n+-            out += $$l\n+-        }\n+-    }\n+-    $$1 = $$out\n++    for (path, 3): \\\n++        pre_lflags += -L$$path\n++    $$1 = $$pre_lflags $$2\n+     export($$1)\n+-    !isEmpty(4) {\n+-        $$4 = $$paths\n+-        export($$4)\n+-    }\n+-    return($$ret)\n+-}\n+-\n+-# source-var\n+-defineTest(qtConfResolveAllLibs) {\n+-    ret = true\n+-    !qtConfResolveLibs($${1}.libs, $$eval($${1}.libs), , $${1}.libdirs): \\\n+-        ret = false\n+-    for (b, $${1}.builds._KEYS_): \\\n+-        !qtConfResolveLibs($${1}.builds.$${b}, $$eval($${1}.builds.$${b}), $$eval($${1}.libdirs), ): \\\n+-            ret = false\n+-    return($$ret)\n++    return(true)\n+ }\n+ \n+ # libs-var, in-paths, libs\n+ defineTest(qtConfResolvePathLibs) {\n+     ret = true\n+-    gcc: 2 = $$qtGccSysrootifiedPaths($$2)\n+-    for (libdir, 2) {\n++    gcc: \\\n++        local_paths = $$qtGccSysrootifiedPaths($$2)\n++    else: \\\n++        local_paths = $$2\n++    for (libdir, local_paths) {\n+         !exists($$libdir/.) {\n+             qtLog(\"Library path $$val_escape(libdir) is invalid.\")\n+             ret = false\n+@@ -667,8 +592,11 @@\n+ # includes-var, in-paths, test-object-var\n+ defineTest(qtConfResolvePathIncs) {\n+     ret = true\n+-    gcc: 2 = $$qtGccSysrootifiedPaths($$2)\n+-    for (incdir, 2) {\n++    gcc: \\\n++        local_paths = $$qtGccSysrootifiedPaths($$2)\n++    else: \\\n++        local_paths = $$2\n++    for (incdir, local_paths) {\n+         !exists($$incdir/.) {\n+             qtLog(\"Include path $$val_escape(incdir) is invalid.\")\n+             ret = false\n+@@ -727,6 +655,7 @@\n+         vars += $$eval(config.commandline.rev_assignments.$${iv})\n+         defined(config.input.$${iv}, var) {\n+             eval($${1}.builds.$${b} = $$eval(config.input.$${iv}))\n++            export($${1}.builds.$${b})\n+             $${1}.builds._KEYS_ *= $${b}\n+             any = true\n+         } else {\n+@@ -741,11 +670,14 @@\n+         export($${1}.builds._KEYS_)\n+         # we also reset the generic libs, to avoid surprises.\n+         $${1}.libs =\n++        export($${1}.libs)\n+     }\n+ \n+     # direct libs. overwrites inline libs.\n+-    defined(config.input.$${input}.libs, var): \\\n++    defined(config.input.$${input}.libs, var) {\n+         eval($${1}.libs = $$eval(config.input.$${input}.libs))\n++        export($${1}.libs)\n++    }\n+ \n+     includes = $$eval(config.input.$${input}.incdir)\n+ \n+@@ -754,6 +686,7 @@\n+     !isEmpty(prefix) {\n+         includes += $$prefix/include\n+         $${1}.libs = -L$$prefix/lib $$eval($${1}.libs)\n++        export($${1}.libs)\n+     }\n+ \n+     libdir = $$eval(config.input.$${input}.libdir)\n+@@ -762,11 +695,9 @@\n+         for (ld, libdir): \\\n+             libs += -L$$ld\n+         $${1}.libs = $$libs $$eval($${1}.libs)\n++        export($${1}.libs)\n+     }\n+ \n+-    !qtConfResolveAllLibs($$1): \\\n+-        return(false)\n+-\n+     !qtConfResolvePathIncs($${1}.includedir, $$includes, $$2): \\\n+         return(false)\n+ "
      },
      {
        "sha": "67f76f1d856ef9256fe31bd1db54f1c04f5eee63",
        "filename": "depends/patches/qt/fix_mingw_cross_compile.patch",
        "status": "removed",
        "additions": 0,
        "deletions": 25,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/depends/patches/qt/fix_mingw_cross_compile.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/depends/patches/qt/fix_mingw_cross_compile.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/fix_mingw_cross_compile.patch?ref=1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05",
        "patch": "@@ -1,25 +0,0 @@\n-commit 5a992a549adfe5a587bbcd6cd2b2cee47d236e27\n-Author: fanquake <fanquake@gmail.com>\n-Date:   Fri Sep 4 08:13:44 2020 +0800\n-\n-    Work around broken mingw cross-compilation\n-\n-    See upstream issues:\n-    https://bugreports.qt.io/browse/QTBUG-63637\n-    https://bugreports.qt.io/browse/QTBUG-63659\n-    https://codereview.qt-project.org/q/8bebded9\n-\n-    We should be able to drop this once we are building qt 5.10.1 or later.\n-\n-    Added in #12971.\n-\n-diff --git a/qtbase/mkspecs/win32-g++/qmake.conf b/qtbase/mkspecs/win32-g++/qmake.conf\n-index e071a0d1..ad229b10 100644\n---- a/qtbase/mkspecs/win32-g++/qmake.conf\n-+++ b/qtbase/mkspecs/win32-g++/qmake.conf\n-@@ -87,3 +87,5 @@ QMAKE_NM                = $${CROSS_COMPILE}nm -P\n- include(../common/angle.conf)\n-\n- load(qt_config)\n-+QMAKE_LINK_OBJECT_MAX = 10\n-+QMAKE_LINK_OBJECT_SCRIPT = object_script"
      },
      {
        "sha": "13723561384d8b7e80fc9e3879559d195ce5f098",
        "filename": "depends/patches/qt/fix_no_printer.patch",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/fix_no_printer.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/fix_no_printer.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/fix_no_printer.patch?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -10,10 +10,10 @@\n \n --- x/qtbase/src/plugins/plugins.pro\n +++ y/qtbase/src/plugins/plugins.pro\n-@@ -8,6 +8,3 @@ qtHaveModule(gui) {\n-     qtConfig(imageformatplugin): SUBDIRS *= imageformats\n+@@ -9,6 +9,3 @@ qtHaveModule(gui) {\n      !android:qtConfig(library): SUBDIRS *= generic\n  }\n+ qtHaveModule(widgets): SUBDIRS += styles\n -\n -!winrt:qtHaveModule(printsupport): \\\n -    SUBDIRS += printsupport"
      },
      {
        "sha": "d37b6c777646c39bd09b4ee63e8c98047b49bab4",
        "filename": "depends/patches/qt/fix_powerpc_libpng.patch",
        "status": "removed",
        "additions": 0,
        "deletions": 23,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/depends/patches/qt/fix_powerpc_libpng.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/depends/patches/qt/fix_powerpc_libpng.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/fix_powerpc_libpng.patch?ref=1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05",
        "patch": "@@ -1,23 +0,0 @@\n-commit 6f9feb773a43c5abfa3455da2e324180e789285b\n-Author: fanquake <fanquake@gmail.com>\n-Date:   Tue Sep 15 21:44:31 2020 +0800\n-\n-    Fix PowerPC build of libpng\n-\n-    See https://bugreports.qt.io/browse/QTBUG-66388.\n-\n-    Can be dropped when we are building qt 5.12.0 or later.\n-\n-diff --git a/qtbase/src/3rdparty/libpng/libpng.pro b/qtbase/src/3rdparty/libpng/libpng.pro\n-index 577b61d8..a2f56669 100644\n---- a/qtbase/src/3rdparty/libpng/libpng.pro\n-+++ b/qtbase/src/3rdparty/libpng/libpng.pro\n-@@ -10,7 +10,7 @@ MODULE_INCLUDEPATH = $$PWD\n- \n- load(qt_helper_lib)\n- \n--DEFINES += PNG_ARM_NEON_OPT=0\n-+DEFINES += PNG_ARM_NEON_OPT=0 PNG_POWERPC_VSX_OPT=0\n- SOURCES += \\\n-     png.c \\\n-     pngerror.c \\"
      },
      {
        "sha": "44c45187c51ef036414d0c8575e2d1b0c953541d",
        "filename": "depends/patches/qt/fix_qpainter_non_determinism.patch",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/fix_qpainter_non_determinism.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/fix_qpainter_non_determinism.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/fix_qpainter_non_determinism.patch?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -22,7 +22,7 @@ diff --git a/qtbase/src/gui/painting/qpaintengine_raster.cpp b/qtbase/src/gui/pa\n index 92ab6e8375..f018009e0b 100644\n --- a/qtbase/src/gui/painting/qpaintengine_raster.cpp\n +++ b/qtbase/src/gui/painting/qpaintengine_raster.cpp\n-@@ -3971,22 +3971,23 @@ static const QSpan *qt_intersect_spans(const QClipData *clip, int *currentClip,\n+@@ -4128,22 +4128,23 @@ static const QSpan *qt_intersect_spans(const QClipData *clip, int *currentClip,\n      const QSpan *clipEnd = clip->m_spans + clip->count;\n  \n      while (available && spans < end ) {\n@@ -51,7 +51,7 @@ index 92ab6e8375..f018009e0b 100644\n  \n          int sx1 = spans->x;\n          int sx2 = sx1 + spans->len;\n-@@ -4005,7 +4006,7 @@ static const QSpan *qt_intersect_spans(const QClipData *clip, int *currentClip,\n+@@ -4162,7 +4163,7 @@ static const QSpan *qt_intersect_spans(const QClipData *clip, int *currentClip,\n          if (len) {\n              out->x = qMax(sx1, cx1);\n              out->len = qMin(sx2, cx2) - out->x;"
      },
      {
        "sha": "a5de2b4b9ee34301b0be760bedb173d5ab157f5d",
        "filename": "depends/patches/qt/fix_qt_pkgconfig.patch",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/fix_qt_pkgconfig.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/fix_qt_pkgconfig.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/fix_qt_pkgconfig.patch?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1,17 +1,17 @@\n --- old/qtbase/mkspecs/features/qt_module.prf\n +++ new/qtbase/mkspecs/features/qt_module.prf\n-@@ -264,7 +264,7 @@\n+@@ -269,7 +269,7 @@ load(qt_installs)\n  load(qt_targets)\n  \n  # this builds on top of qt_common\n--!internal_module:!lib_bundle:if(unix|mingw) {\n+-!internal_module:if(unix|mingw) {\n +if(unix|mingw):!if(darwin:debug_and_release:CONFIG(debug, debug|release)) {\n      CONFIG += create_pc\n      QMAKE_PKGCONFIG_DESTDIR = pkgconfig\n      host_build: \\\n-@@ -274,9 +274,9 @@\n-     QMAKE_PKGCONFIG_INCDIR = $$[QT_INSTALL_HEADERS/raw]\n-     QMAKE_PKGCONFIG_CFLAGS = -I${includedir}/$$MODULE_INCNAME\n+@@ -284,9 +284,9 @@ load(qt_targets)\n+         QMAKE_PKGCONFIG_CFLAGS = -D$$MODULE_DEFINE -I${includedir}/$$MODULE_INCNAME\n+     }\n      QMAKE_PKGCONFIG_NAME = $$replace(TARGET, ^Qt, \"Qt$$QT_MAJOR_VERSION \")\n -    QMAKE_PKGCONFIG_FILE = $$replace(TARGET, ^Qt, Qt$$QT_MAJOR_VERSION)\n +    QMAKE_PKGCONFIG_FILE = $$replace(TARGET, ^Qt, Qt$$QT_MAJOR_VERSION)$$qtPlatformTargetSuffix()\n@@ -20,4 +20,4 @@\n +        QMAKE_PKGCONFIG_REQUIRES += $$replace(QT.$${i}.name, ^Qt, Qt$$section(QT.$${i}.VERSION, ., 0, 0))$$qtPlatformTargetSuffix()\n      isEmpty(QMAKE_PKGCONFIG_DESCRIPTION): \\\n          QMAKE_PKGCONFIG_DESCRIPTION = $$replace(TARGET, ^Qt, \"Qt \") module\n-     pclib_replace.match = $$lib_replace.match\n+     !isEmpty(lib_replace0.match) {"
      },
      {
        "sha": "c1b07fe23afdbd7a2f204811e2aad132bd2d9dff",
        "filename": "depends/patches/qt/fix_rcc_determinism.patch",
        "status": "removed",
        "additions": 0,
        "deletions": 15,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/depends/patches/qt/fix_rcc_determinism.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/depends/patches/qt/fix_rcc_determinism.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/fix_rcc_determinism.patch?ref=1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05",
        "patch": "@@ -1,15 +0,0 @@\n---- old/qtbase/src/tools/rcc/rcc.cpp\n-+++ new/qtbase/src/tools/rcc/rcc.cpp\n-@@ -207,7 +207,11 @@ void RCCFileInfo::writeDataInfo(RCCResourceLibrary &lib)\n-     if (lib.formatVersion() >= 2) {\n-         // last modified time stamp\n-         const QDateTime lastModified = m_fileInfo.lastModified();\n--        lib.writeNumber8(quint64(lastModified.isValid() ? lastModified.toMSecsSinceEpoch() : 0));\n-+        quint64 lastmod = quint64(lastModified.isValid() ? lastModified.toMSecsSinceEpoch() : 0);\n-+        static const quint64 sourceDate = 1000 * qgetenv(\"QT_RCC_SOURCE_DATE_OVERRIDE\").toULongLong();\n-+        if (sourceDate != 0)\n-+            lastmod = sourceDate;\n-+        lib.writeNumber8(lastmod);\n-         if (text || pass1)\n-             lib.writeChar('\\n');\n-     }"
      },
      {
        "sha": "e7f29f01f9cd7f250b86bbd038175aa6a0fb35b0",
        "filename": "depends/patches/qt/fix_riscv64_arch.patch",
        "status": "removed",
        "additions": 0,
        "deletions": 14,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/depends/patches/qt/fix_riscv64_arch.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/depends/patches/qt/fix_riscv64_arch.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/fix_riscv64_arch.patch?ref=1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05",
        "patch": "@@ -1,14 +0,0 @@\n-diff --git a/qtbase/src/3rdparty/double-conversion/include/double-conversion/utils.h b/qtbase/src/3rdparty/double-conversion/include/double-conversion/utils.h\n-index 20bfd36..93729fa 100644\n---- a/qtbase/src/3rdparty/double-conversion/include/double-conversion/utils.h\n-+++ b/qtbase/src/3rdparty/double-conversion/include/double-conversion/utils.h\n-@@ -65,7 +65,8 @@\n-     defined(__sparc__) || defined(__sparc) || defined(__s390__) || \\\n-     defined(__SH4__) || defined(__alpha__) || \\\n-     defined(_MIPS_ARCH_MIPS32R2) || \\\n--    defined(__AARCH64EL__)\n-+    defined(__AARCH64EL__) || defined(__aarch64__) || \\\n-+    defined(__riscv)\n- #define DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS 1\n- #elif defined(_M_IX86) || defined(__i386__) || defined(__i386)\n- #if defined(_WIN32)"
      },
      {
        "sha": "1ca55f1ce32bd11f7dd4b737c8b792341b2ca7e0",
        "filename": "depends/patches/qt/freetype_back_compat.patch",
        "status": "removed",
        "additions": 0,
        "deletions": 28,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/depends/patches/qt/freetype_back_compat.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/depends/patches/qt/freetype_back_compat.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/freetype_back_compat.patch?ref=1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05",
        "patch": "@@ -1,28 +0,0 @@\n-commit 14bc77db61bf9d56f9b6c8b84aa02573605c19c6\n-Author: fanquake <fanquake@gmail.com>\n-Date:   Tue Aug 18 15:15:08 2020 +0800\n-\n-    Fix backwards compatibility with older Freetype versions at runtime\n-\n-    A few years ago, libfreetype introduced FT_Get_Font_Format() as an alias\n-    for FT_Get_X11_Font_Format(), but FT_Get_X11_Font_Format() was kept for abi\n-    backwards-compatibility.\n-\n-    Qt 5.9 introduced a call to FT_Get_Font_Format(). Replace it with FT_Get_X11_Font_Format()\n-    in order to remain compatible with older freetype, which is still used by e.g. Ubuntu Trusty.\n-\n-    See #14348.\n-\n-diff --git a/qtbase/src/platformsupport/fontdatabases/freetype/qfontengine_ft.cpp b/qtbase/src/platformsupport/fontdatabases/freetype/qfontengine_ft.cpp\n-index 3f543755..8ecc1c8c 100644\n---- a/qtbase/src/platformsupport/fontdatabases/freetype/qfontengine_ft.cpp\n-+++ b/qtbase/src/platformsupport/fontdatabases/freetype/qfontengine_ft.cpp\n-@@ -898,7 +898,7 @@ bool QFontEngineFT::init(FaceId faceId, bool antialias, GlyphFormat format,\n-         }\n-     }\n- #if defined(FT_FONT_FORMATS_H)\n--    const char *fmt = FT_Get_Font_Format(face);\n-+    const char *fmt = FT_Get_X11_Font_Format(face);\n-     if (fmt && qstrncmp(fmt, \"CFF\", 4) == 0) {\n-         FT_Bool no_stem_darkening = true;\n-         FT_Error err = FT_Property_Get(qt_getFreetype(), \"cff\", \"no-stem-darkening\", &no_stem_darkening);"
      },
      {
        "sha": "f4a6f09ee49b8caee40f13acbbbe2e72ff74b799",
        "filename": "depends/patches/qt/no-xlib.patch",
        "status": "modified",
        "additions": 9,
        "deletions": 8,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/no-xlib.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/no-xlib.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/no-xlib.patch?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -22,23 +22,23 @@ index 7c62c2e2b3..c05c6c0a07 100644\n  #include <xcb/xfixes.h>\n  #include <xcb/xcb_image.h>\n  \n-@@ -384,6 +386,7 @@ void QXcbCursor::changeCursor(QCursor *cursor, QWindow *widget)\n-     w->setCursor(c, isBitmapCursor);\n+@@ -391,6 +393,7 @@ void QXcbCursor::changeCursor(QCursor *cursor, QWindow *window)\n+     xcb_flush(xcb_connection());\n  }\n  \n +#if QT_CONFIG(xcb_xlib) && QT_CONFIG(library)\n  static int cursorIdForShape(int cshape)\n  {\n      int cursorId = 0;\n-@@ -437,6 +440,7 @@ static int cursorIdForShape(int cshape)\n+@@ -444,6 +447,7 @@ static int cursorIdForShape(int cshape)\n      }\n      return cursorId;\n  }\n +#endif\n  \n  xcb_cursor_t QXcbCursor::createNonStandardCursor(int cshape)\n  {\n-@@ -558,7 +562,9 @@ static xcb_cursor_t loadCursor(void *dpy, int cshape)\n+@@ -556,7 +560,9 @@ static xcb_cursor_t loadCursor(void *dpy, int cshape)\n  xcb_cursor_t QXcbCursor::createFontCursor(int cshape)\n  {\n      xcb_connection_t *conn = xcb_connection();\n@@ -48,22 +48,23 @@ index 7c62c2e2b3..c05c6c0a07 100644\n      xcb_cursor_t cursor = XCB_NONE;\n  \n      // Try Xcursor first\n-@@ -589,6 +595,7 @@ xcb_cursor_t QXcbCursor::createFontCursor(int cshape)\n+@@ -585,7 +591,7 @@ xcb_cursor_t QXcbCursor::createFontCursor(int cshape)\n+ \n      // Non-standard X11 cursors are created from bitmaps\n      cursor = createNonStandardCursor(cshape);\n- \n+-\n +#if QT_CONFIG(xcb_xlib) && QT_CONFIG(library)\n      // Create a glpyh cursor if everything else failed\n      if (!cursor && cursorId) {\n          cursor = xcb_generate_id(conn);\n-@@ -596,6 +603,7 @@ xcb_cursor_t QXcbCursor::createFontCursor(int cshape)\n+@@ -593,6 +599,7 @@ xcb_cursor_t QXcbCursor::createFontCursor(int cshape)\n                                  cursorId, cursorId + 1,\n                                  0xFFFF, 0xFFFF, 0xFFFF, 0, 0, 0);\n      }\n +#endif\n  \n      if (cursor && cshape >= 0 && cshape < Qt::LastCursor && connection()->hasXFixes()) {\n-         const char *name = cursorNames[cshape];\n+         const char *name = cursorNames[cshape].front();\n -- \n 2.22.0\n "
      },
      {
        "sha": "b16635b572025b70996f22f8d44d8e4ebed11a3b",
        "filename": "depends/patches/qt/no_sdk_version_check.patch",
        "status": "added",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/no_sdk_version_check.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/depends/patches/qt/no_sdk_version_check.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/no_sdk_version_check.patch?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -0,0 +1,20 @@\n+commit f5eb142cd04be2bc4ca610ed3b5b7e8ce3520ee3\n+Author: fanquake <fanquake@gmail.com>\n+Date:   Tue Jan 5 16:08:49 2021 +0800\n+\n+    Don't invoke macOS SDK version checking\n+    \n+    This tries to use xcrun which is not available when cross-compiling.\n+\n+diff --git a/qtbase/mkspecs/features/mac/default_post.prf b/qtbase/mkspecs/features/mac/default_post.prf\n+index 92a9112bca6..447e186eb26 100644\n+--- a/qtbase/mkspecs/features/mac/default_post.prf\n++++ b/qtbase/mkspecs/features/mac/default_post.prf\n+@@ -8,7 +8,6 @@ contains(TEMPLATE, .*app) {\n+     !macx-xcode:if(isEmpty(BUILDS)|build_pass) {\n+         # Detect changes to the platform SDK\n+         QMAKE_EXTRA_VARIABLES += QMAKE_MAC_SDK QMAKE_MAC_SDK_VERSION QMAKE_XCODE_DEVELOPER_PATH\n+-        QMAKE_EXTRA_INCLUDES += $$shell_quote($$PWD/sdk.mk)\n+     }\n+ \n+     # Detect incompatible SDK versions"
      },
      {
        "sha": "165abf3e2e7a6d7cdbe7b960ec15dbcfaf0a9dfd",
        "filename": "depends/patches/qt/xkb-default.patch",
        "status": "removed",
        "additions": 0,
        "deletions": 26,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/depends/patches/qt/xkb-default.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/depends/patches/qt/xkb-default.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/xkb-default.patch?ref=1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05",
        "patch": "@@ -1,26 +0,0 @@\n---- old/qtbase/src/gui/configure.pri\t2018-06-06 17:28:10.000000000 -0400\n-+++ new/qtbase/src/gui/configure.pri\t2018-08-17 18:43:01.589384567 -0400\n-@@ -43,18 +43,11 @@\n- }\n-\n- defineTest(qtConfTest_xkbConfigRoot) {\n--    qtConfTest_getPkgConfigVariable($${1}): return(true)\n--\n--    for (dir, $$list(\"/usr/share/X11/xkb\", \"/usr/local/share/X11/xkb\")) {\n--        exists($$dir) {\n--            $${1}.value = $$dir\n--            export($${1}.value)\n--            $${1}.cache += value\n--            export($${1}.cache)\n--            return(true)\n--        }\n--    }\n--    return(false)\n-+    $${1}.value = \"/usr/share/X11/xkb\"\n-+    export($${1}.value)\n-+    $${1}.cache += value\n-+    export($${1}.cache)\n-+    return(true)\n- }\n-\n- defineTest(qtConfTest_qpaDefaultPlatform) {"
      },
      {
        "sha": "f32600d009d92982fd91cbe4cbf7b3b9b32ffe94",
        "filename": "doc/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/doc/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/doc/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README.md?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -44,6 +44,7 @@ The following are developer notes on how to build Bitcoin Core on your native pl\n - [FreeBSD Build Notes](build-freebsd.md)\n - [OpenBSD Build Notes](build-openbsd.md)\n - [NetBSD Build Notes](build-netbsd.md)\n+- [Android Build Notes](build-android.md)\n - [Gitian Building Guide (External Link)](https://github.com/bitcoin-core/docs/blob/master/gitian-building.md)\n \n Development"
      },
      {
        "sha": "f72dbead9d12c27406369c967b0ed3fec996fed3",
        "filename": "doc/bips.md",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/doc/bips.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/doc/bips.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/bips.md?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1,4 +1,4 @@\n-BIPs that are implemented by Bitcoin Core (up-to-date up to **v0.21.0**):\n+BIPs that are implemented by Bitcoin Core (up-to-date up to **v22.0**):\n \n * [`BIP 9`](https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki): The changes allowing multiple soft-forks to be deployed in parallel have been implemented since **v0.12.1**  ([PR #7575](https://github.com/bitcoin/bitcoin/pull/7575))\n * [`BIP 11`](https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki): Multisig outputs are standard since **v0.6.0** ([PR #669](https://github.com/bitcoin/bitcoin/pull/669)).\n@@ -50,3 +50,4 @@ BIPs that are implemented by Bitcoin Core (up-to-date up to **v0.21.0**):\n * [`BIP 325`](https://github.com/bitcoin/bips/blob/master/bip-0325.mediawiki): Signet test network is supported as of **v0.21.0** ([PR 18267](https://github.com/bitcoin/bitcoin/pull/18267)).\n * [`BIP 339`](https://github.com/bitcoin/bips/blob/master/bip-0339.mediawiki): Relay of transactions by wtxid is supported as of **v0.21.0** ([PR 18044](https://github.com/bitcoin/bitcoin/pull/18044)).\n * [`BIP 340`](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki) [`341`](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki) [`342`](https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki): Validation rules for Taproot (including Schnorr signatures and Tapscript leaves) are implemented as of **v0.21.0** ([PR 19953](https://github.com/bitcoin/bitcoin/pull/19953)), without mainnet activation.\n+* [`BIP 350`](https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki): Addresses for native v1+ segregated Witness outputs use Bech32m instead of Bech32 as of **v22.0** ([PR 20861](https://github.com/bitcoin/bitcoin/pull/20861))."
      },
      {
        "sha": "9a312bc33c7aa84ea22ebd1fb48411763bf658f4",
        "filename": "doc/bitcoin-conf.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/doc/bitcoin-conf.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/doc/bitcoin-conf.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/bitcoin-conf.md?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -27,7 +27,7 @@ Comments may appear in two ways:\n ### Network specific options\n \n Network specific options can be:\n-- placed into sections with headers `[main]` (not `[mainnet]`), `[test]` (not `[testnet]`) or `[regtest]`;\n+- placed into sections with headers `[main]` (not `[mainnet]`), `[test]` (not `[testnet]`), `[signet]` or `[regtest]`;\n - prefixed with a chain name; e.g., `regtest.maxmempool=100`.\n \n Network specific options take precedence over non-network specific options."
      },
      {
        "sha": "7a8a9e6a653e403003126d6800707394f20bf879",
        "filename": "doc/build-android.md",
        "status": "added",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/doc/build-android.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/doc/build-android.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-android.md?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -0,0 +1,12 @@\n+ANDROID BUILD NOTES\n+======================\n+\n+This guide describes how to build and package the `bitcoin-qt` GUI for Android on Linux and macOS.\n+\n+## Preparation\n+\n+You will need to get the Android NDK and build dependencies for Android as described in [depends/README.md](../depends/README.md).\n+\n+## Building and packaging\n+\n+After the depends are built configure with one of the resulting prefixes and run `make && make apk` in `src/qt`.\n\\ No newline at end of file"
      },
      {
        "sha": "16c6da66d5b4a6ff4a3ad5f7615ed7611a8563e3",
        "filename": "doc/build-osx.md",
        "status": "modified",
        "additions": 256,
        "deletions": 74,
        "changes": 330,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/doc/build-osx.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/doc/build-osx.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-osx.md?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1,116 +1,303 @@\n-# macOS Build Instructions and Notes\n+# macOS Build Guide\n+\n+**Updated for MacOS [11.2](https://www.apple.com/macos/big-sur/)**\n+\n+This guide describes how to build bitcoind, command-line utilities, and GUI on macOS\n+\n+**Note:** The following is for Intel Macs only!\n+\n+## Dependencies\n+\n+The following dependencies are **required**:\n+\n+Library                                                    | Purpose    | Description\n+-----------------------------------------------------------|------------|----------------------\n+[automake](https://formulae.brew.sh/formula/automake)      | Build      | Generate makefile\n+[libtool](https://formulae.brew.sh/formula/libtool)        | Build      | Shared library support\n+[pkg-config](https://formulae.brew.sh/formula/pkg-config)  | Build      | Configure compiler and linker flags\n+[boost](https://formulae.brew.sh/formula/boost)            | Utility    | Library for threading, data structures, etc\n+[libevent](https://formulae.brew.sh/formula/libevent)      | Networking | OS independent asynchronous networking\n+\n+The following dependencies are **optional**:\n+\n+Library                                                         | Purpose          | Description\n+--------------------------------------------------------------- |------------------|----------------------\n+[berkeley-db@4](https://formulae.brew.sh/formula/berkeley-db@4) | Berkeley DB      | Wallet storage (only needed when wallet enabled)\n+[qt@5](https://formulae.brew.sh/formula/qt@5)                   | GUI              | GUI toolkit (only needed when GUI enabled)\n+[qrencode](https://formulae.brew.sh/formula/qrencode)           | QR codes in GUI  | Generating QR codes (only needed when GUI enabled)\n+[zeromq](https://formulae.brew.sh/formula/zeromq)               | ZMQ notification | Allows generating ZMQ notifications (requires ZMQ version >= 4.0.0)\n+[sqlite](https://formulae.brew.sh/formula/sqlite)               | SQLite DB        | Wallet storage (only needed when wallet enabled)\n+[miniupnpc](https://formulae.brew.sh/formula/miniupnpc)         | UPnP Support     | Firewall-jumping support (needed for port mapping support)\n+[libnatpmp](https://formulae.brew.sh/formula/libnatpmp)         | NAT-PMP Support  | Firewall-jumping support (needed for port mapping support)\n+[python3](https://formulae.brew.sh/formula/python@3.9)          | Testing          | Python Interpreter (only needed when running the test suite)\n+\n+The following dependencies are **optional** packages required for deploying:\n+\n+Library                                             | Purpose          | Description\n+----------------------------------------------------|------------------|----------------------\n+[librsvg](https://formulae.brew.sh/formula/librsvg) | Deploy Dependency| Library to render SVG files\n+[ds_store](https://pypi.org/project/ds-store/)      | Deploy Dependency| Examine and modify .DS_Store files\n+[mac_alias](https://pypi.org/project/mac-alias/)    | Deploy Dependency| Generate/Read binary alias and bookmark records\n+\n+See [dependencies.md](dependencies.md) for a complete overview.\n+\n+## Preparation\n \n The commands in this guide should be executed in a Terminal application.\n-The built-in one is located in\n+macOS comes with a built-in Terminal located in:\n+\n ```\n /Applications/Utilities/Terminal.app\n ```\n \n-## Preparation\n-Install the macOS command line tools:\n+### 1. Xcode Command Line Tools\n \n-```shell\n+The Xcode Command Line Tools are a collection of build tools for macOS.\n+These tools must be installed in order to build Bitcoin Core from source.\n+\n+To install, run the following command from your terminal:\n+\n+``` bash\n xcode-select --install\n ```\n \n-When the popup appears, click `Install`.\n+Upon running the command, you should see a popup appear.\n+Click on `Install` to continue the installation process.\n \n-Then install [Homebrew](https://brew.sh).\n+### 2. Homebrew Package Manager\n \n-## Dependencies\n-```shell\n-brew install automake libtool boost miniupnpc libnatpmp pkg-config python qt@5 libevent qrencode\n+Homebrew is a package manager for macOS that allows one to install packages from the command line easily.\n+While several package managers are available for macOS, this guide will focus on Homebrew as it is the most popular.\n+Since the examples in this guide which walk through the installation of a package will use Homebrew, it is recommended that you install it to follow along.\n+Otherwise, you can adapt the commands to your package manager of choice.\n+\n+To install the Homebrew package manager, see: https://brew.sh\n+\n+Note: If you run into issues while installing Homebrew or pulling packages, refer to [Homebrew's troubleshooting page](https://docs.brew.sh/Troubleshooting).\n+\n+### 3. Install Required Dependencies\n+\n+The first step is to download the required dependencies.\n+These dependencies represent the packages required to get a barebones installation up and running.\n+To install, run the following from your terminal:\n+\n+``` bash\n+brew install automake libtool boost pkg-config libevent\n ```\n \n-If you run into issues, check [Homebrew's troubleshooting page](https://docs.brew.sh/Troubleshooting).\n-See [dependencies.md](dependencies.md) for a complete overview.\n+### 4. Clone Bitcoin repository\n \n-If you want to build the disk image with `make deploy` (.dmg / optional), you need RSVG:\n-```shell\n-brew install librsvg\n+`git` should already be installed by default on your system.\n+Now that all the required dependencies are installed, let's clone the Bitcoin Core repository to a directory.\n+All build scripts and commands will run from this directory.\n+\n+``` bash\n+git clone https://github.com/bitcoin/bitcoin.git\n ```\n \n-and [`macdeployqtplus`](../contrib/macdeploy/README.md) dependencies:\n-```shell\n-pip3 install ds_store mac_alias\n+### 5. Install Optional Dependencies\n+\n+#### Wallet Dependencies\n+\n+It is not necessary to build wallet functionality to run `bitcoind` or  `bitcoin-qt`.\n+To enable legacy wallets, you must install `berkeley-db@4`.\n+To enable [descriptor wallets](https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md), `sqlite` is required.\n+Skip `berkeley-db@4` if you intend to *exclusively* use descriptor wallets.\n+\n+###### Legacy Wallet Support\n+\n+`berkeley-db@4` is required to enable support for legacy wallets.\n+Skip if you don't intend to use legacy wallets.\n+\n+``` bash\n+brew install berkeley-db@4\n ```\n \n-The wallet support requires one or both of the dependencies ([*SQLite*](#sqlite) and [*Berkeley DB*](#berkeley-db)) in the sections below.\n-To build Bitcoin Core without wallet, see [*Disable-wallet mode*](#disable-wallet-mode).\n+###### Descriptor Wallet Support\n \n-#### SQLite\n+Note: Apple has included a useable `sqlite` package since macOS 10.14.\n+You may not need to install this package.\n \n-Usually, macOS installation already has a suitable SQLite installation.\n-Also, the Homebrew package could be installed:\n+`sqlite` is required to enable support for descriptor wallets.\n+Skip if you don't intend to use descriptor wallets.\n \n-```shell\n+``` bash\n brew install sqlite\n ```\n+---\n \n-In that case the Homebrew package will prevail.\n+#### GUI Dependencies\n \n-#### Berkeley DB\n+###### Qt\n \n-It is recommended to use Berkeley DB 4.8. If you have to build it yourself,\n-you can use [this](/contrib/install_db4.sh) script to install it\n-like so:\n+Bitcoin Core includes a GUI built with the cross-platform Qt Framework.\n+To compile the GUI, we need to install `qt@5`.\n+Skip if you don't intend to use the GUI.\n \n-```shell\n-./contrib/install_db4.sh .\n+``` bash\n+brew install qt@5\n ```\n \n-from the root of the repository.\n+Note: Building with Qt binaries downloaded from the Qt website is not officially supported.\n+See the notes in [#7714](https://github.com/bitcoin/bitcoin/issues/7714).\n \n-Also, the Homebrew package could be installed:\n+###### qrencode\n \n-```shell\n-brew install berkeley-db4\n+The GUI can encode addresses in a QR Code. To build in QR support for the GUI, install `qrencode`.\n+Skip if not using the GUI or don't want QR code functionality.\n+\n+``` bash\n+brew install qrencode\n ```\n+---\n+\n+#### Port Mapping Dependencies\n+\n+###### miniupnpc\n \n-## Build Bitcoin Core\n+miniupnpc may be used for UPnP port mapping.\n+Skip if you do not need this functionality.\n \n-1. Clone the Bitcoin Core source code:\n-    ```shell\n-    git clone https://github.com/bitcoin/bitcoin\n-    cd bitcoin\n-    ```\n+``` bash\n+brew install miniupnpc\n+```\n \n-2.  Build Bitcoin Core:\n+###### libnatpmp\n \n-    Configure and build the headless Bitcoin Core binaries as well as the GUI (if Qt is found).\n+libnatpmp may be used for NAT-PMP port mapping.\n+Skip if you do not need this functionality.\n \n-    You can disable the GUI build by passing `--without-gui` to configure.\n-    ```shell\n-    ./autogen.sh\n-    ./configure\n-    make\n-    ```\n+``` bash\n+brew install libnatpmp\n+```\n \n-3.  It is recommended to build and run the unit tests:\n-    ```shell\n-    make check\n-    ```\n+Note: UPnP and NAT-PMP support will be compiled in and disabled by default.\n+Check out the [further configuration](#further-configuration) section for more information.\n \n-4.  You can also create a  `.dmg` that contains the `.app` bundle (optional):\n-    ```shell\n-    make deploy\n-    ```\n+---\n \n-## Disable-wallet mode\n-When the intention is to run only a P2P node without a wallet, Bitcoin Core may be\n-compiled in disable-wallet mode with:\n-```shell\n-./configure --disable-wallet\n+#### ZMQ Dependencies\n+\n+Support for ZMQ notifications requires the following dependency.\n+Skip if you do not need ZMQ functionality.\n+\n+``` bash\n+brew install zeromq\n ```\n \n-In this case there is no dependency on [*Berkeley DB*](#berkeley-db) and [*SQLite*](#sqlite).\n+ZMQ is automatically compiled in and enabled if the dependency is detected.\n+Check out the [further configuration](#further-configuration) section for more information.\n+\n+For more information on ZMQ, see: [zmq.md](zmq.md)\n \n-Mining is also possible in disable-wallet mode using the `getblocktemplate` RPC call.\n+---\n \n-## Running\n-Bitcoin Core is now available at `./src/bitcoind`\n+#### Test Suite Dependencies\n+\n+There is an included test suite that is useful for testing code changes when developing.\n+To run the test suite (recommended), you will need to have Python 3 installed:\n+\n+``` bash\n+brew install python\n+```\n+\n+---\n+\n+#### Deploy Dependencies\n+\n+You can deploy a `.dmg` containing the Bitcoin Core application using `make deploy`.\n+This command depends on a couple of python packages, so it is required that you have `python` installed.\n+\n+Ensuring that `python` is installed, you can install the deploy dependencies by running the following commands in your terminal:\n+\n+``` bash\n+brew install librsvg\n+```\n+\n+``` bash\n+pip3 install ds_store mac_alias\n+```\n+\n+## Building Bitcoin Core\n+\n+### 1. Configuration\n+\n+There are many ways to configure Bitcoin Core, here are a few common examples:\n+\n+##### Wallet (BDB + SQlite) Support, No GUI:\n+\n+If `berkeley-db@4` is installed, then legacy wallet support will be built.\n+If `berkeley-db@4` is not installed, then this will throw an error.\n+If `sqlite` is installed, then descriptor wallet support will also be built.\n+Additionally, this explicitly disables the GUI.\n+\n+``` bash\n+./autogen.sh\n+./configure --with-gui=no\n+```\n+\n+##### Wallet (only SQlite) and GUI Support:\n+\n+This explicitly enables the GUI and disables legacy wallet support.\n+If `qt` is not installed, this will throw an error.\n+If `sqlite` is installed then descriptor wallet functionality will be built.\n+If `sqlite` is not installed, then wallet functionality will be disabled.\n+\n+``` bash\n+./autogen.sh\n+./configure --without-bdb --with-gui=yes\n+```\n+\n+##### No Wallet or GUI\n+\n+``` bash\n+./autogen.sh\n+./configure --without-wallet --with-gui=no\n+```\n+\n+##### Further Configuration\n+\n+You may want to dig deeper into the configuration options to achieve your desired behavior.\n+Examine the output of the following command for a full list of configuration options:\n+\n+``` bash\n+./configure -help\n+```\n+\n+### 2. Compile\n+\n+After configuration, you are ready to compile.\n+Run the following in your terminal to compile Bitcoin Core:\n+\n+``` bash\n+make -jx    # use -jX here for parallelism\n+make check  # Run tests if Python 3 is available\n+```\n+\n+### 3. Deploy (optional)\n+\n+You can also create a  `.dmg` containing the `.app` bundle by running the following command:\n+\n+``` bash\n+make deploy\n+```\n+\n+## Running Bitcoin Core\n+\n+Bitcoin Core should now be available at `./src/bitcoind`.\n+If you compiled support for the GUI, it should be available at `./src/qt/bitcoin-qt`.\n+\n+The first time you run `bitcoind` or `bitcoin-qt`, it will start downloading the blockchain.\n+This process could take many hours, or even days on slower than average systems.\n+\n+By default, blockchain and wallet data files will be stored in:\n+\n+``` bash\n+/Users/${USER}/Library/Application Support/Bitcoin/\n+```\n \n Before running, you may create an empty configuration file:\n+\n ```shell\n mkdir -p \"/Users/${USER}/Library/Application Support/Bitcoin\"\n \n@@ -119,22 +306,17 @@ touch \"/Users/${USER}/Library/Application Support/Bitcoin/bitcoin.conf\"\n chmod 600 \"/Users/${USER}/Library/Application Support/Bitcoin/bitcoin.conf\"\n ```\n \n-The first time you run bitcoind, it will start downloading the blockchain. This process could\n-take many hours, or even days on slower than average systems.\n-\n You can monitor the download process by looking at the debug.log file:\n+\n ```shell\n tail -f $HOME/Library/Application\\ Support/Bitcoin/debug.log\n ```\n \n ## Other commands:\n+\n ```shell\n ./src/bitcoind -daemon      # Starts the bitcoin daemon.\n ./src/bitcoin-cli --help    # Outputs a list of command-line options.\n ./src/bitcoin-cli help      # Outputs a list of RPC commands when the daemon is running.\n+./src/qt/bitcoin-qt -server # Starts the bitcoin-qt server mode, allows bitcoin-cli control\n ```\n-\n-## Notes\n-* Tested on OS X 10.14 Mojave through macOS 11 Big Sur on 64-bit Intel\n-processors only.\n-* Building with downloaded Qt binaries is not officially supported. See the notes in [#7714](https://github.com/bitcoin/bitcoin/issues/7714)."
      },
      {
        "sha": "22161856cec76b62863b567dadaea1bee9a268ac",
        "filename": "doc/dependencies.md",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/doc/dependencies.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/doc/dependencies.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/dependencies.md?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -14,19 +14,19 @@ These are the dependencies currently used by Bitcoin Core. You can find instruct\n | GCC |  | [7+](https://gcc.gnu.org/) (C++17 support) |  |  |  |\n | HarfBuzz-NG |  |  |  |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk) |\n | libevent | [2.1.11-stable](https://github.com/libevent/libevent/releases) | [2.0.21](https://github.com/bitcoin/bitcoin/pull/18676) | No |  |  |\n-| libnatpmp | [20150609](https://miniupnp.tuxfamily.org/files) |  | No |  |  |\n+| libnatpmp | git commit [4536032...](https://github.com/miniupnp/libnatpmp/tree/4536032ae32268a45c073a4d5e91bbab4534773a) |  | No |  |  |\n | libpng |  |  |  |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk) |\n | librsvg | |  |  |  |  |\n-| MiniUPnPc | [2.0.20180203](https://miniupnp.tuxfamily.org/files) |  | No |  |  |\n+| MiniUPnPc | [2.2.2](https://miniupnp.tuxfamily.org/files) |  | No |  |  |\n | PCRE |  |  |  |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk) |\n | Python (tests) |  | [3.6](https://www.python.org/downloads) |  |  |  |\n | qrencode | [3.4.4](https://fukuchi.org/works/qrencode) |  | No |  |  |\n-| Qt | [5.9.8](https://download.qt.io/official_releases/qt/) | [5.9.5](https://github.com/bitcoin/bitcoin/issues/20104) | No |  |  |\n+| Qt | [5.12.10](https://download.qt.io/official_releases/qt/) | [5.9.5](https://github.com/bitcoin/bitcoin/issues/20104) | No |  |  |\n | SQLite | [3.32.1](https://sqlite.org/download.html) | [3.7.17](https://github.com/bitcoin/bitcoin/pull/19077) |  |  |  |\n | XCB |  |  |  |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk) (Linux only) |\n | xkbcommon |  |  |  |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk) (Linux only) |\n | ZeroMQ | [4.3.1](https://github.com/zeromq/libzmq/releases) | 4.0.0 | No |  |  |\n-| zlib | [1.2.11](https://zlib.net/) |  |  |  | No |\n+| zlib |  |  |  |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk) |\n \n Controlling dependencies\n ------------------------\n@@ -43,3 +43,4 @@ Some dependencies are not needed in all configurations. The following are some f\n \n #### Other\n * librsvg is only needed if you need to run `make deploy` on (cross-compilation to) macOS.\n+* Not-Qt-bundled zlib is required to build the [DMG tool](../contrib/macdeploy/README.md#deterministic-macos-dmg-notes) from the libdmg-hfsplus project."
      },
      {
        "sha": "0a78cdff202464ecc37641916eb708594d9fbfd8",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -595,11 +595,6 @@ Common misconceptions are clarified in those sections:\n \n   - *Rationale*: This avoids memory and resource leaks, and ensures exception safety.\n \n-- Use `MakeUnique()` to construct objects owned by `unique_ptr`s.\n-\n-  - *Rationale*: `MakeUnique` is concise and ensures exception safety in complex expressions.\n-    `MakeUnique` is a temporary project local implementation of `std::make_unique` (C++14).\n-\n C++ data structures\n --------------------\n "
      },
      {
        "sha": "2b3b378bee06b5aabbf9544b89633aacf7bf1565",
        "filename": "doc/external-signer.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/doc/external-signer.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/doc/external-signer.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/external-signer.md?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -4,7 +4,7 @@ Bitcoin Core can be launched with `-signer=<cmd>` where `<cmd>` is an external t\n \n ## Example usage\n \n-The following example is based on the [HWI](https://github.com/bitcoin-core/HWI) tool. Although this tool is hosted under the Bitcoin Core GitHub organization and maintained by Bitcoin Core developers, it should be used with caution. It is considered experimental and has far less review than Bitcoin Core itself. Be particularly careful when running tools such as these on a computer with private keys on it.\n+The following example is based on the [HWI](https://github.com/bitcoin-core/HWI) tool. Version 2.0 or newer is required. Although this tool is hosted under the Bitcoin Core GitHub organization and maintained by Bitcoin Core developers, it should be used with caution. It is considered experimental and has far less review than Bitcoin Core itself. Be particularly careful when running tools such as these on a computer with private keys on it.\n \n When using a hardware wallet, consult the manufacturer website for (alternative) software they recommend. As long as their software conforms to the standard below, it should be able to work with Bitcoin Core.\n "
      },
      {
        "sha": "4d8825f4c23647a3e45452699bc7d0d2b64c8584",
        "filename": "doc/fuzzing.md",
        "status": "modified",
        "additions": 9,
        "deletions": 10,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/doc/fuzzing.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/doc/fuzzing.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/fuzzing.md?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -108,33 +108,32 @@ Full configure that was tested on macOS Catalina with `brew` installed `llvm`:\n \n Read the [libFuzzer documentation](https://llvm.org/docs/LibFuzzer.html) for more information. This [libFuzzer tutorial](https://github.com/google/fuzzing/blob/master/tutorial/libFuzzerTutorial.md) might also be of interest.\n \n-# Fuzzing Bitcoin Core using american fuzzy lop (`afl-fuzz`)\n+# Fuzzing Bitcoin Core using afl++\n \n ## Quickstart guide\n \n-To quickly get started fuzzing Bitcoin Core using [`afl-fuzz`](https://github.com/google/afl):\n+To quickly get started fuzzing Bitcoin Core using [afl++](https://github.com/AFLplusplus/AFLplusplus):\n \n ```sh\n $ git clone https://github.com/bitcoin/bitcoin\n $ cd bitcoin/\n-$ git clone https://github.com/google/afl\n-$ make -C afl/\n-$ make -C afl/llvm_mode/\n+$ git clone https://github.com/AFLplusplus/AFLplusplus\n+$ make -C AFLplusplus/ source-only\n $ ./autogen.sh\n-# It is possible to compile with afl-gcc and afl-g++ instead of afl-clang. However, running afl-fuzz\n-# may require more memory via the -m flag.\n-$ CC=$(pwd)/afl/afl-clang-fast CXX=$(pwd)/afl/afl-clang-fast++ ./configure --enable-fuzz\n+# If afl-clang-lto is not available, see\n+# https://github.com/AFLplusplus/AFLplusplus#a-selecting-the-best-afl-compiler-for-instrumenting-the-target\n+$ CC=$(pwd)/AFLplusplus/afl-clang-lto CXX=$(pwd)/AFLplusplus/afl-clang-lto++ ./configure --enable-fuzz\n $ make\n # For macOS you may need to ignore x86 compilation checks when running \"make\". If so,\n # try compiling using: AFL_NO_X86=1 make\n $ mkdir -p inputs/ outputs/\n $ echo A > inputs/thin-air-input\n-$ FUZZ=bech32 afl/afl-fuzz -i inputs/ -o outputs/ -- src/test/fuzz/fuzz\n+$ FUZZ=bech32 AFLplusplus/afl-fuzz -i inputs/ -o outputs/ -- src/test/fuzz/fuzz\n # You may have to change a few kernel parameters to test optimally - afl-fuzz\n # will print an error and suggestion if so.\n ```\n \n-Read the [`afl-fuzz` documentation](https://github.com/google/afl) for more information.\n+Read the [afl++ documentation](https://github.com/AFLplusplus/AFLplusplus) for more information.\n \n # Fuzzing Bitcoin Core using Honggfuzz\n "
      },
      {
        "sha": "5c68e4ab0c9bb6385d54751baee85116e255a650",
        "filename": "doc/release-notes-20861.md",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/doc/release-notes-20861.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/doc/release-notes-20861.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-20861.md?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -0,0 +1,13 @@\n+Updated RPCs\n+------------\n+\n+- Due to [BIP 350](https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki)\n+  being implemented, behavior for all RPCs that accept addresses is changed when\n+  a native witness version 1 (or higher) is passed. These now require a Bech32m\n+  encoding instead of a Bech32 one, and Bech32m encoding will be used for such\n+  addresses in RPC output as well. No version 1 addresses should be created\n+  for mainnet until consensus rules are adopted that give them meaning\n+  (e.g. through [BIP 341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki)).\n+  Once that happens, Bech32m is expected to be used for them, so this shouldn't\n+  affect any production systems, but may be observed on other networks where such\n+  addresses already have meaning (like signet)."
      },
      {
        "sha": "5b7fc776a4c48e8e38000ec693f6508ae607b4cb",
        "filename": "share/examples/bitcoin.conf",
        "status": "modified",
        "additions": 10,
        "deletions": 4,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/share/examples/bitcoin.conf",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/share/examples/bitcoin.conf",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/examples/bitcoin.conf?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -4,13 +4,16 @@\n \n # Network-related settings:\n \n-# Note that if you use testnet or regtest, particularly with the options\n+# Note that if you use testnet, signet or regtest, particularly with the options\n # addnode, connect, port, bind, rpcport, rpcbind or wallet, you will also\n # want to read \"[Sections]\" further down.\n \n-# Run on the test network instead of the real bitcoin network.\n+# Run on the testnet network\n #testnet=0\n \n+# Run on a signet network\n+#signet=0\n+\n # Run a regression test network\n #regtest=0\n \n@@ -57,7 +60,7 @@\n # Listening mode, enabled by default except when 'connect' is being used\n #listen=1\n \n-# Port on which to listen for connections (default: 8333, testnet: 18333, regtest: 18444)\n+# Port on which to listen for connections (default: 8333, testnet: 18333, signet: 38333, regtest: 18444)\n #port=\n \n # Maximum number of inbound+outbound connections.\n@@ -155,7 +158,7 @@\n #minimizetotray=1\n \n # [Sections]\n-# Most options apply to mainnet, testnet and regtest.\n+# Most options apply to mainnet, testnet, signet and regtest.\n # If you want to confine an option to just one network, you should add it in the\n # relevant section below.\n # EXCEPTIONS: The options addnode, connect, port, bind, rpcport, rpcbind and wallet\n@@ -167,5 +170,8 @@\n # Options only for testnet\n [test]\n \n+# Options only for signet\n+[signet]\n+\n # Options only for regtest\n [regtest]"
      },
      {
        "sha": "9903c2e9b3adfb0423397b689915abdccd6a3c3a",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -182,7 +182,6 @@ BITCOIN_CORE_H = \\\n   node/ui_interface.h \\\n   node/utxo_snapshot.h \\\n   noui.h \\\n-  optional.h \\\n   outputtype.h \\\n   policy/feerate.h \\\n   policy/fees.h \\\n@@ -240,7 +239,6 @@ BITCOIN_CORE_H = \\\n   util/golombrice.h \\\n   util/hasher.h \\\n   util/macros.h \\\n-  util/memory.h \\\n   util/message.h \\\n   util/moneystr.h \\\n   util/rbf.h \\\n@@ -253,6 +251,7 @@ BITCOIN_CORE_H = \\\n   util/system.h \\\n   util/threadnames.h \\\n   util/time.h \\\n+  util/tokenpipe.h \\\n   util/trace.h \\\n   util/translation.h \\\n   util/ui_change_type.h \\\n@@ -553,7 +552,6 @@ libbitcoin_util_a_SOURCES = \\\n   support/lockedpool.cpp \\\n   chainparamsbase.cpp \\\n   clientversion.cpp \\\n-  compat/glibc_sanity.cpp \\\n   compat/glibcxx_sanity.cpp \\\n   compat/strnlen.cpp \\\n   fs.cpp \\\n@@ -584,6 +582,7 @@ libbitcoin_util_a_SOURCES = \\\n   util/strencodings.cpp \\\n   util/string.cpp \\\n   util/time.cpp \\\n+  util/tokenpipe.cpp \\\n   $(BITCOIN_CORE_H)\n \n if USE_LIBEVENT"
      },
      {
        "sha": "399a8430efdfee3e507f3e91fc31f1db49fc03cb",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -378,6 +378,20 @@ bitcoin_qt_clean: FORCE\n \n bitcoin_qt : qt/bitcoin-qt$(EXEEXT)\n \n+APK_LIB_DIR = qt/android/libs/$(ANDROID_ARCH)\n+QT_BASE_PATH = $(shell find ../depends/sources/ -maxdepth 1 -type f -regex \".*qtbase.*\\.tar.xz\")\n+QT_BASE_TLD = $(shell tar tf $(QT_BASE_PATH) --exclude='*/*')\n+\n+bitcoin_qt_apk: FORCE\n+\tmkdir -p $(APK_LIB_DIR)\n+\tcp $(dir $(CC))../sysroot/usr/lib/$(host_alias)/libc++_shared.so $(APK_LIB_DIR)\n+\ttar xf $(QT_BASE_PATH) -C qt/android/src/ $(QT_BASE_TLD)src/android/jar/src --strip-components=5\n+\ttar xf $(QT_BASE_PATH) -C qt/android/src/ $(QT_BASE_TLD)src/android/java/src --strip-components=5\n+\ttar xf $(QT_BASE_PATH) -C qt/android/res/ $(QT_BASE_TLD)src/android/java/res --strip-components=5\n+\tcp qt/bitcoin-qt $(APK_LIB_DIR)/libbitcoin-qt.so\n+\tcd qt/android && gradle wrapper --gradle-version=6.6.1\n+\tcd qt/android && ./gradlew build\n+\n ui_%.h: %.ui\n \t@test -f $(UIC)\n \t@$(MKDIR_P) $(@D)"
      },
      {
        "sha": "e00f17a83fc53d6df2db307e3b7a0a2e6a33a98f",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -252,6 +252,7 @@ test_fuzz_fuzz_SOURCES = \\\n  test/fuzz/net.cpp \\\n  test/fuzz/net_permissions.cpp \\\n  test/fuzz/netaddress.cpp \\\n+ test/fuzz/netbase_dns_lookup.cpp \\\n  test/fuzz/node_eviction.cpp \\\n  test/fuzz/p2p_transport_deserializer.cpp \\\n  test/fuzz/parse_hd_keypath.cpp \\\n@@ -296,7 +297,10 @@ test_fuzz_fuzz_SOURCES = \\\n  test/fuzz/transaction.cpp \\\n  test/fuzz/tx_in.cpp \\\n  test/fuzz/tx_out.cpp \\\n- test/fuzz/txrequest.cpp\n+ test/fuzz/tx_pool.cpp \\\n+ test/fuzz/txrequest.cpp \\\n+ test/fuzz/validation_load_mempool.cpp \\\n+ test/fuzz/versionbits.cpp\n endif # ENABLE_FUZZ_BINARY\n \n nodist_test_test_bitcoin_SOURCES = $(GENERATED_TEST_FILES)"
      },
      {
        "sha": "288b14e02389d870cd9c34544dca45750a83561b",
        "filename": "src/bech32.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 22,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/bech32.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/bech32.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bech32.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1,4 +1,4 @@\n-// Copyright (c) 2017 Pieter Wuille\n+// Copyright (c) 2017, 2021 Pieter Wuille\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -7,15 +7,18 @@\n \n #include <assert.h>\n \n+namespace bech32\n+{\n+\n namespace\n {\n \n typedef std::vector<uint8_t> data;\n \n-/** The Bech32 character set for encoding. */\n+/** The Bech32 and Bech32m character set for encoding. */\n const char* CHARSET = \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\";\n \n-/** The Bech32 character set for decoding. */\n+/** The Bech32 and Bech32m character set for decoding. */\n const int8_t CHARSET_REV[128] = {\n     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n@@ -27,6 +30,12 @@ const int8_t CHARSET_REV[128] = {\n      1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1\n };\n \n+/* Determine the final constant to use for the specified encoding. */\n+uint32_t EncodingConstant(Encoding encoding) {\n+    assert(encoding == Encoding::BECH32 || encoding == Encoding::BECH32M);\n+    return encoding == Encoding::BECH32 ? 1 : 0x2bc830a3;\n+}\n+\n /** This function will compute what 6 5-bit values to XOR into the last 6 input values, in order to\n  *  make the checksum 0. These 6 values are packed together in a single 30-bit integer. The higher\n  *  bits correspond to earlier values. */\n@@ -111,21 +120,24 @@ data ExpandHRP(const std::string& hrp)\n }\n \n /** Verify a checksum. */\n-bool VerifyChecksum(const std::string& hrp, const data& values)\n+Encoding VerifyChecksum(const std::string& hrp, const data& values)\n {\n     // PolyMod computes what value to xor into the final values to make the checksum 0. However,\n     // if we required that the checksum was 0, it would be the case that appending a 0 to a valid\n     // list of values would result in a new valid list. For that reason, Bech32 requires the\n-    // resulting checksum to be 1 instead.\n-    return PolyMod(Cat(ExpandHRP(hrp), values)) == 1;\n+    // resulting checksum to be 1 instead. In Bech32m, this constant was amended.\n+    const uint32_t check = PolyMod(Cat(ExpandHRP(hrp), values));\n+    if (check == EncodingConstant(Encoding::BECH32)) return Encoding::BECH32;\n+    if (check == EncodingConstant(Encoding::BECH32M)) return Encoding::BECH32M;\n+    return Encoding::INVALID;\n }\n \n /** Create a checksum. */\n-data CreateChecksum(const std::string& hrp, const data& values)\n+data CreateChecksum(Encoding encoding, const std::string& hrp, const data& values)\n {\n     data enc = Cat(ExpandHRP(hrp), values);\n     enc.resize(enc.size() + 6); // Append 6 zeroes\n-    uint32_t mod = PolyMod(enc) ^ 1; // Determine what to XOR into those 6 zeroes.\n+    uint32_t mod = PolyMod(enc) ^ EncodingConstant(encoding); // Determine what to XOR into those 6 zeroes.\n     data ret(6);\n     for (size_t i = 0; i < 6; ++i) {\n         // Convert the 5-bit groups in mod to checksum values.\n@@ -136,16 +148,13 @@ data CreateChecksum(const std::string& hrp, const data& values)\n \n } // namespace\n \n-namespace bech32\n-{\n-\n-/** Encode a Bech32 string. */\n-std::string Encode(const std::string& hrp, const data& values) {\n-    // First ensure that the HRP is all lowercase. BIP-173 requires an encoder\n-    // to return a lowercase Bech32 string, but if given an uppercase HRP, the\n+/** Encode a Bech32 or Bech32m string. */\n+std::string Encode(Encoding encoding, const std::string& hrp, const data& values) {\n+    // First ensure that the HRP is all lowercase. BIP-173 and BIP350 require an encoder\n+    // to return a lowercase Bech32/Bech32m string, but if given an uppercase HRP, the\n     // result will always be invalid.\n     for (const char& c : hrp) assert(c < 'A' || c > 'Z');\n-    data checksum = CreateChecksum(hrp, values);\n+    data checksum = CreateChecksum(encoding, hrp, values);\n     data combined = Cat(values, checksum);\n     std::string ret = hrp + '1';\n     ret.reserve(ret.size() + combined.size());\n@@ -155,8 +164,8 @@ std::string Encode(const std::string& hrp, const data& values) {\n     return ret;\n }\n \n-/** Decode a Bech32 string. */\n-std::pair<std::string, data> Decode(const std::string& str) {\n+/** Decode a Bech32 or Bech32m string. */\n+DecodeResult Decode(const std::string& str) {\n     bool lower = false, upper = false;\n     for (size_t i = 0; i < str.size(); ++i) {\n         unsigned char c = str[i];\n@@ -183,10 +192,9 @@ std::pair<std::string, data> Decode(const std::string& str) {\n     for (size_t i = 0; i < pos; ++i) {\n         hrp += LowerCase(str[i]);\n     }\n-    if (!VerifyChecksum(hrp, values)) {\n-        return {};\n-    }\n-    return {hrp, data(values.begin(), values.end() - 6)};\n+    Encoding result = VerifyChecksum(hrp, values);\n+    if (result == Encoding::INVALID) return {};\n+    return {result, std::move(hrp), data(values.begin(), values.end() - 6)};\n }\n \n } // namespace bech32"
      },
      {
        "sha": "e9450ccc2b35dc3650905a50418756a3a08af58e",
        "filename": "src/bech32.h",
        "status": "modified",
        "additions": 29,
        "deletions": 10,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/bech32.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/bech32.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bech32.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1,13 +1,14 @@\n-// Copyright (c) 2017 Pieter Wuille\n+// Copyright (c) 2017, 2021 Pieter Wuille\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-// Bech32 is a string encoding format used in newer address types.\n-// The output consists of a human-readable part (alphanumeric), a\n-// separator character (1), and a base32 data section, the last\n-// 6 characters of which are a checksum.\n+// Bech32 and Bech32m are string encoding formats used in newer\n+// address types. The outputs consist of a human-readable part\n+// (alphanumeric), a separator character (1), and a base32 data\n+// section, the last 6 characters of which are a checksum. The\n+// module is namespaced under bech32 for historical reasons.\n //\n-// For more information, see BIP 173.\n+// For more information, see BIP 173 and BIP 350.\n \n #ifndef BITCOIN_BECH32_H\n #define BITCOIN_BECH32_H\n@@ -19,11 +20,29 @@\n namespace bech32\n {\n \n-/** Encode a Bech32 string. If hrp contains uppercase characters, this will cause an assertion error. */\n-std::string Encode(const std::string& hrp, const std::vector<uint8_t>& values);\n+enum class Encoding {\n+    INVALID, //!< Failed decoding\n \n-/** Decode a Bech32 string. Returns (hrp, data). Empty hrp means failure. */\n-std::pair<std::string, std::vector<uint8_t>> Decode(const std::string& str);\n+    BECH32,  //!< Bech32 encoding as defined in BIP173\n+    BECH32M, //!< Bech32m encoding as defined in BIP350\n+};\n+\n+/** Encode a Bech32 or Bech32m string. If hrp contains uppercase characters, this will cause an\n+ *  assertion error. Encoding must be one of BECH32 or BECH32M. */\n+std::string Encode(Encoding encoding, const std::string& hrp, const std::vector<uint8_t>& values);\n+\n+struct DecodeResult\n+{\n+    Encoding encoding;         //!< What encoding was detected in the result; Encoding::INVALID if failed.\n+    std::string hrp;           //!< The human readable part\n+    std::vector<uint8_t> data; //!< The payload (excluding checksum)\n+\n+    DecodeResult() : encoding(Encoding::INVALID) {}\n+    DecodeResult(Encoding enc, std::string&& h, std::vector<uint8_t>&& d) : encoding(enc), hrp(std::move(h)), data(std::move(d)) {}\n+};\n+\n+/** Decode a Bech32 or Bech32m string. */\n+DecodeResult Decode(const std::string& str);\n \n } // namespace bech32\n "
      },
      {
        "sha": "8e10862a37c9cce350733c39ec498d6913acb74b",
        "filename": "src/bench/bech32.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/bench/bech32.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/bench/bech32.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bech32.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -19,7 +19,7 @@ static void Bech32Encode(benchmark::Bench& bench)\n     tmp.reserve(1 + 32 * 8 / 5);\n     ConvertBits<8, 5, true>([&](unsigned char c) { tmp.push_back(c); }, v.begin(), v.end());\n     bench.batch(v.size()).unit(\"byte\").run([&] {\n-        bech32::Encode(\"bc\", tmp);\n+        bech32::Encode(bech32::Encoding::BECH32, \"bc\", tmp);\n     });\n }\n "
      },
      {
        "sha": "80acdec044a664b5d823a924fc5b9ec89d7b1d2d",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -17,7 +17,7 @@ static void addCoin(const CAmount& nValue, const CWallet& wallet, std::vector<st\n     tx.nLockTime = nextLockTime++; // so all transactions get different hashes\n     tx.vout.resize(1);\n     tx.vout[0].nValue = nValue;\n-    wtxs.push_back(MakeUnique<CWalletTx>(&wallet, MakeTransactionRef(std::move(tx))));\n+    wtxs.push_back(std::make_unique<CWalletTx>(&wallet, MakeTransactionRef(std::move(tx))));\n }\n \n // Simple benchmark for wallet coin selection. Note that it maybe be necessary\n@@ -49,7 +49,10 @@ static void CoinSelection(benchmark::Bench& bench)\n     }\n \n     const CoinEligibilityFilter filter_standard(1, 6, 0);\n-    const CoinSelectionParams coin_selection_params(true, 34, 148, CFeeRate(0), 0, false);\n+    const CoinSelectionParams coin_selection_params(/* use_bnb= */ true, /* change_output_size= */ 34,\n+                                                    /* change_spend_size= */ 148, /* effective_feerate= */ CFeeRate(0),\n+                                                    /* long_term_feerate= */ CFeeRate(0), /* discard_feerate= */ CFeeRate(0),\n+                                                    /* tx_no_inputs_size= */ 0, /* avoid_partial= */ false);\n     bench.run([&] {\n         std::set<CInputCoin> setCoinsRet;\n         CAmount nValueRet;\n@@ -73,7 +76,7 @@ static void add_coin(const CAmount& nValue, int nInput, std::vector<OutputGroup>\n     CMutableTransaction tx;\n     tx.vout.resize(nInput + 1);\n     tx.vout[nInput].nValue = nValue;\n-    std::unique_ptr<CWalletTx> wtx = MakeUnique<CWalletTx>(&testWallet, MakeTransactionRef(std::move(tx)));\n+    std::unique_ptr<CWalletTx> wtx = std::make_unique<CWalletTx>(&testWallet, MakeTransactionRef(std::move(tx)));\n     set.emplace_back();\n     set.back().Insert(COutput(wtx.get(), nInput, 0, true, true, true).GetInputCoin(), 0, true, 0, 0, false);\n     wtxn.emplace_back(std::move(wtx));"
      },
      {
        "sha": "d7cc167885d886ffb22bd685abfcc0c631036627",
        "filename": "src/bench/wallet_balance.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/bench/wallet_balance.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/bench/wallet_balance.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/wallet_balance.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -5,13 +5,14 @@\n #include <bench/bench.h>\n #include <interfaces/chain.h>\n #include <node/context.h>\n-#include <optional.h>\n #include <test/util/mining.h>\n #include <test/util/setup_common.h>\n #include <test/util/wallet.h>\n #include <validationinterface.h>\n #include <wallet/wallet.h>\n \n+#include <optional>\n+\n static void WalletBalance(benchmark::Bench& bench, const bool set_dirty, const bool add_watchonly, const bool add_mine)\n {\n     const auto test_setup = MakeNoLogFileContext<const TestingSetup>();\n@@ -26,7 +27,7 @@ static void WalletBalance(benchmark::Bench& bench, const bool set_dirty, const b\n     }\n     auto handler = test_setup->m_node.chain->handleNotifications({&wallet, [](CWallet*) {}});\n \n-    const Optional<std::string> address_mine{add_mine ? Optional<std::string>{getnewaddress(wallet)} : nullopt};\n+    const std::optional<std::string> address_mine{add_mine ? std::optional<std::string>{getnewaddress(wallet)} : std::nullopt};\n     if (add_watchonly) importaddress(wallet, ADDRESS_WATCHONLY);\n \n     for (int i = 0; i < 100; ++i) {"
      },
      {
        "sha": "4f3d7a4ffe588eca267330d7b78e63b0c4508760",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 7,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -9,7 +9,6 @@\n \n #include <chainparamsbase.h>\n #include <clientversion.h>\n-#include <optional.h>\n #include <rpc/client.h>\n #include <rpc/mining.h>\n #include <rpc/protocol.h>\n@@ -24,6 +23,7 @@\n #include <cmath>\n #include <functional>\n #include <memory>\n+#include <optional>\n #include <stdio.h>\n #include <string>\n #include <tuple>\n@@ -611,16 +611,16 @@ class DefaultRequestHandler: public BaseRequestHandler {\n     }\n };\n \n-static UniValue CallRPC(BaseRequestHandler* rh, const std::string& strMethod, const std::vector<std::string>& args, const Optional<std::string>& rpcwallet = {})\n+static UniValue CallRPC(BaseRequestHandler* rh, const std::string& strMethod, const std::vector<std::string>& args, const std::optional<std::string>& rpcwallet = {})\n {\n     std::string host;\n     // In preference order, we choose the following for the port:\n     //     1. -rpcport\n     //     2. port in -rpcconnect (ie following : in ipv4 or ]: in ipv6)\n     //     3. default port for chain\n-    int port = BaseParams().RPCPort();\n+    uint16_t port{BaseParams().RPCPort()};\n     SplitHostPort(gArgs.GetArg(\"-rpcconnect\", DEFAULT_RPCCONNECT), port, host);\n-    port = gArgs.GetArg(\"-rpcport\", port);\n+    port = static_cast<uint16_t>(gArgs.GetArg(\"-rpcport\", port));\n \n     // Obtain event base\n     raii_event_base base = obtain_event_base();\n@@ -708,6 +708,8 @@ static UniValue CallRPC(BaseRequestHandler* rh, const std::string& strMethod, co\n         } else {\n             throw std::runtime_error(\"Authorization failed: Incorrect rpcuser or rpcpassword\");\n         }\n+    } else if (response.status == HTTP_SERVICE_UNAVAILABLE) {\n+        throw std::runtime_error(strprintf(\"Server response: %s\", response.body));\n     } else if (response.status >= 400 && response.status != HTTP_BAD_REQUEST && response.status != HTTP_NOT_FOUND && response.status != HTTP_INTERNAL_SERVER_ERROR)\n         throw std::runtime_error(strprintf(\"server returned HTTP error %d\", response.status));\n     else if (response.body.empty())\n@@ -733,7 +735,7 @@ static UniValue CallRPC(BaseRequestHandler* rh, const std::string& strMethod, co\n  * @returns the RPC response as a UniValue object.\n  * @throws a CConnectionFailed std::runtime_error if connection failed or RPC server still in warmup.\n  */\n-static UniValue ConnectAndCallRPC(BaseRequestHandler* rh, const std::string& strMethod, const std::vector<std::string>& args, const Optional<std::string>& rpcwallet = {})\n+static UniValue ConnectAndCallRPC(BaseRequestHandler* rh, const std::string& strMethod, const std::vector<std::string>& args, const std::optional<std::string>& rpcwallet = {})\n {\n     UniValue response(UniValue::VOBJ);\n     // Execute and handle connection failures with -rpcwait.\n@@ -817,7 +819,7 @@ static void GetWalletBalances(UniValue& result)\n  */\n static UniValue GetNewAddress()\n {\n-    Optional<std::string> wallet_name{};\n+    std::optional<std::string> wallet_name{};\n     if (gArgs.IsArgSet(\"-rpcwallet\")) wallet_name = gArgs.GetArg(\"-rpcwallet\", \"\");\n     DefaultRequestHandler rh;\n     return ConnectAndCallRPC(&rh, \"getnewaddress\", /* args=*/{}, wallet_name);\n@@ -922,7 +924,7 @@ static int CommandLineRPC(int argc, char *argv[])\n         }\n         if (nRet == 0) {\n             // Perform RPC call\n-            Optional<std::string> wallet_name{};\n+            std::optional<std::string> wallet_name{};\n             if (gArgs.IsArgSet(\"-rpcwallet\")) wallet_name = gArgs.GetArg(\"-rpcwallet\", \"\");\n             const UniValue reply = ConnectAndCallRPC(rh.get(), method, args, wallet_name);\n "
      },
      {
        "sha": "1b4ca3e9a83bdc2ef44181d967f4bb593541bf7f",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 112,
        "deletions": 12,
        "changes": 124,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -20,14 +20,89 @@\n #include <util/strencodings.h>\n #include <util/system.h>\n #include <util/threadnames.h>\n+#include <util/tokenpipe.h>\n #include <util/translation.h>\n #include <util/url.h>\n \n #include <functional>\n+#include <optional>\n \n const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n UrlDecodeFn* const URL_DECODE = urlDecode;\n \n+#if HAVE_DECL_FORK\n+\n+/** Custom implementation of daemon(). This implements the same order of operations as glibc.\n+ * Opens a pipe to the child process to be able to wait for an event to occur.\n+ *\n+ * @returns 0 if successful, and in child process.\n+ *          >0 if successful, and in parent process.\n+ *          -1 in case of error (in parent process).\n+ *\n+ *          In case of success, endpoint will be one end of a pipe from the child to parent process,\n+ *          which can be used with TokenWrite (in the child) or TokenRead (in the parent).\n+ */\n+int fork_daemon(bool nochdir, bool noclose, TokenPipeEnd& endpoint)\n+{\n+    // communication pipe with child process\n+    std::optional<TokenPipe> umbilical = TokenPipe::Make();\n+    if (!umbilical) {\n+        return -1; // pipe or pipe2 failed.\n+    }\n+\n+    int pid = fork();\n+    if (pid < 0) {\n+        return -1; // fork failed.\n+    }\n+    if (pid != 0) {\n+        // Parent process gets read end, closes write end.\n+        endpoint = umbilical->TakeReadEnd();\n+        umbilical->TakeWriteEnd().Close();\n+\n+        int status = endpoint.TokenRead();\n+        if (status != 0) { // Something went wrong while setting up child process.\n+            endpoint.Close();\n+            return -1;\n+        }\n+\n+        return pid;\n+    }\n+    // Child process gets write end, closes read end.\n+    endpoint = umbilical->TakeWriteEnd();\n+    umbilical->TakeReadEnd().Close();\n+\n+#if HAVE_DECL_SETSID\n+    if (setsid() < 0) {\n+        exit(1); // setsid failed.\n+    }\n+#endif\n+\n+    if (!nochdir) {\n+        if (chdir(\"/\") != 0) {\n+            exit(1); // chdir failed.\n+        }\n+    }\n+    if (!noclose) {\n+        // Open /dev/null, and clone it into STDIN, STDOUT and STDERR to detach\n+        // from terminal.\n+        int fd = open(\"/dev/null\", O_RDWR);\n+        if (fd >= 0) {\n+            bool err = dup2(fd, STDIN_FILENO) < 0 || dup2(fd, STDOUT_FILENO) < 0 || dup2(fd, STDERR_FILENO) < 0;\n+            // Don't close if fd<=2 to try to handle the case where the program was invoked without any file descriptors open.\n+            if (fd > 2) close(fd);\n+            if (err) {\n+                exit(1); // dup2 failed.\n+            }\n+        } else {\n+            exit(1); // open /dev/null failed.\n+        }\n+    }\n+    endpoint.TokenWrite(0); // Success\n+    return 0;\n+}\n+\n+#endif\n+\n static bool AppInit(int argc, char* argv[])\n {\n     NodeContext node;\n@@ -59,6 +134,14 @@ static bool AppInit(int argc, char* argv[])\n         return true;\n     }\n \n+#if HAVE_DECL_FORK\n+    // Communication with parent after daemonizing. This is used for signalling in the following ways:\n+    // - a boolean token is sent when the initialization process (all the Init* functions) have finished to indicate\n+    // that the parent process can quit, and whether it was successful/unsuccessful.\n+    // - an unexpected shutdown of the child process creates an unexpected end of stream at the parent\n+    // end, which is interpreted as failure to start.\n+    TokenPipeEnd daemon_ep;\n+#endif\n     util::Ref context{node};\n     try\n     {\n@@ -105,24 +188,34 @@ static bool AppInit(int argc, char* argv[])\n             // InitError will have been called with detailed error, which ends up on console\n             return false;\n         }\n-        if (args.GetBoolArg(\"-daemon\", false)) {\n-#if HAVE_DECL_DAEMON\n-#if defined(MAC_OSX)\n-#pragma GCC diagnostic push\n-#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n-#endif\n+        if (args.GetBoolArg(\"-daemon\", DEFAULT_DAEMON) || args.GetBoolArg(\"-daemonwait\", DEFAULT_DAEMONWAIT)) {\n+#if HAVE_DECL_FORK\n             tfm::format(std::cout, PACKAGE_NAME \" starting\\n\");\n \n             // Daemonize\n-            if (daemon(1, 0)) { // don't chdir (1), do close FDs (0)\n-                return InitError(Untranslated(strprintf(\"daemon() failed: %s\\n\", strerror(errno))));\n+            switch (fork_daemon(1, 0, daemon_ep)) { // don't chdir (1), do close FDs (0)\n+            case 0: // Child: continue.\n+                // If -daemonwait is not enabled, immediately send a success token the parent.\n+                if (!args.GetBoolArg(\"-daemonwait\", DEFAULT_DAEMONWAIT)) {\n+                    daemon_ep.TokenWrite(1);\n+                    daemon_ep.Close();\n+                }\n+                break;\n+            case -1: // Error happened.\n+                return InitError(Untranslated(strprintf(\"fork_daemon() failed: %s\\n\", strerror(errno))));\n+            default: { // Parent: wait and exit.\n+                int token = daemon_ep.TokenRead();\n+                if (token) { // Success\n+                    exit(EXIT_SUCCESS);\n+                } else { // fRet = false or token read error (premature exit).\n+                    tfm::format(std::cerr, \"Error during initializaton - check debug.log for details\\n\");\n+                    exit(EXIT_FAILURE);\n+                }\n+            }\n             }\n-#if defined(MAC_OSX)\n-#pragma GCC diagnostic pop\n-#endif\n #else\n             return InitError(Untranslated(\"-daemon is not supported on this operating system\\n\"));\n-#endif // HAVE_DECL_DAEMON\n+#endif // HAVE_DECL_FORK\n         }\n         // Lock data directory after daemonization\n         if (!AppInitLockDataDirectory())\n@@ -138,6 +231,13 @@ static bool AppInit(int argc, char* argv[])\n         PrintExceptionContinue(nullptr, \"AppInit()\");\n     }\n \n+#if HAVE_DECL_FORK\n+    if (daemon_ep.IsOpen()) {\n+        // Signal initialization status to parent, then close pipe.\n+        daemon_ep.TokenWrite(fRet);\n+        daemon_ep.Close();\n+    }\n+#endif\n     if (fRet) {\n         WaitForShutdown();\n     }"
      },
      {
        "sha": "013f075be6571a47ec0800e00907d80079196768",
        "filename": "src/chainparams.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/chainparams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/chainparams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -84,7 +84,7 @@ class CChainParams\n \n     const Consensus::Params& GetConsensus() const { return consensus; }\n     const CMessageHeader::MessageStartChars& MessageStart() const { return pchMessageStart; }\n-    int GetDefaultPort() const { return nDefaultPort; }\n+    uint16_t GetDefaultPort() const { return nDefaultPort; }\n \n     const CBlock& GenesisBlock() const { return genesis; }\n     /** Default value for -checkmempool and -checkblockindex argument */\n@@ -121,7 +121,7 @@ class CChainParams\n \n     Consensus::Params consensus;\n     CMessageHeader::MessageStartChars pchMessageStart;\n-    int nDefaultPort;\n+    uint16_t nDefaultPort;\n     uint64_t nPruneAfterHeight;\n     uint64_t m_assumed_blockchain_size;\n     uint64_t m_assumed_chain_state_size;"
      },
      {
        "sha": "16311764778cd7d8c4b13851d4dc67e58d3b001d",
        "filename": "src/chainparamsbase.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/chainparamsbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/chainparamsbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -7,7 +7,6 @@\n \n #include <tinyformat.h>\n #include <util/system.h>\n-#include <util/memory.h>\n \n #include <assert.h>\n \n@@ -44,13 +43,13 @@ const CBaseChainParams& BaseParams()\n std::unique_ptr<CBaseChainParams> CreateBaseChainParams(const std::string& chain)\n {\n     if (chain == CBaseChainParams::MAIN) {\n-        return MakeUnique<CBaseChainParams>(\"\", 8332, 8334);\n+        return std::make_unique<CBaseChainParams>(\"\", 8332, 8334);\n     } else if (chain == CBaseChainParams::TESTNET) {\n-        return MakeUnique<CBaseChainParams>(\"testnet3\", 18332, 18334);\n+        return std::make_unique<CBaseChainParams>(\"testnet3\", 18332, 18334);\n     } else if (chain == CBaseChainParams::SIGNET) {\n-        return MakeUnique<CBaseChainParams>(\"signet\", 38332, 38334);\n+        return std::make_unique<CBaseChainParams>(\"signet\", 38332, 38334);\n     } else if (chain == CBaseChainParams::REGTEST) {\n-        return MakeUnique<CBaseChainParams>(\"regtest\", 18443, 18445);\n+        return std::make_unique<CBaseChainParams>(\"regtest\", 18443, 18445);\n     }\n     throw std::runtime_error(strprintf(\"%s: Unknown chain %s.\", __func__, chain));\n }"
      },
      {
        "sha": "5a6f73652b4e7798c3442a9530aebabf05145e67",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -75,6 +75,9 @@ class Coin\n         ::Unserialize(s, Using<TxOutCompression>(out));\n     }\n \n+    /** Either this coin never existed (see e.g. coinEmpty in coins.cpp), or it\n+      * did exist and has been spent.\n+      */\n     bool IsSpent() const {\n         return out.IsNull();\n     }"
      },
      {
        "sha": "ff581d4a9e1866d980bdb6f8f87e6f6c3ec71f65",
        "filename": "src/compat/glibc_compat.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/compat/glibc_compat.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/compat/glibc_compat.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibc_compat.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -9,13 +9,6 @@\n #include <cstddef>\n #include <cstdint>\n \n-// Prior to GLIBC_2.14, memcpy was aliased to memmove.\n-extern \"C\" void* memmove(void* a, const void* b, size_t c);\n-extern \"C\" void* memcpy(void* a, const void* b, size_t c)\n-{\n-    return memmove(a, b, c);\n-}\n-\n #if defined(__i386__) || defined(__arm__)\n \n extern \"C\" int64_t __udivmoddi4(uint64_t u, uint64_t v, uint64_t* rp);"
      },
      {
        "sha": "06d0dd6fbabe1cfe9838f8accaa0691276bf38b7",
        "filename": "src/compat/glibc_sanity.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 45,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/src/compat/glibc_sanity.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/src/compat/glibc_sanity.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibc_sanity.cpp?ref=1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05",
        "patch": "@@ -1,45 +0,0 @@\n-// Copyright (c) 2009-2020 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#if defined(HAVE_CONFIG_H)\n-#include <config/bitcoin-config.h>\n-#endif\n-\n-#include <cstddef>\n-\n-extern \"C\" void* memcpy(void* a, const void* b, size_t c);\n-void* memcpy_int(void* a, const void* b, size_t c)\n-{\n-    return memcpy(a, b, c);\n-}\n-\n-namespace\n-{\n-// trigger: Use the memcpy_int wrapper which calls our internal memcpy.\n-//   A direct call to memcpy may be optimized away by the compiler.\n-// test: Fill an array with a sequence of integers. memcpy to a new empty array.\n-//   Verify that the arrays are equal. Use an odd size to decrease the odds of\n-//   the call being optimized away.\n-template <unsigned int T>\n-bool sanity_test_memcpy()\n-{\n-    unsigned int memcpy_test[T];\n-    unsigned int memcpy_verify[T] = {};\n-    for (unsigned int i = 0; i != T; ++i)\n-        memcpy_test[i] = i;\n-\n-    memcpy_int(memcpy_verify, memcpy_test, sizeof(memcpy_test));\n-\n-    for (unsigned int i = 0; i != T; ++i) {\n-        if (memcpy_verify[i] != i)\n-            return false;\n-    }\n-    return true;\n-}\n-} // namespace\n-\n-bool glibc_sanity_test()\n-{\n-    return sanity_test_memcpy<1025>();\n-}"
      },
      {
        "sha": "8efa41610262ed7a72d738a413984b3aac550528",
        "filename": "src/compat/sanity.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/compat/sanity.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/compat/sanity.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/sanity.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -5,7 +5,6 @@\n #ifndef BITCOIN_COMPAT_SANITY_H\n #define BITCOIN_COMPAT_SANITY_H\n \n-bool glibc_sanity_test();\n bool glibcxx_sanity_test();\n \n #endif // BITCOIN_COMPAT_SANITY_H"
      },
      {
        "sha": "867ddb090e7c4c14bbc06a672ee7bfeb7defc55b",
        "filename": "src/httprpc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/httprpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/httprpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -301,7 +301,7 @@ bool StartHTTPRPC(const util::Ref& context)\n     }\n     struct event_base* eventBase = EventBase();\n     assert(eventBase);\n-    httpRPCTimerInterface = MakeUnique<HTTPRPCTimerInterface>(eventBase);\n+    httpRPCTimerInterface = std::make_unique<HTTPRPCTimerInterface>(eventBase);\n     RPCSetTimerInterface(httpRPCTimerInterface.get());\n     return true;\n }"
      },
      {
        "sha": "12395f5b24025b98463e961d7ce12207cfe9796c",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -262,7 +262,7 @@ static void http_request_cb(struct evhttp_request* req, void* arg)\n             item.release(); /* if true, queue took ownership */\n         else {\n             LogPrintf(\"WARNING: request rejected because http work queue depth exceeded, it can be increased with the -rpcworkqueue= setting\\n\");\n-            item->req->WriteReply(HTTP_INTERNAL_SERVER_ERROR, \"Work queue depth exceeded\");\n+            item->req->WriteReply(HTTP_SERVICE_UNAVAILABLE, \"Work queue depth exceeded\");\n         }\n     } else {\n         hreq->WriteReply(HTTP_NOT_FOUND);\n@@ -290,8 +290,8 @@ static bool ThreadHTTP(struct event_base* base)\n /** Bind HTTP server to specified addresses */\n static bool HTTPBindAddresses(struct evhttp* http)\n {\n-    int http_port = gArgs.GetArg(\"-rpcport\", BaseParams().RPCPort());\n-    std::vector<std::pair<std::string, uint16_t> > endpoints;\n+    uint16_t http_port{static_cast<uint16_t>(gArgs.GetArg(\"-rpcport\", BaseParams().RPCPort()))};\n+    std::vector<std::pair<std::string, uint16_t>> endpoints;\n \n     // Determine what addresses to bind to\n     if (!(gArgs.IsArgSet(\"-rpcallowip\") && gArgs.IsArgSet(\"-rpcbind\"))) { // Default to loopback if not allowing external IPs\n@@ -305,7 +305,7 @@ static bool HTTPBindAddresses(struct evhttp* http)\n         }\n     } else if (gArgs.IsArgSet(\"-rpcbind\")) { // Specific bind address\n         for (const std::string& strRPCBind : gArgs.GetArgs(\"-rpcbind\")) {\n-            int port = http_port;\n+            uint16_t port{http_port};\n             std::string host;\n             SplitHostPort(strRPCBind, port, host);\n             endpoints.push_back(std::make_pair(host, port));"
      },
      {
        "sha": "d16c620d88eed2635d455927241d3f2ab3cf707a",
        "filename": "src/i2p.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/i2p.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/i2p.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/i2p.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -153,7 +153,7 @@ bool Session::Accept(Connection& conn)\n             }\n \n             const std::string& peer_dest =\n-                conn.sock.RecvUntilTerminator('\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+                conn.sock.RecvUntilTerminator('\\n', MAX_WAIT_FOR_IO, *m_interrupt, MAX_MSG_SIZE);\n \n             conn.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n \n@@ -252,7 +252,7 @@ Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n     // signaled.\n     static constexpr auto recv_timeout = 3min;\n \n-    reply.full = sock.RecvUntilTerminator('\\n', recv_timeout, *m_interrupt);\n+    reply.full = sock.RecvUntilTerminator('\\n', recv_timeout, *m_interrupt, MAX_MSG_SIZE);\n \n     for (const auto& kv : spanparsing::Split(reply.full, ' ')) {\n         const auto& pos = std::find(kv.begin(), kv.end(), '=');"
      },
      {
        "sha": "1ebe7d03298330d3f12fd265222b017108506d5b",
        "filename": "src/i2p.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/i2p.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/i2p.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/i2p.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -40,6 +40,14 @@ struct Connection {\n \n namespace sam {\n \n+/**\n+ * The maximum size of an incoming message from the I2P SAM proxy (in bytes).\n+ * Used to avoid a runaway proxy from sending us an \"unlimited\" amount of data without a terminator.\n+ * The longest known message is ~1400 bytes, so this is high enough not to be triggered during\n+ * normal operation, yet low enough to avoid a malicious proxy from filling our memory.\n+ */\n+static constexpr size_t MAX_MSG_SIZE{65536};\n+\n /**\n  * I2P SAM session.\n  */"
      },
      {
        "sha": "32271fb7ab7cb5330808eb132dac0a6257e9d682",
        "filename": "src/index/blockfilterindex.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/index/blockfilterindex.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/index/blockfilterindex.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/blockfilterindex.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -102,8 +102,8 @@ BlockFilterIndex::BlockFilterIndex(BlockFilterType filter_type,\n     fs::create_directories(path);\n \n     m_name = filter_name + \" block filter index\";\n-    m_db = MakeUnique<BaseIndex::DB>(path / \"db\", n_cache_size, f_memory, f_wipe);\n-    m_filter_fileseq = MakeUnique<FlatFileSeq>(std::move(path), \"fltr\", FLTR_FILE_CHUNK_SIZE);\n+    m_db = std::make_unique<BaseIndex::DB>(path / \"db\", n_cache_size, f_memory, f_wipe);\n+    m_filter_fileseq = std::make_unique<FlatFileSeq>(std::move(path), \"fltr\", FLTR_FILE_CHUNK_SIZE);\n }\n \n bool BlockFilterIndex::Init()"
      },
      {
        "sha": "f41985c344b3bd23a73311326f1898b6bf5ab51d",
        "filename": "src/index/txindex.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/index/txindex.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/index/txindex.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -192,7 +192,7 @@ bool TxIndex::DB::MigrateData(CBlockTreeDB& block_tree_db, const CBlockLocator&\n }\n \n TxIndex::TxIndex(size_t n_cache_size, bool f_memory, bool f_wipe)\n-    : m_db(MakeUnique<TxIndex::DB>(n_cache_size, f_memory, f_wipe))\n+    : m_db(std::make_unique<TxIndex::DB>(n_cache_size, f_memory, f_wipe))\n {}\n \n TxIndex::~TxIndex() {}"
      },
      {
        "sha": "f4b76992331f8408b9c688d14eb67f79248886ff",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 8,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -580,10 +580,12 @@ void SetupServerArgs(NodeContext& node)\n     argsman.AddArg(\"-rpcworkqueue=<n>\", strprintf(\"Set the depth of the work queue to service RPC calls (default: %d)\", DEFAULT_HTTP_WORKQUEUE), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::RPC);\n     argsman.AddArg(\"-server\", \"Accept command line and JSON-RPC commands\", ArgsManager::ALLOW_ANY, OptionsCategory::RPC);\n \n-#if HAVE_DECL_DAEMON\n-    argsman.AddArg(\"-daemon\", \"Run in the background as a daemon and accept commands\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+#if HAVE_DECL_FORK\n+    argsman.AddArg(\"-daemon\", strprintf(\"Run in the background as a daemon and accept commands (default: %d)\", DEFAULT_DAEMON), ArgsManager::ALLOW_BOOL, OptionsCategory::OPTIONS);\n+    argsman.AddArg(\"-daemonwait\", strprintf(\"Wait for initialization to be finished before exiting. This implies -daemon (default: %d)\", DEFAULT_DAEMONWAIT), ArgsManager::ALLOW_BOOL, OptionsCategory::OPTIONS);\n #else\n     hidden_args.emplace_back(\"-daemon\");\n+    hidden_args.emplace_back(\"-daemonwait\");\n #endif\n \n     // Add the hidden options\n@@ -771,7 +773,7 @@ static bool InitSanityCheck()\n         return InitError(Untranslated(\"Elliptic curve cryptography sanity check failure. Aborting.\"));\n     }\n \n-    if (!glibc_sanity_test() || !glibcxx_sanity_test())\n+    if (!glibcxx_sanity_test())\n         return false;\n \n     if (!Random_SanityCheck()) {\n@@ -1306,7 +1308,7 @@ bool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA\n         LogPrintf(\"Config file: %s\\n\", config_file_path.string());\n     } else if (args.IsArgSet(\"-conf\")) {\n         // Warn if no conf file exists at path provided by user\n-        InitWarning(strprintf(_(\"The specified config file %s does not exist\\n\"), config_file_path.string()));\n+        InitWarning(strprintf(_(\"The specified config file %s does not exist\"), config_file_path.string()));\n     } else {\n         // Not categorizing as \"Warning\" because it's the default behavior\n         LogPrintf(\"Config file: %s (not found, skipping)\\n\", config_file_path.string());\n@@ -1349,7 +1351,7 @@ bool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA\n     }\n \n     assert(!node.scheduler);\n-    node.scheduler = MakeUnique<CScheduler>();\n+    node.scheduler = std::make_unique<CScheduler>();\n \n     // Start the lightweight task scheduler thread\n     node.scheduler->m_service_thread = std::thread([&] { TraceThread(\"scheduler\", [&] { node.scheduler->serviceQueue(); }); });\n@@ -1401,9 +1403,9 @@ bool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA\n     const bool ignores_incoming_txs{args.GetBoolArg(\"-blocksonly\", DEFAULT_BLOCKSONLY)};\n \n     assert(!node.banman);\n-    node.banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", &uiInterface, args.GetArg(\"-bantime\", DEFAULT_MISBEHAVING_BANTIME));\n+    node.banman = std::make_unique<BanMan>(GetDataDir() / \"banlist.dat\", &uiInterface, args.GetArg(\"-bantime\", DEFAULT_MISBEHAVING_BANTIME));\n     assert(!node.connman);\n-    node.connman = MakeUnique<CConnman>(GetRand(std::numeric_limits<uint64_t>::max()), GetRand(std::numeric_limits<uint64_t>::max()), args.GetBoolArg(\"-networkactive\", true));\n+    node.connman = std::make_unique<CConnman>(GetRand(std::numeric_limits<uint64_t>::max()), GetRand(std::numeric_limits<uint64_t>::max()), args.GetBoolArg(\"-networkactive\", true));\n \n     assert(!node.fee_estimator);\n     // Don't initialize fee estimation with old data if we don't relay transactions,\n@@ -1799,7 +1801,7 @@ bool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA\n \n     // ********************************************************* Step 8: start indexers\n     if (args.GetBoolArg(\"-txindex\", DEFAULT_TXINDEX)) {\n-        g_txindex = MakeUnique<TxIndex>(nTxIndexCache, false, fReindex);\n+        g_txindex = std::make_unique<TxIndex>(nTxIndexCache, false, fReindex);\n         g_txindex->Start();\n     }\n "
      },
      {
        "sha": "34bca09dd155a3d9f94ed04fb9762d3b2da5c846",
        "filename": "src/init.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -9,6 +9,11 @@\n #include <memory>\n #include <string>\n \n+//! Default value for -daemon option\n+static constexpr bool DEFAULT_DAEMON = false;\n+//! Default value for -daemonwait option\n+static constexpr bool DEFAULT_DAEMONWAIT = false;\n+\n class ArgsManager;\n struct NodeContext;\n namespace interfaces {"
      },
      {
        "sha": "3395741b1beb32b809fb747b11d383dbbcb7068b",
        "filename": "src/interfaces/chain.h",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/interfaces/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/interfaces/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -5,12 +5,12 @@\n #ifndef BITCOIN_INTERFACES_CHAIN_H\n #define BITCOIN_INTERFACES_CHAIN_H\n \n-#include <optional.h>               // For Optional and nullopt\n #include <primitives/transaction.h> // For CTransactionRef\n #include <util/settings.h>          // For util::SettingsValue\n \n #include <functional>\n #include <memory>\n+#include <optional>\n #include <stddef.h>\n #include <stdint.h>\n #include <string>\n@@ -94,7 +94,7 @@ class Chain\n     //! Get current chain height, not including genesis block (returns 0 if\n     //! chain only contains genesis block, nullopt if chain does not contain\n     //! any blocks)\n-    virtual Optional<int> getHeight() = 0;\n+    virtual std::optional<int> getHeight() = 0;\n \n     //! Get block hash. Height must be valid or this function will abort.\n     virtual uint256 getBlockHash(int height) = 0;\n@@ -109,7 +109,7 @@ class Chain\n     //! Return height of the highest block on chain in common with the locator,\n     //! which will either be the original block used to create the locator,\n     //! or one of its ancestors.\n-    virtual Optional<int> findLocatorFork(const CBlockLocator& locator) = 0;\n+    virtual std::optional<int> findLocatorFork(const CBlockLocator& locator) = 0;\n \n     //! Check if transaction will be final given chain height current time.\n     virtual bool checkFinalTx(const CTransaction& tx) = 0;\n@@ -154,11 +154,14 @@ class Chain\n     //! Return true if data is available for all blocks in the specified range\n     //! of blocks. This checks all blocks that are ancestors of block_hash in\n     //! the height range from min_height to max_height, inclusive.\n-    virtual bool hasBlocks(const uint256& block_hash, int min_height = 0, Optional<int> max_height = {}) = 0;\n+    virtual bool hasBlocks(const uint256& block_hash, int min_height = 0, std::optional<int> max_height = {}) = 0;\n \n     //! Check if transaction is RBF opt in.\n     virtual RBFTransactionState isRBFOptIn(const CTransaction& tx) = 0;\n \n+    //! Check if transaction is in mempool.\n+    virtual bool isInMempool(const uint256& txid) = 0;\n+\n     //! Check if transaction has descendants in mempool.\n     virtual bool hasDescendantsInMempool(const uint256& txid) = 0;\n "
      },
      {
        "sha": "c6bbbed4450dca9d1b69d20988f3d31654421df5",
        "filename": "src/interfaces/handler.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/interfaces/handler.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/interfaces/handler.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/handler.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -4,7 +4,6 @@\n \n #include <interfaces/handler.h>\n \n-#include <util/memory.h>\n \n #include <boost/signals2/connection.hpp>\n #include <utility>\n@@ -35,12 +34,12 @@ class CleanupHandler : public Handler\n \n std::unique_ptr<Handler> MakeHandler(boost::signals2::connection connection)\n {\n-    return MakeUnique<HandlerImpl>(std::move(connection));\n+    return std::make_unique<HandlerImpl>(std::move(connection));\n }\n \n std::unique_ptr<Handler> MakeHandler(std::function<void()> cleanup)\n {\n-    return MakeUnique<CleanupHandler>(std::move(cleanup));\n+    return std::make_unique<CleanupHandler>(std::move(cleanup));\n }\n \n } // namespace interfaces"
      },
      {
        "sha": "dbcbfa1f293bce3b42fdce650f7f2c77e9d106c1",
        "filename": "src/key_io.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 12,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/key_io.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/key_io.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key_io.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -43,15 +43,15 @@ class DestinationEncoder\n         std::vector<unsigned char> data = {0};\n         data.reserve(33);\n         ConvertBits<8, 5, true>([&](unsigned char c) { data.push_back(c); }, id.begin(), id.end());\n-        return bech32::Encode(m_params.Bech32HRP(), data);\n+        return bech32::Encode(bech32::Encoding::BECH32, m_params.Bech32HRP(), data);\n     }\n \n     std::string operator()(const WitnessV0ScriptHash& id) const\n     {\n         std::vector<unsigned char> data = {0};\n         data.reserve(53);\n         ConvertBits<8, 5, true>([&](unsigned char c) { data.push_back(c); }, id.begin(), id.end());\n-        return bech32::Encode(m_params.Bech32HRP(), data);\n+        return bech32::Encode(bech32::Encoding::BECH32, m_params.Bech32HRP(), data);\n     }\n \n     std::string operator()(const WitnessUnknown& id) const\n@@ -62,7 +62,7 @@ class DestinationEncoder\n         std::vector<unsigned char> data = {(unsigned char)id.version};\n         data.reserve(1 + (id.length * 8 + 4) / 5);\n         ConvertBits<8, 5, true>([&](unsigned char c) { data.push_back(c); }, id.program, id.program + id.length);\n-        return bech32::Encode(m_params.Bech32HRP(), data);\n+        return bech32::Encode(bech32::Encoding::BECH32M, m_params.Bech32HRP(), data);\n     }\n \n     std::string operator()(const CNoDestination& no) const { return {}; }\n@@ -95,20 +95,26 @@ CTxDestination DecodeDestination(const std::string& str, const CChainParams& par\n         error_str = \"Invalid prefix for Base58-encoded address\";\n     }\n     data.clear();\n-    auto bech = bech32::Decode(str);\n-    if (bech.second.size() > 0) {\n+    const auto dec = bech32::Decode(str);\n+    if ((dec.encoding == bech32::Encoding::BECH32 || dec.encoding == bech32::Encoding::BECH32M) && dec.data.size() > 0) {\n+        // Bech32 decoding\n         error_str = \"\";\n-\n-        if (bech.first != params.Bech32HRP()) {\n+        if (dec.hrp != params.Bech32HRP()) {\n             error_str = \"Invalid prefix for Bech32 address\";\n             return CNoDestination();\n         }\n-\n-        // Bech32 decoding\n-        int version = bech.second[0]; // The first 5 bit symbol is the witness version (0-16)\n+        int version = dec.data[0]; // The first 5 bit symbol is the witness version (0-16)\n+        if (version == 0 && dec.encoding != bech32::Encoding::BECH32) {\n+            error_str = \"Version 0 witness address must use Bech32 checksum\";\n+            return CNoDestination();\n+        }\n+        if (version != 0 && dec.encoding != bech32::Encoding::BECH32M) {\n+            error_str = \"Version 1+ witness address must use Bech32m checksum\";\n+            return CNoDestination();\n+        }\n         // The rest of the symbols are converted witness program bytes.\n-        data.reserve(((bech.second.size() - 1) * 5) / 8);\n-        if (ConvertBits<5, 8, false>([&](unsigned char c) { data.push_back(c); }, bech.second.begin() + 1, bech.second.end())) {\n+        data.reserve(((dec.data.size() - 1) * 5) / 8);\n+        if (ConvertBits<5, 8, false>([&](unsigned char c) { data.push_back(c); }, dec.data.begin() + 1, dec.data.end())) {\n             if (version == 0) {\n                 {\n                     WitnessV0KeyHash keyid;"
      },
      {
        "sha": "fe7a54c05237eb084275fd1a0c4c4817090401d5",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 8,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -39,13 +39,13 @@ int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParam\n     return nNewTime - nOldTime;\n }\n \n-void RegenerateCommitments(CBlock& block)\n+void RegenerateCommitments(CBlock& block, BlockManager& blockman)\n {\n     CMutableTransaction tx{*block.vtx.at(0)};\n     tx.vout.erase(tx.vout.begin() + GetWitnessCommitmentIndex(block));\n     block.vtx.at(0) = MakeTransactionRef(tx);\n \n-    GenerateCoinbaseCommitment(block, WITH_LOCK(cs_main, return g_chainman.m_blockman.LookupBlockIndex(block.hashPrevBlock)), Params().GetConsensus());\n+    GenerateCoinbaseCommitment(block, WITH_LOCK(::cs_main, assert(std::addressof(g_chainman.m_blockman) == std::addressof(blockman)); return blockman.LookupBlockIndex(block.hashPrevBlock)), Params().GetConsensus());\n \n     block.hashMerkleRoot = BlockMerkleRoot(block);\n }\n@@ -96,10 +96,7 @@ void BlockAssembler::resetBlock()\n     nFees = 0;\n }\n \n-Optional<int64_t> BlockAssembler::m_last_block_num_txs{nullopt};\n-Optional<int64_t> BlockAssembler::m_last_block_weight{nullopt};\n-\n-std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n+std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(CChainState& chainstate, const CScript& scriptPubKeyIn)\n {\n     int64_t nTimeStart = GetTimeMicros();\n \n@@ -117,7 +114,8 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n     pblocktemplate->vTxSigOpsCost.push_back(-1); // updated at end\n \n     LOCK2(cs_main, m_mempool.cs);\n-    CBlockIndex* pindexPrev = ::ChainActive().Tip();\n+    assert(std::addressof(*::ChainActive().Tip()) == std::addressof(*chainstate.m_chain.Tip()));\n+    CBlockIndex* pindexPrev = chainstate.m_chain.Tip();\n     assert(pindexPrev != nullptr);\n     nHeight = pindexPrev->nHeight + 1;\n \n@@ -176,7 +174,8 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n     pblocktemplate->vTxSigOpsCost[0] = WITNESS_SCALE_FACTOR * GetLegacySigOpCount(*pblock->vtx[0]);\n \n     BlockValidationState state;\n-    if (!TestBlockValidity(state, chainparams, ::ChainstateActive(), *pblock, pindexPrev, false, false)) {\n+    assert(std::addressof(::ChainstateActive()) == std::addressof(chainstate));\n+    if (!TestBlockValidity(state, chainparams, chainstate, *pblock, pindexPrev, false, false)) {\n         throw std::runtime_error(strprintf(\"%s: TestBlockValidity failed: %s\", __func__, state.ToString()));\n     }\n     int64_t nTime2 = GetTimeMicros();"
      },
      {
        "sha": "023635814cf13f922c302c4971ff3c88e3d38ae3",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -6,12 +6,12 @@\n #ifndef BITCOIN_MINER_H\n #define BITCOIN_MINER_H\n \n-#include <optional.h>\n #include <primitives/block.h>\n #include <txmempool.h>\n #include <validation.h>\n \n #include <memory>\n+#include <optional>\n #include <stdint.h>\n \n #include <boost/multi_index_container.hpp>\n@@ -158,10 +158,10 @@ class BlockAssembler\n     explicit BlockAssembler(const CTxMemPool& mempool, const CChainParams& params, const Options& options);\n \n     /** Construct a new block template with coinbase to scriptPubKeyIn */\n-    std::unique_ptr<CBlockTemplate> CreateNewBlock(const CScript& scriptPubKeyIn);\n+    std::unique_ptr<CBlockTemplate> CreateNewBlock(CChainState& chainstate, const CScript& scriptPubKeyIn);\n \n-    static Optional<int64_t> m_last_block_num_txs;\n-    static Optional<int64_t> m_last_block_weight;\n+    inline static std::optional<int64_t> m_last_block_num_txs{};\n+    inline static std::optional<int64_t> m_last_block_weight{};\n \n private:\n     // utility functions\n@@ -202,6 +202,6 @@ void IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev, unsigned\n int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev);\n \n /** Update an old GenerateCoinbaseCommitment from CreateNewBlock after the block txs have changed */\n-void RegenerateCommitments(CBlock& block);\n+void RegenerateCommitments(CBlock& block, BlockManager& blockman);\n \n #endif // BITCOIN_MINER_H"
      },
      {
        "sha": "3b1ebede98d45f4d3320d1096222c78dbcb2ed5e",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -18,7 +18,6 @@\n #include <net_permissions.h>\n #include <netbase.h>\n #include <node/ui_interface.h>\n-#include <optional.h>\n #include <protocol.h>\n #include <random.h>\n #include <scheduler.h>\n@@ -39,6 +38,7 @@\n #include <algorithm>\n #include <cstdint>\n #include <functional>\n+#include <optional>\n #include <unordered_map>\n \n #include <math.h>\n@@ -113,7 +113,7 @@ void CConnman::AddAddrFetch(const std::string& strDest)\n \n uint16_t GetListenPort()\n {\n-    return (uint16_t)(gArgs.GetArg(\"-port\", Params().GetDefaultPort()));\n+    return static_cast<uint16_t>(gArgs.GetArg(\"-port\", Params().GetDefaultPort()));\n }\n \n // find 'best' local address for a particular peer\n@@ -193,7 +193,7 @@ bool IsPeerAddrLocalGood(CNode *pnode)\n            IsReachable(addrLocal.GetNetwork());\n }\n \n-Optional<CAddress> GetLocalAddrForPeer(CNode *pnode)\n+std::optional<CAddress> GetLocalAddrForPeer(CNode *pnode)\n {\n     CAddress addrLocal = GetLocalAddress(&pnode->addr, pnode->GetLocalServices());\n     if (gArgs.GetBoolArg(\"-addrmantest\", false)) {\n@@ -215,7 +215,7 @@ Optional<CAddress> GetLocalAddrForPeer(CNode *pnode)\n         return addrLocal;\n     }\n     // Address is unroutable. Don't advertise.\n-    return nullopt;\n+    return std::nullopt;\n }\n \n // learn a new local address\n@@ -394,7 +394,7 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n         pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\n \n     // Resolve\n-    const int default_port = Params().GetDefaultPort();\n+    const uint16_t default_port{Params().GetDefaultPort()};\n     if (pszDest) {\n         std::vector<CService> resolved;\n         if (Lookup(pszDest, resolved,  default_port, fNameLookup && !HaveNameProxy(), 256) && !resolved.empty()) {\n@@ -462,7 +462,7 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n             return nullptr;\n         }\n         std::string host;\n-        int port = default_port;\n+        uint16_t port{default_port};\n         SplitHostPort(std::string(pszDest), port, host);\n         bool proxyConnectionFailed;\n         connected = ConnectThroughProxy(proxy, host, port, *sock, nConnectTimeout,\n@@ -632,7 +632,7 @@ bool CNode::ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete)\n         if (m_deserializer->Complete()) {\n             // decompose a transport agnostic CNetMessage from the deserializer\n             uint32_t out_err_raw_size{0};\n-            Optional<CNetMessage> result{m_deserializer->GetMessage(time, out_err_raw_size)};\n+            std::optional<CNetMessage> result{m_deserializer->GetMessage(time, out_err_raw_size)};\n             if (!result) {\n                 // Message deserialization failed.  Drop the message but don't disconnect the peer.\n                 // store the size of the corrupt message\n@@ -723,10 +723,10 @@ const uint256& V1TransportDeserializer::GetMessageHash() const\n     return data_hash;\n }\n \n-Optional<CNetMessage> V1TransportDeserializer::GetMessage(const std::chrono::microseconds time, uint32_t& out_err_raw_size)\n+std::optional<CNetMessage> V1TransportDeserializer::GetMessage(const std::chrono::microseconds time, uint32_t& out_err_raw_size)\n {\n     // decompose a single CNetMessage from the TransportDeserializer\n-    Optional<CNetMessage> msg(std::move(vRecv));\n+    std::optional<CNetMessage> msg(std::move(vRecv));\n \n     // store command string, time, and sizes\n     msg->m_command = hdr.GetCommand();\n@@ -747,12 +747,12 @@ Optional<CNetMessage> V1TransportDeserializer::GetMessage(const std::chrono::mic\n                  HexStr(hdr.pchChecksum),\n                  m_node_id);\n         out_err_raw_size = msg->m_raw_message_size;\n-        msg = nullopt;\n+        msg = std::nullopt;\n     } else if (!hdr.IsCommandValid()) {\n         LogPrint(BCLog::NET, \"HEADER ERROR - COMMAND (%s, %u bytes), peer=%d\\n\",\n                  hdr.GetCommand(), msg->m_message_size, m_node_id);\n         out_err_raw_size = msg->m_raw_message_size;\n-        msg = nullopt;\n+        msg.reset();\n     }\n \n     // Always reset the network deserializer (prepare for the next message)\n@@ -879,7 +879,7 @@ static void EraseLastKElements(std::vector<T> &elements, Comparator comparator,\n     elements.erase(elements.end() - eraseSize, elements.end());\n }\n \n-[[nodiscard]] Optional<NodeId> SelectNodeToEvict(std::vector<NodeEvictionCandidate>&& vEvictionCandidates)\n+[[nodiscard]] std::optional<NodeId> SelectNodeToEvict(std::vector<NodeEvictionCandidate>&& vEvictionCandidates)\n {\n     // Protect connections with certain characteristics\n \n@@ -918,7 +918,7 @@ static void EraseLastKElements(std::vector<T> &elements, Comparator comparator,\n     total_protect_size -= initial_size - vEvictionCandidates.size();\n     EraseLastKElements(vEvictionCandidates, ReverseCompareNodeTimeConnected, total_protect_size);\n \n-    if (vEvictionCandidates.empty()) return nullopt;\n+    if (vEvictionCandidates.empty()) return std::nullopt;\n \n     // If any remaining peers are preferred for eviction consider only them.\n     // This happens after the other preferences since if a peer is really the best by other criteria (esp relaying blocks)\n@@ -989,7 +989,7 @@ bool CConnman::AttemptToEvictConnection()\n             vEvictionCandidates.push_back(candidate);\n         }\n     }\n-    const Optional<NodeId> node_id_to_evict = SelectNodeToEvict(std::move(vEvictionCandidates));\n+    const std::optional<NodeId> node_id_to_evict = SelectNodeToEvict(std::move(vEvictionCandidates));\n     if (!node_id_to_evict) {\n         return false;\n     }\n@@ -2466,11 +2466,11 @@ bool CConnman::Start(CScheduler& scheduler, const Options& connOptions)\n \n     if (semOutbound == nullptr) {\n         // initialize semaphore\n-        semOutbound = MakeUnique<CSemaphore>(std::min(m_max_outbound, nMaxConnections));\n+        semOutbound = std::make_unique<CSemaphore>(std::min(m_max_outbound, nMaxConnections));\n     }\n     if (semAddnode == nullptr) {\n         // initialize semaphore\n-        semAddnode = MakeUnique<CSemaphore>(nMaxAddnode);\n+        semAddnode = std::make_unique<CSemaphore>(nMaxAddnode);\n     }\n \n     //\n@@ -2906,11 +2906,11 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const\n     hSocket = hSocketIn;\n     addrName = addrNameIn == \"\" ? addr.ToStringIPPort() : addrNameIn;\n     if (conn_type_in != ConnectionType::BLOCK_RELAY) {\n-        m_tx_relay = MakeUnique<TxRelay>();\n+        m_tx_relay = std::make_unique<TxRelay>();\n     }\n \n     if (RelayAddrsWithConn()) {\n-        m_addr_known = MakeUnique<CRollingBloomFilter>(5000, 0.001);\n+        m_addr_known = std::make_unique<CRollingBloomFilter>(5000, 0.001);\n     }\n \n     for (const std::string &msg : getAllNetMessageTypes())\n@@ -2923,8 +2923,8 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const\n         LogPrint(BCLog::NET, \"Added connection peer=%d\\n\", id);\n     }\n \n-    m_deserializer = MakeUnique<V1TransportDeserializer>(V1TransportDeserializer(Params(), GetId(), SER_NETWORK, INIT_PROTO_VERSION));\n-    m_serializer = MakeUnique<V1TransportSerializer>(V1TransportSerializer());\n+    m_deserializer = std::make_unique<V1TransportDeserializer>(V1TransportDeserializer(Params(), GetId(), SER_NETWORK, INIT_PROTO_VERSION));\n+    m_serializer = std::make_unique<V1TransportSerializer>(V1TransportSerializer());\n }\n \n CNode::~CNode()"
      },
      {
        "sha": "5228c4fbd3b3d7b4e80c5033ea65037711428c4f",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -18,7 +18,6 @@\n #include <net_permissions.h>\n #include <netaddress.h>\n #include <netbase.h>\n-#include <optional.h>\n #include <policy/feerate.h>\n #include <protocol.h>\n #include <random.h>\n@@ -35,6 +34,7 @@\n #include <deque>\n #include <map>\n #include <memory>\n+#include <optional>\n #include <thread>\n #include <vector>\n \n@@ -200,7 +200,7 @@ enum\n \n bool IsPeerAddrLocalGood(CNode *pnode);\n /** Returns a local address that we should advertise to this peer */\n-Optional<CAddress> GetLocalAddrForPeer(CNode *pnode);\n+std::optional<CAddress> GetLocalAddrForPeer(CNode *pnode);\n \n /**\n  * Mark a network as reachable or unreachable (no automatic connects to it)\n@@ -229,7 +229,7 @@ extern std::string strSubVersion;\n \n struct LocalServiceInfo {\n     int nScore;\n-    int nPort;\n+    uint16_t nPort;\n };\n \n extern RecursiveMutex cs_mapLocalHost;\n@@ -311,7 +311,7 @@ class TransportDeserializer {\n     /** read and deserialize data, advances msg_bytes data pointer */\n     virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n     // decomposes a message from the context\n-    virtual Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err) = 0;\n+    virtual std::optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err) = 0;\n     virtual ~TransportDeserializer() {}\n };\n \n@@ -375,7 +375,7 @@ class V1TransportDeserializer final : public TransportDeserializer\n         }\n         return ret;\n     }\n-    Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err_raw_size) override;\n+    std::optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err_raw_size) override;\n };\n \n /** The TransportSerializer prepares messages for the network transport\n@@ -1283,6 +1283,6 @@ struct NodeEvictionCandidate\n     bool m_is_local;\n };\n \n-[[nodiscard]] Optional<NodeId> SelectNodeToEvict(std::vector<NodeEvictionCandidate>&& vEvictionCandidates);\n+[[nodiscard]] std::optional<NodeId> SelectNodeToEvict(std::vector<NodeEvictionCandidate>&& vEvictionCandidates);\n \n #endif // BITCOIN_NET_H"
      },
      {
        "sha": "e561f02c4acf3fcb42bec18ff42d8d33ff731f47",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 268,
        "deletions": 290,
        "changes": 558,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -34,6 +34,7 @@\n #include <validation.h>\n \n #include <memory>\n+#include <optional>\n #include <typeinfo>\n \n /** How long to cache transactions in mapRelay for normal relay */\n@@ -246,6 +247,7 @@ class PeerManagerImpl final : public PeerManager\n     bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) override;\n     bool IgnoresIncomingTxs() override { return m_ignore_incoming_txs; }\n     void SendPings() override;\n+    void RelayTransaction(const uint256& txid, const uint256& wtxid) override;\n     void SetBestHeight(int height) override { m_best_height = height; };\n     void Misbehaving(const NodeId pnode, const int howmuch, const std::string& message) override;\n     void ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n@@ -259,7 +261,7 @@ class PeerManagerImpl final : public PeerManager\n     void EvictExtraOutboundPeers(int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     /** Retrieve unbroadcast transactions from the mempool and reattempt sending to peers */\n-    void ReattemptInitialBroadcast(CScheduler& scheduler) const;\n+    void ReattemptInitialBroadcast(CScheduler& scheduler);\n \n     /** Get a shared pointer to the Peer object.\n      *  May return an empty shared_ptr if the Peer object can't be found. */\n@@ -472,6 +474,21 @@ class PeerManagerImpl final : public PeerManager\n     std::vector<std::pair<uint256, CTransactionRef>> vExtraTxnForCompact GUARDED_BY(g_cs_orphans);\n     /** Offset into vExtraTxnForCompact to insert the next tx */\n     size_t vExtraTxnForCompactIt GUARDED_BY(g_cs_orphans) = 0;\n+\n+    void ProcessBlockAvailability(NodeId nodeid) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void UpdateBlockAvailability(NodeId nodeid, const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool CanDirectFetch() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool BlockRequestAllowed(const CBlockIndex* pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool AlreadyHaveBlock(const uint256& block_hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv& inv);\n+    bool PrepareBlockFilterRequest(CNode& peer,\n+                                   BlockFilterType filter_type, uint32_t start_height,\n+                                   const uint256& stop_hash, uint32_t max_height_diff,\n+                                   const CBlockIndex*& stop_index,\n+                                   BlockFilterIndex*& filter_index);\n+    void ProcessGetCFilters(CNode& peer, CDataStream& vRecv);\n+    void ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv);\n+    void ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv);\n };\n } // namespace\n \n@@ -488,50 +505,48 @@ namespace {\n  * and we're no longer holding the node's locks.\n  */\n struct CNodeState {\n-    //! The peer's address\n-    const CService address;\n     //! The best known block we know this peer has announced.\n-    const CBlockIndex *pindexBestKnownBlock;\n+    const CBlockIndex* pindexBestKnownBlock{nullptr};\n     //! The hash of the last unknown block this peer has announced.\n-    uint256 hashLastUnknownBlock;\n+    uint256 hashLastUnknownBlock{};\n     //! The last full block we both have.\n-    const CBlockIndex *pindexLastCommonBlock;\n+    const CBlockIndex* pindexLastCommonBlock{nullptr};\n     //! The best header we have sent our peer.\n-    const CBlockIndex *pindexBestHeaderSent;\n+    const CBlockIndex* pindexBestHeaderSent{nullptr};\n     //! Length of current-streak of unconnecting headers announcements\n-    int nUnconnectingHeaders;\n+    int nUnconnectingHeaders{0};\n     //! Whether we've started headers synchronization with this peer.\n-    bool fSyncStarted;\n+    bool fSyncStarted{false};\n     //! When to potentially disconnect peer for stalling headers download\n     std::chrono::microseconds m_headers_sync_timeout{0us};\n     //! Since when we're stalling block download progress (in microseconds), or 0.\n     std::chrono::microseconds m_stalling_since{0us};\n     std::list<QueuedBlock> vBlocksInFlight;\n     //! When the first entry in vBlocksInFlight started downloading. Don't care when vBlocksInFlight is empty.\n     std::chrono::microseconds m_downloading_since{0us};\n-    int nBlocksInFlight;\n-    int nBlocksInFlightValidHeaders;\n+    int nBlocksInFlight{0};\n+    int nBlocksInFlightValidHeaders{0};\n     //! Whether we consider this a preferred download peer.\n-    bool fPreferredDownload;\n+    bool fPreferredDownload{false};\n     //! Whether this peer wants invs or headers (when possible) for block announcements.\n-    bool fPreferHeaders;\n+    bool fPreferHeaders{false};\n     //! Whether this peer wants invs or cmpctblocks (when possible) for block announcements.\n-    bool fPreferHeaderAndIDs;\n+    bool fPreferHeaderAndIDs{false};\n     /**\n       * Whether this peer will send us cmpctblocks if we request them.\n       * This is not used to gate request logic, as we really only care about fSupportsDesiredCmpctVersion,\n       * but is used as a flag to \"lock in\" the version of compact blocks (fWantsCmpctWitness) we send.\n       */\n-    bool fProvidesHeaderAndIDs;\n+    bool fProvidesHeaderAndIDs{false};\n     //! Whether this peer can give us witnesses\n-    bool fHaveWitness;\n+    bool fHaveWitness{false};\n     //! Whether this peer wants witnesses in cmpctblocks/blocktxns\n-    bool fWantsCmpctWitness;\n+    bool fWantsCmpctWitness{false};\n     /**\n      * If we've announced NODE_WITNESS to this peer: whether the peer sends witnesses in cmpctblocks/blocktxns,\n      * otherwise: whether this peer sends non-witnesses in cmpctblocks/blocktxns.\n      */\n-    bool fSupportsDesiredCmpctVersion;\n+    bool fSupportsDesiredCmpctVersion{false};\n \n     /** State used to enforce CHAIN_SYNC_TIMEOUT and EXTRA_PEER_CHECK_INTERVAL logic.\n       *\n@@ -541,7 +556,7 @@ struct CNodeState {\n       *   - its connection type is IsBlockOnlyConn() == false\n       *   - it gave us a valid connecting header\n       *   - we haven't reached MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT yet\n-      *   - it has a better chain than we have\n+      *   - its chain tip has at least as much work as ours\n       *\n       * CHAIN_SYNC_TIMEOUT: if a peer's best known block has less work than our tip,\n       * set a timeout CHAIN_SYNC_TIMEOUT seconds in the future:\n@@ -559,51 +574,30 @@ struct CNodeState {\n       */\n     struct ChainSyncTimeoutState {\n         //! A timeout used for checking whether our peer has sufficiently synced\n-        int64_t m_timeout;\n+        int64_t m_timeout{0};\n         //! A header with the work we require on our peer's chain\n-        const CBlockIndex * m_work_header;\n+        const CBlockIndex* m_work_header{nullptr};\n         //! After timeout is reached, set to true after sending getheaders\n-        bool m_sent_getheaders;\n+        bool m_sent_getheaders{false};\n         //! Whether this peer is protected from disconnection due to a bad/slow chain\n-        bool m_protect;\n+        bool m_protect{false};\n     };\n \n     ChainSyncTimeoutState m_chain_sync;\n \n     //! Time of last new block announcement\n-    int64_t m_last_block_announcement;\n+    int64_t m_last_block_announcement{0};\n \n     //! Whether this peer is an inbound connection\n-    bool m_is_inbound;\n+    const bool m_is_inbound;\n \n     //! A rolling bloom filter of all announced tx CInvs to this peer.\n     CRollingBloomFilter m_recently_announced_invs = CRollingBloomFilter{INVENTORY_MAX_RECENT_RELAY, 0.000001};\n \n     //! Whether this peer relays txs via wtxid\n     bool m_wtxid_relay{false};\n \n-    CNodeState(CAddress addrIn, bool is_inbound)\n-        : address(addrIn), m_is_inbound(is_inbound)\n-    {\n-        pindexBestKnownBlock = nullptr;\n-        hashLastUnknownBlock.SetNull();\n-        pindexLastCommonBlock = nullptr;\n-        pindexBestHeaderSent = nullptr;\n-        nUnconnectingHeaders = 0;\n-        fSyncStarted = false;\n-        nBlocksInFlight = 0;\n-        nBlocksInFlightValidHeaders = 0;\n-        fPreferredDownload = false;\n-        fPreferHeaders = false;\n-        fPreferHeaderAndIDs = false;\n-        fProvidesHeaderAndIDs = false;\n-        fHaveWitness = false;\n-        fWantsCmpctWitness = false;\n-        fSupportsDesiredCmpctVersion = false;\n-        m_chain_sync = { 0, nullptr, false, false };\n-        m_last_block_announcement = 0;\n-        m_recently_announced_invs.reset();\n-    }\n+    CNodeState(bool is_inbound) : m_is_inbound(is_inbound) {}\n };\n \n /** Map maintaining per-node state. */\n@@ -684,41 +678,6 @@ bool PeerManagerImpl::MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, co\n     return true;\n }\n \n-/** Check whether the last unknown block a peer advertised is not yet known. */\n-static void ProcessBlockAvailability(NodeId nodeid) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n-    CNodeState *state = State(nodeid);\n-    assert(state != nullptr);\n-\n-    if (!state->hashLastUnknownBlock.IsNull()) {\n-        const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(state->hashLastUnknownBlock);\n-        if (pindex && pindex->nChainWork > 0) {\n-            if (state->pindexBestKnownBlock == nullptr || pindex->nChainWork >= state->pindexBestKnownBlock->nChainWork) {\n-                state->pindexBestKnownBlock = pindex;\n-            }\n-            state->hashLastUnknownBlock.SetNull();\n-        }\n-    }\n-}\n-\n-/** Update tracking information about which blocks a peer is assumed to have. */\n-static void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n-    CNodeState *state = State(nodeid);\n-    assert(state != nullptr);\n-\n-    ProcessBlockAvailability(nodeid);\n-\n-    const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(hash);\n-    if (pindex && pindex->nChainWork > 0) {\n-        // An actually better block was announced.\n-        if (state->pindexBestKnownBlock == nullptr || pindex->nChainWork >= state->pindexBestKnownBlock->nChainWork) {\n-            state->pindexBestKnownBlock = pindex;\n-        }\n-    } else {\n-        // An unknown block was announced; just assume that the latest one is the best one.\n-        state->hashLastUnknownBlock = hash;\n-    }\n-}\n-\n void PeerManagerImpl::MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid)\n {\n     AssertLockHeld(cs_main);\n@@ -768,9 +727,9 @@ bool PeerManagerImpl::TipMayBeStale()\n     return m_last_tip_update < GetTime() - consensusParams.nPowTargetSpacing * 3 && mapBlocksInFlight.empty();\n }\n \n-static bool CanDirectFetch(const Consensus::Params &consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+bool PeerManagerImpl::CanDirectFetch()\n {\n-    return ::ChainActive().Tip()->GetBlockTime() > GetAdjustedTime() - consensusParams.nPowTargetSpacing * 20;\n+    return m_chainman.ActiveChain().Tip()->GetBlockTime() > GetAdjustedTime() - m_chainparams.GetConsensus().nPowTargetSpacing * 20;\n }\n \n static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n@@ -782,6 +741,41 @@ static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIV\n     return false;\n }\n \n+/** Check whether the last unknown block a peer advertised is not yet known. */\n+void PeerManagerImpl::ProcessBlockAvailability(NodeId nodeid) {\n+    CNodeState *state = State(nodeid);\n+    assert(state != nullptr);\n+\n+    if (!state->hashLastUnknownBlock.IsNull()) {\n+        const CBlockIndex* pindex = m_chainman.m_blockman.LookupBlockIndex(state->hashLastUnknownBlock);\n+        if (pindex && pindex->nChainWork > 0) {\n+            if (state->pindexBestKnownBlock == nullptr || pindex->nChainWork >= state->pindexBestKnownBlock->nChainWork) {\n+                state->pindexBestKnownBlock = pindex;\n+            }\n+            state->hashLastUnknownBlock.SetNull();\n+        }\n+    }\n+}\n+\n+/** Update tracking information about which blocks a peer is assumed to have. */\n+void PeerManagerImpl::UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n+    CNodeState *state = State(nodeid);\n+    assert(state != nullptr);\n+\n+    ProcessBlockAvailability(nodeid);\n+\n+    const CBlockIndex* pindex = m_chainman.m_blockman.LookupBlockIndex(hash);\n+    if (pindex && pindex->nChainWork > 0) {\n+        // An actually better block was announced.\n+        if (state->pindexBestKnownBlock == nullptr || pindex->nChainWork >= state->pindexBestKnownBlock->nChainWork) {\n+            state->pindexBestKnownBlock = pindex;\n+        }\n+    } else {\n+        // An unknown block was announced; just assume that the latest one is the best one.\n+        state->hashLastUnknownBlock = hash;\n+    }\n+}\n+\n void PeerManagerImpl::FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller)\n {\n     if (count == 0)\n@@ -794,15 +788,15 @@ void PeerManagerImpl::FindNextBlocksToDownload(NodeId nodeid, unsigned int count\n     // Make sure pindexBestKnownBlock is up to date, we'll need it.\n     ProcessBlockAvailability(nodeid);\n \n-    if (state->pindexBestKnownBlock == nullptr || state->pindexBestKnownBlock->nChainWork < ::ChainActive().Tip()->nChainWork || state->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n+    if (state->pindexBestKnownBlock == nullptr || state->pindexBestKnownBlock->nChainWork < m_chainman.ActiveChain().Tip()->nChainWork || state->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n         // This peer has nothing interesting.\n         return;\n     }\n \n     if (state->pindexLastCommonBlock == nullptr) {\n         // Bootstrap quickly by guessing a parent of our best tip is the forking point.\n         // Guessing wrong in either direction is not a problem.\n-        state->pindexLastCommonBlock = ::ChainActive()[std::min(state->pindexBestKnownBlock->nHeight, ::ChainActive().Height())];\n+        state->pindexLastCommonBlock = m_chainman.ActiveChain()[std::min(state->pindexBestKnownBlock->nHeight, m_chainman.ActiveChain().Height())];\n     }\n \n     // If the peer reorganized, our previous pindexLastCommonBlock may not be an ancestor\n@@ -845,7 +839,7 @@ void PeerManagerImpl::FindNextBlocksToDownload(NodeId nodeid, unsigned int count\n                 // We wouldn't download this block or its descendants from this peer.\n                 return;\n             }\n-            if (pindex->nStatus & BLOCK_HAVE_DATA || ::ChainActive().Contains(pindex)) {\n+            if (pindex->nStatus & BLOCK_HAVE_DATA || m_chainman.ActiveChain().Contains(pindex)) {\n                 if (pindex->HaveTxsDownloaded())\n                     state->pindexLastCommonBlock = pindex;\n             } else if (mapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n@@ -937,12 +931,10 @@ void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds)\n \n void PeerManagerImpl::InitializeNode(CNode *pnode)\n {\n-    CAddress addr = pnode->addr;\n-    std::string addrName = pnode->GetAddrName();\n     NodeId nodeid = pnode->GetId();\n     {\n         LOCK(cs_main);\n-        mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, pnode->IsInboundConn()));\n+        mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(pnode->IsInboundConn()));\n         assert(m_txrequest.Count(nodeid) == 0);\n     }\n     {\n@@ -955,7 +947,7 @@ void PeerManagerImpl::InitializeNode(CNode *pnode)\n     }\n }\n \n-void PeerManagerImpl::ReattemptInitialBroadcast(CScheduler& scheduler) const\n+void PeerManagerImpl::ReattemptInitialBroadcast(CScheduler& scheduler)\n {\n     std::set<uint256> unbroadcast_txids = m_mempool.GetUnbroadcastTxs();\n \n@@ -964,7 +956,7 @@ void PeerManagerImpl::ReattemptInitialBroadcast(CScheduler& scheduler) const\n \n         if (tx != nullptr) {\n             LOCK(cs_main);\n-            RelayTransaction(txid, tx->GetWitnessHash(), m_connman);\n+            RelayTransaction(txid, tx->GetWitnessHash());\n         } else {\n             m_mempool.RemoveUnbroadcastTx(txid, true);\n         }\n@@ -1200,13 +1192,13 @@ bool PeerManagerImpl::MaybePunishNodeForTx(NodeId nodeid, const TxValidationStat\n // active chain if they are no more than a month older (both in time, and in\n // best equivalent proof of work) than the best header chain we know about and\n // we fully-validated them at some point.\n-static bool BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+bool PeerManagerImpl::BlockRequestAllowed(const CBlockIndex* pindex)\n {\n     AssertLockHeld(cs_main);\n-    if (::ChainActive().Contains(pindex)) return true;\n+    if (m_chainman.ActiveChain().Contains(pindex)) return true;\n     return pindex->IsValid(BLOCK_VALID_SCRIPTS) && (pindexBestHeader != nullptr) &&\n-        (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() < STALE_RELAY_AGE_LIMIT) &&\n-        (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, consensusParams) < STALE_RELAY_AGE_LIMIT);\n+           (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() < STALE_RELAY_AGE_LIMIT) &&\n+           (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, m_chainparams.GetConsensus()) < STALE_RELAY_AGE_LIMIT);\n }\n \n std::unique_ptr<PeerManager> PeerManager::make(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n@@ -1227,6 +1219,7 @@ PeerManagerImpl::PeerManagerImpl(const CChainParams& chainparams, CConnman& conn\n       m_stale_tip_check_time(0),\n       m_ignore_incoming_txs(ignore_incoming_txs)\n {\n+    assert(std::addressof(g_chainman) == std::addressof(m_chainman));\n     // Initialize global variables that cannot be constructed at startup.\n     recentRejects.reset(new CRollingBloomFilter(120000, 0.000001));\n \n@@ -1352,7 +1345,7 @@ void PeerManagerImpl::NewPoWValidBlock(const CBlockIndex *pindex, const std::sha\n \n /**\n  * Update our best height and announce any block hashes which weren't previously\n- * in ::ChainActive() to our peers.\n+ * in m_chainman.ActiveChain() to our peers.\n  */\n void PeerManagerImpl::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n {\n@@ -1414,7 +1407,7 @@ void PeerManagerImpl::BlockChecked(const CBlock& block, const BlockValidationSta\n     //    the tip yet so we have no way to check this directly here. Instead we\n     //    just check that there are currently no other blocks in flight.\n     else if (state.IsValid() &&\n-             !::ChainstateActive().IsInitialBlockDownload() &&\n+             !m_chainman.ActiveChainstate().IsInitialBlockDownload() &&\n              mapBlocksInFlight.count(hash) == mapBlocksInFlight.size()) {\n         if (it != mapBlockSource.end()) {\n             MaybeSetPeerAsAnnouncingHeaderAndIDs(it->second.first);\n@@ -1433,12 +1426,12 @@ void PeerManagerImpl::BlockChecked(const CBlock& block, const BlockValidationSta\n bool PeerManagerImpl::AlreadyHaveTx(const GenTxid& gtxid)\n {\n     assert(recentRejects);\n-    if (::ChainActive().Tip()->GetBlockHash() != hashRecentRejectsChainTip) {\n+    if (m_chainman.ActiveChain().Tip()->GetBlockHash() != hashRecentRejectsChainTip) {\n         // If the chain tip has changed previously rejected transactions\n         // might be now valid, e.g. due to a nLockTime'd tx becoming valid,\n         // or a double-spend. Reset the rejects filter and give those\n         // txs a second chance.\n-        hashRecentRejectsChainTip = ::ChainActive().Tip()->GetBlockHash();\n+        hashRecentRejectsChainTip = m_chainman.ActiveChain().Tip()->GetBlockHash();\n         recentRejects->reset();\n     }\n \n@@ -1454,9 +1447,9 @@ bool PeerManagerImpl::AlreadyHaveTx(const GenTxid& gtxid)\n     return recentRejects->contains(hash) || m_mempool.exists(gtxid);\n }\n \n-bool static AlreadyHaveBlock(const uint256& block_hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+bool PeerManagerImpl::AlreadyHaveBlock(const uint256& block_hash)\n {\n-    return g_chainman.m_blockman.LookupBlockIndex(block_hash) != nullptr;\n+    return m_chainman.m_blockman.LookupBlockIndex(block_hash) != nullptr;\n }\n \n void PeerManagerImpl::SendPings()\n@@ -1465,9 +1458,9 @@ void PeerManagerImpl::SendPings()\n     for(auto& it : m_peer_map) it.second->m_ping_queued = true;\n }\n \n-void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman& connman)\n+void PeerManagerImpl::RelayTransaction(const uint256& txid, const uint256& wtxid)\n {\n-    connman.ForEachNode([&txid, &wtxid](CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n+    m_connman.ForEachNode([&txid, &wtxid](CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n         AssertLockHeld(::cs_main);\n \n         CNodeState* state = State(pnode->GetId());\n@@ -1535,13 +1528,11 @@ static void RelayAddress(const CNode& originator,\n     connman.ForEachNodeThen(std::move(sortfunc), std::move(pushfunc));\n }\n \n-void static ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChainParams& chainparams, const CInv& inv, CConnman& connman)\n+void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv& inv)\n {\n-    bool send = false;\n     std::shared_ptr<const CBlock> a_recent_block;\n     std::shared_ptr<const CBlockHeaderAndShortTxIDs> a_recent_compact_block;\n     bool fWitnessesPresentInARecentCompactBlock;\n-    const Consensus::Params& consensusParams = chainparams.GetConsensus();\n     {\n         LOCK(cs_most_recent_block);\n         a_recent_block = most_recent_block;\n@@ -1552,7 +1543,7 @@ void static ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChainParams& ch\n     bool need_activate_chain = false;\n     {\n         LOCK(cs_main);\n-        const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(inv.hash);\n+        const CBlockIndex* pindex = m_chainman.m_blockman.LookupBlockIndex(inv.hash);\n         if (pindex) {\n             if (pindex->HaveTxsDownloaded() && !pindex->IsValid(BLOCK_VALID_SCRIPTS) &&\n                     pindex->IsValid(BLOCK_VALID_TREE)) {\n@@ -1567,126 +1558,124 @@ void static ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChainParams& ch\n     } // release cs_main before calling ActivateBestChain\n     if (need_activate_chain) {\n         BlockValidationState state;\n-        if (!::ChainstateActive().ActivateBestChain(state, chainparams, a_recent_block)) {\n+        if (!m_chainman.ActiveChainstate().ActivateBestChain(state, m_chainparams, a_recent_block)) {\n             LogPrint(BCLog::NET, \"failed to activate chain (%s)\\n\", state.ToString());\n         }\n     }\n \n     LOCK(cs_main);\n-    const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(inv.hash);\n-    if (pindex) {\n-        send = BlockRequestAllowed(pindex, consensusParams);\n-        if (!send) {\n-            LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block that isn't in the main chain\\n\", __func__, pfrom.GetId());\n-        }\n+    const CBlockIndex* pindex = m_chainman.m_blockman.LookupBlockIndex(inv.hash);\n+    if (!pindex) {\n+        return;\n+    }\n+    if (!BlockRequestAllowed(pindex)) {\n+        LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block that isn't in the main chain\\n\", __func__, pfrom.GetId());\n+        return;\n     }\n     const CNetMsgMaker msgMaker(pfrom.GetCommonVersion());\n     // disconnect node in case we have reached the outbound limit for serving historical blocks\n-    if (send &&\n-        connman.OutboundTargetReached(true) &&\n+    if (m_connman.OutboundTargetReached(true) &&\n         (((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.IsMsgFilteredBlk()) &&\n         !pfrom.HasPermission(PF_DOWNLOAD) // nodes with the download permission may exceed target\n     ) {\n         LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom.GetId());\n-\n-        //disconnect node\n         pfrom.fDisconnect = true;\n-        send = false;\n+        return;\n     }\n     // Avoid leaking prune-height by never sending blocks below the NODE_NETWORK_LIMITED threshold\n-    if (send && !pfrom.HasPermission(PF_NOBAN) && (\n-            (((pfrom.GetLocalServices() & NODE_NETWORK_LIMITED) == NODE_NETWORK_LIMITED) && ((pfrom.GetLocalServices() & NODE_NETWORK) != NODE_NETWORK) && (::ChainActive().Tip()->nHeight - pindex->nHeight > (int)NODE_NETWORK_LIMITED_MIN_BLOCKS + 2 /* add two blocks buffer extension for possible races */) )\n+    if (!pfrom.HasPermission(PF_NOBAN) && (\n+            (((pfrom.GetLocalServices() & NODE_NETWORK_LIMITED) == NODE_NETWORK_LIMITED) && ((pfrom.GetLocalServices() & NODE_NETWORK) != NODE_NETWORK) && (m_chainman.ActiveChain().Tip()->nHeight - pindex->nHeight > (int)NODE_NETWORK_LIMITED_MIN_BLOCKS + 2 /* add two blocks buffer extension for possible races */) )\n        )) {\n-        LogPrint(BCLog::NET, \"Ignore block request below NODE_NETWORK_LIMITED threshold from peer=%d\\n\", pfrom.GetId());\n-\n+        LogPrint(BCLog::NET, \"Ignore block request below NODE_NETWORK_LIMITED threshold, disconnect peer=%d\\n\", pfrom.GetId());\n         //disconnect node and prevent it from stalling (would otherwise wait for the missing block)\n         pfrom.fDisconnect = true;\n-        send = false;\n+        return;\n     }\n     // Pruned nodes may have deleted the block, so check whether\n     // it's available before trying to send.\n-    if (send && (pindex->nStatus & BLOCK_HAVE_DATA))\n-    {\n-        std::shared_ptr<const CBlock> pblock;\n-        if (a_recent_block && a_recent_block->GetHash() == pindex->GetBlockHash()) {\n-            pblock = a_recent_block;\n-        } else if (inv.IsMsgWitnessBlk()) {\n-            // Fast-path: in this case it is possible to serve the block directly from disk,\n-            // as the network format matches the format on disk\n-            std::vector<uint8_t> block_data;\n-            if (!ReadRawBlockFromDisk(block_data, pindex, chainparams.MessageStart())) {\n-                assert(!\"cannot load block from disk\");\n-            }\n-            connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCK, MakeSpan(block_data)));\n-            // Don't set pblock as we've sent the block\n-        } else {\n-            // Send block from disk\n-            std::shared_ptr<CBlock> pblockRead = std::make_shared<CBlock>();\n-            if (!ReadBlockFromDisk(*pblockRead, pindex, consensusParams))\n-                assert(!\"cannot load block from disk\");\n-            pblock = pblockRead;\n+    if (!(pindex->nStatus & BLOCK_HAVE_DATA)) {\n+        return;\n+    }\n+    std::shared_ptr<const CBlock> pblock;\n+    if (a_recent_block && a_recent_block->GetHash() == pindex->GetBlockHash()) {\n+        pblock = a_recent_block;\n+    } else if (inv.IsMsgWitnessBlk()) {\n+        // Fast-path: in this case it is possible to serve the block directly from disk,\n+        // as the network format matches the format on disk\n+        std::vector<uint8_t> block_data;\n+        if (!ReadRawBlockFromDisk(block_data, pindex, m_chainparams.MessageStart())) {\n+            assert(!\"cannot load block from disk\");\n+        }\n+        m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCK, MakeSpan(block_data)));\n+        // Don't set pblock as we've sent the block\n+    } else {\n+        // Send block from disk\n+        std::shared_ptr<CBlock> pblockRead = std::make_shared<CBlock>();\n+        if (!ReadBlockFromDisk(*pblockRead, pindex, m_chainparams.GetConsensus())) {\n+            assert(!\"cannot load block from disk\");\n         }\n-        if (pblock) {\n-            if (inv.IsMsgBlk()) {\n-                connman.PushMessage(&pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));\n-            } else if (inv.IsMsgWitnessBlk()) {\n-                connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n-            } else if (inv.IsMsgFilteredBlk()) {\n-                bool sendMerkleBlock = false;\n-                CMerkleBlock merkleBlock;\n-                if (pfrom.m_tx_relay != nullptr) {\n-                    LOCK(pfrom.m_tx_relay->cs_filter);\n-                    if (pfrom.m_tx_relay->pfilter) {\n-                        sendMerkleBlock = true;\n-                        merkleBlock = CMerkleBlock(*pblock, *pfrom.m_tx_relay->pfilter);\n-                    }\n-                }\n-                if (sendMerkleBlock) {\n-                    connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));\n-                    // CMerkleBlock just contains hashes, so also push any transactions in the block the client did not see\n-                    // This avoids hurting performance by pointlessly requiring a round-trip\n-                    // Note that there is currently no way for a node to request any single transactions we didn't send here -\n-                    // they must either disconnect and retry or request the full block.\n-                    // Thus, the protocol spec specified allows for us to provide duplicate txn here,\n-                    // however we MUST always provide at least what the remote peer needs\n-                    typedef std::pair<unsigned int, uint256> PairType;\n-                    for (PairType& pair : merkleBlock.vMatchedTxn)\n-                        connman.PushMessage(&pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n+        pblock = pblockRead;\n+    }\n+    if (pblock) {\n+        if (inv.IsMsgBlk()) {\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));\n+        } else if (inv.IsMsgWitnessBlk()) {\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n+        } else if (inv.IsMsgFilteredBlk()) {\n+            bool sendMerkleBlock = false;\n+            CMerkleBlock merkleBlock;\n+            if (pfrom.m_tx_relay != nullptr) {\n+                LOCK(pfrom.m_tx_relay->cs_filter);\n+                if (pfrom.m_tx_relay->pfilter) {\n+                    sendMerkleBlock = true;\n+                    merkleBlock = CMerkleBlock(*pblock, *pfrom.m_tx_relay->pfilter);\n                 }\n-                // else\n-                    // no response\n-            } else if (inv.IsMsgCmpctBlk()) {\n-                // If a peer is asking for old blocks, we're almost guaranteed\n-                // they won't have a useful mempool to match against a compact block,\n-                // and we don't feel like constructing the object for them, so\n-                // instead we respond with the full, non-compact block.\n-                bool fPeerWantsWitness = State(pfrom.GetId())->fWantsCmpctWitness;\n-                int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n-                if (CanDirectFetch(consensusParams) && pindex->nHeight >= ::ChainActive().Height() - MAX_CMPCTBLOCK_DEPTH) {\n-                    if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == pindex->GetBlockHash()) {\n-                        connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n-                    } else {\n-                        CBlockHeaderAndShortTxIDs cmpctblock(*pblock, fPeerWantsWitness);\n-                        connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n-                    }\n+            }\n+            if (sendMerkleBlock) {\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));\n+                // CMerkleBlock just contains hashes, so also push any transactions in the block the client did not see\n+                // This avoids hurting performance by pointlessly requiring a round-trip\n+                // Note that there is currently no way for a node to request any single transactions we didn't send here -\n+                // they must either disconnect and retry or request the full block.\n+                // Thus, the protocol spec specified allows for us to provide duplicate txn here,\n+                // however we MUST always provide at least what the remote peer needs\n+                typedef std::pair<unsigned int, uint256> PairType;\n+                for (PairType& pair : merkleBlock.vMatchedTxn)\n+                    m_connman.PushMessage(&pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n+            }\n+            // else\n+            // no response\n+        } else if (inv.IsMsgCmpctBlk()) {\n+            // If a peer is asking for old blocks, we're almost guaranteed\n+            // they won't have a useful mempool to match against a compact block,\n+            // and we don't feel like constructing the object for them, so\n+            // instead we respond with the full, non-compact block.\n+            bool fPeerWantsWitness = State(pfrom.GetId())->fWantsCmpctWitness;\n+            int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n+            if (CanDirectFetch() && pindex->nHeight >= m_chainman.ActiveChain().Height() - MAX_CMPCTBLOCK_DEPTH) {\n+                if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == pindex->GetBlockHash()) {\n+                    m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n                 } else {\n-                    connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n+                    CBlockHeaderAndShortTxIDs cmpctblock(*pblock, fPeerWantsWitness);\n+                    m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                 }\n+            } else {\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n             }\n         }\n+    }\n \n-        {\n-            LOCK(peer.m_block_inv_mutex);\n-            // Trigger the peer node to send a getblocks request for the next batch of inventory\n-            if (inv.hash == peer.m_continuation_block) {\n-                // Send immediately. This must send even if redundant,\n-                // and we want it right after the last block so they don't\n-                // wait for other stuff first.\n-                std::vector<CInv> vInv;\n-                vInv.push_back(CInv(MSG_BLOCK, ::ChainActive().Tip()->GetBlockHash()));\n-                connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n-                peer.m_continuation_block.SetNull();\n-            }\n+    {\n+        LOCK(peer.m_block_inv_mutex);\n+        // Trigger the peer node to send a getblocks request for the next batch of inventory\n+        if (inv.hash == peer.m_continuation_block) {\n+            // Send immediately. This must send even if redundant,\n+            // and we want it right after the last block so they don't\n+            // wait for other stuff first.\n+            std::vector<CInv> vInv;\n+            vInv.push_back(CInv(MSG_BLOCK, m_chainman.ActiveChain().Tip()->GetBlockHash()));\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n+            peer.m_continuation_block.SetNull();\n         }\n     }\n }\n@@ -1785,7 +1774,7 @@ void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const std::atomic\n     if (it != peer.m_getdata_requests.end() && !pfrom.fPauseSend) {\n         const CInv &inv = *it++;\n         if (inv.IsGenBlkMsg()) {\n-            ProcessGetBlockData(pfrom, peer, m_chainparams, inv, m_connman);\n+            ProcessGetBlockData(pfrom, peer, inv);\n         }\n         // else: If the first item on the queue is an unknown type, we erase it\n         // and continue processing the queue on the next call.\n@@ -1862,9 +1851,9 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n         //   don't connect before giving DoS points\n         // - Once a headers message is received that is valid and does connect,\n         //   nUnconnectingHeaders gets reset back to 0.\n-        if (!g_chainman.m_blockman.LookupBlockIndex(headers[0].hashPrevBlock) && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n+        if (!m_chainman.m_blockman.LookupBlockIndex(headers[0].hashPrevBlock) && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n             nodestate->nUnconnectingHeaders++;\n-            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), uint256()));\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(pindexBestHeader), uint256()));\n             LogPrint(BCLog::NET, \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n                     headers[0].GetHash().ToString(),\n                     headers[0].hashPrevBlock.ToString(),\n@@ -1892,7 +1881,7 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n \n         // If we don't have the last header, then they'll have given us\n         // something new (if these headers are valid).\n-        if (!g_chainman.m_blockman.LookupBlockIndex(hashLastBlock)) {\n+        if (!m_chainman.m_blockman.LookupBlockIndex(hashLastBlock)) {\n             received_new_header = true;\n         }\n     }\n@@ -1920,27 +1909,26 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n         // because it is set in UpdateBlockAvailability. Some nullptr checks\n         // are still present, however, as belt-and-suspenders.\n \n-        if (received_new_header && pindexLast->nChainWork > ::ChainActive().Tip()->nChainWork) {\n+        if (received_new_header && pindexLast->nChainWork > m_chainman.ActiveChain().Tip()->nChainWork) {\n             nodestate->m_last_block_announcement = GetTime();\n         }\n \n         if (nCount == MAX_HEADERS_RESULTS) {\n             // Headers message had its maximum size; the peer may have more headers.\n-            // TODO: optimize: if pindexLast is an ancestor of ::ChainActive().Tip or pindexBestHeader, continue\n+            // TODO: optimize: if pindexLast is an ancestor of m_chainman.ActiveChain().Tip or pindexBestHeader, continue\n             // from there instead.\n             LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\",\n                                  pindexLast->nHeight, pfrom.GetId(), peer.m_starting_height);\n-            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexLast), uint256()));\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(pindexLast), uint256()));\n         }\n \n-        bool fCanDirectFetch = CanDirectFetch(m_chainparams.GetConsensus());\n         // If this set of headers is valid and ends in a block with at least as\n         // much work as our tip, download as much as possible.\n-        if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && ::ChainActive().Tip()->nChainWork <= pindexLast->nChainWork) {\n+        if (CanDirectFetch() && pindexLast->IsValid(BLOCK_VALID_TREE) && m_chainman.ActiveChain().Tip()->nChainWork <= pindexLast->nChainWork) {\n             std::vector<const CBlockIndex*> vToFetch;\n             const CBlockIndex *pindexWalk = pindexLast;\n             // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.\n-            while (pindexWalk && !::ChainActive().Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+            while (pindexWalk && !m_chainman.ActiveChain().Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n                 if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&\n                         !mapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&\n                         (!IsWitnessEnabled(pindexWalk->pprev, m_chainparams.GetConsensus()) || State(pfrom.GetId())->fHaveWitness)) {\n@@ -1953,7 +1941,7 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n             // very large reorg at a time we think we're close to caught up to\n             // the main chain -- this shouldn't really happen.  Bail out on the\n             // direct fetch and rely on parallel download instead.\n-            if (!::ChainActive().Contains(pindexWalk)) {\n+            if (!m_chainman.ActiveChain().Contains(pindexWalk)) {\n                 LogPrint(BCLog::NET, \"Large reorg, won't direct fetch to %s (%d)\\n\",\n                         pindexLast->GetBlockHash().ToString(),\n                         pindexLast->nHeight);\n@@ -1986,15 +1974,15 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n         }\n         // If we're in IBD, we want outbound peers that will serve us a useful\n         // chain. Disconnect peers that are on chains with insufficient work.\n-        if (::ChainstateActive().IsInitialBlockDownload() && nCount != MAX_HEADERS_RESULTS) {\n+        if (m_chainman.ActiveChainstate().IsInitialBlockDownload() && nCount != MAX_HEADERS_RESULTS) {\n             // When nCount < MAX_HEADERS_RESULTS, we know we have no more\n             // headers to fetch from this peer.\n             if (nodestate->pindexBestKnownBlock && nodestate->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n                 // This peer has too little work on their headers chain to help\n                 // us sync -- disconnect if it is an outbound disconnection\n                 // candidate.\n                 // Note: We compare their tip to nMinimumChainWork (rather than\n-                // ::ChainActive().Tip()) because we won't start block download\n+                // m_chainman.ActiveChain().Tip()) because we won't start block download\n                 // until we have a headers chain that has at least\n                 // nMinimumChainWork, even if a peer has a chain past our tip,\n                 // as an anti-DoS measure.\n@@ -2011,7 +1999,7 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n         // thus always subject to eviction under the bad/lagging chain logic.\n         // See ChainSyncTimeoutState.\n         if (!pfrom.fDisconnect && pfrom.IsFullOutboundConn() && nodestate->pindexBestKnownBlock != nullptr) {\n-            if (m_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= ::ChainActive().Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n+            if (m_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= m_chainman.ActiveChain().Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n                 LogPrint(BCLog::NET, \"Protecting outbound peer=%d from eviction\\n\", pfrom.GetId());\n                 nodestate->m_chain_sync.m_protect = true;\n                 ++m_outbound_peers_with_protect_from_disconnect;\n@@ -2042,12 +2030,12 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n         const auto [porphanTx, from_peer] = m_orphanage.GetTx(orphanHash);\n         if (porphanTx == nullptr) continue;\n \n-        const MempoolAcceptResult result = AcceptToMemoryPool(::ChainstateActive(), m_mempool, porphanTx, false /* bypass_limits */);\n+        const MempoolAcceptResult result = AcceptToMemoryPool(m_chainman.ActiveChainstate(), m_mempool, porphanTx, false /* bypass_limits */);\n         const TxValidationState& state = result.m_state;\n \n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n             LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n-            RelayTransaction(orphanHash, porphanTx->GetWitnessHash(), m_connman);\n+            RelayTransaction(orphanHash, porphanTx->GetWitnessHash());\n             m_orphanage.AddChildrenToWorkSet(*porphanTx, orphan_work_set);\n             m_orphanage.EraseTx(orphanHash);\n             for (const CTransactionRef& removedTx : result.m_replaced_transactions.value()) {\n@@ -2109,7 +2097,6 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n  * May disconnect from the peer in the case of a bad request.\n  *\n  * @param[in]   peer            The peer that we received the request from\n- * @param[in]   chain_params    Chain parameters\n  * @param[in]   filter_type     The filter type the request is for. Must be basic filters.\n  * @param[in]   start_height    The start height for the request\n  * @param[in]   stop_hash       The stop_hash for the request\n@@ -2118,11 +2105,11 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n  * @param[out]  filter_index    The filter index, if the request can be serviced.\n  * @return                      True if the request can be serviced.\n  */\n-static bool PrepareBlockFilterRequest(CNode& peer, const CChainParams& chain_params,\n-                                      BlockFilterType filter_type, uint32_t start_height,\n-                                      const uint256& stop_hash, uint32_t max_height_diff,\n-                                      const CBlockIndex*& stop_index,\n-                                      BlockFilterIndex*& filter_index)\n+bool PeerManagerImpl::PrepareBlockFilterRequest(CNode& peer,\n+                                                BlockFilterType filter_type, uint32_t start_height,\n+                                                const uint256& stop_hash, uint32_t max_height_diff,\n+                                                const CBlockIndex*& stop_index,\n+                                                BlockFilterIndex*& filter_index)\n {\n     const bool supported_filter_type =\n         (filter_type == BlockFilterType::BASIC &&\n@@ -2136,10 +2123,10 @@ static bool PrepareBlockFilterRequest(CNode& peer, const CChainParams& chain_par\n \n     {\n         LOCK(cs_main);\n-        stop_index = g_chainman.m_blockman.LookupBlockIndex(stop_hash);\n+        stop_index = m_chainman.m_blockman.LookupBlockIndex(stop_hash);\n \n         // Check that the stop block exists and the peer would be allowed to fetch it.\n-        if (!stop_index || !BlockRequestAllowed(stop_index, chain_params.GetConsensus())) {\n+        if (!stop_index || !BlockRequestAllowed(stop_index)) {\n             LogPrint(BCLog::NET, \"peer %d requested invalid block hash: %s\\n\",\n                      peer.GetId(), stop_hash.ToString());\n             peer.fDisconnect = true;\n@@ -2178,11 +2165,8 @@ static bool PrepareBlockFilterRequest(CNode& peer, const CChainParams& chain_par\n  *\n  * @param[in]   peer            The peer that we received the request from\n  * @param[in]   vRecv           The raw message received\n- * @param[in]   chain_params    Chain parameters\n- * @param[in]   connman         Pointer to the connection manager\n  */\n-static void ProcessGetCFilters(CNode& peer, CDataStream& vRecv, const CChainParams& chain_params,\n-                               CConnman& connman)\n+void PeerManagerImpl::ProcessGetCFilters(CNode& peer, CDataStream& vRecv)\n {\n     uint8_t filter_type_ser;\n     uint32_t start_height;\n@@ -2194,7 +2178,7 @@ static void ProcessGetCFilters(CNode& peer, CDataStream& vRecv, const CChainPara\n \n     const CBlockIndex* stop_index;\n     BlockFilterIndex* filter_index;\n-    if (!PrepareBlockFilterRequest(peer, chain_params, filter_type, start_height, stop_hash,\n+    if (!PrepareBlockFilterRequest(peer, filter_type, start_height, stop_hash,\n                                    MAX_GETCFILTERS_SIZE, stop_index, filter_index)) {\n         return;\n     }\n@@ -2209,7 +2193,7 @@ static void ProcessGetCFilters(CNode& peer, CDataStream& vRecv, const CChainPara\n     for (const auto& filter : filters) {\n         CSerializedNetMsg msg = CNetMsgMaker(peer.GetCommonVersion())\n             .Make(NetMsgType::CFILTER, filter);\n-        connman.PushMessage(&peer, std::move(msg));\n+        m_connman.PushMessage(&peer, std::move(msg));\n     }\n }\n \n@@ -2220,11 +2204,8 @@ static void ProcessGetCFilters(CNode& peer, CDataStream& vRecv, const CChainPara\n  *\n  * @param[in]   peer            The peer that we received the request from\n  * @param[in]   vRecv           The raw message received\n- * @param[in]   chain_params    Chain parameters\n- * @param[in]   connman         Pointer to the connection manager\n  */\n-static void ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv, const CChainParams& chain_params,\n-                                CConnman& connman)\n+void PeerManagerImpl::ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv)\n {\n     uint8_t filter_type_ser;\n     uint32_t start_height;\n@@ -2236,7 +2217,7 @@ static void ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv, const CChainPar\n \n     const CBlockIndex* stop_index;\n     BlockFilterIndex* filter_index;\n-    if (!PrepareBlockFilterRequest(peer, chain_params, filter_type, start_height, stop_hash,\n+    if (!PrepareBlockFilterRequest(peer, filter_type, start_height, stop_hash,\n                                    MAX_GETCFHEADERS_SIZE, stop_index, filter_index)) {\n         return;\n     }\n@@ -2265,7 +2246,7 @@ static void ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv, const CChainPar\n               stop_index->GetBlockHash(),\n               prev_header,\n               filter_hashes);\n-    connman.PushMessage(&peer, std::move(msg));\n+    m_connman.PushMessage(&peer, std::move(msg));\n }\n \n /**\n@@ -2275,11 +2256,8 @@ static void ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv, const CChainPar\n  *\n  * @param[in]   peer            The peer that we received the request from\n  * @param[in]   vRecv           The raw message received\n- * @param[in]   chain_params    Chain parameters\n- * @param[in]   connman         Pointer to the connection manager\n  */\n-static void ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv, const CChainParams& chain_params,\n-                                CConnman& connman)\n+void PeerManagerImpl::ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv)\n {\n     uint8_t filter_type_ser;\n     uint256 stop_hash;\n@@ -2290,7 +2268,7 @@ static void ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv, const CChainPar\n \n     const CBlockIndex* stop_index;\n     BlockFilterIndex* filter_index;\n-    if (!PrepareBlockFilterRequest(peer, chain_params, filter_type, /*start_height=*/0, stop_hash,\n+    if (!PrepareBlockFilterRequest(peer, filter_type, /*start_height=*/0, stop_hash,\n                                    /*max_height_diff=*/std::numeric_limits<uint32_t>::max(),\n                                    stop_index, filter_index)) {\n         return;\n@@ -2316,7 +2294,7 @@ static void ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv, const CChainPar\n               filter_type_ser,\n               stop_index->GetBlockHash(),\n               headers);\n-    connman.PushMessage(&peer, std::move(msg));\n+    m_connman.PushMessage(&peer, std::move(msg));\n }\n \n void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n@@ -2461,7 +2439,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             //\n             // We skip this for block-relay-only peers to avoid potentially leaking\n             // information about our block-relay-only connections via address relay.\n-            if (fListen && !::ChainstateActive().IsInitialBlockDownload())\n+            if (fListen && !m_chainman.ActiveChainstate().IsInitialBlockDownload())\n             {\n                 CAddress addr = GetLocalAddress(&pfrom.addr, pfrom.GetLocalServices());\n                 FastRandomContext insecure_rand;\n@@ -2778,7 +2756,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         }\n \n         if (best_block != nullptr) {\n-            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), *best_block));\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(pindexBestHeader), *best_block));\n             LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, best_block->ToString(), pfrom.GetId());\n         }\n \n@@ -2834,22 +2812,22 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 a_recent_block = most_recent_block;\n             }\n             BlockValidationState state;\n-            if (!::ChainstateActive().ActivateBestChain(state, m_chainparams, a_recent_block)) {\n+            if (!m_chainman.ActiveChainstate().ActivateBestChain(state, m_chainparams, a_recent_block)) {\n                 LogPrint(BCLog::NET, \"failed to activate chain (%s)\\n\", state.ToString());\n             }\n         }\n \n         LOCK(cs_main);\n \n         // Find the last block the caller has in the main chain\n-        const CBlockIndex* pindex = g_chainman.m_blockman.FindForkInGlobalIndex(::ChainActive(), locator);\n+        const CBlockIndex* pindex = m_chainman.m_blockman.FindForkInGlobalIndex(m_chainman.ActiveChain(), locator);\n \n         // Send the rest of the chain\n         if (pindex)\n-            pindex = ::ChainActive().Next(pindex);\n+            pindex = m_chainman.ActiveChain().Next(pindex);\n         int nLimit = 500;\n         LogPrint(BCLog::NET, \"getblocks %d to %s limit %d from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), nLimit, pfrom.GetId());\n-        for (; pindex; pindex = ::ChainActive().Next(pindex))\n+        for (; pindex; pindex = m_chainman.ActiveChain().Next(pindex))\n         {\n             if (pindex->GetBlockHash() == hashStop)\n             {\n@@ -2859,7 +2837,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // If pruning, don't inv blocks unless we have on disk and are likely to still have\n             // for some reasonable time window (1 hour) that block relay might require.\n             const int nPrunedBlocksLikelyToHave = MIN_BLOCKS_TO_KEEP - 3600 / m_chainparams.GetConsensus().nPowTargetSpacing;\n-            if (fPruneMode && (!(pindex->nStatus & BLOCK_HAVE_DATA) || pindex->nHeight <= ::ChainActive().Tip()->nHeight - nPrunedBlocksLikelyToHave))\n+            if (fPruneMode && (!(pindex->nStatus & BLOCK_HAVE_DATA) || pindex->nHeight <= m_chainman.ActiveChain().Tip()->nHeight - nPrunedBlocksLikelyToHave))\n             {\n                 LogPrint(BCLog::NET, \" getblocks stopping, pruned or too old block at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n                 break;\n@@ -2895,13 +2873,13 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         {\n             LOCK(cs_main);\n \n-            const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(req.blockhash);\n+            const CBlockIndex* pindex = m_chainman.m_blockman.LookupBlockIndex(req.blockhash);\n             if (!pindex || !(pindex->nStatus & BLOCK_HAVE_DATA)) {\n                 LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block we don't have\\n\", pfrom.GetId());\n                 return;\n             }\n \n-            if (pindex->nHeight >= ::ChainActive().Height() - MAX_BLOCKTXN_DEPTH) {\n+            if (pindex->nHeight >= m_chainman.ActiveChain().Height() - MAX_BLOCKTXN_DEPTH) {\n                 CBlock block;\n                 bool ret = ReadBlockFromDisk(block, pindex, m_chainparams.GetConsensus());\n                 assert(ret);\n@@ -2939,7 +2917,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         }\n \n         LOCK(cs_main);\n-        if (::ChainstateActive().IsInitialBlockDownload() && !pfrom.HasPermission(PF_DOWNLOAD)) {\n+        if (m_chainman.ActiveChainstate().IsInitialBlockDownload() && !pfrom.HasPermission(PF_DOWNLOAD)) {\n             LogPrint(BCLog::NET, \"Ignoring getheaders from peer=%d because node is in initial block download\\n\", pfrom.GetId());\n             return;\n         }\n@@ -2949,36 +2927,36 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         if (locator.IsNull())\n         {\n             // If locator is null, return the hashStop block\n-            pindex = g_chainman.m_blockman.LookupBlockIndex(hashStop);\n+            pindex = m_chainman.m_blockman.LookupBlockIndex(hashStop);\n             if (!pindex) {\n                 return;\n             }\n \n-            if (!BlockRequestAllowed(pindex, m_chainparams.GetConsensus())) {\n+            if (!BlockRequestAllowed(pindex)) {\n                 LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block header that isn't in the main chain\\n\", __func__, pfrom.GetId());\n                 return;\n             }\n         }\n         else\n         {\n             // Find the last block the caller has in the main chain\n-            pindex = g_chainman.m_blockman.FindForkInGlobalIndex(::ChainActive(), locator);\n+            pindex = m_chainman.m_blockman.FindForkInGlobalIndex(m_chainman.ActiveChain(), locator);\n             if (pindex)\n-                pindex = ::ChainActive().Next(pindex);\n+                pindex = m_chainman.ActiveChain().Next(pindex);\n         }\n \n         // we must use CBlocks, as CBlockHeaders won't include the 0x00 nTx count at the end\n         std::vector<CBlock> vHeaders;\n         int nLimit = MAX_HEADERS_RESULTS;\n         LogPrint(BCLog::NET, \"getheaders %d to %s from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), pfrom.GetId());\n-        for (; pindex; pindex = ::ChainActive().Next(pindex))\n+        for (; pindex; pindex = m_chainman.ActiveChain().Next(pindex))\n         {\n             vHeaders.push_back(pindex->GetBlockHeader());\n             if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)\n                 break;\n         }\n-        // pindex can be nullptr either if we sent ::ChainActive().Tip() OR\n-        // if our peer has ::ChainActive().Tip() (and thus we are sending an empty\n+        // pindex can be nullptr either if we sent m_chainman.ActiveChain().Tip() OR\n+        // if our peer has m_chainman.ActiveChain().Tip() (and thus we are sending an empty\n         // headers message). In both cases it's safe to update\n         // pindexBestHeaderSent to be our tip.\n         //\n@@ -2989,7 +2967,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         // without the new block. By resetting the BestHeaderSent, we ensure we\n         // will re-announce the new block via headers (or compact blocks again)\n         // in the SendMessages logic.\n-        nodestate->pindexBestHeaderSent = pindex ? pindex : ::ChainActive().Tip();\n+        nodestate->pindexBestHeaderSent = pindex ? pindex : m_chainman.ActiveChain().Tip();\n         m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n         return;\n     }\n@@ -3051,13 +3029,13 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     LogPrintf(\"Not relaying non-mempool transaction %s from forcerelay peer=%d\\n\", tx.GetHash().ToString(), pfrom.GetId());\n                 } else {\n                     LogPrintf(\"Force relaying tx %s from peer=%d\\n\", tx.GetHash().ToString(), pfrom.GetId());\n-                    RelayTransaction(tx.GetHash(), tx.GetWitnessHash(), m_connman);\n+                    RelayTransaction(tx.GetHash(), tx.GetWitnessHash());\n                 }\n             }\n             return;\n         }\n \n-        const MempoolAcceptResult result = AcceptToMemoryPool(::ChainstateActive(), m_mempool, ptx, false /* bypass_limits */);\n+        const MempoolAcceptResult result = AcceptToMemoryPool(m_chainman.ActiveChainstate(), m_mempool, ptx, false /* bypass_limits */);\n         const TxValidationState& state = result.m_state;\n \n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n@@ -3066,7 +3044,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // requests for it.\n             m_txrequest.ForgetTxHash(tx.GetHash());\n             m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n-            RelayTransaction(tx.GetHash(), tx.GetWitnessHash(), m_connman);\n+            RelayTransaction(tx.GetHash(), tx.GetWitnessHash());\n             m_orphanage.AddChildrenToWorkSet(tx, peer->m_orphan_work_set);\n \n             pfrom.nLastTXTime = GetTime();\n@@ -3222,14 +3200,14 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         {\n         LOCK(cs_main);\n \n-        if (!g_chainman.m_blockman.LookupBlockIndex(cmpctblock.header.hashPrevBlock)) {\n+        if (!m_chainman.m_blockman.LookupBlockIndex(cmpctblock.header.hashPrevBlock)) {\n             // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n-            if (!::ChainstateActive().IsInitialBlockDownload())\n-                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), uint256()));\n+            if (!m_chainman.ActiveChainstate().IsInitialBlockDownload())\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(pindexBestHeader), uint256()));\n             return;\n         }\n \n-        if (!g_chainman.m_blockman.LookupBlockIndex(cmpctblock.header.GetHash())) {\n+        if (!m_chainman.m_blockman.LookupBlockIndex(cmpctblock.header.GetHash())) {\n             received_new_header = true;\n         }\n         }\n@@ -3269,7 +3247,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         // If this was a new header with more work than our tip, update the\n         // peer's last block announcement time\n-        if (received_new_header && pindex->nChainWork > ::ChainActive().Tip()->nChainWork) {\n+        if (received_new_header && pindex->nChainWork > m_chainman.ActiveChain().Tip()->nChainWork) {\n             nodestate->m_last_block_announcement = GetTime();\n         }\n \n@@ -3279,7 +3257,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         if (pindex->nStatus & BLOCK_HAVE_DATA) // Nothing to do here\n             return;\n \n-        if (pindex->nChainWork <= ::ChainActive().Tip()->nChainWork || // We know something better\n+        if (pindex->nChainWork <= m_chainman.ActiveChain().Tip()->nChainWork || // We know something better\n                 pindex->nTx != 0) { // We had this block at some point, but pruned it\n             if (fAlreadyInFlight) {\n                 // We requested this block for some reason, but our mempool will probably be useless\n@@ -3292,8 +3270,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         }\n \n         // If we're not close to tip yet, give up and let parallel block fetch work its magic\n-        if (!fAlreadyInFlight && !CanDirectFetch(m_chainparams.GetConsensus()))\n+        if (!fAlreadyInFlight && !CanDirectFetch()) {\n             return;\n+        }\n \n         if (IsWitnessEnabled(pindex->pprev, m_chainparams.GetConsensus()) && !nodestate->fSupportsDesiredCmpctVersion) {\n             // Don't bother trying to process compact blocks from v1 peers\n@@ -3303,7 +3282,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         // We want to be a bit conservative just to be extra careful about DoS\n         // possibilities in compact block processing...\n-        if (pindex->nHeight <= ::ChainActive().Height() + 2) {\n+        if (pindex->nHeight <= m_chainman.ActiveChain().Height() + 2) {\n             if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n                  (fAlreadyInFlight && blockInFlightIt->second.first == pfrom.GetId())) {\n                 std::list<QueuedBlock>::iterator* queuedBlockIt = nullptr;\n@@ -3786,17 +3765,17 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n     }\n \n     if (msg_type == NetMsgType::GETCFILTERS) {\n-        ProcessGetCFilters(pfrom, vRecv, m_chainparams, m_connman);\n+        ProcessGetCFilters(pfrom, vRecv);\n         return;\n     }\n \n     if (msg_type == NetMsgType::GETCFHEADERS) {\n-        ProcessGetCFHeaders(pfrom, vRecv, m_chainparams, m_connman);\n+        ProcessGetCFHeaders(pfrom, vRecv);\n         return;\n     }\n \n     if (msg_type == NetMsgType::GETCFCHECKPT) {\n-        ProcessGetCFCheckPt(pfrom, vRecv, m_chainparams, m_connman);\n+        ProcessGetCFCheckPt(pfrom, vRecv);\n         return;\n     }\n \n@@ -3951,7 +3930,7 @@ void PeerManagerImpl::ConsiderEviction(CNode& pto, int64_t time_in_seconds)\n         // their chain has more work than ours, we should sync to it,\n         // unless it's invalid, in which case we should find that out and\n         // disconnect from them elsewhere).\n-        if (state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= ::ChainActive().Tip()->nChainWork) {\n+        if (state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= m_chainman.ActiveChain().Tip()->nChainWork) {\n             if (state.m_chain_sync.m_timeout != 0) {\n                 state.m_chain_sync.m_timeout = 0;\n                 state.m_chain_sync.m_work_header = nullptr;\n@@ -3963,7 +3942,7 @@ void PeerManagerImpl::ConsiderEviction(CNode& pto, int64_t time_in_seconds)\n             // where we checked against our tip.\n             // Either way, set a new timeout based on current tip.\n             state.m_chain_sync.m_timeout = time_in_seconds + CHAIN_SYNC_TIMEOUT;\n-            state.m_chain_sync.m_work_header = ::ChainActive().Tip();\n+            state.m_chain_sync.m_work_header = m_chainman.ActiveChain().Tip();\n             state.m_chain_sync.m_sent_getheaders = false;\n         } else if (state.m_chain_sync.m_timeout > 0 && time_in_seconds > state.m_chain_sync.m_timeout) {\n             // No evidence yet that our peer has synced to a chain with work equal to that\n@@ -3976,7 +3955,7 @@ void PeerManagerImpl::ConsiderEviction(CNode& pto, int64_t time_in_seconds)\n             } else {\n                 assert(state.m_chain_sync.m_work_header);\n                 LogPrint(BCLog::NET, \"sending getheaders to outbound peer=%d to verify chain work (current best known block:%s, benchmark blockhash: %s)\\n\", pto.GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\", state.m_chain_sync.m_work_header->GetBlockHash().ToString());\n-                m_connman.PushMessage(&pto, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(state.m_chain_sync.m_work_header->pprev), uint256()));\n+                m_connman.PushMessage(&pto, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(state.m_chain_sync.m_work_header->pprev), uint256()));\n                 state.m_chain_sync.m_sent_getheaders = true;\n                 constexpr int64_t HEADERS_RESPONSE_TIME = 120; // 2 minutes\n                 // Bump the timeout to allow a response, which could clear the timeout\n@@ -4111,7 +4090,7 @@ void PeerManagerImpl::CheckForStaleTipAndEvictPeers()\n         m_stale_tip_check_time = time_in_seconds + STALE_CHECK_INTERVAL;\n     }\n \n-    if (!m_initial_sync_finished && CanDirectFetch(m_chainparams.GetConsensus())) {\n+    if (!m_initial_sync_finished && CanDirectFetch()) {\n         m_connman.StartExtraBlockRelayPeers();\n         m_initial_sync_finished = true;\n     }\n@@ -4213,7 +4192,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         auto current_time = GetTime<std::chrono::microseconds>();\n \n         if (fListen && pto->RelayAddrsWithConn() &&\n-            !::ChainstateActive().IsInitialBlockDownload() &&\n+            !m_chainman.ActiveChainstate().IsInitialBlockDownload() &&\n             pto->m_next_local_addr_send < current_time) {\n             // If we've sent before, clear the bloom filter for the peer, so that our\n             // self-announcement will actually go out.\n@@ -4224,7 +4203,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n             if (pto->m_next_local_addr_send != 0us) {\n                 pto->m_addr_known->reset();\n             }\n-            if (Optional<CAddress> local_addr = GetLocalAddrForPeer(pto)) {\n+            if (std::optional<CAddress> local_addr = GetLocalAddrForPeer(pto)) {\n                 FastRandomContext insecure_rand;\n                 pto->PushAddress(*local_addr, insecure_rand);\n             }\n@@ -4274,7 +4253,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n \n         // Start block sync\n         if (pindexBestHeader == nullptr)\n-            pindexBestHeader = ::ChainActive().Tip();\n+            pindexBestHeader = m_chainman.ActiveChain().Tip();\n         bool fFetch = state.fPreferredDownload || (nPreferredDownload == 0 && !pto->fClient && !pto->IsAddrFetchConn()); // Download if this is a nice peer, or we have no nice peers and this one might do.\n         if (!state.fSyncStarted && !pto->fClient && !fImporting && !fReindex) {\n             // Only actively request headers from a single peer, unless we're close to today.\n@@ -4299,7 +4278,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 if (pindexStart->pprev)\n                     pindexStart = pindexStart->pprev;\n                 LogPrint(BCLog::NET, \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->GetId(), peer->m_starting_height);\n-                m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexStart), uint256()));\n+                m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(pindexStart), uint256()));\n             }\n         }\n \n@@ -4326,11 +4305,11 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 bool fFoundStartingHeader = false;\n                 // Try to find first header that our peer doesn't have, and\n                 // then send all headers past that one.  If we come across any\n-                // headers that aren't on ::ChainActive(), give up.\n+                // headers that aren't on m_chainman.ActiveChain(), give up.\n                 for (const uint256& hash : peer->m_blocks_for_headers_relay) {\n-                    const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(hash);\n+                    const CBlockIndex* pindex = m_chainman.m_blockman.LookupBlockIndex(hash);\n                     assert(pindex);\n-                    if (::ChainActive()[pindex->nHeight] != pindex) {\n+                    if (m_chainman.ActiveChain()[pindex->nHeight] != pindex) {\n                         // Bail out if we reorged away from this block\n                         fRevertToInv = true;\n                         break;\n@@ -4420,15 +4399,15 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 // in the past.\n                 if (!peer->m_blocks_for_headers_relay.empty()) {\n                     const uint256& hashToAnnounce = peer->m_blocks_for_headers_relay.back();\n-                    const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(hashToAnnounce);\n+                    const CBlockIndex* pindex = m_chainman.m_blockman.LookupBlockIndex(hashToAnnounce);\n                     assert(pindex);\n \n                     // Warn if we're announcing a block that is not on the main chain.\n                     // This should be very rare and could be optimized out.\n                     // Just log for now.\n-                    if (::ChainActive()[pindex->nHeight] != pindex) {\n+                    if (m_chainman.ActiveChain()[pindex->nHeight] != pindex) {\n                         LogPrint(BCLog::NET, \"Announcing block %s not on main chain (tip=%s)\\n\",\n-                            hashToAnnounce.ToString(), ::ChainActive().Tip()->GetBlockHash().ToString());\n+                            hashToAnnounce.ToString(), m_chainman.ActiveChain().Tip()->GetBlockHash().ToString());\n                     }\n \n                     // If the peer's chain has this block, don't inv it back.\n@@ -4658,7 +4637,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         // Message: getdata (blocks)\n         //\n         std::vector<CInv> vGetData;\n-        if (!pto->fClient && ((fFetch && !pto->m_limited_node) || !::ChainstateActive().IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+        if (!pto->fClient && ((fFetch && !pto->m_limited_node) || !m_chainman.ActiveChainstate().IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             std::vector<const CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n             FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller);\n@@ -4747,4 +4726,3 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n     } // release cs_main\n     return true;\n }\n-"
      },
      {
        "sha": "f6f2d73721ddac5d0c50c509992e4d084af379d0",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -47,6 +47,10 @@ class PeerManager : public CValidationInterface, public NetEventsInterface\n     /** Whether this node ignores txs received over p2p. */\n     virtual bool IgnoresIncomingTxs() = 0;\n \n+    /** Relay transaction to all peers. */\n+    virtual void RelayTransaction(const uint256& txid, const uint256& wtxid)\n+        EXCLUSIVE_LOCKS_REQUIRED(cs_main) = 0;\n+\n     /** Send ping message to all peers */\n     virtual void SendPings() = 0;\n \n@@ -71,7 +75,4 @@ class PeerManager : public CValidationInterface, public NetEventsInterface\n                                 const std::chrono::microseconds time_received, const std::atomic<bool>& interruptMsgProc) = 0;\n };\n \n-/** Relay transaction to every node */\n-void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman& connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n #endif // BITCOIN_NET_PROCESSING_H"
      },
      {
        "sha": "49e455aa84895dd896addbe7eab07ab6d0bff160",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 66,
        "deletions": 189,
        "changes": 255,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -42,6 +42,50 @@ bool fNameLookup = DEFAULT_NAME_LOOKUP;\n int g_socks5_recv_timeout = 20 * 1000;\n static std::atomic<bool> interruptSocks5Recv(false);\n \n+std::vector<CNetAddr> WrappedGetAddrInfo(const std::string& name, bool allow_lookup)\n+{\n+    addrinfo ai_hint{};\n+    // We want a TCP port, which is a streaming socket type\n+    ai_hint.ai_socktype = SOCK_STREAM;\n+    ai_hint.ai_protocol = IPPROTO_TCP;\n+    // We don't care which address family (IPv4 or IPv6) is returned\n+    ai_hint.ai_family = AF_UNSPEC;\n+    // If we allow lookups of hostnames, use the AI_ADDRCONFIG flag to only\n+    // return addresses whose family we have an address configured for.\n+    //\n+    // If we don't allow lookups, then use the AI_NUMERICHOST flag for\n+    // getaddrinfo to only decode numerical network addresses and suppress\n+    // hostname lookups.\n+    ai_hint.ai_flags = allow_lookup ? AI_ADDRCONFIG : AI_NUMERICHOST;\n+\n+    addrinfo* ai_res{nullptr};\n+    const int n_err{getaddrinfo(name.c_str(), nullptr, &ai_hint, &ai_res)};\n+    if (n_err != 0) {\n+        return {};\n+    }\n+\n+    // Traverse the linked list starting with ai_trav.\n+    addrinfo* ai_trav{ai_res};\n+    std::vector<CNetAddr> resolved_addresses;\n+    while (ai_trav != nullptr) {\n+        if (ai_trav->ai_family == AF_INET) {\n+            assert(ai_trav->ai_addrlen >= sizeof(sockaddr_in));\n+            resolved_addresses.emplace_back(reinterpret_cast<sockaddr_in*>(ai_trav->ai_addr)->sin_addr);\n+        }\n+        if (ai_trav->ai_family == AF_INET6) {\n+            assert(ai_trav->ai_addrlen >= sizeof(sockaddr_in6));\n+            const sockaddr_in6* s6{reinterpret_cast<sockaddr_in6*>(ai_trav->ai_addr)};\n+            resolved_addresses.emplace_back(s6->sin6_addr, s6->sin6_scope_id);\n+        }\n+        ai_trav = ai_trav->ai_next;\n+    }\n+    freeaddrinfo(ai_res);\n+\n+    return resolved_addresses;\n+}\n+\n+DNSLookupFn g_dns_lookup{WrappedGetAddrInfo};\n+\n enum Network ParseNetwork(const std::string& net_in) {\n     std::string net = ToLower(net_in);\n     if (net == \"ipv4\") return NET_IPV4;\n@@ -87,7 +131,7 @@ std::vector<std::string> GetNetworkNames(bool append_unroutable)\n     return names;\n }\n \n-bool static LookupIntern(const std::string& name, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n+static bool LookupIntern(const std::string& name, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup, DNSLookupFn dns_lookup_function)\n {\n     vIP.clear();\n \n@@ -109,73 +153,20 @@ bool static LookupIntern(const std::string& name, std::vector<CNetAddr>& vIP, un\n         }\n     }\n \n-    struct addrinfo aiHint;\n-    memset(&aiHint, 0, sizeof(struct addrinfo));\n-\n-    // We want a TCP port, which is a streaming socket type\n-    aiHint.ai_socktype = SOCK_STREAM;\n-    aiHint.ai_protocol = IPPROTO_TCP;\n-    // We don't care which address family (IPv4 or IPv6) is returned\n-    aiHint.ai_family = AF_UNSPEC;\n-    // If we allow lookups of hostnames, use the AI_ADDRCONFIG flag to only\n-    // return addresses whose family we have an address configured for.\n-    //\n-    // If we don't allow lookups, then use the AI_NUMERICHOST flag for\n-    // getaddrinfo to only decode numerical network addresses and suppress\n-    // hostname lookups.\n-    aiHint.ai_flags = fAllowLookup ? AI_ADDRCONFIG : AI_NUMERICHOST;\n-    struct addrinfo *aiRes = nullptr;\n-    int nErr = getaddrinfo(name.c_str(), nullptr, &aiHint, &aiRes);\n-    if (nErr)\n-        return false;\n-\n-    // Traverse the linked list starting with aiTrav, add all non-internal\n-    // IPv4,v6 addresses to vIP while respecting nMaxSolutions.\n-    struct addrinfo *aiTrav = aiRes;\n-    while (aiTrav != nullptr && (nMaxSolutions == 0 || vIP.size() < nMaxSolutions))\n-    {\n-        CNetAddr resolved;\n-        if (aiTrav->ai_family == AF_INET)\n-        {\n-            assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in));\n-            resolved = CNetAddr(((struct sockaddr_in*)(aiTrav->ai_addr))->sin_addr);\n-        }\n-\n-        if (aiTrav->ai_family == AF_INET6)\n-        {\n-            assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in6));\n-            struct sockaddr_in6* s6 = (struct sockaddr_in6*) aiTrav->ai_addr;\n-            resolved = CNetAddr(s6->sin6_addr, s6->sin6_scope_id);\n+    for (const CNetAddr& resolved : dns_lookup_function(name, fAllowLookup)) {\n+        if (nMaxSolutions > 0 && vIP.size() >= nMaxSolutions) {\n+            break;\n         }\n         /* Never allow resolving to an internal address. Consider any such result invalid */\n         if (!resolved.IsInternal()) {\n             vIP.push_back(resolved);\n         }\n-\n-        aiTrav = aiTrav->ai_next;\n     }\n \n-    freeaddrinfo(aiRes);\n-\n     return (vIP.size() > 0);\n }\n \n-/**\n- * Resolve a host string to its corresponding network addresses.\n- *\n- * @param name    The string representing a host. Could be a name or a numerical\n- *                IP address (IPv6 addresses in their bracketed form are\n- *                allowed).\n- * @param[out] vIP The resulting network addresses to which the specified host\n- *                 string resolved.\n- *\n- * @returns Whether or not the specified host string successfully resolved to\n- *          any resulting network addresses.\n- *\n- * @see Lookup(const char *, std::vector<CService>&, int, bool, unsigned int)\n- *      for additional parameter descriptions.\n- */\n-bool LookupHost(const std::string& name, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n+bool LookupHost(const std::string& name, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup, DNSLookupFn dns_lookup_function)\n {\n     if (!ValidAsCString(name)) {\n         return false;\n@@ -187,59 +178,33 @@ bool LookupHost(const std::string& name, std::vector<CNetAddr>& vIP, unsigned in\n         strHost = strHost.substr(1, strHost.size() - 2);\n     }\n \n-    return LookupIntern(strHost, vIP, nMaxSolutions, fAllowLookup);\n+    return LookupIntern(strHost, vIP, nMaxSolutions, fAllowLookup, dns_lookup_function);\n }\n \n- /**\n- * Resolve a host string to its first corresponding network address.\n- *\n- * @see LookupHost(const std::string&, std::vector<CNetAddr>&, unsigned int, bool) for\n- *      additional parameter descriptions.\n- */\n-bool LookupHost(const std::string& name, CNetAddr& addr, bool fAllowLookup)\n+bool LookupHost(const std::string& name, CNetAddr& addr, bool fAllowLookup, DNSLookupFn dns_lookup_function)\n {\n     if (!ValidAsCString(name)) {\n         return false;\n     }\n     std::vector<CNetAddr> vIP;\n-    LookupHost(name, vIP, 1, fAllowLookup);\n+    LookupHost(name, vIP, 1, fAllowLookup, dns_lookup_function);\n     if(vIP.empty())\n         return false;\n     addr = vIP.front();\n     return true;\n }\n \n-/**\n- * Resolve a service string to its corresponding service.\n- *\n- * @param name    The string representing a service. Could be a name or a\n- *                numerical IP address (IPv6 addresses should be in their\n- *                disambiguated bracketed form), optionally followed by a port\n- *                number. (e.g. example.com:8333 or\n- *                [2001:db8:85a3:8d3:1319:8a2e:370:7348]:420)\n- * @param[out] vAddr The resulting services to which the specified service string\n- *                   resolved.\n- * @param portDefault The default port for resulting services if not specified\n- *                    by the service string.\n- * @param fAllowLookup Whether or not hostname lookups are permitted. If yes,\n- *                     external queries may be performed.\n- * @param nMaxSolutions The maximum number of results we want, specifying 0\n- *                      means \"as many solutions as we get.\"\n- *\n- * @returns Whether or not the service string successfully resolved to any\n- *          resulting services.\n- */\n-bool Lookup(const std::string& name, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions)\n+bool Lookup(const std::string& name, std::vector<CService>& vAddr, uint16_t portDefault, bool fAllowLookup, unsigned int nMaxSolutions, DNSLookupFn dns_lookup_function)\n {\n     if (name.empty() || !ValidAsCString(name)) {\n         return false;\n     }\n-    int port = portDefault;\n+    uint16_t port{portDefault};\n     std::string hostname;\n     SplitHostPort(name, port, hostname);\n \n     std::vector<CNetAddr> vIP;\n-    bool fRet = LookupIntern(hostname, vIP, nMaxSolutions, fAllowLookup);\n+    bool fRet = LookupIntern(hostname, vIP, nMaxSolutions, fAllowLookup, dns_lookup_function);\n     if (!fRet)\n         return false;\n     vAddr.resize(vIP.size());\n@@ -248,44 +213,28 @@ bool Lookup(const std::string& name, std::vector<CService>& vAddr, int portDefau\n     return true;\n }\n \n-/**\n- * Resolve a service string to its first corresponding service.\n- *\n- * @see Lookup(const char *, std::vector<CService>&, int, bool, unsigned int)\n- *      for additional parameter descriptions.\n- */\n-bool Lookup(const std::string& name, CService& addr, int portDefault, bool fAllowLookup)\n+bool Lookup(const std::string& name, CService& addr, uint16_t portDefault, bool fAllowLookup, DNSLookupFn dns_lookup_function)\n {\n     if (!ValidAsCString(name)) {\n         return false;\n     }\n     std::vector<CService> vService;\n-    bool fRet = Lookup(name, vService, portDefault, fAllowLookup, 1);\n+    bool fRet = Lookup(name, vService, portDefault, fAllowLookup, 1, dns_lookup_function);\n     if (!fRet)\n         return false;\n     addr = vService[0];\n     return true;\n }\n \n-/**\n- * Resolve a service string with a numeric IP to its first corresponding\n- * service.\n- *\n- * @returns The resulting CService if the resolution was successful, [::]:0\n- *          otherwise.\n- *\n- * @see Lookup(const char *, CService&, int, bool) for additional parameter\n- *      descriptions.\n- */\n-CService LookupNumeric(const std::string& name, int portDefault)\n+CService LookupNumeric(const std::string& name, uint16_t portDefault, DNSLookupFn dns_lookup_function)\n {\n     if (!ValidAsCString(name)) {\n         return {};\n     }\n     CService addr;\n     // \"1.2:345\" will fail to resolve the ip, but will still set the port.\n     // If the ip fails to resolve, re-init the result.\n-    if(!Lookup(name, addr, portDefault, false))\n+    if(!Lookup(name, addr, portDefault, false, dns_lookup_function))\n         addr = CService();\n     return addr;\n }\n@@ -414,25 +363,7 @@ static std::string Socks5ErrorString(uint8_t err)\n     }\n }\n \n-/**\n- * Connect to a specified destination service through an already connected\n- * SOCKS5 proxy.\n- *\n- * @param strDest The destination fully-qualified domain name.\n- * @param port The destination port.\n- * @param auth The credentials with which to authenticate with the specified\n- *             SOCKS5 proxy.\n- * @param sock The SOCKS5 proxy socket.\n- *\n- * @returns Whether or not the operation succeeded.\n- *\n- * @note The specified SOCKS5 proxy socket must already be connected to the\n- *       SOCKS5 proxy.\n- *\n- * @see <a href=\"https://www.ietf.org/rfc/rfc1928.txt\">RFC1928: SOCKS Protocol\n- *      Version 5</a>\n- */\n-bool Socks5(const std::string& strDest, int port, const ProxyCredentials* auth, const Sock& sock)\n+bool Socks5(const std::string& strDest, uint16_t port, const ProxyCredentials* auth, const Sock& sock)\n {\n     IntrRecvError recvr;\n     LogPrint(BCLog::NET, \"SOCKS5 connecting %s\\n\", strDest);\n@@ -606,18 +537,6 @@ static void LogConnectFailure(bool manual_connection, const char* fmt, const Arg\n     }\n }\n \n-/**\n- * Try to connect to the specified service on the specified socket.\n- *\n- * @param addrConnect The service to which to connect.\n- * @param hSocket The socket on which to connect.\n- * @param nTimeout Wait this many milliseconds for the connection to be\n- *                 established.\n- * @param manual_connection Whether or not the connection was manually requested\n- *                          (e.g. through the addnode RPC)\n- *\n- * @returns Whether or not a connection was successfully made.\n- */\n bool ConnectSocketDirectly(const CService &addrConnect, const SOCKET& hSocket, int nTimeout, bool manual_connection)\n {\n     // Create a sockaddr from the specified service.\n@@ -716,22 +635,6 @@ bool GetProxy(enum Network net, proxyType &proxyInfoOut) {\n     return true;\n }\n \n-/**\n- * Set the name proxy to use for all connections to nodes specified by a\n- * hostname. After setting this proxy, connecting to a node specified by a\n- * hostname won't result in a local lookup of said hostname, rather, connect to\n- * the node by asking the name proxy for a proxy connection to the hostname,\n- * effectively delegating the hostname lookup to the specified proxy.\n- *\n- * This delegation increases privacy for those who set the name proxy as they no\n- * longer leak their external hostname queries to their DNS servers.\n- *\n- * @returns Whether or not the operation succeeded.\n- *\n- * @note SOCKS5's support for UDP-over-SOCKS5 has been considered, but no SOCK5\n- *       server in common use (most notably Tor) actually implements UDP\n- *       support, and a DNS resolver is beyond the scope of this project.\n- */\n bool SetNameProxy(const proxyType &addrProxy) {\n     if (!addrProxy.IsValid())\n         return false;\n@@ -762,22 +665,7 @@ bool IsProxy(const CNetAddr &addr) {\n     return false;\n }\n \n-/**\n- * Connect to a specified destination service through a SOCKS5 proxy by first\n- * connecting to the SOCKS5 proxy.\n- *\n- * @param proxy The SOCKS5 proxy.\n- * @param strDest The destination service to which to connect.\n- * @param port The destination port.\n- * @param sock The socket on which to connect to the SOCKS5 proxy.\n- * @param nTimeout Wait this many milliseconds for the connection to the SOCKS5\n- *                 proxy to be established.\n- * @param[out] outProxyConnectionFailed Whether or not the connection to the\n- *                                      SOCKS5 proxy failed.\n- *\n- * @returns Whether or not the operation succeeded.\n- */\n-bool ConnectThroughProxy(const proxyType& proxy, const std::string& strDest, int port, const Sock& sock, int nTimeout, bool& outProxyConnectionFailed)\n+bool ConnectThroughProxy(const proxyType& proxy, const std::string& strDest, uint16_t port, const Sock& sock, int nTimeout, bool& outProxyConnectionFailed)\n {\n     // first connect to proxy server\n     if (!ConnectSocketDirectly(proxy.proxy, sock.Get(), nTimeout, true)) {\n@@ -789,29 +677,18 @@ bool ConnectThroughProxy(const proxyType& proxy, const std::string& strDest, int\n         ProxyCredentials random_auth;\n         static std::atomic_int counter(0);\n         random_auth.username = random_auth.password = strprintf(\"%i\", counter++);\n-        if (!Socks5(strDest, (uint16_t)port, &random_auth, sock)) {\n+        if (!Socks5(strDest, port, &random_auth, sock)) {\n             return false;\n         }\n     } else {\n-        if (!Socks5(strDest, (uint16_t)port, 0, sock)) {\n+        if (!Socks5(strDest, port, 0, sock)) {\n             return false;\n         }\n     }\n     return true;\n }\n \n-/**\n- * Parse and resolve a specified subnet string into the appropriate internal\n- * representation.\n- *\n- * @param strSubnet A string representation of a subnet of the form `network\n- *                address [ \"/\", ( CIDR-style suffix | netmask ) ]`(e.g.\n- *                `2001:db8::/32`, `192.0.2.0/255.255.255.0`, or `8.8.8.8`).\n- * @param ret The resulting internal representation of a subnet.\n- *\n- * @returns Whether the operation succeeded or not.\n- */\n-bool LookupSubNet(const std::string& strSubnet, CSubNet& ret)\n+bool LookupSubNet(const std::string& strSubnet, CSubNet& ret, DNSLookupFn dns_lookup_function)\n {\n     if (!ValidAsCString(strSubnet)) {\n         return false;\n@@ -822,7 +699,7 @@ bool LookupSubNet(const std::string& strSubnet, CSubNet& ret)\n     std::string strAddress = strSubnet.substr(0, slash);\n     // TODO: Use LookupHost(const std::string&, CNetAddr&, bool) instead to just get\n     //       one CNetAddr.\n-    if (LookupHost(strAddress, vIP, 1, false))\n+    if (LookupHost(strAddress, vIP, 1, false, dns_lookup_function))\n     {\n         CNetAddr network = vIP[0];\n         if (slash != strSubnet.npos)\n@@ -837,7 +714,7 @@ bool LookupSubNet(const std::string& strSubnet, CSubNet& ret)\n             else // If not a valid number, try full netmask syntax\n             {\n                 // Never allow lookup for netmask\n-                if (LookupHost(strNetmask, vIP, 1, false)) {\n+                if (LookupHost(strNetmask, vIP, 1, false, dns_lookup_function)) {\n                     ret = CSubNet(network, vIP[0]);\n                     return ret.IsValid();\n                 }"
      },
      {
        "sha": "08172b9984fb92bde4f00306d0b679a455d3af88",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 153,
        "deletions": 9,
        "changes": 162,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -64,22 +64,119 @@ struct ProxyCredentials\n     std::string password;\n };\n \n+/**\n+ * Wrapper for getaddrinfo(3). Do not use directly: call Lookup/LookupHost/LookupNumeric/LookupSubNet.\n+ */\n+std::vector<CNetAddr> WrappedGetAddrInfo(const std::string& name, bool allow_lookup);\n+\n enum Network ParseNetwork(const std::string& net);\n std::string GetNetworkName(enum Network net);\n /** Return a vector of publicly routable Network names; optionally append NET_UNROUTABLE. */\n std::vector<std::string> GetNetworkNames(bool append_unroutable = false);\n bool SetProxy(enum Network net, const proxyType &addrProxy);\n bool GetProxy(enum Network net, proxyType &proxyInfoOut);\n bool IsProxy(const CNetAddr &addr);\n+/**\n+ * Set the name proxy to use for all connections to nodes specified by a\n+ * hostname. After setting this proxy, connecting to a node specified by a\n+ * hostname won't result in a local lookup of said hostname, rather, connect to\n+ * the node by asking the name proxy for a proxy connection to the hostname,\n+ * effectively delegating the hostname lookup to the specified proxy.\n+ *\n+ * This delegation increases privacy for those who set the name proxy as they no\n+ * longer leak their external hostname queries to their DNS servers.\n+ *\n+ * @returns Whether or not the operation succeeded.\n+ *\n+ * @note SOCKS5's support for UDP-over-SOCKS5 has been considered, but no SOCK5\n+ *       server in common use (most notably Tor) actually implements UDP\n+ *       support, and a DNS resolver is beyond the scope of this project.\n+ */\n bool SetNameProxy(const proxyType &addrProxy);\n bool HaveNameProxy();\n bool GetNameProxy(proxyType &nameProxyOut);\n-bool LookupHost(const std::string& name, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup);\n-bool LookupHost(const std::string& name, CNetAddr& addr, bool fAllowLookup);\n-bool Lookup(const std::string& name, CService& addr, int portDefault, bool fAllowLookup);\n-bool Lookup(const std::string& name, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions);\n-CService LookupNumeric(const std::string& name, int portDefault = 0);\n-bool LookupSubNet(const std::string& strSubnet, CSubNet& subnet);\n+\n+using DNSLookupFn = std::function<std::vector<CNetAddr>(const std::string&, bool)>;\n+extern DNSLookupFn g_dns_lookup;\n+\n+/**\n+ * Resolve a host string to its corresponding network addresses.\n+ *\n+ * @param name    The string representing a host. Could be a name or a numerical\n+ *                IP address (IPv6 addresses in their bracketed form are\n+ *                allowed).\n+ * @param[out] vIP The resulting network addresses to which the specified host\n+ *                 string resolved.\n+ *\n+ * @returns Whether or not the specified host string successfully resolved to\n+ *          any resulting network addresses.\n+ *\n+ * @see Lookup(const std::string&, std::vector<CService>&, uint16_t, bool, unsigned int, DNSLookupFn)\n+ *      for additional parameter descriptions.\n+ */\n+bool LookupHost(const std::string& name, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup, DNSLookupFn dns_lookup_function = g_dns_lookup);\n+\n+/**\n+ * Resolve a host string to its first corresponding network address.\n+ *\n+ * @see LookupHost(const std::string&, std::vector<CNetAddr>&, uint16_t, bool, DNSLookupFn)\n+ *      for additional parameter descriptions.\n+ */\n+bool LookupHost(const std::string& name, CNetAddr& addr, bool fAllowLookup, DNSLookupFn dns_lookup_function = g_dns_lookup);\n+\n+/**\n+ * Resolve a service string to its corresponding service.\n+ *\n+ * @param name    The string representing a service. Could be a name or a\n+ *                numerical IP address (IPv6 addresses should be in their\n+ *                disambiguated bracketed form), optionally followed by a uint16_t port\n+ *                number. (e.g. example.com:8333 or\n+ *                [2001:db8:85a3:8d3:1319:8a2e:370:7348]:420)\n+ * @param[out] vAddr The resulting services to which the specified service string\n+ *                   resolved.\n+ * @param portDefault The default port for resulting services if not specified\n+ *                    by the service string.\n+ * @param fAllowLookup Whether or not hostname lookups are permitted. If yes,\n+ *                     external queries may be performed.\n+ * @param nMaxSolutions The maximum number of results we want, specifying 0\n+ *                      means \"as many solutions as we get.\"\n+ *\n+ * @returns Whether or not the service string successfully resolved to any\n+ *          resulting services.\n+ */\n+bool Lookup(const std::string& name, std::vector<CService>& vAddr, uint16_t portDefault, bool fAllowLookup, unsigned int nMaxSolutions, DNSLookupFn dns_lookup_function = g_dns_lookup);\n+\n+/**\n+ * Resolve a service string to its first corresponding service.\n+ *\n+ * @see Lookup(const std::string&, std::vector<CService>&, uint16_t, bool, unsigned int, DNSLookupFn)\n+ *      for additional parameter descriptions.\n+ */\n+bool Lookup(const std::string& name, CService& addr, uint16_t portDefault, bool fAllowLookup, DNSLookupFn dns_lookup_function = g_dns_lookup);\n+\n+/**\n+ * Resolve a service string with a numeric IP to its first corresponding\n+ * service.\n+ *\n+ * @returns The resulting CService if the resolution was successful, [::]:0 otherwise.\n+ *\n+ * @see Lookup(const std::string&, std::vector<CService>&, uint16_t, bool, unsigned int, DNSLookupFn)\n+ *      for additional parameter descriptions.\n+ */\n+CService LookupNumeric(const std::string& name, uint16_t portDefault = 0, DNSLookupFn dns_lookup_function = g_dns_lookup);\n+\n+/**\n+ * Parse and resolve a specified subnet string into the appropriate internal\n+ * representation.\n+ *\n+ * @param strSubnet A string representation of a subnet of the form `network\n+ *                address [ \"/\", ( CIDR-style suffix | netmask ) ]`(e.g.\n+ *                `2001:db8::/32`, `192.0.2.0/255.255.255.0`, or `8.8.8.8`).\n+ * @param ret The resulting internal representation of a subnet.\n+ *\n+ * @returns Whether the operation succeeded or not.\n+ */\n+bool LookupSubNet(const std::string& strSubnet, CSubNet& subnet, DNSLookupFn dns_lookup_function = g_dns_lookup);\n \n /**\n  * Create a TCP socket in the given address family.\n@@ -93,14 +190,61 @@ std::unique_ptr<Sock> CreateSockTCP(const CService& address_family);\n  */\n extern std::function<std::unique_ptr<Sock>(const CService&)> CreateSock;\n \n-bool ConnectSocketDirectly(const CService &addrConnect, const SOCKET& hSocketRet, int nTimeout, bool manual_connection);\n-bool ConnectThroughProxy(const proxyType& proxy, const std::string& strDest, int port, const Sock& sock, int nTimeout, bool& outProxyConnectionFailed);\n+/**\n+ * Try to connect to the specified service on the specified socket.\n+ *\n+ * @param addrConnect The service to which to connect.\n+ * @param hSocket The socket on which to connect.\n+ * @param nTimeout Wait this many milliseconds for the connection to be\n+ *                 established.\n+ * @param manual_connection Whether or not the connection was manually requested\n+ *                          (e.g. through the addnode RPC)\n+ *\n+ * @returns Whether or not a connection was successfully made.\n+ */\n+bool ConnectSocketDirectly(const CService &addrConnect, const SOCKET& hSocket, int nTimeout, bool manual_connection);\n+\n+/**\n+ * Connect to a specified destination service through a SOCKS5 proxy by first\n+ * connecting to the SOCKS5 proxy.\n+ *\n+ * @param proxy The SOCKS5 proxy.\n+ * @param strDest The destination service to which to connect.\n+ * @param port The destination port.\n+ * @param sock The socket on which to connect to the SOCKS5 proxy.\n+ * @param nTimeout Wait this many milliseconds for the connection to the SOCKS5\n+ *                 proxy to be established.\n+ * @param[out] outProxyConnectionFailed Whether or not the connection to the\n+ *                                      SOCKS5 proxy failed.\n+ *\n+ * @returns Whether or not the operation succeeded.\n+ */\n+bool ConnectThroughProxy(const proxyType& proxy, const std::string& strDest, uint16_t port, const Sock& sock, int nTimeout, bool& outProxyConnectionFailed);\n+\n /** Disable or enable blocking-mode for a socket */\n bool SetSocketNonBlocking(const SOCKET& hSocket, bool fNonBlocking);\n /** Set the TCP_NODELAY flag on a socket */\n bool SetSocketNoDelay(const SOCKET& hSocket);\n void InterruptSocks5(bool interrupt);\n \n-bool Socks5(const std::string& strDest, int port, const ProxyCredentials* auth, const Sock& socket);\n+/**\n+ * Connect to a specified destination service through an already connected\n+ * SOCKS5 proxy.\n+ *\n+ * @param strDest The destination fully-qualified domain name.\n+ * @param port The destination port.\n+ * @param auth The credentials with which to authenticate with the specified\n+ *             SOCKS5 proxy.\n+ * @param sock The SOCKS5 proxy socket.\n+ *\n+ * @returns Whether or not the operation succeeded.\n+ *\n+ * @note The specified SOCKS5 proxy socket must already be connected to the\n+ *       SOCKS5 proxy.\n+ *\n+ * @see <a href=\"https://www.ietf.org/rfc/rfc1928.txt\">RFC1928: SOCKS Protocol\n+ *      Version 5</a>\n+ */\n+bool Socks5(const std::string& strDest, uint16_t port, const ProxyCredentials* auth, const Sock& socket);\n \n #endif // BITCOIN_NETBASE_H"
      },
      {
        "sha": "263dcff6570b86f6c193d647ff2b93b3c0458209",
        "filename": "src/node/coin.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/node/coin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/node/coin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coin.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -12,7 +12,8 @@ void FindCoins(const NodeContext& node, std::map<COutPoint, Coin>& coins)\n {\n     assert(node.mempool);\n     LOCK2(cs_main, node.mempool->cs);\n-    CCoinsViewCache& chain_view = ::ChainstateActive().CoinsTip();\n+    assert(std::addressof(::ChainstateActive()) == std::addressof(node.chainman->ActiveChainstate()));\n+    CCoinsViewCache& chain_view = node.chainman->ActiveChainstate().CoinsTip();\n     CCoinsViewMemPool mempool_view(&chain_view, *node.mempool);\n     for (auto& coin : coins) {\n         if (!mempool_view.GetCoin(coin.first, coin.second)) {"
      },
      {
        "sha": "268580c6e60d8527c1c1dfbe4b079e508d14dea7",
        "filename": "src/node/coinstats.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/node/coinstats.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/node/coinstats.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coinstats.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -15,6 +15,7 @@\n \n #include <map>\n \n+// Database-independent metric indicating the UTXO set size\n static uint64_t GetBogoSize(const CScript& scriptPubKey)\n {\n     return 32 /* txid */ +\n@@ -83,7 +84,7 @@ static void ApplyStats(CCoinsStats& stats, T& hash_obj, const uint256& hash, con\n \n //! Calculate statistics about the unspent transaction output set\n template <typename T>\n-static bool GetUTXOStats(CCoinsView* view, CCoinsStats& stats, T hash_obj, const std::function<void()>& interruption_point)\n+static bool GetUTXOStats(CCoinsView* view, BlockManager& blockman, CCoinsStats& stats, T hash_obj, const std::function<void()>& interruption_point)\n {\n     stats = CCoinsStats();\n     std::unique_ptr<CCoinsViewCursor> pcursor(view->Cursor());\n@@ -92,7 +93,8 @@ static bool GetUTXOStats(CCoinsView* view, CCoinsStats& stats, T hash_obj, const\n     stats.hashBlock = pcursor->GetBestBlock();\n     {\n         LOCK(cs_main);\n-        stats.nHeight = g_chainman.m_blockman.LookupBlockIndex(stats.hashBlock)->nHeight;\n+        assert(std::addressof(g_chainman.m_blockman) == std::addressof(blockman));\n+        stats.nHeight = blockman.LookupBlockIndex(stats.hashBlock)->nHeight;\n     }\n \n     PrepareHash(hash_obj, stats);\n@@ -126,19 +128,19 @@ static bool GetUTXOStats(CCoinsView* view, CCoinsStats& stats, T hash_obj, const\n     return true;\n }\n \n-bool GetUTXOStats(CCoinsView* view, CCoinsStats& stats, CoinStatsHashType hash_type, const std::function<void()>& interruption_point)\n+bool GetUTXOStats(CCoinsView* view, BlockManager& blockman, CCoinsStats& stats, CoinStatsHashType hash_type, const std::function<void()>& interruption_point)\n {\n     switch (hash_type) {\n     case(CoinStatsHashType::HASH_SERIALIZED): {\n         CHashWriter ss(SER_GETHASH, PROTOCOL_VERSION);\n-        return GetUTXOStats(view, stats, ss, interruption_point);\n+        return GetUTXOStats(view, blockman, stats, ss, interruption_point);\n     }\n     case(CoinStatsHashType::MUHASH): {\n         MuHash3072 muhash;\n-        return GetUTXOStats(view, stats, muhash, interruption_point);\n+        return GetUTXOStats(view, blockman, stats, muhash, interruption_point);\n     }\n     case(CoinStatsHashType::NONE): {\n-        return GetUTXOStats(view, stats, nullptr, interruption_point);\n+        return GetUTXOStats(view, blockman, stats, nullptr, interruption_point);\n     }\n     } // no default case, so the compiler can warn about missing cases\n     assert(false);"
      },
      {
        "sha": "83f228aa7ee47e93d2e11d58f54f35785e85303d",
        "filename": "src/node/coinstats.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/node/coinstats.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/node/coinstats.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coinstats.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -8,6 +8,7 @@\n \n #include <amount.h>\n #include <uint256.h>\n+#include <validation.h>\n \n #include <cstdint>\n #include <functional>\n@@ -36,6 +37,6 @@ struct CCoinsStats\n };\n \n //! Calculate statistics about the unspent transaction output set\n-bool GetUTXOStats(CCoinsView* view, CCoinsStats& stats, const CoinStatsHashType hash_type, const std::function<void()>& interruption_point = {});\n+bool GetUTXOStats(CCoinsView* view, BlockManager& blockman, CCoinsStats& stats, const CoinStatsHashType hash_type, const std::function<void()>& interruption_point = {});\n \n #endif // BITCOIN_NODE_COINSTATS_H"
      },
      {
        "sha": "50c8c291758dd8e42c3c58d14c0b847b0160cc59",
        "filename": "src/node/interfaces.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 27,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/node/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/node/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/interfaces.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -50,6 +50,7 @@\n #endif\n \n #include <memory>\n+#include <optional>\n #include <utility>\n \n using interfaces::BlockTip;\n@@ -182,18 +183,21 @@ class NodeImpl : public Node\n     int getNumBlocks() override\n     {\n         LOCK(::cs_main);\n-        return ::ChainActive().Height();\n+        assert(std::addressof(::ChainActive()) == std::addressof(m_context->chainman->ActiveChain()));\n+        return m_context->chainman->ActiveChain().Height();\n     }\n     uint256 getBestBlockHash() override\n     {\n-        const CBlockIndex* tip = WITH_LOCK(::cs_main, return ::ChainActive().Tip());\n+        assert(std::addressof(::ChainActive()) == std::addressof(m_context->chainman->ActiveChain()));\n+        const CBlockIndex* tip = WITH_LOCK(::cs_main, return m_context->chainman->ActiveChain().Tip());\n         return tip ? tip->GetBlockHash() : Params().GenesisBlock().GetHash();\n     }\n     int64_t getLastBlockTime() override\n     {\n         LOCK(::cs_main);\n-        if (::ChainActive().Tip()) {\n-            return ::ChainActive().Tip()->GetBlockTime();\n+        assert(std::addressof(::ChainActive()) == std::addressof(m_context->chainman->ActiveChain()));\n+        if (m_context->chainman->ActiveChain().Tip()) {\n+            return m_context->chainman->ActiveChain().Tip()->GetBlockTime();\n         }\n         return Params().GenesisBlock().GetBlockTime(); // Genesis block's time of current network\n     }\n@@ -202,11 +206,15 @@ class NodeImpl : public Node\n         const CBlockIndex* tip;\n         {\n             LOCK(::cs_main);\n-            tip = ::ChainActive().Tip();\n+            assert(std::addressof(::ChainActive()) == std::addressof(m_context->chainman->ActiveChain()));\n+            tip = m_context->chainman->ActiveChain().Tip();\n         }\n         return GuessVerificationProgress(Params().TxData(), tip);\n     }\n-    bool isInitialBlockDownload() override { return ::ChainstateActive().IsInitialBlockDownload(); }\n+    bool isInitialBlockDownload() override {\n+        assert(std::addressof(::ChainstateActive()) == std::addressof(m_context->chainman->ActiveChainstate()));\n+        return m_context->chainman->ActiveChainstate().IsInitialBlockDownload();\n+    }\n     bool getReindex() override { return ::fReindex; }\n     bool getImporting() override { return ::fImporting; }\n     void setNetworkActive(bool active) override\n@@ -231,7 +239,8 @@ class NodeImpl : public Node\n     bool getUnspentOutput(const COutPoint& output, Coin& coin) override\n     {\n         LOCK(::cs_main);\n-        return ::ChainstateActive().CoinsTip().GetCoin(output, coin);\n+        assert(std::addressof(::ChainstateActive()) == std::addressof(m_context->chainman->ActiveChainstate()));\n+        return m_context->chainman->ActiveChainstate().CoinsTip().GetCoin(output, coin);\n     }\n     WalletClient& walletClient() override\n     {\n@@ -407,15 +416,15 @@ class ChainImpl : public Chain\n {\n public:\n     explicit ChainImpl(NodeContext& node) : m_node(node) {}\n-    Optional<int> getHeight() override\n+    std::optional<int> getHeight() override\n     {\n         LOCK(::cs_main);\n         const CChain& active = Assert(m_node.chainman)->ActiveChain();\n         int height = active.Height();\n         if (height >= 0) {\n             return height;\n         }\n-        return nullopt;\n+        return std::nullopt;\n     }\n     uint256 getBlockHash(int height) override\n     {\n@@ -441,22 +450,25 @@ class ChainImpl : public Chain\n     bool checkFinalTx(const CTransaction& tx) override\n     {\n         LOCK(cs_main);\n-        return CheckFinalTx(::ChainActive().Tip(), tx);\n+        assert(std::addressof(::ChainActive()) == std::addressof(m_node.chainman->ActiveChain()));\n+        return CheckFinalTx(m_node.chainman->ActiveChain().Tip(), tx);\n     }\n-    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    std::optional<int> findLocatorFork(const CBlockLocator& locator) override\n     {\n         LOCK(cs_main);\n         const CChain& active = Assert(m_node.chainman)->ActiveChain();\n-        if (CBlockIndex* fork = g_chainman.m_blockman.FindForkInGlobalIndex(active, locator)) {\n+        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));\n+        if (CBlockIndex* fork = m_node.chainman->m_blockman.FindForkInGlobalIndex(active, locator)) {\n             return fork->nHeight;\n         }\n-        return nullopt;\n+        return std::nullopt;\n     }\n     bool findBlock(const uint256& hash, const FoundBlock& block) override\n     {\n         WAIT_LOCK(cs_main, lock);\n         const CChain& active = Assert(m_node.chainman)->ActiveChain();\n-        return FillBlock(g_chainman.m_blockman.LookupBlockIndex(hash), block, lock, active);\n+        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));\n+        return FillBlock(m_node.chainman->m_blockman.LookupBlockIndex(hash), block, lock, active);\n     }\n     bool findFirstBlockWithTimeAndHeight(int64_t min_time, int min_height, const FoundBlock& block) override\n     {\n@@ -468,7 +480,8 @@ class ChainImpl : public Chain\n     {\n         WAIT_LOCK(cs_main, lock);\n         const CChain& active = Assert(m_node.chainman)->ActiveChain();\n-        if (const CBlockIndex* block = g_chainman.m_blockman.LookupBlockIndex(block_hash)) {\n+        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));\n+        if (const CBlockIndex* block = m_node.chainman->m_blockman.LookupBlockIndex(block_hash)) {\n             if (const CBlockIndex* ancestor = block->GetAncestor(ancestor_height)) {\n                 return FillBlock(ancestor, ancestor_out, lock, active);\n             }\n@@ -479,17 +492,21 @@ class ChainImpl : public Chain\n     {\n         WAIT_LOCK(cs_main, lock);\n         const CChain& active = Assert(m_node.chainman)->ActiveChain();\n-        const CBlockIndex* block = g_chainman.m_blockman.LookupBlockIndex(block_hash);\n-        const CBlockIndex* ancestor = g_chainman.m_blockman.LookupBlockIndex(ancestor_hash);\n+        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));\n+        const CBlockIndex* block = m_node.chainman->m_blockman.LookupBlockIndex(block_hash);\n+        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));\n+        const CBlockIndex* ancestor = m_node.chainman->m_blockman.LookupBlockIndex(ancestor_hash);\n         if (block && ancestor && block->GetAncestor(ancestor->nHeight) != ancestor) ancestor = nullptr;\n         return FillBlock(ancestor, ancestor_out, lock, active);\n     }\n     bool findCommonAncestor(const uint256& block_hash1, const uint256& block_hash2, const FoundBlock& ancestor_out, const FoundBlock& block1_out, const FoundBlock& block2_out) override\n     {\n         WAIT_LOCK(cs_main, lock);\n         const CChain& active = Assert(m_node.chainman)->ActiveChain();\n-        const CBlockIndex* block1 = g_chainman.m_blockman.LookupBlockIndex(block_hash1);\n-        const CBlockIndex* block2 = g_chainman.m_blockman.LookupBlockIndex(block_hash2);\n+        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));\n+        const CBlockIndex* block1 = m_node.chainman->m_blockman.LookupBlockIndex(block_hash1);\n+        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));\n+        const CBlockIndex* block2 = m_node.chainman->m_blockman.LookupBlockIndex(block_hash2);\n         const CBlockIndex* ancestor = block1 && block2 ? LastCommonAncestor(block1, block2) : nullptr;\n         // Using & instead of && below to avoid short circuiting and leaving\n         // output uninitialized.\n@@ -499,9 +516,10 @@ class ChainImpl : public Chain\n     double guessVerificationProgress(const uint256& block_hash) override\n     {\n         LOCK(cs_main);\n-        return GuessVerificationProgress(Params().TxData(), g_chainman.m_blockman.LookupBlockIndex(block_hash));\n+        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));\n+        return GuessVerificationProgress(Params().TxData(), m_node.chainman->m_blockman.LookupBlockIndex(block_hash));\n     }\n-    bool hasBlocks(const uint256& block_hash, int min_height, Optional<int> max_height) override\n+    bool hasBlocks(const uint256& block_hash, int min_height, std::optional<int> max_height) override\n     {\n         // hasBlocks returns true if all ancestors of block_hash in specified\n         // range have block data (are not pruned), false if any ancestors in\n@@ -511,7 +529,8 @@ class ChainImpl : public Chain\n         // used to limit the range, and passing min_height that's too low or\n         // max_height that's too high will not crash or change the result.\n         LOCK(::cs_main);\n-        if (CBlockIndex* block = g_chainman.m_blockman.LookupBlockIndex(block_hash)) {\n+        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));\n+        if (CBlockIndex* block = m_node.chainman->m_blockman.LookupBlockIndex(block_hash)) {\n             if (max_height && block->nHeight >= *max_height) block = block->GetAncestor(*max_height);\n             for (; block->nStatus & BLOCK_HAVE_DATA; block = block->pprev) {\n                 // Check pprev to not segfault if min_height is too low\n@@ -526,6 +545,12 @@ class ChainImpl : public Chain\n         LOCK(m_node.mempool->cs);\n         return IsRBFOptIn(tx, *m_node.mempool);\n     }\n+    bool isInMempool(const uint256& txid) override\n+    {\n+        if (!m_node.mempool) return false;\n+        LOCK(m_node.mempool->cs);\n+        return m_node.mempool->exists(txid);\n+    }\n     bool hasDescendantsInMempool(const uint256& txid) override\n     {\n         if (!m_node.mempool) return false;\n@@ -595,7 +620,10 @@ class ChainImpl : public Chain\n         return ::fHavePruned;\n     }\n     bool isReadyToBroadcast() override { return !::fImporting && !::fReindex && !isInitialBlockDownload(); }\n-    bool isInitialBlockDownload() override { return ::ChainstateActive().IsInitialBlockDownload(); }\n+    bool isInitialBlockDownload() override {\n+        assert(std::addressof(::ChainstateActive()) == std::addressof(m_node.chainman->ActiveChainstate()));\n+        return m_node.chainman->ActiveChainstate().IsInitialBlockDownload();\n+    }\n     bool shutdownRequested() override { return ShutdownRequested(); }\n     int64_t getAdjustedTime() override { return GetAdjustedTime(); }\n     void initMessage(const std::string& message) override { ::uiInterface.InitMessage(message); }\n@@ -607,7 +635,7 @@ class ChainImpl : public Chain\n     }\n     std::unique_ptr<Handler> handleNotifications(std::shared_ptr<Notifications> notifications) override\n     {\n-        return MakeUnique<NotificationsHandlerImpl>(std::move(notifications));\n+        return std::make_unique<NotificationsHandlerImpl>(std::move(notifications));\n     }\n     void waitForNotificationsIfTipChanged(const uint256& old_tip) override\n     {\n@@ -620,7 +648,7 @@ class ChainImpl : public Chain\n     }\n     std::unique_ptr<Handler> handleRpc(const CRPCCommand& command) override\n     {\n-        return MakeUnique<RpcHandlerImpl>(command);\n+        return std::make_unique<RpcHandlerImpl>(command);\n     }\n     bool rpcEnableDeprecated(const std::string& method) override { return IsDeprecatedRPCEnabled(method); }\n     void rpcRunLater(const std::string& name, std::function<void()> fn, int64_t seconds) override\n@@ -663,6 +691,6 @@ class ChainImpl : public Chain\n } // namespace node\n \n namespace interfaces {\n-std::unique_ptr<Node> MakeNode(NodeContext* context) { return MakeUnique<node::NodeImpl>(context); }\n-std::unique_ptr<Chain> MakeChain(NodeContext& context) { return MakeUnique<node::ChainImpl>(context); }\n+std::unique_ptr<Node> MakeNode(NodeContext* context) { return std::make_unique<node::NodeImpl>(context); }\n+std::unique_ptr<Chain> MakeChain(NodeContext& context) { return std::make_unique<node::ChainImpl>(context); }\n } // namespace interfaces"
      },
      {
        "sha": "def4385c09ce819db950729514fff388b0d6933d",
        "filename": "src/node/psbt.h",
        "status": "modified",
        "additions": 11,
        "deletions": 9,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/node/psbt.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/node/psbt.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/psbt.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -7,6 +7,8 @@\n \n #include <psbt.h>\n \n+#include <optional>\n+\n /**\n  * Holds an analysis of one input from a PSBT\n  */\n@@ -25,18 +27,18 @@ struct PSBTInputAnalysis {\n  * Holds the results of AnalyzePSBT (miscellaneous information about a PSBT)\n  */\n struct PSBTAnalysis {\n-    Optional<size_t> estimated_vsize;      //!< Estimated weight of the transaction\n-    Optional<CFeeRate> estimated_feerate;  //!< Estimated feerate (fee / weight) of the transaction\n-    Optional<CAmount> fee;                 //!< Amount of fee being paid by the transaction\n-    std::vector<PSBTInputAnalysis> inputs; //!< More information about the individual inputs of the transaction\n-    PSBTRole next;                         //!< Which of the BIP 174 roles needs to handle the transaction next\n-    std::string error;                     //!< Error message\n+    std::optional<size_t> estimated_vsize;      //!< Estimated weight of the transaction\n+    std::optional<CFeeRate> estimated_feerate;  //!< Estimated feerate (fee / weight) of the transaction\n+    std::optional<CAmount> fee;                 //!< Amount of fee being paid by the transaction\n+    std::vector<PSBTInputAnalysis> inputs;      //!< More information about the individual inputs of the transaction\n+    PSBTRole next;                              //!< Which of the BIP 174 roles needs to handle the transaction next\n+    std::string error;                          //!< Error message\n \n     void SetInvalid(std::string err_msg)\n     {\n-        estimated_vsize = nullopt;\n-        estimated_feerate = nullopt;\n-        fee = nullopt;\n+        estimated_vsize = std::nullopt;\n+        estimated_feerate = std::nullopt;\n+        fee = std::nullopt;\n         inputs.clear();\n         next = PSBTRole::CREATOR;\n         error = err_msg;"
      },
      {
        "sha": "f47e85acebb66f584c9454af2cc30c7d526094c0",
        "filename": "src/node/transaction.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/node/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/node/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -29,19 +29,20 @@ static TransactionError HandleATMPError(const TxValidationState& state, std::str\n TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef tx, std::string& err_string, const CAmount& max_tx_fee, bool relay, bool wait_callback)\n {\n     // BroadcastTransaction can be called by either sendrawtransaction RPC or wallet RPCs.\n-    // node.connman is assigned both before chain clients and before RPC server is accepting calls,\n-    // and reset after chain clients and RPC sever are stopped. node.connman should never be null here.\n-    assert(node.connman);\n+    // node.peerman is assigned both before chain clients and before RPC server is accepting calls,\n+    // and reset after chain clients and RPC sever are stopped. node.peerman should never be null here.\n+    assert(node.peerman);\n     assert(node.mempool);\n     std::promise<void> promise;\n     uint256 hashTx = tx->GetHash();\n     bool callback_set = false;\n \n     { // cs_main scope\n     LOCK(cs_main);\n+    assert(std::addressof(::ChainstateActive()) == std::addressof(node.chainman->ActiveChainstate()));\n     // If the transaction is already confirmed in the chain, don't do anything\n     // and return early.\n-    CCoinsViewCache &view = ::ChainstateActive().CoinsTip();\n+    CCoinsViewCache &view = node.chainman->ActiveChainstate().CoinsTip();\n     for (size_t o = 0; o < tx->vout.size(); o++) {\n         const Coin& existingCoin = view.AccessCoin(COutPoint(hashTx, o));\n         // IsSpent doesn't mean the coin is spent, it means the output doesn't exist.\n@@ -53,7 +54,7 @@ TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef t\n         if (max_tx_fee > 0) {\n             // First, call ATMP with test_accept and check the fee. If ATMP\n             // fails here, return error immediately.\n-            const MempoolAcceptResult result = AcceptToMemoryPool(::ChainstateActive(), *node.mempool, tx, false /* bypass_limits */,\n+            const MempoolAcceptResult result = AcceptToMemoryPool(node.chainman->ActiveChainstate(), *node.mempool, tx, false /* bypass_limits */,\n                                                                   true /* test_accept */);\n             if (result.m_result_type != MempoolAcceptResult::ResultType::VALID) {\n                 return HandleATMPError(result.m_state, err_string);\n@@ -62,7 +63,7 @@ TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef t\n             }\n         }\n         // Try to submit the transaction to the mempool.\n-        const MempoolAcceptResult result = AcceptToMemoryPool(::ChainstateActive(), *node.mempool, tx, false /* bypass_limits */,\n+        const MempoolAcceptResult result = AcceptToMemoryPool(node.chainman->ActiveChainstate(), *node.mempool, tx, false /* bypass_limits */,\n                                                               false /* test_accept */);\n         if (result.m_result_type != MempoolAcceptResult::ResultType::VALID) {\n             return HandleATMPError(result.m_state, err_string);\n@@ -100,7 +101,7 @@ TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef t\n         node.mempool->AddUnbroadcastTx(hashTx);\n \n         LOCK(cs_main);\n-        RelayTransaction(hashTx, tx->GetWitnessHash(), *node.connman);\n+        node.peerman->RelayTransaction(hashTx, tx->GetWitnessHash());\n     }\n \n     return TransactionError::OK;"
      },
      {
        "sha": "583c56eabdab5004a6251f0937f1430c812d785d",
        "filename": "src/optional.h",
        "status": "removed",
        "additions": 0,
        "deletions": 20,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/src/optional.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/src/optional.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/optional.h?ref=1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05",
        "patch": "@@ -1,20 +0,0 @@\n-// Copyright (c) 2017-2020 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_OPTIONAL_H\n-#define BITCOIN_OPTIONAL_H\n-\n-#include <optional>\n-#include <utility>\n-\n-//! Substitute for C++17 std::optional\n-//! DEPRECATED use std::optional in new code.\n-template <typename T>\n-using Optional = std::optional<T>;\n-\n-//! Substitute for C++17 std::nullopt\n-//! DEPRECATED use std::nullopt in new code.\n-static auto& nullopt = std::nullopt;\n-\n-#endif // BITCOIN_OPTIONAL_H"
      },
      {
        "sha": "96ae39fdb81fa5a28cdb7cc1600b2ba437e60123",
        "filename": "src/psbt.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/psbt.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/psbt.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/psbt.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -7,13 +7,14 @@\n \n #include <attributes.h>\n #include <node/transaction.h>\n-#include <optional.h>\n #include <policy/feerate.h>\n #include <primitives/transaction.h>\n #include <pubkey.h>\n #include <script/sign.h>\n #include <script/signingprovider.h>\n \n+#include <optional>\n+\n // Magic bytes\n static constexpr uint8_t PSBT_MAGIC_BYTES[5] = {'p', 's', 'b', 't', 0xff};\n \n@@ -389,7 +390,7 @@ struct PSBTOutput\n /** A version of CTransaction with the PSBT format*/\n struct PartiallySignedTransaction\n {\n-    Optional<CMutableTransaction> tx;\n+    std::optional<CMutableTransaction> tx;\n     std::vector<PSBTInput> inputs;\n     std::vector<PSBTOutput> outputs;\n     std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;"
      },
      {
        "sha": "3bd6199059bf09ff23bb199da92f7e7fd83e8d3a",
        "filename": "src/qt/Makefile",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/Makefile?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -7,3 +7,5 @@ check: FORCE\n \t$(MAKE) -C .. test_bitcoin_qt_check\n bitcoin-qt bitcoin-qt.exe: FORCE\n \t $(MAKE) -C .. bitcoin_qt\n+apk: FORCE\n+\t$(MAKE) -C .. bitcoin_qt_apk"
      },
      {
        "sha": "9927e925ac05b93afad1dd60baba5d514a0e6d81",
        "filename": "src/qt/addressbookpage.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/addressbookpage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/addressbookpage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addressbookpage.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -295,7 +295,7 @@ void AddressBookPage::on_exportButton_clicked()\n     // CSV is currently the only supported format\n     QString filename = GUIUtil::getSaveFileName(this,\n         tr(\"Export Address List\"), QString(),\n-        tr(\"Comma separated file (*.csv)\"), nullptr);\n+        tr(\"Comma separated file\", \"Name of CSV file format\") + QLatin1String(\" (*.csv)\"), nullptr);\n \n     if (filename.isNull())\n         return;"
      },
      {
        "sha": "abb88fe89da94dce61118c393cea55e7888046eb",
        "filename": "src/qt/android/AndroidManifest.xml",
        "status": "added",
        "additions": 38,
        "deletions": 0,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/android/AndroidManifest.xml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/android/AndroidManifest.xml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/android/AndroidManifest.xml?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -0,0 +1,38 @@\n+<?xml version='1.0' encoding='utf-8'?>\n+<manifest package=\"org.bitcoincore.qt\" xmlns:android=\"http://schemas.android.com/apk/res/android\" android:versionName=\"1.0\" android:versionCode=\"1\" android:installLocation=\"auto\">\n+    <uses-sdk android:targetSdkVersion=\"24\"/>\n+\n+    <uses-permission android:name=\"android.permission.INTERNET\" />\n+    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n+    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n+\n+    <uses-feature android:glEsVersion=\"0x00020000\" android:required=\"true\" />\n+\n+    <supports-screens android:largeScreens=\"true\" android:normalScreens=\"true\" android:anyDensity=\"true\" android:smallScreens=\"true\"/>\n+\n+    <application android:hardwareAccelerated=\"true\" android:name=\"org.qtproject.qt5.android.bindings.QtApplication\" android:label=\"Bitcoin Core\">\n+        <activity android:configChanges=\"orientation|uiMode|screenLayout|screenSize|smallestScreenSize|layoutDirection|locale|fontScale|keyboard|keyboardHidden|navigation|mcc|mnc|density\"\n+                  android:name=\"org.bitcoincore.qt.BitcoinQtActivity\"\n+                  android:label=\"Bitcoin Core\"\n+                  android:icon=\"@drawable/bitcoin\"\n+                  android:screenOrientation=\"unspecified\"\n+                  android:launchMode=\"singleTop\">\n+            <intent-filter>\n+                <action android:name=\"android.intent.action.MAIN\"/>\n+                <category android:name=\"android.intent.category.LAUNCHER\"/>\n+            </intent-filter>\n+\n+            <meta-data android:name=\"android.app.arguments\" android:value=\"-testnet\"/>\n+            <meta-data android:name=\"android.app.lib_name\" android:value=\"bitcoin-qt\"/>\n+            <meta-data android:name=\"android.app.repository\" android:value=\"default\"/>\n+            <meta-data android:name=\"android.app.bundle_local_qt_libs\" android:value=\"1\"/>\n+            <meta-data android:name=\"android.app.use_local_qt_libs\" android:value=\"1\"/>\n+            <meta-data android:name=\"android.app.libs_prefix\" android:value=\"/data/local/tmp/qt/\"/>\n+            <meta-data android:name=\"android.app.system_libs_prefix\" android:value=\"/system/lib/\"/>\n+            <meta-data android:name=\"android.app.background_running\" android:value=\"true\"/>\n+            <meta-data android:name=\"android.app.auto_screen_scale_factor\" android:value=\"true\"/>\n+            <meta-data android:name=\"android.app.extract_android_style\" android:value=\"default\"/>\n+    </activity>\n+\n+    </application>\n+</manifest>"
      },
      {
        "sha": "4c36e79db8fb4e530e404b3e89cf24c99c113114",
        "filename": "src/qt/android/build.gradle",
        "status": "added",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/android/build.gradle",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/android/build.gradle",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/android/build.gradle?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -0,0 +1,52 @@\n+buildscript {\n+    repositories {\n+        google()\n+        jcenter()\n+    }\n+\n+    dependencies {\n+        classpath 'com.android.tools.build:gradle:3.1.0'\n+    }\n+}\n+\n+repositories {\n+    google()\n+    jcenter()\n+}\n+\n+apply plugin: 'com.android.application'\n+\n+dependencies {\n+    implementation fileTree(dir: 'libs', include: ['*.jar'])\n+}\n+\n+android {\n+    compileSdkVersion androidCompileSdkVersion.toInteger()\n+\n+    buildToolsVersion androidBuildToolsVersion\n+\n+    sourceSets {\n+        main {\n+            manifest.srcFile 'AndroidManifest.xml'\n+            java.srcDirs = [qt5AndroidDir + '/src', 'src', 'java']\n+            aidl.srcDirs = [qt5AndroidDir + '/src', 'src', 'aidl']\n+            res.srcDirs = [qt5AndroidDir + '/res', 'res']\n+            resources.srcDirs = ['src']\n+            renderscript.srcDirs = ['src']\n+            assets.srcDirs = ['assets']\n+            jniLibs.srcDirs = ['libs']\n+       }\n+    }\n+\n+    lintOptions {\n+        abortOnError false\n+    }\n+\n+    dexOptions {\n+        javaMaxHeapSize '4g'\n+    }\n+\n+    defaultConfig {\n+        minSdkVersion 24\n+    }\n+}"
      },
      {
        "sha": "838870f62d81bd581c6c50406089915631c2b16c",
        "filename": "src/qt/android/gradle.properties",
        "status": "added",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/android/gradle.properties",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/android/gradle.properties",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/android/gradle.properties?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -0,0 +1,4 @@\n+androidBuildToolsVersion=28.0.3\n+androidCompileSdkVersion=28\n+qt5AndroidDir=new File(\".\").absolutePath\n+org.gradle.jvmargs=-Xmx4608M"
      },
      {
        "sha": "31a556a35f2a473413020c6f15b39868c0022d5d",
        "filename": "src/qt/android/res/drawable-hdpi/bitcoin.png",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/android/res/drawable-hdpi/bitcoin.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/android/res/drawable-hdpi/bitcoin.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/android/res/drawable-hdpi/bitcoin.png?ref=5cee909b883b22f8813ed9e1619e7dea28331759"
      },
      {
        "sha": "76d80d4196cf16cdd31ecee944991a710c28d624",
        "filename": "src/qt/android/res/drawable-ldpi/bitcoin.png",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/android/res/drawable-ldpi/bitcoin.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/android/res/drawable-ldpi/bitcoin.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/android/res/drawable-ldpi/bitcoin.png?ref=5cee909b883b22f8813ed9e1619e7dea28331759"
      },
      {
        "sha": "c2aeab851a869c38c9b2c0a3d48eb88dd47bccd7",
        "filename": "src/qt/android/res/drawable-mdpi/bitcoin.png",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/android/res/drawable-mdpi/bitcoin.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/android/res/drawable-mdpi/bitcoin.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/android/res/drawable-mdpi/bitcoin.png?ref=5cee909b883b22f8813ed9e1619e7dea28331759"
      },
      {
        "sha": "2bd5e3defc7526329523249a740fbe5e8f6c5ec5",
        "filename": "src/qt/android/res/drawable-xhdpi/bitcoin.png",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/android/res/drawable-xhdpi/bitcoin.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/android/res/drawable-xhdpi/bitcoin.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/android/res/drawable-xhdpi/bitcoin.png?ref=5cee909b883b22f8813ed9e1619e7dea28331759"
      },
      {
        "sha": "d236cf2132a429fe43585e374de0afe41edfb59d",
        "filename": "src/qt/android/res/drawable-xxhdpi/bitcoin.png",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/android/res/drawable-xxhdpi/bitcoin.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/android/res/drawable-xxhdpi/bitcoin.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/android/res/drawable-xxhdpi/bitcoin.png?ref=5cee909b883b22f8813ed9e1619e7dea28331759"
      },
      {
        "sha": "bb1dbc355469143ae525d98b8f7080d2daaf5d38",
        "filename": "src/qt/android/res/drawable-xxxhdpi/bitcoin.png",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/android/res/drawable-xxxhdpi/bitcoin.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/android/res/drawable-xxxhdpi/bitcoin.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/android/res/drawable-xxxhdpi/bitcoin.png?ref=5cee909b883b22f8813ed9e1619e7dea28331759"
      },
      {
        "sha": "cf3b4f66680c5d36da6d280a62dbfbf2d3a411af",
        "filename": "src/qt/android/src/org/bitcoincore/qt/BitcoinQtActivity.java",
        "status": "added",
        "additions": 29,
        "deletions": 0,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/android/src/org/bitcoincore/qt/BitcoinQtActivity.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/android/src/org/bitcoincore/qt/BitcoinQtActivity.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/android/src/org/bitcoincore/qt/BitcoinQtActivity.java?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -0,0 +1,29 @@\n+package org.bitcoincore.qt;\n+\n+import android.os.Bundle;\n+import android.system.ErrnoException;\n+import android.system.Os;\n+\n+import org.qtproject.qt5.android.bindings.QtActivity;\n+\n+import java.io.File;\n+\n+public class BitcoinQtActivity extends QtActivity\n+{\n+    @Override\n+    public void onCreate(Bundle savedInstanceState)\n+    {\n+        final File bitcoinDir = new File(getFilesDir().getAbsolutePath() + \"/.bitcoin\");\n+        if (!bitcoinDir.exists()) {\n+            bitcoinDir.mkdir();\n+        }\n+\n+        try {\n+            Os.setenv(\"QT_QPA_PLATFORM\", \"android\", true);\n+        } catch (ErrnoException e) {\n+            e.printStackTrace();\n+        }\n+\n+        super.onCreate(savedInstanceState);\n+    }\n+}"
      },
      {
        "sha": "fc6d0febc2d66223da095cbcab2e1dbb96bc8b86",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -52,7 +52,6 @@\n #include <QThread>\n #include <QTimer>\n #include <QTranslator>\n-#include <QtGlobal>\n \n #if defined(QT_STATICPLUGIN)\n #include <QtPlugin>\n@@ -62,6 +61,7 @@ Q_IMPORT_PLUGIN(QXcbIntegrationPlugin);\n Q_IMPORT_PLUGIN(QWindowsIntegrationPlugin);\n #elif defined(QT_QPA_PLATFORM_COCOA)\n Q_IMPORT_PLUGIN(QCocoaIntegrationPlugin);\n+Q_IMPORT_PLUGIN(QMacStylePlugin);\n #endif\n #endif\n \n@@ -466,11 +466,10 @@ int GuiMain(int argc, char* argv[])\n     QApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);\n     QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);\n \n-#if (QT_VERSION <= QT_VERSION_CHECK(5, 9, 8)) && defined(Q_OS_MACOS)\n-    const auto os_name = QSysInfo::prettyProductName();\n-    if (os_name.startsWith(\"macOS 11\") || os_name.startsWith(\"macOS 10.16\")) {\n-        QApplication::setStyle(\"fusion\");\n-    }\n+#if defined(QT_QPA_PLATFORM_ANDROID)\n+    QApplication::setAttribute(Qt::AA_DontUseNativeMenuBar);\n+    QApplication::setAttribute(Qt::AA_DontCreateNativeWidgetSiblings);\n+    QApplication::setAttribute(Qt::AA_DontUseNativeDialogs);\n #endif\n \n     BitcoinApplication app;"
      },
      {
        "sha": "113bd30a0c1e2be0f6e94756b75cd3579e9bedd9",
        "filename": "src/qt/createwalletdialog.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/createwalletdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/createwalletdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/createwalletdialog.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -53,6 +53,12 @@ CreateWalletDialog::CreateWalletDialog(QWidget* parent) :\n         }\n     });\n \n+    connect(ui->blank_wallet_checkbox, &QCheckBox::toggled, [this](bool checked) {\n+        if (!checked) {\n+          ui->disable_privkeys_checkbox->setChecked(false);\n+        }\n+    });\n+\n #ifndef USE_SQLITE\n         ui->descriptor_checkbox->setToolTip(tr(\"Compiled without sqlite support (required for descriptor wallets)\"));\n         ui->descriptor_checkbox->setEnabled(false);"
      },
      {
        "sha": "b4afdbcc22da0cc13a3bb1a5abb8d86d04efb4e9",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -683,13 +683,13 @@ QString formatDurationStr(int secs)\n     int seconds = secs % 60;\n \n     if (days)\n-        strList.append(QString(QObject::tr(\"%1 d\")).arg(days));\n+        strList.append(QObject::tr(\"%1 d\").arg(days));\n     if (hours)\n-        strList.append(QString(QObject::tr(\"%1 h\")).arg(hours));\n+        strList.append(QObject::tr(\"%1 h\").arg(hours));\n     if (mins)\n-        strList.append(QString(QObject::tr(\"%1 m\")).arg(mins));\n+        strList.append(QObject::tr(\"%1 m\").arg(mins));\n     if (seconds || (!days && !hours && !mins))\n-        strList.append(QString(QObject::tr(\"%1 s\")).arg(seconds));\n+        strList.append(QObject::tr(\"%1 s\").arg(seconds));\n \n     return strList.join(\" \");\n }\n@@ -712,12 +712,12 @@ QString formatPingTime(std::chrono::microseconds ping_time)\n {\n     return (ping_time == std::chrono::microseconds::max() || ping_time == 0us) ?\n         QObject::tr(\"N/A\") :\n-        QString(QObject::tr(\"%1 ms\")).arg(QString::number((int)(count_microseconds(ping_time) / 1000), 10));\n+        QObject::tr(\"%1 ms\").arg(QString::number((int)(count_microseconds(ping_time) / 1000), 10));\n }\n \n QString formatTimeOffset(int64_t nTimeOffset)\n {\n-  return QString(QObject::tr(\"%1 s\")).arg(QString::number((int)nTimeOffset, 10));\n+  return QObject::tr(\"%1 s\").arg(QString::number((int)nTimeOffset, 10));\n }\n \n QString formatNiceTimeOffset(qint64 secs)\n@@ -759,14 +759,14 @@ QString formatNiceTimeOffset(qint64 secs)\n \n QString formatBytes(uint64_t bytes)\n {\n-    if(bytes < 1024)\n-        return QString(QObject::tr(\"%1 B\")).arg(bytes);\n-    if(bytes < 1024 * 1024)\n-        return QString(QObject::tr(\"%1 KB\")).arg(bytes / 1024);\n-    if(bytes < 1024 * 1024 * 1024)\n-        return QString(QObject::tr(\"%1 MB\")).arg(bytes / 1024 / 1024);\n+    if (bytes < 1'000)\n+        return QObject::tr(\"%1 B\").arg(bytes);\n+    if (bytes < 1'000'000)\n+        return QObject::tr(\"%1 kB\").arg(bytes / 1'000);\n+    if (bytes < 1'000'000'000)\n+        return QObject::tr(\"%1 MB\").arg(bytes / 1'000'000);\n \n-    return QString(QObject::tr(\"%1 GB\")).arg(bytes / 1024 / 1024 / 1024);\n+    return QObject::tr(\"%1 GB\").arg(bytes / 1'000'000'000);\n }\n \n qreal calculateIdealFontSize(int width, const QString& text, QFont font, qreal minPointSize, qreal font_size) {"
      },
      {
        "sha": "ba35ff3b67e36cac6417cda93c71eb7a88d64e76",
        "filename": "src/qt/optionsdialog.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/optionsdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/optionsdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsdialog.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -67,7 +67,7 @@ private Q_SLOTS:\n     void updateDefaultProxyNets();\n \n Q_SIGNALS:\n-    void proxyIpChecks(QValidatedLineEdit *pUiProxyIp, int nProxyPort);\n+    void proxyIpChecks(QValidatedLineEdit *pUiProxyIp, uint16_t nProxyPort);\n \n private:\n     Ui::OptionsDialog *ui;"
      },
      {
        "sha": "17746b395b6f50121ecf775701bdfbe9d055b527",
        "filename": "src/qt/psbtoperationsdialog.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/psbtoperationsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/psbtoperationsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/psbtoperationsdialog.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -141,11 +141,11 @@ void PSBTOperationsDialog::saveTransaction() {\n     filename_suggestion.append(\".psbt\");\n     QString filename = GUIUtil::getSaveFileName(this,\n         tr(\"Save Transaction Data\"), filename_suggestion,\n-        tr(\"Partially Signed Transaction (Binary) (*.psbt)\"), &selected_filter);\n+        tr(\"Partially Signed Transaction (Binary)\", \"Name of binary PSBT file format\") + QLatin1String(\" (*.psbt)\"), &selected_filter);\n     if (filename.isEmpty()) {\n         return;\n     }\n-    std::ofstream out(filename.toLocal8Bit().data());\n+    std::ofstream out(filename.toLocal8Bit().data(), std::ofstream::out | std::ofstream::binary);\n     out << ssTx.str();\n     out.close();\n     showStatus(tr(\"PSBT saved to disk.\"), StatusLevel::INFO);"
      },
      {
        "sha": "a71c8831e9afecf7d66620e68b7cb7c09e5bcd10",
        "filename": "src/qt/qrimagewidget.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/qrimagewidget.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/qrimagewidget.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/qrimagewidget.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -120,7 +120,9 @@ void QRImageWidget::saveImage()\n {\n     if (!GUIUtil::HasPixmap(this))\n         return;\n-    QString fn = GUIUtil::getSaveFileName(this, tr(\"Save QR Code\"), QString(), tr(\"PNG Image (*.png)\"), nullptr);\n+    QString fn = GUIUtil::getSaveFileName(\n+        this, tr(\"Save QR Code\"), QString(),\n+        tr(\"PNG Image\", \"Name of PNG file format\") + QLatin1String(\" (*.png)\"), nullptr);\n     if (!fn.isEmpty())\n     {\n         exportImage().save(fn);"
      },
      {
        "sha": "61cb89d75a02348c3c7789615e989423bb41d8a4",
        "filename": "src/qt/receivecoinsdialog.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/receivecoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/receivecoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receivecoinsdialog.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -81,7 +81,6 @@ ReceiveCoinsDialog::ReceiveCoinsDialog(const PlatformStyle *_platformStyle, QWid\n         tableView->horizontalHeader()->setMinimumSectionSize(MINIMUM_COLUMN_WIDTH);\n         tableView->horizontalHeader()->setStretchLastSection(true);\n     }\n-    tableView->horizontalHeader()->setSortIndicator(RecentRequestsTableModel::Date, Qt::DescendingOrder);\n }\n \n void ReceiveCoinsDialog::setModel(WalletModel *_model)\n@@ -96,6 +95,8 @@ void ReceiveCoinsDialog::setModel(WalletModel *_model)\n \n         QTableView* tableView = ui->recentRequestsView;\n         tableView->setModel(_model->getRecentRequestsTableModel());\n+        tableView->sortByColumn(RecentRequestsTableModel::Date, Qt::DescendingOrder);\n+\n         connect(tableView->selectionModel(),\n             &QItemSelectionModel::selectionChanged, this,\n             &ReceiveCoinsDialog::recentRequestsView_selectionChanged);"
      },
      {
        "sha": "95e1ce2210bfda8d49ff7cf3b6beaf100f474fa8",
        "filename": "src/qt/sendcoinsdialog.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/sendcoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/sendcoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -266,7 +266,7 @@ bool SendCoinsDialog::PrepareSendText(QString& question_string, QString& informa\n     }\n \n     // prepare transaction for getting txFee earlier\n-    m_current_transaction = MakeUnique<WalletModelTransaction>(recipients);\n+    m_current_transaction = std::make_unique<WalletModelTransaction>(recipients);\n     WalletModel::SendCoinsReturn prepareStatus;\n \n     updateCoinControlState(*m_coin_control);\n@@ -430,11 +430,11 @@ void SendCoinsDialog::on_sendButton_clicked()\n             fileNameSuggestion.append(\".psbt\");\n             QString filename = GUIUtil::getSaveFileName(this,\n                 tr(\"Save Transaction Data\"), fileNameSuggestion,\n-                tr(\"Partially Signed Transaction (Binary) (*.psbt)\"), &selectedFilter);\n+                tr(\"Partially Signed Transaction (Binary)\", \"Name of binary PSBT file format\") + QLatin1String(\" (*.psbt)\"), &selectedFilter);\n             if (filename.isEmpty()) {\n                 return;\n             }\n-            std::ofstream out(filename.toLocal8Bit().data());\n+            std::ofstream out(filename.toLocal8Bit().data(), std::ofstream::out | std::ofstream::binary);\n             out << ssTx.str();\n             out.close();\n             Q_EMIT message(tr(\"PSBT saved\"), \"PSBT saved to disk\", CClientUIInterface::MSG_INFORMATION);"
      },
      {
        "sha": "a0260692325e07dd8190b36e76aa052a48d2a56f",
        "filename": "src/qt/test/addressbooktests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/test/addressbooktests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/test/addressbooktests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/addressbooktests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -112,7 +112,7 @@ void TestAddAddressesToSendBook(interfaces::Node& node)\n     ClientModel clientModel(node, &optionsModel);\n     AddWallet(wallet);\n     WalletModel walletModel(interfaces::MakeWallet(wallet), clientModel, platformStyle.get());\n-    RemoveWallet(wallet, nullopt);\n+    RemoveWallet(wallet, std::nullopt);\n     EditAddressDialog editAddressDialog(EditAddressDialog::NewSendingAddress);\n     editAddressDialog.setModel(walletModel.getAddressTableModel());\n "
      },
      {
        "sha": "a1baf6a40255d499e506775c2d9232629383ce22",
        "filename": "src/qt/test/test_main.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/test/test_main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/test/test_main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/test_main.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -54,6 +54,13 @@ int main(int argc, char* argv[])\n \n     NodeContext node_context;\n     std::unique_ptr<interfaces::Node> node = interfaces::MakeNode(&node_context);\n+    gArgs.ForceSetArg(\"-listen\", \"0\");\n+    gArgs.ForceSetArg(\"-listenonion\", \"0\");\n+    gArgs.ForceSetArg(\"-discover\", \"0\");\n+    gArgs.ForceSetArg(\"-dnsseed\", \"0\");\n+    gArgs.ForceSetArg(\"-fixedseeds\", \"0\");\n+    gArgs.ForceSetArg(\"-upnp\", \"0\");\n+    gArgs.ForceSetArg(\"-natpmp\", \"0\");\n \n     bool fInvalid = false;\n "
      },
      {
        "sha": "1107c44dc9fb0cdf1fcff75429b94ac1693c7c6a",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -167,7 +167,7 @@ void TestGUI(interfaces::Node& node)\n     ClientModel clientModel(node, &optionsModel);\n     AddWallet(wallet);\n     WalletModel walletModel(interfaces::MakeWallet(wallet), clientModel, platformStyle.get());\n-    RemoveWallet(wallet, nullopt);\n+    RemoveWallet(wallet, std::nullopt);\n     sendCoinsDialog.setModel(&walletModel);\n     transactionView.setModel(&walletModel);\n "
      },
      {
        "sha": "7e12410c801c01277b459c97613da199015257cf",
        "filename": "src/qt/trafficgraphwidget.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/trafficgraphwidget.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/trafficgraphwidget.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/trafficgraphwidget.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -79,7 +79,7 @@ void TrafficGraphWidget::paintEvent(QPaintEvent *)\n     int base = floor(log10(fMax));\n     float val = pow(10.0f, base);\n \n-    const QString units     = tr(\"KB/s\");\n+    const QString units = tr(\"kB/s\");\n     const float yMarginText = 2.0;\n \n     // draw lines\n@@ -128,10 +128,10 @@ void TrafficGraphWidget::updateRates()\n \n     quint64 bytesIn = clientModel->node().getTotalBytesRecv(),\n             bytesOut = clientModel->node().getTotalBytesSent();\n-    float inRate = (bytesIn - nLastBytesIn) / 1024.0f * 1000 / timer->interval();\n-    float outRate = (bytesOut - nLastBytesOut) / 1024.0f * 1000 / timer->interval();\n-    vSamplesIn.push_front(inRate);\n-    vSamplesOut.push_front(outRate);\n+    float in_rate_kilobytes_per_sec = static_cast<float>(bytesIn - nLastBytesIn) / timer->interval();\n+    float out_rate_kilobytes_per_sec = static_cast<float>(bytesOut - nLastBytesOut) / timer->interval();\n+    vSamplesIn.push_front(in_rate_kilobytes_per_sec);\n+    vSamplesOut.push_front(out_rate_kilobytes_per_sec);\n     nLastBytesIn = bytesIn;\n     nLastBytesOut = bytesOut;\n "
      },
      {
        "sha": "42e08c6af7f9b70f797a4d245eecb26ced4ffd8e",
        "filename": "src/qt/transactionview.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/transactionview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/transactionview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -160,7 +160,6 @@ TransactionView::TransactionView(const PlatformStyle *platformStyle, QWidget *pa\n         transactionView->horizontalHeader()->setMinimumSectionSize(MINIMUM_COLUMN_WIDTH);\n         transactionView->horizontalHeader()->setStretchLastSection(true);\n     }\n-    transactionView->horizontalHeader()->setSortIndicator(TransactionTableModel::Date, Qt::DescendingOrder);\n \n     // Actions\n     abandonAction = new QAction(tr(\"Abandon transaction\"), this);\n@@ -236,6 +235,7 @@ void TransactionView::setModel(WalletModel *_model)\n         transactionProxyModel->setFilterCaseSensitivity(Qt::CaseInsensitive);\n         transactionProxyModel->setSortRole(Qt::EditRole);\n         transactionView->setModel(transactionProxyModel);\n+        transactionView->sortByColumn(TransactionTableModel::Date, Qt::DescendingOrder);\n \n         if (_model->getOptionsModel())\n         {\n@@ -357,7 +357,7 @@ void TransactionView::exportClicked()\n     // CSV is currently the only supported format\n     QString filename = GUIUtil::getSaveFileName(this,\n         tr(\"Export Transaction History\"), QString(),\n-        tr(\"Comma separated file (*.csv)\"), nullptr);\n+        tr(\"Comma separated file\", \"Name of CSV file format\") + QLatin1String(\" (*.csv)\"), nullptr);\n \n     if (filename.isNull())\n         return;"
      },
      {
        "sha": "861289368374897dbfad95461831b90183200112",
        "filename": "src/qt/walletview.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/walletview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/walletview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletview.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -273,7 +273,7 @@ void WalletView::backupWallet()\n {\n     QString filename = GUIUtil::getSaveFileName(this,\n         tr(\"Backup Wallet\"), QString(),\n-        tr(\"Wallet Data (*.dat)\"), nullptr);\n+        tr(\"Wallet Data\", \"Name of wallet data file format\") + QLatin1String(\" (*.dat)\"), nullptr);\n \n     if (filename.isEmpty())\n         return;"
      },
      {
        "sha": "3ba2fa46ae5c6e0bf089697820b5481ebd579e05",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 82,
        "deletions": 79,
        "changes": 161,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1050,15 +1050,15 @@ static RPCHelpMan gettxoutsetinfo()\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"\",\n                     {\n-                        {RPCResult::Type::NUM, \"height\", \"The current block height (index)\"},\n-                        {RPCResult::Type::STR_HEX, \"bestblock\", \"The hash of the block at the tip of the chain\"},\n+                        {RPCResult::Type::NUM, \"height\", \"The block height (index) of the returned statistics\"},\n+                        {RPCResult::Type::STR_HEX, \"bestblock\", \"The hash of the block at which these statistics are calculated\"},\n                         {RPCResult::Type::NUM, \"transactions\", \"The number of transactions with unspent outputs\"},\n                         {RPCResult::Type::NUM, \"txouts\", \"The number of unspent transaction outputs\"},\n                         {RPCResult::Type::NUM, \"bogosize\", \"A meaningless metric for UTXO set size\"},\n                         {RPCResult::Type::STR_HEX, \"hash_serialized_2\", /* optional */ true, \"The serialized hash (only present if 'hash_serialized_2' hash_type is chosen)\"},\n                         {RPCResult::Type::STR_HEX, \"muhash\", /* optional */ true, \"The serialized hash (only present if 'muhash' hash_type is chosen)\"},\n                         {RPCResult::Type::NUM, \"disk_size\", \"The estimated size of the chainstate on disk\"},\n-                        {RPCResult::Type::STR_AMOUNT, \"total_amount\", \"The total amount\"},\n+                        {RPCResult::Type::STR_AMOUNT, \"total_amount\", \"The total amount of coins in the UTXO set\"},\n                     }},\n                 RPCExamples{\n                     HelpExampleCli(\"gettxoutsetinfo\", \"\")\n@@ -1073,9 +1073,9 @@ static RPCHelpMan gettxoutsetinfo()\n \n     const CoinStatsHashType hash_type{request.params[0].isNull() ? CoinStatsHashType::HASH_SERIALIZED : ParseHashType(request.params[0].get_str())};\n \n-    CCoinsView* coins_view = WITH_LOCK(cs_main, return &ChainstateActive().CoinsDB());\n+    CCoinsView* coins_view = WITH_LOCK(::cs_main, return &::ChainstateActive().CoinsDB());\n     NodeContext& node = EnsureNodeContext(request.context);\n-    if (GetUTXOStats(coins_view, stats, hash_type, node.rpc_interruption_point)) {\n+    if (GetUTXOStats(coins_view, WITH_LOCK(::cs_main, return std::ref(g_chainman.m_blockman)), stats, hash_type, node.rpc_interruption_point)) {\n         ret.pushKV(\"height\", (int64_t)stats.nHeight);\n         ret.pushKV(\"bestblock\", stats.hashBlock.GetHex());\n         ret.pushKV(\"transactions\", (int64_t)stats.nTransactions);\n@@ -1100,30 +1100,29 @@ static RPCHelpMan gettxoutsetinfo()\n static RPCHelpMan gettxout()\n {\n     return RPCHelpMan{\"gettxout\",\n-                \"\\nReturns details about an unspent transaction output.\\n\",\n-                {\n-                    {\"txid\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The transaction id\"},\n-                    {\"n\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"vout number\"},\n-                    {\"include_mempool\", RPCArg::Type::BOOL, /* default */ \"true\", \"Whether to include the mempool. Note that an unspent output that is spent in the mempool won't appear.\"},\n-                },\n-                RPCResult{\n-                    RPCResult::Type::OBJ, \"\", \"\",\n-                    {\n-                        {RPCResult::Type::STR_HEX, \"bestblock\", \"The hash of the block at the tip of the chain\"},\n-                        {RPCResult::Type::NUM, \"confirmations\", \"The number of confirmations\"},\n-                        {RPCResult::Type::STR_AMOUNT, \"value\", \"The transaction value in \" + CURRENCY_UNIT},\n-                        {RPCResult::Type::OBJ, \"scriptPubKey\", \"\",\n-                            {\n-                                {RPCResult::Type::STR_HEX, \"asm\", \"\"},\n-                                {RPCResult::Type::STR_HEX, \"hex\", \"\"},\n-                                {RPCResult::Type::NUM, \"reqSigs\", \"Number of required signatures\"},\n-                                {RPCResult::Type::STR_HEX, \"type\", \"The type, eg pubkeyhash\"},\n-                                {RPCResult::Type::ARR, \"addresses\", \"array of bitcoin addresses\",\n-                                    {{RPCResult::Type::STR, \"address\", \"bitcoin address\"}}},\n-                            }},\n-                        {RPCResult::Type::BOOL, \"coinbase\", \"Coinbase or not\"},\n-                    }},\n-                RPCExamples{\n+        \"\\nReturns details about an unspent transaction output.\\n\",\n+        {\n+            {\"txid\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The transaction id\"},\n+            {\"n\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"vout number\"},\n+            {\"include_mempool\", RPCArg::Type::BOOL, /* default */ \"true\", \"Whether to include the mempool. Note that an unspent output that is spent in the mempool won't appear.\"},\n+        },\n+        {\n+            RPCResult{\"If the UTXO was not found\", RPCResult::Type::NONE, \"\", \"\"},\n+            RPCResult{\"Otherwise\", RPCResult::Type::OBJ, \"\", \"\", {\n+                {RPCResult::Type::STR_HEX, \"bestblock\", \"The hash of the block at the tip of the chain\"},\n+                {RPCResult::Type::NUM, \"confirmations\", \"The number of confirmations\"},\n+                {RPCResult::Type::STR_AMOUNT, \"value\", \"The transaction value in \" + CURRENCY_UNIT},\n+                {RPCResult::Type::OBJ, \"scriptPubKey\", \"\", {\n+                    {RPCResult::Type::STR_HEX, \"asm\", \"\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", \"\"},\n+                    {RPCResult::Type::NUM, \"reqSigs\", \"Number of required signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"type\", \"The type, eg pubkeyhash\"},\n+                    {RPCResult::Type::ARR, \"addresses\", \"array of bitcoin addresses\", {{RPCResult::Type::STR, \"address\", \"bitcoin address\"}}},\n+                }},\n+                {RPCResult::Type::BOOL, \"coinbase\", \"Coinbase or not\"},\n+            }},\n+        },\n+        RPCExamples{\n             \"\\nGet unspent transactions\\n\"\n             + HelpExampleCli(\"listunspent\", \"\") +\n             \"\\nView the details\\n\"\n@@ -2137,59 +2136,63 @@ class CoinsViewScanReserver\n static RPCHelpMan scantxoutset()\n {\n     return RPCHelpMan{\"scantxoutset\",\n-                \"\\nEXPERIMENTAL warning: this call may be removed or changed in future releases.\\n\"\n-                \"\\nScans the unspent transaction output set for entries that match certain output descriptors.\\n\"\n-                \"Examples of output descriptors are:\\n\"\n-                \"    addr(<address>)                      Outputs whose scriptPubKey corresponds to the specified address (does not include P2PK)\\n\"\n-                \"    raw(<hex script>)                    Outputs whose scriptPubKey equals the specified hex scripts\\n\"\n-                \"    combo(<pubkey>)                      P2PK, P2PKH, P2WPKH, and P2SH-P2WPKH outputs for the given pubkey\\n\"\n-                \"    pkh(<pubkey>)                        P2PKH outputs for the given pubkey\\n\"\n-                \"    sh(multi(<n>,<pubkey>,<pubkey>,...)) P2SH-multisig outputs for the given threshold and pubkeys\\n\"\n-                \"\\nIn the above, <pubkey> either refers to a fixed public key in hexadecimal notation, or to an xpub/xprv optionally followed by one\\n\"\n-                \"or more path elements separated by \\\"/\\\", and optionally ending in \\\"/*\\\" (unhardened), or \\\"/*'\\\" or \\\"/*h\\\" (hardened) to specify all\\n\"\n-                \"unhardened or hardened child keys.\\n\"\n-                \"In the latter case, a range needs to be specified by below if different from 1000.\\n\"\n-                \"For more information on output descriptors, see the documentation in the doc/descriptors.md file.\\n\",\n+        \"\\nScans the unspent transaction output set for entries that match certain output descriptors.\\n\"\n+        \"Examples of output descriptors are:\\n\"\n+        \"    addr(<address>)                      Outputs whose scriptPubKey corresponds to the specified address (does not include P2PK)\\n\"\n+        \"    raw(<hex script>)                    Outputs whose scriptPubKey equals the specified hex scripts\\n\"\n+        \"    combo(<pubkey>)                      P2PK, P2PKH, P2WPKH, and P2SH-P2WPKH outputs for the given pubkey\\n\"\n+        \"    pkh(<pubkey>)                        P2PKH outputs for the given pubkey\\n\"\n+        \"    sh(multi(<n>,<pubkey>,<pubkey>,...)) P2SH-multisig outputs for the given threshold and pubkeys\\n\"\n+        \"\\nIn the above, <pubkey> either refers to a fixed public key in hexadecimal notation, or to an xpub/xprv optionally followed by one\\n\"\n+        \"or more path elements separated by \\\"/\\\", and optionally ending in \\\"/*\\\" (unhardened), or \\\"/*'\\\" or \\\"/*h\\\" (hardened) to specify all\\n\"\n+        \"unhardened or hardened child keys.\\n\"\n+        \"In the latter case, a range needs to be specified by below if different from 1000.\\n\"\n+        \"For more information on output descriptors, see the documentation in the doc/descriptors.md file.\\n\",\n+        {\n+            {\"action\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The action to execute\\n\"\n+                \"\\\"start\\\" for starting a scan\\n\"\n+                \"\\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+                \"\\\"status\\\" for progress report (in %) of the current scan\"},\n+            {\"scanobjects\", RPCArg::Type::ARR, RPCArg::Optional::OMITTED, \"Array of scan objects. Required for \\\"start\\\" action\\n\"\n+                \"Every scan object is either a string descriptor or an object:\",\n+            {\n+                {\"descriptor\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"An output descriptor\"},\n+                {\"\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, \"An object with output descriptor and metadata\",\n                 {\n-                    {\"action\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The action to execute\\n\"\n-            \"                                      \\\"start\\\" for starting a scan\\n\"\n-            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n-            \"                                      \\\"status\\\" for progress report (in %) of the current scan\"},\n-                    {\"scanobjects\", RPCArg::Type::ARR, RPCArg::Optional::OMITTED, \"Array of scan objects. Required for \\\"start\\\" action\\n\"\n-            \"                                  Every scan object is either a string descriptor or an object:\",\n-                        {\n-                            {\"descriptor\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"An output descriptor\"},\n-                            {\"\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, \"An object with output descriptor and metadata\",\n-                                {\n-                                    {\"desc\", RPCArg::Type::STR, RPCArg::Optional::NO, \"An output descriptor\"},\n-                                    {\"range\", RPCArg::Type::RANGE, /* default */ \"1000\", \"The range of HD chain indexes to explore (either end or [begin,end])\"},\n-                                },\n-                            },\n-                        },\n+                    {\"desc\", RPCArg::Type::STR, RPCArg::Optional::NO, \"An output descriptor\"},\n+                    {\"range\", RPCArg::Type::RANGE, /* default */ \"1000\", \"The range of HD chain indexes to explore (either end or [begin,end])\"},\n+                }},\n+            },\n                         \"[scanobjects,...]\"},\n-                },\n-                RPCResult{\n-                    RPCResult::Type::OBJ, \"\", \"\",\n+        },\n+        {\n+            RPCResult{\"When action=='abort'\", RPCResult::Type::BOOL, \"\", \"\"},\n+            RPCResult{\"When action=='status' and no scan is in progress\", RPCResult::Type::NONE, \"\", \"\"},\n+            RPCResult{\"When action=='status' and scan is in progress\", RPCResult::Type::OBJ, \"\", \"\",\n+            {\n+                {RPCResult::Type::NUM, \"progress\", \"The scan progress\"},\n+            }},\n+            RPCResult{\"When action=='start'\", RPCResult::Type::OBJ, \"\", \"\", {\n+                {RPCResult::Type::BOOL, \"success\", \"Whether the scan was completed\"},\n+                {RPCResult::Type::NUM, \"txouts\", \"The number of unspent transaction outputs scanned\"},\n+                {RPCResult::Type::NUM, \"height\", \"The current block height (index)\"},\n+                {RPCResult::Type::STR_HEX, \"bestblock\", \"The hash of the block at the tip of the chain\"},\n+                {RPCResult::Type::ARR, \"unspents\", \"\",\n+                {\n+                    {RPCResult::Type::OBJ, \"\", \"\",\n                     {\n-                        {RPCResult::Type::BOOL, \"success\", \"Whether the scan was completed\"},\n-                        {RPCResult::Type::NUM, \"txouts\", \"The number of unspent transaction outputs scanned\"},\n-                        {RPCResult::Type::NUM, \"height\", \"The current block height (index)\"},\n-                        {RPCResult::Type::STR_HEX, \"bestblock\", \"The hash of the block at the tip of the chain\"},\n-                        {RPCResult::Type::ARR, \"unspents\", \"\",\n-                            {\n-                                {RPCResult::Type::OBJ, \"\", \"\",\n-                                    {\n-                                        {RPCResult::Type::STR_HEX, \"txid\", \"The transaction id\"},\n-                                        {RPCResult::Type::NUM, \"vout\", \"The vout value\"},\n-                                        {RPCResult::Type::STR_HEX, \"scriptPubKey\", \"The script key\"},\n-                                        {RPCResult::Type::STR, \"desc\", \"A specialized descriptor for the matched scriptPubKey\"},\n-                                        {RPCResult::Type::STR_AMOUNT, \"amount\", \"The total amount in \" + CURRENCY_UNIT + \" of the unspent output\"},\n-                                        {RPCResult::Type::NUM, \"height\", \"Height of the unspent transaction output\"},\n-                                    }},\n-                            }},\n-                        {RPCResult::Type::STR_AMOUNT, \"total_amount\", \"The total amount of all found unspent outputs in \" + CURRENCY_UNIT},\n+                        {RPCResult::Type::STR_HEX, \"txid\", \"The transaction id\"},\n+                        {RPCResult::Type::NUM, \"vout\", \"The vout value\"},\n+                        {RPCResult::Type::STR_HEX, \"scriptPubKey\", \"The script key\"},\n+                        {RPCResult::Type::STR, \"desc\", \"A specialized descriptor for the matched scriptPubKey\"},\n+                        {RPCResult::Type::STR_AMOUNT, \"amount\", \"The total amount in \" + CURRENCY_UNIT + \" of the unspent output\"},\n+                        {RPCResult::Type::NUM, \"height\", \"Height of the unspent transaction output\"},\n                     }},\n-                RPCExamples{\"\"},\n+                }},\n+                {RPCResult::Type::STR_AMOUNT, \"total_amount\", \"The total amount of all found unspent outputs in \" + CURRENCY_UNIT},\n+            }},\n+        },\n+        RPCExamples{\"\"},\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n     RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n@@ -2444,7 +2447,7 @@ UniValue CreateUTXOSnapshot(NodeContext& node, CChainState& chainstate, CAutoFil\n \n         chainstate.ForceFlushStateToDisk();\n \n-        if (!GetUTXOStats(&chainstate.CoinsDB(), stats, CoinStatsHashType::NONE, node.rpc_interruption_point)) {\n+        if (!GetUTXOStats(&chainstate.CoinsDB(), chainstate.m_blockman, stats, CoinStatsHashType::NONE, node.rpc_interruption_point)) {\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Unable to read UTXO set\");\n         }\n "
      },
      {
        "sha": "fd780ba78289344cdeee3841a23fddd2a1ba7cce",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 87,
        "deletions": 83,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -150,7 +150,7 @@ static UniValue generateBlocks(ChainstateManager& chainman, const CTxMemPool& me\n     UniValue blockHashes(UniValue::VARR);\n     while (nHeight < nHeightEnd && !ShutdownRequested())\n     {\n-        std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(mempool, Params()).CreateNewBlock(coinbase_script));\n+        std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(mempool, Params()).CreateNewBlock(::ChainstateActive(), coinbase_script));\n         if (!pblocktemplate.get())\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Couldn't create new block\");\n         CBlock *pblock = &pblocktemplate->block;\n@@ -358,7 +358,7 @@ static RPCHelpMan generateblock()\n         LOCK(cs_main);\n \n         CTxMemPool empty_mempool;\n-        std::unique_ptr<CBlockTemplate> blocktemplate(BlockAssembler(empty_mempool, chainparams).CreateNewBlock(coinbase_script));\n+        std::unique_ptr<CBlockTemplate> blocktemplate(BlockAssembler(empty_mempool, chainparams).CreateNewBlock(::ChainstateActive(), coinbase_script));\n         if (!blocktemplate) {\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Couldn't create new block\");\n         }\n@@ -369,7 +369,7 @@ static RPCHelpMan generateblock()\n \n     // Add transactions\n     block.vtx.insert(block.vtx.end(), txs.begin(), txs.end());\n-    RegenerateCommitments(block);\n+    RegenerateCommitments(block, WITH_LOCK(::cs_main, return std::ref(g_chainman.m_blockman)));\n \n     {\n         LOCK(cs_main);\n@@ -505,83 +505,84 @@ static std::string gbt_vb_name(const Consensus::DeploymentPos pos) {\n static RPCHelpMan getblocktemplate()\n {\n     return RPCHelpMan{\"getblocktemplate\",\n-                \"\\nIf the request parameters include a 'mode' key, that is used to explicitly select between the default 'template' request or a 'proposal'.\\n\"\n-                \"It returns data needed to construct a block to work on.\\n\"\n-                \"For full specification, see BIPs 22, 23, 9, and 145:\\n\"\n-                \"    https://github.com/bitcoin/bips/blob/master/bip-0022.mediawiki\\n\"\n-                \"    https://github.com/bitcoin/bips/blob/master/bip-0023.mediawiki\\n\"\n-                \"    https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki#getblocktemplate_changes\\n\"\n-                \"    https://github.com/bitcoin/bips/blob/master/bip-0145.mediawiki\\n\",\n+        \"\\nIf the request parameters include a 'mode' key, that is used to explicitly select between the default 'template' request or a 'proposal'.\\n\"\n+        \"It returns data needed to construct a block to work on.\\n\"\n+        \"For full specification, see BIPs 22, 23, 9, and 145:\\n\"\n+        \"    https://github.com/bitcoin/bips/blob/master/bip-0022.mediawiki\\n\"\n+        \"    https://github.com/bitcoin/bips/blob/master/bip-0023.mediawiki\\n\"\n+        \"    https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki#getblocktemplate_changes\\n\"\n+        \"    https://github.com/bitcoin/bips/blob/master/bip-0145.mediawiki\\n\",\n+        {\n+            {\"template_request\", RPCArg::Type::OBJ, \"{}\", \"Format of the template\",\n+            {\n+                {\"mode\", RPCArg::Type::STR, /* treat as named arg */ RPCArg::Optional::OMITTED_NAMED_ARG, \"This must be set to \\\"template\\\", \\\"proposal\\\" (see BIP 23), or omitted\"},\n+                {\"capabilities\", RPCArg::Type::ARR, /* treat as named arg */ RPCArg::Optional::OMITTED_NAMED_ARG, \"A list of strings\",\n                 {\n-                    {\"template_request\", RPCArg::Type::OBJ, \"{}\", \"Format of the template\",\n-                        {\n-                            {\"mode\", RPCArg::Type::STR, /* treat as named arg */ RPCArg::Optional::OMITTED_NAMED_ARG, \"This must be set to \\\"template\\\", \\\"proposal\\\" (see BIP 23), or omitted\"},\n-                            {\"capabilities\", RPCArg::Type::ARR, /* treat as named arg */ RPCArg::Optional::OMITTED_NAMED_ARG, \"A list of strings\",\n-                                {\n-                                    {\"str\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"client side supported feature, 'longpoll', 'coinbasevalue', 'proposal', 'serverlist', 'workid'\"},\n-                                },\n-                                },\n-                            {\"rules\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"A list of strings\",\n-                                {\n-                                    {\"segwit\", RPCArg::Type::STR, RPCArg::Optional::NO, \"(literal) indicates client side segwit support\"},\n-                                    {\"str\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"other client side supported softfork deployment\"},\n-                                },\n-                                },\n-                        },\n+                    {\"str\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"client side supported feature, 'longpoll', 'coinbasevalue', 'proposal', 'serverlist', 'workid'\"},\n+                }},\n+                {\"rules\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"A list of strings\",\n+                {\n+                    {\"segwit\", RPCArg::Type::STR, RPCArg::Optional::NO, \"(literal) indicates client side segwit support\"},\n+                    {\"str\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"other client side supported softfork deployment\"},\n+                }},\n+            },\n                         \"\\\"template_request\\\"\"},\n-                },\n-                RPCResult{\n-                    RPCResult::Type::OBJ, \"\", \"\",\n+        },\n+        {\n+            RPCResult{\"If the proposal was accepted with mode=='proposal'\", RPCResult::Type::NONE, \"\", \"\"},\n+            RPCResult{\"If the proposal was not accepted with mode=='proposal'\", RPCResult::Type::STR, \"\", \"According to BIP22\"},\n+            RPCResult{\"Otherwise\", RPCResult::Type::OBJ, \"\", \"\",\n+            {\n+                {RPCResult::Type::NUM, \"version\", \"The preferred block version\"},\n+                {RPCResult::Type::ARR, \"rules\", \"specific block rules that are to be enforced\",\n+                {\n+                    {RPCResult::Type::STR, \"\", \"name of a rule the client must understand to some extent; see BIP 9 for format\"},\n+                }},\n+                {RPCResult::Type::OBJ_DYN, \"vbavailable\", \"set of pending, supported versionbit (BIP 9) softfork deployments\",\n+                {\n+                    {RPCResult::Type::NUM, \"rulename\", \"identifies the bit number as indicating acceptance and readiness for the named softfork rule\"},\n+                }},\n+                {RPCResult::Type::NUM, \"vbrequired\", \"bit mask of versionbits the server requires set in submissions\"},\n+                {RPCResult::Type::STR, \"previousblockhash\", \"The hash of current highest block\"},\n+                {RPCResult::Type::ARR, \"transactions\", \"contents of non-coinbase transactions that should be included in the next block\",\n+                {\n+                    {RPCResult::Type::OBJ, \"\", \"\",\n                     {\n-                        {RPCResult::Type::NUM, \"version\", \"The preferred block version\"},\n-                        {RPCResult::Type::ARR, \"rules\", \"specific block rules that are to be enforced\",\n-                            {\n-                                {RPCResult::Type::STR, \"\", \"name of a rule the client must understand to some extent; see BIP 9 for format\"},\n-                            }},\n-                        {RPCResult::Type::OBJ_DYN, \"vbavailable\", \"set of pending, supported versionbit (BIP 9) softfork deployments\",\n-                            {\n-                                {RPCResult::Type::NUM, \"rulename\", \"identifies the bit number as indicating acceptance and readiness for the named softfork rule\"},\n-                            }},\n-                        {RPCResult::Type::NUM, \"vbrequired\", \"bit mask of versionbits the server requires set in submissions\"},\n-                        {RPCResult::Type::STR, \"previousblockhash\", \"The hash of current highest block\"},\n-                        {RPCResult::Type::ARR, \"transactions\", \"contents of non-coinbase transactions that should be included in the next block\",\n-                            {\n-                                {RPCResult::Type::OBJ, \"\", \"\",\n-                                    {\n-                                        {RPCResult::Type::STR_HEX, \"data\", \"transaction data encoded in hexadecimal (byte-for-byte)\"},\n-                                        {RPCResult::Type::STR_HEX, \"txid\", \"transaction id encoded in little-endian hexadecimal\"},\n-                                        {RPCResult::Type::STR_HEX, \"hash\", \"hash encoded in little-endian hexadecimal (including witness data)\"},\n-                                        {RPCResult::Type::ARR, \"depends\", \"array of numbers\",\n-                                            {\n-                                                {RPCResult::Type::NUM, \"\", \"transactions before this one (by 1-based index in 'transactions' list) that must be present in the final block if this one is\"},\n-                                            }},\n-                                        {RPCResult::Type::NUM, \"fee\", \"difference in value between transaction inputs and outputs (in satoshis); for coinbase transactions, this is a negative Number of the total collected block fees (ie, not including the block subsidy); if key is not present, fee is unknown and clients MUST NOT assume there isn't one\"},\n-                                        {RPCResult::Type::NUM, \"sigops\", \"total SigOps cost, as counted for purposes of block limits; if key is not present, sigop cost is unknown and clients MUST NOT assume it is zero\"},\n-                                        {RPCResult::Type::NUM, \"weight\", \"total transaction weight, as counted for purposes of block limits\"},\n-                                    }},\n-                            }},\n-                        {RPCResult::Type::OBJ_DYN, \"coinbaseaux\", \"data that should be included in the coinbase's scriptSig content\",\n+                        {RPCResult::Type::STR_HEX, \"data\", \"transaction data encoded in hexadecimal (byte-for-byte)\"},\n+                        {RPCResult::Type::STR_HEX, \"txid\", \"transaction id encoded in little-endian hexadecimal\"},\n+                        {RPCResult::Type::STR_HEX, \"hash\", \"hash encoded in little-endian hexadecimal (including witness data)\"},\n+                        {RPCResult::Type::ARR, \"depends\", \"array of numbers\",\n                         {\n-                            {RPCResult::Type::STR_HEX, \"key\", \"values must be in the coinbase (keys may be ignored)\"},\n+                            {RPCResult::Type::NUM, \"\", \"transactions before this one (by 1-based index in 'transactions' list) that must be present in the final block if this one is\"},\n                         }},\n-                        {RPCResult::Type::NUM, \"coinbasevalue\", \"maximum allowable input to coinbase transaction, including the generation award and transaction fees (in satoshis)\"},\n-                        {RPCResult::Type::STR, \"longpollid\", \"an id to include with a request to longpoll on an update to this template\"},\n-                        {RPCResult::Type::STR, \"target\", \"The hash target\"},\n-                        {RPCResult::Type::NUM_TIME, \"mintime\", \"The minimum timestamp appropriate for the next block time, expressed in \" + UNIX_EPOCH_TIME},\n-                        {RPCResult::Type::ARR, \"mutable\", \"list of ways the block template may be changed\",\n-                            {\n-                                {RPCResult::Type::STR, \"value\", \"A way the block template may be changed, e.g. 'time', 'transactions', 'prevblock'\"},\n-                            }},\n-                        {RPCResult::Type::STR_HEX, \"noncerange\", \"A range of valid nonces\"},\n-                        {RPCResult::Type::NUM, \"sigoplimit\", \"limit of sigops in blocks\"},\n-                        {RPCResult::Type::NUM, \"sizelimit\", \"limit of block size\"},\n-                        {RPCResult::Type::NUM, \"weightlimit\", \"limit of block weight\"},\n-                        {RPCResult::Type::NUM_TIME, \"curtime\", \"current timestamp in \" + UNIX_EPOCH_TIME},\n-                        {RPCResult::Type::STR, \"bits\", \"compressed target of next block\"},\n-                        {RPCResult::Type::NUM, \"height\", \"The height of the next block\"},\n-                        {RPCResult::Type::STR, \"default_witness_commitment\", /* optional */ true, \"a valid witness commitment for the unmodified block template\"}\n+                        {RPCResult::Type::NUM, \"fee\", \"difference in value between transaction inputs and outputs (in satoshis); for coinbase transactions, this is a negative Number of the total collected block fees (ie, not including the block subsidy); if key is not present, fee is unknown and clients MUST NOT assume there isn't one\"},\n+                        {RPCResult::Type::NUM, \"sigops\", \"total SigOps cost, as counted for purposes of block limits; if key is not present, sigop cost is unknown and clients MUST NOT assume it is zero\"},\n+                        {RPCResult::Type::NUM, \"weight\", \"total transaction weight, as counted for purposes of block limits\"},\n                     }},\n-                RPCExamples{\n+                }},\n+                {RPCResult::Type::OBJ_DYN, \"coinbaseaux\", \"data that should be included in the coinbase's scriptSig content\",\n+                {\n+                    {RPCResult::Type::STR_HEX, \"key\", \"values must be in the coinbase (keys may be ignored)\"},\n+                }},\n+                {RPCResult::Type::NUM, \"coinbasevalue\", \"maximum allowable input to coinbase transaction, including the generation award and transaction fees (in satoshis)\"},\n+                {RPCResult::Type::STR, \"longpollid\", \"an id to include with a request to longpoll on an update to this template\"},\n+                {RPCResult::Type::STR, \"target\", \"The hash target\"},\n+                {RPCResult::Type::NUM_TIME, \"mintime\", \"The minimum timestamp appropriate for the next block time, expressed in \" + UNIX_EPOCH_TIME},\n+                {RPCResult::Type::ARR, \"mutable\", \"list of ways the block template may be changed\",\n+                {\n+                    {RPCResult::Type::STR, \"value\", \"A way the block template may be changed, e.g. 'time', 'transactions', 'prevblock'\"},\n+                }},\n+                {RPCResult::Type::STR_HEX, \"noncerange\", \"A range of valid nonces\"},\n+                {RPCResult::Type::NUM, \"sigoplimit\", \"limit of sigops in blocks\"},\n+                {RPCResult::Type::NUM, \"sizelimit\", \"limit of block size\"},\n+                {RPCResult::Type::NUM, \"weightlimit\", \"limit of block weight\"},\n+                {RPCResult::Type::NUM_TIME, \"curtime\", \"current timestamp in \" + UNIX_EPOCH_TIME},\n+                {RPCResult::Type::STR, \"bits\", \"compressed target of next block\"},\n+                {RPCResult::Type::NUM, \"height\", \"The height of the next block\"},\n+                {RPCResult::Type::STR, \"default_witness_commitment\", /* optional */ true, \"a valid witness commitment for the unmodified block template\"},\n+            }},\n+        },\n+        RPCExamples{\n                     HelpExampleCli(\"getblocktemplate\", \"'{\\\"rules\\\": [\\\"segwit\\\"]}'\")\n             + HelpExampleRpc(\"getblocktemplate\", \"{\\\"rules\\\": [\\\"segwit\\\"]}\")\n                 },\n@@ -747,7 +748,7 @@ static RPCHelpMan getblocktemplate()\n \n         // Create new block\n         CScript scriptDummy = CScript() << OP_TRUE;\n-        pblocktemplate = BlockAssembler(mempool, Params()).CreateNewBlock(scriptDummy);\n+        pblocktemplate = BlockAssembler(mempool, Params()).CreateNewBlock(::ChainstateActive(), scriptDummy);\n         if (!pblocktemplate)\n             throw JSONRPCError(RPC_OUT_OF_MEMORY, \"Out of memory\");\n \n@@ -940,14 +941,17 @@ static RPCHelpMan submitblock()\n {\n     // We allow 2 arguments for compliance with BIP22. Argument 2 is ignored.\n     return RPCHelpMan{\"submitblock\",\n-                \"\\nAttempts to submit new block to network.\\n\"\n-                \"See https://en.bitcoin.it/wiki/BIP_0022 for full specification.\\n\",\n-                {\n-                    {\"hexdata\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"the hex-encoded block data to submit\"},\n-                    {\"dummy\", RPCArg::Type::STR, /* default */ \"ignored\", \"dummy value, for compatibility with BIP22. This value is ignored.\"},\n-                },\n-                RPCResult{RPCResult::Type::NONE, \"\", \"Returns JSON Null when valid, a string according to BIP22 otherwise\"},\n-                RPCExamples{\n+        \"\\nAttempts to submit new block to network.\\n\"\n+        \"See https://en.bitcoin.it/wiki/BIP_0022 for full specification.\\n\",\n+        {\n+            {\"hexdata\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"the hex-encoded block data to submit\"},\n+            {\"dummy\", RPCArg::Type::STR, /* default */ \"ignored\", \"dummy value, for compatibility with BIP22. This value is ignored.\"},\n+        },\n+        {\n+            RPCResult{\"If the block was accepted\", RPCResult::Type::NONE, \"\", \"\"},\n+            RPCResult{\"Otherwise\", RPCResult::Type::STR, \"\", \"According to BIP22\"},\n+        },\n+        RPCExamples{\n                     HelpExampleCli(\"submitblock\", \"\\\"mydata\\\"\")\n             + HelpExampleRpc(\"submitblock\", \"\\\"mydata\\\"\")\n                 },"
      },
      {
        "sha": "d4c1ab4b53202d8ca34e5a0e904c1081b71e8b3c",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -914,7 +914,7 @@ static RPCHelpMan addpeeraddress()\n     UniValue obj(UniValue::VOBJ);\n \n     std::string addr_string = request.params[0].get_str();\n-    uint16_t port = request.params[1].get_int();\n+    uint16_t port{static_cast<uint16_t>(request.params[1].get_int())};\n \n     CNetAddr net_addr;\n     if (!LookupHost(addr_string, net_addr, false)) {"
      },
      {
        "sha": "2f92a321f8ec846973e5e1783c1fdff43b68a38b",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1828,13 +1828,13 @@ static RPCHelpMan analyzepsbt()\n     }\n     if (!inputs_result.empty()) result.pushKV(\"inputs\", inputs_result);\n \n-    if (psbta.estimated_vsize != nullopt) {\n+    if (psbta.estimated_vsize != std::nullopt) {\n         result.pushKV(\"estimated_vsize\", (int)*psbta.estimated_vsize);\n     }\n-    if (psbta.estimated_feerate != nullopt) {\n+    if (psbta.estimated_feerate != std::nullopt) {\n         result.pushKV(\"estimated_feerate\", ValueFromAmount(psbta.estimated_feerate->GetFeePerK()));\n     }\n-    if (psbta.fee != nullopt) {\n+    if (psbta.fee != std::nullopt) {\n         result.pushKV(\"fee\", ValueFromAmount(*psbta.fee));\n     }\n     result.pushKV(\"next\", PSBTRoleName(psbta.next));"
      },
      {
        "sha": "27d06f3c92802d97e353c1dc381d22d8944f3b95",
        "filename": "src/rpc/request.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/rpc/request.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/rpc/request.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/request.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -34,19 +34,19 @@ class JSONRPCRequest\n     UniValue id;\n     std::string strMethod;\n     UniValue params;\n-    bool fHelp;\n+    enum Mode { EXECUTE, GET_HELP, GET_ARGS } mode = EXECUTE;\n     std::string URI;\n     std::string authUser;\n     std::string peerAddr;\n     const util::Ref& context;\n \n-    explicit JSONRPCRequest(const util::Ref& context) : id(NullUniValue), params(NullUniValue), fHelp(false), context(context) {}\n+    explicit JSONRPCRequest(const util::Ref& context) : id(NullUniValue), params(NullUniValue), context(context) {}\n \n     //! Initializes request information from another request object and the\n     //! given context. The implementation should be updated if any members are\n     //! added or removed above.\n     JSONRPCRequest(const JSONRPCRequest& other, const util::Ref& context)\n-        : id(other.id), strMethod(other.strMethod), params(other.params), fHelp(other.fHelp), URI(other.URI),\n+        : id(other.id), strMethod(other.strMethod), params(other.params), mode(other.mode), URI(other.URI),\n           authUser(other.authUser), peerAddr(other.peerAddr), context(context)\n     {\n     }"
      },
      {
        "sha": "39938f4eb9836284a07fbfe0e48d83f0b96b564f",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 10,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -88,7 +88,7 @@ std::string CRPCTable::help(const std::string& strCommand, const JSONRPCRequest&\n     sort(vCommands.begin(), vCommands.end());\n \n     JSONRPCRequest jreq(helpreq);\n-    jreq.fHelp = true;\n+    jreq.mode = JSONRPCRequest::GET_HELP;\n     jreq.params = UniValue();\n \n     for (const std::pair<std::string, const CRPCCommand*>& command : vCommands)\n@@ -149,7 +149,7 @@ static RPCHelpMan help()\n     }\n     if (strCommand == \"dump_all_command_conversions\") {\n         // Used for testing only, undocumented\n-        return tableRPC.dumpArgMap();\n+        return tableRPC.dumpArgMap(jsonRequest);\n     }\n \n     return tableRPC.help(strCommand, jsonRequest);\n@@ -437,6 +437,16 @@ static inline JSONRPCRequest transformNamedArguments(const JSONRPCRequest& in, c\n     return out;\n }\n \n+static bool ExecuteCommands(const std::vector<const CRPCCommand*>& commands, const JSONRPCRequest& request, UniValue& result)\n+{\n+    for (const auto& command : commands) {\n+        if (ExecuteCommand(*command, request, result, &command == &commands.back())) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n UniValue CRPCTable::execute(const JSONRPCRequest &request) const\n {\n     // Return immediately if in warmup\n@@ -450,10 +460,8 @@ UniValue CRPCTable::execute(const JSONRPCRequest &request) const\n     auto it = mapCommands.find(request.strMethod);\n     if (it != mapCommands.end()) {\n         UniValue result;\n-        for (const auto& command : it->second) {\n-            if (ExecuteCommand(*command, request, result, &command == &it->second.back())) {\n-                return result;\n-            }\n+        if (ExecuteCommands(it->second, request, result)) {\n+            return result;\n         }\n     }\n     throw JSONRPCError(RPC_METHOD_NOT_FOUND, \"Method not found\");\n@@ -484,13 +492,18 @@ std::vector<std::string> CRPCTable::listCommands() const\n     return commandList;\n }\n \n-UniValue CRPCTable::dumpArgMap() const\n+UniValue CRPCTable::dumpArgMap(const JSONRPCRequest& args_request) const\n {\n+    JSONRPCRequest request(args_request);\n+    request.mode = JSONRPCRequest::GET_ARGS;\n+\n     UniValue ret{UniValue::VARR};\n     for (const auto& cmd : mapCommands) {\n-        for (const auto& c : cmd.second) {\n-            const auto help = RpcMethodFnType(c->unique_id)();\n-            help.AppendArgMap(ret);\n+        UniValue result;\n+        if (ExecuteCommands(cmd.second, request, result)) {\n+            for (const auto& values : result.getValues()) {\n+                ret.push_back(values);\n+            }\n         }\n     }\n     return ret;"
      },
      {
        "sha": "03967020c2ec6095717221749874cfc61bb9f77e",
        "filename": "src/rpc/server.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/rpc/server.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/rpc/server.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -148,7 +148,7 @@ class CRPCTable\n     /**\n      * Return all named arguments that need to be converted by the client from string to another JSON type\n      */\n-    UniValue dumpArgMap() const;\n+    UniValue dumpArgMap(const JSONRPCRequest& request) const;\n \n     /**\n      * Appends a CRPCCommand to the dispatch table."
      },
      {
        "sha": "44e58cb75fe5bc321549136a6ce5b0f73742fcde",
        "filename": "src/rpc/util.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 1,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/rpc/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/rpc/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -459,6 +459,21 @@ std::string RPCExamples::ToDescriptionString() const\n     return m_examples.empty() ? m_examples : \"\\nExamples:\\n\" + m_examples;\n }\n \n+UniValue RPCHelpMan::HandleRequest(const JSONRPCRequest& request)\n+{\n+    if (request.mode == JSONRPCRequest::GET_ARGS) {\n+        return GetArgMap();\n+    }\n+    /*\n+     * Check if the given request is valid according to this command or if\n+     * the user is asking for help information, and throw help when appropriate.\n+     */\n+    if (request.mode == JSONRPCRequest::GET_HELP || !IsValidNumArgs(request.params.size())) {\n+        throw std::runtime_error(ToString());\n+    }\n+    return m_fun(*this, request);\n+}\n+\n bool RPCHelpMan::IsValidNumArgs(size_t num_args) const\n {\n     size_t num_required_args = 0;\n@@ -532,8 +547,9 @@ std::string RPCHelpMan::ToString() const\n     return ret;\n }\n \n-void RPCHelpMan::AppendArgMap(UniValue& arr) const\n+UniValue RPCHelpMan::GetArgMap() const\n {\n+    UniValue arr{UniValue::VARR};\n     for (int i{0}; i < int(m_args.size()); ++i) {\n         const auto& arg = m_args.at(i);\n         std::vector<std::string> arg_names;\n@@ -548,6 +564,7 @@ void RPCHelpMan::AppendArgMap(UniValue& arr) const\n             arr.push_back(map);\n         }\n     }\n+    return arr;\n }\n \n std::string RPCArg::GetFirstName() const"
      },
      {
        "sha": "94c2d2d626470b9477af89dcfbe3e10955bf4888",
        "filename": "src/rpc/util.h",
        "status": "modified",
        "additions": 3,
        "deletions": 17,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/rpc/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/rpc/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -333,26 +333,12 @@ class RPCHelpMan\n     using RPCMethodImpl = std::function<UniValue(const RPCHelpMan&, const JSONRPCRequest&)>;\n     RPCHelpMan(std::string name, std::string description, std::vector<RPCArg> args, RPCResults results, RPCExamples examples, RPCMethodImpl fun);\n \n+    UniValue HandleRequest(const JSONRPCRequest& request);\n     std::string ToString() const;\n-    /** Append the named args that need to be converted from string to another JSON type */\n-    void AppendArgMap(UniValue& arr) const;\n-    UniValue HandleRequest(const JSONRPCRequest& request)\n-    {\n-        Check(request);\n-        return m_fun(*this, request);\n-    }\n+    /** Return the named args that need to be converted from string to another JSON type */\n+    UniValue GetArgMap() const;\n     /** If the supplied number of args is neither too small nor too high */\n     bool IsValidNumArgs(size_t num_args) const;\n-    /**\n-     * Check if the given request is valid according to this command or if\n-     * the user is asking for help information, and throw help when appropriate.\n-     */\n-    inline void Check(const JSONRPCRequest& request) const {\n-        if (request.fHelp || !IsValidNumArgs(request.params.size())) {\n-            throw std::runtime_error(ToString());\n-        }\n-    }\n-\n     std::vector<std::string> GetArgNames() const;\n \n     const std::string m_name;"
      },
      {
        "sha": "30399dca5125627d124bc467d04110166242a7b4",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 32,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -17,6 +17,7 @@\n #include <util/vector.h>\n \n #include <memory>\n+#include <optional>\n #include <string>\n #include <vector>\n \n@@ -632,7 +633,7 @@ class DescriptorImpl : public Descriptor\n         }\n     }\n \n-    Optional<OutputType> GetOutputType() const override { return nullopt; }\n+    std::optional<OutputType> GetOutputType() const override { return std::nullopt; }\n };\n \n /** A parsed addr(A) descriptor. */\n@@ -646,7 +647,7 @@ class AddressDescriptor final : public DescriptorImpl\n     AddressDescriptor(CTxDestination destination) : DescriptorImpl({}, {}, \"addr\"), m_destination(std::move(destination)) {}\n     bool IsSolvable() const final { return false; }\n \n-    Optional<OutputType> GetOutputType() const override\n+    std::optional<OutputType> GetOutputType() const override\n     {\n         switch (m_destination.index()) {\n             case 1 /* PKHash */:\n@@ -655,7 +656,7 @@ class AddressDescriptor final : public DescriptorImpl\n             case 4 /* WitnessV0KeyHash */:\n             case 5 /* WitnessUnknown */: return OutputType::BECH32;\n             case 0 /* CNoDestination */:\n-            default: return nullopt;\n+            default: return std::nullopt;\n         }\n     }\n     bool IsSingleType() const final { return true; }\n@@ -672,7 +673,7 @@ class RawDescriptor final : public DescriptorImpl\n     RawDescriptor(CScript script) : DescriptorImpl({}, {}, \"raw\"), m_script(std::move(script)) {}\n     bool IsSolvable() const final { return false; }\n \n-    Optional<OutputType> GetOutputType() const override\n+    std::optional<OutputType> GetOutputType() const override\n     {\n         CTxDestination dest;\n         ExtractDestination(m_script, dest);\n@@ -683,7 +684,7 @@ class RawDescriptor final : public DescriptorImpl\n             case 4 /* WitnessV0KeyHash */:\n             case 5 /* WitnessUnknown */: return OutputType::BECH32;\n             case 0 /* CNoDestination */:\n-            default: return nullopt;\n+            default: return std::nullopt;\n         }\n     }\n     bool IsSingleType() const final { return true; }\n@@ -711,7 +712,7 @@ class PKHDescriptor final : public DescriptorImpl\n     }\n public:\n     PKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Vector(std::move(prov)), {}, \"pkh\") {}\n-    Optional<OutputType> GetOutputType() const override { return OutputType::LEGACY; }\n+    std::optional<OutputType> GetOutputType() const override { return OutputType::LEGACY; }\n     bool IsSingleType() const final { return true; }\n };\n \n@@ -727,7 +728,7 @@ class WPKHDescriptor final : public DescriptorImpl\n     }\n public:\n     WPKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Vector(std::move(prov)), {}, \"wpkh\") {}\n-    Optional<OutputType> GetOutputType() const override { return OutputType::BECH32; }\n+    std::optional<OutputType> GetOutputType() const override { return OutputType::BECH32; }\n     bool IsSingleType() const final { return true; }\n };\n \n@@ -783,7 +784,7 @@ class SHDescriptor final : public DescriptorImpl\n public:\n     SHDescriptor(std::unique_ptr<DescriptorImpl> desc) : DescriptorImpl({}, std::move(desc), \"sh\") {}\n \n-    Optional<OutputType> GetOutputType() const override\n+    std::optional<OutputType> GetOutputType() const override\n     {\n         assert(m_subdescriptor_arg);\n         if (m_subdescriptor_arg->GetOutputType() == OutputType::BECH32) return OutputType::P2SH_SEGWIT;\n@@ -799,7 +800,7 @@ class WSHDescriptor final : public DescriptorImpl\n     std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript* script, FlatSigningProvider&) const override { return Vector(GetScriptForDestination(WitnessV0ScriptHash(*script))); }\n public:\n     WSHDescriptor(std::unique_ptr<DescriptorImpl> desc) : DescriptorImpl({}, std::move(desc), \"wsh\") {}\n-    Optional<OutputType> GetOutputType() const override { return OutputType::BECH32; }\n+    std::optional<OutputType> GetOutputType() const override { return OutputType::BECH32; }\n     bool IsSingleType() const final { return true; }\n };\n \n@@ -853,7 +854,7 @@ std::unique_ptr<PubkeyProvider> ParsePubkeyInner(uint32_t key_exp_index, const S\n             CPubKey pubkey(data);\n             if (pubkey.IsFullyValid()) {\n                 if (permit_uncompressed || pubkey.IsCompressed()) {\n-                    return MakeUnique<ConstPubkeyProvider>(key_exp_index, pubkey);\n+                    return std::make_unique<ConstPubkeyProvider>(key_exp_index, pubkey);\n                 } else {\n                     error = \"Uncompressed keys are not allowed\";\n                     return nullptr;\n@@ -867,7 +868,7 @@ std::unique_ptr<PubkeyProvider> ParsePubkeyInner(uint32_t key_exp_index, const S\n             if (permit_uncompressed || key.IsCompressed()) {\n                 CPubKey pubkey = key.GetPubKey();\n                 out.keys.emplace(pubkey.GetID(), key);\n-                return MakeUnique<ConstPubkeyProvider>(key_exp_index, pubkey);\n+                return std::make_unique<ConstPubkeyProvider>(key_exp_index, pubkey);\n             } else {\n                 error = \"Uncompressed keys are not allowed\";\n                 return nullptr;\n@@ -894,7 +895,7 @@ std::unique_ptr<PubkeyProvider> ParsePubkeyInner(uint32_t key_exp_index, const S\n         extpubkey = extkey.Neuter();\n         out.keys.emplace(extpubkey.pubkey.GetID(), extkey.key);\n     }\n-    return MakeUnique<BIP32PubkeyProvider>(key_exp_index, extpubkey, std::move(path), type);\n+    return std::make_unique<BIP32PubkeyProvider>(key_exp_index, extpubkey, std::move(path), type);\n }\n \n /** Parse a public key including origin information (if enabled). */\n@@ -931,7 +932,7 @@ std::unique_ptr<PubkeyProvider> ParsePubkey(uint32_t key_exp_index, const Span<c\n     if (!ParseKeyPath(slash_split, info.path, error)) return nullptr;\n     auto provider = ParsePubkeyInner(key_exp_index, origin_split[1], permit_uncompressed, out, error);\n     if (!provider) return nullptr;\n-    return MakeUnique<OriginPubkeyProvider>(key_exp_index, std::move(info), std::move(provider));\n+    return std::make_unique<OriginPubkeyProvider>(key_exp_index, std::move(info), std::move(provider));\n }\n \n /** Parse a script in a particular context. */\n@@ -944,17 +945,17 @@ std::unique_ptr<DescriptorImpl> ParseScript(uint32_t key_exp_index, Span<const c\n     if (Func(\"pk\", expr)) {\n         auto pubkey = ParsePubkey(key_exp_index, expr, ctx != ParseScriptContext::P2WSH, out, error);\n         if (!pubkey) return nullptr;\n-        return MakeUnique<PKDescriptor>(std::move(pubkey));\n+        return std::make_unique<PKDescriptor>(std::move(pubkey));\n     }\n     if (Func(\"pkh\", expr)) {\n         auto pubkey = ParsePubkey(key_exp_index, expr, ctx != ParseScriptContext::P2WSH, out, error);\n         if (!pubkey) return nullptr;\n-        return MakeUnique<PKHDescriptor>(std::move(pubkey));\n+        return std::make_unique<PKHDescriptor>(std::move(pubkey));\n     }\n     if (ctx == ParseScriptContext::TOP && Func(\"combo\", expr)) {\n         auto pubkey = ParsePubkey(key_exp_index, expr, true, out, error);\n         if (!pubkey) return nullptr;\n-        return MakeUnique<ComboDescriptor>(std::move(pubkey));\n+        return std::make_unique<ComboDescriptor>(std::move(pubkey));\n     } else if (ctx != ParseScriptContext::TOP && Func(\"combo\", expr)) {\n         error = \"Cannot have combo in non-top level\";\n         return nullptr;\n@@ -1002,28 +1003,28 @@ std::unique_ptr<DescriptorImpl> ParseScript(uint32_t key_exp_index, Span<const c\n                 return nullptr;\n             }\n         }\n-        return MakeUnique<MultisigDescriptor>(thres, std::move(providers), sorted_multi);\n+        return std::make_unique<MultisigDescriptor>(thres, std::move(providers), sorted_multi);\n     }\n     if (ctx != ParseScriptContext::P2WSH && Func(\"wpkh\", expr)) {\n         auto pubkey = ParsePubkey(key_exp_index, expr, false, out, error);\n         if (!pubkey) return nullptr;\n-        return MakeUnique<WPKHDescriptor>(std::move(pubkey));\n+        return std::make_unique<WPKHDescriptor>(std::move(pubkey));\n     } else if (ctx == ParseScriptContext::P2WSH && Func(\"wpkh\", expr)) {\n         error = \"Cannot have wpkh within wsh\";\n         return nullptr;\n     }\n     if (ctx == ParseScriptContext::TOP && Func(\"sh\", expr)) {\n         auto desc = ParseScript(key_exp_index, expr, ParseScriptContext::P2SH, out, error);\n         if (!desc || expr.size()) return nullptr;\n-        return MakeUnique<SHDescriptor>(std::move(desc));\n+        return std::make_unique<SHDescriptor>(std::move(desc));\n     } else if (ctx != ParseScriptContext::TOP && Func(\"sh\", expr)) {\n         error = \"Cannot have sh in non-top level\";\n         return nullptr;\n     }\n     if (ctx != ParseScriptContext::P2WSH && Func(\"wsh\", expr)) {\n         auto desc = ParseScript(key_exp_index, expr, ParseScriptContext::P2WSH, out, error);\n         if (!desc || expr.size()) return nullptr;\n-        return MakeUnique<WSHDescriptor>(std::move(desc));\n+        return std::make_unique<WSHDescriptor>(std::move(desc));\n     } else if (ctx == ParseScriptContext::P2WSH && Func(\"wsh\", expr)) {\n         error = \"Cannot have wsh within wsh\";\n         return nullptr;\n@@ -1034,7 +1035,7 @@ std::unique_ptr<DescriptorImpl> ParseScript(uint32_t key_exp_index, Span<const c\n             error = \"Address is not valid\";\n             return nullptr;\n         }\n-        return MakeUnique<AddressDescriptor>(std::move(dest));\n+        return std::make_unique<AddressDescriptor>(std::move(dest));\n     }\n     if (ctx == ParseScriptContext::TOP && Func(\"raw\", expr)) {\n         std::string str(expr.begin(), expr.end());\n@@ -1043,7 +1044,7 @@ std::unique_ptr<DescriptorImpl> ParseScript(uint32_t key_exp_index, Span<const c\n             return nullptr;\n         }\n         auto bytes = ParseHex(str);\n-        return MakeUnique<RawDescriptor>(CScript(bytes.begin(), bytes.end()));\n+        return std::make_unique<RawDescriptor>(CScript(bytes.begin(), bytes.end()));\n     }\n     if (ctx == ParseScriptContext::P2SH) {\n         error = \"A function is needed within P2SH\";\n@@ -1058,10 +1059,10 @@ std::unique_ptr<DescriptorImpl> ParseScript(uint32_t key_exp_index, Span<const c\n \n std::unique_ptr<PubkeyProvider> InferPubkey(const CPubKey& pubkey, ParseScriptContext, const SigningProvider& provider)\n {\n-    std::unique_ptr<PubkeyProvider> key_provider = MakeUnique<ConstPubkeyProvider>(0, pubkey);\n+    std::unique_ptr<PubkeyProvider> key_provider = std::make_unique<ConstPubkeyProvider>(0, pubkey);\n     KeyOriginInfo info;\n     if (provider.GetKeyOrigin(pubkey.GetID(), info)) {\n-        return MakeUnique<OriginPubkeyProvider>(0, std::move(info), std::move(key_provider));\n+        return std::make_unique<OriginPubkeyProvider>(0, std::move(info), std::move(key_provider));\n     }\n     return key_provider;\n }\n@@ -1074,23 +1075,23 @@ std::unique_ptr<DescriptorImpl> InferScript(const CScript& script, ParseScriptCo\n     if (txntype == TxoutType::PUBKEY) {\n         CPubKey pubkey(data[0].begin(), data[0].end());\n         if (pubkey.IsValid()) {\n-            return MakeUnique<PKDescriptor>(InferPubkey(pubkey, ctx, provider));\n+            return std::make_unique<PKDescriptor>(InferPubkey(pubkey, ctx, provider));\n         }\n     }\n     if (txntype == TxoutType::PUBKEYHASH) {\n         uint160 hash(data[0]);\n         CKeyID keyid(hash);\n         CPubKey pubkey;\n         if (provider.GetPubKey(keyid, pubkey)) {\n-            return MakeUnique<PKHDescriptor>(InferPubkey(pubkey, ctx, provider));\n+            return std::make_unique<PKHDescriptor>(InferPubkey(pubkey, ctx, provider));\n         }\n     }\n     if (txntype == TxoutType::WITNESS_V0_KEYHASH && ctx != ParseScriptContext::P2WSH) {\n         uint160 hash(data[0]);\n         CKeyID keyid(hash);\n         CPubKey pubkey;\n         if (provider.GetPubKey(keyid, pubkey)) {\n-            return MakeUnique<WPKHDescriptor>(InferPubkey(pubkey, ctx, provider));\n+            return std::make_unique<WPKHDescriptor>(InferPubkey(pubkey, ctx, provider));\n         }\n     }\n     if (txntype == TxoutType::MULTISIG) {\n@@ -1099,15 +1100,15 @@ std::unique_ptr<DescriptorImpl> InferScript(const CScript& script, ParseScriptCo\n             CPubKey pubkey(data[i].begin(), data[i].end());\n             providers.push_back(InferPubkey(pubkey, ctx, provider));\n         }\n-        return MakeUnique<MultisigDescriptor>((int)data[0][0], std::move(providers));\n+        return std::make_unique<MultisigDescriptor>((int)data[0][0], std::move(providers));\n     }\n     if (txntype == TxoutType::SCRIPTHASH && ctx == ParseScriptContext::TOP) {\n         uint160 hash(data[0]);\n         CScriptID scriptid(hash);\n         CScript subscript;\n         if (provider.GetCScript(scriptid, subscript)) {\n             auto sub = InferScript(subscript, ParseScriptContext::P2SH, provider);\n-            if (sub) return MakeUnique<SHDescriptor>(std::move(sub));\n+            if (sub) return std::make_unique<SHDescriptor>(std::move(sub));\n         }\n     }\n     if (txntype == TxoutType::WITNESS_V0_SCRIPTHASH && ctx != ParseScriptContext::P2WSH) {\n@@ -1116,18 +1117,18 @@ std::unique_ptr<DescriptorImpl> InferScript(const CScript& script, ParseScriptCo\n         CScript subscript;\n         if (provider.GetCScript(scriptid, subscript)) {\n             auto sub = InferScript(subscript, ParseScriptContext::P2WSH, provider);\n-            if (sub) return MakeUnique<WSHDescriptor>(std::move(sub));\n+            if (sub) return std::make_unique<WSHDescriptor>(std::move(sub));\n         }\n     }\n \n     CTxDestination dest;\n     if (ExtractDestination(script, dest)) {\n         if (GetScriptForDestination(dest) == script) {\n-            return MakeUnique<AddressDescriptor>(std::move(dest));\n+            return std::make_unique<AddressDescriptor>(std::move(dest));\n         }\n     }\n \n-    return MakeUnique<RawDescriptor>(script);\n+    return std::make_unique<RawDescriptor>(script);\n }\n \n "
      },
      {
        "sha": "332ae2f230382f00a7d741f0336d0c26e4b2447f",
        "filename": "src/script/descriptor.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/script/descriptor.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/script/descriptor.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -5,12 +5,12 @@\n #ifndef BITCOIN_SCRIPT_DESCRIPTOR_H\n #define BITCOIN_SCRIPT_DESCRIPTOR_H\n \n-#include <optional.h>\n #include <outputtype.h>\n #include <script/script.h>\n #include <script/sign.h>\n #include <script/signingprovider.h>\n \n+#include <optional>\n #include <vector>\n \n using ExtPubKeyMap = std::unordered_map<uint32_t, CExtPubKey>;\n@@ -124,7 +124,7 @@ struct Descriptor {\n     virtual void ExpandPrivate(int pos, const SigningProvider& provider, FlatSigningProvider& out) const = 0;\n \n     /** @return The OutputType of the scriptPubKey(s) produced by this descriptor. Or nullopt if indeterminate (multiple or none) */\n-    virtual Optional<OutputType> GetOutputType() const = 0;\n+    virtual std::optional<OutputType> GetOutputType() const = 0;\n };\n \n /** Parse a `descriptor` string. Included private keys are put in `out`."
      },
      {
        "sha": "2fc195e2d16d0f9866c708d521393a454c34e197",
        "filename": "src/shutdown.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 39,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/shutdown.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/shutdown.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/shutdown.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -5,16 +5,15 @@\n \n #include <shutdown.h>\n \n+#include <logging.h>\n+#include <util/tokenpipe.h>\n+\n #include <config/bitcoin-config.h>\n \n #include <assert.h>\n #include <atomic>\n #ifdef WIN32\n #include <condition_variable>\n-#else\n-#include <errno.h>\n-#include <fcntl.h>\n-#include <unistd.h>\n #endif\n \n static std::atomic<bool> fRequestShutdown(false);\n@@ -24,25 +23,18 @@ std::mutex g_shutdown_mutex;\n std::condition_variable g_shutdown_cv;\n #else\n /** On UNIX-like operating systems use the self-pipe trick.\n- * Index 0 will be the read end of the pipe, index 1 the write end.\n  */\n-static int g_shutdown_pipe[2] = {-1, -1};\n+static TokenPipeEnd g_shutdown_r;\n+static TokenPipeEnd g_shutdown_w;\n #endif\n \n bool InitShutdownState()\n {\n #ifndef WIN32\n-#if HAVE_O_CLOEXEC && HAVE_DECL_PIPE2\n-    // If we can, make sure that the file descriptors are closed on exec()\n-    // to prevent interference.\n-    if (pipe2(g_shutdown_pipe, O_CLOEXEC) != 0) {\n-        return false;\n-    }\n-#else\n-    if (pipe(g_shutdown_pipe) != 0) {\n-        return false;\n-    }\n-#endif\n+    std::optional<TokenPipe> pipe = TokenPipe::Make();\n+    if (!pipe) return false;\n+    g_shutdown_r = pipe->TakeReadEnd();\n+    g_shutdown_w = pipe->TakeWriteEnd();\n #endif\n     return true;\n }\n@@ -59,17 +51,10 @@ void StartShutdown()\n     // case of a reentrant signal.\n     if (!fRequestShutdown.exchange(true)) {\n         // Write an arbitrary byte to the write end of the shutdown pipe.\n-        const char token = 'x';\n-        while (true) {\n-            int result = write(g_shutdown_pipe[1], &token, 1);\n-            if (result < 0) {\n-                // Failure. It's possible that the write was interrupted by another signal.\n-                // Other errors are unexpected here.\n-                assert(errno == EINTR);\n-            } else {\n-                assert(result == 1);\n-                break;\n-            }\n+        int res = g_shutdown_w.TokenWrite('x');\n+        if (res != 0) {\n+            LogPrintf(\"Sending shutdown token failed\\n\");\n+            assert(0);\n         }\n     }\n #endif\n@@ -96,17 +81,10 @@ void WaitForShutdown()\n     std::unique_lock<std::mutex> lk(g_shutdown_mutex);\n     g_shutdown_cv.wait(lk, [] { return fRequestShutdown.load(); });\n #else\n-    char token;\n-    while (true) {\n-        int result = read(g_shutdown_pipe[0], &token, 1);\n-        if (result < 0) {\n-            // Failure. Check if the read was interrupted by a signal.\n-            // Other errors are unexpected here.\n-            assert(errno == EINTR);\n-        } else {\n-            assert(result == 1);\n-            break;\n-        }\n+    int res = g_shutdown_r.TokenRead();\n+    if (res != 'x') {\n+        LogPrintf(\"Reading shutdown token failed\\n\");\n+        assert(0);\n     }\n #endif\n }"
      },
      {
        "sha": "fb41e43752cf1bd1f27ba0e6e0d5e1f2df82d3e5",
        "filename": "src/signet.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/signet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/signet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/signet.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -65,7 +65,7 @@ static uint256 ComputeModifiedMerkleRoot(const CMutableTransaction& cb, const CB\n     return ComputeMerkleRoot(std::move(leaves));\n }\n \n-Optional<SignetTxs> SignetTxs::Create(const CBlock& block, const CScript& challenge)\n+std::optional<SignetTxs> SignetTxs::Create(const CBlock& block, const CScript& challenge)\n {\n     CMutableTransaction tx_to_spend;\n     tx_to_spend.nVersion = 0;\n@@ -83,12 +83,12 @@ Optional<SignetTxs> SignetTxs::Create(const CBlock& block, const CScript& challe\n     // responses from block coinbase tx\n \n     // find and delete signet signature\n-    if (block.vtx.empty()) return nullopt; // no coinbase tx in block; invalid\n+    if (block.vtx.empty()) return std::nullopt; // no coinbase tx in block; invalid\n     CMutableTransaction modified_cb(*block.vtx.at(0));\n \n     const int cidx = GetWitnessCommitmentIndex(block);\n     if (cidx == NO_WITNESS_COMMITMENT) {\n-        return nullopt; // require a witness commitment\n+        return std::nullopt; // require a witness commitment\n     }\n \n     CScript& witness_commitment = modified_cb.vout.at(cidx).scriptPubKey;\n@@ -101,9 +101,9 @@ Optional<SignetTxs> SignetTxs::Create(const CBlock& block, const CScript& challe\n             VectorReader v(SER_NETWORK, INIT_PROTO_VERSION, signet_solution, 0);\n             v >> tx_spending.vin[0].scriptSig;\n             v >> tx_spending.vin[0].scriptWitness.stack;\n-            if (!v.empty()) return nullopt; // extraneous data encountered\n+            if (!v.empty()) return std::nullopt; // extraneous data encountered\n         } catch (const std::exception&) {\n-            return nullopt; // parsing error\n+            return std::nullopt; // parsing error\n         }\n     }\n     uint256 signet_merkle = ComputeModifiedMerkleRoot(modified_cb, block);\n@@ -129,7 +129,7 @@ bool CheckSignetBlockSolution(const CBlock& block, const Consensus::Params& cons\n     }\n \n     const CScript challenge(consensusParams.signet_challenge.begin(), consensusParams.signet_challenge.end());\n-    const Optional<SignetTxs> signet_txs = SignetTxs::Create(block, challenge);\n+    const std::optional<SignetTxs> signet_txs = SignetTxs::Create(block, challenge);\n \n     if (!signet_txs) {\n         LogPrint(BCLog::VALIDATION, \"CheckSignetBlockSolution: Errors in block (block solution parse failure)\\n\");"
      },
      {
        "sha": "f876488c0ae8ff5227b25292c4a2180d4325f64e",
        "filename": "src/signet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/signet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/signet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/signet.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -9,7 +9,7 @@\n #include <primitives/block.h>\n #include <primitives/transaction.h>\n \n-#include <optional.h>\n+#include <optional>\n \n /**\n  * Extract signature and check whether a block has a valid solution\n@@ -28,7 +28,7 @@ class SignetTxs {\n     SignetTxs(const T1& to_spend, const T2& to_sign) : m_to_spend{to_spend}, m_to_sign{to_sign} { }\n \n public:\n-    static Optional<SignetTxs> Create(const CBlock& block, const CScript& challenge);\n+    static std::optional<SignetTxs> Create(const CBlock& block, const CScript& challenge);\n \n     const CTransaction m_to_spend;\n     const CTransaction m_to_sign;"
      },
      {
        "sha": "d438537606a935ab57f6c3ad0f301375092ff036",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -100,7 +100,7 @@ static CNetAddr ResolveIP(const std::string& ip)\n     return addr;\n }\n \n-static CService ResolveService(const std::string& ip, const int port = 0)\n+static CService ResolveService(const std::string& ip, uint16_t port = 0)\n {\n     CService serv;\n     BOOST_CHECK_MESSAGE(Lookup(ip, serv, port, false), strprintf(\"failed to resolve: %s:%i\", ip, port));"
      },
      {
        "sha": "b523173a4526b76712f7c354297bbb9b3c2f67b8",
        "filename": "src/test/allocator_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/allocator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/allocator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/allocator_tests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -2,7 +2,6 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <util/memory.h>\n #include <util/system.h>\n \n #include <test/util/setup_common.h>\n@@ -163,7 +162,7 @@ class TestLockedPageAllocator: public LockedPageAllocator\n BOOST_AUTO_TEST_CASE(lockedpool_tests_mock)\n {\n     // Test over three virtual arenas, of which one will succeed being locked\n-    std::unique_ptr<LockedPageAllocator> x = MakeUnique<TestLockedPageAllocator>(3, 1);\n+    std::unique_ptr<LockedPageAllocator> x = std::make_unique<TestLockedPageAllocator>(3, 1);\n     LockedPool pool(std::move(x));\n     BOOST_CHECK(pool.stats().total == 0);\n     BOOST_CHECK(pool.stats().locked == 0);"
      },
      {
        "sha": "2651e464308619858696ac81f46cfcdaaaf9178b",
        "filename": "src/test/bech32_tests.cpp",
        "status": "modified",
        "additions": 51,
        "deletions": 7,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/bech32_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/bech32_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bech32_tests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -10,7 +10,7 @@\n \n BOOST_FIXTURE_TEST_SUITE(bech32_tests, BasicTestingSetup)\n \n-BOOST_AUTO_TEST_CASE(bip173_testvectors_valid)\n+BOOST_AUTO_TEST_CASE(bech32_testvectors_valid)\n {\n     static const std::string CASES[] = {\n         \"A12UEL5L\",\n@@ -22,15 +22,35 @@ BOOST_AUTO_TEST_CASE(bip173_testvectors_valid)\n         \"?1ezyfcl\",\n     };\n     for (const std::string& str : CASES) {\n-        auto ret = bech32::Decode(str);\n-        BOOST_CHECK(!ret.first.empty());\n-        std::string recode = bech32::Encode(ret.first, ret.second);\n+        const auto dec = bech32::Decode(str);\n+        BOOST_CHECK(dec.encoding == bech32::Encoding::BECH32);\n+        std::string recode = bech32::Encode(bech32::Encoding::BECH32, dec.hrp, dec.data);\n         BOOST_CHECK(!recode.empty());\n         BOOST_CHECK(CaseInsensitiveEqual(str, recode));\n     }\n }\n \n-BOOST_AUTO_TEST_CASE(bip173_testvectors_invalid)\n+BOOST_AUTO_TEST_CASE(bech32m_testvectors_valid)\n+{\n+    static const std::string CASES[] = {\n+        \"A1LQFN3A\",\n+        \"a1lqfn3a\",\n+        \"an83characterlonghumanreadablepartthatcontainsthetheexcludedcharactersbioandnumber11sg7hg6\",\n+        \"abcdef1l7aum6echk45nj3s0wdvt2fg8x9yrzpqzd3ryx\",\n+        \"11llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllludsr8\",\n+        \"split1checkupstagehandshakeupstreamerranterredcaperredlc445v\",\n+        \"?1v759aa\"\n+    };\n+    for (const std::string& str : CASES) {\n+        const auto dec = bech32::Decode(str);\n+        BOOST_CHECK(dec.encoding == bech32::Encoding::BECH32M);\n+        std::string recode = bech32::Encode(bech32::Encoding::BECH32M, dec.hrp, dec.data);\n+        BOOST_CHECK(!recode.empty());\n+        BOOST_CHECK(CaseInsensitiveEqual(str, recode));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(bech32_testvectors_invalid)\n {\n     static const std::string CASES[] = {\n         \" 1nwldj5\",\n@@ -49,8 +69,32 @@ BOOST_AUTO_TEST_CASE(bip173_testvectors_invalid)\n         \"A12uEL5L\",\n     };\n     for (const std::string& str : CASES) {\n-        auto ret = bech32::Decode(str);\n-        BOOST_CHECK(ret.first.empty());\n+        const auto dec = bech32::Decode(str);\n+        BOOST_CHECK(dec.encoding == bech32::Encoding::INVALID);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(bech32m_testvectors_invalid)\n+{\n+    static const std::string CASES[] = {\n+        \" 1xj0phk\",\n+        \"\\x7f\"\"1g6xzxy\",\n+        \"\\x80\"\"1vctc34\",\n+        \"an84characterslonghumanreadablepartthatcontainsthetheexcludedcharactersbioandnumber11d6pts4\",\n+        \"qyrz8wqd2c9m\",\n+        \"1qyrz8wqd2c9m\",\n+        \"y1b0jsk6g\",\n+        \"lt1igcx5c0\",\n+        \"in1muywd\",\n+        \"mm1crxm3i\",\n+        \"au1s5cgom\",\n+        \"M1VUXWEZ\",\n+        \"16plkw9\",\n+        \"1p2gdwpf\"\n+    };\n+    for (const std::string& str : CASES) {\n+        const auto dec = bech32::Decode(str);\n+        BOOST_CHECK(dec.encoding == bech32::Encoding::INVALID);\n     }\n }\n "
      },
      {
        "sha": "04da10715f3298a368d620cb19d9d3bf47fabad8",
        "filename": "src/test/blockfilter_index_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/blockfilter_index_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/blockfilter_index_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/blockfilter_index_tests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -62,7 +62,7 @@ CBlock BuildChainTestingSetup::CreateBlock(const CBlockIndex* prev,\n     const CScript& scriptPubKey)\n {\n     const CChainParams& chainparams = Params();\n-    std::unique_ptr<CBlockTemplate> pblocktemplate = BlockAssembler(*m_node.mempool, chainparams).CreateNewBlock(scriptPubKey);\n+    std::unique_ptr<CBlockTemplate> pblocktemplate = BlockAssembler(*m_node.mempool, chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);\n     CBlock& block = pblocktemplate->block;\n     block.hashPrevBlock = prev->GetBlockHash();\n     block.nTime = prev->nTime + 1;"
      },
      {
        "sha": "64c6d7f634964635ba89b8c98fc4615429c85ae2",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 8,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -5,7 +5,6 @@\n #include <checkqueue.h>\n #include <sync.h>\n #include <test/util/setup_common.h>\n-#include <util/memory.h>\n #include <util/system.h>\n #include <util/time.h>\n \n@@ -146,7 +145,7 @@ typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n  */\n static void Correct_Queue_range(std::vector<size_t> range)\n {\n-    auto small_queue = MakeUnique<Correct_Queue>(QUEUE_BATCH_SIZE);\n+    auto small_queue = std::make_unique<Correct_Queue>(QUEUE_BATCH_SIZE);\n     small_queue->StartWorkerThreads(SCRIPT_CHECK_THREADS);\n     // Make vChecks here to save on malloc (this test can be slow...)\n     std::vector<FakeCheckCheckCompletion> vChecks;\n@@ -206,7 +205,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n /** Test that failing checks are caught */\n BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n {\n-    auto fail_queue = MakeUnique<Failing_Queue>(QUEUE_BATCH_SIZE);\n+    auto fail_queue = std::make_unique<Failing_Queue>(QUEUE_BATCH_SIZE);\n     fail_queue->StartWorkerThreads(SCRIPT_CHECK_THREADS);\n \n     for (size_t i = 0; i < 1001; ++i) {\n@@ -234,7 +233,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n // future blocks, ie, the bad state is cleared.\n BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n {\n-    auto fail_queue = MakeUnique<Failing_Queue>(QUEUE_BATCH_SIZE);\n+    auto fail_queue = std::make_unique<Failing_Queue>(QUEUE_BATCH_SIZE);\n     fail_queue->StartWorkerThreads(SCRIPT_CHECK_THREADS);\n \n     for (auto times = 0; times < 10; ++times) {\n@@ -258,7 +257,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n // more than once as well\n BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n {\n-    auto queue = MakeUnique<Unique_Queue>(QUEUE_BATCH_SIZE);\n+    auto queue = std::make_unique<Unique_Queue>(QUEUE_BATCH_SIZE);\n     queue->StartWorkerThreads(SCRIPT_CHECK_THREADS);\n \n     size_t COUNT = 100000;\n@@ -293,7 +292,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n // time could leave the data hanging across a sequence of blocks.\n BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n {\n-    auto queue = MakeUnique<Memory_Queue>(QUEUE_BATCH_SIZE);\n+    auto queue = std::make_unique<Memory_Queue>(QUEUE_BATCH_SIZE);\n     queue->StartWorkerThreads(SCRIPT_CHECK_THREADS);\n     for (size_t i = 0; i < 1000; ++i) {\n         size_t total = i;\n@@ -320,7 +319,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n // have been destructed\n BOOST_AUTO_TEST_CASE(test_CheckQueue_FrozenCleanup)\n {\n-    auto queue = MakeUnique<FrozenCleanup_Queue>(QUEUE_BATCH_SIZE);\n+    auto queue = std::make_unique<FrozenCleanup_Queue>(QUEUE_BATCH_SIZE);\n     bool fails = false;\n     queue->StartWorkerThreads(SCRIPT_CHECK_THREADS);\n     std::thread t0([&]() {\n@@ -360,7 +359,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_FrozenCleanup)\n /** Test that CCheckQueueControl is threadsafe */\n BOOST_AUTO_TEST_CASE(test_CheckQueueControl_Locks)\n {\n-    auto queue = MakeUnique<Standard_Queue>(QUEUE_BATCH_SIZE);\n+    auto queue = std::make_unique<Standard_Queue>(QUEUE_BATCH_SIZE);\n     {\n         std::vector<std::thread> tg;\n         std::atomic<int> nThreads {0};"
      },
      {
        "sha": "abe07dad248dbb604e692dc816fab07c45cb55a9",
        "filename": "src/test/data/key_io_invalid.json",
        "status": "modified",
        "additions": 88,
        "deletions": 58,
        "changes": 146,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/data/key_io_invalid.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/data/key_io_invalid.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/key_io_invalid.json?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -6,177 +6,207 @@\n         \"x\"\n     ],\n     [\n-        \"37qgekLpCCHrQuSjvX3fs496FWTGsHFHizjJAs6NPcR47aefnnCWECAhHV6E3g4YN7u7Yuwod5Y\"\n+        \"2v7k5Bb8Lr1MMgTgW6HAf5YHXi6BzpPjHpQ4srD4RSwHYpzXKiXmLAgiLhkXvp3JF5v7nq45EWr\"\n     ],\n     [\n-        \"dzb7VV1Ui55BARxv7ATxAtCUeJsANKovDGWFVgpTbhq9gvPqP3yv\"\n+        \"RAZzCGtMbiUgMiiyrZySrSpdfnQReFXA3r\"\n     ],\n     [\n-        \"MuNu7ZAEDFiHthiunm7dPjwKqrVNCM3mAz6rP9zFveQu14YA8CxExSJTHcVP9DErn6u84E6Ej7S\"\n+        \"NYamy7tcPQTzoU5iyQojD3sqhiz7zxkvn8\"\n     ],\n     [\n-        \"rPpQpYknyNQ5AEHuY6H8ijJJrYc2nDKKk9jjmKEXsWzyAQcFGpDLU2Zvsmoi8JLR7hAwoy3RQWf\"\n+        \"geaFG555Ex5nyRf7JjW6Pj2GwZA8KYxtJJLbr1eZhVW75STbYBZeRszy3wg4pkKdF4ez9J4wQiz\"\n     ],\n     [\n-        \"4Uc3FmN6NQ6zLBK5QQBXRBUREaaHwCZYsGCueHauuDmJpZKn6jkEskMB2Zi2CNgtb5r6epWEFfUJq\"\n+        \"2Cxmid3c2XQ2zvQ8SA1ha2TKqvqbJS9XFmXRsCneBS3Po7Qqb65z5zNdsoF9AfieXFcpoVPmkmfa\"\n     ],\n     [\n-        \"7aQgR5DFQ25vyXmqZAWmnVCjL3PkBcdVkBUpjrjMTcghHx3E8wb\"\n+        \"gaJ7UVge2njVg9tFTetJrtHgruMm7aQDiSAxfHrVEgzK8N2ooagDVmDkdph434xzc4K96Gjyxcs\"\n     ],\n     [\n-        \"17QpPprjeg69fW1DV8DcYYCKvWjYhXvWkov6MJ1iTTvMFj6weAqW7wybZeH57WTNxXVCRH4veVs\"\n+        \"5JN5BEVQPZ3tAiatz1RGXkrJuE3EC6bervMaPb38wTNgEuZCeqp\"\n     ],\n     [\n-        \"KxuACDviz8Xvpn1xAh9MfopySZNuyajYMZWz16Dv2mHHryznWUp3\"\n+        \"3TnFbyUtBRS5rE1KTW81qLVspjJNaB3uu6uuvLjxhZo2DB6PCGh\"\n     ],\n     [\n-        \"7nK3GSmqdXJQtdohvGfJ7KsSmn3TmGqExug49583bDAL91pVSGq5xS9SHoAYL3Wv3ijKTit65th\"\n+        \"7UgSZGaMaTc4d2mdEgcGBFiMeS6eMsithGUqvBsKTQdGzD7XQDbMEYo3gojdbXEPbUdFF3CQoK72f\"\n     ],\n     [\n-        \"cTivdBmq7bay3RFGEBBuNfMh2P1pDCgRYN2Wbxmgwr4ki3jNUL2va\"\n+        \"9261wfqQqruNDnBDhbbb4tN9oKA1KpRFHeoYeufyJApVGixyAG4V\"\n     ],\n     [\n-        \"gjMV4vjNjyMrna4fsAr8bWxAbwtmMUBXJS3zL4NJt5qjozpbQLmAfK1uA3CquSqsZQMpoD1g2nk\"\n+        \"cS824CTUh18scFmYuqt6BgxuRhdR4dEEnCHs3fzBbcyQgbfasHbw\"\n     ],\n     [\n-        \"emXm1naBMoVzPjbk7xpeTVMFy4oDEe25UmoyGgKEB1gGWsK8kRGs\"\n+        \"tc1q0ywf7wkz6t580n3yemd3ucfw8jxn93tpc6wskt\"\n     ],\n     [\n-        \"7VThQnNRj1o3Zyvc7XHPRrjDf8j2oivPTeDXnRPYWeYGE4pXeRJDZgf28ppti5hsHWXS2GSobdqyo\"\n+        \"bt1pxeeuh96wpm5c6u3kavts2qgwlv6y8um7u7ga6ltlwrhrv7w9vers8lgt3k\"\n     ],\n     [\n-        \"1G9u6oCVCPh2o8m3t55ACiYvG1y5BHewUkDSdiQarDcYXXhFHYdzMdYfUAhfxn5vNZBwpgUNpso\"\n+        \"tb130lvl2lyugsk2tf3zhwcjjv39dmwt2tt7ytqaexy8edwcuwks6p5scll5kz\"\n     ],\n     [\n-        \"31QQ7ZMLkScDiB4VyZjuptr7AEc9j1SjstF7pRoLhHTGkW4Q2y9XELobQmhhWxeRvqcukGd1XCq\"\n+        \"bcrt1rhsveeudk\"\n     ],\n     [\n-        \"DHqKSnpxa8ZdQyH8keAhvLTrfkyBMQxqngcQA5N8LQ9KVt25kmGN\"\n+        \"bc10rmfwl8nxdweeyc4sf89t0tn9fv9w6qpyzsnl2r4k48vjqh03qas9asdje0rlr0phru0wqw0p\"\n     ],\n     [\n-        \"2LUHcJPbwLCy9GLH1qXmfmAwvadWw4bp4PCpDfduLqV17s6iDcy1imUwhQJhAoNoN1XNmweiJP4i\"\n+        \"tb1qjqnfsuatr54e957xzg9sqk7yqcry9lns\"\n     ],\n     [\n-        \"7USRzBXAnmck8fX9HmW7RAb4qt92VFX6soCnts9s74wxm4gguVhtG5of8fZGbNPJA83irHVY6bCos\"\n+        \"bcrt1q8p08mv8echkf3es027u4cdswxlylm3th76ls8v6y4zy4vwsavngpr4e4td\"\n     ],\n     [\n-        \"1DGezo7BfVebZxAbNT3XGujdeHyNNBF3vnficYoTSp4PfK2QaML9bHzAMxke3wdKdHYWmsMTJVu\"\n+        \"BC1QNC2H66VLWTWTW52DP0FYUSNU3QQG5VT4V\"\n     ],\n     [\n-        \"2D12DqDZKwCxxkzs1ZATJWvgJGhQ4cFi3WrizQ5zLAyhN5HxuAJ1yMYaJp8GuYsTLLxTAz6otCfb\"\n+        \"tb1qgk665m2auw09rc7pqyf7aulcuhmatz9xqtr5mxew7zuysacaascqs9v0vn\"\n     ],\n     [\n-        \"8AFJzuTujXjw1Z6M3fWhQ1ujDW7zsV4ePeVjVo7D1egERqSW9nZ\"\n+        \"bcrt17CAPP7\"\n     ],\n     [\n-        \"163Q17qLbTCue8YY3AvjpUhotuaodLm2uqMhpYirsKjVqnxJRWTEoywMVY3NbBAHuhAJ2cF9GAZ\"\n+        \"bc1qxmf2d6aerjzam3rur0zufqxqnyqfts5u302s7x\"\n     ],\n     [\n-        \"2MnmgiRH4eGLyLc9eAqStzk7dFgBjFtUCtu\"\n+        \"tb1qn8x5dnzpexq7nnvrvnhwr9c3wkakpcyu9wwsjzq9pstkwg0t6qhs4l3rv6\"\n     ],\n     [\n-        \"461QQ2sYWxU7H2PV4oBwJGNch8XVTYYbZxU\"\n+        \"BCRT1Q397G2RNVYRL5LK07CE8NCKHVKP8Z4SC9U0MVH9\"\n     ],\n     [\n-        \"2UCtv53VttmQYkVU4VMtXB31REvQg4ABzs41AEKZ8UcB7DAfVzdkV9JDErwGwyj5AUHLkmgZeobs\"\n+        \"bc1pgxwyajq0gdn389f69uwn2fw9q0z5c9s063j5dgkdd23ajaud4hpsercr9h\"\n     ],\n     [\n-        \"cSNjAsnhgtiFMi6MtfvgscMB2Cbhn2v1FUYfviJ1CdjfidvmeW6mn\"\n+        \"tb1z6mnmp5k542l6yk4ul0mp4rq3yvz44lfm\"\n     ],\n     [\n-        \"gmsow2Y6EWAFDFE1CE4Hd3Tpu2BvfmBfG1SXsuRARbnt1WjkZnFh1qGTiptWWbjsq2Q6qvpgJVj\"\n+        \"bcrt17capp7\"\n     ],\n     [\n-        \"nksUKSkzS76v8EsSgozXGMoQFiCoCHzCVajFKAXqzK5on9ZJYVHMD5CKwgmX3S3c7M1U3xabUny\"\n+        \"2D2bqvKseKHdoKjCNvjVULUgmxHu9hjKGwDbPRjTRH59tsHNLeyKwq3vyVBbo9LByY9wiapqjwFY\"\n     ],\n     [\n-        \"L3favK1UzFGgdzYBF2oBT5tbayCo4vtVBLJhg2iYuMeePxWG8SQc\"\n+        \"2SSjAim4wZpeQRe5zTj1qqS6Li9ttJDaZ3ze\"\n     ],\n     [\n-        \"7VxLxGGtYT6N99GdEfi6xz56xdQ8nP2dG1CavuXx7Rf2PrvNMTBNevjkfgs9JmkcGm6EXpj8ipyPZ\"\n+        \"mi9H6MjLwXxy9kxe1x4ToxyLRBsmcZxgVi\"\n     ],\n     [\n-        \"2mbZwFXF6cxShaCo2czTRB62WTx9LxhTtpP\"\n+        \"VciXoxEitcn88jy197J9n9cpJ1pZahzU3SyWUiHqLgcfjttLEEJz\"\n     ],\n     [\n-        \"dB7cwYdcPSgiyAwKWL3JwCVwSk6epU2txw\"\n+        \"KppmwADGoExPT9Eq5hjRWpWFDbzJyfzHFgsfxBiDHNpVBgWPRNuy\"\n     ],\n     [\n-        \"HPhFUhUAh8ZQQisH8QQWafAxtQYju3SFTX\"\n+        \"TN7EQXMxKffzvHo54yHHu9R4ks9f5gWBW3MMVf5k72zAqrgVK9ys\"\n     ],\n     [\n-        \"4ctAH6AkHzq5ioiM1m9T3E2hiYEev5mTsB\"\n+        \"92dbrMEYzP5dD5UhQ6maNkCQ4GLG42BM4Gc6XKZzSSMSfosfkkcB\"\n     ],\n     [\n-        \"Hn1uFi4dNexWrqARpjMqgT6cX1UsNPuV3cHdGg9ExyXw8HTKadbktRDtdeVmY3M1BxJStiL4vjJ\"\n+        \"J7VQxPxyzuWEkRstQWpCz2AgysEz1APgnWCEQrFvkN3umAnCrhQF\"\n     ],\n     [\n-        \"Sq3fDbvutABmnAHHExJDgPLQn44KnNC7UsXuT7KZecpaYDMU9Txs\"\n+        \"tc1qymllj6c96v5qj2504y27ldtner6eh8ldx38t83\"\n     ],\n     [\n-        \"6TqWyrqdgUEYDQU1aChMuFMMEimHX44qHFzCUgGfqxGgZNMUVWJ\"\n+        \"bt1flep4g\"\n     ],\n     [\n-        \"giqJo7oWqFxNKWyrgcBxAVHXnjJ1t6cGoEffce5Y1y7u649Noj5wJ4mmiUAKEVVrYAGg2KPB3Y4\"\n+        \"tb13c553hwygcgj48qwmr9f8q0hgdcfklyaye5sxzcpcjnmxv4z506xs90tchn\"\n     ],\n     [\n-        \"cNzHY5e8vcmM3QVJUcjCyiKMYfeYvyueq5qCMV3kqcySoLyGLYUK\"\n+        \"bcrt1tyddyu\"\n     ],\n     [\n-        \"37uTe568EYc9WLoHEd9jXEvUiWbq5LFLscNyqvAzLU5vBArUJA6eydkLmnMwJDjkL5kXc2VK7ig\"\n+        \"bc10qssq2mknjqf0glwe2f3587wc4jysvs3f8s6chysae6hcl6fxzdm4wxyyscrl5k9f5qmnf05a\"\n     ],\n     [\n-        \"EsYbG4tWWWY45G31nox838qNdzksbPySWc\"\n+        \"tb1q425lmgvxdgtyl2m6xuu2pc354y4fvgg8\"\n     ],\n     [\n-        \"nbuzhfwMoNzA3PaFnyLcRxE9bTJPDkjZ6Rf6Y6o2ckXZfzZzXBT\"\n+        \"bcrt1q9wp8e5d2u3u4g0pll0cy7smeeuqezdun9xl439n3p2gg4fvgfvk3hu52hj\"\n     ],\n     [\n-        \"cQN9PoxZeCWK1x56xnz6QYAsvR11XAce3Ehp3gMUdfSQ53Y2mPzx\"\n+        \"bc1qrz5acazpue8vl4zsaxn8fxtmeuqmyjkq3\"\n     ],\n     [\n-        \"1Gm3N3rkef6iMbx4voBzaxtXcmmiMTqZPhcuAepRzYUJQW4qRpEnHvMojzof42hjFRf8PE2jPde\"\n+        \"tb1qkeuglpgmnex9tv3fr7htzfrh3rwrk23r52rx9halxzmv9fr85lwq0fwhmp\"\n     ],\n     [\n-        \"2TAq2tuN6x6m233bpT7yqdYQPELdTDJn1eU\"\n+        \"bcrt1qd0t2wrhl7s57z99rsyaekpq0dyjcQRSSmz80r4\"\n     ],\n     [\n-        \"ntEtnnGhqPii4joABvBtSEJG6BxjT2tUZqE8PcVYgk3RHpgxgHDCQxNbLJf7ardf1dDk2oCQ7Cf\"\n+        \"BC1QXLFDUCGX90T3E53PQCNKJ2PK25MSF3VLPMVY6T\"\n     ],\n     [\n-        \"Ky1YjoZNgQ196HJV3HpdkecfhRBmRZdMJk89Hi5KGfpfPwS2bUbfd\"\n+        \"tb1qmycg4zszgnk34vaurx3cu8wpvteg9h40yq6cp52gt26gjel03t3su3x3xu\"\n     ],\n     [\n-        \"2A1q1YsMZowabbvta7kTy2Fd6qN4r5ZCeG3qLpvZBMzCixMUdkN2Y4dHB1wPsZAeVXUGD83MfRED\"\n+        \"bcrt1q9hy58r4fnuxqzdqndpmq9pptc9nt2dw3rczf5e\"\n     ],\n     [\n-        \"tc1qw508d6qejxtdg4y5r3zarvary0c5xw7kg3g4ty\"\n+        \"BC1PA7682NAY6JQSLUWAJYTC0ERWTMW7A4RPWLNTUS32LCXWLHVKKKTQ2UL8CG\"\n     ],\n     [\n-        \"bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t5\"\n+        \"tb1z850dpxnwz2fzae5h2myatj4yvu6rq5xq\"\n     ],\n     [\n-        \"BC13W508D6QEJXTDG4Y5R3ZARVARY0C5XW7KN40WF2\"\n+        \"bcrt1sp525pzjsmpqvcrawjreww36e9keg876skjvpwt\"\n     ],\n     [\n-        \"bc1rw5uspcuh\"\n+        \"xcAvW5jurCpzSpLxBKEhCewCgwwuGhqJnC\"\n     ],\n     [\n-        \"bc10w508d6qejxtdg4y5r3zarvary0c5xw7kw508d6qejxtdg4y5r3zarvary0c5xw7kw5rljs90\"\n+        \"2Cvv8yp9kXbQt8EKh6Yma95yJ1uwYF9YKXuVhGJyu3dHGVsb2AVpTC62TFACZZ3KDNrALxR2CVNs\"\n     ],\n     [\n-        \"BC1QR508D6QEJXTDG4Y5R3ZARVARYV98GJ9P\"\n+        \"niUuL46hCuEVvkAzZKHvD746qbmLmzip9Pv3F6UZV14JxzEXBnTkVxCT4URapChJG6qAEgsZs6G\"\n     ],\n     [\n-        \"tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sL5k7\"\n+        \"2UHHgGfiipzvB8Eumnmvq6SowvrMJimjT3NwwG1839XEiUfwtpSdkUrseNsQuagXv21ce7aZu6yo\"\n     ],\n     [\n-        \"bc1zw508d6qejxtdg4y5r3zarvaryvqyzf3du\"\n+        \"8u9djKu4u6o3bsgeR4BKNnLK3akpo64FYzDAmA9239wKeshgF97\"\n     ],\n     [\n-        \"tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3pjxtptv\"\n+        \"TC1QPAARXSLVMXHVRR0474LZXQYZWLGFZYPSFVL9E4\"\n     ],\n     [\n-        \"bc1gmk9yu\"\n+        \"bt1pakek0n2267t9yaksxaczgr2syhv9y3xkx0wnsdwchfa6xkmjtvuqg3kgyr\"\n+    ],\n+    [\n+        \"tb13h83rtwq62udrhwpn87uely7cyxcjrj0azz6a4r3n9s87x5uj98ys6ufp83\"\n+    ],\n+    [\n+        \"bcrt1rk5vw5qf2\"\n+    ],\n+    [\n+        \"bc10d3rmtg62h747en5j6fju5g5qyvsransrkty6ghh96pu647wumctejlsngh9pf26cysrys2x2\"\n+    ],\n+    [\n+        \"tb1qajuy2cdwqgmrzc7la85al5cwcq374tsp\"\n+    ],\n+    [\n+        \"bcrt1q3udxvj6x20chqh723mn064mzz65yr56ef00xk8czvu3jnx04ydapzk02s5\"\n+    ],\n+    [\n+        \"bc1qule2szwzyaq4qy0s3aa4mauucyqt6fewe\"\n+    ],\n+    [\n+        \"tb1ql0qny5vg9gh5tyzke6dw36px5ulkrp24x53x0pl2t5lpwrtejw3s2seej2\"\n+    ],\n+    [\n+        \"bcrt17CAPP7\"\n+    ],\n+    [\n+        \"bc1qtvm6davyf725wfedc2d5mrgfewqgcrce8gjrpl\"\n+    ],\n+    [\n+        \"tb1q5acjgtqrrw3an0dzavxxxzlex8k7aukjzjk9v2u4rmfdqxjphcyq7ge97e\"\n     ]\n ]"
      },
      {
        "sha": "5dee44c04b684f38d98cdcd4a5a7739cf1687d25",
        "filename": "src/test/data/key_io_valid.json",
        "status": "modified",
        "additions": 324,
        "deletions": 247,
        "changes": 571,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/data/key_io_valid.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/data/key_io_valid.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/key_io_valid.json?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1,533 +1,610 @@\n [\n     [\n-        \"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\",\n-        \"76a91465a16059864a2fdbc7c99a4723a8395bc6f188eb88ac\",\n+        \"1BShJZ8A5q53oJJfMJoEF1gfZCWdZqZwwD\",\n+        \"76a914728d4cc27d19707b0197cfcd7c412d43287864b588ac\",\n         {\n-            \"isPrivkey\": false,\n-            \"chain\": \"main\"\n+            \"chain\": \"main\",\n+            \"isPrivkey\": false\n         }\n     ],\n     [\n-        \"3CMNFxN1oHBc4R1EpboAL5yzHGgE611Xou\",\n-        \"a91474f209f6ea907e2ea48f74fae05782ae8a66525787\",\n+        \"3L1YkZjdeNSqaZcNKZFXQfyokx3zVYm7r6\",\n+        \"a914c8f37c3cc21561296ad81f4bec6b5de10ebc185187\",\n         {\n-            \"isPrivkey\": false,\n-            \"chain\": \"main\"\n+            \"chain\": \"main\",\n+            \"isPrivkey\": false\n         }\n     ],\n     [\n-        \"mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs\",\n-        \"76a91453c0307d6851aa0ce7825ba883c6bd9ad242b48688ac\",\n+        \"mhJuoGLgnJC8gdBgBzEigsoyG4omQXejPT\",\n+        \"76a91413a92d1998e081354d36c13ce0c9dc04b865d40a88ac\",\n         {\n-            \"isPrivkey\": false,\n-            \"chain\": \"test\"\n+            \"chain\": \"test\",\n+            \"isPrivkey\": false\n         }\n     ],\n     [\n-        \"mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs\",\n-        \"76a91453c0307d6851aa0ce7825ba883c6bd9ad242b48688ac\",\n+        \"2N5VpzKEuYvZJbmg6eUNGnfrrD1ir92FWGu\",\n+        \"a91486648cc2faaf05660e72c04c7a837bcc3e986f1787\",\n         {\n-            \"isPrivkey\": false,\n-            \"chain\": \"regtest\"\n+            \"chain\": \"test\",\n+            \"isPrivkey\": false\n         }\n     ],\n     [\n-        \"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\",\n-        \"a9146349a418fc4578d10a372b54b45c280cc8c4382f87\",\n+        \"mtQueCtmAnP3E4aBHXCiFNEQAuPaLMuQNy\",\n+        \"76a9148d74ecd86c845baf9c6d4484d2d00e731b79e34788ac\",\n         {\n-            \"isPrivkey\": false,\n-            \"chain\": \"test\"\n+            \"chain\": \"signet\",\n+            \"isPrivkey\": false\n+        }\n+    ],\n+    [\n+        \"2NEvWRTHjh89gV52fkperFtwzoFWQiQmiCh\",\n+        \"a914edc895152c67ccff0ba620bcc373b789ec68266f87\",\n+        {\n+            \"chain\": \"signet\",\n+            \"isPrivkey\": false\n         }\n     ],\n     [\n-        \"5Kd3NBUAdUnhyzenEwVLy9pBKxSwXvE9FMPyR4UKZvpe6E3AgLr\",\n-        \"eddbdc1168f1daeadbd3e44c1e3f8f5a284c2029f78ad26af98583a499de5b19\",\n+        \"mngdx94qJFhSf7A7SAEgQSC9fQJuapujJp\",\n+        \"76a9144e9dba545455a80ce94c343d1cac9dec62cbf22288ac\",\n         {\n+            \"chain\": \"regtest\",\n+            \"isPrivkey\": false\n+        }\n+    ],\n+    [\n+        \"2NBzRN3pV56k3JUvSHifaHyzjGHv7ZS9FZZ\",\n+        \"a914cd9da5642451273e5b6d088854cc1fad4a8d442187\",\n+        {\n+            \"chain\": \"regtest\",\n+            \"isPrivkey\": false\n+        }\n+    ],\n+    [\n+        \"5KcrFZvJ2p4dM6QVUPu53cKXcCfozA1PJLHm1mNAxkDYhgThLu4\",\n+        \"ed6c796e2f62377410766214f55aa81ac9a6590ad7ed57c509c983bf648409ac\",\n+        {\n+            \"chain\": \"main\",\n             \"isCompressed\": false,\n-            \"isPrivkey\": true,\n-            \"chain\": \"main\"\n+            \"isPrivkey\": true\n         }\n     ],\n     [\n-        \"Kz6UJmQACJmLtaQj5A3JAge4kVTNQ8gbvXuwbmCj7bsaabudb3RD\",\n-        \"55c9bccb9ed68446d1b75273bbce89d7fe013a8acd1625514420fb2aca1a21c4\",\n+        \"L195WBrf2G3nCnun4CLxrb8XKk9LbCqH43THh4n4QrL5SzRzpq9j\",\n+        \"74f76c106e38d20514a99a86e4fe3bb28319e7dd2ad21dbc170cbb516a5358fa\",\n         {\n+            \"chain\": \"main\",\n             \"isCompressed\": true,\n-            \"isPrivkey\": true,\n-            \"chain\": \"main\"\n+            \"isPrivkey\": true\n         }\n     ],\n     [\n-        \"9213qJab2HNEpMpYNBa7wHGFKKbkDn24jpANDs2huN3yi4J11ko\",\n-        \"36cb93b9ab1bdabf7fb9f2c04f1b9cc879933530ae7842398eef5a63a56800c2\",\n+        \"92z6HnMQR4tWqjfVA3UaUN5EuUMgoVMdCa5rZFYZfmgyD7wxYCw\",\n+        \"b8511e1d74549e305517d48a1d394d1be2cfa5d0f3c0d83f9f450316ffa01276\",\n         {\n+            \"chain\": \"test\",\n             \"isCompressed\": false,\n-            \"isPrivkey\": true,\n-            \"chain\": \"test\"\n+            \"isPrivkey\": true\n         }\n     ],\n     [\n-        \"9213qJab2HNEpMpYNBa7wHGFKKbkDn24jpANDs2huN3yi4J11ko\",\n-        \"36cb93b9ab1bdabf7fb9f2c04f1b9cc879933530ae7842398eef5a63a56800c2\",\n+        \"cTPnaF52x4w4Tq6afPxRHux3wbYb86thS7S45A7r3oZc1AHTQ6Qm\",\n+        \"ad68c48d337181da125de9061933ececcdf7d917631af7d34f7e38082bff9a11\",\n         {\n+            \"chain\": \"test\",\n+            \"isCompressed\": true,\n+            \"isPrivkey\": true\n+        }\n+    ],\n+    [\n+        \"924U35yFcYkxe2JXGmuhSRVaShGyhRDZx1ysPmw1sAHuszGMoxq\",\n+        \"3e8dfaf78d4f02b11d0b645648a4f3080d71d0d068979c47f7255c9a29eee01d\",\n+        {\n+            \"chain\": \"signet\",\n             \"isCompressed\": false,\n-            \"isPrivkey\": true,\n-            \"chain\": \"regtest\"\n+            \"isPrivkey\": true\n         }\n     ],\n     [\n-        \"cTpB4YiyKiBcPxnefsDpbnDxFDffjqJob8wGCEDXxgQ7zQoMXJdH\",\n-        \"b9f4892c9e8282028fea1d2667c4dc5213564d41fc5783896a0d843fc15089f3\",\n+        \"cRy1qCf2LUesGPQagTkYwk2V3PyN2KCPKgxeg6k6KoJPzH7nrVjw\",\n+        \"82d4187690d6b59bcffda27dae52f2ecb87313cfc0904e0b674a27d906a65fde\",\n         {\n+            \"chain\": \"signet\",\n             \"isCompressed\": true,\n-            \"isPrivkey\": true,\n-            \"chain\": \"test\"\n+            \"isPrivkey\": true\n         }\n     ],\n     [\n-        \"cTpB4YiyKiBcPxnefsDpbnDxFDffjqJob8wGCEDXxgQ7zQoMXJdH\",\n-        \"b9f4892c9e8282028fea1d2667c4dc5213564d41fc5783896a0d843fc15089f3\",\n+        \"932NTcHK35Apf2C3K9Zv1ZdeZEmB1x7ZT2Ju3SjoEY6pUgUpT7H\",\n+        \"bd7dba24df9e003e145ae9b4862776413a0bb6fa5b4e42753397f2d9536e58a9\",\n         {\n-            \"isCompressed\": true,\n-            \"isPrivkey\": true,\n-            \"chain\": \"regtest\"\n+            \"chain\": \"regtest\",\n+            \"isCompressed\": false,\n+            \"isPrivkey\": true\n         }\n     ],\n     [\n-        \"1Ax4gZtb7gAit2TivwejZHYtNNLT18PUXJ\",\n-        \"76a9146d23156cbbdcc82a5a47eee4c2c7c583c18b6bf488ac\",\n+        \"cNa75orYQ2oos52zCnMaS5PG6XbNZKc5LpGxTHacrxwWeX4WAK3E\",\n+        \"1d87e3c58b08766fea03598380ec8d59f8c88d5392bf683ab1088bd4caf073ee\",\n         {\n-            \"isPrivkey\": false,\n-            \"chain\": \"main\"\n+            \"chain\": \"regtest\",\n+            \"isCompressed\": true,\n+            \"isPrivkey\": true\n         }\n     ],\n     [\n-        \"3QjYXhTkvuj8qPaXHTTWb5wjXhdsLAAWVy\",\n-        \"a914fcc5460dd6e2487c7d75b1963625da0e8f4c597587\",\n+        \"bc1q5cuatynjmk4szh40mmunszfzh7zrc5xm9w8ccy\",\n+        \"0014a639d59272ddab015eafdef9380922bf843c50db\",\n         {\n+            \"chain\": \"main\",\n             \"isPrivkey\": false,\n-            \"chain\": \"main\"\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"n3ZddxzLvAY9o7184TB4c6FJasAybsw4HZ\",\n-        \"76a914f1d470f9b02370fdec2e6b708b08ac431bf7a5f788ac\",\n+        \"bc1qkw7lz3ahms6e0ajv27mzh7g62tchjpmve4afc29u7w49tddydy2syv0087\",\n+        \"0020b3bdf147b7dc3597f64c57b62bf91a52f179076ccd7a9c28bcf3aa55b5a46915\",\n         {\n+            \"chain\": \"main\",\n             \"isPrivkey\": false,\n-            \"chain\": \"test\"\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"2NBFNJTktNa7GZusGbDbGKRZTxdK9VVez3n\",\n-        \"a914c579342c2c4c9220205e2cdc285617040c924a0a87\",\n+        \"bc1p5rgvqejqh9dh37t9g94dd9cm8vtqns7dndgj423egwggsggcdzmsspvr7j\",\n+        \"5120a0d0c06640b95b78f965416ad6971b3b1609c3cd9b512aaa39439088211868b7\",\n         {\n+            \"chain\": \"main\",\n             \"isPrivkey\": false,\n-            \"chain\": \"test\"\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"5K494XZwps2bGyeL71pWid4noiSNA2cfCibrvRWqcHSptoFn7rc\",\n-        \"a326b95ebae30164217d7a7f57d72ab2b54e3be64928a19da0210b9568d4015e\",\n+        \"bc1zr4pq63udck\",\n+        \"52021d42\",\n         {\n-            \"isCompressed\": false,\n-            \"isPrivkey\": true,\n-            \"chain\": \"main\"\n+            \"chain\": \"main\",\n+            \"isPrivkey\": false,\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"L1RrrnXkcKut5DEMwtDthjwRcTTwED36thyL1DebVrKuwvohjMNi\",\n-        \"7d998b45c219a1e38e99e7cbd312ef67f77a455a9b50c730c27f02c6f730dfb4\",\n+        \"tb1q74fxwnvhsue0l8wremgq66xzvn48jlc5zthsvz\",\n+        \"0014f552674d978732ff9dc3ced00d68c264ea797f14\",\n         {\n-            \"isCompressed\": true,\n-            \"isPrivkey\": true,\n-            \"chain\": \"main\"\n+            \"chain\": \"test\",\n+            \"isPrivkey\": false,\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"93DVKyFYwSN6wEo3E2fCrFPUp17FtrtNi2Lf7n4G3garFb16CRj\",\n-        \"d6bca256b5abc5602ec2e1c121a08b0da2556587430bcf7e1898af2224885203\",\n+        \"tb1qpt7cqgq8ukv92dcraun9c3n0s3aswrt62vtv8nqmkfpa2tjfghesv9ln74\",\n+        \"00200afd802007e598553703ef265c466f847b070d7a5316c3cc1bb243d52e4945f3\",\n         {\n-            \"isCompressed\": false,\n-            \"isPrivkey\": true,\n-            \"chain\": \"test\"\n+            \"chain\": \"test\",\n+            \"isPrivkey\": false,\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"cTDVKtMGVYWTHCb1AFjmVbEbWjvKpKqKgMaR3QJxToMSQAhmCeTN\",\n-        \"a81ca4e8f90181ec4b61b6a7eb998af17b2cb04de8a03b504b9e34c4c61db7d9\",\n+        \"tb1ph9v3e8nxct57hknlkhkz75p5pnxnkn05cw8ewpxu6tek56g29xgqydzfu7\",\n+        \"5120b9591c9e66c2e9ebda7fb5ec2f50340ccd3b4df4c38f9704dcd2f36a690a2990\",\n         {\n-            \"isCompressed\": true,\n-            \"isPrivkey\": true,\n-            \"chain\": \"test\"\n+            \"chain\": \"test\",\n+            \"isPrivkey\": false,\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"1C5bSj1iEGUgSTbziymG7Cn18ENQuT36vv\",\n-        \"76a9147987ccaa53d02c8873487ef919677cd3db7a691288ac\",\n+        \"tb1ray6e8gxfx49ers6c4c70l3c8lsxtcmlx\",\n+        \"5310e93593a0c9354b91c358ae3cffc707fc\",\n         {\n+            \"chain\": \"test\",\n             \"isPrivkey\": false,\n-            \"chain\": \"main\"\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"3AnNxabYGoTxYiTEZwFEnerUoeFXK2Zoks\",\n-        \"a91463bcc565f9e68ee0189dd5cc67f1b0e5f02f45cb87\",\n+        \"tb1q0sqzfp3zj42u0perxr6jahhu4y03uw4dypk6sc\",\n+        \"00147c002486229555c7872330f52edefca91f1e3aad\",\n         {\n+            \"chain\": \"signet\",\n             \"isPrivkey\": false,\n-            \"chain\": \"main\"\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"n3LnJXCqbPjghuVs8ph9CYsAe4Sh4j97wk\",\n-        \"76a914ef66444b5b17f14e8fae6e7e19b045a78c54fd7988ac\",\n+        \"tb1q9jv4qnawnuevqaeadn47gkq05ev78m4qg3zqejykdr9u0cm7yutq6gu5dj\",\n+        \"00202c99504fae9f32c0773d6cebe4580fa659e3eea044440cc89668cbc7e37e2716\",\n         {\n+            \"chain\": \"signet\",\n             \"isPrivkey\": false,\n-            \"chain\": \"test\"\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"2NB72XtkjpnATMggui83aEtPawyyKvnbX2o\",\n-        \"a914c3e55fceceaa4391ed2a9677f4a4d34eacd021a087\",\n+        \"tb1pxqf7d825wjtcftj7uep8w24jq3tz8vudfaqj20rns8ahqya56gcs92eqtu\",\n+        \"51203013e69d54749784ae5ee642772ab2045623b38d4f41253c7381fb7013b4d231\",\n         {\n+            \"chain\": \"signet\",\n             \"isPrivkey\": false,\n-            \"chain\": \"test\"\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"5KaBW9vNtWNhc3ZEDyNCiXLPdVPHCikRxSBWwV9NrpLLa4LsXi9\",\n-        \"e75d936d56377f432f404aabb406601f892fd49da90eb6ac558a733c93b47252\",\n+        \"tb1rsrzkyvu2rt0dcgexajtazlw5nft4j7494ay396q6auw9375wxsrsgag884\",\n+        \"532080c562338a1adedc2326ec97d17dd49a57597aa5af4912e81aef1c58fa8e3407\",\n         {\n-            \"isCompressed\": false,\n-            \"isPrivkey\": true,\n-            \"chain\": \"main\"\n+            \"chain\": \"signet\",\n+            \"isPrivkey\": false,\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"L1axzbSyynNYA8mCAhzxkipKkfHtAXYF4YQnhSKcLV8YXA874fgT\",\n-        \"8248bd0375f2f75d7e274ae544fb920f51784480866b102384190b1addfbaa5c\",\n+        \"bcrt1qwf52dt9y2sv0f7fwkcpmtfjf74d4np2saeljt6\",\n+        \"00147268a6aca45418f4f92eb603b5a649f55b598550\",\n         {\n-            \"isCompressed\": true,\n-            \"isPrivkey\": true,\n-            \"chain\": \"main\"\n+            \"chain\": \"regtest\",\n+            \"isPrivkey\": false,\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"927CnUkUbasYtDwYwVn2j8GdTuACNnKkjZ1rpZd2yBB1CLcnXpo\",\n-        \"44c4f6a096eac5238291a94cc24c01e3b19b8d8cef72874a079e00a242237a52\",\n+        \"bcrt1q0lma84unycxl4n96etffthqlf7y5axyp4fxf64kmhymvw8l6pwfs39futd\",\n+        \"00207ff7d3d793260dfaccbacad295dc1f4f894e9881aa4c9d56dbb936c71ffa0b93\",\n         {\n-            \"isCompressed\": false,\n-            \"isPrivkey\": true,\n-            \"chain\": \"test\"\n+            \"chain\": \"regtest\",\n+            \"isPrivkey\": false,\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"cUcfCMRjiQf85YMzzQEk9d1s5A4K7xL5SmBCLrezqXFuTVefyhY7\",\n-        \"d1de707020a9059d6d3abaf85e17967c6555151143db13dbb06db78df0f15c69\",\n+        \"bcrt1p3xat2ryucc2v0adrktqnavfzttvezrr27ngltsa2726p2ehvxz4se722v2\",\n+        \"512089bab50c9cc614c7f5a3b2c13eb1225ad9910c6af4d1f5c3aaf2b41566ec30ab\",\n         {\n-            \"isCompressed\": true,\n-            \"isPrivkey\": true,\n-            \"chain\": \"test\"\n+            \"chain\": \"regtest\",\n+            \"isPrivkey\": false,\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"1Gqk4Tv79P91Cc1STQtU3s1W6277M2CVWu\",\n-        \"76a914adc1cc2081a27206fae25792f28bbc55b831549d88ac\",\n+        \"bcrt1saflydw6e26xhp29euhy5jke5jjqyywk3wvtc9ulgw9dvxyuqy9hdnxthyw755c7ldavy7u\",\n+        \"6028ea7e46bb59568d70a8b9e5c9495b349480423ad1731782f3e8715ac31380216ed9997723bd4a63df\",\n         {\n+            \"chain\": \"regtest\",\n             \"isPrivkey\": false,\n-            \"chain\": \"main\"\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"33vt8ViH5jsr115AGkW6cEmEz9MpvJSwDk\",\n-        \"a914188f91a931947eddd7432d6e614387e32b24470987\",\n+        \"16y3Q1XVRZqMR9T1XL1FkvNtD2E1bXBuYa\",\n+        \"76a9144171ec673aeb9fcf42af6094a3c82207e3b9a78188ac\",\n         {\n-            \"isPrivkey\": false,\n-            \"chain\": \"main\"\n+            \"chain\": \"main\",\n+            \"isPrivkey\": false\n         }\n     ],\n     [\n-        \"mhaMcBxNh5cqXm4aTQ6EcVbKtfL6LGyK2H\",\n-        \"76a9141694f5bc1a7295b600f40018a618a6ea48eeb49888ac\",\n+        \"3CmZZnAiHVQgiAKSakf864oJMxN2BP1eLC\",\n+        \"a914798575fc1041b9440c4e63c28e57e597d00b7e4387\",\n         {\n-            \"isPrivkey\": false,\n-            \"chain\": \"test\"\n+            \"chain\": \"main\",\n+            \"isPrivkey\": false\n         }\n     ],\n     [\n-        \"2MxgPqX1iThW3oZVk9KoFcE5M4JpiETssVN\",\n-        \"a9143b9b3fd7a50d4f08d1a5b0f62f644fa7115ae2f387\",\n+        \"mtCB3SoBo7EYUv8j54kUubGY4x3aJPY8nk\",\n+        \"76a9148b0c5f9ee714e0d1d24642ad63d9d5f398d9b56588ac\",\n         {\n-            \"isPrivkey\": false,\n-            \"chain\": \"test\"\n+            \"chain\": \"test\",\n+            \"isPrivkey\": false\n         }\n     ],\n     [\n-        \"5HtH6GdcwCJA4ggWEL1B3jzBBUB8HPiBi9SBc5h9i4Wk4PSeApR\",\n-        \"091035445ef105fa1bb125eccfb1882f3fe69592265956ade751fd095033d8d0\",\n+        \"2N5ymzzKpx6EdUR4UdMZ7t9hcuwqtpHwgw5\",\n+        \"a9148badb3c3b5c0d39f906f7618e0018b7eae4baf7387\",\n         {\n-            \"isCompressed\": false,\n-            \"isPrivkey\": true,\n-            \"chain\": \"main\"\n+            \"chain\": \"test\",\n+            \"isPrivkey\": false\n         }\n     ],\n     [\n-        \"L2xSYmMeVo3Zek3ZTsv9xUrXVAmrWxJ8Ua4cw8pkfbQhcEFhkXT8\",\n-        \"ab2b4bcdfc91d34dee0ae2a8c6b6668dadaeb3a88b9859743156f462325187af\",\n+        \"myXnpYbub28zgiJupDdZSWZtDbjcyfJVby\",\n+        \"76a914c59ac57661b57daadd7c0caf7318c14f54c6c0fa88ac\",\n         {\n-            \"isCompressed\": true,\n-            \"isPrivkey\": true,\n-            \"chain\": \"main\"\n+            \"chain\": \"signet\",\n+            \"isPrivkey\": false\n         }\n     ],\n     [\n-        \"92xFEve1Z9N8Z641KQQS7ByCSb8kGjsDzw6fAmjHN1LZGKQXyMq\",\n-        \"b4204389cef18bbe2b353623cbf93e8678fbc92a475b664ae98ed594e6cf0856\",\n+        \"2MtLg8jS5jSXm9evMzTtvpLjy26dBmjFEoT\",\n+        \"a9140c0007e89cea625d3bf9543baa5a470bb7e5b67287\",\n         {\n-            \"isCompressed\": false,\n-            \"isPrivkey\": true,\n-            \"chain\": \"test\"\n+            \"chain\": \"signet\",\n+            \"isPrivkey\": false\n         }\n     ],\n     [\n-        \"92xFEve1Z9N8Z641KQQS7ByCSb8kGjsDzw6fAmjHN1LZGKQXyMq\",\n-        \"b4204389cef18bbe2b353623cbf93e8678fbc92a475b664ae98ed594e6cf0856\",\n+        \"mzCyqdf2UNGdpgkD9NBgLcxdwXRg1i9buY\",\n+        \"76a914cd04311bdd1ef9c5c24e41930e032aade82a863a88ac\",\n         {\n-            \"isCompressed\": false,\n-            \"isPrivkey\": true,\n-            \"chain\": \"regtest\"\n+            \"chain\": \"regtest\",\n+            \"isPrivkey\": false\n         }\n     ],\n     [\n-        \"cVM65tdYu1YK37tNoAyGoJTR13VBYFva1vg9FLuPAsJijGvG6NEA\",\n-        \"e7b230133f1b5489843260236b06edca25f66adb1be455fbd38d4010d48faeef\",\n+        \"2N3zGiwFku2vQjYnAqXv5Qu2ztfYRhh7tbF\",\n+        \"a91475d56d75c88e704d6c72fbe84ac1505abf736b4087\",\n         {\n-            \"isCompressed\": true,\n-            \"isPrivkey\": true,\n-            \"chain\": \"test\"\n+            \"chain\": \"regtest\",\n+            \"isPrivkey\": false\n         }\n     ],\n     [\n-        \"1JwMWBVLtiqtscbaRHai4pqHokhFCbtoB4\",\n-        \"76a914c4c1b72491ede1eedaca00618407ee0b772cad0d88ac\",\n+        \"5JUHCgyxNSHg64wwju72eNsG6ajqo4Z2fHHw9iLDLfh69rSiL7w\",\n+        \"5644d06d88855dacf3192a31df8f4acd8e4c155c52a86d2c1fa48303f5cff053\",\n         {\n-            \"isPrivkey\": false,\n-            \"chain\": \"main\"\n+            \"chain\": \"main\",\n+            \"isCompressed\": false,\n+            \"isPrivkey\": true\n         }\n     ],\n     [\n-        \"3QCzvfL4ZRvmJFiWWBVwxfdaNBT8EtxB5y\",\n-        \"a914f6fe69bcb548a829cce4c57bf6fff8af3a5981f987\",\n+        \"L2kZaexG69VSriMe9T2m1jkS86iPe3xNbjcdfakRC1PHe7ay78Ji\",\n+        \"a50ee94aefcabf5a5d7c85be5b3844dee03c5604861dbfc77fe388c91e5a30f8\",\n         {\n-            \"isPrivkey\": false,\n-            \"chain\": \"main\"\n+            \"chain\": \"main\",\n+            \"isCompressed\": true,\n+            \"isPrivkey\": true\n         }\n     ],\n     [\n-        \"mizXiucXRCsEriQCHUkCqef9ph9qtPbZZ6\",\n-        \"76a914261f83568a098a8638844bd7aeca039d5f2352c088ac\",\n+        \"927JwT1ViCr5TD2ZX8CsMNhg17dXmou5xu4y2KiH54zD7i34UJq\",\n+        \"4502a54c0026b0150281d41f40860d1e23870c63cdc32645bbed688f2ee41f64\",\n         {\n-            \"isPrivkey\": false,\n-            \"chain\": \"test\"\n+            \"chain\": \"test\",\n+            \"isCompressed\": false,\n+            \"isPrivkey\": true\n         }\n     ],\n     [\n-        \"2NEWDzHWwY5ZZp8CQWbB7ouNMLqCia6YRda\",\n-        \"a914e930e1834a4d234702773951d627cce82fbb5d2e87\",\n+        \"cTpGGNPVy2Eagawohbr4aGtRJzpLnjxGsGYh9DUcBM45f3KdKGF6\",\n+        \"ba005a0cb39587aab00bd54c848b59e8adaed47403228567ddc739c2a344ff59\",\n         {\n-            \"isPrivkey\": false,\n-            \"chain\": \"test\"\n+            \"chain\": \"test\",\n+            \"isCompressed\": true,\n+            \"isPrivkey\": true\n         }\n     ],\n     [\n-        \"5KQmDryMNDcisTzRp3zEq9e4awRmJrEVU1j5vFRTKpRNYPqYrMg\",\n-        \"d1fab7ab7385ad26872237f1eb9789aa25cc986bacc695e07ac571d6cdac8bc0\",\n+        \"932PLCLA19yPNqV67qwHBSGjxi82LVzWBF7josL9ab4Q1kxgPGF\",\n+        \"bd8677e076eb39770bf7e9f9e8d3f2cf257effab9b4c220fd3439ccfc208c984\",\n         {\n+            \"chain\": \"signet\",\n             \"isCompressed\": false,\n-            \"isPrivkey\": true,\n-            \"chain\": \"main\"\n+            \"isPrivkey\": true\n         }\n     ],\n     [\n-        \"L39Fy7AC2Hhj95gh3Yb2AU5YHh1mQSAHgpNixvm27poizcJyLtUi\",\n-        \"b0bbede33ef254e8376aceb1510253fc3550efd0fcf84dcd0c9998b288f166b3\",\n+        \"cViUpEy8URSsLjUvxwL7cEuNgCVqM7oKBzd1ZPbA4khcQsQJuj1j\",\n+        \"f2b36ade8393e29dc71e52cb75ba1109ba210203cd7d0a5ae881ad6846516203\",\n         {\n+            \"chain\": \"signet\",\n             \"isCompressed\": true,\n-            \"isPrivkey\": true,\n-            \"chain\": \"main\"\n+            \"isPrivkey\": true\n         }\n     ],\n     [\n-        \"91cTVUcgydqyZLgaANpf1fvL55FH53QMm4BsnCADVNYuWuqdVys\",\n-        \"037f4192c630f399d9271e26c575269b1d15be553ea1a7217f0cb8513cef41cb\",\n+        \"92jddDjJCVDmJtgvBHQ9i58PMash8kwsYhRdNo22ea2MYPXdCBE\",\n+        \"977bf8686f1bcad28f86c4c14afbd33215746bd19203647bf7ff9c6fddc9cc87\",\n         {\n+            \"chain\": \"regtest\",\n             \"isCompressed\": false,\n-            \"isPrivkey\": true,\n-            \"chain\": \"test\"\n+            \"isPrivkey\": true\n         }\n     ],\n     [\n-        \"cQspfSzsgLeiJGB2u8vrAiWpCU4MxUT6JseWo2SjXy4Qbzn2fwDw\",\n-        \"6251e205e8ad508bab5596bee086ef16cd4b239e0cc0c5d7c4e6035441e7d5de\",\n+        \"cVwAuMoUqRo399X7vXzuzQyPEvZJMXM8c82zHzRkFCxPCSGx8A6y\",\n+        \"f93acbbce02b8cb9ddca3fad495441e324cc01eb640b0a7b4c9f0e31644c822a\",\n         {\n+            \"chain\": \"regtest\",\n             \"isCompressed\": true,\n-            \"isPrivkey\": true,\n-            \"chain\": \"test\"\n+            \"isPrivkey\": true\n         }\n     ],\n     [\n-        \"19dcawoKcZdQz365WpXWMhX6QCUpR9SY4r\",\n-        \"76a9145eadaf9bb7121f0f192561a5a62f5e5f5421029288ac\",\n+        \"bc1qz377zwe5awr68dnggengqx9vrjt05k98q3sw2n\",\n+        \"0014147de13b34eb87a3b66846668018ac1c96fa58a7\",\n         {\n+            \"chain\": \"main\",\n             \"isPrivkey\": false,\n-            \"chain\": \"main\"\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"37Sp6Rv3y4kVd1nQ1JV5pfqXccHNyZm1x3\",\n-        \"a9143f210e7277c899c3a155cc1c90f4106cbddeec6e87\",\n+        \"bc1qkmhskpdzg8kdkfywhu09kswwn9qan9vnkrf6mk40jvnr06s6sz5ssf82ya\",\n+        \"0020b6ef0b05a241ecdb248ebf1e5b41ce9941d99593b0d3addaaf932637ea1a80a9\",\n         {\n+            \"chain\": \"main\",\n             \"isPrivkey\": false,\n-            \"chain\": \"main\"\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"myoqcgYiehufrsnnkqdqbp69dddVDMopJu\",\n-        \"76a914c8a3c2a09a298592c3e180f02487cd91ba3400b588ac\",\n+        \"bc1ps8cndas60cntk8x79sg9f5e5jz7x050z8agyugln2ukkks23rryqpejzkc\",\n+        \"512081f136f61a7e26bb1cde2c1054d33490bc67d1e23f504e23f3572d6b415118c8\",\n         {\n+            \"chain\": \"main\",\n             \"isPrivkey\": false,\n-            \"chain\": \"test\"\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"2N7FuwuUuoTBrDFdrAZ9KxBmtqMLxce9i1C\",\n-        \"a91499b31df7c9068d1481b596578ddbb4d3bd90baeb87\",\n+        \"bc1zn4tsczge9l\",\n+        \"52029d57\",\n         {\n+            \"chain\": \"main\",\n             \"isPrivkey\": false,\n-            \"chain\": \"test\"\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"5KL6zEaMtPRXZKo1bbMq7JDjjo1bJuQcsgL33je3oY8uSJCR5b4\",\n-        \"c7666842503db6dc6ea061f092cfb9c388448629a6fe868d068c42a488b478ae\",\n+        \"tb1q6xw0wwd9n9d7ge87dryz4vm5vtahzhvz6yett3\",\n+        \"0014d19cf739a5995be464fe68c82ab37462fb715d82\",\n         {\n-            \"isCompressed\": false,\n-            \"isPrivkey\": true,\n-            \"chain\": \"main\"\n+            \"chain\": \"test\",\n+            \"isPrivkey\": false,\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"KwV9KAfwbwt51veZWNscRTeZs9CKpojyu1MsPnaKTF5kz69H1UN2\",\n-        \"07f0803fc5399e773555ab1e8939907e9badacc17ca129e67a2f5f2ff84351dd\",\n+        \"tb1qwn9zq9fu5uk35ykpgsc7rz4uawy4yh0r5m5er26768h5ur50su3qj6evun\",\n+        \"002074ca20153ca72d1a12c14431e18abceb89525de3a6e991ab5ed1ef4e0e8f8722\",\n         {\n-            \"isCompressed\": true,\n-            \"isPrivkey\": true,\n-            \"chain\": \"main\"\n+            \"chain\": \"test\",\n+            \"isPrivkey\": false,\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"93N87D6uxSBzwXvpokpzg8FFmfQPmvX4xHoWQe3pLdYpbiwT5YV\",\n-        \"ea577acfb5d1d14d3b7b195c321566f12f87d2b77ea3a53f68df7ebf8604a801\",\n+        \"tb1pmcdc5d8gr92rtemfsnhpeqanvs0nr82upn5dktxluz9n0qcv34lqxke0wq\",\n+        \"5120de1b8a34e8195435e76984ee1c83b3641f319d5c0ce8db2cdfe08b37830c8d7e\",\n         {\n-            \"isCompressed\": false,\n-            \"isPrivkey\": true,\n-            \"chain\": \"test\"\n+            \"chain\": \"test\",\n+            \"isPrivkey\": false,\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"cMxXusSihaX58wpJ3tNuuUcZEQGt6DKJ1wEpxys88FFaQCYjku9h\",\n-        \"0b3b34f0958d8a268193a9814da92c3e8b58b4a4378a542863e34ac289cd830c\",\n+        \"tb1rgxjvtfzp0xczz6dlzqv8d5cmuykk4qkk\",\n+        \"531041a4c5a44179b02169bf101876d31be1\",\n         {\n-            \"isCompressed\": true,\n-            \"isPrivkey\": true,\n-            \"chain\": \"test\"\n+            \"chain\": \"test\",\n+            \"isPrivkey\": false,\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"13p1ijLwsnrcuyqcTvJXkq2ASdXqcnEBLE\",\n-        \"76a9141ed467017f043e91ed4c44b4e8dd674db211c4e688ac\",\n+        \"tb1qa9dlyt6fydestul4y4wh72yshh044w32np8etk\",\n+        \"0014e95bf22f49237305f3f5255d7f2890bddf5aba2a\",\n         {\n+            \"chain\": \"signet\",\n             \"isPrivkey\": false,\n-            \"chain\": \"main\"\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"3ALJH9Y951VCGcVZYAdpA3KchoP9McEj1G\",\n-        \"a9145ece0cadddc415b1980f001785947120acdb36fc87\",\n+        \"tb1qu4p26n0033720xm0rjgkds5ehdwf039k2fgv75um5krrvfhrrj7qckl9r2\",\n+        \"0020e542ad4def8c7ca79b6f1c9166c299bb5c97c4b65250cf539ba5863626e31cbc\",\n         {\n+            \"chain\": \"signet\",\n             \"isPrivkey\": false,\n-            \"chain\": \"main\"\n+            \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4\",\n-        \"0014751e76e8199196d454941c45d1b3a323f1433bd6\",\n+        \"tb1pjyukm4n4flwd0ey3lrl06c9kalr60ggmlkcxq2rhhxmy4lvkmkpqexdzqy\",\n+        \"512091396dd6754fdcd7e491f8fefd60b6efc7a7a11bfdb0602877b9b64afd96dd82\",\n         {\n+            \"chain\": \"signet\",\n             \"isPrivkey\": false,\n-            \"chain\": \"main\",\n             \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"bcrt1qw508d6qejxtdg4y5r3zarvary0c5xw7kygt080\",\n-        \"0014751e76e8199196d454941c45d1b3a323f1433bd6\",\n+        \"tb1r4k75s5syvewsvxufdc3xfhf4tw4u30alw39xny3dnxrl6hau7systymfdv\",\n+        \"5320adbd485204665d061b896e2264dd355babc8bfbf744a69922d9987fd5fbcf409\",\n         {\n+            \"chain\": \"signet\",\n             \"isPrivkey\": false,\n-            \"chain\": \"regtest\",\n             \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sl5k7\",\n-        \"00201863143c14c5166804bd19203356da136c985678cd4d27a1b8c6329604903262\",\n+        \"bcrt1qnk3tdwwj47ppc4pqmxkjdusegedn9ru5gvccwa\",\n+        \"00149da2b6b9d2af821c5420d9ad26f219465b328f94\",\n         {\n+            \"chain\": \"regtest\",\n             \"isPrivkey\": false,\n-            \"chain\": \"test\",\n             \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"bc1pw508d6qejxtdg4y5r3zarvary0c5xw7kw508d6qejxtdg4y5r3zarvary0c5xw7k7grplx\",\n-        \"5128751e76e8199196d454941c45d1b3a323f1433bd6751e76e8199196d454941c45d1b3a323f1433bd6\",\n+        \"bcrt1qz7prfshfkwsxuk72pt6mzr6uumq4qllxe4vmwqt89tat48d362yqlykk6a\",\n+        \"0020178234c2e9b3a06e5bca0af5b10f5ce6c1507fe6cd59b701672afaba9db1d288\",\n         {\n+            \"chain\": \"regtest\",\n             \"isPrivkey\": false,\n-            \"chain\": \"main\",\n             \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"bc1sw50qa3jx3s\",\n-        \"6002751e\",\n+        \"bcrt1pumee3wj80xvyr7wjmj7zsk26x5pn095aegy862yhx6f2j9sgc9hq6cj4cm\",\n+        \"5120e6f398ba47799841f9d2dcbc28595a350337969dca087d28973692a91608c16e\",\n         {\n+            \"chain\": \"regtest\",\n             \"isPrivkey\": false,\n-            \"chain\": \"main\",\n             \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"bc1zw508d6qejxtdg4y5r3zarvaryvg6kdaj\",\n-        \"5210751e76e8199196d454941c45d1b3a323\",\n+        \"bcrt1szqz8hj64d2hhc6nt65v09jxal66pgff2xpcp9kj648qkk8kjzxelsts4dktd799g47uase\",\n+        \"602810047bcb556aaf7c6a6bd518f2c8ddfeb414252a307012da5aa9c16b1ed211b3f82e156d96df14a8\",\n         {\n+            \"chain\": \"regtest\",\n             \"isPrivkey\": false,\n-            \"chain\": \"main\",\n             \"tryCaseFlip\": true\n         }\n     ],\n     [\n-        \"tb1qqqqqp399et2xygdj5xreqhjjvcmzhxw4aywxecjdzew6hylgvsesrxh6hy\",\n-        \"0020000000c4a5cad46221b2a187905e5266362b99d5e91c6ce24d165dab93e86433\",\n+        \"12agZTajtRE3STSchwWNWnrm467zzTQ916\",\n+        \"76a9141156e00f70061e5faba8b71593a8c7554b47090c88ac\",\n+        {\n+            \"chain\": \"main\",\n+            \"isPrivkey\": false\n+        }\n+    ],\n+    [\n+        \"3NXqB6iZiPYbKruNT3d9xNBTmtb73xMvvf\",\n+        \"a914e49decc9e5d97e0547d3642f3a4795b13ae62bca87\",\n+        {\n+            \"chain\": \"main\",\n+            \"isPrivkey\": false\n+        }\n+    ],\n+    [\n+        \"mjgt4BoCYxjzWvJFoh68x7cj5GeaKDYhyx\",\n+        \"76a9142dc11fc7b8072f733f690ffb0591c00f4062295c88ac\",\n         {\n-            \"isPrivkey\": false,\n             \"chain\": \"test\",\n-            \"tryCaseFlip\": true\n+            \"isPrivkey\": false\n         }\n     ],\n     [\n-        \"bcrt1qqqqqp399et2xygdj5xreqhjjvcmzhxw4aywxecjdzew6hylgvseswlauz7\",\n-        \"0020000000c4a5cad46221b2a187905e5266362b99d5e91c6ce24d165dab93e86433\",\n+        \"2NCT6FdQ5MxorHgnFxLeHyGwTGRdkHcrJDH\",\n+        \"a914d2a8ec992b0894a0d9391ca5d9c45c388c41be7e87\",\n         {\n-            \"isPrivkey\": false,\n-            \"chain\": \"regtest\",\n-            \"tryCaseFlip\": true\n+            \"chain\": \"test\",\n+            \"isPrivkey\": false\n+        }\n+    ],\n+    [\n+        \"mpomiA7wqDnMcxaNLC23eBuXAb4U6H4ZqW\",\n+        \"76a91465e75e340415ed297c58d6a14d3c17ceeaa17bbd88ac\",\n+        {\n+            \"chain\": \"signet\",\n+            \"isPrivkey\": false\n+        }\n+    ],\n+    [\n+        \"2N1pGAA5uatbU2PKvMA9BnJmHcK6yHfMiZa\",\n+        \"a9145e008b6cc232164570befc23d216060bf4ea793b87\",\n+        {\n+            \"chain\": \"signet\",\n+            \"isPrivkey\": false\n         }\n     ]\n ]"
      },
      {
        "sha": "a6080ad3ddb9a553ac601edc6fb13ac4c75b2ea4",
        "filename": "src/test/dbwrapper_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/dbwrapper_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/dbwrapper_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/dbwrapper_tests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -5,7 +5,6 @@\n #include <dbwrapper.h>\n #include <test/util/setup_common.h>\n #include <uint256.h>\n-#include <util/memory.h>\n \n #include <memory>\n \n@@ -207,7 +206,7 @@ BOOST_AUTO_TEST_CASE(existing_data_no_obfuscate)\n     create_directories(ph);\n \n     // Set up a non-obfuscated wrapper to write some initial data.\n-    std::unique_ptr<CDBWrapper> dbw = MakeUnique<CDBWrapper>(ph, (1 << 10), false, false, false);\n+    std::unique_ptr<CDBWrapper> dbw = std::make_unique<CDBWrapper>(ph, (1 << 10), false, false, false);\n     char key = 'k';\n     uint256 in = InsecureRand256();\n     uint256 res;\n@@ -248,7 +247,7 @@ BOOST_AUTO_TEST_CASE(existing_data_reindex)\n     create_directories(ph);\n \n     // Set up a non-obfuscated wrapper to write some initial data.\n-    std::unique_ptr<CDBWrapper> dbw = MakeUnique<CDBWrapper>(ph, (1 << 10), false, false, false);\n+    std::unique_ptr<CDBWrapper> dbw = std::make_unique<CDBWrapper>(ph, (1 << 10), false, false, false);\n     char key = 'k';\n     uint256 in = InsecureRand256();\n     uint256 res;"
      },
      {
        "sha": "e75982bc6fe2f5e8a4cdaa31cff3cb24bf351b32",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -15,7 +15,6 @@\n #include <script/standard.h>\n #include <serialize.h>\n #include <txorphanage.h>\n-#include <util/memory.h>\n #include <util/string.h>\n #include <util/system.h>\n #include <util/time.h>\n@@ -68,7 +67,7 @@ BOOST_FIXTURE_TEST_SUITE(denialofservice_tests, TestingSetup)\n BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n {\n     const CChainParams& chainparams = Params();\n-    auto connman = MakeUnique<CConnman>(0x1337, 0x1337);\n+    auto connman = std::make_unique<CConnman>(0x1337, 0x1337);\n     auto peerLogic = PeerManager::make(chainparams, *connman, nullptr, *m_node.scheduler,\n                                        *m_node.chainman, *m_node.mempool, false);\n \n@@ -138,7 +137,7 @@ static void AddRandomOutboundPeer(std::vector<CNode *> &vNodes, PeerManager &pee\n BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n {\n     const CChainParams& chainparams = Params();\n-    auto connman = MakeUnique<CConnmanTest>(0x1337, 0x1337);\n+    auto connman = std::make_unique<CConnmanTest>(0x1337, 0x1337);\n     auto peerLogic = PeerManager::make(chainparams, *connman, nullptr, *m_node.scheduler,\n                                        *m_node.chainman, *m_node.mempool, false);\n \n@@ -211,8 +210,8 @@ BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n BOOST_AUTO_TEST_CASE(peer_discouragement)\n {\n     const CChainParams& chainparams = Params();\n-    auto banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n-    auto connman = MakeUnique<CConnman>(0x1337, 0x1337);\n+    auto banman = std::make_unique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n+    auto connman = std::make_unique<CConnman>(0x1337, 0x1337);\n     auto peerLogic = PeerManager::make(chainparams, *connman, banman.get(), *m_node.scheduler,\n                                        *m_node.chainman, *m_node.mempool, false);\n \n@@ -258,8 +257,8 @@ BOOST_AUTO_TEST_CASE(peer_discouragement)\n BOOST_AUTO_TEST_CASE(DoS_bantime)\n {\n     const CChainParams& chainparams = Params();\n-    auto banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n-    auto connman = MakeUnique<CConnman>(0x1337, 0x1337);\n+    auto banman = std::make_unique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n+    auto connman = std::make_unique<CConnman>(0x1337, 0x1337);\n     auto peerLogic = PeerManager::make(chainparams, *connman, banman.get(), *m_node.scheduler,\n                                        *m_node.chainman, *m_node.mempool, false);\n "
      },
      {
        "sha": "aecf955fee7f2272c92d2f2f1532d42811331a32",
        "filename": "src/test/descriptor_tests.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 13,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/descriptor_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/descriptor_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/descriptor_tests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -10,6 +10,7 @@\n \n #include <boost/test/unit_test.hpp>\n \n+#include <optional>\n #include <string>\n #include <vector>\n \n@@ -65,7 +66,7 @@ std::string UseHInsteadOfApostrophe(const std::string& desc)\n \n const std::set<std::vector<uint32_t>> ONLY_EMPTY{{}};\n \n-void DoCheck(const std::string& prv, const std::string& pub, const std::string& norm_prv, const std::string& norm_pub, int flags, const std::vector<std::vector<std::string>>& scripts, const Optional<OutputType>& type, const std::set<std::vector<uint32_t>>& paths = ONLY_EMPTY,\n+void DoCheck(const std::string& prv, const std::string& pub, const std::string& norm_prv, const std::string& norm_pub, int flags, const std::vector<std::vector<std::string>>& scripts, const std::optional<OutputType>& type, const std::set<std::vector<uint32_t>>& paths = ONLY_EMPTY,\n     bool replace_apostrophe_with_h_in_prv=false, bool replace_apostrophe_with_h_in_pub=false)\n {\n     FlatSigningProvider keys_priv, keys_pub;\n@@ -262,7 +263,7 @@ void DoCheck(const std::string& prv, const std::string& pub, const std::string&\n     BOOST_CHECK_MESSAGE(left_paths.empty(), \"Not all expected key paths found: \" + prv);\n }\n \n-void Check(const std::string& prv, const std::string& pub, const std::string& norm_prv, const std::string& norm_pub, int flags, const std::vector<std::vector<std::string>>& scripts, const Optional<OutputType>& type, const std::set<std::vector<uint32_t>>& paths = ONLY_EMPTY)\n+void Check(const std::string& prv, const std::string& pub, const std::string& norm_prv, const std::string& norm_pub, int flags, const std::vector<std::vector<std::string>>& scripts, const std::optional<OutputType>& type, const std::set<std::vector<uint32_t>>& paths = ONLY_EMPTY)\n {\n     bool found_apostrophes_in_prv = false;\n     bool found_apostrophes_in_pub = false;\n@@ -295,8 +296,8 @@ BOOST_FIXTURE_TEST_SUITE(descriptor_tests, BasicTestingSetup)\n BOOST_AUTO_TEST_CASE(descriptor_test)\n {\n     // Basic single-key compressed\n-    Check(\"combo(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)\", \"combo(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)\", \"combo(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)\", \"combo(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)\", SIGNABLE, {{\"2103a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bdac\",\"76a9149a1c78a507689f6f54b847ad1cef1e614ee23f1e88ac\",\"00149a1c78a507689f6f54b847ad1cef1e614ee23f1e\",\"a91484ab21b1b2fd065d4504ff693d832434b6108d7b87\"}}, nullopt);\n-    Check(\"pk(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)\", \"pk(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)\", \"pk(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)\", \"pk(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)\", SIGNABLE, {{\"2103a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bdac\"}}, nullopt);\n+    Check(\"combo(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)\", \"combo(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)\", \"combo(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)\", \"combo(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)\", SIGNABLE, {{\"2103a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bdac\",\"76a9149a1c78a507689f6f54b847ad1cef1e614ee23f1e88ac\",\"00149a1c78a507689f6f54b847ad1cef1e614ee23f1e\",\"a91484ab21b1b2fd065d4504ff693d832434b6108d7b87\"}}, std::nullopt);\n+    Check(\"pk(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)\", \"pk(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)\", \"pk(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)\", \"pk(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)\", SIGNABLE, {{\"2103a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bdac\"}}, std::nullopt);\n     Check(\"pkh([deadbeef/1/2'/3/4']L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)\", \"pkh([deadbeef/1/2'/3/4']03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)\", \"pkh([deadbeef/1/2'/3/4']L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)\", \"pkh([deadbeef/1/2'/3/4']03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)\", SIGNABLE, {{\"76a9149a1c78a507689f6f54b847ad1cef1e614ee23f1e88ac\"}}, OutputType::LEGACY, {{1,0x80000002UL,3,0x80000004UL}});\n     Check(\"wpkh(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)\", \"wpkh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)\", \"wpkh(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)\", \"wpkh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)\", SIGNABLE, {{\"00149a1c78a507689f6f54b847ad1cef1e614ee23f1e\"}}, OutputType::BECH32);\n     Check(\"sh(wpkh(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1))\", \"sh(wpkh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd))\", \"sh(wpkh(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1))\", \"sh(wpkh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd))\", SIGNABLE, {{\"a91484ab21b1b2fd065d4504ff693d832434b6108d7b87\"}}, OutputType::P2SH_SEGWIT);\n@@ -305,8 +306,8 @@ BOOST_AUTO_TEST_CASE(descriptor_test)\n     CheckUnparsable(\"pkh([deadbeef]/1/2'/3/4']L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)\", \"pkh([deadbeef]/1/2'/3/4']03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)\", \"Multiple ']' characters found for a single pubkey\"); // Multiple end brackets in key origin\n \n     // Basic single-key uncompressed\n-    Check(\"combo(5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"combo(04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\", \"combo(5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"combo(04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\",SIGNABLE, {{\"4104a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235ac\",\"76a914b5bd079c4d57cc7fc28ecf8213a6b791625b818388ac\"}}, nullopt);\n-    Check(\"pk(5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"pk(04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\", \"pk(5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"pk(04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\", SIGNABLE, {{\"4104a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235ac\"}}, nullopt);\n+    Check(\"combo(5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"combo(04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\", \"combo(5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"combo(04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\",SIGNABLE, {{\"4104a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235ac\",\"76a914b5bd079c4d57cc7fc28ecf8213a6b791625b818388ac\"}}, std::nullopt);\n+    Check(\"pk(5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"pk(04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\", \"pk(5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"pk(04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\", SIGNABLE, {{\"4104a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235ac\"}}, std::nullopt);\n     Check(\"pkh(5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"pkh(04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\", \"pkh(5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"pkh(04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\", SIGNABLE, {{\"76a914b5bd079c4d57cc7fc28ecf8213a6b791625b818388ac\"}}, OutputType::LEGACY);\n     CheckUnparsable(\"wpkh(5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"wpkh(04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\", \"Uncompressed keys are not allowed\"); // No uncompressed keys in witness\n     CheckUnparsable(\"wsh(pk(5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss))\", \"wsh(pk(04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235))\", \"Uncompressed keys are not allowed\"); // No uncompressed keys in witness\n@@ -321,23 +322,23 @@ BOOST_AUTO_TEST_CASE(descriptor_test)\n     Check(\"sh(wsh(pkh(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)))\", \"sh(wsh(pkh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)))\", \"sh(wsh(pkh(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)))\", \"sh(wsh(pkh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)))\", SIGNABLE, {{\"a914b61b92e2ca21bac1e72a3ab859a742982bea960a87\"}}, OutputType::P2SH_SEGWIT);\n \n     // Versions with BIP32 derivations\n-    Check(\"combo([01234567]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc)\", \"combo([01234567]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL)\", \"combo([01234567]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc)\", \"combo([01234567]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL)\", SIGNABLE, {{\"2102d2b36900396c9282fa14628566582f206a5dd0bcc8d5e892611806cafb0301f0ac\",\"76a91431a507b815593dfc51ffc7245ae7e5aee304246e88ac\",\"001431a507b815593dfc51ffc7245ae7e5aee304246e\",\"a9142aafb926eb247cb18240a7f4c07983ad1f37922687\"}}, nullopt);\n-    Check(\"pk(xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0)\", \"pk(xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0)\", \"pk(xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0)\", \"pk(xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0)\", DEFAULT, {{\"210379e45b3cf75f9c5f9befd8e9506fb962f6a9d185ac87001ec44a8d3df8d4a9e3ac\"}}, nullopt, {{0}});\n+    Check(\"combo([01234567]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc)\", \"combo([01234567]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL)\", \"combo([01234567]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc)\", \"combo([01234567]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL)\", SIGNABLE, {{\"2102d2b36900396c9282fa14628566582f206a5dd0bcc8d5e892611806cafb0301f0ac\",\"76a91431a507b815593dfc51ffc7245ae7e5aee304246e88ac\",\"001431a507b815593dfc51ffc7245ae7e5aee304246e\",\"a9142aafb926eb247cb18240a7f4c07983ad1f37922687\"}}, std::nullopt);\n+    Check(\"pk(xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0)\", \"pk(xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0)\", \"pk(xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0)\", \"pk(xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0)\", DEFAULT, {{\"210379e45b3cf75f9c5f9befd8e9506fb962f6a9d185ac87001ec44a8d3df8d4a9e3ac\"}}, std::nullopt, {{0}});\n     Check(\"pkh(xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/2147483647'/0)\", \"pkh(xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/2147483647'/0)\", \"pkh([bd16bee5/2147483647']xprv9vHkqa6XAPwKqSKSEJMcAB3yoCZhaSVsGZbSkFY5L3Lfjjk8sjZucbsbvEw5o3QrSA69nPfZDCgFnNnLhQ2ohpZuwummndnPasDw2Qr6dC2/0)\", \"pkh([bd16bee5/2147483647']xpub69H7F5dQzmVd3vPuLKtcXJziMEQByuDidnX3YdwgtNsecY5HRGtAAQC5mXTt4dsv9RzyjgDjAQs9VGVV6ydYCHnprc9vvaA5YtqWyL6hyds/0)\", HARDENED, {{\"76a914ebdc90806a9c4356c1c88e42216611e1cb4c1c1788ac\"}}, OutputType::LEGACY, {{0xFFFFFFFFUL,0}});\n     Check(\"wpkh([ffffffff/13']xprv9vHkqa6EV4sPZHYqZznhT2NPtPCjKuDKGY38FBWLvgaDx45zo9WQRUT3dKYnjwih2yJD9mkrocEZXo1ex8G81dwSM1fwqWpWkeS3v86pgKt/1/2/*)\", \"wpkh([ffffffff/13']xpub69H7F5d8KSRgmmdJg2KhpAK8SR3DjMwAdkxj3ZuxV27CprR9LgpeyGmXUbC6wb7ERfvrnKZjXoUmmDznezpbZb7ap6r1D3tgFxHmwMkQTPH/1/2/*)\", \"wpkh([ffffffff/13']xprv9vHkqa6EV4sPZHYqZznhT2NPtPCjKuDKGY38FBWLvgaDx45zo9WQRUT3dKYnjwih2yJD9mkrocEZXo1ex8G81dwSM1fwqWpWkeS3v86pgKt/1/2/*)\", \"wpkh([ffffffff/13']xpub69H7F5d8KSRgmmdJg2KhpAK8SR3DjMwAdkxj3ZuxV27CprR9LgpeyGmXUbC6wb7ERfvrnKZjXoUmmDznezpbZb7ap6r1D3tgFxHmwMkQTPH/1/2/*)\", RANGE, {{\"0014326b2249e3a25d5dc60935f044ee835d090ba859\"},{\"0014af0bd98abc2f2cae66e36896a39ffe2d32984fb7\"},{\"00141fa798efd1cbf95cebf912c031b8a4a6e9fb9f27\"}}, OutputType::BECH32, {{0x8000000DUL, 1, 2, 0}, {0x8000000DUL, 1, 2, 1}, {0x8000000DUL, 1, 2, 2}});\n     Check(\"sh(wpkh(xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi/10/20/30/40/*'))\", \"sh(wpkh(xpub661MyMwAqRbcFtXgS5sYJABqqG9YLmC4Q1Rdap9gSE8NqtwybGhePY2gZ29ESFjqJoCu1Rupje8YtGqsefD265TMg7usUDFdp6W1EGMcet8/10/20/30/40/*'))\", \"sh(wpkh(xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi/10/20/30/40/*'))\", \"sh(wpkh(xpub661MyMwAqRbcFtXgS5sYJABqqG9YLmC4Q1Rdap9gSE8NqtwybGhePY2gZ29ESFjqJoCu1Rupje8YtGqsefD265TMg7usUDFdp6W1EGMcet8/10/20/30/40/*'))\", RANGE | HARDENED | DERIVE_HARDENED, {{\"a9149a4d9901d6af519b2a23d4a2f51650fcba87ce7b87\"},{\"a914bed59fc0024fae941d6e20a3b44a109ae740129287\"},{\"a9148483aa1116eb9c05c482a72bada4b1db24af654387\"}}, OutputType::P2SH_SEGWIT, {{10, 20, 30, 40, 0x80000000UL}, {10, 20, 30, 40, 0x80000001UL}, {10, 20, 30, 40, 0x80000002UL}});\n-    Check(\"combo(xprvA2JDeKCSNNZky6uBCviVfJSKyQ1mDYahRjijr5idH2WwLsEd4Hsb2Tyh8RfQMuPh7f7RtyzTtdrbdqqsunu5Mm3wDvUAKRHSC34sJ7in334/*)\", \"combo(xpub6FHa3pjLCk84BayeJxFW2SP4XRrFd1JYnxeLeU8EqN3vDfZmbqBqaGJAyiLjTAwm6ZLRQUMv1ZACTj37sR62cfN7fe5JnJ7dh8zL4fiyLHV/*)\", \"combo(xprvA2JDeKCSNNZky6uBCviVfJSKyQ1mDYahRjijr5idH2WwLsEd4Hsb2Tyh8RfQMuPh7f7RtyzTtdrbdqqsunu5Mm3wDvUAKRHSC34sJ7in334/*)\", \"combo(xpub6FHa3pjLCk84BayeJxFW2SP4XRrFd1JYnxeLeU8EqN3vDfZmbqBqaGJAyiLjTAwm6ZLRQUMv1ZACTj37sR62cfN7fe5JnJ7dh8zL4fiyLHV/*)\", RANGE, {{\"2102df12b7035bdac8e3bab862a3a83d06ea6b17b6753d52edecba9be46f5d09e076ac\",\"76a914f90e3178ca25f2c808dc76624032d352fdbdfaf288ac\",\"0014f90e3178ca25f2c808dc76624032d352fdbdfaf2\",\"a91408f3ea8c68d4a7585bf9e8bda226723f70e445f087\"},{\"21032869a233c9adff9a994e4966e5b821fd5bac066da6c3112488dc52383b4a98ecac\",\"76a914a8409d1b6dfb1ed2a3e8aa5e0ef2ff26b15b75b788ac\",\"0014a8409d1b6dfb1ed2a3e8aa5e0ef2ff26b15b75b7\",\"a91473e39884cb71ae4e5ac9739e9225026c99763e6687\"}}, nullopt, {{0}, {1}});\n+    Check(\"combo(xprvA2JDeKCSNNZky6uBCviVfJSKyQ1mDYahRjijr5idH2WwLsEd4Hsb2Tyh8RfQMuPh7f7RtyzTtdrbdqqsunu5Mm3wDvUAKRHSC34sJ7in334/*)\", \"combo(xpub6FHa3pjLCk84BayeJxFW2SP4XRrFd1JYnxeLeU8EqN3vDfZmbqBqaGJAyiLjTAwm6ZLRQUMv1ZACTj37sR62cfN7fe5JnJ7dh8zL4fiyLHV/*)\", \"combo(xprvA2JDeKCSNNZky6uBCviVfJSKyQ1mDYahRjijr5idH2WwLsEd4Hsb2Tyh8RfQMuPh7f7RtyzTtdrbdqqsunu5Mm3wDvUAKRHSC34sJ7in334/*)\", \"combo(xpub6FHa3pjLCk84BayeJxFW2SP4XRrFd1JYnxeLeU8EqN3vDfZmbqBqaGJAyiLjTAwm6ZLRQUMv1ZACTj37sR62cfN7fe5JnJ7dh8zL4fiyLHV/*)\", RANGE, {{\"2102df12b7035bdac8e3bab862a3a83d06ea6b17b6753d52edecba9be46f5d09e076ac\",\"76a914f90e3178ca25f2c808dc76624032d352fdbdfaf288ac\",\"0014f90e3178ca25f2c808dc76624032d352fdbdfaf2\",\"a91408f3ea8c68d4a7585bf9e8bda226723f70e445f087\"},{\"21032869a233c9adff9a994e4966e5b821fd5bac066da6c3112488dc52383b4a98ecac\",\"76a914a8409d1b6dfb1ed2a3e8aa5e0ef2ff26b15b75b788ac\",\"0014a8409d1b6dfb1ed2a3e8aa5e0ef2ff26b15b75b7\",\"a91473e39884cb71ae4e5ac9739e9225026c99763e6687\"}}, std::nullopt, {{0}, {1}});\n     CheckUnparsable(\"combo([012345678]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc)\", \"combo([012345678]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL)\", \"Fingerprint is not 4 bytes (9 characters instead of 8 characters)\"); // Too long key fingerprint\n     CheckUnparsable(\"pkh(xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/2147483648)\", \"pkh(xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/2147483648)\", \"Key path value 2147483648 is out of range\"); // BIP 32 path element overflow\n     CheckUnparsable(\"pkh(xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/1aa)\", \"pkh(xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/1aa)\", \"Key path value '1aa' is not a valid uint32\"); // Path is not valid uint\n     Check(\"pkh([01234567/10/20]xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/2147483647'/0)\", \"pkh([01234567/10/20]xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/2147483647'/0)\", \"pkh([01234567/10/20/2147483647']xprv9vHkqa6XAPwKqSKSEJMcAB3yoCZhaSVsGZbSkFY5L3Lfjjk8sjZucbsbvEw5o3QrSA69nPfZDCgFnNnLhQ2ohpZuwummndnPasDw2Qr6dC2/0)\", \"pkh([01234567/10/20/2147483647']xpub69H7F5dQzmVd3vPuLKtcXJziMEQByuDidnX3YdwgtNsecY5HRGtAAQC5mXTt4dsv9RzyjgDjAQs9VGVV6ydYCHnprc9vvaA5YtqWyL6hyds/0)\", HARDENED, {{\"76a914ebdc90806a9c4356c1c88e42216611e1cb4c1c1788ac\"}}, OutputType::LEGACY, {{10, 20, 0xFFFFFFFFUL, 0}});\n \n     // Multisig constructions\n-    Check(\"multi(1,L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1,5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"multi(1,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd,04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\", \"multi(1,L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1,5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"multi(1,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd,04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\", SIGNABLE, {{\"512103a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd4104a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea23552ae\"}}, nullopt);\n-    Check(\"sortedmulti(1,L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1,5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"sortedmulti(1,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd,04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\", \"sortedmulti(1,L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1,5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"sortedmulti(1,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd,04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\", SIGNABLE, {{\"512103a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd4104a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea23552ae\"}}, nullopt);\n-    Check(\"sortedmulti(1,5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss,L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)\", \"sortedmulti(1,04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)\", \"sortedmulti(1,5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss,L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)\", \"sortedmulti(1,04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)\", SIGNABLE, {{\"512103a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd4104a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea23552ae\"}}, nullopt);\n+    Check(\"multi(1,L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1,5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"multi(1,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd,04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\", \"multi(1,L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1,5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"multi(1,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd,04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\", SIGNABLE, {{\"512103a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd4104a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea23552ae\"}}, std::nullopt);\n+    Check(\"sortedmulti(1,L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1,5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"sortedmulti(1,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd,04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\", \"sortedmulti(1,L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1,5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"sortedmulti(1,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd,04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\", SIGNABLE, {{\"512103a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd4104a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea23552ae\"}}, std::nullopt);\n+    Check(\"sortedmulti(1,5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss,L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)\", \"sortedmulti(1,04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)\", \"sortedmulti(1,5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss,L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)\", \"sortedmulti(1,04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)\", SIGNABLE, {{\"512103a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd4104a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea23552ae\"}}, std::nullopt);\n     Check(\"sh(multi(2,[00000000/111'/222]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0))\", \"sh(multi(2,[00000000/111'/222]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0))\", \"sh(multi(2,[00000000/111'/222]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0))\", \"sh(multi(2,[00000000/111'/222]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0))\", DEFAULT, {{\"a91445a9a622a8b0a1269944be477640eedc447bbd8487\"}}, OutputType::LEGACY, {{0x8000006FUL,222},{0}});\n-    Check(\"sortedmulti(2,xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc/*,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0/0/*)\", \"sortedmulti(2,xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/*,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0/0/*)\", \"sortedmulti(2,xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc/*,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0/0/*)\", \"sortedmulti(2,xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/*,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0/0/*)\", RANGE, {{\"5221025d5fc65ebb8d44a5274b53bac21ff8307fec2334a32df05553459f8b1f7fe1b62102fbd47cc8034098f0e6a94c6aeee8528abf0a2153a5d8e46d325b7284c046784652ae\"}, {\"52210264fd4d1f5dea8ded94c61e9641309349b62f27fbffe807291f664e286bfbe6472103f4ece6dfccfa37b211eb3d0af4d0c61dba9ef698622dc17eecdf764beeb005a652ae\"}, {\"5221022ccabda84c30bad578b13c89eb3b9544ce149787e5b538175b1d1ba259cbb83321024d902e1a2fc7a8755ab5b694c575fce742c48d9ff192e63df5193e4c7afe1f9c52ae\"}}, nullopt, {{0}, {1}, {2}, {0, 0, 0}, {0, 0, 1}, {0, 0, 2}});\n+    Check(\"sortedmulti(2,xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc/*,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0/0/*)\", \"sortedmulti(2,xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/*,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0/0/*)\", \"sortedmulti(2,xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc/*,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0/0/*)\", \"sortedmulti(2,xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/*,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0/0/*)\", RANGE, {{\"5221025d5fc65ebb8d44a5274b53bac21ff8307fec2334a32df05553459f8b1f7fe1b62102fbd47cc8034098f0e6a94c6aeee8528abf0a2153a5d8e46d325b7284c046784652ae\"}, {\"52210264fd4d1f5dea8ded94c61e9641309349b62f27fbffe807291f664e286bfbe6472103f4ece6dfccfa37b211eb3d0af4d0c61dba9ef698622dc17eecdf764beeb005a652ae\"}, {\"5221022ccabda84c30bad578b13c89eb3b9544ce149787e5b538175b1d1ba259cbb83321024d902e1a2fc7a8755ab5b694c575fce742c48d9ff192e63df5193e4c7afe1f9c52ae\"}}, std::nullopt, {{0}, {1}, {2}, {0, 0, 0}, {0, 0, 1}, {0, 0, 2}});\n     Check(\"wsh(multi(2,xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/2147483647'/0,xprv9vHkqa6EV4sPZHYqZznhT2NPtPCjKuDKGY38FBWLvgaDx45zo9WQRUT3dKYnjwih2yJD9mkrocEZXo1ex8G81dwSM1fwqWpWkeS3v86pgKt/1/2/*,xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi/10/20/30/40/*'))\", \"wsh(multi(2,xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/2147483647'/0,xpub69H7F5d8KSRgmmdJg2KhpAK8SR3DjMwAdkxj3ZuxV27CprR9LgpeyGmXUbC6wb7ERfvrnKZjXoUmmDznezpbZb7ap6r1D3tgFxHmwMkQTPH/1/2/*,xpub661MyMwAqRbcFtXgS5sYJABqqG9YLmC4Q1Rdap9gSE8NqtwybGhePY2gZ29ESFjqJoCu1Rupje8YtGqsefD265TMg7usUDFdp6W1EGMcet8/10/20/30/40/*'))\", \"wsh(multi(2,[bd16bee5/2147483647']xprv9vHkqa6XAPwKqSKSEJMcAB3yoCZhaSVsGZbSkFY5L3Lfjjk8sjZucbsbvEw5o3QrSA69nPfZDCgFnNnLhQ2ohpZuwummndnPasDw2Qr6dC2/0,xprv9vHkqa6EV4sPZHYqZznhT2NPtPCjKuDKGY38FBWLvgaDx45zo9WQRUT3dKYnjwih2yJD9mkrocEZXo1ex8G81dwSM1fwqWpWkeS3v86pgKt/1/2/*,xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi/10/20/30/40/*'))\", \"wsh(multi(2,[bd16bee5/2147483647']xpub69H7F5dQzmVd3vPuLKtcXJziMEQByuDidnX3YdwgtNsecY5HRGtAAQC5mXTt4dsv9RzyjgDjAQs9VGVV6ydYCHnprc9vvaA5YtqWyL6hyds/0,xpub69H7F5d8KSRgmmdJg2KhpAK8SR3DjMwAdkxj3ZuxV27CprR9LgpeyGmXUbC6wb7ERfvrnKZjXoUmmDznezpbZb7ap6r1D3tgFxHmwMkQTPH/1/2/*,xpub661MyMwAqRbcFtXgS5sYJABqqG9YLmC4Q1Rdap9gSE8NqtwybGhePY2gZ29ESFjqJoCu1Rupje8YtGqsefD265TMg7usUDFdp6W1EGMcet8/10/20/30/40/*'))\", HARDENED | RANGE | DERIVE_HARDENED, {{\"0020b92623201f3bb7c3771d45b2ad1d0351ea8fbf8cfe0a0e570264e1075fa1948f\"},{\"002036a08bbe4923af41cf4316817c93b8d37e2f635dd25cfff06bd50df6ae7ea203\"},{\"0020a96e7ab4607ca6b261bfe3245ffda9c746b28d3f59e83d34820ec0e2b36c139c\"}}, OutputType::BECH32, {{0xFFFFFFFFUL,0}, {1,2,0}, {1,2,1}, {1,2,2}, {10, 20, 30, 40, 0x80000000UL}, {10, 20, 30, 40, 0x80000001UL}, {10, 20, 30, 40, 0x80000002UL}});\n     Check(\"sh(wsh(multi(16,KzoAz5CanayRKex3fSLQ2BwJpN7U52gZvxMyk78nDMHuqrUxuSJy,KwGNz6YCCQtYvFzMtrC6D3tKTKdBBboMrLTsjr2NYVBwapCkn7Mr,KxogYhiNfwxuswvXV66eFyKcCpm7dZ7TqHVqujHAVUjJxyivxQ9X,L2BUNduTSyZwZjwNHynQTF14mv2uz2NRq5n5sYWTb4FkkmqgEE9f,L1okJGHGn1kFjdXHKxXjwVVtmCMR2JA5QsbKCSpSb7ReQjezKeoD,KxDCNSST75HFPaW5QKpzHtAyaCQC7p9Vo3FYfi2u4dXD1vgMiboK,L5edQjFtnkcf5UWURn6UuuoFrabgDQUHdheKCziwN42aLwS3KizU,KzF8UWFcEC7BYTq8Go1xVimMkDmyNYVmXV5PV7RuDicvAocoPB8i,L3nHUboKG2w4VSJ5jYZ5CBM97oeK6YuKvfZxrefdShECcjEYKMWZ,KyjHo36dWkYhimKmVVmQTq3gERv3pnqA4xFCpvUgbGDJad7eS8WE,KwsfyHKRUTZPQtysN7M3tZ4GXTnuov5XRgjdF2XCG8faAPmFruRF,KzCUbGhN9LJhdeFfL9zQgTJMjqxdBKEekRGZX24hXdgCNCijkkap,KzgpMBwwsDLwkaC5UrmBgCYaBD2WgZ7PBoGYXR8KT7gCA9UTN5a3,KyBXTPy4T7YG4q9tcAM3LkvfRpD1ybHMvcJ2ehaWXaSqeGUxEdkP,KzJDe9iwJRPtKP2F2AoN6zBgzS7uiuAwhWCfGdNeYJ3PC1HNJ8M8,L1xbHrxynrqLKkoYc4qtoQPx6uy5qYXR5ZDYVYBSRmCV5piU3JG9)))\",\"sh(wsh(multi(16,03669b8afcec803a0d323e9a17f3ea8e68e8abe5a278020a929adbec52421adbd0,0260b2003c386519fc9eadf2b5cf124dd8eea4c4e68d5e154050a9346ea98ce600,0362a74e399c39ed5593852a30147f2959b56bb827dfa3e60e464b02ccf87dc5e8,0261345b53de74a4d721ef877c255429961b7e43714171ac06168d7e08c542a8b8,02da72e8b46901a65d4374fe6315538d8f368557dda3a1dcf9ea903f3afe7314c8,0318c82dd0b53fd3a932d16e0ba9e278fcc937c582d5781be626ff16e201f72286,0297ccef1ef99f9d73dec9ad37476ddb232f1238aff877af19e72ba04493361009,02e502cfd5c3f972fe9a3e2a18827820638f96b6f347e54d63deb839011fd5765d,03e687710f0e3ebe81c1037074da939d409c0025f17eb86adb9427d28f0f7ae0e9,02c04d3a5274952acdbc76987f3184b346a483d43be40874624b29e3692c1df5af,02ed06e0f418b5b43a7ec01d1d7d27290fa15f75771cb69b642a51471c29c84acd,036d46073cbb9ffee90473f3da429abc8de7f8751199da44485682a989a4bebb24,02f5d1ff7c9029a80a4e36b9a5497027ef7f3e73384a4a94fbfe7c4e9164eec8bc,02e41deffd1b7cce11cde209a781adcffdabd1b91c0ba0375857a2bfd9302419f3,02d76625f7956a7fc505ab02556c23ee72d832f1bac391bcd2d3abce5710a13d06,0399eb0a5487515802dc14544cf10b3666623762fbed2ec38a3975716e2c29c232)))\", \"sh(wsh(multi(16,KzoAz5CanayRKex3fSLQ2BwJpN7U52gZvxMyk78nDMHuqrUxuSJy,KwGNz6YCCQtYvFzMtrC6D3tKTKdBBboMrLTsjr2NYVBwapCkn7Mr,KxogYhiNfwxuswvXV66eFyKcCpm7dZ7TqHVqujHAVUjJxyivxQ9X,L2BUNduTSyZwZjwNHynQTF14mv2uz2NRq5n5sYWTb4FkkmqgEE9f,L1okJGHGn1kFjdXHKxXjwVVtmCMR2JA5QsbKCSpSb7ReQjezKeoD,KxDCNSST75HFPaW5QKpzHtAyaCQC7p9Vo3FYfi2u4dXD1vgMiboK,L5edQjFtnkcf5UWURn6UuuoFrabgDQUHdheKCziwN42aLwS3KizU,KzF8UWFcEC7BYTq8Go1xVimMkDmyNYVmXV5PV7RuDicvAocoPB8i,L3nHUboKG2w4VSJ5jYZ5CBM97oeK6YuKvfZxrefdShECcjEYKMWZ,KyjHo36dWkYhimKmVVmQTq3gERv3pnqA4xFCpvUgbGDJad7eS8WE,KwsfyHKRUTZPQtysN7M3tZ4GXTnuov5XRgjdF2XCG8faAPmFruRF,KzCUbGhN9LJhdeFfL9zQgTJMjqxdBKEekRGZX24hXdgCNCijkkap,KzgpMBwwsDLwkaC5UrmBgCYaBD2WgZ7PBoGYXR8KT7gCA9UTN5a3,KyBXTPy4T7YG4q9tcAM3LkvfRpD1ybHMvcJ2ehaWXaSqeGUxEdkP,KzJDe9iwJRPtKP2F2AoN6zBgzS7uiuAwhWCfGdNeYJ3PC1HNJ8M8,L1xbHrxynrqLKkoYc4qtoQPx6uy5qYXR5ZDYVYBSRmCV5piU3JG9)))\",\"sh(wsh(multi(16,03669b8afcec803a0d323e9a17f3ea8e68e8abe5a278020a929adbec52421adbd0,0260b2003c386519fc9eadf2b5cf124dd8eea4c4e68d5e154050a9346ea98ce600,0362a74e399c39ed5593852a30147f2959b56bb827dfa3e60e464b02ccf87dc5e8,0261345b53de74a4d721ef877c255429961b7e43714171ac06168d7e08c542a8b8,02da72e8b46901a65d4374fe6315538d8f368557dda3a1dcf9ea903f3afe7314c8,0318c82dd0b53fd3a932d16e0ba9e278fcc937c582d5781be626ff16e201f72286,0297ccef1ef99f9d73dec9ad37476ddb232f1238aff877af19e72ba04493361009,02e502cfd5c3f972fe9a3e2a18827820638f96b6f347e54d63deb839011fd5765d,03e687710f0e3ebe81c1037074da939d409c0025f17eb86adb9427d28f0f7ae0e9,02c04d3a5274952acdbc76987f3184b346a483d43be40874624b29e3692c1df5af,02ed06e0f418b5b43a7ec01d1d7d27290fa15f75771cb69b642a51471c29c84acd,036d46073cbb9ffee90473f3da429abc8de7f8751199da44485682a989a4bebb24,02f5d1ff7c9029a80a4e36b9a5497027ef7f3e73384a4a94fbfe7c4e9164eec8bc,02e41deffd1b7cce11cde209a781adcffdabd1b91c0ba0375857a2bfd9302419f3,02d76625f7956a7fc505ab02556c23ee72d832f1bac391bcd2d3abce5710a13d06,0399eb0a5487515802dc14544cf10b3666623762fbed2ec38a3975716e2c29c232)))\", SIGNABLE, {{\"a9147fc63e13dc25e8a95a3cee3d9a714ac3afd96f1e87\"}}, OutputType::P2SH_SEGWIT);\n     CheckUnparsable(\"sh(multi(16,KzoAz5CanayRKex3fSLQ2BwJpN7U52gZvxMyk78nDMHuqrUxuSJy,KwGNz6YCCQtYvFzMtrC6D3tKTKdBBboMrLTsjr2NYVBwapCkn7Mr,KxogYhiNfwxuswvXV66eFyKcCpm7dZ7TqHVqujHAVUjJxyivxQ9X,L2BUNduTSyZwZjwNHynQTF14mv2uz2NRq5n5sYWTb4FkkmqgEE9f,L1okJGHGn1kFjdXHKxXjwVVtmCMR2JA5QsbKCSpSb7ReQjezKeoD,KxDCNSST75HFPaW5QKpzHtAyaCQC7p9Vo3FYfi2u4dXD1vgMiboK,L5edQjFtnkcf5UWURn6UuuoFrabgDQUHdheKCziwN42aLwS3KizU,KzF8UWFcEC7BYTq8Go1xVimMkDmyNYVmXV5PV7RuDicvAocoPB8i,L3nHUboKG2w4VSJ5jYZ5CBM97oeK6YuKvfZxrefdShECcjEYKMWZ,KyjHo36dWkYhimKmVVmQTq3gERv3pnqA4xFCpvUgbGDJad7eS8WE,KwsfyHKRUTZPQtysN7M3tZ4GXTnuov5XRgjdF2XCG8faAPmFruRF,KzCUbGhN9LJhdeFfL9zQgTJMjqxdBKEekRGZX24hXdgCNCijkkap,KzgpMBwwsDLwkaC5UrmBgCYaBD2WgZ7PBoGYXR8KT7gCA9UTN5a3,KyBXTPy4T7YG4q9tcAM3LkvfRpD1ybHMvcJ2ehaWXaSqeGUxEdkP,KzJDe9iwJRPtKP2F2AoN6zBgzS7uiuAwhWCfGdNeYJ3PC1HNJ8M8,L1xbHrxynrqLKkoYc4qtoQPx6uy5qYXR5ZDYVYBSRmCV5piU3JG9))\",\"sh(multi(16,03669b8afcec803a0d323e9a17f3ea8e68e8abe5a278020a929adbec52421adbd0,0260b2003c386519fc9eadf2b5cf124dd8eea4c4e68d5e154050a9346ea98ce600,0362a74e399c39ed5593852a30147f2959b56bb827dfa3e60e464b02ccf87dc5e8,0261345b53de74a4d721ef877c255429961b7e43714171ac06168d7e08c542a8b8,02da72e8b46901a65d4374fe6315538d8f368557dda3a1dcf9ea903f3afe7314c8,0318c82dd0b53fd3a932d16e0ba9e278fcc937c582d5781be626ff16e201f72286,0297ccef1ef99f9d73dec9ad37476ddb232f1238aff877af19e72ba04493361009,02e502cfd5c3f972fe9a3e2a18827820638f96b6f347e54d63deb839011fd5765d,03e687710f0e3ebe81c1037074da939d409c0025f17eb86adb9427d28f0f7ae0e9,02c04d3a5274952acdbc76987f3184b346a483d43be40874624b29e3692c1df5af,02ed06e0f418b5b43a7ec01d1d7d27290fa15f75771cb69b642a51471c29c84acd,036d46073cbb9ffee90473f3da429abc8de7f8751199da44485682a989a4bebb24,02f5d1ff7c9029a80a4e36b9a5497027ef7f3e73384a4a94fbfe7c4e9164eec8bc,02e41deffd1b7cce11cde209a781adcffdabd1b91c0ba0375857a2bfd9302419f3,02d76625f7956a7fc505ab02556c23ee72d832f1bac391bcd2d3abce5710a13d06,0399eb0a5487515802dc14544cf10b3666623762fbed2ec38a3975716e2c29c232))\", \"P2SH script is too large, 547 bytes is larger than 520 bytes\"); // P2SH does not fit 16 compressed pubkeys in a redeemscript"
      },
      {
        "sha": "6cbfc39bc20b99997941b56bf7bd578ee609e0b6",
        "filename": "src/test/fuzz/FuzzedDataProvider.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/FuzzedDataProvider.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/FuzzedDataProvider.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/FuzzedDataProvider.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -20,6 +20,7 @@\n #include <cstdint>\n #include <cstring>\n #include <initializer_list>\n+#include <limits>\n #include <string>\n #include <type_traits>\n #include <utility>"
      },
      {
        "sha": "0baf30aef6f4a8a9061681c566865211bb2ac91c",
        "filename": "src/test/fuzz/addrman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/addrman.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -104,7 +104,7 @@ FUZZ_TARGET_INIT(addrman, initialize_addrman)\n             [&] {\n                 const std::optional<CService> opt_service = ConsumeDeserializable<CService>(fuzzed_data_provider);\n                 if (opt_service) {\n-                    addr_man.SetServices(*opt_service, ServiceFlags{fuzzed_data_provider.ConsumeIntegral<uint64_t>()});\n+                    addr_man.SetServices(*opt_service, ConsumeWeakEnum(fuzzed_data_provider, ALL_SERVICE_FLAGS));\n                 }\n             },\n             [&] {"
      },
      {
        "sha": "8ca4de3919bb003a3e2075eea7b401b2dbad53fd",
        "filename": "src/test/fuzz/asmap_direct.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/asmap_direct.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/asmap_direct.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/asmap_direct.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -2,8 +2,9 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <test/fuzz/fuzz.h>\n+#include <netaddress.h>\n #include <util/asmap.h>\n+#include <test/fuzz/fuzz.h>\n \n #include <cstdint>\n #include <optional>"
      },
      {
        "sha": "479342e4be85d6f6f9157ff50cee2b75b4e1496d",
        "filename": "src/test/fuzz/autofile.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/autofile.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/autofile.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/autofile.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -2,7 +2,6 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <optional.h>\n #include <streams.h>\n #include <test/fuzz/FuzzedDataProvider.h>\n #include <test/fuzz/fuzz.h>"
      },
      {
        "sha": "ad3bf73af4328c7454cb8666e3f0e65abe8d41a7",
        "filename": "src/test/fuzz/bech32.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/bech32.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/bech32.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/bech32.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -16,28 +16,28 @@\n FUZZ_TARGET(bech32)\n {\n     const std::string random_string(buffer.begin(), buffer.end());\n-    const std::pair<std::string, std::vector<uint8_t>> r1 = bech32::Decode(random_string);\n-    if (r1.first.empty()) {\n-        assert(r1.second.empty());\n+    const auto r1 = bech32::Decode(random_string);\n+    if (r1.hrp.empty()) {\n+        assert(r1.encoding == bech32::Encoding::INVALID);\n+        assert(r1.data.empty());\n     } else {\n-        const std::string& hrp = r1.first;\n-        const std::vector<uint8_t>& data = r1.second;\n-        const std::string reencoded = bech32::Encode(hrp, data);\n+        assert(r1.encoding != bech32::Encoding::INVALID);\n+        const std::string reencoded = bech32::Encode(r1.encoding, r1.hrp, r1.data);\n         assert(CaseInsensitiveEqual(random_string, reencoded));\n     }\n \n     std::vector<unsigned char> input;\n     ConvertBits<8, 5, true>([&](unsigned char c) { input.push_back(c); }, buffer.begin(), buffer.end());\n-    const std::string encoded = bech32::Encode(\"bc\", input);\n-    assert(!encoded.empty());\n \n-    const std::pair<std::string, std::vector<uint8_t>> r2 = bech32::Decode(encoded);\n-    if (r2.first.empty()) {\n-        assert(r2.second.empty());\n-    } else {\n-        const std::string& hrp = r2.first;\n-        const std::vector<uint8_t>& data = r2.second;\n-        assert(hrp == \"bc\");\n-        assert(data == input);\n+    if (input.size() + 3 + 6 <= 90) {\n+        // If it's possible to encode input in Bech32(m) without exceeding the 90-character limit:\n+        for (auto encoding : {bech32::Encoding::BECH32, bech32::Encoding::BECH32M}) {\n+            const std::string encoded = bech32::Encode(encoding, \"bc\", input);\n+            assert(!encoded.empty());\n+            const auto r2 = bech32::Decode(encoded);\n+            assert(r2.encoding == encoding);\n+            assert(r2.hrp == \"bc\");\n+            assert(r2.data == input);\n+        }\n     }\n }"
      },
      {
        "sha": "ed72260d109a205ce966122eb9f7ded65301f7f7",
        "filename": "src/test/fuzz/buffered_file.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/buffered_file.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/buffered_file.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/buffered_file.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -2,7 +2,6 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <optional.h>\n #include <streams.h>\n #include <test/fuzz/FuzzedDataProvider.h>\n #include <test/fuzz/fuzz.h>"
      },
      {
        "sha": "d951bda20f2e5a8149061d6641d46a5e711e3314",
        "filename": "src/test/fuzz/coins_view.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/coins_view.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/coins_view.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/coins_view.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -264,7 +264,7 @@ FUZZ_TARGET_INIT(coins_view, initialize_coins_view)\n                 CCoinsStats stats;\n                 bool expected_code_path = false;\n                 try {\n-                    (void)GetUTXOStats(&coins_view_cache, stats, CoinStatsHashType::HASH_SERIALIZED);\n+                    (void)GetUTXOStats(&coins_view_cache, WITH_LOCK(::cs_main, return std::ref(g_chainman.m_blockman)), stats, CoinStatsHashType::HASH_SERIALIZED);\n                 } catch (const std::logic_error&) {\n                     expected_code_path = true;\n                 }"
      },
      {
        "sha": "a522c837ef14ac8c439adb48f39e533a98f0c731",
        "filename": "src/test/fuzz/cuckoocache.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/cuckoocache.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/cuckoocache.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/cuckoocache.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -30,7 +30,7 @@ FUZZ_TARGET(cuckoocache)\n {\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n     fuzzed_data_provider_ptr = &fuzzed_data_provider;\n-    CuckooCache::cache<bool, RandomHasher> cuckoo_cache{};\n+    CuckooCache::cache<int, RandomHasher> cuckoo_cache{};\n     if (fuzzed_data_provider.ConsumeBool()) {\n         const size_t megabytes = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 16);\n         cuckoo_cache.setup_bytes(megabytes << 20);"
      },
      {
        "sha": "ffe48556623c080b7aa35b91fc24707082557e64",
        "filename": "src/test/fuzz/descriptor_parse.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/descriptor_parse.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/descriptor_parse.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/descriptor_parse.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -6,7 +6,6 @@\n #include <pubkey.h>\n #include <script/descriptor.h>\n #include <test/fuzz/fuzz.h>\n-#include <util/memory.h>\n \n void initialize_descriptor_parse()\n {"
      },
      {
        "sha": "1290c78712b4405d92f98778226324f8394df54c",
        "filename": "src/test/fuzz/deserialize.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/deserialize.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/deserialize.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/deserialize.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -15,7 +15,6 @@\n #include <net.h>\n #include <netbase.h>\n #include <node/utxo_snapshot.h>\n-#include <optional.h>\n #include <primitives/block.h>\n #include <protocol.h>\n #include <psbt.h>\n@@ -26,6 +25,7 @@\n #include <version.h>\n \n #include <exception>\n+#include <optional>\n #include <stdexcept>\n #include <stdint.h>\n #include <unistd.h>\n@@ -69,7 +69,7 @@ T Deserialize(CDataStream ds)\n }\n \n template <typename T>\n-void DeserializeFromFuzzingInput(FuzzBufferType buffer, T& obj, const Optional<int> protocol_version = nullopt)\n+void DeserializeFromFuzzingInput(FuzzBufferType buffer, T& obj, const std::optional<int> protocol_version = std::nullopt)\n {\n     CDataStream ds(buffer, SER_NETWORK, INIT_PROTO_VERSION);\n     if (protocol_version) {"
      },
      {
        "sha": "77ed7989232e51fefa4833d6a2e33e6f3a5f4317",
        "filename": "src/test/fuzz/eval_script.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/eval_script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/eval_script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/eval_script.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -6,7 +6,6 @@\n #include <script/interpreter.h>\n #include <test/fuzz/FuzzedDataProvider.h>\n #include <test/fuzz/fuzz.h>\n-#include <util/memory.h>\n \n #include <limits>\n "
      },
      {
        "sha": "32077b1fe2c909ae279c25653383426ca64a0deb",
        "filename": "src/test/fuzz/key.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/key.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -17,7 +17,6 @@\n #include <script/standard.h>\n #include <streams.h>\n #include <test/fuzz/fuzz.h>\n-#include <util/memory.h>\n #include <util/strencodings.h>\n \n #include <cassert>"
      },
      {
        "sha": "272f6415a9a386834b4dcd5048efc01242fe48d7",
        "filename": "src/test/fuzz/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/net.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -7,7 +7,6 @@\n #include <net.h>\n #include <net_permissions.h>\n #include <netaddress.h>\n-#include <optional.h>\n #include <protocol.h>\n #include <random.h>\n #include <test/fuzz/FuzzedDataProvider.h>\n@@ -17,6 +16,7 @@\n #include <test/util/setup_common.h>\n \n #include <cstdint>\n+#include <optional>\n #include <string>\n #include <vector>\n "
      },
      {
        "sha": "cf2fa337443c8e584e5ecd21d3d468773f329d8b",
        "filename": "src/test/fuzz/netbase_dns_lookup.cpp",
        "status": "added",
        "additions": 71,
        "deletions": 0,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/netbase_dns_lookup.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/netbase_dns_lookup.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/netbase_dns_lookup.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -0,0 +1,71 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <string>\n+#include <vector>\n+\n+FUZZ_TARGET(netbase_dns_lookup)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const std::string name = fuzzed_data_provider.ConsumeRandomLengthString(512);\n+    const unsigned int max_results = fuzzed_data_provider.ConsumeIntegral<unsigned int>();\n+    const bool allow_lookup = fuzzed_data_provider.ConsumeBool();\n+    const uint16_t default_port = fuzzed_data_provider.ConsumeIntegral<uint16_t>();\n+\n+    auto fuzzed_dns_lookup_function = [&](const std::string&, bool) {\n+        std::vector<CNetAddr> resolved_addresses;\n+        while (fuzzed_data_provider.ConsumeBool()) {\n+            resolved_addresses.push_back(ConsumeNetAddr(fuzzed_data_provider));\n+        }\n+        return resolved_addresses;\n+    };\n+\n+    {\n+        std::vector<CNetAddr> resolved_addresses;\n+        if (LookupHost(name, resolved_addresses, max_results, allow_lookup, fuzzed_dns_lookup_function)) {\n+            for (const CNetAddr& resolved_address : resolved_addresses) {\n+                assert(!resolved_address.IsInternal());\n+            }\n+        }\n+        assert(resolved_addresses.size() <= max_results || max_results == 0);\n+    }\n+    {\n+        CNetAddr resolved_address;\n+        if (LookupHost(name, resolved_address, allow_lookup, fuzzed_dns_lookup_function)) {\n+            assert(!resolved_address.IsInternal());\n+        }\n+    }\n+    {\n+        std::vector<CService> resolved_services;\n+        if (Lookup(name, resolved_services, default_port, allow_lookup, max_results, fuzzed_dns_lookup_function)) {\n+            for (const CNetAddr& resolved_service : resolved_services) {\n+                assert(!resolved_service.IsInternal());\n+            }\n+        }\n+        assert(resolved_services.size() <= max_results || max_results == 0);\n+    }\n+    {\n+        CService resolved_service;\n+        if (Lookup(name, resolved_service, default_port, allow_lookup, fuzzed_dns_lookup_function)) {\n+            assert(!resolved_service.IsInternal());\n+        }\n+    }\n+    {\n+        CService resolved_service = LookupNumeric(name, default_port, fuzzed_dns_lookup_function);\n+        assert(!resolved_service.IsInternal());\n+    }\n+    {\n+        CSubNet resolved_subnet;\n+        if (LookupSubNet(name, resolved_subnet, fuzzed_dns_lookup_function)) {\n+            assert(resolved_subnet.IsValid());\n+        }\n+    }\n+}"
      },
      {
        "sha": "603d520cf5b0de9748ba68edb10f22dac4499557",
        "filename": "src/test/fuzz/node_eviction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/node_eviction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/node_eviction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/node_eviction.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -3,7 +3,6 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <net.h>\n-#include <optional.h>\n #include <protocol.h>\n #include <test/fuzz/FuzzedDataProvider.h>\n #include <test/fuzz/fuzz.h>\n@@ -37,7 +36,7 @@ FUZZ_TARGET(node_eviction)\n     // Make a copy since eviction_candidates may be in some valid but otherwise\n     // indeterminate state after the SelectNodeToEvict(&&) call.\n     const std::vector<NodeEvictionCandidate> eviction_candidates_copy = eviction_candidates;\n-    const Optional<NodeId> node_to_evict = SelectNodeToEvict(std::move(eviction_candidates));\n+    const std::optional<NodeId> node_to_evict = SelectNodeToEvict(std::move(eviction_candidates));\n     if (node_to_evict) {\n         assert(std::any_of(eviction_candidates_copy.begin(), eviction_candidates_copy.end(), [&node_to_evict](const NodeEvictionCandidate& eviction_candidate) { return *node_to_evict == eviction_candidate.id; }));\n     }"
      },
      {
        "sha": "3a1fdaad8fec96be7dc51781c99922c108af7b6e",
        "filename": "src/test/fuzz/p2p_transport_deserializer.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/p2p_transport_deserializer.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/p2p_transport_deserializer.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/p2p_transport_deserializer.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -10,6 +10,7 @@\n #include <cassert>\n #include <cstdint>\n #include <limits>\n+#include <optional>\n #include <vector>\n \n void initialize_p2p_transport_deserializer()\n@@ -30,7 +31,7 @@ FUZZ_TARGET_INIT(p2p_transport_deserializer, initialize_p2p_transport_deserializ\n         if (deserializer.Complete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             uint32_t out_err_raw_size{0};\n-            Optional<CNetMessage> result{deserializer.GetMessage(m_time, out_err_raw_size)};\n+            std::optional<CNetMessage> result{deserializer.GetMessage(m_time, out_err_raw_size)};\n             if (result) {\n                 assert(result->m_command.size() <= CMessageHeader::COMMAND_SIZE);\n                 assert(result->m_raw_message_size <= buffer.size());"
      },
      {
        "sha": "2c546e9b4aae2a85233e763eab0548b64f62dfa4",
        "filename": "src/test/fuzz/parse_numbers.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/parse_numbers.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/parse_numbers.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/parse_numbers.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -18,6 +18,12 @@ FUZZ_TARGET(parse_numbers)\n     double d;\n     (void)ParseDouble(random_string, &d);\n \n+    uint8_t u8;\n+    (void)ParseUInt8(random_string, &u8);\n+\n+    uint16_t u16;\n+    (void)ParseUInt16(random_string, &u16);\n+\n     int32_t i32;\n     (void)ParseInt32(random_string, &i32);\n     (void)atoi(random_string);"
      },
      {
        "sha": "3fffaac8d0341b24c4e7f7d2d3e5474090a8db92",
        "filename": "src/test/fuzz/parse_univalue.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/parse_univalue.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/parse_univalue.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/parse_univalue.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -7,7 +7,6 @@\n #include <rpc/client.h>\n #include <rpc/util.h>\n #include <test/fuzz/fuzz.h>\n-#include <util/memory.h>\n \n #include <limits>\n #include <string>"
      },
      {
        "sha": "47b4323e816401b364533a478591ee73237a6573",
        "filename": "src/test/fuzz/pow.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/pow.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/pow.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/pow.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -34,7 +34,7 @@ FUZZ_TARGET_INIT(pow, initialize_pow)\n         }\n         CBlockIndex current_block{*block_header};\n         {\n-            CBlockIndex* previous_block = !blocks.empty() ? &blocks[fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, blocks.size() - 1)] : nullptr;\n+            CBlockIndex* previous_block = blocks.empty() ? nullptr : &PickValue(fuzzed_data_provider, blocks);\n             const int current_height = (previous_block != nullptr && previous_block->nHeight != std::numeric_limits<int>::max()) ? previous_block->nHeight + 1 : 0;\n             if (fuzzed_data_provider.ConsumeBool()) {\n                 current_block.pprev = previous_block;\n@@ -66,9 +66,9 @@ FUZZ_TARGET_INIT(pow, initialize_pow)\n             }\n         }\n         {\n-            const CBlockIndex* to = &blocks[fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, blocks.size() - 1)];\n-            const CBlockIndex* from = &blocks[fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, blocks.size() - 1)];\n-            const CBlockIndex* tip = &blocks[fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, blocks.size() - 1)];\n+            const CBlockIndex* to = &PickValue(fuzzed_data_provider, blocks);\n+            const CBlockIndex* from = &PickValue(fuzzed_data_provider, blocks);\n+            const CBlockIndex* tip = &PickValue(fuzzed_data_provider, blocks);\n             try {\n                 (void)GetBlockProofEquivalentTime(*to, *from, *tip, consensus_params);\n             } catch (const uint_error&) {"
      },
      {
        "sha": "96e1cfa08fb818f8534c995251539d02f0111242",
        "filename": "src/test/fuzz/process_message.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/process_message.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/process_message.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/process_message.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -19,7 +19,6 @@\n #include <test/util/setup_common.h>\n #include <test/util/validation.h>\n #include <txorphanage.h>\n-#include <util/memory.h>\n #include <validationinterface.h>\n #include <version.h>\n \n@@ -69,8 +68,8 @@ void fuzz_target(FuzzBufferType buffer, const std::string& LIMIT_TO_MESSAGE_TYPE\n {\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n \n-    ConnmanTestMsg& connman = *(ConnmanTestMsg*)g_setup->m_node.connman.get();\n-    TestChainState& chainstate = *(TestChainState*)&g_setup->m_node.chainman->ActiveChainstate();\n+    ConnmanTestMsg& connman = *static_cast<ConnmanTestMsg*>(g_setup->m_node.connman.get());\n+    TestChainState& chainstate = *static_cast<TestChainState*>(&g_setup->m_node.chainman->ActiveChainstate());\n     SetMockTime(1610000000); // any time to successfully reset ibd\n     chainstate.ResetIbd();\n "
      },
      {
        "sha": "203c0ef8e1573c401e99e6510ffeb5c0b519c758",
        "filename": "src/test/fuzz/process_messages.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/process_messages.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/process_messages.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/process_messages.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -14,7 +14,6 @@\n #include <test/util/setup_common.h>\n #include <test/util/validation.h>\n #include <txorphanage.h>\n-#include <util/memory.h>\n #include <validation.h>\n #include <validationinterface.h>\n \n@@ -36,8 +35,8 @@ FUZZ_TARGET_INIT(process_messages, initialize_process_messages)\n {\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n \n-    ConnmanTestMsg& connman = *(ConnmanTestMsg*)g_setup->m_node.connman.get();\n-    TestChainState& chainstate = *(TestChainState*)&g_setup->m_node.chainman->ActiveChainstate();\n+    ConnmanTestMsg& connman = *static_cast<ConnmanTestMsg*>(g_setup->m_node.connman.get());\n+    TestChainState& chainstate = *static_cast<TestChainState*>(&g_setup->m_node.chainman->ActiveChainstate());\n     SetMockTime(1610000000); // any time to successfully reset ibd\n     chainstate.ResetIbd();\n \n@@ -66,7 +65,7 @@ FUZZ_TARGET_INIT(process_messages, initialize_process_messages)\n         net_msg.m_type = random_message_type;\n         net_msg.data = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n \n-        CNode& random_node = *peers.at(fuzzed_data_provider.ConsumeIntegralInRange<int>(0, peers.size() - 1));\n+        CNode& random_node = *PickValue(fuzzed_data_provider, peers);\n \n         (void)connman.ReceiveMsgFrom(random_node, net_msg);\n         random_node.fPauseSend = false;"
      },
      {
        "sha": "d1cc6f9c7ebc7e262c39b8025976e830c12acd6e",
        "filename": "src/test/fuzz/psbt.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/psbt.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/psbt.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/psbt.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -5,15 +5,14 @@\n #include <test/fuzz/fuzz.h>\n \n #include <node/psbt.h>\n-#include <optional.h>\n #include <psbt.h>\n #include <pubkey.h>\n #include <script/script.h>\n #include <streams.h>\n-#include <util/memory.h>\n #include <version.h>\n \n #include <cstdint>\n+#include <optional>\n #include <string>\n #include <vector>\n \n@@ -40,7 +39,7 @@ FUZZ_TARGET_INIT(psbt, initialize_psbt)\n \n     (void)psbt.IsNull();\n \n-    Optional<CMutableTransaction> tx = psbt.tx;\n+    std::optional<CMutableTransaction> tx = psbt.tx;\n     if (tx) {\n         const CMutableTransaction& mtx = *tx;\n         const PartiallySignedTransaction psbt_from_tx{mtx};"
      },
      {
        "sha": "8219a04e49d393788d89e7cff8207c2fb629840c",
        "filename": "src/test/fuzz/script.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/script.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -20,7 +20,6 @@\n #include <test/fuzz/fuzz.h>\n #include <test/fuzz/util.h>\n #include <univalue.h>\n-#include <util/memory.h>\n \n #include <algorithm>\n #include <cassert>"
      },
      {
        "sha": "6ce13d56792afc25d2b890c4052481beee6b1bd3",
        "filename": "src/test/fuzz/script_descriptor_cache.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/script_descriptor_cache.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/script_descriptor_cache.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/script_descriptor_cache.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -2,14 +2,14 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <optional.h>\n #include <pubkey.h>\n #include <script/descriptor.h>\n #include <test/fuzz/FuzzedDataProvider.h>\n #include <test/fuzz/fuzz.h>\n #include <test/fuzz/util.h>\n \n #include <cstdint>\n+#include <optional>\n #include <string>\n #include <vector>\n "
      },
      {
        "sha": "561230707c82bcf0856c9c50cb5fbd5485c88bd4",
        "filename": "src/test/fuzz/script_flags.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/script_flags.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/script_flags.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/script_flags.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -5,7 +5,6 @@\n #include <pubkey.h>\n #include <script/interpreter.h>\n #include <streams.h>\n-#include <util/memory.h>\n #include <version.h>\n \n #include <test/fuzz/fuzz.h>"
      },
      {
        "sha": "7b57c5dfd81ef3d565c43b757455ecf62650057c",
        "filename": "src/test/fuzz/signature_checker.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/signature_checker.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/signature_checker.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/signature_checker.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -6,7 +6,6 @@\n #include <script/interpreter.h>\n #include <test/fuzz/FuzzedDataProvider.h>\n #include <test/fuzz/fuzz.h>\n-#include <util/memory.h>\n \n #include <cstdint>\n #include <limits>\n@@ -15,7 +14,7 @@\n \n void initialize_signature_checker()\n {\n-    static const auto verify_handle = MakeUnique<ECCVerifyHandle>();\n+    static const auto verify_handle = std::make_unique<ECCVerifyHandle>();\n }\n \n namespace {"
      },
      {
        "sha": "c3a6eed0896ee244923e810831c4d2a7ed73df3d",
        "filename": "src/test/fuzz/socks5.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/socks5.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/socks5.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/socks5.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -2,6 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <netaddress.h>\n #include <netbase.h>\n #include <test/fuzz/FuzzedDataProvider.h>\n #include <test/fuzz/fuzz.h>\n@@ -38,7 +39,7 @@ FUZZ_TARGET_INIT(socks5, initialize_socks5)\n     // This Socks5(...) fuzzing harness would have caught CVE-2017-18350 within\n     // a few seconds of fuzzing.\n     (void)Socks5(fuzzed_data_provider.ConsumeRandomLengthString(512),\n-                 fuzzed_data_provider.ConsumeIntegral<int>(),\n+                 fuzzed_data_provider.ConsumeIntegral<uint16_t>(),\n                  fuzzed_data_provider.ConsumeBool() ? &proxy_credentials : nullptr,\n                  fuzzed_sock);\n }"
      },
      {
        "sha": "286375f7ae0770a9d8bcb7f72b26b5a0897ef974",
        "filename": "src/test/fuzz/string.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/string.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/string.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/string.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -5,6 +5,7 @@\n #include <blockfilter.h>\n #include <clientversion.h>\n #include <logging.h>\n+#include <netaddress.h>\n #include <netbase.h>\n #include <outputtype.h>\n #include <rpc/client.h>\n@@ -82,7 +83,7 @@ FUZZ_TARGET(string)\n #ifndef WIN32\n     (void)ShellEscape(random_string_1);\n #endif // WIN32\n-    int port_out;\n+    uint16_t port_out;\n     std::string host_out;\n     SplitHostPort(random_string_1, port_out, host_out);\n     (void)TimingResistantEqual(random_string_1, random_string_2);"
      },
      {
        "sha": "b25dcfcd3bd76bbaec994330d70d9a449dca1953",
        "filename": "src/test/fuzz/system.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/system.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/system.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/system.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -51,7 +51,7 @@ FUZZ_TARGET(system)\n                 // Avoid hitting:\n                 // util/system.cpp:425: void ArgsManager::AddArg(const std::string &, const std::string &, unsigned int, const OptionsCategory &): Assertion `ret.second' failed.\n                 const std::string argument_name = GetArgumentName(fuzzed_data_provider.ConsumeRandomLengthString(16));\n-                if (args_manager.GetArgFlags(argument_name) != nullopt) {\n+                if (args_manager.GetArgFlags(argument_name) != std::nullopt) {\n                     return;\n                 }\n                 args_manager.AddArg(argument_name, fuzzed_data_provider.ConsumeRandomLengthString(16), fuzzed_data_provider.ConsumeIntegral<unsigned int>() & ~ArgsManager::COMMAND, options_category);\n@@ -63,7 +63,7 @@ FUZZ_TARGET(system)\n                 std::vector<std::string> hidden_arguments;\n                 for (const std::string& name : names) {\n                     const std::string hidden_argument = GetArgumentName(name);\n-                    if (args_manager.GetArgFlags(hidden_argument) != nullopt) {\n+                    if (args_manager.GetArgFlags(hidden_argument) != std::nullopt) {\n                         continue;\n                     }\n                     if (std::find(hidden_arguments.begin(), hidden_arguments.end(), hidden_argument) != hidden_arguments.end()) {"
      },
      {
        "sha": "f84d6702a700670453182651c4259bfa7d573aac",
        "filename": "src/test/fuzz/tx_pool.cpp",
        "status": "added",
        "additions": 285,
        "deletions": 0,
        "changes": 285,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/tx_pool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/tx_pool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/tx_pool.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -0,0 +1,285 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate()\n+    {\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        CTxIn in = MineBlock(g_setup->m_node, P2WSH_OP_TRUE);\n+        // Remember the txids to avoid expensive disk acess later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(in.prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        Assert(m_added.insert(tx).second);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        Assert(m_removed.insert(tx).second);\n+    }\n+};\n+\n+void SetMempoolConstraints(ArgsManager& args, FuzzedDataProvider& fuzzed_data_provider)\n+{\n+    args.ForceSetArg(\"-limitancestorcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitancestorsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-limitdescendantcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitdescendantsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-maxmempool\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200)));\n+    args.ForceSetArg(\"-mempoolexpiry\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)));\n+}\n+\n+FUZZ_TARGET_INIT(tx_pool_standard, initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate = node.chainman->ActiveChainstate();\n+\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    SetMempoolConstraints(*node.args, fuzzed_data_provider);\n+\n+    // All RBF-spendable outpoints\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+    }\n+    outpoints_rbf = outpoints_supply;\n+\n+    // The sum of the values of all spendable outpoints\n+    constexpr CAmount SUPPLY_TOTAL{COINBASE_MATURITY * 50 * COIN};\n+\n+    CTxMemPool tx_pool_{/* estimator */ nullptr, /* check_ratio */ 1};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    // Helper to query an amount\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        Coin c;\n+        Assert(amount_view.GetCoin(outpoint, c));\n+        return c.out.nValue;\n+    };\n+\n+    while (fuzzed_data_provider.ConsumeBool()) {\n+        {\n+            // Total supply is the mempool fee + all outpoints\n+            CAmount supply_now{WITH_LOCK(tx_pool.cs, return tx_pool.GetTotalFee())};\n+            for (const auto& op : outpoints_supply) {\n+                supply_now += GetAmount(op);\n+            }\n+            Assert(supply_now == SUPPLY_TOTAL);\n+        }\n+        Assert(!outpoints_supply.empty());\n+\n+        // Create transaction to add to the mempool\n+        const CTransactionRef tx = [&] {\n+            CMutableTransaction tx_mut;\n+            tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+            tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+            const auto num_in = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+            const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+            CAmount amount_in{0};\n+            for (int i = 0; i < num_in; ++i) {\n+                // Pop random outpoint\n+                auto pop = outpoints_rbf.begin();\n+                std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints_rbf.size() - 1));\n+                const auto outpoint = *pop;\n+                outpoints_rbf.erase(pop);\n+                amount_in += GetAmount(outpoint);\n+\n+                // Create input\n+                const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                const auto script_sig = CScript{};\n+                const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                CTxIn in;\n+                in.prevout = outpoint;\n+                in.nSequence = sequence;\n+                in.scriptSig = script_sig;\n+                in.scriptWitness.stack = script_wit_stack;\n+\n+                tx_mut.vin.push_back(in);\n+            }\n+            const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-1000, amount_in);\n+            const auto amount_out = (amount_in - amount_fee) / num_out;\n+            for (int i = 0; i < num_out; ++i) {\n+                tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+            }\n+            const auto tx = MakeTransactionRef(tx_mut);\n+            // Restore previously removed outpoints\n+            for (const auto& in : tx->vin) {\n+                Assert(outpoints_rbf.insert(in.prevout).second);\n+            }\n+            return tx;\n+        }();\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            SetMockTime(ConsumeTime(fuzzed_data_provider));\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            SetMempoolConstraints(*node.args, fuzzed_data_provider);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   tx->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+        ::fRequireStandard = fuzzed_data_provider.ConsumeBool();\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, tx_pool, tx, bypass_limits));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        Assert(accepted != added.empty());\n+        Assert(accepted == res.m_state.IsValid());\n+        Assert(accepted != res.m_state.IsInvalid());\n+        if (accepted) {\n+            Assert(added.size() == 1); // For now, no package acceptance\n+            Assert(tx == *added.begin());\n+        } else {\n+            // Do not consider rejected transaction removed\n+            removed.erase(tx);\n+        }\n+\n+        // Helper to insert spent and created outpoints of a tx into collections\n+        using Sets = std::vector<std::reference_wrapper<std::set<COutPoint>>>;\n+        const auto insert_tx = [](Sets created_by_tx, Sets consumed_by_tx, const auto& tx) {\n+            for (size_t i{0}; i < tx.vout.size(); ++i) {\n+                for (auto& set : created_by_tx) {\n+                    Assert(set.get().emplace(tx.GetHash(), i).second);\n+                }\n+            }\n+            for (const auto& in : tx.vin) {\n+                for (auto& set : consumed_by_tx) {\n+                    Assert(set.get().insert(in.prevout).second);\n+                }\n+            }\n+        };\n+        // Add created outpoints, remove spent outpoints\n+        {\n+            // Outpoints that no longer exist at all\n+            std::set<COutPoint> consumed_erased;\n+            // Outpoints that no longer count toward the total supply\n+            std::set<COutPoint> consumed_supply;\n+            for (const auto& removed_tx : removed) {\n+                insert_tx(/* created_by_tx */ {consumed_erased}, /* consumed_by_tx */ {outpoints_supply}, /* tx */ *removed_tx);\n+            }\n+            for (const auto& added_tx : added) {\n+                insert_tx(/* created_by_tx */ {outpoints_supply, outpoints_rbf}, /* consumed_by_tx */ {consumed_supply}, /* tx */ *added_tx);\n+            }\n+            for (const auto& p : consumed_erased) {\n+                Assert(outpoints_supply.erase(p) == 1);\n+                Assert(outpoints_rbf.erase(p) == 1);\n+            }\n+            for (const auto& p : consumed_supply) {\n+                Assert(outpoints_supply.erase(p) == 1);\n+            }\n+        }\n+    }\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate));\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, /* dummy */ MemPoolRemovalReason::BLOCK));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+FUZZ_TARGET_INIT(tx_pool, initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+\n+    std::vector<uint256> txids;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        txids.push_back(outpoint.hash);\n+    }\n+    for (int i{0}; i <= 3; ++i) {\n+        // Add some immature and non-existent outpoints\n+        txids.push_back(g_outpoints_coinbase_init_immature.at(i).hash);\n+        txids.push_back(ConsumeUInt256(fuzzed_data_provider));\n+    }\n+\n+    CTxMemPool tx_pool{/* estimator */ nullptr, /* check_ratio */ 1};\n+\n+    while (fuzzed_data_provider.ConsumeBool()) {\n+        const auto mut_tx = ConsumeTransaction(fuzzed_data_provider, txids);\n+\n+        const auto tx = MakeTransactionRef(mut_tx);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+        ::fRequireStandard = fuzzed_data_provider.ConsumeBool();\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(node.chainman->ActiveChainstate(), tx_pool, tx, bypass_limits));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+        if (accepted) {\n+            txids.push_back(tx->GetHash());\n+        }\n+\n+        SyncWithValidationInterfaceQueue();\n+    }\n+}\n+} // namespace"
      },
      {
        "sha": "93418ab1ff76d77b3f068d78b04576a33a7f6379",
        "filename": "src/test/fuzz/util.cpp",
        "status": "modified",
        "additions": 78,
        "deletions": 0,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/util.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -3,8 +3,11 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <test/fuzz/util.h>\n+#include <test/util/script.h>\n+#include <util/rbf.h>\n #include <version.h>\n \n+\n void FillNode(FuzzedDataProvider& fuzzed_data_provider, CNode& node, bool init_version) noexcept\n {\n     const ServiceFlags remote_services = ConsumeWeakEnum(fuzzed_data_provider, ALL_SERVICE_FLAGS);\n@@ -23,3 +26,78 @@ void FillNode(FuzzedDataProvider& fuzzed_data_provider, CNode& node, bool init_v\n         node.m_tx_relay->fRelayTxes = filter_txs;\n     }\n }\n+\n+CMutableTransaction ConsumeTransaction(FuzzedDataProvider& fuzzed_data_provider, const std::optional<std::vector<uint256>>& prevout_txids, const int max_num_in, const int max_num_out) noexcept\n+{\n+    CMutableTransaction tx_mut;\n+    const auto p2wsh_op_true = fuzzed_data_provider.ConsumeBool();\n+    tx_mut.nVersion = fuzzed_data_provider.ConsumeBool() ?\n+                          CTransaction::CURRENT_VERSION :\n+                          fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    tx_mut.nLockTime = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+    const auto num_in = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, max_num_in);\n+    const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, max_num_out);\n+    for (int i = 0; i < num_in; ++i) {\n+        const auto& txid_prev = prevout_txids ?\n+                                    PickValue(fuzzed_data_provider, *prevout_txids) :\n+                                    ConsumeUInt256(fuzzed_data_provider);\n+        const auto index_out = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(0, max_num_out);\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = p2wsh_op_true ? CScript{} : ConsumeScript(fuzzed_data_provider);\n+        CScriptWitness script_wit;\n+        if (p2wsh_op_true) {\n+            script_wit.stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+        } else {\n+            script_wit = ConsumeScriptWitness(fuzzed_data_provider);\n+        }\n+        CTxIn in;\n+        in.prevout = COutPoint{txid_prev, index_out};\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness = script_wit;\n+\n+        tx_mut.vin.push_back(in);\n+    }\n+    for (int i = 0; i < num_out; ++i) {\n+        const auto amount = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-10, 50 * COIN + 10);\n+        const auto script_pk = p2wsh_op_true ?\n+                                   P2WSH_OP_TRUE :\n+                                   ConsumeScript(fuzzed_data_provider, /* max_length */ 128, /* maybe_p2wsh */ true);\n+        tx_mut.vout.emplace_back(amount, script_pk);\n+    }\n+    return tx_mut;\n+}\n+\n+CScriptWitness ConsumeScriptWitness(FuzzedDataProvider& fuzzed_data_provider, const size_t max_stack_elem_size) noexcept\n+{\n+    CScriptWitness ret;\n+    const auto n_elements = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, max_stack_elem_size);\n+    for (size_t i = 0; i < n_elements; ++i) {\n+        ret.stack.push_back(ConsumeRandomLengthByteVector(fuzzed_data_provider));\n+    }\n+    return ret;\n+}\n+\n+CScript ConsumeScript(FuzzedDataProvider& fuzzed_data_provider, const size_t max_length, const bool maybe_p2wsh) noexcept\n+{\n+    const std::vector<uint8_t> b = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+    CScript r_script{b.begin(), b.end()};\n+    if (maybe_p2wsh && fuzzed_data_provider.ConsumeBool()) {\n+        uint256 script_hash;\n+        CSHA256().Write(&r_script[0], r_script.size()).Finalize(script_hash.begin());\n+        r_script.clear();\n+        r_script << OP_0 << ToByteVector(script_hash);\n+    }\n+    return r_script;\n+}\n+\n+uint32_t ConsumeSequence(FuzzedDataProvider& fuzzed_data_provider) noexcept\n+{\n+    return fuzzed_data_provider.ConsumeBool() ?\n+               fuzzed_data_provider.PickValueInArray({\n+                   CTxIn::SEQUENCE_FINAL,\n+                   CTxIn::SEQUENCE_FINAL - 1,\n+                   MAX_BIP125_RBF_SEQUENCE,\n+               }) :\n+               fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+}"
      },
      {
        "sha": "d5c54911c57cf468847f1d080788c6946d294dcd",
        "filename": "src/test/fuzz/util.h",
        "status": "modified",
        "additions": 45,
        "deletions": 6,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/util.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -48,6 +48,16 @@ void CallOneOf(FuzzedDataProvider& fuzzed_data_provider, Callables... callables)\n     return ((i++ == call_index ? callables() : void()), ...);\n }\n \n+template <typename Collection>\n+auto& PickValue(FuzzedDataProvider& fuzzed_data_provider, Collection& col)\n+{\n+    const auto sz = col.size();\n+    assert(sz >= 1);\n+    auto it = col.begin();\n+    std::advance(it, fuzzed_data_provider.ConsumeIntegralInRange<decltype(sz)>(0, sz - 1));\n+    return *it;\n+}\n+\n [[nodiscard]] inline std::vector<uint8_t> ConsumeRandomLengthByteVector(FuzzedDataProvider& fuzzed_data_provider, const size_t max_length = 4096) noexcept\n {\n     const std::string s = fuzzed_data_provider.ConsumeRandomLengthString(max_length);\n@@ -125,11 +135,13 @@ template <typename WeakEnumType, size_t size>\n     return fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(time_min, time_max);\n }\n \n-[[nodiscard]] inline CScript ConsumeScript(FuzzedDataProvider& fuzzed_data_provider) noexcept\n-{\n-    const std::vector<uint8_t> b = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n-    return {b.begin(), b.end()};\n-}\n+[[nodiscard]] CMutableTransaction ConsumeTransaction(FuzzedDataProvider& fuzzed_data_provider, const std::optional<std::vector<uint256>>& prevout_txids, const int max_num_in = 10, const int max_num_out = 10) noexcept;\n+\n+[[nodiscard]] CScriptWitness ConsumeScriptWitness(FuzzedDataProvider& fuzzed_data_provider, const size_t max_stack_elem_size = 32) noexcept;\n+\n+[[nodiscard]] CScript ConsumeScript(FuzzedDataProvider& fuzzed_data_provider, const size_t max_length = 4096, const bool maybe_p2wsh = false) noexcept;\n+\n+[[nodiscard]] uint32_t ConsumeSequence(FuzzedDataProvider& fuzzed_data_provider) noexcept;\n \n [[nodiscard]] inline CScriptNum ConsumeScriptNum(FuzzedDataProvider& fuzzed_data_provider) noexcept\n {\n@@ -259,6 +271,16 @@ void SetFuzzedErrNo(FuzzedDataProvider& fuzzed_data_provider, const std::array<T\n     errno = fuzzed_data_provider.PickValueInArray(errnos);\n }\n \n+/*\n+ * Sets a fuzzed errno in the range [0, 133 (EHWPOISON)]. Can be used from functions emulating\n+ * standard library functions that set errno, or in other contexts where the value of errno\n+ * might be relevant for the execution path that will be taken.\n+ */\n+inline void SetFuzzedErrNo(FuzzedDataProvider& fuzzed_data_provider) noexcept\n+{\n+    errno = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 133);\n+}\n+\n /**\n  * Returns a byte vector of specified size regardless of the number of remaining bytes available\n  * from the fuzzer. Pads with zero value bytes if needed to achieve the specified size.\n@@ -345,6 +367,7 @@ class FuzzedFileProvider\n \n     FILE* open()\n     {\n+        SetFuzzedErrNo(m_fuzzed_data_provider);\n         if (m_fuzzed_data_provider.ConsumeBool()) {\n             return nullptr;\n         }\n@@ -386,6 +409,7 @@ class FuzzedFileProvider\n     static ssize_t read(void* cookie, char* buf, size_t size)\n     {\n         FuzzedFileProvider* fuzzed_file = (FuzzedFileProvider*)cookie;\n+        SetFuzzedErrNo(fuzzed_file->m_fuzzed_data_provider);\n         if (buf == nullptr || size == 0 || fuzzed_file->m_fuzzed_data_provider.ConsumeBool()) {\n             return fuzzed_file->m_fuzzed_data_provider.ConsumeBool() ? 0 : -1;\n         }\n@@ -404,6 +428,7 @@ class FuzzedFileProvider\n     static ssize_t write(void* cookie, const char* buf, size_t size)\n     {\n         FuzzedFileProvider* fuzzed_file = (FuzzedFileProvider*)cookie;\n+        SetFuzzedErrNo(fuzzed_file->m_fuzzed_data_provider);\n         const ssize_t n = fuzzed_file->m_fuzzed_data_provider.ConsumeIntegralInRange<ssize_t>(0, size);\n         if (AdditionOverflow(fuzzed_file->m_offset, (int64_t)n)) {\n             return fuzzed_file->m_fuzzed_data_provider.ConsumeBool() ? 0 : -1;\n@@ -414,8 +439,9 @@ class FuzzedFileProvider\n \n     static int seek(void* cookie, int64_t* offset, int whence)\n     {\n-        assert(whence == SEEK_SET || whence == SEEK_CUR); // SEEK_END not implemented yet.\n+        assert(whence == SEEK_SET || whence == SEEK_CUR || whence == SEEK_END);\n         FuzzedFileProvider* fuzzed_file = (FuzzedFileProvider*)cookie;\n+        SetFuzzedErrNo(fuzzed_file->m_fuzzed_data_provider);\n         int64_t new_offset = 0;\n         if (whence == SEEK_SET) {\n             new_offset = *offset;\n@@ -424,6 +450,12 @@ class FuzzedFileProvider\n                 return -1;\n             }\n             new_offset = fuzzed_file->m_offset + *offset;\n+        } else if (whence == SEEK_END) {\n+            const int64_t n = fuzzed_file->m_fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, 4096);\n+            if (AdditionOverflow(n, *offset)) {\n+                return -1;\n+            }\n+            new_offset = n + *offset;\n         }\n         if (new_offset < 0) {\n             return -1;\n@@ -436,6 +468,7 @@ class FuzzedFileProvider\n     static int close(void* cookie)\n     {\n         FuzzedFileProvider* fuzzed_file = (FuzzedFileProvider*)cookie;\n+        SetFuzzedErrNo(fuzzed_file->m_fuzzed_data_provider);\n         return fuzzed_file->m_fuzzed_data_provider.ConsumeIntegralInRange<int>(-1, 0);\n     }\n };\n@@ -543,6 +576,12 @@ class FuzzedSock : public Sock\n     {\n     }\n \n+    FuzzedSock& operator=(Sock&& other) override\n+    {\n+        assert(false && \"Not implemented yet.\");\n+        return *this;\n+    }\n+\n     SOCKET Get() const override\n     {\n         assert(false && \"Not implemented yet.\");"
      },
      {
        "sha": "e1a21b6c5397afa5d2ec66d040b2aae836d57bdc",
        "filename": "src/test/fuzz/validation_load_mempool.cpp",
        "status": "added",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/validation_load_mempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/validation_load_mempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/validation_load_mempool.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -0,0 +1,34 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparamsbase.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <txmempool.h>\n+#include <util/time.h>\n+#include <validation.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+void initialize_validation_load_mempool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+}\n+\n+FUZZ_TARGET_INIT(validation_load_mempool, initialize_validation_load_mempool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    FuzzedFileProvider fuzzed_file_provider = ConsumeFile(fuzzed_data_provider);\n+\n+    CTxMemPool pool{};\n+    auto fuzzed_fopen = [&](const fs::path&, const char*) {\n+        return fuzzed_file_provider.open();\n+    };\n+    (void)LoadMempool(pool, ::ChainstateActive(), fuzzed_fopen);\n+    (void)DumpMempool(pool, fuzzed_fopen, true);\n+}"
      },
      {
        "sha": "88c1a1a9cb81f51ccf8d3dec1542ed9104b63026",
        "filename": "src/test/fuzz/versionbits.cpp",
        "status": "added",
        "additions": 351,
        "deletions": 0,
        "changes": 351,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/versionbits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/fuzz/versionbits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/versionbits.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -0,0 +1,351 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin;\n+    const int64_t m_end;\n+    const int m_period;\n+    const int m_threshold;\n+    const int m_bit;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit < 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    int Period(const Consensus::Params& params) const override { return m_period; }\n+    int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int32_t version) const\n+    {\n+        uint32_t mask = ((uint32_t)1) << m_bit;\n+        return (((version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS) && (version & mask) != 0);\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + m_blocks.size() * m_interval;\n+        header.nBits = 0x1d00ffff;\n+\n+        auto current_block = std::make_unique<CBlockIndex>(header);\n+        current_block->pprev = tip();\n+        current_block->nHeight = m_blocks.size();\n+        current_block->BuildSkip();\n+\n+        return m_blocks.emplace_back(std::move(current_block)).get();\n+    }\n+};\n+\n+std::unique_ptr<const CChainParams> g_params;\n+\n+void initialize()\n+{\n+    // this is actually comparatively slow, so only do it once\n+    g_params = CreateChainParams(ArgsManager{}, CBaseChainParams::MAIN);\n+    assert(g_params != nullptr);\n+}\n+\n+constexpr uint32_t MAX_START_TIME = 4102444800; // 2100-01-01\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    const CChainParams& params = *g_params;\n+    const int64_t interval = params.GetConsensus().nPowTargetSpacing;\n+    assert(interval > 1); // need to be able to halve it\n+    assert(interval < std::numeric_limits<int32_t>::max());\n+\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // making period/max_periods larger slows these tests down significantly\n+    const int period = 32;\n+    const size_t max_periods = 16;\n+    const size_t max_blocks = 2 * period * max_periods;\n+\n+    const int threshold = fuzzed_data_provider.ConsumeIntegralInRange(1, period);\n+    assert(0 < threshold && threshold <= period); // must be able to both pass and fail threshold!\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(std::numeric_limits<uint32_t>::max() - MAX_START_TIME > interval * max_blocks);\n+\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(params.GenesisBlock().nTime, MAX_START_TIME);\n+\n+    // what values for version will we use to signal / not signal?\n+    const int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    const int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    const int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS - 1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        // pick the timestamp to switch based on a block\n+        // note states will change *after* these blocks because mediantime lags\n+        int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods - 3));\n+        int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods - 3));\n+\n+        start_time = block_start_time + start_block * interval;\n+        timeout = block_start_time + end_block * interval;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += interval / 2;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += interval / 2;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999;    // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive and meet min\n+    // version requirement\n+    assert(ver_signal > 0);\n+    assert(ver_signal >= VERSIONBITS_LAST_OLD_BLOCK_VERSION);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, interval, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    const uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {\n+        // all blocks in these periods either do or don't signal\n+        bool signal = fuzzed_data_provider.ConsumeBool();\n+        for (int b = 0; b < period; ++b) {\n+            blocks.mine_block(signal);\n+        }\n+\n+        // don't risk exceeding max_blocks or times may wrap around\n+        if (blocks.size() + 2 * period > max_blocks) break;\n+    }\n+    // NOTE: fuzzed_data_provider may be fully consumed at this point and should not be used further\n+\n+    // now we mine the final period and check that everything looks sane\n+\n+    // count the number of signalling blocks\n+    int blocks_sig = 0;\n+\n+    // get the info for the first block of the period\n+    CBlockIndex* prev = blocks.tip();\n+    const int exp_since = checker.GetStateSinceHeightFor(prev);\n+    const ThresholdState exp_state = checker.GetStateFor(prev);\n+    BIP9Stats last_stats = checker.GetStateStatisticsFor(prev);\n+\n+    int prev_next_height = (prev == nullptr ? 0 : prev->nHeight + 1);\n+    assert(exp_since <= prev_next_height);\n+\n+    // mine (period-1) blocks and check state\n+    for (int b = 1; b < period; ++b) {\n+        const bool signal = (signalling_mask >> (b % 32)) & 1;\n+        if (signal) ++blocks_sig;\n+\n+        CBlockIndex* current_block = blocks.mine_block(signal);\n+\n+        // verify that signalling attempt was interpreted correctly\n+        assert(checker.Condition(current_block) == signal);\n+\n+        // state and since don't change within the period\n+        const ThresholdState state = checker.GetStateFor(current_block);\n+        const int since = checker.GetStateSinceHeightFor(current_block);\n+        assert(state == exp_state);\n+        assert(since == exp_since);\n+\n+        // GetStateStatistics may crash when state is not STARTED\n+        if (state != ThresholdState::STARTED) continue;\n+\n+        // check that after mining this block stats change as expected\n+        const BIP9Stats stats = checker.GetStateStatisticsFor(current_block);\n+        assert(stats.period == period);\n+        assert(stats.threshold == threshold);\n+        assert(stats.elapsed == b);\n+        assert(stats.count == last_stats.count + (signal ? 1 : 0));\n+        assert(stats.possible == (stats.count + period >= stats.elapsed + threshold));\n+        last_stats = stats;\n+    }\n+\n+    if (exp_state == ThresholdState::STARTED) {\n+        // double check that stats.possible is sane\n+        if (blocks_sig >= threshold - 1) assert(last_stats.possible);\n+    }\n+\n+    // mine the final block\n+    bool signal = (signalling_mask >> (period % 32)) & 1;\n+    if (signal) ++blocks_sig;\n+    CBlockIndex* current_block = blocks.mine_block(signal);\n+    assert(checker.Condition(current_block) == signal);\n+\n+    // GetStateStatistics is safe on a period boundary\n+    // and has progressed to a new period\n+    const BIP9Stats stats = checker.GetStateStatisticsFor(current_block);\n+    assert(stats.period == period);\n+    assert(stats.threshold == threshold);\n+    assert(stats.elapsed == 0);\n+    assert(stats.count == 0);\n+    assert(stats.possible == true);\n+\n+    // More interesting is whether the state changed.\n+    const ThresholdState state = checker.GetStateFor(current_block);\n+    const int since = checker.GetStateSinceHeightFor(current_block);\n+\n+    // since is straightforward:\n+    assert(since % period == 0);\n+    assert(0 <= since && since <= current_block->nHeight + 1);\n+    if (state == exp_state) {\n+        assert(since == exp_since);\n+    } else {\n+        assert(since == current_block->nHeight + 1);\n+    }\n+\n+    // state is where everything interesting is\n+    switch (state) {\n+    case ThresholdState::DEFINED:\n+        assert(since == 0);\n+        assert(exp_state == ThresholdState::DEFINED);\n+        assert(current_block->GetMedianTimePast() < checker.m_begin);\n+        assert(current_block->GetMedianTimePast() < checker.m_end);\n+        break;\n+    case ThresholdState::STARTED:\n+        assert(current_block->GetMedianTimePast() >= checker.m_begin);\n+        assert(current_block->GetMedianTimePast() < checker.m_end);\n+        if (exp_state == ThresholdState::STARTED) {\n+            assert(blocks_sig < threshold);\n+        } else {\n+            assert(exp_state == ThresholdState::DEFINED);\n+        }\n+        break;\n+    case ThresholdState::LOCKED_IN:\n+        assert(exp_state == ThresholdState::STARTED);\n+        assert(current_block->GetMedianTimePast() < checker.m_end);\n+        assert(blocks_sig >= threshold);\n+        break;\n+    case ThresholdState::ACTIVE:\n+        assert(exp_state == ThresholdState::ACTIVE || exp_state == ThresholdState::LOCKED_IN);\n+        break;\n+    case ThresholdState::FAILED:\n+        assert(current_block->GetMedianTimePast() >= checker.m_end);\n+        assert(exp_state != ThresholdState::LOCKED_IN && exp_state != ThresholdState::ACTIVE);\n+        break;\n+    default:\n+        assert(false);\n+    }\n+\n+    if (blocks.size() >= period * max_periods) {\n+        // we chose the timeout (and block times) so that by the time we have this many blocks it's all over\n+        assert(state == ThresholdState::ACTIVE || state == ThresholdState::FAILED);\n+    }\n+\n+    // \"always active\" has additional restrictions\n+    if (always_active_test) {\n+        assert(state == ThresholdState::ACTIVE);\n+        assert(exp_state == ThresholdState::ACTIVE);\n+        assert(since == 0);\n+    } else {\n+        // except for always active, the initial state is always DEFINED\n+        assert(since > 0 || state == ThresholdState::DEFINED);\n+        assert(exp_since > 0 || exp_state == ThresholdState::DEFINED);\n+    }\n+\n+    // \"never active\" does too\n+    if (never_active_test) {\n+        assert(state == ThresholdState::FAILED);\n+        assert(since == period);\n+        if (exp_since == 0) {\n+            assert(exp_state == ThresholdState::DEFINED);\n+        } else {\n+            assert(exp_state == ThresholdState::FAILED);\n+        }\n+    }\n+}\n+} // namespace"
      },
      {
        "sha": "9acd17c463193ebcdc8dcea26fbd8877ab46c263",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 19,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -122,7 +122,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     uint256 hashHighFeeTx = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(50000).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n \n-    std::unique_ptr<CBlockTemplate> pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n+    std::unique_ptr<CBlockTemplate> pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);\n     BOOST_REQUIRE_EQUAL(pblocktemplate->block.vtx.size(), 4U);\n     BOOST_CHECK(pblocktemplate->block.vtx[1]->GetHash() == hashParentTx);\n     BOOST_CHECK(pblocktemplate->block.vtx[2]->GetHash() == hashHighFeeTx);\n@@ -143,7 +143,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vout[0].nValue = 5000000000LL - 1000 - 50000 - feeToUse;\n     uint256 hashLowFeeTx = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(feeToUse).FromTx(tx));\n-    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n+    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);\n     // Verify that the free tx and the low fee tx didn't get selected\n     for (size_t i=0; i<pblocktemplate->block.vtx.size(); ++i) {\n         BOOST_CHECK(pblocktemplate->block.vtx[i]->GetHash() != hashFreeTx);\n@@ -157,7 +157,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vout[0].nValue -= 2; // Now we should be just over the min relay fee\n     hashLowFeeTx = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(feeToUse+2).FromTx(tx));\n-    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n+    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);\n     BOOST_REQUIRE_EQUAL(pblocktemplate->block.vtx.size(), 6U);\n     BOOST_CHECK(pblocktemplate->block.vtx[4]->GetHash() == hashFreeTx);\n     BOOST_CHECK(pblocktemplate->block.vtx[5]->GetHash() == hashLowFeeTx);\n@@ -179,7 +179,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vout[0].nValue = 5000000000LL - 100000000 - feeToUse;\n     uint256 hashLowFeeTx2 = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(feeToUse).SpendsCoinbase(false).FromTx(tx));\n-    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n+    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);\n \n     // Verify that this tx isn't selected.\n     for (size_t i=0; i<pblocktemplate->block.vtx.size(); ++i) {\n@@ -192,7 +192,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vin[0].prevout.n = 1;\n     tx.vout[0].nValue = 100000000 - 10000; // 10k satoshi fee\n     m_node.mempool->addUnchecked(entry.Fee(10000).FromTx(tx));\n-    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n+    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);\n     BOOST_REQUIRE_EQUAL(pblocktemplate->block.vtx.size(), 9U);\n     BOOST_CHECK(pblocktemplate->block.vtx[8]->GetHash() == hashLowFeeTx2);\n }\n@@ -215,7 +215,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     fCheckpointsEnabled = false;\n \n     // Simple block creation, nothing special yet:\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n \n     // We can't make transactions until we have inputs\n     // Therefore, load 110 blocks :)\n@@ -252,7 +252,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     LOCK(m_node.mempool->cs);\n \n     // Just to make sure we can still make simple blocks\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n \n     const CAmount BLOCKSUBSIDY = 50*COIN;\n     const CAmount LOWFEE = CENT;\n@@ -277,7 +277,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         tx.vin[0].prevout.hash = hash;\n     }\n \n-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-blk-sigops\"));\n+    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey), std::runtime_error, HasReason(\"bad-blk-sigops\"));\n     m_node.mempool->clear();\n \n     tx.vin[0].prevout.hash = txFirst[0]->GetHash();\n@@ -291,7 +291,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).SigOpsCost(80).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n     }\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n     m_node.mempool->clear();\n \n     // block size > limit\n@@ -311,13 +311,13 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n     }\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n     m_node.mempool->clear();\n \n     // orphan in *m_node.mempool, template creation fails\n     hash = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).FromTx(tx));\n-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-txns-inputs-missingorspent\"));\n+    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey), std::runtime_error, HasReason(\"bad-txns-inputs-missingorspent\"));\n     m_node.mempool->clear();\n \n     // child with higher feerate than parent\n@@ -334,7 +334,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].nValue = tx.vout[0].nValue+BLOCKSUBSIDY-HIGHERFEE; //First txn output + fresh coinbase - new txn fee\n     hash = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(HIGHERFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n     m_node.mempool->clear();\n \n     // coinbase in *m_node.mempool, template creation fails\n@@ -346,7 +346,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     // give it a fee so it'll get mined\n     m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n     // Should throw bad-cb-multiple\n-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-cb-multiple\"));\n+    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey), std::runtime_error, HasReason(\"bad-cb-multiple\"));\n     m_node.mempool->clear();\n \n     // double spend txn pair in *m_node.mempool, template creation fails\n@@ -359,7 +359,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].scriptPubKey = CScript() << OP_2;\n     hash = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-txns-inputs-missingorspent\"));\n+    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey), std::runtime_error, HasReason(\"bad-txns-inputs-missingorspent\"));\n     m_node.mempool->clear();\n \n     // subsidy changing\n@@ -375,7 +375,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         next->BuildSkip();\n         ::ChainActive().SetTip(next);\n     }\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n     // Extend to a 210000-long block chain.\n     while (::ChainActive().Tip()->nHeight < 210000) {\n         CBlockIndex* prev = ::ChainActive().Tip();\n@@ -387,7 +387,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         next->BuildSkip();\n         ::ChainActive().SetTip(next);\n     }\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n \n     // invalid p2sh txn in *m_node.mempool, template creation fails\n     tx.vin[0].prevout.hash = txFirst[0]->GetHash();\n@@ -404,7 +404,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     hash = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n     // Should throw block-validation-failed\n-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"block-validation-failed\"));\n+    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey), std::runtime_error, HasReason(\"block-validation-failed\"));\n     m_node.mempool->clear();\n \n     // Delete the dummy blocks again.\n@@ -492,7 +492,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG | 1;\n     BOOST_CHECK(!TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks fail\n \n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n \n     // None of the of the absolute height/time locked tx should have made\n     // it into the template because we still check IsFinalTx in CreateNewBlock,\n@@ -505,7 +505,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     ::ChainActive().Tip()->nHeight++;\n     SetMockTime(::ChainActive().Tip()->GetMedianTimePast() + 1);\n \n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n     BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 5U);\n \n     ::ChainActive().Tip()->nHeight--;"
      },
      {
        "sha": "c336705d50875c9b0e9bb1681caf3d1bef7c7a30",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -8,13 +8,12 @@\n #include <clientversion.h>\n #include <cstdint>\n #include <net.h>\n+#include <netaddress.h>\n #include <netbase.h>\n-#include <optional.h>\n #include <serialize.h>\n #include <span.h>\n #include <streams.h>\n #include <test/util/setup_common.h>\n-#include <util/memory.h>\n #include <util/strencodings.h>\n #include <util/string.h>\n #include <util/system.h>\n@@ -25,6 +24,7 @@\n #include <algorithm>\n #include <ios>\n #include <memory>\n+#include <optional>\n #include <string>\n \n using namespace std::literals;\n@@ -92,7 +92,7 @@ BOOST_FIXTURE_TEST_SUITE(net_tests, BasicTestingSetup)\n BOOST_AUTO_TEST_CASE(cnode_listen_port)\n {\n     // test default\n-    uint16_t port = GetListenPort();\n+    uint16_t port{GetListenPort()};\n     BOOST_CHECK(port == Params().GetDefaultPort());\n     // test set port\n     uint16_t altPort = 12345;\n@@ -188,7 +188,7 @@ BOOST_AUTO_TEST_CASE(cnode_simple_test)\n     CAddress addr = CAddress(CService(ipv4Addr, 7777), NODE_NETWORK);\n     std::string pszDest;\n \n-    std::unique_ptr<CNode> pnode1 = MakeUnique<CNode>(\n+    std::unique_ptr<CNode> pnode1 = std::make_unique<CNode>(\n         id++, NODE_NETWORK, hSocket, addr,\n         /* nKeyedNetGroupIn = */ 0,\n         /* nLocalHostNonceIn = */ 0,\n@@ -203,7 +203,7 @@ BOOST_AUTO_TEST_CASE(cnode_simple_test)\n     BOOST_CHECK(pnode1->m_inbound_onion == false);\n     BOOST_CHECK_EQUAL(pnode1->ConnectedThroughNetwork(), Network::NET_IPV4);\n \n-    std::unique_ptr<CNode> pnode2 = MakeUnique<CNode>(\n+    std::unique_ptr<CNode> pnode2 = std::make_unique<CNode>(\n         id++, NODE_NETWORK, hSocket, addr,\n         /* nKeyedNetGroupIn = */ 1,\n         /* nLocalHostNonceIn = */ 1,\n@@ -218,7 +218,7 @@ BOOST_AUTO_TEST_CASE(cnode_simple_test)\n     BOOST_CHECK(pnode2->m_inbound_onion == false);\n     BOOST_CHECK_EQUAL(pnode2->ConnectedThroughNetwork(), Network::NET_IPV4);\n \n-    std::unique_ptr<CNode> pnode3 = MakeUnique<CNode>(\n+    std::unique_ptr<CNode> pnode3 = std::make_unique<CNode>(\n         id++, NODE_NETWORK, hSocket, addr,\n         /* nKeyedNetGroupIn = */ 0,\n         /* nLocalHostNonceIn = */ 0,\n@@ -233,7 +233,7 @@ BOOST_AUTO_TEST_CASE(cnode_simple_test)\n     BOOST_CHECK(pnode3->m_inbound_onion == false);\n     BOOST_CHECK_EQUAL(pnode3->ConnectedThroughNetwork(), Network::NET_IPV4);\n \n-    std::unique_ptr<CNode> pnode4 = MakeUnique<CNode>(\n+    std::unique_ptr<CNode> pnode4 = std::make_unique<CNode>(\n         id++, NODE_NETWORK, hSocket, addr,\n         /* nKeyedNetGroupIn = */ 1,\n         /* nLocalHostNonceIn = */ 1,\n@@ -711,7 +711,7 @@ BOOST_AUTO_TEST_CASE(ipv4_peer_with_ipv6_addrMe_test)\n     in_addr ipv4AddrPeer;\n     ipv4AddrPeer.s_addr = 0xa0b0c001;\n     CAddress addr = CAddress(CService(ipv4AddrPeer, 7777), NODE_NETWORK);\n-    std::unique_ptr<CNode> pnode = MakeUnique<CNode>(0, NODE_NETWORK, INVALID_SOCKET, addr, /* nKeyedNetGroupIn */ 0, /* nLocalHostNonceIn */ 0, CAddress{}, /* pszDest */ std::string{}, ConnectionType::OUTBOUND_FULL_RELAY, /* inbound_onion */ false);\n+    std::unique_ptr<CNode> pnode = std::make_unique<CNode>(0, NODE_NETWORK, INVALID_SOCKET, addr, /* nKeyedNetGroupIn */ 0, /* nLocalHostNonceIn */ 0, CAddress{}, /* pszDest */ std::string{}, ConnectionType::OUTBOUND_FULL_RELAY, /* inbound_onion */ false);\n     pnode->fSuccessfullyConnected.store(true);\n \n     // the peer claims to be reaching us via IPv6\n@@ -828,7 +828,7 @@ std::vector<NodeEvictionCandidate> GetRandomNodeEvictionCandidates(const int n_c\n bool IsEvicted(std::vector<NodeEvictionCandidate> candidates, const std::vector<NodeId>& node_ids, FastRandomContext& random_context)\n {\n     Shuffle(candidates.begin(), candidates.end(), random_context);\n-    const Optional<NodeId> evicted_node_id = SelectNodeToEvict(std::move(candidates));\n+    const std::optional<NodeId> evicted_node_id = SelectNodeToEvict(std::move(candidates));\n     if (!evicted_node_id) {\n         return false;\n     }"
      },
      {
        "sha": "33b56624a8199598bcdf11214464dde329f831ff",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 9,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <net_permissions.h>\n+#include <netaddress.h>\n #include <netbase.h>\n #include <protocol.h>\n #include <serialize.h>\n@@ -83,31 +84,31 @@ BOOST_AUTO_TEST_CASE(netbase_properties)\n \n }\n \n-bool static TestSplitHost(std::string test, std::string host, int port)\n+bool static TestSplitHost(const std::string& test, const std::string& host, uint16_t port)\n {\n     std::string hostOut;\n-    int portOut = -1;\n+    uint16_t portOut{0};\n     SplitHostPort(test, portOut, hostOut);\n     return hostOut == host && port == portOut;\n }\n \n BOOST_AUTO_TEST_CASE(netbase_splithost)\n {\n-    BOOST_CHECK(TestSplitHost(\"www.bitcoincore.org\", \"www.bitcoincore.org\", -1));\n-    BOOST_CHECK(TestSplitHost(\"[www.bitcoincore.org]\", \"www.bitcoincore.org\", -1));\n+    BOOST_CHECK(TestSplitHost(\"www.bitcoincore.org\", \"www.bitcoincore.org\", 0));\n+    BOOST_CHECK(TestSplitHost(\"[www.bitcoincore.org]\", \"www.bitcoincore.org\", 0));\n     BOOST_CHECK(TestSplitHost(\"www.bitcoincore.org:80\", \"www.bitcoincore.org\", 80));\n     BOOST_CHECK(TestSplitHost(\"[www.bitcoincore.org]:80\", \"www.bitcoincore.org\", 80));\n-    BOOST_CHECK(TestSplitHost(\"127.0.0.1\", \"127.0.0.1\", -1));\n+    BOOST_CHECK(TestSplitHost(\"127.0.0.1\", \"127.0.0.1\", 0));\n     BOOST_CHECK(TestSplitHost(\"127.0.0.1:8333\", \"127.0.0.1\", 8333));\n-    BOOST_CHECK(TestSplitHost(\"[127.0.0.1]\", \"127.0.0.1\", -1));\n+    BOOST_CHECK(TestSplitHost(\"[127.0.0.1]\", \"127.0.0.1\", 0));\n     BOOST_CHECK(TestSplitHost(\"[127.0.0.1]:8333\", \"127.0.0.1\", 8333));\n-    BOOST_CHECK(TestSplitHost(\"::ffff:127.0.0.1\", \"::ffff:127.0.0.1\", -1));\n+    BOOST_CHECK(TestSplitHost(\"::ffff:127.0.0.1\", \"::ffff:127.0.0.1\", 0));\n     BOOST_CHECK(TestSplitHost(\"[::ffff:127.0.0.1]:8333\", \"::ffff:127.0.0.1\", 8333));\n     BOOST_CHECK(TestSplitHost(\"[::]:8333\", \"::\", 8333));\n-    BOOST_CHECK(TestSplitHost(\"::8333\", \"::8333\", -1));\n+    BOOST_CHECK(TestSplitHost(\"::8333\", \"::8333\", 0));\n     BOOST_CHECK(TestSplitHost(\":8333\", \"\", 8333));\n     BOOST_CHECK(TestSplitHost(\"[]:8333\", \"\", 8333));\n-    BOOST_CHECK(TestSplitHost(\"\", \"\", -1));\n+    BOOST_CHECK(TestSplitHost(\"\", \"\", 0));\n }\n \n bool static TestParse(std::string src, std::string canon)"
      },
      {
        "sha": "2e0fc7e48f04c82ba790da6d343683289a902c63",
        "filename": "src/test/rpc_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/rpc_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/rpc_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/rpc_tests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -36,7 +36,6 @@ UniValue RPCTestingSetup::CallRPC(std::string args)\n     JSONRPCRequest request(context);\n     request.strMethod = strMethod;\n     request.params = RPCConvertValues(strMethod, vArgs);\n-    request.fHelp = false;\n     if (RPCIsInWarmup(nullptr)) SetRPCWarmupFinished();\n     try {\n         UniValue result = tableRPC.execute(request);"
      },
      {
        "sha": "496292875da0ff2c23a8a4a6f90e393727dcfca9",
        "filename": "src/test/sanity_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/sanity_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/sanity_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sanity_tests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -13,7 +13,6 @@ BOOST_FIXTURE_TEST_SUITE(sanity_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(basic_sanity)\n {\n-  BOOST_CHECK_MESSAGE(glibc_sanity_test() == true, \"libc sanity test\");\n   BOOST_CHECK_MESSAGE(glibcxx_sanity_test() == true, \"stdlib sanity test\");\n   BOOST_CHECK_MESSAGE(ECC_InitSanityCheck() == true, \"secp256k1 sanity test\");\n   BOOST_CHECK_MESSAGE(ChronoSanityCheck() == true, \"chrono epoch test\");"
      },
      {
        "sha": "400de875b7b9cd95c626d7a6125430271c4fd618",
        "filename": "src/test/sock_tests.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 0,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/sock_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/sock_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sock_tests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -4,11 +4,13 @@\n \n #include <compat.h>\n #include <test/util/setup_common.h>\n+#include <threadinterrupt.h>\n #include <util/sock.h>\n #include <util/system.h>\n \n #include <boost/test/unit_test.hpp>\n \n+#include <cassert>\n #include <thread>\n \n using namespace std::chrono_literals;\n@@ -144,6 +146,35 @@ BOOST_AUTO_TEST_CASE(wait)\n     waiter.join();\n }\n \n+BOOST_AUTO_TEST_CASE(recv_until_terminator_limit)\n+{\n+    constexpr auto timeout = 1min; // High enough so that it is never hit.\n+    CThreadInterrupt interrupt;\n+    int s[2];\n+    CreateSocketPair(s);\n+\n+    Sock sock_send(s[0]);\n+    Sock sock_recv(s[1]);\n+\n+    std::thread receiver([&sock_recv, &timeout, &interrupt]() {\n+        constexpr size_t max_data{10};\n+        bool threw_as_expected{false};\n+        // BOOST_CHECK_EXCEPTION() writes to some variables shared with the main thread which\n+        // creates a data race. So mimic it manually.\n+        try {\n+            sock_recv.RecvUntilTerminator('\\n', timeout, interrupt, max_data);\n+        } catch (const std::runtime_error& e) {\n+            threw_as_expected = HasReason(\"too many bytes without a terminator\")(e);\n+        }\n+        assert(threw_as_expected);\n+    });\n+\n+    BOOST_REQUIRE_NO_THROW(sock_send.SendComplete(\"1234567\", timeout, interrupt));\n+    BOOST_REQUIRE_NO_THROW(sock_send.SendComplete(\"89a\\n\", timeout, interrupt));\n+\n+    receiver.join();\n+}\n+\n #endif /* WIN32 */\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "66f4efc139f943973c0ddd47bbc68d0d6ef519e5",
        "filename": "src/test/util/logging.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/util/logging.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/util/logging.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/logging.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -7,7 +7,6 @@\n #include <logging.h>\n #include <noui.h>\n #include <tinyformat.h>\n-#include <util/memory.h>\n \n #include <stdexcept>\n "
      },
      {
        "sha": "ba1edba0ae3288d80dbca47d3aaf2a20fbd41e17",
        "filename": "src/test/util/mining.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/util/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/util/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/mining.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -42,7 +42,7 @@ std::shared_ptr<CBlock> PrepareBlock(const NodeContext& node, const CScript& coi\n {\n     auto block = std::make_shared<CBlock>(\n         BlockAssembler{*Assert(node.mempool), Params()}\n-            .CreateNewBlock(coinbase_scriptPubKey)\n+            .CreateNewBlock(::ChainstateActive(), coinbase_scriptPubKey)\n             ->block);\n \n     LOCK(cs_main);"
      },
      {
        "sha": "f866c2a1f91436383484496306fa2635c3f9a7de",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -25,7 +25,6 @@\n #include <script/sigcache.h>\n #include <streams.h>\n #include <txdb.h>\n-#include <util/memory.h>\n #include <util/strencodings.h>\n #include <util/string.h>\n #include <util/time.h>\n@@ -131,7 +130,7 @@ ChainTestingSetup::ChainTestingSetup(const std::string& chainName, const std::ve\n {\n     // We have to run a scheduler thread to prevent ActivateBestChain\n     // from blocking due to queue overrun.\n-    m_node.scheduler = MakeUnique<CScheduler>();\n+    m_node.scheduler = std::make_unique<CScheduler>();\n     m_node.scheduler->m_service_thread = std::thread([&] { TraceThread(\"scheduler\", [&] { m_node.scheduler->serviceQueue(); }); });\n     GetMainSignals().RegisterBackgroundSignalScheduler(*m_node.scheduler);\n \n@@ -188,8 +187,8 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n         throw std::runtime_error(strprintf(\"ActivateBestChain failed. (%s)\", state.ToString()));\n     }\n \n-    m_node.banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n-    m_node.connman = MakeUnique<CConnman>(0x1337, 0x1337); // Deterministic randomness for tests.\n+    m_node.banman = std::make_unique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n+    m_node.connman = std::make_unique<CConnman>(0x1337, 0x1337); // Deterministic randomness for tests.\n     m_node.peerman = PeerManager::make(chainparams, *m_node.connman, m_node.banman.get(),\n                                        *m_node.scheduler, *m_node.chainman, *m_node.mempool,\n                                        false);\n@@ -245,13 +244,13 @@ CBlock TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransa\n {\n     const CChainParams& chainparams = Params();\n     CTxMemPool empty_pool;\n-    CBlock block = BlockAssembler(empty_pool, chainparams).CreateNewBlock(scriptPubKey)->block;\n+    CBlock block = BlockAssembler(empty_pool, chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey)->block;\n \n     Assert(block.vtx.size() == 1);\n     for (const CMutableTransaction& tx : txns) {\n         block.vtx.push_back(MakeTransactionRef(tx));\n     }\n-    RegenerateCommitments(block);\n+    RegenerateCommitments(block, WITH_LOCK(::cs_main, return std::ref(g_chainman.m_blockman)));\n \n     while (!CheckProofOfWork(block.GetHash(), block.nBits, chainparams.GetConsensus())) ++block.nNonce;\n "
      },
      {
        "sha": "5ac09b05db3b13c5cb1095b8c58026631e23f431",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 85,
        "deletions": 23,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -7,7 +7,6 @@\n #include <clientversion.h>\n #include <hash.h> // For Hash()\n #include <key.h>  // For CKey\n-#include <optional.h>\n #include <sync.h>\n #include <test/util/logging.h>\n #include <test/util/setup_common.h>\n@@ -23,6 +22,7 @@\n #include <util/vector.h>\n \n #include <array>\n+#include <optional>\n #include <stdint.h>\n #include <string.h>\n #include <thread>\n@@ -38,6 +38,7 @@\n #include <boost/test/unit_test.hpp>\n \n using namespace std::literals;\n+static const std::string STRING_WITH_EMBEDDED_NULL_CHAR{\"1\"s \"\\0\" \"1\"s};\n \n /* defined in logging.cpp */\n namespace BCLog {\n@@ -71,11 +72,14 @@ BOOST_AUTO_TEST_CASE(util_datadir)\n BOOST_AUTO_TEST_CASE(util_check)\n {\n     // Check that Assert can forward\n-    const std::unique_ptr<int> p_two = Assert(MakeUnique<int>(2));\n+    const std::unique_ptr<int> p_two = Assert(std::make_unique<int>(2));\n     // Check that Assert works on lvalues and rvalues\n     const int two = *Assert(p_two);\n     Assert(two == 2);\n     Assert(true);\n+    // Check that Assume can be used as unary expression\n+    const bool result{Assume(two == 2)};\n+    Assert(result);\n }\n \n BOOST_AUTO_TEST_CASE(util_criticalsection)\n@@ -227,9 +231,9 @@ class CheckValueTest : public TestChain100Setup\n         bool default_int = false;\n         bool default_bool = false;\n         const char* string_value = nullptr;\n-        Optional<int64_t> int_value;\n-        Optional<bool> bool_value;\n-        Optional<std::vector<std::string>> list_value;\n+        std::optional<int64_t> int_value;\n+        std::optional<bool> bool_value;\n+        std::optional<std::vector<std::string>> list_value;\n         const char* error = nullptr;\n \n         explicit Expect(util::SettingsValue s) : setting(std::move(s)) {}\n@@ -1272,7 +1276,7 @@ BOOST_AUTO_TEST_CASE(util_ParseMoney)\n \n     // Parsing strings with embedded NUL characters should fail\n     BOOST_CHECK(!ParseMoney(\"\\0-1\"s, ret));\n-    BOOST_CHECK(!ParseMoney(\"\\0\" \"1\"s, ret));\n+    BOOST_CHECK(!ParseMoney(STRING_WITH_EMBEDDED_NULL_CHAR, ret));\n     BOOST_CHECK(!ParseMoney(\"1\\0\"s, ret));\n }\n \n@@ -1449,10 +1453,7 @@ BOOST_AUTO_TEST_CASE(test_ParseInt32)\n     BOOST_CHECK(!ParseInt32(\"1a\", &n));\n     BOOST_CHECK(!ParseInt32(\"aap\", &n));\n     BOOST_CHECK(!ParseInt32(\"0x1\", &n)); // no hex\n-    BOOST_CHECK(!ParseInt32(\"0x1\", &n)); // no hex\n-    const char test_bytes[] = {'1', 0, '1'};\n-    std::string teststr(test_bytes, sizeof(test_bytes));\n-    BOOST_CHECK(!ParseInt32(teststr, &n)); // no embedded NULs\n+    BOOST_CHECK(!ParseInt32(STRING_WITH_EMBEDDED_NULL_CHAR, &n));\n     // Overflow and underflow\n     BOOST_CHECK(!ParseInt32(\"-2147483649\", nullptr));\n     BOOST_CHECK(!ParseInt32(\"2147483648\", nullptr));\n@@ -1480,16 +1481,84 @@ BOOST_AUTO_TEST_CASE(test_ParseInt64)\n     BOOST_CHECK(!ParseInt64(\"1a\", &n));\n     BOOST_CHECK(!ParseInt64(\"aap\", &n));\n     BOOST_CHECK(!ParseInt64(\"0x1\", &n)); // no hex\n-    const char test_bytes[] = {'1', 0, '1'};\n-    std::string teststr(test_bytes, sizeof(test_bytes));\n-    BOOST_CHECK(!ParseInt64(teststr, &n)); // no embedded NULs\n+    BOOST_CHECK(!ParseInt64(STRING_WITH_EMBEDDED_NULL_CHAR, &n));\n     // Overflow and underflow\n     BOOST_CHECK(!ParseInt64(\"-9223372036854775809\", nullptr));\n     BOOST_CHECK(!ParseInt64(\"9223372036854775808\", nullptr));\n     BOOST_CHECK(!ParseInt64(\"-32482348723847471234\", nullptr));\n     BOOST_CHECK(!ParseInt64(\"32482348723847471234\", nullptr));\n }\n \n+BOOST_AUTO_TEST_CASE(test_ParseUInt8)\n+{\n+    uint8_t n;\n+    // Valid values\n+    BOOST_CHECK(ParseUInt8(\"255\", nullptr));\n+    BOOST_CHECK(ParseUInt8(\"0\", &n) && n == 0);\n+    BOOST_CHECK(ParseUInt8(\"255\", &n) && n == 255);\n+    BOOST_CHECK(ParseUInt8(\"0255\", &n) && n == 255); // no octal\n+    BOOST_CHECK(ParseUInt8(\"255\", &n) && n == static_cast<uint8_t>(255));\n+    BOOST_CHECK(ParseUInt8(\"+255\", &n) && n == 255);\n+    BOOST_CHECK(ParseUInt8(\"00000000000000000012\", &n) && n == 12);\n+    BOOST_CHECK(ParseUInt8(\"00000000000000000000\", &n) && n == 0);\n+    // Invalid values\n+    BOOST_CHECK(!ParseUInt8(\"-00000000000000000000\", &n));\n+    BOOST_CHECK(!ParseUInt8(\"\", &n));\n+    BOOST_CHECK(!ParseUInt8(\" 1\", &n)); // no padding inside\n+    BOOST_CHECK(!ParseUInt8(\" -1\", &n));\n+    BOOST_CHECK(!ParseUInt8(\"++1\", &n));\n+    BOOST_CHECK(!ParseUInt8(\"+-1\", &n));\n+    BOOST_CHECK(!ParseUInt8(\"-+1\", &n));\n+    BOOST_CHECK(!ParseUInt8(\"--1\", &n));\n+    BOOST_CHECK(!ParseUInt8(\"-1\", &n));\n+    BOOST_CHECK(!ParseUInt8(\"1 \", &n));\n+    BOOST_CHECK(!ParseUInt8(\"1a\", &n));\n+    BOOST_CHECK(!ParseUInt8(\"aap\", &n));\n+    BOOST_CHECK(!ParseUInt8(\"0x1\", &n)); // no hex\n+    BOOST_CHECK(!ParseUInt8(STRING_WITH_EMBEDDED_NULL_CHAR, &n));\n+    // Overflow and underflow\n+    BOOST_CHECK(!ParseUInt8(\"-255\", &n));\n+    BOOST_CHECK(!ParseUInt8(\"256\", &n));\n+    BOOST_CHECK(!ParseUInt8(\"-123\", &n));\n+    BOOST_CHECK(!ParseUInt8(\"-123\", nullptr));\n+    BOOST_CHECK(!ParseUInt8(\"256\", nullptr));\n+}\n+\n+BOOST_AUTO_TEST_CASE(test_ParseUInt16)\n+{\n+    uint16_t n;\n+    // Valid values\n+    BOOST_CHECK(ParseUInt16(\"1234\", nullptr));\n+    BOOST_CHECK(ParseUInt16(\"0\", &n) && n == 0);\n+    BOOST_CHECK(ParseUInt16(\"1234\", &n) && n == 1234);\n+    BOOST_CHECK(ParseUInt16(\"01234\", &n) && n == 1234); // no octal\n+    BOOST_CHECK(ParseUInt16(\"65535\", &n) && n == static_cast<uint16_t>(65535));\n+    BOOST_CHECK(ParseUInt16(\"+65535\", &n) && n == 65535);\n+    BOOST_CHECK(ParseUInt16(\"00000000000000000012\", &n) && n == 12);\n+    BOOST_CHECK(ParseUInt16(\"00000000000000000000\", &n) && n == 0);\n+    // Invalid values\n+    BOOST_CHECK(!ParseUInt16(\"-00000000000000000000\", &n));\n+    BOOST_CHECK(!ParseUInt16(\"\", &n));\n+    BOOST_CHECK(!ParseUInt16(\" 1\", &n)); // no padding inside\n+    BOOST_CHECK(!ParseUInt16(\" -1\", &n));\n+    BOOST_CHECK(!ParseUInt16(\"++1\", &n));\n+    BOOST_CHECK(!ParseUInt16(\"+-1\", &n));\n+    BOOST_CHECK(!ParseUInt16(\"-+1\", &n));\n+    BOOST_CHECK(!ParseUInt16(\"--1\", &n));\n+    BOOST_CHECK(!ParseUInt16(\"-1\", &n));\n+    BOOST_CHECK(!ParseUInt16(\"1 \", &n));\n+    BOOST_CHECK(!ParseUInt16(\"1a\", &n));\n+    BOOST_CHECK(!ParseUInt16(\"aap\", &n));\n+    BOOST_CHECK(!ParseUInt16(\"0x1\", &n)); // no hex\n+    BOOST_CHECK(!ParseUInt16(STRING_WITH_EMBEDDED_NULL_CHAR, &n));\n+    // Overflow and underflow\n+    BOOST_CHECK(!ParseUInt16(\"-65535\", &n));\n+    BOOST_CHECK(!ParseUInt16(\"65536\", &n));\n+    BOOST_CHECK(!ParseUInt16(\"-123\", &n));\n+    BOOST_CHECK(!ParseUInt16(\"-123\", nullptr));\n+    BOOST_CHECK(!ParseUInt16(\"65536\", nullptr));\n+}\n+\n BOOST_AUTO_TEST_CASE(test_ParseUInt32)\n {\n     uint32_t n;\n@@ -1518,10 +1587,7 @@ BOOST_AUTO_TEST_CASE(test_ParseUInt32)\n     BOOST_CHECK(!ParseUInt32(\"1a\", &n));\n     BOOST_CHECK(!ParseUInt32(\"aap\", &n));\n     BOOST_CHECK(!ParseUInt32(\"0x1\", &n)); // no hex\n-    BOOST_CHECK(!ParseUInt32(\"0x1\", &n)); // no hex\n-    const char test_bytes[] = {'1', 0, '1'};\n-    std::string teststr(test_bytes, sizeof(test_bytes));\n-    BOOST_CHECK(!ParseUInt32(teststr, &n)); // no embedded NULs\n+    BOOST_CHECK(!ParseUInt32(STRING_WITH_EMBEDDED_NULL_CHAR, &n));\n     // Overflow and underflow\n     BOOST_CHECK(!ParseUInt32(\"-2147483648\", &n));\n     BOOST_CHECK(!ParseUInt32(\"4294967296\", &n));\n@@ -1550,9 +1616,7 @@ BOOST_AUTO_TEST_CASE(test_ParseUInt64)\n     BOOST_CHECK(!ParseUInt64(\"1a\", &n));\n     BOOST_CHECK(!ParseUInt64(\"aap\", &n));\n     BOOST_CHECK(!ParseUInt64(\"0x1\", &n)); // no hex\n-    const char test_bytes[] = {'1', 0, '1'};\n-    std::string teststr(test_bytes, sizeof(test_bytes));\n-    BOOST_CHECK(!ParseUInt64(teststr, &n)); // no embedded NULs\n+    BOOST_CHECK(!ParseUInt64(STRING_WITH_EMBEDDED_NULL_CHAR, &n));\n     // Overflow and underflow\n     BOOST_CHECK(!ParseUInt64(\"-9223372036854775809\", nullptr));\n     BOOST_CHECK(!ParseUInt64(\"18446744073709551616\", nullptr));\n@@ -1582,9 +1646,7 @@ BOOST_AUTO_TEST_CASE(test_ParseDouble)\n     BOOST_CHECK(!ParseDouble(\"1a\", &n));\n     BOOST_CHECK(!ParseDouble(\"aap\", &n));\n     BOOST_CHECK(!ParseDouble(\"0x1\", &n)); // no hex\n-    const char test_bytes[] = {'1', 0, '1'};\n-    std::string teststr(test_bytes, sizeof(test_bytes));\n-    BOOST_CHECK(!ParseDouble(teststr, &n)); // no embedded NULs\n+    BOOST_CHECK(!ParseDouble(STRING_WITH_EMBEDDED_NULL_CHAR, &n));\n     // Overflow and underflow\n     BOOST_CHECK(!ParseDouble(\"-1e10000\", nullptr));\n     BOOST_CHECK(!ParseDouble(\"1e10000\", nullptr));"
      },
      {
        "sha": "f3fc83078f9ac2b2fae4f138ec0e16b00d59e0e5",
        "filename": "src/test/validation_block_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/validation_block_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/validation_block_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_block_tests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -63,7 +63,7 @@ std::shared_ptr<CBlock> MinerTestingSetup::Block(const uint256& prev_hash)\n     static int i = 0;\n     static uint64_t time = Params().GenesisBlock().nTime;\n \n-    auto ptemplate = BlockAssembler(*m_node.mempool, Params()).CreateNewBlock(CScript{} << i++ << OP_TRUE);\n+    auto ptemplate = BlockAssembler(*m_node.mempool, Params()).CreateNewBlock(::ChainstateActive(), CScript{} << i++ << OP_TRUE);\n     auto pblock = std::make_shared<CBlock>(ptemplate->block);\n     pblock->hashPrevBlock = prev_hash;\n     pblock->nTime = ++time;\n@@ -325,7 +325,7 @@ BOOST_AUTO_TEST_CASE(witness_commitment_index)\n {\n     CScript pubKey;\n     pubKey << 1 << OP_TRUE;\n-    auto ptemplate = BlockAssembler(*m_node.mempool, Params()).CreateNewBlock(pubKey);\n+    auto ptemplate = BlockAssembler(*m_node.mempool, Params()).CreateNewBlock(::ChainstateActive(), pubKey);\n     CBlock pblock = ptemplate->block;\n \n     CTxOut witness;"
      },
      {
        "sha": "3a08e28c013b7336edba99fc853ba7683ad90b58",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -10,7 +10,6 @@\n #include <random.h>\n #include <shutdown.h>\n #include <uint256.h>\n-#include <util/memory.h>\n #include <util/system.h>\n #include <util/translation.h>\n #include <util/vector.h>\n@@ -41,7 +40,7 @@ struct CoinEntry {\n }\n \n CCoinsViewDB::CCoinsViewDB(fs::path ldb_path, size_t nCacheSize, bool fMemory, bool fWipe) :\n-    m_db(MakeUnique<CDBWrapper>(ldb_path, nCacheSize, fMemory, fWipe, true)),\n+    m_db(std::make_unique<CDBWrapper>(ldb_path, nCacheSize, fMemory, fWipe, true)),\n     m_ldb_path(ldb_path),\n     m_is_memory(fMemory) { }\n \n@@ -53,7 +52,7 @@ void CCoinsViewDB::ResizeCache(size_t new_cache_size)\n         // Have to do a reset first to get the original `m_db` state to release its\n         // filesystem lock.\n         m_db.reset();\n-        m_db = MakeUnique<CDBWrapper>(\n+        m_db = std::make_unique<CDBWrapper>(\n             m_ldb_path, new_cache_size, m_is_memory, /*fWipe*/ false, /*obfuscate*/ true);\n     }\n }"
      },
      {
        "sha": "67549fc13d4de56381a9bbc386fb592b4b4551b7",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -8,7 +8,6 @@\n #include <consensus/consensus.h>\n #include <consensus/tx_verify.h>\n #include <consensus/validation.h>\n-#include <optional.h>\n #include <policy/fees.h>\n #include <policy/policy.h>\n #include <policy/settings.h>\n@@ -19,6 +18,8 @@\n #include <validation.h>\n #include <validationinterface.h>\n \n+#include <optional>\n+\n CTxMemPoolEntry::CTxMemPoolEntry(const CTransactionRef& _tx, const CAmount& _nFee,\n                                  int64_t _nTime, unsigned int _entryHeight,\n                                  bool _spendsCoinbase, int64_t _sigOpsCost, LockPoints lp)\n@@ -159,7 +160,7 @@ bool CTxMemPool::CalculateMemPoolAncestors(const CTxMemPoolEntry &entry, setEntr\n         // GetMemPoolParents() is only valid for entries in the mempool, so we\n         // iterate mapTx to find parents.\n         for (unsigned int i = 0; i < tx.vin.size(); i++) {\n-            Optional<txiter> piter = GetIter(tx.vin[i].prevout.hash);\n+            std::optional<txiter> piter = GetIter(tx.vin[i].prevout.hash);\n             if (piter) {\n                 staged_ancestors.insert(**piter);\n                 if (staged_ancestors.size() + 1 > limitAncestorCount) {\n@@ -890,11 +891,11 @@ const CTransaction* CTxMemPool::GetConflictTx(const COutPoint& prevout) const\n     return it == mapNextTx.end() ? nullptr : it->second;\n }\n \n-Optional<CTxMemPool::txiter> CTxMemPool::GetIter(const uint256& txid) const\n+std::optional<CTxMemPool::txiter> CTxMemPool::GetIter(const uint256& txid) const\n {\n     auto it = mapTx.find(txid);\n     if (it != mapTx.end()) return it;\n-    return Optional<txiter>{};\n+    return std::nullopt;\n }\n \n CTxMemPool::setEntries CTxMemPool::GetIterSet(const std::set<uint256>& hashes) const"
      },
      {
        "sha": "c3a9bd851d5f2a5bd46588fbcb204fdd7161e836",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -8,6 +8,7 @@\n \n #include <atomic>\n #include <map>\n+#include <optional>\n #include <set>\n #include <string>\n #include <utility>\n@@ -16,7 +17,6 @@\n #include <amount.h>\n #include <coins.h>\n #include <indirectmap.h>\n-#include <optional.h>\n #include <policy/feerate.h>\n #include <primitives/transaction.h>\n #include <random.h>\n@@ -476,7 +476,7 @@ enum class MemPoolRemovalReason {\n  */\n class CTxMemPool\n {\n-private:\n+protected:\n     const int m_check_ratio; //!< Value n means that 1 times in n we check.\n     std::atomic<unsigned int> nTransactionsUpdated{0}; //!< Used by getblocktemplate to trigger CreateNewBlock() invocation\n     CBlockPolicyEstimator* minerPolicyEstimator;\n@@ -644,7 +644,7 @@ class CTxMemPool\n     const CTransaction* GetConflictTx(const COutPoint& prevout) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     /** Returns an iterator to the given hash, if found */\n-    Optional<txiter> GetIter(const uint256& txid) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    std::optional<txiter> GetIter(const uint256& txid) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     /** Translate a set of hashes into a set of pool iterators to avoid repeated lookups */\n     setEntries GetIterSet(const std::set<uint256>& hashes) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n@@ -841,7 +841,7 @@ class CTxMemPool\n         return m_epoch.visited(it->m_epoch_marker);\n     }\n \n-    bool visited(Optional<txiter> it) const EXCLUSIVE_LOCKS_REQUIRED(cs, m_epoch)\n+    bool visited(std::optional<txiter> it) const EXCLUSIVE_LOCKS_REQUIRED(cs, m_epoch)\n     {\n         assert(m_epoch.guarded()); // verify guard even when it==nullopt\n         return !it || visited(*it);"
      },
      {
        "sha": "58424134b0259a8dcea34f5615afcae1d7e0b3f9",
        "filename": "src/txrequest.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/txrequest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/txrequest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txrequest.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -9,7 +9,6 @@\n #include <primitives/transaction.h>\n #include <random.h>\n #include <uint256.h>\n-#include <util/memory.h>\n \n #include <boost/multi_index_container.hpp>\n #include <boost/multi_index/ordered_index.hpp>\n@@ -711,7 +710,7 @@ class TxRequestTracker::Impl {\n };\n \n TxRequestTracker::TxRequestTracker(bool deterministic) :\n-    m_impl{MakeUnique<TxRequestTracker::Impl>(deterministic)} {}\n+    m_impl{std::make_unique<TxRequestTracker::Impl>(deterministic)} {}\n \n TxRequestTracker::~TxRequestTracker() = default;\n "
      },
      {
        "sha": "e60088a2c6bc7ea886dac021157ba4ed10555e38",
        "filename": "src/util/check.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/util/check.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/util/check.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/check.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -69,7 +69,7 @@ T get_pure_r_value(T&& val)\n #ifdef ABORT_ON_FAILED_ASSUME\n #define Assume(val) Assert(val)\n #else\n-#define Assume(val) ((void)(val))\n+#define Assume(val) ([&]() -> decltype(get_pure_r_value(val)) { auto&& check = (val); return std::forward<decltype(get_pure_r_value(val))>(check); }())\n #endif\n \n #endif // BITCOIN_UTIL_CHECK_H"
      },
      {
        "sha": "f21b81bade23ff11520e121622c7fa146821f24b",
        "filename": "src/util/memory.h",
        "status": "removed",
        "additions": 0,
        "deletions": 20,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/src/util/memory.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05/src/util/memory.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/memory.h?ref=1a4a9305c2d25eafa5ad5365b4daa2bd15fc6e05",
        "patch": "@@ -1,20 +0,0 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2020 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_UTIL_MEMORY_H\n-#define BITCOIN_UTIL_MEMORY_H\n-\n-#include <memory>\n-#include <utility>\n-\n-//! Substitute for C++14 std::make_unique.\n-//! DEPRECATED use std::make_unique in new code.\n-template <typename T, typename... Args>\n-std::unique_ptr<T> MakeUnique(Args&&... args)\n-{\n-    return std::make_unique<T>(std::forward<Args>(args)...);\n-}\n-\n-#endif"
      },
      {
        "sha": "f9ecfef5d449df4c618bac2497b8a5ea38055e40",
        "filename": "src/util/sock.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/util/sock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/util/sock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/sock.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -175,7 +175,8 @@ void Sock::SendComplete(const std::string& data,\n \n std::string Sock::RecvUntilTerminator(uint8_t terminator,\n                                       std::chrono::milliseconds timeout,\n-                                      CThreadInterrupt& interrupt) const\n+                                      CThreadInterrupt& interrupt,\n+                                      size_t max_data) const\n {\n     const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n     std::string data;\n@@ -190,9 +191,14 @@ std::string Sock::RecvUntilTerminator(uint8_t terminator,\n     // at a time is about 50 times slower.\n \n     for (;;) {\n+        if (data.size() >= max_data) {\n+            throw std::runtime_error(\n+                strprintf(\"Received too many bytes without a terminator (%u)\", data.size()));\n+        }\n+\n         char buf[512];\n \n-        const ssize_t peek_ret{Recv(buf, sizeof(buf), MSG_PEEK)};\n+        const ssize_t peek_ret{Recv(buf, std::min(sizeof(buf), max_data - data.size()), MSG_PEEK)};\n \n         switch (peek_ret) {\n         case -1: {"
      },
      {
        "sha": "4b0618dcffdd22ee6c349c178c2c143e435f81e4",
        "filename": "src/util/sock.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/util/sock.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/util/sock.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/sock.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -135,13 +135,16 @@ class Sock\n      * @param[in] terminator Character up to which to read from the socket.\n      * @param[in] timeout Timeout for the entire operation.\n      * @param[in] interrupt If this is signaled then the operation is canceled.\n+     * @param[in] max_data The maximum amount of data (in bytes) to receive. If this many bytes\n+     * are received and there is still no terminator, then this method will throw an exception.\n      * @return The data that has been read, without the terminating character.\n      * @throws std::runtime_error if the operation cannot be completed. In this case some bytes may\n      * have been consumed from the socket.\n      */\n     virtual std::string RecvUntilTerminator(uint8_t terminator,\n                                             std::chrono::milliseconds timeout,\n-                                            CThreadInterrupt& interrupt) const;\n+                                            CThreadInterrupt& interrupt,\n+                                            size_t max_data) const;\n \n     /**\n      * Check if still connected."
      },
      {
        "sha": "4734de3e0b457a48a195508c48817f14d6db218c",
        "filename": "src/util/strencodings.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 9,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/util/strencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/util/strencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/strencodings.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -107,23 +107,25 @@ std::vector<unsigned char> ParseHex(const std::string& str)\n     return ParseHex(str.c_str());\n }\n \n-void SplitHostPort(std::string in, int &portOut, std::string &hostOut) {\n+void SplitHostPort(std::string in, uint16_t& portOut, std::string& hostOut)\n+{\n     size_t colon = in.find_last_of(':');\n     // if a : is found, and it either follows a [...], or no other : is in the string, treat it as port separator\n     bool fHaveColon = colon != in.npos;\n-    bool fBracketed = fHaveColon && (in[0]=='[' && in[colon-1]==']'); // if there is a colon, and in[0]=='[', colon is not 0, so in[colon-1] is safe\n-    bool fMultiColon = fHaveColon && (in.find_last_of(':',colon-1) != in.npos);\n-    if (fHaveColon && (colon==0 || fBracketed || !fMultiColon)) {\n-        int32_t n;\n-        if (ParseInt32(in.substr(colon + 1), &n) && n > 0 && n < 0x10000) {\n+    bool fBracketed = fHaveColon && (in[0] == '[' && in[colon - 1] == ']'); // if there is a colon, and in[0]=='[', colon is not 0, so in[colon-1] is safe\n+    bool fMultiColon = fHaveColon && (in.find_last_of(':', colon - 1) != in.npos);\n+    if (fHaveColon && (colon == 0 || fBracketed || !fMultiColon)) {\n+        uint16_t n;\n+        if (ParseUInt16(in.substr(colon + 1), &n)) {\n             in = in.substr(0, colon);\n             portOut = n;\n         }\n     }\n-    if (in.size()>0 && in[0] == '[' && in[in.size()-1] == ']')\n-        hostOut = in.substr(1, in.size()-2);\n-    else\n+    if (in.size() > 0 && in[0] == '[' && in[in.size() - 1] == ']') {\n+        hostOut = in.substr(1, in.size() - 2);\n+    } else {\n         hostOut = in;\n+    }\n }\n \n std::string EncodeBase64(Span<const unsigned char> input)\n@@ -334,6 +336,18 @@ bool ParseUInt8(const std::string& str, uint8_t *out)\n     return true;\n }\n \n+bool ParseUInt16(const std::string& str, uint16_t* out)\n+{\n+    uint32_t u32;\n+    if (!ParseUInt32(str, &u32) || u32 > std::numeric_limits<uint16_t>::max()) {\n+        return false;\n+    }\n+    if (out != nullptr) {\n+        *out = static_cast<uint16_t>(u32);\n+    }\n+    return true;\n+}\n+\n bool ParseUInt32(const std::string& str, uint32_t *out)\n {\n     if (!ParsePrechecks(str))"
      },
      {
        "sha": "26dc0a0ce32600fadb0b7bf9c89afe51ed9f6eea",
        "filename": "src/util/strencodings.h",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/util/strencodings.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/util/strencodings.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/strencodings.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -65,7 +65,7 @@ std::string EncodeBase32(Span<const unsigned char> input, bool pad = true);\n  */\n std::string EncodeBase32(const std::string& str, bool pad = true);\n \n-void SplitHostPort(std::string in, int& portOut, std::string& hostOut);\n+void SplitHostPort(std::string in, uint16_t& portOut, std::string& hostOut);\n int64_t atoi64(const std::string& str);\n int atoi(const std::string& str);\n \n@@ -115,6 +115,13 @@ constexpr inline bool IsSpace(char c) noexcept {\n  */\n [[nodiscard]] bool ParseUInt8(const std::string& str, uint8_t *out);\n \n+/**\n+ * Convert decimal string to unsigned 16-bit integer with strict parse error feedback.\n+ * @returns true if the entire string could be parsed as valid integer,\n+ *   false if the entire string could not be parsed or if overflow or underflow occurred.\n+ */\n+[[nodiscard]] bool ParseUInt16(const std::string& str, uint16_t* out);\n+\n /**\n  * Convert decimal string to unsigned 32-bit integer with strict parse error feedback.\n  * @returns true if the entire string could be parsed as valid integer,"
      },
      {
        "sha": "0b83a76504ad88b93dbe66f43b7367720087b5f1",
        "filename": "src/util/system.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/util/system.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/util/system.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/system.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -100,7 +100,7 @@ bool LockDirectory(const fs::path& directory, const std::string lockfile_name, b\n     // Create empty lock file if it doesn't exist.\n     FILE* file = fsbridge::fopen(pathLockFile, \"a\");\n     if (file) fclose(file);\n-    auto lock = MakeUnique<fsbridge::FileLock>(pathLockFile);\n+    auto lock = std::make_unique<fsbridge::FileLock>(pathLockFile);\n     if (!lock->TryLock()) {\n         return error(\"Error while attempting to lock directory %s: %s\", directory.string(), lock->GetReason());\n     }\n@@ -315,7 +315,7 @@ bool ArgsManager::ParseParameters(int argc, const char* const argv[], std::strin\n         if (key[0] != '-') {\n             if (!m_accept_any_command && m_command.empty()) {\n                 // The first non-dash arg is a registered command\n-                Optional<unsigned int> flags = GetArgFlags(key);\n+                std::optional<unsigned int> flags = GetArgFlags(key);\n                 if (!flags || !(*flags & ArgsManager::COMMAND)) {\n                     error = strprintf(\"Invalid command '%s'\", argv[i]);\n                     return false;\n@@ -337,7 +337,7 @@ bool ArgsManager::ParseParameters(int argc, const char* const argv[], std::strin\n         key.erase(0, 1);\n         std::string section;\n         util::SettingsValue value = InterpretOption(section, key, val);\n-        Optional<unsigned int> flags = GetArgFlags('-' + key);\n+        std::optional<unsigned int> flags = GetArgFlags('-' + key);\n \n         // Unknown command line options and command line options with dot\n         // characters (which are returned from InterpretOption with nonempty\n@@ -363,7 +363,7 @@ bool ArgsManager::ParseParameters(int argc, const char* const argv[], std::strin\n     return success;\n }\n \n-Optional<unsigned int> ArgsManager::GetArgFlags(const std::string& name) const\n+std::optional<unsigned int> ArgsManager::GetArgFlags(const std::string& name) const\n {\n     LOCK(cs_args);\n     for (const auto& arg_map : m_available_args) {\n@@ -372,7 +372,7 @@ Optional<unsigned int> ArgsManager::GetArgFlags(const std::string& name) const\n             return search->second.m_flags;\n         }\n     }\n-    return nullopt;\n+    return std::nullopt;\n }\n \n std::optional<const ArgsManager::Command> ArgsManager::GetCommand() const\n@@ -874,7 +874,7 @@ bool ArgsManager::ReadConfigStream(std::istream& stream, const std::string& file\n         std::string section;\n         std::string key = option.first;\n         util::SettingsValue value = InterpretOption(section, key, option.second);\n-        Optional<unsigned int> flags = GetArgFlags('-' + key);\n+        std::optional<unsigned int> flags = GetArgFlags('-' + key);\n         if (flags) {\n             if (!CheckValid(key, value, *flags, error)) {\n                 return false;\n@@ -1034,7 +1034,7 @@ void ArgsManager::logArgsPrefix(\n     std::string section_str = section.empty() ? \"\" : \"[\" + section + \"] \";\n     for (const auto& arg : args) {\n         for (const auto& value : arg.second) {\n-            Optional<unsigned int> flags = GetArgFlags('-' + arg.first);\n+            std::optional<unsigned int> flags = GetArgFlags('-' + arg.first);\n             if (flags) {\n                 std::string value_str = (*flags & SENSITIVE) ? \"****\" : value.write();\n                 LogPrintf(\"%s %s%s=%s\\n\", prefix, section_str, arg.first, value_str);"
      },
      {
        "sha": "291f3f5541374bc210082ac05beda6736efd0f2c",
        "filename": "src/util/system.h",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/util/system.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/util/system.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/system.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -19,16 +19,15 @@\n #include <compat/assumptions.h>\n #include <fs.h>\n #include <logging.h>\n-#include <optional.h>\n #include <sync.h>\n #include <tinyformat.h>\n-#include <util/memory.h>\n #include <util/settings.h>\n #include <util/threadnames.h>\n #include <util/time.h>\n \n #include <exception>\n #include <map>\n+#include <optional>\n #include <set>\n #include <stdint.h>\n #include <string>\n@@ -376,7 +375,7 @@ class ArgsManager\n      * Return Flags for known arg.\n      * Return nullopt for unknown arg.\n      */\n-    Optional<unsigned int> GetArgFlags(const std::string& name) const;\n+    std::optional<unsigned int> GetArgFlags(const std::string& name) const;\n \n     /**\n      * Read and update settings file with saved settings. This needs to be"
      },
      {
        "sha": "4c091cd2e69e82ab58952538cca510a409dcf32b",
        "filename": "src/util/tokenpipe.cpp",
        "status": "added",
        "additions": 109,
        "deletions": 0,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/util/tokenpipe.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/util/tokenpipe.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/tokenpipe.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -0,0 +1,109 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <util/tokenpipe.h>\n+\n+#include <config/bitcoin-config.h>\n+\n+#ifndef WIN32\n+\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <optional>\n+#include <unistd.h>\n+\n+TokenPipeEnd TokenPipe::TakeReadEnd()\n+{\n+    TokenPipeEnd res(m_fds[0]);\n+    m_fds[0] = -1;\n+    return res;\n+}\n+\n+TokenPipeEnd TokenPipe::TakeWriteEnd()\n+{\n+    TokenPipeEnd res(m_fds[1]);\n+    m_fds[1] = -1;\n+    return res;\n+}\n+\n+TokenPipeEnd::TokenPipeEnd(int fd) : m_fd(fd)\n+{\n+}\n+\n+TokenPipeEnd::~TokenPipeEnd()\n+{\n+    Close();\n+}\n+\n+int TokenPipeEnd::TokenWrite(uint8_t token)\n+{\n+    while (true) {\n+        ssize_t result = write(m_fd, &token, 1);\n+        if (result < 0) {\n+            // Failure. It's possible that the write was interrupted by a signal,\n+            // in that case retry.\n+            if (errno != EINTR) {\n+                return TS_ERR;\n+            }\n+        } else if (result == 0) {\n+            return TS_EOS;\n+        } else { // ==1\n+            return 0;\n+        }\n+    }\n+}\n+\n+int TokenPipeEnd::TokenRead()\n+{\n+    uint8_t token;\n+    while (true) {\n+        ssize_t result = read(m_fd, &token, 1);\n+        if (result < 0) {\n+            // Failure. Check if the read was interrupted by a signal,\n+            // in that case retry.\n+            if (errno != EINTR) {\n+                return TS_ERR;\n+            }\n+        } else if (result == 0) {\n+            return TS_EOS;\n+        } else { // ==1\n+            return token;\n+        }\n+    }\n+    return token;\n+}\n+\n+void TokenPipeEnd::Close()\n+{\n+    if (m_fd != -1) close(m_fd);\n+    m_fd = -1;\n+}\n+\n+std::optional<TokenPipe> TokenPipe::Make()\n+{\n+    int fds[2] = {-1, -1};\n+#if HAVE_O_CLOEXEC && HAVE_DECL_PIPE2\n+    if (pipe2(fds, O_CLOEXEC) != 0) {\n+        return std::nullopt;\n+    }\n+#else\n+    if (pipe(fds) != 0) {\n+        return std::nullopt;\n+    }\n+#endif\n+    return TokenPipe(fds);\n+}\n+\n+TokenPipe::~TokenPipe()\n+{\n+    Close();\n+}\n+\n+void TokenPipe::Close()\n+{\n+    if (m_fds[0] != -1) close(m_fds[0]);\n+    if (m_fds[1] != -1) close(m_fds[1]);\n+    m_fds[0] = m_fds[1] = -1;\n+}\n+\n+#endif // WIN32"
      },
      {
        "sha": "f56be93a38c93875ba4ca2dcb5ba0234a402b8b8",
        "filename": "src/util/tokenpipe.h",
        "status": "added",
        "additions": 127,
        "deletions": 0,
        "changes": 127,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/util/tokenpipe.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/util/tokenpipe.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/tokenpipe.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -0,0 +1,127 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_TOKENPIPE_H\n+#define BITCOIN_UTIL_TOKENPIPE_H\n+\n+#ifndef WIN32\n+\n+#include <cstdint>\n+#include <optional>\n+\n+/** One end of a token pipe. */\n+class TokenPipeEnd\n+{\n+private:\n+    int m_fd = -1;\n+\n+public:\n+    TokenPipeEnd(int fd = -1);\n+    ~TokenPipeEnd();\n+\n+    /** Return value constants for TokenWrite and TokenRead. */\n+    enum Status {\n+        TS_ERR = -1, //!< I/O error\n+        TS_EOS = -2, //!< Unexpected end of stream\n+    };\n+\n+    /** Write token to endpoint.\n+     *\n+     * @returns 0       If successful.\n+     *          <0 if error:\n+     *            TS_ERR  If an error happened.\n+     *            TS_EOS  If end of stream happened.\n+     */\n+    int TokenWrite(uint8_t token);\n+\n+    /** Read token from endpoint.\n+     *\n+     * @returns >=0     Token value, if successful.\n+     *          <0 if error:\n+     *            TS_ERR  If an error happened.\n+     *            TS_EOS  If end of stream happened.\n+     */\n+    int TokenRead();\n+\n+    /** Explicit close function.\n+     */\n+    void Close();\n+\n+    /** Return whether endpoint is open.\n+     */\n+    bool IsOpen() { return m_fd != -1; }\n+\n+    // Move-only class.\n+    TokenPipeEnd(TokenPipeEnd&& other)\n+    {\n+        m_fd = other.m_fd;\n+        other.m_fd = -1;\n+    }\n+    TokenPipeEnd& operator=(TokenPipeEnd&& other)\n+    {\n+        Close();\n+        m_fd = other.m_fd;\n+        other.m_fd = -1;\n+        return *this;\n+    }\n+    TokenPipeEnd(const TokenPipeEnd&) = delete;\n+    TokenPipeEnd& operator=(const TokenPipeEnd&) = delete;\n+};\n+\n+/** An interprocess or interthread pipe for sending tokens (one-byte values)\n+ * over.\n+ */\n+class TokenPipe\n+{\n+private:\n+    int m_fds[2] = {-1, -1};\n+\n+    TokenPipe(int fds[2]) : m_fds{fds[0], fds[1]} {}\n+\n+public:\n+    ~TokenPipe();\n+\n+    /** Create a new pipe.\n+     * @returns The created TokenPipe, or an empty std::nullopt in case of error.\n+     */\n+    static std::optional<TokenPipe> Make();\n+\n+    /** Take the read end of this pipe. This can only be called once,\n+     * as the object will be moved out.\n+     */\n+    TokenPipeEnd TakeReadEnd();\n+\n+    /** Take the write end of this pipe. This should only be called once,\n+     * as the object will be moved out.\n+     */\n+    TokenPipeEnd TakeWriteEnd();\n+\n+    /** Close and end of the pipe that hasn't been moved out.\n+     */\n+    void Close();\n+\n+    // Move-only class.\n+    TokenPipe(TokenPipe&& other)\n+    {\n+        for (int i = 0; i < 2; ++i) {\n+            m_fds[i] = other.m_fds[i];\n+            other.m_fds[i] = -1;\n+        }\n+    }\n+    TokenPipe& operator=(TokenPipe&& other)\n+    {\n+        Close();\n+        for (int i = 0; i < 2; ++i) {\n+            m_fds[i] = other.m_fds[i];\n+            other.m_fds[i] = -1;\n+        }\n+        return *this;\n+    }\n+    TokenPipe(const TokenPipe&) = delete;\n+    TokenPipe& operator=(const TokenPipe&) = delete;\n+};\n+\n+#endif // WIN32\n+\n+#endif // BITCOIN_UTIL_TOKENPIPE_H"
      },
      {
        "sha": "d1b9efe7bac91c0ebe6cd96bdd51aaf541f84b18",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 12,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -23,7 +23,6 @@\n #include <logging/timer.h>\n #include <node/coinstats.h>\n #include <node/ui_interface.h>\n-#include <optional.h>\n #include <policy/policy.h>\n #include <policy/settings.h>\n #include <pow.h>\n@@ -50,6 +49,7 @@\n #include <validationinterface.h>\n #include <warnings.h>\n \n+#include <optional>\n #include <string>\n \n #include <boost/algorithm/string/replace.hpp>\n@@ -1287,7 +1287,7 @@ CoinsViews::CoinsViews(\n \n void CoinsViews::InitCache()\n {\n-    m_cacheview = MakeUnique<CCoinsViewCache>(&m_catcherview);\n+    m_cacheview = std::make_unique<CCoinsViewCache>(&m_catcherview);\n }\n \n CChainState::CChainState(CTxMemPool& mempool, BlockManager& blockman, uint256 from_snapshot_blockhash)\n@@ -1305,7 +1305,7 @@ void CChainState::InitCoinsDB(\n         leveldb_name += \"_\" + m_from_snapshot_blockhash.ToString();\n     }\n \n-    m_coins_views = MakeUnique<CoinsViews>(\n+    m_coins_views = std::make_unique<CoinsViews>(\n         leveldb_name, cache_size_bytes, in_memory, should_wipe);\n }\n \n@@ -2974,6 +2974,10 @@ bool CChainState::PreciousBlock(BlockValidationState& state, const CChainParams&\n \n bool CChainState::InvalidateBlock(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex *pindex)\n {\n+    // Genesis block can't be invalidated\n+    assert(pindex);\n+    if (pindex->nHeight == 0) return false;\n+\n     CBlockIndex* to_mark_failed = pindex;\n     bool pindex_was_in_chain = false;\n     int disconnected = 0;\n@@ -5010,11 +5014,11 @@ CBlockFileInfo* GetBlockFileInfo(size_t n)\n \n static const uint64_t MEMPOOL_DUMP_VERSION = 1;\n \n-bool LoadMempool(CTxMemPool& pool, CChainState& active_chainstate)\n+bool LoadMempool(CTxMemPool& pool, CChainState& active_chainstate, FopenFn mockable_fopen_function)\n {\n     const CChainParams& chainparams = Params();\n     int64_t nExpiryTimeout = gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60;\n-    FILE* filestr = fsbridge::fopen(GetDataDir() / \"mempool.dat\", \"rb\");\n+    FILE* filestr{mockable_fopen_function(GetDataDir() / \"mempool.dat\", \"rb\")};\n     CAutoFile file(filestr, SER_DISK, CLIENT_VERSION);\n     if (file.IsNull()) {\n         LogPrintf(\"Failed to open mempool file from disk. Continuing anyway.\\n\");\n@@ -5095,7 +5099,7 @@ bool LoadMempool(CTxMemPool& pool, CChainState& active_chainstate)\n     return true;\n }\n \n-bool DumpMempool(const CTxMemPool& pool)\n+bool DumpMempool(const CTxMemPool& pool, FopenFn mockable_fopen_function, bool skip_file_commit)\n {\n     int64_t start = GetTimeMicros();\n \n@@ -5118,7 +5122,7 @@ bool DumpMempool(const CTxMemPool& pool)\n     int64_t mid = GetTimeMicros();\n \n     try {\n-        FILE* filestr = fsbridge::fopen(GetDataDir() / \"mempool.dat.new\", \"wb\");\n+        FILE* filestr{mockable_fopen_function(GetDataDir() / \"mempool.dat.new\", \"wb\")};\n         if (!filestr) {\n             return false;\n         }\n@@ -5141,7 +5145,7 @@ bool DumpMempool(const CTxMemPool& pool)\n         LogPrintf(\"Writing %d unbroadcast transactions to disk.\\n\", unbroadcast_txids.size());\n         file << unbroadcast_txids;\n \n-        if (!FileCommit(file.Get()))\n+        if (!skip_file_commit && !FileCommit(file.Get()))\n             throw std::runtime_error(\"FileCommit failed\");\n         file.fclose();\n         if (!RenameOver(GetDataDir() / \"mempool.dat.new\", GetDataDir() / \"mempool.dat\")) {\n@@ -5175,14 +5179,14 @@ double GuessVerificationProgress(const ChainTxData& data, const CBlockIndex *pin\n     return std::min<double>(pindex->nChainTx / fTxTotal, 1.0);\n }\n \n-Optional<uint256> ChainstateManager::SnapshotBlockhash() const {\n+std::optional<uint256> ChainstateManager::SnapshotBlockhash() const {\n     LOCK(::cs_main);\n     if (m_active_chainstate != nullptr &&\n             !m_active_chainstate->m_from_snapshot_blockhash.IsNull()) {\n         // If a snapshot chainstate exists, it will always be our active.\n         return m_active_chainstate->m_from_snapshot_blockhash;\n     }\n-    return {};\n+    return std::nullopt;\n }\n \n std::vector<CChainState*> ChainstateManager::GetAll()\n@@ -5279,7 +5283,7 @@ bool ChainstateManager::ActivateSnapshot(\n             static_cast<size_t>(current_coinsdb_cache_size * IBD_CACHE_PERC));\n     }\n \n-    auto snapshot_chainstate = WITH_LOCK(::cs_main, return MakeUnique<CChainState>(\n+    auto snapshot_chainstate = WITH_LOCK(::cs_main, return std::make_unique<CChainState>(\n             this->ActiveChainstate().m_mempool, m_blockman, base_blockhash));\n \n     {\n@@ -5425,7 +5429,7 @@ bool ChainstateManager::PopulateAndValidateSnapshot(\n     // about the snapshot_chainstate.\n     CCoinsViewDB* snapshot_coinsdb = WITH_LOCK(::cs_main, return &snapshot_chainstate.CoinsDB());\n \n-    if (!GetUTXOStats(snapshot_coinsdb, stats, CoinStatsHashType::HASH_SERIALIZED, breakpoint_fnc)) {\n+    if (!GetUTXOStats(snapshot_coinsdb, WITH_LOCK(::cs_main, return std::ref(m_blockman)), stats, CoinStatsHashType::HASH_SERIALIZED, breakpoint_fnc)) {\n         LogPrintf(\"[snapshot] failed to generate coins stats\\n\");\n         return false;\n     }"
      },
      {
        "sha": "2ff5f4ac87da0ddb14140132529487288420c8d7",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -17,7 +17,6 @@\n #include <crypto/common.h> // for ReadLE64\n #include <fs.h>\n #include <node/utxo_snapshot.h>\n-#include <optional.h>\n #include <policy/feerate.h>\n #include <protocol.h> // For CMessageHeader::MessageStartChars\n #include <script/script_error.h>\n@@ -32,6 +31,7 @@\n #include <atomic>\n #include <map>\n #include <memory>\n+#include <optional>\n #include <set>\n #include <stdint.h>\n #include <string>\n@@ -148,8 +148,6 @@ extern const std::vector<std::string> CHECKLEVEL_DOC;\n FILE* OpenBlockFile(const FlatFilePos &pos, bool fReadOnly = false);\n /** Translation to a filesystem path */\n fs::path GetBlockPosFilename(const FlatFilePos &pos);\n-/** Ensures we have a genesis block in the block tree, possibly writing one to disk. */\n-bool LoadGenesisBlock(const CChainParams& chainparams);\n /** Unload database information */\n void UnloadBlockIndex(CTxMemPool* mempool, ChainstateManager& chainman);\n /** Run instances of script checking worker threads */\n@@ -207,8 +205,7 @@ struct MempoolAcceptResult {\n \n     /** Constructor for failure case */\n     explicit MempoolAcceptResult(TxValidationState state)\n-        : m_result_type(ResultType::INVALID),\n-        m_state(state), m_replaced_transactions(nullopt), m_base_fees(nullopt) {\n+        : m_result_type(ResultType::INVALID), m_state(state) {\n             Assume(!state.IsValid()); // Can be invalid or error\n         }\n \n@@ -725,6 +722,7 @@ class CChainState\n     /** Replay blocks that aren't fully applied to the database. */\n     bool ReplayBlocks(const CChainParams& params);\n     bool RewindBlockIndex(const CChainParams& params) LOCKS_EXCLUDED(cs_main);\n+    /** Ensures we have a genesis block in the block tree, possibly writing one to disk. */\n     bool LoadGenesisBlock(const CChainParams& chainparams);\n \n     void PruneBlockIndexCandidates();\n@@ -925,7 +923,7 @@ class ChainstateManager\n \n     bool IsSnapshotActive() const;\n \n-    Optional<uint256> SnapshotBlockhash() const;\n+    std::optional<uint256> SnapshotBlockhash() const;\n \n     //! Is there a snapshot in use and has it been fully validated?\n     bool IsSnapshotValidated() const { return m_snapshot_validated; }\n@@ -1014,11 +1012,13 @@ int32_t ComputeBlockVersion(const CBlockIndex* pindexPrev, const Consensus::Para\n /** Get block file info entry for one block file */\n CBlockFileInfo* GetBlockFileInfo(size_t n);\n \n+using FopenFn = std::function<FILE*(const fs::path&, const char*)>;\n+\n /** Dump the mempool to disk. */\n-bool DumpMempool(const CTxMemPool& pool);\n+bool DumpMempool(const CTxMemPool& pool, FopenFn mockable_fopen_function = fsbridge::fopen, bool skip_file_commit = false);\n \n /** Load the mempool from disk. */\n-bool LoadMempool(CTxMemPool& pool, CChainState& active_chainstate);\n+bool LoadMempool(CTxMemPool& pool, CChainState& active_chainstate, FopenFn mockable_fopen_function = fsbridge::fopen);\n \n //! Check whether the block associated with this index entry is pruned or not.\n inline bool IsBlockPruned(const CBlockIndex* pblockindex)"
      },
      {
        "sha": "1dc23374e319e0b1bee76b16979ef3c6986d9499",
        "filename": "src/wallet/bdb.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/bdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/bdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/bdb.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -331,7 +331,7 @@ void BerkeleyDatabase::Open()\n \n         if (m_db == nullptr) {\n             int ret;\n-            std::unique_ptr<Db> pdb_temp = MakeUnique<Db>(env->dbenv.get(), 0);\n+            std::unique_ptr<Db> pdb_temp = std::make_unique<Db>(env->dbenv.get(), 0);\n \n             bool fMockDb = env->IsMock();\n             if (fMockDb) {\n@@ -462,7 +462,7 @@ bool BerkeleyDatabase::Rewrite(const char* pszSkip)\n                 std::string strFileRes = strFile + \".rewrite\";\n                 { // surround usage of db with extra {}\n                     BerkeleyBatch db(*this, true);\n-                    std::unique_ptr<Db> pdbCopy = MakeUnique<Db>(env->dbenv.get(), 0);\n+                    std::unique_ptr<Db> pdbCopy = std::make_unique<Db>(env->dbenv.get(), 0);\n \n                     int ret = pdbCopy->open(nullptr,               // Txn pointer\n                                             strFileRes.c_str(), // Filename\n@@ -819,7 +819,7 @@ void BerkeleyDatabase::RemoveRef()\n \n std::unique_ptr<DatabaseBatch> BerkeleyDatabase::MakeBatch(bool flush_on_close)\n {\n-    return MakeUnique<BerkeleyBatch>(*this, false, flush_on_close);\n+    return std::make_unique<BerkeleyBatch>(*this, false, flush_on_close);\n }\n \n std::unique_ptr<BerkeleyDatabase> MakeBerkeleyDatabase(const fs::path& path, const DatabaseOptions& options, DatabaseStatus& status, bilingual_str& error)\n@@ -835,7 +835,7 @@ std::unique_ptr<BerkeleyDatabase> MakeBerkeleyDatabase(const fs::path& path, con\n             status = DatabaseStatus::FAILED_ALREADY_LOADED;\n             return nullptr;\n         }\n-        db = MakeUnique<BerkeleyDatabase>(std::move(env), std::move(data_filename));\n+        db = std::make_unique<BerkeleyDatabase>(std::move(env), std::move(data_filename));\n     }\n \n     if (options.verify && !db->Verify(error)) {"
      },
      {
        "sha": "d25a3fb3fa1fe5bf57a6628c905be629a377de5f",
        "filename": "src/wallet/coincontrol.h",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/coincontrol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/coincontrol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coincontrol.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -5,13 +5,14 @@\n #ifndef BITCOIN_WALLET_COINCONTROL_H\n #define BITCOIN_WALLET_COINCONTROL_H\n \n-#include <optional.h>\n #include <outputtype.h>\n #include <policy/feerate.h>\n #include <policy/fees.h>\n #include <primitives/transaction.h>\n #include <script/standard.h>\n \n+#include <optional>\n+\n const int DEFAULT_MIN_DEPTH = 0;\n const int DEFAULT_MAX_DEPTH = 9999999;\n \n@@ -25,7 +26,7 @@ class CCoinControl\n     //! Custom change destination, if not set an address is generated\n     CTxDestination destChange;\n     //! Override the default change type if set, ignored if destChange is set\n-    Optional<OutputType> m_change_type;\n+    std::optional<OutputType> m_change_type;\n     //! If false, only selected inputs are used\n     bool m_add_inputs;\n     //! If false, allows unselected inputs, but requires all selected inputs be used\n@@ -35,11 +36,11 @@ class CCoinControl\n     //! Override automatic min/max checks on fee, m_feerate must be set if true\n     bool fOverrideFeeRate;\n     //! Override the wallet's m_pay_tx_fee if set\n-    Optional<CFeeRate> m_feerate;\n+    std::optional<CFeeRate> m_feerate;\n     //! Override the default confirmation target if set\n-    Optional<unsigned int> m_confirm_target;\n+    std::optional<unsigned int> m_confirm_target;\n     //! Override the wallet's m_signal_rbf if set\n-    Optional<bool> m_signal_bip125_rbf;\n+    std::optional<bool> m_signal_bip125_rbf;\n     //! Avoid partial use of funds sent to a given address\n     bool m_avoid_partial_spends;\n     //! Forbids inclusion of dirty (previously used) addresses"
      },
      {
        "sha": "5a18308a733c99265c51ebbf94f28e12900350bb",
        "filename": "src/wallet/coinselection.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/coinselection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/coinselection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -4,11 +4,12 @@\n \n #include <wallet/coinselection.h>\n \n-#include <optional.h>\n #include <policy/feerate.h>\n #include <util/system.h>\n #include <util/moneystr.h>\n \n+#include <optional>\n+\n // Descending order comparator\n struct {\n     bool operator()(const OutputGroup& a, const OutputGroup& b) const\n@@ -222,7 +223,7 @@ bool KnapsackSolver(const CAmount& nTargetValue, std::vector<OutputGroup>& group\n     nValueRet = 0;\n \n     // List of values less than target\n-    Optional<OutputGroup> lowest_larger;\n+    std::optional<OutputGroup> lowest_larger;\n     std::vector<OutputGroup> applicable_groups;\n     CAmount nTotalLower = 0;\n "
      },
      {
        "sha": "7a0d3d2e07ad116b86ececbdde6bb9f87ce388f3",
        "filename": "src/wallet/db.h",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -8,13 +8,12 @@\n \n #include <clientversion.h>\n #include <fs.h>\n-#include <optional.h>\n #include <streams.h>\n #include <support/allocators/secure.h>\n-#include <util/memory.h>\n \n #include <atomic>\n #include <memory>\n+#include <optional>\n #include <string>\n \n struct bilingual_str;\n@@ -193,7 +192,7 @@ class DummyDatabase : public WalletDatabase\n     void ReloadDbEnv() override {}\n     std::string Filename() override { return \"dummy\"; }\n     std::string Format() override { return \"dummy\"; }\n-    std::unique_ptr<DatabaseBatch> MakeBatch(bool flush_on_close = true) override { return MakeUnique<DummyBatch>(); }\n+    std::unique_ptr<DatabaseBatch> MakeBatch(bool flush_on_close = true) override { return std::make_unique<DummyBatch>(); }\n };\n \n enum class DatabaseFormat {\n@@ -204,7 +203,7 @@ enum class DatabaseFormat {\n struct DatabaseOptions {\n     bool require_existing = false;\n     bool require_create = false;\n-    Optional<DatabaseFormat> require_format;\n+    std::optional<DatabaseFormat> require_format;\n     uint64_t create_flags = 0;\n     SecureString create_passphrase;\n     bool verify = true;"
      },
      {
        "sha": "08adf09df4d8c155e8e6d18dcf2a68693d06ec0f",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -190,7 +190,7 @@ Result CreateRateBumpTransaction(CWallet& wallet, const uint256& txid, const CCo\n     if (coin_control.m_feerate) {\n         // The user provided a feeRate argument.\n         // We calculate this here to avoid compiler warning on the cs_wallet lock\n-        const int64_t maxTxSize = CalculateMaximumSignedTxSize(*wtx.tx, &wallet);\n+        const int64_t maxTxSize = CalculateMaximumSignedTxSize(*wtx.tx, &wallet).first;\n         Result res = CheckFeeRate(wallet, wtx, *new_coin_control.m_feerate, maxTxSize, errors);\n         if (res != Result::OK) {\n             return res;"
      },
      {
        "sha": "fdeead1fa59eee0c556efed235ecb7f0ff42650e",
        "filename": "src/wallet/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/init.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -70,7 +70,7 @@ void WalletInit::AddWalletOptions(ArgsManager& argsman) const\n     argsman.AddArg(\"-walletbroadcast\",  strprintf(\"Make the wallet broadcast transactions (default: %u)\", DEFAULT_WALLETBROADCAST), ArgsManager::ALLOW_ANY, OptionsCategory::WALLET);\n     argsman.AddArg(\"-walletdir=<dir>\", \"Specify directory to hold wallets (default: <datadir>/wallets if it exists, otherwise <datadir>)\", ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::WALLET);\n #if HAVE_SYSTEM\n-    argsman.AddArg(\"-walletnotify=<cmd>\", \"Execute command when a wallet transaction changes. %s in cmd is replaced by TxID and %w is replaced by wallet name. %w is not currently implemented on windows. On systems where %w is supported, it should NOT be quoted because this would break shell escaping used to invoke the command.\", ArgsManager::ALLOW_ANY, OptionsCategory::WALLET);\n+    argsman.AddArg(\"-walletnotify=<cmd>\", \"Execute command when a wallet transaction changes. %s in cmd is replaced by TxID, %w is replaced by wallet name, %b is replaced by the hash of the block including the transaction (set to 'unconfirmed' if the transaction is not included) and %h is replaced by the block height (-1 if not included). %w is not currently implemented on windows. On systems where %w is supported, it should NOT be quoted because this would break shell escaping used to invoke the command.\", ArgsManager::ALLOW_ANY, OptionsCategory::WALLET);\n #endif\n     argsman.AddArg(\"-walletrbf\", strprintf(\"Send transactions with full-RBF opt-in enabled (RPC only, default: %u)\", DEFAULT_WALLET_RBF), ArgsManager::ALLOW_ANY, OptionsCategory::WALLET);\n "
      },
      {
        "sha": "ada586119a4c33423334c2db10db3ccc9f2e290c",
        "filename": "src/wallet/interfaces.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/interfaces.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -588,10 +588,10 @@ class WalletClientImpl : public WalletClient\n } // namespace wallet\n \n namespace interfaces {\n-std::unique_ptr<Wallet> MakeWallet(const std::shared_ptr<CWallet>& wallet) { return wallet ? MakeUnique<wallet::WalletImpl>(wallet) : nullptr; }\n+std::unique_ptr<Wallet> MakeWallet(const std::shared_ptr<CWallet>& wallet) { return wallet ? std::make_unique<wallet::WalletImpl>(wallet) : nullptr; }\n \n std::unique_ptr<WalletClient> MakeWalletClient(Chain& chain, ArgsManager& args)\n {\n-    return MakeUnique<wallet::WalletClientImpl>(chain, args);\n+    return std::make_unique<wallet::WalletClientImpl>(chain, args);\n }\n } // namespace interfaces"
      },
      {
        "sha": "6a59bc2b38ecd401f19dd24f228ddbf55fdd4dcf",
        "filename": "src/wallet/load.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/load.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/load.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/load.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -76,7 +76,7 @@ bool VerifyWallets(interfaces::Chain& chain)\n         bilingual_str error_string;\n         if (!MakeWalletDatabase(wallet_file, options, status, error_string)) {\n             if (status == DatabaseStatus::FAILED_NOT_FOUND) {\n-                chain.initWarning(Untranslated(strprintf(\"Skipping -wallet path that doesn't exist. %s\\n\", error_string.original)));\n+                chain.initWarning(Untranslated(strprintf(\"Skipping -wallet path that doesn't exist. %s\", error_string.original)));\n             } else {\n                 chain.initError(error_string);\n                 return false;\n@@ -154,7 +154,7 @@ void UnloadWallets()\n         auto wallet = wallets.back();\n         wallets.pop_back();\n         std::vector<bilingual_str> warnings;\n-        RemoveWallet(wallet, nullopt, warnings);\n+        RemoveWallet(wallet, std::nullopt, warnings);\n         UnloadWallet(std::move(wallet));\n     }\n }"
      },
      {
        "sha": "0737e68cf3a633fb4b294f7c9276b0853e285833",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 56,
        "deletions": 66,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -56,13 +56,13 @@ static std::string DecodeDumpString(const std::string &str) {\n     return ret.str();\n }\n \n-static bool GetWalletAddressesForKey(LegacyScriptPubKeyMan* spk_man, const CWallet* const pwallet, const CKeyID& keyid, std::string& strAddr, std::string& strLabel) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static bool GetWalletAddressesForKey(LegacyScriptPubKeyMan* spk_man, const CWallet& wallet, const CKeyID& keyid, std::string& strAddr, std::string& strLabel) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet)\n {\n     bool fLabelFound = false;\n     CKey key;\n     spk_man->GetKey(keyid, key);\n     for (const auto& dest : GetAllDestinationsForKey(key.GetPubKey())) {\n-        const auto* address_book_entry = pwallet->FindAddressBookEntry(dest);\n+        const auto* address_book_entry = wallet.FindAddressBookEntry(dest);\n         if (address_book_entry) {\n             if (!strAddr.empty()) {\n                 strAddr += \",\";\n@@ -73,7 +73,7 @@ static bool GetWalletAddressesForKey(LegacyScriptPubKeyMan* spk_man, const CWall\n         }\n     }\n     if (!fLabelFound) {\n-        strAddr = EncodeDestination(GetDestinationForKey(key.GetPubKey(), pwallet->m_default_address_type));\n+        strAddr = EncodeDestination(GetDestinationForKey(key.GetPubKey(), wallet.m_default_address_type));\n     }\n     return fLabelFound;\n }\n@@ -118,22 +118,21 @@ RPCHelpMan importprivkey()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot import private keys to a wallet with private keys disabled\");\n     }\n \n-    EnsureLegacyScriptPubKeyMan(*wallet, true);\n+    EnsureLegacyScriptPubKeyMan(*pwallet, true);\n \n     WalletRescanReserver reserver(*pwallet);\n     bool fRescan = true;\n     {\n         LOCK(pwallet->cs_wallet);\n \n-        EnsureWalletIsUnlocked(pwallet);\n+        EnsureWalletIsUnlocked(*pwallet);\n \n         std::string strSecret = request.params[0].get_str();\n         std::string strLabel = \"\";\n@@ -210,9 +209,8 @@ RPCHelpMan abortrescan()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     if (!pwallet->IsScanning() || pwallet->IsAbortingRescan()) return false;\n     pwallet->AbortRescan();\n@@ -249,9 +247,8 @@ RPCHelpMan importaddress()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     EnsureLegacyScriptPubKeyMan(*pwallet, true);\n \n@@ -335,9 +332,8 @@ RPCHelpMan importprunedfunds()\n                 RPCExamples{\"\"},\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     CMutableTransaction tx;\n     if (!DecodeHexTx(tx, request.params[0].get_str())) {\n@@ -397,9 +393,8 @@ RPCHelpMan removeprunedfunds()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -445,11 +440,10 @@ RPCHelpMan importpubkey()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n-    EnsureLegacyScriptPubKeyMan(*wallet, true);\n+    EnsureLegacyScriptPubKeyMan(*pwallet, true);\n \n     std::string strLabel;\n     if (!request.params[1].isNull())\n@@ -527,11 +521,10 @@ RPCHelpMan importwallet()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n-    EnsureLegacyScriptPubKeyMan(*wallet, true);\n+    EnsureLegacyScriptPubKeyMan(*pwallet, true);\n \n     if (pwallet->chain().havePruned()) {\n         // Exit early and print an error.\n@@ -550,7 +543,7 @@ RPCHelpMan importwallet()\n     {\n         LOCK(pwallet->cs_wallet);\n \n-        EnsureWalletIsUnlocked(pwallet);\n+        EnsureWalletIsUnlocked(*pwallet);\n \n         fsbridge::ifstream file;\n         file.open(request.params[0].get_str(), std::ios::in | std::ios::ate);\n@@ -684,15 +677,14 @@ RPCHelpMan dumpprivkey()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n-    LegacyScriptPubKeyMan& spk_man = EnsureLegacyScriptPubKeyMan(*wallet);\n+    LegacyScriptPubKeyMan& spk_man = EnsureLegacyScriptPubKeyMan(*pwallet);\n \n     LOCK2(pwallet->cs_wallet, spk_man.cs_KeyStore);\n \n-    EnsureWalletIsUnlocked(pwallet);\n+    EnsureWalletIsUnlocked(*pwallet);\n \n     std::string strAddress = request.params[0].get_str();\n     CTxDestination dest = DecodeDestination(strAddress);\n@@ -747,7 +739,7 @@ RPCHelpMan dumpwallet()\n \n     LOCK2(wallet.cs_wallet, spk_man.cs_KeyStore);\n \n-    EnsureWalletIsUnlocked(&wallet);\n+    EnsureWalletIsUnlocked(wallet);\n \n     fs::path filepath = request.params[0].get_str();\n     filepath = fs::absolute(filepath);\n@@ -809,7 +801,7 @@ RPCHelpMan dumpwallet()\n         CKey key;\n         if (spk_man.GetKey(keyid, key)) {\n             file << strprintf(\"%s %s \", EncodeSecret(key), strTime);\n-            if (GetWalletAddressesForKey(&spk_man, &wallet, keyid, strAddr, strLabel)) {\n+            if (GetWalletAddressesForKey(&spk_man, wallet, keyid, strAddr, strLabel)) {\n                 file << strprintf(\"label=%s\", strLabel);\n             } else if (keyid == seed_id) {\n                 file << \"hdseed=1\";\n@@ -990,14 +982,14 @@ static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CP\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n         }\n         auto parsed_redeemscript = ParseHex(strRedeemScript);\n-        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+        import_data.redeemscript = std::make_unique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n     }\n     if (witness_script_hex.size()) {\n         if (!IsHex(witness_script_hex)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n         }\n         auto parsed_witnessscript = ParseHex(witness_script_hex);\n-        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        import_data.witnessscript = std::make_unique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n     }\n     for (size_t i = 0; i < pubKeys.size(); ++i) {\n         const auto& str = pubKeys[i].get_str();\n@@ -1169,7 +1161,7 @@ static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID\n     return warnings;\n }\n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static UniValue ProcessImport(CWallet& wallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet)\n {\n     UniValue warnings(UniValue::VARR);\n     UniValue result(UniValue::VOBJ);\n@@ -1184,7 +1176,7 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         const bool add_keypool = data.exists(\"keypool\") ? data[\"keypool\"].get_bool() : false;\n \n         // Add to keypool only works with privkeys disabled\n-        if (add_keypool && !pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n+        if (add_keypool && !wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Keys can only be imported to the keypool when private keys are disabled\");\n         }\n \n@@ -1206,29 +1198,29 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         }\n \n         // If private keys are disabled, abort if private keys are being imported\n-        if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && !privkey_map.empty()) {\n+        if (wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && !privkey_map.empty()) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot import private keys to a wallet with private keys disabled\");\n         }\n \n         // Check whether we have any work to do\n         for (const CScript& script : script_pub_keys) {\n-            if (pwallet->IsMine(script) & ISMINE_SPENDABLE) {\n+            if (wallet.IsMine(script) & ISMINE_SPENDABLE) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script (\\\"\" + HexStr(script) + \"\\\")\");\n             }\n         }\n \n         // All good, time to import\n-        pwallet->MarkDirty();\n-        if (!pwallet->ImportScripts(import_data.import_scripts, timestamp)) {\n+        wallet.MarkDirty();\n+        if (!wallet.ImportScripts(import_data.import_scripts, timestamp)) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n         }\n-        if (!pwallet->ImportPrivKeys(privkey_map, timestamp)) {\n+        if (!wallet.ImportPrivKeys(privkey_map, timestamp)) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n         }\n-        if (!pwallet->ImportPubKeys(ordered_pubkeys, pubkey_map, import_data.key_origins, add_keypool, internal, timestamp)) {\n+        if (!wallet.ImportPubKeys(ordered_pubkeys, pubkey_map, import_data.key_origins, add_keypool, internal, timestamp)) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n         }\n-        if (!pwallet->ImportScriptPubKeys(label, script_pub_keys, have_solving_data, !internal, timestamp)) {\n+        if (!wallet.ImportScriptPubKeys(label, script_pub_keys, have_solving_data, !internal, timestamp)) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n         }\n \n@@ -1336,13 +1328,12 @@ RPCHelpMan importmulti()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& mainRequest) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(mainRequest);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(mainRequest);\n+    if (!pwallet) return NullUniValue;\n \n     RPCTypeCheck(mainRequest.params, {UniValue::VARR, UniValue::VOBJ});\n \n-    EnsureLegacyScriptPubKeyMan(*wallet, true);\n+    EnsureLegacyScriptPubKeyMan(*pwallet, true);\n \n     const UniValue& requests = mainRequest.params[0];\n \n@@ -1368,7 +1359,7 @@ RPCHelpMan importmulti()\n     UniValue response(UniValue::VARR);\n     {\n         LOCK(pwallet->cs_wallet);\n-        EnsureWalletIsUnlocked(pwallet);\n+        EnsureWalletIsUnlocked(*pwallet);\n \n         // Verify all timestamps are present before importing any keys.\n         CHECK_NONFATAL(pwallet->chain().findBlock(pwallet->GetLastBlockHash(), FoundBlock().time(nLowestTimestamp).mtpTime(now)));\n@@ -1380,7 +1371,7 @@ RPCHelpMan importmulti()\n \n         for (const UniValue& data : requests.getValues()) {\n             const int64_t timestamp = std::max(GetImportTimestamp(data, now), minimumTimestamp);\n-            const UniValue result = ProcessImport(pwallet, data, timestamp);\n+            const UniValue result = ProcessImport(*pwallet, data, timestamp);\n             response.push_back(result);\n \n             if (!fRescan) {\n@@ -1447,7 +1438,7 @@ RPCHelpMan importmulti()\n     };\n }\n \n-static UniValue ProcessDescriptorImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static UniValue ProcessDescriptorImport(CWallet& wallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet)\n {\n     UniValue warnings(UniValue::VARR);\n     UniValue result(UniValue::VOBJ);\n@@ -1516,7 +1507,7 @@ static UniValue ProcessDescriptorImport(CWallet * const pwallet, const UniValue&\n         }\n \n         // If the wallet disabled private keys, abort if private keys exist\n-        if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && !keys.keys.empty()) {\n+        if (wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && !keys.keys.empty()) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot import private keys to a wallet with private keys disabled\");\n         }\n \n@@ -1540,7 +1531,7 @@ static UniValue ProcessDescriptorImport(CWallet * const pwallet, const UniValue&\n         }\n \n         // If private keys are enabled, check some things.\n-        if (!pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n+        if (!wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n            if (keys.keys.empty()) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot import descriptor without private keys to a wallet with private keys enabled\");\n            }\n@@ -1552,7 +1543,7 @@ static UniValue ProcessDescriptorImport(CWallet * const pwallet, const UniValue&\n         WalletDescriptor w_desc(std::move(parsed_desc), timestamp, range_start, range_end, next_index);\n \n         // Check if the wallet already contains the descriptor\n-        auto existing_spk_manager = pwallet->GetDescriptorScriptPubKeyMan(w_desc);\n+        auto existing_spk_manager = wallet.GetDescriptorScriptPubKeyMan(w_desc);\n         if (existing_spk_manager) {\n             LOCK(existing_spk_manager->cs_desc_man);\n             if (range_start > existing_spk_manager->GetWalletDescriptor().range_start) {\n@@ -1561,7 +1552,7 @@ static UniValue ProcessDescriptorImport(CWallet * const pwallet, const UniValue&\n         }\n \n         // Add descriptor to the wallet\n-        auto spk_manager = pwallet->AddWalletDescriptor(w_desc, keys, label, internal);\n+        auto spk_manager = wallet.AddWalletDescriptor(w_desc, keys, label, internal);\n         if (spk_manager == nullptr) {\n             throw JSONRPCError(RPC_WALLET_ERROR, strprintf(\"Could not add descriptor '%s'\", descriptor));\n         }\n@@ -1571,7 +1562,7 @@ static UniValue ProcessDescriptorImport(CWallet * const pwallet, const UniValue&\n             if (!w_desc.descriptor->GetOutputType()) {\n                 warnings.push_back(\"Unknown output type, cannot set descriptor to active.\");\n             } else {\n-                pwallet->AddActiveScriptPubKeyMan(spk_manager->GetID(), *w_desc.descriptor->GetOutputType(), internal);\n+                wallet.AddActiveScriptPubKeyMan(spk_manager->GetID(), *w_desc.descriptor->GetOutputType(), internal);\n             }\n         }\n \n@@ -1641,9 +1632,8 @@ RPCHelpMan importdescriptors()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& main_request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(main_request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(main_request);\n+    if (!pwallet) return NullUniValue;\n \n     //  Make sure wallet is a descriptor wallet\n     if (!pwallet->IsWalletFlagSet(WALLET_FLAG_DESCRIPTORS)) {\n@@ -1665,15 +1655,15 @@ RPCHelpMan importdescriptors()\n     UniValue response(UniValue::VARR);\n     {\n         LOCK(pwallet->cs_wallet);\n-        EnsureWalletIsUnlocked(pwallet);\n+        EnsureWalletIsUnlocked(*pwallet);\n \n         CHECK_NONFATAL(pwallet->chain().findBlock(pwallet->GetLastBlockHash(), FoundBlock().time(lowest_timestamp).mtpTime(now)));\n \n         // Get all timestamps and extract the lowest timestamp\n         for (const UniValue& request : requests.getValues()) {\n             // This throws an error if \"timestamp\" doesn't exist\n             const int64_t timestamp = std::max(GetImportTimestamp(request, now), minimum_timestamp);\n-            const UniValue result = ProcessDescriptorImport(pwallet, request, timestamp);\n+            const UniValue result = ProcessDescriptorImport(*pwallet, request, timestamp);\n             response.push_back(result);\n \n             if (lowest_timestamp > timestamp ) {\n@@ -1775,7 +1765,7 @@ RPCHelpMan listdescriptors()\n         throw JSONRPCError(RPC_WALLET_ERROR, \"listdescriptors is not available for non-descriptor wallets\");\n     }\n \n-    EnsureWalletIsUnlocked(wallet.get());\n+    EnsureWalletIsUnlocked(*wallet);\n \n     LOCK(wallet->cs_wallet);\n \n@@ -1798,7 +1788,7 @@ RPCHelpMan listdescriptors()\n         const bool active = active_spk_mans.count(desc_spk_man) != 0;\n         spk.pushKV(\"active\", active);\n         const auto& type = wallet_descriptor.descriptor->GetOutputType();\n-        if (active && type != nullopt) {\n+        if (active && type) {\n             spk.pushKV(\"internal\", wallet->GetScriptPubKeyMan(*type, true) == desc_spk_man);\n         }\n         if (wallet_descriptor.descriptor->IsRange()) {"
      },
      {
        "sha": "696c74d6659e9a895aa281dd47a9b2f6d9aef89a",
        "filename": "src/wallet/rpcsigner.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/rpcsigner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/rpcsigner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcsigner.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -32,9 +32,6 @@ static RPCHelpMan enumeratesigners()\n         },\n         RPCExamples{\"\"},\n         [](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue {\n-            std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-            if (!wallet) return NullUniValue;\n-\n             const std::string command = gArgs.GetArg(\"-signer\", \"\");\n             if (command == \"\") throw JSONRPCError(RPC_WALLET_ERROR, \"Error: restart bitcoind with -signer=<cmd>\");\n             std::string chain = gArgs.GetChainName();"
      },
      {
        "sha": "6dc8d1de422c0bb23d70d388e3eea60778efee67",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 145,
        "deletions": 186,
        "changes": 331,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -8,7 +8,6 @@\n #include <interfaces/chain.h>\n #include <key_io.h>\n #include <node/context.h>\n-#include <optional.h>\n #include <outputtype.h>\n #include <policy/feerate.h>\n #include <policy/fees.h>\n@@ -38,6 +37,7 @@\n #include <wallet/walletdb.h>\n #include <wallet/walletutil.h>\n \n+#include <optional>\n #include <stdint.h>\n \n #include <univalue.h>\n@@ -48,8 +48,8 @@ using interfaces::FoundBlock;\n static const std::string WALLET_ENDPOINT_BASE = \"/wallet/\";\n static const std::string HELP_REQUIRING_PASSPHRASE{\"\\nRequires wallet passphrase to be set with walletpassphrase call if wallet is encrypted.\\n\"};\n \n-static inline bool GetAvoidReuseFlag(const CWallet* const pwallet, const UniValue& param) {\n-    bool can_avoid_reuse = pwallet->IsWalletFlagSet(WALLET_FLAG_AVOID_REUSE);\n+static inline bool GetAvoidReuseFlag(const CWallet& wallet, const UniValue& param) {\n+    bool can_avoid_reuse = wallet.IsWalletFlagSet(WALLET_FLAG_AVOID_REUSE);\n     bool avoid_reuse = param.isNull() ? can_avoid_reuse : param.get_bool();\n \n     if (avoid_reuse && !can_avoid_reuse) {\n@@ -64,11 +64,11 @@ static inline bool GetAvoidReuseFlag(const CWallet* const pwallet, const UniValu\n  *  We default to true for watchonly wallets if include_watchonly isn't\n  *  explicitly set.\n  */\n-static bool ParseIncludeWatchonly(const UniValue& include_watchonly, const CWallet& pwallet)\n+static bool ParseIncludeWatchonly(const UniValue& include_watchonly, const CWallet& wallet)\n {\n     if (include_watchonly.isNull()) {\n         // if include_watchonly isn't explicitly set, then check if we have a watchonly wallet\n-        return pwallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS);\n+        return wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS);\n     }\n \n     // otherwise return whatever include_watchonly was set to\n@@ -96,7 +96,7 @@ bool GetWalletNameFromJSONRPCRequest(const JSONRPCRequest& request, std::string&\n \n std::shared_ptr<CWallet> GetWalletForJSONRPCRequest(const JSONRPCRequest& request)\n {\n-    CHECK_NONFATAL(!request.fHelp);\n+    CHECK_NONFATAL(request.mode == JSONRPCRequest::EXECUTE);\n     std::string wallet_name;\n     if (GetWalletNameFromJSONRPCRequest(request, wallet_name)) {\n         std::shared_ptr<CWallet> pwallet = GetWallet(wallet_name);\n@@ -117,9 +117,9 @@ std::shared_ptr<CWallet> GetWalletForJSONRPCRequest(const JSONRPCRequest& reques\n         \"Wallet file not specified (must request wallet RPC through /wallet/<filename> uri-path).\");\n }\n \n-void EnsureWalletIsUnlocked(const CWallet* pwallet)\n+void EnsureWalletIsUnlocked(const CWallet& wallet)\n {\n-    if (pwallet->IsLocked()) {\n+    if (wallet.IsLocked()) {\n         throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n     }\n }\n@@ -219,7 +219,7 @@ static void SetFeeEstimateMode(const CWallet& wallet, CCoinControl& cc, const Un\n         cc.m_feerate = CFeeRate(AmountFromValue(fee_rate), COIN);\n         if (override_min_fee) cc.fOverrideFeeRate = true;\n         // Default RBF to true for explicit fee_rate, if unset.\n-        if (cc.m_signal_bip125_rbf == nullopt) cc.m_signal_bip125_rbf = true;\n+        if (!cc.m_signal_bip125_rbf) cc.m_signal_bip125_rbf = true;\n         return;\n     }\n     if (!estimate_mode.isNull() && !FeeModeFromString(estimate_mode.get_str(), cc.m_fee_mode)) {\n@@ -249,9 +249,8 @@ static RPCHelpMan getnewaddress()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -299,9 +298,8 @@ static RPCHelpMan getrawchangeaddress()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -342,9 +340,8 @@ static RPCHelpMan setlabel()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -396,13 +393,13 @@ void ParseRecipients(const UniValue& address_amounts, const UniValue& subtract_f\n     }\n }\n \n-UniValue SendMoney(CWallet* const pwallet, const CCoinControl &coin_control, std::vector<CRecipient> &recipients, mapValue_t map_value, bool verbose)\n+UniValue SendMoney(CWallet& wallet, const CCoinControl &coin_control, std::vector<CRecipient> &recipients, mapValue_t map_value, bool verbose)\n {\n-    EnsureWalletIsUnlocked(pwallet);\n+    EnsureWalletIsUnlocked(wallet);\n \n     // This function is only used by sendtoaddress and sendmany.\n     // This should always try to sign, if we don't have private keys, don't try to do anything here.\n-    if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n+    if (wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Error: Private keys are disabled for this wallet\");\n     }\n \n@@ -415,11 +412,11 @@ UniValue SendMoney(CWallet* const pwallet, const CCoinControl &coin_control, std\n     bilingual_str error;\n     CTransactionRef tx;\n     FeeCalculation fee_calc_out;\n-    const bool fCreated = pwallet->CreateTransaction(recipients, tx, nFeeRequired, nChangePosRet, error, coin_control, fee_calc_out, true);\n+    const bool fCreated = wallet.CreateTransaction(recipients, tx, nFeeRequired, nChangePosRet, error, coin_control, fee_calc_out, true);\n     if (!fCreated) {\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, error.original);\n     }\n-    pwallet->CommitTransaction(tx, std::move(map_value), {} /* orderForm */);\n+    wallet.CommitTransaction(tx, std::move(map_value), {} /* orderForm */);\n     if (verbose) {\n         UniValue entry(UniValue::VOBJ);\n         entry.pushKV(\"txid\", tx->GetHash().GetHex());\n@@ -480,9 +477,8 @@ static RPCHelpMan sendtoaddress()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -507,13 +503,13 @@ static RPCHelpMan sendtoaddress()\n         coin_control.m_signal_bip125_rbf = request.params[5].get_bool();\n     }\n \n-    coin_control.m_avoid_address_reuse = GetAvoidReuseFlag(pwallet, request.params[8]);\n+    coin_control.m_avoid_address_reuse = GetAvoidReuseFlag(*pwallet, request.params[8]);\n     // We also enable partial spend avoidance if reuse avoidance is set.\n     coin_control.m_avoid_partial_spends |= coin_control.m_avoid_address_reuse;\n \n     SetFeeEstimateMode(*pwallet, coin_control, /* conf_target */ request.params[6], /* estimate_mode */ request.params[7], /* fee_rate */ request.params[9], /* override_min_fee */ false);\n \n-    EnsureWalletIsUnlocked(pwallet);\n+    EnsureWalletIsUnlocked(*pwallet);\n \n     UniValue address_amounts(UniValue::VOBJ);\n     const std::string address = request.params[0].get_str();\n@@ -527,7 +523,7 @@ static RPCHelpMan sendtoaddress()\n     ParseRecipients(address_amounts, subtractFeeFromAmount, recipients);\n     const bool verbose{request.params[10].isNull() ? false : request.params[10].get_bool()};\n \n-    return SendMoney(pwallet, coin_control, recipients, mapValue, verbose);\n+    return SendMoney(*pwallet, coin_control, recipients, mapValue, verbose);\n },\n     };\n }\n@@ -559,9 +555,8 @@ static RPCHelpMan listaddressgroupings()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -617,13 +612,12 @@ static RPCHelpMan signmessage()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n-    EnsureWalletIsUnlocked(pwallet);\n+    EnsureWalletIsUnlocked(*pwallet);\n \n     std::string strAddress = request.params[0].get_str();\n     std::string strMessage = request.params[1].get_str();\n@@ -720,9 +714,8 @@ static RPCHelpMan getreceivedbyaddress()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -759,9 +752,8 @@ static RPCHelpMan getreceivedbylabel()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -800,9 +792,8 @@ static RPCHelpMan getbalance()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -822,7 +813,7 @@ static RPCHelpMan getbalance()\n \n     bool include_watchonly = ParseIncludeWatchonly(request.params[2], *pwallet);\n \n-    bool avoid_reuse = GetAvoidReuseFlag(pwallet, request.params[3]);\n+    bool avoid_reuse = GetAvoidReuseFlag(*pwallet, request.params[3]);\n \n     const auto bal = pwallet->GetBalance(min_depth, avoid_reuse);\n \n@@ -840,9 +831,8 @@ static RPCHelpMan getunconfirmedbalance()\n                 RPCExamples{\"\"},\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -911,9 +901,8 @@ static RPCHelpMan sendmany()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -945,7 +934,7 @@ static RPCHelpMan sendmany()\n     ParseRecipients(sendTo, subtractFeeFromAmount, recipients);\n     const bool verbose{request.params[9].isNull() ? false : request.params[9].get_bool()};\n \n-    return SendMoney(pwallet, coin_control, recipients, std::move(mapValue), verbose);\n+    return SendMoney(*pwallet, coin_control, recipients, std::move(mapValue), verbose);\n },\n     };\n }\n@@ -985,9 +974,8 @@ static RPCHelpMan addmultisigaddress()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LegacyScriptPubKeyMan& spk_man = EnsureLegacyScriptPubKeyMan(*pwallet);\n \n@@ -1045,7 +1033,7 @@ struct tallyitem\n     }\n };\n \n-static UniValue ListReceived(const CWallet* const pwallet, const UniValue& params, bool by_label) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static UniValue ListReceived(const CWallet& wallet, const UniValue& params, bool by_label) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet)\n {\n     // Minimum confirmations\n     int nMinDepth = 1;\n@@ -1059,7 +1047,7 @@ static UniValue ListReceived(const CWallet* const pwallet, const UniValue& param\n \n     isminefilter filter = ISMINE_SPENDABLE;\n \n-    if (ParseIncludeWatchonly(params[2], *pwallet)) {\n+    if (ParseIncludeWatchonly(params[2], wallet)) {\n         filter |= ISMINE_WATCH_ONLY;\n     }\n \n@@ -1075,10 +1063,10 @@ static UniValue ListReceived(const CWallet* const pwallet, const UniValue& param\n \n     // Tally\n     std::map<CTxDestination, tallyitem> mapTally;\n-    for (const std::pair<const uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n+    for (const std::pair<const uint256, CWalletTx>& pairWtx : wallet.mapWallet) {\n         const CWalletTx& wtx = pairWtx.second;\n \n-        if (wtx.IsCoinBase() || !pwallet->chain().checkFinalTx(*wtx.tx)) {\n+        if (wtx.IsCoinBase() || !wallet.chain().checkFinalTx(*wtx.tx)) {\n             continue;\n         }\n \n@@ -1096,7 +1084,7 @@ static UniValue ListReceived(const CWallet* const pwallet, const UniValue& param\n                 continue;\n             }\n \n-            isminefilter mine = pwallet->IsMine(address);\n+            isminefilter mine = wallet.IsMine(address);\n             if(!(mine & filter))\n                 continue;\n \n@@ -1115,11 +1103,11 @@ static UniValue ListReceived(const CWallet* const pwallet, const UniValue& param\n \n     // Create m_address_book iterator\n     // If we aren't filtering, go from begin() to end()\n-    auto start = pwallet->m_address_book.begin();\n-    auto end = pwallet->m_address_book.end();\n+    auto start = wallet.m_address_book.begin();\n+    auto end = wallet.m_address_book.end();\n     // If we are filtering, find() the applicable entry\n     if (has_filtered_address) {\n-        start = pwallet->m_address_book.find(filtered_address);\n+        start = wallet.m_address_book.find(filtered_address);\n         if (start != end) {\n             end = std::next(start);\n         }\n@@ -1227,17 +1215,16 @@ static RPCHelpMan listreceivedbyaddress()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n     LOCK(pwallet->cs_wallet);\n \n-    return ListReceived(pwallet, request.params, false);\n+    return ListReceived(*pwallet, request.params, false);\n },\n     };\n }\n@@ -1270,17 +1257,16 @@ static RPCHelpMan listreceivedbylabel()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n     LOCK(pwallet->cs_wallet);\n \n-    return ListReceived(pwallet, request.params, true);\n+    return ListReceived(*pwallet, request.params, true);\n },\n     };\n }\n@@ -1303,7 +1289,7 @@ static void MaybePushAddress(UniValue & entry, const CTxDestination &dest)\n  * @param  filter_ismine  The \"is mine\" filter flags.\n  * @param  filter_label   Optional label string to filter incoming transactions.\n  */\n-static void ListTransactions(const CWallet* const pwallet, const CWalletTx& wtx, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter_ismine, const std::string* filter_label) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ListTransactions(const CWallet& wallet, const CWalletTx& wtx, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter_ismine, const std::string* filter_label) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet)\n {\n     CAmount nFee;\n     std::list<COutputEntry> listReceived;\n@@ -1319,20 +1305,20 @@ static void ListTransactions(const CWallet* const pwallet, const CWalletTx& wtx,\n         for (const COutputEntry& s : listSent)\n         {\n             UniValue entry(UniValue::VOBJ);\n-            if (involvesWatchonly || (pwallet->IsMine(s.destination) & ISMINE_WATCH_ONLY)) {\n+            if (involvesWatchonly || (wallet.IsMine(s.destination) & ISMINE_WATCH_ONLY)) {\n                 entry.pushKV(\"involvesWatchonly\", true);\n             }\n             MaybePushAddress(entry, s.destination);\n             entry.pushKV(\"category\", \"send\");\n             entry.pushKV(\"amount\", ValueFromAmount(-s.amount));\n-            const auto* address_book_entry = pwallet->FindAddressBookEntry(s.destination);\n+            const auto* address_book_entry = wallet.FindAddressBookEntry(s.destination);\n             if (address_book_entry) {\n                 entry.pushKV(\"label\", address_book_entry->GetLabel());\n             }\n             entry.pushKV(\"vout\", s.vout);\n             entry.pushKV(\"fee\", ValueFromAmount(-nFee));\n             if (fLong)\n-                WalletTxToJSON(pwallet->chain(), wtx, entry);\n+                WalletTxToJSON(wallet.chain(), wtx, entry);\n             entry.pushKV(\"abandoned\", wtx.isAbandoned());\n             ret.push_back(entry);\n         }\n@@ -1343,15 +1329,15 @@ static void ListTransactions(const CWallet* const pwallet, const CWalletTx& wtx,\n         for (const COutputEntry& r : listReceived)\n         {\n             std::string label;\n-            const auto* address_book_entry = pwallet->FindAddressBookEntry(r.destination);\n+            const auto* address_book_entry = wallet.FindAddressBookEntry(r.destination);\n             if (address_book_entry) {\n                 label = address_book_entry->GetLabel();\n             }\n             if (filter_label && label != *filter_label) {\n                 continue;\n             }\n             UniValue entry(UniValue::VOBJ);\n-            if (involvesWatchonly || (pwallet->IsMine(r.destination) & ISMINE_WATCH_ONLY)) {\n+            if (involvesWatchonly || (wallet.IsMine(r.destination) & ISMINE_WATCH_ONLY)) {\n                 entry.pushKV(\"involvesWatchonly\", true);\n             }\n             MaybePushAddress(entry, r.destination);\n@@ -1374,7 +1360,7 @@ static void ListTransactions(const CWallet* const pwallet, const CWalletTx& wtx,\n             }\n             entry.pushKV(\"vout\", r.vout);\n             if (fLong)\n-                WalletTxToJSON(pwallet->chain(), wtx, entry);\n+                WalletTxToJSON(wallet.chain(), wtx, entry);\n             ret.push_back(entry);\n         }\n     }\n@@ -1451,9 +1437,8 @@ static RPCHelpMan listtransactions()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -1494,7 +1479,7 @@ static RPCHelpMan listtransactions()\n         for (CWallet::TxItems::const_reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n         {\n             CWalletTx *const pwtx = (*it).second;\n-            ListTransactions(pwallet, *pwtx, 0, true, ret, filter, filter_label);\n+            ListTransactions(*pwallet, *pwtx, 0, true, ret, filter, filter_label);\n             if ((int)ret.size() >= (nCount+nFrom)) break;\n         }\n     }\n@@ -1579,8 +1564,8 @@ static RPCHelpMan listsinceblock()\n \n     LOCK(wallet.cs_wallet);\n \n-    Optional<int> height;    // Height of the specified block or the common ancestor, if the block provided was in a deactivated chain.\n-    Optional<int> altheight; // Height of the specified block, even if it's in a deactivated chain.\n+    std::optional<int> height;    // Height of the specified block or the common ancestor, if the block provided was in a deactivated chain.\n+    std::optional<int> altheight; // Height of the specified block, even if it's in a deactivated chain.\n     int target_confirms = 1;\n     isminefilter filter = ISMINE_SPENDABLE;\n \n@@ -1616,7 +1601,7 @@ static RPCHelpMan listsinceblock()\n         const CWalletTx& tx = pairWtx.second;\n \n         if (depth == -1 || abs(tx.GetDepthInMainChain()) < depth) {\n-            ListTransactions(&wallet, tx, 0, true, transactions, filter, nullptr /* filter_label */);\n+            ListTransactions(wallet, tx, 0, true, transactions, filter, nullptr /* filter_label */);\n         }\n     }\n \n@@ -1633,7 +1618,7 @@ static RPCHelpMan listsinceblock()\n             if (it != wallet.mapWallet.end()) {\n                 // We want all transactions regardless of confirmation count to appear here,\n                 // even negative confirmation ones, hence the big negative.\n-                ListTransactions(&wallet, it->second, -100000000, true, removed, filter, nullptr /* filter_label */);\n+                ListTransactions(wallet, it->second, -100000000, true, removed, filter, nullptr /* filter_label */);\n             }\n         }\n         blockId = block.hashPrevBlock;\n@@ -1710,9 +1695,8 @@ static RPCHelpMan gettransaction()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -1749,7 +1733,7 @@ static RPCHelpMan gettransaction()\n     WalletTxToJSON(pwallet->chain(), wtx, entry);\n \n     UniValue details(UniValue::VARR);\n-    ListTransactions(pwallet, wtx, 0, false, details, filter, nullptr /* filter_label */);\n+    ListTransactions(*pwallet, wtx, 0, false, details, filter, nullptr /* filter_label */);\n     entry.pushKV(\"details\", details);\n \n     std::string strHex = EncodeHexTx(*wtx.tx, pwallet->chain().rpcSerializationFlags());\n@@ -1784,9 +1768,8 @@ static RPCHelpMan abandontransaction()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -1823,9 +1806,8 @@ static RPCHelpMan backupwallet()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -1859,9 +1841,8 @@ static RPCHelpMan keypoolrefill()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     if (pwallet->IsLegacy() && pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Error: Private keys are disabled for this wallet\");\n@@ -1877,7 +1858,7 @@ static RPCHelpMan keypoolrefill()\n         kpSize = (unsigned int)request.params[0].get_int();\n     }\n \n-    EnsureWalletIsUnlocked(pwallet);\n+    EnsureWalletIsUnlocked(*pwallet);\n     pwallet->TopUpKeyPool(kpSize);\n \n     if (pwallet->GetKeyPoolSize() < kpSize) {\n@@ -2001,9 +1982,8 @@ static RPCHelpMan walletpassphrasechange()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -2055,9 +2035,8 @@ static RPCHelpMan walletlock()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -2100,9 +2079,8 @@ static RPCHelpMan encryptwallet()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -2174,9 +2152,8 @@ static RPCHelpMan lockunspent()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -2289,9 +2266,8 @@ static RPCHelpMan listlockunspent()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -2330,9 +2306,8 @@ static RPCHelpMan settxfee()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -2460,9 +2435,8 @@ static RPCHelpMan getwalletinfo()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -2616,7 +2590,7 @@ static RPCHelpMan loadwallet()\n     options.require_existing = true;\n     bilingual_str error;\n     std::vector<bilingual_str> warnings;\n-    Optional<bool> load_on_start = request.params[1].isNull() ? nullopt : Optional<bool>(request.params[1].get_bool());\n+    std::optional<bool> load_on_start = request.params[1].isNull() ? std::nullopt : std::optional<bool>(request.params[1].get_bool());\n     std::shared_ptr<CWallet> const wallet = LoadWallet(*context.chain, name, load_on_start, options, status, error, warnings);\n     if (!wallet) {\n         // Map bad format to not found, since bad format is returned when the\n@@ -2672,9 +2646,8 @@ static RPCHelpMan setwalletflag()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     std::string flag_str = request.params[0].get_str();\n     bool value = request.params[1].isNull() || request.params[1].get_bool();\n@@ -2791,7 +2764,7 @@ static RPCHelpMan createwallet()\n     options.create_flags = flags;\n     options.create_passphrase = passphrase;\n     bilingual_str error;\n-    Optional<bool> load_on_start = request.params[6].isNull() ? nullopt : Optional<bool>(request.params[6].get_bool());\n+    std::optional<bool> load_on_start = request.params[6].isNull() ? std::nullopt : std::optional<bool>(request.params[6].get_bool());\n     std::shared_ptr<CWallet> wallet = CreateWallet(*context.chain, request.params[0].get_str(), load_on_start, options, status, error, warnings);\n     if (!wallet) {\n         RPCErrorCode code = status == DatabaseStatus::FAILED_ENCRYPT ? RPC_WALLET_ENCRYPTION_FAILED : RPC_WALLET_ERROR;\n@@ -2843,7 +2816,7 @@ static RPCHelpMan unloadwallet()\n     // Note that any attempt to load the same wallet would fail until the wallet\n     // is destroyed (see CheckUniqueFileid).\n     std::vector<bilingual_str> warnings;\n-    Optional<bool> load_on_start = request.params[1].isNull() ? nullopt : Optional<bool>(request.params[1].get_bool());\n+    std::optional<bool> load_on_start = request.params[1].isNull() ? std::nullopt : std::optional<bool>(request.params[1].get_bool());\n     if (!RemoveWallet(wallet, load_on_start, warnings)) {\n         throw JSONRPCError(RPC_MISC_ERROR, \"Requested wallet already unloaded\");\n     }\n@@ -2916,9 +2889,8 @@ static RPCHelpMan listunspent()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     int nMinDepth = 1;\n     if (!request.params[0].isNull()) {\n@@ -3080,11 +3052,11 @@ static RPCHelpMan listunspent()\n     };\n }\n \n-void FundTransaction(CWallet* const pwallet, CMutableTransaction& tx, CAmount& fee_out, int& change_position, const UniValue& options, CCoinControl& coinControl, bool override_min_fee)\n+void FundTransaction(CWallet& wallet, CMutableTransaction& tx, CAmount& fee_out, int& change_position, const UniValue& options, CCoinControl& coinControl, bool override_min_fee)\n {\n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n-    pwallet->BlockUntilSyncedToCurrentChain();\n+    wallet.BlockUntilSyncedToCurrentChain();\n \n     change_position = -1;\n     bool lockUnspents = false;\n@@ -3155,7 +3127,7 @@ void FundTransaction(CWallet* const pwallet, CMutableTransaction& tx, CAmount& f\n         }\n \n         const UniValue include_watching_option = options.exists(\"include_watching\") ? options[\"include_watching\"] : options[\"includeWatching\"];\n-        coinControl.fAllowWatchOnly = ParseIncludeWatchonly(include_watching_option, *pwallet);\n+        coinControl.fAllowWatchOnly = ParseIncludeWatchonly(include_watching_option, wallet);\n \n         if (options.exists(\"lockUnspents\") || options.exists(\"lock_unspents\")) {\n             lockUnspents = (options.exists(\"lock_unspents\") ? options[\"lock_unspents\"] : options[\"lockUnspents\"]).get_bool();\n@@ -3181,11 +3153,11 @@ void FundTransaction(CWallet* const pwallet, CMutableTransaction& tx, CAmount& f\n         if (options.exists(\"replaceable\")) {\n             coinControl.m_signal_bip125_rbf = options[\"replaceable\"].get_bool();\n         }\n-        SetFeeEstimateMode(*pwallet, coinControl, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], override_min_fee);\n+        SetFeeEstimateMode(wallet, coinControl, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], override_min_fee);\n       }\n     } else {\n         // if options is null and not a bool\n-        coinControl.fAllowWatchOnly = ParseIncludeWatchonly(NullUniValue, *pwallet);\n+        coinControl.fAllowWatchOnly = ParseIncludeWatchonly(NullUniValue, wallet);\n     }\n \n     if (tx.vout.size() == 0)\n@@ -3207,7 +3179,7 @@ void FundTransaction(CWallet* const pwallet, CMutableTransaction& tx, CAmount& f\n \n     bilingual_str error;\n \n-    if (!pwallet->FundTransaction(tx, fee_out, change_position, error, lockUnspents, setSubtractFeeFromOutputs, coinControl)) {\n+    if (!wallet.FundTransaction(tx, fee_out, change_position, error, lockUnspents, setSubtractFeeFromOutputs, coinControl)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, error.original);\n     }\n }\n@@ -3283,9 +3255,8 @@ static RPCHelpMan fundrawtransaction()\n                                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     RPCTypeCheck(request.params, {UniValue::VSTR, UniValueType(), UniValue::VBOOL});\n \n@@ -3302,7 +3273,7 @@ static RPCHelpMan fundrawtransaction()\n     CCoinControl coin_control;\n     // Automatically select (additional) coins. Can be overridden by options.add_inputs.\n     coin_control.m_add_inputs = true;\n-    FundTransaction(pwallet, tx, fee, change_position, request.params[1], coin_control, /* override_min_fee */ true);\n+    FundTransaction(*pwallet, tx, fee, change_position, request.params[1], coin_control, /* override_min_fee */ true);\n \n     UniValue result(UniValue::VOBJ);\n     result.pushKV(\"hex\", EncodeHexTx(CTransaction(tx)));\n@@ -3369,9 +3340,8 @@ RPCHelpMan signrawtransactionwithwallet()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR, UniValue::VSTR}, true);\n \n@@ -3382,7 +3352,7 @@ RPCHelpMan signrawtransactionwithwallet()\n \n     // Sign the transaction\n     LOCK(pwallet->cs_wallet);\n-    EnsureWalletIsUnlocked(pwallet);\n+    EnsureWalletIsUnlocked(*pwallet);\n \n     // Fetch previous transactions (inputs):\n     std::map<COutPoint, Coin> coins;\n@@ -3469,9 +3439,8 @@ static RPCHelpMan bumpfee_helper(std::string method_name)\n         },\n         [want_psbt](const RPCHelpMan& self, const JSONRPCRequest& request) mutable -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && !want_psbt) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"bumpfee is not available with wallets that have private keys disabled. Use psbtbumpfee instead.\");\n@@ -3514,7 +3483,8 @@ static RPCHelpMan bumpfee_helper(std::string method_name)\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n     LOCK(pwallet->cs_wallet);\n-    EnsureWalletIsUnlocked(pwallet);\n+\n+    EnsureWalletIsUnlocked(*pwallet);\n \n \n     std::vector<bilingual_str> errors;\n@@ -3608,17 +3578,16 @@ static RPCHelpMan rescanblockchain()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     WalletRescanReserver reserver(*pwallet);\n     if (!reserver.reserve()) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Wallet is currently rescanning. Abort existing rescan or wait.\");\n     }\n \n     int start_height = 0;\n-    Optional<int> stop_height;\n+    std::optional<int> stop_height;\n     uint256 start_block;\n     {\n         LOCK(pwallet->cs_wallet);\n@@ -3759,15 +3728,13 @@ class DescribeWalletAddressVisitor\n     UniValue operator()(const WitnessUnknown& id) const { return UniValue(UniValue::VOBJ); }\n };\n \n-static UniValue DescribeWalletAddress(const CWallet* const pwallet, const CTxDestination& dest)\n+static UniValue DescribeWalletAddress(const CWallet& wallet, const CTxDestination& dest)\n {\n     UniValue ret(UniValue::VOBJ);\n     UniValue detail = DescribeAddress(dest);\n     CScript script = GetScriptForDestination(dest);\n     std::unique_ptr<SigningProvider> provider = nullptr;\n-    if (pwallet) {\n-        provider = pwallet->GetSolvingProvider(script);\n-    }\n+    provider = wallet.GetSolvingProvider(script);\n     ret.pushKVs(detail);\n     ret.pushKVs(std::visit(DescribeWalletAddressVisitor(provider.get()), dest));\n     return ret;\n@@ -3840,9 +3807,8 @@ RPCHelpMan getaddressinfo()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -3887,7 +3853,7 @@ RPCHelpMan getaddressinfo()\n \n     ret.pushKV(\"iswatchonly\", bool(mine & ISMINE_WATCH_ONLY));\n \n-    UniValue detail = DescribeWalletAddress(pwallet, dest);\n+    UniValue detail = DescribeWalletAddress(*pwallet, dest);\n     ret.pushKVs(detail);\n \n     ret.pushKV(\"ischange\", pwallet->IsChange(scriptPubKey));\n@@ -3943,9 +3909,8 @@ static RPCHelpMan getaddressesbylabel()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -4005,9 +3970,8 @@ static RPCHelpMan listlabels()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -4130,9 +4094,8 @@ static RPCHelpMan send()\n                 }, true\n             );\n \n-            std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-            if (!wallet) return NullUniValue;\n-            CWallet* const pwallet = wallet.get();\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n             if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n@@ -4185,7 +4148,7 @@ static RPCHelpMan send()\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n-            FundTransaction(pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n+            FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n             bool add_to_wallet = true;\n             if (options.exists(\"add_to_wallet\")) {\n@@ -4258,9 +4221,8 @@ static RPCHelpMan sethdseed()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LegacyScriptPubKeyMan& spk_man = EnsureLegacyScriptPubKeyMan(*pwallet, true);\n \n@@ -4275,7 +4237,7 @@ static RPCHelpMan sethdseed()\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot set an HD seed on a non-HD wallet. Use the upgradewallet RPC in order to upgrade a non-HD wallet to HD\");\n     }\n \n-    EnsureWalletIsUnlocked(pwallet);\n+    EnsureWalletIsUnlocked(*pwallet);\n \n     bool flush_key_pool = true;\n     if (!request.params[0].isNull()) {\n@@ -4336,9 +4298,8 @@ static RPCHelpMan walletprocesspsbt()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL, UniValue::VSTR});\n \n@@ -4448,9 +4409,8 @@ static RPCHelpMan walletcreatefundedpsbt()\n                                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     RPCTypeCheck(request.params, {\n         UniValue::VARR,\n@@ -4474,7 +4434,7 @@ static RPCHelpMan walletcreatefundedpsbt()\n     // Automatically select coins, unless at least one is manually selected. Can\n     // be overridden by options.add_inputs.\n     coin_control.m_add_inputs = rawTx.vin.size() == 0;\n-    FundTransaction(pwallet, rawTx, fee, change_position, request.params[3], coin_control, /* override_min_fee */ true);\n+    FundTransaction(*pwallet, rawTx, fee, change_position, request.params[3], coin_control, /* override_min_fee */ true);\n \n     // Make a blank psbt\n     PartiallySignedTransaction psbtx(rawTx);\n@@ -4524,13 +4484,12 @@ static RPCHelpMan upgradewallet()\n         },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     RPCTypeCheck(request.params, {UniValue::VNUM}, true);\n \n-    EnsureWalletIsUnlocked(pwallet);\n+    EnsureWalletIsUnlocked(*pwallet);\n \n     int version = 0;\n     if (!request.params[0].isNull()) {"
      },
      {
        "sha": "b82fe1ec76870de6e24c5162816d5319acaeafda",
        "filename": "src/wallet/rpcwallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/rpcwallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/rpcwallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -30,7 +30,7 @@ Span<const CRPCCommand> GetWalletRPCCommands();\n  */\n std::shared_ptr<CWallet> GetWalletForJSONRPCRequest(const JSONRPCRequest& request);\n \n-void EnsureWalletIsUnlocked(const CWallet*);\n+void EnsureWalletIsUnlocked(const CWallet&);\n WalletContext& EnsureWalletContext(const util::Ref& context);\n LegacyScriptPubKeyMan& EnsureLegacyScriptPubKeyMan(CWallet& wallet, bool also_create = false);\n "
      },
      {
        "sha": "6d912be019424e986e1f54e07ab6826169fd8038",
        "filename": "src/wallet/salvage.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/salvage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/salvage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/salvage.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -119,7 +119,7 @@ bool RecoverDatabaseFile(const fs::path& file_path, bilingual_str& error, std::v\n         return false;\n     }\n \n-    std::unique_ptr<Db> pdbCopy = MakeUnique<Db>(env->dbenv.get(), 0);\n+    std::unique_ptr<Db> pdbCopy = std::make_unique<Db>(env->dbenv.get(), 0);\n     int ret = pdbCopy->open(nullptr,               // Txn pointer\n                             filename.c_str(),   // Filename\n                             \"main\",             // Logical db name"
      },
      {
        "sha": "54319ca662225be7fa4c4bbe8ccd13b12773b6cc",
        "filename": "src/wallet/scriptpubkeyman.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 11,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/scriptpubkeyman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/scriptpubkeyman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -16,6 +16,8 @@\n #include <wallet/external_signer.h>\n #include <wallet/scriptpubkeyman.h>\n \n+#include <optional>\n+\n //! Value for the first BIP 32 hardened derivation. Can be used as a bit mask and as a value. See BIP 32 for more details.\n const uint32_t BIP32_HARDENED_KEY_LIMIT = 0x80000000;\n \n@@ -378,7 +380,7 @@ void LegacyScriptPubKeyMan::UpgradeKeyMetadata()\n         return;\n     }\n \n-    std::unique_ptr<WalletBatch> batch = MakeUnique<WalletBatch>(m_storage.GetDatabase());\n+    std::unique_ptr<WalletBatch> batch = std::make_unique<WalletBatch>(m_storage.GetDatabase());\n     for (auto& meta_pair : mapKeyMetadata) {\n         CKeyMetadata& meta = meta_pair.second;\n         if (!meta.hd_seed_id.IsNull() && !meta.has_key_origin && meta.hdKeypath != \"s\") { // If the hdKeypath is \"s\", that's the seed and it doesn't have a key origin\n@@ -551,7 +553,7 @@ int64_t LegacyScriptPubKeyMan::GetTimeFirstKey() const\n \n std::unique_ptr<SigningProvider> LegacyScriptPubKeyMan::GetSolvingProvider(const CScript& script) const\n {\n-    return MakeUnique<LegacySigningProvider>(*this);\n+    return std::make_unique<LegacySigningProvider>(*this);\n }\n \n bool LegacyScriptPubKeyMan::CanProvide(const CScript& script, SignatureData& sigdata)\n@@ -651,14 +653,14 @@ std::unique_ptr<CKeyMetadata> LegacyScriptPubKeyMan::GetMetadata(const CTxDestin\n     if (!key_id.IsNull()) {\n         auto it = mapKeyMetadata.find(key_id);\n         if (it != mapKeyMetadata.end()) {\n-            return MakeUnique<CKeyMetadata>(it->second);\n+            return std::make_unique<CKeyMetadata>(it->second);\n         }\n     }\n \n     CScript scriptPubKey = GetScriptForDestination(dest);\n     auto it = m_script_metadata.find(CScriptID(scriptPubKey));\n     if (it != m_script_metadata.end()) {\n-        return MakeUnique<CKeyMetadata>(it->second);\n+        return std::make_unique<CKeyMetadata>(it->second);\n     }\n \n     return nullptr;\n@@ -1607,7 +1609,7 @@ bool DescriptorScriptPubKeyMan::GetNewDestination(const OutputType type, CTxDest\n     {\n         LOCK(cs_desc_man);\n         assert(m_wallet_descriptor.descriptor->IsSingleType()); // This is a combo descriptor which should not be an active descriptor\n-        Optional<OutputType> desc_addr_type = m_wallet_descriptor.descriptor->GetOutputType();\n+        std::optional<OutputType> desc_addr_type = m_wallet_descriptor.descriptor->GetOutputType();\n         assert(desc_addr_type);\n         if (type != *desc_addr_type) {\n             throw std::runtime_error(std::string(__func__) + \": Types are inconsistent\");\n@@ -1629,7 +1631,7 @@ bool DescriptorScriptPubKeyMan::GetNewDestination(const OutputType type, CTxDest\n             return false;\n         }\n \n-        Optional<OutputType> out_script_type = m_wallet_descriptor.descriptor->GetOutputType();\n+        std::optional<OutputType> out_script_type = m_wallet_descriptor.descriptor->GetOutputType();\n         if (out_script_type && out_script_type == type) {\n             ExtractDestination(scripts_temp[0], dest);\n         } else {\n@@ -2026,7 +2028,7 @@ std::unique_ptr<FlatSigningProvider> DescriptorScriptPubKeyMan::GetSigningProvid\n {\n     AssertLockHeld(cs_desc_man);\n     // Get the scripts, keys, and key origins for this script\n-    std::unique_ptr<FlatSigningProvider> out_keys = MakeUnique<FlatSigningProvider>();\n+    std::unique_ptr<FlatSigningProvider> out_keys = std::make_unique<FlatSigningProvider>();\n     std::vector<CScript> scripts_temp;\n     if (!m_wallet_descriptor.descriptor->ExpandFromCache(index, m_wallet_descriptor.cache, scripts_temp, *out_keys)) return nullptr;\n \n@@ -2051,7 +2053,7 @@ bool DescriptorScriptPubKeyMan::CanProvide(const CScript& script, SignatureData&\n \n bool DescriptorScriptPubKeyMan::SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, std::string>& input_errors) const\n {\n-    std::unique_ptr<FlatSigningProvider> keys = MakeUnique<FlatSigningProvider>();\n+    std::unique_ptr<FlatSigningProvider> keys = std::make_unique<FlatSigningProvider>();\n     for (const auto& coin_pair : coins) {\n         std::unique_ptr<FlatSigningProvider> coin_keys = GetSigningProvider(coin_pair.second.out.scriptPubKey, true);\n         if (!coin_keys) {\n@@ -2115,13 +2117,13 @@ TransactionError DescriptorScriptPubKeyMan::FillPSBT(PartiallySignedTransaction&\n         SignatureData sigdata;\n         input.FillSignatureData(sigdata);\n \n-        std::unique_ptr<FlatSigningProvider> keys = MakeUnique<FlatSigningProvider>();\n+        std::unique_ptr<FlatSigningProvider> keys = std::make_unique<FlatSigningProvider>();\n         std::unique_ptr<FlatSigningProvider> script_keys = GetSigningProvider(script, sign);\n         if (script_keys) {\n             *keys = Merge(*keys, *script_keys);\n         } else {\n             // Maybe there are pubkeys listed that we can sign for\n-            script_keys = MakeUnique<FlatSigningProvider>();\n+            script_keys = std::make_unique<FlatSigningProvider>();\n             for (const auto& pk_pair : input.hd_keypaths) {\n                 const CPubKey& pubkey = pk_pair.first;\n                 std::unique_ptr<FlatSigningProvider> pk_keys = GetSigningProvider(pubkey);\n@@ -2162,7 +2164,7 @@ std::unique_ptr<CKeyMetadata> DescriptorScriptPubKeyMan::GetMetadata(const CTxDe\n         CKeyID key_id = GetKeyForDestination(*provider, dest);\n         if (provider->GetKeyOrigin(key_id, orig)) {\n             LOCK(cs_desc_man);\n-            std::unique_ptr<CKeyMetadata> meta = MakeUnique<CKeyMetadata>();\n+            std::unique_ptr<CKeyMetadata> meta = std::make_unique<CKeyMetadata>();\n             meta->key_origin = orig;\n             meta->has_key_origin = true;\n             meta->nCreateTime = m_wallet_descriptor.creation_time;"
      },
      {
        "sha": "975974cb6a261f1124479aa84cec5fe6939d8bba",
        "filename": "src/wallet/sqlite.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/sqlite.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/sqlite.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/sqlite.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -8,7 +8,6 @@\n #include <crypto/common.h>\n #include <logging.h>\n #include <sync.h>\n-#include <util/memory.h>\n #include <util/strencodings.h>\n #include <util/system.h>\n #include <util/translation.h>\n@@ -330,7 +329,7 @@ void SQLiteDatabase::Close()\n std::unique_ptr<DatabaseBatch> SQLiteDatabase::MakeBatch(bool flush_on_close)\n {\n     // We ignore flush_on_close because we don't do manual flushing for SQLite\n-    return MakeUnique<SQLiteBatch>(*this);\n+    return std::make_unique<SQLiteBatch>(*this);\n }\n \n SQLiteBatch::SQLiteBatch(SQLiteDatabase& database)\n@@ -571,7 +570,7 @@ std::unique_ptr<SQLiteDatabase> MakeSQLiteDatabase(const fs::path& path, const D\n {\n     try {\n         fs::path data_file = SQLiteDataFile(path);\n-        auto db = MakeUnique<SQLiteDatabase>(data_file.parent_path(), data_file);\n+        auto db = std::make_unique<SQLiteDatabase>(data_file.parent_path(), data_file);\n         if (options.verify && !db->Verify(error)) {\n             status = DatabaseStatus::FAILED_VERIFY;\n             return nullptr;"
      },
      {
        "sha": "7eff6e592da7e3071bd0ed5f14a9052659f11166",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 6,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -35,7 +35,10 @@ static CAmount balance = 0;\n CoinEligibilityFilter filter_standard(1, 6, 0);\n CoinEligibilityFilter filter_confirmed(1, 1, 0);\n CoinEligibilityFilter filter_standard_extra(6, 6, 0);\n-CoinSelectionParams coin_selection_params(false, 0, 0, CFeeRate(0), 0, false);\n+CoinSelectionParams coin_selection_params(/* use_bnb= */ false, /* change_output_size= */ 0,\n+                                          /* change_spend_size= */ 0, /* effective_feerate= */ CFeeRate(0),\n+                                          /* long_term_feerate= */ CFeeRate(0), /* discard_feerate= */ CFeeRate(0),\n+                                          /* tx_no_inputs_size= */ 0, /* avoid_partial= */ false);\n \n static void add_coin(const CAmount& nValue, int nInput, std::vector<CInputCoin>& set)\n {\n@@ -269,7 +272,10 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     }\n \n     // Make sure that effective value is working in SelectCoinsMinConf when BnB is used\n-    CoinSelectionParams coin_selection_params_bnb(true, 0, 0, CFeeRate(3000), 0, false);\n+    CoinSelectionParams coin_selection_params_bnb(/* use_bnb= */ true, /* change_output_size= */ 0,\n+                                                  /* change_spend_size= */ 0, /* effective_feerate= */ CFeeRate(3000),\n+                                                  /* long_term_feerate= */ CFeeRate(1000), /* discard_feerate= */ CFeeRate(1000),\n+                                                  /* tx_no_inputs_size= */ 0, /* avoid_partial= */ false);\n     CoinSet setCoinsRet;\n     CAmount nValueRet;\n     bool bnb_used;\n@@ -290,7 +296,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     // Make sure that can use BnB when there are preset inputs\n     empty_wallet();\n     {\n-        std::unique_ptr<CWallet> wallet = MakeUnique<CWallet>(m_node.chain.get(), \"\", CreateMockWalletDatabase());\n+        std::unique_ptr<CWallet> wallet = std::make_unique<CWallet>(m_node.chain.get(), \"\", CreateMockWalletDatabase());\n         bool firstRun;\n         wallet->LoadWallet(firstRun);\n         wallet->SetupLegacyScriptPubKeyMan();\n@@ -301,7 +307,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         CCoinControl coin_control;\n         coin_control.fAllowOtherInputs = true;\n         coin_control.Select(COutPoint(vCoins.at(0).tx->GetHash(), vCoins.at(0).i));\n-        coin_selection_params_bnb.effective_fee = CFeeRate(0);\n+        coin_selection_params_bnb.m_effective_feerate = CFeeRate(0);\n         BOOST_CHECK(wallet->SelectCoins(vCoins, 10 * CENT, setCoinsRet, nValueRet, coin_control, coin_selection_params_bnb, bnb_used));\n         BOOST_CHECK(bnb_used);\n         BOOST_CHECK(coin_selection_params_bnb.use_bnb);\n@@ -639,8 +645,14 @@ BOOST_AUTO_TEST_CASE(SelectCoins_test)\n         CAmount target = rand.randrange(balance - 1000) + 1000;\n \n         // Perform selection\n-        CoinSelectionParams coin_selection_params_knapsack(false, 34, 148, CFeeRate(0), 0, false);\n-        CoinSelectionParams coin_selection_params_bnb(true, 34, 148, CFeeRate(0), 0, false);\n+        CoinSelectionParams coin_selection_params_knapsack(/* use_bnb= */ false, /* change_output_size= */ 34,\n+                                                           /* change_spend_size= */ 148, /* effective_feerate= */ CFeeRate(0),\n+                                                           /* long_term_feerate= */ CFeeRate(0), /* discard_feerate= */ CFeeRate(0),\n+                                                           /* tx_no_inputs_size= */ 0, /* avoid_partial= */ false);\n+        CoinSelectionParams coin_selection_params_bnb(/* use_bnb= */ true, /* change_output_size= */ 34,\n+                                                      /* change_spend_size= */ 148, /* effective_feerate= */ CFeeRate(0),\n+                                                      /* long_term_feerate= */ CFeeRate(0), /* discard_feerate= */ CFeeRate(0),\n+                                                      /* tx_no_inputs_size= */ 0, /* avoid_partial= */ false);\n         CoinSet out_set;\n         CAmount out_value = 0;\n         bool bnb_used = false;"
      },
      {
        "sha": "30cc4520657a86ffb5168ee223d5f70402f920f4",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -228,7 +228,7 @@ BOOST_FIXTURE_TEST_CASE(importmulti_rescan, TestChain100Setup)\n                       \"downloading and rescanning the relevant blocks (see -reindex and -rescan \"\n                       \"options).\\\"}},{\\\"success\\\":true}]\",\n                               0, oldTip->GetBlockTimeMax(), TIMESTAMP_WINDOW));\n-        RemoveWallet(wallet, nullopt);\n+        RemoveWallet(wallet, std::nullopt);\n     }\n }\n \n@@ -271,7 +271,7 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n         request.params.push_back(backup_file);\n \n         ::dumpwallet().HandleRequest(request);\n-        RemoveWallet(wallet, nullopt);\n+        RemoveWallet(wallet, std::nullopt);\n     }\n \n     // Call importwallet RPC and verify all blocks with timestamps >= BLOCK_TIME\n@@ -288,7 +288,7 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n         AddWallet(wallet);\n         wallet->SetLastBlockProcessed(::ChainActive().Height(), ::ChainActive().Tip()->GetBlockHash());\n         ::importwallet().HandleRequest(request);\n-        RemoveWallet(wallet, nullopt);\n+        RemoveWallet(wallet, std::nullopt);\n \n         BOOST_CHECK_EQUAL(wallet->mapWallet.size(), 3U);\n         BOOST_CHECK_EQUAL(m_coinbase_txns.size(), 103U);\n@@ -485,7 +485,7 @@ class ListCoinsTestingSetup : public TestChain100Setup\n     ListCoinsTestingSetup()\n     {\n         CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n-        wallet = MakeUnique<CWallet>(m_node.chain.get(), \"\", CreateMockWalletDatabase());\n+        wallet = std::make_unique<CWallet>(m_node.chain.get(), \"\", CreateMockWalletDatabase());\n         {\n             LOCK2(wallet->cs_wallet, ::cs_main);\n             wallet->SetLastBlockProcessed(::ChainActive().Height(), ::ChainActive().Tip()->GetBlockHash());"
      },
      {
        "sha": "b00fa851fd988633aa82b4109b77b92711012afb",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 66,
        "deletions": 47,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -13,7 +13,6 @@\n #include <interfaces/wallet.h>\n #include <key.h>\n #include <key_io.h>\n-#include <optional.h>\n #include <outputtype.h>\n #include <policy/fees.h>\n #include <policy/policy.h>\n@@ -40,6 +39,7 @@\n \n #include <algorithm>\n #include <assert.h>\n+#include <optional>\n \n #include <boost/algorithm/string/replace.hpp>\n \n@@ -84,10 +84,10 @@ bool RemoveWalletSetting(interfaces::Chain& chain, const std::string& wallet_nam\n \n static void UpdateWalletSetting(interfaces::Chain& chain,\n                                 const std::string& wallet_name,\n-                                Optional<bool> load_on_startup,\n+                                std::optional<bool> load_on_startup,\n                                 std::vector<bilingual_str>& warnings)\n {\n-    if (load_on_startup == nullopt) return;\n+    if (!load_on_startup) return;\n     if (load_on_startup.value() && !AddWalletSetting(chain, wallet_name)) {\n         warnings.emplace_back(Untranslated(\"Wallet load on startup setting could not be updated, so wallet may not be loaded next node startup.\"));\n     } else if (!load_on_startup.value() && !RemoveWalletSetting(chain, wallet_name)) {\n@@ -107,7 +107,7 @@ bool AddWallet(const std::shared_ptr<CWallet>& wallet)\n     return true;\n }\n \n-bool RemoveWallet(const std::shared_ptr<CWallet>& wallet, Optional<bool> load_on_start, std::vector<bilingual_str>& warnings)\n+bool RemoveWallet(const std::shared_ptr<CWallet>& wallet, std::optional<bool> load_on_start, std::vector<bilingual_str>& warnings)\n {\n     assert(wallet);\n \n@@ -127,7 +127,7 @@ bool RemoveWallet(const std::shared_ptr<CWallet>& wallet, Optional<bool> load_on\n     return true;\n }\n \n-bool RemoveWallet(const std::shared_ptr<CWallet>& wallet, Optional<bool> load_on_start)\n+bool RemoveWallet(const std::shared_ptr<CWallet>& wallet, std::optional<bool> load_on_start)\n {\n     std::vector<bilingual_str> warnings;\n     return RemoveWallet(wallet, load_on_start, warnings);\n@@ -204,7 +204,7 @@ void UnloadWallet(std::shared_ptr<CWallet>&& wallet)\n }\n \n namespace {\n-std::shared_ptr<CWallet> LoadWalletInternal(interfaces::Chain& chain, const std::string& name, Optional<bool> load_on_start, const DatabaseOptions& options, DatabaseStatus& status, bilingual_str& error, std::vector<bilingual_str>& warnings)\n+std::shared_ptr<CWallet> LoadWalletInternal(interfaces::Chain& chain, const std::string& name, std::optional<bool> load_on_start, const DatabaseOptions& options, DatabaseStatus& status, bilingual_str& error, std::vector<bilingual_str>& warnings)\n {\n     try {\n         std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(name, options, status, error);\n@@ -234,11 +234,11 @@ std::shared_ptr<CWallet> LoadWalletInternal(interfaces::Chain& chain, const std:\n }\n } // namespace\n \n-std::shared_ptr<CWallet> LoadWallet(interfaces::Chain& chain, const std::string& name, Optional<bool> load_on_start, const DatabaseOptions& options, DatabaseStatus& status, bilingual_str& error, std::vector<bilingual_str>& warnings)\n+std::shared_ptr<CWallet> LoadWallet(interfaces::Chain& chain, const std::string& name, std::optional<bool> load_on_start, const DatabaseOptions& options, DatabaseStatus& status, bilingual_str& error, std::vector<bilingual_str>& warnings)\n {\n     auto result = WITH_LOCK(g_loading_wallet_mutex, return g_loading_wallet_set.insert(name));\n     if (!result.second) {\n-        error = Untranslated(\"Wallet already being loading.\");\n+        error = Untranslated(\"Wallet already loading.\");\n         status = DatabaseStatus::FAILED_LOAD;\n         return nullptr;\n     }\n@@ -247,7 +247,7 @@ std::shared_ptr<CWallet> LoadWallet(interfaces::Chain& chain, const std::string&\n     return wallet;\n }\n \n-std::shared_ptr<CWallet> CreateWallet(interfaces::Chain& chain, const std::string& name, Optional<bool> load_on_start, DatabaseOptions& options, DatabaseStatus& status, bilingual_str& error, std::vector<bilingual_str>& warnings)\n+std::shared_ptr<CWallet> CreateWallet(interfaces::Chain& chain, const std::string& name, std::optional<bool> load_on_start, DatabaseOptions& options, DatabaseStatus& status, bilingual_str& error, std::vector<bilingual_str>& warnings)\n {\n     uint64_t wallet_creation_flags = options.create_flags;\n     const SecureString& passphrase = options.create_passphrase;\n@@ -791,6 +791,12 @@ bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n \n     wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();\n \n+    // Refresh mempool status without waiting for transactionRemovedFromMempool\n+    // notification so the wallet is in an internally consistent state and\n+    // immediately knows the old transaction should not be considered trusted\n+    // and is eligible to be abandoned\n+    wtx.fInMempool = chain().isInMempool(originalHash);\n+\n     WalletBatch batch(GetDatabase());\n \n     bool success = true;\n@@ -938,6 +944,14 @@ CWalletTx* CWallet::AddToWallet(CTransactionRef tx, const CWalletTx::Confirmatio\n     if (!strCmd.empty())\n     {\n         boost::replace_all(strCmd, \"%s\", hash.GetHex());\n+        if (confirm.status == CWalletTx::Status::CONFIRMED)\n+        {\n+            boost::replace_all(strCmd, \"%b\", confirm.hashBlock.GetHex());\n+            boost::replace_all(strCmd, \"%h\", ToString(confirm.block_height));\n+        } else {\n+            boost::replace_all(strCmd, \"%b\", \"unconfirmed\");\n+            boost::replace_all(strCmd, \"%h\", \"-1\");\n+        }\n #ifndef WIN32\n         // Substituting the wallet name isn't currently supported on windows\n         // because windows shell escaping has not been implemented yet:\n@@ -1611,14 +1625,15 @@ bool CWallet::ImportScriptPubKeys(const std::string& label, const std::set<CScri\n     return true;\n }\n \n-int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, bool use_max_sig)\n+// Returns pair of vsize and weight\n+std::pair<int64_t, int64_t> CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, bool use_max_sig)\n {\n     std::vector<CTxOut> txouts;\n     for (const CTxIn& input : tx.vin) {\n         const auto mi = wallet->mapWallet.find(input.prevout.hash);\n         // Can not estimate size without knowing the input details\n         if (mi == wallet->mapWallet.end()) {\n-            return -1;\n+            return std::make_pair(-1, -1);\n         }\n         assert(input.prevout.n < mi->second.tx->vout.size());\n         txouts.emplace_back(mi->second.tx->vout[input.prevout.n]);\n@@ -1627,13 +1642,16 @@ int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wall\n }\n \n // txouts needs to be in the order of tx.vin\n-int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, const std::vector<CTxOut>& txouts, bool use_max_sig)\n+std::pair<int64_t, int64_t> CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, const std::vector<CTxOut>& txouts, bool use_max_sig)\n {\n     CMutableTransaction txNew(tx);\n     if (!wallet->DummySignTx(txNew, txouts, use_max_sig)) {\n-        return -1;\n+        return std::make_pair(-1, -1);\n     }\n-    return GetVirtualTransactionSize(CTransaction(txNew));\n+    CTransaction ctx(txNew);\n+    int64_t vsize = GetVirtualTransactionSize(ctx);\n+    int64_t weight = GetTransactionWeight(ctx);\n+    return std::make_pair(vsize, weight);\n }\n \n int CalculateMaximumSignedInputSize(const CTxOut& txout, const CWallet* wallet, bool use_max_sig)\n@@ -1753,7 +1771,7 @@ int64_t CWallet::RescanFromTime(int64_t startTime, const WalletRescanReserver& r\n  * the main chain after to the addition of any new keys you want to detect\n  * transactions for.\n  */\n-CWallet::ScanResult CWallet::ScanForWalletTransactions(const uint256& start_block, int start_height, Optional<int> max_height, const WalletRescanReserver& reserver, bool fUpdate)\n+CWallet::ScanResult CWallet::ScanForWalletTransactions(const uint256& start_block, int start_height, std::optional<int> max_height, const WalletRescanReserver& reserver, bool fUpdate)\n {\n     int64_t nNow = GetTime();\n     int64_t start_time = GetTimeMillis();\n@@ -2381,26 +2399,20 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n     nValueRet = 0;\n \n     if (coin_selection_params.use_bnb) {\n-        // Get long term estimate\n-        FeeCalculation feeCalc;\n-        CCoinControl temp;\n-        temp.m_confirm_target = 1008;\n-        CFeeRate long_term_feerate = GetMinimumFeeRate(*this, temp, &feeCalc);\n-\n         // Get the feerate for effective value.\n         // When subtracting the fee from the outputs, we want the effective feerate to be 0\n         CFeeRate effective_feerate{0};\n         if (!coin_selection_params.m_subtract_fee_outputs) {\n-            effective_feerate = coin_selection_params.effective_fee;\n+            effective_feerate = coin_selection_params.m_effective_feerate;\n         }\n \n-        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, effective_feerate, long_term_feerate, eligibility_filter, true /* positive_only */);\n+        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, effective_feerate, coin_selection_params.m_long_term_feerate, eligibility_filter, true /* positive_only */);\n \n         // Calculate cost of change\n-        CAmount cost_of_change = GetDiscardRate(*this).GetFee(coin_selection_params.change_spend_size) + coin_selection_params.effective_fee.GetFee(coin_selection_params.change_output_size);\n+        CAmount cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n \n         // Calculate the fees for things that aren't inputs\n-        CAmount not_input_fees = coin_selection_params.effective_fee.GetFee(coin_selection_params.tx_noinputs_size);\n+        CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n         bnb_used = true;\n         return SelectCoinsBnB(groups, nTargetValue, cost_of_change, setCoinsRet, nValueRet, not_input_fees);\n     } else {\n@@ -2454,7 +2466,7 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n             if (coin.m_input_bytes <= 0) {\n                 return false; // Not solvable, can't estimate size for fee\n             }\n-            coin.effective_value = coin.txout.nValue - coin_selection_params.effective_fee.GetFee(coin.m_input_bytes);\n+            coin.effective_value = coin.txout.nValue - coin_selection_params.m_effective_feerate.GetFee(coin.m_input_bytes);\n             if (coin_selection_params.use_bnb) {\n                 value_to_select -= coin.effective_value;\n             } else {\n@@ -2715,7 +2727,7 @@ static uint32_t GetLocktimeForNewTransaction(interfaces::Chain& chain, const uin\n     return locktime;\n }\n \n-OutputType CWallet::TransactionChangeType(const Optional<OutputType>& change_type, const std::vector<CRecipient>& vecSend) const\n+OutputType CWallet::TransactionChangeType(const std::optional<OutputType>& change_type, const std::vector<CRecipient>& vecSend) const\n {\n     // If -changetype is specified, always use that change type.\n     if (change_type) {\n@@ -2779,6 +2791,7 @@ bool CWallet::CreateTransactionInternal(\n     CMutableTransaction txNew;\n     FeeCalculation feeCalc;\n     CAmount nFeeNeeded;\n+    std::pair<int64_t, int64_t> tx_sizes;\n     int nBytes;\n     {\n         std::set<CInputCoin> setCoins;\n@@ -2821,16 +2834,27 @@ bool CWallet::CreateTransactionInternal(\n             CTxOut change_prototype_txout(0, scriptChange);\n             coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n \n-            CFeeRate discard_rate = GetDiscardRate(*this);\n+            // Set discard feerate\n+            coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n \n             // Get the fee rate to use effective values in coin selection\n-            CFeeRate nFeeRateNeeded = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n+            coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n             // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n             // provided one\n-            if (coin_control.m_feerate && nFeeRateNeeded > *coin_control.m_feerate) {\n-                error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), nFeeRateNeeded.ToString(FeeEstimateMode::SAT_VB));\n+            if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n+                error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n                 return false;\n             }\n+            if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+                return false;\n+            }\n+\n+            // Get long term estimate\n+            CCoinControl cc_temp;\n+            cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n+            coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n \n             nFeeRet = 0;\n             bool pick_new_inputs = true;\n@@ -2905,7 +2929,6 @@ bool CWallet::CreateTransactionInternal(\n                     } else {\n                         coin_selection_params.change_spend_size = (size_t)change_spend_size;\n                     }\n-                    coin_selection_params.effective_fee = nFeeRateNeeded;\n                     if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, bnb_used))\n                     {\n                         // If BnB was used, it was the first pass. No longer the first pass and continue loop with knapsack.\n@@ -2931,7 +2954,7 @@ bool CWallet::CreateTransactionInternal(\n                     // Never create dust outputs; if we would, just\n                     // add the dust to the fee.\n                     // The nChange when BnB is used is always going to go to fees.\n-                    if (IsDust(newTxOut, discard_rate) || bnb_used)\n+                    if (IsDust(newTxOut, coin_selection_params.m_discard_feerate) || bnb_used)\n                     {\n                         nChangePosInOut = -1;\n                         nFeeRet += nChange;\n@@ -2962,19 +2985,14 @@ bool CWallet::CreateTransactionInternal(\n                     txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n                 }\n \n-                nBytes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+                tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+                nBytes = tx_sizes.first;\n                 if (nBytes < 0) {\n                     error = _(\"Signing transaction failed\");\n                     return false;\n                 }\n \n-                nFeeNeeded = GetMinimumFee(*this, nBytes, coin_control, &feeCalc);\n-                if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n-                    // eventually allow a fallback fee\n-                    error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n-                    return false;\n-                }\n-\n+                nFeeNeeded = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n                 if (nFeeRet >= nFeeNeeded) {\n                     // Reduce fee to only the needed amount if possible. This\n                     // prevents potential overpayment in fees if the coins\n@@ -2988,8 +3006,8 @@ bool CWallet::CreateTransactionInternal(\n                     // change output. Only try this once.\n                     if (nChangePosInOut == -1 && nSubtractFeeFromAmount == 0 && pick_new_inputs) {\n                         unsigned int tx_size_with_change = nBytes + coin_selection_params.change_output_size + 2; // Add 2 as a buffer in case increasing # of outputs changes compact size\n-                        CAmount fee_needed_with_change = GetMinimumFee(*this, tx_size_with_change, coin_control, nullptr);\n-                        CAmount minimum_value_for_change = GetDustThreshold(change_prototype_txout, discard_rate);\n+                        CAmount fee_needed_with_change = coin_selection_params.m_effective_feerate.GetFee(tx_size_with_change);\n+                        CAmount minimum_value_for_change = GetDustThreshold(change_prototype_txout, coin_selection_params.m_discard_feerate);\n                         if (nFeeRet >= fee_needed_with_change + minimum_value_for_change) {\n                             pick_new_inputs = false;\n                             nFeeRet = fee_needed_with_change;\n@@ -3072,7 +3090,8 @@ bool CWallet::CreateTransactionInternal(\n         tx = MakeTransactionRef(std::move(txNew));\n \n         // Limit size\n-        if (GetTransactionWeight(*tx) > MAX_STANDARD_TX_WEIGHT)\n+        if ((sign && GetTransactionWeight(*tx) > MAX_STANDARD_TX_WEIGHT) ||\n+            (!sign && tx_sizes.second > MAX_STANDARD_TX_WEIGHT))\n         {\n             error = _(\"Transaction too large\");\n             return false;\n@@ -4054,13 +4073,13 @@ std::shared_ptr<CWallet> CWallet::Create(interfaces::Chain& chain, const std::st\n         WalletBatch batch(walletInstance->GetDatabase());\n         CBlockLocator locator;\n         if (batch.ReadBestBlock(locator)) {\n-            if (const Optional<int> fork_height = chain.findLocatorFork(locator)) {\n+            if (const std::optional<int> fork_height = chain.findLocatorFork(locator)) {\n                 rescan_height = *fork_height;\n             }\n         }\n     }\n \n-    const Optional<int> tip_height = chain.getHeight();\n+    const std::optional<int> tip_height = chain.getHeight();\n     if (tip_height) {\n         walletInstance->m_last_block_processed = chain.getBlockHash(*tip_height);\n         walletInstance->m_last_block_processed_height = *tip_height;\n@@ -4094,7 +4113,7 @@ std::shared_ptr<CWallet> CWallet::Create(interfaces::Chain& chain, const std::st\n \n         // No need to read and scan block if block was created before\n         // our wallet birthday (as adjusted for block time variability)\n-        Optional<int64_t> time_first_key;\n+        std::optional<int64_t> time_first_key;\n         for (auto spk_man : walletInstance->GetAllScriptPubKeyMans()) {\n             int64_t time = spk_man->GetTimeFirstKey();\n             if (!time_first_key || time < *time_first_key) time_first_key = time;"
      },
      {
        "sha": "6031d36b97c570293272c8f3d7d2d01e863a9ef2",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 19,
        "deletions": 13,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -30,6 +30,7 @@\n #include <atomic>\n #include <map>\n #include <memory>\n+#include <optional>\n #include <set>\n #include <stdexcept>\n #include <stdint.h>\n@@ -51,12 +52,12 @@ struct bilingual_str;\n void UnloadWallet(std::shared_ptr<CWallet>&& wallet);\n \n bool AddWallet(const std::shared_ptr<CWallet>& wallet);\n-bool RemoveWallet(const std::shared_ptr<CWallet>& wallet, Optional<bool> load_on_start, std::vector<bilingual_str>& warnings);\n-bool RemoveWallet(const std::shared_ptr<CWallet>& wallet, Optional<bool> load_on_start);\n+bool RemoveWallet(const std::shared_ptr<CWallet>& wallet, std::optional<bool> load_on_start, std::vector<bilingual_str>& warnings);\n+bool RemoveWallet(const std::shared_ptr<CWallet>& wallet, std::optional<bool> load_on_start);\n std::vector<std::shared_ptr<CWallet>> GetWallets();\n std::shared_ptr<CWallet> GetWallet(const std::string& name);\n-std::shared_ptr<CWallet> LoadWallet(interfaces::Chain& chain, const std::string& name, Optional<bool> load_on_start, const DatabaseOptions& options, DatabaseStatus& status, bilingual_str& error, std::vector<bilingual_str>& warnings);\n-std::shared_ptr<CWallet> CreateWallet(interfaces::Chain& chain, const std::string& name, Optional<bool> load_on_start, DatabaseOptions& options, DatabaseStatus& status, bilingual_str& error, std::vector<bilingual_str>& warnings);\n+std::shared_ptr<CWallet> LoadWallet(interfaces::Chain& chain, const std::string& name, std::optional<bool> load_on_start, const DatabaseOptions& options, DatabaseStatus& status, bilingual_str& error, std::vector<bilingual_str>& warnings);\n+std::shared_ptr<CWallet> CreateWallet(interfaces::Chain& chain, const std::string& name, std::optional<bool> load_on_start, DatabaseOptions& options, DatabaseStatus& status, bilingual_str& error, std::vector<bilingual_str>& warnings);\n std::unique_ptr<interfaces::Handler> HandleLoadWallet(LoadWalletFn load_wallet);\n std::unique_ptr<WalletDatabase> MakeWalletDatabase(const std::string& name, const DatabaseOptions& options, DatabaseStatus& status, bilingual_str& error);\n \n@@ -608,17 +609,22 @@ struct CoinSelectionParams\n     bool use_bnb = true;\n     size_t change_output_size = 0;\n     size_t change_spend_size = 0;\n-    CFeeRate effective_fee = CFeeRate(0);\n+    CFeeRate m_effective_feerate;\n+    CFeeRate m_long_term_feerate;\n+    CFeeRate m_discard_feerate;\n     size_t tx_noinputs_size = 0;\n     //! Indicate that we are subtracting the fee from outputs\n     bool m_subtract_fee_outputs = false;\n     bool m_avoid_partial_spends = false;\n \n-    CoinSelectionParams(bool use_bnb, size_t change_output_size, size_t change_spend_size, CFeeRate effective_fee, size_t tx_noinputs_size, bool avoid_partial) :\n+    CoinSelectionParams(bool use_bnb, size_t change_output_size, size_t change_spend_size, CFeeRate effective_feerate,\n+                        CFeeRate long_term_feerate, CFeeRate discard_feerate, size_t tx_noinputs_size, bool avoid_partial) :\n         use_bnb(use_bnb),\n         change_output_size(change_output_size),\n         change_spend_size(change_spend_size),\n-        effective_fee(effective_fee),\n+        m_effective_feerate(effective_feerate),\n+        m_long_term_feerate(long_term_feerate),\n+        m_discard_feerate(discard_feerate),\n         tx_noinputs_size(tx_noinputs_size),\n         m_avoid_partial_spends(avoid_partial)\n     {}\n@@ -923,15 +929,15 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n         //! Unset if no blocks were scanned due to read errors or the chain\n         //! being empty.\n         uint256 last_scanned_block;\n-        Optional<int> last_scanned_height;\n+        std::optional<int> last_scanned_height;\n \n         //! Height of the most recent block that could not be scanned due to\n         //! read errors or pruning. Will be set if status is FAILURE, unset if\n         //! status is SUCCESS, and may or may not be set if status is\n         //! USER_ABORT.\n         uint256 last_failed_block;\n     };\n-    ScanResult ScanForWalletTransactions(const uint256& start_block, int start_height, Optional<int> max_height, const WalletRescanReserver& reserver, bool fUpdate);\n+    ScanResult ScanForWalletTransactions(const uint256& start_block, int start_height, std::optional<int> max_height, const WalletRescanReserver& reserver, bool fUpdate);\n     void transactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) override;\n     void ReacceptWalletTransactions() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     void ResendWalletTransactions();\n@@ -946,7 +952,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     Balance GetBalance(int min_depth = 0, bool avoid_reuse = true) const;\n     CAmount GetAvailableBalance(const CCoinControl* coinControl = nullptr) const;\n \n-    OutputType TransactionChangeType(const Optional<OutputType>& change_type, const std::vector<CRecipient>& vecSend) const;\n+    OutputType TransactionChangeType(const std::optional<OutputType>& change_type, const std::vector<CRecipient>& vecSend) const;\n \n     /**\n      * Insert additional inputs into the transaction by\n@@ -1031,7 +1037,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      * (see -changetype option documentation and implementation in\n      * CWallet::TransactionChangeType for details).\n      */\n-    Optional<OutputType> m_default_change_type{};\n+    std::optional<OutputType> m_default_change_type{};\n     /** Absolute maximum transaction fee (in satoshis) used by default for the wallet */\n     CAmount m_default_max_tx_fee{DEFAULT_TRANSACTION_MAXFEE};\n \n@@ -1334,8 +1340,8 @@ class WalletRescanReserver\n // Use DummySignatureCreator, which inserts 71 byte signatures everywhere.\n // NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n // be IsAllFromMe).\n-int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, bool use_max_sig = false) EXCLUSIVE_LOCKS_REQUIRED(wallet->cs_wallet);\n-int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, const std::vector<CTxOut>& txouts, bool use_max_sig = false);\n+std::pair<int64_t, int64_t> CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, bool use_max_sig = false) EXCLUSIVE_LOCKS_REQUIRED(wallet->cs_wallet);\n+std::pair<int64_t, int64_t> CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, const std::vector<CTxOut>& txouts, bool use_max_sig = false);\n \n //! Add wallet name to persistent configuration so it will be loaded on startup.\n bool AddWalletSetting(interfaces::Chain& chain, const std::string& wallet_name);"
      },
      {
        "sha": "3d9248009fdb63e0156f1fa9f1ea08934c8f5543",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -23,6 +23,7 @@\n #include <wallet/wallet.h>\n \n #include <atomic>\n+#include <optional>\n #include <string>\n \n namespace DBKeys {\n@@ -1015,7 +1016,7 @@ std::unique_ptr<WalletDatabase> MakeDatabase(const fs::path& path, const Databas\n         return nullptr;\n     }\n \n-    Optional<DatabaseFormat> format;\n+    std::optional<DatabaseFormat> format;\n     if (exists) {\n         if (IsBDBFile(BDBDataFile(path))) {\n             format = DatabaseFormat::BERKELEY;\n@@ -1086,15 +1087,15 @@ std::unique_ptr<WalletDatabase> MakeDatabase(const fs::path& path, const Databas\n /** Return object for accessing dummy database with no read/write capabilities. */\n std::unique_ptr<WalletDatabase> CreateDummyWalletDatabase()\n {\n-    return MakeUnique<DummyDatabase>();\n+    return std::make_unique<DummyDatabase>();\n }\n \n /** Return object for accessing temporary in-memory database. */\n std::unique_ptr<WalletDatabase> CreateMockWalletDatabase()\n {\n #ifdef USE_BDB\n-    return MakeUnique<BerkeleyDatabase>(std::make_shared<BerkeleyEnvironment>(), \"\");\n+    return std::make_unique<BerkeleyDatabase>(std::make_shared<BerkeleyEnvironment>(), \"\");\n #elif USE_SQLITE\n-    return MakeUnique<SQLiteDatabase>(\"\", \"\", true);\n+    return std::make_unique<SQLiteDatabase>(\"\", \"\", true);\n #endif\n }"
      },
      {
        "sha": "49c1c2a07d58cd0ec55d594165ad4c9e2709f463",
        "filename": "src/zmq/zmqabstractnotifier.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/zmq/zmqabstractnotifier.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/zmq/zmqabstractnotifier.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqabstractnotifier.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -5,7 +5,6 @@\n #ifndef BITCOIN_ZMQ_ZMQABSTRACTNOTIFIER_H\n #define BITCOIN_ZMQ_ZMQABSTRACTNOTIFIER_H\n \n-#include <util/memory.h>\n \n #include <memory>\n #include <string>\n@@ -27,7 +26,7 @@ class CZMQAbstractNotifier\n     template <typename T>\n     static std::unique_ptr<CZMQAbstractNotifier> Create()\n     {\n-        return MakeUnique<T>();\n+        return std::make_unique<T>();\n     }\n \n     std::string GetType() const { return type; }"
      },
      {
        "sha": "a60a723b3e363fb9774a0c65165838c4a16a80a0",
        "filename": "test/functional/feature_anchors.py",
        "status": "added",
        "additions": 85,
        "deletions": 0,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/feature_anchors.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/feature_anchors.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_anchors.py?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -0,0 +1,85 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test Anchors functionality\"\"\"\n+\n+import os\n+\n+from test_framework.p2p import P2PInterface\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal\n+\n+\n+def check_node_connections(*, node, num_in, num_out):\n+    info = node.getnetworkinfo()\n+    assert_equal(info[\"connections_in\"], num_in)\n+    assert_equal(info[\"connections_out\"], num_out)\n+\n+\n+class AnchorsTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def run_test(self):\n+        self.log.info(\"Add 2 block-relay-only connections to node 0\")\n+        for i in range(2):\n+            self.log.debug(f\"block-relay-only: {i}\")\n+            self.nodes[0].add_outbound_p2p_connection(\n+                P2PInterface(), p2p_idx=i, connection_type=\"block-relay-only\"\n+            )\n+\n+        self.log.info(\"Add 5 inbound connections to node 0\")\n+        for i in range(5):\n+            self.log.debug(f\"inbound: {i}\")\n+            self.nodes[0].add_p2p_connection(P2PInterface())\n+\n+        self.log.info(\"Check node 0 connections\")\n+        check_node_connections(node=self.nodes[0], num_in=5, num_out=2)\n+\n+        # 127.0.0.1\n+        ip = \"7f000001\"\n+\n+        # Since the ip is always 127.0.0.1 for this case,\n+        # we store only the port to identify the peers\n+        block_relay_nodes_port = []\n+        inbound_nodes_port = []\n+        for p in self.nodes[0].getpeerinfo():\n+            addr_split = p[\"addr\"].split(\":\")\n+            if p[\"connection_type\"] == \"block-relay-only\":\n+                block_relay_nodes_port.append(hex(int(addr_split[1]))[2:])\n+            else:\n+                inbound_nodes_port.append(hex(int(addr_split[1]))[2:])\n+\n+        self.log.info(\"Stop node 0\")\n+        self.stop_node(0)\n+\n+        node0_anchors_path = os.path.join(\n+            self.nodes[0].datadir, \"regtest\", \"anchors.dat\"\n+        )\n+\n+        # It should contain only the block-relay-only addresses\n+        self.log.info(\"Check the addresses in anchors.dat\")\n+\n+        with open(node0_anchors_path, \"rb\") as file_handler:\n+            anchors = file_handler.read().hex()\n+\n+        for port in block_relay_nodes_port:\n+            ip_port = ip + port\n+            assert ip_port in anchors\n+        for port in inbound_nodes_port:\n+            ip_port = ip + port\n+            assert ip_port not in anchors\n+\n+        self.log.info(\"Start node 0\")\n+        self.start_node(0)\n+\n+        self.log.info(\"When node starts, check if anchors.dat doesn't exist anymore\")\n+        assert not os.path.exists(node0_anchors_path)\n+\n+\n+if __name__ == \"__main__\":\n+    AnchorsTest().main()"
      },
      {
        "sha": "4e2de1daf42477b9597ab7e90864e99462f9e72d",
        "filename": "test/functional/feature_notifications.py",
        "status": "modified",
        "additions": 34,
        "deletions": 20,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/feature_notifications.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/feature_notifications.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_notifications.py?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -17,7 +17,7 @@\n FILE_CHAR_START = 32 if os.name == 'nt' else 1\n FILE_CHAR_END = 128\n FILE_CHARS_DISALLOWED = '/\\\\?%*:|\"<>' if os.name == 'nt' else '/'\n-\n+UNCONFIRMED_HASH_STRING = 'unconfirmed'\n \n def notify_outputname(walletname, txid):\n     return txid if os.name == 'nt' else '{}_{}'.format(walletname, txid)\n@@ -43,7 +43,7 @@ def setup_network(self):\n             \"-blocknotify=echo > {}\".format(os.path.join(self.blocknotify_dir, '%s')),\n         ], [\n             \"-rescan\",\n-            \"-walletnotify=echo > {}\".format(os.path.join(self.walletnotify_dir, notify_outputname('%w', '%s'))),\n+            \"-walletnotify=echo %h_%b > {}\".format(os.path.join(self.walletnotify_dir, notify_outputname('%w', '%s'))),\n         ]]\n         self.wallet_names = [self.default_wallet_name, self.wallet]\n         super().setup_network()\n@@ -90,11 +90,9 @@ def run_test(self):\n             self.wait_until(lambda: len(os.listdir(self.walletnotify_dir)) == block_count, timeout=10)\n \n             # directory content should equal the generated transaction hashes\n-            txids_rpc = list(map(lambda t: notify_outputname(self.wallet, t['txid']), self.nodes[1].listtransactions(\"*\", block_count)))\n-            assert_equal(sorted(txids_rpc), sorted(os.listdir(self.walletnotify_dir)))\n+            tx_details = list(map(lambda t: (t['txid'], t['blockheight'], t['blockhash']), self.nodes[1].listtransactions(\"*\", block_count)))\n             self.stop_node(1)\n-            for tx_file in os.listdir(self.walletnotify_dir):\n-                os.remove(os.path.join(self.walletnotify_dir, tx_file))\n+            self.expect_wallet_notify(tx_details)\n \n             self.log.info(\"test -walletnotify after rescan\")\n             # restart node to rescan to force wallet notifications\n@@ -104,10 +102,8 @@ def run_test(self):\n             self.wait_until(lambda: len(os.listdir(self.walletnotify_dir)) == block_count, timeout=10)\n \n             # directory content should equal the generated transaction hashes\n-            txids_rpc = list(map(lambda t: notify_outputname(self.wallet, t['txid']), self.nodes[1].listtransactions(\"*\", block_count)))\n-            assert_equal(sorted(txids_rpc), sorted(os.listdir(self.walletnotify_dir)))\n-            for tx_file in os.listdir(self.walletnotify_dir):\n-                os.remove(os.path.join(self.walletnotify_dir, tx_file))\n+            tx_details = list(map(lambda t: (t['txid'], t['blockheight'], t['blockhash']), self.nodes[1].listtransactions(\"*\", block_count)))\n+            self.expect_wallet_notify(tx_details)\n \n             # Conflicting transactions tests.\n             # Generate spends from node 0, and check notifications\n@@ -122,7 +118,7 @@ def run_test(self):\n             tx1 = self.nodes[0].sendtoaddress(address=ADDRESS_BCRT1_UNSPENDABLE, amount=1, replaceable=True)\n             assert_equal(tx1 in self.nodes[0].getrawmempool(), True)\n             self.sync_mempools()\n-            self.expect_wallet_notify([tx1])\n+            self.expect_wallet_notify([(tx1, -1, UNCONFIRMED_HASH_STRING)])\n \n             # Generate bump transaction, sync mempools, and check for bump1\n             # notification. In the future, per\n@@ -131,39 +127,57 @@ def run_test(self):\n             bump1 = self.nodes[0].bumpfee(tx1)[\"txid\"]\n             assert_equal(bump1 in self.nodes[0].getrawmempool(), True)\n             self.sync_mempools()\n-            self.expect_wallet_notify([bump1])\n+            self.expect_wallet_notify([(bump1, -1, UNCONFIRMED_HASH_STRING)])\n \n             # Add bump1 transaction to new block, checking for a notification\n             # and the correct number of confirmations.\n-            self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n+            blockhash1 = self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+            blockheight1 = self.nodes[0].getblockcount()\n             self.sync_blocks()\n-            self.expect_wallet_notify([bump1])\n+            self.expect_wallet_notify([(bump1, blockheight1, blockhash1)])\n             assert_equal(self.nodes[1].gettransaction(bump1)[\"confirmations\"], 1)\n \n             # Generate a second transaction to be bumped.\n             tx2 = self.nodes[0].sendtoaddress(address=ADDRESS_BCRT1_UNSPENDABLE, amount=1, replaceable=True)\n             assert_equal(tx2 in self.nodes[0].getrawmempool(), True)\n             self.sync_mempools()\n-            self.expect_wallet_notify([tx2])\n+            self.expect_wallet_notify([(tx2, -1, UNCONFIRMED_HASH_STRING)])\n \n             # Bump tx2 as bump2 and generate a block on node 0 while\n             # disconnected, then reconnect and check for notifications on node 1\n             # about newly confirmed bump2 and newly conflicted tx2.\n             self.disconnect_nodes(0, 1)\n             bump2 = self.nodes[0].bumpfee(tx2)[\"txid\"]\n-            self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n+            blockhash2 = self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+            blockheight2 = self.nodes[0].getblockcount()\n             assert_equal(self.nodes[0].gettransaction(bump2)[\"confirmations\"], 1)\n             assert_equal(tx2 in self.nodes[1].getrawmempool(), True)\n             self.connect_nodes(0, 1)\n             self.sync_blocks()\n-            self.expect_wallet_notify([bump2, tx2])\n+            self.expect_wallet_notify([(bump2, blockheight2, blockhash2), (tx2, -1, UNCONFIRMED_HASH_STRING)])\n             assert_equal(self.nodes[1].gettransaction(bump2)[\"confirmations\"], 1)\n \n         # TODO: add test for `-alertnotify` large fork notifications\n \n-    def expect_wallet_notify(self, tx_ids):\n-        self.wait_until(lambda: len(os.listdir(self.walletnotify_dir)) >= len(tx_ids), timeout=10)\n-        assert_equal(sorted(notify_outputname(self.wallet, tx_id) for tx_id in tx_ids), sorted(os.listdir(self.walletnotify_dir)))\n+    def expect_wallet_notify(self, tx_details):\n+        self.wait_until(lambda: len(os.listdir(self.walletnotify_dir)) >= len(tx_details), timeout=10)\n+        # Should have no more and no less files than expected\n+        assert_equal(sorted(notify_outputname(self.wallet, tx_id) for tx_id, _, _ in tx_details), sorted(os.listdir(self.walletnotify_dir)))\n+        # Should now verify contents of each file\n+        for tx_id, blockheight, blockhash in tx_details:\n+            fname = os.path.join(self.walletnotify_dir, notify_outputname(self.wallet, tx_id))\n+            with open(fname, 'rt', encoding='utf-8') as f:\n+                text = f.read()\n+                # Universal newline ensures '\\n' on 'nt'\n+                assert_equal(text[-1], '\\n')\n+                text = text[:-1]\n+                if os.name == 'nt':\n+                    # On Windows, echo as above will append a whitespace\n+                    assert_equal(text[-1], ' ')\n+                    text = text[:-1]\n+                expected = str(blockheight) + '_' + blockhash\n+                assert_equal(text, expected)\n+\n         for tx_file in os.listdir(self.walletnotify_dir):\n             os.remove(os.path.join(self.walletnotify_dir, tx_file))\n "
      },
      {
        "sha": "ce00faffee09e3a0c4c6df5e33d3a3083fd1c248",
        "filename": "test/functional/feature_utxo_set_hash.py",
        "status": "modified",
        "additions": 12,
        "deletions": 18,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/feature_utxo_set_hash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/feature_utxo_set_hash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_utxo_set_hash.py?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -6,7 +6,6 @@\n \n import struct\n \n-from test_framework.blocktools import create_transaction\n from test_framework.messages import (\n     CBlock,\n     COutPoint,\n@@ -15,38 +14,30 @@\n from test_framework.muhash import MuHash3072\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal\n+from test_framework.wallet import MiniWallet\n \n class UTXOSetHashTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n         self.setup_clean_chain = True\n \n-    def skip_test_if_missing_module(self):\n-        self.skip_if_no_wallet()\n-\n-    def test_deterministic_hash_results(self):\n-        self.log.info(\"Test deterministic UTXO set hash results\")\n-\n-        # These depend on the setup_clean_chain option, the chain loaded from the cache\n-        assert_equal(self.nodes[0].gettxoutsetinfo()['hash_serialized_2'], \"b32ec1dda5a53cd025b95387aad344a801825fe46a60ff952ce26528f01d3be8\")\n-        assert_equal(self.nodes[0].gettxoutsetinfo(\"muhash\")['muhash'], \"dd5ad2a105c2d29495f577245c357409002329b9f4d6182c0af3dc2f462555c8\")\n-\n     def test_muhash_implementation(self):\n         self.log.info(\"Test MuHash implementation consistency\")\n \n         node = self.nodes[0]\n+        wallet = MiniWallet(node)\n+        mocktime = node.getblockheader(node.getblockhash(0))['time'] + 1\n+        node.setmocktime(mocktime)\n \n         # Generate 100 blocks and remove the first since we plan to spend its\n         # coinbase\n-        block_hashes = node.generate(100)\n+        block_hashes = wallet.generate(1) + node.generate(99)\n         blocks = list(map(lambda block: FromHex(CBlock(), node.getblock(block, False)), block_hashes))\n-        spending = blocks.pop(0)\n+        blocks.pop(0)\n \n         # Create a spending transaction and mine a block which includes it\n-        tx = create_transaction(node, spending.vtx[0].rehash(), node.getnewaddress(), amount=49)\n-        txid = node.sendrawtransaction(hexstring=tx.serialize_with_witness().hex(), maxfeerate=0)\n-\n-        tx_block = node.generateblock(output=node.getnewaddress(), transactions=[txid])\n+        txid = wallet.send_self_transfer(from_node=node)['txid']\n+        tx_block = node.generateblock(output=wallet.get_address(), transactions=[txid])\n         blocks.append(FromHex(CBlock(), node.getblock(tx_block['hash'], False)))\n \n         # Serialize the outputs that should be in the UTXO set and add them to\n@@ -77,8 +68,11 @@ def test_muhash_implementation(self):\n \n         assert_equal(finalized[::-1].hex(), node_muhash)\n \n+        self.log.info(\"Test deterministic UTXO set hash results\")\n+        assert_equal(node.gettxoutsetinfo()['hash_serialized_2'], \"5b1b44097406226c0eb8e1362cd17a1f346522cf9390a8175a57a5262cb1963f\")\n+        assert_equal(node.gettxoutsetinfo(\"muhash\")['muhash'], \"4b8803075d7151d06fad3e88b68ba726886794873fbfa841d12aefb2cc2b881b\")\n+\n     def run_test(self):\n-        self.test_deterministic_hash_results()\n         self.test_muhash_implementation()\n \n "
      },
      {
        "sha": "4d5666f414efc39d6e59fe436e72fb3c8e6d58c0",
        "filename": "test/functional/interface_rpc.py",
        "status": "modified",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/interface_rpc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/interface_rpc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_rpc.py?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -8,6 +8,9 @@\n from test_framework.authproxy import JSONRPCException\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, assert_greater_than_or_equal\n+from threading import Thread\n+import subprocess\n+\n \n def expect_http_status(expected_http_status, expected_rpc_code,\n                        fcn, *args):\n@@ -18,6 +21,16 @@ def expect_http_status(expected_http_status, expected_rpc_code,\n         assert_equal(exc.error[\"code\"], expected_rpc_code)\n         assert_equal(exc.http_status, expected_http_status)\n \n+\n+def test_work_queue_getblock(node, got_exceeded_error):\n+    while not got_exceeded_error:\n+        try:\n+            node.cli('getrpcinfo').send_cli()\n+        except subprocess.CalledProcessError as e:\n+            assert_equal(e.output, 'error: Server response: Work queue depth exceeded\\n')\n+            got_exceeded_error.append(True)\n+\n+\n class RPCInterfaceTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n@@ -67,10 +80,23 @@ def test_http_status_codes(self):\n         expect_http_status(404, -32601, self.nodes[0].invalidmethod)\n         expect_http_status(500, -8, self.nodes[0].getblockhash, 42)\n \n+    def test_work_queue_exceeded(self):\n+        self.log.info(\"Testing work queue exceeded...\")\n+        self.restart_node(0, ['-rpcworkqueue=1', '-rpcthreads=1'])\n+        got_exceeded_error = []\n+        threads = []\n+        for _ in range(3):\n+            t = Thread(target=test_work_queue_getblock, args=(self.nodes[0], got_exceeded_error))\n+            t.start()\n+            threads.append(t)\n+        for t in threads:\n+            t.join()\n+\n     def run_test(self):\n         self.test_getrpcinfo()\n         self.test_batch_request()\n         self.test_http_status_codes()\n+        self.test_work_queue_exceeded()\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "8c9755cc8cb35e3daf07b3b51aed358a91b54ab8",
        "filename": "test/functional/rpc_fundrawtransaction.py",
        "status": "modified",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/rpc_fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/rpc_fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_fundrawtransaction.py?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -32,6 +32,7 @@ def set_test_params(self):\n         # This test isn't testing tx relay. Set whitelist on the peers for\n         # instant tx relay.\n         self.extra_args = [['-whitelist=noban@127.0.0.1']] * self.num_nodes\n+        self.rpc_timeout = 90  # to prevent timeouts in `test_transaction_too_large`\n \n     def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n@@ -94,6 +95,7 @@ def run_test(self):\n         self.test_address_reuse()\n         self.test_option_subtract_fee_from_outputs()\n         self.test_subtract_fee_with_presets()\n+        self.test_transaction_too_large()\n \n     def test_change_position(self):\n         \"\"\"Ensure setting changePosition in fundraw with an exact match is handled properly.\"\"\"\n@@ -907,5 +909,25 @@ def test_subtract_fee_with_presets(self):\n         signedtx = self.nodes[0].signrawtransactionwithwallet(fundedtx['hex'])\n         self.nodes[0].sendrawtransaction(signedtx['hex'])\n \n+    def test_transaction_too_large(self):\n+        self.log.info(\"Test fundrawtx where BnB solution would result in a too large transaction, but Knapsack would not\")\n+        self.nodes[0].createwallet(\"large\")\n+        wallet = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        recipient = self.nodes[0].get_wallet_rpc(\"large\")\n+        outputs = {}\n+        rawtx = recipient.createrawtransaction([], {wallet.getnewaddress(): 147.99899260})\n+\n+        # Make 1500 0.1 BTC outputs. The amount that we target for funding is in\n+        # the BnB range when these outputs are used.  However if these outputs\n+        # are selected, the transaction will end up being too large, so it\n+        # shouldn't use BnB and instead fall back to Knapsack but that behavior\n+        # is not implemented yet. For now we just check that we get an error.\n+        for _ in range(1500):\n+            outputs[recipient.getnewaddress()] = 0.1\n+        wallet.sendmany(\"\", outputs)\n+        self.nodes[0].generate(10)\n+        assert_raises_rpc_error(-4, \"Transaction too large\", recipient.fundrawtransaction, rawtx)\n+\n+\n if __name__ == '__main__':\n     RawTransactionsTest().main()"
      },
      {
        "sha": "e362642f0fa3aace4d9cf51756972f777def4b81",
        "filename": "test/functional/rpc_invalid_address_message.py",
        "status": "modified",
        "additions": 18,
        "deletions": 2,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/rpc_invalid_address_message.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/rpc_invalid_address_message.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_invalid_address_message.py?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -12,8 +12,12 @@\n )\n \n BECH32_VALID = 'bcrt1qtmp74ayg7p24uslctssvjm06q5phz4yrxucgnv'\n-BECH32_INVALID_SIZE = 'bcrt1sqqpl9r5c'\n-BECH32_INVALID_PREFIX = 'bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4'\n+BECH32_INVALID_BECH32 = 'bcrt1p0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7vqdmchcc'\n+BECH32_INVALID_BECH32M = 'bcrt1qw508d6qejxtdg4y5r3zarvary0c5xw7k35mrzd'\n+BECH32_INVALID_VERSION = 'bcrt130xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7vqynjegk'\n+BECH32_INVALID_SIZE = 'bcrt1s0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7v8n0nx0muaewav25430mtr'\n+BECH32_INVALID_V0_SIZE = 'bcrt1qw508d6qejxtdg4y5r3zarvary0c5xw7kqqq5k3my'\n+BECH32_INVALID_PREFIX = 'bc1pw508d6qejxtdg4y5r3zarvary0c5xw7kw508d6qejxtdg4y5r3zarvary0c5xw7k7grplx'\n \n BASE58_VALID = 'mipcBbFg9gMiCh81Kj8tqqdgoZub1ZJRfn'\n BASE58_INVALID_PREFIX = '17VZNX1SN5NtKa8UQFxwQbFeFc3iqRYhem'\n@@ -40,6 +44,18 @@ def test_validateaddress(self):\n         assert not info['isvalid']\n         assert_equal(info['error'], 'Invalid prefix for Bech32 address')\n \n+        info = node.validateaddress(BECH32_INVALID_BECH32)\n+        assert not info['isvalid']\n+        assert_equal(info['error'], 'Version 1+ witness address must use Bech32m checksum')\n+\n+        info = node.validateaddress(BECH32_INVALID_BECH32M)\n+        assert not info['isvalid']\n+        assert_equal(info['error'], 'Version 0 witness address must use Bech32 checksum')\n+\n+        info = node.validateaddress(BECH32_INVALID_V0_SIZE)\n+        assert not info['isvalid']\n+        assert_equal(info['error'], 'Invalid Bech32 v0 address data size')\n+\n         info = node.validateaddress(BECH32_VALID)\n         assert info['isvalid']\n         assert 'error' not in info"
      },
      {
        "sha": "5a9736a7a3e9a4e5b783c0d04b6f3c4d469f424b",
        "filename": "test/functional/test_framework/messages.py",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/test_framework/messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/test_framework/messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/messages.py?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1045,13 +1045,11 @@ def deserialize(self, f):\n \n         self.nStartingHeight = struct.unpack(\"<i\", f.read(4))[0]\n \n-        if self.nVersion >= 70001:\n-            # Relay field is optional for version 70001 onwards\n-            try:\n-                self.relay = struct.unpack(\"<b\", f.read(1))[0]\n-            except:\n-                self.relay = 0\n-        else:\n+        # Relay field is optional for version 70001 onwards\n+        # But, unconditionally check it to match behaviour in bitcoind\n+        try:\n+            self.relay = struct.unpack(\"<b\", f.read(1))[0]\n+        except struct.error:\n             self.relay = 0\n \n     def serialize(self):"
      },
      {
        "sha": "861ca2b949bda78d23f122ccf42148dedde7ebb2",
        "filename": "test/functional/test_framework/segwit_addr.py",
        "status": "modified",
        "additions": 37,
        "deletions": 17,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/test_framework/segwit_addr.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/test_framework/segwit_addr.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/segwit_addr.py?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -2,10 +2,18 @@\n # Copyright (c) 2017 Pieter Wuille\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Reference implementation for Bech32 and segwit addresses.\"\"\"\n+\"\"\"Reference implementation for Bech32/Bech32m and segwit addresses.\"\"\"\n import unittest\n+from enum import Enum\n \n CHARSET = \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"\n+BECH32_CONST = 1\n+BECH32M_CONST = 0x2bc830a3\n+\n+class Encoding(Enum):\n+    \"\"\"Enumeration type to list the various supported encodings.\"\"\"\n+    BECH32 = 1\n+    BECH32M = 2\n \n \n def bech32_polymod(values):\n@@ -27,38 +35,45 @@ def bech32_hrp_expand(hrp):\n \n def bech32_verify_checksum(hrp, data):\n     \"\"\"Verify a checksum given HRP and converted data characters.\"\"\"\n-    return bech32_polymod(bech32_hrp_expand(hrp) + data) == 1\n-\n+    check = bech32_polymod(bech32_hrp_expand(hrp) + data)\n+    if check == BECH32_CONST:\n+        return Encoding.BECH32\n+    elif check == BECH32M_CONST:\n+        return Encoding.BECH32M\n+    else:\n+        return None\n \n-def bech32_create_checksum(hrp, data):\n+def bech32_create_checksum(encoding, hrp, data):\n     \"\"\"Compute the checksum values given HRP and data.\"\"\"\n     values = bech32_hrp_expand(hrp) + data\n-    polymod = bech32_polymod(values + [0, 0, 0, 0, 0, 0]) ^ 1\n+    const = BECH32M_CONST if encoding == Encoding.BECH32M else BECH32_CONST\n+    polymod = bech32_polymod(values + [0, 0, 0, 0, 0, 0]) ^ const\n     return [(polymod >> 5 * (5 - i)) & 31 for i in range(6)]\n \n \n-def bech32_encode(hrp, data):\n-    \"\"\"Compute a Bech32 string given HRP and data values.\"\"\"\n-    combined = data + bech32_create_checksum(hrp, data)\n+def bech32_encode(encoding, hrp, data):\n+    \"\"\"Compute a Bech32 or Bech32m string given HRP and data values.\"\"\"\n+    combined = data + bech32_create_checksum(encoding, hrp, data)\n     return hrp + '1' + ''.join([CHARSET[d] for d in combined])\n \n \n def bech32_decode(bech):\n-    \"\"\"Validate a Bech32 string, and determine HRP and data.\"\"\"\n+    \"\"\"Validate a Bech32/Bech32m string, and determine HRP and data.\"\"\"\n     if ((any(ord(x) < 33 or ord(x) > 126 for x in bech)) or\n             (bech.lower() != bech and bech.upper() != bech)):\n-        return (None, None)\n+        return (None, None, None)\n     bech = bech.lower()\n     pos = bech.rfind('1')\n     if pos < 1 or pos + 7 > len(bech) or len(bech) > 90:\n-        return (None, None)\n+        return (None, None, None)\n     if not all(x in CHARSET for x in bech[pos+1:]):\n-        return (None, None)\n+        return (None, None, None)\n     hrp = bech[:pos]\n     data = [CHARSET.find(x) for x in bech[pos+1:]]\n-    if not bech32_verify_checksum(hrp, data):\n-        return (None, None)\n-    return (hrp, data[:-6])\n+    encoding = bech32_verify_checksum(hrp, data)\n+    if encoding is None:\n+        return (None, None, None)\n+    return (encoding, hrp, data[:-6])\n \n \n def convertbits(data, frombits, tobits, pad=True):\n@@ -86,7 +101,7 @@ def convertbits(data, frombits, tobits, pad=True):\n \n def decode_segwit_address(hrp, addr):\n     \"\"\"Decode a segwit address.\"\"\"\n-    hrpgot, data = bech32_decode(addr)\n+    encoding, hrpgot, data = bech32_decode(addr)\n     if hrpgot != hrp:\n         return (None, None)\n     decoded = convertbits(data[1:], 5, 8, False)\n@@ -96,12 +111,15 @@ def decode_segwit_address(hrp, addr):\n         return (None, None)\n     if data[0] == 0 and len(decoded) != 20 and len(decoded) != 32:\n         return (None, None)\n+    if (data[0] == 0 and encoding != Encoding.BECH32) or (data[0] != 0 and encoding != Encoding.BECH32M):\n+        return (None, None)\n     return (data[0], decoded)\n \n \n def encode_segwit_address(hrp, witver, witprog):\n     \"\"\"Encode a segwit address.\"\"\"\n-    ret = bech32_encode(hrp, [witver] + convertbits(witprog, 8, 5))\n+    encoding = Encoding.BECH32 if witver == 0 else Encoding.BECH32M\n+    ret = bech32_encode(encoding, hrp, [witver] + convertbits(witprog, 8, 5))\n     if decode_segwit_address(hrp, ret) == (None, None):\n         return None\n     return ret\n@@ -119,3 +137,5 @@ def test_python_bech32(addr):\n         # P2WSH\n         test_python_bech32('bcrt1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3xueyj')\n         test_python_bech32('bcrt1qft5p2uhsdcdc3l2ua4ap5qqfg4pjaqlp250x7us7a8qqhrxrxfsqseac85')\n+        # P2TR\n+        test_python_bech32('bcrt1p0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7vqc8gma6')"
      },
      {
        "sha": "a906a21dd01280a582e62a2d4e8c0416ec9e1ff6",
        "filename": "test/functional/test_framework/wallet.py",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/test_framework/wallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/test_framework/wallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/wallet.py?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -49,6 +49,9 @@ def generate(self, num_blocks):\n             self._utxos.append({'txid': cb_tx['txid'], 'vout': 0, 'value': cb_tx['vout'][0]['value']})\n         return blocks\n \n+    def get_address(self):\n+        return self._address\n+\n     def get_utxo(self, *, txid=''):\n         \"\"\"\n         Returns a utxo and marks it as spent (pops it from the internal list)"
      },
      {
        "sha": "28d35187158d53c23c2907269fee03d6c1bb02b0",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -279,6 +279,7 @@\n     'p2p_ping.py',\n     'rpc_scantxoutset.py',\n     'feature_logging.py',\n+    'feature_anchors.py',\n     'p2p_node_network_limited.py',\n     'p2p_permissions.py',\n     'feature_blocksdir.py',"
      },
      {
        "sha": "c0b76d960fbfa9f03c1d5711bd7ebcc9d3617679",
        "filename": "test/functional/wallet_groups.py",
        "status": "modified",
        "additions": 9,
        "deletions": 7,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/wallet_groups.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/wallet_groups.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_groups.py?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -29,8 +29,9 @@ def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n     def run_test(self):\n+        self.log.info(\"Setting up\")\n         # Mine some coins\n-        self.nodes[0].generate(110)\n+        self.nodes[0].generate(101)\n \n         # Get some addresses from the two nodes\n         addr1 = [self.nodes[1].getnewaddress() for _ in range(3)]\n@@ -48,6 +49,7 @@ def run_test(self):\n         # - node[1] should pick one 0.5 UTXO and leave the rest\n         # - node[2] should pick one (1.0 + 0.5) UTXO group corresponding to a\n         #   given address, and leave the rest\n+        self.log.info(\"Test sending transactions picks one UTXO group and leaves the rest\")\n         txid1 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 0.2)\n         tx1 = self.nodes[1].getrawtransaction(txid1, True)\n         # txid1 should have 1 input and 2 outputs\n@@ -70,7 +72,7 @@ def run_test(self):\n         assert_approx(v[0], vexp=0.2, vspan=0.0001)\n         assert_approx(v[1], vexp=1.3, vspan=0.0001)\n \n-        # Test 'avoid partial if warranted, even if disabled'\n+        self.log.info(\"Test avoiding partial spends if warranted, even if avoidpartialspends is disabled\")\n         self.sync_all()\n         self.nodes[0].generate(1)\n         # Nodes 1-2 now have confirmed UTXOs (letters denote destinations):\n@@ -104,7 +106,7 @@ def run_test(self):\n         assert_equal(input_addrs[0], input_addrs[1])\n         # Node 2 enforces avoidpartialspends so needs no checking here\n \n-        # Test wallet option maxapsfee with Node 3\n+        self.log.info(\"Test wallet option maxapsfee\")\n         addr_aps = self.nodes[3].getnewaddress()\n         self.nodes[0].sendtoaddress(addr_aps, 1.0)\n         self.nodes[0].sendtoaddress(addr_aps, 1.0)\n@@ -131,6 +133,7 @@ def run_test(self):\n \n         # Test wallet option maxapsfee with node 4, which sets maxapsfee\n         # 1 sat higher, crossing the threshold from non-grouped to grouped.\n+        self.log.info(\"Test wallet option maxapsfee threshold from non-grouped to grouped\")\n         addr_aps3 = self.nodes[4].getnewaddress()\n         [self.nodes[0].sendtoaddress(addr_aps3, 1.0) for _ in range(5)]\n         self.nodes[0].generate(1)\n@@ -147,8 +150,7 @@ def run_test(self):\n         self.sync_all()\n         self.nodes[0].generate(1)\n \n-        # Fill node2's wallet with 10000 outputs corresponding to the same\n-        # scriptPubKey\n+        self.log.info(\"Fill a wallet with 10,000 outputs corresponding to the same scriptPubKey\")\n         for _ in range(5):\n             raw_tx = self.nodes[0].createrawtransaction([{\"txid\":\"0\"*64, \"vout\":0}], [{addr2[0]: 0.05}])\n             tx = FromHex(CTransaction(), raw_tx)\n@@ -158,12 +160,12 @@ def run_test(self):\n             signed_tx = self.nodes[0].signrawtransactionwithwallet(funded_tx['hex'])\n             self.nodes[0].sendrawtransaction(signed_tx['hex'])\n             self.nodes[0].generate(1)\n-\n-        self.sync_all()\n+            self.sync_all()\n \n         # Check that we can create a transaction that only requires ~100 of our\n         # utxos, without pulling in all outputs and creating a transaction that\n         # is way too big.\n+        self.log.info(\"Test creating txn that only requires ~100 of our UTXOs without pulling in all outputs\")\n         assert self.nodes[2].sendtoaddress(address=addr2[0], amount=5)\n \n "
      },
      {
        "sha": "551eb72720ad6fb00c905b533e172c9bfca917e4",
        "filename": "test/functional/wallet_labels.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/wallet_labels.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/wallet_labels.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_labels.py?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -138,13 +138,13 @@ def run_test(self):\n         node.createwallet(wallet_name='watch_only', disable_private_keys=True)\n         wallet_watch_only = node.get_wallet_rpc('watch_only')\n         BECH32_VALID = {\n-            '\u2714\ufe0f_VER15_PROG40': 'bcrt10qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqn2cjv3',\n-            '\u2714\ufe0f_VER16_PROG03': 'bcrt1sqqqqqjq8pdp',\n-            '\u2714\ufe0f_VER16_PROB02': 'bcrt1sqqqqqjq8pv',\n+            '\u2714\ufe0f_VER15_PROG40': 'bcrt10qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqxkg7fn',\n+            '\u2714\ufe0f_VER16_PROG03': 'bcrt1sqqqqq8uhdgr',\n+            '\u2714\ufe0f_VER16_PROB02': 'bcrt1sqqqq4wstyw',\n         }\n         BECH32_INVALID = {\n-            '\u274c_VER15_PROG41': 'bcrt10qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzc7xyq',\n-            '\u274c_VER16_PROB01': 'bcrt1sqqpl9r5c',\n+            '\u274c_VER15_PROG41': 'bcrt1sqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqajlxj8',\n+            '\u274c_VER16_PROB01': 'bcrt1sqq5r4036',\n         }\n         for l in BECH32_VALID:\n             ad = BECH32_VALID[l]"
      },
      {
        "sha": "71d1b96a955c05e357b7d6c37797945f288e45f3",
        "filename": "test/functional/wallet_multiwallet.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/wallet_multiwallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/test/functional/wallet_multiwallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_multiwallet.py?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -34,7 +34,7 @@ def test_load_unload(node, name):\n             node.loadwallet(name)\n             node.unloadwallet(name)\n         except JSONRPCException as e:\n-            if e.error['code'] == -4 and 'Wallet already being loading' in e.error['message']:\n+            if e.error['code'] == -4 and 'Wallet already loading' in e.error['message']:\n                 got_loading_error = True\n                 return\n "
      },
      {
        "sha": "eeff7a4515480d927496559f2aed385a70af8d98",
        "filename": "test/fuzz/test_runner.py",
        "status": "modified",
        "additions": 27,
        "deletions": 27,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/test/fuzz/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/test/fuzz/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/fuzz/test_runner.py?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -27,7 +27,7 @@ def get_fuzz_env(*, target, source_dir):\n def main():\n     parser = argparse.ArgumentParser(\n         formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n-        description='''Run the fuzz targets with all inputs from the seed_dir once.''',\n+        description='''Run the fuzz targets with all inputs from the corpus_dir once.''',\n     )\n     parser.add_argument(\n         \"-l\",\n@@ -54,8 +54,8 @@ def main():\n         help='How many targets to merge or execute in parallel.',\n     )\n     parser.add_argument(\n-        'seed_dir',\n-        help='The seed corpus to run on (must contain subfolders for each fuzz target).',\n+        'corpus_dir',\n+        help='The corpus to run on (must contain subfolders for each fuzz target).',\n     )\n     parser.add_argument(\n         'target',\n@@ -64,15 +64,15 @@ def main():\n     )\n     parser.add_argument(\n         '--m_dir',\n-        help='Merge inputs from this directory into the seed_dir.',\n+        help='Merge inputs from this directory into the corpus_dir.',\n     )\n     parser.add_argument(\n         '-g',\n         '--generate',\n         action='store_true',\n-        help='Create new corpus seeds (or extend the existing ones) by running'\n+        help='Create new corpus (or extend the existing ones) by running'\n              ' the given targets for a finite number of times. Outputs them to'\n-             ' the passed seed_dir.'\n+             ' the passed corpus_dir.'\n     )\n \n     args = parser.parse_args()\n@@ -119,19 +119,19 @@ def main():\n     logging.info(\"{} of {} detected fuzz target(s) selected: {}\".format(len(test_list_selection), len(test_list_all), \" \".join(test_list_selection)))\n \n     if not args.generate:\n-        test_list_seedless = []\n+        test_list_missing_corpus = []\n         for t in test_list_selection:\n-            corpus_path = os.path.join(args.seed_dir, t)\n+            corpus_path = os.path.join(args.corpus_dir, t)\n             if not os.path.exists(corpus_path) or len(os.listdir(corpus_path)) == 0:\n-                test_list_seedless.append(t)\n-        test_list_seedless.sort()\n-        if test_list_seedless:\n+                test_list_missing_corpus.append(t)\n+        test_list_missing_corpus.sort()\n+        if test_list_missing_corpus:\n             logging.info(\n-                \"Fuzzing harnesses lacking a seed corpus: {}\".format(\n-                    \" \".join(test_list_seedless)\n+                \"Fuzzing harnesses lacking a corpus: {}\".format(\n+                    \" \".join(test_list_missing_corpus)\n                 )\n             )\n-            logging.info(\"Please consider adding a fuzz seed corpus at https://github.com/bitcoin-core/qa-assets\")\n+            logging.info(\"Please consider adding a fuzz corpus at https://github.com/bitcoin-core/qa-assets\")\n \n     try:\n         help_output = subprocess.run(\n@@ -154,18 +154,18 @@ def main():\n \n     with ThreadPoolExecutor(max_workers=args.par) as fuzz_pool:\n         if args.generate:\n-            return generate_corpus_seeds(\n+            return generate_corpus(\n                 fuzz_pool=fuzz_pool,\n                 src_dir=config['environment']['SRCDIR'],\n                 build_dir=config[\"environment\"][\"BUILDDIR\"],\n-                seed_dir=args.seed_dir,\n+                corpus_dir=args.corpus_dir,\n                 targets=test_list_selection,\n             )\n \n         if args.m_dir:\n             merge_inputs(\n                 fuzz_pool=fuzz_pool,\n-                corpus=args.seed_dir,\n+                corpus=args.corpus_dir,\n                 test_list=test_list_selection,\n                 src_dir=config['environment']['SRCDIR'],\n                 build_dir=config[\"environment\"][\"BUILDDIR\"],\n@@ -175,21 +175,21 @@ def main():\n \n         run_once(\n             fuzz_pool=fuzz_pool,\n-            corpus=args.seed_dir,\n+            corpus=args.corpus_dir,\n             test_list=test_list_selection,\n             src_dir=config['environment']['SRCDIR'],\n             build_dir=config[\"environment\"][\"BUILDDIR\"],\n             use_valgrind=args.valgrind,\n         )\n \n \n-def generate_corpus_seeds(*, fuzz_pool, src_dir, build_dir, seed_dir, targets):\n-    \"\"\"Generates new corpus seeds.\n+def generate_corpus(*, fuzz_pool, src_dir, build_dir, corpus_dir, targets):\n+    \"\"\"Generates new corpus.\n \n-    Run {targets} without input, and outputs the generated corpus seeds to\n-    {seed_dir}.\n+    Run {targets} without input, and outputs the generated corpus to\n+    {corpus_dir}.\n     \"\"\"\n-    logging.info(\"Generating corpus seeds to {}\".format(seed_dir))\n+    logging.info(\"Generating corpus to {}\".format(corpus_dir))\n \n     def job(command, t):\n         logging.debug(\"Running '{}'\\n\".format(\" \".join(command)))\n@@ -205,12 +205,12 @@ def job(command, t):\n \n     futures = []\n     for target in targets:\n-        target_seed_dir = os.path.join(seed_dir, target)\n-        os.makedirs(target_seed_dir, exist_ok=True)\n+        target_corpus_dir = os.path.join(corpus_dir, target)\n+        os.makedirs(target_corpus_dir, exist_ok=True)\n         command = [\n             os.path.join(build_dir, 'src', 'test', 'fuzz', 'fuzz'),\n             \"-runs=100000\",\n-            target_seed_dir,\n+            target_corpus_dir,\n         ]\n         futures.append(fuzz_pool.submit(job, command, target))\n \n@@ -219,7 +219,7 @@ def job(command, t):\n \n \n def merge_inputs(*, fuzz_pool, corpus, test_list, src_dir, build_dir, merge_dir):\n-    logging.info(\"Merge the inputs from the passed dir into the seed_dir. Passed dir {}\".format(merge_dir))\n+    logging.info(\"Merge the inputs from the passed dir into the corpus_dir. Passed dir {}\".format(merge_dir))\n     jobs = []\n     for t in test_list:\n         args = ["
      }
    ]
  },
  {
    "sha": "2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYjllNDVmYjEwYWU4YTMwMWE5NGViOTgzZTVkZjNmZjFhMGE1ODVm",
    "commit": {
      "author": {
        "name": "J0hn",
        "email": "songjh.john@gmail.com",
        "date": "2021-04-01T16:59:33Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-04-01T16:59:33Z"
      },
      "message": "Merge pull request #2 from bitcoin/master\n\nRemove help test",
      "tree": {
        "sha": "e902132d836647b814dd495c7274aa62c5775d7d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e902132d836647b814dd495c7274aa62c5775d7d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgZfv1CRBK7hj4Ov3rIwAAdHIIAEH70pNHKC01Kx3OtWQOdcmZ\n/jOnJIxhgxra3Pnh4jwBRCcu1lPSVH00sBlbDhgymKmEgsqREtok2Wx8e+WxVCqI\nQwQSwlXRJQAU76W33ES+cUqq4whtHk/+AG38AcGrJ8ZVjR3swA3+X834R1iDqxR8\nnGUbXKwvd1HOLhjTg87G+4qFZj/bt40+iTN7oYpX76BQ0K9xqH9qykeRyXocIQyB\ndaFhhSnsr5P2SetZVkSHJa3ymjxDxYUPWTBzUt8NapWUW+dGvL8D/Yb+zdYNI4kV\nujHjWUALkuneeFRBJJsFAEo108eDRVSqMRGFsjt1IdEEbgH3OzqKXm4jn/M47Wo=\n=8xBq\n-----END PGP SIGNATURE-----\n",
        "payload": "tree e902132d836647b814dd495c7274aa62c5775d7d\nparent 5cee909b883b22f8813ed9e1619e7dea28331759\nparent 086226d98ae8c194a0a38b2fbfffd0dc3773e879\nauthor J0hn <songjh.john@gmail.com> 1617296373 +0100\ncommitter GitHub <noreply@github.com> 1617296373 +0100\n\nMerge pull request #2 from bitcoin/master\n\nRemove help test"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/comments",
    "author": {
      "login": "Rqcker",
      "id": 20661419,
      "node_id": "MDQ6VXNlcjIwNjYxNDE5",
      "avatar_url": "https://avatars.githubusercontent.com/u/20661419?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Rqcker",
      "html_url": "https://github.com/Rqcker",
      "followers_url": "https://api.github.com/users/Rqcker/followers",
      "following_url": "https://api.github.com/users/Rqcker/following{/other_user}",
      "gists_url": "https://api.github.com/users/Rqcker/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Rqcker/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Rqcker/subscriptions",
      "organizations_url": "https://api.github.com/users/Rqcker/orgs",
      "repos_url": "https://api.github.com/users/Rqcker/repos",
      "events_url": "https://api.github.com/users/Rqcker/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Rqcker/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5cee909b883b22f8813ed9e1619e7dea28331759",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5cee909b883b22f8813ed9e1619e7dea28331759",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5cee909b883b22f8813ed9e1619e7dea28331759"
      },
      {
        "sha": "086226d98ae8c194a0a38b2fbfffd0dc3773e879",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/086226d98ae8c194a0a38b2fbfffd0dc3773e879",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/086226d98ae8c194a0a38b2fbfffd0dc3773e879"
      }
    ],
    "stats": {
      "total": 2878,
      "additions": 1707,
      "deletions": 1171
    },
    "files": [
      {
        "sha": "d7d5ab6c5cc45420c987f68751b851071ec5b4ce",
        "filename": ".cirrus.yml",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/.cirrus.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/.cirrus.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.cirrus.yml?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -35,8 +35,6 @@ global_task_template: &GLOBAL_TASK_TEMPLATE\n     folder: \"/tmp/cirrus-ci-build/depends/built\"\n   depends_sdk_cache:\n     folder: \"/tmp/cirrus-ci-build/depends/sdk-sources\"\n-  depends_releases_cache:\n-    folder: \"/tmp/cirrus-ci-build/releases\"\n   ci_script:\n     - ./ci/test_run_all.sh\n \n@@ -103,6 +101,8 @@ task:\n   # For faster CI feedback, immediately schedule a task that compiles most modules\n   << : *CREDITS_TEMPLATE\n   << : *GLOBAL_TASK_TEMPLATE\n+  depends_releases_cache:\n+    folder: \"/tmp/cirrus-ci-build/releases\"\n   container:\n     image: ubuntu:bionic\n   env:\n@@ -168,23 +168,25 @@ task:\n     FILE_ENV: \"./ci/test/00_setup_env_mac.sh\"\n \n task:\n-  name: 'macOS 10.15 native [gui] [no depends]'\n+  name: 'macOS 11 native [gui] [no depends]'\n   macos_brew_addon_script:\n     - brew install boost libevent berkeley-db4 qt miniupnpc libnatpmp ccache zeromq qrencode sqlite libtool automake pkg-config gnu-getopt\n   << : *GLOBAL_TASK_TEMPLATE\n   osx_instance:\n     # Use latest image, but hardcode version to avoid silent upgrades (and breaks)\n-    image: catalina-xcode-12.1  # https://cirrus-ci.org/guide/macOS\n+    image: big-sur-xcode-12.4  # https://cirrus-ci.org/guide/macOS\n   env:\n     DANGER_RUN_CI_ON_HOST: \"true\"\n     CI_USE_APT_INSTALL: \"no\"\n     PACKAGE_MANAGER_INSTALL: \"echo\"  # Nothing to do\n     FILE_ENV: \"./ci/test/00_setup_env_mac_host.sh\"\n \n task:\n-  name: 'ARM64 Android APK [bionic]'\n+  name: 'ARM64 Android APK [focal]'\n+  depends_sources_cache:\n+    folder: \"/tmp/cirrus-ci-build/depends/sources\"\n   << : *GLOBAL_TASK_TEMPLATE\n   container:\n-    image: ubuntu:bionic\n+    image: ubuntu:focal\n   env:\n     FILE_ENV: \"./ci/test/00_setup_env_android.sh\""
      },
      {
        "sha": "38923a98fc966a932118c550e05ad3de91bf2cb2",
        "filename": "build-aux/m4/l_socket.m4",
        "status": "added",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/build-aux/m4/l_socket.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/build-aux/m4/l_socket.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/l_socket.m4?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -0,0 +1,36 @@\n+# Illumos/SmartOS requires linking with -lsocket if\n+# using getifaddrs & freeifaddrs\n+\n+m4_define([_CHECK_SOCKET_testbody], [[\n+  #include <sys/types.h>\n+  #include <ifaddrs.h>\n+\n+  int main() {\n+    struct ifaddrs *ifaddr;\n+    getifaddrs(&ifaddr);\n+    freeifaddrs(ifaddr);\n+  }\n+]])\n+\n+AC_DEFUN([CHECK_SOCKET], [\n+\n+  AC_LANG_PUSH(C++)\n+\n+  AC_MSG_CHECKING([whether ifaddrs funcs can be used without link library])\n+\n+  AC_LINK_IFELSE([AC_LANG_SOURCE([_CHECK_SOCKET_testbody])],[\n+      AC_MSG_RESULT([yes])\n+    ],[\n+      AC_MSG_RESULT([no])\n+      LIBS=\"$LIBS -lsocket\"\n+      AC_MSG_CHECKING([whether getifaddrs needs -lsocket])\n+      AC_LINK_IFELSE([AC_LANG_SOURCE([_CHECK_SOCKET_testbody])],[\n+          AC_MSG_RESULT([yes])\n+        ],[\n+          AC_MSG_RESULT([no])\n+          AC_MSG_FAILURE([cannot figure out how to use getifaddrs])\n+        ])\n+    ])\n+\n+  AC_LANG_POP\n+])"
      },
      {
        "sha": "f195d3d45146c3d49ed94da9f5a11202e8216dc4",
        "filename": "build_msvc/common.init.vcxproj",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/build_msvc/common.init.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/build_msvc/common.init.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/common.init.vcxproj?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -97,7 +97,7 @@\n       <WarningLevel>Level3</WarningLevel>\n       <PrecompiledHeader>NotUsing</PrecompiledHeader>\n       <AdditionalOptions>/utf-8 /Zc:__cplusplus /std:c++17 %(AdditionalOptions)</AdditionalOptions>\n-      <DisableSpecificWarnings>4018;4221;4244;4267;4334;4715;4805;4834</DisableSpecificWarnings>\n+      <DisableSpecificWarnings>4018;4244;4267;4334;4715;4805;4834</DisableSpecificWarnings>\n       <TreatWarningAsError>true</TreatWarningAsError>\n       <PreprocessorDefinitions>_SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING;_SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING;ZMQ_STATIC;NOMINMAX;WIN32;HAVE_CONFIG_H;_CRT_SECURE_NO_WARNINGS;_SCL_SECURE_NO_WARNINGS;_CONSOLE;_WIN32_WINNT=0x0601;_WIN32_IE=0x0501;WIN32_LEAN_AND_MEAN;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n       <AdditionalIncludeDirectories>..\\..\\src;..\\..\\src\\univalue\\include;..\\..\\src\\secp256k1\\include;..\\..\\src\\leveldb\\include;..\\..\\src\\leveldb\\helpers\\memenv;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>"
      },
      {
        "sha": "009be30decbf11fb95aafbcc935809706b6cd186",
        "filename": "build_msvc/libleveldb/libleveldb.vcxproj",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/build_msvc/libleveldb/libleveldb.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/build_msvc/libleveldb/libleveldb.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/libleveldb/libleveldb.vcxproj?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -51,7 +51,7 @@\n   <ItemDefinitionGroup>\n      <ClCompile>\n        <PreprocessorDefinitions>HAVE_CRC32C=0;HAVE_SNAPPY=0;__STDC_LIMIT_MACROS;LEVELDB_IS_BIG_ENDIAN=0;_UNICODE;UNICODE;_CRT_NONSTDC_NO_DEPRECATE;LEVELDB_PLATFORM_WINDOWS;LEVELDB_ATOMIC_PRESENT;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n-       <DisableSpecificWarnings>4244;4267;4312;4722;</DisableSpecificWarnings>\n+       <DisableSpecificWarnings>4244;4267</DisableSpecificWarnings>\n        <AdditionalIncludeDirectories>..\\..\\src\\leveldb;..\\..\\src\\leveldb\\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n      </ClCompile>\n   </ItemDefinitionGroup>"
      },
      {
        "sha": "1d2c86b7ace65877b5cfa70e3c73df570f67dd2b",
        "filename": "build_msvc/test_bitcoin-qt/test_bitcoin-qt.vcxproj",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/build_msvc/test_bitcoin-qt/test_bitcoin-qt.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/build_msvc/test_bitcoin-qt/test_bitcoin-qt.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/test_bitcoin-qt/test_bitcoin-qt.vcxproj?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -11,7 +11,6 @@\n     <ClCompile Include=\"..\\..\\src\\test\\util\\setup_common.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\test\\addressbooktests.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\test\\apptests.cpp\" />\n-    <ClCompile Include=\"..\\..\\src\\qt\\test\\compattests.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\test\\rpcnestedtests.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\test\\test_main.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\test\\uritests.cpp\" />\n@@ -20,7 +19,6 @@\n     <ClCompile Include=\"..\\..\\src\\wallet\\test\\wallet_test_fixture.cpp\" />\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_addressbooktests.cpp\" />\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_apptests.cpp\" />\n-    <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_compattests.cpp\" />\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_rpcnestedtests.cpp\" />\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_uritests.cpp\" />\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_wallettests.cpp\" />\n@@ -89,7 +87,6 @@\n   <ItemGroup>\n     <MocTestFiles Include=\"..\\..\\src\\qt\\test\\addressbooktests.h\" />\n     <MocTestFiles Include=\"..\\..\\src\\qt\\test\\apptests.h\" />\n-    <MocTestFiles Include=\"..\\..\\src\\qt\\test\\compattests.h\" />\n     <MocTestFiles Include=\"..\\..\\src\\qt\\test\\rpcnestedtests.h\" />\n     <MocTestFiles Include=\"..\\..\\src\\qt\\test\\uritests.h\" />\n     <MocTestFiles Include=\"..\\..\\src\\qt\\test\\wallettests.h\" />"
      },
      {
        "sha": "e6aec723bc603f902c2988bcc74f5f7a9c6997e9",
        "filename": "ci/test/00_setup_env.sh",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/ci/test/00_setup_env.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/ci/test/00_setup_env.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env.sh?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -11,6 +11,9 @@ export LC_ALL=C.UTF-8\n # This is where the depends build is done.\n BASE_ROOT_DIR=$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\"/../../ >/dev/null 2>&1 && pwd )\n export BASE_ROOT_DIR\n+# The depends dir.\n+# This folder exists on the ci host and ci guest. Changes are propagated back and forth.\n+export DEPENDS_DIR=${DEPENDS_DIR:-$BASE_ROOT_DIR/depends}\n \n echo \"Setting specific values in env\"\n if [ -n \"${FILE_ENV}\" ]; then\n@@ -56,9 +59,6 @@ export CCACHE_COMPRESS=${CCACHE_COMPRESS:-1}\n # The cache dir.\n # This folder exists on the ci host and ci guest. Changes are propagated back and forth.\n export CCACHE_DIR=${CCACHE_DIR:-$BASE_SCRATCH_DIR/.ccache}\n-# The depends dir.\n-# This folder exists on the ci host and ci guest. Changes are propagated back and forth.\n-export DEPENDS_DIR=${DEPENDS_DIR:-$BASE_ROOT_DIR/depends}\n # Folder where the build result is put (bin and lib).\n export BASE_OUTDIR=${BASE_OUTDIR:-$BASE_SCRATCH_DIR/out/$HOST}\n # Folder where the build is done (dist and out-of-tree build)."
      },
      {
        "sha": "f78a84eeac47dde651ba6cb7fbbe62e84024722f",
        "filename": "ci/test/00_setup_env_android.sh",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/ci/test/00_setup_env_android.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/ci/test/00_setup_env_android.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_android.sh?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -6,12 +6,20 @@\n \n export LC_ALL=C.UTF-8\n \n-export CONTAINER_NAME=ci_android\n+export HOST=aarch64-linux-android\n export PACKAGES=\"clang llvm unzip openjdk-8-jdk gradle\"\n+export CONTAINER_NAME=ci_android\n+export DOCKER_NAME_TAG=\"ubuntu:focal\"\n+\n+export RUN_UNIT_TESTS=false\n+export RUN_FUNCTIONAL_TESTS=false\n \n export ANDROID_API_LEVEL=28\n export ANDROID_BUILD_TOOLS_VERSION=28.0.3\n export ANDROID_NDK_VERSION=21.1.6352462\n export ANDROID_TOOLS_URL=https://dl.google.com/android/repository/commandlinetools-linux-6609375_latest.zip\n+export ANDROID_HOME=\"${DEPENDS_DIR}/SDKs/android\"\n+export ANDROID_NDK_HOME=\"${ANDROID_HOME}/ndk/${ANDROID_NDK_VERSION}\"\n+export DEP_OPTS=\"ANDROID_SDK=${ANDROID_HOME} ANDROID_NDK=${ANDROID_NDK_HOME} ANDROID_API_LEVEL=${ANDROID_API_LEVEL} ANDROID_TOOLCHAIN_BIN=${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/\"\n \n-export BITCOIN_CONFIG=\"--disable-ccache\"\n\\ No newline at end of file\n+export BITCOIN_CONFIG=\"--disable-ccache\""
      },
      {
        "sha": "8dd489d7f8fec6b2142b561a3d1507230a96e3f6",
        "filename": "ci/test/05_before_script.sh",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/ci/test/05_before_script.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/ci/test/05_before_script.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/05_before_script.sh?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -24,16 +24,11 @@ fi\n \n if [ -n \"$ANDROID_TOOLS_URL\" ]; then\n   ANDROID_TOOLS_PATH=$DEPENDS_DIR/sdk-sources/android-tools.zip\n-  ANDROID_HOME=\"$DEPENDS_DIR\"/SDKs/android\n-  ANDROID_NDK_HOME=${ANDROID_HOME}/ndk/${ANDROID_NDK_VERSION}\n \n   DOCKER_EXEC curl --location --fail \"${ANDROID_TOOLS_URL}\" -o \"$ANDROID_TOOLS_PATH\"\n   DOCKER_EXEC mkdir -p \"${ANDROID_HOME}/cmdline-tools\"\n   DOCKER_EXEC unzip -o \"$ANDROID_TOOLS_PATH\" -d \"${ANDROID_HOME}/cmdline-tools\"\n   DOCKER_EXEC \"yes | ${ANDROID_HOME}/cmdline-tools/tools/bin/sdkmanager --install \\\"build-tools;${ANDROID_BUILD_TOOLS_VERSION}\\\" \\\"platform-tools\\\" \\\"platforms;android-${ANDROID_API_LEVEL}\\\" \\\"ndk;${ANDROID_NDK_VERSION}\\\"\"\n-\n-  MAKE_COMMAND=\"ANDROID_SDK=${ANDROID_HOME} ANDROID_NDK=${ANDROID_NDK_HOME} make $MAKEJOBS -C depends HOST=aarch64-linux-android ANDROID_API_LEVEL=${ANDROID_API_LEVEL} ANDROID_TOOLCHAIN_BIN=${ANDROID_HOME}/ndk/${ANDROID_NDK_VERSION}/toolchains/llvm/prebuilt/linux-x86_64/bin/ $DEP_OPTS\"\n-  DOCKER_EXEC \"$MAKE_COMMAND\" HOST=aarch64-linux-android\n fi\n \n if [[ ${USE_MEMORY_SANITIZER} == \"true\" ]]; then"
      },
      {
        "sha": "c3eabad1313c5c85aa60f24a03f4163948936431",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -936,7 +936,7 @@ fi\n \n AC_CHECK_HEADERS([endian.h sys/endian.h byteswap.h stdio.h stdlib.h unistd.h strings.h sys/types.h sys/stat.h sys/select.h sys/prctl.h sys/sysctl.h vm/vm_param.h sys/vmmeter.h sys/resources.h])\n \n-AC_CHECK_DECLS([getifaddrs, freeifaddrs],,,\n+AC_CHECK_DECLS([getifaddrs, freeifaddrs],[CHECK_SOCKET],,\n     [#include <sys/types.h>\n     #include <ifaddrs.h>]\n )"
      },
      {
        "sha": "1cde19efd1a49bd1aae5ae819632821ff0eb0854",
        "filename": "contrib/qos/tc.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/contrib/qos/tc.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/contrib/qos/tc.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/qos/tc.sh?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -16,7 +16,7 @@ LOCALNET_V4=\"192.168.0.0/16\"\n #defines the IPv6 address space for which you wish to disable rate limiting\n LOCALNET_V6=\"fe80::/10\"\n \n-#delete existing rules\n+#delete existing rules ('Error: Cannot delete qdisc with handle of zero.' means there weren't any.)\n tc qdisc del dev ${IF} root\n \n #add root class"
      },
      {
        "sha": "dd71697f0fca49bcc37375ae57ec0441438bca53",
        "filename": "depends/hosts/darwin.mk",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/depends/hosts/darwin.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/depends/hosts/darwin.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/hosts/darwin.mk?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -12,14 +12,13 @@ ifeq ($(strip $(FORCE_USE_SYSTEM_CLANG)),)\n # FORCE_USE_SYSTEM_CLANG is empty, so we use our depends-managed, pinned clang\n # from llvm.org\n \n-# The native_cctools package is what provides clang when FORCE_USE_SYSTEM_CLANG\n-# is empty\n+# Clang is a dependency of native_cctools when FORCE_USE_SYSTEM_CLANG is empty\n darwin_native_toolchain=native_cctools\n \n clang_prog=$(build_prefix)/bin/clang\n clangxx_prog=$(clang_prog)++\n \n-clang_resource_dir=$(build_prefix)/lib/clang/$(native_cctools_clang_version)\n+clang_resource_dir=$(build_prefix)/lib/clang/$(native_clang_version)\n else\n # FORCE_USE_SYSTEM_CLANG is non-empty, so we use the clang from the user's\n # system"
      },
      {
        "sha": "c789dab74cb814a1f01df4726a1270b5be2d3075",
        "filename": "depends/packages/native_cctools.mk",
        "status": "modified",
        "additions": 9,
        "deletions": 87,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/depends/packages/native_cctools.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/depends/packages/native_cctools.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/native_cctools.mk?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -5,81 +5,19 @@ $(package)_file_name=$($(package)_version).tar.gz\n $(package)_sha256_hash=e51995a843533a3dac155dd0c71362dd471597a2d23f13dff194c6285362f875\n $(package)_build_subdir=cctools\n $(package)_patches=ld64_disable_threading.patch\n-\n-ifeq ($(strip $(FORCE_USE_SYSTEM_CLANG)),)\n-$(package)_clang_version=8.0.0\n-$(package)_clang_download_path=https://releases.llvm.org/$($(package)_clang_version)\n-$(package)_clang_download_file=clang+llvm-$($(package)_clang_version)-x86_64-linux-gnu-ubuntu-14.04.tar.xz\n-$(package)_clang_file_name=clang-llvm-$($(package)_clang_version)-x86_64-linux-gnu-ubuntu-14.04.tar.xz\n-$(package)_clang_sha256_hash=9ef854b71949f825362a119bf2597f744836cb571131ae6b721cd102ffea8cd0\n-endif\n-\n-$(package)_libtapi_version=3efb201881e7a76a21e0554906cf306432539cef\n-$(package)_libtapi_download_path=https://github.com/tpoechtrager/apple-libtapi/archive\n-$(package)_libtapi_download_file=$($(package)_libtapi_version).tar.gz\n-$(package)_libtapi_file_name=$($(package)_libtapi_version).tar.gz\n-$(package)_libtapi_sha256_hash=380c1ca37cfa04a8699d0887a8d3ee1ad27f3d08baba78887c73b09485c0fbd3\n-\n-$(package)_extra_sources=$($(package)_libtapi_file_name)\n-ifeq ($(strip $(FORCE_USE_SYSTEM_CLANG)),)\n-$(package)_extra_sources += $($(package)_clang_file_name)\n-endif\n-\n-ifeq ($(strip $(FORCE_USE_SYSTEM_CLANG)),)\n-define $(package)_fetch_cmds\n-$(call fetch_file,$(package),$($(package)_download_path),$($(package)_download_file),$($(package)_file_name),$($(package)_sha256_hash)) && \\\n-$(call fetch_file,$(package),$($(package)_clang_download_path),$($(package)_clang_download_file),$($(package)_clang_file_name),$($(package)_clang_sha256_hash)) && \\\n-$(call fetch_file,$(package),$($(package)_libtapi_download_path),$($(package)_libtapi_download_file),$($(package)_libtapi_file_name),$($(package)_libtapi_sha256_hash))\n-endef\n-else\n-define $(package)_fetch_cmds\n-$(call fetch_file,$(package),$($(package)_download_path),$($(package)_download_file),$($(package)_file_name),$($(package)_sha256_hash)) && \\\n-$(call fetch_file,$(package),$($(package)_libtapi_download_path),$($(package)_libtapi_download_file),$($(package)_libtapi_file_name),$($(package)_libtapi_sha256_hash))\n-endef\n-endif\n-\n-ifeq ($(strip $(FORCE_USE_SYSTEM_CLANG)),)\n-define $(package)_extract_cmds\n-  mkdir -p $($(package)_extract_dir) && \\\n-  echo \"$($(package)_sha256_hash)  $($(package)_source)\" > $($(package)_extract_dir)/.$($(package)_file_name).hash && \\\n-  echo \"$($(package)_clang_sha256_hash)  $($(package)_source_dir)/$($(package)_clang_file_name)\" >> $($(package)_extract_dir)/.$($(package)_file_name).hash && \\\n-  echo \"$($(package)_libtapi_sha256_hash)  $($(package)_source_dir)/$($(package)_libtapi_file_name)\" >> $($(package)_extract_dir)/.$($(package)_file_name).hash && \\\n-  $(build_SHA256SUM) -c $($(package)_extract_dir)/.$($(package)_file_name).hash && \\\n-  mkdir -p toolchain/bin toolchain/lib/clang/$($(package)_clang_version)/include && \\\n-  mkdir -p libtapi && \\\n-  tar --no-same-owner --strip-components=1 -C libtapi -xf $($(package)_source_dir)/$($(package)_libtapi_file_name) && \\\n-  tar --no-same-owner --strip-components=1 -C toolchain -xf $($(package)_source_dir)/$($(package)_clang_file_name) && \\\n-  rm -f toolchain/lib/libc++abi.so* && \\\n-  tar --no-same-owner --strip-components=1 -xf $($(package)_source)\n-endef\n-else\n-define $(package)_extract_cmds\n-  mkdir -p $($(package)_extract_dir) && \\\n-  echo \"$($(package)_sha256_hash)  $($(package)_source)\" > $($(package)_extract_dir)/.$($(package)_file_name).hash && \\\n-  echo \"$($(package)_libtapi_sha256_hash)  $($(package)_source_dir)/$($(package)_libtapi_file_name)\" >> $($(package)_extract_dir)/.$($(package)_file_name).hash && \\\n-  $(build_SHA256SUM) -c $($(package)_extract_dir)/.$($(package)_file_name).hash && \\\n-  mkdir -p libtapi && \\\n-  tar --no-same-owner --strip-components=1 -C libtapi -xf $($(package)_source_dir)/$($(package)_libtapi_file_name) && \\\n-  tar --no-same-owner --strip-components=1 -xf $($(package)_source)\n-endef\n-endif\n+$(package)_dependencies=native_libtapi\n \n define $(package)_set_vars\n-  $(package)_config_opts=--target=$(host) --with-libtapi=$($(package)_extract_dir)\n+  $(package)_config_opts=--target=$(host)\n   $(package)_ldflags+=-Wl,-rpath=\\\\$$$$$$$$\\$$$$$$$$ORIGIN/../lib\n   ifeq ($(strip $(FORCE_USE_SYSTEM_CLANG)),)\n-  $(package)_config_opts+=--enable-lto-support --with-llvm-config=$($(package)_extract_dir)/toolchain/bin/llvm-config\n-  $(package)_cc=$($(package)_extract_dir)/toolchain/bin/clang\n-  $(package)_cxx=$($(package)_extract_dir)/toolchain/bin/clang++\n-  else\n-  $(package)_cc=clang\n-  $(package)_cxx=clang++\n+  $(package)_config_opts+=--enable-lto-support --with-llvm-config=$(build_prefix)/bin/llvm-config\n   endif\n+  $(package)_cc=$(clang_prog)\n+  $(package)_cxx=$(clangxx_prog)\n endef\n \n define $(package)_preprocess_cmds\n-  CC=$($(package)_cc) CXX=$($(package)_cxx) INSTALLPREFIX=$($(package)_extract_dir) ./libtapi/build.sh && \\\n-  CC=$($(package)_cc) CXX=$($(package)_cxx) INSTALLPREFIX=$($(package)_extract_dir) ./libtapi/install.sh && \\\n   patch -p1 < $($(package)_patch_dir)/ld64_disable_threading.patch\n endef\n \n@@ -91,26 +29,10 @@ define $(package)_build_cmds\n   $(MAKE)\n endef\n \n-ifeq ($(strip $(FORCE_USE_SYSTEM_CLANG)),)\n define $(package)_stage_cmds\n-  $(MAKE) DESTDIR=$($(package)_staging_dir) install && \\\n-  mkdir -p $($(package)_staging_prefix_dir)/lib/ && \\\n-  cd $($(package)_extract_dir) && \\\n-  cp lib/libtapi.so.6 $($(package)_staging_prefix_dir)/lib/ && \\\n-  cd $($(package)_extract_dir)/toolchain && \\\n-  mkdir -p $($(package)_staging_prefix_dir)/lib/clang/$($(package)_clang_version)/include && \\\n-  mkdir -p $($(package)_staging_prefix_dir)/bin $($(package)_staging_prefix_dir)/include && \\\n-  cp bin/clang $($(package)_staging_prefix_dir)/bin/ &&\\\n-  cp -P bin/clang++ $($(package)_staging_prefix_dir)/bin/ &&\\\n-  cp lib/libLTO.so $($(package)_staging_prefix_dir)/lib/ && \\\n-  cp -rf lib/clang/$($(package)_clang_version)/include/* $($(package)_staging_prefix_dir)/lib/clang/$($(package)_clang_version)/include/ && \\\n-  cp bin/dsymutil $($(package)_staging_prefix_dir)/bin/$(host)-dsymutil\n+  $(MAKE) DESTDIR=$($(package)_staging_dir) install\n endef\n-else\n-define $(package)_stage_cmds\n-  $(MAKE) DESTDIR=$($(package)_staging_dir) install && \\\n-  mkdir -p $($(package)_staging_prefix_dir)/lib/ && \\\n-  cd $($(package)_extract_dir) && \\\n-  cp lib/libtapi.so.6 $($(package)_staging_prefix_dir)/lib/\n+\n+define $(package)_postprocess_cmds\n+  rm -rf share\n endef\n-endif"
      },
      {
        "sha": "741ddacf09946df9795317766dd838ef84e9c732",
        "filename": "depends/packages/native_clang.mk",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/depends/packages/native_clang.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/depends/packages/native_clang.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/native_clang.mk?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -0,0 +1,26 @@\n+package=native_clang\n+$(package)_version=8.0.0\n+$(package)_download_path=https://releases.llvm.org/$($(package)_version)\n+$(package)_download_file=clang+llvm-$($(package)_version)-x86_64-linux-gnu-ubuntu-14.04.tar.xz\n+$(package)_file_name=clang-llvm-$($(package)_version)-x86_64-linux-gnu-ubuntu-14.04.tar.xz\n+$(package)_sha256_hash=9ef854b71949f825362a119bf2597f744836cb571131ae6b721cd102ffea8cd0\n+\n+define $(package)_preprocess_cmds\n+  rm -f $($(package)_extract_dir)/lib/libc++abi.so*\n+endef\n+\n+define $(package)_stage_cmds\n+  mkdir -p $($(package)_staging_prefix_dir)/lib/clang/$($(package)_version)/include && \\\n+  mkdir -p $($(package)_staging_prefix_dir)/bin && \\\n+  mkdir -p $($(package)_staging_prefix_dir)/include && \\\n+  cp bin/clang $($(package)_staging_prefix_dir)/bin/ && \\\n+  cp -P bin/clang++ $($(package)_staging_prefix_dir)/bin/ && \\\n+  cp bin/dsymutil $($(package)_staging_prefix_dir)/bin/$(host)-dsymutil && \\\n+  cp bin/llvm-config $($(package)_staging_prefix_dir)/bin/ && \\\n+  cp lib/libLTO.so $($(package)_staging_prefix_dir)/lib/ && \\\n+  cp -rf lib/clang/$($(package)_version)/include/* $($(package)_staging_prefix_dir)/lib/clang/$($(package)_version)/include/\n+endef\n+\n+define $(package)_postprocess_cmds\n+  rmdir include\n+endef"
      },
      {
        "sha": "d7ac4156a7475002fbc9d90dadd72aa3f1f102d9",
        "filename": "depends/packages/native_libtapi.mk",
        "status": "added",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/depends/packages/native_libtapi.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/depends/packages/native_libtapi.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/native_libtapi.mk?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -0,0 +1,20 @@\n+package=native_libtapi\n+$(package)_version=3efb201881e7a76a21e0554906cf306432539cef\n+$(package)_download_path=https://github.com/tpoechtrager/apple-libtapi/archive\n+$(package)_download_file=$($(package)_version).tar.gz\n+$(package)_file_name=$($(package)_version).tar.gz\n+$(package)_sha256_hash=380c1ca37cfa04a8699d0887a8d3ee1ad27f3d08baba78887c73b09485c0fbd3\n+\n+ifeq ($(strip $(FORCE_USE_SYSTEM_CLANG)),)\n+$(package)_dependencies=native_clang\n+endif\n+\n+define $(package)_build_cmds\n+  CC=$(clang_prog) CXX=$(clangxx_prog) INSTALLPREFIX=$($(package)_staging_prefix_dir) ./build.sh\n+endef\n+\n+define $(package)_stage_cmds\n+  ./install.sh && \\\n+  mkdir -p $($(package)_staging_prefix_dir)/include/llvm-c && \\\n+  cp src/llvm/include/llvm-c/lto.h $($(package)_staging_prefix_dir)/include/llvm-c\n+endef"
      },
      {
        "sha": "9094e327ef5b0103c370916b7ee0cb074f950a03",
        "filename": "depends/packages/packages.mk",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/depends/packages/packages.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/depends/packages/packages.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/packages.mk?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -24,5 +24,10 @@ darwin_native_packages = native_ds_store native_mac_alias\n $(host_arch)_$(host_os)_native_packages += native_b2\n \n ifneq ($(build_os),darwin)\n-darwin_native_packages += native_cctools native_libdmg-hfsplus\n+darwin_native_packages += native_cctools native_libtapi native_libdmg-hfsplus\n+\n+ifeq ($(strip $(FORCE_USE_SYSTEM_CLANG)),)\n+darwin_native_packages+= native_clang\n+endif\n+\n endif"
      },
      {
        "sha": "8b281acca773274eb6089598f20ffa8165bdd967",
        "filename": "doc/REST-interface.md",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/doc/REST-interface.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/doc/REST-interface.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/REST-interface.md?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -95,11 +95,8 @@ $ curl localhost:18332/rest/getutxos/checkmempool/b2cdfd7b89def827ff8af7cd9bff76\n          \"scriptPubKey\" : {\n             \"asm\" : \"OP_DUP OP_HASH160 1c7cebb529b86a04c683dfa87be49de35bcf589e OP_EQUALVERIFY OP_CHECKSIG\",\n             \"hex\" : \"76a9141c7cebb529b86a04c683dfa87be49de35bcf589e88ac\",\n-            \"reqSigs\" : 1,\n             \"type\" : \"pubkeyhash\",\n-            \"addresses\" : [\n-               \"mi7as51dvLJsizWnTMurtRmrP8hG2m1XvD\"\n-            ]\n+            \"address\" : \"mi7as51dvLJsizWnTMurtRmrP8hG2m1XvD\"\n          }\n       }\n    ]"
      },
      {
        "sha": "4034a4c19c02cbec167cc5378bd652da001781d8",
        "filename": "doc/release-notes-18077.md",
        "status": "removed",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/doc/release-notes-18077.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/doc/release-notes-18077.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-18077.md?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1,10 +0,0 @@\n-P2P and network changes\n------------------------\n-\n-- Added NAT-PMP port mapping support via [`libnatpmp`](https://miniupnp.tuxfamily.org/libnatpmp.html)\n-\n-Command-line options\n---------------------\n-\n-- The `-natpmp` option has been added to use NAT-PMP to map the listening port. If both UPnP\n-and NAT-PMP are enabled, a successful allocation from UPnP prevails over one from NAT-PMP."
      },
      {
        "sha": "e46d5064a385f3289087931399fd6ec375258739",
        "filename": "doc/release-notes-18466.md",
        "status": "removed",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/doc/release-notes-18466.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/doc/release-notes-18466.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-18466.md?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1,10 +0,0 @@\n-Low-level RPC changes\n----------------------\n-\n-- Error codes have been updated to be more accurate for the following error cases (#18466):\n-  - `signmessage` now returns RPC_INVALID_ADDRESS_OR_KEY (-5) if the\n-    passed address is invalid. Previously returned RPC_TYPE_ERROR (-3).\n-  - `verifymessage` now returns RPC_INVALID_ADDRESS_OR_KEY (-5) if the\n-    passed address is invalid. Previously returned RPC_TYPE_ERROR (-3).\n-  - `verifymessage` now returns RPC_TYPE_ERROR (-3) if the passed signature\n-    is malformed. Previously returned RPC_INVALID_ADDRESS_OR_KEY (-5)."
      },
      {
        "sha": "5553c5a7bde7b78b23c8238e9bb0c0af2bad6212",
        "filename": "doc/release-notes-19776.md",
        "status": "removed",
        "additions": 0,
        "deletions": 9,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/doc/release-notes-19776.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/doc/release-notes-19776.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-19776.md?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1,9 +0,0 @@\n-Updated RPCs\n-------------\n-\n-- The `getpeerinfo` RPC returns two new boolean fields, `bip152_hb_to` and\n-  `bip152_hb_from`, that respectively indicate whether we selected a peer to be\n-  in compact blocks high-bandwidth mode or whether a peer selected us as a\n-  compact blocks high-bandwidth peer. High-bandwidth peers send new block\n-  announcements via a `cmpctblock` message rather than the usual inv/headers\n-  announcements. See BIP 152 for more details. (#19776)"
      },
      {
        "sha": "5c68e4ab0c9bb6385d54751baee85116e255a650",
        "filename": "doc/release-notes-20861.md",
        "status": "removed",
        "additions": 0,
        "deletions": 13,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/doc/release-notes-20861.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/doc/release-notes-20861.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-20861.md?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1,13 +0,0 @@\n-Updated RPCs\n-------------\n-\n-- Due to [BIP 350](https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki)\n-  being implemented, behavior for all RPCs that accept addresses is changed when\n-  a native witness version 1 (or higher) is passed. These now require a Bech32m\n-  encoding instead of a Bech32 one, and Bech32m encoding will be used for such\n-  addresses in RPC output as well. No version 1 addresses should be created\n-  for mainnet until consensus rules are adopted that give them meaning\n-  (e.g. through [BIP 341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki)).\n-  Once that happens, Bech32m is expected to be used for them, so this shouldn't\n-  affect any production systems, but may be observed on other networks where such\n-  addresses already have meaning (like signet)."
      },
      {
        "sha": "334dfa80a413d1f70c491e58dbda86a4b41dbcce",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 58,
        "deletions": 3,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -51,24 +51,59 @@ Core should also work on most other Unix-like systems but is not as\n frequently tested on them.  It is not recommended to use Bitcoin Core on\n unsupported systems.\n \n-From Bitcoin Core 0.22.0 onwards, macOS versions earlier than 10.14 are no\n-longer supported. Additionally, Bitcoin Core does not yet change appearance\n-when macOS \"dark mode\" is activated.\n+From Bitcoin Core 22.0 onwards, macOS versions earlier than 10.14 are no longer supported.\n \n Notable changes\n ===============\n \n P2P and network changes\n -----------------------\n \n+- Added NAT-PMP port mapping support via\n+  [`libnatpmp`](https://miniupnp.tuxfamily.org/libnatpmp.html). (#18077)\n+\n Updated RPCs\n ------------\n+\n+- Due to [BIP 350](https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki)\n+  being implemented, behavior for all RPCs that accept addresses is changed when\n+  a native witness version 1 (or higher) is passed. These now require a Bech32m\n+  encoding instead of a Bech32 one, and Bech32m encoding will be used for such\n+  addresses in RPC output as well. No version 1 addresses should be created\n+  for mainnet until consensus rules are adopted that give them meaning\n+  (e.g. through [BIP 341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki)).\n+  Once that happens, Bech32m is expected to be used for them, so this shouldn't\n+  affect any production systems, but may be observed on other networks where such\n+  addresses already have meaning (like signet). (#20861)\n+\n+- The `getpeerinfo` RPC returns two new boolean fields, `bip152_hb_to` and\n+  `bip152_hb_from`, that respectively indicate whether we selected a peer to be\n+  in compact blocks high-bandwidth mode or whether a peer selected us as a\n+  compact blocks high-bandwidth peer. High-bandwidth peers send new block\n+  announcements via a `cmpctblock` message rather than the usual inv/headers\n+  announcements. See BIP 152 for more details. (#19776)\n+\n - `getpeerinfo` no longer returns the following fields: `addnode`, `banscore`,\n   and `whitelisted`, which were previously deprecated in 0.21. Instead of\n   `addnode`, the `connection_type` field returns manual. Instead of\n   `whitelisted`, the `permissions` field indicates if the peer has special\n   privileges. The `banscore` field has simply been removed. (#20755)\n \n+- The following RPCs:  `gettxout`, `getrawtransaction`, `decoderawtransaction`,\n+  `decodescript`, `gettransaction`, and REST endpoints: `/rest/tx`,\n+  `/rest/getutxos`, `/rest/block` deprecated the following fields (which are no\n+  longer returned in the responses by default): `addresses`, `reqSigs`.\n+  The `-deprecatedrpc=addresses` flag must be passed for these fields to be\n+  included in the RPC response. This flag/option will be available only for this major release, after which\n+  the deprecation will be removed entirely. Note that these fields are attributes of\n+  the `scriptPubKey` object returned in the RPC response. However, in the response\n+  of `decodescript` these fields are top-level attributes, and included again as attributes\n+  of the `scriptPubKey` object. (#20286)\n+\n+- When creating a hex-encoded bitcoin transaction using the `bitcoin-tx` utility\n+  with the `-json` option set, the following fields: `addresses`, `reqSigs` are no longer\n+  returned in the tx output of the response. (#20286)\n+\n Changes to Wallet or GUI related RPCs can be found in the GUI or Wallet section below.\n \n New RPCs\n@@ -80,6 +115,10 @@ Build System\n New settings\n ------------\n \n+- The `-natpmp` option has been added to use NAT-PMP to map the listening port.\n+  If both UPnP and NAT-PMP are enabled, a successful allocation from UPnP\n+  prevails over one from NAT-PMP. (#18077)\n+\n Updated settings\n ----------------\n \n@@ -97,6 +136,9 @@ Wallet\n   The RPC returns public versions of all imported descriptors, including their timestamp and flags.\n   For ranged descriptors, it also returns the range boundaries and the next index to generate addresses from. (#20226)\n \n+- The `bumpfee` RPC is not available with wallets that have private keys\n+  disabled. `psbtbumpfee` can be used instead. (#20891)\n+\n GUI changes\n -----------\n \n@@ -106,6 +148,19 @@ Low-level changes\n RPC\n ---\n \n+- The RPC server can process a limited number of simultaneous RPC requests.\n+  Previously, if this limit was exceeded, the RPC server would respond with\n+  [status code 500 (`HTTP_INTERNAL_SERVER_ERROR`)](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#5xx_server_errors).\n+  Now it returns status code 503 (`HTTP_SERVICE_UNAVAILABLE`). (#18335)\n+\n+- Error codes have been updated to be more accurate for the following error cases (#18466):\n+  - `signmessage` now returns RPC_INVALID_ADDRESS_OR_KEY (-5) if the\n+    passed address is invalid. Previously returned RPC_TYPE_ERROR (-3).\n+  - `verifymessage` now returns RPC_INVALID_ADDRESS_OR_KEY (-5) if the\n+    passed address is invalid. Previously returned RPC_TYPE_ERROR (-3).\n+  - `verifymessage` now returns RPC_TYPE_ERROR (-3) if the passed signature\n+    is malformed. Previously returned RPC_INVALID_ADDRESS_OR_KEY (-5).\n+\n Tests\n -----\n "
      },
      {
        "sha": "da10dbb3be1b28aef0b129cc336a8199838ae670",
        "filename": "share/qt/Info.plist.in",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/share/qt/Info.plist.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/share/qt/Info.plist.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/qt/Info.plist.in?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -60,9 +60,6 @@\n   <key>NSHighResolutionCapable</key>\n     <string>True</string>\n \n-  <key>NSRequiresAquaSystemAppearance</key>\n-    <string>True</string>\n-\n   <key>LSApplicationCategoryType</key>\n     <string>public.app-category.finance</string>\n </dict>"
      },
      {
        "sha": "4e09c86ebd72a730f8dc8a1725bf88bbd77639ab",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -243,7 +243,6 @@ BITCOIN_CORE_H = \\\n   util/moneystr.h \\\n   util/rbf.h \\\n   util/readwritefile.h \\\n-  util/ref.h \\\n   util/settings.h \\\n   util/sock.h \\\n   util/spanparsing.h \\"
      },
      {
        "sha": "91a5e9fd9b440a59d6983ff6328ec01397e3d2b8",
        "filename": "src/Makefile.qttest.include",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/Makefile.qttest.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/Makefile.qttest.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qttest.include?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -7,7 +7,6 @@ TESTS += qt/test/test_bitcoin-qt\n \n TEST_QT_MOC_CPP = \\\n   qt/test/moc_apptests.cpp \\\n-  qt/test/moc_compattests.cpp \\\n   qt/test/moc_rpcnestedtests.cpp \\\n   qt/test/moc_uritests.cpp\n \n@@ -20,7 +19,6 @@ endif # ENABLE_WALLET\n TEST_QT_H = \\\n   qt/test/addressbooktests.h \\\n   qt/test/apptests.h \\\n-  qt/test/compattests.h \\\n   qt/test/rpcnestedtests.h \\\n   qt/test/uritests.h \\\n   qt/test/util.h \\\n@@ -31,7 +29,6 @@ qt_test_test_bitcoin_qt_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BITCOIN_\n \n qt_test_test_bitcoin_qt_SOURCES = \\\n   qt/test/apptests.cpp \\\n-  qt/test/compattests.cpp \\\n   qt/test/rpcnestedtests.cpp \\\n   qt/test/test_main.cpp \\\n   qt/test/uritests.cpp \\"
      },
      {
        "sha": "570f011f7a2d4e7933915e3c3d686fd3242f0629",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -90,6 +90,7 @@ BITCOIN_TESTS =\\\n   test/fs_tests.cpp \\\n   test/getarg_tests.cpp \\\n   test/hash_tests.cpp \\\n+  test/i2p_tests.cpp \\\n   test/interfaces_tests.cpp \\\n   test/key_io_tests.cpp \\\n   test/key_tests.cpp \\\n@@ -101,6 +102,7 @@ BITCOIN_TESTS =\\\n   test/merkleblock_tests.cpp \\\n   test/miner_tests.cpp \\\n   test/multisig_tests.cpp \\\n+  test/net_peer_eviction_tests.cpp \\\n   test/net_tests.cpp \\\n   test/netbase_tests.cpp \\\n   test/pmt_tests.cpp \\\n@@ -110,7 +112,6 @@ BITCOIN_TESTS =\\\n   test/prevector_tests.cpp \\\n   test/raii_event_tests.cpp \\\n   test/random_tests.cpp \\\n-  test/ref_tests.cpp \\\n   test/reverselock_tests.cpp \\\n   test/rpc_tests.cpp \\\n   test/sanity_tests.cpp \\\n@@ -239,6 +240,7 @@ test_fuzz_fuzz_SOURCES = \\\n  test/fuzz/golomb_rice.cpp \\\n  test/fuzz/hex.cpp \\\n  test/fuzz/http_request.cpp \\\n+ test/fuzz/i2p.cpp \\\n  test/fuzz/integer.cpp \\\n  test/fuzz/key.cpp \\\n  test/fuzz/key_io.cpp \\"
      },
      {
        "sha": "85e50ebf7058bfb9ed8084f371df1ca8ea25e29d",
        "filename": "src/Makefile.test_util.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/Makefile.test_util.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/Makefile.test_util.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test_util.include?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -26,6 +26,7 @@ libtest_util_a_SOURCES = \\\n   test/util/logging.cpp \\\n   test/util/mining.cpp \\\n   test/util/net.cpp \\\n+  test/util/script.cpp \\\n   test/util/setup_common.cpp \\\n   test/util/str.cpp \\\n   test/util/transaction_utils.cpp \\"
      },
      {
        "sha": "93ac4b8f7ee1452cdc3051ef32053672cd86c576",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -725,7 +725,7 @@ static void MutateTx(CMutableTransaction& tx, const std::string& command,\n static void OutputTxJSON(const CTransaction& tx)\n {\n     UniValue entry(UniValue::VOBJ);\n-    TxToUniv(tx, uint256(), entry);\n+    TxToUniv(tx, uint256(), /* include_addresses */ false, entry);\n \n     std::string jsonOutput = entry.write(4);\n     tfm::format(std::cout, \"%s\\n\", jsonOutput);"
      },
      {
        "sha": "80ab69c131e30690759258a518f8f6b13102e090",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -16,14 +16,15 @@\n #include <node/ui_interface.h>\n #include <noui.h>\n #include <shutdown.h>\n-#include <util/ref.h>\n+#include <util/check.h>\n #include <util/strencodings.h>\n #include <util/system.h>\n #include <util/threadnames.h>\n #include <util/tokenpipe.h>\n #include <util/translation.h>\n #include <util/url.h>\n \n+#include <any>\n #include <functional>\n #include <optional>\n \n@@ -142,7 +143,7 @@ static bool AppInit(int argc, char* argv[])\n     // end, which is interpreted as failure to start.\n     TokenPipeEnd daemon_ep;\n #endif\n-    util::Ref context{node};\n+    std::any context{&node};\n     try\n     {\n         if (!CheckDataDirOption()) {"
      },
      {
        "sha": "3b9b66574cf7277b0af813d17c2afa0ce007c6fd",
        "filename": "src/core_io.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/core_io.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/core_io.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_io.h?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -44,8 +44,8 @@ UniValue ValueFromAmount(const CAmount amount);\n std::string FormatScript(const CScript& script);\n std::string EncodeHexTx(const CTransaction& tx, const int serializeFlags = 0);\n std::string SighashToStr(unsigned char sighash_type);\n-void ScriptPubKeyToUniv(const CScript& scriptPubKey, UniValue& out, bool fIncludeHex);\n+void ScriptPubKeyToUniv(const CScript& scriptPubKey, UniValue& out, bool fIncludeHex, bool include_addresses);\n void ScriptToUniv(const CScript& script, UniValue& out, bool include_address);\n-void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry, bool include_hex = true, int serialize_flags = 0, const CTxUndo* txundo = nullptr);\n+void TxToUniv(const CTransaction& tx, const uint256& hashBlock, bool include_addresses, UniValue& entry, bool include_hex = true, int serialize_flags = 0, const CTxUndo* txundo = nullptr);\n \n #endif // BITCOIN_CORE_IO_H"
      },
      {
        "sha": "b35f835f422088dccee490262a5a6e4b3fb3999d",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 8,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -156,10 +156,13 @@ void ScriptToUniv(const CScript& script, UniValue& out, bool include_address)\n     }\n }\n \n+// TODO: from v23 (\"addresses\" and \"reqSigs\" deprecated) this method should be refactored to remove the `include_addresses` option\n+// this method can also be combined with `ScriptToUniv` as they will overlap\n void ScriptPubKeyToUniv(const CScript& scriptPubKey,\n-                        UniValue& out, bool fIncludeHex)\n+                        UniValue& out, bool fIncludeHex, bool include_addresses)\n {\n     TxoutType type;\n+    CTxDestination address;\n     std::vector<CTxDestination> addresses;\n     int nRequired;\n \n@@ -172,17 +175,22 @@ void ScriptPubKeyToUniv(const CScript& scriptPubKey,\n         return;\n     }\n \n-    out.pushKV(\"reqSigs\", nRequired);\n+    if (ExtractDestination(scriptPubKey, address)) {\n+        out.pushKV(\"address\", EncodeDestination(address));\n+    }\n     out.pushKV(\"type\", GetTxnOutputType(type));\n \n-    UniValue a(UniValue::VARR);\n-    for (const CTxDestination& addr : addresses) {\n-        a.push_back(EncodeDestination(addr));\n+    if (include_addresses) {\n+        UniValue a(UniValue::VARR);\n+        for (const CTxDestination& addr : addresses) {\n+            a.push_back(EncodeDestination(addr));\n+        }\n+        out.pushKV(\"addresses\", a);\n+        out.pushKV(\"reqSigs\", nRequired);\n     }\n-    out.pushKV(\"addresses\", a);\n }\n \n-void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry, bool include_hex, int serialize_flags, const CTxUndo* txundo)\n+void TxToUniv(const CTransaction& tx, const uint256& hashBlock, bool include_addresses, UniValue& entry, bool include_hex, int serialize_flags, const CTxUndo* txundo)\n {\n     entry.pushKV(\"txid\", tx.GetHash().GetHex());\n     entry.pushKV(\"hash\", tx.GetWitnessHash().GetHex());\n@@ -241,7 +249,7 @@ void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry,\n         out.pushKV(\"n\", (int64_t)i);\n \n         UniValue o(UniValue::VOBJ);\n-        ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+        ScriptPubKeyToUniv(txout.scriptPubKey, o, true, include_addresses);\n         out.pushKV(\"scriptPubKey\", o);\n         vout.push_back(out);\n "
      },
      {
        "sha": "16ab38e0b2cd6a50c161a515100b7f568a1fbb24",
        "filename": "src/httprpc.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/httprpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/httprpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -144,7 +144,7 @@ static bool RPCAuthorized(const std::string& strAuth, std::string& strAuthUserna\n     return multiUserAuthorized(strUserPass);\n }\n \n-static bool HTTPReq_JSONRPC(const util::Ref& context, HTTPRequest* req)\n+static bool HTTPReq_JSONRPC(const std::any& context, HTTPRequest* req)\n {\n     // JSONRPC handles only POST\n     if (req->GetRequestMethod() != HTTPRequest::POST) {\n@@ -288,7 +288,7 @@ static bool InitRPCAuthentication()\n     return true;\n }\n \n-bool StartHTTPRPC(const util::Ref& context)\n+bool StartHTTPRPC(const std::any& context)\n {\n     LogPrint(BCLog::RPC, \"Starting HTTP RPC server\\n\");\n     if (!InitRPCAuthentication())"
      },
      {
        "sha": "5a3b99064669af51cf20d3f97aeb4125ea809a97",
        "filename": "src/httprpc.h",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/httprpc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/httprpc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.h?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -5,14 +5,12 @@\n #ifndef BITCOIN_HTTPRPC_H\n #define BITCOIN_HTTPRPC_H\n \n-namespace util {\n-class Ref;\n-} // namespace util\n+#include <any>\n \n /** Start HTTP RPC subsystem.\n  * Precondition; HTTP and RPC has been started.\n  */\n-bool StartHTTPRPC(const util::Ref& context);\n+bool StartHTTPRPC(const std::any& context);\n /** Interrupt HTTP RPC subsystem.\n  */\n void InterruptHTTPRPC();\n@@ -24,7 +22,7 @@ void StopHTTPRPC();\n /** Start HTTP REST subsystem.\n  * Precondition; HTTP and RPC has been started.\n  */\n-void StartREST(const util::Ref& context);\n+void StartREST(const std::any& context);\n /** Interrupt RPC REST subsystem.\n  */\n void InterruptREST();"
      },
      {
        "sha": "a44f09f0436b06b1b2094148f96722a102a7adcb",
        "filename": "src/i2p.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 20,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/i2p.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/i2p.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/i2p.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -20,6 +20,7 @@\n #include <util/system.h>\n \n #include <chrono>\n+#include <memory>\n #include <stdexcept>\n #include <string>\n \n@@ -115,7 +116,8 @@ namespace sam {\n Session::Session(const fs::path& private_key_file,\n                  const CService& control_host,\n                  CThreadInterrupt* interrupt)\n-    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(std::make_unique<Sock>(INVALID_SOCKET))\n {\n }\n \n@@ -145,15 +147,15 @@ bool Session::Accept(Connection& conn)\n     try {\n         while (!*m_interrupt) {\n             Sock::Event occurred;\n-            conn.sock.Wait(MAX_WAIT_FOR_IO, Sock::RECV, &occurred);\n+            conn.sock->Wait(MAX_WAIT_FOR_IO, Sock::RECV, &occurred);\n \n             if ((occurred & Sock::RECV) == 0) {\n                 // Timeout, no incoming connections within MAX_WAIT_FOR_IO.\n                 continue;\n             }\n \n             const std::string& peer_dest =\n-                conn.sock.RecvUntilTerminator('\\n', MAX_WAIT_FOR_IO, *m_interrupt, MAX_MSG_SIZE);\n+                conn.sock->RecvUntilTerminator('\\n', MAX_WAIT_FOR_IO, *m_interrupt, MAX_MSG_SIZE);\n \n             conn.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n \n@@ -171,7 +173,7 @@ bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n     proxy_error = true;\n \n     std::string session_id;\n-    Sock sock;\n+    std::unique_ptr<Sock> sock;\n     conn.peer = to;\n \n     try {\n@@ -184,12 +186,12 @@ bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n         }\n \n         const Reply& lookup_reply =\n-            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+            SendRequestAndGetReply(*sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n \n         const std::string& dest = lookup_reply.Get(\"VALUE\");\n \n         const Reply& connect_reply = SendRequestAndGetReply(\n-            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            *sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n             false);\n \n         const std::string& result = connect_reply.Get(\"RESULT\");\n@@ -271,29 +273,29 @@ Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n     return reply;\n }\n \n-Sock Session::Hello() const\n+std::unique_ptr<Sock> Session::Hello() const\n {\n     auto sock = CreateSock(m_control_host);\n \n     if (!sock) {\n         throw std::runtime_error(\"Cannot create socket\");\n     }\n \n-    if (!ConnectSocketDirectly(m_control_host, sock->Get(), nConnectTimeout, true)) {\n+    if (!ConnectSocketDirectly(m_control_host, *sock, nConnectTimeout, true)) {\n         throw std::runtime_error(strprintf(\"Cannot connect to %s\", m_control_host.ToString()));\n     }\n \n     SendRequestAndGetReply(*sock, \"HELLO VERSION MIN=3.1 MAX=3.1\");\n \n-    return std::move(*sock);\n+    return sock;\n }\n \n void Session::CheckControlSock()\n {\n     LOCK(m_mutex);\n \n     std::string errmsg;\n-    if (!m_control_sock.IsConnected(errmsg)) {\n+    if (!m_control_sock->IsConnected(errmsg)) {\n         Log(\"Control socket error: %s\", errmsg);\n         Disconnect();\n     }\n@@ -341,26 +343,26 @@ Binary Session::MyDestination() const\n void Session::CreateIfNotCreatedAlready()\n {\n     std::string errmsg;\n-    if (m_control_sock.IsConnected(errmsg)) {\n+    if (m_control_sock->IsConnected(errmsg)) {\n         return;\n     }\n \n     Log(\"Creating SAM session with %s\", m_control_host.ToString());\n \n-    Sock sock = Hello();\n+    auto sock = Hello();\n \n     const auto& [read_ok, data] = ReadBinaryFile(m_private_key_file);\n     if (read_ok) {\n         m_private_key.assign(data.begin(), data.end());\n     } else {\n-        GenerateAndSavePrivateKey(sock);\n+        GenerateAndSavePrivateKey(*sock);\n     }\n \n     const std::string& session_id = GetRandHash().GetHex().substr(0, 10); // full is an overkill, too verbose in the logs\n     const std::string& private_key_b64 = SwapBase64(EncodeBase64(m_private_key));\n \n-    SendRequestAndGetReply(sock, strprintf(\"SESSION CREATE STYLE=STREAM ID=%s DESTINATION=%s\",\n-                                           session_id, private_key_b64));\n+    SendRequestAndGetReply(*sock, strprintf(\"SESSION CREATE STYLE=STREAM ID=%s DESTINATION=%s\",\n+                                            session_id, private_key_b64));\n \n     m_my_addr = CService(DestBinToAddr(MyDestination()), Params().GetDefaultPort());\n     m_session_id = session_id;\n@@ -370,12 +372,12 @@ void Session::CreateIfNotCreatedAlready()\n               m_my_addr.ToString());\n }\n \n-Sock Session::StreamAccept()\n+std::unique_ptr<Sock> Session::StreamAccept()\n {\n-    Sock sock = Hello();\n+    auto sock = Hello();\n \n     const Reply& reply = SendRequestAndGetReply(\n-        sock, strprintf(\"STREAM ACCEPT ID=%s SILENT=false\", m_session_id), false);\n+        *sock, strprintf(\"STREAM ACCEPT ID=%s SILENT=false\", m_session_id), false);\n \n     const std::string& result = reply.Get(\"RESULT\");\n \n@@ -393,14 +395,14 @@ Sock Session::StreamAccept()\n \n void Session::Disconnect()\n {\n-    if (m_control_sock.Get() != INVALID_SOCKET) {\n+    if (m_control_sock->Get() != INVALID_SOCKET) {\n         if (m_session_id.empty()) {\n             Log(\"Destroying incomplete session\");\n         } else {\n             Log(\"Destroying session %s\", m_session_id);\n         }\n     }\n-    m_control_sock.Reset();\n+    m_control_sock->Reset();\n     m_session_id.clear();\n }\n } // namespace sam"
      },
      {
        "sha": "cb2efedba8b24d310543d4d7e37a4ef5c3750d40",
        "filename": "src/i2p.h",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/i2p.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/i2p.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/i2p.h?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -12,6 +12,7 @@\n #include <threadinterrupt.h>\n #include <util/sock.h>\n \n+#include <memory>\n #include <optional>\n #include <string>\n #include <unordered_map>\n@@ -29,7 +30,7 @@ using Binary = std::vector<uint8_t>;\n  */\n struct Connection {\n     /** Connected socket. */\n-    Sock sock;\n+    std::unique_ptr<Sock> sock;\n \n     /** Our I2P address. */\n     CService me;\n@@ -166,7 +167,7 @@ class Session\n      * @return a connected socket\n      * @throws std::runtime_error if an error occurs\n      */\n-    Sock Hello() const EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+    std::unique_ptr<Sock> Hello() const EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n \n     /**\n      * Check the control socket for errors and possibly disconnect.\n@@ -204,10 +205,11 @@ class Session\n \n     /**\n      * Open a new connection to the SAM proxy and issue \"STREAM ACCEPT\" request using the existing\n-     * session id. Return the idle socket that is waiting for a peer to connect to us.\n+     * session id.\n+     * @return the idle socket that is waiting for a peer to connect to us\n      * @throws std::runtime_error if an error occurs\n      */\n-    Sock StreamAccept() EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+    std::unique_ptr<Sock> StreamAccept() EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n \n     /**\n      * Destroy the session, closing the internally used sockets.\n@@ -248,7 +250,7 @@ class Session\n      * connections and make outgoing ones.\n      * See https://geti2p.net/en/docs/api/samv3\n      */\n-    Sock m_control_sock GUARDED_BY(m_mutex);\n+    std::unique_ptr<Sock> m_control_sock GUARDED_BY(m_mutex);\n \n     /**\n      * Our .b32.i2p address."
      },
      {
        "sha": "17b216573f2d7709013e84cbbbadc694bc0fbb1b",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -228,6 +228,7 @@ void Shutdown(NodeContext& node)\n     node.peerman.reset();\n     node.connman.reset();\n     node.banman.reset();\n+    node.addrman.reset();\n \n     if (node.mempool && node.mempool->IsLoaded() && node.args->GetArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) {\n         DumpMempool(*node.mempool);\n@@ -787,7 +788,7 @@ static bool InitSanityCheck()\n     return true;\n }\n \n-static bool AppInitServers(const util::Ref& context, NodeContext& node)\n+static bool AppInitServers(const std::any& context, NodeContext& node)\n {\n     const ArgsManager& args = *Assert(node.args);\n     RPCServer::OnStarted(&OnRPCStarted);\n@@ -1276,7 +1277,7 @@ bool AppInitInterfaces(NodeContext& node)\n     return true;\n }\n \n-bool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n+bool AppInitMain(const std::any& context, NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n {\n     const ArgsManager& args = *Assert(node.args);\n     const CChainParams& chainparams = Params();\n@@ -1402,10 +1403,12 @@ bool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA\n     fDiscover = args.GetBoolArg(\"-discover\", true);\n     const bool ignores_incoming_txs{args.GetBoolArg(\"-blocksonly\", DEFAULT_BLOCKSONLY)};\n \n+    assert(!node.addrman);\n+    node.addrman = std::make_unique<CAddrMan>();\n     assert(!node.banman);\n     node.banman = std::make_unique<BanMan>(GetDataDir() / \"banlist.dat\", &uiInterface, args.GetArg(\"-bantime\", DEFAULT_MISBEHAVING_BANTIME));\n     assert(!node.connman);\n-    node.connman = std::make_unique<CConnman>(GetRand(std::numeric_limits<uint64_t>::max()), GetRand(std::numeric_limits<uint64_t>::max()), args.GetBoolArg(\"-networkactive\", true));\n+    node.connman = std::make_unique<CConnman>(GetRand(std::numeric_limits<uint64_t>::max()), GetRand(std::numeric_limits<uint64_t>::max()), *node.addrman, args.GetBoolArg(\"-networkactive\", true));\n \n     assert(!node.fee_estimator);\n     // Don't initialize fee estimation with old data if we don't relay transactions,\n@@ -1421,7 +1424,7 @@ bool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA\n     ChainstateManager& chainman = *Assert(node.chainman);\n \n     assert(!node.peerman);\n-    node.peerman = PeerManager::make(chainparams, *node.connman, node.banman.get(),\n+    node.peerman = PeerManager::make(chainparams, *node.connman, *node.addrman, node.banman.get(),\n                                      *node.scheduler, chainman, *node.mempool, ignores_incoming_txs);\n     RegisterValidationInterface(node.peerman.get());\n "
      },
      {
        "sha": "5d01d4c1ac3cab2b949a0469d92d24a51f62265e",
        "filename": "src/init.h",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.h?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -6,6 +6,7 @@\n #ifndef BITCOIN_INIT_H\n #define BITCOIN_INIT_H\n \n+#include <any>\n #include <memory>\n #include <string>\n \n@@ -22,9 +23,6 @@ struct BlockAndHeaderTipInfo;\n namespace boost {\n class thread_group;\n } // namespace boost\n-namespace util {\n-class Ref;\n-} // namespace util\n \n /** Interrupt threads */\n void Interrupt(NodeContext& node);\n@@ -66,7 +64,7 @@ bool AppInitInterfaces(NodeContext& node);\n  * @note This should only be done after daemonization. Call Shutdown() if this function fails.\n  * @pre Parameters should be parsed and config file should be read, AppInitLockDataDirectory should have been called.\n  */\n-bool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info = nullptr);\n+bool AppInitMain(const std::any& context, NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info = nullptr);\n \n /**\n  * Register all arguments with the ArgsManager"
      },
      {
        "sha": "8a9406f810934f8d3d617b54b218d239c7c4e51b",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 9,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -55,9 +55,10 @@ BlockAssembler::Options::Options() {\n     nBlockMaxWeight = DEFAULT_BLOCK_MAX_WEIGHT;\n }\n \n-BlockAssembler::BlockAssembler(const CTxMemPool& mempool, const CChainParams& params, const Options& options)\n+BlockAssembler::BlockAssembler(CChainState& chainstate, const CTxMemPool& mempool, const CChainParams& params, const Options& options)\n     : chainparams(params),\n-      m_mempool(mempool)\n+      m_mempool(mempool),\n+      m_chainstate(chainstate)\n {\n     blockMinFeeRate = options.blockMinFeeRate;\n     // Limit weight to between 4K and MAX_BLOCK_WEIGHT-4K for sanity:\n@@ -79,8 +80,8 @@ static BlockAssembler::Options DefaultOptions()\n     return options;\n }\n \n-BlockAssembler::BlockAssembler(const CTxMemPool& mempool, const CChainParams& params)\n-    : BlockAssembler(mempool, params, DefaultOptions()) {}\n+BlockAssembler::BlockAssembler(CChainState& chainstate, const CTxMemPool& mempool, const CChainParams& params)\n+    : BlockAssembler(chainstate, mempool, params, DefaultOptions()) {}\n \n void BlockAssembler::resetBlock()\n {\n@@ -96,7 +97,7 @@ void BlockAssembler::resetBlock()\n     nFees = 0;\n }\n \n-std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(CChainState& chainstate, const CScript& scriptPubKeyIn)\n+std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n {\n     int64_t nTimeStart = GetTimeMicros();\n \n@@ -114,8 +115,8 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(CChainState& chai\n     pblocktemplate->vTxSigOpsCost.push_back(-1); // updated at end\n \n     LOCK2(cs_main, m_mempool.cs);\n-    assert(std::addressof(*::ChainActive().Tip()) == std::addressof(*chainstate.m_chain.Tip()));\n-    CBlockIndex* pindexPrev = chainstate.m_chain.Tip();\n+    assert(std::addressof(*::ChainActive().Tip()) == std::addressof(*m_chainstate.m_chain.Tip()));\n+    CBlockIndex* pindexPrev = m_chainstate.m_chain.Tip();\n     assert(pindexPrev != nullptr);\n     nHeight = pindexPrev->nHeight + 1;\n \n@@ -174,8 +175,8 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(CChainState& chai\n     pblocktemplate->vTxSigOpsCost[0] = WITNESS_SCALE_FACTOR * GetLegacySigOpCount(*pblock->vtx[0]);\n \n     BlockValidationState state;\n-    assert(std::addressof(::ChainstateActive()) == std::addressof(chainstate));\n-    if (!TestBlockValidity(state, chainparams, chainstate, *pblock, pindexPrev, false, false)) {\n+    assert(std::addressof(::ChainstateActive()) == std::addressof(m_chainstate));\n+    if (!TestBlockValidity(state, chainparams, m_chainstate, *pblock, pindexPrev, false, false)) {\n         throw std::runtime_error(strprintf(\"%s: TestBlockValidity failed: %s\", __func__, state.ToString()));\n     }\n     int64_t nTime2 = GetTimeMicros();"
      },
      {
        "sha": "c400c90f6cb7b5f4d4aa920119ed6a649d8472e0",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -146,6 +146,7 @@ class BlockAssembler\n     int64_t nLockTimeCutoff;\n     const CChainParams& chainparams;\n     const CTxMemPool& m_mempool;\n+    CChainState& m_chainstate;\n \n public:\n     struct Options {\n@@ -154,11 +155,11 @@ class BlockAssembler\n         CFeeRate blockMinFeeRate;\n     };\n \n-    explicit BlockAssembler(const CTxMemPool& mempool, const CChainParams& params);\n-    explicit BlockAssembler(const CTxMemPool& mempool, const CChainParams& params, const Options& options);\n+    explicit BlockAssembler(CChainState& chainstate, const CTxMemPool& mempool, const CChainParams& params);\n+    explicit BlockAssembler(CChainState& chainstate, const CTxMemPool& mempool, const CChainParams& params, const Options& options);\n \n     /** Construct a new block template with coinbase to scriptPubKeyIn */\n-    std::unique_ptr<CBlockTemplate> CreateNewBlock(CChainState& chainstate, const CScript& scriptPubKeyIn);\n+    std::unique_ptr<CBlockTemplate> CreateNewBlock(const CScript& scriptPubKeyIn);\n \n     inline static std::optional<int64_t> m_last_block_num_txs{};\n     inline static std::optional<int64_t> m_last_block_weight{};\n@@ -201,6 +202,7 @@ class BlockAssembler\n void IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev, unsigned int& nExtraNonce);\n int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev);\n \n+// TODO just accept a CBlockIndex*\n /** Update an old GenerateCoinbaseCommitment from CreateNewBlock after the block txs have changed */\n void RegenerateCommitments(CBlock& block, BlockManager& blockman);\n "
      },
      {
        "sha": "c43c53795e24a42d480987945ce0b3252b98dca8",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 73,
        "deletions": 53,
        "changes": 126,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -31,6 +31,10 @@\n #include <fcntl.h>\n #endif\n \n+#if HAVE_DECL_GETIFADDRS && HAVE_DECL_FREEIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+\n #ifdef USE_POLL\n #include <poll.h>\n #endif\n@@ -432,7 +436,7 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n             i2p::Connection conn;\n             if (m_i2p_sam_session->Connect(addrConnect, conn, proxyConnectionFailed)) {\n                 connected = true;\n-                sock = std::make_unique<Sock>(std::move(conn.sock));\n+                sock = std::move(conn.sock);\n                 addr_bind = CAddress{conn.me, NODE_NONE};\n             }\n         } else if (GetProxy(addrConnect.GetNetwork(), proxy)) {\n@@ -448,7 +452,7 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n             if (!sock) {\n                 return nullptr;\n             }\n-            connected = ConnectSocketDirectly(addrConnect, sock->Get(), nConnectTimeout,\n+            connected = ConnectSocketDirectly(addrConnect, *sock, nConnectTimeout,\n                                               conn_type == ConnectionType::MANUAL);\n         }\n         if (!proxyConnectionFailed) {\n@@ -840,6 +844,12 @@ static bool CompareLocalHostTimeConnected(const NodeEvictionCandidate &a, const\n     return a.nTimeConnected > b.nTimeConnected;\n }\n \n+static bool CompareOnionTimeConnected(const NodeEvictionCandidate& a, const NodeEvictionCandidate& b)\n+{\n+    if (a.m_is_onion != b.m_is_onion) return b.m_is_onion;\n+    return a.nTimeConnected > b.nTimeConnected;\n+}\n+\n static bool CompareNetGroupKeyed(const NodeEvictionCandidate &a, const NodeEvictionCandidate &b) {\n     return a.nKeyedNetGroup < b.nKeyedNetGroup;\n }\n@@ -870,13 +880,51 @@ static bool CompareNodeBlockRelayOnlyTime(const NodeEvictionCandidate &a, const\n     return a.nTimeConnected > b.nTimeConnected;\n }\n \n-//! Sort an array by the specified comparator, then erase the last K elements.\n-template<typename T, typename Comparator>\n-static void EraseLastKElements(std::vector<T> &elements, Comparator comparator, size_t k)\n+//! Sort an array by the specified comparator, then erase the last K elements where predicate is true.\n+template <typename T, typename Comparator>\n+static void EraseLastKElements(\n+    std::vector<T>& elements, Comparator comparator, size_t k,\n+    std::function<bool(const NodeEvictionCandidate&)> predicate = [](const NodeEvictionCandidate& n) { return true; })\n {\n     std::sort(elements.begin(), elements.end(), comparator);\n     size_t eraseSize = std::min(k, elements.size());\n-    elements.erase(elements.end() - eraseSize, elements.end());\n+    elements.erase(std::remove_if(elements.end() - eraseSize, elements.end(), predicate), elements.end());\n+}\n+\n+void ProtectEvictionCandidatesByRatio(std::vector<NodeEvictionCandidate>& vEvictionCandidates)\n+{\n+    // Protect the half of the remaining nodes which have been connected the longest.\n+    // This replicates the non-eviction implicit behavior, and precludes attacks that start later.\n+    // To favorise the diversity of our peer connections, reserve up to (half + 2) of\n+    // these protected spots for onion and localhost peers, if any, even if they're not\n+    // longest uptime overall. This helps protect tor peers, which tend to be otherwise\n+    // disadvantaged under our eviction criteria.\n+    const size_t initial_size = vEvictionCandidates.size();\n+    size_t total_protect_size = initial_size / 2;\n+    const size_t onion_protect_size = total_protect_size / 2;\n+\n+    if (onion_protect_size) {\n+        // Pick out up to 1/4 peers connected via our onion service, sorted by longest uptime.\n+        EraseLastKElements(vEvictionCandidates, CompareOnionTimeConnected, onion_protect_size,\n+                           [](const NodeEvictionCandidate& n) { return n.m_is_onion; });\n+    }\n+\n+    const size_t localhost_min_protect_size{2};\n+    if (onion_protect_size >= localhost_min_protect_size) {\n+        // Allocate any remaining slots of the 1/4, or minimum 2 additional slots,\n+        // to localhost peers, sorted by longest uptime, as manually configured\n+        // hidden services not using `-bind=addr[:port]=onion` will not be detected\n+        // as inbound onion connections.\n+        const size_t remaining_tor_slots{onion_protect_size - (initial_size - vEvictionCandidates.size())};\n+        const size_t localhost_protect_size{std::max(remaining_tor_slots, localhost_min_protect_size)};\n+        EraseLastKElements(vEvictionCandidates, CompareLocalHostTimeConnected, localhost_protect_size,\n+                           [](const NodeEvictionCandidate& n) { return n.m_is_local; });\n+    }\n+\n+    // Calculate how many we removed, and update our total number of peers that\n+    // we want to protect based on uptime accordingly.\n+    total_protect_size -= initial_size - vEvictionCandidates.size();\n+    EraseLastKElements(vEvictionCandidates, ReverseCompareNodeTimeConnected, total_protect_size);\n }\n \n [[nodiscard]] std::optional<NodeId> SelectNodeToEvict(std::vector<NodeEvictionCandidate>&& vEvictionCandidates)\n@@ -893,30 +941,17 @@ static void EraseLastKElements(std::vector<T> &elements, Comparator comparator,\n     // An attacker cannot manipulate this metric without performing useful work.\n     EraseLastKElements(vEvictionCandidates, CompareNodeTXTime, 4);\n     // Protect up to 8 non-tx-relay peers that have sent us novel blocks.\n-    std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), CompareNodeBlockRelayOnlyTime);\n-    size_t erase_size = std::min(size_t(8), vEvictionCandidates.size());\n-    vEvictionCandidates.erase(std::remove_if(vEvictionCandidates.end() - erase_size, vEvictionCandidates.end(), [](NodeEvictionCandidate const &n) { return !n.fRelayTxes && n.fRelevantServices; }), vEvictionCandidates.end());\n+    const size_t erase_size = std::min(size_t(8), vEvictionCandidates.size());\n+    EraseLastKElements(vEvictionCandidates, CompareNodeBlockRelayOnlyTime, erase_size,\n+                       [](const NodeEvictionCandidate& n) { return !n.fRelayTxes && n.fRelevantServices; });\n \n     // Protect 4 nodes that most recently sent us novel blocks.\n     // An attacker cannot manipulate this metric without performing useful work.\n     EraseLastKElements(vEvictionCandidates, CompareNodeBlockTime, 4);\n \n-    // Protect the half of the remaining nodes which have been connected the longest.\n-    // This replicates the non-eviction implicit behavior, and precludes attacks that start later.\n-    // Reserve half of these protected spots for localhost peers, even if\n-    // they're not longest-uptime overall. This helps protect tor peers, which\n-    // tend to be otherwise disadvantaged under our eviction criteria.\n-    size_t initial_size = vEvictionCandidates.size();\n-    size_t total_protect_size = initial_size / 2;\n-\n-    // Pick out up to 1/4 peers that are localhost, sorted by longest uptime.\n-    std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), CompareLocalHostTimeConnected);\n-    size_t local_erase_size = total_protect_size / 2;\n-    vEvictionCandidates.erase(std::remove_if(vEvictionCandidates.end() - local_erase_size, vEvictionCandidates.end(), [](NodeEvictionCandidate const &n) { return n.m_is_local; }), vEvictionCandidates.end());\n-    // Calculate how many we removed, and update our total number of peers that\n-    // we want to protect based on uptime accordingly.\n-    total_protect_size -= initial_size - vEvictionCandidates.size();\n-    EraseLastKElements(vEvictionCandidates, ReverseCompareNodeTimeConnected, total_protect_size);\n+    // Protect some of the remaining eviction candidates by ratios of desirable\n+    // or disadvantaged characteristics.\n+    ProtectEvictionCandidatesByRatio(vEvictionCandidates);\n \n     if (vEvictionCandidates.empty()) return std::nullopt;\n \n@@ -937,7 +972,7 @@ static void EraseLastKElements(std::vector<T> &elements, Comparator comparator,\n     for (const NodeEvictionCandidate &node : vEvictionCandidates) {\n         std::vector<NodeEvictionCandidate> &group = mapNetGroupNodes[node.nKeyedNetGroup];\n         group.push_back(node);\n-        int64_t grouptime = group[0].nTimeConnected;\n+        const int64_t grouptime = group[0].nTimeConnected;\n \n         if (group.size() > nMostConnections || (group.size() == nMostConnections && grouptime > nMostConnectionsTime)) {\n             nMostConnections = group.size();\n@@ -985,7 +1020,8 @@ bool CConnman::AttemptToEvictConnection()\n                                                node->nLastBlockTime, node->nLastTXTime,\n                                                HasAllDesirableServiceFlags(node->nServices),\n                                                peer_relay_txes, peer_filter_not_null, node->nKeyedNetGroup,\n-                                               node->m_prefer_evict, node->addr.IsLocal()};\n+                                               node->m_prefer_evict, node->addr.IsLocal(),\n+                                               node->m_inbound_onion};\n             vEvictionCandidates.push_back(candidate);\n         }\n     }\n@@ -1219,9 +1255,10 @@ void CConnman::NotifyNumConnectionsChanged()\n     }\n }\n \n-bool CConnman::RunInactivityChecks(const CNode& node) const\n+bool CConnman::ShouldRunInactivityChecks(const CNode& node, std::optional<int64_t> now_in) const\n {\n-    return GetSystemTimeInSeconds() > node.nTimeConnected + m_peer_connect_timeout;\n+    const int64_t now = now_in ? now_in.value() : GetSystemTimeInSeconds();\n+    return node.nTimeConnected + m_peer_connect_timeout < now;\n }\n \n bool CConnman::InactivityCheck(const CNode& node) const\n@@ -1230,6 +1267,8 @@ bool CConnman::InactivityCheck(const CNode& node) const\n     // use setmocktime in the tests).\n     int64_t now = GetSystemTimeInSeconds();\n \n+    if (!ShouldRunInactivityChecks(node, now)) return false;\n+\n     if (node.nLastRecv == 0 || node.nLastSend == 0) {\n         LogPrint(BCLog::NET, \"socket no message in first %i seconds, %d %d peer=%d\\n\", m_peer_connect_timeout, node.nLastRecv != 0, node.nLastSend != 0, node.GetId());\n         return true;\n@@ -1526,7 +1565,7 @@ void CConnman::SocketHandler()\n             if (bytes_sent) RecordBytesSent(bytes_sent);\n         }\n \n-        if (RunInactivityChecks(*pnode) && InactivityCheck(*pnode)) pnode->fDisconnect = true;\n+        if (InactivityCheck(*pnode)) pnode->fDisconnect = true;\n     }\n     {\n         LOCK(cs_vNodes);\n@@ -2221,7 +2260,7 @@ void CConnman::ThreadI2PAcceptIncoming()\n             continue;\n         }\n \n-        CreateNodeFromAcceptedSocket(conn.sock.Release(), NetPermissionFlags::PF_NONE,\n+        CreateNodeFromAcceptedSocket(conn.sock->Release(), NetPermissionFlags::PF_NONE,\n                                      CAddress{conn.me, NODE_NONE}, CAddress{conn.peer, NODE_NONE});\n     }\n }\n@@ -2351,8 +2390,8 @@ void CConnman::SetNetworkActive(bool active)\n     uiInterface.NotifyNetworkActiveChanged(fNetworkActive);\n }\n \n-CConnman::CConnman(uint64_t nSeed0In, uint64_t nSeed1In, bool network_active)\n-    : nSeed0(nSeed0In), nSeed1(nSeed1In)\n+CConnman::CConnman(uint64_t nSeed0In, uint64_t nSeed1In, CAddrMan& addrman_in, bool network_active)\n+    : addrman(addrman_in), nSeed0(nSeed0In), nSeed1(nSeed1In)\n {\n     SetTryNewOutboundPeer(false);\n \n@@ -2621,11 +2660,7 @@ void CConnman::StopNodes()\n void CConnman::DeleteNode(CNode* pnode)\n {\n     assert(pnode);\n-    bool fUpdateConnectionTime = false;\n-    m_msgproc->FinalizeNode(*pnode, fUpdateConnectionTime);\n-    if (fUpdateConnectionTime) {\n-        addrman.Connected(pnode->addr);\n-    }\n+    m_msgproc->FinalizeNode(*pnode);\n     delete pnode;\n }\n \n@@ -2635,21 +2670,6 @@ CConnman::~CConnman()\n     Stop();\n }\n \n-void CConnman::SetServices(const CService &addr, ServiceFlags nServices)\n-{\n-    addrman.SetServices(addr, nServices);\n-}\n-\n-void CConnman::MarkAddressGood(const CAddress& addr)\n-{\n-    addrman.Good(addr);\n-}\n-\n-bool CConnman::AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty)\n-{\n-    return addrman.Add(vAddr, addrFrom, nTimePenalty);\n-}\n-\n std::vector<CAddress> CConnman::GetAddresses(size_t max_addresses, size_t max_pct)\n {\n     std::vector<CAddress> addresses = addrman.GetAddr(max_addresses, max_pct);"
      },
      {
        "sha": "13f86b6a91878f2a5c6fe3a4a0ea4539dc116593",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 40,
        "deletions": 10,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -425,6 +425,7 @@ class CNode\n \n     std::atomic<int64_t> nLastSend{0};\n     std::atomic<int64_t> nLastRecv{0};\n+    //! Unix epoch time at peer connection, in seconds.\n     const int64_t nTimeConnected;\n     std::atomic<int64_t> nTimeOffset{0};\n     // Address of this peer\n@@ -548,8 +549,9 @@ class CNode\n     std::vector<CAddress> vAddrToSend;\n     std::unique_ptr<CRollingBloomFilter> m_addr_known{nullptr};\n     bool fGetAddr{false};\n-    std::chrono::microseconds m_next_addr_send GUARDED_BY(cs_sendProcessing){0};\n-    std::chrono::microseconds m_next_local_addr_send GUARDED_BY(cs_sendProcessing){0};\n+    Mutex m_addr_send_times_mutex;\n+    std::chrono::microseconds m_next_addr_send GUARDED_BY(m_addr_send_times_mutex){0};\n+    std::chrono::microseconds m_next_local_addr_send GUARDED_BY(m_addr_send_times_mutex){0};\n \n     struct TxRelay {\n         mutable RecursiveMutex cs_filter;\n@@ -770,7 +772,7 @@ class NetEventsInterface\n     virtual void InitializeNode(CNode* pnode) = 0;\n \n     /** Handle removal of a peer (clear state) */\n-    virtual void FinalizeNode(const CNode& node, bool& update_connection_time) = 0;\n+    virtual void FinalizeNode(const CNode& node) = 0;\n \n     /**\n     * Process protocol messages received from a given node\n@@ -856,7 +858,7 @@ class CConnman\n         m_onion_binds = connOptions.onion_binds;\n     }\n \n-    CConnman(uint64_t seed0, uint64_t seed1, bool network_active = true);\n+    CConnman(uint64_t seed0, uint64_t seed1, CAddrMan& addrman, bool network_active = true);\n     ~CConnman();\n     bool Start(CScheduler& scheduler, const Options& options);\n \n@@ -921,9 +923,6 @@ class CConnman\n     };\n \n     // Addrman functions\n-    void SetServices(const CService &addr, ServiceFlags nServices);\n-    void MarkAddressGood(const CAddress& addr);\n-    bool AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty = 0);\n     std::vector<CAddress> GetAddresses(size_t max_addresses, size_t max_pct);\n     /**\n      * Cache is used to minimize topology leaks, so it should\n@@ -1019,8 +1018,8 @@ class CConnman\n \n     void SetAsmap(std::vector<bool> asmap) { addrman.m_asmap = std::move(asmap); }\n \n-    /** Return true if the peer has been connected for long enough to do inactivity checks. */\n-    bool RunInactivityChecks(const CNode& node) const;\n+    /** Return true if we should disconnect the peer for failing an inactivity check. */\n+    bool ShouldRunInactivityChecks(const CNode& node, std::optional<int64_t> now=std::nullopt) const;\n \n private:\n     struct ListenSocket {\n@@ -1130,7 +1129,7 @@ class CConnman\n     std::vector<ListenSocket> vhListenSocket;\n     std::atomic<bool> fNetworkActive{true};\n     bool fAddressesInitialized{false};\n-    CAddrMan addrman;\n+    CAddrMan& addrman;\n     std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n     RecursiveMutex m_addr_fetches_mutex;\n     std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);\n@@ -1281,8 +1280,39 @@ struct NodeEvictionCandidate\n     uint64_t nKeyedNetGroup;\n     bool prefer_evict;\n     bool m_is_local;\n+    bool m_is_onion;\n };\n \n+/**\n+ * Select an inbound peer to evict after filtering out (protecting) peers having\n+ * distinct, difficult-to-forge characteristics. The protection logic picks out\n+ * fixed numbers of desirable peers per various criteria, followed by (mostly)\n+ * ratios of desirable or disadvantaged peers. If any eviction candidates\n+ * remain, the selection logic chooses a peer to evict.\n+ */\n [[nodiscard]] std::optional<NodeId> SelectNodeToEvict(std::vector<NodeEvictionCandidate>&& vEvictionCandidates);\n \n+/** Protect desirable or disadvantaged inbound peers from eviction by ratio.\n+ *\n+ * This function protects half of the peers which have been connected the\n+ * longest, to replicate the non-eviction implicit behavior and preclude attacks\n+ * that start later.\n+ *\n+ * Half of these protected spots (1/4 of the total) are reserved for onion peers\n+ * connected via our tor control service, if any, sorted by longest uptime, even\n+ * if they're not longest uptime overall. Any remaining slots of the 1/4 are\n+ * then allocated to protect localhost peers, if any (or up to 2 localhost peers\n+ * if no slots remain and 2 or more onion peers were protected), sorted by\n+ * longest uptime, as manually configured hidden services not using\n+ * `-bind=addr[:port]=onion` will not be detected as inbound onion connections.\n+ *\n+ * This helps protect onion peers, which tend to be otherwise disadvantaged\n+ * under our eviction criteria for their higher min ping times relative to IPv4\n+ * and IPv6 peers, and favorise the diversity of peer connections.\n+ *\n+ * This function was extracted from SelectNodeToEvict() to be able to test the\n+ * ratio-based protection logic deterministically.\n+ */\n+void ProtectEvictionCandidatesByRatio(std::vector<NodeEvictionCandidate>& vEvictionCandidates);\n+\n #endif // BITCOIN_NET_H"
      },
      {
        "sha": "4108de2c8a8b47059c25398154ca970624502f16",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 167,
        "deletions": 148,
        "changes": 315,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -33,6 +33,7 @@\n #include <util/system.h>\n #include <validation.h>\n \n+#include <algorithm>\n #include <memory>\n #include <optional>\n #include <typeinfo>\n@@ -225,9 +226,9 @@ using PeerRef = std::shared_ptr<Peer>;\n class PeerManagerImpl final : public PeerManager\n {\n public:\n-    PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n-                    CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool,\n-                    bool ignore_incoming_txs);\n+    PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n+                    BanMan* banman, CScheduler& scheduler, ChainstateManager& chainman,\n+                    CTxMemPool& pool, bool ignore_incoming_txs);\n \n     /** Overridden from CValidationInterface. */\n     void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected) override;\n@@ -238,7 +239,7 @@ class PeerManagerImpl final : public PeerManager\n \n     /** Implement NetEventsInterface */\n     void InitializeNode(CNode* pnode) override;\n-    void FinalizeNode(const CNode& node, bool& fUpdateConnectionTime) override;\n+    void FinalizeNode(const CNode& node) override;\n     bool ProcessMessages(CNode* pfrom, std::atomic<bool>& interrupt) override;\n     bool SendMessages(CNode* pto) override EXCLUSIVE_LOCKS_REQUIRED(pto->cs_sendProcessing);\n \n@@ -317,11 +318,17 @@ class PeerManagerImpl final : public PeerManager\n     void PushNodeVersion(CNode& pnode, int64_t nTime);\n \n     /** Send a ping message every PING_INTERVAL or if requested via RPC. May\n-     *  mark the peer to be disconnected if a ping has timed out. */\n-    void MaybeSendPing(CNode& node_to, Peer& peer);\n+     *  mark the peer to be disconnected if a ping has timed out.\n+     *  We use mockable time for ping timeouts, so setmocktime may cause pings\n+     *  to time out. */\n+    void MaybeSendPing(CNode& node_to, Peer& peer, std::chrono::microseconds now);\n+\n+    /** Send `addr` messages on a regular schedule. */\n+    void MaybeSendAddr(CNode& node, std::chrono::microseconds current_time);\n \n     const CChainParams& m_chainparams;\n     CConnman& m_connman;\n+    CAddrMan& m_addrman;\n     /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n     BanMan* const m_banman;\n     ChainstateManager& m_chainman;\n@@ -475,19 +482,70 @@ class PeerManagerImpl final : public PeerManager\n     /** Offset into vExtraTxnForCompact to insert the next tx */\n     size_t vExtraTxnForCompactIt GUARDED_BY(g_cs_orphans) = 0;\n \n+    /** Check whether the last unknown block a peer advertised is not yet known. */\n     void ProcessBlockAvailability(NodeId nodeid) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    /** Update tracking information about which blocks a peer is assumed to have. */\n     void UpdateBlockAvailability(NodeId nodeid, const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     bool CanDirectFetch() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    /**\n+     * To prevent fingerprinting attacks, only send blocks/headers outside of\n+     * the active chain if they are no more than a month older (both in time,\n+     * and in best equivalent proof of work) than the best header chain we know\n+     * about and we fully-validated them at some point.\n+     */\n     bool BlockRequestAllowed(const CBlockIndex* pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     bool AlreadyHaveBlock(const uint256& block_hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     void ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv& inv);\n+\n+    /**\n+     * Validation logic for compact filters request handling.\n+     *\n+     * May disconnect from the peer in the case of a bad request.\n+     *\n+     * @param[in]   peer            The peer that we received the request from\n+     * @param[in]   filter_type     The filter type the request is for. Must be basic filters.\n+     * @param[in]   start_height    The start height for the request\n+     * @param[in]   stop_hash       The stop_hash for the request\n+     * @param[in]   max_height_diff The maximum number of items permitted to request, as specified in BIP 157\n+     * @param[out]  stop_index      The CBlockIndex for the stop_hash block, if the request can be serviced.\n+     * @param[out]  filter_index    The filter index, if the request can be serviced.\n+     * @return                      True if the request can be serviced.\n+     */\n     bool PrepareBlockFilterRequest(CNode& peer,\n                                    BlockFilterType filter_type, uint32_t start_height,\n                                    const uint256& stop_hash, uint32_t max_height_diff,\n                                    const CBlockIndex*& stop_index,\n                                    BlockFilterIndex*& filter_index);\n+\n+    /**\n+     * Handle a cfilters request.\n+     *\n+     * May disconnect from the peer in the case of a bad request.\n+     *\n+     * @param[in]   peer            The peer that we received the request from\n+     * @param[in]   vRecv           The raw message received\n+     */\n     void ProcessGetCFilters(CNode& peer, CDataStream& vRecv);\n+\n+    /**\n+     * Handle a cfheaders request.\n+     *\n+     * May disconnect from the peer in the case of a bad request.\n+     *\n+     * @param[in]   peer            The peer that we received the request from\n+     * @param[in]   vRecv           The raw message received\n+     */\n     void ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv);\n+\n+    /**\n+     * Handle a getcfcheckpt request.\n+     *\n+     * May disconnect from the peer in the case of a bad request.\n+     *\n+     * @param[in]   peer            The peer that we received the request from\n+     * @param[in]   vRecv           The raw message received\n+     */\n     void ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv);\n };\n } // namespace\n@@ -741,7 +799,6 @@ static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIV\n     return false;\n }\n \n-/** Check whether the last unknown block a peer advertised is not yet known. */\n void PeerManagerImpl::ProcessBlockAvailability(NodeId nodeid) {\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n@@ -757,7 +814,6 @@ void PeerManagerImpl::ProcessBlockAvailability(NodeId nodeid) {\n     }\n }\n \n-/** Update tracking information about which blocks a peer is assumed to have. */\n void PeerManagerImpl::UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n@@ -968,12 +1024,12 @@ void PeerManagerImpl::ReattemptInitialBroadcast(CScheduler& scheduler)\n     scheduler.scheduleFromNow([&] { ReattemptInitialBroadcast(scheduler); }, delta);\n }\n \n-void PeerManagerImpl::FinalizeNode(const CNode& node, bool& fUpdateConnectionTime)\n+void PeerManagerImpl::FinalizeNode(const CNode& node)\n {\n     NodeId nodeid = node.GetId();\n-    fUpdateConnectionTime = false;\n-    LOCK(cs_main);\n     int misbehavior{0};\n+    {\n+    LOCK(cs_main);\n     {\n         // We remove the PeerRef from g_peer_map here, but we don't always\n         // destruct the Peer. Sometimes another thread is still holding a\n@@ -990,12 +1046,6 @@ void PeerManagerImpl::FinalizeNode(const CNode& node, bool& fUpdateConnectionTim\n     if (state->fSyncStarted)\n         nSyncStarted--;\n \n-    if (node.fSuccessfullyConnected && misbehavior == 0 &&\n-        !node.IsBlockOnlyConn() && !node.IsInboundConn()) {\n-        // Only change visible addrman state for outbound, full-relay peers\n-        fUpdateConnectionTime = true;\n-    }\n-\n     for (const QueuedBlock& entry : state->vBlocksInFlight) {\n         mapBlocksInFlight.erase(entry.hash);\n     }\n@@ -1020,6 +1070,14 @@ void PeerManagerImpl::FinalizeNode(const CNode& node, bool& fUpdateConnectionTim\n         assert(m_wtxid_relay_peers == 0);\n         assert(m_txrequest.Size() == 0);\n     }\n+    } // cs_main\n+    if (node.fSuccessfullyConnected && misbehavior == 0 &&\n+        !node.IsBlockOnlyConn() && !node.IsInboundConn()) {\n+        // Only change visible addrman state for full outbound peers.  We don't\n+        // call Connected() for feeler connections since they don't have\n+        // fSuccessfullyConnected set.\n+        m_addrman.Connected(node.addr);\n+    }\n     LogPrint(BCLog::NET, \"Cleared nodestate for peer=%d\\n\", nodeid);\n }\n \n@@ -1182,16 +1240,6 @@ bool PeerManagerImpl::MaybePunishNodeForTx(NodeId nodeid, const TxValidationStat\n     return false;\n }\n \n-\n-//////////////////////////////////////////////////////////////////////////////\n-//\n-// blockchain -> download logic notification\n-//\n-\n-// To prevent fingerprinting attacks, only send blocks/headers outside of the\n-// active chain if they are no more than a month older (both in time, and in\n-// best equivalent proof of work) than the best header chain we know about and\n-// we fully-validated them at some point.\n bool PeerManagerImpl::BlockRequestAllowed(const CBlockIndex* pindex)\n {\n     AssertLockHeld(cs_main);\n@@ -1201,18 +1249,19 @@ bool PeerManagerImpl::BlockRequestAllowed(const CBlockIndex* pindex)\n            (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, m_chainparams.GetConsensus()) < STALE_RELAY_AGE_LIMIT);\n }\n \n-std::unique_ptr<PeerManager> PeerManager::make(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n-                                               CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool,\n-                                               bool ignore_incoming_txs)\n+std::unique_ptr<PeerManager> PeerManager::make(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n+                                               BanMan* banman, CScheduler& scheduler, ChainstateManager& chainman,\n+                                               CTxMemPool& pool, bool ignore_incoming_txs)\n {\n-    return std::make_unique<PeerManagerImpl>(chainparams, connman, banman, scheduler, chainman, pool, ignore_incoming_txs);\n+    return std::make_unique<PeerManagerImpl>(chainparams, connman, addrman, banman, scheduler, chainman, pool, ignore_incoming_txs);\n }\n \n-PeerManagerImpl::PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n-                                 CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool,\n-                                 bool ignore_incoming_txs)\n+PeerManagerImpl::PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n+                                 BanMan* banman, CScheduler& scheduler, ChainstateManager& chainman,\n+                                 CTxMemPool& pool, bool ignore_incoming_txs)\n     : m_chainparams(chainparams),\n       m_connman(connman),\n+      m_addrman(addrman),\n       m_banman(banman),\n       m_chainman(chainman),\n       m_mempool(pool),\n@@ -2091,20 +2140,6 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n     m_mempool.check(m_chainman.ActiveChainstate());\n }\n \n-/**\n- * Validation logic for compact filters request handling.\n- *\n- * May disconnect from the peer in the case of a bad request.\n- *\n- * @param[in]   peer            The peer that we received the request from\n- * @param[in]   filter_type     The filter type the request is for. Must be basic filters.\n- * @param[in]   start_height    The start height for the request\n- * @param[in]   stop_hash       The stop_hash for the request\n- * @param[in]   max_height_diff The maximum number of items permitted to request, as specified in BIP 157\n- * @param[out]  stop_index      The CBlockIndex for the stop_hash block, if the request can be serviced.\n- * @param[out]  filter_index    The filter index, if the request can be serviced.\n- * @return                      True if the request can be serviced.\n- */\n bool PeerManagerImpl::PrepareBlockFilterRequest(CNode& peer,\n                                                 BlockFilterType filter_type, uint32_t start_height,\n                                                 const uint256& stop_hash, uint32_t max_height_diff,\n@@ -2158,14 +2193,6 @@ bool PeerManagerImpl::PrepareBlockFilterRequest(CNode& peer,\n     return true;\n }\n \n-/**\n- * Handle a cfilters request.\n- *\n- * May disconnect from the peer in the case of a bad request.\n- *\n- * @param[in]   peer            The peer that we received the request from\n- * @param[in]   vRecv           The raw message received\n- */\n void PeerManagerImpl::ProcessGetCFilters(CNode& peer, CDataStream& vRecv)\n {\n     uint8_t filter_type_ser;\n@@ -2197,14 +2224,6 @@ void PeerManagerImpl::ProcessGetCFilters(CNode& peer, CDataStream& vRecv)\n     }\n }\n \n-/**\n- * Handle a cfheaders request.\n- *\n- * May disconnect from the peer in the case of a bad request.\n- *\n- * @param[in]   peer            The peer that we received the request from\n- * @param[in]   vRecv           The raw message received\n- */\n void PeerManagerImpl::ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv)\n {\n     uint8_t filter_type_ser;\n@@ -2249,14 +2268,6 @@ void PeerManagerImpl::ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv)\n     m_connman.PushMessage(&peer, std::move(msg));\n }\n \n-/**\n- * Handle a getcfcheckpt request.\n- *\n- * May disconnect from the peer in the case of a bad request.\n- *\n- * @param[in]   peer            The peer that we received the request from\n- * @param[in]   vRecv           The raw message received\n- */\n void PeerManagerImpl::ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv)\n {\n     uint8_t filter_type_ser;\n@@ -2330,7 +2341,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         nServices = ServiceFlags(nServiceInt);\n         if (!pfrom.IsInboundConn())\n         {\n-            m_connman.SetServices(pfrom.addr, nServices);\n+            m_addrman.SetServices(pfrom.addr, nServices);\n         }\n         if (pfrom.ExpectServicesFromConn() && !HasAllDesirableServiceFlags(nServices))\n         {\n@@ -2474,7 +2485,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             //\n             // This moves an address from New to Tried table in Addrman,\n             // resolves tried-table collisions, etc.\n-            m_connman.MarkAddressGood(pfrom.addr);\n+            m_addrman.Good(pfrom.addr);\n         }\n \n         std::string remoteAddr;\n@@ -2679,7 +2690,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             if (fReachable)\n                 vAddrOk.push_back(addr);\n         }\n-        m_connman.AddNewAddresses(vAddrOk, pfrom.addr, 2 * 60 * 60);\n+        m_addrman.Add(vAddrOk, pfrom.addr, 2 * 60 * 60);\n         if (vAddr.size() < 1000)\n             pfrom.fGetAddr = false;\n         if (pfrom.IsAddrFetchConn()) {\n@@ -4096,13 +4107,9 @@ void PeerManagerImpl::CheckForStaleTipAndEvictPeers()\n     }\n }\n \n-void PeerManagerImpl::MaybeSendPing(CNode& node_to, Peer& peer)\n+void PeerManagerImpl::MaybeSendPing(CNode& node_to, Peer& peer, std::chrono::microseconds now)\n {\n-    // Use mockable time for ping timeouts.\n-    // This means that setmocktime may cause pings to time out.\n-    auto now = GetTime<std::chrono::microseconds>();\n-\n-    if (m_connman.RunInactivityChecks(node_to) && peer.m_ping_nonce_sent &&\n+    if (m_connman.ShouldRunInactivityChecks(node_to) && peer.m_ping_nonce_sent &&\n         now > peer.m_ping_start.load() + std::chrono::seconds{TIMEOUT_INTERVAL}) {\n         LogPrint(BCLog::NET, \"ping timeout: %fs peer=%d\\n\", 0.000001 * count_microseconds(now - peer.m_ping_start.load()), peer.m_id);\n         node_to.fDisconnect = true;\n@@ -4140,6 +4147,75 @@ void PeerManagerImpl::MaybeSendPing(CNode& node_to, Peer& peer)\n     }\n }\n \n+void PeerManagerImpl::MaybeSendAddr(CNode& node, std::chrono::microseconds current_time)\n+{\n+    // Nothing to do for non-address-relay peers\n+    if (!node.RelayAddrsWithConn()) return;\n+\n+    assert(node.m_addr_known);\n+\n+    LOCK(node.m_addr_send_times_mutex);\n+    // Periodically advertise our local address to the peer.\n+    if (fListen && !m_chainman.ActiveChainstate().IsInitialBlockDownload() &&\n+        node.m_next_local_addr_send < current_time) {\n+        // If we've sent before, clear the bloom filter for the peer, so that our\n+        // self-announcement will actually go out.\n+        // This might be unnecessary if the bloom filter has already rolled\n+        // over since our last self-announcement, but there is only a small\n+        // bandwidth cost that we can incur by doing this (which happens\n+        // once a day on average).\n+        if (node.m_next_local_addr_send != 0us) {\n+            node.m_addr_known->reset();\n+        }\n+        if (std::optional<CAddress> local_addr = GetLocalAddrForPeer(&node)) {\n+            FastRandomContext insecure_rand;\n+            node.PushAddress(*local_addr, insecure_rand);\n+        }\n+        node.m_next_local_addr_send = PoissonNextSend(current_time, AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL);\n+    }\n+\n+    // We sent an `addr` message to this peer recently. Nothing more to do.\n+    if (current_time <= node.m_next_addr_send) return;\n+\n+    node.m_next_addr_send = PoissonNextSend(current_time, AVG_ADDRESS_BROADCAST_INTERVAL);\n+\n+    if (!Assume(node.vAddrToSend.size() <= MAX_ADDR_TO_SEND)) {\n+        // Should be impossible since we always check size before adding to\n+        // vAddrToSend. Recover by trimming the vector.\n+        node.vAddrToSend.resize(MAX_ADDR_TO_SEND);\n+    }\n+\n+    // Remove addr records that the peer already knows about, and add new\n+    // addrs to the m_addr_known filter on the same pass.\n+    auto addr_already_known = [&node](const CAddress& addr) {\n+        bool ret = node.m_addr_known->contains(addr.GetKey());\n+        if (!ret) node.m_addr_known->insert(addr.GetKey());\n+        return ret;\n+    };\n+    node.vAddrToSend.erase(std::remove_if(node.vAddrToSend.begin(), node.vAddrToSend.end(), addr_already_known),\n+                           node.vAddrToSend.end());\n+\n+    // No addr messages to send\n+    if (node.vAddrToSend.empty()) return;\n+\n+    const char* msg_type;\n+    int make_flags;\n+    if (node.m_wants_addrv2) {\n+        msg_type = NetMsgType::ADDRV2;\n+        make_flags = ADDRV2_FORMAT;\n+    } else {\n+        msg_type = NetMsgType::ADDR;\n+        make_flags = 0;\n+    }\n+    m_connman.PushMessage(&node, CNetMsgMaker(node.GetCommonVersion()).Make(make_flags, msg_type, node.vAddrToSend));\n+    node.vAddrToSend.clear();\n+\n+    // we only send the big addr message once\n+    if (node.vAddrToSend.capacity() > 40) {\n+        node.vAddrToSend.shrink_to_fit();\n+    }\n+}\n+\n namespace {\n class CompareInvMempoolOrder\n {\n@@ -4178,79 +4254,20 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n     // If we get here, the outgoing message serialization version is set and can't change.\n     const CNetMsgMaker msgMaker(pto->GetCommonVersion());\n \n-    MaybeSendPing(*pto, *peer);\n+    const auto current_time = GetTime<std::chrono::microseconds>();\n+\n+    MaybeSendPing(*pto, *peer, current_time);\n \n     // MaybeSendPing may have marked peer for disconnection\n     if (pto->fDisconnect) return true;\n \n+    MaybeSendAddr(*pto, current_time);\n+\n     {\n         LOCK(cs_main);\n \n         CNodeState &state = *State(pto->GetId());\n \n-        // Address refresh broadcast\n-        auto current_time = GetTime<std::chrono::microseconds>();\n-\n-        if (fListen && pto->RelayAddrsWithConn() &&\n-            !m_chainman.ActiveChainstate().IsInitialBlockDownload() &&\n-            pto->m_next_local_addr_send < current_time) {\n-            // If we've sent before, clear the bloom filter for the peer, so that our\n-            // self-announcement will actually go out.\n-            // This might be unnecessary if the bloom filter has already rolled\n-            // over since our last self-announcement, but there is only a small\n-            // bandwidth cost that we can incur by doing this (which happens\n-            // once a day on average).\n-            if (pto->m_next_local_addr_send != 0us) {\n-                pto->m_addr_known->reset();\n-            }\n-            if (std::optional<CAddress> local_addr = GetLocalAddrForPeer(pto)) {\n-                FastRandomContext insecure_rand;\n-                pto->PushAddress(*local_addr, insecure_rand);\n-            }\n-            pto->m_next_local_addr_send = PoissonNextSend(current_time, AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL);\n-        }\n-\n-        //\n-        // Message: addr\n-        //\n-        if (pto->RelayAddrsWithConn() && pto->m_next_addr_send < current_time) {\n-            pto->m_next_addr_send = PoissonNextSend(current_time, AVG_ADDRESS_BROADCAST_INTERVAL);\n-            std::vector<CAddress> vAddr;\n-            vAddr.reserve(pto->vAddrToSend.size());\n-            assert(pto->m_addr_known);\n-\n-            const char* msg_type;\n-            int make_flags;\n-            if (pto->m_wants_addrv2) {\n-                msg_type = NetMsgType::ADDRV2;\n-                make_flags = ADDRV2_FORMAT;\n-            } else {\n-                msg_type = NetMsgType::ADDR;\n-                make_flags = 0;\n-            }\n-\n-            for (const CAddress& addr : pto->vAddrToSend)\n-            {\n-                if (!pto->m_addr_known->contains(addr.GetKey()))\n-                {\n-                    pto->m_addr_known->insert(addr.GetKey());\n-                    vAddr.push_back(addr);\n-                    // receiver rejects addr messages larger than MAX_ADDR_TO_SEND\n-                    if (vAddr.size() >= MAX_ADDR_TO_SEND)\n-                    {\n-                        m_connman.PushMessage(pto, msgMaker.Make(make_flags, msg_type, vAddr));\n-                        vAddr.clear();\n-                    }\n-                }\n-            }\n-            pto->vAddrToSend.clear();\n-            if (!vAddr.empty())\n-                m_connman.PushMessage(pto, msgMaker.Make(make_flags, msg_type, vAddr));\n-            // we only send the big addr message once\n-            if (pto->vAddrToSend.capacity() > 40)\n-                pto->vAddrToSend.shrink_to_fit();\n-        }\n-\n         // Start block sync\n         if (pindexBestHeader == nullptr)\n             pindexBestHeader = m_chainman.ActiveChain().Tip();\n@@ -4485,7 +4502,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             vInv.clear();\n                         }\n                     }\n-                    pto->m_tx_relay->m_last_mempool_req = GetTime<std::chrono::seconds>();\n+                    pto->m_tx_relay->m_last_mempool_req = std::chrono::duration_cast<std::chrono::seconds>(current_time);\n                 }\n \n                 // Determine transactions to relay\n@@ -4573,7 +4590,6 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n         // Detect whether we're stalling\n-        current_time = GetTime<std::chrono::microseconds>();\n         if (state.m_stalling_since.count() && state.m_stalling_since < current_time - BLOCK_STALLING_TIMEOUT) {\n             // Stalling only triggers when the block download window cannot move. During normal steady state,\n             // the download window should be much larger than the to-be-downloaded set of blocks, so disconnection\n@@ -4689,7 +4705,10 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         //\n         // Message: feefilter\n         //\n-        if (pto->m_tx_relay != nullptr && pto->GetCommonVersion() >= FEEFILTER_VERSION && gArgs.GetBoolArg(\"-feefilter\", DEFAULT_FEEFILTER) &&\n+        if (pto->m_tx_relay != nullptr &&\n+            !m_ignore_incoming_txs &&\n+            pto->GetCommonVersion() >= FEEFILTER_VERSION &&\n+            gArgs.GetBoolArg(\"-feefilter\", DEFAULT_FEEFILTER) &&\n             !pto->HasPermission(PF_FORCERELAY) // peers with the forcerelay permission should not filter txs to us\n         ) {\n             CAmount currentFilter = m_mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();"
      },
      {
        "sha": "4556d32377139e767a59b2e524bcf46ad94541fb",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -10,6 +10,7 @@\n #include <sync.h>\n #include <validationinterface.h>\n \n+class CAddrMan;\n class CChainParams;\n class CTxMemPool;\n class ChainstateManager;\n@@ -36,9 +37,9 @@ struct CNodeStateStats {\n class PeerManager : public CValidationInterface, public NetEventsInterface\n {\n public:\n-    static std::unique_ptr<PeerManager> make(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n-                                             CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool,\n-                                             bool ignore_incoming_txs);\n+    static std::unique_ptr<PeerManager> make(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n+                                             BanMan* banman, CScheduler& scheduler, ChainstateManager& chainman,\n+                                             CTxMemPool& pool, bool ignore_incoming_txs);\n     virtual ~PeerManager() { }\n \n     /** Get statistics from node state */"
      },
      {
        "sha": "2980bdf4592338b9dfd90ea24357ba997c10d016",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 36,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -537,12 +537,12 @@ static void LogConnectFailure(bool manual_connection, const char* fmt, const Arg\n     }\n }\n \n-bool ConnectSocketDirectly(const CService &addrConnect, const SOCKET& hSocket, int nTimeout, bool manual_connection)\n+bool ConnectSocketDirectly(const CService &addrConnect, const Sock& sock, int nTimeout, bool manual_connection)\n {\n     // Create a sockaddr from the specified service.\n     struct sockaddr_storage sockaddr;\n     socklen_t len = sizeof(sockaddr);\n-    if (hSocket == INVALID_SOCKET) {\n+    if (sock.Get() == INVALID_SOCKET) {\n         LogPrintf(\"Cannot connect to %s: invalid socket\\n\", addrConnect.ToString());\n         return false;\n     }\n@@ -552,55 +552,42 @@ bool ConnectSocketDirectly(const CService &addrConnect, const SOCKET& hSocket, i\n     }\n \n     // Connect to the addrConnect service on the hSocket socket.\n-    if (connect(hSocket, (struct sockaddr*)&sockaddr, len) == SOCKET_ERROR)\n-    {\n+    if (sock.Connect(reinterpret_cast<struct sockaddr*>(&sockaddr), len) == SOCKET_ERROR) {\n         int nErr = WSAGetLastError();\n         // WSAEINVAL is here because some legacy version of winsock uses it\n         if (nErr == WSAEINPROGRESS || nErr == WSAEWOULDBLOCK || nErr == WSAEINVAL)\n         {\n             // Connection didn't actually fail, but is being established\n             // asynchronously. Thus, use async I/O api (select/poll)\n             // synchronously to check for successful connection with a timeout.\n-#ifdef USE_POLL\n-            struct pollfd pollfd = {};\n-            pollfd.fd = hSocket;\n-            pollfd.events = POLLIN | POLLOUT;\n-            int nRet = poll(&pollfd, 1, nTimeout);\n-#else\n-            struct timeval timeout = MillisToTimeval(nTimeout);\n-            fd_set fdset;\n-            FD_ZERO(&fdset);\n-            FD_SET(hSocket, &fdset);\n-            int nRet = select(hSocket + 1, nullptr, &fdset, nullptr, &timeout);\n-#endif\n-            // Upon successful completion, both select and poll return the total\n-            // number of file descriptors that have been selected. A value of 0\n-            // indicates that the call timed out and no file descriptors have\n-            // been selected.\n-            if (nRet == 0)\n-            {\n-                LogPrint(BCLog::NET, \"connection to %s timeout\\n\", addrConnect.ToString());\n+            const Sock::Event requested = Sock::RECV | Sock::SEND;\n+            Sock::Event occurred;\n+            if (!sock.Wait(std::chrono::milliseconds{nTimeout}, requested, &occurred)) {\n+                LogPrintf(\"wait for connect to %s failed: %s\\n\",\n+                          addrConnect.ToString(),\n+                          NetworkErrorString(WSAGetLastError()));\n                 return false;\n-            }\n-            if (nRet == SOCKET_ERROR)\n-            {\n-                LogPrintf(\"select() for %s failed: %s\\n\", addrConnect.ToString(), NetworkErrorString(WSAGetLastError()));\n+            } else if (occurred == 0) {\n+                LogPrint(BCLog::NET, \"connection attempt to %s timed out\\n\", addrConnect.ToString());\n                 return false;\n             }\n \n-            // Even if the select/poll was successful, the connect might not\n+            // Even if the wait was successful, the connect might not\n             // have been successful. The reason for this failure is hidden away\n             // in the SO_ERROR for the socket in modern systems. We read it into\n-            // nRet here.\n-            socklen_t nRetSize = sizeof(nRet);\n-            if (getsockopt(hSocket, SOL_SOCKET, SO_ERROR, (sockopt_arg_type)&nRet, &nRetSize) == SOCKET_ERROR)\n-            {\n+            // sockerr here.\n+            int sockerr;\n+            socklen_t sockerr_len = sizeof(sockerr);\n+            if (sock.GetSockOpt(SOL_SOCKET, SO_ERROR, (sockopt_arg_type)&sockerr, &sockerr_len) ==\n+                SOCKET_ERROR) {\n                 LogPrintf(\"getsockopt() for %s failed: %s\\n\", addrConnect.ToString(), NetworkErrorString(WSAGetLastError()));\n                 return false;\n             }\n-            if (nRet != 0)\n-            {\n-                LogConnectFailure(manual_connection, \"connect() to %s failed after select(): %s\", addrConnect.ToString(), NetworkErrorString(nRet));\n+            if (sockerr != 0) {\n+                LogConnectFailure(manual_connection,\n+                                  \"connect() to %s failed after wait: %s\",\n+                                  addrConnect.ToString(),\n+                                  NetworkErrorString(sockerr));\n                 return false;\n             }\n         }\n@@ -668,7 +655,7 @@ bool IsProxy(const CNetAddr &addr) {\n bool ConnectThroughProxy(const proxyType& proxy, const std::string& strDest, uint16_t port, const Sock& sock, int nTimeout, bool& outProxyConnectionFailed)\n {\n     // first connect to proxy server\n-    if (!ConnectSocketDirectly(proxy.proxy, sock.Get(), nTimeout, true)) {\n+    if (!ConnectSocketDirectly(proxy.proxy, sock, nTimeout, true)) {\n         outProxyConnectionFailed = true;\n         return false;\n     }"
      },
      {
        "sha": "1f35c29dcbea1becc21fddea20b7a96580389744",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -194,15 +194,15 @@ extern std::function<std::unique_ptr<Sock>(const CService&)> CreateSock;\n  * Try to connect to the specified service on the specified socket.\n  *\n  * @param addrConnect The service to which to connect.\n- * @param hSocket The socket on which to connect.\n+ * @param sock The socket on which to connect.\n  * @param nTimeout Wait this many milliseconds for the connection to be\n  *                 established.\n  * @param manual_connection Whether or not the connection was manually requested\n  *                          (e.g. through the addnode RPC)\n  *\n  * @returns Whether or not a connection was successfully made.\n  */\n-bool ConnectSocketDirectly(const CService &addrConnect, const SOCKET& hSocket, int nTimeout, bool manual_connection);\n+bool ConnectSocketDirectly(const CService &addrConnect, const Sock& sock, int nTimeout, bool manual_connection);\n \n /**\n  * Connect to a specified destination service through a SOCKS5 proxy by first"
      },
      {
        "sha": "23d4fa2aaef8fa4581d232e3d0272ff05a62edb1",
        "filename": "src/node/coin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/node/coin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/node/coin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coin.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -11,6 +11,7 @@\n void FindCoins(const NodeContext& node, std::map<COutPoint, Coin>& coins)\n {\n     assert(node.mempool);\n+    assert(node.chainman);\n     LOCK2(cs_main, node.mempool->cs);\n     assert(std::addressof(::ChainstateActive()) == std::addressof(node.chainman->ActiveChainstate()));\n     CCoinsViewCache& chain_view = node.chainman->ActiveChainstate().CoinsTip();"
      },
      {
        "sha": "975651dcc4c4971f7e0a98a49643b76e24ad942b",
        "filename": "src/node/coinstats.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/node/coinstats.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/node/coinstats.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coinstats.h?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -8,11 +8,11 @@\n \n #include <amount.h>\n #include <uint256.h>\n-#include <validation.h>\n \n #include <cstdint>\n #include <functional>\n \n+class BlockManager;\n class CCoinsView;\n \n enum class CoinStatsHashType {"
      },
      {
        "sha": "6d22a6b110cf8dfb9213561981a49f3f260a47c2",
        "filename": "src/node/context.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/node/context.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/node/context.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/context.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <node/context.h>\n \n+#include <addrman.h>\n #include <banman.h>\n #include <interfaces/chain.h>\n #include <net.h>"
      },
      {
        "sha": "2be9a584e663113c4094bbb3d5b41f9cc25d4c5d",
        "filename": "src/node/context.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/node/context.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/node/context.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/context.h?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -12,6 +12,7 @@\n \n class ArgsManager;\n class BanMan;\n+class CAddrMan;\n class CBlockPolicyEstimator;\n class CConnman;\n class CScheduler;\n@@ -35,6 +36,7 @@ class WalletClient;\n //! any member functions. It should just be a collection of references that can\n //! be used without pulling in unwanted dependencies or functionality.\n struct NodeContext {\n+    std::unique_ptr<CAddrMan> addrman;\n     std::unique_ptr<CConnman> connman;\n     std::unique_ptr<CTxMemPool> mempool;\n     std::unique_ptr<CBlockPolicyEstimator> fee_estimator;"
      },
      {
        "sha": "7ad02f81dccb0a2e131e123cee51d4482002f7ec",
        "filename": "src/node/interfaces.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 25,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/node/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/node/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/interfaces.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -38,7 +38,6 @@\n #include <uint256.h>\n #include <univalue.h>\n #include <util/check.h>\n-#include <util/ref.h>\n #include <util/system.h>\n #include <util/translation.h>\n #include <validation.h>\n@@ -49,6 +48,7 @@\n #include <config/bitcoin-config.h>\n #endif\n \n+#include <any>\n #include <memory>\n #include <optional>\n #include <utility>\n@@ -65,6 +65,8 @@ namespace node {\n namespace {\n class NodeImpl : public Node\n {\n+private:\n+    ChainstateManager& chainman() { return *Assert(m_context->chainman); }\n public:\n     explicit NodeImpl(NodeContext* context) { setContext(context); }\n     void initLogging() override { InitLogging(*Assert(m_context->args)); }\n@@ -183,21 +185,28 @@ class NodeImpl : public Node\n     int getNumBlocks() override\n     {\n         LOCK(::cs_main);\n-        assert(std::addressof(::ChainActive()) == std::addressof(m_context->chainman->ActiveChain()));\n-        return m_context->chainman->ActiveChain().Height();\n+        assert(std::addressof(::ChainActive()) == std::addressof(chainman().ActiveChain()));\n+        return chainman().ActiveChain().Height();\n     }\n     uint256 getBestBlockHash() override\n     {\n-        assert(std::addressof(::ChainActive()) == std::addressof(m_context->chainman->ActiveChain()));\n-        const CBlockIndex* tip = WITH_LOCK(::cs_main, return m_context->chainman->ActiveChain().Tip());\n+        const CBlockIndex* tip;\n+        {\n+            // TODO: Temporary scope to check correctness of refactored code.\n+            // Should be removed manually after merge of\n+            // https://github.com/bitcoin/bitcoin/pull/20158\n+            LOCK(cs_main);\n+            assert(std::addressof(::ChainActive()) == std::addressof(chainman().ActiveChain()));\n+            tip = chainman().ActiveChain().Tip();\n+        }\n         return tip ? tip->GetBlockHash() : Params().GenesisBlock().GetHash();\n     }\n     int64_t getLastBlockTime() override\n     {\n         LOCK(::cs_main);\n-        assert(std::addressof(::ChainActive()) == std::addressof(m_context->chainman->ActiveChain()));\n-        if (m_context->chainman->ActiveChain().Tip()) {\n-            return m_context->chainman->ActiveChain().Tip()->GetBlockTime();\n+        assert(std::addressof(::ChainActive()) == std::addressof(chainman().ActiveChain()));\n+        if (chainman().ActiveChain().Tip()) {\n+            return chainman().ActiveChain().Tip()->GetBlockTime();\n         }\n         return Params().GenesisBlock().GetBlockTime(); // Genesis block's time of current network\n     }\n@@ -206,14 +215,22 @@ class NodeImpl : public Node\n         const CBlockIndex* tip;\n         {\n             LOCK(::cs_main);\n-            assert(std::addressof(::ChainActive()) == std::addressof(m_context->chainman->ActiveChain()));\n-            tip = m_context->chainman->ActiveChain().Tip();\n+            assert(std::addressof(::ChainActive()) == std::addressof(chainman().ActiveChain()));\n+            tip = chainman().ActiveChain().Tip();\n         }\n         return GuessVerificationProgress(Params().TxData(), tip);\n     }\n     bool isInitialBlockDownload() override {\n-        assert(std::addressof(::ChainstateActive()) == std::addressof(m_context->chainman->ActiveChainstate()));\n-        return m_context->chainman->ActiveChainstate().IsInitialBlockDownload();\n+        const CChainState* active_chainstate;\n+        {\n+            // TODO: Temporary scope to check correctness of refactored code.\n+            // Should be removed manually after merge of\n+            // https://github.com/bitcoin/bitcoin/pull/20158\n+            LOCK(::cs_main);\n+            active_chainstate = &m_context->chainman->ActiveChainstate();\n+            assert(std::addressof(::ChainstateActive()) == std::addressof(*active_chainstate));\n+        }\n+        return active_chainstate->IsInitialBlockDownload();\n     }\n     bool getReindex() override { return ::fReindex; }\n     bool getImporting() override { return ::fImporting; }\n@@ -239,8 +256,8 @@ class NodeImpl : public Node\n     bool getUnspentOutput(const COutPoint& output, Coin& coin) override\n     {\n         LOCK(::cs_main);\n-        assert(std::addressof(::ChainstateActive()) == std::addressof(m_context->chainman->ActiveChainstate()));\n-        return m_context->chainman->ActiveChainstate().CoinsTip().GetCoin(output, coin);\n+        assert(std::addressof(::ChainstateActive()) == std::addressof(chainman().ActiveChainstate()));\n+        return chainman().ActiveChainstate().CoinsTip().GetCoin(output, coin);\n     }\n     WalletClient& walletClient() override\n     {\n@@ -298,13 +315,13 @@ class NodeImpl : public Node\n     {\n         m_context = context;\n         if (context) {\n-            m_context_ref.Set(*context);\n+            m_context_ref = context;\n         } else {\n-            m_context_ref.Clear();\n+            m_context_ref.reset();\n         }\n     }\n     NodeContext* m_context{nullptr};\n-    util::Ref m_context_ref;\n+    std::any m_context_ref;\n };\n \n bool FillBlock(const CBlockIndex* index, const FoundBlock& block, UniqueLock<RecursiveMutex>& lock, const CChain& active)\n@@ -414,6 +431,8 @@ class RpcHandlerImpl : public Handler\n \n class ChainImpl : public Chain\n {\n+private:\n+    ChainstateManager& chainman() { return *Assert(m_node.chainman); }\n public:\n     explicit ChainImpl(NodeContext& node) : m_node(node) {}\n     std::optional<int> getHeight() override\n@@ -450,8 +469,8 @@ class ChainImpl : public Chain\n     bool checkFinalTx(const CTransaction& tx) override\n     {\n         LOCK(cs_main);\n-        assert(std::addressof(::ChainActive()) == std::addressof(m_node.chainman->ActiveChain()));\n-        return CheckFinalTx(m_node.chainman->ActiveChain().Tip(), tx);\n+        assert(std::addressof(::ChainActive()) == std::addressof(chainman().ActiveChain()));\n+        return CheckFinalTx(chainman().ActiveChain().Tip(), tx);\n     }\n     std::optional<int> findLocatorFork(const CBlockLocator& locator) override\n     {\n@@ -516,8 +535,8 @@ class ChainImpl : public Chain\n     double guessVerificationProgress(const uint256& block_hash) override\n     {\n         LOCK(cs_main);\n-        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));\n-        return GuessVerificationProgress(Params().TxData(), m_node.chainman->m_blockman.LookupBlockIndex(block_hash));\n+        assert(std::addressof(g_chainman.m_blockman) == std::addressof(chainman().m_blockman));\n+        return GuessVerificationProgress(Params().TxData(), chainman().m_blockman.LookupBlockIndex(block_hash));\n     }\n     bool hasBlocks(const uint256& block_hash, int min_height, std::optional<int> max_height) override\n     {\n@@ -529,8 +548,8 @@ class ChainImpl : public Chain\n         // used to limit the range, and passing min_height that's too low or\n         // max_height that's too high will not crash or change the result.\n         LOCK(::cs_main);\n-        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));\n-        if (CBlockIndex* block = m_node.chainman->m_blockman.LookupBlockIndex(block_hash)) {\n+        assert(std::addressof(g_chainman.m_blockman) == std::addressof(chainman().m_blockman));\n+        if (CBlockIndex* block = chainman().m_blockman.LookupBlockIndex(block_hash)) {\n             if (max_height && block->nHeight >= *max_height) block = block->GetAncestor(*max_height);\n             for (; block->nStatus & BLOCK_HAVE_DATA; block = block->pprev) {\n                 // Check pprev to not segfault if min_height is too low\n@@ -621,8 +640,16 @@ class ChainImpl : public Chain\n     }\n     bool isReadyToBroadcast() override { return !::fImporting && !::fReindex && !isInitialBlockDownload(); }\n     bool isInitialBlockDownload() override {\n-        assert(std::addressof(::ChainstateActive()) == std::addressof(m_node.chainman->ActiveChainstate()));\n-        return m_node.chainman->ActiveChainstate().IsInitialBlockDownload();\n+        const CChainState* active_chainstate;\n+        {\n+            // TODO: Temporary scope to check correctness of refactored code.\n+            // Should be removed manually after merge of\n+            // https://github.com/bitcoin/bitcoin/pull/20158\n+            LOCK(::cs_main);\n+            active_chainstate = &chainman().ActiveChainstate();\n+            assert(std::addressof(::ChainstateActive()) == std::addressof(*active_chainstate));\n+        }\n+        return active_chainstate->IsInitialBlockDownload();\n     }\n     bool shutdownRequested() override { return ShutdownRequested(); }\n     int64_t getAdjustedTime() override { return GetAdjustedTime(); }"
      },
      {
        "sha": "691b2791d73e00bb2a4c6ca2e1bdbf3fd02cd0c9",
        "filename": "src/node/transaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/node/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/node/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -38,6 +38,7 @@ TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef t\n     bool callback_set = false;\n \n     { // cs_main scope\n+    assert(node.chainman);\n     LOCK(cs_main);\n     assert(std::addressof(::ChainstateActive()) == std::addressof(node.chainman->ActiveChainstate()));\n     // If the transaction is already confirmed in the chain, don't do anything"
      },
      {
        "sha": "58f6c14e7a1c9495d985986c854b6c45cc7e94da",
        "filename": "src/qt/paymentserver.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/qt/paymentserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/qt/paymentserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -235,9 +235,9 @@ void PaymentServer::handleURIOrFile(const QString& s)\n                 if (!IsValidDestinationString(recipient.address.toStdString())) {\n                     if (uri.hasQueryItem(\"r\")) {  // payment request\n                         Q_EMIT message(tr(\"URI handling\"),\n-                            tr(\"Cannot process payment request because BIP70 is not supported.\")+\n-                            tr(\"Due to widespread security flaws in BIP70 it's strongly recommended that any merchant instructions to switch wallets be ignored.\")+\n-                            tr(\"If you are receiving this error you should request the merchant provide a BIP21 compatible URI.\"),\n+                            tr(\"Cannot process payment request because BIP70 is not supported.\\n\"\n+                               \"Due to widespread security flaws in BIP70 it's strongly recommended that any merchant instructions to switch wallets be ignored.\\n\"\n+                               \"If you are receiving this error you should request the merchant provide a BIP21 compatible URI.\"),\n                             CClientUIInterface::ICON_WARNING);\n                     }\n                     Q_EMIT message(tr(\"URI handling\"), tr(\"Invalid payment address %1\").arg(recipient.address),\n@@ -258,9 +258,9 @@ void PaymentServer::handleURIOrFile(const QString& s)\n     if (QFile::exists(s)) // payment request file\n     {\n         Q_EMIT message(tr(\"Payment request file handling\"),\n-            tr(\"Cannot process payment request because BIP70 is not supported.\")+\n-            tr(\"Due to widespread security flaws in BIP70 it's strongly recommended that any merchant instructions to switch wallets be ignored.\")+\n-            tr(\"If you are receiving this error you should request the merchant provide a BIP21 compatible URI.\"),\n+            tr(\"Cannot process payment request because BIP70 is not supported.\\n\"\n+               \"Due to widespread security flaws in BIP70 it's strongly recommended that any merchant instructions to switch wallets be ignored.\\n\"\n+               \"If you are receiving this error you should request the merchant provide a BIP21 compatible URI.\"),\n             CClientUIInterface::ICON_WARNING);\n     }\n }"
      },
      {
        "sha": "1d0605c9030ef7e3c8d6795a83980ce56ce17878",
        "filename": "src/qt/platformstyle.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/qt/platformstyle.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/qt/platformstyle.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/platformstyle.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -18,7 +18,7 @@ static const struct {\n     /** Extra padding/spacing in transactionview */\n     const bool useExtraSpacing;\n } platform_styles[] = {\n-    {\"macosx\", false, false, true},\n+    {\"macosx\", false, true, true},\n     {\"windows\", true, false, false},\n     /* Other: linux, unix, ... */\n     {\"other\", true, true, false}"
      },
      {
        "sha": "34d055e5a5358aebfb34eaf8eedd06d01c4aecee",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -608,7 +608,6 @@ void RPCConsole::setClientModel(ClientModel *model, int bestblock_height, int64_\n         // set up peer table\n         ui->peerWidget->setModel(model->getPeerTableModel());\n         ui->peerWidget->verticalHeader()->hide();\n-        ui->peerWidget->setEditTriggers(QAbstractItemView::NoEditTriggers);\n         ui->peerWidget->setSelectionBehavior(QAbstractItemView::SelectRows);\n         ui->peerWidget->setSelectionMode(QAbstractItemView::ExtendedSelection);\n         ui->peerWidget->setContextMenuPolicy(Qt::CustomContextMenu);\n@@ -651,7 +650,6 @@ void RPCConsole::setClientModel(ClientModel *model, int bestblock_height, int64_\n         // set up ban table\n         ui->banlistWidget->setModel(model->getBanTableModel());\n         ui->banlistWidget->verticalHeader()->hide();\n-        ui->banlistWidget->setEditTriggers(QAbstractItemView::NoEditTriggers);\n         ui->banlistWidget->setSelectionBehavior(QAbstractItemView::SelectRows);\n         ui->banlistWidget->setSelectionMode(QAbstractItemView::SingleSelection);\n         ui->banlistWidget->setContextMenuPolicy(Qt::CustomContextMenu);"
      },
      {
        "sha": "c76dee5091b66529232e5c205f57cf44ae83973a",
        "filename": "src/qt/test/compattests.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 25,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/test/compattests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/test/compattests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/compattests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1,25 +0,0 @@\n-// Copyright (c) 2016-2019 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#if defined(HAVE_CONFIG_H)\n-#include <config/bitcoin-config.h>\n-#endif\n-\n-#include <qt/test/compattests.h>\n-\n-#include <compat/byteswap.h>\n-\n-void CompatTests::bswapTests()\n-{\n-\t// Sibling in bitcoin/src/test/bswap_tests.cpp\n-\tuint16_t u1 = 0x1234;\n-\tuint32_t u2 = 0x56789abc;\n-\tuint64_t u3 = 0xdef0123456789abc;\n-\tuint16_t e1 = 0x3412;\n-\tuint32_t e2 = 0xbc9a7856;\n-\tuint64_t e3 = 0xbc9a78563412f0de;\n-\tQVERIFY(bswap_16(u1) == e1);\n-\tQVERIFY(bswap_32(u2) == e2);\n-\tQVERIFY(bswap_64(u3) == e3);\n-}"
      },
      {
        "sha": "1af97696b2fea24965d5414994661435c3e42bc8",
        "filename": "src/qt/test/compattests.h",
        "status": "removed",
        "additions": 0,
        "deletions": 19,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/test/compattests.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/qt/test/compattests.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/compattests.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1,19 +0,0 @@\n-// Copyright (c) 2009-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_QT_TEST_COMPATTESTS_H\n-#define BITCOIN_QT_TEST_COMPATTESTS_H\n-\n-#include <QObject>\n-#include <QTest>\n-\n-class CompatTests : public QObject\n-{\n-    Q_OBJECT\n-\n-private Q_SLOTS:\n-    void bswapTests();\n-};\n-\n-#endif // BITCOIN_QT_TEST_COMPATTESTS_H"
      },
      {
        "sha": "eb86f027ef942fbf932b41de96b0cd28f1257ccb",
        "filename": "src/qt/test/test_main.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/qt/test/test_main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/qt/test/test_main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/test_main.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -11,7 +11,6 @@\n #include <qt/test/apptests.h>\n #include <qt/test/rpcnestedtests.h>\n #include <qt/test/uritests.h>\n-#include <qt/test/compattests.h>\n #include <test/util/setup_common.h>\n \n #ifdef ENABLE_WALLET\n@@ -92,10 +91,6 @@ int main(int argc, char* argv[])\n     if (QTest::qExec(&test3) != 0) {\n         fInvalid = true;\n     }\n-    CompatTests test4;\n-    if (QTest::qExec(&test4) != 0) {\n-        fInvalid = true;\n-    }\n #ifdef ENABLE_WALLET\n     WalletTests test5(app.node());\n     if (QTest::qExec(&test5) != 0) {"
      },
      {
        "sha": "fa2a3a0607f108c3821e29a9fcc18957cf5bd0c6",
        "filename": "src/randomenv.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/randomenv.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/randomenv.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/randomenv.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -38,7 +38,7 @@\n #include <sys/utsname.h>\n #include <unistd.h>\n #endif\n-#if HAVE_DECL_GETIFADDRS\n+#if HAVE_DECL_GETIFADDRS && HAVE_DECL_FREEIFADDRS\n #include <ifaddrs.h>\n #endif\n #if HAVE_SYSCTL\n@@ -361,7 +361,7 @@ void RandAddStaticEnv(CSHA512& hasher)\n         hasher.Write((const unsigned char*)hname, strnlen(hname, 256));\n     }\n \n-#if HAVE_DECL_GETIFADDRS\n+#if HAVE_DECL_GETIFADDRS && HAVE_DECL_FREEIFADDRS\n     // Network interfaces\n     struct ifaddrs *ifad = NULL;\n     getifaddrs(&ifad);"
      },
      {
        "sha": "aa97470ca72cb7d01463f3c478fe5aeb2c0e1f45",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 20,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -18,10 +18,12 @@\n #include <sync.h>\n #include <txmempool.h>\n #include <util/check.h>\n-#include <util/ref.h>\n+#include <util/system.h>\n #include <validation.h>\n #include <version.h>\n \n+#include <any>\n+\n #include <boost/algorithm/string.hpp>\n \n #include <univalue.h>\n@@ -73,18 +75,18 @@ static bool RESTERR(HTTPRequest* req, enum HTTPStatusCode status, std::string me\n  *                  context is not found.\n  * @returns         Pointer to the node context or nullptr if not found.\n  */\n-static NodeContext* GetNodeContext(const util::Ref& context, HTTPRequest* req)\n+static NodeContext* GetNodeContext(const std::any& context, HTTPRequest* req)\n {\n-    NodeContext* node = context.Has<NodeContext>() ? &context.Get<NodeContext>() : nullptr;\n-    if (!node) {\n+    auto node_context = util::AnyPtr<NodeContext>(context);\n+    if (!node_context) {\n         RESTERR(req, HTTP_INTERNAL_SERVER_ERROR,\n                 strprintf(\"%s:%d (%s)\\n\"\n                           \"Internal bug detected: Node context not found!\\n\"\n                           \"You may report this issue here: %s\\n\",\n                           __FILE__, __LINE__, __func__, PACKAGE_BUGREPORT));\n         return nullptr;\n     }\n-    return node;\n+    return node_context;\n }\n \n /**\n@@ -94,14 +96,14 @@ static NodeContext* GetNodeContext(const util::Ref& context, HTTPRequest* req)\n  *                 context mempool is not found.\n  * @returns        Pointer to the mempool or nullptr if no mempool found.\n  */\n-static CTxMemPool* GetMemPool(const util::Ref& context, HTTPRequest* req)\n+static CTxMemPool* GetMemPool(const std::any& context, HTTPRequest* req)\n {\n-    NodeContext* node = context.Has<NodeContext>() ? &context.Get<NodeContext>() : nullptr;\n-    if (!node || !node->mempool) {\n+    auto node_context = util::AnyPtr<NodeContext>(context);\n+    if (!node_context || !node_context->mempool) {\n         RESTERR(req, HTTP_NOT_FOUND, \"Mempool disabled or instance not found\");\n         return nullptr;\n     }\n-    return node->mempool.get();\n+    return node_context->mempool.get();\n }\n \n static RetFormat ParseDataFormat(std::string& param, const std::string& strReq)\n@@ -151,7 +153,7 @@ static bool CheckWarmup(HTTPRequest* req)\n     return true;\n }\n \n-static bool rest_headers(const util::Ref& context,\n+static bool rest_headers(const std::any& context,\n                          HTTPRequest* req,\n                          const std::string& strURIPart)\n {\n@@ -293,20 +295,20 @@ static bool rest_block(HTTPRequest* req,\n     }\n }\n \n-static bool rest_block_extended(const util::Ref& context, HTTPRequest* req, const std::string& strURIPart)\n+static bool rest_block_extended(const std::any& context, HTTPRequest* req, const std::string& strURIPart)\n {\n     return rest_block(req, strURIPart, true);\n }\n \n-static bool rest_block_notxdetails(const util::Ref& context, HTTPRequest* req, const std::string& strURIPart)\n+static bool rest_block_notxdetails(const std::any& context, HTTPRequest* req, const std::string& strURIPart)\n {\n     return rest_block(req, strURIPart, false);\n }\n \n // A bit of a hack - dependency on a function defined in rpc/blockchain.cpp\n RPCHelpMan getblockchaininfo();\n \n-static bool rest_chaininfo(const util::Ref& context, HTTPRequest* req, const std::string& strURIPart)\n+static bool rest_chaininfo(const std::any& context, HTTPRequest* req, const std::string& strURIPart)\n {\n     if (!CheckWarmup(req))\n         return false;\n@@ -329,7 +331,7 @@ static bool rest_chaininfo(const util::Ref& context, HTTPRequest* req, const std\n     }\n }\n \n-static bool rest_mempool_info(const util::Ref& context, HTTPRequest* req, const std::string& strURIPart)\n+static bool rest_mempool_info(const std::any& context, HTTPRequest* req, const std::string& strURIPart)\n {\n     if (!CheckWarmup(req))\n         return false;\n@@ -353,7 +355,7 @@ static bool rest_mempool_info(const util::Ref& context, HTTPRequest* req, const\n     }\n }\n \n-static bool rest_mempool_contents(const util::Ref& context, HTTPRequest* req, const std::string& strURIPart)\n+static bool rest_mempool_contents(const std::any& context, HTTPRequest* req, const std::string& strURIPart)\n {\n     if (!CheckWarmup(req)) return false;\n     const CTxMemPool* mempool = GetMemPool(context, req);\n@@ -376,7 +378,7 @@ static bool rest_mempool_contents(const util::Ref& context, HTTPRequest* req, co\n     }\n }\n \n-static bool rest_tx(const util::Ref& context, HTTPRequest* req, const std::string& strURIPart)\n+static bool rest_tx(const std::any& context, HTTPRequest* req, const std::string& strURIPart)\n {\n     if (!CheckWarmup(req))\n         return false;\n@@ -435,7 +437,7 @@ static bool rest_tx(const util::Ref& context, HTTPRequest* req, const std::strin\n     }\n }\n \n-static bool rest_getutxos(const util::Ref& context, HTTPRequest* req, const std::string& strURIPart)\n+static bool rest_getutxos(const std::any& context, HTTPRequest* req, const std::string& strURIPart)\n {\n     if (!CheckWarmup(req))\n         return false;\n@@ -621,7 +623,7 @@ static bool rest_getutxos(const util::Ref& context, HTTPRequest* req, const std:\n     }\n }\n \n-static bool rest_blockhash_by_height(const util::Ref& context, HTTPRequest* req,\n+static bool rest_blockhash_by_height(const std::any& context, HTTPRequest* req,\n                        const std::string& str_uri_part)\n {\n     if (!CheckWarmup(req)) return false;\n@@ -669,7 +671,7 @@ static bool rest_blockhash_by_height(const util::Ref& context, HTTPRequest* req,\n \n static const struct {\n     const char* prefix;\n-    bool (*handler)(const util::Ref& context, HTTPRequest* req, const std::string& strReq);\n+    bool (*handler)(const std::any& context, HTTPRequest* req, const std::string& strReq);\n } uri_prefixes[] = {\n       {\"/rest/tx/\", rest_tx},\n       {\"/rest/block/notxdetails/\", rest_block_notxdetails},\n@@ -682,7 +684,7 @@ static const struct {\n       {\"/rest/blockhashbyheight/\", rest_blockhash_by_height},\n };\n \n-void StartREST(const util::Ref& context)\n+void StartREST(const std::any& context)\n {\n     for (const auto& up : uri_prefixes) {\n         auto handler = [&context, up](HTTPRequest* req, const std::string& prefix) { return up.handler(context, req, prefix); };"
      },
      {
        "sha": "e1501d7254b82aa9bd826f7b711eed96578f1171",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 14,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -30,7 +30,6 @@\n #include <txdb.h>\n #include <txmempool.h>\n #include <undo.h>\n-#include <util/ref.h>\n #include <util/strencodings.h>\n #include <util/system.h>\n #include <util/translation.h>\n@@ -56,15 +55,16 @@ static Mutex cs_blockchange;\n static std::condition_variable cond_blockchange;\n static CUpdatedBlock latestblock GUARDED_BY(cs_blockchange);\n \n-NodeContext& EnsureNodeContext(const util::Ref& context)\n+NodeContext& EnsureNodeContext(const std::any& context)\n {\n-    if (!context.Has<NodeContext>()) {\n+    auto node_context = util::AnyPtr<NodeContext>(context);\n+    if (!node_context) {\n         throw JSONRPCError(RPC_INTERNAL_ERROR, \"Node context not found\");\n     }\n-    return context.Get<NodeContext>();\n+    return *node_context;\n }\n \n-CTxMemPool& EnsureMemPool(const util::Ref& context)\n+CTxMemPool& EnsureMemPool(const std::any& context)\n {\n     const NodeContext& node = EnsureNodeContext(context);\n     if (!node.mempool) {\n@@ -73,7 +73,7 @@ CTxMemPool& EnsureMemPool(const util::Ref& context)\n     return *node.mempool;\n }\n \n-ChainstateManager& EnsureChainman(const util::Ref& context)\n+ChainstateManager& EnsureChainman(const std::any& context)\n {\n     const NodeContext& node = EnsureNodeContext(context);\n     if (!node.chainman) {\n@@ -82,7 +82,7 @@ ChainstateManager& EnsureChainman(const util::Ref& context)\n     return *node.chainman;\n }\n \n-CBlockPolicyEstimator& EnsureFeeEstimator(const util::Ref& context)\n+CBlockPolicyEstimator& EnsureFeeEstimator(const std::any& context)\n {\n     NodeContext& node = EnsureNodeContext(context);\n     if (!node.fee_estimator) {\n@@ -1113,11 +1113,13 @@ static RPCHelpMan gettxout()\n                 {RPCResult::Type::NUM, \"confirmations\", \"The number of confirmations\"},\n                 {RPCResult::Type::STR_AMOUNT, \"value\", \"The transaction value in \" + CURRENCY_UNIT},\n                 {RPCResult::Type::OBJ, \"scriptPubKey\", \"\", {\n-                    {RPCResult::Type::STR_HEX, \"asm\", \"\"},\n+                    {RPCResult::Type::STR, \"asm\", \"\"},\n                     {RPCResult::Type::STR_HEX, \"hex\", \"\"},\n-                    {RPCResult::Type::NUM, \"reqSigs\", \"Number of required signatures\"},\n-                    {RPCResult::Type::STR_HEX, \"type\", \"The type, eg pubkeyhash\"},\n-                    {RPCResult::Type::ARR, \"addresses\", \"array of bitcoin addresses\", {{RPCResult::Type::STR, \"address\", \"bitcoin address\"}}},\n+                    {RPCResult::Type::NUM, \"reqSigs\", /* optional */ true, \"(DEPRECATED, returned only if config option -deprecatedrpc=addresses is passed) Number of required signatures\"},\n+                    {RPCResult::Type::STR, \"type\", \"The type, eg pubkeyhash\"},\n+                    {RPCResult::Type::STR, \"address\", /* optional */ true, \"bitcoin address (only if a well-defined address exists)\"},\n+                    {RPCResult::Type::ARR, \"addresses\", /* optional */ true, \"(DEPRECATED, returned only if config option -deprecatedrpc=addresses is passed) Array of bitcoin addresses\",\n+                        {{RPCResult::Type::STR, \"address\", \"bitcoin address\"}}},\n                 }},\n                 {RPCResult::Type::BOOL, \"coinbase\", \"Coinbase or not\"},\n             }},\n@@ -1667,9 +1669,9 @@ static RPCHelpMan getchaintxstats()\n                         {RPCResult::Type::STR_HEX, \"window_final_block_hash\", \"The hash of the final block in the window\"},\n                         {RPCResult::Type::NUM, \"window_final_block_height\", \"The height of the final block in the window.\"},\n                         {RPCResult::Type::NUM, \"window_block_count\", \"Size of the window in number of blocks\"},\n-                        {RPCResult::Type::NUM, \"window_tx_count\", \"The number of transactions in the window. Only returned if \\\"window_block_count\\\" is > 0\"},\n-                        {RPCResult::Type::NUM, \"window_interval\", \"The elapsed time in the window in seconds. Only returned if \\\"window_block_count\\\" is > 0\"},\n-                        {RPCResult::Type::NUM, \"txrate\", \"The average rate of transactions per second in the window. Only returned if \\\"window_interval\\\" is > 0\"},\n+                        {RPCResult::Type::NUM, \"window_tx_count\", /* optional */ true, \"The number of transactions in the window. Only returned if \\\"window_block_count\\\" is > 0\"},\n+                        {RPCResult::Type::NUM, \"window_interval\", /* optional */ true, \"The elapsed time in the window in seconds. Only returned if \\\"window_block_count\\\" is > 0\"},\n+                        {RPCResult::Type::NUM, \"txrate\", /* optional */ true, \"The average rate of transactions per second in the window. Only returned if \\\"window_interval\\\" is > 0\"},\n                     }},\n                 RPCExamples{\n                     HelpExampleCli(\"getchaintxstats\", \"\")\n@@ -1775,6 +1777,16 @@ void CalculatePercentilesByWeight(CAmount result[NUM_GETBLOCKSTATS_PERCENTILES],\n     }\n }\n \n+void ScriptPubKeyToUniv(const CScript& scriptPubKey, UniValue& out, bool fIncludeHex)\n+{\n+    ScriptPubKeyToUniv(scriptPubKey, out, fIncludeHex, IsDeprecatedRPCEnabled(\"addresses\"));\n+}\n+\n+void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry, bool include_hex, int serialize_flags, const CTxUndo* txundo)\n+{\n+    TxToUniv(tx, hashBlock, IsDeprecatedRPCEnabled(\"addresses\"), entry, include_hex, serialize_flags, txundo);\n+}\n+\n template<typename T>\n static inline bool SetHasKeys(const std::set<T>& set) {return false;}\n template<typename T, typename Tk, typename... Args>"
      },
      {
        "sha": "cd04c9a10f71c23e134a28b397ef0b00be7d5286",
        "filename": "src/rpc/blockchain.h",
        "status": "modified",
        "additions": 9,
        "deletions": 7,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/rpc/blockchain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/rpc/blockchain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.h?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -6,9 +6,11 @@\n #define BITCOIN_RPC_BLOCKCHAIN_H\n \n #include <amount.h>\n+#include <core_io.h>\n #include <streams.h>\n #include <sync.h>\n \n+#include <any>\n #include <stdint.h>\n #include <vector>\n \n@@ -22,9 +24,6 @@ class CTxMemPool;\n class ChainstateManager;\n class UniValue;\n struct NodeContext;\n-namespace util {\n-class Ref;\n-} // namespace util\n \n static constexpr int NUM_GETBLOCKSTATS_PERCENTILES = 5;\n \n@@ -54,10 +53,13 @@ UniValue blockheaderToJSON(const CBlockIndex* tip, const CBlockIndex* blockindex\n /** Used by getblockstats to get feerates at different percentiles by weight  */\n void CalculatePercentilesByWeight(CAmount result[NUM_GETBLOCKSTATS_PERCENTILES], std::vector<std::pair<CAmount, int64_t>>& scores, int64_t total_weight);\n \n-NodeContext& EnsureNodeContext(const util::Ref& context);\n-CTxMemPool& EnsureMemPool(const util::Ref& context);\n-ChainstateManager& EnsureChainman(const util::Ref& context);\n-CBlockPolicyEstimator& EnsureFeeEstimator(const util::Ref& context);\n+void ScriptPubKeyToUniv(const CScript& scriptPubKey, UniValue& out, bool fIncludeHex);\n+void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry, bool include_hex = true, int serialize_flags = 0, const CTxUndo* txundo = nullptr);\n+\n+NodeContext& EnsureNodeContext(const std::any& context);\n+CTxMemPool& EnsureMemPool(const std::any& context);\n+ChainstateManager& EnsureChainman(const std::any& context);\n+CBlockPolicyEstimator& EnsureFeeEstimator(const std::any& context);\n \n /**\n  * Helper to create UTXO snapshots given a chainstate and a file handle."
      },
      {
        "sha": "72ad0df19962db9b6877d1d547c5a371675a6a25",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -150,7 +150,7 @@ static UniValue generateBlocks(ChainstateManager& chainman, const CTxMemPool& me\n     UniValue blockHashes(UniValue::VARR);\n     while (nHeight < nHeightEnd && !ShutdownRequested())\n     {\n-        std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(mempool, Params()).CreateNewBlock(::ChainstateActive(), coinbase_script));\n+        std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(chainman.ActiveChainstate(), mempool, Params()).CreateNewBlock(coinbase_script));\n         if (!pblocktemplate.get())\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Couldn't create new block\");\n         CBlock *pblock = &pblocktemplate->block;\n@@ -358,7 +358,7 @@ static RPCHelpMan generateblock()\n         LOCK(cs_main);\n \n         CTxMemPool empty_mempool;\n-        std::unique_ptr<CBlockTemplate> blocktemplate(BlockAssembler(empty_mempool, chainparams).CreateNewBlock(::ChainstateActive(), coinbase_script));\n+        std::unique_ptr<CBlockTemplate> blocktemplate(BlockAssembler(::ChainstateActive(), empty_mempool, chainparams).CreateNewBlock(coinbase_script));\n         if (!blocktemplate) {\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Couldn't create new block\");\n         }\n@@ -748,7 +748,7 @@ static RPCHelpMan getblocktemplate()\n \n         // Create new block\n         CScript scriptDummy = CScript() << OP_TRUE;\n-        pblocktemplate = BlockAssembler(mempool, Params()).CreateNewBlock(::ChainstateActive(), scriptDummy);\n+        pblocktemplate = BlockAssembler(::ChainstateActive(), mempool, Params()).CreateNewBlock(scriptDummy);\n         if (!pblocktemplate)\n             throw JSONRPCError(RPC_OUT_OF_MEMORY, \"Out of memory\");\n "
      },
      {
        "sha": "1df5c5171801bf9c019e8f592ca29fb6715b55a9",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -17,7 +17,6 @@\n #include <script/descriptor.h>\n #include <util/check.h>\n #include <util/message.h> // For MessageSign(), MessageVerify()\n-#include <util/ref.h>\n #include <util/strencodings.h>\n #include <util/system.h>\n \n@@ -391,8 +390,9 @@ static RPCHelpMan setmocktime()\n         throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Mocktime can not be negative: %s.\", time));\n     }\n     SetMockTime(time);\n-    if (request.context.Has<NodeContext>()) {\n-        for (const auto& chain_client : request.context.Get<NodeContext>().chain_clients) {\n+    auto node_context = util::AnyPtr<NodeContext>(request.context);\n+    if (node_context) {\n+        for (const auto& chain_client : node_context->chain_clients) {\n             chain_client->setMockTime(time);\n         }\n     }\n@@ -424,11 +424,11 @@ static RPCHelpMan mockscheduler()\n         throw std::runtime_error(\"delta_time must be between 1 and 3600 seconds (1 hr)\");\n     }\n \n+    auto node_context = util::AnyPtr<NodeContext>(request.context);\n     // protect against null pointer dereference\n-    CHECK_NONFATAL(request.context.Has<NodeContext>());\n-    NodeContext& node = request.context.Get<NodeContext>();\n-    CHECK_NONFATAL(node.scheduler);\n-    node.scheduler->MockForward(std::chrono::seconds(delta_seconds));\n+    CHECK_NONFATAL(node_context);\n+    CHECK_NONFATAL(node_context->scheduler);\n+    node_context->scheduler->MockForward(std::chrono::seconds(delta_seconds));\n \n     return NullUniValue;\n },"
      },
      {
        "sha": "96533a50c8429abf2b67b08931b3770198d2b624",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -907,8 +907,8 @@ static RPCHelpMan addpeeraddress()\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n     NodeContext& node = EnsureNodeContext(request.context);\n-    if (!node.connman) {\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n+    if (!node.addrman) {\n+        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Address manager functionality missing or disabled\");\n     }\n \n     UniValue obj(UniValue::VOBJ);\n@@ -925,7 +925,7 @@ static RPCHelpMan addpeeraddress()\n     address.nTime = GetAdjustedTime();\n     // The source address is set equal to the address. This is equivalent to the peer\n     // announcing itself.\n-    if (!node.connman->AddNewAddresses({address}, address)) {\n+    if (!node.addrman->Add(address, address)) {\n         obj.pushKV(\"success\", false);\n         return obj;\n     }"
      },
      {
        "sha": "7932bd2915c11432e4a56957ac2d9d203c3a4d66",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 9,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -35,7 +35,6 @@\n #include <validation.h>\n #include <validationinterface.h>\n \n-\n #include <numeric>\n #include <stdint.h>\n \n@@ -132,9 +131,10 @@ static RPCHelpMan getrawtransaction()\n                                      {\n                                          {RPCResult::Type::STR, \"asm\", \"the asm\"},\n                                          {RPCResult::Type::STR, \"hex\", \"the hex\"},\n-                                         {RPCResult::Type::NUM, \"reqSigs\", \"The required sigs\"},\n+                                         {RPCResult::Type::NUM, \"reqSigs\", /* optional */ true, \"(DEPRECATED, returned only if config option -deprecatedrpc=addresses is passed) Number of required signatures\"},\n                                          {RPCResult::Type::STR, \"type\", \"The type, eg 'pubkeyhash'\"},\n-                                         {RPCResult::Type::ARR, \"addresses\", \"\",\n+                                         {RPCResult::Type::STR, \"address\", /* optional */ true, \"bitcoin address (only if a well-defined address exists)\"},\n+                                         {RPCResult::Type::ARR, \"addresses\", /* optional */ true, \"(DEPRECATED, returned only if config option -deprecatedrpc=addresses is passed) Array of bitcoin addresses\",\n                                          {\n                                              {RPCResult::Type::STR, \"address\", \"bitcoin address\"},\n                                          }},\n@@ -490,9 +490,10 @@ static RPCHelpMan decoderawtransaction()\n                                 {\n                                     {RPCResult::Type::STR, \"asm\", \"the asm\"},\n                                     {RPCResult::Type::STR_HEX, \"hex\", \"the hex\"},\n-                                    {RPCResult::Type::NUM, \"reqSigs\", \"The required sigs\"},\n+                                    {RPCResult::Type::NUM, \"reqSigs\", /* optional */ true, \"(DEPRECATED, returned only if config option -deprecatedrpc=addresses is passed) Number of required signatures\"},\n                                     {RPCResult::Type::STR, \"type\", \"The type, eg 'pubkeyhash'\"},\n-                                    {RPCResult::Type::ARR, \"addresses\", \"\",\n+                                    {RPCResult::Type::STR, \"address\", /* optional */ true, \"bitcoin address (only if a well-defined address exists)\"},\n+                                    {RPCResult::Type::ARR, \"addresses\", /* optional */ true, \"(DEPRECATED, returned only if config option -deprecatedrpc=addresses is passed) Array of bitcoin addresses\",\n                                     {\n                                         {RPCResult::Type::STR, \"address\", \"bitcoin address\"},\n                                     }},\n@@ -548,8 +549,9 @@ static RPCHelpMan decodescript()\n                     {\n                         {RPCResult::Type::STR, \"asm\", \"Script public key\"},\n                         {RPCResult::Type::STR, \"type\", \"The output type (e.g. \"+GetAllOutputTypes()+\")\"},\n-                        {RPCResult::Type::NUM, \"reqSigs\", \"The required signatures\"},\n-                        {RPCResult::Type::ARR, \"addresses\", \"\",\n+                        {RPCResult::Type::STR, \"address\", /* optional */ true, \"bitcoin address (only if a well-defined address exists)\"},\n+                        {RPCResult::Type::NUM, \"reqSigs\", /* optional */ true, \"(DEPRECATED, returned only if config option -deprecatedrpc=addresses is passed) Number of required signatures\"},\n+                        {RPCResult::Type::ARR, \"addresses\", /* optional */ true, \"(DEPRECATED, returned only if config option -deprecatedrpc=addresses is passed) Array of bitcoin addresses\",\n                         {\n                             {RPCResult::Type::STR, \"address\", \"bitcoin address\"},\n                         }},\n@@ -559,8 +561,9 @@ static RPCHelpMan decodescript()\n                             {RPCResult::Type::STR, \"asm\", \"String representation of the script public key\"},\n                             {RPCResult::Type::STR_HEX, \"hex\", \"Hex string of the script public key\"},\n                             {RPCResult::Type::STR, \"type\", \"The type of the script public key (e.g. witness_v0_keyhash or witness_v0_scripthash)\"},\n-                            {RPCResult::Type::NUM, \"reqSigs\", \"The required signatures (always 1)\"},\n-                            {RPCResult::Type::ARR, \"addresses\", \"(always length 1)\",\n+                            {RPCResult::Type::STR, \"address\", /* optional */ true, \"bitcoin address (only if a well-defined address exists)\"},\n+                            {RPCResult::Type::NUM, \"reqSigs\", /* optional */ true, \"(DEPRECATED, returned only if config option -deprecatedrpc=addresses is passed) Number of required signatures\"},\n+                            {RPCResult::Type::ARR, \"addresses\", /* optional */ true, \"(DEPRECATED, returned only if config option -deprecatedrpc=addresses is passed) Array of bitcoin addresses\",\n                             {\n                                 {RPCResult::Type::STR, \"address\", \"segwit address\"},\n                             }},"
      },
      {
        "sha": "e1569673f6909959bfd1bcc06c82dfc13b9fdcda",
        "filename": "src/rpc/request.h",
        "status": "modified",
        "additions": 4,
        "deletions": 7,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/rpc/request.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/rpc/request.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/request.h?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -6,14 +6,11 @@\n #ifndef BITCOIN_RPC_REQUEST_H\n #define BITCOIN_RPC_REQUEST_H\n \n+#include <any>\n #include <string>\n \n #include <univalue.h>\n \n-namespace util {\n-class Ref;\n-} // namespace util\n-\n UniValue JSONRPCRequestObj(const std::string& strMethod, const UniValue& params, const UniValue& id);\n UniValue JSONRPCReplyObj(const UniValue& result, const UniValue& error, const UniValue& id);\n std::string JSONRPCReply(const UniValue& result, const UniValue& error, const UniValue& id);\n@@ -38,14 +35,14 @@ class JSONRPCRequest\n     std::string URI;\n     std::string authUser;\n     std::string peerAddr;\n-    const util::Ref& context;\n+    const std::any& context;\n \n-    explicit JSONRPCRequest(const util::Ref& context) : id(NullUniValue), params(NullUniValue), context(context) {}\n+    explicit JSONRPCRequest(const std::any& context) : id(NullUniValue), params(NullUniValue), context(context) {}\n \n     //! Initializes request information from another request object and the\n     //! given context. The implementation should be updated if any members are\n     //! added or removed above.\n-    JSONRPCRequest(const JSONRPCRequest& other, const util::Ref& context)\n+    JSONRPCRequest(const JSONRPCRequest& other, const std::any& context)\n         : id(other.id), strMethod(other.strMethod), params(other.params), mode(other.mode), URI(other.URI),\n           authUser(other.authUser), peerAddr(other.peerAddr), context(context)\n     {"
      },
      {
        "sha": "2f05c8842f4166afc04a4227c36bd6f40a49f319",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -87,7 +87,7 @@ std::string CRPCTable::help(const std::string& strCommand, const JSONRPCRequest&\n         vCommands.push_back(make_pair(entry.second.front()->category + entry.first, entry.second.front()));\n     sort(vCommands.begin(), vCommands.end());\n \n-    JSONRPCRequest jreq(helpreq);\n+    JSONRPCRequest jreq = helpreq;\n     jreq.mode = JSONRPCRequest::GET_HELP;\n     jreq.params = UniValue();\n \n@@ -494,7 +494,7 @@ std::vector<std::string> CRPCTable::listCommands() const\n \n UniValue CRPCTable::dumpArgMap(const JSONRPCRequest& args_request) const\n {\n-    JSONRPCRequest request(args_request);\n+    JSONRPCRequest request = args_request;\n     request.mode = JSONRPCRequest::GET_ARGS;\n \n     UniValue ret{UniValue::VARR};"
      },
      {
        "sha": "700155c8d46395d030fd4aba4227d12403da90a7",
        "filename": "src/script/standard.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/script/standard.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/script/standard.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -220,14 +220,14 @@ bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n         return true;\n     }\n     case TxoutType::MULTISIG:\n-        // Multisig txns have more than one address...\n     case TxoutType::NULL_DATA:\n     case TxoutType::NONSTANDARD:\n         return false;\n     } // no default case, so the compiler can warn about missing cases\n     assert(false);\n }\n \n+// TODO: from v23 (\"addresses\" and \"reqSigs\" deprecated) \"ExtractDestinations\" should be removed\n bool ExtractDestinations(const CScript& scriptPubKey, TxoutType& typeRet, std::vector<CTxDestination>& addressRet, int& nRequiredRet)\n {\n     addressRet.clear();"
      },
      {
        "sha": "f2bf4a8af35019600a1d3d037ab20de603d3a96a",
        "filename": "src/script/standard.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/script/standard.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/script/standard.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.h?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -247,6 +247,8 @@ bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n  * Note: this function confuses destinations (a subset of CScripts that are\n  * encodable as an address) with key identifiers (of keys involved in a\n  * CScript), and its use should be phased out.\n+ *\n+ * TODO: from v23 (\"addresses\" and \"reqSigs\" deprecated) \"ExtractDestinations\" should be removed\n  */\n bool ExtractDestinations(const CScript& scriptPubKey, TxoutType& typeRet, std::vector<CTxDestination>& addressRet, int& nRequiredRet);\n "
      },
      {
        "sha": "9903ba75cb114660f8e06185acb6f2f4e563b01b",
        "filename": "src/test/blockfilter_index_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/blockfilter_index_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/blockfilter_index_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/blockfilter_index_tests.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -62,7 +62,7 @@ CBlock BuildChainTestingSetup::CreateBlock(const CBlockIndex* prev,\n     const CScript& scriptPubKey)\n {\n     const CChainParams& chainparams = Params();\n-    std::unique_ptr<CBlockTemplate> pblocktemplate = BlockAssembler(*m_node.mempool, chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);\n+    std::unique_ptr<CBlockTemplate> pblocktemplate = BlockAssembler(::ChainstateActive(), *m_node.mempool, chainparams).CreateNewBlock(scriptPubKey);\n     CBlock& block = pblocktemplate->block;\n     block.hashPrevBlock = prev->GetBlockHash();\n     block.nTime = prev->nTime + 1;"
      },
      {
        "sha": "2dbca4e8b69fc87234b17aa3dd6edec13fede52d",
        "filename": "src/test/bswap_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/bswap_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/bswap_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bswap_tests.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -11,7 +11,6 @@ BOOST_FIXTURE_TEST_SUITE(bswap_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(bswap_tests)\n {\n-    // Sibling in bitcoin/src/qt/test/compattests.cpp\n     uint16_t u1 = 0x1234;\n     uint32_t u2 = 0x56789abc;\n     uint64_t u3 = 0xdef0123456789abc;"
      },
      {
        "sha": "7557d4618a5b150cc54f7954ae258c20b70d580b",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 21,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -67,9 +67,9 @@ BOOST_FIXTURE_TEST_SUITE(denialofservice_tests, TestingSetup)\n BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n {\n     const CChainParams& chainparams = Params();\n-    auto connman = std::make_unique<CConnman>(0x1337, 0x1337);\n-    auto peerLogic = PeerManager::make(chainparams, *connman, nullptr, *m_node.scheduler,\n-                                       *m_node.chainman, *m_node.mempool, false);\n+    auto connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman);\n+    auto peerLogic = PeerManager::make(chainparams, *connman, *m_node.addrman, nullptr,\n+                                       *m_node.scheduler, *m_node.chainman, *m_node.mempool, false);\n \n     // Mock an outbound peer\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n@@ -117,8 +117,7 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     BOOST_CHECK(dummyNode1.fDisconnect == true);\n     SetMockTime(0);\n \n-    bool dummy;\n-    peerLogic->FinalizeNode(dummyNode1, dummy);\n+    peerLogic->FinalizeNode(dummyNode1);\n }\n \n static void AddRandomOutboundPeer(std::vector<CNode *> &vNodes, PeerManager &peerLogic, CConnmanTest* connman)\n@@ -137,9 +136,9 @@ static void AddRandomOutboundPeer(std::vector<CNode *> &vNodes, PeerManager &pee\n BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n {\n     const CChainParams& chainparams = Params();\n-    auto connman = std::make_unique<CConnmanTest>(0x1337, 0x1337);\n-    auto peerLogic = PeerManager::make(chainparams, *connman, nullptr, *m_node.scheduler,\n-                                       *m_node.chainman, *m_node.mempool, false);\n+    auto connman = std::make_unique<CConnmanTest>(0x1337, 0x1337, *m_node.addrman);\n+    auto peerLogic = PeerManager::make(chainparams, *connman, *m_node.addrman, nullptr,\n+                                       *m_node.scheduler, *m_node.chainman, *m_node.mempool, false);\n \n     constexpr int max_outbound_full_relay = MAX_OUTBOUND_FULL_RELAY_CONNECTIONS;\n     CConnman::Options options;\n@@ -199,9 +198,8 @@ BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n     BOOST_CHECK(vNodes[max_outbound_full_relay-1]->fDisconnect == true);\n     BOOST_CHECK(vNodes.back()->fDisconnect == false);\n \n-    bool dummy;\n     for (const CNode *node : vNodes) {\n-        peerLogic->FinalizeNode(*node, dummy);\n+        peerLogic->FinalizeNode(*node);\n     }\n \n     connman->ClearNodes();\n@@ -211,9 +209,9 @@ BOOST_AUTO_TEST_CASE(peer_discouragement)\n {\n     const CChainParams& chainparams = Params();\n     auto banman = std::make_unique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n-    auto connman = std::make_unique<CConnman>(0x1337, 0x1337);\n-    auto peerLogic = PeerManager::make(chainparams, *connman, banman.get(), *m_node.scheduler,\n-                                       *m_node.chainman, *m_node.mempool, false);\n+    auto connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman);\n+    auto peerLogic = PeerManager::make(chainparams, *connman, *m_node.addrman, banman.get(),\n+                                       *m_node.scheduler, *m_node.chainman, *m_node.mempool, false);\n \n     banman->ClearBanned();\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n@@ -249,18 +247,17 @@ BOOST_AUTO_TEST_CASE(peer_discouragement)\n     BOOST_CHECK(banman->IsDiscouraged(addr1));  // Expect both 1 and 2\n     BOOST_CHECK(banman->IsDiscouraged(addr2));  // to be discouraged now\n \n-    bool dummy;\n-    peerLogic->FinalizeNode(dummyNode1, dummy);\n-    peerLogic->FinalizeNode(dummyNode2, dummy);\n+    peerLogic->FinalizeNode(dummyNode1);\n+    peerLogic->FinalizeNode(dummyNode2);\n }\n \n BOOST_AUTO_TEST_CASE(DoS_bantime)\n {\n     const CChainParams& chainparams = Params();\n     auto banman = std::make_unique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n-    auto connman = std::make_unique<CConnman>(0x1337, 0x1337);\n-    auto peerLogic = PeerManager::make(chainparams, *connman, banman.get(), *m_node.scheduler,\n-                                       *m_node.chainman, *m_node.mempool, false);\n+    auto connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman);\n+    auto peerLogic = PeerManager::make(chainparams, *connman, *m_node.addrman, banman.get(),\n+                                       *m_node.scheduler, *m_node.chainman, *m_node.mempool, false);\n \n     banman->ClearBanned();\n     int64_t nStartTime = GetTime();\n@@ -279,8 +276,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     }\n     BOOST_CHECK(banman->IsDiscouraged(addr));\n \n-    bool dummy;\n-    peerLogic->FinalizeNode(dummyNode, dummy);\n+    peerLogic->FinalizeNode(dummyNode);\n }\n \n class TxOrphanageTest : public TxOrphanage"
      },
      {
        "sha": "b21d2eae79bce4a0f7b0f78e8625b94f2bbdd15d",
        "filename": "src/test/fuzz/coins_view.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/fuzz/coins_view.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/fuzz/coins_view.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/coins_view.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -230,11 +230,8 @@ FUZZ_TARGET_INIT(coins_view, initialize_coins_view)\n                     // consensus/tx_verify.cpp:171: bool Consensus::CheckTxInputs(const CTransaction &, TxValidationState &, const CCoinsViewCache &, int, CAmount &): Assertion `!coin.IsSpent()' failed.\n                     return;\n                 }\n-                try {\n-                    (void)Consensus::CheckTxInputs(transaction, state, coins_view_cache, fuzzed_data_provider.ConsumeIntegralInRange<int>(0, std::numeric_limits<int>::max()), tx_fee_out);\n-                    assert(MoneyRange(tx_fee_out));\n-                } catch (const std::runtime_error&) {\n-                }\n+                (void)Consensus::CheckTxInputs(transaction, state, coins_view_cache, fuzzed_data_provider.ConsumeIntegralInRange<int>(0, std::numeric_limits<int>::max()), tx_fee_out);\n+                assert(MoneyRange(tx_fee_out));\n             },\n             [&] {\n                 const CTransaction transaction{random_mutable_transaction};"
      },
      {
        "sha": "e07f25dedfa35aa339dd644d7aa301c11404a0cc",
        "filename": "src/test/fuzz/connman.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 23,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/fuzz/connman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/fuzz/connman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/connman.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -25,39 +25,24 @@ FUZZ_TARGET_INIT(connman, initialize_connman)\n {\n     FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n-    CConnman connman{fuzzed_data_provider.ConsumeIntegral<uint64_t>(), fuzzed_data_provider.ConsumeIntegral<uint64_t>(), fuzzed_data_provider.ConsumeBool()};\n-    CAddress random_address;\n+    CAddrMan addrman;\n+    CConnman connman{fuzzed_data_provider.ConsumeIntegral<uint64_t>(), fuzzed_data_provider.ConsumeIntegral<uint64_t>(), addrman, fuzzed_data_provider.ConsumeBool()};\n     CNetAddr random_netaddr;\n     CNode random_node = ConsumeNode(fuzzed_data_provider);\n-    CService random_service;\n     CSubNet random_subnet;\n     std::string random_string;\n     while (fuzzed_data_provider.ConsumeBool()) {\n         CallOneOf(\n             fuzzed_data_provider,\n-            [&] {\n-                random_address = ConsumeAddress(fuzzed_data_provider);\n-            },\n             [&] {\n                 random_netaddr = ConsumeNetAddr(fuzzed_data_provider);\n             },\n-            [&] {\n-                random_service = ConsumeService(fuzzed_data_provider);\n-            },\n             [&] {\n                 random_subnet = ConsumeSubNet(fuzzed_data_provider);\n             },\n             [&] {\n                 random_string = fuzzed_data_provider.ConsumeRandomLengthString(64);\n             },\n-            [&] {\n-                std::vector<CAddress> addresses;\n-                while (fuzzed_data_provider.ConsumeBool()) {\n-                    addresses.push_back(ConsumeAddress(fuzzed_data_provider));\n-                }\n-                // Limit nTimePenalty to int32_t to avoid signed integer overflow\n-                (void)connman.AddNewAddresses(addresses, ConsumeAddress(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int32_t>());\n-            },\n             [&] {\n                 connman.AddNode(random_string);\n             },\n@@ -97,9 +82,6 @@ FUZZ_TARGET_INIT(connman, initialize_connman)\n             [&] {\n                 (void)connman.GetNodeCount(fuzzed_data_provider.PickValueInArray({ConnectionDirection::None, ConnectionDirection::In, ConnectionDirection::Out, ConnectionDirection::Both}));\n             },\n-            [&] {\n-                connman.MarkAddressGood(random_address);\n-            },\n             [&] {\n                 (void)connman.OutboundTargetReached(fuzzed_data_provider.ConsumeBool());\n             },\n@@ -127,9 +109,6 @@ FUZZ_TARGET_INIT(connman, initialize_connman)\n             [&] {\n                 connman.SetNetworkActive(fuzzed_data_provider.ConsumeBool());\n             },\n-            [&] {\n-                connman.SetServices(random_service, ConsumeWeakEnum(fuzzed_data_provider, ALL_SERVICE_FLAGS));\n-            },\n             [&] {\n                 connman.SetTryNewOutboundPeer(fuzzed_data_provider.ConsumeBool());\n             });"
      },
      {
        "sha": "345d68502adea231611d446bb17a09ba7e0c1196",
        "filename": "src/test/fuzz/i2p.cpp",
        "status": "added",
        "additions": 57,
        "deletions": 0,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/fuzz/i2p.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/fuzz/i2p.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/i2p.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -0,0 +1,57 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+void initialize_i2p()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<>();\n+}\n+\n+FUZZ_TARGET_INIT(i2p, initialize_i2p)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+\n+    // Mock CreateSock() to create FuzzedSock.\n+    auto CreateSockOrig = CreateSock;\n+    CreateSock = [&fuzzed_data_provider](const CService&) {\n+        return std::make_unique<FuzzedSock>(fuzzed_data_provider);\n+    };\n+\n+    const CService sam_proxy;\n+    CThreadInterrupt interrupt;\n+\n+    i2p::sam::Session sess{GetDataDir() / \"fuzzed_i2p_private_key\", sam_proxy, &interrupt};\n+\n+    i2p::Connection conn;\n+\n+    if (sess.Listen(conn)) {\n+        if (sess.Accept(conn)) {\n+            try {\n+                conn.sock->RecvUntilTerminator('\\n', 10ms, interrupt, i2p::sam::MAX_MSG_SIZE);\n+            } catch (const std::runtime_error&) {\n+            }\n+        }\n+    }\n+\n+    const CService to;\n+    bool proxy_error;\n+\n+    if (sess.Connect(to, conn, proxy_error)) {\n+        try {\n+            conn.sock->SendComplete(\"verack\\n\", 10ms, interrupt);\n+        } catch (const std::runtime_error&) {\n+        }\n+    }\n+\n+    CreateSock = CreateSockOrig;\n+}"
      },
      {
        "sha": "70ffc6bf37f25c5850b148ea40dbd5de73e1ea59",
        "filename": "src/test/fuzz/node_eviction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/fuzz/node_eviction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/fuzz/node_eviction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/node_eviction.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -31,6 +31,7 @@ FUZZ_TARGET(node_eviction)\n             /* nKeyedNetGroup */ fuzzed_data_provider.ConsumeIntegral<uint64_t>(),\n             /* prefer_evict */ fuzzed_data_provider.ConsumeBool(),\n             /* m_is_local */ fuzzed_data_provider.ConsumeBool(),\n+            /* m_is_onion */ fuzzed_data_provider.ConsumeBool(),\n         });\n     }\n     // Make a copy since eviction_candidates may be in some valid but otherwise"
      },
      {
        "sha": "e87ae5b04b883ec2cef51dd51c126d5b05707d04",
        "filename": "src/test/fuzz/script.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/fuzz/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/fuzz/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/script.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -103,9 +103,11 @@ FUZZ_TARGET_INIT(script, initialize_script)\n     (void)ScriptToAsmStr(script, true);\n \n     UniValue o1(UniValue::VOBJ);\n-    ScriptPubKeyToUniv(script, o1, true);\n+    ScriptPubKeyToUniv(script, o1, true, true);\n+    ScriptPubKeyToUniv(script, o1, true, false);\n     UniValue o2(UniValue::VOBJ);\n-    ScriptPubKeyToUniv(script, o2, false);\n+    ScriptPubKeyToUniv(script, o2, false, true);\n+    ScriptPubKeyToUniv(script, o2, false, false);\n     UniValue o3(UniValue::VOBJ);\n     ScriptToUniv(script, o3, true);\n     UniValue o4(UniValue::VOBJ);"
      },
      {
        "sha": "387f9c069c378c4baabf4fdcbc9951967f9e663b",
        "filename": "src/test/fuzz/script_flags.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 10,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/fuzz/script_flags.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/fuzz/script_flags.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/script_flags.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -5,13 +5,11 @@\n #include <pubkey.h>\n #include <script/interpreter.h>\n #include <streams.h>\n+#include <test/util/script.h>\n #include <version.h>\n \n #include <test/fuzz/fuzz.h>\n \n-/** Flags that are not forbidden by an assert */\n-static bool IsValidFlagCombination(unsigned flags);\n-\n void initialize_script_flags()\n {\n     static const ECCVerifyHandle verify_handle;\n@@ -74,10 +72,3 @@ FUZZ_TARGET_INIT(script_flags, initialize_script_flags)\n         return;\n     }\n }\n-\n-static bool IsValidFlagCombination(unsigned flags)\n-{\n-    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n-    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n-    return true;\n-}"
      },
      {
        "sha": "6b86c8889d17aeb4e9f01f050ce36727757a7f1b",
        "filename": "src/test/fuzz/signature_checker.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 10,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/fuzz/signature_checker.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/fuzz/signature_checker.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/signature_checker.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -6,6 +6,8 @@\n #include <script/interpreter.h>\n #include <test/fuzz/FuzzedDataProvider.h>\n #include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/script.h>\n \n #include <cstdint>\n #include <limits>\n@@ -56,17 +58,12 @@ FUZZ_TARGET_INIT(signature_checker, initialize_signature_checker)\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n     const unsigned int flags = fuzzed_data_provider.ConsumeIntegral<unsigned int>();\n     const SigVersion sig_version = fuzzed_data_provider.PickValueInArray({SigVersion::BASE, SigVersion::WITNESS_V0});\n-    const std::string script_string_1 = fuzzed_data_provider.ConsumeRandomLengthString(65536);\n-    const std::vector<uint8_t> script_bytes_1{script_string_1.begin(), script_string_1.end()};\n-    const std::string script_string_2 = fuzzed_data_provider.ConsumeRandomLengthString(65536);\n-    const std::vector<uint8_t> script_bytes_2{script_string_2.begin(), script_string_2.end()};\n+    const auto script_1 = ConsumeScript(fuzzed_data_provider, 65536);\n+    const auto script_2 = ConsumeScript(fuzzed_data_provider, 65536);\n     std::vector<std::vector<unsigned char>> stack;\n-    (void)EvalScript(stack, {script_bytes_1.begin(), script_bytes_1.end()}, flags, FuzzedSignatureChecker(fuzzed_data_provider), sig_version, nullptr);\n-    if ((flags & SCRIPT_VERIFY_CLEANSTACK) != 0 && ((flags & SCRIPT_VERIFY_P2SH) == 0 || (flags & SCRIPT_VERIFY_WITNESS) == 0)) {\n+    (void)EvalScript(stack, script_1, flags, FuzzedSignatureChecker(fuzzed_data_provider), sig_version, nullptr);\n+    if (!IsValidFlagCombination(flags)) {\n         return;\n     }\n-    if ((flags & SCRIPT_VERIFY_WITNESS) != 0 && (flags & SCRIPT_VERIFY_P2SH) == 0) {\n-        return;\n-    }\n-    (void)VerifyScript({script_bytes_1.begin(), script_bytes_1.end()}, {script_bytes_2.begin(), script_bytes_2.end()}, nullptr, flags, FuzzedSignatureChecker(fuzzed_data_provider), nullptr);\n+    (void)VerifyScript(script_1, script_2, nullptr, flags, FuzzedSignatureChecker(fuzzed_data_provider), nullptr);\n }"
      },
      {
        "sha": "17e4405a1368ea21e0c4d421716a426d810fa120",
        "filename": "src/test/fuzz/transaction.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/fuzz/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/fuzz/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/transaction.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -100,7 +100,9 @@ FUZZ_TARGET_INIT(transaction, initialize_transaction)\n     (void)IsWitnessStandard(tx, coins_view_cache);\n \n     UniValue u(UniValue::VOBJ);\n-    TxToUniv(tx, /* hashBlock */ {}, u);\n+    TxToUniv(tx, /* hashBlock */ {}, /* include_addresses */ true, u);\n+    TxToUniv(tx, /* hashBlock */ {}, /* include_addresses */ false, u);\n     static const uint256 u256_max(uint256S(\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n-    TxToUniv(tx, u256_max, u);\n+    TxToUniv(tx, u256_max, /* include_addresses */ true, u);\n+    TxToUniv(tx, u256_max, /* include_addresses */ false, u);\n }"
      },
      {
        "sha": "d786ac1db11cc61f14489569399c37b651008f02",
        "filename": "src/test/fuzz/util.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/fuzz/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/fuzz/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/util.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -80,7 +80,7 @@ CScriptWitness ConsumeScriptWitness(FuzzedDataProvider& fuzzed_data_provider, co\n \n CScript ConsumeScript(FuzzedDataProvider& fuzzed_data_provider, const size_t max_length, const bool maybe_p2wsh) noexcept\n {\n-    const std::vector<uint8_t> b = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+    const std::vector<uint8_t> b = ConsumeRandomLengthByteVector(fuzzed_data_provider, max_length);\n     CScript r_script{b.begin(), b.end()};\n     if (maybe_p2wsh && fuzzed_data_provider.ConsumeBool()) {\n         uint256 script_hash;"
      },
      {
        "sha": "50d3ac66e5fd8e6e2928fe19d581b6d32dec89fe",
        "filename": "src/test/fuzz/util.h",
        "status": "modified",
        "additions": 89,
        "deletions": 18,
        "changes": 107,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/fuzz/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/fuzz/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/util.h?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -567,36 +567,37 @@ class FuzzedSock : public Sock\n {\n     FuzzedDataProvider& m_fuzzed_data_provider;\n \n+    /**\n+     * Data to return when `MSG_PEEK` is used as a `Recv()` flag.\n+     * If `MSG_PEEK` is used, then our `Recv()` returns some random data as usual, but on the next\n+     * `Recv()` call we must return the same data, thus we remember it here.\n+     */\n+    mutable std::optional<uint8_t> m_peek_data;\n+\n public:\n     explicit FuzzedSock(FuzzedDataProvider& fuzzed_data_provider) : m_fuzzed_data_provider{fuzzed_data_provider}\n     {\n+          m_socket = fuzzed_data_provider.ConsumeIntegral<SOCKET>();\n     }\n \n     ~FuzzedSock() override\n     {\n+        // Sock::~Sock() will be called after FuzzedSock::~FuzzedSock() and it will call\n+        // Sock::Reset() (not FuzzedSock::Reset()!) which will call CloseSocket(m_socket).\n+        // Avoid closing an arbitrary file descriptor (m_socket is just a random number which\n+        // may concide with a real opened file descriptor).\n+        Reset();\n     }\n \n     FuzzedSock& operator=(Sock&& other) override\n     {\n-        assert(false && \"Not implemented yet.\");\n+        assert(false && \"Move of Sock into FuzzedSock not allowed.\");\n         return *this;\n     }\n \n-    SOCKET Get() const override\n-    {\n-        assert(false && \"Not implemented yet.\");\n-        return INVALID_SOCKET;\n-    }\n-\n-    SOCKET Release() override\n-    {\n-        assert(false && \"Not implemented yet.\");\n-        return INVALID_SOCKET;\n-    }\n-\n     void Reset() override\n     {\n-        assert(false && \"Not implemented yet.\");\n+        m_socket = INVALID_SOCKET;\n     }\n \n     ssize_t Send(const void* data, size_t len, int flags) const override\n@@ -633,10 +634,13 @@ class FuzzedSock : public Sock\n \n     ssize_t Recv(void* buf, size_t len, int flags) const override\n     {\n+        // Have a permanent error at recv_errnos[0] because when the fuzzed data is exhausted\n+        // SetFuzzedErrNo() will always return the first element and we want to avoid Recv()\n+        // returning -1 and setting errno to EAGAIN repeatedly.\n         constexpr std::array recv_errnos{\n+            ECONNREFUSED,\n             EAGAIN,\n             EBADF,\n-            ECONNREFUSED,\n             EFAULT,\n             EINTR,\n             EINVAL,\n@@ -653,8 +657,26 @@ class FuzzedSock : public Sock\n             }\n             return r;\n         }\n-        const std::vector<uint8_t> random_bytes = m_fuzzed_data_provider.ConsumeBytes<uint8_t>(\n-            m_fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, len));\n+        std::vector<uint8_t> random_bytes;\n+        bool pad_to_len_bytes{m_fuzzed_data_provider.ConsumeBool()};\n+        if (m_peek_data.has_value()) {\n+            // `MSG_PEEK` was used in the preceding `Recv()` call, return `m_peek_data`.\n+            random_bytes.assign({m_peek_data.value()});\n+            if ((flags & MSG_PEEK) == 0) {\n+                m_peek_data.reset();\n+            }\n+            pad_to_len_bytes = false;\n+        } else if ((flags & MSG_PEEK) != 0) {\n+            // New call with `MSG_PEEK`.\n+            random_bytes = m_fuzzed_data_provider.ConsumeBytes<uint8_t>(1);\n+            if (!random_bytes.empty()) {\n+                m_peek_data = random_bytes[0];\n+                pad_to_len_bytes = false;\n+            }\n+        } else {\n+            random_bytes = m_fuzzed_data_provider.ConsumeBytes<uint8_t>(\n+                m_fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, len));\n+        }\n         if (random_bytes.empty()) {\n             const ssize_t r = m_fuzzed_data_provider.ConsumeBool() ? 0 : -1;\n             if (r == -1) {\n@@ -663,7 +685,7 @@ class FuzzedSock : public Sock\n             return r;\n         }\n         std::memcpy(buf, random_bytes.data(), random_bytes.size());\n-        if (m_fuzzed_data_provider.ConsumeBool()) {\n+        if (pad_to_len_bytes) {\n             if (len > random_bytes.size()) {\n                 std::memset((char*)buf + random_bytes.size(), 0, len - random_bytes.size());\n             }\n@@ -675,10 +697,59 @@ class FuzzedSock : public Sock\n         return random_bytes.size();\n     }\n \n+    int Connect(const sockaddr*, socklen_t) const override\n+    {\n+        // Have a permanent error at connect_errnos[0] because when the fuzzed data is exhausted\n+        // SetFuzzedErrNo() will always return the first element and we want to avoid Connect()\n+        // returning -1 and setting errno to EAGAIN repeatedly.\n+        constexpr std::array connect_errnos{\n+            ECONNREFUSED,\n+            EAGAIN,\n+            ECONNRESET,\n+            EHOSTUNREACH,\n+            EINPROGRESS,\n+            EINTR,\n+            ENETUNREACH,\n+            ETIMEDOUT,\n+        };\n+        if (m_fuzzed_data_provider.ConsumeBool()) {\n+            SetFuzzedErrNo(m_fuzzed_data_provider, connect_errnos);\n+            return -1;\n+        }\n+        return 0;\n+    }\n+\n+    int GetSockOpt(int level, int opt_name, void* opt_val, socklen_t* opt_len) const override\n+    {\n+        constexpr std::array getsockopt_errnos{\n+            ENOMEM,\n+            ENOBUFS,\n+        };\n+        if (m_fuzzed_data_provider.ConsumeBool()) {\n+            SetFuzzedErrNo(m_fuzzed_data_provider, getsockopt_errnos);\n+            return -1;\n+        }\n+        if (opt_val == nullptr) {\n+            return 0;\n+        }\n+        std::memcpy(opt_val,\n+                    ConsumeFixedLengthByteVector(m_fuzzed_data_provider, *opt_len).data(),\n+                    *opt_len);\n+        return 0;\n+    }\n+\n     bool Wait(std::chrono::milliseconds timeout, Event requested, Event* occurred = nullptr) const override\n     {\n         return m_fuzzed_data_provider.ConsumeBool();\n     }\n+\n+    bool IsConnected(std::string& errmsg) const override {\n+        if (m_fuzzed_data_provider.ConsumeBool()) {\n+            return true;\n+        }\n+        errmsg = \"disconnected at random by the fuzzer\";\n+        return false;\n+    }\n };\n \n [[nodiscard]] inline FuzzedSock ConsumeSock(FuzzedDataProvider& fuzzed_data_provider)"
      },
      {
        "sha": "334f71106c66ce6e5fccdcbb84c9dce7fcd34625",
        "filename": "src/test/i2p_tests.cpp",
        "status": "added",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/i2p_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/i2p_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/i2p_tests.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -0,0 +1,44 @@\n+// Copyright (c) 2021-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <test/util/logging.h>\n+#include <test/util/net.h>\n+#include <test/util/setup_common.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <memory>\n+#include <string>\n+\n+BOOST_FIXTURE_TEST_SUITE(i2p_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(unlimited_recv)\n+{\n+    auto CreateSockOrig = CreateSock;\n+\n+    // Mock CreateSock() to create MockSock.\n+    CreateSock = [](const CService&) {\n+        return std::make_unique<StaticContentsSock>(std::string(i2p::sam::MAX_MSG_SIZE + 1, 'a'));\n+    };\n+\n+    CThreadInterrupt interrupt;\n+    i2p::sam::Session session(GetDataDir() / \"test_i2p_private_key\", CService{}, &interrupt);\n+\n+    {\n+        ASSERT_DEBUG_LOG(\"Creating SAM session\");\n+        ASSERT_DEBUG_LOG(\"too many bytes without a terminator\");\n+\n+        i2p::Connection conn;\n+        bool proxy_error;\n+        BOOST_REQUIRE(!session.Connect(CService{}, conn, proxy_error));\n+    }\n+\n+    CreateSock = CreateSockOrig;\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "9ba004cc38ed9723b1f386c4787fea65fd97aa51",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -44,7 +44,7 @@ BlockAssembler MinerTestingSetup::AssemblerForTest(const CChainParams& params)\n \n     options.nBlockMaxWeight = MAX_BLOCK_WEIGHT;\n     options.blockMinFeeRate = blockMinFeeRate;\n-    return BlockAssembler(*m_node.mempool, params, options);\n+    return BlockAssembler(::ChainstateActive(), *m_node.mempool, params, options);\n }\n \n constexpr static struct {\n@@ -122,7 +122,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     uint256 hashHighFeeTx = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(50000).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n \n-    std::unique_ptr<CBlockTemplate> pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);\n+    std::unique_ptr<CBlockTemplate> pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n     BOOST_REQUIRE_EQUAL(pblocktemplate->block.vtx.size(), 4U);\n     BOOST_CHECK(pblocktemplate->block.vtx[1]->GetHash() == hashParentTx);\n     BOOST_CHECK(pblocktemplate->block.vtx[2]->GetHash() == hashHighFeeTx);\n@@ -143,7 +143,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vout[0].nValue = 5000000000LL - 1000 - 50000 - feeToUse;\n     uint256 hashLowFeeTx = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(feeToUse).FromTx(tx));\n-    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);\n+    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n     // Verify that the free tx and the low fee tx didn't get selected\n     for (size_t i=0; i<pblocktemplate->block.vtx.size(); ++i) {\n         BOOST_CHECK(pblocktemplate->block.vtx[i]->GetHash() != hashFreeTx);\n@@ -157,7 +157,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vout[0].nValue -= 2; // Now we should be just over the min relay fee\n     hashLowFeeTx = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(feeToUse+2).FromTx(tx));\n-    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);\n+    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n     BOOST_REQUIRE_EQUAL(pblocktemplate->block.vtx.size(), 6U);\n     BOOST_CHECK(pblocktemplate->block.vtx[4]->GetHash() == hashFreeTx);\n     BOOST_CHECK(pblocktemplate->block.vtx[5]->GetHash() == hashLowFeeTx);\n@@ -179,7 +179,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vout[0].nValue = 5000000000LL - 100000000 - feeToUse;\n     uint256 hashLowFeeTx2 = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(feeToUse).SpendsCoinbase(false).FromTx(tx));\n-    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);\n+    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n \n     // Verify that this tx isn't selected.\n     for (size_t i=0; i<pblocktemplate->block.vtx.size(); ++i) {\n@@ -192,7 +192,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vin[0].prevout.n = 1;\n     tx.vout[0].nValue = 100000000 - 10000; // 10k satoshi fee\n     m_node.mempool->addUnchecked(entry.Fee(10000).FromTx(tx));\n-    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);\n+    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n     BOOST_REQUIRE_EQUAL(pblocktemplate->block.vtx.size(), 9U);\n     BOOST_CHECK(pblocktemplate->block.vtx[8]->GetHash() == hashLowFeeTx2);\n }\n@@ -215,7 +215,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     fCheckpointsEnabled = false;\n \n     // Simple block creation, nothing special yet:\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n \n     // We can't make transactions until we have inputs\n     // Therefore, load 110 blocks :)\n@@ -252,7 +252,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     LOCK(m_node.mempool->cs);\n \n     // Just to make sure we can still make simple blocks\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n \n     const CAmount BLOCKSUBSIDY = 50*COIN;\n     const CAmount LOWFEE = CENT;\n@@ -277,7 +277,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         tx.vin[0].prevout.hash = hash;\n     }\n \n-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey), std::runtime_error, HasReason(\"bad-blk-sigops\"));\n+    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-blk-sigops\"));\n     m_node.mempool->clear();\n \n     tx.vin[0].prevout.hash = txFirst[0]->GetHash();\n@@ -291,7 +291,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).SigOpsCost(80).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n     }\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n     m_node.mempool->clear();\n \n     // block size > limit\n@@ -311,13 +311,13 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n     }\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n     m_node.mempool->clear();\n \n     // orphan in *m_node.mempool, template creation fails\n     hash = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).FromTx(tx));\n-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey), std::runtime_error, HasReason(\"bad-txns-inputs-missingorspent\"));\n+    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-txns-inputs-missingorspent\"));\n     m_node.mempool->clear();\n \n     // child with higher feerate than parent\n@@ -334,7 +334,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].nValue = tx.vout[0].nValue+BLOCKSUBSIDY-HIGHERFEE; //First txn output + fresh coinbase - new txn fee\n     hash = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(HIGHERFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n     m_node.mempool->clear();\n \n     // coinbase in *m_node.mempool, template creation fails\n@@ -346,7 +346,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     // give it a fee so it'll get mined\n     m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n     // Should throw bad-cb-multiple\n-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey), std::runtime_error, HasReason(\"bad-cb-multiple\"));\n+    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-cb-multiple\"));\n     m_node.mempool->clear();\n \n     // double spend txn pair in *m_node.mempool, template creation fails\n@@ -359,7 +359,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].scriptPubKey = CScript() << OP_2;\n     hash = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey), std::runtime_error, HasReason(\"bad-txns-inputs-missingorspent\"));\n+    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-txns-inputs-missingorspent\"));\n     m_node.mempool->clear();\n \n     // subsidy changing\n@@ -375,7 +375,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         next->BuildSkip();\n         ::ChainActive().SetTip(next);\n     }\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n     // Extend to a 210000-long block chain.\n     while (::ChainActive().Tip()->nHeight < 210000) {\n         CBlockIndex* prev = ::ChainActive().Tip();\n@@ -387,7 +387,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         next->BuildSkip();\n         ::ChainActive().SetTip(next);\n     }\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n \n     // invalid p2sh txn in *m_node.mempool, template creation fails\n     tx.vin[0].prevout.hash = txFirst[0]->GetHash();\n@@ -404,7 +404,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     hash = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n     // Should throw block-validation-failed\n-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey), std::runtime_error, HasReason(\"block-validation-failed\"));\n+    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"block-validation-failed\"));\n     m_node.mempool->clear();\n \n     // Delete the dummy blocks again.\n@@ -492,7 +492,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG | 1;\n     BOOST_CHECK(!TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks fail\n \n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n \n     // None of the of the absolute height/time locked tx should have made\n     // it into the template because we still check IsFinalTx in CreateNewBlock,\n@@ -505,7 +505,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     ::ChainActive().Tip()->nHeight++;\n     SetMockTime(::ChainActive().Tip()->GetMedianTimePast() + 1);\n \n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n     BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 5U);\n \n     ::ChainActive().Tip()->nHeight--;"
      },
      {
        "sha": "31d391bf7d88755ee8a207ff030a229e9b9672bc",
        "filename": "src/test/net_peer_eviction_tests.cpp",
        "status": "added",
        "additions": 348,
        "deletions": 0,
        "changes": 348,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/net_peer_eviction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/net_peer_eviction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_peer_eviction_tests.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -0,0 +1,348 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <optional>\n+#include <unordered_set>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(net_peer_eviction_tests, BasicTestingSetup)\n+\n+namespace {\n+constexpr int NODE_EVICTION_TEST_ROUNDS{10};\n+constexpr int NODE_EVICTION_TEST_UP_TO_N_NODES{200};\n+} // namespace\n+\n+std::vector<NodeEvictionCandidate> GetRandomNodeEvictionCandidates(const int n_candidates, FastRandomContext& random_context)\n+{\n+    std::vector<NodeEvictionCandidate> candidates;\n+    for (int id = 0; id < n_candidates; ++id) {\n+        candidates.push_back({\n+            /* id */ id,\n+            /* nTimeConnected */ static_cast<int64_t>(random_context.randrange(100)),\n+            /* m_min_ping_time */ std::chrono::microseconds{random_context.randrange(100)},\n+            /* nLastBlockTime */ static_cast<int64_t>(random_context.randrange(100)),\n+            /* nLastTXTime */ static_cast<int64_t>(random_context.randrange(100)),\n+            /* fRelevantServices */ random_context.randbool(),\n+            /* fRelayTxes */ random_context.randbool(),\n+            /* fBloomFilter */ random_context.randbool(),\n+            /* nKeyedNetGroup */ random_context.randrange(100),\n+            /* prefer_evict */ random_context.randbool(),\n+            /* m_is_local */ random_context.randbool(),\n+            /* m_is_onion */ random_context.randbool(),\n+        });\n+    }\n+    return candidates;\n+}\n+\n+// Create `num_peers` random nodes, apply setup function `candidate_setup_fn`,\n+// call ProtectEvictionCandidatesByRatio() to apply protection logic, and then\n+// return true if all of `protected_peer_ids` and none of `unprotected_peer_ids`\n+// are protected from eviction, i.e. removed from the eviction candidates.\n+bool IsProtected(int num_peers,\n+                 std::function<void(NodeEvictionCandidate&)> candidate_setup_fn,\n+                 const std::unordered_set<NodeId>& protected_peer_ids,\n+                 const std::unordered_set<NodeId>& unprotected_peer_ids,\n+                 FastRandomContext& random_context)\n+{\n+    std::vector<NodeEvictionCandidate> candidates{GetRandomNodeEvictionCandidates(num_peers, random_context)};\n+    for (NodeEvictionCandidate& candidate : candidates) {\n+        candidate_setup_fn(candidate);\n+    }\n+    Shuffle(candidates.begin(), candidates.end(), random_context);\n+\n+    const size_t size{candidates.size()};\n+    const size_t expected{size - size / 2}; // Expect half the candidates will be protected.\n+    ProtectEvictionCandidatesByRatio(candidates);\n+    BOOST_CHECK_EQUAL(candidates.size(), expected);\n+\n+    size_t unprotected_count{0};\n+    for (const NodeEvictionCandidate& candidate : candidates) {\n+        if (protected_peer_ids.count(candidate.id)) {\n+            // this peer should have been removed from the eviction candidates\n+            BOOST_TEST_MESSAGE(strprintf(\"expected candidate to be protected: %d\", candidate.id));\n+            return false;\n+        }\n+        if (unprotected_peer_ids.count(candidate.id)) {\n+            // this peer remains in the eviction candidates, as expected\n+            ++unprotected_count;\n+        }\n+    }\n+\n+    const bool is_protected{unprotected_count == unprotected_peer_ids.size()};\n+    if (!is_protected) {\n+        BOOST_TEST_MESSAGE(strprintf(\"unprotected: expected %d, actual %d\",\n+                                     unprotected_peer_ids.size(), unprotected_count));\n+    }\n+    return is_protected;\n+}\n+\n+BOOST_AUTO_TEST_CASE(peer_protection_test)\n+{\n+    FastRandomContext random_context{true};\n+    int num_peers{12};\n+\n+    // Expect half of the peers with greatest uptime (the lowest nTimeConnected)\n+    // to be protected from eviction.\n+    BOOST_CHECK(IsProtected(\n+        num_peers, [](NodeEvictionCandidate& c) {\n+            c.nTimeConnected = c.id;\n+            c.m_is_onion = c.m_is_local = false;\n+        },\n+        /* protected_peer_ids */ {0, 1, 2, 3, 4, 5},\n+        /* unprotected_peer_ids */ {6, 7, 8, 9, 10, 11},\n+        random_context));\n+\n+    // Verify in the opposite direction.\n+    BOOST_CHECK(IsProtected(\n+        num_peers, [num_peers](NodeEvictionCandidate& c) {\n+            c.nTimeConnected = num_peers - c.id;\n+            c.m_is_onion = c.m_is_local = false;\n+        },\n+        /* protected_peer_ids */ {6, 7, 8, 9, 10, 11},\n+        /* unprotected_peer_ids */ {0, 1, 2, 3, 4, 5},\n+        random_context));\n+\n+    // Test protection of onion and localhost peers...\n+\n+    // Expect 1/4 onion peers to be protected from eviction,\n+    // independently of other characteristics.\n+    BOOST_CHECK(IsProtected(\n+        num_peers, [](NodeEvictionCandidate& c) {\n+            c.m_is_onion = (c.id == 3 || c.id == 8 || c.id == 9);\n+        },\n+        /* protected_peer_ids */ {3, 8, 9},\n+        /* unprotected_peer_ids */ {},\n+        random_context));\n+\n+    // Expect 1/4 onion peers and 1/4 of the others to be protected\n+    // from eviction, sorted by longest uptime (lowest nTimeConnected).\n+    BOOST_CHECK(IsProtected(\n+        num_peers, [](NodeEvictionCandidate& c) {\n+            c.nTimeConnected = c.id;\n+            c.m_is_local = false;\n+            c.m_is_onion = (c.id == 3 || c.id > 7);\n+        },\n+        /* protected_peer_ids */ {0, 1, 2, 3, 8, 9},\n+        /* unprotected_peer_ids */ {4, 5, 6, 7, 10, 11},\n+        random_context));\n+\n+    // Expect 1/4 localhost peers to be protected from eviction,\n+    // if no onion peers.\n+    BOOST_CHECK(IsProtected(\n+        num_peers, [](NodeEvictionCandidate& c) {\n+            c.m_is_onion = false;\n+            c.m_is_local = (c.id == 1 || c.id == 9 || c.id == 11);\n+        },\n+        /* protected_peer_ids */ {1, 9, 11},\n+        /* unprotected_peer_ids */ {},\n+        random_context));\n+\n+    // Expect 1/4 localhost peers and 1/4 of the other peers to be protected,\n+    // sorted by longest uptime (lowest nTimeConnected), if no onion peers.\n+    BOOST_CHECK(IsProtected(\n+        num_peers, [](NodeEvictionCandidate& c) {\n+            c.nTimeConnected = c.id;\n+            c.m_is_onion = false;\n+            c.m_is_local = (c.id > 6);\n+        },\n+        /* protected_peer_ids */ {0, 1, 2, 7, 8, 9},\n+        /* unprotected_peer_ids */ {3, 4, 5, 6, 10, 11},\n+        random_context));\n+\n+    // Combined test: expect 1/4 onion and 2 localhost peers to be protected\n+    // from eviction, sorted by longest uptime.\n+    BOOST_CHECK(IsProtected(\n+        num_peers, [](NodeEvictionCandidate& c) {\n+            c.nTimeConnected = c.id;\n+            c.m_is_onion = (c.id == 0 || c.id == 5 || c.id == 10);\n+            c.m_is_local = (c.id == 1 || c.id == 9 || c.id == 11);\n+        },\n+        /* protected_peer_ids */ {0, 1, 2, 5, 9, 10},\n+        /* unprotected_peer_ids */ {3, 4, 6, 7, 8, 11},\n+        random_context));\n+\n+    // Combined test: expect having only 1 onion to allow allocating the\n+    // remaining 2 of the 1/4 to localhost peers, sorted by longest uptime.\n+    BOOST_CHECK(IsProtected(\n+        num_peers + 4, [](NodeEvictionCandidate& c) {\n+            c.nTimeConnected = c.id;\n+            c.m_is_onion = (c.id == 15);\n+            c.m_is_local = (c.id > 6 && c.id < 11);\n+        },\n+        /* protected_peer_ids */ {0, 1, 2, 3, 7, 8, 9, 15},\n+        /* unprotected_peer_ids */ {4, 5, 6, 10, 11, 12, 13, 14},\n+        random_context));\n+\n+    // Combined test: expect 2 onions (< 1/4) to allow allocating the minimum 2\n+    // localhost peers, sorted by longest uptime.\n+    BOOST_CHECK(IsProtected(\n+        num_peers, [](NodeEvictionCandidate& c) {\n+            c.nTimeConnected = c.id;\n+            c.m_is_onion = (c.id == 7 || c.id == 9);\n+            c.m_is_local = (c.id == 6 || c.id == 11);\n+        },\n+        /* protected_peer_ids */ {0, 1, 6, 7, 9, 11},\n+        /* unprotected_peer_ids */ {2, 3, 4, 5, 8, 10},\n+        random_context));\n+\n+    // Combined test: when > 1/4, expect max 1/4 onion and 2 localhost peers\n+    // to be protected from eviction, sorted by longest uptime.\n+    BOOST_CHECK(IsProtected(\n+        num_peers, [](NodeEvictionCandidate& c) {\n+            c.nTimeConnected = c.id;\n+            c.m_is_onion = (c.id > 3 && c.id < 8);\n+            c.m_is_local = (c.id > 7);\n+        },\n+        /* protected_peer_ids */ {0, 4, 5, 6, 8, 9},\n+        /* unprotected_peer_ids */ {1, 2, 3, 7, 10, 11},\n+        random_context));\n+\n+    // Combined test: idem > 1/4 with only 8 peers: expect 2 onion and 2\n+    // localhost peers (1/4 + 2) to be protected, sorted by longest uptime.\n+    BOOST_CHECK(IsProtected(\n+        8, [](NodeEvictionCandidate& c) {\n+            c.nTimeConnected = c.id;\n+            c.m_is_onion = (c.id > 1 && c.id < 5);\n+            c.m_is_local = (c.id > 4);\n+        },\n+        /* protected_peer_ids */ {2, 3, 5, 6},\n+        /* unprotected_peer_ids */ {0, 1, 4, 7},\n+        random_context));\n+\n+    // Combined test: idem > 1/4 with only 6 peers: expect 1 onion peer and no\n+    // localhost peers (1/4 + 0) to be protected, sorted by longest uptime.\n+    BOOST_CHECK(IsProtected(\n+        6, [](NodeEvictionCandidate& c) {\n+            c.nTimeConnected = c.id;\n+            c.m_is_onion = (c.id == 4 || c.id == 5);\n+            c.m_is_local = (c.id == 3);\n+        },\n+        /* protected_peer_ids */ {0, 1, 4},\n+        /* unprotected_peer_ids */ {2, 3, 5},\n+        random_context));\n+}\n+\n+// Returns true if any of the node ids in node_ids are selected for eviction.\n+bool IsEvicted(std::vector<NodeEvictionCandidate> candidates, const std::unordered_set<NodeId>& node_ids, FastRandomContext& random_context)\n+{\n+    Shuffle(candidates.begin(), candidates.end(), random_context);\n+    const std::optional<NodeId> evicted_node_id = SelectNodeToEvict(std::move(candidates));\n+    if (!evicted_node_id) {\n+        return false;\n+    }\n+    return node_ids.count(*evicted_node_id);\n+}\n+\n+// Create number_of_nodes random nodes, apply setup function candidate_setup_fn,\n+// apply eviction logic and then return true if any of the node ids in node_ids\n+// are selected for eviction.\n+bool IsEvicted(const int number_of_nodes, std::function<void(NodeEvictionCandidate&)> candidate_setup_fn, const std::unordered_set<NodeId>& node_ids, FastRandomContext& random_context)\n+{\n+    std::vector<NodeEvictionCandidate> candidates = GetRandomNodeEvictionCandidates(number_of_nodes, random_context);\n+    for (NodeEvictionCandidate& candidate : candidates) {\n+        candidate_setup_fn(candidate);\n+    }\n+    return IsEvicted(candidates, node_ids, random_context);\n+}\n+\n+BOOST_AUTO_TEST_CASE(peer_eviction_test)\n+{\n+    FastRandomContext random_context{true};\n+\n+    for (int i = 0; i < NODE_EVICTION_TEST_ROUNDS; ++i) {\n+        for (int number_of_nodes = 0; number_of_nodes < NODE_EVICTION_TEST_UP_TO_N_NODES; ++number_of_nodes) {\n+            // Four nodes with the highest keyed netgroup values should be\n+            // protected from eviction.\n+            BOOST_CHECK(!IsEvicted(\n+                number_of_nodes, [number_of_nodes](NodeEvictionCandidate& candidate) {\n+                    candidate.nKeyedNetGroup = number_of_nodes - candidate.id;\n+                },\n+                {0, 1, 2, 3}, random_context));\n+\n+            // Eight nodes with the lowest minimum ping time should be protected\n+            // from eviction.\n+            BOOST_CHECK(!IsEvicted(\n+                number_of_nodes, [](NodeEvictionCandidate& candidate) {\n+                    candidate.m_min_ping_time = std::chrono::microseconds{candidate.id};\n+                },\n+                {0, 1, 2, 3, 4, 5, 6, 7}, random_context));\n+\n+            // Four nodes that most recently sent us novel transactions accepted\n+            // into our mempool should be protected from eviction.\n+            BOOST_CHECK(!IsEvicted(\n+                number_of_nodes, [number_of_nodes](NodeEvictionCandidate& candidate) {\n+                    candidate.nLastTXTime = number_of_nodes - candidate.id;\n+                },\n+                {0, 1, 2, 3}, random_context));\n+\n+            // Up to eight non-tx-relay peers that most recently sent us novel\n+            // blocks should be protected from eviction.\n+            BOOST_CHECK(!IsEvicted(\n+                number_of_nodes, [number_of_nodes](NodeEvictionCandidate& candidate) {\n+                    candidate.nLastBlockTime = number_of_nodes - candidate.id;\n+                    if (candidate.id <= 7) {\n+                        candidate.fRelayTxes = false;\n+                        candidate.fRelevantServices = true;\n+                    }\n+                },\n+                {0, 1, 2, 3, 4, 5, 6, 7}, random_context));\n+\n+            // Four peers that most recently sent us novel blocks should be\n+            // protected from eviction.\n+            BOOST_CHECK(!IsEvicted(\n+                number_of_nodes, [number_of_nodes](NodeEvictionCandidate& candidate) {\n+                    candidate.nLastBlockTime = number_of_nodes - candidate.id;\n+                },\n+                {0, 1, 2, 3}, random_context));\n+\n+            // Combination of the previous two tests.\n+            BOOST_CHECK(!IsEvicted(\n+                number_of_nodes, [number_of_nodes](NodeEvictionCandidate& candidate) {\n+                    candidate.nLastBlockTime = number_of_nodes - candidate.id;\n+                    if (candidate.id <= 7) {\n+                        candidate.fRelayTxes = false;\n+                        candidate.fRelevantServices = true;\n+                    }\n+                },\n+                {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}, random_context));\n+\n+            // Combination of all tests above.\n+            BOOST_CHECK(!IsEvicted(\n+                number_of_nodes, [number_of_nodes](NodeEvictionCandidate& candidate) {\n+                    candidate.nKeyedNetGroup = number_of_nodes - candidate.id;           // 4 protected\n+                    candidate.m_min_ping_time = std::chrono::microseconds{candidate.id}; // 8 protected\n+                    candidate.nLastTXTime = number_of_nodes - candidate.id;              // 4 protected\n+                    candidate.nLastBlockTime = number_of_nodes - candidate.id;           // 4 protected\n+                },\n+                {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19}, random_context));\n+\n+            // An eviction is expected given >= 29 random eviction candidates. The eviction logic protects at most\n+            // four peers by net group, eight by lowest ping time, four by last time of novel tx, up to eight non-tx-relay\n+            // peers by last novel block time, and four more peers by last novel block time.\n+            if (number_of_nodes >= 29) {\n+                BOOST_CHECK(SelectNodeToEvict(GetRandomNodeEvictionCandidates(number_of_nodes, random_context)));\n+            }\n+\n+            // No eviction is expected given <= 20 random eviction candidates. The eviction logic protects at least\n+            // four peers by net group, eight by lowest ping time, four by last time of novel tx and four peers by last\n+            // novel block time.\n+            if (number_of_nodes <= 20) {\n+                BOOST_CHECK(!SelectNodeToEvict(GetRandomNodeEvictionCandidates(number_of_nodes, random_context)));\n+            }\n+\n+            // Cases left to test:\n+            // * \"If any remaining peers are preferred for eviction consider only them. [...]\"\n+            // * \"Identify the network group with the most connections and youngest member. [...]\"\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "8eab26f3d55940b323d7bdfbe593367831ca798f",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 143,
        "changes": 197,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -396,6 +396,60 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     BOOST_CHECK(!addr.SetSpecial(\"totally bogus\"));\n }\n \n+BOOST_AUTO_TEST_CASE(cnetaddr_tostring_canonical_ipv6)\n+{\n+    // Test that CNetAddr::ToString formats IPv6 addresses with zero compression as described in\n+    // RFC 5952 (\"A Recommendation for IPv6 Address Text Representation\").\n+    const std::map<std::string, std::string> canonical_representations_ipv6{\n+        {\"0000:0000:0000:0000:0000:0000:0000:0000\", \"::\"},\n+        {\"000:0000:000:00:0:00:000:0000\", \"::\"},\n+        {\"000:000:000:000:000:000:000:000\", \"::\"},\n+        {\"00:00:00:00:00:00:00:00\", \"::\"},\n+        {\"0:0:0:0:0:0:0:0\", \"::\"},\n+        {\"0:0:0:0:0:0:0:1\", \"::1\"},\n+        {\"2001:0:0:1:0:0:0:1\", \"2001:0:0:1::1\"},\n+        {\"2001:0db8:0:0:1:0:0:1\", \"2001:db8::1:0:0:1\"},\n+        {\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"2001:db8:85a3::8a2e:370:7334\"},\n+        {\"2001:0db8::0001\", \"2001:db8::1\"},\n+        {\"2001:0db8::0001:0000\", \"2001:db8::1:0\"},\n+        {\"2001:0db8::1:0:0:1\", \"2001:db8::1:0:0:1\"},\n+        {\"2001:db8:0000:0:1::1\", \"2001:db8::1:0:0:1\"},\n+        {\"2001:db8:0000:1:1:1:1:1\", \"2001:db8:0:1:1:1:1:1\"},\n+        {\"2001:db8:0:0:0:0:2:1\", \"2001:db8::2:1\"},\n+        {\"2001:db8:0:0:0::1\", \"2001:db8::1\"},\n+        {\"2001:db8:0:0:1:0:0:1\", \"2001:db8::1:0:0:1\"},\n+        {\"2001:db8:0:0:1::1\", \"2001:db8::1:0:0:1\"},\n+        {\"2001:DB8:0:0:1::1\", \"2001:db8::1:0:0:1\"},\n+        {\"2001:db8:0:0::1\", \"2001:db8::1\"},\n+        {\"2001:db8:0:0:aaaa::1\", \"2001:db8::aaaa:0:0:1\"},\n+        {\"2001:db8:0:1:1:1:1:1\", \"2001:db8:0:1:1:1:1:1\"},\n+        {\"2001:db8:0::1\", \"2001:db8::1\"},\n+        {\"2001:db8:85a3:0:0:8a2e:370:7334\", \"2001:db8:85a3::8a2e:370:7334\"},\n+        {\"2001:db8::0:1\", \"2001:db8::1\"},\n+        {\"2001:db8::0:1:0:0:1\", \"2001:db8::1:0:0:1\"},\n+        {\"2001:DB8::1\", \"2001:db8::1\"},\n+        {\"2001:db8::1\", \"2001:db8::1\"},\n+        {\"2001:db8::1:0:0:1\", \"2001:db8::1:0:0:1\"},\n+        {\"2001:db8::1:1:1:1:1\", \"2001:db8:0:1:1:1:1:1\"},\n+        {\"2001:db8::aaaa:0:0:1\", \"2001:db8::aaaa:0:0:1\"},\n+        {\"2001:db8:aaaa:bbbb:cccc:dddd:0:1\", \"2001:db8:aaaa:bbbb:cccc:dddd:0:1\"},\n+        {\"2001:db8:aaaa:bbbb:cccc:dddd::1\", \"2001:db8:aaaa:bbbb:cccc:dddd:0:1\"},\n+        {\"2001:db8:aaaa:bbbb:cccc:dddd:eeee:0001\", \"2001:db8:aaaa:bbbb:cccc:dddd:eeee:1\"},\n+        {\"2001:db8:aaaa:bbbb:cccc:dddd:eeee:001\", \"2001:db8:aaaa:bbbb:cccc:dddd:eeee:1\"},\n+        {\"2001:db8:aaaa:bbbb:cccc:dddd:eeee:01\", \"2001:db8:aaaa:bbbb:cccc:dddd:eeee:1\"},\n+        {\"2001:db8:aaaa:bbbb:cccc:dddd:eeee:1\", \"2001:db8:aaaa:bbbb:cccc:dddd:eeee:1\"},\n+        {\"2001:db8:aaaa:bbbb:cccc:dddd:eeee:aaaa\", \"2001:db8:aaaa:bbbb:cccc:dddd:eeee:aaaa\"},\n+        {\"2001:db8:aaaa:bbbb:cccc:dddd:eeee:AAAA\", \"2001:db8:aaaa:bbbb:cccc:dddd:eeee:aaaa\"},\n+        {\"2001:db8:aaaa:bbbb:cccc:dddd:eeee:AaAa\", \"2001:db8:aaaa:bbbb:cccc:dddd:eeee:aaaa\"},\n+    };\n+    for (const auto& [input_address, expected_canonical_representation_output] : canonical_representations_ipv6) {\n+        CNetAddr net_addr;\n+        BOOST_REQUIRE(LookupHost(input_address, net_addr, false));\n+        BOOST_REQUIRE(net_addr.IsIPv6());\n+        BOOST_CHECK_EQUAL(net_addr.ToString(), expected_canonical_representation_output);\n+    }\n+}\n+\n BOOST_AUTO_TEST_CASE(cnetaddr_serialize_v1)\n {\n     CNetAddr addr;\n@@ -803,147 +857,4 @@ BOOST_AUTO_TEST_CASE(LocalAddress_BasicLifecycle)\n     BOOST_CHECK_EQUAL(IsLocal(addr), false);\n }\n \n-std::vector<NodeEvictionCandidate> GetRandomNodeEvictionCandidates(const int n_candidates, FastRandomContext& random_context)\n-{\n-    std::vector<NodeEvictionCandidate> candidates;\n-    for (int id = 0; id < n_candidates; ++id) {\n-        candidates.push_back({\n-            /* id */ id,\n-            /* nTimeConnected */ static_cast<int64_t>(random_context.randrange(100)),\n-            /* m_min_ping_time */ std::chrono::microseconds{random_context.randrange(100)},\n-            /* nLastBlockTime */ static_cast<int64_t>(random_context.randrange(100)),\n-            /* nLastTXTime */ static_cast<int64_t>(random_context.randrange(100)),\n-            /* fRelevantServices */ random_context.randbool(),\n-            /* fRelayTxes */ random_context.randbool(),\n-            /* fBloomFilter */ random_context.randbool(),\n-            /* nKeyedNetGroup */ random_context.randrange(100),\n-            /* prefer_evict */ random_context.randbool(),\n-            /* m_is_local */ random_context.randbool(),\n-        });\n-    }\n-    return candidates;\n-}\n-\n-// Returns true if any of the node ids in node_ids are selected for eviction.\n-bool IsEvicted(std::vector<NodeEvictionCandidate> candidates, const std::vector<NodeId>& node_ids, FastRandomContext& random_context)\n-{\n-    Shuffle(candidates.begin(), candidates.end(), random_context);\n-    const std::optional<NodeId> evicted_node_id = SelectNodeToEvict(std::move(candidates));\n-    if (!evicted_node_id) {\n-        return false;\n-    }\n-    return std::find(node_ids.begin(), node_ids.end(), *evicted_node_id) != node_ids.end();\n-}\n-\n-// Create number_of_nodes random nodes, apply setup function candidate_setup_fn,\n-// apply eviction logic and then return true if any of the node ids in node_ids\n-// are selected for eviction.\n-bool IsEvicted(const int number_of_nodes, std::function<void(NodeEvictionCandidate&)> candidate_setup_fn, const std::vector<NodeId>& node_ids, FastRandomContext& random_context)\n-{\n-    std::vector<NodeEvictionCandidate> candidates = GetRandomNodeEvictionCandidates(number_of_nodes, random_context);\n-    for (NodeEvictionCandidate& candidate : candidates) {\n-        candidate_setup_fn(candidate);\n-    }\n-    return IsEvicted(candidates, node_ids, random_context);\n-}\n-\n-namespace {\n-constexpr int NODE_EVICTION_TEST_ROUNDS{10};\n-constexpr int NODE_EVICTION_TEST_UP_TO_N_NODES{200};\n-} // namespace\n-\n-BOOST_AUTO_TEST_CASE(node_eviction_test)\n-{\n-    FastRandomContext random_context{true};\n-\n-    for (int i = 0; i < NODE_EVICTION_TEST_ROUNDS; ++i) {\n-        for (int number_of_nodes = 0; number_of_nodes < NODE_EVICTION_TEST_UP_TO_N_NODES; ++number_of_nodes) {\n-            // Four nodes with the highest keyed netgroup values should be\n-            // protected from eviction.\n-            BOOST_CHECK(!IsEvicted(\n-                number_of_nodes, [number_of_nodes](NodeEvictionCandidate& candidate) {\n-                    candidate.nKeyedNetGroup = number_of_nodes - candidate.id;\n-                },\n-                {0, 1, 2, 3}, random_context));\n-\n-            // Eight nodes with the lowest minimum ping time should be protected\n-            // from eviction.\n-            BOOST_CHECK(!IsEvicted(\n-                number_of_nodes, [](NodeEvictionCandidate& candidate) {\n-                    candidate.m_min_ping_time = std::chrono::microseconds{candidate.id};\n-                },\n-                {0, 1, 2, 3, 4, 5, 6, 7}, random_context));\n-\n-            // Four nodes that most recently sent us novel transactions accepted\n-            // into our mempool should be protected from eviction.\n-            BOOST_CHECK(!IsEvicted(\n-                number_of_nodes, [number_of_nodes](NodeEvictionCandidate& candidate) {\n-                    candidate.nLastTXTime = number_of_nodes - candidate.id;\n-                },\n-                {0, 1, 2, 3}, random_context));\n-\n-            // Up to eight non-tx-relay peers that most recently sent us novel\n-            // blocks should be protected from eviction.\n-            BOOST_CHECK(!IsEvicted(\n-                number_of_nodes, [number_of_nodes](NodeEvictionCandidate& candidate) {\n-                    candidate.nLastBlockTime = number_of_nodes - candidate.id;\n-                    if (candidate.id <= 7) {\n-                        candidate.fRelayTxes = false;\n-                        candidate.fRelevantServices = true;\n-                    }\n-                },\n-                {0, 1, 2, 3, 4, 5, 6, 7}, random_context));\n-\n-            // Four peers that most recently sent us novel blocks should be\n-            // protected from eviction.\n-            BOOST_CHECK(!IsEvicted(\n-                number_of_nodes, [number_of_nodes](NodeEvictionCandidate& candidate) {\n-                    candidate.nLastBlockTime = number_of_nodes - candidate.id;\n-                },\n-                {0, 1, 2, 3}, random_context));\n-\n-            // Combination of the previous two tests.\n-            BOOST_CHECK(!IsEvicted(\n-                number_of_nodes, [number_of_nodes](NodeEvictionCandidate& candidate) {\n-                    candidate.nLastBlockTime = number_of_nodes - candidate.id;\n-                    if (candidate.id <= 7) {\n-                        candidate.fRelayTxes = false;\n-                        candidate.fRelevantServices = true;\n-                    }\n-                },\n-                {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}, random_context));\n-\n-            // Combination of all tests above.\n-            BOOST_CHECK(!IsEvicted(\n-                number_of_nodes, [number_of_nodes](NodeEvictionCandidate& candidate) {\n-                    candidate.nKeyedNetGroup = number_of_nodes - candidate.id;           // 4 protected\n-                    candidate.m_min_ping_time = std::chrono::microseconds{candidate.id}; // 8 protected\n-                    candidate.nLastTXTime = number_of_nodes - candidate.id;              // 4 protected\n-                    candidate.nLastBlockTime = number_of_nodes - candidate.id;           // 4 protected\n-                },\n-                {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19}, random_context));\n-\n-            // An eviction is expected given >= 29 random eviction candidates. The eviction logic protects at most\n-            // four peers by net group, eight by lowest ping time, four by last time of novel tx, up to eight non-tx-relay\n-            // peers by last novel block time, and four more peers by last novel block time.\n-            if (number_of_nodes >= 29) {\n-                BOOST_CHECK(SelectNodeToEvict(GetRandomNodeEvictionCandidates(number_of_nodes, random_context)));\n-            }\n-\n-            // No eviction is expected given <= 20 random eviction candidates. The eviction logic protects at least\n-            // four peers by net group, eight by lowest ping time, four by last time of novel tx and four peers by last\n-            // novel block time.\n-            if (number_of_nodes <= 20) {\n-                BOOST_CHECK(!SelectNodeToEvict(GetRandomNodeEvictionCandidates(number_of_nodes, random_context)));\n-            }\n-\n-            // Cases left to test:\n-            // * \"Protect the half of the remaining nodes which have been connected the longest. [...]\"\n-            // * \"Pick out up to 1/4 peers that are localhost, sorted by longest uptime. [...]\"\n-            // * \"If any remaining peers are preferred for eviction consider only them. [...]\"\n-            // * \"Identify the network group with the most connections and youngest member. [...]\"\n-        }\n-    }\n-}\n-\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "0ec0799fbcbbeb05cb975ae851602ec449a45ed3",
        "filename": "src/test/ref_tests.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 33,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/ref_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/test/ref_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/ref_tests.cpp?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1,33 +0,0 @@\n-// Copyright (c) 2020 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <util/ref.h>\n-\n-#include <boost/test/unit_test.hpp>\n-\n-BOOST_AUTO_TEST_SUITE(ref_tests)\n-\n-BOOST_AUTO_TEST_CASE(ref_test)\n-{\n-    util::Ref ref;\n-    BOOST_CHECK(!ref.Has<int>());\n-    BOOST_CHECK_THROW(ref.Get<int>(), NonFatalCheckError);\n-    int value = 5;\n-    ref.Set(value);\n-    BOOST_CHECK(ref.Has<int>());\n-    BOOST_CHECK_EQUAL(ref.Get<int>(), 5);\n-    ++ref.Get<int>();\n-    BOOST_CHECK_EQUAL(ref.Get<int>(), 6);\n-    BOOST_CHECK_EQUAL(value, 6);\n-    ++value;\n-    BOOST_CHECK_EQUAL(value, 7);\n-    BOOST_CHECK_EQUAL(ref.Get<int>(), 7);\n-    BOOST_CHECK(!ref.Has<bool>());\n-    BOOST_CHECK_THROW(ref.Get<bool>(), NonFatalCheckError);\n-    ref.Clear();\n-    BOOST_CHECK(!ref.Has<int>());\n-    BOOST_CHECK_THROW(ref.Get<int>(), NonFatalCheckError);\n-}\n-\n-BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "67e70b3bc390dd4486c2d58fd69db3b43920649d",
        "filename": "src/test/rpc_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/rpc_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/rpc_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/rpc_tests.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -10,9 +10,10 @@\n #include <interfaces/chain.h>\n #include <node/context.h>\n #include <test/util/setup_common.h>\n-#include <util/ref.h>\n #include <util/time.h>\n \n+#include <any>\n+\n #include <boost/algorithm/string.hpp>\n #include <boost/test/unit_test.hpp>\n \n@@ -32,7 +33,7 @@ UniValue RPCTestingSetup::CallRPC(std::string args)\n     boost::split(vArgs, args, boost::is_any_of(\" \\t\"));\n     std::string strMethod = vArgs[0];\n     vArgs.erase(vArgs.begin());\n-    util::Ref context{m_node};\n+    std::any context{&m_node};\n     JSONRPCRequest request(context);\n     request.strMethod = strMethod;\n     request.params = RPCConvertValues(strMethod, vArgs);"
      },
      {
        "sha": "3fc3329da23e628a8fe0bb4537a9f25a4d3851d5",
        "filename": "src/test/util/mining.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/util/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/util/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/mining.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -41,8 +41,8 @@ CTxIn MineBlock(const NodeContext& node, const CScript& coinbase_scriptPubKey)\n std::shared_ptr<CBlock> PrepareBlock(const NodeContext& node, const CScript& coinbase_scriptPubKey)\n {\n     auto block = std::make_shared<CBlock>(\n-        BlockAssembler{*Assert(node.mempool), Params()}\n-            .CreateNewBlock(::ChainstateActive(), coinbase_scriptPubKey)\n+        BlockAssembler{::ChainstateActive(), *Assert(node.mempool), Params()}\n+            .CreateNewBlock(coinbase_scriptPubKey)\n             ->block);\n \n     LOCK(cs_main);"
      },
      {
        "sha": "2b7988413f897de1b004008ef54fecbac229c83c",
        "filename": "src/test/util/net.h",
        "status": "modified",
        "additions": 69,
        "deletions": 0,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/util/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/util/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/net.h?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -5,7 +5,13 @@\n #ifndef BITCOIN_TEST_UTIL_NET_H\n #define BITCOIN_TEST_UTIL_NET_H\n \n+#include <compat.h>\n #include <net.h>\n+#include <util/sock.h>\n+\n+#include <cassert>\n+#include <cstring>\n+#include <string>\n \n struct ConnmanTestMsg : public CConnman {\n     using CConnman::CConnman;\n@@ -61,4 +67,67 @@ constexpr ConnectionType ALL_CONNECTION_TYPES[]{\n     ConnectionType::ADDR_FETCH,\n };\n \n+/**\n+ * A mocked Sock alternative that returns a statically contained data upon read and succeeds\n+ * and ignores all writes. The data to be returned is given to the constructor and when it is\n+ * exhausted an EOF is returned by further reads.\n+ */\n+class StaticContentsSock : public Sock\n+{\n+public:\n+    explicit StaticContentsSock(const std::string& contents) : m_contents{contents}, m_consumed{0}\n+    {\n+        // Just a dummy number that is not INVALID_SOCKET.\n+        static_assert(INVALID_SOCKET != 1000);\n+        m_socket = 1000;\n+    }\n+\n+    ~StaticContentsSock() override { Reset(); }\n+\n+    StaticContentsSock& operator=(Sock&& other) override\n+    {\n+        assert(false && \"Move of Sock into MockSock not allowed.\");\n+        return *this;\n+    }\n+\n+    void Reset() override\n+    {\n+        m_socket = INVALID_SOCKET;\n+    }\n+\n+    ssize_t Send(const void*, size_t len, int) const override { return len; }\n+\n+    ssize_t Recv(void* buf, size_t len, int flags) const override\n+    {\n+        const size_t consume_bytes{std::min(len, m_contents.size() - m_consumed)};\n+        std::memcpy(buf, m_contents.data() + m_consumed, consume_bytes);\n+        if ((flags & MSG_PEEK) == 0) {\n+            m_consumed += consume_bytes;\n+        }\n+        return consume_bytes;\n+    }\n+\n+    int Connect(const sockaddr*, socklen_t) const override { return 0; }\n+\n+    int GetSockOpt(int level, int opt_name, void* opt_val, socklen_t* opt_len) const override\n+    {\n+        std::memset(opt_val, 0x0, *opt_len);\n+        return 0;\n+    }\n+\n+    bool Wait(std::chrono::milliseconds timeout,\n+              Event requested,\n+              Event* occurred = nullptr) const override\n+    {\n+        if (occurred != nullptr) {\n+            *occurred = requested;\n+        }\n+        return true;\n+    }\n+\n+private:\n+    const std::string m_contents;\n+    mutable size_t m_consumed;\n+};\n+\n #endif // BITCOIN_TEST_UTIL_NET_H"
      },
      {
        "sha": "a5852daa60288adbd9c82a4cb16496a5179b5cd3",
        "filename": "src/test/util/script.cpp",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/util/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/util/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/script.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -0,0 +1,13 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/interpreter.h>\n+#include <test/util/script.h>\n+\n+bool IsValidFlagCombination(unsigned flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}"
      },
      {
        "sha": "428b3e10b3ee6f57e5b9eb2942d4c3aa06be87d0",
        "filename": "src/test/util/script.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/util/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/util/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/script.h?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -18,4 +18,7 @@ static const CScript P2WSH_OP_TRUE{\n            return hash;\n        }())};\n \n+/** Flags that are not forbidden by an assert in script validation */\n+bool IsValidFlagCombination(unsigned flags);\n+\n #endif // BITCOIN_TEST_UTIL_SCRIPT_H"
      },
      {
        "sha": "f7800aefca526d29fedc5b7f42b968aabca154cf",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 5,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <test/util/setup_common.h>\n \n+#include <addrman.h>\n #include <banman.h>\n #include <chainparams.h>\n #include <consensus/consensus.h>\n@@ -155,6 +156,7 @@ ChainTestingSetup::~ChainTestingSetup()\n     GetMainSignals().UnregisterBackgroundSignalScheduler();\n     m_node.connman.reset();\n     m_node.banman.reset();\n+    m_node.addrman.reset();\n     m_node.args = nullptr;\n     UnloadBlockIndex(m_node.mempool.get(), *m_node.chainman);\n     m_node.mempool.reset();\n@@ -187,11 +189,12 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n         throw std::runtime_error(strprintf(\"ActivateBestChain failed. (%s)\", state.ToString()));\n     }\n \n+    m_node.addrman = std::make_unique<CAddrMan>();\n     m_node.banman = std::make_unique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n-    m_node.connman = std::make_unique<CConnman>(0x1337, 0x1337); // Deterministic randomness for tests.\n-    m_node.peerman = PeerManager::make(chainparams, *m_node.connman, m_node.banman.get(),\n-                                       *m_node.scheduler, *m_node.chainman, *m_node.mempool,\n-                                       false);\n+    m_node.connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman); // Deterministic randomness for tests.\n+    m_node.peerman = PeerManager::make(chainparams, *m_node.connman, *m_node.addrman,\n+                                       m_node.banman.get(), *m_node.scheduler, *m_node.chainman,\n+                                       *m_node.mempool, false);\n     {\n         CConnman::Options options;\n         options.m_msgproc = m_node.peerman.get();\n@@ -244,7 +247,7 @@ CBlock TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransa\n {\n     const CChainParams& chainparams = Params();\n     CTxMemPool empty_pool;\n-    CBlock block = BlockAssembler(empty_pool, chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey)->block;\n+    CBlock block = BlockAssembler(::ChainstateActive(), empty_pool, chainparams).CreateNewBlock(scriptPubKey)->block;\n \n     Assert(block.vtx.size() == 1);\n     for (const CMutableTransaction& tx : txns) {"
      },
      {
        "sha": "552be0a2da49649e667c75d9458cd510b78c3358",
        "filename": "src/test/validation_block_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/validation_block_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/test/validation_block_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_block_tests.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -63,7 +63,7 @@ std::shared_ptr<CBlock> MinerTestingSetup::Block(const uint256& prev_hash)\n     static int i = 0;\n     static uint64_t time = Params().GenesisBlock().nTime;\n \n-    auto ptemplate = BlockAssembler(*m_node.mempool, Params()).CreateNewBlock(::ChainstateActive(), CScript{} << i++ << OP_TRUE);\n+    auto ptemplate = BlockAssembler(m_node.chainman->ActiveChainstate(), *m_node.mempool, Params()).CreateNewBlock(CScript{} << i++ << OP_TRUE);\n     auto pblock = std::make_shared<CBlock>(ptemplate->block);\n     pblock->hashPrevBlock = prev_hash;\n     pblock->nTime = ++time;\n@@ -325,7 +325,7 @@ BOOST_AUTO_TEST_CASE(witness_commitment_index)\n {\n     CScript pubKey;\n     pubKey << 1 << OP_TRUE;\n-    auto ptemplate = BlockAssembler(*m_node.mempool, Params()).CreateNewBlock(::ChainstateActive(), pubKey);\n+    auto ptemplate = BlockAssembler(m_node.chainman->ActiveChainstate(), *m_node.mempool, Params()).CreateNewBlock(pubKey);\n     CBlock pblock = ptemplate->block;\n \n     CTxOut witness;"
      },
      {
        "sha": "9685ea9fec0dbedb1030768fb7fa14bd57c770c9",
        "filename": "src/util/ref.h",
        "status": "removed",
        "additions": 0,
        "deletions": 38,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cee909b883b22f8813ed9e1619e7dea28331759/src/util/ref.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cee909b883b22f8813ed9e1619e7dea28331759/src/util/ref.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/ref.h?ref=5cee909b883b22f8813ed9e1619e7dea28331759",
        "patch": "@@ -1,38 +0,0 @@\n-// Copyright (c) 2020 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_UTIL_REF_H\n-#define BITCOIN_UTIL_REF_H\n-\n-#include <util/check.h>\n-\n-#include <typeindex>\n-\n-namespace util {\n-\n-/**\n- * Type-safe dynamic reference.\n- *\n- * This implements a small subset of the functionality in C++17's std::any\n- * class, and can be dropped when the project updates to C++17\n- * (https://github.com/bitcoin/bitcoin/issues/16684)\n- */\n-class Ref\n-{\n-public:\n-    Ref() = default;\n-    template<typename T> Ref(T& value) { Set(value); }\n-    template<typename T> T& Get() const { CHECK_NONFATAL(Has<T>()); return *static_cast<T*>(m_value); }\n-    template<typename T> void Set(T& value) { m_value = &value; m_type = std::type_index(typeid(T)); }\n-    template<typename T> bool Has() const { return m_value && m_type == std::type_index(typeid(T)); }\n-    void Clear() { m_value = nullptr; m_type = std::type_index(typeid(void)); }\n-\n-private:\n-    void* m_value = nullptr;\n-    std::type_index m_type = std::type_index(typeid(void));\n-};\n-\n-} // namespace util\n-\n-#endif // BITCOIN_UTIL_REF_H"
      },
      {
        "sha": "0bc9795db3d577c4fcffc385f4c56f49a7da1054",
        "filename": "src/util/sock.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/util/sock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/util/sock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/sock.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -66,6 +66,16 @@ ssize_t Sock::Recv(void* buf, size_t len, int flags) const\n     return recv(m_socket, static_cast<char*>(buf), len, flags);\n }\n \n+int Sock::Connect(const sockaddr* addr, socklen_t addr_len) const\n+{\n+    return connect(m_socket, addr, addr_len);\n+}\n+\n+int Sock::GetSockOpt(int level, int opt_name, void* opt_val, socklen_t* opt_len) const\n+{\n+    return getsockopt(m_socket, level, opt_name, static_cast<char*>(opt_val), opt_len);\n+}\n+\n bool Sock::Wait(std::chrono::milliseconds timeout, Event requested, Event* occurred) const\n {\n #ifdef USE_POLL"
      },
      {
        "sha": "c4ad0cbc437ca8d044cf3eba3645a89e609c731c",
        "filename": "src/util/sock.h",
        "status": "modified",
        "additions": 16,
        "deletions": 3,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/util/sock.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/util/sock.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/sock.h?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -80,16 +80,29 @@ class Sock\n \n     /**\n      * send(2) wrapper. Equivalent to `send(this->Get(), data, len, flags);`. Code that uses this\n-     * wrapper can be unit-tested if this method is overridden by a mock Sock implementation.\n+     * wrapper can be unit tested if this method is overridden by a mock Sock implementation.\n      */\n     virtual ssize_t Send(const void* data, size_t len, int flags) const;\n \n     /**\n      * recv(2) wrapper. Equivalent to `recv(this->Get(), buf, len, flags);`. Code that uses this\n-     * wrapper can be unit-tested if this method is overridden by a mock Sock implementation.\n+     * wrapper can be unit tested if this method is overridden by a mock Sock implementation.\n      */\n     virtual ssize_t Recv(void* buf, size_t len, int flags) const;\n \n+    /**\n+     * connect(2) wrapper. Equivalent to `connect(this->Get(), addr, addrlen)`. Code that uses this\n+     * wrapper can be unit tested if this method is overridden by a mock Sock implementation.\n+     */\n+    virtual int Connect(const sockaddr* addr, socklen_t addr_len) const;\n+\n+    /**\n+     * getsockopt(2) wrapper. Equivalent to\n+     * `getsockopt(this->Get(), level, opt_name, opt_val, opt_len)`. Code that uses this\n+     * wrapper can be unit tested if this method is overridden by a mock Sock implementation.\n+     */\n+    virtual int GetSockOpt(int level, int opt_name, void* opt_val, socklen_t* opt_len) const;\n+\n     using Event = uint8_t;\n \n     /**\n@@ -153,7 +166,7 @@ class Sock\n      */\n     virtual bool IsConnected(std::string& errmsg) const;\n \n-private:\n+protected:\n     /**\n      * Contained socket. `INVALID_SOCKET` designates the object is empty.\n      */"
      },
      {
        "sha": "29657e56e2491466d101fe653982b61eb3b5b007",
        "filename": "src/util/system.h",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/util/system.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/util/system.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/system.h?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -25,6 +25,7 @@\n #include <util/threadnames.h>\n #include <util/time.h>\n \n+#include <any>\n #include <exception>\n #include <map>\n #include <optional>\n@@ -500,6 +501,18 @@ inline void insert(std::set<TsetT>& dst, const Tsrc& src) {\n     dst.insert(src.begin(), src.end());\n }\n \n+/**\n+ * Helper function to access the contained object of a std::any instance.\n+ * Returns a pointer to the object if passed instance has a value and the type\n+ * matches, nullptr otherwise.\n+ */\n+template<typename T>\n+T* AnyPtr(const std::any& any) noexcept\n+{\n+    T* const* ptr = std::any_cast<T*>(&any);\n+    return ptr ? *ptr : nullptr;\n+}\n+\n #ifdef WIN32\n class WinCmdLineArgs\n {"
      },
      {
        "sha": "b5c19971b400e342312b08e7fc724136e3a85246",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -169,7 +169,7 @@ namespace {\n     std::set<int> setDirtyFileInfo;\n } // anon namespace\n \n-CBlockIndex* BlockManager::LookupBlockIndex(const uint256& hash)\n+CBlockIndex* BlockManager::LookupBlockIndex(const uint256& hash) const\n {\n     AssertLockHeld(cs_main);\n     assert(std::addressof(g_chainman.BlockIndex()) == std::addressof(m_block_index));"
      },
      {
        "sha": "21e63947fae95cbfa18186d1a5149252cfa11c3d",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -457,7 +457,7 @@ class BlockManager\n         const CChainParams& chainparams,\n         CBlockIndex** ppindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-    CBlockIndex* LookupBlockIndex(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    CBlockIndex* LookupBlockIndex(const uint256& hash) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     /** Find the last common block between the parameter chain and a locator. */\n     CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator) EXCLUSIVE_LOCKS_REQUIRED(cs_main);"
      },
      {
        "sha": "da5b84ce838e114fe997b9dc9ce9221e69f60718",
        "filename": "src/wallet/interfaces.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/wallet/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/wallet/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/interfaces.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -15,7 +15,6 @@\n #include <sync.h>\n #include <uint256.h>\n #include <util/check.h>\n-#include <util/ref.h>\n #include <util/system.h>\n #include <util/ui_change_type.h>\n #include <wallet/context.h>\n@@ -515,7 +514,7 @@ class WalletClientImpl : public WalletClient\n     {\n         for (const CRPCCommand& command : GetWalletRPCCommands()) {\n             m_rpc_commands.emplace_back(command.category, command.name, [this, &command](const JSONRPCRequest& request, UniValue& result, bool last_handler) {\n-                return command.actor({request, m_context}, result, last_handler);\n+                return command.actor({request, &m_context}, result, last_handler);\n             }, command.argNames, command.unique_id);\n             m_rpc_handlers.emplace_back(m_context.chain->handleRpc(m_rpc_commands.back()));\n         }"
      },
      {
        "sha": "df26f039a0805be5220b7459bc0fafa54a90498b",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -22,7 +22,6 @@\n #include <util/fees.h>\n #include <util/message.h> // For MessageSign()\n #include <util/moneystr.h>\n-#include <util/ref.h>\n #include <util/string.h>\n #include <util/system.h>\n #include <util/translation.h>\n@@ -124,12 +123,13 @@ void EnsureWalletIsUnlocked(const CWallet& wallet)\n     }\n }\n \n-WalletContext& EnsureWalletContext(const util::Ref& context)\n+WalletContext& EnsureWalletContext(const std::any& context)\n {\n-    if (!context.Has<WalletContext>()) {\n+    auto wallet_context = util::AnyPtr<WalletContext>(context);\n+    if (!wallet_context) {\n         throw JSONRPCError(RPC_INTERNAL_ERROR, \"Wallet context not found\");\n     }\n-    return context.Get<WalletContext>();\n+    return *wallet_context;\n }\n \n // also_create should only be set to true only when the RPC is expected to add things to a blank wallet and make it no longer blank\n@@ -1741,7 +1741,7 @@ static RPCHelpMan gettransaction()\n \n     if (verbose) {\n         UniValue decoded(UniValue::VOBJ);\n-        TxToUniv(*wtx.tx, uint256(), decoded, false);\n+        TxToUniv(*wtx.tx, uint256(), pwallet->chain().rpcEnableDeprecated(\"addresses\"), decoded, false);\n         entry.pushKV(\"decoded\", decoded);\n     }\n \n@@ -3379,7 +3379,7 @@ RPCHelpMan signrawtransactionwithwallet()\n \n static RPCHelpMan bumpfee_helper(std::string method_name)\n {\n-    bool want_psbt = method_name == \"psbtbumpfee\";\n+    const bool want_psbt = method_name == \"psbtbumpfee\";\n     const std::string incremental_fee{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE).ToString(FeeEstimateMode::SAT_VB)};\n \n     return RPCHelpMan{method_name,\n@@ -3413,14 +3413,14 @@ static RPCHelpMan bumpfee_helper(std::string method_name)\n                              \"still be replaceable in practice, for example if it has unconfirmed ancestors which\\n\"\n                              \"are replaceable).\\n\"},\n                     {\"estimate_mode\", RPCArg::Type::STR, /* default */ \"unset\", std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n-    \"         \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+                             \"\\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n                 },\n                 \"options\"},\n         },\n         RPCResult{\n             RPCResult::Type::OBJ, \"\", \"\", Cat(Cat<std::vector<RPCResult>>(\n             {\n-                {RPCResult::Type::STR, \"psbt\", \"The base64-encoded unsigned PSBT of the new transaction.\" + std::string(want_psbt ? \"\" : \" Only returned when wallet private keys are disabled. (DEPRECATED)\")},\n+                {RPCResult::Type::STR, \"psbt\", \"The base64-encoded unsigned PSBT of the new transaction.\"},\n             },\n             want_psbt ? std::vector<RPCResult>{} : std::vector<RPCResult>{{RPCResult::Type::STR_HEX, \"txid\", \"The id of the new transaction. Only returned when wallet private keys are enabled.\"}}\n             ),\n@@ -3437,7 +3437,7 @@ static RPCHelpMan bumpfee_helper(std::string method_name)\n     \"\\nBump the fee, get the new transaction\\'s\" + std::string(want_psbt ? \"psbt\" : \"txid\") + \"\\n\" +\n             HelpExampleCli(method_name, \"<txid>\")\n         },\n-        [want_psbt](const RPCHelpMan& self, const JSONRPCRequest& request) mutable -> UniValue\n+        [want_psbt](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n     std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n     if (!pwallet) return NullUniValue;"
      },
      {
        "sha": "8b88ffe8eda4587a773f40c0bbd645f1b6c3b5f5",
        "filename": "src/wallet/rpcwallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/wallet/rpcwallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/wallet/rpcwallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.h?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -7,6 +7,7 @@\n \n #include <span.h>\n \n+#include <any>\n #include <memory>\n #include <string>\n #include <vector>\n@@ -31,7 +32,7 @@ Span<const CRPCCommand> GetWalletRPCCommands();\n std::shared_ptr<CWallet> GetWalletForJSONRPCRequest(const JSONRPCRequest& request);\n \n void EnsureWalletIsUnlocked(const CWallet&);\n-WalletContext& EnsureWalletContext(const util::Ref& context);\n+WalletContext& EnsureWalletContext(const std::any& context);\n LegacyScriptPubKeyMan& EnsureLegacyScriptPubKeyMan(CWallet& wallet, bool also_create = false);\n \n RPCHelpMan getaddressinfo();"
      },
      {
        "sha": "ba2e17d62aca97eabec1814758f0c2e89829bfd0",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <wallet/wallet.h>\n \n+#include <any>\n #include <future>\n #include <memory>\n #include <stdint.h>\n@@ -15,7 +16,6 @@\n #include <rpc/server.h>\n #include <test/util/logging.h>\n #include <test/util/setup_common.h>\n-#include <util/ref.h>\n #include <util/translation.h>\n #include <validation.h>\n #include <wallet/coincontrol.h>\n@@ -213,7 +213,7 @@ BOOST_FIXTURE_TEST_CASE(importmulti_rescan, TestChain100Setup)\n         key.pushKV(\"timestamp\", newTip->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1);\n         key.pushKV(\"internal\", UniValue(true));\n         keys.push_back(key);\n-        util::Ref context;\n+        std::any context;\n         JSONRPCRequest request(context);\n         request.params.setArray();\n         request.params.push_back(keys);\n@@ -265,7 +265,7 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n             AddWallet(wallet);\n             wallet->SetLastBlockProcessed(::ChainActive().Height(), ::ChainActive().Tip()->GetBlockHash());\n         }\n-        util::Ref context;\n+        std::any context;\n         JSONRPCRequest request(context);\n         request.params.setArray();\n         request.params.push_back(backup_file);\n@@ -281,7 +281,7 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n         LOCK(wallet->cs_wallet);\n         wallet->SetupLegacyScriptPubKeyMan();\n \n-        util::Ref context;\n+        std::any context;\n         JSONRPCRequest request(context);\n         request.params.setArray();\n         request.params.push_back(backup_file);"
      },
      {
        "sha": "c7981d31dc984b0e683d71444818ca53f5e75e42",
        "filename": "test/functional/feature_nulldummy.py",
        "status": "modified",
        "additions": 16,
        "deletions": 14,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/feature_nulldummy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/feature_nulldummy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_nulldummy.py?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -6,11 +6,11 @@\n \n Connect to a single node.\n Generate 2 blocks (save the coinbases for later).\n-Generate 427 more blocks.\n-[Policy/Consensus] Check that NULLDUMMY compliant transactions are accepted in the 430th block.\n+Generate COINBASE_MATURITY (CB) more blocks to ensure the coinbases are mature.\n+[Policy/Consensus] Check that NULLDUMMY compliant transactions are accepted in block CB + 3.\n [Policy] Check that non-NULLDUMMY transactions are rejected before activation.\n-[Consensus] Check that the new NULLDUMMY rules are not enforced on the 431st block.\n-[Policy/Consensus] Check that the new NULLDUMMY rules are enforced on the 432nd block.\n+[Consensus] Check that the new NULLDUMMY rules are not enforced on block CB + 4.\n+[Policy/Consensus] Check that the new NULLDUMMY rules are enforced on block CB + 5.\n \"\"\"\n import time\n \n@@ -20,13 +20,14 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, assert_raises_rpc_error\n \n+COINBASE_MATURITY = 100\n NULLDUMMY_ERROR = \"non-mandatory-script-verify-flag (Dummy CHECKMULTISIG argument must be zero)\"\n \n def trueDummy(tx):\n     scriptSig = CScript(tx.vin[0].scriptSig)\n     newscript = []\n     for i in scriptSig:\n-        if (len(newscript) == 0):\n+        if len(newscript) == 0:\n             assert len(i) == 0\n             newscript.append(b'\\x51')\n         else:\n@@ -37,13 +38,13 @@ def trueDummy(tx):\n class NULLDUMMYTest(BitcoinTestFramework):\n \n     def set_test_params(self):\n-        # Need two nodes only so GBT doesn't complain that it's not connected\n+        # Need two nodes so GBT (getblocktemplate) doesn't complain that it's not connected.\n         self.num_nodes = 2\n         self.setup_clean_chain = True\n         # This script tests NULLDUMMY activation, which is part of the 'segwit' deployment, so we go through\n         # normal segwit activation here (and don't use the default always-on behaviour).\n         self.extra_args = [[\n-            '-segwitheight=432',\n+            f'-segwitheight={COINBASE_MATURITY + 5}',\n             '-addresstype=legacy',\n         ]] * 2\n \n@@ -64,16 +65,16 @@ def run_test(self):\n             wmulti.importaddress(self.ms_address)\n             wmulti.importaddress(self.wit_ms_address)\n \n-        self.coinbase_blocks = self.nodes[0].generate(2)  # Block 2\n+        self.coinbase_blocks = self.nodes[0].generate(2)  # block height = 2\n         coinbase_txid = []\n         for i in self.coinbase_blocks:\n             coinbase_txid.append(self.nodes[0].getblock(i)['tx'][0])\n-        self.nodes[0].generate(427)  # Block 429\n+        self.nodes[0].generate(COINBASE_MATURITY)  # block height = COINBASE_MATURITY + 2\n         self.lastblockhash = self.nodes[0].getbestblockhash()\n-        self.lastblockheight = 429\n-        self.lastblocktime = int(time.time()) + 429\n+        self.lastblockheight = COINBASE_MATURITY + 2\n+        self.lastblocktime = int(time.time()) + self.lastblockheight\n \n-        self.log.info(\"Test 1: NULLDUMMY compliant base transactions should be accepted to mempool and mined before activation [430]\")\n+        self.log.info(f\"Test 1: NULLDUMMY compliant base transactions should be accepted to mempool and mined before activation [{COINBASE_MATURITY + 3}]\")\n         test1txs = [create_transaction(self.nodes[0], coinbase_txid[0], self.ms_address, amount=49)]\n         txid1 = self.nodes[0].sendrawtransaction(test1txs[0].serialize_with_witness().hex(), 0)\n         test1txs.append(create_transaction(self.nodes[0], txid1, self.ms_address, amount=48))\n@@ -87,7 +88,7 @@ def run_test(self):\n         trueDummy(test2tx)\n         assert_raises_rpc_error(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, test2tx.serialize_with_witness().hex(), 0)\n \n-        self.log.info(\"Test 3: Non-NULLDUMMY base transactions should be accepted in a block before activation [431]\")\n+        self.log.info(f\"Test 3: Non-NULLDUMMY base transactions should be accepted in a block before activation [{COINBASE_MATURITY + 4}]\")\n         self.block_submit(self.nodes[0], [test2tx], False, True)\n \n         self.log.info(\"Test 4: Non-NULLDUMMY base multisig transaction is invalid after activation\")\n@@ -104,7 +105,7 @@ def run_test(self):\n         assert_raises_rpc_error(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, test5tx.serialize_with_witness().hex(), 0)\n         self.block_submit(self.nodes[0], [test5tx], True)\n \n-        self.log.info(\"Test 6: NULLDUMMY compliant base/witness transactions should be accepted to mempool and in block after activation [432]\")\n+        self.log.info(f\"Test 6: NULLDUMMY compliant base/witness transactions should be accepted to mempool and in block after activation [{COINBASE_MATURITY + 5}]\")\n         for i in test6txs:\n             self.nodes[0].sendrawtransaction(i.serialize_with_witness().hex(), 0)\n         self.block_submit(self.nodes[0], test6txs, True, True)\n@@ -130,5 +131,6 @@ def block_submit(self, node, txs, witness=False, accept=False):\n         else:\n             assert_equal(node.getbestblockhash(), self.lastblockhash)\n \n+\n if __name__ == '__main__':\n     NULLDUMMYTest().main()"
      },
      {
        "sha": "945880cc3b8ed76d1aae434e254e26381f302fe4",
        "filename": "test/functional/feature_rbf.py",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/feature_rbf.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/feature_rbf.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_rbf.py?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -33,12 +33,7 @@ def make_utxo(node, amount, confirmed=True, scriptPubKey=DUMMY_P2WPKH_SCRIPT):\n     txid = node.sendtoaddress(new_addr, satoshi_round((amount+fee)/COIN))\n     tx1 = node.getrawtransaction(txid, 1)\n     txid = int(txid, 16)\n-    i = None\n-\n-    for i, txout in enumerate(tx1['vout']):\n-        if txout['scriptPubKey']['addresses'] == [new_addr]:\n-            break\n-    assert i is not None\n+    i, _ = next(filter(lambda vout: new_addr == vout[1]['scriptPubKey']['address'], enumerate(tx1['vout'])))\n \n     tx2 = CTransaction()\n     tx2.vin = [CTxIn(COutPoint(txid, i))]"
      },
      {
        "sha": "ad8767556b98c298ff9e2e2e78143967aa13ab3f",
        "filename": "test/functional/feature_segwit.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/feature_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/feature_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_segwit.py?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -523,7 +523,7 @@ def run_test(self):\n         v1_addr = program_to_witness(1, [3, 5])\n         v1_tx = self.nodes[0].createrawtransaction([getutxo(spendable_txid[0])], {v1_addr: 1})\n         v1_decoded = self.nodes[1].decoderawtransaction(v1_tx)\n-        assert_equal(v1_decoded['vout'][0]['scriptPubKey']['addresses'][0], v1_addr)\n+        assert_equal(v1_decoded['vout'][0]['scriptPubKey']['address'], v1_addr)\n         assert_equal(v1_decoded['vout'][0]['scriptPubKey']['hex'], \"51020305\")\n \n         # Check that spendable outputs are really spendable"
      },
      {
        "sha": "884a2fef11b49fd21b95010ffdb0cab202505b0a",
        "filename": "test/functional/mempool_package_onemore.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/mempool_package_onemore.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/mempool_package_onemore.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_package_onemore.py?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -80,7 +80,7 @@ def run_test(self):\n         self.chain_transaction(self.nodes[0], [second_chain], [0], second_chain_value, fee, 1)\n \n         # Make sure we can RBF the chain which used our carve-out rule\n-        second_tx_outputs = {self.nodes[0].getrawtransaction(replacable_txid, True)[\"vout\"][0]['scriptPubKey']['addresses'][0]: replacable_orig_value - (Decimal(1) / Decimal(100))}\n+        second_tx_outputs = {self.nodes[0].getrawtransaction(replacable_txid, True)[\"vout\"][0]['scriptPubKey']['address']: replacable_orig_value - (Decimal(1) / Decimal(100))}\n         second_tx = self.nodes[0].createrawtransaction([{'txid': chain[0][0], 'vout': 1}], second_tx_outputs)\n         signed_second_tx = self.nodes[0].signrawtransactionwithwallet(second_tx)\n         self.nodes[0].sendrawtransaction(signed_second_tx['hex'])"
      },
      {
        "sha": "52dc4de3bd1293b4ce01a9e6f895f10725f8474b",
        "filename": "test/functional/p2p_feefilter.py",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/p2p_feefilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/p2p_feefilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_feefilter.py?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -61,6 +61,7 @@ def set_test_params(self):\n     def run_test(self):\n         self.test_feefilter_forcerelay()\n         self.test_feefilter()\n+        self.test_feefilter_blocksonly()\n \n     def test_feefilter_forcerelay(self):\n         self.log.info('Check that peers without forcerelay permission (default) get a feefilter message')\n@@ -119,6 +120,19 @@ def test_feefilter(self):\n         conn.wait_for_invs_to_match(txids)\n         conn.clear_invs()\n \n+    def test_feefilter_blocksonly(self):\n+        \"\"\"Test that we don't send fee filters to block-relay-only peers and when we're in blocksonly mode.\"\"\"\n+        self.log.info(\"Check that we don't send fee filters to block-relay-only peers.\")\n+        feefilter_peer = self.nodes[0].add_outbound_p2p_connection(FeefilterConn(), p2p_idx=0, connection_type=\"block-relay-only\")\n+        feefilter_peer.sync_with_ping()\n+        feefilter_peer.assert_feefilter_received(False)\n+\n+        self.log.info(\"Check that we don't send fee filters when in blocksonly mode.\")\n+        self.restart_node(0, [\"-blocksonly\"])\n+        feefilter_peer = self.nodes[0].add_p2p_connection(FeefilterConn())\n+        feefilter_peer.sync_with_ping()\n+        feefilter_peer.assert_feefilter_received(False)\n+\n \n if __name__ == '__main__':\n     FeeFilterTest().main()"
      },
      {
        "sha": "4bee33f8250a6dfaa919337c09e139520bf8292d",
        "filename": "test/functional/p2p_filter.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/p2p_filter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/p2p_filter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_filter.py?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -130,7 +130,7 @@ def test_msg_mempool(self):\n         filter_peer = P2PBloomFilter()\n \n         self.log.debug(\"Create a tx relevant to the peer before connecting\")\n-        filter_address = self.nodes[0].decodescript(filter_peer.watch_script_pubkey)['addresses'][0]\n+        filter_address = self.nodes[0].decodescript(filter_peer.watch_script_pubkey)['address']\n         txid = self.nodes[0].sendtoaddress(filter_address, 90)\n \n         self.log.debug(\"Send a mempool msg after connecting and check that the tx is received\")\n@@ -142,7 +142,7 @@ def test_msg_mempool(self):\n     def test_frelay_false(self, filter_peer):\n         self.log.info(\"Check that a node with fRelay set to false does not receive invs until the filter is set\")\n         filter_peer.tx_received = False\n-        filter_address = self.nodes[0].decodescript(filter_peer.watch_script_pubkey)['addresses'][0]\n+        filter_address = self.nodes[0].decodescript(filter_peer.watch_script_pubkey)['address']\n         self.nodes[0].sendtoaddress(filter_address, 90)\n         # Sync to make sure the reason filter_peer doesn't receive the tx is not p2p delays\n         filter_peer.sync_with_ping()\n@@ -156,7 +156,7 @@ def test_filter(self, filter_peer):\n         filter_peer.send_and_ping(filter_peer.watch_filter_init)\n         # If fRelay is not already True, sending filterload sets it to True\n         assert self.nodes[0].getpeerinfo()[0]['relaytxes']\n-        filter_address = self.nodes[0].decodescript(filter_peer.watch_script_pubkey)['addresses'][0]\n+        filter_address = self.nodes[0].decodescript(filter_peer.watch_script_pubkey)['address']\n \n         self.log.info('Check that we receive merkleblock and tx if the filter matches a tx in a block')\n         block_hash = self.nodes[0].generatetoaddress(1, filter_address)[0]"
      },
      {
        "sha": "bc0559f3b542fcd8fa76c39a56e3e8ebec9bb105",
        "filename": "test/functional/rpc_addresses_deprecation.py",
        "status": "added",
        "additions": 58,
        "deletions": 0,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/rpc_addresses_deprecation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/rpc_addresses_deprecation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_addresses_deprecation.py?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -0,0 +1,58 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test deprecation of reqSigs and addresses RPC fields.\"\"\"\n+\n+from io import BytesIO\n+\n+from test_framework.messages import CTransaction\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    hex_str_to_bytes\n+)\n+\n+\n+class AddressesDeprecationTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[], [\"-deprecatedrpc=addresses\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_addresses_deprecation()\n+\n+    def test_addresses_deprecation(self):\n+        node = self.nodes[0]\n+        coin = node.listunspent().pop()\n+\n+        inputs = [{'txid': coin['txid'], 'vout': coin['vout']}]\n+        outputs = {node.getnewaddress(): 0.99}\n+        raw = node.createrawtransaction(inputs, outputs)\n+        signed = node.signrawtransactionwithwallet(raw)['hex']\n+\n+        # This transaction is derived from test/util/data/txcreatemultisig1.json\n+        tx = CTransaction()\n+        tx.deserialize(BytesIO(hex_str_to_bytes(signed)))\n+        tx.vout[0].scriptPubKey = hex_str_to_bytes(\"522102a5613bd857b7048924264d1e70e08fb2a7e6527d32b7ab1bb993ac59964ff39721021ac43c7ff740014c3b33737ede99c967e4764553d1b2b83db77c83b8715fa72d2102df2089105c77f266fa11a9d33f05c735234075f2e8780824c6b709415f9fb48553ae\")\n+        tx_signed = node.signrawtransactionwithwallet(tx.serialize().hex())['hex']\n+        txid = node.sendrawtransaction(hexstring=tx_signed, maxfeerate=0)\n+\n+        self.log.info(\"Test RPCResult scriptPubKey no longer returns the fields addresses or reqSigs by default\")\n+        hash = node.generateblock(output=node.getnewaddress(), transactions=[txid])['hash']\n+        # Ensure both nodes have the newly generated block on disk.\n+        self.sync_blocks()\n+        script_pub_key = node.getblock(blockhash=hash, verbose=2)['tx'][-1]['vout'][0]['scriptPubKey']\n+        assert 'addresses' not in script_pub_key and 'reqSigs' not in script_pub_key\n+\n+        self.log.info(\"Test RPCResult scriptPubKey returns the addresses field with -deprecatedrpc=addresses\")\n+        script_pub_key = self.nodes[1].getblock(blockhash=hash, verbose=2)['tx'][-1]['vout'][0]['scriptPubKey']\n+        assert_equal(script_pub_key['addresses'], ['mvKDK6D54HU8wQumJBLHY95eq5iHFqXSBz', 'mv3rHCQSwKp2BLSuMHD8uCS32LW5xiNAA5', 'mirrsyhAQYzo5CwVhcaYJKwUJu1WJRCRJe'])\n+        assert_equal(script_pub_key['reqSigs'], 2)\n+\n+\n+if __name__ == \"__main__\":\n+    AddressesDeprecationTest().main()"
      },
      {
        "sha": "19f0d5765a15bc9817fccc9e819adaec08d12e43",
        "filename": "test/functional/rpc_createmultisig.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/rpc_createmultisig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/rpc_createmultisig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_createmultisig.py?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -165,7 +165,7 @@ def do_multisig(self):\n         txid = node0.sendtoaddress(madd, 40)\n \n         tx = node0.getrawtransaction(txid, True)\n-        vout = [v[\"n\"] for v in tx[\"vout\"] if madd in v[\"scriptPubKey\"].get(\"addresses\", [])]\n+        vout = [v[\"n\"] for v in tx[\"vout\"] if madd == v[\"scriptPubKey\"][\"address\"]]\n         assert len(vout) == 1\n         vout = vout[0]\n         scriptPubKey = tx[\"vout\"][vout][\"scriptPubKey\"][\"hex\"]"
      },
      {
        "sha": "5129ecb8956ecd7d5c396f27cec5870feb817a5a",
        "filename": "test/functional/rpc_fundrawtransaction.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/rpc_fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/rpc_fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_fundrawtransaction.py?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -248,7 +248,7 @@ def test_valid_change_address(self):\n         rawtxfund = self.nodes[2].fundrawtransaction(rawtx, {'changeAddress': change, 'changePosition': 0})\n         dec_tx  = self.nodes[2].decoderawtransaction(rawtxfund['hex'])\n         out = dec_tx['vout'][0]\n-        assert_equal(change, out['scriptPubKey']['addresses'][0])\n+        assert_equal(change, out['scriptPubKey']['address'])\n \n     def test_change_type(self):\n         self.log.info(\"Test fundrawtxn with a provided change type\")\n@@ -288,7 +288,7 @@ def test_coin_selection(self):\n         matchingOuts = 0\n         for i, out in enumerate(dec_tx['vout']):\n             totalOut += out['value']\n-            if out['scriptPubKey']['addresses'][0] in outputs:\n+            if out['scriptPubKey']['address'] in outputs:\n                 matchingOuts+=1\n             else:\n                 assert_equal(i, rawtxfund['changepos'])\n@@ -319,7 +319,7 @@ def test_two_vin(self):\n         matchingOuts = 0\n         for out in dec_tx['vout']:\n             totalOut += out['value']\n-            if out['scriptPubKey']['addresses'][0] in outputs:\n+            if out['scriptPubKey']['address'] in outputs:\n                 matchingOuts+=1\n \n         assert_equal(matchingOuts, 1)\n@@ -353,7 +353,7 @@ def test_two_vin_two_vout(self):\n         matchingOuts = 0\n         for out in dec_tx['vout']:\n             totalOut += out['value']\n-            if out['scriptPubKey']['addresses'][0] in outputs:\n+            if out['scriptPubKey']['address'] in outputs:\n                 matchingOuts+=1\n \n         assert_equal(matchingOuts, 2)\n@@ -802,7 +802,7 @@ def test_address_reuse(self):\n         changeaddress = \"\"\n         for out in res_dec['vout']:\n             if out['value'] > 1.0:\n-                changeaddress += out['scriptPubKey']['addresses'][0]\n+                changeaddress += out['scriptPubKey']['address']\n         assert changeaddress != \"\"\n         nextaddr = self.nodes[3].getnewaddress()\n         # Now the change address key should be removed from the keypool."
      },
      {
        "sha": "742441648442923e7eb89c69a4be4f6392649ae9",
        "filename": "test/functional/rpc_generateblock.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/rpc_generateblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/rpc_generateblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_generateblock.py?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -27,29 +27,29 @@ def run_test(self):\n         hash = node.generateblock(output=address, transactions=[])['hash']\n         block = node.getblock(blockhash=hash, verbose=2)\n         assert_equal(len(block['tx']), 1)\n-        assert_equal(block['tx'][0]['vout'][0]['scriptPubKey']['addresses'][0], address)\n+        assert_equal(block['tx'][0]['vout'][0]['scriptPubKey']['address'], address)\n \n         self.log.info('Generate an empty block to a descriptor')\n         hash = node.generateblock('addr(' + address + ')', [])['hash']\n         block = node.getblock(blockhash=hash, verbosity=2)\n         assert_equal(len(block['tx']), 1)\n-        assert_equal(block['tx'][0]['vout'][0]['scriptPubKey']['addresses'][0], address)\n+        assert_equal(block['tx'][0]['vout'][0]['scriptPubKey']['address'], address)\n \n         self.log.info('Generate an empty block to a combo descriptor with compressed pubkey')\n         combo_key = '0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'\n         combo_address = 'bcrt1qw508d6qejxtdg4y5r3zarvary0c5xw7kygt080'\n         hash = node.generateblock('combo(' + combo_key + ')', [])['hash']\n         block = node.getblock(hash, 2)\n         assert_equal(len(block['tx']), 1)\n-        assert_equal(block['tx'][0]['vout'][0]['scriptPubKey']['addresses'][0], combo_address)\n+        assert_equal(block['tx'][0]['vout'][0]['scriptPubKey']['address'], combo_address)\n \n         self.log.info('Generate an empty block to a combo descriptor with uncompressed pubkey')\n         combo_key = '0408ef68c46d20596cc3f6ddf7c8794f71913add807f1dc55949fa805d764d191c0b7ce6894c126fce0babc6663042f3dde9b0cf76467ea315514e5a6731149c67'\n         combo_address = 'mkc9STceoCcjoXEXe6cm66iJbmjM6zR9B2'\n         hash = node.generateblock('combo(' + combo_key + ')', [])['hash']\n         block = node.getblock(hash, 2)\n         assert_equal(len(block['tx']), 1)\n-        assert_equal(block['tx'][0]['vout'][0]['scriptPubKey']['addresses'][0], combo_address)\n+        assert_equal(block['tx'][0]['vout'][0]['scriptPubKey']['address'], combo_address)\n \n         # Generate 110 blocks to spend\n         node.generatetoaddress(110, address)"
      },
      {
        "sha": "079a3bd3baafabb0948e248f024898c35eacf64f",
        "filename": "test/functional/rpc_psbt.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/rpc_psbt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/rpc_psbt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_psbt.py?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -158,17 +158,17 @@ def run_test(self):\n         p2sh_p2wpkh_pos = -1\n         decoded = self.nodes[0].decoderawtransaction(signed_tx)\n         for out in decoded['vout']:\n-            if out['scriptPubKey']['addresses'][0] == p2sh:\n+            if out['scriptPubKey']['address'] == p2sh:\n                 p2sh_pos = out['n']\n-            elif out['scriptPubKey']['addresses'][0] == p2wsh:\n+            elif out['scriptPubKey']['address'] == p2wsh:\n                 p2wsh_pos = out['n']\n-            elif out['scriptPubKey']['addresses'][0] == p2wpkh:\n+            elif out['scriptPubKey']['address'] == p2wpkh:\n                 p2wpkh_pos = out['n']\n-            elif out['scriptPubKey']['addresses'][0] == p2sh_p2wsh:\n+            elif out['scriptPubKey']['address'] == p2sh_p2wsh:\n                 p2sh_p2wsh_pos = out['n']\n-            elif out['scriptPubKey']['addresses'][0] == p2sh_p2wpkh:\n+            elif out['scriptPubKey']['address'] == p2sh_p2wpkh:\n                 p2sh_p2wpkh_pos = out['n']\n-            elif out['scriptPubKey']['addresses'][0] == p2pkh:\n+            elif out['scriptPubKey']['address'] == p2pkh:\n                 p2pkh_pos = out['n']\n \n         inputs = [{\"txid\": txid, \"vout\": p2wpkh_pos}, {\"txid\": txid, \"vout\": p2sh_p2wpkh_pos}, {\"txid\": txid, \"vout\": p2pkh_pos}]"
      },
      {
        "sha": "5c774934be4630c897634636e138447a37983df5",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -543,7 +543,7 @@ def find_vout_for_address(node, txid, addr):\n     \"\"\"\n     tx = node.getrawtransaction(txid, True)\n     for i in range(len(tx[\"vout\"])):\n-        if any([addr == a for a in tx[\"vout\"][i][\"scriptPubKey\"][\"addresses\"]]):\n+        if addr == tx[\"vout\"][i][\"scriptPubKey\"][\"address\"]:\n             return i\n     raise RuntimeError(\"Vout not found for address: txid=%s, addr=%s\" % (txid, addr))\n "
      },
      {
        "sha": "001d161612e3086bb889fc37c2ac944506951e18",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -287,6 +287,7 @@\n     'feature_config_args.py',\n     'feature_settings.py',\n     'rpc_getdescriptorinfo.py',\n+    'rpc_addresses_deprecation.py',\n     'rpc_help.py',\n     'feature_help.py',\n     'feature_shutdown.py',"
      },
      {
        "sha": "b3bee1876d218e8ebb76fb1998c2e7b7fa04f1f0",
        "filename": "test/functional/wallet_address_types.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/wallet_address_types.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/wallet_address_types.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_address_types.py?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -210,7 +210,7 @@ def test_change_output_type(self, node_sender, destinations, expected_type):\n         assert_equal(len(tx[\"vout\"]), len(destinations) + 1)\n \n         # Make sure the destinations are included, and remove them:\n-        output_addresses = [vout['scriptPubKey']['addresses'][0] for vout in tx[\"vout\"]]\n+        output_addresses = [vout['scriptPubKey']['address'] for vout in tx[\"vout\"]]\n         change_addresses = [d for d in output_addresses if d not in destinations]\n         assert_equal(len(change_addresses), 1)\n "
      },
      {
        "sha": "1d3736d9b1a5d1ce27e74a97c66046021c1a17c5",
        "filename": "test/functional/wallet_avoidreuse.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/wallet_avoidreuse.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/wallet_avoidreuse.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_avoidreuse.py?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -253,7 +253,7 @@ def test_sending_from_reused_address_fails(self, second_addr_type):\n             if second_addr_type == \"p2sh-segwit\":\n                 new_fundaddr = fund_decoded[\"segwit\"][\"p2sh-segwit\"]\n             elif second_addr_type == \"bech32\":\n-                new_fundaddr = fund_decoded[\"segwit\"][\"addresses\"][0]\n+                new_fundaddr = fund_decoded[\"segwit\"][\"address\"]\n             else:\n                 new_fundaddr = fundaddr\n                 assert_equal(second_addr_type, \"legacy\")"
      },
      {
        "sha": "dc6f8ed9c43f28ac618d19b08c234f1abcd2886d",
        "filename": "test/functional/wallet_basic.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/wallet_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/wallet_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_basic.py?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -600,7 +600,7 @@ def run_test(self):\n         destination = self.nodes[1].getnewaddress()\n         txid = self.nodes[0].sendtoaddress(destination, 0.123)\n         tx = self.nodes[0].decoderawtransaction(self.nodes[0].gettransaction(txid)['hex'])\n-        output_addresses = [vout['scriptPubKey']['addresses'][0] for vout in tx[\"vout\"]]\n+        output_addresses = [vout['scriptPubKey']['address'] for vout in tx[\"vout\"]]\n         assert len(output_addresses) > 1\n         for address in output_addresses:\n             ischange = self.nodes[0].getaddressinfo(address)['ischange']"
      },
      {
        "sha": "0d1b6c54cea29226eef6b35848e831f7f0fdd5fe",
        "filename": "test/functional/wallet_bumpfee.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/wallet_bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/wallet_bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_bumpfee.py?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -535,7 +535,7 @@ def test_change_script_match(self, rbf_node, dest_address):\n \n     def get_change_address(tx):\n         tx_details = rbf_node.getrawtransaction(tx, 1)\n-        txout_addresses = [txout['scriptPubKey']['addresses'][0] for txout in tx_details[\"vout\"]]\n+        txout_addresses = [txout['scriptPubKey']['address'] for txout in tx_details[\"vout\"]]\n         return [address for address in txout_addresses if rbf_node.getaddressinfo(address)[\"ischange\"]]\n \n     # Check that there is only one change output"
      },
      {
        "sha": "23d132df414a142818e661c9a2a956acce8d9cae",
        "filename": "test/functional/wallet_hd.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/wallet_hd.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/wallet_hd.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_hd.py?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -132,7 +132,7 @@ def run_test(self):\n         keypath = \"\"\n         for out in outs:\n             if out['value'] != 1:\n-                keypath = self.nodes[1].getaddressinfo(out['scriptPubKey']['addresses'][0])['hdkeypath']\n+                keypath = self.nodes[1].getaddressinfo(out['scriptPubKey']['address'])['hdkeypath']\n \n         if self.options.descriptors:\n             assert_equal(keypath[0:14], \"m/84'/1'/0'/1/\")"
      },
      {
        "sha": "53553dcd807a813b9b34abe706c25b195b215d6a",
        "filename": "test/functional/wallet_send.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/wallet_send.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/wallet_send.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_send.py?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -389,10 +389,10 @@ def run_test(self):\n         assert res[\"complete\"]\n         res = self.test_send(from_wallet=w0, to_wallet=w1, amount=1, add_to_wallet=False, change_address=change_address, change_position=0)\n         assert res[\"complete\"]\n-        assert_equal(self.nodes[0].decodepsbt(res[\"psbt\"])[\"tx\"][\"vout\"][0][\"scriptPubKey\"][\"addresses\"], [change_address])\n+        assert_equal(self.nodes[0].decodepsbt(res[\"psbt\"])[\"tx\"][\"vout\"][0][\"scriptPubKey\"][\"address\"], change_address)\n         res = self.test_send(from_wallet=w0, to_wallet=w1, amount=1, add_to_wallet=False, change_type=\"legacy\", change_position=0)\n         assert res[\"complete\"]\n-        change_address = self.nodes[0].decodepsbt(res[\"psbt\"])[\"tx\"][\"vout\"][0][\"scriptPubKey\"][\"addresses\"][0]\n+        change_address = self.nodes[0].decodepsbt(res[\"psbt\"])[\"tx\"][\"vout\"][0][\"scriptPubKey\"][\"address\"]\n         assert change_address[0] == \"m\" or change_address[0] == \"n\"\n \n         self.log.info(\"Set lock time...\")"
      },
      {
        "sha": "84ff9ad772ae09fef5b7f2085034e3f6cd00335f",
        "filename": "test/functional/wallet_txn_clone.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/wallet_txn_clone.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/functional/wallet_txn_clone.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_txn_clone.py?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -65,8 +65,8 @@ def run_test(self):\n         # Construct a clone of tx1, to be malleated\n         rawtx1 = self.nodes[0].getrawtransaction(txid1, 1)\n         clone_inputs = [{\"txid\": rawtx1[\"vin\"][0][\"txid\"], \"vout\": rawtx1[\"vin\"][0][\"vout\"], \"sequence\": rawtx1[\"vin\"][0][\"sequence\"]}]\n-        clone_outputs = {rawtx1[\"vout\"][0][\"scriptPubKey\"][\"addresses\"][0]: rawtx1[\"vout\"][0][\"value\"],\n-                         rawtx1[\"vout\"][1][\"scriptPubKey\"][\"addresses\"][0]: rawtx1[\"vout\"][1][\"value\"]}\n+        clone_outputs = {rawtx1[\"vout\"][0][\"scriptPubKey\"][\"address\"]: rawtx1[\"vout\"][0][\"value\"],\n+                         rawtx1[\"vout\"][1][\"scriptPubKey\"][\"address\"]: rawtx1[\"vout\"][1][\"value\"]}\n         clone_locktime = rawtx1[\"locktime\"]\n         clone_raw = self.nodes[0].createrawtransaction(clone_inputs, clone_outputs, clone_locktime)\n "
      },
      {
        "sha": "0ab6aad50ce5ce187207dd4473ba2b5ffcf70538",
        "filename": "test/lint/extended-lint-cppcheck.sh",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/lint/extended-lint-cppcheck.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/lint/extended-lint-cppcheck.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/extended-lint-cppcheck.sh?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -57,7 +57,6 @@ IGNORED_WARNINGS=(\n     \"src/test/checkqueue_tests.cpp:.* Struct 'UniqueCheck' has a constructor with 1 argument that is not explicit.\"\n     \"src/test/fuzz/util.h:.* Class 'FuzzedFileProvider' has a constructor with 1 argument that is not explicit.\"\n     \"src/test/fuzz/util.h:.* Class 'FuzzedAutoFileProvider' has a constructor with 1 argument that is not explicit.\"\n-    \"src/util/ref.h:.* Class 'Ref' has a constructor with 1 argument that is not explicit.\"\n     \"src/wallet/db.h:.* Class 'BerkeleyEnvironment' has a constructor with 1 argument that is not explicit.\"\n )\n "
      },
      {
        "sha": "c5b9f6df01e1f2b7b27779792b3acd3ba10fb37a",
        "filename": "test/util/data/tt-delin1-out.json",
        "status": "modified",
        "additions": 4,
        "deletions": 10,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/tt-delin1-out.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/tt-delin1-out.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/tt-delin1-out.json?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -195,11 +195,8 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"OP_DUP OP_HASH160 8fd139bb39ced713f231c58a4d07bf6954d1c201 OP_EQUALVERIFY OP_CHECKSIG\",\n                 \"hex\": \"76a9148fd139bb39ced713f231c58a4d07bf6954d1c20188ac\",\n-                \"reqSigs\": 1,\n-                \"type\": \"pubkeyhash\",\n-                \"addresses\": [\n-                    \"1E7SGgAZFCHDnVZLuRViX3gUmxpMfdvd2o\"\n-                ]\n+                \"address\": \"1E7SGgAZFCHDnVZLuRViX3gUmxpMfdvd2o\",\n+                \"type\": \"pubkeyhash\"\n             }\n         },\n         {\n@@ -208,11 +205,8 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"OP_DUP OP_HASH160 6c772e9cf96371bba3da8cb733da70a2fcf20078 OP_EQUALVERIFY OP_CHECKSIG\",\n                 \"hex\": \"76a9146c772e9cf96371bba3da8cb733da70a2fcf2007888ac\",\n-                \"reqSigs\": 1,\n-                \"type\": \"pubkeyhash\",\n-                \"addresses\": [\n-                    \"1AtWkdmfmYkErU16d3KYykJUbEp9MAj9Sb\"\n-                ]\n+                \"address\": \"1AtWkdmfmYkErU16d3KYykJUbEp9MAj9Sb\",\n+                \"type\": \"pubkeyhash\"\n             }\n         }\n     ],"
      },
      {
        "sha": "38634164309b2c33048a8aa73ecf82f92d69487c",
        "filename": "test/util/data/tt-delout1-out.json",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/tt-delout1-out.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/tt-delout1-out.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/tt-delout1-out.json?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -204,11 +204,8 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"OP_DUP OP_HASH160 8fd139bb39ced713f231c58a4d07bf6954d1c201 OP_EQUALVERIFY OP_CHECKSIG\",\n                 \"hex\": \"76a9148fd139bb39ced713f231c58a4d07bf6954d1c20188ac\",\n-                \"reqSigs\": 1,\n-                \"type\": \"pubkeyhash\",\n-                \"addresses\": [\n-                    \"1E7SGgAZFCHDnVZLuRViX3gUmxpMfdvd2o\"\n-                ]\n+                \"address\": \"1E7SGgAZFCHDnVZLuRViX3gUmxpMfdvd2o\",\n+                \"type\": \"pubkeyhash\"\n             }\n         }\n     ],"
      },
      {
        "sha": "62e785f7d08550223ebfc2b9f584b4d3d09c12d8",
        "filename": "test/util/data/tt-locktime317000-out.json",
        "status": "modified",
        "additions": 4,
        "deletions": 10,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/tt-locktime317000-out.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/tt-locktime317000-out.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/tt-locktime317000-out.json?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -204,11 +204,8 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"OP_DUP OP_HASH160 8fd139bb39ced713f231c58a4d07bf6954d1c201 OP_EQUALVERIFY OP_CHECKSIG\",\n                 \"hex\": \"76a9148fd139bb39ced713f231c58a4d07bf6954d1c20188ac\",\n-                \"reqSigs\": 1,\n-                \"type\": \"pubkeyhash\",\n-                \"addresses\": [\n-                    \"1E7SGgAZFCHDnVZLuRViX3gUmxpMfdvd2o\"\n-                ]\n+                \"address\": \"1E7SGgAZFCHDnVZLuRViX3gUmxpMfdvd2o\",\n+                \"type\": \"pubkeyhash\"\n             }\n         },\n         {\n@@ -217,11 +214,8 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"OP_DUP OP_HASH160 6c772e9cf96371bba3da8cb733da70a2fcf20078 OP_EQUALVERIFY OP_CHECKSIG\",\n                 \"hex\": \"76a9146c772e9cf96371bba3da8cb733da70a2fcf2007888ac\",\n-                \"reqSigs\": 1,\n-                \"type\": \"pubkeyhash\",\n-                \"addresses\": [\n-                    \"1AtWkdmfmYkErU16d3KYykJUbEp9MAj9Sb\"\n-                ]\n+                \"address\": \"1AtWkdmfmYkErU16d3KYykJUbEp9MAj9Sb\",\n+                \"type\": \"pubkeyhash\"\n             }\n         }\n     ],"
      },
      {
        "sha": "96d77ef273194fe1e2dd8021a8b31f0a675acc09",
        "filename": "test/util/data/txcreate1.json",
        "status": "modified",
        "additions": 4,
        "deletions": 10,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreate1.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreate1.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreate1.json?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -42,11 +42,8 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"OP_DUP OP_HASH160 1fc11f39be1729bf973a7ab6a615ca4729d64574 OP_EQUALVERIFY OP_CHECKSIG\",\n                 \"hex\": \"76a9141fc11f39be1729bf973a7ab6a615ca4729d6457488ac\",\n-                \"reqSigs\": 1,\n-                \"type\": \"pubkeyhash\",\n-                \"addresses\": [\n-                    \"13tuJJDR2RgArmgfv6JScSdreahzgc4T6o\"\n-                ]\n+                \"address\": \"13tuJJDR2RgArmgfv6JScSdreahzgc4T6o\",\n+                \"type\": \"pubkeyhash\"\n             }\n         },\n         {\n@@ -55,11 +52,8 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"OP_DUP OP_HASH160 f2d4db28cad6502226ee484ae24505c2885cb12d OP_EQUALVERIFY OP_CHECKSIG\",\n                 \"hex\": \"76a914f2d4db28cad6502226ee484ae24505c2885cb12d88ac\",\n-                \"reqSigs\": 1,\n-                \"type\": \"pubkeyhash\",\n-                \"addresses\": [\n-                    \"1P8yWvZW8jVihP1bzHeqfE4aoXNX8AVa46\"\n-                ]\n+                \"address\": \"1P8yWvZW8jVihP1bzHeqfE4aoXNX8AVa46\",\n+                \"type\": \"pubkeyhash\"\n             }\n         }\n     ],"
      },
      {
        "sha": "87fc7e9cf740f4814fea5f7d1646a36cee9be100",
        "filename": "test/util/data/txcreatedata1.json",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatedata1.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatedata1.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatedata1.json?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -24,11 +24,8 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"OP_DUP OP_HASH160 1fc11f39be1729bf973a7ab6a615ca4729d64574 OP_EQUALVERIFY OP_CHECKSIG\",\n                 \"hex\": \"76a9141fc11f39be1729bf973a7ab6a615ca4729d6457488ac\",\n-                \"reqSigs\": 1,\n-                \"type\": \"pubkeyhash\",\n-                \"addresses\": [\n-                    \"13tuJJDR2RgArmgfv6JScSdreahzgc4T6o\"\n-                ]\n+                \"address\": \"13tuJJDR2RgArmgfv6JScSdreahzgc4T6o\",\n+                \"type\": \"pubkeyhash\"\n             }\n         },\n         {"
      },
      {
        "sha": "d03b1c8244729f2360af60ca2a0d819762bf11c7",
        "filename": "test/util/data/txcreatedata2.json",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatedata2.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatedata2.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatedata2.json?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -24,11 +24,8 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"OP_DUP OP_HASH160 1fc11f39be1729bf973a7ab6a615ca4729d64574 OP_EQUALVERIFY OP_CHECKSIG\",\n                 \"hex\": \"76a9141fc11f39be1729bf973a7ab6a615ca4729d6457488ac\",\n-                \"reqSigs\": 1,\n-                \"type\": \"pubkeyhash\",\n-                \"addresses\": [\n-                    \"13tuJJDR2RgArmgfv6JScSdreahzgc4T6o\"\n-                ]\n+                \"address\": \"13tuJJDR2RgArmgfv6JScSdreahzgc4T6o\",\n+                \"type\": \"pubkeyhash\"\n             }\n         },\n         {"
      },
      {
        "sha": "8a123f1ba876587219934bbe04f274e273001e55",
        "filename": "test/util/data/txcreatedata_seq0.json",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatedata_seq0.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatedata_seq0.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatedata_seq0.json?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -24,11 +24,8 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"OP_DUP OP_HASH160 1fc11f39be1729bf973a7ab6a615ca4729d64574 OP_EQUALVERIFY OP_CHECKSIG\",\n                 \"hex\": \"76a9141fc11f39be1729bf973a7ab6a615ca4729d6457488ac\",\n-                \"reqSigs\": 1,\n-                \"type\": \"pubkeyhash\",\n-                \"addresses\": [\n-                    \"13tuJJDR2RgArmgfv6JScSdreahzgc4T6o\"\n-                ]\n+                \"address\": \"13tuJJDR2RgArmgfv6JScSdreahzgc4T6o\",\n+                \"type\": \"pubkeyhash\"\n             }\n         }\n     ],"
      },
      {
        "sha": "006fd7259ff2f0322a3886b38f98b8e5550ba33f",
        "filename": "test/util/data/txcreatedata_seq1.json",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatedata_seq1.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatedata_seq1.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatedata_seq1.json?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -33,11 +33,8 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"OP_DUP OP_HASH160 1fc11f39be1729bf973a7ab6a615ca4729d64574 OP_EQUALVERIFY OP_CHECKSIG\",\n                 \"hex\": \"76a9141fc11f39be1729bf973a7ab6a615ca4729d6457488ac\",\n-                \"reqSigs\": 1,\n-                \"type\": \"pubkeyhash\",\n-                \"addresses\": [\n-                    \"13tuJJDR2RgArmgfv6JScSdreahzgc4T6o\"\n-                ]\n+                \"address\": \"13tuJJDR2RgArmgfv6JScSdreahzgc4T6o\",\n+                \"type\": \"pubkeyhash\"\n             }\n         }\n     ],"
      },
      {
        "sha": "baa290c2b14199b29fb28efe1658667083e788ef",
        "filename": "test/util/data/txcreatemultisig1.json",
        "status": "modified",
        "additions": 1,
        "deletions": 7,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatemultisig1.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatemultisig1.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatemultisig1.json?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -15,13 +15,7 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"2 02a5613bd857b7048924264d1e70e08fb2a7e6527d32b7ab1bb993ac59964ff397 021ac43c7ff740014c3b33737ede99c967e4764553d1b2b83db77c83b8715fa72d 02df2089105c77f266fa11a9d33f05c735234075f2e8780824c6b709415f9fb485 3 OP_CHECKMULTISIG\",\n                 \"hex\": \"522102a5613bd857b7048924264d1e70e08fb2a7e6527d32b7ab1bb993ac59964ff39721021ac43c7ff740014c3b33737ede99c967e4764553d1b2b83db77c83b8715fa72d2102df2089105c77f266fa11a9d33f05c735234075f2e8780824c6b709415f9fb48553ae\",\n-                \"reqSigs\": 2,\n-                \"type\": \"multisig\",\n-                \"addresses\": [\n-                    \"1FoG2386FG2tAJS9acMuiDsKy67aGg9MKz\",\n-                    \"1FXtz9KU8JNmQDyHdiEm5HDiALuP3zdHvV\",\n-                    \"14LuavcBbXZYJ6Tsz3cAUQj9SuQoL2xCQX\"\n-                ]\n+                \"type\": \"multisig\"\n             }\n         }\n     ],"
      },
      {
        "sha": "66855125875729afc170cd83ecc26c68b084e091",
        "filename": "test/util/data/txcreatemultisig2.json",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatemultisig2.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatemultisig2.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatemultisig2.json?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -15,11 +15,8 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"OP_HASH160 1c6fbaf46d64221e80cbae182c33ddf81b9294ac OP_EQUAL\",\n                 \"hex\": \"a9141c6fbaf46d64221e80cbae182c33ddf81b9294ac87\",\n-                \"reqSigs\": 1,\n-                \"type\": \"scripthash\",\n-                \"addresses\": [\n-                    \"34HNh57oBCRKkxNyjTuWAJkTbuGh6jg2Ms\"\n-                ]\n+                \"address\": \"34HNh57oBCRKkxNyjTuWAJkTbuGh6jg2Ms\",\n+                \"type\": \"scripthash\"\n             }\n         }\n     ],"
      },
      {
        "sha": "be96f4c704f0a036537cc0b98b3d10a5fad3b2ae",
        "filename": "test/util/data/txcreatemultisig3.json",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatemultisig3.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatemultisig3.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatemultisig3.json?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -15,11 +15,8 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"0 e15a86a23178f433d514dbbce042e87d72662b8b5edcacfd2e37ab7a2d135f05\",\n                 \"hex\": \"0020e15a86a23178f433d514dbbce042e87d72662b8b5edcacfd2e37ab7a2d135f05\",\n-                \"reqSigs\": 1,\n-                \"type\": \"witness_v0_scripthash\",\n-                \"addresses\": [\n-                    \"bc1qu9dgdg330r6r84g5mw7wqshg04exv2uttmw2elfwx74h5tgntuzs44gyfg\"\n-                ]\n+                \"address\": \"bc1qu9dgdg330r6r84g5mw7wqshg04exv2uttmw2elfwx74h5tgntuzs44gyfg\",\n+                \"type\": \"witness_v0_scripthash\"\n             }\n         }\n     ],"
      },
      {
        "sha": "08831ecdcacb0b2fd0b9d7dd526de8bb39e2c1ab",
        "filename": "test/util/data/txcreatemultisig4.json",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatemultisig4.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatemultisig4.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatemultisig4.json?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -15,11 +15,8 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"OP_HASH160 6edf12858999f0dae74f9c692e6694ee3621b2ac OP_EQUAL\",\n                 \"hex\": \"a9146edf12858999f0dae74f9c692e6694ee3621b2ac87\",\n-                \"reqSigs\": 1,\n-                \"type\": \"scripthash\",\n-                \"addresses\": [\n-                    \"3BoFUz1StqcNcgUTZE5cC1eFhuYFzj3fGH\"\n-                ]\n+                \"address\": \"3BoFUz1StqcNcgUTZE5cC1eFhuYFzj3fGH\",\n+                \"type\": \"scripthash\"\n             }\n         }\n     ],"
      },
      {
        "sha": "93048cf26169e1e0a99ffc387cafe9a7737e74da",
        "filename": "test/util/data/txcreatemultisig5.json",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatemultisig5.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatemultisig5.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatemultisig5.json?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -15,11 +15,8 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"OP_HASH160 a4051c02398868af83f28f083208fae99a769263 OP_EQUAL\",\n                 \"hex\": \"a914a4051c02398868af83f28f083208fae99a76926387\",\n-                \"reqSigs\": 1,\n-                \"type\": \"scripthash\",\n-                \"addresses\": [\n-                    \"3GeGs1eHUxPz5YyuFe9WPpXid2UsUb5Jos\"\n-                ]\n+                \"address\": \"3GeGs1eHUxPz5YyuFe9WPpXid2UsUb5Jos\",\n+                \"type\": \"scripthash\"\n             }\n         }\n     ],"
      },
      {
        "sha": "52168a889bcb4a426d538d043ccd0f99f3d02a81",
        "filename": "test/util/data/txcreateoutpubkey2.json",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreateoutpubkey2.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreateoutpubkey2.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreateoutpubkey2.json?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -15,11 +15,8 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"0 a2516e770582864a6a56ed21a102044e388c62e3\",\n                 \"hex\": \"0014a2516e770582864a6a56ed21a102044e388c62e3\",\n-                \"reqSigs\": 1,\n-                \"type\": \"witness_v0_keyhash\",\n-                \"addresses\": [\n-                    \"bc1q5fgkuac9s2ry56jka5s6zqsyfcugcchry5cwu0\"\n-                ]\n+                \"address\": \"bc1q5fgkuac9s2ry56jka5s6zqsyfcugcchry5cwu0\",\n+                \"type\": \"witness_v0_keyhash\"\n             }\n         }\n     ],"
      },
      {
        "sha": "fce210f8a38384b0947c64e406c0cff82736fd5d",
        "filename": "test/util/data/txcreateoutpubkey3.json",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreateoutpubkey3.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreateoutpubkey3.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreateoutpubkey3.json?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -15,11 +15,8 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"OP_HASH160 a5ab14c9804d0d8bf02f1aea4e82780733ad0a83 OP_EQUAL\",\n                 \"hex\": \"a914a5ab14c9804d0d8bf02f1aea4e82780733ad0a8387\",\n-                \"reqSigs\": 1,\n-                \"type\": \"scripthash\",\n-                \"addresses\": [\n-                    \"3GnzN8FqgvYGYdhj8NW6UNxxVv3Uj1ApQn\"\n-                ]\n+                \"address\": \"3GnzN8FqgvYGYdhj8NW6UNxxVv3Uj1ApQn\",\n+                \"type\": \"scripthash\"\n             }\n         }\n     ],"
      },
      {
        "sha": "2cde70fdf755a6874eb19dbccd9bf899f78c6023",
        "filename": "test/util/data/txcreatescript2.json",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatescript2.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatescript2.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatescript2.json?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -15,11 +15,8 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"OP_HASH160 71ed53322d470bb96657deb786b94f97dd46fb15 OP_EQUAL\",\n                 \"hex\": \"a91471ed53322d470bb96657deb786b94f97dd46fb1587\",\n-                \"reqSigs\": 1,\n-                \"type\": \"scripthash\",\n-                \"addresses\": [\n-                    \"3C5QarEGh9feKbDJ3QbMf2YNjnMoiPDhNp\"\n-                ]\n+                \"address\": \"3C5QarEGh9feKbDJ3QbMf2YNjnMoiPDhNp\",\n+                \"type\": \"scripthash\"\n             }\n         }\n     ],"
      },
      {
        "sha": "7a282faf4fac9f1dc7c566e78c422dd10cdfca88",
        "filename": "test/util/data/txcreatescript3.json",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatescript3.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatescript3.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatescript3.json?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -15,11 +15,8 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"0 0bfe935e70c321c7ca3afc75ce0d0ca2f98b5422e008bb31c00c6d7f1f1c0ad6\",\n                 \"hex\": \"00200bfe935e70c321c7ca3afc75ce0d0ca2f98b5422e008bb31c00c6d7f1f1c0ad6\",\n-                \"reqSigs\": 1,\n-                \"type\": \"witness_v0_scripthash\",\n-                \"addresses\": [\n-                    \"bc1qp0lfxhnscvsu0j36l36uurgv5tuck4pzuqytkvwqp3kh78cupttqyf705v\"\n-                ]\n+                \"address\": \"bc1qp0lfxhnscvsu0j36l36uurgv5tuck4pzuqytkvwqp3kh78cupttqyf705v\",\n+                \"type\": \"witness_v0_scripthash\"\n             }\n         }\n     ],"
      },
      {
        "sha": "298b37bb4a0e05a4c2a9f2681cae67d1a3064751",
        "filename": "test/util/data/txcreatescript4.json",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatescript4.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatescript4.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatescript4.json?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -15,11 +15,8 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"OP_HASH160 6a2c482f4985f57e702f325816c90e3723ca81ae OP_EQUAL\",\n                 \"hex\": \"a9146a2c482f4985f57e702f325816c90e3723ca81ae87\",\n-                \"reqSigs\": 1,\n-                \"type\": \"scripthash\",\n-                \"addresses\": [\n-                    \"3BNQbeFeJJGMAyDxPwWPuqxPMrjsFLjk3f\"\n-                ]\n+                \"address\": \"3BNQbeFeJJGMAyDxPwWPuqxPMrjsFLjk3f\",\n+                \"type\": \"scripthash\"\n             }\n         }\n     ],"
      },
      {
        "sha": "ca5e003110377b306c652977a44b716ba169884b",
        "filename": "test/util/data/txcreatesignv1.json",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatesignv1.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f/test/util/data/txcreatesignv1.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatesignv1.json?ref=2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "patch": "@@ -24,11 +24,8 @@\n             \"scriptPubKey\": {\n                 \"asm\": \"OP_DUP OP_HASH160 5834479edbbe0539b31ffd3a8f8ebadc2165ed01 OP_EQUALVERIFY OP_CHECKSIG\",\n                 \"hex\": \"76a9145834479edbbe0539b31ffd3a8f8ebadc2165ed0188ac\",\n-                \"reqSigs\": 1,\n-                \"type\": \"pubkeyhash\",\n-                \"addresses\": [\n-                    \"193P6LtvS4nCnkDvM9uXn1gsSRqh4aDAz7\"\n-                ]\n+                \"address\": \"193P6LtvS4nCnkDvM9uXn1gsSRqh4aDAz7\",\n+                \"type\": \"pubkeyhash\"\n             }\n         }\n     ],"
      }
    ]
  },
  {
    "sha": "7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZGM1NzEyZWFlY2M4ZWNmNzU1ZTE4NGMzYmNiNjMxOGNjYWU0NTFm",
    "commit": {
      "author": {
        "name": "J0hn",
        "email": "songjh.john@gmail.com",
        "date": "2021-04-09T19:01:31Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-04-09T19:01:31Z"
      },
      "message": "Merge pull request #3 from bitcoin/master\n\nCode pull",
      "tree": {
        "sha": "222a14f0021990e317f6f35371c1a9b453078624",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/222a14f0021990e317f6f35371c1a9b453078624"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgcKSLCRBK7hj4Ov3rIwAAdHIIAC8MEfUXWPYuY5D05PnsPOla\nw2x4EOSHrjWNc+BsVlzcb7zIP5dyxlkYlFkJOthxW7Kjl75abdnR40rQ3CJVABdM\nyl6XP3v14L77PDl8+0hL0VHVYQ/v2ztf1bn7bHyWKtf116gEmVQicuOgoDgVJYpL\nraiOyzYgv6kNtxuDb/vlQfev73w2H6eGxc/Y8P6OgwEsgnqkW2UMjv2cjSe5Jlte\nNbmN62PVZYbNlxeGTPxGYsHeWXLyaU1kspi11uKlOhQfj38AGj1w9ZpjuVSri06S\nLGFEAj/VR+MmRzHh7b1ne1yn4v+JzI25nb3on8Z2qbeWjbzLHZarYiAAqSHgVdc=\n=k00G\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 222a14f0021990e317f6f35371c1a9b453078624\nparent 2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f\nparent f0fa32450ec35056b3e1025262aeaef4a24c35ee\nauthor J0hn <songjh.john@gmail.com> 1617994891 +0100\ncommitter GitHub <noreply@github.com> 1617994891 +0100\n\nMerge pull request #3 from bitcoin/master\n\nCode pull"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/comments",
    "author": {
      "login": "Rqcker",
      "id": 20661419,
      "node_id": "MDQ6VXNlcjIwNjYxNDE5",
      "avatar_url": "https://avatars.githubusercontent.com/u/20661419?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Rqcker",
      "html_url": "https://github.com/Rqcker",
      "followers_url": "https://api.github.com/users/Rqcker/followers",
      "following_url": "https://api.github.com/users/Rqcker/following{/other_user}",
      "gists_url": "https://api.github.com/users/Rqcker/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Rqcker/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Rqcker/subscriptions",
      "organizations_url": "https://api.github.com/users/Rqcker/orgs",
      "repos_url": "https://api.github.com/users/Rqcker/repos",
      "events_url": "https://api.github.com/users/Rqcker/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Rqcker/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2b9e45fb10ae8a301a94eb983e5df3ff1a0a585f"
      },
      {
        "sha": "f0fa32450ec35056b3e1025262aeaef4a24c35ee",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f0fa32450ec35056b3e1025262aeaef4a24c35ee",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f0fa32450ec35056b3e1025262aeaef4a24c35ee"
      }
    ],
    "stats": {
      "total": 4157,
      "additions": 2507,
      "deletions": 1650
    },
    "files": [
      {
        "sha": "99957f08c5e90d5a8a19e0dc12a535f8488792c5",
        "filename": ".cirrus.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/.cirrus.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/.cirrus.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.cirrus.yml?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -28,7 +28,6 @@ global_task_template: &GLOBAL_TASK_TEMPLATE\n     # Each project has 16 CPU in total, assign 2 to each container, so that 8 tasks run in parallel\n     cpu: 2\n     memory: 8G  # Set to 8GB to avoid OOM. https://cirrus-ci.org/guide/linux/#linux-containers\n-    kvm: true  # Use kvm to avoid spurious CI failures in the default virtualization cluster, see https://github.com/bitcoin/bitcoin/issues/20093\n   ccache_cache:\n     folder: \"/tmp/ccache_dir\"\n   depends_built_cache:\n@@ -113,7 +112,7 @@ task:\n   << : *GLOBAL_TASK_TEMPLATE\n   container:\n     image: ubuntu:focal\n-    cpu: 4  # Double CPU and increase Memory to avoid timeout\n+    cpu: 6  # Increase CPU and Memory to avoid timeout\n     memory: 24G\n   env:\n     MAKEJOBS: \"-j8\""
      },
      {
        "sha": "5e453b9ae1995343b48635cf88337c549875a656",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -4,7 +4,7 @@\n \n # Pattern rule to print variables, e.g. make print-top_srcdir\n print-%:\n-\t@echo '$*' = '$($*)'\n+\t@echo '$*'='$($*)'\n \n ACLOCAL_AMFLAGS = -I build-aux/m4\n SUBDIRS = src"
      },
      {
        "sha": "57b4c10d778cefc38605937be8dc9c8c8f284d74",
        "filename": "build-aux/m4/bitcoin_qt.m4",
        "status": "modified",
        "additions": 36,
        "deletions": 29,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/build-aux/m4/bitcoin_qt.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/build-aux/m4/bitcoin_qt.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_qt.m4?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -108,11 +108,10 @@ AC_DEFUN([BITCOIN_QT_CONFIGURE],[\n   BITCOIN_QT_CHECK([_BITCOIN_QT_FIND_LIBS])\n \n   dnl This is ugly and complicated. Yuck. Works as follows:\n-  dnl For Qt5, we can check a header to find out whether Qt is build\n-  dnl statically. When Qt is built statically, some plugins must be linked into\n-  dnl the final binary as well.\n-  dnl _BITCOIN_QT_CHECK_STATIC_PLUGIN does a quick link-check and appends the\n-  dnl results to QT_LIBS.\n+  dnl We check a header to find out whether Qt is built statically.\n+  dnl When Qt is built statically, some plugins must be linked into\n+  dnl the final binary as well. _BITCOIN_QT_CHECK_STATIC_PLUGIN does\n+  dnl a quick link-check and appends the results to QT_LIBS.\n   BITCOIN_QT_CHECK([\n   TEMP_CPPFLAGS=$CPPFLAGS\n   TEMP_CXXFLAGS=$CXXFLAGS\n@@ -162,7 +161,7 @@ AC_DEFUN([BITCOIN_QT_CONFIGURE],[\n       _BITCOIN_QT_CHECK_STATIC_PLUGIN([QMacStylePlugin], [-lqmacstyle])\n       AC_DEFINE(QT_QPA_PLATFORM_COCOA, 1, [Define this symbol if the qt platform is cocoa])\n     elif test \"x$TARGET_OS\" = xandroid; then\n-      QT_LIBS=\"-Wl,--export-dynamic,--undefined=JNI_OnLoad -lqtforandroid -ljnigraphics -landroid -lqtfreetype -lQt5EglSupport $QT_LIBS\"\n+      QT_LIBS=\"-Wl,--export-dynamic,--undefined=JNI_OnLoad -lqtforandroid -ljnigraphics -landroid -lqtfreetype $QT_LIBS\"\n       AC_DEFINE(QT_QPA_PLATFORM_ANDROID, 1, [Define this symbol if the qt platform is android])\n     fi\n   fi\n@@ -171,7 +170,7 @@ AC_DEFUN([BITCOIN_QT_CONFIGURE],[\n   ])\n \n   if test \"x$qt_bin_path\" = x; then\n-    qt_bin_path=\"`$PKG_CONFIG --variable=host_bins Qt5Core 2>/dev/null`\"\n+    qt_bin_path=\"`$PKG_CONFIG --variable=host_bins ${qt_lib_prefix}Core 2>/dev/null`\"\n   fi\n \n   if test \"x$use_hardening\" != xno; then\n@@ -282,12 +281,13 @@ AC_DEFUN([BITCOIN_QT_CONFIGURE],[\n   AC_SUBST(MOC_DEFS)\n ])\n \n-dnl All macros below are internal and should _not_ be used from the main\n-dnl configure.ac.\n-dnl ----\n+dnl All macros below are internal and should _not_ be used from configure.ac.\n \n-dnl Internal. Check if the linked version of Qt was built as static libs.\n-dnl Requires: Qt5.\n+dnl Internal. Check if the linked version of Qt was built statically.\n+dnl\n+dnl _BITCOIN_QT_IS_STATIC\n+dnl ---------------------\n+dnl\n dnl Requires: INCLUDES and LIBS must be populated as necessary.\n dnl Output: bitcoin_cv_static_qt=yes|no\n AC_DEFUN([_BITCOIN_QT_IS_STATIC],[\n@@ -335,47 +335,54 @@ dnl\n dnl _BITCOIN_QT_CHECK_STATIC_LIBS\n dnl -----------------------------\n dnl\n-dnl Inputs: no inputs.\n dnl Outputs: QT_LIBS is prepended.\n AC_DEFUN([_BITCOIN_QT_CHECK_STATIC_LIBS], [\n-  PKG_CHECK_MODULES([QTFONTDATABASE], [Qt5FontDatabaseSupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5FontDatabaseSupport${qt_lib_suffix} $QT_LIBS\"])\n-  PKG_CHECK_MODULES([QTEVENTDISPATCHER], [Qt5EventDispatcherSupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5EventDispatcherSupport${qt_lib_suffix} $QT_LIBS\"])\n-  PKG_CHECK_MODULES([QTTHEME], [Qt5ThemeSupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5ThemeSupport${qt_lib_suffix} $QT_LIBS\"])\n-  PKG_CHECK_MODULES([QTDEVICEDISCOVERY], [Qt5DeviceDiscoverySupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5DeviceDiscoverySupport${qt_lib_suffix} $QT_LIBS\"])\n-  PKG_CHECK_MODULES([QTACCESSIBILITY], [Qt5AccessibilitySupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5AccessibilitySupport${qt_lib_suffix} $QT_LIBS\"])\n-  PKG_CHECK_MODULES([QTFB], [Qt5FbSupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5FbSupport${qt_lib_suffix} $QT_LIBS\"])\n+  PKG_CHECK_MODULES([QT_ACCESSIBILITY], [${qt_lib_prefix}AccessibilitySupport${qt_lib_suffix}], [QT_LIBS=\"$QT_ACCESSIBILITY_LIBS $QT_LIBS\"])\n+  PKG_CHECK_MODULES([QT_DEVICEDISCOVERY], [${qt_lib_prefix}DeviceDiscoverySupport${qt_lib_suffix}], [QT_LIBS=\"$QT_DEVICEDISCOVERY_LIBS $QT_LIBS\"])\n+  PKG_CHECK_MODULES([QT_EDID], [${qt_lib_prefix}EdidSupport${qt_lib_suffix}], [QT_LIBS=\"$QT_EDID_LIBS $QT_LIBS\"])\n+  PKG_CHECK_MODULES([QT_EVENTDISPATCHER], [${qt_lib_prefix}EventDispatcherSupport${qt_lib_suffix}], [QT_LIBS=\"$QT_EVENTDISPATCHER_LIBS $QT_LIBS\"])\n+  PKG_CHECK_MODULES([QT_FB], [${qt_lib_prefix}FbSupport${qt_lib_suffix}], [QT_LIBS=\"$QT_FB_LIBS $QT_LIBS\"])\n+  PKG_CHECK_MODULES([QT_FONTDATABASE], [${qt_lib_prefix}FontDatabaseSupport${qt_lib_suffix}], [QT_LIBS=\"$QT_FONTDATABASE_LIBS $QT_LIBS\"])\n+  PKG_CHECK_MODULES([QT_THEME], [${qt_lib_prefix}ThemeSupport${qt_lib_suffix}], [QT_LIBS=\"$QT_THEME_LIBS $QT_LIBS\"])\n   if test \"x$TARGET_OS\" = xlinux; then\n-    PKG_CHECK_MODULES([QTXCBQPA], [Qt5XcbQpa], [QT_LIBS=\"$QTXCBQPA_LIBS $QT_LIBS\"])\n+    PKG_CHECK_MODULES([QT_INPUT], [${qt_lib_prefix}XcbQpa], [QT_LIBS=\"$QT_INPUT_LIBS $QT_LIBS\"])\n+    PKG_CHECK_MODULES([QT_SERVICE], [${qt_lib_prefix}ServiceSupport], [QT_LIBS=\"$QT_SERVICE_LIBS $QT_LIBS\"])\n+    PKG_CHECK_MODULES([QT_XCBQPA], [${qt_lib_prefix}XcbQpa], [QT_LIBS=\"$QT_XCBQPA_LIBS $QT_LIBS\"])\n   elif test \"x$TARGET_OS\" = xdarwin; then\n-    PKG_CHECK_MODULES([QTCLIPBOARD], [Qt5ClipboardSupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5ClipboardSupport${qt_lib_suffix} $QT_LIBS\"])\n-    PKG_CHECK_MODULES([QTGRAPHICS], [Qt5GraphicsSupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5GraphicsSupport${qt_lib_suffix} $QT_LIBS\"])\n+    PKG_CHECK_MODULES([QT_CLIPBOARD], [${qt_lib_prefix}ClipboardSupport${qt_lib_suffix}], [QT_LIBS=\"$QT_CLIPBOARD_LIBS $QT_LIBS\"])\n+    PKG_CHECK_MODULES([QT_GRAPHICS], [${qt_lib_prefix}GraphicsSupport${qt_lib_suffix}], [QT_LIBS=\"$QT_GRAPHICS_LIBS $QT_LIBS\"])\n+    PKG_CHECK_MODULES([QT_SERVICE], [${qt_lib_prefix}ServiceSupport${qt_lib_suffix}], [QT_LIBS=\"$QT_SERVICE_LIBS $QT_LIBS\"])\n   elif test \"x$TARGET_OS\" = xwindows; then\n-    PKG_CHECK_MODULES([QTWINDOWSUIAUTOMATION], [Qt5WindowsUIAutomationSupport${qt_lib_suffix}], [QT_LIBS=\"-lQt5WindowsUIAutomationSupport${qt_lib_suffix} $QT_LIBS\"])\n+    PKG_CHECK_MODULES([QT_WINDOWSUIAUTOMATION], [${qt_lib_prefix}WindowsUIAutomationSupport${qt_lib_suffix}], [QT_LIBS=\"$QT_WINDOWSUIAUTOMATION_LIBS $QT_LIBS\"])\n+  elif test \"x$TARGET_OS\" = xandroid; then\n+    PKG_CHECK_MODULES([QT_EGL], [${qt_lib_prefix}EglSupport], [QT_LIBS=\"$QT_EGL_LIBS $QT_LIBS\"])\n   fi\n ])\n \n dnl Internal. Find Qt libraries using pkg-config.\n+dnl\n+dnl _BITCOIN_QT_FIND_LIBS\n+dnl ---------------------\n+dnl\n dnl Outputs: All necessary QT_* variables are set.\n dnl Outputs: have_qt_test and have_qt_dbus are set (if applicable) to yes|no.\n AC_DEFUN([_BITCOIN_QT_FIND_LIBS],[\n   BITCOIN_QT_CHECK([\n-    PKG_CHECK_MODULES([QT_CORE], [${qt_lib_prefix}Core${qt_lib_suffix} $qt_version], [],\n+    PKG_CHECK_MODULES([QT_CORE], [${qt_lib_prefix}Core${qt_lib_suffix} $qt_version], [QT_INCLUDES=\"$QT_CORE_CFLAGS $QT_INCLUDES\" QT_LIBS=\"$QT_CORE_LIBS $QT_LIBS\"],\n                       [BITCOIN_QT_FAIL([${qt_lib_prefix}Core${qt_lib_suffix} $qt_version not found])])\n   ])\n   BITCOIN_QT_CHECK([\n-    PKG_CHECK_MODULES([QT_GUI], [${qt_lib_prefix}Gui${qt_lib_suffix} $qt_version], [],\n+    PKG_CHECK_MODULES([QT_GUI], [${qt_lib_prefix}Gui${qt_lib_suffix} $qt_version], [QT_INCLUDES=\"$QT_GUI_CFLAGS $QT_INCLUDES\" QT_LIBS=\"$QT_GUI_LIBS $QT_LIBS\"],\n                       [BITCOIN_QT_FAIL([${qt_lib_prefix}Gui${qt_lib_suffix} $qt_version not found])])\n   ])\n   BITCOIN_QT_CHECK([\n-    PKG_CHECK_MODULES([QT_WIDGETS], [${qt_lib_prefix}Widgets${qt_lib_suffix} $qt_version], [],\n+    PKG_CHECK_MODULES([QT_WIDGETS], [${qt_lib_prefix}Widgets${qt_lib_suffix} $qt_version], [QT_INCLUDES=\"$QT_WIDGETS_CFLAGS $QT_INCLUDES\" QT_LIBS=\"$QT_WIDGETS_LIBS $QT_LIBS\"],\n                       [BITCOIN_QT_FAIL([${qt_lib_prefix}Widgets${qt_lib_suffix} $qt_version not found])])\n   ])\n   BITCOIN_QT_CHECK([\n-    PKG_CHECK_MODULES([QT_NETWORK], [${qt_lib_prefix}Network${qt_lib_suffix} $qt_version], [],\n+    PKG_CHECK_MODULES([QT_NETWORK], [${qt_lib_prefix}Network${qt_lib_suffix} $qt_version], [QT_INCLUDES=\"$QT_NETWORK_CFLAGS $QT_INCLUDES\" QT_LIBS=\"$QT_NETWORK_LIBS $QT_LIBS\"],\n                       [BITCOIN_QT_FAIL([${qt_lib_prefix}Network${qt_lib_suffix} $qt_version not found])])\n   ])\n-  QT_INCLUDES=\"$QT_CORE_CFLAGS $QT_GUI_CFLAGS $QT_WIDGETS_CFLAGS $QT_NETWORK_CFLAGS\"\n-  QT_LIBS=\"$QT_CORE_LIBS $QT_GUI_LIBS $QT_WIDGETS_LIBS $QT_NETWORK_LIBS\"\n \n   BITCOIN_QT_CHECK([\n     PKG_CHECK_MODULES([QT_TEST], [${qt_lib_prefix}Test${qt_lib_suffix} $qt_version], [QT_TEST_INCLUDES=\"$QT_TEST_CFLAGS\"; have_qt_test=yes], [have_qt_test=no])"
      },
      {
        "sha": "cce97e925902025b77f4d7cbc47b3aee56ddc8a5",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 12,
        "deletions": 1,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -439,6 +439,10 @@ if test \"x$enable_werror\" = \"xyes\"; then\n                         [AC_LANG_SOURCE([[struct A { virtual void f(); }; struct B : A { void f() final; };]])])\n   AX_CHECK_COMPILE_FLAG([-Werror=unreachable-code-loop-increment],[ERROR_CXXFLAGS=\"$ERROR_CXXFLAGS -Werror=unreachable-code-loop-increment\"],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_COMPILE_FLAG([-Werror=mismatched-tags], [ERROR_CXXFLAGS=\"$ERROR_CXXFLAGS -Werror=mismatched-tags\"], [], [$CXXFLAG_WERROR])\n+\n+  if test x$suppress_external_warnings != xno ; then\n+    AX_CHECK_COMPILE_FLAG([-Werror=documentation],[ERROR_CXXFLAGS=\"$ERROR_CXXFLAGS -Werror=documentation\"],,[[$CXXFLAG_WERROR]])\n+  fi\n fi\n \n if test \"x$CXXFLAGS_overridden\" = \"xno\"; then\n@@ -466,13 +470,16 @@ if test \"x$CXXFLAGS_overridden\" = \"xno\"; then\n                         [AC_LANG_SOURCE([[struct A { virtual void f(); }; struct B : A { void f() final; };]])])\n   AX_CHECK_COMPILE_FLAG([-Wunreachable-code-loop-increment],[WARN_CXXFLAGS=\"$WARN_CXXFLAGS -Wunreachable-code-loop-increment\"],,[[$CXXFLAG_WERROR]])\n \n+  if test x$suppress_external_warnings != xno ; then\n+    AX_CHECK_COMPILE_FLAG([-Wdocumentation],[WARN_CXXFLAGS=\"$WARN_CXXFLAGS -Wdocumentation\"],,[[$CXXFLAG_WERROR]])\n+  fi\n+\n   dnl Some compilers (gcc) ignore unknown -Wno-* options, but warn about all\n   dnl unknown options if any other warning is produced. Test the -Wfoo case, and\n   dnl set the -Wno-foo case if it works.\n   AX_CHECK_COMPILE_FLAG([-Wunused-parameter],[NOWARN_CXXFLAGS=\"$NOWARN_CXXFLAGS -Wno-unused-parameter\"],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_COMPILE_FLAG([-Wself-assign],[NOWARN_CXXFLAGS=\"$NOWARN_CXXFLAGS -Wno-self-assign\"],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_COMPILE_FLAG([-Wunused-local-typedef],[NOWARN_CXXFLAGS=\"$NOWARN_CXXFLAGS -Wno-unused-local-typedef\"],,[[$CXXFLAG_WERROR]])\n-  AX_CHECK_COMPILE_FLAG([-Wdeprecated-register],[NOWARN_CXXFLAGS=\"$NOWARN_CXXFLAGS -Wno-deprecated-register\"],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_COMPILE_FLAG([-Wimplicit-fallthrough],[NOWARN_CXXFLAGS=\"$NOWARN_CXXFLAGS -Wno-implicit-fallthrough\"],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_COMPILE_FLAG([-Wdeprecated-copy],[NOWARN_CXXFLAGS=\"$NOWARN_CXXFLAGS -Wno-deprecated-copy\"],,[[$CXXFLAG_WERROR]])\n fi\n@@ -1486,6 +1493,10 @@ if test x$build_bitcoin_cli$build_bitcoind$bitcoin_enable_qt$use_tests$use_bench\n   if test x$TARGET_OS != xwindows; then\n     PKG_CHECK_MODULES([EVENT_PTHREADS], [libevent_pthreads >= 2.0.21],, [AC_MSG_ERROR([libevent_pthreads version 2.0.21 or greater not found.])])\n   fi\n+\n+  if test x$suppress_external_warnings != xno; then\n+    EVENT_CFLAGS=SUPPRESS_WARNINGS($EVENT_CFLAGS)\n+  fi\n fi\n \n dnl QR Code encoding library check"
      },
      {
        "sha": "bc5535b4c7747163b1db6b0450b6219620d3b888",
        "filename": "contrib/debian/copyright",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/debian/copyright",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/debian/copyright",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/copyright?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -87,7 +87,7 @@ Files: src/qt/res/icons/proxy.png\n Copyright: Cristian Mircea Messel\n License: public-domain\n \n-Files: src/qt/fonts/RobotoMono-Bold.ttf\n+Files: src/qt/res/fonts/RobotoMono-Bold.ttf\n License: Apache-2.0\n Comment: Site: https://fonts.google.com/specimen/Roboto+Mono\n "
      },
      {
        "sha": "330fbc041b31ac8f1a828f7eccca76f866cc51b7",
        "filename": "contrib/gitian-descriptors/assign_DISTNAME",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/gitian-descriptors/assign_DISTNAME",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/gitian-descriptors/assign_DISTNAME",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/assign_DISTNAME?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -4,7 +4,7 @@\n #\n # A helper script to be sourced into the gitian descriptors\n \n-if RECENT_TAG=\"$(git describe --exact-match HEAD)\"; then\n+if RECENT_TAG=\"$(git describe --exact-match HEAD 2> /dev/null)\"; then\n     VERSION=\"${RECENT_TAG#v}\"\n else\n     VERSION=\"$(git rev-parse --short=12 HEAD)\""
      },
      {
        "sha": "b13ad17c81e17ece7d560768a7b6a8e59e2e3be0",
        "filename": "contrib/guix/README.md",
        "status": "modified",
        "additions": 104,
        "deletions": 5,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/guix/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/guix/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/README.md?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -80,6 +80,50 @@ at the end of the `guix pull`)\n export PATH=\"${HOME}/.config/guix/current/bin${PATH:+:}$PATH\"\n ```\n \n+### Controlling the number of threads used by `guix` build commands\n+\n+By default, the scripts under `./contrib/guix` will invoke all `guix` build\n+commands with `--cores=\"$JOBS\"`. Note that `$JOBS` defaults to `$(nproc)` if not\n+specified. However, astute manual readers will also notice that there is a\n+`--max-jobs=` flag (which defaults to 1 if unspecified).\n+\n+Here is the difference between `--cores=` and `--max-jobs=`:\n+\n+> Note: When I say \"derivation,\" think \"package\"\n+\n+`--cores=`\n+\n+  - controls the number of CPU cores to build each derivation. This is the value\n+    passed to `make`'s `--jobs=` flag.\n+\n+`--max-jobs=`\n+\n+  - controls how many derivations can be built in parallel\n+  - defaults to 1\n+\n+Therefore, the default is for `guix` build commands to build one derivation at a\n+time, utilizing `$JOBS` threads.\n+\n+Specifying the `$JOBS` environment variable will only modify `--cores=`, but you\n+can also modify the value for `--max-jobs=` by specifying\n+`$ADDITIONAL_GUIX_COMMON_FLAGS`. For example, if you have a LOT of memory, you\n+may want to set:\n+\n+```sh\n+export ADDITIONAL_GUIX_COMMON_FLAGS='--max-jobs=8'\n+```\n+\n+Which allows for a maximum of 8 derivations to be built at the same time, each\n+utilizing `$JOBS` threads.\n+\n+Or, if you'd like to avoid spurious build failures caused by issues with\n+parallelism within a single package, but would still like to build multiple\n+packages when the dependency graph allows for it, you may want to try:\n+\n+```sh\n+export JOBS=1 ADDITIONAL_GUIX_COMMON_FLAGS='--max-jobs=8'\n+```\n+\n ## Usage\n \n ### As a Tool for Deterministic Builds\n@@ -125,12 +169,16 @@ find output/ -type f -print0 | sort -z | xargs -r0 sha256sum\n   the actual SDK (e.g. SDK_PATH=$HOME/Downloads/macOS-SDKs instead of\n   $HOME/Downloads/macOS-SDKs/Xcode-11.3.1-11C505-extracted-SDK-with-libcxx-headers).\n \n-* _**MAX_JOBS**_\n+* _**JOBS**_\n+\n+  Override the number of jobs to run simultaneously, you might want to do so on\n+  a memory-limited machine. This may be passed to:\n+\n+  - `guix` build commands as in `guix environment --cores=\"$JOBS\"`\n+  - `make` as in `make --jobs=\"$JOBS\"`\n+  - `xargs` as in `xargs -P\"$JOBS\"`\n \n-  Override the maximum number of jobs to run simultaneously, you might want to\n-  do so on a memory-limited machine. This may be passed to `make` as in `make\n-  --jobs=\"$MAX_JOBS\"` or `xargs` as in `xargs -P\"$MAX_JOBS\"`. _(defaults to the\n-  value of `nproc` outside the container)_\n+  _(defaults to the value of `nproc` outside the container)_\n \n * _**SOURCE_DATE_EPOCH**_\n \n@@ -217,6 +265,57 @@ To use dongcarl's substitute server for Bitcoin Core builds after having\n export SUBSTITUTE_URLS='https://guix.carldong.io https://ci.guix.gnu.org'\n ```\n \n+## Troubleshooting\n+\n+### Derivation failed to build\n+\n+When you see a build failure like below:\n+\n+```\n+building /gnu/store/...-foo-3.6.12.drv...\n+/ 'check' phasenote: keeping build directory `/tmp/guix-build-foo-3.6.12.drv-0'\n+builder for `/gnu/store/...-foo-3.6.12.drv' failed with exit code 1\n+build of /gnu/store/...-foo-3.6.12.drv failed\n+View build log at '/var/log/guix/drvs/../...-foo-3.6.12.drv.bz2'.\n+cannot build derivation `/gnu/store/...-qux-7.69.1.drv': 1 dependencies couldn't be built\n+cannot build derivation `/gnu/store/...-bar-3.16.5.drv': 1 dependencies couldn't be built\n+cannot build derivation `/gnu/store/...-baz-2.0.5.drv': 1 dependencies couldn't be built\n+guix time-machine: error: build of `/gnu/store/...-baz-2.0.5.drv' failed\n+```\n+\n+It means that `guix` failed to build a package named `foo`, which was a\n+dependency of `qux`, `bar`, and `baz`. Importantly, note that the last \"failed\"\n+line is not necessarily the root cause, the first \"failed\" line is.\n+\n+Most of the time, the build failure is due to a spurious test failure or the\n+package's build system/test suite breaking when running multi-threaded. To\n+rebuild _just_ this derivation in a single-threaded fashion:\n+\n+```sh\n+$ guix build --cores=1 /gnu/store/...-foo-3.6.12.drv\n+```\n+\n+If the single-threaded rebuild did not succeed, you may need to dig deeper.\n+You may view `foo`'s build logs in `less` like so (please replace paths with the\n+path you see in the build failure output):\n+\n+```sh\n+$ bzcat /var/log/guix/drvs/../...-foo-3.6.12.drv.bz2 | less\n+```\n+\n+`foo`'s build directory is also preserved and available at\n+`/tmp/guix-build-foo-3.6.12.drv-0`. However, if you fail to build `foo` multiple\n+times, it may be `/tmp/...drv-1` or `/tmp/...drv-2`. Always consult the build\n+failure output for the most accurate, up-to-date information.\n+\n+#### python(-minimal): [Errno 84] Invalid or incomplete multibyte or wide character\n+\n+This error occurs when your `$TMPDIR` (default: /tmp) exists on a filesystem\n+which rejects characters not present in the UTF-8 character code set. An example\n+is ZFS with the utf8only=on option set.\n+\n+More information: https://bugs.python.org/issue37584\n+\n ## FAQ\n \n ### How can I trust the binary installation?"
      },
      {
        "sha": "5b3c20b234804e0a207ea859bb3a3fd9bb3fdc00",
        "filename": "contrib/guix/guix-build",
        "status": "renamed",
        "additions": 158,
        "deletions": 49,
        "changes": 207,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/guix/guix-build",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/guix/guix-build",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/guix-build?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -2,22 +2,26 @@\n export LC_ALL=C\n set -e -o pipefail\n \n+# Source the common prelude, which:\n+#   1. Checks if we're at the top directory of the Bitcoin Core repository\n+#   2. Defines a few common functions and variables\n+#\n+# shellcheck source=libexec/prelude.bash\n+source \"$(dirname \"${BASH_SOURCE[0]}\")/libexec/prelude.bash\"\n+\n+\n ###################\n-## Sanity Checks ##\n+## SANITY CHECKS ##\n ###################\n \n ################\n-# Check 1: Make sure that we can invoke required tools\n+# Required non-builtin commands should be invocable\n ################\n-for cmd in git make guix cat mkdir curl; do\n-    if ! command -v \"$cmd\" > /dev/null 2>&1; then\n-        echo \"ERR: This script requires that '$cmd' is installed and available in your \\$PATH\"\n-        exit 1\n-    fi\n-done\n+\n+check_tools cat mkdir make git guix\n \n ################\n-# Check 2: Make sure GUIX_BUILD_OPTIONS is empty\n+# GUIX_BUILD_OPTIONS should be empty\n ################\n #\n # GUIX_BUILD_OPTIONS is an environment variable recognized by guix commands that\n@@ -45,8 +49,9 @@ exit 1\n fi\n \n ################\n-# Check 3: Make sure that we're not in a dirty worktree\n+# The git worktree should not be dirty\n ################\n+\n if ! git diff-index --quiet HEAD -- && [ -z \"$FORCE_DIRTY_WORKTREE\" ]; then\n cat << EOF\n ERR: The current git worktree is dirty, which may lead to broken builds.\n@@ -60,27 +65,25 @@ Hint: To make your git worktree clean, You may want to:\n          using a dirty worktree\n EOF\n exit 1\n-else\n-    GIT_COMMIT=$(git rev-parse --short=12 HEAD)\n fi\n \n+mkdir -p \"$VERSION_BASE\"\n+\n ################\n-# Check 4: Make sure that build directories do not exist\n+# Build directories should not exist\n ################\n \n # Default to building for all supported HOSTs (overridable by environment)\n export HOSTS=\"${HOSTS:-x86_64-linux-gnu arm-linux-gnueabihf aarch64-linux-gnu riscv64-linux-gnu powerpc64-linux-gnu powerpc64le-linux-gnu\n                        x86_64-w64-mingw32\n                        x86_64-apple-darwin18}\"\n \n-DISTSRC_BASE=\"${DISTSRC_BASE:-${PWD}}\"\n-\n # Usage: distsrc_for_host HOST\n #\n #   HOST: The current platform triple we're building for\n #\n distsrc_for_host() {\n-    echo \"${DISTSRC_BASE}/distsrc-${GIT_COMMIT}-${1}\"\n+    echo \"${DISTSRC_BASE}/distsrc-${VERSION}-${1}\"\n }\n \n # Accumulate a list of build directories that already exist...\n@@ -100,24 +103,31 @@ ERR: Build directories for this commit already exist for the following platform\n \n      Aborting...\n \n+Hint: To blow everything away, you may want to use:\n+\n+  $ ./contrib/guix/guix-clean\n+\n+Specifically, this will remove all files without an entry in the index,\n+excluding the SDK directory, the depends download cache, the depends built\n+packages cache, the garbage collector roots for Guix environments, and the\n+output directory.\n EOF\n for host in $hosts_distsrc_exists; do\n     echo \"     ${host} '$(distsrc_for_host \"$host\")'\"\n done\n exit 1\n else\n-\n     mkdir -p \"$DISTSRC_BASE\"\n fi\n \n ################\n-# Check 5: When building for darwin, make sure that the macOS SDK exists\n+# When building for darwin, the macOS SDK should exists\n ################\n \n for host in $HOSTS; do\n     case \"$host\" in\n         *darwin*)\n-            OSX_SDK=\"$(make -C \"${PWD}/depends\" --no-print-directory HOST=\"$host\" print-OSX_SDK | sed 's@^[^=]\\+=[[:space:]]\\+@@g')\"\n+            OSX_SDK=\"$(make -C \"${PWD}/depends\" --no-print-directory HOST=\"$host\" print-OSX_SDK | sed 's@^[^=]\\+=@@g')\"\n             if [ -e \"$OSX_SDK\" ]; then\n                 echo \"Found macOS SDK at '${OSX_SDK}', using...\"\n             else\n@@ -128,13 +138,40 @@ for host in $HOSTS; do\n     esac\n done\n \n+################\n+# Check that we can connect to the guix-daemon\n+################\n+\n+cat << EOF\n+Checking that we can connect to the guix-daemon...\n+\n+Hint: If this hangs, you may want to try turning your guix-daemon off and on\n+      again.\n+\n+EOF\n+if ! guix gc --list-failures > /dev/null; then\n+cat << EOF\n+\n+ERR: Failed to connect to the guix-daemon, please ensure that one is running and\n+     reachable.\n+EOF\n+exit 1\n+fi\n+\n+# Developer note: we could use `guix repl` for this check and run:\n+#\n+#     (import (guix store)) (close-connection (open-connection))\n+#\n+# However, the internal API is likely to change more than the CLI invocation\n+\n+\n #########\n-# Setup #\n+# SETUP #\n #########\n \n # Determine the maximum number of jobs to run simultaneously (overridable by\n # environment)\n-MAX_JOBS=\"${MAX_JOBS:-$(nproc)}\"\n+JOBS=\"${JOBS:-$(nproc)}\"\n \n # Usage: host_to_commonname HOST\n #\n@@ -149,12 +186,6 @@ host_to_commonname() {\n     esac\n }\n \n-# Download the depends sources now as we won't have internet access in the build\n-# container\n-for host in $HOSTS; do\n-  make -C \"${PWD}/depends\" -j\"$MAX_JOBS\" download-\"$(host_to_commonname \"$host\")\" ${V:+V=1} ${SOURCES_PATH:+SOURCES_PATH=\"$SOURCES_PATH\"}\n-done\n-\n # Determine the reference time used for determinism (overridable by environment)\n SOURCE_DATE_EPOCH=\"${SOURCE_DATE_EPOCH:-$(git log --format=%at -1)}\"\n \n@@ -164,44 +195,117 @@ time-machine() {\n     # shellcheck disable=SC2086\n     guix time-machine --url=https://github.com/dongcarl/guix.git \\\n                       --commit=490e39ff303f4f6873a04bfb8253755bdae1b29c \\\n-                      --max-jobs=\"$MAX_JOBS\" \\\n+                      --cores=\"$JOBS\" \\\n                       --keep-failed \\\n+                      --fallback \\\n                       ${SUBSTITUTE_URLS:+--substitute-urls=\"$SUBSTITUTE_URLS\"} \\\n                       ${ADDITIONAL_GUIX_COMMON_FLAGS} ${ADDITIONAL_GUIX_TIMEMACHINE_FLAGS} \\\n                       -- \"$@\"\n }\n \n+\n+# Precious directories are those which should not be cleaned between successive\n+# guix builds\n+depends_precious_dir_names='SOURCES_PATH BASE_CACHE SDK_PATH'\n+precious_dir_names=\"${depends_precious_dir_names} OUTDIR_BASE PROFILES_BASE\"\n+\n+# Usage: contains IFS-SEPARATED-LIST ITEM\n+contains() {\n+    for i in ${1}; do\n+        if [ \"$i\" = \"${2}\" ]; then\n+            return 0  # Found!\n+        fi\n+    done\n+    return 1\n+}\n+\n+# If the user explicitly specified a precious directory, create it so we\n+# can map it into the container\n+for precious_dir_name in $precious_dir_names; do\n+    precious_dir_path=\"${!precious_dir_name}\"\n+    if [ -n \"$precious_dir_path\" ]; then\n+        if [ ! -e \"$precious_dir_path\" ]; then\n+            mkdir -p \"$precious_dir_path\"\n+        elif [ -L \"$precious_dir_path\" ]; then\n+            echo \"ERR: ${precious_dir_name} cannot be a symbolic link\"\n+            exit 1\n+        elif [ ! -d \"$precious_dir_path\" ]; then\n+            echo \"ERR: ${precious_dir_name} must be a directory\"\n+            exit 1\n+        fi\n+    fi\n+done\n+\n+mkdir -p \"$VAR_BASE\"\n+\n+# Record the _effective_ values of precious directories such that guix-clean can\n+# avoid clobbering them if appropriate.\n+#\n+# shellcheck disable=SC2046,SC2086\n+{\n+    # Get depends precious dir definitions from depends\n+    make -C \"${PWD}/depends\" \\\n+         --no-print-directory \\\n+         -- $(printf \"print-%s\\n\" $depends_precious_dir_names)\n+\n+    # Get remaining precious dir definitions from the environment\n+    for precious_dir_name in $precious_dir_names; do\n+        precious_dir_path=\"${!precious_dir_name}\"\n+        if ! contains \"$depends_precious_dir_names\" \"$precious_dir_name\"; then\n+            echo \"${precious_dir_name}=${precious_dir_path}\"\n+        fi\n+    done\n+} > \"${VAR_BASE}/precious_dirs\"\n+\n # Make sure an output directory exists for our builds\n-OUTDIR=\"${OUTDIR:-${PWD}/output}\"\n-[ -e \"$OUTDIR\" ] || mkdir -p \"$OUTDIR\"\n+OUTDIR_BASE=\"${OUTDIR_BASE:-${VERSION_BASE}/output}\"\n+mkdir -p \"$OUTDIR_BASE\"\n+\n+# Download the depends sources now as we won't have internet access in the build\n+# container\n+for host in $HOSTS; do\n+    make -C \"${PWD}/depends\" -j\"$JOBS\" download-\"$(host_to_commonname \"$host\")\" ${V:+V=1} ${SOURCES_PATH:+SOURCES_PATH=\"$SOURCES_PATH\"}\n+done\n+\n+# Usage: outdir_for_host HOST\n+#\n+#   HOST: The current platform triple we're building for\n+#\n+outdir_for_host() {\n+    echo \"${OUTDIR_BASE}/${1}\"\n+}\n+\n+# Usage: profiledir_for_host HOST COMMAND\n+#\n+#   HOST: The current platform triple we're building for\n+#\n+profiledir_for_host() {\n+    echo \"${PROFILES_BASE}/${2}-${1}\"\n+}\n+\n \n #########\n-# Build #\n+# BUILD #\n #########\n \n # Function to be called when building for host ${1} and the user interrupts the\n # build\n int_trap() {\n cat << EOF\n ** INT received while building ${1}, you may want to clean up the relevant\n-   output, deploy, and distsrc-* directories before rebuilding\n+   work directories (e.g. distsrc-*) before rebuilding\n \n Hint: To blow everything away, you may want to use:\n \n-  $ git clean -xdff --exclude='/depends/SDKs/*'\n+  $ ./contrib/guix/guix-clean\n \n Specifically, this will remove all files without an entry in the index,\n-excluding the SDK directory. Practically speaking, this means that all ignored\n-and untracked files and directories will be wiped, allowing you to start anew.\n+excluding the SDK directory, the depends download cache, the depends built\n+packages cache, the garbage collector roots for Guix environments, and the\n+output directory.\n EOF\n }\n \n-# Create SOURCES_PATH, BASE_CACHE, and SDK_PATH if they are non-empty so that we\n-# can map them into the container\n-[ -z \"$SOURCES_PATH\" ] || mkdir -p \"$SOURCES_PATH\"\n-[ -z \"$BASE_CACHE\" ]   || mkdir -p \"$BASE_CACHE\"\n-[ -z \"$SDK_PATH\" ]     || mkdir -p \"$SDK_PATH\"\n-\n # Deterministically build Bitcoin Core\n # shellcheck disable=SC2153\n for host in $HOSTS; do\n@@ -216,15 +320,15 @@ for host in $HOSTS; do\n \n         # shellcheck disable=SC2030\n cat << EOF\n-INFO: Building commit ${GIT_COMMIT:?not set} for platform triple ${HOST:?not set}:\n+INFO: Building ${VERSION:?not set} for platform triple ${HOST:?not set}:\n       ...using reference timestamp: ${SOURCE_DATE_EPOCH:?not set}\n-      ...running at most ${MAX_JOBS:?not set} jobs\n+      ...running at most ${JOBS:?not set} jobs\n       ...from worktree directory: '${PWD}'\n           ...bind-mounted in container to: '/bitcoin'\n       ...in build directory: '$(distsrc_for_host \"$HOST\")'\n           ...bind-mounted in container to: '$(DISTSRC_BASE=/distsrc-base && distsrc_for_host \"$HOST\")'\n-      ...outputting in: '${OUTDIR:?not set}'\n-          ...bind-mounted in container to: '/outdir'\n+      ...outputting in: '$(outdir_for_host \"$HOST\")'\n+          ...bind-mounted in container to: '$(OUTDIR_BASE=/outdir-base && outdir_for_host \"$HOST\")'\n EOF\n \n         # Run the build script 'contrib/guix/libexec/build.sh' in the build\n@@ -299,24 +403,29 @@ EOF\n                                  --no-cwd \\\n                                  --share=\"$PWD\"=/bitcoin \\\n                                  --share=\"$DISTSRC_BASE\"=/distsrc-base \\\n-                                 --share=\"$OUTDIR\"=/outdir \\\n+                                 --share=\"$OUTDIR_BASE\"=/outdir-base \\\n                                  --expose=\"$(git rev-parse --git-common-dir)\" \\\n                                  ${SOURCES_PATH:+--share=\"$SOURCES_PATH\"} \\\n                                  ${BASE_CACHE:+--share=\"$BASE_CACHE\"} \\\n                                  ${SDK_PATH:+--share=\"$SDK_PATH\"} \\\n-                                 --max-jobs=\"$MAX_JOBS\" \\\n+                                 --cores=\"$JOBS\" \\\n                                  --keep-failed \\\n+                                 --fallback \\\n+                                 --link-profile \\\n+                                 --root=\"$(profiledir_for_host \"${HOST}\" build)\" \\\n                                  ${SUBSTITUTE_URLS:+--substitute-urls=\"$SUBSTITUTE_URLS\"} \\\n                                  ${ADDITIONAL_GUIX_COMMON_FLAGS} ${ADDITIONAL_GUIX_ENVIRONMENT_FLAGS} \\\n                                  -- env HOST=\"$host\" \\\n-                                        MAX_JOBS=\"$MAX_JOBS\" \\\n+                                        DISTNAME=\"$DISTNAME\" \\\n+                                        JOBS=\"$JOBS\" \\\n                                         SOURCE_DATE_EPOCH=\"${SOURCE_DATE_EPOCH:?unable to determine value}\" \\\n                                         ${V:+V=1} \\\n                                         ${SOURCES_PATH:+SOURCES_PATH=\"$SOURCES_PATH\"} \\\n                                         ${BASE_CACHE:+BASE_CACHE=\"$BASE_CACHE\"} \\\n                                         ${SDK_PATH:+SDK_PATH=\"$SDK_PATH\"} \\\n                                         DISTSRC=\"$(DISTSRC_BASE=/distsrc-base && distsrc_for_host \"$HOST\")\" \\\n-                                        OUTDIR=/outdir \\\n+                                        OUTDIR=\"$(OUTDIR_BASE=/outdir-base && outdir_for_host \"$HOST\")\" \\\n+                                        DIST_ARCHIVE_BASE=/outdir-base/dist-archive \\\n                                       bash -c \"cd /bitcoin && bash contrib/guix/libexec/build.sh\"\n     )\n ",
        "previous_filename": "contrib/guix/guix-build.sh"
      },
      {
        "sha": "9fa17191e80888902f52b30dcca16fd37adbf0cd",
        "filename": "contrib/guix/guix-clean",
        "status": "added",
        "additions": 83,
        "deletions": 0,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/guix/guix-clean",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/guix/guix-clean",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/guix-clean?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -0,0 +1,83 @@\n+#!/usr/bin/env bash\n+export LC_ALL=C\n+set -e -o pipefail\n+\n+# Source the common prelude, which:\n+#   1. Checks if we're at the top directory of the Bitcoin Core repository\n+#   2. Defines a few common functions and variables\n+#\n+# shellcheck source=libexec/prelude.bash\n+source \"$(dirname \"${BASH_SOURCE[0]}\")/libexec/prelude.bash\"\n+\n+\n+###################\n+## Sanity Checks ##\n+###################\n+\n+################\n+# Required non-builtin commands should be invokable\n+################\n+\n+check_tools cat mkdir make git guix\n+\n+\n+#############\n+##  Clean  ##\n+#############\n+\n+# Usage: under_dir MAYBE_PARENT MAYBE_CHILD\n+#\n+# If MAYBE_CHILD is a subdirectory of MAYBE_PARENT, print the relative path\n+# from MAYBE_PARENT to MAYBE_CHILD. Otherwise, return 1 as the error code.\n+#\n+# NOTE: This does not perform any symlink-resolving or path canonicalization.\n+#\n+under_dir() {\n+    local path_residue\n+    path_residue=\"${2##${1}}\"\n+    if [ -z \"$path_residue\" ] || [ \"$path_residue\" = \"$2\" ]; then\n+        return 1\n+    else\n+        echo \"$path_residue\"\n+    fi\n+}\n+\n+# Usage: dir_under_git_root MAYBE_CHILD\n+#\n+# If MAYBE_CHILD is under the current git repository and exists, print the\n+# relative path from the git repository's top-level directory to MAYBE_CHILD,\n+# otherwise, exit with an error code.\n+#\n+dir_under_git_root() {\n+    local rv\n+    rv=\"$(under_dir \"$(git_root)\" \"$1\")\"\n+    [ -n \"$rv\" ] && echo \"$rv\"\n+}\n+\n+shopt -s nullglob\n+found_precious_dirs_files=( \"${version_base_prefix}\"*/\"${var_base_basename}/precious_dirs\" ) # This expands to an array of directories...\n+shopt -u nullglob\n+\n+exclude_flags=()\n+\n+for precious_dirs_file in \"${found_precious_dirs_files[@]}\"; do\n+    # Make sure the precious directories (e.g. SOURCES_PATH, BASE_CACHE, SDK_PATH)\n+    # are excluded from git-clean\n+    echo \"Found precious_dirs file: '${precious_dirs_file}'\"\n+\n+    # Exclude the precious_dirs file itself\n+    if dirs_file_exclude_fragment=$(dir_under_git_root \"$(dirname \"$precious_dirs_file\")\"); then\n+        exclude_flags+=( --exclude=\"${dirs_file_exclude_fragment}/precious_dirs\" )\n+    fi\n+\n+    # Read each 'name=dir' pair from the precious_dirs file\n+    while IFS='=' read -r name dir; do\n+        # Add an exclusion flag if the precious directory is under the git root.\n+        if under=$(dir_under_git_root \"$dir\"); then\n+            echo \"Avoiding ${name}: ${under}\"\n+            exclude_flags+=( --exclude=\"$under\" )\n+        fi\n+    done < \"$precious_dirs_file\"\n+done\n+\n+git clean -xdff \"${exclude_flags[@]}\""
      },
      {
        "sha": "4239c3d4755566d08540b5e7617bafb88a709c21",
        "filename": "contrib/guix/libexec/build.sh",
        "status": "modified",
        "additions": 49,
        "deletions": 33,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/guix/libexec/build.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/guix/libexec/build.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/libexec/build.sh?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -24,9 +24,11 @@ fi\n # Check that required environment variables are set\n cat << EOF\n Required environment variables as seen inside the container:\n+    DIST_ARCHIVE_BASE: ${DIST_ARCHIVE_BASE:?not set}\n+    DISTNAME: ${DISTNAME:?not set}\n     HOST: ${HOST:?not set}\n     SOURCE_DATE_EPOCH: ${SOURCE_DATE_EPOCH:?not set}\n-    MAX_JOBS: ${MAX_JOBS:?not set}\n+    JOBS: ${JOBS:?not set}\n     DISTSRC: ${DISTSRC:?not set}\n     OUTDIR: ${OUTDIR:?not set}\n EOF\n@@ -52,16 +54,36 @@ store_path() {\n # Set environment variables to point the NATIVE toolchain to the right\n # includes/libs\n NATIVE_GCC=\"$(store_path gcc-toolchain)\"\n-export LIBRARY_PATH=\"${NATIVE_GCC}/lib:${NATIVE_GCC}/lib64\"\n-export CPATH=\"${NATIVE_GCC}/include\"\n+NATIVE_GCC_STATIC=\"$(store_path gcc-toolchain static)\"\n+\n+unset LIBRARY_PATH\n+unset CPATH\n unset C_INCLUDE_PATH\n unset CPLUS_INCLUDE_PATH\n+unset OBJC_INCLUDE_PATH\n+unset OBJCPLUS_INCLUDE_PATH\n+\n+export LIBRARY_PATH=\"${NATIVE_GCC}/lib:${NATIVE_GCC}/lib64:${NATIVE_GCC_STATIC}/lib:${NATIVE_GCC_STATIC}/lib64\"\n+export C_INCLUDE_PATH=\"${NATIVE_GCC}/include\"\n+export CPLUS_INCLUDE_PATH=\"${NATIVE_GCC}/include/c++:${NATIVE_GCC}/include\"\n+export OBJC_INCLUDE_PATH=\"${NATIVE_GCC}/include\"\n+export OBJCPLUS_INCLUDE_PATH=\"${NATIVE_GCC}/include/c++:${NATIVE_GCC}/include\"\n+\n+prepend_to_search_env_var() {\n+    export \"${1}=${2}${!1:+:}${!1}\"\n+}\n+\n case \"$HOST\" in\n     *darwin*)\n         # When targeting darwin, zlib is required by native_libdmg-hfsplus.\n         zlib_store_path=$(store_path \"zlib\")\n-        export LIBRARY_PATH=\"${zlib_store_path}/lib:${LIBRARY_PATH}\"\n-        export CPATH=\"${zlib_store_path}/include:${CPATH}\"\n+        zlib_static_store_path=$(store_path \"zlib\" static)\n+\n+        prepend_to_search_env_var LIBRARY_PATH \"${zlib_static_store_path}/lib:${zlib_store_path}/lib\"\n+        prepend_to_search_env_var C_INCLUDE_PATH \"${zlib_store_path}/include\"\n+        prepend_to_search_env_var CPLUS_INCLUDE_PATH \"${zlib_store_path}/include\"\n+        prepend_to_search_env_var OBJC_INCLUDE_PATH \"${zlib_store_path}/include\"\n+        prepend_to_search_env_var OBJCPLUS_INCLUDE_PATH \"${zlib_store_path}/include\"\n esac\n \n # Set environment variables to point the CROSS toolchain to the right\n@@ -173,7 +195,7 @@ esac\n ####################\n \n # Build the depends tree, overriding variables that assume multilib gcc\n-make -C depends --jobs=\"$MAX_JOBS\" HOST=\"$HOST\" \\\n+make -C depends --jobs=\"$JOBS\" HOST=\"$HOST\" \\\n                                    ${V:+V=1} \\\n                                    ${SOURCES_PATH+SOURCES_PATH=\"$SOURCES_PATH\"} \\\n                                    ${BASE_CACHE+BASE_CACHE=\"$BASE_CACHE\"} \\\n@@ -198,11 +220,7 @@ make -C depends --jobs=\"$MAX_JOBS\" HOST=\"$HOST\" \\\n # Source Tarball Building #\n ###########################\n \n-# Define DISTNAME variable.\n-# shellcheck source=contrib/gitian-descriptors/assign_DISTNAME\n-source contrib/gitian-descriptors/assign_DISTNAME\n-\n-GIT_ARCHIVE=\"${OUTDIR}/src/${DISTNAME}.tar.gz\"\n+GIT_ARCHIVE=\"${DIST_ARCHIVE_BASE}/${DISTNAME}.tar.gz\"\n \n # Create the source tarball if not already there\n if [ ! -e \"$GIT_ARCHIVE\" ]; then\n@@ -267,14 +285,15 @@ mkdir -p \"$DISTSRC\"\n     sed -i.old 's/-lstdc++ //g' config.status libtool src/univalue/config.status src/univalue/libtool\n \n     # Build Bitcoin Core\n-    make --jobs=\"$MAX_JOBS\" ${V:+V=1}\n+    make --jobs=\"$JOBS\" ${V:+V=1}\n \n     # Perform basic ELF security checks on a series of executables.\n     make -C src --jobs=1 check-security ${V:+V=1}\n     # Check that executables only contain allowed gcc, glibc and libstdc++\n     # version symbols for Linux distro back-compatibility.\n     make -C src --jobs=1 check-symbols  ${V:+V=1}\n \n+    mkdir -p ${OUTDIR}\n     # Make the os-specific installers\n     case \"$HOST\" in\n         *mingw*)\n@@ -306,9 +325,6 @@ mkdir -p \"$DISTSRC\"\n                 osx_volname \\\n                 contrib/macdeploy/detached-sig-{apply,create}.sh \\\n                 \"${BASEPREFIX}/${HOST}\"/native/bin/dmg\n-            for util in codesign_allocate pagestuff; do\n-                cp --no-target-directory {\"${BASEPREFIX}/${HOST}/native/bin/${HOST}-\",\"unsigned-app-${HOST}/\"}\"$util\"\n-            done\n             mv --target-directory=\"unsigned-app-${HOST}\" dist\n             (\n                 cd \"unsigned-app-${HOST}\"\n@@ -344,7 +360,7 @@ mkdir -p \"$DISTSRC\"\n                 {\n                     find \"${DISTNAME}/bin\" -type f -executable -print0\n                     find \"${DISTNAME}/lib\" -type f -print0\n-                } | xargs -0 -n1 -P\"$MAX_JOBS\" -I{} \"${DISTSRC}/contrib/devtools/split-debug.sh\" {} {} {}.dbg\n+                } | xargs -0 -n1 -P\"$JOBS\" -I{} \"${DISTSRC}/contrib/devtools/split-debug.sh\" {} {} {}.dbg\n                 ;;\n         esac\n \n@@ -394,21 +410,21 @@ mkdir -p \"$DISTSRC\"\n                     || ( rm -f \"${OUTDIR}/${DISTNAME}-${HOST//x86_64-apple-darwin18/osx64}.tar.gz\" && exit 1 )\n                 ;;\n         esac\n-    )\n-)\n+    )  # $DISTSRC/installed\n \n-case \"$HOST\" in\n-    *mingw*)\n-        cp -rf --target-directory=. contrib/windeploy\n-        (\n-            cd ./windeploy\n-            mkdir unsigned\n-            cp --target-directory=unsigned/ \"${OUTDIR}/${DISTNAME}-win64-setup-unsigned.exe\"\n-            find . -print0 \\\n-                | sort --zero-terminated \\\n-                | tar --create --no-recursion --mode='u+rw,go+r-w,a+X' --null --files-from=- \\\n-                | gzip -9n > \"${OUTDIR}/${DISTNAME}-win-unsigned.tar.gz\" \\\n-                || ( rm -f \"${OUTDIR}/${DISTNAME}-win-unsigned.tar.gz\" && exit 1 )\n-        )\n-        ;;\n-esac\n+    case \"$HOST\" in\n+        *mingw*)\n+            cp -rf --target-directory=. contrib/windeploy\n+            (\n+                cd ./windeploy\n+                mkdir -p unsigned\n+                cp --target-directory=unsigned/ \"${OUTDIR}/${DISTNAME}-win64-setup-unsigned.exe\"\n+                find . -print0 \\\n+                    | sort --zero-terminated \\\n+                    | tar --create --no-recursion --mode='u+rw,go+r-w,a+X' --null --files-from=- \\\n+                    | gzip -9n > \"${OUTDIR}/${DISTNAME}-win-unsigned.tar.gz\" \\\n+                    || ( rm -f \"${OUTDIR}/${DISTNAME}-win-unsigned.tar.gz\" && exit 1 )\n+            )\n+            ;;\n+    esac\n+)  # $DISTSRC"
      },
      {
        "sha": "9705607119fb5ebd180c77c162cf09e77826053f",
        "filename": "contrib/guix/libexec/prelude.bash",
        "status": "added",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/guix/libexec/prelude.bash",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/guix/libexec/prelude.bash",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/libexec/prelude.bash?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -0,0 +1,66 @@\n+#!/usr/bin/env bash\n+export LC_ALL=C\n+set -e -o pipefail\n+\n+# shellcheck source=../../shell/realpath.bash\n+source contrib/shell/realpath.bash\n+\n+# shellcheck source=../../shell/git-utils.bash\n+source contrib/shell/git-utils.bash\n+\n+################\n+# Required non-builtin commands should be invocable\n+################\n+\n+check_tools() {\n+    for cmd in \"$@\"; do\n+        if ! command -v \"$cmd\" > /dev/null 2>&1; then\n+            echo \"ERR: This script requires that '$cmd' is installed and available in your \\$PATH\"\n+            exit 1\n+        fi\n+    done\n+}\n+\n+check_tools cat env readlink dirname basename git\n+\n+################\n+# We should be at the top directory of the repository\n+################\n+\n+same_dir() {\n+    local resolved1 resolved2\n+    resolved1=\"$(bash_realpath \"${1}\")\"\n+    resolved2=\"$(bash_realpath \"${2}\")\"\n+    [ \"$resolved1\" = \"$resolved2\" ]\n+}\n+\n+if ! same_dir \"${PWD}\" \"$(git_root)\"; then\n+cat << EOF\n+ERR: This script must be invoked from the top level of the git repository\n+\n+Hint: This may look something like:\n+    env FOO=BAR ./contrib/guix/guix-<blah>\n+\n+EOF\n+exit 1\n+fi\n+\n+################\n+# Set common variables\n+################\n+\n+VERSION=\"${VERSION:-$(git_head_version)}\"\n+DISTNAME=\"${DISTNAME:-bitcoin-${VERSION}}\"\n+\n+version_base_prefix=\"${PWD}/guix-build-\"\n+VERSION_BASE=\"${version_base_prefix}${VERSION}\"  # TOP\n+\n+DISTSRC_BASE=\"${DISTSRC_BASE:-${VERSION_BASE}}\"\n+\n+OUTDIR_BASE=\"${OUTDIR_BASE:-${VERSION_BASE}/output}\"\n+\n+var_base_basename=\"var\"\n+VAR_BASE=\"${VAR_BASE:-${VERSION_BASE}/${var_base_basename}}\"\n+\n+profiles_base_basename=\"profiles\"\n+PROFILES_BASE=\"${PROFILES_BASE:-${VAR_BASE}/${profiles_base_basename}}\""
      },
      {
        "sha": "910a9dd6f65230b4215c3c343dcbd1f127ab9f09",
        "filename": "contrib/guix/manifest.scm",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/guix/manifest.scm",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/guix/manifest.scm",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/manifest.scm?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -214,6 +214,7 @@ chain for \" target \" development.\"))\n         gzip\n         xz\n         zlib\n+        (list zlib \"static\")\n         ;; Build tools\n         gnu-make\n         libtool\n@@ -227,7 +228,8 @@ chain for \" target \" development.\"))\n         ;; Git\n         git\n         ;; Native gcc 7 toolchain\n-        gcc-toolchain-7)\n+        gcc-toolchain-7\n+        (list gcc-toolchain-7 \"static\"))\n   (let ((target (getenv \"HOST\")))\n     (cond ((string-suffix? \"-mingw32\" target)\n            ;; Windows\n@@ -237,5 +239,5 @@ chain for \" target \" development.\"))\n           ((string-contains target \"-linux-\")\n            (list (make-bitcoin-cross-toolchain target)))\n           ((string-contains target \"darwin\")\n-           (list clang-8 binutils imagemagick libtiff librsvg font-tuffy cmake xorriso))\n+           (list clang-toolchain-8 binutils imagemagick libtiff librsvg font-tuffy cmake xorriso))\n           (else '())))))"
      },
      {
        "sha": "d95069277df622da03c382e0058bc5adb93c1f15",
        "filename": "contrib/seeds/generate-seeds.py",
        "status": "modified",
        "additions": 62,
        "deletions": 41,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/seeds/generate-seeds.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/seeds/generate-seeds.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/seeds/generate-seeds.py?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2017 Wladimir J. van der Laan\n+# Copyright (c) 2014-2021 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n '''\n@@ -13,44 +13,47 @@\n \n These files must consist of lines in the format\n \n-    <ip>\n     <ip>:<port>\n-    [<ipv6>]\n     [<ipv6>]:<port>\n-    <onion>.onion\n-    0xDDBBCCAA (IPv4 little-endian old pnSeeds format)\n+    <onion>.onion:<port>\n \n The output will be two data structures with the peers in binary format:\n \n-   static SeedSpec6 pnSeed6_main[]={\n-   ...\n-   }\n-   static SeedSpec6 pnSeed6_test[]={\n+   static const uint8_t chainparams_seed_{main,test}[]={\n    ...\n    }\n \n These should be pasted into `src/chainparamsseeds.h`.\n '''\n \n from base64 import b32decode\n-from binascii import a2b_hex\n+from enum import Enum\n+import struct\n import sys\n import os\n import re\n \n-# ipv4 in ipv6 prefix\n-pchIPv4 = bytearray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff])\n-# tor-specific ipv6 prefix\n-pchOnionCat = bytearray([0xFD,0x87,0xD8,0x7E,0xEB,0x43])\n-\n-def name_to_ipv6(addr):\n-    if len(addr)>6 and addr.endswith('.onion'):\n+class BIP155Network(Enum):\n+    IPV4 = 1\n+    IPV6 = 2\n+    TORV2 = 3\n+    TORV3 = 4\n+    I2P = 5\n+    CJDNS = 6\n+\n+def name_to_bip155(addr):\n+    '''Convert address string to BIP155 (networkID, addr) tuple.'''\n+    if addr.endswith('.onion'):\n         vchAddr = b32decode(addr[0:-6], True)\n-        if len(vchAddr) != 16-len(pchOnionCat):\n+        if len(vchAddr) == 10:\n+            return (BIP155Network.TORV2, vchAddr)\n+        elif len(vchAddr) == 35:\n+            assert(vchAddr[34] == 3)\n+            return (BIP155Network.TORV3, vchAddr[:32])\n+        else:\n             raise ValueError('Invalid onion %s' % vchAddr)\n-        return pchOnionCat + vchAddr\n     elif '.' in addr: # IPv4\n-        return pchIPv4 + bytearray((int(x) for x in addr.split('.')))\n+        return (BIP155Network.IPV4, bytes((int(x) for x in addr.split('.'))))\n     elif ':' in addr: # IPv6\n         sub = [[], []] # prefix, suffix\n         x = 0\n@@ -67,13 +70,12 @@ def name_to_ipv6(addr):\n                 sub[x].append(val & 0xff)\n         nullbytes = 16 - len(sub[0]) - len(sub[1])\n         assert((x == 0 and nullbytes == 0) or (x == 1 and nullbytes > 0))\n-        return bytearray(sub[0] + ([0] * nullbytes) + sub[1])\n-    elif addr.startswith('0x'): # IPv4-in-little-endian\n-        return pchIPv4 + bytearray(reversed(a2b_hex(addr[2:])))\n+        return (BIP155Network.IPV6, bytes(sub[0] + ([0] * nullbytes) + sub[1]))\n     else:\n         raise ValueError('Could not parse address %s' % addr)\n \n-def parse_spec(s, defaultport):\n+def parse_spec(s):\n+    '''Convert endpoint string to BIP155 (networkID, addr, port) tuple.'''\n     match = re.match(r'\\[([0-9a-fA-F:]+)\\](?::([0-9]+))?$', s)\n     if match: # ipv6\n         host = match.group(1)\n@@ -85,32 +87,52 @@ def parse_spec(s, defaultport):\n         (host,_,port) = s.partition(':')\n \n     if not port:\n-        port = defaultport\n+        port = 0\n     else:\n         port = int(port)\n \n-    host = name_to_ipv6(host)\n+    host = name_to_bip155(host)\n \n-    return (host,port)\n+    return host + (port, )\n \n-def process_nodes(g, f, structname, defaultport):\n-    g.write('static SeedSpec6 %s[] = {\\n' % structname)\n-    first = True\n+def ser_compact_size(l):\n+    r = b\"\"\n+    if l < 253:\n+        r = struct.pack(\"B\", l)\n+    elif l < 0x10000:\n+        r = struct.pack(\"<BH\", 253, l)\n+    elif l < 0x100000000:\n+        r = struct.pack(\"<BI\", 254, l)\n+    else:\n+        r = struct.pack(\"<BQ\", 255, l)\n+    return r\n+\n+def bip155_serialize(spec):\n+    '''\n+    Serialize (networkID, addr, port) tuple to BIP155 binary format.\n+    '''\n+    r = b\"\"\n+    r += struct.pack('B', spec[0].value)\n+    r += ser_compact_size(len(spec[1]))\n+    r += spec[1]\n+    r += struct.pack('>H', spec[2])\n+    return r\n+\n+def process_nodes(g, f, structname):\n+    g.write('static const uint8_t %s[] = {\\n' % structname)\n     for line in f:\n         comment = line.find('#')\n         if comment != -1:\n             line = line[0:comment]\n         line = line.strip()\n         if not line:\n             continue\n-        if not first:\n-            g.write(',\\n')\n-        first = False\n \n-        (host,port) = parse_spec(line, defaultport)\n-        hoststr = ','.join(('0x%02x' % b) for b in host)\n-        g.write('    {{%s}, %i}' % (hoststr, port))\n-    g.write('\\n};\\n')\n+        spec = parse_spec(line)\n+        blob = bip155_serialize(spec)\n+        hoststr = ','.join(('0x%02x' % b) for b in blob)\n+        g.write(f'    {hoststr},\\n')\n+    g.write('};\\n')\n \n def main():\n     if len(sys.argv)<2:\n@@ -124,14 +146,13 @@ def main():\n     g.write(' * List of fixed seed nodes for the bitcoin network\\n')\n     g.write(' * AUTOGENERATED by contrib/seeds/generate-seeds.py\\n')\n     g.write(' *\\n')\n-    g.write(' * Each line contains a 16-byte IPv6 address and a port.\\n')\n-    g.write(' * IPv4 as well as onion addresses are wrapped inside an IPv6 address accordingly.\\n')\n+    g.write(' * Each line contains a BIP155 serialized (networkID, addr, port) tuple.\\n')\n     g.write(' */\\n')\n     with open(os.path.join(indir,'nodes_main.txt'), 'r', encoding=\"utf8\") as f:\n-        process_nodes(g, f, 'pnSeed6_main', 8333)\n+        process_nodes(g, f, 'chainparams_seed_main')\n     g.write('\\n')\n     with open(os.path.join(indir,'nodes_test.txt'), 'r', encoding=\"utf8\") as f:\n-        process_nodes(g, f, 'pnSeed6_test', 18333)\n+        process_nodes(g, f, 'chainparams_seed_test')\n     g.write('#endif // BITCOIN_CHAINPARAMSSEEDS_H\\n')\n \n if __name__ == '__main__':"
      },
      {
        "sha": "c43caa73eb83b521903abea9850135273b4e45c1",
        "filename": "contrib/seeds/nodes_main.txt",
        "status": "modified",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/seeds/nodes_main.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/seeds/nodes_main.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/seeds/nodes_main.txt?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -1162,3 +1162,29 @@ zuytrfevzjcpizli.onion:8333\n zvq6dpt3i2ofdp3g.onion:8333\n zwwm6ga7u2hqe2sd.onion:8333\n zyqb4lenfspntj5m.onion:8333\n+\n+# manually added 2021-03 for minimal torv3 bootstrap support\n+2g5qfdkn2vvcbqhzcyvyiitg4ceukybxklraxjnu7atlhd22gdwywaid.onion:8333\n+2jmtxvyup3ijr7u6uvu7ijtnojx4g5wodvaedivbv74w4vzntxbrhvad.onion:8333\n+37m62wn7dz3uqpathpc4qfmgrbupachj52nt3jbtbjugpbu54kbud7yd.onion:8333\n+5g72ppm3krkorsfopcm2bi7wlv4ohhs4u4mlseymasn7g7zhdcyjpfid.onion:8333\n+7cgwjuwi5ehvcay4tazy7ya6463bndjk6xzrttw5t3xbpq4p22q6fyid.onion:8333\n+7pyrpvqdhmayxggpcyqn5l3m5vqkw3qubnmgwlpya2mdo6x7pih7r7id.onion:8333\n+b64xcbleqmwgq2u46bh4hegnlrzzvxntyzbmucn3zt7cssm7y4ubv3id.onion:8333\n+ejxefzf5fpst4mg2rib7grksvscl7p6fvjp6agzgfc2yglxnjtxc3aid.onion:8333\n+fjdyxicpm4o42xmedlwl3uvk5gmqdfs5j37wir52327vncjzvtpfv7yd.onion:8333\n+fpz6r5ppsakkwypjcglz6gcnwt7ytfhxskkfhzu62tnylcknh3eq6pad.onion:8333\n+fzhn4uoxfbfss7h7d6ffbn266ca432ekbbzvqtsdd55ylgxn4jucm5qd.onion:8333\n+gxo5anvfnffnftfy5frkgvplq3rpga2ie3tcblo2vl754fvnhgorn5yd.onion:8333\n+ifdu5qvbofrt4ekui2iyb3kbcyzcsglazhx2hn4wfskkrx2v24qxriid.onion:8333\n+itz3oxsihs62muvknc237xabl5f6w6rfznfhbpayrslv2j2ubels47yd.onion:8333\n+lrjh6fywjqttmlifuemq3puhvmshxzzyhoqx7uoufali57eypuenzzid.onion:8333\n+m7cbpjolo662uel7rpaid46as2otcj44vvwg3gccodnvaeuwbm3anbyd.onion:8333\n+opnyfyeiibe5qo5a3wbxzbb4xdiagc32bbce46owmertdknta5mi7uyd.onion:8333\n+owjsdxmzla6d7lrwkbmetywqym5cyswpihciesfl5qdv2vrmwsgy4uqd.onion:8333\n+q7kgmd7n7h27ds4fg7wocgniuqb3oe2zxp4nfe4skd5da6wyipibqzqd.onion:8333\n+rp7k2go3s5lyj3fnj6zn62ktarlrsft2ohlsxkyd7v3e3idqyptvread.onion:8333\n+sys54sv4xv3hn3sdiv3oadmzqpgyhd4u4xphv4xqk64ckvaxzm57a7yd.onion:8333\n+tddeij4qigtjr6jfnrmq6btnirmq5msgwcsdpcdjr7atftm7cxlqztid.onion:8333\n+vi5bnbxkleeqi6hfccjochnn65lcxlfqs4uwgmhudph554zibiusqnad.onion:8333\n+xqt25cobm5zqucac3634zfght72he6u3eagfyej5ellbhcdgos7t2had.onion:8333"
      },
      {
        "sha": "0af88d1bde45aa6f0903f402df4fa0810e6511af",
        "filename": "contrib/seeds/nodes_test.txt",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/seeds/nodes_test.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/seeds/nodes_test.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/seeds/nodes_test.txt?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -1,11 +1,11 @@\n # List of fixed seed nodes for testnet\n \n # Onion nodes\n-thfsmmn2jbitcoin.onion\n-it2pj4f7657g3rhi.onion\n-nkf5e6b7pl4jfd4a.onion\n-4zhkir2ofl7orfom.onion\n-t6xj6wilh4ytvcs7.onion\n-i6y6ivorwakd7nw3.onion\n-ubqj4rsu3nqtxmtp.onion\n+thfsmmn2jbitcoin.onion:18333\n+it2pj4f7657g3rhi.onion:18333\n+nkf5e6b7pl4jfd4a.onion:18333\n+4zhkir2ofl7orfom.onion:18333\n+t6xj6wilh4ytvcs7.onion:18333\n+i6y6ivorwakd7nw3.onion:18333\n+ubqj4rsu3nqtxmtp.onion:18333\n "
      },
      {
        "sha": "37bac1f38d8f087b4b0e073141bdd29a6a33f8ac",
        "filename": "contrib/shell/git-utils.bash",
        "status": "added",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/shell/git-utils.bash",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/shell/git-utils.bash",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/shell/git-utils.bash?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -0,0 +1,14 @@\n+#!/usr/bin/env bash\n+\n+git_root() {\n+    git rev-parse --show-toplevel 2> /dev/null\n+}\n+\n+git_head_version() {\n+    local recent_tag\n+    if recent_tag=\"$(git describe --exact-match HEAD 2> /dev/null)\"; then\n+        echo \"${recent_tag#v}\"\n+    else\n+        git rev-parse --short=12 HEAD\n+    fi\n+}"
      },
      {
        "sha": "389b77b56266d3e753598d5aa90d9642b2e7c30f",
        "filename": "contrib/shell/realpath.bash",
        "status": "added",
        "additions": 71,
        "deletions": 0,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/shell/realpath.bash",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/contrib/shell/realpath.bash",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/shell/realpath.bash?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -0,0 +1,71 @@\n+#!/usr/bin/env bash\n+\n+# Based on realpath.sh written by Michael Kropat\n+# Found at: https://github.com/mkropat/sh-realpath/blob/65512368b8155b176b67122aa395ac580d9acc5b/realpath.sh\n+\n+bash_realpath() {\n+    canonicalize_path \"$(resolve_symlinks \"$1\")\"\n+}\n+\n+resolve_symlinks() {\n+    _resolve_symlinks \"$1\"\n+}\n+\n+_resolve_symlinks() {\n+    _assert_no_path_cycles \"$@\" || return\n+\n+    local dir_context path\n+    if path=$(readlink -- \"$1\"); then\n+        dir_context=$(dirname -- \"$1\")\n+        _resolve_symlinks \"$(_prepend_dir_context_if_necessary \"$dir_context\" \"$path\")\" \"$@\"\n+    else\n+        printf '%s\\n' \"$1\"\n+    fi\n+}\n+\n+_prepend_dir_context_if_necessary() {\n+    if [ \"$1\" = . ]; then\n+        printf '%s\\n' \"$2\"\n+    else\n+        _prepend_path_if_relative \"$1\" \"$2\"\n+    fi\n+}\n+\n+_prepend_path_if_relative() {\n+    case \"$2\" in\n+        /* ) printf '%s\\n' \"$2\" ;;\n+         * ) printf '%s\\n' \"$1/$2\" ;;\n+    esac\n+}\n+\n+_assert_no_path_cycles() {\n+    local target path\n+\n+    target=$1\n+    shift\n+\n+    for path in \"$@\"; do\n+        if [ \"$path\" = \"$target\" ]; then\n+            return 1\n+        fi\n+    done\n+}\n+\n+canonicalize_path() {\n+    if [ -d \"$1\" ]; then\n+        _canonicalize_dir_path \"$1\"\n+    else\n+        _canonicalize_file_path \"$1\"\n+    fi\n+}\n+\n+_canonicalize_dir_path() {\n+    (cd \"$1\" 2>/dev/null && pwd -P)\n+}\n+\n+_canonicalize_file_path() {\n+    local dir file\n+    dir=$(dirname -- \"$1\")\n+    file=$(basename -- \"$1\")\n+    (cd \"$dir\" 2>/dev/null && printf '%s/%s\\n' \"$(pwd -P)\" \"$file\")\n+}"
      },
      {
        "sha": "c5dfd1e8a72824094930fc384f494fcf5226ba3a",
        "filename": "depends/Makefile",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/depends/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/depends/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/Makefile?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -2,7 +2,7 @@\n \n # Pattern rule to print variables, e.g. make print-top_srcdir\n print-%:\n-\t@echo '$*' = '$($*)'\n+\t@echo '$*'='$($*)'\n \n # When invoking a sub-make, keep only the command line variable definitions\n # matching the pattern in the filter function.\n@@ -141,8 +141,8 @@ build_id_string+=system_clang\n $(host_arch)_$(host_os)_id_string+=system_clang\n endif\n \n-build_id_string+=GUIX_ENVIRONMENT=$(GUIX_ENVIRONMENT)\n-$(host_arch)_$(host_os)_id_string+=GUIX_ENVIRONMENT=$(GUIX_ENVIRONMENT)\n+build_id_string+=GUIX_ENVIRONMENT=$(realpath $(GUIX_ENVIRONMENT))\n+$(host_arch)_$(host_os)_id_string+=GUIX_ENVIRONMENT=$(realpath $(GUIX_ENVIRONMENT))\n \n qrencode_packages_$(NO_QR) = $(qrencode_packages)\n "
      },
      {
        "sha": "6e1a922f89067a414b858b2771496dc854d3acf3",
        "filename": "depends/funcs.mk",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/depends/funcs.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/depends/funcs.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/funcs.mk?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -140,7 +140,13 @@ $(1)_config_env+=CMAKE_MODULE_PATH=$($($(1)_type)_prefix)/lib/cmake\n $(1)_config_env+=PATH=$(build_prefix)/bin:$(PATH)\n $(1)_build_env+=PATH=$(build_prefix)/bin:$(PATH)\n $(1)_stage_env+=PATH=$(build_prefix)/bin:$(PATH)\n-$(1)_autoconf=./configure --host=$($($(1)_type)_host) --prefix=$($($(1)_type)_prefix) $$($(1)_config_opts) CC=\"$$($(1)_cc)\" CXX=\"$$($(1)_cxx)\"\n+\n+# Setting a --build type that differs from --host will explicitly enable\n+# cross-compilation mode. Note that --build defaults to the output of\n+# config.guess, which is what we set it too here. This also quells autoconf\n+# warnings, \"If you wanted to set the --build type, don't use --host.\",\n+# when using versions older than 2.70.\n+$(1)_autoconf=./configure --build=$(BUILD) --host=$($($(1)_type)_host) --prefix=$($($(1)_type)_prefix) $$($(1)_config_opts) CC=\"$$($(1)_cc)\" CXX=\"$$($(1)_cxx)\"\n ifneq ($($(1)_nm),)\n $(1)_autoconf += NM=\"$$($(1)_nm)\"\n endif"
      },
      {
        "sha": "c7c8adef41580324169ac5be802beafa9860759f",
        "filename": "depends/packages/native_libdmg-hfsplus.mk",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/depends/packages/native_libdmg-hfsplus.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/depends/packages/native_libdmg-hfsplus.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/native_libdmg-hfsplus.mk?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -12,7 +12,7 @@ define $(package)_preprocess_cmds\n endef\n \n define $(package)_config_cmds\n-  $($(package)_cmake) -DCMAKE_C_FLAGS=\"$$($(1)_cflags) -Wl,--build-id=none\" ..\n+  $($(package)_cmake) -DCMAKE_C_FLAGS=\"$$($(1)_cflags) -Wl,--build-id=none\" -DCMAKE_SKIP_RPATH=\"ON\" -DCMAKE_EXE_LINKER_FLAGS=\"-static\" -DCMAKE_FIND_LIBRARY_SUFFIXES=\".a\" ..\n endef\n \n define $(package)_build_cmds"
      },
      {
        "sha": "ae83eae911caa0badf5e5ce1ba5871c0fc68cb5e",
        "filename": "depends/packages/qt.mk",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/depends/packages/qt.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/depends/packages/qt.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/qt.mk?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -10,7 +10,7 @@ $(package)_patches=fix_qt_pkgconfig.patch mac-qmake.conf fix_no_printer.patch no\n $(package)_patches+= fix_android_qmake_conf.patch fix_android_jni_static.patch dont_hardcode_pwd.patch\n $(package)_patches+= drop_lrelease_dependency.patch no_sdk_version_check.patch\n $(package)_patches+= fix_qpainter_non_determinism.patch fix_lib_paths.patch fix_android_pch.patch\n-$(package)_patches+= fix_bigsur_drawing.patch\n+$(package)_patches+= fix_bigsur_drawing.patch qtbase-moc-ignore-gcc-macro.patch\n \n $(package)_qttranslations_file_name=qttranslations-$($(package)_suffix)\n $(package)_qttranslations_sha256_hash=e1de58ed108b7e0a138815ea60fd46a2c4e1fc31396a707e5630e92de79c53de\n@@ -232,6 +232,7 @@ define $(package)_preprocess_cmds\n   patch -p1 -i $($(package)_patch_dir)/no_sdk_version_check.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/fix_lib_paths.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/fix_bigsur_drawing.patch && \\\n+  patch -p1 -i $($(package)_patch_dir)/qtbase-moc-ignore-gcc-macro.patch && \\\n   sed -i.old \"s|updateqm.commands = \\$$$$\\$$$$LRELEASE|updateqm.commands = $($(package)_extract_dir)/qttools/bin/lrelease|\" qttranslations/translations/translations.pro && \\\n   mkdir -p qtbase/mkspecs/macx-clang-linux &&\\\n   cp -f qtbase/mkspecs/macx-clang/qplatformdefs.h qtbase/mkspecs/macx-clang-linux/ &&\\"
      },
      {
        "sha": "0358bea6e940384ada32e83fa8ed5bf987b90a14",
        "filename": "depends/patches/qt/qtbase-moc-ignore-gcc-macro.patch",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/depends/patches/qt/qtbase-moc-ignore-gcc-macro.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/depends/patches/qt/qtbase-moc-ignore-gcc-macro.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/qtbase-moc-ignore-gcc-macro.patch?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -0,0 +1,17 @@\n+The moc executable loops through headers on CPLUS_INCLUDE_PATH and stumbles\n+on the GCC internal _GLIBCXX_VISIBILITY macro.  Tell it to ignore it as it is\n+not supposed to be looking there to begin with.\n+\n+Upstream report: https://bugreports.qt.io/browse/QTBUG-83160\n+\n+diff --git a/qtbase/src/tools/moc/main.cpp b/qtbase/src/tools/moc/main.cpp\n+--- a/qtbase/src/tools/moc/main.cpp\n++++ b/qtbase/src/tools/moc/main.cpp\n+@@ -188,6 +188,7 @@ int runMoc(int argc, char **argv)\n+     dummyVariadicFunctionMacro.arguments += Symbol(0, PP_IDENTIFIER, \"__VA_ARGS__\");\n+     pp.macros[\"__attribute__\"] = dummyVariadicFunctionMacro;\n+     pp.macros[\"__declspec\"] = dummyVariadicFunctionMacro;\n++    pp.macros[\"_GLIBCXX_VISIBILITY\"] = dummyVariadicFunctionMacro;\n+ \n+     QString filename;\n+     QString output;"
      },
      {
        "sha": "2130332eec8803dc42844154a7bd8e56e1025189",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -812,7 +812,7 @@ class ChainstateManager\n {\n public:\n     ...\n-    bool ProcessNewBlock(...) EXCLUSIVE_LOCKS_REQUIRED(!::cs_main);\n+    bool ProcessNewBlock(...) LOCKS_EXCLUDED(::cs_main);\n     ...\n }\n "
      },
      {
        "sha": "4ef94cf7543d5ef7a61b0475e6b38514a02c2701",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -126,6 +126,9 @@ Changes to Wallet or GUI related settings can be found in the GUI or Wallet sect\n \n - Passing an invalid `-rpcauth` argument now cause bitcoind to fail to start.  (#20461)\n \n+- The `getnodeaddresses` RPC now returns a \"network\" field indicating the\n+  network type (ipv4, ipv6, onion, or i2p) for each address.  (#21594)\n+\n Tools and Utilities\n -------------------\n "
      },
      {
        "sha": "b47bdfaa2695721c5ce47805d8125209eb7f3ee7",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -4,7 +4,7 @@\n \n # Pattern rule to print variables, e.g. make print-top_srcdir\n print-%:\n-\t@echo '$*' = '$($*)'\n+\t@echo '$*'='$($*)'\n \n DIST_SUBDIRS = secp256k1 univalue\n "
      },
      {
        "sha": "225b8b1ec40f7bb27b1c7c377da9f1d9466e1aa0",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -224,7 +224,7 @@ static bool AppInit(int argc, char* argv[])\n             // If locking the data directory failed, exit immediately\n             return false;\n         }\n-        fRet = AppInitInterfaces(node) && AppInitMain(context, node);\n+        fRet = AppInitInterfaces(node) && AppInitMain(node);\n     }\n     catch (const std::exception& e) {\n         PrintExceptionContinue(&e, \"AppInit()\");"
      },
      {
        "sha": "3e778838562d6a56c5e6856e1d1655338e3a36fc",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -56,7 +56,7 @@ static CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, uint32_t nBits\n }\n \n /**\n- * Main network\n+ * Main network on which people trade goods and services.\n  */\n class CMainParams : public CChainParams {\n public:\n@@ -134,7 +134,7 @@ class CMainParams : public CChainParams {\n \n         bech32_hrp = \"bc\";\n \n-        vFixedSeeds = std::vector<SeedSpec6>(std::begin(pnSeed6_main), std::end(pnSeed6_main));\n+        vFixedSeeds = std::vector<uint8_t>(std::begin(chainparams_seed_main), std::end(chainparams_seed_main));\n \n         fDefaultConsistencyChecks = false;\n         fRequireStandard = true;\n@@ -173,7 +173,7 @@ class CMainParams : public CChainParams {\n };\n \n /**\n- * Testnet (v3)\n+ * Testnet (v3): public test network which is reset from time to time.\n  */\n class CTestNetParams : public CChainParams {\n public:\n@@ -239,7 +239,7 @@ class CTestNetParams : public CChainParams {\n \n         bech32_hrp = \"tb\";\n \n-        vFixedSeeds = std::vector<SeedSpec6>(std::begin(pnSeed6_test), std::end(pnSeed6_test));\n+        vFixedSeeds = std::vector<uint8_t>(std::begin(chainparams_seed_test), std::end(chainparams_seed_test));\n \n         fDefaultConsistencyChecks = false;\n         fRequireStandard = false;\n@@ -266,7 +266,7 @@ class CTestNetParams : public CChainParams {\n };\n \n /**\n- * Signet\n+ * Signet: test network with an additional consensus parameter (see BIP325).\n  */\n class SigNetParams : public CChainParams {\n public:\n@@ -373,7 +373,8 @@ class SigNetParams : public CChainParams {\n };\n \n /**\n- * Regression test\n+ * Regression test: intended for private networks only. Has minimal difficulty to ensure that\n+ * blocks can be found instantly.\n  */\n class CRegTestParams : public CChainParams {\n public:\n@@ -440,7 +441,7 @@ class CRegTestParams : public CChainParams {\n         m_assumeutxo_data = MapAssumeutxo{\n             {\n                 110,\n-                {uint256S(\"0x76fd7334ac7c1baf57ddc0c626f073a655a35d98a4258cd1382c8cc2b8392e10\"), 110},\n+                {uint256S(\"0x1ebbf5850204c0bdb15bf030f47c7fe91d45c44c712697e4509ba67adb01c618\"), 110},\n             },\n             {\n                 210,"
      },
      {
        "sha": "6f231999868ab8d7cdf117ffbc5581ed832da492",
        "filename": "src/chainparams.h",
        "status": "modified",
        "additions": 3,
        "deletions": 11,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/chainparams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/chainparams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.h?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -14,11 +14,6 @@\n #include <memory>\n #include <vector>\n \n-struct SeedSpec6 {\n-    uint8_t addr[16];\n-    uint16_t port;\n-};\n-\n typedef std::map<int, uint256> MapCheckpoints;\n \n struct CCheckpointData {\n@@ -64,10 +59,7 @@ struct ChainTxData {\n \n /**\n  * CChainParams defines various tweakable parameters of a given instance of the\n- * Bitcoin system. There are three: the main network on which people trade goods\n- * and services, the public test network which gets reset from time to time and\n- * a regression test mode which is intended for private networks only. It has\n- * minimal difficulty to ensure that blocks can be found instantly.\n+ * Bitcoin system.\n  */\n class CChainParams\n {\n@@ -108,7 +100,7 @@ class CChainParams\n     const std::vector<std::string>& DNSSeeds() const { return vSeeds; }\n     const std::vector<unsigned char>& Base58Prefix(Base58Type type) const { return base58Prefixes[type]; }\n     const std::string& Bech32HRP() const { return bech32_hrp; }\n-    const std::vector<SeedSpec6>& FixedSeeds() const { return vFixedSeeds; }\n+    const std::vector<uint8_t>& FixedSeeds() const { return vFixedSeeds; }\n     const CCheckpointData& Checkpoints() const { return checkpointData; }\n \n     //! Get allowed assumeutxo configuration.\n@@ -130,7 +122,7 @@ class CChainParams\n     std::string bech32_hrp;\n     std::string strNetworkID;\n     CBlock genesis;\n-    std::vector<SeedSpec6> vFixedSeeds;\n+    std::vector<uint8_t> vFixedSeeds;\n     bool fDefaultConsistencyChecks;\n     bool fRequireStandard;\n     bool m_is_test_chain;"
      },
      {
        "sha": "cd7b806621dfe60852c00dffd84426d36203c5f2",
        "filename": "src/chainparamsseeds.h",
        "status": "modified",
        "additions": 1198,
        "deletions": 1175,
        "changes": 2373,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/chainparamsseeds.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/chainparamsseeds.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsseeds.h?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f"
      },
      {
        "sha": "e11e4acb5c2dd0b6c64a8d6560049e48e86bb25c",
        "filename": "src/httprpc.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/httprpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/httprpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -159,7 +159,8 @@ static bool HTTPReq_JSONRPC(const std::any& context, HTTPRequest* req)\n         return false;\n     }\n \n-    JSONRPCRequest jreq(context);\n+    JSONRPCRequest jreq;\n+    jreq.context = context;\n     jreq.peerAddr = req->GetPeer().ToString();\n     if (!RPCAuthorized(authHeader.second, jreq.authUser)) {\n         LogPrintf(\"ThreadRPCServer incorrect password attempt from %s\\n\", jreq.peerAddr);\n@@ -294,7 +295,7 @@ bool StartHTTPRPC(const std::any& context)\n     if (!InitRPCAuthentication())\n         return false;\n \n-    auto handle_rpc = [&context](HTTPRequest* req, const std::string&) { return HTTPReq_JSONRPC(context, req); };\n+    auto handle_rpc = [context](HTTPRequest* req, const std::string&) { return HTTPReq_JSONRPC(context, req); };\n     RegisterHTTPHandler(\"/\", true, handle_rpc);\n     if (g_wallet_init_interface.HasWalletSupport()) {\n         RegisterHTTPHandler(\"/wallet/\", false, handle_rpc);"
      },
      {
        "sha": "ac3c429a5a373dcfcaeecdf2c0457f9ba270607f",
        "filename": "src/index/base.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/index/base.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/index/base.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/base.h?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -109,7 +109,7 @@ class BaseIndex : public CValidationInterface\n     /// sync once and only needs to process blocks in the ValidationInterface\n     /// queue. If the index is catching up from far behind, this method does\n     /// not block and immediately returns false.\n-    bool BlockUntilSyncedToCurrentChain() const;\n+    bool BlockUntilSyncedToCurrentChain() const LOCKS_EXCLUDED(::cs_main);\n \n     void Interrupt();\n "
      },
      {
        "sha": "701a7529afa5cd16d5e84d4b0236281e9fd782fd",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -788,7 +788,7 @@ static bool InitSanityCheck()\n     return true;\n }\n \n-static bool AppInitServers(const std::any& context, NodeContext& node)\n+static bool AppInitServers(NodeContext& node)\n {\n     const ArgsManager& args = *Assert(node.args);\n     RPCServer::OnStarted(&OnRPCStarted);\n@@ -797,9 +797,9 @@ static bool AppInitServers(const std::any& context, NodeContext& node)\n         return false;\n     StartRPC();\n     node.rpc_interruption_point = RpcInterruptionPoint;\n-    if (!StartHTTPRPC(context))\n+    if (!StartHTTPRPC(&node))\n         return false;\n-    if (args.GetBoolArg(\"-rest\", DEFAULT_REST_ENABLE)) StartREST(context);\n+    if (args.GetBoolArg(\"-rest\", DEFAULT_REST_ENABLE)) StartREST(&node);\n     StartHTTPServer();\n     return true;\n }\n@@ -1277,7 +1277,7 @@ bool AppInitInterfaces(NodeContext& node)\n     return true;\n }\n \n-bool AppInitMain(const std::any& context, NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n+bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n {\n     const ArgsManager& args = *Assert(node.args);\n     const CChainParams& chainparams = Params();\n@@ -1382,7 +1382,7 @@ bool AppInitMain(const std::any& context, NodeContext& node, interfaces::BlockAn\n      */\n     if (args.GetBoolArg(\"-server\", false)) {\n         uiInterface.InitMessage_connect(SetRPCWarmupStatus);\n-        if (!AppInitServers(context, node))\n+        if (!AppInitServers(node))\n             return InitError(_(\"Unable to start HTTP server. See debug log for details.\"));\n     }\n "
      },
      {
        "sha": "328eda9c7e859b13687ef2df76bae9ed79c1ab39",
        "filename": "src/init.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.h?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -64,7 +64,7 @@ bool AppInitInterfaces(NodeContext& node);\n  * @note This should only be done after daemonization. Call Shutdown() if this function fails.\n  * @pre Parameters should be parsed and config file should be read, AppInitLockDataDirectory should have been called.\n  */\n-bool AppInitMain(const std::any& context, NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info = nullptr);\n+bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info = nullptr);\n \n /**\n  * Register all arguments with the ArgsManager"
      },
      {
        "sha": "ae38acdc3cb2f8bf44aedfc0bb59a95f38519ef5",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 8,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -145,22 +145,23 @@ bool GetLocal(CService& addr, const CNetAddr *paddrPeer)\n     return nBestScore >= 0;\n }\n \n-//! Convert the pnSeed6 array into usable address objects.\n-static std::vector<CAddress> convertSeed6(const std::vector<SeedSpec6> &vSeedsIn)\n+//! Convert the serialized seeds into usable address objects.\n+static std::vector<CAddress> ConvertSeeds(const std::vector<uint8_t> &vSeedsIn)\n {\n     // It'll only connect to one or two seed nodes because once it connects,\n     // it'll get a pile of addresses with newer timestamps.\n     // Seed nodes are given a random 'last seen time' of between one and two\n     // weeks ago.\n     const int64_t nOneWeek = 7*24*60*60;\n     std::vector<CAddress> vSeedsOut;\n-    vSeedsOut.reserve(vSeedsIn.size());\n     FastRandomContext rng;\n-    for (const auto& seed_in : vSeedsIn) {\n-        struct in6_addr ip;\n-        memcpy(&ip, seed_in.addr, sizeof(ip));\n-        CAddress addr(CService(ip, seed_in.port), GetDesirableServiceFlags(NODE_NONE));\n+    CDataStream s(vSeedsIn, SER_NETWORK, PROTOCOL_VERSION | ADDRV2_FORMAT);\n+    while (!s.eof()) {\n+        CService endpoint;\n+        s >> endpoint;\n+        CAddress addr{endpoint, GetDesirableServiceFlags(NODE_NONE)};\n         addr.nTime = GetTime() - rng.randrange(nOneWeek) - nOneWeek;\n+        LogPrint(BCLog::NET, \"Added hardcoded seed: %s\\n\", addr.ToString());\n         vSeedsOut.push_back(addr);\n     }\n     return vSeedsOut;\n@@ -1847,7 +1848,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n             if (add_fixed_seeds_now) {\n                 CNetAddr local;\n                 local.SetInternal(\"fixedseeds\");\n-                addrman.Add(convertSeed6(Params().FixedSeeds()), local);\n+                addrman.Add(ConvertSeeds(Params().FixedSeeds()), local);\n                 add_fixed_seeds = false;\n             }\n         }"
      },
      {
        "sha": "84c26c3df1c6e5cbb33682e029e023af6f16f9f2",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -448,7 +448,7 @@ class PeerManagerImpl final : public PeerManager\n     /** Determine whether or not a peer can request a transaction, and return it (or nullptr if not found or not allowed). */\n     CTransactionRef FindTxForGetData(const CNode& peer, const GenTxid& gtxid, const std::chrono::seconds mempool_req, const std::chrono::seconds now) LOCKS_EXCLUDED(cs_main);\n \n-    void ProcessGetData(CNode& pfrom, Peer& peer, const std::atomic<bool>& interruptMsgProc) EXCLUSIVE_LOCKS_REQUIRED(!cs_main, peer.m_getdata_requests_mutex);\n+    void ProcessGetData(CNode& pfrom, Peer& peer, const std::atomic<bool>& interruptMsgProc) EXCLUSIVE_LOCKS_REQUIRED(peer.m_getdata_requests_mutex) LOCKS_EXCLUDED(::cs_main);\n \n     /** Relay map (txid or wtxid -> CTransactionRef) */\n     typedef std::map<uint256, CTransactionRef> MapRelay;\n@@ -2062,7 +2062,7 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n /**\n  * Reconsider orphan transactions after a parent has been accepted to the mempool.\n  *\n- * @param[in/out]  orphan_work_set  The set of orphan transactions to reconsider. Generally only one\n+ * @param[in,out]  orphan_work_set  The set of orphan transactions to reconsider. Generally only one\n  *                                  orphan will be reconsidered on each call of this function. This set\n  *                                  may be added to if accepting an orphan causes its children to be\n  *                                  reconsidered."
      },
      {
        "sha": "6a87c338a07b9942b12406b3c6a98977aea6ae6c",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -172,7 +172,6 @@ CService LookupNumeric(const std::string& name, uint16_t portDefault = 0, DNSLoo\n  * @param strSubnet A string representation of a subnet of the form `network\n  *                address [ \"/\", ( CIDR-style suffix | netmask ) ]`(e.g.\n  *                `2001:db8::/32`, `192.0.2.0/255.255.255.0`, or `8.8.8.8`).\n- * @param ret The resulting internal representation of a subnet.\n  *\n  * @returns Whether the operation succeeded or not.\n  */\n@@ -235,7 +234,7 @@ void InterruptSocks5(bool interrupt);\n  * @param port The destination port.\n  * @param auth The credentials with which to authenticate with the specified\n  *             SOCKS5 proxy.\n- * @param sock The SOCKS5 proxy socket.\n+ * @param socket The SOCKS5 proxy socket.\n  *\n  * @returns Whether or not the operation succeeded.\n  *"
      },
      {
        "sha": "f8f0fff43f5b09af83bdcec5e21a5484e3252e19",
        "filename": "src/node/coinstats.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/node/coinstats.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/node/coinstats.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coinstats.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -94,7 +94,8 @@ static bool GetUTXOStats(CCoinsView* view, BlockManager& blockman, CCoinsStats&\n     {\n         LOCK(cs_main);\n         assert(std::addressof(g_chainman.m_blockman) == std::addressof(blockman));\n-        stats.nHeight = blockman.LookupBlockIndex(stats.hashBlock)->nHeight;\n+        const CBlockIndex* block = blockman.LookupBlockIndex(stats.hashBlock);\n+        stats.nHeight = Assert(block)->nHeight;\n     }\n \n     PrepareHash(hash_obj, stats);"
      },
      {
        "sha": "e10e89b8cfee37429c4f25e24404c83899c095ca",
        "filename": "src/node/interfaces.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 8,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/node/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/node/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/interfaces.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -80,7 +80,7 @@ class NodeImpl : public Node\n     }\n     bool appInitMain(interfaces::BlockAndHeaderTipInfo* tip_info) override\n     {\n-        return AppInitMain(m_context_ref, *m_context, tip_info);\n+        return AppInitMain(*m_context, tip_info);\n     }\n     void appShutdown() override\n     {\n@@ -244,7 +244,8 @@ class NodeImpl : public Node\n     CFeeRate getDustRelayFee() override { return ::dustRelayFee; }\n     UniValue executeRpc(const std::string& command, const UniValue& params, const std::string& uri) override\n     {\n-        JSONRPCRequest req(m_context_ref);\n+        JSONRPCRequest req;\n+        req.context = m_context;\n         req.params = params;\n         req.strMethod = command;\n         req.URI = uri;\n@@ -314,14 +315,8 @@ class NodeImpl : public Node\n     void setContext(NodeContext* context) override\n     {\n         m_context = context;\n-        if (context) {\n-            m_context_ref = context;\n-        } else {\n-            m_context_ref.reset();\n-        }\n     }\n     NodeContext* m_context{nullptr};\n-    std::any m_context_ref;\n };\n \n bool FillBlock(const CBlockIndex* index, const FoundBlock& block, UniqueLock<RecursiveMutex>& lock, const CChain& active)"
      },
      {
        "sha": "0e4f9914b8c9701be1645111b7e053f10a571557",
        "filename": "src/policy/feerate.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/policy/feerate.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/policy/feerate.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/feerate.h?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -47,7 +47,6 @@ class CFeeRate\n      *\n      *  @param[in] nFeePaid  CAmount fee rate to construct with\n      *  @param[in] nBytes    size_t bytes (units) to construct with\n-     *  @returns   fee rate\n      */\n     CFeeRate(const CAmount& nFeePaid, size_t nBytes);\n     /**"
      },
      {
        "sha": "9e6e98b274da28c6ea6b030cc9585050ecf9bd22",
        "filename": "src/qt/test/rpcnestedtests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 11,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/qt/test/rpcnestedtests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/qt/test/rpcnestedtests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/rpcnestedtests.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -11,8 +11,10 @@\n #include <univalue.h>\n #include <util/system.h>\n \n-#include <QDir>\n-#include <QtGlobal>\n+#include <QTest>\n+\n+#include <string>\n+#include <stdexcept>\n \n static RPCHelpMan rpcNestedTest_rpc()\n {\n@@ -24,9 +26,9 @@ static RPCHelpMan rpcNestedTest_rpc()\n             {\"arg2\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"\"},\n             {\"arg3\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"\"},\n         },\n-        {},\n+        RPCResult{RPCResult::Type::ANY, \"\", \"\"},\n         RPCExamples{\"\"},\n-        [](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue {\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue {\n             return request.params.write(0, 0);\n         },\n     };\n@@ -68,13 +70,13 @@ void RPCNestedTests::rpcNestedTests()\n     RPCConsole::RPCExecuteCommandLine(m_node, result, \"getblockchaininfo \"); //whitespace at the end will be tolerated\n     QVERIFY(result.substr(0,1) == \"{\");\n \n-    (RPCConsole::RPCExecuteCommandLine(m_node, result, \"getblockchaininfo()[\\\"chain\\\"]\")); //Quote path identifier are allowed, but look after a child containing the quotes in the key\n+    RPCConsole::RPCExecuteCommandLine(m_node, result, \"getblockchaininfo()[\\\"chain\\\"]\"); //Quote path identifier are allowed, but look after a child containing the quotes in the key\n     QVERIFY(result == \"null\");\n \n-    (RPCConsole::RPCExecuteCommandLine(m_node, result, \"createrawtransaction [] {} 0\")); //parameter not in brackets are allowed\n-    (RPCConsole::RPCExecuteCommandLine(m_node, result2, \"createrawtransaction([],{},0)\")); //parameter in brackets are allowed\n+    RPCConsole::RPCExecuteCommandLine(m_node, result, \"createrawtransaction [] {} 0\"); //parameter not in brackets are allowed\n+    RPCConsole::RPCExecuteCommandLine(m_node, result2, \"createrawtransaction([],{},0)\"); //parameter in brackets are allowed\n     QVERIFY(result == result2);\n-    (RPCConsole::RPCExecuteCommandLine(m_node, result2, \"createrawtransaction( [],  {} , 0   )\")); //whitespace between parameters is allowed\n+    RPCConsole::RPCExecuteCommandLine(m_node, result2, \"createrawtransaction( [],  {} , 0   )\"); //whitespace between parameters is allowed\n     QVERIFY(result == result2);\n \n     RPCConsole::RPCExecuteCommandLine(m_node, result, \"getblock(getbestblockhash())[tx][0]\", &filtered);\n@@ -123,11 +125,10 @@ void RPCNestedTests::rpcNestedTests()\n     RPCConsole::RPCExecuteCommandLine(m_node, result, \"rpcNestedTest(   abc   ,   cba )\");\n     QVERIFY(result == \"[\\\"abc\\\",\\\"cba\\\"]\");\n \n-    // do the QVERIFY_EXCEPTION_THROWN checks only with Qt5.3 and higher (QVERIFY_EXCEPTION_THROWN was introduced in Qt5.3)\n     QVERIFY_EXCEPTION_THROWN(RPCConsole::RPCExecuteCommandLine(m_node, result, \"getblockchaininfo() .\\n\"), std::runtime_error); //invalid syntax\n     QVERIFY_EXCEPTION_THROWN(RPCConsole::RPCExecuteCommandLine(m_node, result, \"getblockchaininfo() getblockchaininfo()\"), std::runtime_error); //invalid syntax\n-    (RPCConsole::RPCExecuteCommandLine(m_node, result, \"getblockchaininfo(\")); //tolerate non closing brackets if we have no arguments\n-    (RPCConsole::RPCExecuteCommandLine(m_node, result, \"getblockchaininfo()()()\")); //tolerate non command brackets\n+    RPCConsole::RPCExecuteCommandLine(m_node, result, \"getblockchaininfo(\"); //tolerate non closing brackets if we have no arguments\n+    RPCConsole::RPCExecuteCommandLine(m_node, result, \"getblockchaininfo()()()\"); //tolerate non command brackets\n     QVERIFY_EXCEPTION_THROWN(RPCConsole::RPCExecuteCommandLine(m_node, result, \"getblockchaininfo(True)\"), UniValue); //invalid argument\n     QVERIFY_EXCEPTION_THROWN(RPCConsole::RPCExecuteCommandLine(m_node, result, \"a(getblockchaininfo(True))\"), UniValue); //method not found\n     QVERIFY_EXCEPTION_THROWN(RPCConsole::RPCExecuteCommandLine(m_node, result, \"rpcNestedTest abc,,abc\"), std::runtime_error); //don't tolerate empty arguments when using ,"
      },
      {
        "sha": "71d258b077b56b6c5e25908c005c14bb99147586",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -317,7 +317,8 @@ static bool rest_chaininfo(const std::any& context, HTTPRequest* req, const std:\n \n     switch (rf) {\n     case RetFormat::JSON: {\n-        JSONRPCRequest jsonRequest(context);\n+        JSONRPCRequest jsonRequest;\n+        jsonRequest.context = context;\n         jsonRequest.params = UniValue(UniValue::VARR);\n         UniValue chainInfoObject = getblockchaininfo().HandleRequest(jsonRequest);\n         std::string strJSON = chainInfoObject.write() + \"\\n\";\n@@ -687,7 +688,7 @@ static const struct {\n void StartREST(const std::any& context)\n {\n     for (const auto& up : uri_prefixes) {\n-        auto handler = [&context, up](HTTPRequest* req, const std::string& prefix) { return up.handler(context, req, prefix); };\n+        auto handler = [context, up](HTTPRequest* req, const std::string& prefix) { return up.handler(context, req, prefix); };\n         RegisterHTTPHandler(up.prefix, false, handler);\n     }\n }"
      },
      {
        "sha": "8e989193915d5ec6c4376cee9e49f6518e113a6f",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -628,7 +628,7 @@ static RPCHelpMan echo(const std::string& name)\n                     {\"arg8\", RPCArg::Type::STR, RPCArg::Optional::OMITTED_NAMED_ARG, \"\"},\n                     {\"arg9\", RPCArg::Type::STR, RPCArg::Optional::OMITTED_NAMED_ARG, \"\"},\n                 },\n-                RPCResult{RPCResult::Type::NONE, \"\", \"Returns whatever was passed in\"},\n+                RPCResult{RPCResult::Type::ANY, \"\", \"Returns whatever was passed in\"},\n                 RPCExamples{\"\"},\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {"
      },
      {
        "sha": "9ace33d529967280a0c56befe6d52d1c498bcbfd",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 12,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -835,7 +835,7 @@ static RPCHelpMan setnetworkactive()\n static RPCHelpMan getnodeaddresses()\n {\n     return RPCHelpMan{\"getnodeaddresses\",\n-                \"\\nReturn known addresses which can potentially be used to find new nodes in the network\\n\",\n+                \"\\nReturn known addresses, which can potentially be used to find new nodes in the network.\\n\",\n                 {\n                     {\"count\", RPCArg::Type::NUM, /* default */ \"1\", \"The maximum number of addresses to return. Specify 0 to return all known addresses.\"},\n                 },\n@@ -844,10 +844,11 @@ static RPCHelpMan getnodeaddresses()\n                     {\n                         {RPCResult::Type::OBJ, \"\", \"\",\n                         {\n-                            {RPCResult::Type::NUM_TIME, \"time\", \"The \" + UNIX_EPOCH_TIME + \" of when the node was last seen\"},\n-                            {RPCResult::Type::NUM, \"services\", \"The services offered\"},\n+                            {RPCResult::Type::NUM_TIME, \"time\", \"The \" + UNIX_EPOCH_TIME + \" when the node was last seen\"},\n+                            {RPCResult::Type::NUM, \"services\", \"The services offered by the node\"},\n                             {RPCResult::Type::STR, \"address\", \"The address of the node\"},\n-                            {RPCResult::Type::NUM, \"port\", \"The port of the node\"},\n+                            {RPCResult::Type::NUM, \"port\", \"The port number of the node\"},\n+                            {RPCResult::Type::STR, \"network\", \"The network (\" + Join(GetNetworkNames(), \", \") + \") the node connected through\"},\n                         }},\n                     }\n                 },\n@@ -862,15 +863,11 @@ static RPCHelpMan getnodeaddresses()\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n     }\n \n-    int count = 1;\n-    if (!request.params[0].isNull()) {\n-        count = request.params[0].get_int();\n-        if (count < 0) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Address count out of range\");\n-        }\n-    }\n+    const int count{request.params[0].isNull() ? 1 : request.params[0].get_int()};\n+    if (count < 0) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Address count out of range\");\n+\n     // returns a shuffled list of CAddress\n-    std::vector<CAddress> vAddr = node.connman->GetAddresses(count, /* max_pct */ 0);\n+    const std::vector<CAddress> vAddr{node.connman->GetAddresses(count, /* max_pct */ 0)};\n     UniValue ret(UniValue::VARR);\n \n     for (const CAddress& addr : vAddr) {\n@@ -879,6 +876,7 @@ static RPCHelpMan getnodeaddresses()\n         obj.pushKV(\"services\", (uint64_t)addr.nServices);\n         obj.pushKV(\"address\", addr.ToStringIP());\n         obj.pushKV(\"port\", addr.GetPort());\n+        obj.pushKV(\"network\", GetNetworkName(addr.GetNetClass()));\n         ret.push_back(obj);\n     }\n     return ret;"
      },
      {
        "sha": "bb091efea80992d3bbf85a718c57a6bf87c20ed8",
        "filename": "src/rpc/request.h",
        "status": "modified",
        "additions": 1,
        "deletions": 12,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/rpc/request.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/rpc/request.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/request.h?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -35,18 +35,7 @@ class JSONRPCRequest\n     std::string URI;\n     std::string authUser;\n     std::string peerAddr;\n-    const std::any& context;\n-\n-    explicit JSONRPCRequest(const std::any& context) : id(NullUniValue), params(NullUniValue), context(context) {}\n-\n-    //! Initializes request information from another request object and the\n-    //! given context. The implementation should be updated if any members are\n-    //! added or removed above.\n-    JSONRPCRequest(const JSONRPCRequest& other, const std::any& context)\n-        : id(other.id), strMethod(other.strMethod), params(other.params), mode(other.mode), URI(other.URI),\n-          authUser(other.authUser), peerAddr(other.peerAddr), context(context)\n-    {\n-    }\n+    std::any context;\n \n     void parse(const UniValue& valRequest);\n };"
      },
      {
        "sha": "5d816ba5bb64e2a27b0b5ee6cb25bec898f7a71a",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -137,8 +137,9 @@ static RPCHelpMan help()\n                 {\n                     {\"command\", RPCArg::Type::STR, /* default */ \"all commands\", \"The command to get help on\"},\n                 },\n-                RPCResult{\n-                    RPCResult::Type::STR, \"\", \"The help text\"\n+                {\n+                    RPCResult{RPCResult::Type::STR, \"\", \"The help text\"},\n+                    RPCResult{RPCResult::Type::ANY, \"\", \"\"},\n                 },\n                 RPCExamples{\"\"},\n         [&](const RPCHelpMan& self, const JSONRPCRequest& jsonRequest) -> UniValue"
      },
      {
        "sha": "ba3105ca013fa5bfd45d1a040cec0271fcc4414b",
        "filename": "src/rpc/util.cpp",
        "status": "modified",
        "additions": 107,
        "deletions": 2,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/rpc/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/rpc/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -113,17 +113,80 @@ std::vector<unsigned char> ParseHexO(const UniValue& o, std::string strKey)\n     return ParseHexV(find_value(o, strKey), strKey);\n }\n \n+namespace {\n+\n+/**\n+ * Quote an argument for shell.\n+ *\n+ * @note This is intended for help, not for security-sensitive purposes.\n+ */\n+std::string ShellQuote(const std::string& s)\n+{\n+    std::string result;\n+    result.reserve(s.size() * 2);\n+    for (const char ch: s) {\n+        if (ch == '\\'') {\n+            result += \"'\\''\";\n+        } else {\n+            result += ch;\n+        }\n+    }\n+    return \"'\" + result + \"'\";\n+}\n+\n+/**\n+ * Shell-quotes the argument if it needs quoting, else returns it literally, to save typing.\n+ *\n+ * @note This is intended for help, not for security-sensitive purposes.\n+ */\n+std::string ShellQuoteIfNeeded(const std::string& s)\n+{\n+    for (const char ch: s) {\n+        if (ch == ' ' || ch == '\\'' || ch == '\"') {\n+            return ShellQuote(s);\n+        }\n+    }\n+\n+    return s;\n+}\n+\n+}\n+\n std::string HelpExampleCli(const std::string& methodname, const std::string& args)\n {\n     return \"> bitcoin-cli \" + methodname + \" \" + args + \"\\n\";\n }\n \n+std::string HelpExampleCliNamed(const std::string& methodname, const RPCArgList& args)\n+{\n+    std::string result = \"> bitcoin-cli -named \" + methodname;\n+    for (const auto& argpair: args) {\n+        const auto& value = argpair.second.isStr()\n+                ? argpair.second.get_str()\n+                : argpair.second.write();\n+        result += \" \" + argpair.first + \"=\" + ShellQuoteIfNeeded(value);\n+    }\n+    result += \"\\n\";\n+    return result;\n+}\n+\n std::string HelpExampleRpc(const std::string& methodname, const std::string& args)\n {\n     return \"> curl --user myusername --data-binary '{\\\"jsonrpc\\\": \\\"1.0\\\", \\\"id\\\": \\\"curltest\\\", \"\n         \"\\\"method\\\": \\\"\" + methodname + \"\\\", \\\"params\\\": [\" + args + \"]}' -H 'content-type: text/plain;' http://127.0.0.1:8332/\\n\";\n }\n \n+std::string HelpExampleRpcNamed(const std::string& methodname, const RPCArgList& args)\n+{\n+    UniValue params(UniValue::VOBJ);\n+    for (const auto& param: args) {\n+        params.pushKV(param.first, param.second);\n+    }\n+\n+    return \"> curl --user myusername --data-binary '{\\\"jsonrpc\\\": \\\"1.0\\\", \\\"id\\\": \\\"curltest\\\", \"\n+           \"\\\"method\\\": \\\"\" + methodname + \"\\\", \\\"params\\\": \" + params.write() + \"}' -H 'content-type: text/plain;' http://127.0.0.1:8332/\\n\";\n+}\n+\n // Converts a hex string to a public key if possible\n CPubKey HexToPubKey(const std::string& hex_in)\n {\n@@ -442,6 +505,7 @@ std::string RPCResults::ToDescriptionString() const\n {\n     std::string result;\n     for (const auto& r : m_results) {\n+        if (r.m_type == RPCResult::Type::ANY) continue; // for testing only\n         if (r.m_cond.empty()) {\n             result += \"\\nResult:\\n\";\n         } else {\n@@ -459,7 +523,7 @@ std::string RPCExamples::ToDescriptionString() const\n     return m_examples.empty() ? m_examples : \"\\nExamples:\\n\" + m_examples;\n }\n \n-UniValue RPCHelpMan::HandleRequest(const JSONRPCRequest& request)\n+UniValue RPCHelpMan::HandleRequest(const JSONRPCRequest& request) const\n {\n     if (request.mode == JSONRPCRequest::GET_ARGS) {\n         return GetArgMap();\n@@ -471,7 +535,9 @@ UniValue RPCHelpMan::HandleRequest(const JSONRPCRequest& request)\n     if (request.mode == JSONRPCRequest::GET_HELP || !IsValidNumArgs(request.params.size())) {\n         throw std::runtime_error(ToString());\n     }\n-    return m_fun(*this, request);\n+    const UniValue ret = m_fun(*this, request);\n+    CHECK_NONFATAL(std::any_of(m_results.m_results.begin(), m_results.m_results.end(), [ret](const RPCResult& res) { return res.MatchesType(ret); }));\n+    return ret;\n }\n \n bool RPCHelpMan::IsValidNumArgs(size_t num_args) const\n@@ -677,6 +743,9 @@ void RPCResult::ToSections(Sections& sections, const OuterType outer_type, const\n         sections.PushSection({indent + \"...\" + maybe_separator, m_description});\n         return;\n     }\n+    case Type::ANY: {\n+        CHECK_NONFATAL(false); // Only for testing\n+    }\n     case Type::NONE: {\n         sections.PushSection({indent + \"null\" + maybe_separator, Description(\"json null\")});\n         return;\n@@ -742,6 +811,42 @@ void RPCResult::ToSections(Sections& sections, const OuterType outer_type, const\n     CHECK_NONFATAL(false);\n }\n \n+bool RPCResult::MatchesType(const UniValue& result) const\n+{\n+    switch (m_type) {\n+    case Type::ELISION: {\n+        return false;\n+    }\n+    case Type::ANY: {\n+        return true;\n+    }\n+    case Type::NONE: {\n+        return UniValue::VNULL == result.getType();\n+    }\n+    case Type::STR:\n+    case Type::STR_HEX: {\n+        return UniValue::VSTR == result.getType();\n+    }\n+    case Type::NUM:\n+    case Type::STR_AMOUNT:\n+    case Type::NUM_TIME: {\n+        return UniValue::VNUM == result.getType();\n+    }\n+    case Type::BOOL: {\n+        return UniValue::VBOOL == result.getType();\n+    }\n+    case Type::ARR_FIXED:\n+    case Type::ARR: {\n+        return UniValue::VARR == result.getType();\n+    }\n+    case Type::OBJ_DYN:\n+    case Type::OBJ: {\n+        return UniValue::VOBJ == result.getType();\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    CHECK_NONFATAL(false);\n+}\n+\n std::string RPCArg::ToStringObj(const bool oneline) const\n {\n     std::string res;"
      },
      {
        "sha": "6e783e19fb87183efbba146ff616d06f5b858b7a",
        "filename": "src/rpc/util.h",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/rpc/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/rpc/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.h?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -78,8 +78,12 @@ extern std::vector<unsigned char> ParseHexV(const UniValue& v, std::string strNa\n extern std::vector<unsigned char> ParseHexO(const UniValue& o, std::string strKey);\n \n extern CAmount AmountFromValue(const UniValue& value);\n+\n+using RPCArgList = std::vector<std::pair<std::string, UniValue>>;\n extern std::string HelpExampleCli(const std::string& methodname, const std::string& args);\n+extern std::string HelpExampleCliNamed(const std::string& methodname, const RPCArgList& args);\n extern std::string HelpExampleRpc(const std::string& methodname, const std::string& args);\n+extern std::string HelpExampleRpcNamed(const std::string& methodname, const RPCArgList& args);\n \n CPubKey HexToPubKey(const std::string& hex_in);\n CPubKey AddrToPubKey(const FillableSigningProvider& keystore, const std::string& addr_in);\n@@ -223,6 +227,7 @@ struct RPCResult {\n         NUM,\n         BOOL,\n         NONE,\n+        ANY,        //!< Special type to disable type checks (for testing only)\n         STR_AMOUNT, //!< Special string to represent a floating point amount\n         STR_HEX,    //!< Special string with only hex chars\n         OBJ_DYN,    //!< Special dictionary with keys that are not literals\n@@ -295,6 +300,8 @@ struct RPCResult {\n     std::string ToStringObj() const;\n     /** Return the description string, including the result type. */\n     std::string ToDescriptionString() const;\n+    /** Check whether the result JSON type matches. */\n+    bool MatchesType(const UniValue& result) const;\n };\n \n struct RPCResults {\n@@ -333,7 +340,7 @@ class RPCHelpMan\n     using RPCMethodImpl = std::function<UniValue(const RPCHelpMan&, const JSONRPCRequest&)>;\n     RPCHelpMan(std::string name, std::string description, std::vector<RPCArg> args, RPCResults results, RPCExamples examples, RPCMethodImpl fun);\n \n-    UniValue HandleRequest(const JSONRPCRequest& request);\n+    UniValue HandleRequest(const JSONRPCRequest& request) const;\n     std::string ToString() const;\n     /** Return the named args that need to be converted from string to another JSON type */\n     UniValue GetArgMap() const;"
      },
      {
        "sha": "effbc055d4f65e032a52cba2468efa55b8911b9f",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -272,6 +272,34 @@ class GenericTransactionSignatureChecker : public BaseSignatureChecker\n using TransactionSignatureChecker = GenericTransactionSignatureChecker<CTransaction>;\n using MutableTransactionSignatureChecker = GenericTransactionSignatureChecker<CMutableTransaction>;\n \n+class DeferringSignatureChecker : public BaseSignatureChecker\n+{\n+protected:\n+    BaseSignatureChecker& m_checker;\n+\n+public:\n+    DeferringSignatureChecker(BaseSignatureChecker& checker) : m_checker(checker) {}\n+\n+    bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override\n+    {\n+        return m_checker.CheckECDSASignature(scriptSig, vchPubKey, scriptCode, sigversion);\n+    }\n+\n+    bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion, const ScriptExecutionData& execdata, ScriptError* serror = nullptr) const override\n+    {\n+        return m_checker.CheckSchnorrSignature(sig, pubkey, sigversion, execdata, serror);\n+    }\n+\n+    bool CheckLockTime(const CScriptNum& nLockTime) const override\n+    {\n+        return m_checker.CheckLockTime(nLockTime);\n+    }\n+    bool CheckSequence(const CScriptNum& nSequence) const override\n+    {\n+        return m_checker.CheckSequence(nSequence);\n+    }\n+};\n+\n bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptExecutionData& execdata, ScriptError* error = nullptr);\n bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = nullptr);\n bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror = nullptr);"
      },
      {
        "sha": "3c8f6d22ead56011e6a27d98fc2d9c3e29bfb759",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -250,17 +250,17 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n }\n \n namespace {\n-class SignatureExtractorChecker final : public BaseSignatureChecker\n+class SignatureExtractorChecker final : public DeferringSignatureChecker\n {\n private:\n     SignatureData& sigdata;\n-    BaseSignatureChecker& checker;\n \n public:\n-    SignatureExtractorChecker(SignatureData& sigdata, BaseSignatureChecker& checker) : sigdata(sigdata), checker(checker) {}\n+    SignatureExtractorChecker(SignatureData& sigdata, BaseSignatureChecker& checker) : DeferringSignatureChecker(checker), sigdata(sigdata) {}\n+\n     bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override\n     {\n-        if (checker.CheckECDSASignature(scriptSig, vchPubKey, scriptCode, sigversion)) {\n+        if (m_checker.CheckECDSASignature(scriptSig, vchPubKey, scriptCode, sigversion)) {\n             CPubKey pubkey(vchPubKey);\n             sigdata.signatures.emplace(pubkey.GetID(), SigPair(pubkey, scriptSig));\n             return true;"
      },
      {
        "sha": "146c2285925ea0c4732feaae3072f4b5086cff9a",
        "filename": "src/sync.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/sync.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/sync.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.h?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -56,7 +56,7 @@ std::string LocksHeld();\n template <typename MutexType>\n void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs);\n template <typename MutexType>\n-void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) LOCKS_EXCLUDED(cs);\n void DeleteLock(void* cs);\n bool LockStackEmpty();\n \n@@ -74,7 +74,7 @@ inline void CheckLastCritical(void* cs, std::string& lockname, const char* guard\n template <typename MutexType>\n inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs) {}\n template <typename MutexType>\n-void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs) {}\n+void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) LOCKS_EXCLUDED(cs) {}\n inline void DeleteLock(void* cs) {}\n inline bool LockStackEmpty() { return true; }\n #endif"
      },
      {
        "sha": "e7cb12dbba497869ebc8dcc856849b9be5fa663d",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 79,
        "deletions": 30,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -22,6 +22,7 @@\n \n #include <test/util/setup_common.h>\n \n+#include <array>\n #include <stdint.h>\n \n #include <boost/test/unit_test.hpp>\n@@ -209,46 +210,94 @@ BOOST_AUTO_TEST_CASE(peer_discouragement)\n {\n     const CChainParams& chainparams = Params();\n     auto banman = std::make_unique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n-    auto connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman);\n+    auto connman = std::make_unique<CConnmanTest>(0x1337, 0x1337, *m_node.addrman);\n     auto peerLogic = PeerManager::make(chainparams, *connman, *m_node.addrman, banman.get(),\n                                        *m_node.scheduler, *m_node.chainman, *m_node.mempool, false);\n \n+    CNetAddr tor_netaddr;\n+    BOOST_REQUIRE(\n+        tor_netaddr.SetSpecial(\"pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion\"));\n+    const CService tor_service{tor_netaddr, Params().GetDefaultPort()};\n+\n+    const std::array<CAddress, 3> addr{CAddress{ip(0xa0b0c001), NODE_NONE},\n+                                       CAddress{ip(0xa0b0c002), NODE_NONE},\n+                                       CAddress{tor_service, NODE_NONE}};\n+\n+    const CNetAddr other_addr{ip(0xa0b0ff01)}; // Not any of addr[].\n+\n+    std::array<CNode*, 3> nodes;\n+\n     banman->ClearBanned();\n-    CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n-    CNode dummyNode1(id++, NODE_NETWORK, INVALID_SOCKET, addr1, /* nKeyedNetGroupIn */ 0, /* nLocalHostNonceIn */ 0, CAddress(), /* pszDest */ \"\", ConnectionType::INBOUND, /* inbound_onion */ false);\n-    dummyNode1.SetCommonVersion(PROTOCOL_VERSION);\n-    peerLogic->InitializeNode(&dummyNode1);\n-    dummyNode1.fSuccessfullyConnected = true;\n-    peerLogic->Misbehaving(dummyNode1.GetId(), DISCOURAGEMENT_THRESHOLD, /* message */ \"\"); // Should be discouraged\n+    nodes[0] = new CNode{id++, NODE_NETWORK, INVALID_SOCKET, addr[0], /* nKeyedNetGroupIn */ 0,\n+                         /* nLocalHostNonceIn */ 0, CAddress(), /* pszDest */ \"\",\n+                         ConnectionType::INBOUND, /* inbound_onion */ false};\n+    nodes[0]->SetCommonVersion(PROTOCOL_VERSION);\n+    peerLogic->InitializeNode(nodes[0]);\n+    nodes[0]->fSuccessfullyConnected = true;\n+    connman->AddNode(*nodes[0]);\n+    peerLogic->Misbehaving(nodes[0]->GetId(), DISCOURAGEMENT_THRESHOLD, /* message */ \"\"); // Should be discouraged\n     {\n-        LOCK(dummyNode1.cs_sendProcessing);\n-        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1));\n+        LOCK(nodes[0]->cs_sendProcessing);\n+        BOOST_CHECK(peerLogic->SendMessages(nodes[0]));\n     }\n-    BOOST_CHECK(banman->IsDiscouraged(addr1));\n-    BOOST_CHECK(!banman->IsDiscouraged(ip(0xa0b0c001|0x0000ff00))); // Different IP, not discouraged\n-\n-    CAddress addr2(ip(0xa0b0c002), NODE_NONE);\n-    CNode dummyNode2(id++, NODE_NETWORK, INVALID_SOCKET, addr2, /* nKeyedNetGroupIn */ 1, /* nLocalHostNonceIn */ 1, CAddress(), /* pszDest */ \"\", ConnectionType::INBOUND, /* inbound_onion */ false);\n-    dummyNode2.SetCommonVersion(PROTOCOL_VERSION);\n-    peerLogic->InitializeNode(&dummyNode2);\n-    dummyNode2.fSuccessfullyConnected = true;\n-    peerLogic->Misbehaving(dummyNode2.GetId(), DISCOURAGEMENT_THRESHOLD - 1, /* message */ \"\");\n+    BOOST_CHECK(banman->IsDiscouraged(addr[0]));\n+    BOOST_CHECK(nodes[0]->fDisconnect);\n+    BOOST_CHECK(!banman->IsDiscouraged(other_addr)); // Different address, not discouraged\n+\n+    nodes[1] = new CNode{id++, NODE_NETWORK, INVALID_SOCKET, addr[1], /* nKeyedNetGroupIn */ 1,\n+                         /* nLocalHostNonceIn */ 1, CAddress(), /* pszDest */ \"\",\n+                         ConnectionType::INBOUND, /* inbound_onion */ false};\n+    nodes[1]->SetCommonVersion(PROTOCOL_VERSION);\n+    peerLogic->InitializeNode(nodes[1]);\n+    nodes[1]->fSuccessfullyConnected = true;\n+    connman->AddNode(*nodes[1]);\n+    peerLogic->Misbehaving(nodes[1]->GetId(), DISCOURAGEMENT_THRESHOLD - 1, /* message */ \"\");\n     {\n-        LOCK(dummyNode2.cs_sendProcessing);\n-        BOOST_CHECK(peerLogic->SendMessages(&dummyNode2));\n+        LOCK(nodes[1]->cs_sendProcessing);\n+        BOOST_CHECK(peerLogic->SendMessages(nodes[1]));\n     }\n-    BOOST_CHECK(!banman->IsDiscouraged(addr2)); // 2 not discouraged yet...\n-    BOOST_CHECK(banman->IsDiscouraged(addr1));  // ... but 1 still should be\n-    peerLogic->Misbehaving(dummyNode2.GetId(), 1, /* message */ \"\");         // 2 reaches discouragement threshold\n+    // [0] is still discouraged/disconnected.\n+    BOOST_CHECK(banman->IsDiscouraged(addr[0]));\n+    BOOST_CHECK(nodes[0]->fDisconnect);\n+    // [1] is not discouraged/disconnected yet.\n+    BOOST_CHECK(!banman->IsDiscouraged(addr[1]));\n+    BOOST_CHECK(!nodes[1]->fDisconnect);\n+    peerLogic->Misbehaving(nodes[1]->GetId(), 1, /* message */ \"\"); // [1] reaches discouragement threshold\n     {\n-        LOCK(dummyNode2.cs_sendProcessing);\n-        BOOST_CHECK(peerLogic->SendMessages(&dummyNode2));\n+        LOCK(nodes[1]->cs_sendProcessing);\n+        BOOST_CHECK(peerLogic->SendMessages(nodes[1]));\n     }\n-    BOOST_CHECK(banman->IsDiscouraged(addr1));  // Expect both 1 and 2\n-    BOOST_CHECK(banman->IsDiscouraged(addr2));  // to be discouraged now\n-\n-    peerLogic->FinalizeNode(dummyNode1);\n-    peerLogic->FinalizeNode(dummyNode2);\n+    // Expect both [0] and [1] to be discouraged/disconnected now.\n+    BOOST_CHECK(banman->IsDiscouraged(addr[0]));\n+    BOOST_CHECK(nodes[0]->fDisconnect);\n+    BOOST_CHECK(banman->IsDiscouraged(addr[1]));\n+    BOOST_CHECK(nodes[1]->fDisconnect);\n+\n+    // Make sure non-IP peers are discouraged and disconnected properly.\n+\n+    nodes[2] = new CNode{id++, NODE_NETWORK, INVALID_SOCKET, addr[2], /* nKeyedNetGroupIn */ 1,\n+                         /* nLocalHostNonceIn */ 1, CAddress(), /* pszDest */ \"\",\n+                         ConnectionType::OUTBOUND_FULL_RELAY, /* inbound_onion */ false};\n+    nodes[2]->SetCommonVersion(PROTOCOL_VERSION);\n+    peerLogic->InitializeNode(nodes[2]);\n+    nodes[2]->fSuccessfullyConnected = true;\n+    connman->AddNode(*nodes[2]);\n+    peerLogic->Misbehaving(nodes[2]->GetId(), DISCOURAGEMENT_THRESHOLD, /* message */ \"\");\n+    {\n+        LOCK(nodes[2]->cs_sendProcessing);\n+        BOOST_CHECK(peerLogic->SendMessages(nodes[2]));\n+    }\n+    BOOST_CHECK(banman->IsDiscouraged(addr[0]));\n+    BOOST_CHECK(banman->IsDiscouraged(addr[1]));\n+    BOOST_CHECK(banman->IsDiscouraged(addr[2]));\n+    BOOST_CHECK(nodes[0]->fDisconnect);\n+    BOOST_CHECK(nodes[1]->fDisconnect);\n+    BOOST_CHECK(nodes[2]->fDisconnect);\n+\n+    for (CNode* node : nodes) {\n+        peerLogic->FinalizeNode(*node);\n+    }\n+    connman->ClearNodes();\n }\n \n BOOST_AUTO_TEST_CASE(DoS_bantime)"
      },
      {
        "sha": "6c62dd6e489f12aca4a3c15f7ff2b2d4e0771569",
        "filename": "src/test/fuzz/psbt.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 3,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/test/fuzz/psbt.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/test/fuzz/psbt.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/psbt.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -2,13 +2,15 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <test/fuzz/FuzzedDataProvider.h>\n #include <test/fuzz/fuzz.h>\n \n #include <node/psbt.h>\n #include <psbt.h>\n #include <pubkey.h>\n #include <script/script.h>\n #include <streams.h>\n+#include <util/check.h>\n #include <version.h>\n \n #include <cstdint>\n@@ -23,10 +25,10 @@ void initialize_psbt()\n \n FUZZ_TARGET_INIT(psbt, initialize_psbt)\n {\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n     PartiallySignedTransaction psbt_mut;\n-    const std::string raw_psbt{buffer.begin(), buffer.end()};\n     std::string error;\n-    if (!DecodeRawPSBT(psbt_mut, raw_psbt, error)) {\n+    if (!DecodeRawPSBT(psbt_mut, fuzzed_data_provider.ConsumeRandomLengthString(), error)) {\n         return;\n     }\n     const PartiallySignedTransaction psbt = psbt_mut;\n@@ -49,6 +51,7 @@ FUZZ_TARGET_INIT(psbt, initialize_psbt)\n         (void)PSBTInputSigned(input);\n         (void)input.IsNull();\n     }\n+    (void)CountPSBTUnsignedInputs(psbt);\n \n     for (const PSBTOutput& output : psbt.outputs) {\n         (void)output.IsNull();\n@@ -71,6 +74,20 @@ FUZZ_TARGET_INIT(psbt, initialize_psbt)\n         const PartiallySignedTransaction psbt_from_tx{result};\n     }\n \n+    PartiallySignedTransaction psbt_merge;\n+    if (!DecodeRawPSBT(psbt_merge, fuzzed_data_provider.ConsumeRandomLengthString(), error)) {\n+        psbt_merge = psbt;\n+    }\n+    psbt_mut = psbt;\n+    (void)psbt_mut.Merge(psbt_merge);\n+    psbt_mut = psbt;\n+    (void)CombinePSBTs(psbt_mut, {psbt_mut, psbt_merge});\n     psbt_mut = psbt;\n-    (void)psbt_mut.Merge(psbt);\n+    for (unsigned int i = 0; i < psbt_merge.tx->vin.size(); ++i) {\n+        (void)psbt_mut.AddInput(psbt_merge.tx->vin[i], psbt_merge.inputs[i]);\n+    }\n+    for (unsigned int i = 0; i < psbt_merge.tx->vout.size(); ++i) {\n+        Assert(psbt_mut.AddOutput(psbt_merge.tx->vout[i], psbt_merge.outputs[i]));\n+    }\n+    psbt_mut.unknown.insert(psbt_merge.unknown.begin(), psbt_merge.unknown.end());\n }"
      },
      {
        "sha": "fe8d17b24a47ee7468c9fed1247b9ecf8bb985a8",
        "filename": "src/test/fuzz/tx_pool.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/test/fuzz/tx_pool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/test/fuzz/tx_pool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/tx_pool.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -34,7 +34,7 @@ void initialize_tx_pool()\n \n     for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n         CTxIn in = MineBlock(g_setup->m_node, P2WSH_OP_TRUE);\n-        // Remember the txids to avoid expensive disk acess later on\n+        // Remember the txids to avoid expensive disk access later on\n         auto& outpoints = i < COINBASE_MATURITY ?\n                               g_outpoints_coinbase_init_mature :\n                               g_outpoints_coinbase_init_immature;"
      },
      {
        "sha": "cf5244e31484e8e40d31052c166dce6f6cf174e1",
        "filename": "src/test/fuzz/util.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/test/fuzz/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/test/fuzz/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/util.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -7,6 +7,14 @@\n #include <util/rbf.h>\n #include <version.h>\n \n+bool FuzzedSock::Wait(std::chrono::milliseconds timeout, Event requested, Event* occurred ) const\n+{\n+    if (!m_fuzzed_data_provider.ConsumeBool()) {\n+        return false;\n+    }\n+    if (occurred) *occurred = 0;\n+    return true;\n+}\n \n void FillNode(FuzzedDataProvider& fuzzed_data_provider, CNode& node, bool init_version) noexcept\n {"
      },
      {
        "sha": "adcdd7174883f9701861c8d8035e74252e85bd0d",
        "filename": "src/test/fuzz/util.h",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/test/fuzz/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/test/fuzz/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/util.h?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -738,12 +738,10 @@ class FuzzedSock : public Sock\n         return 0;\n     }\n \n-    bool Wait(std::chrono::milliseconds timeout, Event requested, Event* occurred = nullptr) const override\n-    {\n-        return m_fuzzed_data_provider.ConsumeBool();\n-    }\n+    bool Wait(std::chrono::milliseconds timeout, Event requested, Event* occurred = nullptr) const override;\n \n-    bool IsConnected(std::string& errmsg) const override {\n+    bool IsConnected(std::string& errmsg) const override\n+    {\n         if (m_fuzzed_data_provider.ConsumeBool()) {\n             return true;\n         }"
      },
      {
        "sha": "e2f8725fcb38066d5015469f9346509354f4b9cf",
        "filename": "src/test/rpc_tests.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 2,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/test/rpc_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/test/rpc_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/rpc_tests.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -33,8 +33,8 @@ UniValue RPCTestingSetup::CallRPC(std::string args)\n     boost::split(vArgs, args, boost::is_any_of(\" \\t\"));\n     std::string strMethod = vArgs[0];\n     vArgs.erase(vArgs.begin());\n-    std::any context{&m_node};\n-    JSONRPCRequest request(context);\n+    JSONRPCRequest request;\n+    request.context = &m_node;\n     request.strMethod = strMethod;\n     request.params = RPCConvertValues(strMethod, vArgs);\n     if (RPCIsInWarmup(nullptr)) SetRPCWarmupFinished();\n@@ -431,4 +431,39 @@ BOOST_AUTO_TEST_CASE(rpc_getblockstats_calculate_percentiles_by_weight)\n     }\n }\n \n+BOOST_AUTO_TEST_CASE(help_example)\n+{\n+    // test different argument types\n+    const RPCArgList& args = {{\"foo\", \"bar\"}, {\"b\", true}, {\"n\", 1}};\n+    BOOST_CHECK_EQUAL(HelpExampleCliNamed(\"test\", args), \"> bitcoin-cli -named test foo=bar b=true n=1\\n\");\n+    BOOST_CHECK_EQUAL(HelpExampleRpcNamed(\"test\", args), \"> curl --user myusername --data-binary '{\\\"jsonrpc\\\": \\\"1.0\\\", \\\"id\\\": \\\"curltest\\\", \\\"method\\\": \\\"test\\\", \\\"params\\\": {\\\"foo\\\":\\\"bar\\\",\\\"b\\\":true,\\\"n\\\":1}}' -H 'content-type: text/plain;' http://127.0.0.1:8332/\\n\");\n+\n+    // test shell escape\n+    BOOST_CHECK_EQUAL(HelpExampleCliNamed(\"test\", {{\"foo\", \"b'ar\"}}), \"> bitcoin-cli -named test foo='b'''ar'\\n\");\n+    BOOST_CHECK_EQUAL(HelpExampleCliNamed(\"test\", {{\"foo\", \"b\\\"ar\"}}), \"> bitcoin-cli -named test foo='b\\\"ar'\\n\");\n+    BOOST_CHECK_EQUAL(HelpExampleCliNamed(\"test\", {{\"foo\", \"b ar\"}}), \"> bitcoin-cli -named test foo='b ar'\\n\");\n+\n+    // test object params\n+    UniValue obj_value(UniValue::VOBJ);\n+    obj_value.pushKV(\"foo\", \"bar\");\n+    obj_value.pushKV(\"b\", false);\n+    obj_value.pushKV(\"n\", 1);\n+    BOOST_CHECK_EQUAL(HelpExampleCliNamed(\"test\", {{\"name\", obj_value}}), \"> bitcoin-cli -named test name='{\\\"foo\\\":\\\"bar\\\",\\\"b\\\":false,\\\"n\\\":1}'\\n\");\n+    BOOST_CHECK_EQUAL(HelpExampleRpcNamed(\"test\", {{\"name\", obj_value}}), \"> curl --user myusername --data-binary '{\\\"jsonrpc\\\": \\\"1.0\\\", \\\"id\\\": \\\"curltest\\\", \\\"method\\\": \\\"test\\\", \\\"params\\\": {\\\"name\\\":{\\\"foo\\\":\\\"bar\\\",\\\"b\\\":false,\\\"n\\\":1}}}' -H 'content-type: text/plain;' http://127.0.0.1:8332/\\n\");\n+\n+    // test array params\n+    UniValue arr_value(UniValue::VARR);\n+    arr_value.push_back(\"bar\");\n+    arr_value.push_back(false);\n+    arr_value.push_back(1);\n+    BOOST_CHECK_EQUAL(HelpExampleCliNamed(\"test\", {{\"name\", arr_value}}), \"> bitcoin-cli -named test name='[\\\"bar\\\",false,1]'\\n\");\n+    BOOST_CHECK_EQUAL(HelpExampleRpcNamed(\"test\", {{\"name\", arr_value}}), \"> curl --user myusername --data-binary '{\\\"jsonrpc\\\": \\\"1.0\\\", \\\"id\\\": \\\"curltest\\\", \\\"method\\\": \\\"test\\\", \\\"params\\\": {\\\"name\\\":[\\\"bar\\\",false,1]}}' -H 'content-type: text/plain;' http://127.0.0.1:8332/\\n\");\n+\n+    // test types don't matter for shell\n+    BOOST_CHECK_EQUAL(HelpExampleCliNamed(\"foo\", {{\"arg\", true}}), HelpExampleCliNamed(\"foo\", {{\"arg\", \"true\"}}));\n+\n+    // test types matter for Rpc\n+    BOOST_CHECK_NE(HelpExampleRpcNamed(\"foo\", {{\"arg\", true}}), HelpExampleRpcNamed(\"foo\", {{\"arg\", \"true\"}}));\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "2d7f335a048a828aa1f73ea6d877f58cf7cdb051",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 24,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -202,43 +202,31 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n     }\n }\n \n-TestChain100Setup::TestChain100Setup(bool deterministic)\n+TestChain100Setup::TestChain100Setup()\n {\n-    m_deterministic = deterministic;\n-\n-    if (m_deterministic) {\n-        SetMockTime(1598887952);\n-        constexpr std::array<unsigned char, 32> vchKey = {\n-            {\n-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\n-            }\n-        };\n-        coinbaseKey.Set(vchKey.begin(), vchKey.end(), false);\n-    } else {\n-        coinbaseKey.MakeNewKey(true);\n-    }\n+    SetMockTime(1598887952);\n+    constexpr std::array<unsigned char, 32> vchKey = {\n+        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}};\n+    coinbaseKey.Set(vchKey.begin(), vchKey.end(), true);\n \n     // Generate a 100-block chain:\n     this->mineBlocks(COINBASE_MATURITY);\n \n-    if (m_deterministic) {\n+    {\n         LOCK(::cs_main);\n         assert(\n             m_node.chainman->ActiveChain().Tip()->GetBlockHash().ToString() ==\n-            \"49c95db1e470fed04496d801c9d8fbb78155d2c7f855232c918823d2c17d0cf6\");\n+            \"571d80a9967ae599cec0448b0b0ba1cfb606f584d8069bd7166b86854ba7a191\");\n     }\n }\n \n void TestChain100Setup::mineBlocks(int num_blocks)\n {\n     CScript scriptPubKey = CScript() << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\n-    for (int i = 0; i < num_blocks; i++)\n-    {\n+    for (int i = 0; i < num_blocks; i++) {\n         std::vector<CMutableTransaction> noTxns;\n         CBlock b = CreateAndProcessBlock(noTxns, scriptPubKey);\n-        if (m_deterministic) {\n-            SetMockTime(GetTime() + 1);\n-        }\n+        SetMockTime(GetTime() + 1);\n         m_coinbase_txns.push_back(b.vtx[0]);\n     }\n }\n@@ -315,9 +303,7 @@ CMutableTransaction TestChain100Setup::CreateValidMempoolTransaction(CTransactio\n TestChain100Setup::~TestChain100Setup()\n {\n     gArgs.ForceSetArg(\"-segwitheight\", \"0\");\n-    if (m_deterministic) {\n-        SetMockTime(0);\n-    }\n+    SetMockTime(0);\n }\n \n CTxMemPoolEntry TestMemPoolEntryHelper::FromTx(const CMutableTransaction& tx) const"
      },
      {
        "sha": "a32f1f380518b8c2504b251dd9d0eb4d6faa2ed9",
        "filename": "src/test/util/setup_common.h",
        "status": "modified",
        "additions": 1,
        "deletions": 7,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/test/util/setup_common.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/test/util/setup_common.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.h?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -112,7 +112,7 @@ class CScript;\n  * Testing fixture that pre-creates a 100-block REGTEST-mode block chain\n  */\n struct TestChain100Setup : public RegTestingSetup {\n-    TestChain100Setup(bool deterministic = false);\n+    TestChain100Setup();\n \n     /**\n      * Create a new block with just given transactions, coinbase paying to\n@@ -143,16 +143,10 @@ struct TestChain100Setup : public RegTestingSetup {\n \n     ~TestChain100Setup();\n \n-    bool m_deterministic;\n     std::vector<CTransactionRef> m_coinbase_txns; // For convenience, coinbase transactions\n     CKey coinbaseKey; // private/public key needed to spend coinbase transactions\n };\n \n-\n-struct TestChain100DeterministicSetup : public TestChain100Setup {\n-    TestChain100DeterministicSetup() : TestChain100Setup(true) { }\n-};\n-\n /**\n  * Make a test setup that has disk access to the debug.log file disabled. Can\n  * be used in \"hot loops\", for example fuzzing or benchmarking."
      },
      {
        "sha": "ab31662f975b1efdf9f2792d17ef9e5a42000e94",
        "filename": "src/test/validation_chainstatemanager_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/test/validation_chainstatemanager_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/test/validation_chainstatemanager_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_chainstatemanager_tests.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -200,7 +200,7 @@ CreateAndActivateUTXOSnapshot(NodeContext& node, const fs::path root, F malleati\n }\n \n //! Test basic snapshot activation.\n-BOOST_FIXTURE_TEST_CASE(chainstatemanager_activate_snapshot, TestChain100DeterministicSetup)\n+BOOST_FIXTURE_TEST_CASE(chainstatemanager_activate_snapshot, TestChain100Setup)\n {\n     ChainstateManager& chainman = *Assert(m_node.chainman);\n \n@@ -259,6 +259,11 @@ BOOST_FIXTURE_TEST_CASE(chainstatemanager_activate_snapshot, TestChain100Determi\n             // Coins count is smaller than coins in file\n             metadata.m_coins_count -= 1;\n     }));\n+    BOOST_REQUIRE(!CreateAndActivateUTXOSnapshot(\n+        m_node, m_path_root, [](CAutoFile& auto_infile, SnapshotMetadata& metadata) {\n+            // Wrong hash\n+            metadata.m_base_blockhash = uint256::ONE;\n+    }));\n \n     BOOST_REQUIRE(CreateAndActivateUTXOSnapshot(m_node, m_path_root));\n "
      },
      {
        "sha": "d0317aca0a401ad75db2d18e689748bcd973150d",
        "filename": "src/test/validation_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/test/validation_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/test/validation_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_tests.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -135,7 +135,7 @@ BOOST_AUTO_TEST_CASE(test_assumeutxo)\n     }\n \n     const auto out110 = *ExpectedAssumeutxo(110, *params);\n-    BOOST_CHECK_EQUAL(out110.hash_serialized, uint256S(\"76fd7334ac7c1baf57ddc0c626f073a655a35d98a4258cd1382c8cc2b8392e10\"));\n+    BOOST_CHECK_EQUAL(out110.hash_serialized, uint256S(\"1ebbf5850204c0bdb15bf030f47c7fe91d45c44c712697e4509ba67adb01c618\"));\n     BOOST_CHECK_EQUAL(out110.nChainTx, (unsigned int)110);\n \n     const auto out210 = *ExpectedAssumeutxo(210, *params);"
      },
      {
        "sha": "e4266e470a459be2f853f941119b272c506bd560",
        "filename": "src/txorphanage.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/txorphanage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/txorphanage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.h?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -24,9 +24,9 @@ class TxOrphanage {\n     bool AddTx(const CTransactionRef& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n \n     /** Check if we already have an orphan transaction (by txid or wtxid) */\n-    bool HaveTx(const GenTxid& gtxid) const EXCLUSIVE_LOCKS_REQUIRED(!g_cs_orphans);\n+    bool HaveTx(const GenTxid& gtxid) const LOCKS_EXCLUDED(::g_cs_orphans);\n \n-    /** Get an orphan transaction and its orginating peer\n+    /** Get an orphan transaction and its originating peer\n      * (Transaction ref will be nullptr if not found)\n      */\n     std::pair<CTransactionRef, NodeId> GetTx(const uint256& txid) const EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n@@ -38,7 +38,7 @@ class TxOrphanage {\n     void EraseForPeer(NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n \n     /** Erase all orphans included in or invalidated by a new block */\n-    void EraseForBlock(const CBlock& block) EXCLUSIVE_LOCKS_REQUIRED(!g_cs_orphans);\n+    void EraseForBlock(const CBlock& block) LOCKS_EXCLUDED(::g_cs_orphans);\n \n     /** Limit the orphanage to the given maximum */\n     unsigned int LimitOrphans(unsigned int max_orphans) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);"
      },
      {
        "sha": "f8d7a1ece8813795bdb9d2acda99e50ff6bbd1d1",
        "filename": "src/txrequest.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/txrequest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/txrequest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txrequest.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -486,7 +486,7 @@ class TxRequestTracker::Impl {\n     }\n \n     //! Make the data structure consistent with a given point in time:\n-    //! - REQUESTED annoucements with expiry <= now are turned into COMPLETED.\n+    //! - REQUESTED announcements with expiry <= now are turned into COMPLETED.\n     //! - CANDIDATE_DELAYED announcements with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n     //! - CANDIDATE_{READY,BEST} announcements with reqtime > now are turned into CANDIDATE_DELAYED.\n     void SetTimePoint(std::chrono::microseconds now, std::vector<std::pair<NodeId, GenTxid>>* expired)"
      },
      {
        "sha": "a4df7cd21b094ccad24350736b5e0417a4ac79d4",
        "filename": "src/util/sock.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/util/sock.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/util/sock.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/sock.h?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -161,7 +161,7 @@ class Sock\n \n     /**\n      * Check if still connected.\n-     * @param[out] err The error string, if the socket has been disconnected.\n+     * @param[out] errmsg The error string, if the socket has been disconnected.\n      * @return true if connected\n      */\n     virtual bool IsConnected(std::string& errmsg) const;"
      },
      {
        "sha": "619d3cea98ba7827c3a39f303a3f0c90b3d100b2",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 29,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -690,7 +690,8 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         }\n     }\n \n-    // Bring the best block into scope\n+    // This is const, but calls into the back end CoinsViews. The CCoinsViewDB at the bottom of the\n+    // hierarchy brings the best block into scope. See CCoinsViewDB::GetBestBlock().\n     m_view.GetBestBlock();\n \n     // we have all inputs cached now, so switch back to dummy (to protect\n@@ -1099,9 +1100,9 @@ static MempoolAcceptResult AcceptToMemoryPoolWithTime(const CChainParams& chainp\n     assert(std::addressof(::ChainstateActive()) == std::addressof(active_chainstate));\n     const MempoolAcceptResult result = MemPoolAccept(pool, active_chainstate).AcceptSingleTransaction(tx, args);\n     if (result.m_result_type != MempoolAcceptResult::ResultType::VALID) {\n-        // Remove coins that were not present in the coins cache before calling ATMPW;\n-        // this is to prevent memory DoS in case we receive a large number of\n-        // invalid transactions that attempt to overrun the in-memory coins cache\n+        // Remove coins that were not present in the coins cache before calling\n+        // AcceptSingleTransaction(); this is to prevent memory DoS in case we receive a large\n+        // number of invalid transactions that attempt to overrun the in-memory coins cache\n         // (`CCoinsViewCache::cacheCoins`).\n \n         for (const COutPoint& hashTx : coins_to_uncache)\n@@ -5422,6 +5423,15 @@ bool ChainstateManager::PopulateAndValidateSnapshot(\n \n     assert(coins_cache.GetBestBlock() == base_blockhash);\n \n+    CBlockIndex* snapshot_start_block = WITH_LOCK(::cs_main, return m_blockman.LookupBlockIndex(base_blockhash));\n+\n+    if (!snapshot_start_block) {\n+        // Needed for GetUTXOStats to determine the height\n+        LogPrintf(\"[snapshot] Did not find snapshot start blockheader %s\\n\",\n+                  base_blockhash.ToString());\n+        return false;\n+    }\n+\n     CCoinsStats stats;\n     auto breakpoint_fnc = [] { /* TODO insert breakpoint here? */ };\n \n@@ -5434,31 +5444,6 @@ bool ChainstateManager::PopulateAndValidateSnapshot(\n         return false;\n     }\n \n-    // Ensure that the base blockhash appears in the known chain of valid headers. We're willing to\n-    // wait a bit here because the snapshot may have been loaded on startup, before we've\n-    // received headers from the network.\n-\n-    int max_secs_to_wait_for_headers = 60 * 10;\n-    CBlockIndex* snapshot_start_block = nullptr;\n-\n-    while (max_secs_to_wait_for_headers > 0) {\n-        snapshot_start_block = WITH_LOCK(::cs_main,\n-            return m_blockman.LookupBlockIndex(base_blockhash));\n-        --max_secs_to_wait_for_headers;\n-\n-        if (!snapshot_start_block) {\n-            std::this_thread::sleep_for(std::chrono::seconds(1));\n-        } else {\n-            break;\n-        }\n-    }\n-\n-    if (snapshot_start_block == nullptr) {\n-        LogPrintf(\"[snapshot] timed out waiting for snapshot start blockheader %s\\n\",\n-            base_blockhash.ToString());\n-        return false;\n-    }\n-\n     // Assert that the deserialized chainstate contents match the expected assumeutxo value.\n \n     int base_height = snapshot_start_block->nHeight;"
      },
      {
        "sha": "9f2c2444827f1bd0606a3fda18d8eff7f54257ec",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -1029,7 +1029,7 @@ inline bool IsBlockPruned(const CBlockIndex* pblockindex)\n /**\n  * Return the expected assumeutxo value for a given height, if one exists.\n  *\n- * @param height[in] Get the assumeutxo value for this height.\n+ * @param[in] height Get the assumeutxo value for this height.\n  *\n  * @returns empty if no assumeutxo configuration exists for the given height.\n  */"
      },
      {
        "sha": "23bdaa671a3e777609ee58711228e5213c7c28fb",
        "filename": "src/wallet/interfaces.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/wallet/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/wallet/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/interfaces.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -514,15 +514,19 @@ class WalletClientImpl : public WalletClient\n     {\n         for (const CRPCCommand& command : GetWalletRPCCommands()) {\n             m_rpc_commands.emplace_back(command.category, command.name, [this, &command](const JSONRPCRequest& request, UniValue& result, bool last_handler) {\n-                return command.actor({request, &m_context}, result, last_handler);\n+                JSONRPCRequest wallet_request = request;\n+                wallet_request.context = &m_context;\n+                return command.actor(wallet_request, result, last_handler);\n             }, command.argNames, command.unique_id);\n             m_rpc_handlers.emplace_back(m_context.chain->handleRpc(m_rpc_commands.back()));\n         }\n \n #ifdef ENABLE_EXTERNAL_SIGNER\n         for (const CRPCCommand& command : GetSignerRPCCommands()) {\n             m_rpc_commands.emplace_back(command.category, command.name, [this, &command](const JSONRPCRequest& request, UniValue& result, bool last_handler) {\n-                return command.actor({request, m_context}, result, last_handler);\n+                JSONRPCRequest wallet_request = request;\n+                wallet_request.context = &m_context;\n+                return command.actor(wallet_request, result, last_handler);\n             }, command.argNames, command.unique_id);\n             m_rpc_handlers.emplace_back(m_context.chain->handleRpc(m_rpc_commands.back()));\n         }"
      },
      {
        "sha": "769987ccf2e776d74011d8b4357d5e1cb03eecf6",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 7,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -1737,22 +1737,23 @@ RPCHelpMan listdescriptors()\n         \"listdescriptors\",\n         \"\\nList descriptors imported into a descriptor-enabled wallet.\",\n         {},\n-        RPCResult{\n-            RPCResult::Type::ARR, \"\", \"Response is an array of descriptor objects\",\n+        RPCResult{RPCResult::Type::OBJ, \"\", \"\", {\n+            {RPCResult::Type::STR, \"wallet_name\", \"Name of wallet this operation was performed on\"},\n+            {RPCResult::Type::ARR, \"descriptors\", \"Array of descriptor objects\",\n             {\n                 {RPCResult::Type::OBJ, \"\", \"\", {\n                     {RPCResult::Type::STR, \"desc\", \"Descriptor string representation\"},\n                     {RPCResult::Type::NUM, \"timestamp\", \"The creation time of the descriptor\"},\n                     {RPCResult::Type::BOOL, \"active\", \"Activeness flag\"},\n-                    {RPCResult::Type::BOOL, \"internal\", true, \"Whether this is internal or external descriptor; defined only for active descriptors\"},\n+                    {RPCResult::Type::BOOL, \"internal\", true, \"Whether this is an internal or external descriptor; defined only for active descriptors\"},\n                     {RPCResult::Type::ARR_FIXED, \"range\", true, \"Defined only for ranged descriptors\", {\n                         {RPCResult::Type::NUM, \"\", \"Range start inclusive\"},\n                         {RPCResult::Type::NUM, \"\", \"Range end inclusive\"},\n                     }},\n                     {RPCResult::Type::NUM, \"next\", true, \"The next index to generate addresses from; defined only for ranged descriptors\"},\n                 }},\n-            }\n-        },\n+            }}\n+        }},\n         RPCExamples{\n             HelpExampleCli(\"listdescriptors\", \"\") + HelpExampleRpc(\"listdescriptors\", \"\")\n         },\n@@ -1769,7 +1770,7 @@ RPCHelpMan listdescriptors()\n \n     LOCK(wallet->cs_wallet);\n \n-    UniValue response(UniValue::VARR);\n+    UniValue descriptors(UniValue::VARR);\n     const auto active_spk_mans = wallet->GetActiveScriptPubKeyMans();\n     for (const auto& spk_man : wallet->GetAllScriptPubKeyMans()) {\n         const auto desc_spk_man = dynamic_cast<DescriptorScriptPubKeyMan*>(spk_man);\n@@ -1798,9 +1799,13 @@ RPCHelpMan listdescriptors()\n             spk.pushKV(\"range\", range);\n             spk.pushKV(\"next\", wallet_descriptor.next_index);\n         }\n-        response.push_back(spk);\n+        descriptors.push_back(spk);\n     }\n \n+    UniValue response(UniValue::VOBJ);\n+    response.pushKV(\"wallet_name\", wallet->GetName());\n+    response.pushKV(\"descriptors\", descriptors);\n+\n     return response;\n },\n     };"
      },
      {
        "sha": "672ee3e7a49601d0fd360e7d87d6ab7672951166",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -1281,7 +1281,7 @@ static void MaybePushAddress(UniValue & entry, const CTxDestination &dest)\n /**\n  * List transactions based on the given criteria.\n  *\n- * @param  pwallet        The wallet.\n+ * @param  wallet         The wallet.\n  * @param  wtx            The wallet transaction.\n  * @param  nMinDepth      The minimum confirmation depth.\n  * @param  fLong          Whether to include the JSON version of the transaction.\n@@ -2711,6 +2711,8 @@ static RPCHelpMan createwallet()\n         RPCExamples{\n             HelpExampleCli(\"createwallet\", \"\\\"testwallet\\\"\")\n             + HelpExampleRpc(\"createwallet\", \"\\\"testwallet\\\"\")\n+            + HelpExampleCliNamed(\"createwallet\", {{\"wallet_name\", \"descriptors\"}, {\"avoid_reuse\", true}, {\"descriptors\", true}, {\"load_on_startup\", true}})\n+            + HelpExampleRpcNamed(\"createwallet\", {{\"wallet_name\", \"descriptors\"}, {\"avoid_reuse\", true}, {\"descriptors\", true}, {\"load_on_startup\", true}})\n         },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {"
      },
      {
        "sha": "9a75002b6c48b5029cec8457997452140182b8c9",
        "filename": "src/wallet/scriptpubkeyman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/wallet/scriptpubkeyman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/wallet/scriptpubkeyman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -84,7 +84,7 @@ bool HaveKeys(const std::vector<valtype>& pubkeys, const LegacyScriptPubKeyMan&\n //! Recursively solve script and return spendable/watchonly/invalid status.\n //!\n //! @param keystore            legacy key and script store\n-//! @param script              script to solve\n+//! @param scriptPubKey        script to solve\n //! @param sigversion          script type (top-level / redeemscript / witnessscript)\n //! @param recurse_scripthash  whether to recurse into nested p2sh and p2wsh\n //!                            scripts or simply treat any script that has been"
      },
      {
        "sha": "91891c5fc2c0ece0c1cc671f14352eab6dd4f391",
        "filename": "src/wallet/sqlite.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 48,
        "changes": 81,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/wallet/sqlite.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/wallet/sqlite.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/sqlite.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -16,6 +16,9 @@\n #include <sqlite3.h>\n #include <stdint.h>\n \n+#include <utility>\n+#include <vector>\n+\n static constexpr int32_t WALLET_SCHEMA_VERSION = 0;\n \n static Mutex g_sqlite_mutex;\n@@ -69,30 +72,21 @@ SQLiteDatabase::SQLiteDatabase(const fs::path& dir_path, const fs::path& file_pa\n \n void SQLiteBatch::SetupSQLStatements()\n {\n-    int res;\n-    if (!m_read_stmt) {\n-        if ((res = sqlite3_prepare_v2(m_database.m_db, \"SELECT value FROM main WHERE key = ?\", -1, &m_read_stmt, nullptr)) != SQLITE_OK) {\n-            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n-        }\n-    }\n-    if (!m_insert_stmt) {\n-        if ((res = sqlite3_prepare_v2(m_database.m_db, \"INSERT INTO main VALUES(?, ?)\", -1, &m_insert_stmt, nullptr)) != SQLITE_OK) {\n-            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n-        }\n-    }\n-    if (!m_overwrite_stmt) {\n-        if ((res = sqlite3_prepare_v2(m_database.m_db, \"INSERT or REPLACE into main values(?, ?)\", -1, &m_overwrite_stmt, nullptr)) != SQLITE_OK) {\n-            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n-        }\n-    }\n-    if (!m_delete_stmt) {\n-        if ((res = sqlite3_prepare_v2(m_database.m_db, \"DELETE FROM main WHERE key = ?\", -1, &m_delete_stmt, nullptr)) != SQLITE_OK) {\n-            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n-        }\n-    }\n-    if (!m_cursor_stmt) {\n-        if ((res = sqlite3_prepare_v2(m_database.m_db, \"SELECT key, value FROM main\", -1, &m_cursor_stmt, nullptr)) != SQLITE_OK) {\n-            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements : %s\\n\", sqlite3_errstr(res)));\n+    const std::vector<std::pair<sqlite3_stmt**, const char*>> statements{\n+        {&m_read_stmt, \"SELECT value FROM main WHERE key = ?\"},\n+        {&m_insert_stmt, \"INSERT INTO main VALUES(?, ?)\"},\n+        {&m_overwrite_stmt, \"INSERT or REPLACE into main values(?, ?)\"},\n+        {&m_delete_stmt, \"DELETE FROM main WHERE key = ?\"},\n+        {&m_cursor_stmt, \"SELECT key, value FROM main\"},\n+    };\n+\n+    for (const auto& [stmt_prepared, stmt_text] : statements) {\n+        if (*stmt_prepared == nullptr) {\n+            int res = sqlite3_prepare_v2(m_database.m_db, stmt_text, -1, stmt_prepared, nullptr);\n+            if (res != SQLITE_OK) {\n+                throw std::runtime_error(strprintf(\n+                    \"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+            }\n         }\n     }\n }\n@@ -353,31 +347,22 @@ void SQLiteBatch::Close()\n     }\n \n     // Free all of the prepared statements\n-    int ret = sqlite3_finalize(m_read_stmt);\n-    if (ret != SQLITE_OK) {\n-        LogPrintf(\"SQLiteBatch: Batch closed but could not finalize read statement: %s\\n\", sqlite3_errstr(ret));\n-    }\n-    ret = sqlite3_finalize(m_insert_stmt);\n-    if (ret != SQLITE_OK) {\n-        LogPrintf(\"SQLiteBatch: Batch closed but could not finalize insert statement: %s\\n\", sqlite3_errstr(ret));\n-    }\n-    ret = sqlite3_finalize(m_overwrite_stmt);\n-    if (ret != SQLITE_OK) {\n-        LogPrintf(\"SQLiteBatch: Batch closed but could not finalize overwrite statement: %s\\n\", sqlite3_errstr(ret));\n-    }\n-    ret = sqlite3_finalize(m_delete_stmt);\n-    if (ret != SQLITE_OK) {\n-        LogPrintf(\"SQLiteBatch: Batch closed but could not finalize delete statement: %s\\n\", sqlite3_errstr(ret));\n-    }\n-    ret = sqlite3_finalize(m_cursor_stmt);\n-    if (ret != SQLITE_OK) {\n-        LogPrintf(\"SQLiteBatch: Batch closed but could not finalize cursor statement: %s\\n\", sqlite3_errstr(ret));\n+    const std::vector<std::pair<sqlite3_stmt**, const char*>> statements{\n+        {&m_read_stmt, \"read\"},\n+        {&m_insert_stmt, \"insert\"},\n+        {&m_overwrite_stmt, \"overwrite\"},\n+        {&m_delete_stmt, \"delete\"},\n+        {&m_cursor_stmt, \"cursor\"},\n+    };\n+\n+    for (const auto& [stmt_prepared, stmt_description] : statements) {\n+        int res = sqlite3_finalize(*stmt_prepared);\n+        if (res != SQLITE_OK) {\n+            LogPrintf(\"SQLiteBatch: Batch closed but could not finalize %s statement: %s\\n\",\n+                      stmt_description, sqlite3_errstr(res));\n+        }\n+        *stmt_prepared = nullptr;\n     }\n-    m_read_stmt = nullptr;\n-    m_insert_stmt = nullptr;\n-    m_overwrite_stmt = nullptr;\n-    m_delete_stmt = nullptr;\n-    m_cursor_stmt = nullptr;\n }\n \n bool SQLiteBatch::ReadKey(CDataStream&& key, CDataStream& value)"
      },
      {
        "sha": "01f2dfe06bfd278754edd3a0ec1cf5a8238ca7e8",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -213,8 +213,7 @@ BOOST_FIXTURE_TEST_CASE(importmulti_rescan, TestChain100Setup)\n         key.pushKV(\"timestamp\", newTip->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1);\n         key.pushKV(\"internal\", UniValue(true));\n         keys.push_back(key);\n-        std::any context;\n-        JSONRPCRequest request(context);\n+        JSONRPCRequest request;\n         request.params.setArray();\n         request.params.push_back(keys);\n \n@@ -265,8 +264,7 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n             AddWallet(wallet);\n             wallet->SetLastBlockProcessed(::ChainActive().Height(), ::ChainActive().Tip()->GetBlockHash());\n         }\n-        std::any context;\n-        JSONRPCRequest request(context);\n+        JSONRPCRequest request;\n         request.params.setArray();\n         request.params.push_back(backup_file);\n \n@@ -281,8 +279,7 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n         LOCK(wallet->cs_wallet);\n         wallet->SetupLegacyScriptPubKeyMan();\n \n-        std::any context;\n-        JSONRPCRequest request(context);\n+        JSONRPCRequest request;\n         request.params.setArray();\n         request.params.push_back(backup_file);\n         AddWallet(wallet);"
      },
      {
        "sha": "192fd60dc2fa507d37d44349213c9f363e12f23a",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -1181,7 +1181,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      * Obviously holding cs_main/cs_wallet when going into this call may cause\n      * deadlock\n      */\n-    void BlockUntilSyncedToCurrentChain() const EXCLUSIVE_LOCKS_REQUIRED(!::cs_main, !cs_wallet);\n+    void BlockUntilSyncedToCurrentChain() const LOCKS_EXCLUDED(::cs_main) EXCLUSIVE_LOCKS_REQUIRED(!cs_wallet);\n \n     /** set a single wallet flag */\n     void SetWalletFlag(uint64_t flags);"
      },
      {
        "sha": "16d7958712dc07c526ae5bba4b02e0599ee002e6",
        "filename": "test/functional/rpc_net.py",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/test/functional/rpc_net.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/test/functional/rpc_net.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_net.py?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -195,7 +195,7 @@ def test_getnodeaddresses(self):\n         for i in range(10000):\n             first_octet = i >> 8\n             second_octet = i % 256\n-            a = \"{}.{}.1.1\".format(first_octet, second_octet)\n+            a = \"{}.{}.1.1\".format(first_octet, second_octet)  # IPV4\n             imported_addrs.append(a)\n             self.nodes[0].addpeeraddress(a, 8333)\n \n@@ -212,6 +212,7 @@ def test_getnodeaddresses(self):\n             assert_equal(a[\"services\"], NODE_NETWORK | NODE_WITNESS)\n             assert a[\"address\"] in imported_addrs\n             assert_equal(a[\"port\"], 8333)\n+            assert_equal(a[\"network\"], \"ipv4\")\n \n         node_addresses = self.nodes[0].getnodeaddresses(1)\n         assert_equal(len(node_addresses), 1)"
      },
      {
        "sha": "60b4d1c7447c9fbb707be62b588c6f7dcc6884a1",
        "filename": "test/functional/rpc_signrawtransaction.py",
        "status": "modified",
        "additions": 79,
        "deletions": 4,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/test/functional/rpc_signrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/test/functional/rpc_signrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_signrawtransaction.py?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -4,16 +4,17 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test transaction signing using the signrawtransaction* RPCs.\"\"\"\n \n-from test_framework.address import check_script, script_to_p2sh\n+from test_framework.address import check_script, script_to_p2sh, script_to_p2wsh\n from test_framework.key import ECKey\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, assert_raises_rpc_error, find_vout_for_address, hex_str_to_bytes\n-from test_framework.messages import sha256\n-from test_framework.script import CScript, OP_0, OP_CHECKSIG\n+from test_framework.messages import sha256, CTransaction, CTxInWitness\n+from test_framework.script import CScript, OP_0, OP_CHECKSIG, OP_CHECKSEQUENCEVERIFY, OP_CHECKLOCKTIMEVERIFY, OP_DROP, OP_TRUE\n from test_framework.script_util import key_to_p2pkh_script, script_to_p2sh_p2wsh_script, script_to_p2wsh_script\n from test_framework.wallet_util import bytes_to_wif\n \n-from decimal import Decimal\n+from decimal import Decimal, getcontext\n+from io import BytesIO\n \n class SignRawTransactionsTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -238,13 +239,87 @@ def OP_1NEGATE_test(self):\n         txn = self.nodes[0].signrawtransactionwithwallet(hex_str, prev_txs)\n         assert txn[\"complete\"]\n \n+    def test_signing_with_csv(self):\n+        self.log.info(\"Test signing a transaction containing a fully signed CSV input\")\n+        self.nodes[0].walletpassphrase(\"password\", 9999)\n+        getcontext().prec = 8\n+\n+        # Make sure CSV is active\n+        self.nodes[0].generate(500)\n+\n+        # Create a P2WSH script with CSV\n+        script = CScript([1, OP_CHECKSEQUENCEVERIFY, OP_DROP])\n+        address = script_to_p2wsh(script)\n+\n+        # Fund that address and make the spend\n+        txid = self.nodes[0].sendtoaddress(address, 1)\n+        vout = find_vout_for_address(self.nodes[0], txid, address)\n+        self.nodes[0].generate(1)\n+        utxo = self.nodes[0].listunspent()[0]\n+        amt = Decimal(1) + utxo[\"amount\"] - Decimal(0.00001)\n+        tx = self.nodes[0].createrawtransaction(\n+            [{\"txid\": txid, \"vout\": vout, \"sequence\": 1},{\"txid\": utxo[\"txid\"], \"vout\": utxo[\"vout\"]}],\n+            [{self.nodes[0].getnewaddress(): amt}],\n+            self.nodes[0].getblockcount()\n+        )\n+\n+        # Set the witness script\n+        ctx = CTransaction()\n+        ctx.deserialize(BytesIO(hex_str_to_bytes(tx)))\n+        ctx.wit.vtxinwit.append(CTxInWitness())\n+        ctx.wit.vtxinwit[0].scriptWitness.stack = [CScript([OP_TRUE]), script]\n+        tx = ctx.serialize_with_witness().hex()\n+\n+        # Sign and send the transaction\n+        signed = self.nodes[0].signrawtransactionwithwallet(tx)\n+        assert_equal(signed[\"complete\"], True)\n+        self.nodes[0].sendrawtransaction(signed[\"hex\"])\n+\n+    def test_signing_with_cltv(self):\n+        self.log.info(\"Test signing a transaction containing a fully signed CLTV input\")\n+        self.nodes[0].walletpassphrase(\"password\", 9999)\n+        getcontext().prec = 8\n+\n+        # Make sure CSV is active\n+        self.nodes[0].generate(1500)\n+\n+        # Create a P2WSH script with CLTV\n+        script = CScript([1000, OP_CHECKLOCKTIMEVERIFY, OP_DROP])\n+        address = script_to_p2wsh(script)\n+\n+        # Fund that address and make the spend\n+        txid = self.nodes[0].sendtoaddress(address, 1)\n+        vout = find_vout_for_address(self.nodes[0], txid, address)\n+        self.nodes[0].generate(1)\n+        utxo = self.nodes[0].listunspent()[0]\n+        amt = Decimal(1) + utxo[\"amount\"] - Decimal(0.00001)\n+        tx = self.nodes[0].createrawtransaction(\n+            [{\"txid\": txid, \"vout\": vout},{\"txid\": utxo[\"txid\"], \"vout\": utxo[\"vout\"]}],\n+            [{self.nodes[0].getnewaddress(): amt}],\n+            self.nodes[0].getblockcount()\n+        )\n+\n+        # Set the witness script\n+        ctx = CTransaction()\n+        ctx.deserialize(BytesIO(hex_str_to_bytes(tx)))\n+        ctx.wit.vtxinwit.append(CTxInWitness())\n+        ctx.wit.vtxinwit[0].scriptWitness.stack = [CScript([OP_TRUE]), script]\n+        tx = ctx.serialize_with_witness().hex()\n+\n+        # Sign and send the transaction\n+        signed = self.nodes[0].signrawtransactionwithwallet(tx)\n+        assert_equal(signed[\"complete\"], True)\n+        self.nodes[0].sendrawtransaction(signed[\"hex\"])\n+\n     def run_test(self):\n         self.successful_signing_test()\n         self.script_verification_error_test()\n         self.witness_script_test()\n         self.OP_1NEGATE_test()\n         self.test_with_lock_outputs()\n         self.test_fully_signed_tx()\n+        self.test_signing_with_csv()\n+        self.test_signing_with_cltv()\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "c1444164ce7a249bb14e3e7be37a5df9b9c7d585",
        "filename": "test/functional/wallet_listdescriptors.py",
        "status": "modified",
        "additions": 25,
        "deletions": 14,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/test/functional/wallet_listdescriptors.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/test/functional/wallet_listdescriptors.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listdescriptors.py?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -36,15 +36,16 @@ def run_test(self):\n \n         self.log.info('Test the command for empty descriptors wallet.')\n         node.createwallet(wallet_name='w2', blank=True, descriptors=True)\n-        assert_equal(0, len(node.get_wallet_rpc('w2').listdescriptors()))\n+        assert_equal(0, len(node.get_wallet_rpc('w2').listdescriptors()['descriptors']))\n \n         self.log.info('Test the command for a default descriptors wallet.')\n         node.createwallet(wallet_name='w3', descriptors=True)\n         result = node.get_wallet_rpc('w3').listdescriptors()\n-        assert_equal(6, len(result))\n-        assert_equal(6, len([d for d in result if d['active']]))\n-        assert_equal(3, len([d for d in result if d['internal']]))\n-        for item in result:\n+        assert_equal(\"w3\", result['wallet_name'])\n+        assert_equal(6, len(result['descriptors']))\n+        assert_equal(6, len([d for d in result['descriptors'] if d['active']]))\n+        assert_equal(3, len([d for d in result['descriptors'] if d['internal']]))\n+        for item in result['descriptors']:\n             assert item['desc'] != ''\n             assert item['next'] == 0\n             assert item['range'] == [0, 0]\n@@ -59,12 +60,17 @@ def run_test(self):\n             'desc': descsum_create('wpkh(' + xprv + hardened_path + '/0/*)'),\n             'timestamp': 1296688602,\n         }])\n-        expected = {'desc': descsum_create('wpkh([80002067' + hardened_path + ']' + xpub_acc + '/0/*)'),\n-                    'timestamp': 1296688602,\n-                    'active': False,\n-                    'range': [0, 0],\n-                    'next': 0}\n-        assert_equal([expected], wallet.listdescriptors())\n+        expected = {\n+            'wallet_name': 'w2',\n+            'descriptors': [\n+                {'desc': descsum_create('wpkh([80002067' + hardened_path + ']' + xpub_acc + '/0/*)'),\n+                 'timestamp': 1296688602,\n+                 'active': False,\n+                 'range': [0, 0],\n+                 'next': 0},\n+            ],\n+        }\n+        assert_equal(expected, wallet.listdescriptors())\n \n         self.log.info('Test non-active non-range combo descriptor')\n         node.createwallet(wallet_name='w4', blank=True, descriptors=True)\n@@ -73,9 +79,14 @@ def run_test(self):\n             'desc': descsum_create('combo(' + node.get_deterministic_priv_key().key + ')'),\n             'timestamp': 1296688602,\n         }])\n-        expected = [{'active': False,\n-                     'desc': 'combo(0227d85ba011276cf25b51df6a188b75e604b38770a462b2d0e9fb2fc839ef5d3f)#np574htj',\n-                     'timestamp': 1296688602}]\n+        expected = {\n+            'wallet_name': 'w4',\n+            'descriptors': [\n+                {'active': False,\n+                 'desc': 'combo(0227d85ba011276cf25b51df6a188b75e604b38770a462b2d0e9fb2fc839ef5d3f)#np574htj',\n+                 'timestamp': 1296688602},\n+            ]\n+        }\n         assert_equal(expected, wallet.listdescriptors())\n \n "
      },
      {
        "sha": "5b832b57636a9376bbea7b64e82723a26d5ba30a",
        "filename": "test/sanitizer_suppressions/tsan",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/test/sanitizer_suppressions/tsan",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/test/sanitizer_suppressions/tsan",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/sanitizer_suppressions/tsan?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -28,7 +28,6 @@ race:BerkeleyBatch\n race:BerkeleyDatabase\n race:DatabaseBatch\n race:leveldb::DBImpl::DeleteObsoleteFiles\n-race:validation_chainstatemanager_tests\n race:zmq::*\n race:bitcoin-qt\n \n@@ -42,6 +41,10 @@ deadlock:TestPotentialDeadLockDetected\n race:src/qt/test/*\n deadlock:src/qt/test/*\n \n+# Race in src/test/main.cpp\n+# Can be removed once upgraded to boost test 1.74 in depends\n+race:validation_chainstatemanager_tests\n+\n # External libraries\n deadlock:libdb\n race:libzmq"
      },
      {
        "sha": "27885b094e250dc42cc6aa100f50098231507838",
        "filename": "test/sanitizer_suppressions/ubsan",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/test/sanitizer_suppressions/ubsan",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc5712eaecc8ecf755e184c3bcb6318ccae451f/test/sanitizer_suppressions/ubsan",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/sanitizer_suppressions/ubsan?ref=7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "patch": "@@ -1,6 +1,10 @@\n # -fsanitize=undefined suppressions\n # =================================\n-# No suppressions at the moment. Hooray!\n+# This would be `signed-integer-overflow:CTxMemPool::PrioritiseTransaction`,\n+# however due to a bug in clang the symbolizer is disabled and thus no symbol\n+# names can be used.\n+# See https://github.com/google/sanitizers/issues/1364\n+signed-integer-overflow:txmempool.cpp\n \n # -fsanitize=integer suppressions\n # ==============================="
      }
    ]
  },
  {
    "sha": "662c7a525c69a71685c95c3bed95bd0a05f5c76a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NjJjN2E1MjVjNjlhNzE2ODVjOTVjM2JlZDk1YmQwYTA1ZjVjNzZh",
    "commit": {
      "author": {
        "name": "J0hn",
        "email": "songjh.john@gmail.com",
        "date": "2021-04-11T15:15:45Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-04-11T15:15:45Z"
      },
      "message": "Merge pull request #4 from bitcoin/master\n\nPull requests without a rationale and clear improvement may be closed immediately.",
      "tree": {
        "sha": "a2e6bd2b554d7da1c9d7e52d2c8363b00ab5e999",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a2e6bd2b554d7da1c9d7e52d2c8363b00ab5e999"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/662c7a525c69a71685c95c3bed95bd0a05f5c76a",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgcxKhCRBK7hj4Ov3rIwAAdHIIABVSCg9B8rgBv1TbHsVQgWKE\nR7E55LsvbBAcSQ6j8nFWV2LTZRK+3WOi+D7YnZ2FwkPVyu0OLN7Bpbm6Uqq8Qxqp\nNWE0TwYFWY/dM21QwlTGM6PmRhrtE4/x6Ay9slpVeONqzsqLmq0B+IX5FbyRHgXR\ngh5froC1zWuWmuxIYsY7/eUDuoTKMG+i78oU5e7iN9SmImfzW1TrspveFko0lOq6\nBKhfcIVlq7p/9on0RRQ7iSHIw6s0juSOrstiZzJGfDevooF9TOVeBJGof+lE+by0\neOOZ0VKpy63L/L/GAr48vnaDTS593vNFe2YC89C7FvI7tFvFk5mH1YlQBUZk1/o=\n=0Fzm\n-----END PGP SIGNATURE-----\n",
        "payload": "tree a2e6bd2b554d7da1c9d7e52d2c8363b00ab5e999\nparent 7dc5712eaecc8ecf755e184c3bcb6318ccae451f\nparent f6c44e999b7d1d9a0de5d678ac8f1679aa271f65\nauthor J0hn <songjh.john@gmail.com> 1618154145 +0100\ncommitter GitHub <noreply@github.com> 1618154145 +0100\n\nMerge pull request #4 from bitcoin/master\n\nPull requests without a rationale and clear improvement may be closed immediately."
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/662c7a525c69a71685c95c3bed95bd0a05f5c76a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/662c7a525c69a71685c95c3bed95bd0a05f5c76a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/662c7a525c69a71685c95c3bed95bd0a05f5c76a/comments",
    "author": {
      "login": "Rqcker",
      "id": 20661419,
      "node_id": "MDQ6VXNlcjIwNjYxNDE5",
      "avatar_url": "https://avatars.githubusercontent.com/u/20661419?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Rqcker",
      "html_url": "https://github.com/Rqcker",
      "followers_url": "https://api.github.com/users/Rqcker/followers",
      "following_url": "https://api.github.com/users/Rqcker/following{/other_user}",
      "gists_url": "https://api.github.com/users/Rqcker/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Rqcker/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Rqcker/subscriptions",
      "organizations_url": "https://api.github.com/users/Rqcker/orgs",
      "repos_url": "https://api.github.com/users/Rqcker/repos",
      "events_url": "https://api.github.com/users/Rqcker/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Rqcker/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7dc5712eaecc8ecf755e184c3bcb6318ccae451f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7dc5712eaecc8ecf755e184c3bcb6318ccae451f"
      },
      {
        "sha": "f6c44e999b7d1d9a0de5d678ac8f1679aa271f65",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f6c44e999b7d1d9a0de5d678ac8f1679aa271f65",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f6c44e999b7d1d9a0de5d678ac8f1679aa271f65"
      }
    ],
    "stats": {
      "total": 83,
      "additions": 62,
      "deletions": 21
    },
    "files": [
      {
        "sha": "6148f56e0d5e37499536f34f08055dca04b49ab9",
        "filename": ".cirrus.yml",
        "status": "modified",
        "additions": 30,
        "deletions": 10,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/662c7a525c69a71685c95c3bed95bd0a05f5c76a/.cirrus.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/662c7a525c69a71685c95c3bed95bd0a05f5c76a/.cirrus.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.cirrus.yml?ref=662c7a525c69a71685c95c3bed95bd0a05f5c76a",
        "patch": "@@ -3,10 +3,19 @@\n env:\n   PACKAGE_MANAGER_INSTALL: \"apt-get update && apt-get install -y\"\n   MAKEJOBS: \"-j4\"\n-  DANGER_RUN_CI_ON_HOST: \"1\"  # Containers will be discarded after the run, so there is no risk that the ci scripts modify the system\n   TEST_RUNNER_PORT_MIN: \"14000\"  # Must be larger than 12321, which is used for the http cache. See https://cirrus-ci.org/guide/writing-tasks/#http-cache\n   CCACHE_SIZE: \"200M\"\n   CCACHE_DIR: \"/tmp/ccache_dir\"\n+  CCACHE_NOHASHDIR: \"1\"  # Debug info might contain a stale path if the build dir changes, but this is fine\n+\n+cirrus_ephemeral_worker_template_env: &CIRRUS_EPHEMERAL_WORKER_TEMPLATE_ENV\n+  DANGER_RUN_CI_ON_HOST: \"1\"  # Containers will be discarded after the run, so there is no risk that the ci scripts modify the system\n+\n+persistent_worker_template_env: &PERSISTENT_WORKER_TEMPLATE_ENV\n+  RESTART_CI_DOCKER_BEFORE_RUN: \"1\"\n+\n+persistent_worker_template: &PERSISTENT_WORKER_TEMPLATE\n+  persistent_worker: {}  # https://cirrus-ci.org/guide/persistent-workers/\n \n # https://cirrus-ci.org/guide/tips-and-tricks/#sharing-configuration-between-tasks\n base_template: &BASE_TEMPLATE\n@@ -31,9 +40,9 @@ global_task_template: &GLOBAL_TASK_TEMPLATE\n   ccache_cache:\n     folder: \"/tmp/ccache_dir\"\n   depends_built_cache:\n-    folder: \"/tmp/cirrus-ci-build/depends/built\"\n+    folder: \"depends/built\"\n   depends_sdk_cache:\n-    folder: \"/tmp/cirrus-ci-build/depends/sdk-sources\"\n+    folder: \"depends/sdk-sources\"\n   ci_script:\n     - ./ci/test_run_all.sh\n \n@@ -69,13 +78,16 @@ task:\n   << : *CREDITS_TEMPLATE\n   lint_script:\n     - ./ci/lint_run_all.sh\n+  env:\n+    << : *CIRRUS_EPHEMERAL_WORKER_TEMPLATE_ENV\n \n task:\n   name: 'ARM [unit tests, no functional tests] [buster]'\n   << : *GLOBAL_TASK_TEMPLATE\n   container:\n     image: debian:buster\n   env:\n+    << : *CIRRUS_EPHEMERAL_WORKER_TEMPLATE_ENV\n     FILE_ENV: \"./ci/test/00_setup_env_arm.sh\"\n \n task:\n@@ -84,6 +96,7 @@ task:\n   container:\n     image: ubuntu:focal\n   env:\n+    << : *CIRRUS_EPHEMERAL_WORKER_TEMPLATE_ENV\n     FILE_ENV: \"./ci/test/00_setup_env_win64.sh\"\n \n task:\n@@ -92,19 +105,18 @@ task:\n   container:\n     image: centos:8\n   env:\n+    << : *CIRRUS_EPHEMERAL_WORKER_TEMPLATE_ENV\n     PACKAGE_MANAGER_INSTALL: \"yum install -y\"\n     FILE_ENV: \"./ci/test/00_setup_env_i686_centos.sh\"\n \n task:\n   name: '[previous releases, uses qt5 dev package and some depends packages] [unsigned char] [bionic]'\n-  # For faster CI feedback, immediately schedule a task that compiles most modules\n-  << : *CREDITS_TEMPLATE\n   << : *GLOBAL_TASK_TEMPLATE\n   depends_releases_cache:\n-    folder: \"/tmp/cirrus-ci-build/releases\"\n-  container:\n-    image: ubuntu:bionic\n+    folder: \"releases\"\n+  << : *PERSISTENT_WORKER_TEMPLATE\n   env:\n+    << : *PERSISTENT_WORKER_TEMPLATE_ENV\n     FILE_ENV: \"./ci/test/00_setup_env_native_qt5.sh\"\n \n task:\n@@ -115,6 +127,7 @@ task:\n     cpu: 6  # Increase CPU and Memory to avoid timeout\n     memory: 24G\n   env:\n+    << : *CIRRUS_EPHEMERAL_WORKER_TEMPLATE_ENV\n     MAKEJOBS: \"-j8\"\n     FILE_ENV: \"./ci/test/00_setup_env_native_tsan.sh\"\n \n@@ -124,6 +137,7 @@ task:\n   container:\n     image: ubuntu:focal\n   env:\n+    << : *CIRRUS_EPHEMERAL_WORKER_TEMPLATE_ENV\n     FILE_ENV: \"./ci/test/00_setup_env_native_msan.sh\"\n \n task:\n@@ -132,6 +146,7 @@ task:\n   container:\n     image: ubuntu:focal\n   env:\n+    << : *CIRRUS_EPHEMERAL_WORKER_TEMPLATE_ENV\n     FILE_ENV: \"./ci/test/00_setup_env_native_asan.sh\"\n \n task:\n@@ -140,6 +155,7 @@ task:\n   container:\n     image: ubuntu:focal\n   env:\n+    << : *CIRRUS_EPHEMERAL_WORKER_TEMPLATE_ENV\n     FILE_ENV: \"./ci/test/00_setup_env_native_fuzz.sh\"\n \n task:\n@@ -148,6 +164,7 @@ task:\n   container:\n     image: ubuntu:focal\n   env:\n+    << : *CIRRUS_EPHEMERAL_WORKER_TEMPLATE_ENV\n     FILE_ENV: \"./ci/test/00_setup_env_native_multiprocess.sh\"\n \n task:\n@@ -156,6 +173,7 @@ task:\n   container:\n     image: ubuntu:bionic\n   env:\n+    << : *CIRRUS_EPHEMERAL_WORKER_TEMPLATE_ENV\n     FILE_ENV: \"./ci/test/00_setup_env_native_nowallet.sh\"\n \n task:\n@@ -164,6 +182,7 @@ task:\n   container:\n     image: ubuntu:focal\n   env:\n+    << : *CIRRUS_EPHEMERAL_WORKER_TEMPLATE_ENV\n     FILE_ENV: \"./ci/test/00_setup_env_mac.sh\"\n \n task:\n@@ -175,17 +194,18 @@ task:\n     # Use latest image, but hardcode version to avoid silent upgrades (and breaks)\n     image: big-sur-xcode-12.4  # https://cirrus-ci.org/guide/macOS\n   env:\n-    DANGER_RUN_CI_ON_HOST: \"true\"\n+    << : *CIRRUS_EPHEMERAL_WORKER_TEMPLATE_ENV\n     CI_USE_APT_INSTALL: \"no\"\n     PACKAGE_MANAGER_INSTALL: \"echo\"  # Nothing to do\n     FILE_ENV: \"./ci/test/00_setup_env_mac_host.sh\"\n \n task:\n   name: 'ARM64 Android APK [focal]'\n   depends_sources_cache:\n-    folder: \"/tmp/cirrus-ci-build/depends/sources\"\n+    folder: \"depends/sources\"\n   << : *GLOBAL_TASK_TEMPLATE\n   container:\n     image: ubuntu:focal\n   env:\n+    << : *CIRRUS_EPHEMERAL_WORKER_TEMPLATE_ENV\n     FILE_ENV: \"./ci/test/00_setup_env_android.sh\""
      },
      {
        "sha": "5d817c8bbde2039db6700d86d9371f196b63c559",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/662c7a525c69a71685c95c3bed95bd0a05f5c76a/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/662c7a525c69a71685c95c3bed95bd0a05f5c76a/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=662c7a525c69a71685c95c3bed95bd0a05f5c76a",
        "patch": "@@ -149,3 +149,5 @@ db4/\n osx_volname\n dist/\n *.background.tiff\n+\n+/guix-build-*"
      },
      {
        "sha": "608acfc2cf5d7467a68fbe757d7bf33b56c2ac59",
        "filename": "ci/test/04_install.sh",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/662c7a525c69a71685c95c3bed95bd0a05f5c76a/ci/test/04_install.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/662c7a525c69a71685c95c3bed95bd0a05f5c76a/ci/test/04_install.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/04_install.sh?ref=662c7a525c69a71685c95c3bed95bd0a05f5c76a",
        "patch": "@@ -33,7 +33,12 @@ if [ -z \"$DANGER_RUN_CI_ON_HOST\" ]; then\n   echo \"Creating $DOCKER_NAME_TAG container to run in\"\n   ${CI_RETRY_EXE} docker pull \"$DOCKER_NAME_TAG\"\n \n-  DOCKER_ID=$(docker run $DOCKER_ADMIN -idt \\\n+  if [ -n \"${RESTART_CI_DOCKER_BEFORE_RUN}\" ] ; then\n+    echo \"Restart docker before run to stop and clear all containers started with --rm\"\n+    systemctl restart docker\n+  fi\n+\n+  DOCKER_ID=$(docker run $DOCKER_ADMIN --rm --interactive --detach --tty \\\n                   --mount type=bind,src=$BASE_ROOT_DIR,dst=/ro_base,readonly \\\n                   --mount type=bind,src=$CCACHE_DIR,dst=$CCACHE_DIR \\\n                   --mount type=bind,src=$DEPENDS_DIR,dst=$DEPENDS_DIR \\"
      },
      {
        "sha": "fced86254a48b6f399cca123ff51141e5585376f",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/662c7a525c69a71685c95c3bed95bd0a05f5c76a/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/662c7a525c69a71685c95c3bed95bd0a05f5c76a/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=662c7a525c69a71685c95c3bed95bd0a05f5c76a",
        "patch": "@@ -104,6 +104,10 @@ Updated RPCs\n   with the `-json` option set, the following fields: `addresses`, `reqSigs` are no longer\n   returned in the tx output of the response. (#20286)\n \n+- The `listbanned` RPC now returns two new numeric fields: `ban_duration` and `time_remaining`.\n+  Respectively, these new fields indicate the duration of a ban and the time remaining until a ban expires,\n+  both in seconds. Additionally, the `ban_created` field is repositioned to come before `banned_until`. (#21602)\n+\n Changes to Wallet or GUI related RPCs can be found in the GUI or Wallet section below.\n \n New RPCs"
      },
      {
        "sha": "337f861903e1a5433ec8d193d437d56d9f98824d",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 4,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/662c7a525c69a71685c95c3bed95bd0a05f5c76a/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/662c7a525c69a71685c95c3bed95bd0a05f5c76a/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=662c7a525c69a71685c95c3bed95bd0a05f5c76a",
        "patch": "@@ -749,9 +749,11 @@ static RPCHelpMan listbanned()\n             {\n                 {RPCResult::Type::OBJ, \"\", \"\",\n                     {\n-                        {RPCResult::Type::STR, \"address\", \"\"},\n-                        {RPCResult::Type::NUM_TIME, \"banned_until\", \"\"},\n-                        {RPCResult::Type::NUM_TIME, \"ban_created\", \"\"},\n+                        {RPCResult::Type::STR, \"address\", \"The IP/Subnet of the banned node\"},\n+                        {RPCResult::Type::NUM_TIME, \"ban_created\", \"The \" + UNIX_EPOCH_TIME + \" the ban was created\"},\n+                        {RPCResult::Type::NUM_TIME, \"banned_until\", \"The \" + UNIX_EPOCH_TIME + \" the ban expires\"},\n+                        {RPCResult::Type::NUM_TIME, \"ban_duration\", \"The ban duration, in seconds\"},\n+                        {RPCResult::Type::NUM_TIME, \"time_remaining\", \"The time remaining until the ban expires, in seconds\"},\n                     }},\n             }},\n                 RPCExamples{\n@@ -767,15 +769,18 @@ static RPCHelpMan listbanned()\n \n     banmap_t banMap;\n     node.banman->GetBanned(banMap);\n+    const int64_t current_time{GetTime()};\n \n     UniValue bannedAddresses(UniValue::VARR);\n     for (const auto& entry : banMap)\n     {\n         const CBanEntry& banEntry = entry.second;\n         UniValue rec(UniValue::VOBJ);\n         rec.pushKV(\"address\", entry.first.ToString());\n-        rec.pushKV(\"banned_until\", banEntry.nBanUntil);\n         rec.pushKV(\"ban_created\", banEntry.nCreateTime);\n+        rec.pushKV(\"banned_until\", banEntry.nBanUntil);\n+        rec.pushKV(\"ban_duration\", (banEntry.nBanUntil - banEntry.nCreateTime));\n+        rec.pushKV(\"time_remaining\", (banEntry.nBanUntil - current_time));\n \n         bannedAddresses.push_back(rec);\n     }"
      },
      {
        "sha": "3b6faf7bbb38a91a8152d9fe276cd1e8603c4ec6",
        "filename": "src/test/rpc_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 6,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/662c7a525c69a71685c95c3bed95bd0a05f5c76a/src/test/rpc_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/662c7a525c69a71685c95c3bed95bd0a05f5c76a/src/test/rpc_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/rpc_tests.cpp?ref=662c7a525c69a71685c95c3bed95bd0a05f5c76a",
        "patch": "@@ -269,9 +269,9 @@ BOOST_AUTO_TEST_CASE(rpc_ban)\n     ar = r.get_array();\n     o1 = ar[0].get_obj();\n     adr = find_value(o1, \"address\");\n-    UniValue banned_until = find_value(o1, \"banned_until\");\n+    int64_t banned_until{find_value(o1, \"banned_until\").get_int64()};\n     BOOST_CHECK_EQUAL(adr.get_str(), \"127.0.0.0/24\");\n-    BOOST_CHECK_EQUAL(banned_until.get_int64(), 9907731200); // absolute time check\n+    BOOST_CHECK_EQUAL(banned_until, 9907731200); // absolute time check\n \n     BOOST_CHECK_NO_THROW(CallRPC(std::string(\"clearbanned\")));\n \n@@ -280,11 +280,16 @@ BOOST_AUTO_TEST_CASE(rpc_ban)\n     ar = r.get_array();\n     o1 = ar[0].get_obj();\n     adr = find_value(o1, \"address\");\n-    banned_until = find_value(o1, \"banned_until\");\n+    banned_until = find_value(o1, \"banned_until\").get_int64();\n+    const int64_t ban_created{find_value(o1, \"ban_created\").get_int64()};\n+    const int64_t ban_duration{find_value(o1, \"ban_duration\").get_int64()};\n+    const int64_t time_remaining{find_value(o1, \"time_remaining\").get_int64()};\n+    const int64_t now{GetTime()};\n     BOOST_CHECK_EQUAL(adr.get_str(), \"127.0.0.0/24\");\n-    int64_t now = GetTime();\n-    BOOST_CHECK(banned_until.get_int64() > now);\n-    BOOST_CHECK(banned_until.get_int64()-now <= 200);\n+    BOOST_CHECK(banned_until > now);\n+    BOOST_CHECK(banned_until - now <= 200);\n+    BOOST_CHECK_EQUAL(ban_duration, banned_until - ban_created);\n+    BOOST_CHECK_EQUAL(time_remaining, banned_until - now);\n \n     // must throw an exception because 127.0.0.1 is in already banned subnet range\n     BOOST_CHECK_THROW(r = CallRPC(std::string(\"setban 127.0.0.1 add\")), std::runtime_error);"
      }
    ]
  },
  {
    "sha": "e94414b77bcdcac3110d41a6ad56fbb8732887b9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplOTQ0MTRiNzdiY2RjYWMzMTEwZDQxYTZhZDU2ZmJiODczMjg4N2I5",
    "commit": {
      "author": {
        "name": "J0hn",
        "email": "songjh.john@gmail.com",
        "date": "2021-04-12T23:06:02Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-04-12T23:06:02Z"
      },
      "message": "Merge pull request #5 from bitcoin/master\n\nFixed the bitcoin",
      "tree": {
        "sha": "25a78eafa1d87abe0da5ae4f6957b7c77f53ce23",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/25a78eafa1d87abe0da5ae4f6957b7c77f53ce23"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e94414b77bcdcac3110d41a6ad56fbb8732887b9",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgdNJaCRBK7hj4Ov3rIwAAdHIIACLww++yccCJPxzGGG2v40iL\ndYlGA8p5KqRRuwaKRdQJ8kAB9E2N+jUjqIshZIR1bqk6mj9Mftkh0MWGzDHPGYLQ\nF5C7CcLysfNBOru7DYBoRhrfKNWZ37NOR8zgXrTUW2ol1WZ9sQclY5nVM2Afhv4Q\ny4b69AQL8YHAlH9JsujJK5UEax1jb58Q5mnlFjDyyMyHnqKmmhzdbf3TQjTLlafq\np1nSCoksSsW4/swXnTSlhdJ+RUBTllcT2i4XfhefWI2eiMkR85sN2F7/2rC/iIzi\nyUg1cQSYAAWXLiOguWduXdo6lfs2C/RjmY3fD+L7Lsq/U+4gdIDnj6rBV1ndK7U=\n=3ApB\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 25a78eafa1d87abe0da5ae4f6957b7c77f53ce23\nparent 662c7a525c69a71685c95c3bed95bd0a05f5c76a\nparent 708517b2dd642c20a240431891ab90979168372d\nauthor J0hn <songjh.john@gmail.com> 1618268762 +0100\ncommitter GitHub <noreply@github.com> 1618268762 +0100\n\nMerge pull request #5 from bitcoin/master\n\nFixed the bitcoin"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e94414b77bcdcac3110d41a6ad56fbb8732887b9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e94414b77bcdcac3110d41a6ad56fbb8732887b9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e94414b77bcdcac3110d41a6ad56fbb8732887b9/comments",
    "author": {
      "login": "Rqcker",
      "id": 20661419,
      "node_id": "MDQ6VXNlcjIwNjYxNDE5",
      "avatar_url": "https://avatars.githubusercontent.com/u/20661419?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Rqcker",
      "html_url": "https://github.com/Rqcker",
      "followers_url": "https://api.github.com/users/Rqcker/followers",
      "following_url": "https://api.github.com/users/Rqcker/following{/other_user}",
      "gists_url": "https://api.github.com/users/Rqcker/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Rqcker/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Rqcker/subscriptions",
      "organizations_url": "https://api.github.com/users/Rqcker/orgs",
      "repos_url": "https://api.github.com/users/Rqcker/repos",
      "events_url": "https://api.github.com/users/Rqcker/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Rqcker/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "662c7a525c69a71685c95c3bed95bd0a05f5c76a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/662c7a525c69a71685c95c3bed95bd0a05f5c76a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/662c7a525c69a71685c95c3bed95bd0a05f5c76a"
      },
      {
        "sha": "708517b2dd642c20a240431891ab90979168372d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/708517b2dd642c20a240431891ab90979168372d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/708517b2dd642c20a240431891ab90979168372d"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 3,
      "deletions": 2
    },
    "files": [
      {
        "sha": "3999e2dfd746db4622342665982c27dd45ff422d",
        "filename": ".cirrus.yml",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e94414b77bcdcac3110d41a6ad56fbb8732887b9/.cirrus.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e94414b77bcdcac3110d41a6ad56fbb8732887b9/.cirrus.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.cirrus.yml?ref=e94414b77bcdcac3110d41a6ad56fbb8732887b9",
        "patch": "@@ -187,8 +187,9 @@ task:\n \n task:\n   name: 'macOS 11 native [gui] [no depends]'\n-  macos_brew_addon_script:\n-    - brew install boost libevent berkeley-db4 qt miniupnpc libnatpmp ccache zeromq qrencode sqlite libtool automake pkg-config gnu-getopt\n+  brew_install_script:\n+    - brew update\n+    - brew install boost libevent berkeley-db4 qt@5 miniupnpc libnatpmp ccache zeromq qrencode sqlite libtool automake pkg-config gnu-getopt\n   << : *GLOBAL_TASK_TEMPLATE\n   osx_instance:\n     # Use latest image, but hardcode version to avoid silent upgrades (and breaks)"
      }
    ]
  },
  {
    "sha": "fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZDA2YTdiNzc1ZDM3ZjYwY2JmNzhmNWViNGVmMzc3MjhjYjhhNzlm",
    "commit": {
      "author": {
        "name": "J0hn",
        "email": "songjh.john@gmail.com",
        "date": "2021-04-15T12:59:37Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-04-15T12:59:37Z"
      },
      "message": "Merge pull request #6 from bitcoin/master\n\nGUI-related pull requests",
      "tree": {
        "sha": "03317584ae2e941555ab7fe29d392a359af24ab1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/03317584ae2e941555ab7fe29d392a359af24ab1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgeDi5CRBK7hj4Ov3rIwAAdHIIAF01Up1bKRBdvDNgbtuNOLOY\n8BsMSvVTfSFPdas1h+kdGY3YpBo+h0idy4LKserdTJMH6C1xFMkYJ1ZfCM7+u/v9\nMBTumhCKIFShNv3wrqV6hNFE8DtkNAO+gVQyKDe9E7SzlgZ5MDUQZH2ys8bUW2N+\njg6/dAlr27ROnQynJGgk3ZD1yHiDDew7lUgiEQOQJxxJvWWfBweCjCE6WDbRvNfU\nWotEMpqbMNKKVKiVJk+VYBRcet35qNAgHtNnwidE+xy2plRLkZKdLIaVxNfY08nK\nfHYDu0l3yz1BocMfOZOYu2A3eNyRROHH0hb77xBCQ3Y3wPfVBDvvIXhwzlJ6bFM=\n=LuaH\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 03317584ae2e941555ab7fe29d392a359af24ab1\nparent e94414b77bcdcac3110d41a6ad56fbb8732887b9\nparent c6b30ccb2eee5f80f844f79766591f0a1326ce43\nauthor J0hn <songjh.john@gmail.com> 1618491577 +0100\ncommitter GitHub <noreply@github.com> 1618491577 +0100\n\nMerge pull request #6 from bitcoin/master\n\nGUI-related pull requests"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/comments",
    "author": {
      "login": "Rqcker",
      "id": 20661419,
      "node_id": "MDQ6VXNlcjIwNjYxNDE5",
      "avatar_url": "https://avatars.githubusercontent.com/u/20661419?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Rqcker",
      "html_url": "https://github.com/Rqcker",
      "followers_url": "https://api.github.com/users/Rqcker/followers",
      "following_url": "https://api.github.com/users/Rqcker/following{/other_user}",
      "gists_url": "https://api.github.com/users/Rqcker/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Rqcker/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Rqcker/subscriptions",
      "organizations_url": "https://api.github.com/users/Rqcker/orgs",
      "repos_url": "https://api.github.com/users/Rqcker/repos",
      "events_url": "https://api.github.com/users/Rqcker/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Rqcker/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e94414b77bcdcac3110d41a6ad56fbb8732887b9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e94414b77bcdcac3110d41a6ad56fbb8732887b9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e94414b77bcdcac3110d41a6ad56fbb8732887b9"
      },
      {
        "sha": "c6b30ccb2eee5f80f844f79766591f0a1326ce43",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6b30ccb2eee5f80f844f79766591f0a1326ce43",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c6b30ccb2eee5f80f844f79766591f0a1326ce43"
      }
    ],
    "stats": {
      "total": 2322,
      "additions": 1365,
      "deletions": 957
    },
    "files": [
      {
        "sha": "6dc029ee51e470afd83206fdfbe3d6067dd26e5b",
        "filename": ".cirrus.yml",
        "status": "modified",
        "additions": 10,
        "deletions": 6,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/.cirrus.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/.cirrus.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.cirrus.yml?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -41,11 +41,13 @@ global_task_template: &GLOBAL_TASK_TEMPLATE\n     folder: \"/tmp/ccache_dir\"\n   depends_built_cache:\n     folder: \"depends/built\"\n-  depends_sdk_cache:\n-    folder: \"depends/sdk-sources\"\n   ci_script:\n     - ./ci/test_run_all.sh\n \n+depends_sdk_cache_template: &DEPENDS_SDK_CACHE_TEMPLATE\n+  depends_sdk_cache:\n+    folder: \"depends/sdk-sources\"\n+\n compute_credits_template: &CREDITS_TEMPLATE\n   # https://cirrus-ci.org/pricing/#compute-credits\n   # Only use credits for pull requests to the main repo\n@@ -111,19 +113,19 @@ task:\n \n task:\n   name: '[previous releases, uses qt5 dev package and some depends packages] [unsigned char] [bionic]'\n-  << : *GLOBAL_TASK_TEMPLATE\n-  depends_releases_cache:\n+  previous_releases_cache:\n     folder: \"releases\"\n+  << : *GLOBAL_TASK_TEMPLATE\n   << : *PERSISTENT_WORKER_TEMPLATE\n   env:\n     << : *PERSISTENT_WORKER_TEMPLATE_ENV\n     FILE_ENV: \"./ci/test/00_setup_env_native_qt5.sh\"\n \n task:\n-  name: '[depends, sanitizers: thread (TSan), no gui] [focal]'\n+  name: '[depends, sanitizers: thread (TSan), no gui] [hirsute]'\n   << : *GLOBAL_TASK_TEMPLATE\n   container:\n-    image: ubuntu:focal\n+    image: ubuntu:hirsute\n     cpu: 6  # Increase CPU and Memory to avoid timeout\n     memory: 24G\n   env:\n@@ -178,6 +180,7 @@ task:\n \n task:\n   name: 'macOS 10.14 [gui, no tests] [focal]'\n+  << : *DEPENDS_SDK_CACHE_TEMPLATE\n   << : *GLOBAL_TASK_TEMPLATE\n   container:\n     image: ubuntu:focal\n@@ -202,6 +205,7 @@ task:\n \n task:\n   name: 'ARM64 Android APK [focal]'\n+  << : *DEPENDS_SDK_CACHE_TEMPLATE\n   depends_sources_cache:\n     folder: \"depends/sources\"\n   << : *GLOBAL_TASK_TEMPLATE"
      },
      {
        "sha": "07f099b85ce2e6a31c428b3a4ad8b5321174184e",
        "filename": "ci/test/00_setup_env_arm.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_arm.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_arm.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_arm.sh?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -25,4 +25,4 @@ export RUN_FUNCTIONAL_TESTS=false\n export GOAL=\"install\"\n # -Wno-psabi is to disable ABI warnings: \"note: parameter passing for argument of type ... changed in GCC 7.1\"\n # This could be removed once the ABI change warning does not show up by default\n-export BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports CXXFLAGS=-Wno-psabi --with-boost-process\"\n+export BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports CXXFLAGS=-Wno-psabi --enable-external-signer\""
      },
      {
        "sha": "05c724fc0bd1689d1ed36cc36373083d620e8f64",
        "filename": "ci/test/00_setup_env_i686_centos.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_i686_centos.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_i686_centos.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_i686_centos.sh?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -11,6 +11,6 @@ export CONTAINER_NAME=ci_i686_centos_8\n export DOCKER_NAME_TAG=centos:8\n export DOCKER_PACKAGES=\"gcc-c++ glibc-devel.x86_64 libstdc++-devel.x86_64 glibc-devel.i686 libstdc++-devel.i686 ccache libtool make git python3 python3-zmq which patch lbzip2 dash rsync coreutils bison\"\n export GOAL=\"install\"\n-export BITCOIN_CONFIG=\"--enable-zmq --with-gui=qt5 --enable-reduce-exports --with-boost-process\"\n+export BITCOIN_CONFIG=\"--enable-zmq --with-gui=qt5 --enable-reduce-exports --enable-external-signer\"\n export CONFIG_SHELL=\"/bin/dash\"\n export TEST_RUNNER_ENV=\"LC_ALL=en_US.UTF-8\""
      },
      {
        "sha": "f051318a58c691789cf71889b260d1883e1aad00",
        "filename": "ci/test/00_setup_env_mac.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_mac.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_mac.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_mac.sh?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -15,4 +15,4 @@ export XCODE_BUILD_ID=11C505\n export RUN_UNIT_TESTS=false\n export RUN_FUNCTIONAL_TESTS=false\n export GOAL=\"deploy\"\n-export BITCOIN_CONFIG=\"--with-gui --enable-reduce-exports --with-boost-process\"\n+export BITCOIN_CONFIG=\"--with-gui --enable-reduce-exports --enable-external-signer\""
      },
      {
        "sha": "e54e78add4a64bdd1a8bf69c875e29f2aa7d921c",
        "filename": "ci/test/00_setup_env_mac_host.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_mac_host.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_mac_host.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_mac_host.sh?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -9,7 +9,7 @@ export LC_ALL=C.UTF-8\n export HOST=x86_64-apple-darwin18\n export PIP_PACKAGES=\"zmq\"\n export GOAL=\"install\"\n-export BITCOIN_CONFIG=\"--with-gui --enable-reduce-exports --with-boost-process\"\n+export BITCOIN_CONFIG=\"--with-gui --enable-reduce-exports --enable-external-signer\"\n export CI_OS_NAME=\"macos\"\n export NO_DEPENDS=1\n export OSX_SDK=\"\""
      },
      {
        "sha": "6039c510188889162c9fe9f5f9491ad5183ecfee",
        "filename": "ci/test/00_setup_env_native_asan.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_native_asan.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_native_asan.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_native_asan.sh?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -11,4 +11,4 @@ export PACKAGES=\"clang llvm python3-zmq qtbase5-dev qttools5-dev-tools libevent-\n export DOCKER_NAME_TAG=ubuntu:20.04\n export NO_DEPENDS=1\n export GOAL=\"install\"\n-export BITCOIN_CONFIG=\"--enable-zmq --with-incompatible-bdb --with-gui=qt5 CPPFLAGS='-DARENA_DEBUG -DDEBUG_LOCKORDER' --with-sanitizers=address,integer,undefined CC=clang CXX=clang++ --with-boost-process\"\n+export BITCOIN_CONFIG=\"--enable-zmq --with-incompatible-bdb --with-gui=qt5 CPPFLAGS='-DARENA_DEBUG -DDEBUG_LOCKORDER' --with-sanitizers=address,integer,undefined CC=clang CXX=clang++ --enable-external-signer\""
      },
      {
        "sha": "bedd0cf9aa3f201f3ba1b1da2edf888dcaede7b1",
        "filename": "ci/test/00_setup_env_native_fuzz.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_native_fuzz.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_native_fuzz.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_native_fuzz.sh?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -14,5 +14,5 @@ export RUN_UNIT_TESTS=false\n export RUN_FUNCTIONAL_TESTS=false\n export RUN_FUZZ_TESTS=true\n export GOAL=\"install\"\n-export BITCOIN_CONFIG=\"--enable-fuzz --with-sanitizers=fuzzer,address,undefined,integer CC=clang CXX=clang++ --with-boost-process\"\n+export BITCOIN_CONFIG=\"--enable-fuzz --with-sanitizers=fuzzer,address,undefined,integer CC=clang CXX=clang++ --enable-external-signer\"\n export CCACHE_SIZE=200M"
      },
      {
        "sha": "26a3996ce2b36ce2c9fa780f2dc12e4df379a7e8",
        "filename": "ci/test/00_setup_env_native_multiprocess.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_native_multiprocess.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_native_multiprocess.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_native_multiprocess.sh?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -11,6 +11,6 @@ export DOCKER_NAME_TAG=ubuntu:20.04\n export PACKAGES=\"cmake python3\"\n export DEP_OPTS=\"MULTIPROCESS=1\"\n export GOAL=\"install\"\n-export BITCOIN_CONFIG=\"--with-boost-process\"\n+export BITCOIN_CONFIG=\"--enable-external-signer\"\n export TEST_RUNNER_ENV=\"BITCOIND=bitcoin-node\"\n export RUN_SECURITY_TESTS=\"true\""
      },
      {
        "sha": "a496b5af6e98a936a5e3338f4ee467fe2d080587",
        "filename": "ci/test/00_setup_env_native_nowallet.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_native_nowallet.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_native_nowallet.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_native_nowallet.sh?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -11,4 +11,4 @@ export DOCKER_NAME_TAG=ubuntu:18.04  # Use bionic to have one config run the tes\n export PACKAGES=\"python3-zmq clang-5.0 llvm-5.0\"  # Use clang-5 to test C++17 compatibility, see doc/dependencies.md\n export DEP_OPTS=\"NO_WALLET=1\"\n export GOAL=\"install\"\n-export BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports CC=clang-5.0 CXX=clang++-5.0 --with-boost-process\"\n+export BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports CC=clang-5.0 CXX=clang++-5.0 --enable-external-signer\""
      },
      {
        "sha": "61948ab2219cc52fc91c3cca28e6bb2677a1bde1",
        "filename": "ci/test/00_setup_env_native_qt5.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_native_qt5.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_native_qt5.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_native_qt5.sh?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -16,4 +16,4 @@ export RUN_UNIT_TESTS=\"false\"\n export GOAL=\"install\"\n export PREVIOUS_RELEASES_TO_DOWNLOAD=\"v0.15.2 v0.16.3 v0.17.2 v0.18.1 v0.19.1\"\n export BITCOIN_CONFIG=\"--enable-zmq --with-libs=no --with-gui=qt5 --enable-glibc-back-compat --enable-reduce-exports\n---enable-debug --disable-fuzz-binary  CFLAGS=\\\"-g0 -O2 -funsigned-char\\\" CXXFLAGS=\\\"-g0 -O2 -funsigned-char\\\" --with-boost-process\"\n+--enable-debug --disable-fuzz-binary  CFLAGS=\\\"-g0 -O2 -funsigned-char\\\" CXXFLAGS=\\\"-g0 -O2 -funsigned-char\\\" --enable-external-signer\""
      },
      {
        "sha": "33f63fa9ba989c26396234fd4c0c9fce1749e542",
        "filename": "ci/test/00_setup_env_native_tsan.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_native_tsan.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_native_tsan.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_native_tsan.sh?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -7,8 +7,8 @@\n export LC_ALL=C.UTF-8\n \n export CONTAINER_NAME=ci_native_tsan\n-export DOCKER_NAME_TAG=ubuntu:20.04\n+export DOCKER_NAME_TAG=ubuntu:hirsute\n export PACKAGES=\"clang llvm libc++abi-dev libc++-dev python3-zmq\"\n export DEP_OPTS=\"CC=clang CXX='clang++ -stdlib=libc++'\"\n export GOAL=\"install\"\n-export BITCOIN_CONFIG=\"--enable-zmq --with-gui=no CPPFLAGS='-DARENA_DEBUG -DDEBUG_LOCKORDER' CXXFLAGS='-g' --with-sanitizers=thread CC=clang CXX='clang++ -stdlib=libc++' --with-boost-process\"\n+export BITCOIN_CONFIG=\"--enable-zmq --with-gui=no CPPFLAGS='-DARENA_DEBUG -DDEBUG_LOCKORDER' CXXFLAGS='-g' --with-sanitizers=thread CC=clang CXX='clang++ -stdlib=libc++' --enable-external-signer\""
      },
      {
        "sha": "88b431f3c75cc83dbe198bc7425edd5978a000a5",
        "filename": "ci/test/00_setup_env_s390x.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_s390x.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_s390x.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_s390x.sh?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -23,4 +23,4 @@ export RUN_UNIT_TESTS=true\n export TEST_RUNNER_ENV=\"LC_ALL=C\"\n export RUN_FUNCTIONAL_TESTS=true\n export GOAL=\"install\"\n-export BITCOIN_CONFIG=\"--enable-reduce-exports --with-incompatible-bdb --with-boost-process\"\n+export BITCOIN_CONFIG=\"--enable-reduce-exports --with-incompatible-bdb --enable-external-signer\""
      },
      {
        "sha": "4d5bde13fddac6ec8a4756dd6d70c5bfc48052cd",
        "filename": "ci/test/00_setup_env_win64.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_win64.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/ci/test/00_setup_env_win64.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_win64.sh?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -13,7 +13,7 @@ export DPKG_ADD_ARCH=\"i386\"\n export PACKAGES=\"python3 nsis g++-mingw-w64-x86-64 wine-binfmt wine64 wine32 file\"\n export RUN_FUNCTIONAL_TESTS=false\n export GOAL=\"deploy\"\n-export BITCOIN_CONFIG=\"--enable-reduce-exports --disable-gui-tests --without-boost-process\"\n+export BITCOIN_CONFIG=\"--enable-reduce-exports --disable-gui-tests --disable-external-signer\"\n \n # Compiler for MinGW-w64 causes false -Wreturn-type warning.\n # See https://sourceforge.net/p/mingw-w64/bugs/306/"
      },
      {
        "sha": "dad7de32c41cec7ba66bdfd7c1369d48971a69ba",
        "filename": "contrib/guix/README.md",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/contrib/guix/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/contrib/guix/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/README.md?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -131,7 +131,7 @@ export JOBS=1 ADDITIONAL_GUIX_COMMON_FLAGS='--max-jobs=8'\n From the top of a clean Bitcoin Core repository:\n \n ```sh\n-./contrib/guix/guix-build.sh\n+./contrib/guix/guix-build\n ```\n \n After the build finishes successfully (check the status code please), compare\n@@ -205,10 +205,7 @@ find output/ -type f -print0 | sort -z | xargs -r0 sha256sum\n \n * _**ADDITIONAL_GUIX_COMMON_FLAGS**_\n \n-  Additional flags to be passed to all `guix` commands. For a fully-bootstrapped\n-  build, set this to `--bootstrap --no-substitutes` (refer to the [security\n-  model section](#choosing-your-security-model) for more details). Note that a\n-  fully-bootstrapped build will take quite a long time on the first run.\n+  Additional flags to be passed to all `guix` commands.\n \n * _**ADDITIONAL_GUIX_TIMEMACHINE_FLAGS**_\n "
      },
      {
        "sha": "6b20791281a827b1d418926b43fbf96c0ae9cbd2",
        "filename": "depends/README.md",
        "status": "modified",
        "additions": 9,
        "deletions": 7,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/depends/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/depends/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/README.md?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -12,15 +12,18 @@ For example:\n \n     make HOST=x86_64-w64-mingw32 -j4\n \n-**Bitcoin Core's configure script by default will ignore the depends output.** In\n+**Bitcoin Core's `configure` script by default will ignore the depends output.** In\n order for it to pick up libraries, tools, and settings from the depends build,\n-you must point it at the appropriate `--prefix` directory generated by the\n-build. In the above example, a prefix dir named x86_64-w64-mingw32 will be\n-created. To use it for Bitcoin:\n+you must set the `CONFIG_SITE` environment variable to point to a `config.site` settings file.\n+In the above example, a file named `depends/x86_64-w64-mingw32/share/config.site` will be\n+created. To use it during compilation:\n \n-    ./configure --prefix=$PWD/depends/x86_64-w64-mingw32\n+    CONFIG_SITE=$PWD/depends/x86_64-w64-mingw32/share/config.site ./configure\n \n-Common `host-platform-triplets` for cross compilation are:\n+The default install prefix when using `config.site` is `--prefix=depends/<host-platform-triplet>`,\n+so depends build outputs will be installed in that location.\n+\n+Common `host-platform-triplet`s for cross compilation are:\n \n - `i686-pc-linux-gnu` for Linux 32 bit\n - `x86_64-pc-linux-gnu` for x86 Linux\n@@ -133,4 +136,3 @@ This is an example command for a default build with no disabled dependencies:\n \n - [description.md](description.md): General description of the depends system\n - [packages.md](packages.md): Steps for adding packages\n-"
      },
      {
        "sha": "0c438db29a425c42d974bb40310b16465551a527",
        "filename": "doc/build-unix.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/doc/build-unix.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/doc/build-unix.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-unix.md?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -331,7 +331,7 @@ To build executables for ARM:\n     make HOST=arm-linux-gnueabihf NO_QT=1\n     cd ..\n     ./autogen.sh\n-    ./configure --prefix=$PWD/depends/arm-linux-gnueabihf --enable-glibc-back-compat --enable-reduce-exports LDFLAGS=-static-libstdc++\n+    CONFIG_SITE=$PWD/depends/arm-linux-gnueabihf/share/config.site ./configure --enable-glibc-back-compat --enable-reduce-exports LDFLAGS=-static-libstdc++\n     make\n \n "
      },
      {
        "sha": "de44cdd88013cd33a23c2d2be41009e5525fc624",
        "filename": "doc/external-signer.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/doc/external-signer.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/doc/external-signer.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/external-signer.md?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -46,7 +46,7 @@ Display an address on the device:\n \n ```sh\n $ bitcoin-cli -rpcwallet=<wallet> getnewaddress\n-$ bitcoin-cli -rpcwallet=<wallet> signerdisplayaddress <address>\n+$ bitcoin-cli -rpcwallet=<wallet> walletdisplayaddress <address>\n ```\n \n Replace `<address>` with the result of `getnewaddress`.\n@@ -166,6 +166,6 @@ The `createwallet` RPC calls:\n \n It then imports descriptors for all support address types, in a BIP44/49/84 compatible manner.\n \n-The `displayaddress` RPC reuses some code from `getaddressinfo` on the provided address and obtains the inferred descriptor. It then calls `<cmd> --fingerprint=00000000 displayaddress --desc=<descriptor>`.\n+The `walletdisplayaddress` RPC reuses some code from `getaddressinfo` on the provided address and obtains the inferred descriptor. It then calls `<cmd> --fingerprint=00000000 displayaddress --desc=<descriptor>`.\n \n `sendtoaddress` and `sendmany` check `inputs->bip32_derivs` to see if any inputs have the same `master_fingerprint` as the signer. If so, it calls `<cmd> --fingerprint=00000000 signtransaction <psbt>`. It waits for the device to return a (partially) signed psbt, tries to finalize it and broadcasts the transaction."
      },
      {
        "sha": "7a42fdd734f755066d8e2814ef51500a93c36d4a",
        "filename": "doc/multiprocess.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/doc/multiprocess.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/doc/multiprocess.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/multiprocess.md?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -24,7 +24,7 @@ The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [lib\n ```\n cd <BITCOIN_SOURCE_DIRECTORY>\n make -C depends NO_QT=1 MULTIPROCESS=1\n-./configure --prefix=$PWD/depends/x86_64-pc-linux-gnu\n+CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n make\n src/bitcoin-node -regtest -printtoconsole -debug=ipc\n BITCOIND=bitcoin-node test/functional/test_runner.py"
      },
      {
        "sha": "ddeccd85ea95353219349484171e21e1cc4a8f38",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -144,6 +144,7 @@ BITCOIN_CORE_H = \\\n   core_memusage.h \\\n   cuckoocache.h \\\n   dbwrapper.h \\\n+  external_signer.h \\\n   flatfile.h \\\n   fs.h \\\n   httprpc.h \\\n@@ -174,6 +175,7 @@ BITCOIN_CORE_H = \\\n   netaddress.h \\\n   netbase.h \\\n   netmessagemaker.h \\\n+  node/blockstorage.h \\\n   node/coin.h \\\n   node/coinstats.h \\\n   node/context.h \\\n@@ -267,13 +269,11 @@ BITCOIN_CORE_H = \\\n   wallet/crypter.h \\\n   wallet/db.h \\\n   wallet/dump.h \\\n-  wallet/external_signer.h \\\n   wallet/external_signer_scriptpubkeyman.h \\\n   wallet/feebumper.h \\\n   wallet/fees.h \\\n   wallet/ismine.h \\\n   wallet/load.h \\\n-  wallet/rpcsigner.h \\\n   wallet/rpcwallet.h \\\n   wallet/salvage.h \\\n   wallet/scriptpubkeyman.h \\\n@@ -324,6 +324,7 @@ libbitcoin_server_a_SOURCES = \\\n   miner.cpp \\\n   net.cpp \\\n   net_processing.cpp \\\n+  node/blockstorage.cpp \\\n   node/coin.cpp \\\n   node/coinstats.cpp \\\n   node/context.cpp \\\n@@ -387,13 +388,11 @@ libbitcoin_wallet_a_SOURCES = \\\n   wallet/db.cpp \\\n   wallet/dump.cpp \\\n   wallet/external_signer_scriptpubkeyman.cpp \\\n-  wallet/external_signer.cpp \\\n   wallet/feebumper.cpp \\\n   wallet/fees.cpp \\\n   wallet/interfaces.cpp \\\n   wallet/load.cpp \\\n   wallet/rpcdump.cpp \\\n-  wallet/rpcsigner.cpp \\\n   wallet/rpcwallet.cpp \\\n   wallet/scriptpubkeyman.cpp \\\n   wallet/wallet.cpp \\\n@@ -520,6 +519,7 @@ libbitcoin_common_a_SOURCES = \\\n   compressor.cpp \\\n   core_read.cpp \\\n   core_write.cpp \\\n+  external_signer.cpp \\\n   key.cpp \\\n   key_io.cpp \\\n   merkleblock.cpp \\\n@@ -532,6 +532,7 @@ libbitcoin_common_a_SOURCES = \\\n   protocol.cpp \\\n   psbt.cpp \\\n   rpc/rawtransaction_util.cpp \\\n+  rpc/external_signer.cpp \\\n   rpc/util.cpp \\\n   scheduler.cpp \\\n   script/descriptor.cpp \\"
      },
      {
        "sha": "39e74b9b2b2207cff814c3c98e440113f66e544f",
        "filename": "src/bench/verify_script.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/bench/verify_script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/bench/verify_script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/verify_script.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -56,7 +56,7 @@ static void VerifyScriptBench(benchmark::Bench& bench)\n             txCredit.vout[0].scriptPubKey,\n             &txSpend.vin[0].scriptWitness,\n             flags,\n-            MutableTransactionSignatureChecker(&txSpend, 0, txCredit.vout[0].nValue),\n+            MutableTransactionSignatureChecker(&txSpend, 0, txCredit.vout[0].nValue, MissingDataBehavior::ASSERT_FAIL),\n             &err);\n         assert(err == SCRIPT_ERR_OK);\n         assert(success);"
      },
      {
        "sha": "45d93ca014f5655dc6eaa4750ee9d07e72bb502c",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 17,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -78,16 +78,18 @@ class CMainParams : public CChainParams {\n         consensus.nPowTargetSpacing = 10 * 60;\n         consensus.fPowAllowMinDifficultyBlocks = false;\n         consensus.fPowNoRetargeting = false;\n-        consensus.nRuleChangeActivationThreshold = 1916; // 95% of 2016\n+        consensus.nRuleChangeActivationThreshold = 1815; // 90% of 2016\n         consensus.nMinerConfirmationWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = Consensus::BIP9Deployment::NEVER_ACTIVE;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].min_activation_height = 0; // No activation delay\n \n         // Deployment of Taproot (BIPs 340-342)\n         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nStartTime = 1199145601; // January 1, 2008\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nTimeout = 1230767999; // December 31, 2008\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nStartTime = 1619222400; // April 24th, 2021\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nTimeout = 1628640000; // August 11th, 2021\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].min_activation_height = 709632; // Approximately November 12th, 2021\n \n         consensus.nMinimumChainWork = uint256S(\"0x00000000000000000000000000000000000000001533efd8d716a517fe2c5008\");\n         consensus.defaultAssumeValid = uint256S(\"0x0000000000000000000b9d2ec5a352ecba0592946514a92f14319dc2b367fc72\"); // 654683\n@@ -198,13 +200,15 @@ class CTestNetParams : public CChainParams {\n         consensus.nRuleChangeActivationThreshold = 1512; // 75% for testchains\n         consensus.nMinerConfirmationWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = Consensus::BIP9Deployment::NEVER_ACTIVE;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].min_activation_height = 0; // No activation delay\n \n         // Deployment of Taproot (BIPs 340-342)\n         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nStartTime = 1199145601; // January 1, 2008\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nTimeout = 1230767999; // December 31, 2008\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nStartTime = 1619222400; // April 24th, 2021\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nTimeout = 1628640000; // August 11th, 2021\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].min_activation_height = 0; // No activation delay\n \n         consensus.nMinimumChainWork = uint256S(\"0x0000000000000000000000000000000000000000000001db6ec4ac88cf2272c6\");\n         consensus.defaultAssumeValid = uint256S(\"0x000000000000006433d1efec504c53ca332b64963c425395515b01977bd7b3b0\"); // 1864000\n@@ -328,18 +332,20 @@ class SigNetParams : public CChainParams {\n         consensus.nPowTargetSpacing = 10 * 60;\n         consensus.fPowAllowMinDifficultyBlocks = false;\n         consensus.fPowNoRetargeting = false;\n-        consensus.nRuleChangeActivationThreshold = 1916; // 95% of 2016\n+        consensus.nRuleChangeActivationThreshold = 1815; // 90% of 2016\n         consensus.nMinerConfirmationWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing\n         consensus.MinBIP9WarningHeight = 0;\n         consensus.powLimit = uint256S(\"00000377ae000000000000000000000000000000000000000000000000000000\");\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = Consensus::BIP9Deployment::NEVER_ACTIVE;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].min_activation_height = 0; // No activation delay\n \n         // Activation of Taproot (BIPs 340-342)\n         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;\n         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nStartTime = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].min_activation_height = 0; // No activation delay\n \n         // message start is defined as the first 4 bytes of the sha256d of the block script\n         CHashWriter h(SER_DISK, 0);\n@@ -398,12 +404,16 @@ class CRegTestParams : public CChainParams {\n         consensus.fPowNoRetargeting = true;\n         consensus.nRuleChangeActivationThreshold = 108; // 75% for testchains\n         consensus.nMinerConfirmationWindow = 144; // Faster than normal for regtest (144 instead of 2016)\n+\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 0;\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].min_activation_height = 0; // No activation delay\n+\n         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;\n         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nStartTime = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].min_activation_height = 0; // No activation delay\n \n         consensus.nMinimumChainWork = uint256{};\n         consensus.defaultAssumeValid = uint256{};\n@@ -467,10 +477,11 @@ class CRegTestParams : public CChainParams {\n     /**\n      * Allows modifying the Version Bits regtest parameters.\n      */\n-    void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n+    void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout, int min_activation_height)\n     {\n         consensus.vDeployments[d].nStartTime = nStartTime;\n         consensus.vDeployments[d].nTimeout = nTimeout;\n+        consensus.vDeployments[d].min_activation_height = min_activation_height;\n     }\n     void UpdateActivationParametersFromArgs(const ArgsManager& args);\n };\n@@ -493,22 +504,26 @@ void CRegTestParams::UpdateActivationParametersFromArgs(const ArgsManager& args)\n     for (const std::string& strDeployment : args.GetArgs(\"-vbparams\")) {\n         std::vector<std::string> vDeploymentParams;\n         boost::split(vDeploymentParams, strDeployment, boost::is_any_of(\":\"));\n-        if (vDeploymentParams.size() != 3) {\n-            throw std::runtime_error(\"Version bits parameters malformed, expecting deployment:start:end\");\n+        if (vDeploymentParams.size() < 3 || 4 < vDeploymentParams.size()) {\n+            throw std::runtime_error(\"Version bits parameters malformed, expecting deployment:start:end[:min_activation_height]\");\n         }\n         int64_t nStartTime, nTimeout;\n+        int min_activation_height = 0;\n         if (!ParseInt64(vDeploymentParams[1], &nStartTime)) {\n             throw std::runtime_error(strprintf(\"Invalid nStartTime (%s)\", vDeploymentParams[1]));\n         }\n         if (!ParseInt64(vDeploymentParams[2], &nTimeout)) {\n             throw std::runtime_error(strprintf(\"Invalid nTimeout (%s)\", vDeploymentParams[2]));\n         }\n+        if (vDeploymentParams.size() >= 4 && !ParseInt32(vDeploymentParams[3], &min_activation_height)) {\n+            throw std::runtime_error(strprintf(\"Invalid min_activation_height (%s)\", vDeploymentParams[3]));\n+        }\n         bool found = false;\n         for (int j=0; j < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j) {\n             if (vDeploymentParams[0] == VersionBitsDeploymentInfo[j].name) {\n-                UpdateVersionBitsParameters(Consensus::DeploymentPos(j), nStartTime, nTimeout);\n+                UpdateVersionBitsParameters(Consensus::DeploymentPos(j), nStartTime, nTimeout, min_activation_height);\n                 found = true;\n-                LogPrintf(\"Setting version bits activation parameters for %s to start=%ld, timeout=%ld\\n\", vDeploymentParams[0], nStartTime, nTimeout);\n+                LogPrintf(\"Setting version bits activation parameters for %s to start=%ld, timeout=%ld, min_activation_height=%d\\n\", vDeploymentParams[0], nStartTime, nTimeout, min_activation_height);\n                 break;\n             }\n         }"
      },
      {
        "sha": "e71b4bc85937511f33f7bde32a09ecb0ade339ac",
        "filename": "src/chainparamsbase.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/chainparamsbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/chainparamsbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -22,7 +22,7 @@ void SetupChainParamsBaseOptions(ArgsManager& argsman)\n                  \"This is intended for regression testing tools and app development. Equivalent to -chain=regtest.\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::CHAINPARAMS);\n     argsman.AddArg(\"-segwitheight=<n>\", \"Set the activation height of segwit. -1 to disable. (regtest-only)\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-testnet\", \"Use the test chain. Equivalent to -chain=test.\", ArgsManager::ALLOW_ANY, OptionsCategory::CHAINPARAMS);\n-    argsman.AddArg(\"-vbparams=deployment:start:end\", \"Use given start/end times for specified version bits deployment (regtest-only)\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::CHAINPARAMS);\n+    argsman.AddArg(\"-vbparams=deployment:start:end[:min_activation_height]\", \"Use given start/end times and min_activation_height for specified version bits deployment (regtest-only)\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::CHAINPARAMS);\n     argsman.AddArg(\"-signet\", \"Use the signet chain. Equivalent to -chain=signet. Note that the network is defined by the -signetchallenge parameter\", ArgsManager::ALLOW_ANY, OptionsCategory::CHAINPARAMS);\n     argsman.AddArg(\"-signetchallenge\", \"Blocks must satisfy the given script to be considered valid (only for signet networks; defaults to the global default signet test network challenge)\", ArgsManager::ALLOW_STRING, OptionsCategory::CHAINPARAMS);\n     argsman.AddArg(\"-signetseednode\", \"Specify a seed node for the signet network, in the hostname[:port] format, e.g. sig.net:1234 (may be used multiple times to specify multiple seed nodes; defaults to the global default signet test network seed node(s))\", ArgsManager::ALLOW_STRING, OptionsCategory::CHAINPARAMS);"
      },
      {
        "sha": "28c95e0884150851ce68d2ba4dece86249169cde",
        "filename": "src/consensus/params.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/consensus/params.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/consensus/params.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/params.h?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -29,6 +29,11 @@ struct BIP9Deployment {\n     int64_t nStartTime;\n     /** Timeout/expiry MedianTime for the deployment attempt. */\n     int64_t nTimeout;\n+    /** If lock in occurs, delay activation until at least this block\n+     *  height.  Note that activation will only occur on a retarget\n+     *  boundary.\n+     */\n+    int min_activation_height{0};\n \n     /** Constant for nTimeout very far in the future. */\n     static constexpr int64_t NO_TIMEOUT = std::numeric_limits<int64_t>::max();\n@@ -38,6 +43,11 @@ struct BIP9Deployment {\n      *  process (which takes at least 3 BIP9 intervals). Only tests that specifically test the\n      *  behaviour during activation cannot use this. */\n     static constexpr int64_t ALWAYS_ACTIVE = -1;\n+\n+    /** Special value for nStartTime indicating that the deployment is never active.\n+     *  This is useful for integrating the code changes for a new feature\n+     *  prior to deploying it on some or all networks. */\n+    static constexpr int64_t NEVER_ACTIVE = -2;\n };\n \n /**"
      },
      {
        "sha": "95886d31385dea876628c2b4a3ffeec88973f36a",
        "filename": "src/dummywallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/dummywallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/dummywallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dummywallet.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -50,6 +50,7 @@ void DummyWalletInit::AddWalletOptions(ArgsManager& argsman) const\n         \"-flushwallet\",\n         \"-privdb\",\n         \"-walletrejectlongchains\",\n+        \"-unsafesqlitesync\",\n     });\n }\n "
      },
      {
        "sha": "f16d21fa60cacbe52601e02ed8508c4d215f3f5b",
        "filename": "src/external_signer.cpp",
        "status": "renamed",
        "additions": 20,
        "deletions": 19,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/external_signer.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/external_signer.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/external_signer.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -7,45 +7,46 @@\n #include <psbt.h>\n #include <util/strencodings.h>\n #include <util/system.h>\n-#include <wallet/external_signer.h>\n+#include <external_signer.h>\n \n-ExternalSigner::ExternalSigner(const std::string& command, const std::string& fingerprint, std::string chain, std::string name): m_command(command), m_fingerprint(fingerprint), m_chain(chain), m_name(name) {}\n+#include <stdexcept>\n+#include <string>\n+#include <vector>\n+\n+#ifdef ENABLE_EXTERNAL_SIGNER\n+\n+ExternalSigner::ExternalSigner(const std::string& command, const std::string& fingerprint, const std::string chain, const std::string name): m_command(command), m_fingerprint(fingerprint), m_chain(chain), m_name(name) {}\n \n const std::string ExternalSigner::NetworkArg() const\n {\n     return \" --chain \" + m_chain;\n }\n \n-#ifdef ENABLE_EXTERNAL_SIGNER\n-\n-bool ExternalSigner::Enumerate(const std::string& command, std::vector<ExternalSigner>& signers, std::string chain, bool ignore_errors)\n+bool ExternalSigner::Enumerate(const std::string& command, std::vector<ExternalSigner>& signers, const std::string chain)\n {\n     // Call <command> enumerate\n     const UniValue result = RunCommandParseJSON(command + \" enumerate\");\n     if (!result.isArray()) {\n-        if (ignore_errors) return false;\n-        throw ExternalSignerException(strprintf(\"'%s' received invalid response, expected array of signers\", command));\n+        throw std::runtime_error(strprintf(\"'%s' received invalid response, expected array of signers\", command));\n     }\n     for (UniValue signer : result.getValues()) {\n         // Check for error\n         const UniValue& error = find_value(signer, \"error\");\n         if (!error.isNull()) {\n-            if (ignore_errors) return false;\n             if (!error.isStr()) {\n-                throw ExternalSignerException(strprintf(\"'%s' error\", command));\n+                throw std::runtime_error(strprintf(\"'%s' error\", command));\n             }\n-            throw ExternalSignerException(strprintf(\"'%s' error: %s\", command, error.getValStr()));\n+            throw std::runtime_error(strprintf(\"'%s' error: %s\", command, error.getValStr()));\n         }\n         // Check if fingerprint is present\n         const UniValue& fingerprint = find_value(signer, \"fingerprint\");\n         if (fingerprint.isNull()) {\n-            if (ignore_errors) return false;\n-            throw ExternalSignerException(strprintf(\"'%s' received invalid response, missing signer fingerprint\", command));\n+            throw std::runtime_error(strprintf(\"'%s' received invalid response, missing signer fingerprint\", command));\n         }\n-        std::string fingerprintStr = fingerprint.get_str();\n+        const std::string fingerprintStr = fingerprint.get_str();\n         // Skip duplicate signer\n         bool duplicate = false;\n-        for (ExternalSigner signer : signers) {\n+        for (const ExternalSigner& signer : signers) {\n             if (signer.m_fingerprint.compare(fingerprintStr) == 0) duplicate = true;\n         }\n         if (duplicate) break;\n@@ -64,7 +65,7 @@ UniValue ExternalSigner::DisplayAddress(const std::string& descriptor) const\n     return RunCommandParseJSON(m_command + \" --fingerprint \\\"\" + m_fingerprint + \"\\\"\" + NetworkArg() + \" displayaddress --desc \\\"\" + descriptor + \"\\\"\");\n }\n \n-UniValue ExternalSigner::GetDescriptors(int account)\n+UniValue ExternalSigner::GetDescriptors(const int account)\n {\n     return RunCommandParseJSON(m_command + \" --fingerprint \\\"\" + m_fingerprint + \"\\\"\" + NetworkArg() + \" getdescriptors --account \" + strprintf(\"%d\", account));\n }\n@@ -79,7 +80,7 @@ bool ExternalSigner::SignTransaction(PartiallySignedTransaction& psbtx, std::str\n     bool match = false;\n     for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n         const PSBTInput& input = psbtx.inputs[i];\n-        for (auto entry : input.hd_keypaths) {\n+        for (const auto& entry : input.hd_keypaths) {\n             if (m_fingerprint == strprintf(\"%08x\", ReadBE32(entry.second.fingerprint))) match = true;\n         }\n     }\n@@ -89,8 +90,8 @@ bool ExternalSigner::SignTransaction(PartiallySignedTransaction& psbtx, std::str\n         return false;\n     }\n \n-    std::string command = m_command + \" --stdin --fingerprint \\\"\" + m_fingerprint + \"\\\"\" + NetworkArg();\n-    std::string stdinStr = \"signtx \\\"\" + EncodeBase64(ssTx.str()) + \"\\\"\";\n+    const std::string command = m_command + \" --stdin --fingerprint \\\"\" + m_fingerprint + \"\\\"\" + NetworkArg();\n+    const std::string stdinStr = \"signtx \\\"\" + EncodeBase64(ssTx.str()) + \"\\\"\";\n \n     const UniValue signer_result = RunCommandParseJSON(command, stdinStr);\n \n@@ -116,4 +117,4 @@ bool ExternalSigner::SignTransaction(PartiallySignedTransaction& psbtx, std::str\n     return true;\n }\n \n-#endif\n+#endif // ENABLE_EXTERNAL_SIGNER",
        "previous_filename": "src/wallet/external_signer.cpp"
      },
      {
        "sha": "b3b202091a645078daa39c5d239377008a01b272",
        "filename": "src/external_signer.h",
        "status": "renamed",
        "additions": 15,
        "deletions": 18,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/external_signer.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/external_signer.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/external_signer.h?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -2,20 +2,18 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_WALLET_EXTERNAL_SIGNER_H\n-#define BITCOIN_WALLET_EXTERNAL_SIGNER_H\n+#ifndef BITCOIN_EXTERNAL_SIGNER_H\n+#define BITCOIN_EXTERNAL_SIGNER_H\n \n-#include <stdexcept>\n-#include <string>\n #include <univalue.h>\n #include <util/system.h>\n \n-struct PartiallySignedTransaction;\n+#include <string>\n+#include <vector>\n \n-class ExternalSignerException : public std::runtime_error {\n-public:\n-    using std::runtime_error::runtime_error;\n-};\n+#ifdef ENABLE_EXTERNAL_SIGNER\n+\n+struct PartiallySignedTransaction;\n \n //! Enables interaction with an external signing device or service, such as\n //! a hardware wallet. See doc/external-signer.md\n@@ -30,7 +28,7 @@ class ExternalSigner\n     //! @param[in] fingerprint  master key fingerprint of the signer\n     //! @param[in] chain        \"main\", \"test\", \"regtest\" or \"signet\"\n     //! @param[in] name         device name\n-    ExternalSigner(const std::string& command, const std::string& fingerprint, std::string chain, std::string name);\n+    ExternalSigner(const std::string& command, const std::string& fingerprint, const std::string chain, const std::string name);\n \n     //! Master key fingerprint of the signer\n     std::string m_fingerprint;\n@@ -43,13 +41,12 @@ class ExternalSigner\n \n     const std::string NetworkArg() const;\n \n-#ifdef ENABLE_EXTERNAL_SIGNER\n     //! Obtain a list of signers. Calls `<command> enumerate`.\n     //! @param[in]              command the command which handles interaction with the external signer\n     //! @param[in,out] signers  vector to which new signers (with a unique master key fingerprint) are added\n     //! @param chain            \"main\", \"test\", \"regtest\" or \"signet\"\n-    //! @param[out] success     Boolean\n-    static bool Enumerate(const std::string& command, std::vector<ExternalSigner>& signers, std::string chain, bool ignore_errors = false);\n+    //! @returns success\n+    static bool Enumerate(const std::string& command, std::vector<ExternalSigner>& signers, const std::string chain);\n \n     //! Display address on the device. Calls `<command> displayaddress --desc <descriptor>`.\n     //! @param[in] descriptor Descriptor specifying which address to display.\n@@ -59,15 +56,15 @@ class ExternalSigner\n     //! Get receive and change Descriptor(s) from device for a given account.\n     //! Calls `<command> getdescriptors --account <account>`\n     //! @param[in] account  which BIP32 account to use (e.g. `m/44'/0'/account'`)\n-    //! @param[out] UniValue see doc/external-signer.md\n-    UniValue GetDescriptors(int account);\n+    //! @returns see doc/external-signer.md\n+    UniValue GetDescriptors(const int account);\n \n     //! Sign PartiallySignedTransaction on the device.\n     //! Calls `<command> signtransaction` and passes the PSBT via stdin.\n     //! @param[in,out] psbt  PartiallySignedTransaction to be signed\n     bool SignTransaction(PartiallySignedTransaction& psbt, std::string& error);\n-\n-#endif\n };\n \n-#endif // BITCOIN_WALLET_EXTERNAL_SIGNER_H\n+#endif // ENABLE_EXTERNAL_SIGNER\n+\n+#endif // BITCOIN_EXTERNAL_SIGNER_H",
        "previous_filename": "src/wallet/external_signer.h"
      },
      {
        "sha": "2ae164633b9b912680a477c4809d45c204fc8938",
        "filename": "src/i2p.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/i2p.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/i2p.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/i2p.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -147,7 +147,9 @@ bool Session::Accept(Connection& conn)\n     try {\n         while (!*m_interrupt) {\n             Sock::Event occurred;\n-            conn.sock->Wait(MAX_WAIT_FOR_IO, Sock::RECV, &occurred);\n+            if (!conn.sock->Wait(MAX_WAIT_FOR_IO, Sock::RECV, &occurred)) {\n+                throw std::runtime_error(\"wait on socket failed\");\n+            }\n \n             if ((occurred & Sock::RECV) == 0) {\n                 // Timeout, no incoming connections within MAX_WAIT_FOR_IO."
      },
      {
        "sha": "9e637c9c6f306306566afbadb4b779dfd2e90faa",
        "filename": "src/index/base.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/index/base.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/index/base.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/base.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -4,12 +4,13 @@\n \n #include <chainparams.h>\n #include <index/base.h>\n+#include <node/blockstorage.h>\n #include <node/ui_interface.h>\n #include <shutdown.h>\n #include <tinyformat.h>\n #include <util/system.h>\n #include <util/translation.h>\n-#include <validation.h>\n+#include <validation.h> // For g_chainman\n #include <warnings.h>\n \n constexpr char DB_BEST_BLOCK = 'B';"
      },
      {
        "sha": "154d7a7027048a6a59b3967dc939001a03475f70",
        "filename": "src/index/blockfilterindex.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/index/blockfilterindex.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/index/blockfilterindex.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/blockfilterindex.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -6,8 +6,8 @@\n \n #include <dbwrapper.h>\n #include <index/blockfilterindex.h>\n+#include <node/blockstorage.h>\n #include <util/system.h>\n-#include <validation.h>\n \n /* The index database stores three items for each block: the disk location of the encoded filter,\n  * its dSHA256 hash, and the header. Those belonging to blocks on the active chain are indexed by"
      },
      {
        "sha": "07e882c9df20c3b6dc171f594293b51952be3f26",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 92,
        "changes": 95,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -16,7 +16,6 @@\n #include <chain.h>\n #include <chainparams.h>\n #include <compat/sanity.h>\n-#include <consensus/validation.h>\n #include <fs.h>\n #include <hash.h>\n #include <httprpc.h>\n@@ -32,6 +31,7 @@\n #include <net_permissions.h>\n #include <net_processing.h>\n #include <netbase.h>\n+#include <node/blockstorage.h>\n #include <node/context.h>\n #include <node/ui_interface.h>\n #include <policy/feerate.h>\n@@ -61,7 +61,6 @@\n #include <util/threadnames.h>\n #include <util/translation.h>\n #include <validation.h>\n-\n #include <validationinterface.h>\n #include <walletinitinterface.h>\n \n@@ -90,7 +89,6 @@\n \n static const bool DEFAULT_PROXYRANDOMIZE = true;\n static const bool DEFAULT_REST_ENABLE = false;\n-static const bool DEFAULT_STOPAFTERBLOCKIMPORT = false;\n \n #ifdef WIN32\n // Win32 LevelDB doesn't use filedescriptors, and the ones used for\n@@ -155,8 +153,6 @@ static fs::path GetPidFile(const ArgsManager& args)\n \n static std::unique_ptr<ECCVerifyHandle> globalVerifyHandle;\n \n-static std::thread g_load_block;\n-\n void Interrupt(NodeContext& node)\n {\n     InterruptHTTPServer();\n@@ -220,7 +216,7 @@ void Shutdown(NodeContext& node)\n     // After everything has been shut down, but before things get flushed, stop the\n     // CScheduler/checkqueue, scheduler and load block thread.\n     if (node.scheduler) node.scheduler->stop();\n-    if (g_load_block.joinable()) g_load_block.join();\n+    if (node.chainman && node.chainman->m_load_block.joinable()) node.chainman->m_load_block.join();\n     StopScriptCheckWorkerThreads();\n \n     // After the threads that potentially access these pointers have been stopped,\n@@ -627,20 +623,6 @@ static void BlockNotifyGenesisWait(const CBlockIndex* pBlockIndex)\n     }\n }\n \n-struct CImportingNow\n-{\n-    CImportingNow() {\n-        assert(fImporting == false);\n-        fImporting = true;\n-    }\n-\n-    ~CImportingNow() {\n-        assert(fImporting == true);\n-        fImporting = false;\n-    }\n-};\n-\n-\n // If we're using -prune with -reindex, then delete block files that will be ignored by the\n // reindex.  Since reindexing works by starting at block file 0 and looping until a blockfile\n // is missing, do the same here to delete any later block files after a gap.  Also delete all\n@@ -693,77 +675,6 @@ static void StartupNotify(const ArgsManager& args)\n }\n #endif\n \n-static void ThreadImport(ChainstateManager& chainman, std::vector<fs::path> vImportFiles, const ArgsManager& args)\n-{\n-    const CChainParams& chainparams = Params();\n-    ScheduleBatchPriority();\n-\n-    {\n-    CImportingNow imp;\n-\n-    // -reindex\n-    if (fReindex) {\n-        int nFile = 0;\n-        while (true) {\n-            FlatFilePos pos(nFile, 0);\n-            if (!fs::exists(GetBlockPosFilename(pos)))\n-                break; // No block files left to reindex\n-            FILE *file = OpenBlockFile(pos, true);\n-            if (!file)\n-                break; // This error is logged in OpenBlockFile\n-            LogPrintf(\"Reindexing block file blk%05u.dat...\\n\", (unsigned int)nFile);\n-            ::ChainstateActive().LoadExternalBlockFile(chainparams, file, &pos);\n-            if (ShutdownRequested()) {\n-                LogPrintf(\"Shutdown requested. Exit %s\\n\", __func__);\n-                return;\n-            }\n-            nFile++;\n-        }\n-        pblocktree->WriteReindexing(false);\n-        fReindex = false;\n-        LogPrintf(\"Reindexing finished\\n\");\n-        // To avoid ending up in a situation without genesis block, re-try initializing (no-op if reindexing worked):\n-        ::ChainstateActive().LoadGenesisBlock(chainparams);\n-    }\n-\n-    // -loadblock=\n-    for (const fs::path& path : vImportFiles) {\n-        FILE *file = fsbridge::fopen(path, \"rb\");\n-        if (file) {\n-            LogPrintf(\"Importing blocks file %s...\\n\", path.string());\n-            ::ChainstateActive().LoadExternalBlockFile(chainparams, file);\n-            if (ShutdownRequested()) {\n-                LogPrintf(\"Shutdown requested. Exit %s\\n\", __func__);\n-                return;\n-            }\n-        } else {\n-            LogPrintf(\"Warning: Could not open blocks file %s\\n\", path.string());\n-        }\n-    }\n-\n-    // scan for better chains in the block chain database, that are not yet connected in the active best chain\n-\n-    // We can't hold cs_main during ActivateBestChain even though we're accessing\n-    // the chainman unique_ptrs since ABC requires us not to be holding cs_main, so retrieve\n-    // the relevant pointers before the ABC call.\n-    for (CChainState* chainstate : WITH_LOCK(::cs_main, return chainman.GetAll())) {\n-        BlockValidationState state;\n-        if (!chainstate->ActivateBestChain(state, chainparams, nullptr)) {\n-            LogPrintf(\"Failed to connect best block (%s)\\n\", state.ToString());\n-            StartShutdown();\n-            return;\n-        }\n-    }\n-\n-    if (args.GetBoolArg(\"-stopafterblockimport\", DEFAULT_STOPAFTERBLOCKIMPORT)) {\n-        LogPrintf(\"Stopping after block import\\n\");\n-        StartShutdown();\n-        return;\n-    }\n-    } // End scope of CImportingNow\n-    chainman.ActiveChainstate().LoadMempool(args);\n-}\n-\n /** Sanity checks\n  *  Ensure that Bitcoin is running in a usable environment with all\n  *  necessary library support.\n@@ -1880,7 +1791,7 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n         vImportFiles.push_back(strFile);\n     }\n \n-    g_load_block = std::thread(&TraceThread<std::function<void()>>, \"loadblk\", [=, &chainman, &args] {\n+    chainman.m_load_block = std::thread(&TraceThread<std::function<void()>>, \"loadblk\", [=, &chainman, &args] {\n         ThreadImport(chainman, vImportFiles, args);\n     });\n "
      },
      {
        "sha": "a5bcf9eaa8fdf1fce59f9798c4be52f2f78e64d5",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -16,6 +16,7 @@\n #include <merkleblock.h>\n #include <netbase.h>\n #include <netmessagemaker.h>\n+#include <node/blockstorage.h>\n #include <policy/fees.h>\n #include <policy/policy.h>\n #include <primitives/block.h>"
      },
      {
        "sha": "ab5979594d480675f77b285c457309df7fa9219b",
        "filename": "src/node/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/node/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/node/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/README.md?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -15,8 +15,7 @@ As a rule of thumb, code in one of the [`src/node/`](./),\n calling code in the other directories directly, and only invoke it indirectly\n through the more limited [`src/interfaces/`](../interfaces/) classes.\n \n-The [`src/node/`](./) directory is a new directory introduced in\n-[#14978](https://github.com/bitcoin/bitcoin/pull/14978) and at the moment is\n+This directory is at the moment\n sparsely populated. Eventually more substantial files like\n [`src/validation.cpp`](../validation.cpp) and\n [`src/txmempool.cpp`](../txmempool.cpp) might be moved there."
      },
      {
        "sha": "daed6605e87305cb0776fa507a8454cb60677da3",
        "filename": "src/node/blockstorage.cpp",
        "status": "added",
        "additions": 244,
        "deletions": 0,
        "changes": 244,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/node/blockstorage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/node/blockstorage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -0,0 +1,244 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/blockstorage.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <fs.h>\n+#include <pow.h>\n+#include <shutdown.h>\n+#include <signet.h>\n+#include <streams.h>\n+#include <util/system.h>\n+#include <validation.h>\n+\n+// From validation. TODO move here\n+bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown = false);\n+\n+static bool WriteBlockToDisk(const CBlock& block, FlatFilePos& pos, const CMessageHeader::MessageStartChars& messageStart)\n+{\n+    // Open history file to append\n+    CAutoFile fileout(OpenBlockFile(pos), SER_DISK, CLIENT_VERSION);\n+    if (fileout.IsNull()) {\n+        return error(\"WriteBlockToDisk: OpenBlockFile failed\");\n+    }\n+\n+    // Write index header\n+    unsigned int nSize = GetSerializeSize(block, fileout.GetVersion());\n+    fileout << messageStart << nSize;\n+\n+    // Write block\n+    long fileOutPos = ftell(fileout.Get());\n+    if (fileOutPos < 0) {\n+        return error(\"WriteBlockToDisk: ftell failed\");\n+    }\n+    pos.nPos = (unsigned int)fileOutPos;\n+    fileout << block;\n+\n+    return true;\n+}\n+\n+bool ReadBlockFromDisk(CBlock& block, const FlatFilePos& pos, const Consensus::Params& consensusParams)\n+{\n+    block.SetNull();\n+\n+    // Open history file to read\n+    CAutoFile filein(OpenBlockFile(pos, true), SER_DISK, CLIENT_VERSION);\n+    if (filein.IsNull()) {\n+        return error(\"ReadBlockFromDisk: OpenBlockFile failed for %s\", pos.ToString());\n+    }\n+\n+    // Read block\n+    try {\n+        filein >> block;\n+    } catch (const std::exception& e) {\n+        return error(\"%s: Deserialize or I/O error - %s at %s\", __func__, e.what(), pos.ToString());\n+    }\n+\n+    // Check the header\n+    if (!CheckProofOfWork(block.GetHash(), block.nBits, consensusParams)) {\n+        return error(\"ReadBlockFromDisk: Errors in block header at %s\", pos.ToString());\n+    }\n+\n+    // Signet only: check block solution\n+    if (consensusParams.signet_blocks && !CheckSignetBlockSolution(block, consensusParams)) {\n+        return error(\"ReadBlockFromDisk: Errors in block solution at %s\", pos.ToString());\n+    }\n+\n+    return true;\n+}\n+\n+bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex, const Consensus::Params& consensusParams)\n+{\n+    FlatFilePos blockPos;\n+    {\n+        LOCK(cs_main);\n+        blockPos = pindex->GetBlockPos();\n+    }\n+\n+    if (!ReadBlockFromDisk(block, blockPos, consensusParams)) {\n+        return false;\n+    }\n+    if (block.GetHash() != pindex->GetBlockHash()) {\n+        return error(\"ReadBlockFromDisk(CBlock&, CBlockIndex*): GetHash() doesn't match index for %s at %s\",\n+                     pindex->ToString(), pindex->GetBlockPos().ToString());\n+    }\n+    return true;\n+}\n+\n+bool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const FlatFilePos& pos, const CMessageHeader::MessageStartChars& message_start)\n+{\n+    FlatFilePos hpos = pos;\n+    hpos.nPos -= 8; // Seek back 8 bytes for meta header\n+    CAutoFile filein(OpenBlockFile(hpos, true), SER_DISK, CLIENT_VERSION);\n+    if (filein.IsNull()) {\n+        return error(\"%s: OpenBlockFile failed for %s\", __func__, pos.ToString());\n+    }\n+\n+    try {\n+        CMessageHeader::MessageStartChars blk_start;\n+        unsigned int blk_size;\n+\n+        filein >> blk_start >> blk_size;\n+\n+        if (memcmp(blk_start, message_start, CMessageHeader::MESSAGE_START_SIZE)) {\n+            return error(\"%s: Block magic mismatch for %s: %s versus expected %s\", __func__, pos.ToString(),\n+                         HexStr(blk_start),\n+                         HexStr(message_start));\n+        }\n+\n+        if (blk_size > MAX_SIZE) {\n+            return error(\"%s: Block data is larger than maximum deserialization size for %s: %s versus %s\", __func__, pos.ToString(),\n+                         blk_size, MAX_SIZE);\n+        }\n+\n+        block.resize(blk_size); // Zeroing of memory is intentional here\n+        filein.read((char*)block.data(), blk_size);\n+    } catch (const std::exception& e) {\n+        return error(\"%s: Read from block file failed: %s for %s\", __func__, e.what(), pos.ToString());\n+    }\n+\n+    return true;\n+}\n+\n+bool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const CBlockIndex* pindex, const CMessageHeader::MessageStartChars& message_start)\n+{\n+    FlatFilePos block_pos;\n+    {\n+        LOCK(cs_main);\n+        block_pos = pindex->GetBlockPos();\n+    }\n+\n+    return ReadRawBlockFromDisk(block, block_pos, message_start);\n+}\n+\n+/** Store block on disk. If dbp is non-nullptr, the file is known to already reside on disk */\n+FlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const CChainParams& chainparams, const FlatFilePos* dbp)\n+{\n+    unsigned int nBlockSize = ::GetSerializeSize(block, CLIENT_VERSION);\n+    FlatFilePos blockPos;\n+    if (dbp != nullptr) {\n+        blockPos = *dbp;\n+    }\n+    if (!FindBlockPos(blockPos, nBlockSize + 8, nHeight, active_chain, block.GetBlockTime(), dbp != nullptr)) {\n+        error(\"%s: FindBlockPos failed\", __func__);\n+        return FlatFilePos();\n+    }\n+    if (dbp == nullptr) {\n+        if (!WriteBlockToDisk(block, blockPos, chainparams.MessageStart())) {\n+            AbortNode(\"Failed to write block\");\n+            return FlatFilePos();\n+        }\n+    }\n+    return blockPos;\n+}\n+\n+struct CImportingNow {\n+    CImportingNow()\n+    {\n+        assert(fImporting == false);\n+        fImporting = true;\n+    }\n+\n+    ~CImportingNow()\n+    {\n+        assert(fImporting == true);\n+        fImporting = false;\n+    }\n+};\n+\n+void ThreadImport(ChainstateManager& chainman, std::vector<fs::path> vImportFiles, const ArgsManager& args)\n+{\n+    const CChainParams& chainparams = Params();\n+    ScheduleBatchPriority();\n+\n+    {\n+        CImportingNow imp;\n+\n+        // -reindex\n+        if (fReindex) {\n+            int nFile = 0;\n+            while (true) {\n+                FlatFilePos pos(nFile, 0);\n+                if (!fs::exists(GetBlockPosFilename(pos))) {\n+                    break; // No block files left to reindex\n+                }\n+                FILE* file = OpenBlockFile(pos, true);\n+                if (!file) {\n+                    break; // This error is logged in OpenBlockFile\n+                }\n+                LogPrintf(\"Reindexing block file blk%05u.dat...\\n\", (unsigned int)nFile);\n+                chainman.ActiveChainstate().LoadExternalBlockFile(chainparams, file, &pos);\n+                if (ShutdownRequested()) {\n+                    LogPrintf(\"Shutdown requested. Exit %s\\n\", __func__);\n+                    return;\n+                }\n+                nFile++;\n+            }\n+            pblocktree->WriteReindexing(false);\n+            fReindex = false;\n+            LogPrintf(\"Reindexing finished\\n\");\n+            // To avoid ending up in a situation without genesis block, re-try initializing (no-op if reindexing worked):\n+            chainman.ActiveChainstate().LoadGenesisBlock(chainparams);\n+        }\n+\n+        // -loadblock=\n+        for (const fs::path& path : vImportFiles) {\n+            FILE* file = fsbridge::fopen(path, \"rb\");\n+            if (file) {\n+                LogPrintf(\"Importing blocks file %s...\\n\", path.string());\n+                chainman.ActiveChainstate().LoadExternalBlockFile(chainparams, file);\n+                if (ShutdownRequested()) {\n+                    LogPrintf(\"Shutdown requested. Exit %s\\n\", __func__);\n+                    return;\n+                }\n+            } else {\n+                LogPrintf(\"Warning: Could not open blocks file %s\\n\", path.string());\n+            }\n+        }\n+\n+        // scan for better chains in the block chain database, that are not yet connected in the active best chain\n+\n+        // We can't hold cs_main during ActivateBestChain even though we're accessing\n+        // the chainman unique_ptrs since ABC requires us not to be holding cs_main, so retrieve\n+        // the relevant pointers before the ABC call.\n+        for (CChainState* chainstate : WITH_LOCK(::cs_main, return chainman.GetAll())) {\n+            BlockValidationState state;\n+            if (!chainstate->ActivateBestChain(state, chainparams, nullptr)) {\n+                LogPrintf(\"Failed to connect best block (%s)\\n\", state.ToString());\n+                StartShutdown();\n+                return;\n+            }\n+        }\n+\n+        if (args.GetBoolArg(\"-stopafterblockimport\", DEFAULT_STOPAFTERBLOCKIMPORT)) {\n+            LogPrintf(\"Stopping after block import\\n\");\n+            StartShutdown();\n+            return;\n+        }\n+    } // End scope of CImportingNow\n+    chainman.ActiveChainstate().LoadMempool(args);\n+}"
      },
      {
        "sha": "3b546f0719296ce3a391922dcf61e8de5e22707d",
        "filename": "src/node/blockstorage.h",
        "status": "added",
        "additions": 40,
        "deletions": 0,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/node/blockstorage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/node/blockstorage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.h?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -0,0 +1,40 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_BLOCKSTORAGE_H\n+#define BITCOIN_NODE_BLOCKSTORAGE_H\n+\n+#include <cstdint>\n+#include <vector>\n+\n+#include <fs.h>\n+#include <protocol.h> // For CMessageHeader::MessageStartChars\n+\n+class ArgsManager;\n+class CBlock;\n+class CBlockIndex;\n+class CBlockUndo;\n+class CChain;\n+class CChainParams;\n+class ChainstateManager;\n+struct FlatFilePos;\n+namespace Consensus {\n+struct Params;\n+}\n+\n+static constexpr bool DEFAULT_STOPAFTERBLOCKIMPORT{false};\n+\n+/** Functions for disk access for blocks */\n+bool ReadBlockFromDisk(CBlock& block, const FlatFilePos& pos, const Consensus::Params& consensusParams);\n+bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex, const Consensus::Params& consensusParams);\n+bool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const FlatFilePos& pos, const CMessageHeader::MessageStartChars& message_start);\n+bool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const CBlockIndex* pindex, const CMessageHeader::MessageStartChars& message_start);\n+\n+bool UndoReadFromDisk(CBlockUndo& blockundo, const CBlockIndex* pindex);\n+\n+FlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const CChainParams& chainparams, const FlatFilePos* dbp);\n+\n+void ThreadImport(ChainstateManager& chainman, std::vector<fs::path> vImportFiles, const ArgsManager& args);\n+\n+#endif // BITCOIN_NODE_BLOCKSTORAGE_H"
      },
      {
        "sha": "8befbf5e3075cc7cd39a613457edbdddcd3a6402",
        "filename": "src/node/interfaces.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/node/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/node/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/interfaces.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -4,7 +4,6 @@\n \n #include <addrdb.h>\n #include <banman.h>\n-#include <boost/signals2/signal.hpp>\n #include <chain.h>\n #include <chainparams.h>\n #include <init.h>\n@@ -17,6 +16,7 @@\n #include <net_processing.h>\n #include <netaddress.h>\n #include <netbase.h>\n+#include <node/blockstorage.h>\n #include <node/coin.h>\n #include <node/context.h>\n #include <node/transaction.h>\n@@ -53,6 +53,8 @@\n #include <optional>\n #include <utility>\n \n+#include <boost/signals2/signal.hpp>\n+\n using interfaces::BlockTip;\n using interfaces::Chain;\n using interfaces::FoundBlock;"
      },
      {
        "sha": "de71b7dea7dd2d420b575280b9f7d98cbfab1db0",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 1,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -45,10 +45,12 @@\n #include <QApplication>\n #include <QDebug>\n #include <QFontDatabase>\n+#include <QLatin1String>\n #include <QLibraryInfo>\n #include <QLocale>\n #include <QMessageBox>\n #include <QSettings>\n+#include <QStringBuilder>\n #include <QThread>\n #include <QTimer>\n #include <QTranslator>\n@@ -417,10 +419,23 @@ void BitcoinApplication::shutdownResult()\n \n void BitcoinApplication::handleRunawayException(const QString &message)\n {\n-    QMessageBox::critical(nullptr, \"Runaway exception\", BitcoinGUI::tr(\"A fatal error occurred. %1 can no longer continue safely and will quit.\").arg(PACKAGE_NAME) + QString(\"<br><br>\") + message);\n+    QMessageBox::critical(\n+        nullptr, tr(\"Runaway exception\"),\n+        tr(\"A fatal error occurred. %1 can no longer continue safely and will quit.\").arg(PACKAGE_NAME) %\n+        QLatin1String(\"<br><br>\") % GUIUtil::MakeHtmlLink(message, PACKAGE_BUGREPORT));\n     ::exit(EXIT_FAILURE);\n }\n \n+void BitcoinApplication::handleNonFatalException(const QString& message)\n+{\n+    assert(QThread::currentThread() == thread());\n+    QMessageBox::warning(\n+        nullptr, tr(\"Internal error\"),\n+        tr(\"An internal error occurred. %1 will attempt to continue safely. This is \"\n+           \"an unexpected bug which can be reported as described below.\").arg(PACKAGE_NAME) %\n+        QLatin1String(\"<br><br>\") % GUIUtil::MakeHtmlLink(message, PACKAGE_BUGREPORT));\n+}\n+\n WId BitcoinApplication::getMainWinId() const\n {\n     if (!window)"
      },
      {
        "sha": "5fd6bd607f29ca1987ba8511d36bfedd6dd8d902",
        "filename": "src/qt/bitcoin.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.h?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -99,6 +99,12 @@ public Q_SLOTS:\n     /// Handle runaway exceptions. Shows a message box with the problem and quits the program.\n     void handleRunawayException(const QString &message);\n \n+    /**\n+     * A helper function that shows a message box\n+     * with details about a non-fatal exception.\n+     */\n+    void handleNonFatalException(const QString& message);\n+\n Q_SIGNALS:\n     void requestedInitialize();\n     void requestedShutdown();"
      },
      {
        "sha": "3abca7dcff2b7ee987b1fa4736b6b2c501e6828b",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -654,7 +654,7 @@ void BitcoinGUI::setWalletController(WalletController* wallet_controller)\n     m_open_wallet_action->setEnabled(true);\n     m_open_wallet_action->setMenu(m_open_wallet_menu);\n \n-    connect(wallet_controller, &WalletController::walletAdded, this, &BitcoinGUI::addWallet);\n+    GUIUtil::ExceptionSafeConnect(wallet_controller, &WalletController::walletAdded, this, &BitcoinGUI::addWallet);\n     connect(wallet_controller, &WalletController::walletRemoved, this, &BitcoinGUI::removeWallet);\n \n     for (WalletModel* wallet_model : m_wallet_controller->getOpenWallets()) {"
      },
      {
        "sha": "0e91f9f3856bddc268966554217376ff36395612",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -42,6 +42,7 @@\n #include <QGuiApplication>\n #include <QJsonObject>\n #include <QKeyEvent>\n+#include <QLatin1String>\n #include <QLineEdit>\n #include <QList>\n #include <QLocale>\n@@ -54,6 +55,7 @@\n #include <QShortcut>\n #include <QSize>\n #include <QString>\n+#include <QStringBuilder>\n #include <QTextDocument> // for Qt::mightBeRichText\n #include <QThread>\n #include <QUrlQuery>\n@@ -893,4 +895,22 @@ QImage GetImage(const QLabel* label)\n #endif\n }\n \n+QString MakeHtmlLink(const QString& source, const QString& link)\n+{\n+    return QString(source).replace(\n+        link,\n+        QLatin1String(\"<a href=\\\"\") % link % QLatin1String(\"\\\">\") % link % QLatin1String(\"</a>\"));\n+}\n+\n+void PrintSlotException(\n+    const std::exception* exception,\n+    const QObject* sender,\n+    const QObject* receiver)\n+{\n+    std::string description = sender->metaObject()->className();\n+    description += \"->\";\n+    description += receiver->metaObject()->className();\n+    PrintExceptionContinue(exception, description.c_str());\n+}\n+\n } // namespace GUIUtil"
      },
      {
        "sha": "a1cf27435493d0856b1238a1fe5ffe5299c33be5",
        "filename": "src/qt/guiutil.h",
        "status": "modified",
        "additions": 57,
        "deletions": 0,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/guiutil.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/guiutil.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.h?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -9,18 +9,23 @@\n #include <fs.h>\n #include <net.h>\n #include <netaddress.h>\n+#include <util/check.h>\n \n+#include <QApplication>\n #include <QEvent>\n #include <QHeaderView>\n #include <QItemDelegate>\n #include <QLabel>\n #include <QMessageBox>\n+#include <QMetaObject>\n #include <QObject>\n #include <QProgressBar>\n #include <QString>\n #include <QTableView>\n \n+#include <cassert>\n #include <chrono>\n+#include <utility>\n \n class QValidatedLineEdit;\n class SendCoinsRecipient;\n@@ -327,6 +332,58 @@ namespace GUIUtil\n         QObject::connect(&source, &QObject::destroyed, object, std::forward<Fn>(function), connection);\n     }\n \n+    /**\n+     * Replaces a plain text link with an HTML tagged one.\n+     */\n+    QString MakeHtmlLink(const QString& source, const QString& link);\n+\n+    void PrintSlotException(\n+        const std::exception* exception,\n+        const QObject* sender,\n+        const QObject* receiver);\n+\n+    /**\n+     * A drop-in replacement of QObject::connect function\n+     * (see: https://doc.qt.io/qt-5/qobject.html#connect-3), that\n+     * guaranties that all exceptions are handled within the slot.\n+     *\n+     * NOTE: This function is incompatible with Qt private signals.\n+     */\n+    template <typename Sender, typename Signal, typename Receiver, typename Slot>\n+    auto ExceptionSafeConnect(\n+        Sender sender, Signal signal, Receiver receiver, Slot method,\n+        Qt::ConnectionType type = Qt::AutoConnection)\n+    {\n+        return QObject::connect(\n+            sender, signal, receiver,\n+            [sender, receiver, method](auto&&... args) {\n+                bool ok{true};\n+                try {\n+                    (receiver->*method)(std::forward<decltype(args)>(args)...);\n+                } catch (const NonFatalCheckError& e) {\n+                    PrintSlotException(&e, sender, receiver);\n+                    ok = QMetaObject::invokeMethod(\n+                        qApp, \"handleNonFatalException\",\n+                        blockingGUIThreadConnection(),\n+                        Q_ARG(QString, QString::fromStdString(e.what())));\n+                } catch (const std::exception& e) {\n+                    PrintSlotException(&e, sender, receiver);\n+                    ok = QMetaObject::invokeMethod(\n+                        qApp, \"handleRunawayException\",\n+                        blockingGUIThreadConnection(),\n+                        Q_ARG(QString, QString::fromStdString(e.what())));\n+                } catch (...) {\n+                    PrintSlotException(nullptr, sender, receiver);\n+                    ok = QMetaObject::invokeMethod(\n+                        qApp, \"handleRunawayException\",\n+                        blockingGUIThreadConnection(),\n+                        Q_ARG(QString, \"Unknown failure occurred.\"));\n+                }\n+                assert(ok);\n+            },\n+            type);\n+    }\n+\n } // namespace GUIUtil\n \n #endif // BITCOIN_QT_GUIUTIL_H"
      },
      {
        "sha": "f0e720617cf5b5dbde53a5f91e28569a43291fa3",
        "filename": "src/qt/sendcoinsdialog.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/sendcoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/sendcoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -129,6 +129,8 @@ SendCoinsDialog::SendCoinsDialog(const PlatformStyle *_platformStyle, QWidget *p\n     ui->customFee->SetAllowEmpty(false);\n     ui->customFee->setValue(settings.value(\"nTransactionFee\").toLongLong());\n     minimizeFeeSection(settings.value(\"fFeeSectionMinimized\").toBool());\n+\n+    GUIUtil::ExceptionSafeConnect(ui->sendButton, &QPushButton::clicked, this, &SendCoinsDialog::sendButtonClicked);\n }\n \n void SendCoinsDialog::setClientModel(ClientModel *_clientModel)\n@@ -375,7 +377,7 @@ bool SendCoinsDialog::PrepareSendText(QString& question_string, QString& informa\n     return true;\n }\n \n-void SendCoinsDialog::on_sendButton_clicked()\n+void SendCoinsDialog::sendButtonClicked([[maybe_unused]] bool checked)\n {\n     if(!model || !model->getOptionsModel())\n         return;"
      },
      {
        "sha": "3e276201bab43a067851983fa3bba5fcf0289d0a",
        "filename": "src/qt/sendcoinsdialog.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/sendcoinsdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/sendcoinsdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.h?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -80,7 +80,7 @@ public Q_SLOTS:\n     void updateCoinControlState(CCoinControl& ctrl);\n \n private Q_SLOTS:\n-    void on_sendButton_clicked();\n+    void sendButtonClicked(bool checked);\n     void on_buttonChooseFee_clicked();\n     void on_buttonMinimizeFee_clicked();\n     void removeEntry(SendCoinsEntry* entry);"
      },
      {
        "sha": "03460cd6eba3b7760da965831d3ee439d7a17d1a",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -73,7 +73,7 @@ uint256 SendCoins(CWallet& wallet, SendCoinsDialog& sendCoinsDialog, const CTxDe\n         if (status == CT_NEW) txid = hash;\n     }));\n     ConfirmSend();\n-    bool invoked = QMetaObject::invokeMethod(&sendCoinsDialog, \"on_sendButton_clicked\");\n+    bool invoked = QMetaObject::invokeMethod(&sendCoinsDialog, \"sendButtonClicked\", Q_ARG(bool, false));\n     assert(invoked);\n     return txid;\n }"
      },
      {
        "sha": "15114101298b4b0f7f42de6a37b58b871c963503",
        "filename": "src/qt/transactionview.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/transactionview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/transactionview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -199,7 +199,7 @@ TransactionView::TransactionView(const PlatformStyle *platformStyle, QWidget *pa\n     connect(transactionView, &QTableView::doubleClicked, this, &TransactionView::doubleClicked);\n     connect(transactionView, &QTableView::customContextMenuRequested, this, &TransactionView::contextualMenu);\n \n-    connect(bumpFeeAction, &QAction::triggered, this, &TransactionView::bumpFee);\n+    GUIUtil::ExceptionSafeConnect(bumpFeeAction, &QAction::triggered, this, &TransactionView::bumpFee);\n     connect(abandonAction, &QAction::triggered, this, &TransactionView::abandonTx);\n     connect(copyAddressAction, &QAction::triggered, this, &TransactionView::copyAddress);\n     connect(copyLabelAction, &QAction::triggered, this, &TransactionView::copyLabel);\n@@ -424,7 +424,7 @@ void TransactionView::abandonTx()\n     model->getTransactionTableModel()->updateTransaction(hashQStr, CT_UPDATED, false);\n }\n \n-void TransactionView::bumpFee()\n+void TransactionView::bumpFee([[maybe_unused]] bool checked)\n {\n     if(!transactionView || !transactionView->selectionModel())\n         return;"
      },
      {
        "sha": "66350bdc02ecf7d11bc405e82cac79e22d36e276",
        "filename": "src/qt/transactionview.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/transactionview.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/transactionview.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.h?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -99,7 +99,7 @@ private Q_SLOTS:\n     void openThirdPartyTxUrl(QString url);\n     void updateWatchOnlyColumn(bool fHaveWatchOnly);\n     void abandonTx();\n-    void bumpFee();\n+    void bumpFee(bool checked);\n \n Q_SIGNALS:\n     void doubleClicked(const QModelIndex&);"
      },
      {
        "sha": "c6dd0c2ad6ac9d8c0ccedcd2ea4cb208a65597bd",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -65,7 +65,10 @@ WalletModel::~WalletModel()\n void WalletModel::startPollBalance()\n {\n     // This timer will be fired repeatedly to update the balance\n-    connect(timer, &QTimer::timeout, this, &WalletModel::pollBalanceChanged);\n+    // Since the QTimer::timeout is a private signal, it cannot be used\n+    // in the GUIUtil::ExceptionSafeConnect directly.\n+    connect(timer, &QTimer::timeout, this, &WalletModel::timerTimeout);\n+    GUIUtil::ExceptionSafeConnect(this, &WalletModel::timerTimeout, this, &WalletModel::pollBalanceChanged);\n     timer->start(MODEL_UPDATE_DELAY);\n }\n "
      },
      {
        "sha": "4ca8643444ddac65adeadca7c3462ed9c6f3ce36",
        "filename": "src/qt/walletmodel.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/walletmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/qt/walletmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.h?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -223,6 +223,8 @@ class WalletModel : public QObject\n     // Notify that there are now keys in the keypool\n     void canGetAddressesChanged();\n \n+    void timerTimeout();\n+\n public Q_SLOTS:\n     /* Starts a timer to periodically update the balance */\n     void startPollBalance();"
      },
      {
        "sha": "9d4ac55bbe718c8568aa7bf7e67a18b5c8d2ee3c",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -8,6 +8,7 @@\n #include <core_io.h>\n #include <httpserver.h>\n #include <index/txindex.h>\n+#include <node/blockstorage.h>\n #include <node/context.h>\n #include <primitives/block.h>\n #include <primitives/transaction.h>"
      },
      {
        "sha": "f27e9af0d996475bca890f6663d3a7b72080f003",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -14,6 +14,7 @@\n #include <core_io.h>\n #include <hash.h>\n #include <index/blockfilterindex.h>\n+#include <node/blockstorage.h>\n #include <node/coinstats.h>\n #include <node/context.h>\n #include <node/utxo_snapshot.h>\n@@ -1227,10 +1228,8 @@ static void BuriedForkDescPushBack(UniValue& softforks, const std::string &name,\n static void BIP9SoftForkDescPushBack(UniValue& softforks, const std::string &name, const Consensus::Params& consensusParams, Consensus::DeploymentPos id) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     // For BIP9 deployments.\n-    // Deployments (e.g. testdummy) with timeout value before Jan 1, 2009 are hidden.\n-    // A timeout value of 0 guarantees a softfork will never be activated.\n-    // This is used when merging logic to implement a proposed softfork without a specified deployment schedule.\n-    if (consensusParams.vDeployments[id].nTimeout <= 1230768000) return;\n+    // Deployments that are never active are hidden.\n+    if (consensusParams.vDeployments[id].nStartTime == Consensus::BIP9Deployment::NEVER_ACTIVE) return;\n \n     UniValue bip9(UniValue::VOBJ);\n     const ThresholdState thresholdState = VersionBitsState(::ChainActive().Tip(), consensusParams, id, versionbitscache);\n@@ -1260,6 +1259,7 @@ static void BIP9SoftForkDescPushBack(UniValue& softforks, const std::string &nam\n         statsUV.pushKV(\"possible\", statsStruct.possible);\n         bip9.pushKV(\"statistics\", statsUV);\n     }\n+    bip9.pushKV(\"min_activation_height\", consensusParams.vDeployments[id].min_activation_height);\n \n     UniValue rv(UniValue::VOBJ);\n     rv.pushKV(\"type\", \"bip9\");\n@@ -1306,6 +1306,7 @@ RPCHelpMan getblockchaininfo()\n                                     {RPCResult::Type::NUM_TIME, \"start_time\", \"the minimum median time past of a block at which the bit gains its meaning\"},\n                                     {RPCResult::Type::NUM_TIME, \"timeout\", \"the median time past of a block at which the deployment is considered failed if not yet locked in\"},\n                                     {RPCResult::Type::NUM, \"since\", \"height of the first block to which the status applies\"},\n+                                    {RPCResult::Type::NUM, \"min_activation_height\", \"minimum height of blocks for which the rules may be enforced\"},\n                                     {RPCResult::Type::OBJ, \"statistics\", \"numeric statistics about BIP9 signalling for a softfork (only for \\\"started\\\" status)\",\n                                     {\n                                         {RPCResult::Type::NUM, \"period\", \"the length in blocks of the BIP9 signalling period\"},"
      },
      {
        "sha": "6ec2b1a07f8f2c3da6a720000673e14b7a705ec7",
        "filename": "src/rpc/external_signer.cpp",
        "status": "added",
        "additions": 76,
        "deletions": 0,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/rpc/external_signer.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/rpc/external_signer.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/external_signer.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -0,0 +1,76 @@\n+// Copyright (c) 2018-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparamsbase.h>\n+#include <external_signer.h>\n+#include <rpc/server.h>\n+#include <rpc/util.h>\n+#include <util/strencodings.h>\n+#include <rpc/protocol.h>\n+\n+#include <string>\n+#include <vector>\n+\n+#ifdef ENABLE_EXTERNAL_SIGNER\n+\n+static RPCHelpMan enumeratesigners()\n+{\n+    return RPCHelpMan{\"enumeratesigners\",\n+        \"Returns a list of external signers from -signer.\",\n+        {},\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+            {\n+                {RPCResult::Type::ARR, \"signers\", /* optional */ false, \"\",\n+                {\n+                    {RPCResult::Type::STR_HEX, \"masterkeyfingerprint\", \"Master key fingerprint\"},\n+                    {RPCResult::Type::STR, \"name\", \"Device name\"},\n+                },\n+                }\n+            }\n+        },\n+        RPCExamples{\n+            HelpExampleCli(\"enumeratesigners\", \"\")\n+            + HelpExampleRpc(\"enumeratesigners\", \"\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            const std::string command = gArgs.GetArg(\"-signer\", \"\");\n+            if (command == \"\") throw JSONRPCError(RPC_MISC_ERROR, \"Error: restart bitcoind with -signer=<cmd>\");\n+            const std::string chain = gArgs.GetChainName();\n+            UniValue signers_res = UniValue::VARR;\n+            try {\n+                std::vector<ExternalSigner> signers;\n+                ExternalSigner::Enumerate(command, signers, chain);\n+                for (const ExternalSigner& signer : signers) {\n+                    UniValue signer_res = UniValue::VOBJ;\n+                    signer_res.pushKV(\"fingerprint\", signer.m_fingerprint);\n+                    signer_res.pushKV(\"name\", signer.m_name);\n+                    signers_res.push_back(signer_res);\n+                }\n+            } catch (const std::exception& e) {\n+                throw JSONRPCError(RPC_MISC_ERROR, e.what());\n+            }\n+            UniValue result(UniValue::VOBJ);\n+            result.pushKV(\"signers\", signers_res);\n+            return result;\n+        }\n+    };\n+}\n+\n+void RegisterSignerRPCCommands(CRPCTable &t)\n+{\n+// clang-format off\n+static const CRPCCommand commands[] =\n+{ // category              actor (function)\n+  // --------------------- ------------------------\n+  { \"signer\",              &enumeratesigners,      },\n+};\n+// clang-format on\n+    for (const auto& c : commands) {\n+        t.appendCommand(c.name, &c);\n+    }\n+}\n+\n+#endif // ENABLE_EXTERNAL_SIGNER"
      },
      {
        "sha": "527e9be87c1ea642513223d02001e6d721fff6fe",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -10,6 +10,7 @@\n #include <index/txindex.h>\n #include <key_io.h>\n #include <merkleblock.h>\n+#include <node/blockstorage.h>\n #include <node/coin.h>\n #include <node/context.h>\n #include <node/psbt.h>"
      },
      {
        "sha": "6724203ffe75074432d536ccea26f5d70f6e149a",
        "filename": "src/rpc/register.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/rpc/register.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/rpc/register.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/register.h?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -19,6 +19,8 @@ void RegisterMiscRPCCommands(CRPCTable &tableRPC);\n void RegisterMiningRPCCommands(CRPCTable &tableRPC);\n /** Register raw transaction RPC commands */\n void RegisterRawTransactionRPCCommands(CRPCTable &tableRPC);\n+/** Register raw transaction RPC commands */\n+void RegisterSignerRPCCommands(CRPCTable &tableRPC);\n \n static inline void RegisterAllCoreRPCCommands(CRPCTable &t)\n {\n@@ -27,6 +29,9 @@ static inline void RegisterAllCoreRPCCommands(CRPCTable &t)\n     RegisterMiscRPCCommands(t);\n     RegisterMiningRPCCommands(t);\n     RegisterRawTransactionRPCCommands(t);\n+#ifdef ENABLE_EXTERNAL_SIGNER\n+    RegisterSignerRPCCommands(t);\n+#endif // ENABLE_EXTERNAL_SIGNER\n }\n \n #endif // BITCOIN_RPC_REGISTER_H"
      },
      {
        "sha": "a9aa6a0060f94692da082dd64a66025be200c4c7",
        "filename": "src/script/bitcoinconsensus.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/script/bitcoinconsensus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/script/bitcoinconsensus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinconsensus.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -92,7 +92,7 @@ static int verify_script(const unsigned char *scriptPubKey, unsigned int scriptP\n         set_error(err, bitcoinconsensus_ERR_OK);\n \n         PrecomputedTransactionData txdata(tx);\n-        return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), &tx.vin[nIn].scriptWitness, flags, TransactionSignatureChecker(&tx, nIn, amount, txdata), nullptr);\n+        return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), &tx.vin[nIn].scriptWitness, flags, TransactionSignatureChecker(&tx, nIn, amount, txdata, MissingDataBehavior::FAIL), nullptr);\n     } catch (const std::exception&) {\n         return set_error(err, bitcoinconsensus_ERR_TX_DESERIALIZE); // Error deserializing\n     }"
      },
      {
        "sha": "abc0625bb1cd424edfcfd5e9e43e4159d986a818",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 3,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -1488,8 +1488,20 @@ static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n \n+static bool HandleMissingData(MissingDataBehavior mdb)\n+{\n+    switch (mdb) {\n+    case MissingDataBehavior::ASSERT_FAIL:\n+        assert(!\"Missing data\");\n+        break;\n+    case MissingDataBehavior::FAIL:\n+        return false;\n+    }\n+    assert(!\"Unknown MissingDataBehavior value\");\n+}\n+\n template<typename T>\n-bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, uint32_t in_pos, uint8_t hash_type, SigVersion sigversion, const PrecomputedTransactionData& cache)\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, uint32_t in_pos, uint8_t hash_type, SigVersion sigversion, const PrecomputedTransactionData& cache, MissingDataBehavior mdb)\n {\n     uint8_t ext_flag, key_version;\n     switch (sigversion) {\n@@ -1509,7 +1521,9 @@ bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata\n         assert(false);\n     }\n     assert(in_pos < tx_to.vin.size());\n-    assert(cache.m_bip341_taproot_ready && cache.m_spent_outputs_ready);\n+    if (!(cache.m_bip341_taproot_ready && cache.m_spent_outputs_ready)) {\n+        return HandleMissingData(mdb);\n+    }\n \n     CHashWriter ss = HASHER_TAPSIGHASH;\n \n@@ -1667,6 +1681,9 @@ bool GenericTransactionSignatureChecker<T>::CheckECDSASignature(const std::vecto\n     int nHashType = vchSig.back();\n     vchSig.pop_back();\n \n+    // Witness sighashes need the amount.\n+    if (sigversion == SigVersion::WITNESS_V0 && amount < 0) return HandleMissingData(m_mdb);\n+\n     uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);\n \n     if (!VerifyECDSASignature(vchSig, pubkey, sighash))\n@@ -1696,7 +1713,7 @@ bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(Span<const uns\n     }\n     uint256 sighash;\n     assert(this->txdata);\n-    if (!SignatureHashSchnorr(sighash, execdata, *txTo, nIn, hashtype, sigversion, *this->txdata)) {\n+    if (!SignatureHashSchnorr(sighash, execdata, *txTo, nIn, hashtype, sigversion, *this->txdata, m_mdb)) {\n         return set_error(serror, SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n     }\n     if (!VerifySchnorrSignature(sig, pubkey, sighash)) return set_error(serror, SCRIPT_ERR_SCHNORR_SIG);"
      },
      {
        "sha": "c76b3acb2259ce959302f0a5fdf0a09b80242f71",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 12,
        "deletions": 2,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -247,11 +247,21 @@ class BaseSignatureChecker\n     virtual ~BaseSignatureChecker() {}\n };\n \n+/** Enum to specify what *TransactionSignatureChecker's behavior should be\n+ *  when dealing with missing transaction data.\n+ */\n+enum class MissingDataBehavior\n+{\n+    ASSERT_FAIL,  //!< Abort execution through assertion failure (for consensus code)\n+    FAIL,         //!< Just act as if the signature was invalid\n+};\n+\n template <class T>\n class GenericTransactionSignatureChecker : public BaseSignatureChecker\n {\n private:\n     const T* txTo;\n+    const MissingDataBehavior m_mdb;\n     unsigned int nIn;\n     const CAmount amount;\n     const PrecomputedTransactionData* txdata;\n@@ -261,8 +271,8 @@ class GenericTransactionSignatureChecker : public BaseSignatureChecker\n     virtual bool VerifySchnorrSignature(Span<const unsigned char> sig, const XOnlyPubKey& pubkey, const uint256& sighash) const;\n \n public:\n-    GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(nullptr) {}\n-    GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn, const PrecomputedTransactionData& txdataIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(&txdataIn) {}\n+    GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn, MissingDataBehavior mdb) : txTo(txToIn), m_mdb(mdb), nIn(nInIn), amount(amountIn), txdata(nullptr) {}\n+    GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn, const PrecomputedTransactionData& txdataIn, MissingDataBehavior mdb) : txTo(txToIn), m_mdb(mdb), nIn(nInIn), amount(amountIn), txdata(&txdataIn) {}\n     bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;\n     bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion, const ScriptExecutionData& execdata, ScriptError* serror = nullptr) const override;\n     bool CheckLockTime(const CScriptNum& nLockTime) const override;"
      },
      {
        "sha": "7b6b91c963be966fabf5ba789ddb399fa5860e2c",
        "filename": "src/script/sigcache.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/script/sigcache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/script/sigcache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.h?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -27,7 +27,7 @@ class CachingTransactionSignatureChecker : public TransactionSignatureChecker\n     bool store;\n \n public:\n-    CachingTransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, bool storeIn, PrecomputedTransactionData& txdataIn) : TransactionSignatureChecker(txToIn, nInIn, amountIn, txdataIn), store(storeIn) {}\n+    CachingTransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, bool storeIn, PrecomputedTransactionData& txdataIn) : TransactionSignatureChecker(txToIn, nInIn, amountIn, txdataIn, MissingDataBehavior::ASSERT_FAIL), store(storeIn) {}\n \n     bool VerifyECDSASignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const override;\n     bool VerifySchnorrSignature(Span<const unsigned char> sig, const XOnlyPubKey& pubkey, const uint256& sighash) const override;"
      },
      {
        "sha": "4d9026427e30f7a56264df03a3d3978ba564db6c",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -14,7 +14,7 @@\n \n typedef std::vector<unsigned char> valtype;\n \n-MutableTransactionSignatureCreator::MutableTransactionSignatureCreator(const CMutableTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : txTo(txToIn), nIn(nInIn), nHashType(nHashTypeIn), amount(amountIn), checker(txTo, nIn, amountIn) {}\n+MutableTransactionSignatureCreator::MutableTransactionSignatureCreator(const CMutableTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : txTo(txToIn), nIn(nInIn), nHashType(nHashTypeIn), amount(amountIn), checker(txTo, nIn, amountIn, MissingDataBehavior::FAIL) {}\n \n bool MutableTransactionSignatureCreator::CreateSig(const SigningProvider& provider, std::vector<unsigned char>& vchSig, const CKeyID& address, const CScript& scriptCode, SigVersion sigversion) const\n {\n@@ -26,6 +26,9 @@ bool MutableTransactionSignatureCreator::CreateSig(const SigningProvider& provid\n     if (sigversion == SigVersion::WITNESS_V0 && !key.IsCompressed())\n         return false;\n \n+    // Signing for witness scripts needs the amount.\n+    if (sigversion == SigVersion::WITNESS_V0 && amount < 0) return false;\n+\n     uint256 hash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion);\n     if (!key.Sign(hash, vchSig))\n         return false;\n@@ -292,7 +295,7 @@ SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nI\n     Stacks stack(data);\n \n     // Get signatures\n-    MutableTransactionSignatureChecker tx_checker(&tx, nIn, txout.nValue);\n+    MutableTransactionSignatureChecker tx_checker(&tx, nIn, txout.nValue, MissingDataBehavior::FAIL);\n     SignatureExtractorChecker extractor_checker(data, tx_checker);\n     if (VerifyScript(data.scriptSig, txout.scriptPubKey, &data.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, extractor_checker)) {\n         data.complete = true;\n@@ -499,7 +502,7 @@ bool SignTransaction(CMutableTransaction& mtx, const SigningProvider* keystore,\n         }\n \n         ScriptError serror = SCRIPT_ERR_OK;\n-        if (!VerifyScript(txin.scriptSig, prevPubKey, &txin.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, TransactionSignatureChecker(&txConst, i, amount), &serror)) {\n+        if (!VerifyScript(txin.scriptSig, prevPubKey, &txin.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, TransactionSignatureChecker(&txConst, i, amount, MissingDataBehavior::FAIL), &serror)) {\n             if (serror == SCRIPT_ERR_INVALID_STACK_OPERATION) {\n                 // Unable to sign input and verification failed (possible attempt to partially sign).\n                 input_errors[i] = \"Unable to sign input, invalid stack size (possibly missing key)\";"
      },
      {
        "sha": "35faf3c41294bd5dd93495060ce4193eb735a5bf",
        "filename": "src/shutdown.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/shutdown.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/shutdown.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/shutdown.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -6,7 +6,9 @@\n #include <shutdown.h>\n \n #include <logging.h>\n+#include <node/ui_interface.h>\n #include <util/tokenpipe.h>\n+#include <warnings.h>\n \n #include <config/bitcoin-config.h>\n \n@@ -16,6 +18,18 @@\n #include <condition_variable>\n #endif\n \n+bool AbortNode(const std::string& strMessage, bilingual_str user_message)\n+{\n+    SetMiscWarning(Untranslated(strMessage));\n+    LogPrintf(\"*** %s\\n\", strMessage);\n+    if (user_message.empty()) {\n+        user_message = _(\"A fatal internal error occurred, see debug.log for details\");\n+    }\n+    AbortError(user_message);\n+    StartShutdown();\n+    return false;\n+}\n+\n static std::atomic<bool> fRequestShutdown(false);\n #ifdef WIN32\n /** On windows it is possible to simply use a condition variable. */"
      },
      {
        "sha": "ff56c6bd87230e6d9fcde51ed1f054d0a032f6b1",
        "filename": "src/shutdown.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/shutdown.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/shutdown.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/shutdown.h?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -6,6 +6,11 @@\n #ifndef BITCOIN_SHUTDOWN_H\n #define BITCOIN_SHUTDOWN_H\n \n+#include <util/translation.h> // For bilingual_str\n+\n+/** Abort with a message */\n+bool AbortNode(const std::string& strMessage, bilingual_str user_message = bilingual_str{});\n+\n /** Initialize shutdown state. This must be called before using either StartShutdown(),\n  * AbortShutdown() or WaitForShutdown(). Calling ShutdownRequested() is always safe.\n  */"
      },
      {
        "sha": "1ba8502287596470101910d014e75dd3eadaa0c7",
        "filename": "src/signet.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/signet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/signet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/signet.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -139,7 +139,9 @@ bool CheckSignetBlockSolution(const CBlock& block, const Consensus::Params& cons\n     const CScript& scriptSig = signet_txs->m_to_sign.vin[0].scriptSig;\n     const CScriptWitness& witness = signet_txs->m_to_sign.vin[0].scriptWitness;\n \n-    TransactionSignatureChecker sigcheck(&signet_txs->m_to_sign, /*nIn=*/ 0, /*amount=*/ signet_txs->m_to_spend.vout[0].nValue);\n+    PrecomputedTransactionData txdata;\n+    txdata.Init(signet_txs->m_to_sign, {signet_txs->m_to_spend.vout[0]});\n+    TransactionSignatureChecker sigcheck(&signet_txs->m_to_sign, /*nIn=*/ 0, /*amount=*/ signet_txs->m_to_spend.vout[0].nValue, txdata, MissingDataBehavior::ASSERT_FAIL);\n \n     if (!VerifyScript(scriptSig, signet_txs->m_to_spend.vout[0].scriptPubKey, &witness, BLOCK_SCRIPT_VERIFY_FLAGS, sigcheck)) {\n         LogPrint(BCLog::VALIDATION, \"CheckSignetBlockSolution: Errors in block (block solution invalid)\\n\");"
      },
      {
        "sha": "599e62868560e6a321537d08a14a886a9703725a",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -116,7 +116,6 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode1)); // should result in disconnect\n     }\n     BOOST_CHECK(dummyNode1.fDisconnect == true);\n-    SetMockTime(0);\n \n     peerLogic->FinalizeNode(dummyNode1);\n }"
      },
      {
        "sha": "cec5212f421008cee3dd43947395156c092ad60a",
        "filename": "src/test/fuzz/script_assets_test_minimizer.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/fuzz/script_assets_test_minimizer.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/fuzz/script_assets_test_minimizer.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/script_assets_test_minimizer.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -161,7 +161,7 @@ void Test(const std::string& str)\n         tx.vin[idx].scriptWitness = ScriptWitnessFromJSON(test[\"success\"][\"witness\"]);\n         PrecomputedTransactionData txdata;\n         txdata.Init(tx, std::vector<CTxOut>(prevouts));\n-        MutableTransactionSignatureChecker txcheck(&tx, idx, prevouts[idx].nValue, txdata);\n+        MutableTransactionSignatureChecker txcheck(&tx, idx, prevouts[idx].nValue, txdata, MissingDataBehavior::ASSERT_FAIL);\n         for (const auto flags : ALL_FLAGS) {\n             // \"final\": true tests are valid for all flags. Others are only valid with flags that are\n             // a subset of test_flags.\n@@ -176,7 +176,7 @@ void Test(const std::string& str)\n         tx.vin[idx].scriptWitness = ScriptWitnessFromJSON(test[\"failure\"][\"witness\"]);\n         PrecomputedTransactionData txdata;\n         txdata.Init(tx, std::vector<CTxOut>(prevouts));\n-        MutableTransactionSignatureChecker txcheck(&tx, idx, prevouts[idx].nValue, txdata);\n+        MutableTransactionSignatureChecker txcheck(&tx, idx, prevouts[idx].nValue, txdata, MissingDataBehavior::ASSERT_FAIL);\n         for (const auto flags : ALL_FLAGS) {\n             // If a test is supposed to fail with test_flags, it should also fail with any superset thereof.\n             if ((flags & test_flags) == test_flags) {"
      },
      {
        "sha": "aa911cdeda59ae6e89ba5f530fbec8a8afc8a02a",
        "filename": "src/test/fuzz/script_flags.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/fuzz/script_flags.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/fuzz/script_flags.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/script_flags.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -48,7 +48,7 @@ FUZZ_TARGET_INIT(script_flags, initialize_script_flags)\n \n         for (unsigned i = 0; i < tx.vin.size(); ++i) {\n             const CTxOut& prevout = txdata.m_spent_outputs.at(i);\n-            const TransactionSignatureChecker checker{&tx, i, prevout.nValue, txdata};\n+            const TransactionSignatureChecker checker{&tx, i, prevout.nValue, txdata, MissingDataBehavior::ASSERT_FAIL};\n \n             ScriptError serror;\n             const bool ret = VerifyScript(tx.vin.at(i).scriptSig, prevout.scriptPubKey, &tx.vin.at(i).scriptWitness, verify_flags, checker, &serror);"
      },
      {
        "sha": "b8d846a995865356b41a8a4ab19a1ac9911adaf4",
        "filename": "src/test/fuzz/util.cpp",
        "status": "modified",
        "additions": 184,
        "deletions": 3,
        "changes": 187,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/fuzz/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/fuzz/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/util.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -7,15 +7,196 @@\n #include <util/rbf.h>\n #include <version.h>\n \n-bool FuzzedSock::Wait(std::chrono::milliseconds timeout, Event requested, Event* occurred ) const\n+FuzzedSock::FuzzedSock(FuzzedDataProvider& fuzzed_data_provider)\n+    : m_fuzzed_data_provider{fuzzed_data_provider}\n {\n-    if (!m_fuzzed_data_provider.ConsumeBool()) {\n+    m_socket = fuzzed_data_provider.ConsumeIntegralInRange<SOCKET>(INVALID_SOCKET - 1, INVALID_SOCKET);\n+}\n+\n+FuzzedSock::~FuzzedSock()\n+{\n+    // Sock::~Sock() will be called after FuzzedSock::~FuzzedSock() and it will call\n+    // Sock::Reset() (not FuzzedSock::Reset()!) which will call CloseSocket(m_socket).\n+    // Avoid closing an arbitrary file descriptor (m_socket is just a random very high number which\n+    // theoretically may concide with a real opened file descriptor).\n+    Reset();\n+}\n+\n+FuzzedSock& FuzzedSock::operator=(Sock&& other)\n+{\n+    assert(false && \"Move of Sock into FuzzedSock not allowed.\");\n+    return *this;\n+}\n+\n+void FuzzedSock::Reset()\n+{\n+    m_socket = INVALID_SOCKET;\n+}\n+\n+ssize_t FuzzedSock::Send(const void* data, size_t len, int flags) const\n+{\n+    constexpr std::array send_errnos{\n+        EACCES,\n+        EAGAIN,\n+        EALREADY,\n+        EBADF,\n+        ECONNRESET,\n+        EDESTADDRREQ,\n+        EFAULT,\n+        EINTR,\n+        EINVAL,\n+        EISCONN,\n+        EMSGSIZE,\n+        ENOBUFS,\n+        ENOMEM,\n+        ENOTCONN,\n+        ENOTSOCK,\n+        EOPNOTSUPP,\n+        EPIPE,\n+        EWOULDBLOCK,\n+    };\n+    if (m_fuzzed_data_provider.ConsumeBool()) {\n+        return len;\n+    }\n+    const ssize_t r = m_fuzzed_data_provider.ConsumeIntegralInRange<ssize_t>(-1, len);\n+    if (r == -1) {\n+        SetFuzzedErrNo(m_fuzzed_data_provider, send_errnos);\n+    }\n+    return r;\n+}\n+\n+ssize_t FuzzedSock::Recv(void* buf, size_t len, int flags) const\n+{\n+    // Have a permanent error at recv_errnos[0] because when the fuzzed data is exhausted\n+    // SetFuzzedErrNo() will always return the first element and we want to avoid Recv()\n+    // returning -1 and setting errno to EAGAIN repeatedly.\n+    constexpr std::array recv_errnos{\n+        ECONNREFUSED,\n+        EAGAIN,\n+        EBADF,\n+        EFAULT,\n+        EINTR,\n+        EINVAL,\n+        ENOMEM,\n+        ENOTCONN,\n+        ENOTSOCK,\n+        EWOULDBLOCK,\n+    };\n+    assert(buf != nullptr || len == 0);\n+    if (len == 0 || m_fuzzed_data_provider.ConsumeBool()) {\n+        const ssize_t r = m_fuzzed_data_provider.ConsumeBool() ? 0 : -1;\n+        if (r == -1) {\n+            SetFuzzedErrNo(m_fuzzed_data_provider, recv_errnos);\n+        }\n+        return r;\n+    }\n+    std::vector<uint8_t> random_bytes;\n+    bool pad_to_len_bytes{m_fuzzed_data_provider.ConsumeBool()};\n+    if (m_peek_data.has_value()) {\n+        // `MSG_PEEK` was used in the preceding `Recv()` call, return `m_peek_data`.\n+        random_bytes.assign({m_peek_data.value()});\n+        if ((flags & MSG_PEEK) == 0) {\n+            m_peek_data.reset();\n+        }\n+        pad_to_len_bytes = false;\n+    } else if ((flags & MSG_PEEK) != 0) {\n+        // New call with `MSG_PEEK`.\n+        random_bytes = m_fuzzed_data_provider.ConsumeBytes<uint8_t>(1);\n+        if (!random_bytes.empty()) {\n+            m_peek_data = random_bytes[0];\n+            pad_to_len_bytes = false;\n+        }\n+    } else {\n+        random_bytes = m_fuzzed_data_provider.ConsumeBytes<uint8_t>(\n+            m_fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, len));\n+    }\n+    if (random_bytes.empty()) {\n+        const ssize_t r = m_fuzzed_data_provider.ConsumeBool() ? 0 : -1;\n+        if (r == -1) {\n+            SetFuzzedErrNo(m_fuzzed_data_provider, recv_errnos);\n+        }\n+        return r;\n+    }\n+    std::memcpy(buf, random_bytes.data(), random_bytes.size());\n+    if (pad_to_len_bytes) {\n+        if (len > random_bytes.size()) {\n+            std::memset((char*)buf + random_bytes.size(), 0, len - random_bytes.size());\n+        }\n+        return len;\n+    }\n+    if (m_fuzzed_data_provider.ConsumeBool() && std::getenv(\"FUZZED_SOCKET_FAKE_LATENCY\") != nullptr) {\n+        std::this_thread::sleep_for(std::chrono::milliseconds{2});\n+    }\n+    return random_bytes.size();\n+}\n+\n+int FuzzedSock::Connect(const sockaddr*, socklen_t) const\n+{\n+    // Have a permanent error at connect_errnos[0] because when the fuzzed data is exhausted\n+    // SetFuzzedErrNo() will always return the first element and we want to avoid Connect()\n+    // returning -1 and setting errno to EAGAIN repeatedly.\n+    constexpr std::array connect_errnos{\n+        ECONNREFUSED,\n+        EAGAIN,\n+        ECONNRESET,\n+        EHOSTUNREACH,\n+        EINPROGRESS,\n+        EINTR,\n+        ENETUNREACH,\n+        ETIMEDOUT,\n+    };\n+    if (m_fuzzed_data_provider.ConsumeBool()) {\n+        SetFuzzedErrNo(m_fuzzed_data_provider, connect_errnos);\n+        return -1;\n+    }\n+    return 0;\n+}\n+\n+int FuzzedSock::GetSockOpt(int level, int opt_name, void* opt_val, socklen_t* opt_len) const\n+{\n+    constexpr std::array getsockopt_errnos{\n+        ENOMEM,\n+        ENOBUFS,\n+    };\n+    if (m_fuzzed_data_provider.ConsumeBool()) {\n+        SetFuzzedErrNo(m_fuzzed_data_provider, getsockopt_errnos);\n+        return -1;\n+    }\n+    if (opt_val == nullptr) {\n+        return 0;\n+    }\n+    std::memcpy(opt_val,\n+                ConsumeFixedLengthByteVector(m_fuzzed_data_provider, *opt_len).data(),\n+                *opt_len);\n+    return 0;\n+}\n+\n+bool FuzzedSock::Wait(std::chrono::milliseconds timeout, Event requested, Event* occurred) const\n+{\n+    constexpr std::array wait_errnos{\n+        EBADF,\n+        EINTR,\n+        EINVAL,\n+    };\n+    if (m_fuzzed_data_provider.ConsumeBool()) {\n+        SetFuzzedErrNo(m_fuzzed_data_provider, wait_errnos);\n         return false;\n     }\n-    if (occurred) *occurred = 0;\n+    if (occurred != nullptr) {\n+        *occurred = m_fuzzed_data_provider.ConsumeBool() ? requested : 0;\n+    }\n     return true;\n }\n \n+bool FuzzedSock::IsConnected(std::string& errmsg) const\n+{\n+    if (m_fuzzed_data_provider.ConsumeBool()) {\n+        return true;\n+    }\n+    errmsg = \"disconnected at random by the fuzzer\";\n+    return false;\n+}\n+\n void FillNode(FuzzedDataProvider& fuzzed_data_provider, CNode& node, bool init_version) noexcept\n {\n     const ServiceFlags remote_services = ConsumeWeakEnum(fuzzed_data_provider, ALL_SERVICE_FLAGS);"
      },
      {
        "sha": "8f4f87fbdcf86eac8eacd0a75a931e9106e33b6d",
        "filename": "src/test/fuzz/util.h",
        "status": "modified",
        "additions": 9,
        "deletions": 163,
        "changes": 172,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/fuzz/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/fuzz/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/util.h?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -575,179 +575,25 @@ class FuzzedSock : public Sock\n     mutable std::optional<uint8_t> m_peek_data;\n \n public:\n-    explicit FuzzedSock(FuzzedDataProvider& fuzzed_data_provider) : m_fuzzed_data_provider{fuzzed_data_provider}\n-    {\n-          m_socket = fuzzed_data_provider.ConsumeIntegral<SOCKET>();\n-    }\n+    explicit FuzzedSock(FuzzedDataProvider& fuzzed_data_provider);\n \n-    ~FuzzedSock() override\n-    {\n-        // Sock::~Sock() will be called after FuzzedSock::~FuzzedSock() and it will call\n-        // Sock::Reset() (not FuzzedSock::Reset()!) which will call CloseSocket(m_socket).\n-        // Avoid closing an arbitrary file descriptor (m_socket is just a random number which\n-        // may concide with a real opened file descriptor).\n-        Reset();\n-    }\n+    ~FuzzedSock() override;\n \n-    FuzzedSock& operator=(Sock&& other) override\n-    {\n-        assert(false && \"Move of Sock into FuzzedSock not allowed.\");\n-        return *this;\n-    }\n+    FuzzedSock& operator=(Sock&& other) override;\n \n-    void Reset() override\n-    {\n-        m_socket = INVALID_SOCKET;\n-    }\n+    void Reset() override;\n \n-    ssize_t Send(const void* data, size_t len, int flags) const override\n-    {\n-        constexpr std::array send_errnos{\n-            EACCES,\n-            EAGAIN,\n-            EALREADY,\n-            EBADF,\n-            ECONNRESET,\n-            EDESTADDRREQ,\n-            EFAULT,\n-            EINTR,\n-            EINVAL,\n-            EISCONN,\n-            EMSGSIZE,\n-            ENOBUFS,\n-            ENOMEM,\n-            ENOTCONN,\n-            ENOTSOCK,\n-            EOPNOTSUPP,\n-            EPIPE,\n-            EWOULDBLOCK,\n-        };\n-        if (m_fuzzed_data_provider.ConsumeBool()) {\n-            return len;\n-        }\n-        const ssize_t r = m_fuzzed_data_provider.ConsumeIntegralInRange<ssize_t>(-1, len);\n-        if (r == -1) {\n-            SetFuzzedErrNo(m_fuzzed_data_provider, send_errnos);\n-        }\n-        return r;\n-    }\n+    ssize_t Send(const void* data, size_t len, int flags) const override;\n \n-    ssize_t Recv(void* buf, size_t len, int flags) const override\n-    {\n-        // Have a permanent error at recv_errnos[0] because when the fuzzed data is exhausted\n-        // SetFuzzedErrNo() will always return the first element and we want to avoid Recv()\n-        // returning -1 and setting errno to EAGAIN repeatedly.\n-        constexpr std::array recv_errnos{\n-            ECONNREFUSED,\n-            EAGAIN,\n-            EBADF,\n-            EFAULT,\n-            EINTR,\n-            EINVAL,\n-            ENOMEM,\n-            ENOTCONN,\n-            ENOTSOCK,\n-            EWOULDBLOCK,\n-        };\n-        assert(buf != nullptr || len == 0);\n-        if (len == 0 || m_fuzzed_data_provider.ConsumeBool()) {\n-            const ssize_t r = m_fuzzed_data_provider.ConsumeBool() ? 0 : -1;\n-            if (r == -1) {\n-                SetFuzzedErrNo(m_fuzzed_data_provider, recv_errnos);\n-            }\n-            return r;\n-        }\n-        std::vector<uint8_t> random_bytes;\n-        bool pad_to_len_bytes{m_fuzzed_data_provider.ConsumeBool()};\n-        if (m_peek_data.has_value()) {\n-            // `MSG_PEEK` was used in the preceding `Recv()` call, return `m_peek_data`.\n-            random_bytes.assign({m_peek_data.value()});\n-            if ((flags & MSG_PEEK) == 0) {\n-                m_peek_data.reset();\n-            }\n-            pad_to_len_bytes = false;\n-        } else if ((flags & MSG_PEEK) != 0) {\n-            // New call with `MSG_PEEK`.\n-            random_bytes = m_fuzzed_data_provider.ConsumeBytes<uint8_t>(1);\n-            if (!random_bytes.empty()) {\n-                m_peek_data = random_bytes[0];\n-                pad_to_len_bytes = false;\n-            }\n-        } else {\n-            random_bytes = m_fuzzed_data_provider.ConsumeBytes<uint8_t>(\n-                m_fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, len));\n-        }\n-        if (random_bytes.empty()) {\n-            const ssize_t r = m_fuzzed_data_provider.ConsumeBool() ? 0 : -1;\n-            if (r == -1) {\n-                SetFuzzedErrNo(m_fuzzed_data_provider, recv_errnos);\n-            }\n-            return r;\n-        }\n-        std::memcpy(buf, random_bytes.data(), random_bytes.size());\n-        if (pad_to_len_bytes) {\n-            if (len > random_bytes.size()) {\n-                std::memset((char*)buf + random_bytes.size(), 0, len - random_bytes.size());\n-            }\n-            return len;\n-        }\n-        if (m_fuzzed_data_provider.ConsumeBool() && std::getenv(\"FUZZED_SOCKET_FAKE_LATENCY\") != nullptr) {\n-            std::this_thread::sleep_for(std::chrono::milliseconds{2});\n-        }\n-        return random_bytes.size();\n-    }\n+    ssize_t Recv(void* buf, size_t len, int flags) const override;\n \n-    int Connect(const sockaddr*, socklen_t) const override\n-    {\n-        // Have a permanent error at connect_errnos[0] because when the fuzzed data is exhausted\n-        // SetFuzzedErrNo() will always return the first element and we want to avoid Connect()\n-        // returning -1 and setting errno to EAGAIN repeatedly.\n-        constexpr std::array connect_errnos{\n-            ECONNREFUSED,\n-            EAGAIN,\n-            ECONNRESET,\n-            EHOSTUNREACH,\n-            EINPROGRESS,\n-            EINTR,\n-            ENETUNREACH,\n-            ETIMEDOUT,\n-        };\n-        if (m_fuzzed_data_provider.ConsumeBool()) {\n-            SetFuzzedErrNo(m_fuzzed_data_provider, connect_errnos);\n-            return -1;\n-        }\n-        return 0;\n-    }\n+    int Connect(const sockaddr*, socklen_t) const override;\n \n-    int GetSockOpt(int level, int opt_name, void* opt_val, socklen_t* opt_len) const override\n-    {\n-        constexpr std::array getsockopt_errnos{\n-            ENOMEM,\n-            ENOBUFS,\n-        };\n-        if (m_fuzzed_data_provider.ConsumeBool()) {\n-            SetFuzzedErrNo(m_fuzzed_data_provider, getsockopt_errnos);\n-            return -1;\n-        }\n-        if (opt_val == nullptr) {\n-            return 0;\n-        }\n-        std::memcpy(opt_val,\n-                    ConsumeFixedLengthByteVector(m_fuzzed_data_provider, *opt_len).data(),\n-                    *opt_len);\n-        return 0;\n-    }\n+    int GetSockOpt(int level, int opt_name, void* opt_val, socklen_t* opt_len) const override;\n \n     bool Wait(std::chrono::milliseconds timeout, Event requested, Event* occurred = nullptr) const override;\n \n-    bool IsConnected(std::string& errmsg) const override\n-    {\n-        if (m_fuzzed_data_provider.ConsumeBool()) {\n-            return true;\n-        }\n-        errmsg = \"disconnected at random by the fuzzer\";\n-        return false;\n-    }\n+    bool IsConnected(std::string& errmsg) const override;\n };\n \n [[nodiscard]] inline FuzzedSock ConsumeSock(FuzzedDataProvider& fuzzed_data_provider)"
      },
      {
        "sha": "91868218362c17e4141dde0cc196cf0b03412092",
        "filename": "src/test/fuzz/versionbits.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 32,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/fuzz/versionbits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/fuzz/versionbits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/versionbits.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -29,21 +29,24 @@ class TestConditionChecker : public AbstractThresholdConditionChecker\n     const int64_t m_end;\n     const int m_period;\n     const int m_threshold;\n+    const int m_min_activation_height;\n     const int m_bit;\n \n-    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n-        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int min_activation_height, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_min_activation_height{min_activation_height}, m_bit{bit}\n     {\n         assert(m_period > 0);\n         assert(0 <= m_threshold && m_threshold <= m_period);\n         assert(0 <= m_bit && m_bit < 32 && m_bit < VERSIONBITS_NUM_BITS);\n+        assert(0 <= m_min_activation_height);\n     }\n \n     bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n     int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n     int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n     int Period(const Consensus::Params& params) const override { return m_period; }\n     int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+    int MinActivationHeight(const Consensus::Params& params) const override { return m_min_activation_height; }\n \n     ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n     int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n@@ -144,32 +147,27 @@ FUZZ_TARGET_INIT(versionbits, initialize)\n         // pick the timestamp to switch based on a block\n         // note states will change *after* these blocks because mediantime lags\n         int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods - 3));\n-        int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods - 3));\n+        int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods - 3));\n \n         start_time = block_start_time + start_block * interval;\n         timeout = block_start_time + end_block * interval;\n \n-        assert(start_time <= timeout);\n-\n         // allow for times to not exactly match a block\n         if (fuzzed_data_provider.ConsumeBool()) start_time += interval / 2;\n         if (fuzzed_data_provider.ConsumeBool()) timeout += interval / 2;\n-\n-        // this may make timeout too early; if so, don't run the test\n-        if (start_time > timeout) return;\n     } else {\n         if (fuzzed_data_provider.ConsumeBool()) {\n             start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n-            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n             always_active_test = true;\n         } else {\n-            start_time = 1199145601; // January 1, 2008\n-            timeout = 1230767999;    // December 31, 2008\n+            start_time = Consensus::BIP9Deployment::NEVER_ACTIVE;\n             never_active_test = true;\n         }\n+        timeout = fuzzed_data_provider.ConsumeBool() ? Consensus::BIP9Deployment::NO_TIMEOUT : fuzzed_data_provider.ConsumeIntegral<int64_t>();\n     }\n+    int min_activation = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * max_periods);\n \n-    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+    TestConditionChecker checker(start_time, timeout, period, threshold, min_activation, bit);\n \n     // Early exit if the versions don't signal sensibly for the deployment\n     if (!checker.Condition(ver_signal)) return;\n@@ -294,28 +292,35 @@ FUZZ_TARGET_INIT(versionbits, initialize)\n         assert(since == 0);\n         assert(exp_state == ThresholdState::DEFINED);\n         assert(current_block->GetMedianTimePast() < checker.m_begin);\n-        assert(current_block->GetMedianTimePast() < checker.m_end);\n         break;\n     case ThresholdState::STARTED:\n         assert(current_block->GetMedianTimePast() >= checker.m_begin);\n-        assert(current_block->GetMedianTimePast() < checker.m_end);\n         if (exp_state == ThresholdState::STARTED) {\n             assert(blocks_sig < threshold);\n+            assert(current_block->GetMedianTimePast() < checker.m_end);\n         } else {\n             assert(exp_state == ThresholdState::DEFINED);\n         }\n         break;\n     case ThresholdState::LOCKED_IN:\n-        assert(exp_state == ThresholdState::STARTED);\n-        assert(current_block->GetMedianTimePast() < checker.m_end);\n-        assert(blocks_sig >= threshold);\n+        if (exp_state == ThresholdState::LOCKED_IN) {\n+            assert(current_block->nHeight + 1 < min_activation);\n+        } else {\n+            assert(exp_state == ThresholdState::STARTED);\n+            assert(blocks_sig >= threshold);\n+        }\n         break;\n     case ThresholdState::ACTIVE:\n+        assert(always_active_test || min_activation <= current_block->nHeight + 1);\n         assert(exp_state == ThresholdState::ACTIVE || exp_state == ThresholdState::LOCKED_IN);\n         break;\n     case ThresholdState::FAILED:\n-        assert(current_block->GetMedianTimePast() >= checker.m_end);\n-        assert(exp_state != ThresholdState::LOCKED_IN && exp_state != ThresholdState::ACTIVE);\n+        assert(never_active_test || current_block->GetMedianTimePast() >= checker.m_end);\n+        if (exp_state == ThresholdState::STARTED) {\n+            assert(blocks_sig < threshold);\n+        } else {\n+            assert(exp_state == ThresholdState::FAILED);\n+        }\n         break;\n     default:\n         assert(false);\n@@ -326,26 +331,20 @@ FUZZ_TARGET_INIT(versionbits, initialize)\n         assert(state == ThresholdState::ACTIVE || state == ThresholdState::FAILED);\n     }\n \n-    // \"always active\" has additional restrictions\n     if (always_active_test) {\n+        // \"always active\" has additional restrictions\n         assert(state == ThresholdState::ACTIVE);\n         assert(exp_state == ThresholdState::ACTIVE);\n         assert(since == 0);\n+    } else if (never_active_test) {\n+        // \"never active\" does too\n+        assert(state == ThresholdState::FAILED);\n+        assert(exp_state == ThresholdState::FAILED);\n+        assert(since == 0);\n     } else {\n-        // except for always active, the initial state is always DEFINED\n+        // for signalled deployments, the initial state is always DEFINED\n         assert(since > 0 || state == ThresholdState::DEFINED);\n         assert(exp_since > 0 || exp_state == ThresholdState::DEFINED);\n     }\n-\n-    // \"never active\" does too\n-    if (never_active_test) {\n-        assert(state == ThresholdState::FAILED);\n-        assert(since == period);\n-        if (exp_since == 0) {\n-            assert(exp_state == ThresholdState::DEFINED);\n-        } else {\n-            assert(exp_state == ThresholdState::FAILED);\n-        }\n-    }\n }\n } // namespace"
      },
      {
        "sha": "e99c6e0fc8bd8e5a090fa44b4e49fa4663e83c22",
        "filename": "src/test/logging_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/logging_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/logging_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/logging_tests.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -14,7 +14,6 @@ BOOST_FIXTURE_TEST_SUITE(logging_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(logging_timer)\n {\n-\n     SetMockTime(1);\n     auto sec_timer = BCLog::Timer<std::chrono::seconds>(\"tests\", \"end_msg\");\n     SetMockTime(2);\n@@ -29,8 +28,6 @@ BOOST_AUTO_TEST_CASE(logging_timer)\n     auto micro_timer = BCLog::Timer<std::chrono::microseconds>(\"tests\", \"end_msg\");\n     SetMockTime(2);\n     BOOST_CHECK_EQUAL(micro_timer.LogMsg(\"test micros\"), \"tests: test micros (1000000.00\u03bcs)\");\n-\n-    SetMockTime(0);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "bf36f8a6c998f05ddd604ea10eee6d23b24c63ab",
        "filename": "src/test/mempool_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -571,8 +571,6 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)\n     SetMockTime(42 + 8*CTxMemPool::ROLLING_FEE_HALFLIFE + CTxMemPool::ROLLING_FEE_HALFLIFE/2 + CTxMemPool::ROLLING_FEE_HALFLIFE/4);\n     BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), 0);\n     // ... unless it has gone all the way to 0 (after getting past 1000/2)\n-\n-    SetMockTime(0);\n }\n \n inline CTransactionRef make_tx(std::vector<CAmount>&& output_values, std::vector<CTransactionRef>&& inputs=std::vector<CTransactionRef>(), std::vector<uint32_t>&& input_indices=std::vector<uint32_t>())"
      },
      {
        "sha": "39f9b7ee28623119481ed1a7e3b84145d15858cd",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -77,20 +77,20 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n     keys.assign(1,key[0]);\n     keys.push_back(key[1]);\n     s = sign_multisig(a_and_b, keys, CTransaction(txTo[0]), 0);\n-    BOOST_CHECK(VerifyScript(s, a_and_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err));\n+    BOOST_CHECK(VerifyScript(s, a_and_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount, MissingDataBehavior::ASSERT_FAIL), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     for (int i = 0; i < 4; i++)\n     {\n         keys.assign(1,key[i]);\n         s = sign_multisig(a_and_b, keys, CTransaction(txTo[0]), 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err), strprintf(\"a&b 1: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount, MissingDataBehavior::ASSERT_FAIL), &err), strprintf(\"a&b 1: %d\", i));\n         BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\n \n         keys.assign(1,key[1]);\n         keys.push_back(key[i]);\n         s = sign_multisig(a_and_b, keys, CTransaction(txTo[0]), 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err), strprintf(\"a&b 2: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount, MissingDataBehavior::ASSERT_FAIL), &err), strprintf(\"a&b 2: %d\", i));\n         BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n     }\n \n@@ -101,18 +101,18 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n         s = sign_multisig(a_or_b, keys, CTransaction(txTo[1]), 0);\n         if (i == 0 || i == 1)\n         {\n-            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount, MissingDataBehavior::ASSERT_FAIL), &err), strprintf(\"a|b: %d\", i));\n             BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n         }\n         else\n         {\n-            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount, MissingDataBehavior::ASSERT_FAIL), &err), strprintf(\"a|b: %d\", i));\n             BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n         }\n     }\n     s.clear();\n     s << OP_0 << OP_1;\n-    BOOST_CHECK(!VerifyScript(s, a_or_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err));\n+    BOOST_CHECK(!VerifyScript(s, a_or_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount, MissingDataBehavior::ASSERT_FAIL), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_SIG_DER, ScriptErrorString(err));\n \n \n@@ -124,12 +124,12 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n             s = sign_multisig(escrow, keys, CTransaction(txTo[2]), 0);\n             if (i < j && i < 3 && j < 3)\n             {\n-                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, nullptr, flags, MutableTransactionSignatureChecker(&txTo[2], 0, amount), &err), strprintf(\"escrow 1: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, nullptr, flags, MutableTransactionSignatureChecker(&txTo[2], 0, amount, MissingDataBehavior::ASSERT_FAIL), &err), strprintf(\"escrow 1: %d %d\", i, j));\n                 BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n             }\n             else\n             {\n-                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, nullptr, flags, MutableTransactionSignatureChecker(&txTo[2], 0, amount), &err), strprintf(\"escrow 2: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, nullptr, flags, MutableTransactionSignatureChecker(&txTo[2], 0, amount, MissingDataBehavior::ASSERT_FAIL), &err), strprintf(\"escrow 2: %d %d\", i, j));\n                 BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n             }\n         }"
      },
      {
        "sha": "67fbc9f8a2cf4e4e2423e343f2ea7e2379cb74e1",
        "filename": "src/test/rpc_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/rpc_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/rpc_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/rpc_tests.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -275,7 +275,11 @@ BOOST_AUTO_TEST_CASE(rpc_ban)\n \n     BOOST_CHECK_NO_THROW(CallRPC(std::string(\"clearbanned\")));\n \n+    auto now = 10'000s;\n+    SetMockTime(now);\n     BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"setban 127.0.0.0/24 add 200\")));\n+    SetMockTime(now += 2s);\n+    const int64_t time_remaining_expected{198};\n     BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"listbanned\")));\n     ar = r.get_array();\n     o1 = ar[0].get_obj();\n@@ -284,12 +288,10 @@ BOOST_AUTO_TEST_CASE(rpc_ban)\n     const int64_t ban_created{find_value(o1, \"ban_created\").get_int64()};\n     const int64_t ban_duration{find_value(o1, \"ban_duration\").get_int64()};\n     const int64_t time_remaining{find_value(o1, \"time_remaining\").get_int64()};\n-    const int64_t now{GetTime()};\n     BOOST_CHECK_EQUAL(adr.get_str(), \"127.0.0.0/24\");\n-    BOOST_CHECK(banned_until > now);\n-    BOOST_CHECK(banned_until - now <= 200);\n+    BOOST_CHECK_EQUAL(banned_until, time_remaining_expected + now.count());\n     BOOST_CHECK_EQUAL(ban_duration, banned_until - ban_created);\n-    BOOST_CHECK_EQUAL(time_remaining, banned_until - now);\n+    BOOST_CHECK_EQUAL(time_remaining, time_remaining_expected);\n \n     // must throw an exception because 127.0.0.1 is in already banned subnet range\n     BOOST_CHECK_THROW(r = CallRPC(std::string(\"setban 127.0.0.1 add\")), std::runtime_error);"
      },
      {
        "sha": "d8a44a65dd6e710105a5439b2e8a331c33be8df7",
        "filename": "src/test/script_p2sh_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/script_p2sh_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/script_p2sh_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_p2sh_tests.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -41,7 +41,7 @@ Verify(const CScript& scriptSig, const CScript& scriptPubKey, bool fStrict, Scri\n     txTo.vin[0].scriptSig = scriptSig;\n     txTo.vout[0].nValue = 1;\n \n-    return VerifyScript(scriptSig, scriptPubKey, nullptr, fStrict ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE, MutableTransactionSignatureChecker(&txTo, 0, txFrom.vout[0].nValue), &err);\n+    return VerifyScript(scriptSig, scriptPubKey, nullptr, fStrict ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE, MutableTransactionSignatureChecker(&txTo, 0, txFrom.vout[0].nValue, MissingDataBehavior::ASSERT_FAIL), &err);\n }\n \n "
      },
      {
        "sha": "14cfadf75d20913f8dee9647fa9b9520f76d6b22",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -135,7 +135,7 @@ void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, const CScript\n     const CTransaction txCredit{BuildCreditingTransaction(scriptPubKey, nValue)};\n     CMutableTransaction tx = BuildSpendingTransaction(scriptSig, scriptWitness, txCredit);\n     CMutableTransaction tx2 = tx;\n-    BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, &scriptWitness, flags, MutableTransactionSignatureChecker(&tx, 0, txCredit.vout[0].nValue), &err) == expect, message);\n+    BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, &scriptWitness, flags, MutableTransactionSignatureChecker(&tx, 0, txCredit.vout[0].nValue, MissingDataBehavior::ASSERT_FAIL), &err) == expect, message);\n     BOOST_CHECK_MESSAGE(err == scriptError, FormatScriptError(err) + \" where \" + FormatScriptError((ScriptError_t)scriptError) + \" expected: \" + message);\n \n     // Verify that removing flags from a passing test or adding flags to a failing test does not change the result.\n@@ -145,7 +145,7 @@ void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, const CScript\n         // Weed out some invalid flag combinations.\n         if (combined_flags & SCRIPT_VERIFY_CLEANSTACK && ~combined_flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) continue;\n         if (combined_flags & SCRIPT_VERIFY_WITNESS && ~combined_flags & SCRIPT_VERIFY_P2SH) continue;\n-        BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, &scriptWitness, combined_flags, MutableTransactionSignatureChecker(&tx, 0, txCredit.vout[0].nValue), &err) == expect, message + strprintf(\" (with flags %x)\", combined_flags));\n+        BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, &scriptWitness, combined_flags, MutableTransactionSignatureChecker(&tx, 0, txCredit.vout[0].nValue, MissingDataBehavior::ASSERT_FAIL), &err) == expect, message + strprintf(\" (with flags %x)\", combined_flags));\n     }\n \n #if defined(HAVE_CONSENSUS_LIB)\n@@ -1071,18 +1071,18 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n     CMutableTransaction txTo12 = BuildSpendingTransaction(CScript(), CScriptWitness(), txFrom12);\n \n     CScript goodsig1 = sign_multisig(scriptPubKey12, key1, CTransaction(txTo12));\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue, MissingDataBehavior::ASSERT_FAIL), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n     txTo12.vout[0].nValue = 2;\n-    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n+    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue, MissingDataBehavior::ASSERT_FAIL), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     CScript goodsig2 = sign_multisig(scriptPubKey12, key2, CTransaction(txTo12));\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue, MissingDataBehavior::ASSERT_FAIL), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     CScript badsig1 = sign_multisig(scriptPubKey12, key3, CTransaction(txTo12));\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue, MissingDataBehavior::ASSERT_FAIL), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n }\n \n@@ -1104,54 +1104,54 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n     std::vector<CKey> keys;\n     keys.push_back(key1); keys.push_back(key2);\n     CScript goodsig1 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue, MissingDataBehavior::ASSERT_FAIL), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key3);\n     CScript goodsig2 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue, MissingDataBehavior::ASSERT_FAIL), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key3);\n     CScript goodsig3 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n-    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue, MissingDataBehavior::ASSERT_FAIL), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key2); // Can't re-use sig\n     CScript badsig1 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue, MissingDataBehavior::ASSERT_FAIL), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key1); // sigs must be in correct order\n     CScript badsig2 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n-    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue, MissingDataBehavior::ASSERT_FAIL), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key3); keys.push_back(key2); // sigs must be in correct order\n     CScript badsig3 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n-    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue, MissingDataBehavior::ASSERT_FAIL), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key4); keys.push_back(key2); // sigs must match pubkeys\n     CScript badsig4 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n-    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue, MissingDataBehavior::ASSERT_FAIL), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key4); // sigs must match pubkeys\n     CScript badsig5 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n-    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue, MissingDataBehavior::ASSERT_FAIL), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear(); // Must have signatures\n     CScript badsig6 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n-    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue, MissingDataBehavior::ASSERT_FAIL), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\n }\n "
      },
      {
        "sha": "12fc575c1ec5a272da2ad7e48b0ed79c2ce40e91",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -71,7 +71,7 @@ static ScriptError VerifyWithFlag(const CTransaction& output, const CMutableTran\n {\n     ScriptError error;\n     CTransaction inputi(input);\n-    bool ret = VerifyScript(inputi.vin[0].scriptSig, output.vout[0].scriptPubKey, &inputi.vin[0].scriptWitness, flags, TransactionSignatureChecker(&inputi, 0, output.vout[0].nValue), &error);\n+    bool ret = VerifyScript(inputi.vin[0].scriptSig, output.vout[0].scriptPubKey, &inputi.vin[0].scriptWitness, flags, TransactionSignatureChecker(&inputi, 0, output.vout[0].nValue, MissingDataBehavior::ASSERT_FAIL), &error);\n     BOOST_CHECK((ret == true) == (error == SCRIPT_ERR_OK));\n \n     return error;"
      },
      {
        "sha": "aaa6caa4f1433463c39e587cf5bc375af60c1411",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -108,7 +108,7 @@ bool CheckTxScripts(const CTransaction& tx, const std::map<COutPoint, CScript>&\n         const CAmount amount = map_prevout_values.count(input.prevout) ? map_prevout_values.at(input.prevout) : 0;\n         try {\n             tx_valid = VerifyScript(input.scriptSig, map_prevout_scriptPubKeys.at(input.prevout),\n-                &input.scriptWitness, flags, TransactionSignatureChecker(&tx, i, amount, txdata), &err);\n+                &input.scriptWitness, flags, TransactionSignatureChecker(&tx, i, amount, txdata, MissingDataBehavior::ASSERT_FAIL), &err);\n         } catch (...) {\n             BOOST_ERROR(\"Bad test: \" << strTest);\n             return true; // The test format is bad and an error is thrown. Return true to silence further error.\n@@ -427,7 +427,7 @@ static void CheckWithFlag(const CTransactionRef& output, const CMutableTransacti\n {\n     ScriptError error;\n     CTransaction inputi(input);\n-    bool ret = VerifyScript(inputi.vin[0].scriptSig, output->vout[0].scriptPubKey, &inputi.vin[0].scriptWitness, flags, TransactionSignatureChecker(&inputi, 0, output->vout[0].nValue), &error);\n+    bool ret = VerifyScript(inputi.vin[0].scriptSig, output->vout[0].scriptPubKey, &inputi.vin[0].scriptWitness, flags, TransactionSignatureChecker(&inputi, 0, output->vout[0].nValue, MissingDataBehavior::ASSERT_FAIL), &error);\n     assert(ret == success);\n }\n "
      },
      {
        "sha": "b8ab9d2344fe4bd31bb0c628ca35582f33039780",
        "filename": "src/test/util/blockfilter.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/util/blockfilter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/util/blockfilter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/blockfilter.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -5,6 +5,7 @@\n #include <test/util/blockfilter.h>\n \n #include <chainparams.h>\n+#include <node/blockstorage.h>\n #include <validation.h>\n \n "
      },
      {
        "sha": "9268d60a1ed6383809b71e0f044a2b6ceace70a7",
        "filename": "src/test/util/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/util/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/util/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/net.h?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -78,8 +78,7 @@ class StaticContentsSock : public Sock\n     explicit StaticContentsSock(const std::string& contents) : m_contents{contents}, m_consumed{0}\n     {\n         // Just a dummy number that is not INVALID_SOCKET.\n-        static_assert(INVALID_SOCKET != 1000);\n-        m_socket = 1000;\n+        m_socket = INVALID_SOCKET - 1;\n     }\n \n     ~StaticContentsSock() override { Reset(); }"
      },
      {
        "sha": "d644dd23275adfe1c741db6d646257671ba50805",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -120,6 +120,7 @@ BasicTestingSetup::BasicTestingSetup(const std::string& chainName, const std::ve\n \n BasicTestingSetup::~BasicTestingSetup()\n {\n+    SetMockTime(0s); // Reset mocktime for following tests\n     LogInstance().DisconnectTestLogger();\n     fs::remove_all(m_path_root);\n     gArgs.ClearArgs();\n@@ -303,7 +304,6 @@ CMutableTransaction TestChain100Setup::CreateValidMempoolTransaction(CTransactio\n TestChain100Setup::~TestChain100Setup()\n {\n     gArgs.ForceSetArg(\"-segwitheight\", \"0\");\n-    SetMockTime(0);\n }\n \n CTxMemPoolEntry TestMemPoolEntryHelper::FromTx(const CMutableTransaction& tx) const"
      },
      {
        "sha": "a1ac9ead69051906c4b7d360c8eb5ccf0e6495b8",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -1766,7 +1766,7 @@ static constexpr char LockCommand = 'L';\n static constexpr char UnlockCommand = 'U';\n static constexpr char ExitCommand = 'X';\n \n-static void TestOtherProcess(fs::path dirname, std::string lockname, int fd)\n+[[noreturn]] static void TestOtherProcess(fs::path dirname, std::string lockname, int fd)\n {\n     char ch;\n     while (true) {"
      },
      {
        "sha": "05838ec19a21031c985912274c56bfb91424a8fb",
        "filename": "src/test/versionbits_tests.cpp",
        "status": "modified",
        "additions": 213,
        "deletions": 92,
        "changes": 305,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/versionbits_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/test/versionbits_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/versionbits_tests.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -44,6 +44,12 @@ class TestConditionChecker : public AbstractThresholdConditionChecker\n     int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, paramsDummy, cache); }\n };\n \n+class TestDelayedActivationConditionChecker : public TestConditionChecker\n+{\n+public:\n+    int MinActivationHeight(const Consensus::Params& params) const override { return 15000; }\n+};\n+\n class TestAlwaysActiveConditionChecker : public TestConditionChecker\n {\n public:\n@@ -53,8 +59,7 @@ class TestAlwaysActiveConditionChecker : public TestConditionChecker\n class TestNeverActiveConditionChecker : public TestConditionChecker\n {\n public:\n-    int64_t BeginTime(const Consensus::Params& params) const override { return 0; }\n-    int64_t EndTime(const Consensus::Params& params) const override { return 1230768000; }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return Consensus::BIP9Deployment::NEVER_ACTIVE; }\n };\n \n #define CHECKERS 6\n@@ -68,6 +73,8 @@ class VersionBitsTester\n     // The first one performs all checks, the second only 50%, the third only 25%, etc...\n     // This is to test whether lack of cached information leads to the same results.\n     TestConditionChecker checker[CHECKERS];\n+    // Another 6 that assume delayed activation\n+    TestDelayedActivationConditionChecker checker_delayed[CHECKERS];\n     // Another 6 that assume always active activation\n     TestAlwaysActiveConditionChecker checker_always[CHECKERS];\n     // Another 6 that assume never active activation\n@@ -77,14 +84,18 @@ class VersionBitsTester\n     int num;\n \n public:\n-    VersionBitsTester() : num(0) {}\n+    VersionBitsTester() : num(1000) {}\n \n     VersionBitsTester& Reset() {\n+        // Have each group of tests be counted by the 1000s part, starting at 1000\n+        num = num - (num % 1000) + 1000;\n+\n         for (unsigned int i = 0; i < vpblock.size(); i++) {\n             delete vpblock[i];\n         }\n         for (unsigned int  i = 0; i < CHECKERS; i++) {\n             checker[i] = TestConditionChecker();\n+            checker_delayed[i] = TestDelayedActivationConditionChecker();\n             checker_always[i] = TestAlwaysActiveConditionChecker();\n             checker_never[i] = TestNeverActiveConditionChecker();\n         }\n@@ -100,7 +111,7 @@ class VersionBitsTester\n         while (vpblock.size() < height) {\n             CBlockIndex* pindex = new CBlockIndex();\n             pindex->nHeight = vpblock.size();\n-            pindex->pprev = vpblock.size() > 0 ? vpblock.back() : nullptr;\n+            pindex->pprev = Tip();\n             pindex->nTime = nTime;\n             pindex->nVersion = nVersion;\n             pindex->BuildSkip();\n@@ -109,34 +120,53 @@ class VersionBitsTester\n         return *this;\n     }\n \n-    VersionBitsTester& TestStateSinceHeight(int height) {\n+    VersionBitsTester& TestStateSinceHeight(int height)\n+    {\n+        return TestStateSinceHeight(height, height);\n+    }\n+\n+    VersionBitsTester& TestStateSinceHeight(int height, int height_delayed)\n+    {\n+        const CBlockIndex* tip = Tip();\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateSinceHeightFor(vpblock.empty() ? nullptr : vpblock.back()) == height, strprintf(\"Test %i for StateSinceHeight\", num));\n-                BOOST_CHECK_MESSAGE(checker_always[i].GetStateSinceHeightFor(vpblock.empty() ? nullptr : vpblock.back()) == 0, strprintf(\"Test %i for StateSinceHeight (always active)\", num));\n-\n-                // never active may go from DEFINED -> FAILED at the first period\n-                const auto never_height = checker_never[i].GetStateSinceHeightFor(vpblock.empty() ? nullptr : vpblock.back());\n-                BOOST_CHECK_MESSAGE(never_height == 0 || never_height == checker_never[i].Period(paramsDummy), strprintf(\"Test %i for StateSinceHeight (never active)\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateSinceHeightFor(tip) == height, strprintf(\"Test %i for StateSinceHeight\", num));\n+                BOOST_CHECK_MESSAGE(checker_delayed[i].GetStateSinceHeightFor(tip) == height_delayed, strprintf(\"Test %i for StateSinceHeight (delayed)\", num));\n+                BOOST_CHECK_MESSAGE(checker_always[i].GetStateSinceHeightFor(tip) == 0, strprintf(\"Test %i for StateSinceHeight (always active)\", num));\n+                BOOST_CHECK_MESSAGE(checker_never[i].GetStateSinceHeightFor(tip) == 0, strprintf(\"Test %i for StateSinceHeight (never active)\", num));\n             }\n         }\n         num++;\n         return *this;\n     }\n \n-    VersionBitsTester& TestState(ThresholdState exp) {\n+    VersionBitsTester& TestState(ThresholdState exp)\n+    {\n+        return TestState(exp, exp);\n+    }\n+\n+    VersionBitsTester& TestState(ThresholdState exp, ThresholdState exp_delayed)\n+    {\n+        if (exp != exp_delayed) {\n+            // only expected differences are that delayed stays in locked_in longer\n+            BOOST_CHECK_EQUAL(exp, ThresholdState::ACTIVE);\n+            BOOST_CHECK_EQUAL(exp_delayed, ThresholdState::LOCKED_IN);\n+        }\n+\n+        const CBlockIndex* pindex = Tip();\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                const CBlockIndex* pindex = vpblock.empty() ? nullptr : vpblock.back();\n                 ThresholdState got = checker[i].GetStateFor(pindex);\n+                ThresholdState got_delayed = checker_delayed[i].GetStateFor(pindex);\n                 ThresholdState got_always = checker_always[i].GetStateFor(pindex);\n                 ThresholdState got_never = checker_never[i].GetStateFor(pindex);\n                 // nHeight of the next block. If vpblock is empty, the next (ie first)\n                 // block should be the genesis block with nHeight == 0.\n                 int height = pindex == nullptr ? 0 : pindex->nHeight + 1;\n                 BOOST_CHECK_MESSAGE(got == exp, strprintf(\"Test %i for %s height %d (got %s)\", num, StateName(exp), height, StateName(got)));\n+                BOOST_CHECK_MESSAGE(got_delayed == exp_delayed, strprintf(\"Test %i for %s height %d (got %s; delayed case)\", num, StateName(exp_delayed), height, StateName(got_delayed)));\n                 BOOST_CHECK_MESSAGE(got_always == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE height %d (got %s; always active case)\", num, height, StateName(got_always)));\n-                BOOST_CHECK_MESSAGE(got_never == ThresholdState::DEFINED|| got_never == ThresholdState::FAILED, strprintf(\"Test %i for DEFINED/FAILED height %d (got %s; never active case)\", num, height, StateName(got_never)));\n+                BOOST_CHECK_MESSAGE(got_never == ThresholdState::FAILED, strprintf(\"Test %i for FAILED height %d (got %s; never active case)\", num, height, StateName(got_never)));\n             }\n         }\n         num++;\n@@ -149,26 +179,30 @@ class VersionBitsTester\n     VersionBitsTester& TestActive() { return TestState(ThresholdState::ACTIVE); }\n     VersionBitsTester& TestFailed() { return TestState(ThresholdState::FAILED); }\n \n-    CBlockIndex * Tip() { return vpblock.size() ? vpblock.back() : nullptr; }\n+    // non-delayed should be active; delayed should still be locked in\n+    VersionBitsTester& TestActiveDelayed() { return TestState(ThresholdState::ACTIVE, ThresholdState::LOCKED_IN); }\n+\n+    CBlockIndex* Tip() { return vpblock.empty() ? nullptr : vpblock.back(); }\n };\n \n BOOST_FIXTURE_TEST_SUITE(versionbits_tests, TestingSetup)\n \n BOOST_AUTO_TEST_CASE(versionbits_test)\n {\n     for (int i = 0; i < 64; i++) {\n-        // DEFINED -> FAILED\n+        // DEFINED -> STARTED after timeout reached -> FAILED\n         VersionBitsTester().TestDefined().TestStateSinceHeight(0)\n                            .Mine(1, TestTime(1), 0x100).TestDefined().TestStateSinceHeight(0)\n                            .Mine(11, TestTime(11), 0x100).TestDefined().TestStateSinceHeight(0)\n                            .Mine(989, TestTime(989), 0x100).TestDefined().TestStateSinceHeight(0)\n-                           .Mine(999, TestTime(20000), 0x100).TestDefined().TestStateSinceHeight(0)\n-                           .Mine(1000, TestTime(20000), 0x100).TestFailed().TestStateSinceHeight(1000)\n-                           .Mine(1999, TestTime(30001), 0x100).TestFailed().TestStateSinceHeight(1000)\n-                           .Mine(2000, TestTime(30002), 0x100).TestFailed().TestStateSinceHeight(1000)\n-                           .Mine(2001, TestTime(30003), 0x100).TestFailed().TestStateSinceHeight(1000)\n-                           .Mine(2999, TestTime(30004), 0x100).TestFailed().TestStateSinceHeight(1000)\n-                           .Mine(3000, TestTime(30005), 0x100).TestFailed().TestStateSinceHeight(1000)\n+                           .Mine(999, TestTime(20000), 0x100).TestDefined().TestStateSinceHeight(0) // Timeout and start time reached simultaneously\n+                           .Mine(1000, TestTime(20000), 0).TestStarted().TestStateSinceHeight(1000) // Hit started, stop signalling\n+                           .Mine(1999, TestTime(30001), 0).TestStarted().TestStateSinceHeight(1000)\n+                           .Mine(2000, TestTime(30002), 0x100).TestFailed().TestStateSinceHeight(2000) // Hit failed, start signalling again\n+                           .Mine(2001, TestTime(30003), 0x100).TestFailed().TestStateSinceHeight(2000)\n+                           .Mine(2999, TestTime(30004), 0x100).TestFailed().TestStateSinceHeight(2000)\n+                           .Mine(3000, TestTime(30005), 0x100).TestFailed().TestStateSinceHeight(2000)\n+                           .Mine(4000, TestTime(30006), 0x100).TestFailed().TestStateSinceHeight(2000)\n \n         // DEFINED -> STARTED -> FAILED\n                            .Reset().TestDefined().TestStateSinceHeight(0)\n@@ -180,19 +214,19 @@ BOOST_AUTO_TEST_CASE(versionbits_test)\n                            .Mine(3000, TestTime(20000), 0).TestFailed().TestStateSinceHeight(3000) // 50 old blocks (so 899 out of the past 1000)\n                            .Mine(4000, TestTime(20010), 0x100).TestFailed().TestStateSinceHeight(3000)\n \n-        // DEFINED -> STARTED -> FAILED while threshold reached\n+        // DEFINED -> STARTED -> LOCKEDIN after timeout reached -> ACTIVE\n                            .Reset().TestDefined().TestStateSinceHeight(0)\n                            .Mine(1, TestTime(1), 0).TestDefined().TestStateSinceHeight(0)\n                            .Mine(1000, TestTime(10000) - 1, 0x101).TestDefined().TestStateSinceHeight(0) // One second more and it would be defined\n                            .Mine(2000, TestTime(10000), 0x101).TestStarted().TestStateSinceHeight(2000) // So that's what happens the next period\n                            .Mine(2999, TestTime(30000), 0x100).TestStarted().TestStateSinceHeight(2000) // 999 new blocks\n-                           .Mine(3000, TestTime(30000), 0x100).TestFailed().TestStateSinceHeight(3000) // 1 new block (so 1000 out of the past 1000 are new)\n-                           .Mine(3999, TestTime(30001), 0).TestFailed().TestStateSinceHeight(3000)\n-                           .Mine(4000, TestTime(30002), 0).TestFailed().TestStateSinceHeight(3000)\n-                           .Mine(14333, TestTime(30003), 0).TestFailed().TestStateSinceHeight(3000)\n-                           .Mine(24000, TestTime(40000), 0).TestFailed().TestStateSinceHeight(3000)\n+                           .Mine(3000, TestTime(30000), 0x100).TestLockedIn().TestStateSinceHeight(3000) // 1 new block (so 1000 out of the past 1000 are new)\n+                           .Mine(3999, TestTime(30001), 0).TestLockedIn().TestStateSinceHeight(3000)\n+                           .Mine(4000, TestTime(30002), 0).TestActiveDelayed().TestStateSinceHeight(4000, 3000)\n+                           .Mine(14333, TestTime(30003), 0).TestActiveDelayed().TestStateSinceHeight(4000, 3000)\n+                           .Mine(24000, TestTime(40000), 0).TestActive().TestStateSinceHeight(4000, 15000)\n \n-        // DEFINED -> STARTED -> LOCKEDIN at the last minute -> ACTIVE\n+        // DEFINED -> STARTED -> LOCKEDIN before timeout -> ACTIVE\n                            .Reset().TestDefined()\n                            .Mine(1, TestTime(1), 0).TestDefined().TestStateSinceHeight(0)\n                            .Mine(1000, TestTime(10000) - 1, 0x101).TestDefined().TestStateSinceHeight(0) // One second more and it would be defined\n@@ -202,9 +236,10 @@ BOOST_AUTO_TEST_CASE(versionbits_test)\n                            .Mine(2999, TestTime(19999), 0x200).TestStarted().TestStateSinceHeight(2000) // 49 old blocks\n                            .Mine(3000, TestTime(29999), 0x200).TestLockedIn().TestStateSinceHeight(3000) // 1 old block (so 900 out of the past 1000)\n                            .Mine(3999, TestTime(30001), 0).TestLockedIn().TestStateSinceHeight(3000)\n-                           .Mine(4000, TestTime(30002), 0).TestActive().TestStateSinceHeight(4000)\n-                           .Mine(14333, TestTime(30003), 0).TestActive().TestStateSinceHeight(4000)\n-                           .Mine(24000, TestTime(40000), 0).TestActive().TestStateSinceHeight(4000)\n+                           .Mine(4000, TestTime(30002), 0).TestActiveDelayed().TestStateSinceHeight(4000, 3000) // delayed will not become active until height=15000\n+                           .Mine(14333, TestTime(30003), 0).TestActiveDelayed().TestStateSinceHeight(4000, 3000)\n+                           .Mine(15000, TestTime(40000), 0).TestActive().TestStateSinceHeight(4000, 15000)\n+                           .Mine(24000, TestTime(40000), 0).TestActive().TestStateSinceHeight(4000, 15000)\n \n         // DEFINED multiple periods -> STARTED multiple periods -> FAILED\n                            .Reset().TestDefined().TestStateSinceHeight(0)\n@@ -214,10 +249,16 @@ BOOST_AUTO_TEST_CASE(versionbits_test)\n                            .Mine(3000, TestTime(10000), 0).TestStarted().TestStateSinceHeight(3000)\n                            .Mine(4000, TestTime(10000), 0).TestStarted().TestStateSinceHeight(3000)\n                            .Mine(5000, TestTime(10000), 0).TestStarted().TestStateSinceHeight(3000)\n+                           .Mine(5999, TestTime(20000), 0).TestStarted().TestStateSinceHeight(3000)\n                            .Mine(6000, TestTime(20000), 0).TestFailed().TestStateSinceHeight(6000)\n-                           .Mine(7000, TestTime(20000), 0x100).TestFailed().TestStateSinceHeight(6000);\n+                           .Mine(7000, TestTime(20000), 0x100).TestFailed().TestStateSinceHeight(6000)\n+                           .Mine(24000, TestTime(20000), 0x100).TestFailed().TestStateSinceHeight(6000) // stay in FAILED no matter how much we signal\n+        ;\n     }\n+}\n \n+BOOST_AUTO_TEST_CASE(versionbits_sanity)\n+{\n     // Sanity checks of version bit deployments\n     const auto chainParams = CreateChainParams(*m_node.args, CBaseChainParams::MAIN);\n     const Consensus::Params &mainnetParams = chainParams->GetConsensus();\n@@ -226,6 +267,13 @@ BOOST_AUTO_TEST_CASE(versionbits_test)\n         // Make sure that no deployment tries to set an invalid bit.\n         BOOST_CHECK_EQUAL(bitmask & ~(uint32_t)VERSIONBITS_TOP_MASK, bitmask);\n \n+        // Check min_activation_height is on a retarget boundary\n+        BOOST_CHECK_EQUAL(mainnetParams.vDeployments[i].min_activation_height % mainnetParams.nMinerConfirmationWindow, 0);\n+        // Check min_activation_height is 0 for ALWAYS_ACTIVE and never active deployments\n+        if (mainnetParams.vDeployments[i].nStartTime == Consensus::BIP9Deployment::ALWAYS_ACTIVE || mainnetParams.vDeployments[i].nStartTime == Consensus::BIP9Deployment::NEVER_ACTIVE) {\n+            BOOST_CHECK_EQUAL(mainnetParams.vDeployments[i].min_activation_height, 0);\n+        }\n+\n         // Verify that the deployment windows of different deployment using the\n         // same bit are disjoint.\n         // This test may need modification at such time as a new deployment\n@@ -242,81 +290,118 @@ BOOST_AUTO_TEST_CASE(versionbits_test)\n     }\n }\n \n-BOOST_AUTO_TEST_CASE(versionbits_computeblockversion)\n+/** Check that ComputeBlockVersion will set the appropriate bit correctly */\n+static void check_computeblockversion(const Consensus::Params& params, Consensus::DeploymentPos dep)\n {\n-    // Check that ComputeBlockVersion will set the appropriate bit correctly\n-    // on mainnet.\n-    const auto chainParams = CreateChainParams(*m_node.args, CBaseChainParams::MAIN);\n-    const Consensus::Params &mainnetParams = chainParams->GetConsensus();\n+    // This implicitly uses versionbitscache, so clear it every time\n+    versionbitscache.Clear();\n+\n+    int64_t bit = params.vDeployments[dep].bit;\n+    int64_t nStartTime = params.vDeployments[dep].nStartTime;\n+    int64_t nTimeout = params.vDeployments[dep].nTimeout;\n+    int min_activation_height = params.vDeployments[dep].min_activation_height;\n+\n+    // should not be any signalling for first block\n+    BOOST_CHECK_EQUAL(ComputeBlockVersion(nullptr, params), VERSIONBITS_TOP_BITS);\n \n-    // Use the TESTDUMMY deployment for testing purposes.\n-    int64_t bit = mainnetParams.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit;\n-    int64_t nStartTime = mainnetParams.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime;\n-    int64_t nTimeout = mainnetParams.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout;\n+    // always/never active deployments shouldn't need to be tested further\n+    if (nStartTime == Consensus::BIP9Deployment::ALWAYS_ACTIVE) return;\n+    if (nStartTime == Consensus::BIP9Deployment::NEVER_ACTIVE) return;\n \n-    assert(nStartTime < nTimeout);\n+    BOOST_REQUIRE(nStartTime < nTimeout);\n+    BOOST_REQUIRE(nStartTime >= 0);\n+    BOOST_REQUIRE(nTimeout <= std::numeric_limits<uint32_t>::max() || nTimeout == Consensus::BIP9Deployment::NO_TIMEOUT);\n+    BOOST_REQUIRE(0 <= bit && bit < 32);\n+    BOOST_REQUIRE(((1 << bit) & VERSIONBITS_TOP_MASK) == 0);\n+    BOOST_REQUIRE(min_activation_height >= 0);\n+    BOOST_REQUIRE_EQUAL(min_activation_height % params.nMinerConfirmationWindow, 0);\n \n     // In the first chain, test that the bit is set by CBV until it has failed.\n     // In the second chain, test the bit is set by CBV while STARTED and\n     // LOCKED-IN, and then no longer set while ACTIVE.\n     VersionBitsTester firstChain, secondChain;\n \n-    // Start generating blocks before nStartTime\n-    int64_t nTime = nStartTime - 1;\n+    int64_t nTime = nStartTime;\n+\n+    const CBlockIndex *lastBlock = nullptr;\n \n     // Before MedianTimePast of the chain has crossed nStartTime, the bit\n     // should not be set.\n-    CBlockIndex *lastBlock = nullptr;\n-    lastBlock = firstChain.Mine(mainnetParams.nMinerConfirmationWindow, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-    BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit), 0);\n-\n-    // Mine more blocks (4 less than the adjustment period) at the old time, and check that CBV isn't setting the bit yet.\n-    for (uint32_t i = 1; i < mainnetParams.nMinerConfirmationWindow - 4; i++) {\n-        lastBlock = firstChain.Mine(mainnetParams.nMinerConfirmationWindow + i, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-        // This works because VERSIONBITS_LAST_OLD_BLOCK_VERSION happens\n-        // to be 4, and the bit we're testing happens to be bit 28.\n-        BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit), 0);\n-    }\n-    // Now mine 5 more blocks at the start time -- MTP should not have passed yet, so\n-    // CBV should still not yet set the bit.\n-    nTime = nStartTime;\n-    for (uint32_t i = mainnetParams.nMinerConfirmationWindow - 4; i <= mainnetParams.nMinerConfirmationWindow; i++) {\n-        lastBlock = firstChain.Mine(mainnetParams.nMinerConfirmationWindow + i, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-        BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit), 0);\n+    if (nTime == 0) {\n+        // since CBlockIndex::nTime is uint32_t we can't represent any\n+        // earlier time, so will transition from DEFINED to STARTED at the\n+        // end of the first period by mining blocks at nTime == 0\n+        lastBlock = firstChain.Mine(params.nMinerConfirmationWindow - 1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n+        BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, params) & (1<<bit), 0);\n+        lastBlock = firstChain.Mine(params.nMinerConfirmationWindow, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n+        BOOST_CHECK((ComputeBlockVersion(lastBlock, params) & (1<<bit)) != 0);\n+        // then we'll keep mining at nStartTime...\n+    } else {\n+        // use a time 1s earlier than start time to check we stay DEFINED\n+        --nTime;\n+\n+        // Start generating blocks before nStartTime\n+        lastBlock = firstChain.Mine(params.nMinerConfirmationWindow, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n+        BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, params) & (1<<bit), 0);\n+\n+        // Mine more blocks (4 less than the adjustment period) at the old time, and check that CBV isn't setting the bit yet.\n+        for (uint32_t i = 1; i < params.nMinerConfirmationWindow - 4; i++) {\n+            lastBlock = firstChain.Mine(params.nMinerConfirmationWindow + i, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n+            BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, params) & (1<<bit), 0);\n+        }\n+        // Now mine 5 more blocks at the start time -- MTP should not have passed yet, so\n+        // CBV should still not yet set the bit.\n+        nTime = nStartTime;\n+        for (uint32_t i = params.nMinerConfirmationWindow - 4; i <= params.nMinerConfirmationWindow; i++) {\n+            lastBlock = firstChain.Mine(params.nMinerConfirmationWindow + i, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n+            BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, params) & (1<<bit), 0);\n+        }\n+        // Next we will advance to the next period and transition to STARTED,\n     }\n \n-    // Advance to the next period and transition to STARTED,\n-    lastBlock = firstChain.Mine(mainnetParams.nMinerConfirmationWindow * 3, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n+    lastBlock = firstChain.Mine(params.nMinerConfirmationWindow * 3, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n     // so ComputeBlockVersion should now set the bit,\n-    BOOST_CHECK((ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit)) != 0);\n+    BOOST_CHECK((ComputeBlockVersion(lastBlock, params) & (1<<bit)) != 0);\n     // and should also be using the VERSIONBITS_TOP_BITS.\n-    BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & VERSIONBITS_TOP_MASK, VERSIONBITS_TOP_BITS);\n+    BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, params) & VERSIONBITS_TOP_MASK, VERSIONBITS_TOP_BITS);\n \n     // Check that ComputeBlockVersion will set the bit until nTimeout\n     nTime += 600;\n-    uint32_t blocksToMine = mainnetParams.nMinerConfirmationWindow * 2; // test blocks for up to 2 time periods\n-    uint32_t nHeight = mainnetParams.nMinerConfirmationWindow * 3;\n+    uint32_t blocksToMine = params.nMinerConfirmationWindow * 2; // test blocks for up to 2 time periods\n+    uint32_t nHeight = params.nMinerConfirmationWindow * 3;\n     // These blocks are all before nTimeout is reached.\n     while (nTime < nTimeout && blocksToMine > 0) {\n         lastBlock = firstChain.Mine(nHeight+1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-        BOOST_CHECK((ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit)) != 0);\n-        BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & VERSIONBITS_TOP_MASK, VERSIONBITS_TOP_BITS);\n+        BOOST_CHECK((ComputeBlockVersion(lastBlock, params) & (1<<bit)) != 0);\n+        BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, params) & VERSIONBITS_TOP_MASK, VERSIONBITS_TOP_BITS);\n         blocksToMine--;\n         nTime += 600;\n         nHeight += 1;\n     }\n \n-    nTime = nTimeout;\n-    // FAILED is only triggered at the end of a period, so CBV should be setting\n-    // the bit until the period transition.\n-    for (uint32_t i = 0; i < mainnetParams.nMinerConfirmationWindow - 1; i++) {\n+    if (nTimeout != Consensus::BIP9Deployment::NO_TIMEOUT) {\n+        // can reach any nTimeout other than NO_TIMEOUT due to earlier BOOST_REQUIRE\n+\n+        nTime = nTimeout;\n+\n+        // finish the last period before we start timing out\n+        while (nHeight % params.nMinerConfirmationWindow != 0) {\n+            lastBlock = firstChain.Mine(nHeight+1, nTime - 1, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n+            BOOST_CHECK((ComputeBlockVersion(lastBlock, params) & (1<<bit)) != 0);\n+            nHeight += 1;\n+        }\n+\n+        // FAILED is only triggered at the end of a period, so CBV should be setting\n+        // the bit until the period transition.\n+        for (uint32_t i = 0; i < params.nMinerConfirmationWindow - 1; i++) {\n+            lastBlock = firstChain.Mine(nHeight+1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n+            BOOST_CHECK((ComputeBlockVersion(lastBlock, params) & (1<<bit)) != 0);\n+            nHeight += 1;\n+        }\n+        // The next block should trigger no longer setting the bit.\n         lastBlock = firstChain.Mine(nHeight+1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-        BOOST_CHECK((ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit)) != 0);\n-        nHeight += 1;\n+        BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, params) & (1<<bit), 0);\n     }\n-    // The next block should trigger no longer setting the bit.\n-    lastBlock = firstChain.Mine(nHeight+1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-    BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit), 0);\n \n     // On a new chain:\n     // verify that the bit will be set after lock-in, and then stop being set\n@@ -325,26 +410,62 @@ BOOST_AUTO_TEST_CASE(versionbits_computeblockversion)\n \n     // Mine one period worth of blocks, and check that the bit will be on for the\n     // next period.\n-    lastBlock = secondChain.Mine(mainnetParams.nMinerConfirmationWindow, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-    BOOST_CHECK((ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit)) != 0);\n+    lastBlock = secondChain.Mine(params.nMinerConfirmationWindow, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n+    BOOST_CHECK((ComputeBlockVersion(lastBlock, params) & (1<<bit)) != 0);\n \n     // Mine another period worth of blocks, signaling the new bit.\n-    lastBlock = secondChain.Mine(mainnetParams.nMinerConfirmationWindow * 2, nTime, VERSIONBITS_TOP_BITS | (1<<bit)).Tip();\n+    lastBlock = secondChain.Mine(params.nMinerConfirmationWindow * 2, nTime, VERSIONBITS_TOP_BITS | (1<<bit)).Tip();\n     // After one period of setting the bit on each block, it should have locked in.\n     // We keep setting the bit for one more period though, until activation.\n-    BOOST_CHECK((ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit)) != 0);\n+    BOOST_CHECK((ComputeBlockVersion(lastBlock, params) & (1<<bit)) != 0);\n \n     // Now check that we keep mining the block until the end of this period, and\n     // then stop at the beginning of the next period.\n-    lastBlock = secondChain.Mine((mainnetParams.nMinerConfirmationWindow * 3) - 1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-    BOOST_CHECK((ComputeBlockVersion(lastBlock, mainnetParams) & (1 << bit)) != 0);\n-    lastBlock = secondChain.Mine(mainnetParams.nMinerConfirmationWindow * 3, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-    BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit), 0);\n-\n-    // Finally, verify that after a soft fork has activated, CBV no longer uses\n-    // VERSIONBITS_LAST_OLD_BLOCK_VERSION.\n-    //BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & VERSIONBITS_TOP_MASK, VERSIONBITS_TOP_BITS);\n+    lastBlock = secondChain.Mine((params.nMinerConfirmationWindow * 3) - 1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n+    BOOST_CHECK((ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);\n+    lastBlock = secondChain.Mine(params.nMinerConfirmationWindow * 3, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n+\n+    if (lastBlock->nHeight + 1 < min_activation_height) {\n+        // check signalling continues while min_activation_height is not reached\n+        lastBlock = secondChain.Mine(min_activation_height - 1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n+        BOOST_CHECK((ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);\n+        // then reach min_activation_height, which was already REQUIRE'd to start a new period\n+        lastBlock = secondChain.Mine(min_activation_height, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n+    }\n+\n+    // Check that we don't signal after activation\n+    BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, params) & (1<<bit), 0);\n }\n \n+BOOST_AUTO_TEST_CASE(versionbits_computeblockversion)\n+{\n+    // check that any deployment on any chain can conceivably reach both\n+    // ACTIVE and FAILED states in roughly the way we expect\n+    for (const auto& chain_name : {CBaseChainParams::MAIN, CBaseChainParams::TESTNET, CBaseChainParams::SIGNET, CBaseChainParams::REGTEST}) {\n+        const auto chainParams = CreateChainParams(*m_node.args, chain_name);\n+        for (int i = 0; i < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++i) {\n+            check_computeblockversion(chainParams->GetConsensus(), static_cast<Consensus::DeploymentPos>(i));\n+        }\n+    }\n+\n+    {\n+        // Use regtest/testdummy to ensure we always exercise some\n+        // deployment that's not always/never active\n+        ArgsManager args;\n+        args.ForceSetArg(\"-vbparams\", \"testdummy:1199145601:1230767999\"); // January 1, 2008 - December 31, 2008\n+        const auto chainParams = CreateChainParams(args, CBaseChainParams::REGTEST);\n+        check_computeblockversion(chainParams->GetConsensus(), Consensus::DEPLOYMENT_TESTDUMMY);\n+    }\n+\n+    {\n+        // Use regtest/testdummy to ensure we always exercise the\n+        // min_activation_height test, even if we're not using that in a\n+        // live deployment\n+        ArgsManager args;\n+        args.ForceSetArg(\"-vbparams\", \"testdummy:1199145601:1230767999:403200\"); // January 1, 2008 - December 31, 2008, min act height 403200\n+        const auto chainParams = CreateChainParams(args, CBaseChainParams::REGTEST);\n+        check_computeblockversion(chainParams->GetConsensus(), Consensus::DEPLOYMENT_TESTDUMMY);\n+    }\n+}\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "332cb581b87a242248da16695d0aac78dcf6e81e",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 153,
        "changes": 159,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -21,6 +21,7 @@\n #include <index/txindex.h>\n #include <logging.h>\n #include <logging/timer.h>\n+#include <node/blockstorage.h>\n #include <node/coinstats.h>\n #include <node/ui_interface.h>\n #include <policy/policy.h>\n@@ -1148,123 +1149,6 @@ CTransactionRef GetTransaction(const CBlockIndex* const block_index, const CTxMe\n     return nullptr;\n }\n \n-//////////////////////////////////////////////////////////////////////////////\n-//\n-// CBlock and CBlockIndex\n-//\n-\n-static bool WriteBlockToDisk(const CBlock& block, FlatFilePos& pos, const CMessageHeader::MessageStartChars& messageStart)\n-{\n-    // Open history file to append\n-    CAutoFile fileout(OpenBlockFile(pos), SER_DISK, CLIENT_VERSION);\n-    if (fileout.IsNull())\n-        return error(\"WriteBlockToDisk: OpenBlockFile failed\");\n-\n-    // Write index header\n-    unsigned int nSize = GetSerializeSize(block, fileout.GetVersion());\n-    fileout << messageStart << nSize;\n-\n-    // Write block\n-    long fileOutPos = ftell(fileout.Get());\n-    if (fileOutPos < 0)\n-        return error(\"WriteBlockToDisk: ftell failed\");\n-    pos.nPos = (unsigned int)fileOutPos;\n-    fileout << block;\n-\n-    return true;\n-}\n-\n-bool ReadBlockFromDisk(CBlock& block, const FlatFilePos& pos, const Consensus::Params& consensusParams)\n-{\n-    block.SetNull();\n-\n-    // Open history file to read\n-    CAutoFile filein(OpenBlockFile(pos, true), SER_DISK, CLIENT_VERSION);\n-    if (filein.IsNull())\n-        return error(\"ReadBlockFromDisk: OpenBlockFile failed for %s\", pos.ToString());\n-\n-    // Read block\n-    try {\n-        filein >> block;\n-    }\n-    catch (const std::exception& e) {\n-        return error(\"%s: Deserialize or I/O error - %s at %s\", __func__, e.what(), pos.ToString());\n-    }\n-\n-    // Check the header\n-    if (!CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))\n-        return error(\"ReadBlockFromDisk: Errors in block header at %s\", pos.ToString());\n-\n-    // Signet only: check block solution\n-    if (consensusParams.signet_blocks && !CheckSignetBlockSolution(block, consensusParams)) {\n-        return error(\"ReadBlockFromDisk: Errors in block solution at %s\", pos.ToString());\n-    }\n-\n-    return true;\n-}\n-\n-bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex, const Consensus::Params& consensusParams)\n-{\n-    FlatFilePos blockPos;\n-    {\n-        LOCK(cs_main);\n-        blockPos = pindex->GetBlockPos();\n-    }\n-\n-    if (!ReadBlockFromDisk(block, blockPos, consensusParams))\n-        return false;\n-    if (block.GetHash() != pindex->GetBlockHash())\n-        return error(\"ReadBlockFromDisk(CBlock&, CBlockIndex*): GetHash() doesn't match index for %s at %s\",\n-                pindex->ToString(), pindex->GetBlockPos().ToString());\n-    return true;\n-}\n-\n-bool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const FlatFilePos& pos, const CMessageHeader::MessageStartChars& message_start)\n-{\n-    FlatFilePos hpos = pos;\n-    hpos.nPos -= 8; // Seek back 8 bytes for meta header\n-    CAutoFile filein(OpenBlockFile(hpos, true), SER_DISK, CLIENT_VERSION);\n-    if (filein.IsNull()) {\n-        return error(\"%s: OpenBlockFile failed for %s\", __func__, pos.ToString());\n-    }\n-\n-    try {\n-        CMessageHeader::MessageStartChars blk_start;\n-        unsigned int blk_size;\n-\n-        filein >> blk_start >> blk_size;\n-\n-        if (memcmp(blk_start, message_start, CMessageHeader::MESSAGE_START_SIZE)) {\n-            return error(\"%s: Block magic mismatch for %s: %s versus expected %s\", __func__, pos.ToString(),\n-                    HexStr(blk_start),\n-                    HexStr(message_start));\n-        }\n-\n-        if (blk_size > MAX_SIZE) {\n-            return error(\"%s: Block data is larger than maximum deserialization size for %s: %s versus %s\", __func__, pos.ToString(),\n-                    blk_size, MAX_SIZE);\n-        }\n-\n-        block.resize(blk_size); // Zeroing of memory is intentional here\n-        filein.read((char*)block.data(), blk_size);\n-    } catch(const std::exception& e) {\n-        return error(\"%s: Read from block file failed: %s for %s\", __func__, e.what(), pos.ToString());\n-    }\n-\n-    return true;\n-}\n-\n-bool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const CBlockIndex* pindex, const CMessageHeader::MessageStartChars& message_start)\n-{\n-    FlatFilePos block_pos;\n-    {\n-        LOCK(cs_main);\n-        block_pos = pindex->GetBlockPos();\n-    }\n-\n-    return ReadRawBlockFromDisk(block, block_pos, message_start);\n-}\n-\n CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams)\n {\n     int halvings = nHeight / consensusParams.nSubsidyHalvingInterval;\n@@ -1636,19 +1520,6 @@ bool UndoReadFromDisk(CBlockUndo& blockundo, const CBlockIndex* pindex)\n     return true;\n }\n \n-/** Abort with a message */\n-static bool AbortNode(const std::string& strMessage, bilingual_str user_message = bilingual_str())\n-{\n-    SetMiscWarning(Untranslated(strMessage));\n-    LogPrintf(\"*** %s\\n\", strMessage);\n-    if (user_message.empty()) {\n-        user_message = _(\"A fatal internal error occurred, see debug.log for details\");\n-    }\n-    AbortError(user_message);\n-    StartShutdown();\n-    return false;\n-}\n-\n static bool AbortNode(BlockValidationState& state, const std::string& strMessage, const bilingual_str& userMessage = bilingual_str())\n {\n     AbortNode(strMessage, userMessage);\n@@ -3231,7 +3102,8 @@ void CChainState::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pi\n     }\n }\n \n-static bool FindBlockPos(FlatFilePos &pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown = false)\n+// TODO move to blockstorage\n+bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown = false)\n {\n     LOCK(cs_LastBlockFile);\n \n@@ -3708,25 +3580,6 @@ bool ChainstateManager::ProcessNewBlockHeaders(const std::vector<CBlockHeader>&\n     return true;\n }\n \n-/** Store block on disk. If dbp is non-nullptr, the file is known to already reside on disk */\n-static FlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const CChainParams& chainparams, const FlatFilePos* dbp) {\n-    unsigned int nBlockSize = ::GetSerializeSize(block, CLIENT_VERSION);\n-    FlatFilePos blockPos;\n-    if (dbp != nullptr)\n-        blockPos = *dbp;\n-    if (!FindBlockPos(blockPos, nBlockSize+8, nHeight, active_chain, block.GetBlockTime(), dbp != nullptr)) {\n-        error(\"%s: FindBlockPos failed\", __func__);\n-        return FlatFilePos();\n-    }\n-    if (dbp == nullptr) {\n-        if (!WriteBlockToDisk(block, blockPos, chainparams.MessageStart())) {\n-            AbortNode(\"Failed to write block\");\n-            return FlatFilePos();\n-        }\n-    }\n-    return blockPos;\n-}\n-\n /** Store block on disk. If dbp is non-nullptr, the file is known to already reside on disk */\n bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock)\n {\n@@ -5345,12 +5198,12 @@ bool ChainstateManager::PopulateAndValidateSnapshot(\n     while (coins_left > 0) {\n         try {\n             coins_file >> outpoint;\n+            coins_file >> coin;\n         } catch (const std::ios_base::failure&) {\n-            LogPrintf(\"[snapshot] bad snapshot - no coins left after deserializing %d coins\\n\",\n-                coins_count - coins_left);\n+            LogPrintf(\"[snapshot] bad snapshot format or truncated snapshot after deserializing %d coins\\n\",\n+                      coins_count - coins_left);\n             return false;\n         }\n-        coins_file >> coin;\n         coins_cache.EmplaceCoinInternalDANGER(std::move(outpoint), std::move(coin));\n \n         --coins_left;"
      },
      {
        "sha": "de121ab46a554594a62cb09f925aba0b4eb2ddea",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 9,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -35,6 +35,7 @@\n #include <set>\n #include <stdint.h>\n #include <string>\n+#include <thread>\n #include <utility>\n #include <vector>\n \n@@ -299,15 +300,6 @@ class CScriptCheck\n /** Initializes the script-execution cache */\n void InitScriptExecutionCache();\n \n-\n-/** Functions for disk access for blocks */\n-bool ReadBlockFromDisk(CBlock& block, const FlatFilePos& pos, const Consensus::Params& consensusParams);\n-bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex, const Consensus::Params& consensusParams);\n-bool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const FlatFilePos& pos, const CMessageHeader::MessageStartChars& message_start);\n-bool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const CBlockIndex* pindex, const CMessageHeader::MessageStartChars& message_start);\n-\n-bool UndoReadFromDisk(CBlockUndo& blockundo, const CBlockIndex* pindex);\n-\n /** Functions for validating blocks and updating the block tree */\n \n /** Context-independent validity checks */\n@@ -869,6 +861,7 @@ class ChainstateManager\n     friend CChain& ChainActive();\n \n public:\n+    std::thread m_load_block;\n     //! A single BlockManager instance is shared across each constructed\n     //! chainstate to avoid duplicating block metadata.\n     BlockManager m_blockman GUARDED_BY(::cs_main);"
      },
      {
        "sha": "df2ec4e056ed7d3a938bcada3343f140ab90d429",
        "filename": "src/versionbits.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 10,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/versionbits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/versionbits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -9,6 +9,7 @@ ThresholdState AbstractThresholdConditionChecker::GetStateFor(const CBlockIndex*\n {\n     int nPeriod = Period(params);\n     int nThreshold = Threshold(params);\n+    int min_activation_height = MinActivationHeight(params);\n     int64_t nTimeStart = BeginTime(params);\n     int64_t nTimeTimeout = EndTime(params);\n \n@@ -17,6 +18,11 @@ ThresholdState AbstractThresholdConditionChecker::GetStateFor(const CBlockIndex*\n         return ThresholdState::ACTIVE;\n     }\n \n+    // Check if this deployment is never active.\n+    if (nTimeStart == Consensus::BIP9Deployment::NEVER_ACTIVE) {\n+        return ThresholdState::FAILED;\n+    }\n+\n     // A block's state is always the same as that of the first of its period, so it is computed based on a pindexPrev whose height equals a multiple of nPeriod - 1.\n     if (pindexPrev != nullptr) {\n         pindexPrev = pindexPrev->GetAncestor(pindexPrev->nHeight - ((pindexPrev->nHeight + 1) % nPeriod));\n@@ -51,18 +57,12 @@ ThresholdState AbstractThresholdConditionChecker::GetStateFor(const CBlockIndex*\n \n         switch (state) {\n             case ThresholdState::DEFINED: {\n-                if (pindexPrev->GetMedianTimePast() >= nTimeTimeout) {\n-                    stateNext = ThresholdState::FAILED;\n-                } else if (pindexPrev->GetMedianTimePast() >= nTimeStart) {\n+                if (pindexPrev->GetMedianTimePast() >= nTimeStart) {\n                     stateNext = ThresholdState::STARTED;\n                 }\n                 break;\n             }\n             case ThresholdState::STARTED: {\n-                if (pindexPrev->GetMedianTimePast() >= nTimeTimeout) {\n-                    stateNext = ThresholdState::FAILED;\n-                    break;\n-                }\n                 // We need to count\n                 const CBlockIndex* pindexCount = pindexPrev;\n                 int count = 0;\n@@ -74,12 +74,16 @@ ThresholdState AbstractThresholdConditionChecker::GetStateFor(const CBlockIndex*\n                 }\n                 if (count >= nThreshold) {\n                     stateNext = ThresholdState::LOCKED_IN;\n+                } else if (pindexPrev->GetMedianTimePast() >= nTimeTimeout) {\n+                    stateNext = ThresholdState::FAILED;\n                 }\n                 break;\n             }\n             case ThresholdState::LOCKED_IN: {\n-                // Always progresses into ACTIVE.\n-                stateNext = ThresholdState::ACTIVE;\n+                // Progresses into ACTIVE provided activation height will have been reached.\n+                if (pindexPrev->nHeight + 1 >= min_activation_height) {\n+                    stateNext = ThresholdState::ACTIVE;\n+                }\n                 break;\n             }\n             case ThresholdState::FAILED:\n@@ -126,7 +130,7 @@ BIP9Stats AbstractThresholdConditionChecker::GetStateStatisticsFor(const CBlockI\n int AbstractThresholdConditionChecker::GetStateSinceHeightFor(const CBlockIndex* pindexPrev, const Consensus::Params& params, ThresholdConditionCache& cache) const\n {\n     int64_t start_time = BeginTime(params);\n-    if (start_time == Consensus::BIP9Deployment::ALWAYS_ACTIVE) {\n+    if (start_time == Consensus::BIP9Deployment::ALWAYS_ACTIVE || start_time == Consensus::BIP9Deployment::NEVER_ACTIVE) {\n         return 0;\n     }\n \n@@ -170,6 +174,7 @@ class VersionBitsConditionChecker : public AbstractThresholdConditionChecker {\n protected:\n     int64_t BeginTime(const Consensus::Params& params) const override { return params.vDeployments[id].nStartTime; }\n     int64_t EndTime(const Consensus::Params& params) const override { return params.vDeployments[id].nTimeout; }\n+    int MinActivationHeight(const Consensus::Params& params) const override { return params.vDeployments[id].min_activation_height; }\n     int Period(const Consensus::Params& params) const override { return params.nMinerConfirmationWindow; }\n     int Threshold(const Consensus::Params& params) const override { return params.nRuleChangeActivationThreshold; }\n "
      },
      {
        "sha": "634a848ef58f5a9b8501eafdb0dea5a90ebc354e",
        "filename": "src/versionbits.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/versionbits.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/versionbits.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.h?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -25,7 +25,7 @@ static const int32_t VERSIONBITS_NUM_BITS = 29;\n enum class ThresholdState {\n     DEFINED,   // First state that each softfork starts out as. The genesis block is by definition in this state for each deployment.\n     STARTED,   // For blocks past the starttime.\n-    LOCKED_IN, // For one retarget period after the first retarget period with STARTED blocks of which at least threshold have the associated bit set in nVersion.\n+    LOCKED_IN, // For at least one retarget period after the first retarget period with STARTED blocks of which at least threshold have the associated bit set in nVersion, until min_activation_height is reached.\n     ACTIVE,    // For all blocks after the LOCKED_IN retarget period (final state)\n     FAILED,    // For all blocks once the first retarget period after the timeout time is hit, if LOCKED_IN wasn't already reached (final state)\n };\n@@ -57,6 +57,7 @@ class AbstractThresholdConditionChecker {\n     virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const =0;\n     virtual int64_t BeginTime(const Consensus::Params& params) const =0;\n     virtual int64_t EndTime(const Consensus::Params& params) const =0;\n+    virtual int MinActivationHeight(const Consensus::Params& params) const { return 0; }\n     virtual int Period(const Consensus::Params& params) const =0;\n     virtual int Threshold(const Consensus::Params& params) const =0;\n "
      },
      {
        "sha": "fe2c810afa71a438a7333dc7fe199f3889003d63",
        "filename": "src/wallet/external_signer_scriptpubkeyman.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/wallet/external_signer_scriptpubkeyman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/wallet/external_signer_scriptpubkeyman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/external_signer_scriptpubkeyman.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -3,9 +3,16 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <chainparams.h>\n-#include <wallet/external_signer.h>\n+#include <external_signer.h>\n #include <wallet/external_signer_scriptpubkeyman.h>\n \n+#include <iostream>\n+#include <memory>\n+#include <stdexcept>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n #ifdef ENABLE_EXTERNAL_SIGNER\n \n bool ExternalSignerScriptPubKeyMan::SetupDescriptor(std::unique_ptr<Descriptor> desc)"
      },
      {
        "sha": "1786958912c873b10d0b186d100b059841047f37",
        "filename": "src/wallet/external_signer_scriptpubkeyman.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/wallet/external_signer_scriptpubkeyman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/wallet/external_signer_scriptpubkeyman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/external_signer_scriptpubkeyman.h?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -8,6 +8,8 @@\n #ifdef ENABLE_EXTERNAL_SIGNER\n #include <wallet/scriptpubkeyman.h>\n \n+#include <memory>\n+\n class ExternalSignerScriptPubKeyMan : public DescriptorScriptPubKeyMan\n {\n   public:"
      },
      {
        "sha": "0dc220b6fd795cd9ea4bbe71317208e7bb90bf92",
        "filename": "src/wallet/init.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/wallet/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/wallet/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/init.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -82,6 +82,12 @@ void WalletInit::AddWalletOptions(ArgsManager& argsman) const\n     argsman.AddHiddenArgs({\"-dblogsize\", \"-flushwallet\", \"-privdb\"});\n #endif\n \n+#ifdef USE_SQLITE\n+    argsman.AddArg(\"-unsafesqlitesync\", \"Set SQLite synchronous=OFF to disable waiting for the database to sync to disk. This is unsafe and can cause data loss and corruption. This option is only used by tests to improve their performance (default: false)\", ArgsManager::ALLOW_BOOL | ArgsManager::DEBUG_ONLY, OptionsCategory::WALLET_DEBUG_TEST);\n+#else\n+    argsman.AddHiddenArgs({\"-unsafesqlitesync\"});\n+#endif\n+\n     argsman.AddArg(\"-walletrejectlongchains\", strprintf(\"Wallet will not create transactions that violate mempool chain limits (default: %u)\", DEFAULT_WALLET_REJECT_LONG_CHAINS), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::WALLET_DEBUG_TEST);\n \n     argsman.AddHiddenArgs({\"-zapwallettxes\"});"
      },
      {
        "sha": "64ce09d1d126660e764bb2aaae6665f58d4f2fc3",
        "filename": "src/wallet/interfaces.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 12,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/wallet/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/wallet/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/interfaces.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -22,7 +22,6 @@\n #include <wallet/fees.h>\n #include <wallet/ismine.h>\n #include <wallet/load.h>\n-#include <wallet/rpcsigner.h>\n #include <wallet/rpcwallet.h>\n #include <wallet/wallet.h>\n \n@@ -520,17 +519,6 @@ class WalletClientImpl : public WalletClient\n             }, command.argNames, command.unique_id);\n             m_rpc_handlers.emplace_back(m_context.chain->handleRpc(m_rpc_commands.back()));\n         }\n-\n-#ifdef ENABLE_EXTERNAL_SIGNER\n-        for (const CRPCCommand& command : GetSignerRPCCommands()) {\n-            m_rpc_commands.emplace_back(command.category, command.name, [this, &command](const JSONRPCRequest& request, UniValue& result, bool last_handler) {\n-                JSONRPCRequest wallet_request = request;\n-                wallet_request.context = &m_context;\n-                return command.actor(wallet_request, result, last_handler);\n-            }, command.argNames, command.unique_id);\n-            m_rpc_handlers.emplace_back(m_context.chain->handleRpc(m_rpc_commands.back()));\n-        }\n-#endif\n     }\n     bool verify() override { return VerifyWallets(*m_context.chain); }\n     bool load() override { return LoadWallets(*m_context.chain); }"
      },
      {
        "sha": "696c74d6659e9a895aa281dd47a9b2f6d9aef89a",
        "filename": "src/wallet/rpcsigner.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 108,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e94414b77bcdcac3110d41a6ad56fbb8732887b9/src/wallet/rpcsigner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e94414b77bcdcac3110d41a6ad56fbb8732887b9/src/wallet/rpcsigner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcsigner.cpp?ref=e94414b77bcdcac3110d41a6ad56fbb8732887b9",
        "patch": "@@ -1,108 +0,0 @@\n-// Copyright (c) 2018-2021 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <chainparamsbase.h>\n-#include <key_io.h>\n-#include <rpc/server.h>\n-#include <rpc/util.h>\n-#include <util/strencodings.h>\n-#include <wallet/rpcsigner.h>\n-#include <wallet/rpcwallet.h>\n-#include <wallet/wallet.h>\n-\n-#ifdef ENABLE_EXTERNAL_SIGNER\n-\n-static RPCHelpMan enumeratesigners()\n-{\n-    return RPCHelpMan{\n-        \"enumeratesigners\",\n-        \"Returns a list of external signers from -signer.\",\n-        {},\n-        RPCResult{\n-            RPCResult::Type::OBJ, \"\", \"\",\n-            {\n-                {RPCResult::Type::ARR, \"signers\", /* optional */ false, \"\",\n-                {\n-                    {RPCResult::Type::STR_HEX, \"masterkeyfingerprint\", \"Master key fingerprint\"},\n-                    {RPCResult::Type::STR, \"name\", \"Device name\"},\n-                },\n-                }\n-            }\n-        },\n-        RPCExamples{\"\"},\n-        [](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue {\n-            const std::string command = gArgs.GetArg(\"-signer\", \"\");\n-            if (command == \"\") throw JSONRPCError(RPC_WALLET_ERROR, \"Error: restart bitcoind with -signer=<cmd>\");\n-            std::string chain = gArgs.GetChainName();\n-            UniValue signers_res = UniValue::VARR;\n-            try {\n-                std::vector<ExternalSigner> signers;\n-                ExternalSigner::Enumerate(command, signers, chain);\n-                for (ExternalSigner signer : signers) {\n-                    UniValue signer_res = UniValue::VOBJ;\n-                    signer_res.pushKV(\"fingerprint\", signer.m_fingerprint);\n-                    signer_res.pushKV(\"name\", signer.m_name);\n-                    signers_res.push_back(signer_res);\n-                }\n-            } catch (const ExternalSignerException& e) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, e.what());\n-            }\n-            UniValue result(UniValue::VOBJ);\n-            result.pushKV(\"signers\", signers_res);\n-            return result;\n-        }\n-    };\n-}\n-\n-static RPCHelpMan signerdisplayaddress()\n-{\n-    return RPCHelpMan{\n-        \"signerdisplayaddress\",\n-        \"Display address on an external signer for verification.\\n\",\n-        {\n-            {\"address\",     RPCArg::Type::STR, RPCArg::Optional::NO, /* default_val */ \"\", \"bitcoin address to display\"},\n-        },\n-        RPCResult{RPCResult::Type::NONE,\"\",\"\"},\n-        RPCExamples{\"\"},\n-        [](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue {\n-            std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-            if (!wallet) return NullUniValue;\n-            CWallet* const pwallet = wallet.get();\n-\n-            LOCK(pwallet->cs_wallet);\n-\n-            CTxDestination dest = DecodeDestination(request.params[0].get_str());\n-\n-            // Make sure the destination is valid\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-\n-            if (!pwallet->DisplayAddress(dest)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Failed to display address\");\n-            }\n-\n-            UniValue result(UniValue::VOBJ);\n-            result.pushKV(\"address\", request.params[0].get_str());\n-            return result;\n-        }\n-    };\n-}\n-\n-Span<const CRPCCommand> GetSignerRPCCommands()\n-{\n-\n-// clang-format off\n-static const CRPCCommand commands[] =\n-{ // category              actor (function)\n-  // --------------------- ------------------------\n-  { \"signer\",              &enumeratesigners,      },\n-  { \"signer\",              &signerdisplayaddress,  },\n-};\n-// clang-format on\n-    return MakeSpan(commands);\n-}\n-\n-\n-#endif // ENABLE_EXTERNAL_SIGNER"
      },
      {
        "sha": "f3ab83c4288f808f4fc1e62737fd9631de0cf568",
        "filename": "src/wallet/rpcsigner.h",
        "status": "removed",
        "additions": 0,
        "deletions": 25,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e94414b77bcdcac3110d41a6ad56fbb8732887b9/src/wallet/rpcsigner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e94414b77bcdcac3110d41a6ad56fbb8732887b9/src/wallet/rpcsigner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcsigner.h?ref=e94414b77bcdcac3110d41a6ad56fbb8732887b9",
        "patch": "@@ -1,25 +0,0 @@\n-// Copyright (c) 2018-2021 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_WALLET_RPCSIGNER_H\n-#define BITCOIN_WALLET_RPCSIGNER_H\n-\n-#include <span.h>\n-#include <util/system.h>\n-#include <vector>\n-\n-#ifdef ENABLE_EXTERNAL_SIGNER\n-\n-class CRPCCommand;\n-\n-namespace interfaces {\n-class Chain;\n-class Handler;\n-}\n-\n-Span<const CRPCCommand> GetSignerRPCCommands();\n-\n-#endif // ENABLE_EXTERNAL_SIGNER\n-\n-#endif //BITCOIN_WALLET_RPCSIGNER_H"
      },
      {
        "sha": "76460f106b7d6d8e8075ea36edaf80a9b21f3a7f",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 1,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -2750,7 +2750,7 @@ static RPCHelpMan createwallet()\n #ifdef ENABLE_EXTERNAL_SIGNER\n         flags |= WALLET_FLAG_EXTERNAL_SIGNER;\n #else\n-        throw JSONRPCError(RPC_WALLET_ERROR, \"Configure with --enable-external-signer to use this\");\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Compiled without external signing support (required for external signing)\");\n #endif\n     }\n \n@@ -4526,6 +4526,48 @@ static RPCHelpMan upgradewallet()\n     };\n }\n \n+#ifdef ENABLE_EXTERNAL_SIGNER\n+static RPCHelpMan walletdisplayaddress()\n+{\n+    return RPCHelpMan{\"walletdisplayaddress\",\n+        \"Display address on an external signer for verification.\",\n+        {\n+            {\"address\",     RPCArg::Type::STR, RPCArg::Optional::NO, /* default_val */ \"\", \"bitcoin address to display\"},\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ,\"\",\"\",\n+            {\n+                {RPCResult::Type::STR, \"address\", \"The address as confirmed by the signer\"},\n+            }\n+        },\n+        RPCExamples{\"\"},\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+            if (!wallet) return NullUniValue;\n+            CWallet* const pwallet = wallet.get();\n+\n+            LOCK(pwallet->cs_wallet);\n+\n+            CTxDestination dest = DecodeDestination(request.params[0].get_str());\n+\n+            // Make sure the destination is valid\n+            if (!IsValidDestination(dest)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+            }\n+\n+            if (!pwallet->DisplayAddress(dest)) {\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Failed to display address\");\n+            }\n+\n+            UniValue result(UniValue::VOBJ);\n+            result.pushKV(\"address\", request.params[0].get_str());\n+            return result;\n+        }\n+    };\n+}\n+#endif // ENABLE_EXTERNAL_SIGNER\n+\n RPCHelpMan abortrescan();\n RPCHelpMan dumpprivkey();\n RPCHelpMan importprivkey();\n@@ -4602,6 +4644,9 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             &unloadwallet,                   },\n     { \"wallet\",             &upgradewallet,                  },\n     { \"wallet\",             &walletcreatefundedpsbt,         },\n+#ifdef ENABLE_EXTERNAL_SIGNER\n+    { \"wallet\",             &walletdisplayaddress,           },\n+#endif // ENABLE_EXTERNAL_SIGNER\n     { \"wallet\",             &walletlock,                     },\n     { \"wallet\",             &walletpassphrase,               },\n     { \"wallet\",             &walletpassphrasechange,         },"
      },
      {
        "sha": "149549410c156f065e972c3dec9770a6d6e38f86",
        "filename": "src/wallet/scriptpubkeyman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/wallet/scriptpubkeyman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/wallet/scriptpubkeyman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -13,7 +13,7 @@\n #include <util/system.h>\n #include <util/time.h>\n #include <util/translation.h>\n-#include <wallet/external_signer.h>\n+#include <external_signer.h>\n #include <wallet/scriptpubkeyman.h>\n \n #include <optional>"
      },
      {
        "sha": "e245a277e44f33ee7cd03a226bacb246d05a9140",
        "filename": "src/wallet/sqlite.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/wallet/sqlite.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/wallet/sqlite.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/sqlite.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -233,6 +233,15 @@ void SQLiteDatabase::Open()\n         throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to enable fullfsync: %s\\n\", sqlite3_errstr(ret)));\n     }\n \n+    if (gArgs.GetBoolArg(\"-unsafesqlitesync\", false)) {\n+        // Use normal synchronous mode for the journal\n+        LogPrintf(\"WARNING SQLite is configured to not wait for data to be flushed to disk. Data loss and corruption may occur.\\n\");\n+        ret = sqlite3_exec(m_db, \"PRAGMA synchronous = OFF\", nullptr, nullptr, nullptr);\n+        if (ret != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to set synchronous mode to OFF: %s\\n\", sqlite3_errstr(ret)));\n+        }\n+    }\n+\n     // Make the table for our key-value pairs\n     // First check that the main table exists\n     sqlite3_stmt* check_main_stmt{nullptr};"
      },
      {
        "sha": "011d59ecaf6be5b5cbe1fea8cce29542d5ceaa46",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -295,8 +295,6 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n             BOOST_CHECK_EQUAL(found, expected);\n         }\n     }\n-\n-    SetMockTime(0);\n }\n \n // Check that GetImmatureCredit() returns a newly calculated value instead of\n@@ -377,9 +375,6 @@ BOOST_AUTO_TEST_CASE(ComputeTimeSmart)\n     // If there are future entries, new transaction should use time of the\n     // newest entry that is no more than 300 seconds ahead of the clock time.\n     BOOST_CHECK_EQUAL(AddTx(*m_node.chainman, m_wallet, 5, 50, 600), 300);\n-\n-    // Reset mock time for other tests.\n-    SetMockTime(0);\n }\n \n BOOST_AUTO_TEST_CASE(LoadReceiveRequests)\n@@ -692,6 +687,7 @@ BOOST_FIXTURE_TEST_CASE(wallet_descriptor_test, BasicTestingSetup)\n //! rescanning where new transactions in new blocks could be lost.\n BOOST_FIXTURE_TEST_CASE(CreateWallet, TestChain100Setup)\n {\n+    gArgs.ForceSetArg(\"-unsafesqlitesync\", \"1\");\n     // Create new wallet with known key and unload it.\n     auto wallet = TestLoadWallet(*m_node.chain);\n     CKey key;\n@@ -787,6 +783,7 @@ BOOST_FIXTURE_TEST_CASE(CreateWallet, TestChain100Setup)\n \n BOOST_FIXTURE_TEST_CASE(ZapSelectTx, TestChain100Setup)\n {\n+    gArgs.ForceSetArg(\"-unsafesqlitesync\", \"1\");\n     auto wallet = TestLoadWallet(*m_node.chain);\n     CKey key;\n     key.MakeNewKey(true);"
      },
      {
        "sha": "332e7b1397d4b5bebc391340f31baf92130a4a54",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 17,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -3594,19 +3594,6 @@ void ReserveDestination::ReturnDestination()\n     address = CNoDestination();\n }\n \n-#ifdef ENABLE_EXTERNAL_SIGNER\n-ExternalSigner CWallet::GetExternalSigner()\n-{\n-    const std::string command = gArgs.GetArg(\"-signer\", \"\");\n-    if (command == \"\") throw std::runtime_error(std::string(__func__) + \": restart bitcoind with -signer=<cmd>\");\n-    std::vector<ExternalSigner> signers;\n-    ExternalSigner::Enumerate(command, signers, Params().NetworkIDString());\n-    if (signers.empty()) throw std::runtime_error(std::string(__func__) + \": No external signers found\");\n-    // TODO: add fingerprint argument in case of multiple signers\n-    return signers[0];\n-}\n-#endif\n-\n bool CWallet::DisplayAddress(const CTxDestination& dest)\n {\n #ifdef ENABLE_EXTERNAL_SIGNER\n@@ -3619,7 +3606,7 @@ bool CWallet::DisplayAddress(const CTxDestination& dest)\n     if (signer_spk_man == nullptr) {\n         return false;\n     }\n-    ExternalSigner signer = GetExternalSigner(); // TODO: move signer in spk_man\n+    ExternalSigner signer = ExternalSignerScriptPubKeyMan::GetExternalSigner();\n     return signer_spk_man->DisplayAddress(scriptPubKey, signer);\n #else\n     return false;\n@@ -4516,7 +4503,7 @@ void CWallet::LoadDescriptorScriptPubKeyMan(uint256 id, WalletDescriptor& desc)\n         auto spk_manager = std::unique_ptr<ScriptPubKeyMan>(new ExternalSignerScriptPubKeyMan(*this, desc));\n         m_spk_managers[id] = std::move(spk_manager);\n #else\n-        throw std::runtime_error(std::string(__func__) + \": Configure with --enable-external-signer to use external signer wallets\");\n+        throw std::runtime_error(std::string(__func__) + \": Compiled without external signing support (required for external signing)\");\n #endif\n     } else {\n         auto spk_manager = std::unique_ptr<ScriptPubKeyMan>(new DescriptorScriptPubKeyMan(*this, desc));\n@@ -4585,8 +4572,8 @@ void CWallet::SetupDescriptorScriptPubKeyMans()\n             }\n         }\n #else\n-        throw std::runtime_error(std::string(__func__) + \": Wallets with external signers require Boost::Process library.\");\n-#endif\n+        throw std::runtime_error(std::string(__func__) + \": Compiled without external signing support (required for external signing)\");\n+#endif // ENABLE_EXTERNAL_SIGNER\n     }\n }\n "
      },
      {
        "sha": "c4acef8705fa21185c8a2056a93dbdf7ef55ef93",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -22,7 +22,7 @@\n #include <wallet/coinselection.h>\n #include <wallet/crypter.h>\n #include <wallet/scriptpubkeyman.h>\n-#include <wallet/external_signer.h>\n+#include <external_signer.h>\n #include <wallet/walletdb.h>\n #include <wallet/walletutil.h>\n \n@@ -845,9 +845,6 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n \n     std::vector<OutputGroup> GroupOutputs(const std::vector<COutput>& outputs, bool separate_coins, const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate, const CoinEligibilityFilter& filter, bool positive_only) const;\n \n-#ifdef ENABLE_EXTERNAL_SIGNER\n-    ExternalSigner GetExternalSigner() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-#endif\n     /** Display address on an external signer. Returns false if external signer support is not compiled */\n     bool DisplayAddress(const CTxDestination& dest) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n "
      },
      {
        "sha": "25afa94d0f84aeaa70c3e1a6108e4eec7d04bebe",
        "filename": "src/zmq/zmqpublishnotifier.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/zmq/zmqpublishnotifier.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/src/zmq/zmqpublishnotifier.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqpublishnotifier.cpp?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -6,10 +6,11 @@\n \n #include <chain.h>\n #include <chainparams.h>\n+#include <node/blockstorage.h>\n #include <rpc/server.h>\n #include <streams.h>\n #include <util/system.h>\n-#include <validation.h>\n+#include <validation.h> // For cs_main\n #include <zmq/zmqutil.h>\n \n #include <zmq.h>"
      },
      {
        "sha": "821409ccc143e3a8fe50f72c35c48797e863a212",
        "filename": "test/functional/rpc_blockchain.py",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/test/functional/rpc_blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/test/functional/rpc_blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_blockchain.py?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -149,6 +149,7 @@ def _test_getblockchaininfo(self):\n                         'count': 57,\n                         'possible': True,\n                     },\n+                    'min_activation_height': 0,\n                 },\n                 'active': False\n             },\n@@ -158,7 +159,8 @@ def _test_getblockchaininfo(self):\n                     'status': 'active',\n                     'start_time': -1,\n                     'timeout': 9223372036854775807,\n-                    'since': 0\n+                    'since': 0,\n+                    'min_activation_height': 0,\n                 },\n                 'height': 0,\n                 'active': True"
      },
      {
        "sha": "3188763f49ee71248a59024dd3a1b72db12dc1a2",
        "filename": "test/functional/rpc_signer.py",
        "status": "added",
        "additions": 79,
        "deletions": 0,
        "changes": 79,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/test/functional/rpc_signer.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/test/functional/rpc_signer.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_signer.py?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -0,0 +1,79 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test external signer.\n+\n+Verify that a bitcoind node can use an external signer command.\n+See also wallet_signer.py for tests that require wallet context.\n+\"\"\"\n+import os\n+import platform\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class RPCSignerTest(BitcoinTestFramework):\n+    def mock_signer_path(self):\n+        path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'mocks', 'signer.py')\n+        if platform.system() == \"Windows\":\n+            return \"py \" + path\n+        else:\n+            return path\n+\n+    def set_test_params(self):\n+        self.num_nodes = 4\n+\n+        self.extra_args = [\n+            [],\n+            [f\"-signer={self.mock_signer_path()}\", '-keypool=10'],\n+            [f\"-signer={self.mock_signer_path()}\", '-keypool=10'],\n+            [\"-signer=fake.py\"],\n+        ]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_external_signer()\n+\n+    def set_mock_result(self, node, res):\n+        with open(os.path.join(node.cwd, \"mock_result\"), \"w\", encoding=\"utf8\") as f:\n+            f.write(res)\n+\n+    def clear_mock_result(self, node):\n+        os.remove(os.path.join(node.cwd, \"mock_result\"))\n+\n+    def run_test(self):\n+        self.log.debug(f\"-signer={self.mock_signer_path()}\")\n+\n+        assert_raises_rpc_error(-1, 'Error: restart bitcoind with -signer=<cmd>',\n+            self.nodes[0].enumeratesigners\n+        )\n+\n+        # Handle script missing:\n+        assert_raises_rpc_error(-1, 'execve failed: No such file or directory',\n+            self.nodes[3].enumeratesigners\n+        )\n+\n+        # Handle error thrown by script\n+        self.set_mock_result(self.nodes[1], \"2\")\n+        assert_raises_rpc_error(-1, 'RunCommandParseJSON error',\n+            self.nodes[1].enumeratesigners\n+        )\n+        self.clear_mock_result(self.nodes[1])\n+\n+        self.set_mock_result(self.nodes[1], '0 [{\"type\": \"trezor\", \"model\": \"trezor_t\", \"error\": \"fingerprint not found\"}]')\n+        assert_raises_rpc_error(-1, 'fingerprint not found',\n+            self.nodes[1].enumeratesigners\n+        )\n+        self.clear_mock_result(self.nodes[1])\n+\n+        result = self.nodes[1].enumeratesigners()\n+        assert_equal(len(result['signers']), 2)\n+        assert_equal(result['signers'][0][\"fingerprint\"], \"00000001\")\n+        assert_equal(result['signers'][0][\"name\"], \"trezor_t\")\n+\n+if __name__ == '__main__':\n+    RPCSignerTest().main()"
      },
      {
        "sha": "55166ba0adca7e03c611e101765081a32b805b3e",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -374,6 +374,8 @@ def write_config(config_path, *, n, chain, extra_config=\"\"):\n         f.write(\"upnp=0\\n\")\n         f.write(\"natpmp=0\\n\")\n         f.write(\"shrinkdebugfile=0\\n\")\n+        # To improve SQLite wallet performance so that the tests don't timeout, use -unsafesqlitesync\n+        f.write(\"unsafesqlitesync=1\\n\")\n         f.write(extra_config)\n \n "
      },
      {
        "sha": "bd58f2cd51938b8a63b70f5b7df9fceb05915196",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -111,6 +111,7 @@\n     'wallet_listtransactions.py --legacy-wallet',\n     'wallet_listtransactions.py --descriptors',\n     'feature_taproot.py',\n+    'rpc_signer.py',\n     'wallet_signer.py --descriptors',\n     # vv Tests less than 60s vv\n     'p2p_sendheaders.py',"
      },
      {
        "sha": "afd4fd3691d4138890e8cd9e29932b2bd8d57b14",
        "filename": "test/functional/wallet_signer.py",
        "status": "modified",
        "additions": 8,
        "deletions": 36,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/test/functional/wallet_signer.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/test/functional/wallet_signer.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_signer.py?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -5,6 +5,7 @@\n \"\"\"Test external signer.\n \n Verify that a bitcoind node can use an external signer command\n+See also rpc_signer.py for tests without wallet context.\n \"\"\"\n import os\n import platform\n@@ -16,7 +17,7 @@\n )\n \n \n-class SignerTest(BitcoinTestFramework):\n+class WalletSignerTest(BitcoinTestFramework):\n     def mock_signer_path(self):\n         path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'mocks', 'signer.py')\n         if platform.system() == \"Windows\":\n@@ -25,18 +26,16 @@ def mock_signer_path(self):\n             return path\n \n     def set_test_params(self):\n-        self.num_nodes = 4\n+        self.num_nodes = 2\n \n         self.extra_args = [\n             [],\n             [f\"-signer={self.mock_signer_path()}\", '-keypool=10'],\n-            [f\"-signer={self.mock_signer_path()}\", '-keypool=10'],\n-            [\"-signer=fake.py\"],\n         ]\n \n     def skip_test_if_missing_module(self):\n-        self.skip_if_no_wallet()\n         self.skip_if_no_external_signer()\n+        self.skip_if_no_wallet()\n \n     def set_mock_result(self, node, res):\n         with open(os.path.join(node.cwd, \"mock_result\"), \"w\", encoding=\"utf8\") as f:\n@@ -48,28 +47,6 @@ def clear_mock_result(self, node):\n     def run_test(self):\n         self.log.debug(f\"-signer={self.mock_signer_path()}\")\n \n-        assert_raises_rpc_error(-4, 'Error: restart bitcoind with -signer=<cmd>',\n-            self.nodes[0].enumeratesigners\n-        )\n-\n-        # Handle script missing:\n-        assert_raises_rpc_error(-1, 'execve failed: No such file or directory',\n-            self.nodes[3].enumeratesigners\n-        )\n-\n-        # Handle error thrown by script\n-        self.set_mock_result(self.nodes[1], \"2\")\n-        assert_raises_rpc_error(-1, 'RunCommandParseJSON error',\n-            self.nodes[1].enumeratesigners\n-        )\n-        self.clear_mock_result(self.nodes[1])\n-\n-        self.set_mock_result(self.nodes[1], '0 [{\"type\": \"trezor\", \"model\": \"trezor_t\", \"error\": \"fingerprint not found\"}]')\n-        assert_raises_rpc_error(-4, 'fingerprint not found',\n-            self.nodes[1].enumeratesigners\n-        )\n-        self.clear_mock_result(self.nodes[1])\n-\n         # Create new wallets for an external signer.\n         # disable_private_keys and descriptors must be true:\n         assert_raises_rpc_error(-4, \"Private keys must be disabled when using an external signer\", self.nodes[1].createwallet, wallet_name='not_hww', disable_private_keys=False, descriptors=True, external_signer=True)\n@@ -81,11 +58,6 @@ def run_test(self):\n         self.nodes[1].createwallet(wallet_name='hww', disable_private_keys=True, descriptors=True, external_signer=True)\n         hww = self.nodes[1].get_wallet_rpc('hww')\n \n-        result = hww.enumeratesigners()\n-        assert_equal(len(result['signers']), 2)\n-        assert_equal(result['signers'][0][\"fingerprint\"], \"00000001\")\n-        assert_equal(result['signers'][0][\"name\"], \"trezor_t\")\n-\n         # Flag can't be set afterwards (could be added later for non-blank descriptor based watch-only wallets)\n         self.nodes[1].createwallet(wallet_name='not_hww', disable_private_keys=True, descriptors=True, external_signer=False)\n         not_hww = self.nodes[1].get_wallet_rpc('not_hww')\n@@ -123,14 +95,14 @@ def run_test(self):\n         assert_equal(address_info['ismine'], True)\n         assert_equal(address_info['hdkeypath'], \"m/44'/1'/0'/0/0\")\n \n-        self.log.info('Test signerdisplayaddress')\n-        result = hww.signerdisplayaddress(address1)\n+        self.log.info('Test walletdisplayaddress')\n+        result = hww.walletdisplayaddress(address1)\n         assert_equal(result, {\"address\": address1})\n \n         # Handle error thrown by script\n         self.set_mock_result(self.nodes[1], \"2\")\n         assert_raises_rpc_error(-1, 'RunCommandParseJSON error',\n-            hww.signerdisplayaddress, address1\n+            hww.walletdisplayaddress, address1\n         )\n         self.clear_mock_result(self.nodes[1])\n \n@@ -214,4 +186,4 @@ def run_test(self):\n         # self.clear_mock_result(self.nodes[4])\n \n if __name__ == '__main__':\n-    SignerTest().main()\n+    WalletSignerTest().main()"
      },
      {
        "sha": "ad2333a808e8b7890e064e3abd19fe117875b164",
        "filename": "test/lint/lint-circular-dependencies.sh",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/test/lint/lint-circular-dependencies.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/test/lint/lint-circular-dependencies.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-circular-dependencies.sh?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -11,7 +11,9 @@ export LC_ALL=C\n EXPECTED_CIRCULAR_DEPENDENCIES=(\n     \"chainparamsbase -> util/system -> chainparamsbase\"\n     \"index/txindex -> validation -> index/txindex\"\n-    \"index/blockfilterindex -> validation -> index/blockfilterindex\"\n+    \"node/blockstorage -> validation -> node/blockstorage\"\n+    \"index/blockfilterindex -> node/blockstorage -> validation -> index/blockfilterindex\"\n+    \"index/base -> validation -> index/blockfilterindex -> index/base\"\n     \"policy/fees -> txmempool -> policy/fees\"\n     \"qt/addresstablemodel -> qt/walletmodel -> qt/addresstablemodel\"\n     \"qt/bitcoingui -> qt/walletframe -> qt/bitcoingui\""
      },
      {
        "sha": "7db051ca37912787aa8ca98cfa3d5b6493a4c215",
        "filename": "test/sanitizer_suppressions/tsan",
        "status": "modified",
        "additions": 1,
        "deletions": 20,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/test/sanitizer_suppressions/tsan",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/test/sanitizer_suppressions/tsan",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/sanitizer_suppressions/tsan?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -3,39 +3,20 @@\n #\n # https://github.com/google/sanitizers/wiki/ThreadSanitizerSuppressions\n \n-# double locks (TODO fix)\n-mutex:g_genesis_wait_mutex\n-mutex:Interrupt\n-mutex:CThreadInterrupt\n-mutex:CConnman::Interrupt\n-mutex:CConnman::WakeMessageHandler\n-mutex:CConnman::ThreadOpenConnections\n-mutex:CConnman::ThreadOpenAddedConnections\n-mutex:CConnman::SocketHandler\n-mutex:UpdateTip\n-mutex:PeerManagerImpl::UpdatedBlockTip\n-mutex:g_best_block_mutex\n-\n # race (TODO fix)\n-race:CConnman::WakeMessageHandler\n-race:CConnman::ThreadMessageHandler\n-race:fHaveGenesis\n-race:ProcessNewBlock\n-race:ThreadImport\n race:LoadWallet\n race:WalletBatch::WriteHDChain\n race:BerkeleyBatch\n race:BerkeleyDatabase\n race:DatabaseBatch\n-race:leveldb::DBImpl::DeleteObsoleteFiles\n race:zmq::*\n race:bitcoin-qt\n \n # deadlock (TODO fix)\n deadlock:CChainState::ConnectTip\n \n # Intentional deadlock in tests\n-deadlock:TestPotentialDeadLockDetected\n+deadlock:sync_tests::potential_deadlock_detected\n \n # Wildcard for all gui tests, should be replaced with non-wildcard suppressions\n race:src/qt/test/*"
      }
    ]
  },
  {
    "sha": "9508ba18ce2c3de7858c9b859af3d24f076e4139",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NTA4YmExOGNlMmMzZGU3ODU4YzliODU5YWYzZDI0ZjA3NmU0MTM5",
    "commit": {
      "author": {
        "name": "J0hn",
        "email": "songjh.john@gmail.com",
        "date": "2021-04-16T14:28:20Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-04-16T14:28:20Z"
      },
      "message": "Merge pull request #7 from bitcoin/master\n\nbit pull",
      "tree": {
        "sha": "17548e1816dab3da471acc62708bd9c9bc5795f9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/17548e1816dab3da471acc62708bd9c9bc5795f9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9508ba18ce2c3de7858c9b859af3d24f076e4139",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgeZ8ECRBK7hj4Ov3rIwAAbNkIAD4h8NYQvR/fV99snXk4T1PB\nLuUFGW19fEiFEaKqrQ0kjxItjCHE8o/5pwmJzHEMPfn3FUVT5O5rxBc93ZJYoEO2\nrw5G+kIwUseWczVGXTXT+gtTUdxjrudibUfYr0asgvk9vII31MYoClpe5ky5OPAX\nSKyKm0CekMRoO/bKAmUW4XhrDUi0kD2oztipLS5tTAI9fGOY7h5Aj+PRijzbfXyR\nG4sfMT6MP+KPG+RMMTX868gtJGL9MhcNFptd6KEHOyBv6AYQFhcx3tENBtEByVKI\nf4ih+NSxoUb1cDLIR9RLlqsq2bGGYcmU8T1Y9Kedpf42MQncunceGM8ikQrS+aE=\n=I8uM\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 17548e1816dab3da471acc62708bd9c9bc5795f9\nparent fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f\nparent 585cbe22575306c05b156ea90faa9caa1add4c87\nauthor J0hn <songjh.john@gmail.com> 1618583300 +0100\ncommitter GitHub <noreply@github.com> 1618583300 +0100\n\nMerge pull request #7 from bitcoin/master\n\nbit pull"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9508ba18ce2c3de7858c9b859af3d24f076e4139",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9508ba18ce2c3de7858c9b859af3d24f076e4139",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9508ba18ce2c3de7858c9b859af3d24f076e4139/comments",
    "author": {
      "login": "Rqcker",
      "id": 20661419,
      "node_id": "MDQ6VXNlcjIwNjYxNDE5",
      "avatar_url": "https://avatars.githubusercontent.com/u/20661419?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Rqcker",
      "html_url": "https://github.com/Rqcker",
      "followers_url": "https://api.github.com/users/Rqcker/followers",
      "following_url": "https://api.github.com/users/Rqcker/following{/other_user}",
      "gists_url": "https://api.github.com/users/Rqcker/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Rqcker/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Rqcker/subscriptions",
      "organizations_url": "https://api.github.com/users/Rqcker/orgs",
      "repos_url": "https://api.github.com/users/Rqcker/repos",
      "events_url": "https://api.github.com/users/Rqcker/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Rqcker/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f"
      },
      {
        "sha": "585cbe22575306c05b156ea90faa9caa1add4c87",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/585cbe22575306c05b156ea90faa9caa1add4c87",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/585cbe22575306c05b156ea90faa9caa1add4c87"
      }
    ],
    "stats": {
      "total": 24,
      "additions": 0,
      "deletions": 24
    },
    "files": [
      {
        "sha": "0e4eeee0a7ad9ebc49c30d30c285ccd41a752771",
        "filename": "contrib/bitcoin-qt.pro",
        "status": "removed",
        "additions": 0,
        "deletions": 22,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/contrib/bitcoin-qt.pro",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f/contrib/bitcoin-qt.pro",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/bitcoin-qt.pro?ref=fd06a7b775d37f60cbf78f5eb4ef37728cb8a79f",
        "patch": "@@ -1,22 +0,0 @@\n-FORMS += \\\n-    ../src/qt/forms/aboutdialog.ui \\\n-    ../src/qt/forms/addressbookpage.ui \\\n-    ../src/qt/forms/askpassphrasedialog.ui \\\n-    ../src/qt/forms/coincontroldialog.ui \\\n-    ../src/qt/forms/editaddressdialog.ui \\\n-    ../src/qt/forms/helpmessagedialog.ui \\\n-    ../src/qt/forms/intro.ui \\\n-    ../src/qt/forms/openuridialog.ui \\\n-    ../src/qt/forms/optionsdialog.ui \\\n-    ../src/qt/forms/overviewpage.ui \\\n-    ../src/qt/forms/receivecoinsdialog.ui \\\n-    ../src/qt/forms/receiverequestdialog.ui \\\n-    ../src/qt/forms/debugwindow.ui \\\n-    ../src/qt/forms/sendcoinsdialog.ui \\\n-    ../src/qt/forms/sendcoinsentry.ui \\\n-    ../src/qt/forms/signverifymessagedialog.ui \\\n-    ../src/qt/forms/transactiondescdialog.ui \\\n-    ../src/qt/forms/createwalletdialog.ui\n-\n-RESOURCES += \\\n-    ../src/qt/bitcoin.qrc"
      },
      {
        "sha": "785bb0047b532dbad8987390517d61435d9b9a3f",
        "filename": "doc/translation_process.md",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9508ba18ce2c3de7858c9b859af3d24f076e4139/doc/translation_process.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9508ba18ce2c3de7858c9b859af3d24f076e4139/doc/translation_process.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/translation_process.md?ref=9508ba18ce2c3de7858c9b859af3d24f076e4139",
        "patch": "@@ -22,8 +22,6 @@ cd src/\n make translate\n ```\n \n-`contrib/bitcoin-qt.pro` takes care of generating `.qm` (binary compiled) files from `.ts` (source files) files. It\u2019s mostly automated, and you shouldn\u2019t need to worry about it.\n-\n **Example Qt translation**\n ```cpp\n QToolBar *toolbar = addToolBar(tr(\"Tabs toolbar\"));"
      }
    ]
  },
  {
    "sha": "f00e799b4ac718b892ee4c3dac18074256e90b52",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMDBlNzk5YjRhYzcxOGI4OTJlZTRjM2RhYzE4MDc0MjU2ZTkwYjUy",
    "commit": {
      "author": {
        "name": "J0hn",
        "email": "songjh.john@gmail.com",
        "date": "2021-04-17T18:54:17Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-04-17T18:54:17Z"
      },
      "message": "Merge pull request #8 from bitcoin/master\n\nTest part",
      "tree": {
        "sha": "b9ddbf86936e1db3f84a4346ab3234e6c83b2266",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b9ddbf86936e1db3f84a4346ab3234e6c83b2266"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f00e799b4ac718b892ee4c3dac18074256e90b52",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgey7ZCRBK7hj4Ov3rIwAAgR4IABMiI3BdBdrU4yHTyNXevTon\n5MOwAhWjujOM0wHqGjVhWva+GYnGnVnLF5JXujJLlx2dkfDwxF4HtoS5GY8UYsDG\nMu+h5IRnH9wpc4dDvDhVlN2uQL1d+kSWDsW30BkAVFWkHqfrXnzC26Ixc1Y31fAe\nThUWEgPqxJYJmAzRIgyQcNvssU0gHumCGB6csISxudlgGBerjavqs5/EvoNItQaY\nOuP7ZnwMbq+D6mJrvT0waBhGK4Vq8xWsW+4oaavdcu+mlOjHF6WqUyRspX5helTd\nlH1eFYnh3b8gM+cOKZdwn6s58XVVM+jpyHPbkh9ypu9PupOjTMqdPSq3MkMM4rs=\n=DMEE\n-----END PGP SIGNATURE-----\n",
        "payload": "tree b9ddbf86936e1db3f84a4346ab3234e6c83b2266\nparent 9508ba18ce2c3de7858c9b859af3d24f076e4139\nparent 0dd7b234895b02bfc512ae83bd77b581c861d6e9\nauthor J0hn <songjh.john@gmail.com> 1618685657 +0100\ncommitter GitHub <noreply@github.com> 1618685657 +0100\n\nMerge pull request #8 from bitcoin/master\n\nTest part"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f00e799b4ac718b892ee4c3dac18074256e90b52",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f00e799b4ac718b892ee4c3dac18074256e90b52",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f00e799b4ac718b892ee4c3dac18074256e90b52/comments",
    "author": {
      "login": "Rqcker",
      "id": 20661419,
      "node_id": "MDQ6VXNlcjIwNjYxNDE5",
      "avatar_url": "https://avatars.githubusercontent.com/u/20661419?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Rqcker",
      "html_url": "https://github.com/Rqcker",
      "followers_url": "https://api.github.com/users/Rqcker/followers",
      "following_url": "https://api.github.com/users/Rqcker/following{/other_user}",
      "gists_url": "https://api.github.com/users/Rqcker/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Rqcker/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Rqcker/subscriptions",
      "organizations_url": "https://api.github.com/users/Rqcker/orgs",
      "repos_url": "https://api.github.com/users/Rqcker/repos",
      "events_url": "https://api.github.com/users/Rqcker/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Rqcker/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9508ba18ce2c3de7858c9b859af3d24f076e4139",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9508ba18ce2c3de7858c9b859af3d24f076e4139",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9508ba18ce2c3de7858c9b859af3d24f076e4139"
      },
      {
        "sha": "0dd7b234895b02bfc512ae83bd77b581c861d6e9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0dd7b234895b02bfc512ae83bd77b581c861d6e9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0dd7b234895b02bfc512ae83bd77b581c861d6e9"
      }
    ],
    "stats": {
      "total": 466,
      "additions": 278,
      "deletions": 188
    },
    "files": [
      {
        "sha": "3bc7fdd458f98b029a61ff980c37c1def590b58a",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f00e799b4ac718b892ee4c3dac18074256e90b52/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f00e799b4ac718b892ee4c3dac18074256e90b52/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=f00e799b4ac718b892ee4c3dac18074256e90b52",
        "patch": "@@ -39,13 +39,14 @@ int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParam\n     return nNewTime - nOldTime;\n }\n \n-void RegenerateCommitments(CBlock& block, BlockManager& blockman)\n+void RegenerateCommitments(CBlock& block, CBlockIndex* prev_block)\n {\n     CMutableTransaction tx{*block.vtx.at(0)};\n     tx.vout.erase(tx.vout.begin() + GetWitnessCommitmentIndex(block));\n     block.vtx.at(0) = MakeTransactionRef(tx);\n \n-    GenerateCoinbaseCommitment(block, WITH_LOCK(::cs_main, assert(std::addressof(g_chainman.m_blockman) == std::addressof(blockman)); return blockman.LookupBlockIndex(block.hashPrevBlock)), Params().GetConsensus());\n+    WITH_LOCK(::cs_main, assert(g_chainman.m_blockman.LookupBlockIndex(block.hashPrevBlock) == prev_block));\n+    GenerateCoinbaseCommitment(block, prev_block, Params().GetConsensus());\n \n     block.hashMerkleRoot = BlockMerkleRoot(block);\n }"
      },
      {
        "sha": "becf362b79db3ac3fe2a9b3dce86724265f19623",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f00e799b4ac718b892ee4c3dac18074256e90b52/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f00e799b4ac718b892ee4c3dac18074256e90b52/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=f00e799b4ac718b892ee4c3dac18074256e90b52",
        "patch": "@@ -202,8 +202,7 @@ class BlockAssembler\n void IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev, unsigned int& nExtraNonce);\n int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev);\n \n-// TODO just accept a CBlockIndex*\n /** Update an old GenerateCoinbaseCommitment from CreateNewBlock after the block txs have changed */\n-void RegenerateCommitments(CBlock& block, BlockManager& blockman);\n+void RegenerateCommitments(CBlock& block, CBlockIndex* prev_block);\n \n #endif // BITCOIN_MINER_H"
      },
      {
        "sha": "d10bf9f9aeb0f3fd8cf0204563d98bd4d7f22170",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f00e799b4ac718b892ee4c3dac18074256e90b52/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f00e799b4ac718b892ee4c3dac18074256e90b52/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=f00e799b4ac718b892ee4c3dac18074256e90b52",
        "patch": "@@ -630,8 +630,11 @@ bool SetStartOnSystemStartup(bool fAutoStart) { return false; }\n \n void setClipboard(const QString& str)\n {\n-    QApplication::clipboard()->setText(str, QClipboard::Clipboard);\n-    QApplication::clipboard()->setText(str, QClipboard::Selection);\n+    QClipboard* clipboard = QApplication::clipboard();\n+    clipboard->setText(str, QClipboard::Clipboard);\n+    if (clipboard->supportsSelection()) {\n+        clipboard->setText(str, QClipboard::Selection);\n+    }\n }\n \n fs::path qstringToBoostPath(const QString &path)"
      },
      {
        "sha": "d41f374c499f94778b5c0d6327553ee6c0361f44",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 17,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f00e799b4ac718b892ee4c3dac18074256e90b52/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f00e799b4ac718b892ee4c3dac18074256e90b52/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=f00e799b4ac718b892ee4c3dac18074256e90b52",
        "patch": "@@ -181,14 +181,16 @@ static bool rest_headers(const std::any& context,\n     std::vector<const CBlockIndex *> headers;\n     headers.reserve(count);\n     {\n+        ChainstateManager& chainman = EnsureAnyChainman(context);\n         LOCK(cs_main);\n-        tip = ::ChainActive().Tip();\n-        const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(hash);\n-        while (pindex != nullptr && ::ChainActive().Contains(pindex)) {\n+        CChain& active_chain = chainman.ActiveChain();\n+        tip = active_chain.Tip();\n+        const CBlockIndex* pindex = chainman.m_blockman.LookupBlockIndex(hash);\n+        while (pindex != nullptr && active_chain.Contains(pindex)) {\n             headers.push_back(pindex);\n             if (headers.size() == (unsigned long)count)\n                 break;\n-            pindex = ::ChainActive().Next(pindex);\n+            pindex = active_chain.Next(pindex);\n         }\n     }\n \n@@ -232,7 +234,8 @@ static bool rest_headers(const std::any& context,\n     }\n }\n \n-static bool rest_block(HTTPRequest* req,\n+static bool rest_block(const std::any& context,\n+                       HTTPRequest* req,\n                        const std::string& strURIPart,\n                        bool showTxDetails)\n {\n@@ -249,9 +252,10 @@ static bool rest_block(HTTPRequest* req,\n     CBlockIndex* pblockindex = nullptr;\n     CBlockIndex* tip = nullptr;\n     {\n+        ChainstateManager& chainman = EnsureAnyChainman(context);\n         LOCK(cs_main);\n-        tip = ::ChainActive().Tip();\n-        pblockindex = g_chainman.m_blockman.LookupBlockIndex(hash);\n+        tip = chainman.ActiveChain().Tip();\n+        pblockindex = chainman.m_blockman.LookupBlockIndex(hash);\n         if (!pblockindex) {\n             return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not found\");\n         }\n@@ -298,12 +302,12 @@ static bool rest_block(HTTPRequest* req,\n \n static bool rest_block_extended(const std::any& context, HTTPRequest* req, const std::string& strURIPart)\n {\n-    return rest_block(req, strURIPart, true);\n+    return rest_block(context, req, strURIPart, true);\n }\n \n static bool rest_block_notxdetails(const std::any& context, HTTPRequest* req, const std::string& strURIPart)\n {\n-    return rest_block(req, strURIPart, false);\n+    return rest_block(context, req, strURIPart, false);\n }\n \n // A bit of a hack - dependency on a function defined in rpc/blockchain.cpp\n@@ -537,6 +541,7 @@ static bool rest_getutxos(const std::any& context, HTTPRequest* req, const std::\n     std::string bitmapStringRepresentation;\n     std::vector<bool> hits;\n     bitmap.resize((vOutPoints.size() + 7) / 8);\n+    ChainstateManager& chainman = EnsureAnyChainman(context);\n     {\n         auto process_utxos = [&vOutPoints, &outs, &hits](const CCoinsView& view, const CTxMemPool& mempool) {\n             for (const COutPoint& vOutPoint : vOutPoints) {\n@@ -552,12 +557,12 @@ static bool rest_getutxos(const std::any& context, HTTPRequest* req, const std::\n             if (!mempool) return false;\n             // use db+mempool as cache backend in case user likes to query mempool\n             LOCK2(cs_main, mempool->cs);\n-            CCoinsViewCache& viewChain = ::ChainstateActive().CoinsTip();\n+            CCoinsViewCache& viewChain = chainman.ActiveChainstate().CoinsTip();\n             CCoinsViewMemPool viewMempool(&viewChain, *mempool);\n             process_utxos(viewMempool, *mempool);\n         } else {\n             LOCK(cs_main);  // no need to lock mempool!\n-            process_utxos(::ChainstateActive().CoinsTip(), CTxMemPool());\n+            process_utxos(chainman.ActiveChainstate().CoinsTip(), CTxMemPool());\n         }\n \n         for (size_t i = 0; i < hits.size(); ++i) {\n@@ -572,7 +577,7 @@ static bool rest_getutxos(const std::any& context, HTTPRequest* req, const std::\n         // serialize data\n         // use exact same output as mentioned in Bip64\n         CDataStream ssGetUTXOResponse(SER_NETWORK, PROTOCOL_VERSION);\n-        ssGetUTXOResponse << ::ChainActive().Height() << ::ChainActive().Tip()->GetBlockHash() << bitmap << outs;\n+        ssGetUTXOResponse << chainman.ActiveChain().Height() << chainman.ActiveChain().Tip()->GetBlockHash() << bitmap << outs;\n         std::string ssGetUTXOResponseString = ssGetUTXOResponse.str();\n \n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n@@ -582,7 +587,7 @@ static bool rest_getutxos(const std::any& context, HTTPRequest* req, const std::\n \n     case RetFormat::HEX: {\n         CDataStream ssGetUTXOResponse(SER_NETWORK, PROTOCOL_VERSION);\n-        ssGetUTXOResponse << ::ChainActive().Height() << ::ChainActive().Tip()->GetBlockHash() << bitmap << outs;\n+        ssGetUTXOResponse << chainman.ActiveChain().Height() << chainman.ActiveChain().Tip()->GetBlockHash() << bitmap << outs;\n         std::string strHex = HexStr(ssGetUTXOResponse) + \"\\n\";\n \n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n@@ -595,8 +600,8 @@ static bool rest_getutxos(const std::any& context, HTTPRequest* req, const std::\n \n         // pack in some essentials\n         // use more or less the same output as mentioned in Bip64\n-        objGetUTXOResponse.pushKV(\"chainHeight\", ::ChainActive().Height());\n-        objGetUTXOResponse.pushKV(\"chaintipHash\", ::ChainActive().Tip()->GetBlockHash().GetHex());\n+        objGetUTXOResponse.pushKV(\"chainHeight\", chainman.ActiveChain().Height());\n+        objGetUTXOResponse.pushKV(\"chaintipHash\", chainman.ActiveChain().Tip()->GetBlockHash().GetHex());\n         objGetUTXOResponse.pushKV(\"bitmap\", bitmapStringRepresentation);\n \n         UniValue utxos(UniValue::VARR);\n@@ -639,11 +644,13 @@ static bool rest_blockhash_by_height(const std::any& context, HTTPRequest* req,\n \n     CBlockIndex* pblockindex = nullptr;\n     {\n+        ChainstateManager& chainman = EnsureAnyChainman(context);\n         LOCK(cs_main);\n-        if (blockheight > ::ChainActive().Height()) {\n+        const CChain& active_chain = chainman.ActiveChain();\n+        if (blockheight > active_chain.Height()) {\n             return RESTERR(req, HTTP_NOT_FOUND, \"Block height out of range\");\n         }\n-        pblockindex = ::ChainActive()[blockheight];\n+        pblockindex = active_chain[blockheight];\n     }\n     switch (rf) {\n     case RetFormat::BINARY: {"
      },
      {
        "sha": "7cf6a413e13b0d2be249355d570507e53d4c3dae",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 129,
        "deletions": 79,
        "changes": 208,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f00e799b4ac718b892ee4c3dac18074256e90b52/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f00e799b4ac718b892ee4c3dac18074256e90b52/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=f00e799b4ac718b892ee4c3dac18074256e90b52",
        "patch": "@@ -56,7 +56,7 @@ static Mutex cs_blockchange;\n static std::condition_variable cond_blockchange;\n static CUpdatedBlock latestblock GUARDED_BY(cs_blockchange);\n \n-NodeContext& EnsureNodeContext(const std::any& context)\n+NodeContext& EnsureAnyNodeContext(const std::any& context)\n {\n     auto node_context = util::AnyPtr<NodeContext>(context);\n     if (!node_context) {\n@@ -65,33 +65,46 @@ NodeContext& EnsureNodeContext(const std::any& context)\n     return *node_context;\n }\n \n-CTxMemPool& EnsureMemPool(const std::any& context)\n+CTxMemPool& EnsureMemPool(const NodeContext& node)\n {\n-    const NodeContext& node = EnsureNodeContext(context);\n     if (!node.mempool) {\n         throw JSONRPCError(RPC_CLIENT_MEMPOOL_DISABLED, \"Mempool disabled or instance not found\");\n     }\n     return *node.mempool;\n }\n \n-ChainstateManager& EnsureChainman(const std::any& context)\n+CTxMemPool& EnsureAnyMemPool(const std::any& context)\n+{\n+    return EnsureMemPool(EnsureAnyNodeContext(context));\n+}\n+\n+ChainstateManager& EnsureChainman(const NodeContext& node)\n {\n-    const NodeContext& node = EnsureNodeContext(context);\n     if (!node.chainman) {\n         throw JSONRPCError(RPC_INTERNAL_ERROR, \"Node chainman not found\");\n     }\n+    WITH_LOCK(::cs_main, CHECK_NONFATAL(std::addressof(g_chainman) == std::addressof(*node.chainman)));\n     return *node.chainman;\n }\n \n-CBlockPolicyEstimator& EnsureFeeEstimator(const std::any& context)\n+ChainstateManager& EnsureAnyChainman(const std::any& context)\n+{\n+    return EnsureChainman(EnsureAnyNodeContext(context));\n+}\n+\n+CBlockPolicyEstimator& EnsureFeeEstimator(const NodeContext& node)\n {\n-    NodeContext& node = EnsureNodeContext(context);\n     if (!node.fee_estimator) {\n         throw JSONRPCError(RPC_INTERNAL_ERROR, \"Fee estimation disabled\");\n     }\n     return *node.fee_estimator;\n }\n \n+CBlockPolicyEstimator& EnsureAnyFeeEstimator(const std::any& context)\n+{\n+    return EnsureFeeEstimator(EnsureAnyNodeContext(context));\n+}\n+\n /* Calculate the difficulty for a given block index.\n  */\n double GetDifficulty(const CBlockIndex* blockindex)\n@@ -198,8 +211,9 @@ static RPCHelpMan getblockcount()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n+    ChainstateManager& chainman = EnsureAnyChainman(request.context);\n     LOCK(cs_main);\n-    return ::ChainActive().Height();\n+    return chainman.ActiveChain().Height();\n },\n     };\n }\n@@ -217,8 +231,9 @@ static RPCHelpMan getbestblockhash()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n+    ChainstateManager& chainman = EnsureAnyChainman(request.context);\n     LOCK(cs_main);\n-    return ::ChainActive().Tip()->GetBlockHash().GetHex();\n+    return chainman.ActiveChain().Tip()->GetBlockHash().GetHex();\n },\n     };\n }\n@@ -398,8 +413,9 @@ static RPCHelpMan getdifficulty()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n+    ChainstateManager& chainman = EnsureAnyChainman(request.context);\n     LOCK(cs_main);\n-    return GetDifficulty(::ChainActive().Tip());\n+    return GetDifficulty(chainman.ActiveChain().Tip());\n },\n     };\n }\n@@ -581,7 +597,7 @@ static RPCHelpMan getrawmempool()\n         include_mempool_sequence = request.params[1].get_bool();\n     }\n \n-    return MempoolToJSON(EnsureMemPool(request.context), fVerbose, include_mempool_sequence);\n+    return MempoolToJSON(EnsureAnyMemPool(request.context), fVerbose, include_mempool_sequence);\n },\n     };\n }\n@@ -616,7 +632,7 @@ static RPCHelpMan getmempoolancestors()\n \n     uint256 hash = ParseHashV(request.params[0], \"parameter 1\");\n \n-    const CTxMemPool& mempool = EnsureMemPool(request.context);\n+    const CTxMemPool& mempool = EnsureAnyMemPool(request.context);\n     LOCK(mempool.cs);\n \n     CTxMemPool::txiter it = mempool.mapTx.find(hash);\n@@ -680,7 +696,7 @@ static RPCHelpMan getmempooldescendants()\n \n     uint256 hash = ParseHashV(request.params[0], \"parameter 1\");\n \n-    const CTxMemPool& mempool = EnsureMemPool(request.context);\n+    const CTxMemPool& mempool = EnsureAnyMemPool(request.context);\n     LOCK(mempool.cs);\n \n     CTxMemPool::txiter it = mempool.mapTx.find(hash);\n@@ -732,7 +748,7 @@ static RPCHelpMan getmempoolentry()\n {\n     uint256 hash = ParseHashV(request.params[0], \"parameter 1\");\n \n-    const CTxMemPool& mempool = EnsureMemPool(request.context);\n+    const CTxMemPool& mempool = EnsureAnyMemPool(request.context);\n     LOCK(mempool.cs);\n \n     CTxMemPool::txiter it = mempool.mapTx.find(hash);\n@@ -763,13 +779,15 @@ static RPCHelpMan getblockhash()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n+    ChainstateManager& chainman = EnsureAnyChainman(request.context);\n     LOCK(cs_main);\n+    const CChain& active_chain = chainman.ActiveChain();\n \n     int nHeight = request.params[0].get_int();\n-    if (nHeight < 0 || nHeight > ::ChainActive().Height())\n+    if (nHeight < 0 || nHeight > active_chain.Height())\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Block height out of range\");\n \n-    CBlockIndex* pblockindex = ::ChainActive()[nHeight];\n+    CBlockIndex* pblockindex = active_chain[nHeight];\n     return pblockindex->GetBlockHash().GetHex();\n },\n     };\n@@ -822,9 +840,10 @@ static RPCHelpMan getblockheader()\n     const CBlockIndex* pblockindex;\n     const CBlockIndex* tip;\n     {\n+        ChainstateManager& chainman = EnsureAnyChainman(request.context);\n         LOCK(cs_main);\n-        pblockindex = g_chainman.m_blockman.LookupBlockIndex(hash);\n-        tip = ::ChainActive().Tip();\n+        pblockindex = chainman.m_blockman.LookupBlockIndex(hash);\n+        tip = chainman.ActiveChain().Tip();\n     }\n \n     if (!pblockindex) {\n@@ -946,9 +965,10 @@ static RPCHelpMan getblock()\n     const CBlockIndex* pblockindex;\n     const CBlockIndex* tip;\n     {\n+        ChainstateManager& chainman = EnsureAnyChainman(request.context);\n         LOCK(cs_main);\n-        pblockindex = g_chainman.m_blockman.LookupBlockIndex(hash);\n-        tip = ::ChainActive().Tip();\n+        pblockindex = chainman.m_blockman.LookupBlockIndex(hash);\n+        tip = chainman.ActiveChain().Tip();\n \n         if (!pblockindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n@@ -988,7 +1008,10 @@ static RPCHelpMan pruneblockchain()\n     if (!fPruneMode)\n         throw JSONRPCError(RPC_MISC_ERROR, \"Cannot prune blocks because node is not in prune mode.\");\n \n+    ChainstateManager& chainman = EnsureAnyChainman(request.context);\n     LOCK(cs_main);\n+    CChainState& active_chainstate = chainman.ActiveChainstate();\n+    CChain& active_chain = active_chainstate.m_chain;\n \n     int heightParam = request.params[0].get_int();\n     if (heightParam < 0)\n@@ -998,15 +1021,15 @@ static RPCHelpMan pruneblockchain()\n     // too low to be a block time (corresponds to timestamp from Sep 2001).\n     if (heightParam > 1000000000) {\n         // Add a 2 hour buffer to include blocks which might have had old timestamps\n-        CBlockIndex* pindex = ::ChainActive().FindEarliestAtLeast(heightParam - TIMESTAMP_WINDOW, 0);\n+        CBlockIndex* pindex = active_chain.FindEarliestAtLeast(heightParam - TIMESTAMP_WINDOW, 0);\n         if (!pindex) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Could not find block with at least the specified timestamp.\");\n         }\n         heightParam = pindex->nHeight;\n     }\n \n     unsigned int height = (unsigned int) heightParam;\n-    unsigned int chainHeight = (unsigned int) ::ChainActive().Height();\n+    unsigned int chainHeight = (unsigned int) active_chain.Height();\n     if (chainHeight < Params().PruneAfterHeight())\n         throw JSONRPCError(RPC_MISC_ERROR, \"Blockchain is too short for pruning.\");\n     else if (height > chainHeight)\n@@ -1016,8 +1039,8 @@ static RPCHelpMan pruneblockchain()\n         height = chainHeight - MIN_BLOCKS_TO_KEEP;\n     }\n \n-    PruneBlockFilesManual(::ChainstateActive(), height);\n-    const CBlockIndex* block = ::ChainActive().Tip();\n+    PruneBlockFilesManual(active_chainstate, height);\n+    const CBlockIndex* block = active_chain.Tip();\n     CHECK_NONFATAL(block);\n     while (block->pprev && (block->pprev->nStatus & BLOCK_HAVE_DATA)) {\n         block = block->pprev;\n@@ -1070,13 +1093,21 @@ static RPCHelpMan gettxoutsetinfo()\n     UniValue ret(UniValue::VOBJ);\n \n     CCoinsStats stats;\n-    ::ChainstateActive().ForceFlushStateToDisk();\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n+    ChainstateManager& chainman = EnsureChainman(node);\n+    CChainState& active_chainstate = chainman.ActiveChainstate();\n+    active_chainstate.ForceFlushStateToDisk();\n \n     const CoinStatsHashType hash_type{request.params[0].isNull() ? CoinStatsHashType::HASH_SERIALIZED : ParseHashType(request.params[0].get_str())};\n \n-    CCoinsView* coins_view = WITH_LOCK(::cs_main, return &::ChainstateActive().CoinsDB());\n-    NodeContext& node = EnsureNodeContext(request.context);\n-    if (GetUTXOStats(coins_view, WITH_LOCK(::cs_main, return std::ref(g_chainman.m_blockman)), stats, hash_type, node.rpc_interruption_point)) {\n+    CCoinsView* coins_view;\n+    BlockManager* blockman;\n+    {\n+        LOCK(::cs_main);\n+        coins_view = &active_chainstate.CoinsDB();\n+        blockman = &active_chainstate.m_blockman;\n+    }\n+    if (GetUTXOStats(coins_view, *blockman, stats, hash_type, node.rpc_interruption_point)) {\n         ret.pushKV(\"height\", (int64_t)stats.nHeight);\n         ret.pushKV(\"bestblock\", stats.hashBlock.GetHex());\n         ret.pushKV(\"transactions\", (int64_t)stats.nTransactions);\n@@ -1135,6 +1166,8 @@ static RPCHelpMan gettxout()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n+    ChainstateManager& chainman = EnsureChainman(node);\n     LOCK(cs_main);\n \n     UniValue ret(UniValue::VOBJ);\n@@ -1147,10 +1180,11 @@ static RPCHelpMan gettxout()\n         fMempool = request.params[2].get_bool();\n \n     Coin coin;\n-    CCoinsViewCache* coins_view = &::ChainstateActive().CoinsTip();\n+    CChainState& active_chainstate = chainman.ActiveChainstate();\n+    CCoinsViewCache* coins_view = &active_chainstate.CoinsTip();\n \n     if (fMempool) {\n-        const CTxMemPool& mempool = EnsureMemPool(request.context);\n+        const CTxMemPool& mempool = EnsureMemPool(node);\n         LOCK(mempool.cs);\n         CCoinsViewMemPool view(coins_view, mempool);\n         if (!view.GetCoin(out, coin) || mempool.isSpent(out)) {\n@@ -1162,7 +1196,7 @@ static RPCHelpMan gettxout()\n         }\n     }\n \n-    const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(coins_view->GetBestBlock());\n+    const CBlockIndex* pindex = active_chainstate.m_blockman.LookupBlockIndex(coins_view->GetBestBlock());\n     ret.pushKV(\"bestblock\", pindex->GetBlockHash().GetHex());\n     if (coin.nHeight == MEMPOOL_HEIGHT) {\n         ret.pushKV(\"confirmations\", 0);\n@@ -1200,39 +1234,41 @@ static RPCHelpMan verifychain()\n     const int check_level(request.params[0].isNull() ? DEFAULT_CHECKLEVEL : request.params[0].get_int());\n     const int check_depth{request.params[1].isNull() ? DEFAULT_CHECKBLOCKS : request.params[1].get_int()};\n \n+    ChainstateManager& chainman = EnsureAnyChainman(request.context);\n     LOCK(cs_main);\n \n-    return CVerifyDB().VerifyDB(Params(), ::ChainstateActive(), &::ChainstateActive().CoinsTip(), check_level, check_depth);\n+    CChainState& active_chainstate = chainman.ActiveChainstate();\n+    return CVerifyDB().VerifyDB(Params(), active_chainstate, &active_chainstate.CoinsTip(), check_level, check_depth);\n },\n     };\n }\n \n-static void BuriedForkDescPushBack(UniValue& softforks, const std::string &name, int height) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+static void BuriedForkDescPushBack(UniValue& softforks, const std::string &name, int softfork_height, int tip_height) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     // For buried deployments.\n     // A buried deployment is one where the height of the activation has been hardcoded into\n     // the client implementation long after the consensus change has activated. See BIP 90.\n     // Buried deployments with activation height value of\n     // std::numeric_limits<int>::max() are disabled and thus hidden.\n-    if (height == std::numeric_limits<int>::max()) return;\n+    if (softfork_height == std::numeric_limits<int>::max()) return;\n \n     UniValue rv(UniValue::VOBJ);\n     rv.pushKV(\"type\", \"buried\");\n     // getblockchaininfo reports the softfork as active from when the chain height is\n     // one below the activation height\n-    rv.pushKV(\"active\", ::ChainActive().Tip()->nHeight + 1 >= height);\n-    rv.pushKV(\"height\", height);\n+    rv.pushKV(\"active\", tip_height + 1 >= softfork_height);\n+    rv.pushKV(\"height\", softfork_height);\n     softforks.pushKV(name, rv);\n }\n \n-static void BIP9SoftForkDescPushBack(UniValue& softforks, const std::string &name, const Consensus::Params& consensusParams, Consensus::DeploymentPos id) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+static void BIP9SoftForkDescPushBack(const CBlockIndex* active_chain_tip, UniValue& softforks, const std::string &name, const Consensus::Params& consensusParams, Consensus::DeploymentPos id) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     // For BIP9 deployments.\n     // Deployments that are never active are hidden.\n     if (consensusParams.vDeployments[id].nStartTime == Consensus::BIP9Deployment::NEVER_ACTIVE) return;\n \n     UniValue bip9(UniValue::VOBJ);\n-    const ThresholdState thresholdState = VersionBitsState(::ChainActive().Tip(), consensusParams, id, versionbitscache);\n+    const ThresholdState thresholdState = VersionBitsState(active_chain_tip, consensusParams, id, versionbitscache);\n     switch (thresholdState) {\n     case ThresholdState::DEFINED: bip9.pushKV(\"status\", \"defined\"); break;\n     case ThresholdState::STARTED: bip9.pushKV(\"status\", \"started\"); break;\n@@ -1246,12 +1282,12 @@ static void BIP9SoftForkDescPushBack(UniValue& softforks, const std::string &nam\n     }\n     bip9.pushKV(\"start_time\", consensusParams.vDeployments[id].nStartTime);\n     bip9.pushKV(\"timeout\", consensusParams.vDeployments[id].nTimeout);\n-    int64_t since_height = VersionBitsStateSinceHeight(::ChainActive().Tip(), consensusParams, id, versionbitscache);\n+    int64_t since_height = VersionBitsStateSinceHeight(active_chain_tip, consensusParams, id, versionbitscache);\n     bip9.pushKV(\"since\", since_height);\n     if (ThresholdState::STARTED == thresholdState)\n     {\n         UniValue statsUV(UniValue::VOBJ);\n-        BIP9Stats statsStruct = VersionBitsStatistics(::ChainActive().Tip(), consensusParams, id);\n+        BIP9Stats statsStruct = VersionBitsStatistics(active_chain_tip, consensusParams, id);\n         statsUV.pushKV(\"period\", statsStruct.period);\n         statsUV.pushKV(\"threshold\", statsStruct.threshold);\n         statsUV.pushKV(\"elapsed\", statsStruct.elapsed);\n@@ -1328,18 +1364,22 @@ RPCHelpMan getblockchaininfo()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n+    ChainstateManager& chainman = EnsureAnyChainman(request.context);\n     LOCK(cs_main);\n+    CChainState& active_chainstate = chainman.ActiveChainstate();\n \n-    const CBlockIndex* tip = ::ChainActive().Tip();\n+    const CBlockIndex* tip = active_chainstate.m_chain.Tip();\n+    CHECK_NONFATAL(tip);\n+    const int height = tip->nHeight;\n     UniValue obj(UniValue::VOBJ);\n     obj.pushKV(\"chain\",                 Params().NetworkIDString());\n-    obj.pushKV(\"blocks\",                (int)::ChainActive().Height());\n+    obj.pushKV(\"blocks\",                height);\n     obj.pushKV(\"headers\",               pindexBestHeader ? pindexBestHeader->nHeight : -1);\n     obj.pushKV(\"bestblockhash\",         tip->GetBlockHash().GetHex());\n     obj.pushKV(\"difficulty\",            (double)GetDifficulty(tip));\n     obj.pushKV(\"mediantime\",            (int64_t)tip->GetMedianTimePast());\n     obj.pushKV(\"verificationprogress\",  GuessVerificationProgress(Params().TxData(), tip));\n-    obj.pushKV(\"initialblockdownload\",  ::ChainstateActive().IsInitialBlockDownload());\n+    obj.pushKV(\"initialblockdownload\",  active_chainstate.IsInitialBlockDownload());\n     obj.pushKV(\"chainwork\",             tip->nChainWork.GetHex());\n     obj.pushKV(\"size_on_disk\",          CalculateCurrentUsage());\n     obj.pushKV(\"pruned\",                fPruneMode);\n@@ -1362,13 +1402,13 @@ RPCHelpMan getblockchaininfo()\n \n     const Consensus::Params& consensusParams = Params().GetConsensus();\n     UniValue softforks(UniValue::VOBJ);\n-    BuriedForkDescPushBack(softforks, \"bip34\", consensusParams.BIP34Height);\n-    BuriedForkDescPushBack(softforks, \"bip66\", consensusParams.BIP66Height);\n-    BuriedForkDescPushBack(softforks, \"bip65\", consensusParams.BIP65Height);\n-    BuriedForkDescPushBack(softforks, \"csv\", consensusParams.CSVHeight);\n-    BuriedForkDescPushBack(softforks, \"segwit\", consensusParams.SegwitHeight);\n-    BIP9SoftForkDescPushBack(softforks, \"testdummy\", consensusParams, Consensus::DEPLOYMENT_TESTDUMMY);\n-    BIP9SoftForkDescPushBack(softforks, \"taproot\", consensusParams, Consensus::DEPLOYMENT_TAPROOT);\n+    BuriedForkDescPushBack(softforks, \"bip34\", consensusParams.BIP34Height, height);\n+    BuriedForkDescPushBack(softforks, \"bip66\", consensusParams.BIP66Height, height);\n+    BuriedForkDescPushBack(softforks, \"bip65\", consensusParams.BIP65Height, height);\n+    BuriedForkDescPushBack(softforks, \"csv\", consensusParams.CSVHeight, height);\n+    BuriedForkDescPushBack(softforks, \"segwit\", consensusParams.SegwitHeight, height);\n+    BIP9SoftForkDescPushBack(tip, softforks, \"testdummy\", consensusParams, Consensus::DEPLOYMENT_TESTDUMMY);\n+    BIP9SoftForkDescPushBack(tip, softforks, \"taproot\", consensusParams, Consensus::DEPLOYMENT_TAPROOT);\n     obj.pushKV(\"softforks\",             softforks);\n \n     obj.pushKV(\"warnings\", GetWarnings(false).original);\n@@ -1419,8 +1459,9 @@ static RPCHelpMan getchaintips()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    ChainstateManager& chainman = EnsureChainman(request.context);\n+    ChainstateManager& chainman = EnsureAnyChainman(request.context);\n     LOCK(cs_main);\n+    CChain& active_chain = chainman.ActiveChain();\n \n     /*\n      * Idea: The set of chain tips is the active chain tip, plus orphan blocks which do not have another orphan building off of them.\n@@ -1434,7 +1475,7 @@ static RPCHelpMan getchaintips()\n     std::set<const CBlockIndex*> setPrevs;\n \n     for (const std::pair<const uint256, CBlockIndex*>& item : chainman.BlockIndex()) {\n-        if (!chainman.ActiveChain().Contains(item.second)) {\n+        if (!active_chain.Contains(item.second)) {\n             setOrphans.insert(item.second);\n             setPrevs.insert(item.second->pprev);\n         }\n@@ -1447,7 +1488,7 @@ static RPCHelpMan getchaintips()\n     }\n \n     // Always report the currently active tip.\n-    setTips.insert(chainman.ActiveChain().Tip());\n+    setTips.insert(active_chain.Tip());\n \n     /* Construct the output array.  */\n     UniValue res(UniValue::VARR);\n@@ -1456,11 +1497,11 @@ static RPCHelpMan getchaintips()\n         obj.pushKV(\"height\", block->nHeight);\n         obj.pushKV(\"hash\", block->phashBlock->GetHex());\n \n-        const int branchLen = block->nHeight - chainman.ActiveChain().FindFork(block)->nHeight;\n+        const int branchLen = block->nHeight - active_chain.FindFork(block)->nHeight;\n         obj.pushKV(\"branchlen\", branchLen);\n \n         std::string status;\n-        if (chainman.ActiveChain().Contains(block)) {\n+        if (active_chain.Contains(block)) {\n             // This block is part of the currently active chain.\n             status = \"active\";\n         } else if (block->nStatus & BLOCK_FAILED_MASK) {\n@@ -1531,7 +1572,7 @@ static RPCHelpMan getmempoolinfo()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    return MempoolInfoToJSON(EnsureMemPool(request.context));\n+    return MempoolInfoToJSON(EnsureAnyMemPool(request.context));\n },\n     };\n }\n@@ -1555,16 +1596,17 @@ static RPCHelpMan preciousblock()\n     uint256 hash(ParseHashV(request.params[0], \"blockhash\"));\n     CBlockIndex* pblockindex;\n \n+    ChainstateManager& chainman = EnsureAnyChainman(request.context);\n     {\n         LOCK(cs_main);\n-        pblockindex = g_chainman.m_blockman.LookupBlockIndex(hash);\n+        pblockindex = chainman.m_blockman.LookupBlockIndex(hash);\n         if (!pblockindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         }\n     }\n \n     BlockValidationState state;\n-    ::ChainstateActive().PreciousBlock(state, Params(), pblockindex);\n+    chainman.ActiveChainstate().PreciousBlock(state, Params(), pblockindex);\n \n     if (!state.IsValid()) {\n         throw JSONRPCError(RPC_DATABASE_ERROR, state.ToString());\n@@ -1592,18 +1634,19 @@ static RPCHelpMan invalidateblock()\n     uint256 hash(ParseHashV(request.params[0], \"blockhash\"));\n     BlockValidationState state;\n \n+    ChainstateManager& chainman = EnsureAnyChainman(request.context);\n     CBlockIndex* pblockindex;\n     {\n         LOCK(cs_main);\n-        pblockindex = g_chainman.m_blockman.LookupBlockIndex(hash);\n+        pblockindex = chainman.m_blockman.LookupBlockIndex(hash);\n         if (!pblockindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         }\n     }\n-    ::ChainstateActive().InvalidateBlock(state, Params(), pblockindex);\n+    chainman.ActiveChainstate().InvalidateBlock(state, Params(), pblockindex);\n \n     if (state.IsValid()) {\n-        ::ChainstateActive().ActivateBestChain(state, Params());\n+        chainman.ActiveChainstate().ActivateBestChain(state, Params());\n     }\n \n     if (!state.IsValid()) {\n@@ -1630,20 +1673,21 @@ static RPCHelpMan reconsiderblock()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n+    ChainstateManager& chainman = EnsureAnyChainman(request.context);\n     uint256 hash(ParseHashV(request.params[0], \"blockhash\"));\n \n     {\n         LOCK(cs_main);\n-        CBlockIndex* pblockindex = g_chainman.m_blockman.LookupBlockIndex(hash);\n+        CBlockIndex* pblockindex = chainman.m_blockman.LookupBlockIndex(hash);\n         if (!pblockindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         }\n \n-        ::ChainstateActive().ResetBlockFailureFlags(pblockindex);\n+        chainman.ActiveChainstate().ResetBlockFailureFlags(pblockindex);\n     }\n \n     BlockValidationState state;\n-    ::ChainstateActive().ActivateBestChain(state, Params());\n+    chainman.ActiveChainstate().ActivateBestChain(state, Params());\n \n     if (!state.IsValid()) {\n         throw JSONRPCError(RPC_DATABASE_ERROR, state.ToString());\n@@ -1680,20 +1724,21 @@ static RPCHelpMan getchaintxstats()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n+    ChainstateManager& chainman = EnsureAnyChainman(request.context);\n     const CBlockIndex* pindex;\n     int blockcount = 30 * 24 * 60 * 60 / Params().GetConsensus().nPowTargetSpacing; // By default: 1 month\n \n     if (request.params[1].isNull()) {\n         LOCK(cs_main);\n-        pindex = ::ChainActive().Tip();\n+        pindex = chainman.ActiveChain().Tip();\n     } else {\n         uint256 hash(ParseHashV(request.params[1], \"blockhash\"));\n         LOCK(cs_main);\n-        pindex = g_chainman.m_blockman.LookupBlockIndex(hash);\n+        pindex = chainman.m_blockman.LookupBlockIndex(hash);\n         if (!pindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         }\n-        if (!::ChainActive().Contains(pindex)) {\n+        if (!chainman.ActiveChain().Contains(pindex)) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Block is not in main chain\");\n         }\n     }\n@@ -1861,27 +1906,29 @@ static RPCHelpMan getblockstats()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n+    ChainstateManager& chainman = EnsureAnyChainman(request.context);\n     LOCK(cs_main);\n+    CChain& active_chain = chainman.ActiveChain();\n \n     CBlockIndex* pindex;\n     if (request.params[0].isNum()) {\n         const int height = request.params[0].get_int();\n-        const int current_tip = ::ChainActive().Height();\n+        const int current_tip = active_chain.Height();\n         if (height < 0) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d is negative\", height));\n         }\n         if (height > current_tip) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d after current tip %d\", height, current_tip));\n         }\n \n-        pindex = ::ChainActive()[height];\n+        pindex = active_chain[height];\n     } else {\n         const uint256 hash(ParseHashV(request.params[0], \"hash_or_height\"));\n-        pindex = g_chainman.m_blockman.LookupBlockIndex(hash);\n+        pindex = chainman.m_blockman.LookupBlockIndex(hash);\n         if (!pindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         }\n-        if (!::ChainActive().Contains(pindex)) {\n+        if (!active_chain.Contains(pindex)) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Block is not in chain %s\", Params().NetworkIDString()));\n         }\n     }\n@@ -2072,7 +2119,7 @@ static RPCHelpMan savemempool()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    const CTxMemPool& mempool = EnsureMemPool(request.context);\n+    const CTxMemPool& mempool = EnsureAnyMemPool(request.context);\n \n     if (!mempool.IsLoaded()) {\n         throw JSONRPCError(RPC_MISC_ERROR, \"The mempool was not loaded yet\");\n@@ -2262,15 +2309,17 @@ static RPCHelpMan scantxoutset()\n         int64_t count = 0;\n         std::unique_ptr<CCoinsViewCursor> pcursor;\n         CBlockIndex* tip;\n+        NodeContext& node = EnsureAnyNodeContext(request.context);\n         {\n+            ChainstateManager& chainman = EnsureChainman(node);\n             LOCK(cs_main);\n-            ::ChainstateActive().ForceFlushStateToDisk();\n-            pcursor = std::unique_ptr<CCoinsViewCursor>(::ChainstateActive().CoinsDB().Cursor());\n+            CChainState& active_chainstate = chainman.ActiveChainstate();\n+            active_chainstate.ForceFlushStateToDisk();\n+            pcursor = std::unique_ptr<CCoinsViewCursor>(active_chainstate.CoinsDB().Cursor());\n             CHECK_NONFATAL(pcursor);\n-            tip = ::ChainActive().Tip();\n+            tip = active_chainstate.m_chain.Tip();\n             CHECK_NONFATAL(tip);\n         }\n-        NodeContext& node = EnsureNodeContext(request.context);\n         bool res = FindScriptPubKey(g_scan_progress, g_should_abort_scan, count, pcursor.get(), needles, coins, node.rpc_interruption_point);\n         result.pushKV(\"success\", res);\n         result.pushKV(\"txouts\", count);\n@@ -2343,8 +2392,9 @@ static RPCHelpMan getblockfilter()\n     const CBlockIndex* block_index;\n     bool block_was_connected;\n     {\n+        ChainstateManager& chainman = EnsureAnyChainman(request.context);\n         LOCK(cs_main);\n-        block_index = g_chainman.m_blockman.LookupBlockIndex(block_hash);\n+        block_index = chainman.m_blockman.LookupBlockIndex(block_hash);\n         if (!block_index) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         }\n@@ -2427,7 +2477,7 @@ static RPCHelpMan dumptxoutset()\n \n     FILE* file{fsbridge::fopen(temppath, \"wb\")};\n     CAutoFile afile{file, SER_DISK, CLIENT_VERSION};\n-    NodeContext& node = EnsureNodeContext(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n     UniValue result = CreateUTXOSnapshot(node, node.chainman->ActiveChainstate(), afile);\n     fs::rename(temppath, path);\n \n@@ -2465,7 +2515,7 @@ UniValue CreateUTXOSnapshot(NodeContext& node, CChainState& chainstate, CAutoFil\n         }\n \n         pcursor = std::unique_ptr<CCoinsViewCursor>(chainstate.CoinsDB().Cursor());\n-        tip = g_chainman.m_blockman.LookupBlockIndex(stats.hashBlock);\n+        tip = chainstate.m_blockman.LookupBlockIndex(stats.hashBlock);\n         CHECK_NONFATAL(tip);\n     }\n "
      },
      {
        "sha": "ffb6f03b476fc785f243b7e5d1c793d861d52808",
        "filename": "src/rpc/blockchain.h",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f00e799b4ac718b892ee4c3dac18074256e90b52/src/rpc/blockchain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f00e799b4ac718b892ee4c3dac18074256e90b52/src/rpc/blockchain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.h?ref=f00e799b4ac718b892ee4c3dac18074256e90b52",
        "patch": "@@ -56,10 +56,13 @@ void CalculatePercentilesByWeight(CAmount result[NUM_GETBLOCKSTATS_PERCENTILES],\n void ScriptPubKeyToUniv(const CScript& scriptPubKey, UniValue& out, bool fIncludeHex);\n void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry, bool include_hex = true, int serialize_flags = 0, const CTxUndo* txundo = nullptr);\n \n-NodeContext& EnsureNodeContext(const std::any& context);\n-CTxMemPool& EnsureMemPool(const std::any& context);\n-ChainstateManager& EnsureChainman(const std::any& context);\n-CBlockPolicyEstimator& EnsureFeeEstimator(const std::any& context);\n+NodeContext& EnsureAnyNodeContext(const std::any& context);\n+CTxMemPool& EnsureMemPool(const NodeContext& node);\n+CTxMemPool& EnsureAnyMemPool(const std::any& context);\n+ChainstateManager& EnsureChainman(const NodeContext& node);\n+ChainstateManager& EnsureAnyChainman(const std::any& context);\n+CBlockPolicyEstimator& EnsureFeeEstimator(const NodeContext& node);\n+CBlockPolicyEstimator& EnsureAnyFeeEstimator(const std::any& context);\n \n /**\n  * Helper to create UTXO snapshots given a chainstate and a file handle."
      },
      {
        "sha": "0cef310c500cc3936636d72b2e5b3114905d779c",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 56,
        "deletions": 39,
        "changes": 95,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f00e799b4ac718b892ee4c3dac18074256e90b52/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f00e799b4ac718b892ee4c3dac18074256e90b52/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=f00e799b4ac718b892ee4c3dac18074256e90b52",
        "patch": "@@ -44,11 +44,12 @@\n  * or from the last difficulty change if 'lookup' is nonpositive.\n  * If 'height' is nonnegative, compute the estimate at the time when a given block was found.\n  */\n-static UniValue GetNetworkHashPS(int lookup, int height) {\n-    CBlockIndex *pb = ::ChainActive().Tip();\n+static UniValue GetNetworkHashPS(int lookup, int height, const CChain& active_chain) {\n+    const CBlockIndex* pb = active_chain.Tip();\n \n-    if (height >= 0 && height < ::ChainActive().Height())\n-        pb = ::ChainActive()[height];\n+    if (height >= 0 && height < active_chain.Height()) {\n+        pb = active_chain[height];\n+    }\n \n     if (pb == nullptr || !pb->nHeight)\n         return 0;\n@@ -61,7 +62,7 @@ static UniValue GetNetworkHashPS(int lookup, int height) {\n     if (lookup > pb->nHeight)\n         lookup = pb->nHeight;\n \n-    CBlockIndex *pb0 = pb;\n+    const CBlockIndex* pb0 = pb;\n     int64_t minTime = pb0->GetBlockTime();\n     int64_t maxTime = minTime;\n     for (int i = 0; i < lookup; i++) {\n@@ -99,8 +100,9 @@ static RPCHelpMan getnetworkhashps()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n+    ChainstateManager& chainman = EnsureAnyChainman(request.context);\n     LOCK(cs_main);\n-    return GetNetworkHashPS(!request.params[0].isNull() ? request.params[0].get_int() : 120, !request.params[1].isNull() ? request.params[1].get_int() : -1);\n+    return GetNetworkHashPS(!request.params[0].isNull() ? request.params[0].get_int() : 120, !request.params[1].isNull() ? request.params[1].get_int() : -1, chainman.ActiveChain());\n },\n     };\n }\n@@ -111,7 +113,8 @@ static bool GenerateBlock(ChainstateManager& chainman, CBlock& block, uint64_t&\n \n     {\n         LOCK(cs_main);\n-        IncrementExtraNonce(&block, ::ChainActive().Tip(), extra_nonce);\n+        CHECK_NONFATAL(std::addressof(::ChainActive()) == std::addressof(chainman.ActiveChain()));\n+        IncrementExtraNonce(&block, chainman.ActiveChain().Tip(), extra_nonce);\n     }\n \n     CChainParams chainparams(Params());\n@@ -143,7 +146,8 @@ static UniValue generateBlocks(ChainstateManager& chainman, const CTxMemPool& me\n \n     {   // Don't keep cs_main locked\n         LOCK(cs_main);\n-        nHeight = ::ChainActive().Height();\n+        CHECK_NONFATAL(std::addressof(::ChainActive()) == std::addressof(chainman.ActiveChain()));\n+        nHeight = chainman.ActiveChain().Height();\n         nHeightEnd = nHeight+nGenerate;\n     }\n     unsigned int nExtraNonce = 0;\n@@ -231,8 +235,9 @@ static RPCHelpMan generatetodescriptor()\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, error);\n     }\n \n-    const CTxMemPool& mempool = EnsureMemPool(request.context);\n-    ChainstateManager& chainman = EnsureChainman(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n+    const CTxMemPool& mempool = EnsureMemPool(node);\n+    ChainstateManager& chainman = EnsureChainman(node);\n \n     return generateBlocks(chainman, mempool, coinbase_script, num_blocks, max_tries);\n },\n@@ -276,8 +281,9 @@ static RPCHelpMan generatetoaddress()\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Error: Invalid address\");\n     }\n \n-    const CTxMemPool& mempool = EnsureMemPool(request.context);\n-    ChainstateManager& chainman = EnsureChainman(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n+    const CTxMemPool& mempool = EnsureMemPool(node);\n+    ChainstateManager& chainman = EnsureChainman(node);\n \n     CScript coinbase_script = GetScriptForDestination(destination);\n \n@@ -325,7 +331,8 @@ static RPCHelpMan generateblock()\n         coinbase_script = GetScriptForDestination(destination);\n     }\n \n-    const CTxMemPool& mempool = EnsureMemPool(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n+    const CTxMemPool& mempool = EnsureMemPool(node);\n \n     std::vector<CTransactionRef> txs;\n     const auto raw_txs_or_txids = request.params[1].get_array();\n@@ -354,11 +361,12 @@ static RPCHelpMan generateblock()\n     CChainParams chainparams(Params());\n     CBlock block;\n \n+    ChainstateManager& chainman = EnsureChainman(node);\n     {\n         LOCK(cs_main);\n \n         CTxMemPool empty_mempool;\n-        std::unique_ptr<CBlockTemplate> blocktemplate(BlockAssembler(::ChainstateActive(), empty_mempool, chainparams).CreateNewBlock(coinbase_script));\n+        std::unique_ptr<CBlockTemplate> blocktemplate(BlockAssembler(chainman.ActiveChainstate(), empty_mempool, chainparams).CreateNewBlock(coinbase_script));\n         if (!blocktemplate) {\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Couldn't create new block\");\n         }\n@@ -369,13 +377,14 @@ static RPCHelpMan generateblock()\n \n     // Add transactions\n     block.vtx.insert(block.vtx.end(), txs.begin(), txs.end());\n-    RegenerateCommitments(block, WITH_LOCK(::cs_main, return std::ref(g_chainman.m_blockman)));\n+    CBlockIndex* prev_block = WITH_LOCK(::cs_main, return chainman.m_blockman.LookupBlockIndex(block.hashPrevBlock));\n+    RegenerateCommitments(block, prev_block);\n \n     {\n         LOCK(cs_main);\n \n         BlockValidationState state;\n-        if (!TestBlockValidity(state, chainparams, ::ChainstateActive(), block, g_chainman.m_blockman.LookupBlockIndex(block.hashPrevBlock), false, false)) {\n+        if (!TestBlockValidity(state, chainparams, chainman.ActiveChainstate(), block, chainman.m_blockman.LookupBlockIndex(block.hashPrevBlock), false, false)) {\n             throw JSONRPCError(RPC_VERIFY_ERROR, strprintf(\"TestBlockValidity failed: %s\", state.ToString()));\n         }\n     }\n@@ -384,7 +393,7 @@ static RPCHelpMan generateblock()\n     uint64_t max_tries{DEFAULT_MAX_TRIES};\n     unsigned int extra_nonce{0};\n \n-    if (!GenerateBlock(EnsureChainman(request.context), block, max_tries, extra_nonce, block_hash) || block_hash.IsNull()) {\n+    if (!GenerateBlock(chainman, block, max_tries, extra_nonce, block_hash) || block_hash.IsNull()) {\n         throw JSONRPCError(RPC_MISC_ERROR, \"Failed to make block.\");\n     }\n \n@@ -418,14 +427,17 @@ static RPCHelpMan getmininginfo()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n+    const CTxMemPool& mempool = EnsureMemPool(node);\n+    ChainstateManager& chainman = EnsureChainman(node);\n     LOCK(cs_main);\n-    const CTxMemPool& mempool = EnsureMemPool(request.context);\n+    const CChain& active_chain = chainman.ActiveChain();\n \n     UniValue obj(UniValue::VOBJ);\n-    obj.pushKV(\"blocks\",           (int)::ChainActive().Height());\n+    obj.pushKV(\"blocks\",           active_chain.Height());\n     if (BlockAssembler::m_last_block_weight) obj.pushKV(\"currentblockweight\", *BlockAssembler::m_last_block_weight);\n     if (BlockAssembler::m_last_block_num_txs) obj.pushKV(\"currentblocktx\", *BlockAssembler::m_last_block_num_txs);\n-    obj.pushKV(\"difficulty\",       (double)GetDifficulty(::ChainActive().Tip()));\n+    obj.pushKV(\"difficulty\",       (double)GetDifficulty(active_chain.Tip()));\n     obj.pushKV(\"networkhashps\",    getnetworkhashps().HandleRequest(request));\n     obj.pushKV(\"pooledtx\",         (uint64_t)mempool.size());\n     obj.pushKV(\"chain\",            Params().NetworkIDString());\n@@ -467,7 +479,7 @@ static RPCHelpMan prioritisetransaction()\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Priority is no longer supported, dummy argument to prioritisetransaction must be 0.\");\n     }\n \n-    EnsureMemPool(request.context).PrioritiseTransaction(hash, nAmount);\n+    EnsureAnyMemPool(request.context).PrioritiseTransaction(hash, nAmount);\n     return true;\n },\n     };\n@@ -588,12 +600,16 @@ static RPCHelpMan getblocktemplate()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n+    ChainstateManager& chainman = EnsureChainman(node);\n     LOCK(cs_main);\n \n     std::string strMode = \"template\";\n     UniValue lpval = NullUniValue;\n     std::set<std::string> setClientRules;\n     int64_t nMaxVersionPreVB = -1;\n+    CChainState& active_chainstate = chainman.ActiveChainstate();\n+    CChain& active_chain = active_chainstate.m_chain;\n     if (!request.params[0].isNull())\n     {\n         const UniValue& oparam = request.params[0].get_obj();\n@@ -619,7 +635,7 @@ static RPCHelpMan getblocktemplate()\n                 throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Block decode failed\");\n \n             uint256 hash = block.GetHash();\n-            const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(hash);\n+            const CBlockIndex* pindex = chainman.m_blockman.LookupBlockIndex(hash);\n             if (pindex) {\n                 if (pindex->IsValid(BLOCK_VALID_SCRIPTS))\n                     return \"duplicate\";\n@@ -628,12 +644,12 @@ static RPCHelpMan getblocktemplate()\n                 return \"duplicate-inconclusive\";\n             }\n \n-            CBlockIndex* const pindexPrev = ::ChainActive().Tip();\n+            CBlockIndex* const pindexPrev = active_chain.Tip();\n             // TestBlockValidity only supports blocks built on the current Tip\n             if (block.hashPrevBlock != pindexPrev->GetBlockHash())\n                 return \"inconclusive-not-best-prevblk\";\n             BlockValidationState state;\n-            TestBlockValidity(state, Params(), ::ChainstateActive(), block, pindexPrev, false, true);\n+            TestBlockValidity(state, Params(), active_chainstate, block, pindexPrev, false, true);\n             return BIP22ValidationResult(state);\n         }\n \n@@ -655,7 +671,6 @@ static RPCHelpMan getblocktemplate()\n     if (strMode != \"template\")\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid mode\");\n \n-    NodeContext& node = EnsureNodeContext(request.context);\n     if(!node.connman)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n \n@@ -664,13 +679,13 @@ static RPCHelpMan getblocktemplate()\n             throw JSONRPCError(RPC_CLIENT_NOT_CONNECTED, PACKAGE_NAME \" is not connected!\");\n         }\n \n-        if (::ChainstateActive().IsInitialBlockDownload()) {\n+        if (active_chainstate.IsInitialBlockDownload()) {\n             throw JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, PACKAGE_NAME \" is in initial sync and waiting for blocks...\");\n         }\n     }\n \n     static unsigned int nTransactionsUpdatedLast;\n-    const CTxMemPool& mempool = EnsureMemPool(request.context);\n+    const CTxMemPool& mempool = EnsureMemPool(node);\n \n     if (!lpval.isNull())\n     {\n@@ -690,7 +705,7 @@ static RPCHelpMan getblocktemplate()\n         else\n         {\n             // NOTE: Spec does not specify behaviour for non-string longpollid, but this makes testing easier\n-            hashWatchedChain = ::ChainActive().Tip()->GetBlockHash();\n+            hashWatchedChain = active_chain.Tip()->GetBlockHash();\n             nTransactionsUpdatedLastLP = nTransactionsUpdatedLast;\n         }\n \n@@ -735,20 +750,20 @@ static RPCHelpMan getblocktemplate()\n     static CBlockIndex* pindexPrev;\n     static int64_t nStart;\n     static std::unique_ptr<CBlockTemplate> pblocktemplate;\n-    if (pindexPrev != ::ChainActive().Tip() ||\n+    if (pindexPrev != active_chain.Tip() ||\n         (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 5))\n     {\n         // Clear pindexPrev so future calls make a new block, despite any failures from here on\n         pindexPrev = nullptr;\n \n         // Store the pindexBest used before CreateNewBlock, to avoid races\n         nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();\n-        CBlockIndex* pindexPrevNew = ::ChainActive().Tip();\n+        CBlockIndex* pindexPrevNew = active_chain.Tip();\n         nStart = GetTime();\n \n         // Create new block\n         CScript scriptDummy = CScript() << OP_TRUE;\n-        pblocktemplate = BlockAssembler(::ChainstateActive(), mempool, Params()).CreateNewBlock(scriptDummy);\n+        pblocktemplate = BlockAssembler(active_chainstate, mempool, Params()).CreateNewBlock(scriptDummy);\n         if (!pblocktemplate)\n             throw JSONRPCError(RPC_OUT_OF_MEMORY, \"Out of memory\");\n \n@@ -884,7 +899,7 @@ static RPCHelpMan getblocktemplate()\n     result.pushKV(\"transactions\", transactions);\n     result.pushKV(\"coinbaseaux\", aux);\n     result.pushKV(\"coinbasevalue\", (int64_t)pblock->vtx[0]->vout[0].nValue);\n-    result.pushKV(\"longpollid\", ::ChainActive().Tip()->GetBlockHash().GetHex() + ToString(nTransactionsUpdatedLast));\n+    result.pushKV(\"longpollid\", active_chain.Tip()->GetBlockHash().GetHex() + ToString(nTransactionsUpdatedLast));\n     result.pushKV(\"target\", hashTarget.GetHex());\n     result.pushKV(\"mintime\", (int64_t)pindexPrev->GetMedianTimePast()+1);\n     result.pushKV(\"mutable\", aMutable);\n@@ -967,10 +982,11 @@ static RPCHelpMan submitblock()\n         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Block does not start with a coinbase\");\n     }\n \n+    ChainstateManager& chainman = EnsureAnyChainman(request.context);\n     uint256 hash = block.GetHash();\n     {\n         LOCK(cs_main);\n-        const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(hash);\n+        const CBlockIndex* pindex = chainman.m_blockman.LookupBlockIndex(hash);\n         if (pindex) {\n             if (pindex->IsValid(BLOCK_VALID_SCRIPTS)) {\n                 return \"duplicate\";\n@@ -983,7 +999,7 @@ static RPCHelpMan submitblock()\n \n     {\n         LOCK(cs_main);\n-        const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(block.hashPrevBlock);\n+        const CBlockIndex* pindex = chainman.m_blockman.LookupBlockIndex(block.hashPrevBlock);\n         if (pindex) {\n             UpdateUncommittedBlockStructures(block, pindex, Params().GetConsensus());\n         }\n@@ -992,7 +1008,7 @@ static RPCHelpMan submitblock()\n     bool new_block;\n     auto sc = std::make_shared<submitblock_StateCatcher>(block.GetHash());\n     RegisterSharedValidationInterface(sc);\n-    bool accepted = EnsureChainman(request.context).ProcessNewBlock(Params(), blockptr, /* fForceProcessing */ true, /* fNewBlock */ &new_block);\n+    bool accepted = chainman.ProcessNewBlock(Params(), blockptr, /* fForceProcessing */ true, /* fNewBlock */ &new_block);\n     UnregisterSharedValidationInterface(sc);\n     if (!new_block && accepted) {\n         return \"duplicate\";\n@@ -1025,15 +1041,16 @@ static RPCHelpMan submitheader()\n     if (!DecodeHexBlockHeader(h, request.params[0].get_str())) {\n         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Block header decode failed\");\n     }\n+    ChainstateManager& chainman = EnsureAnyChainman(request.context);\n     {\n         LOCK(cs_main);\n-        if (!g_chainman.m_blockman.LookupBlockIndex(h.hashPrevBlock)) {\n+        if (!chainman.m_blockman.LookupBlockIndex(h.hashPrevBlock)) {\n             throw JSONRPCError(RPC_VERIFY_ERROR, \"Must submit previous header (\" + h.hashPrevBlock.GetHex() + \") first\");\n         }\n     }\n \n     BlockValidationState state;\n-    EnsureChainman(request.context).ProcessNewBlockHeaders({h}, state, Params());\n+    chainman.ProcessNewBlockHeaders({h}, state, Params());\n     if (state.IsValid()) return NullUniValue;\n     if (state.IsError()) {\n         throw JSONRPCError(RPC_VERIFY_ERROR, state.ToString());\n@@ -1082,7 +1099,7 @@ static RPCHelpMan estimatesmartfee()\n     RPCTypeCheck(request.params, {UniValue::VNUM, UniValue::VSTR});\n     RPCTypeCheckArgument(request.params[0], UniValue::VNUM);\n \n-    CBlockPolicyEstimator& fee_estimator = EnsureFeeEstimator(request.context);\n+    CBlockPolicyEstimator& fee_estimator = EnsureAnyFeeEstimator(request.context);\n \n     unsigned int max_target = fee_estimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);\n     unsigned int conf_target = ParseConfirmTarget(request.params[0], max_target);\n@@ -1170,7 +1187,7 @@ static RPCHelpMan estimaterawfee()\n     RPCTypeCheck(request.params, {UniValue::VNUM, UniValue::VNUM}, true);\n     RPCTypeCheckArgument(request.params[0], UniValue::VNUM);\n \n-    CBlockPolicyEstimator& fee_estimator = EnsureFeeEstimator(request.context);\n+    CBlockPolicyEstimator& fee_estimator = EnsureAnyFeeEstimator(request.context);\n \n     unsigned int max_target = fee_estimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);\n     unsigned int conf_target = ParseConfirmTarget(request.params[0], max_target);"
      },
      {
        "sha": "a5159fb792c3f55ecc543ee569bb23029a39d4f5",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f00e799b4ac718b892ee4c3dac18074256e90b52/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f00e799b4ac718b892ee4c3dac18074256e90b52/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=f00e799b4ac718b892ee4c3dac18074256e90b52",
        "patch": "@@ -53,7 +53,7 @@ static RPCHelpMan getconnectioncount()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    NodeContext& node = EnsureNodeContext(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n     if(!node.connman)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n \n@@ -76,7 +76,7 @@ static RPCHelpMan ping()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    NodeContext& node = EnsureNodeContext(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n     if (!node.peerman) {\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n     }\n@@ -165,7 +165,7 @@ static RPCHelpMan getpeerinfo()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    NodeContext& node = EnsureNodeContext(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n     if(!node.connman || !node.peerman) {\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n     }\n@@ -285,7 +285,7 @@ static RPCHelpMan addnode()\n             self.ToString());\n     }\n \n-    NodeContext& node = EnsureNodeContext(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n     if(!node.connman)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n \n@@ -350,7 +350,7 @@ static RPCHelpMan addconnection()\n         throw JSONRPCError(RPC_INVALID_PARAMETER, self.ToString());\n     }\n \n-    NodeContext& node = EnsureNodeContext(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n     if (!node.connman) {\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled.\");\n     }\n@@ -388,7 +388,7 @@ static RPCHelpMan disconnectnode()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    NodeContext& node = EnsureNodeContext(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n     if(!node.connman)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n \n@@ -448,7 +448,7 @@ static RPCHelpMan getaddednodeinfo()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    NodeContext& node = EnsureNodeContext(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n     if(!node.connman)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n \n@@ -519,7 +519,7 @@ static RPCHelpMan getnettotals()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    NodeContext& node = EnsureNodeContext(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n     if(!node.connman)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n \n@@ -618,7 +618,7 @@ static RPCHelpMan getnetworkinfo()\n     obj.pushKV(\"version\",       CLIENT_VERSION);\n     obj.pushKV(\"subversion\",    strSubVersion);\n     obj.pushKV(\"protocolversion\",PROTOCOL_VERSION);\n-    NodeContext& node = EnsureNodeContext(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n     if (node.connman) {\n         ServiceFlags services = node.connman->GetLocalServices();\n         obj.pushKV(\"localservices\", strprintf(\"%016x\", services));\n@@ -680,7 +680,7 @@ static RPCHelpMan setban()\n     if (strCommand != \"add\" && strCommand != \"remove\") {\n         throw std::runtime_error(help.ToString());\n     }\n-    NodeContext& node = EnsureNodeContext(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n     if (!node.banman) {\n         throw JSONRPCError(RPC_DATABASE_ERROR, \"Error: Ban database not loaded\");\n     }\n@@ -762,7 +762,7 @@ static RPCHelpMan listbanned()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    NodeContext& node = EnsureNodeContext(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n     if(!node.banman) {\n         throw JSONRPCError(RPC_DATABASE_ERROR, \"Error: Ban database not loaded\");\n     }\n@@ -802,7 +802,7 @@ static RPCHelpMan clearbanned()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    NodeContext& node = EnsureNodeContext(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n     if (!node.banman) {\n         throw JSONRPCError(RPC_DATABASE_ERROR, \"Error: Ban database not loaded\");\n     }\n@@ -825,7 +825,7 @@ static RPCHelpMan setnetworkactive()\n                 RPCExamples{\"\"},\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    NodeContext& node = EnsureNodeContext(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n     if (!node.connman) {\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n     }\n@@ -863,7 +863,7 @@ static RPCHelpMan getnodeaddresses()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    NodeContext& node = EnsureNodeContext(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n     if (!node.connman) {\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n     }\n@@ -909,7 +909,7 @@ static RPCHelpMan addpeeraddress()\n         },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    NodeContext& node = EnsureNodeContext(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n     if (!node.addrman) {\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Address manager functionality missing or disabled\");\n     }"
      },
      {
        "sha": "ecdd00dcca82206c3b4f13cef5afab901b168f36",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 24,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f00e799b4ac718b892ee4c3dac18074256e90b52/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f00e799b4ac718b892ee4c3dac18074256e90b52/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=f00e799b4ac718b892ee4c3dac18074256e90b52",
        "patch": "@@ -41,7 +41,7 @@\n \n #include <univalue.h>\n \n-static void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n+static void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry, CChainState& active_chainstate)\n {\n     // Call into TxToUniv() in bitcoin-common to decode the transaction hex.\n     //\n@@ -54,10 +54,10 @@ static void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue&\n         LOCK(cs_main);\n \n         entry.pushKV(\"blockhash\", hashBlock.GetHex());\n-        CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(hashBlock);\n+        CBlockIndex* pindex = active_chainstate.m_blockman.LookupBlockIndex(hashBlock);\n         if (pindex) {\n-            if (::ChainActive().Contains(pindex)) {\n-                entry.pushKV(\"confirmations\", 1 + ::ChainActive().Height() - pindex->nHeight);\n+            if (active_chainstate.m_chain.Contains(pindex)) {\n+                entry.pushKV(\"confirmations\", 1 + active_chainstate.m_chain.Height() - pindex->nHeight);\n                 entry.pushKV(\"time\", pindex->GetBlockTime());\n                 entry.pushKV(\"blocktime\", pindex->GetBlockTime());\n             }\n@@ -158,7 +158,8 @@ static RPCHelpMan getrawtransaction()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    const NodeContext& node = EnsureNodeContext(request.context);\n+    const NodeContext& node = EnsureAnyNodeContext(request.context);\n+    ChainstateManager& chainman = EnsureChainman(node);\n \n     bool in_active_chain = true;\n     uint256 hash = ParseHashV(request.params[0], \"parameter 1\");\n@@ -179,11 +180,11 @@ static RPCHelpMan getrawtransaction()\n         LOCK(cs_main);\n \n         uint256 blockhash = ParseHashV(request.params[2], \"parameter 3\");\n-        blockindex = g_chainman.m_blockman.LookupBlockIndex(blockhash);\n+        blockindex = chainman.m_blockman.LookupBlockIndex(blockhash);\n         if (!blockindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block hash not found\");\n         }\n-        in_active_chain = ::ChainActive().Contains(blockindex);\n+        in_active_chain = chainman.ActiveChain().Contains(blockindex);\n     }\n \n     bool f_txindex_ready = false;\n@@ -216,7 +217,7 @@ static RPCHelpMan getrawtransaction()\n \n     UniValue result(UniValue::VOBJ);\n     if (blockindex) result.pushKV(\"in_active_chain\", in_active_chain);\n-    TxToJSON(*tx, hash_block, result);\n+    TxToJSON(*tx, hash_block, result, chainman.ActiveChainstate());\n     return result;\n },\n     };\n@@ -258,21 +259,23 @@ static RPCHelpMan gettxoutproof()\n \n     CBlockIndex* pblockindex = nullptr;\n     uint256 hashBlock;\n+    ChainstateManager& chainman = EnsureAnyChainman(request.context);\n     if (!request.params[1].isNull()) {\n         LOCK(cs_main);\n         hashBlock = ParseHashV(request.params[1], \"blockhash\");\n-        pblockindex = g_chainman.m_blockman.LookupBlockIndex(hashBlock);\n+        pblockindex = chainman.m_blockman.LookupBlockIndex(hashBlock);\n         if (!pblockindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         }\n     } else {\n         LOCK(cs_main);\n+        CChainState& active_chainstate = chainman.ActiveChainstate();\n \n         // Loop through txids and try to find which block they're in. Exit loop once a block is found.\n         for (const auto& tx : setTxids) {\n-            const Coin& coin = AccessByTxid(::ChainstateActive().CoinsTip(), tx);\n+            const Coin& coin = AccessByTxid(active_chainstate.CoinsTip(), tx);\n             if (!coin.IsSpent()) {\n-                pblockindex = ::ChainActive()[coin.nHeight];\n+                pblockindex = active_chainstate.m_chain[coin.nHeight];\n                 break;\n             }\n         }\n@@ -291,7 +294,7 @@ static RPCHelpMan gettxoutproof()\n         if (!tx || hashBlock.IsNull()) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction not yet in block\");\n         }\n-        pblockindex = g_chainman.m_blockman.LookupBlockIndex(hashBlock);\n+        pblockindex = chainman.m_blockman.LookupBlockIndex(hashBlock);\n         if (!pblockindex) {\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Transaction index corrupt\");\n         }\n@@ -349,10 +352,11 @@ static RPCHelpMan verifytxoutproof()\n     if (merkleBlock.txn.ExtractMatches(vMatch, vIndex) != merkleBlock.header.hashMerkleRoot)\n         return res;\n \n+    ChainstateManager& chainman = EnsureAnyChainman(request.context);\n     LOCK(cs_main);\n \n-    const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(merkleBlock.header.GetHash());\n-    if (!pindex || !::ChainActive().Contains(pindex) || pindex->nTx == 0) {\n+    const CBlockIndex* pindex = chainman.m_blockman.LookupBlockIndex(merkleBlock.header.GetHash());\n+    if (!pindex || !chainman.ActiveChain().Contains(pindex) || pindex->nTx == 0) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found in chain\");\n     }\n \n@@ -676,10 +680,11 @@ static RPCHelpMan combinerawtransaction()\n     CCoinsView viewDummy;\n     CCoinsViewCache view(&viewDummy);\n     {\n-        const CTxMemPool& mempool = EnsureMemPool(request.context);\n-        LOCK(cs_main);\n-        LOCK(mempool.cs);\n-        CCoinsViewCache &viewChain = ::ChainstateActive().CoinsTip();\n+        NodeContext& node = EnsureAnyNodeContext(request.context);\n+        const CTxMemPool& mempool = EnsureMemPool(node);\n+        ChainstateManager& chainman = EnsureChainman(node);\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = chainman.ActiveChainstate().CoinsTip();\n         CCoinsViewMemPool viewMempool(&viewChain, mempool);\n         view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n \n@@ -803,7 +808,7 @@ static RPCHelpMan signrawtransactionwithkey()\n     for (const CTxIn& txin : mtx.vin) {\n         coins[txin.prevout]; // Create empty map entry keyed by prevout.\n     }\n-    NodeContext& node = EnsureNodeContext(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n     FindCoins(node, coins);\n \n     // Parse the prevtxs array\n@@ -866,7 +871,7 @@ static RPCHelpMan sendrawtransaction()\n \n     std::string err_string;\n     AssertLockNotHeld(cs_main);\n-    NodeContext& node = EnsureNodeContext(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n     const TransactionError err = BroadcastTransaction(node, tx, err_string, max_raw_tx_fee, /*relay*/ true, /*wait_callback*/ true);\n     if (TransactionError::OK != err) {\n         throw JSONRPCTransactionError(err, err_string);\n@@ -941,7 +946,9 @@ static RPCHelpMan testmempoolaccept()\n                                              DEFAULT_MAX_RAW_TX_FEE_RATE :\n                                              CFeeRate(AmountFromValue(request.params[1]));\n \n-    CTxMemPool& mempool = EnsureMemPool(request.context);\n+    NodeContext& node = EnsureAnyNodeContext(request.context);\n+\n+    CTxMemPool& mempool = EnsureMemPool(node);\n     int64_t virtual_size = GetVirtualTransactionSize(*tx);\n     CAmount max_raw_tx_fee = max_raw_tx_fee_rate.GetFee(virtual_size);\n \n@@ -950,7 +957,8 @@ static RPCHelpMan testmempoolaccept()\n     result_0.pushKV(\"txid\", tx->GetHash().GetHex());\n     result_0.pushKV(\"wtxid\", tx->GetWitnessHash().GetHex());\n \n-    const MempoolAcceptResult accept_result = WITH_LOCK(cs_main, return AcceptToMemoryPool(::ChainstateActive(), mempool, std::move(tx),\n+    ChainstateManager& chainman = EnsureChainman(node);\n+    const MempoolAcceptResult accept_result = WITH_LOCK(cs_main, return AcceptToMemoryPool(chainman.ActiveChainstate(), mempool, std::move(tx),\n                                                   false /* bypass_limits */, /* test_accept */ true));\n \n     // Only return the fee and vsize if the transaction would pass ATMP.\n@@ -1599,9 +1607,11 @@ static RPCHelpMan utxoupdatepsbt()\n     CCoinsView viewDummy;\n     CCoinsViewCache view(&viewDummy);\n     {\n-        const CTxMemPool& mempool = EnsureMemPool(request.context);\n+        NodeContext& node = EnsureAnyNodeContext(request.context);\n+        const CTxMemPool& mempool = EnsureMemPool(node);\n+        ChainstateManager& chainman = EnsureChainman(node);\n         LOCK2(cs_main, mempool.cs);\n-        CCoinsViewCache &viewChain = ::ChainstateActive().CoinsTip();\n+        CCoinsViewCache &viewChain = chainman.ActiveChainstate().CoinsTip();\n         CCoinsViewMemPool viewMempool(&viewChain, mempool);\n         view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n "
      },
      {
        "sha": "1c397481dc69107eaf08c86b36d0cfa27e5804d6",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f00e799b4ac718b892ee4c3dac18074256e90b52/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f00e799b4ac718b892ee4c3dac18074256e90b52/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=f00e799b4ac718b892ee4c3dac18074256e90b52",
        "patch": "@@ -307,9 +307,6 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     BOOST_REQUIRE(addr.IsValid());\n     BOOST_REQUIRE(addr.IsIPv6());\n     BOOST_CHECK(!addr.IsBindAny());\n-    const std::string addr_str{addr.ToString()};\n-    BOOST_CHECK(addr_str == scoped_addr || addr_str == \"fe80:0:0:0:0:0:0:1\");\n-    // The fallback case \"fe80:0:0:0:0:0:0:1\" is needed for macOS 10.14/10.15 and (probably) later.\n     // Test that the delimiter \"%\" and default zone id of 0 can be omitted for the default scope.\n     BOOST_REQUIRE(LookupHost(link_local + \"%0\", addr, false));\n     BOOST_REQUIRE(addr.IsValid());"
      },
      {
        "sha": "2e7f64a444b932f63d509eda85b1833ef04e01a7",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f00e799b4ac718b892ee4c3dac18074256e90b52/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f00e799b4ac718b892ee4c3dac18074256e90b52/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=f00e799b4ac718b892ee4c3dac18074256e90b52",
        "patch": "@@ -242,7 +242,8 @@ CBlock TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransa\n     for (const CMutableTransaction& tx : txns) {\n         block.vtx.push_back(MakeTransactionRef(tx));\n     }\n-    RegenerateCommitments(block, WITH_LOCK(::cs_main, return std::ref(g_chainman.m_blockman)));\n+    CBlockIndex* prev_block = WITH_LOCK(::cs_main, return g_chainman.m_blockman.LookupBlockIndex(block.hashPrevBlock));\n+    RegenerateCommitments(block, prev_block);\n \n     while (!CheckProofOfWork(block.GetHash(), block.nBits, chainparams.GetConsensus())) ++block.nNonce;\n "
      },
      {
        "sha": "46eecae611375b1a990a11529e98b2310ec3a2ed",
        "filename": "test/functional/wallet_basic.py",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f00e799b4ac718b892ee4c3dac18074256e90b52/test/functional/wallet_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f00e799b4ac718b892ee4c3dac18074256e90b52/test/functional/wallet_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_basic.py?ref=f00e799b4ac718b892ee4c3dac18074256e90b52",
        "patch": "@@ -95,6 +95,8 @@ def run_test(self):\n         # but invisible if you include mempool\n         txout = self.nodes[0].gettxout(confirmed_txid, confirmed_index, False)\n         assert_equal(txout['value'], 50)\n+        txout = self.nodes[0].gettxout(confirmed_txid, confirmed_index)  # by default include_mempool=True\n+        assert txout is None\n         txout = self.nodes[0].gettxout(confirmed_txid, confirmed_index, True)\n         assert txout is None\n         # new utxo from mempool should be invisible if you exclude mempool"
      }
    ]
  },
  {
    "sha": "a443bc6dfbafd2fec5e4658961b74943a62acccd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNDQzYmM2ZGZiYWZkMmZlYzVlNDY1ODk2MWI3NDk0M2E2MmFjY2Nk",
    "commit": {
      "author": {
        "name": "J0hn",
        "email": "songjh.john@gmail.com",
        "date": "2021-04-19T23:06:33Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-04-19T23:06:33Z"
      },
      "message": "Merge pull request #9 from bitcoin/master\n\npull",
      "tree": {
        "sha": "cb176bc0a9cfdc9c41de818cc37055c8467f4b8b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cb176bc0a9cfdc9c41de818cc37055c8467f4b8b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a443bc6dfbafd2fec5e4658961b74943a62acccd",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgfgz5CRBK7hj4Ov3rIwAAylAIAEVSN6cdioo09HP8N29GEQsU\nMU5E9ugOP6qxBoXmSAD94BUENXczfugdYX5OP7KofWpispIfbzLS7mK8hCMKq1zK\n7jN64rGeyy8jYkSRqPcFXja3JstKdaeYA4crasFvxkFmaPjCDz4QnRr0cDNDYPE8\n/ffNH+cz1xdLxVefrCO0Llf2F5V33SZZv/gfv0ZbiemIMDd8ySYF15YQi6gREPW2\nYh9VNNG9x9MS0uMLRnehIhkU27swupMIRkFfG7an9rhiLAsbgdmmAB00twWXNr3H\n0prGZZR7AX75UXZy4+y8+cUNCzVqDVzE5mUgI+tGD8CXYI2HLdwW4IN8Rh5PeYw=\n=y1Nn\n-----END PGP SIGNATURE-----\n",
        "payload": "tree cb176bc0a9cfdc9c41de818cc37055c8467f4b8b\nparent f00e799b4ac718b892ee4c3dac18074256e90b52\nparent 13d27b452d4b60010c54d4f80757dea9805076be\nauthor J0hn <songjh.john@gmail.com> 1618873593 +0100\ncommitter GitHub <noreply@github.com> 1618873593 +0100\n\nMerge pull request #9 from bitcoin/master\n\npull"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a443bc6dfbafd2fec5e4658961b74943a62acccd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a443bc6dfbafd2fec5e4658961b74943a62acccd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a443bc6dfbafd2fec5e4658961b74943a62acccd/comments",
    "author": {
      "login": "Rqcker",
      "id": 20661419,
      "node_id": "MDQ6VXNlcjIwNjYxNDE5",
      "avatar_url": "https://avatars.githubusercontent.com/u/20661419?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Rqcker",
      "html_url": "https://github.com/Rqcker",
      "followers_url": "https://api.github.com/users/Rqcker/followers",
      "following_url": "https://api.github.com/users/Rqcker/following{/other_user}",
      "gists_url": "https://api.github.com/users/Rqcker/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Rqcker/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Rqcker/subscriptions",
      "organizations_url": "https://api.github.com/users/Rqcker/orgs",
      "repos_url": "https://api.github.com/users/Rqcker/repos",
      "events_url": "https://api.github.com/users/Rqcker/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Rqcker/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f00e799b4ac718b892ee4c3dac18074256e90b52",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f00e799b4ac718b892ee4c3dac18074256e90b52",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f00e799b4ac718b892ee4c3dac18074256e90b52"
      },
      {
        "sha": "13d27b452d4b60010c54d4f80757dea9805076be",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/13d27b452d4b60010c54d4f80757dea9805076be",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/13d27b452d4b60010c54d4f80757dea9805076be"
      }
    ],
    "stats": {
      "total": 572,
      "additions": 313,
      "deletions": 259
    },
    "files": [
      {
        "sha": "c14f90b04b716326df73bf7eba513d4623db2f69",
        "filename": "contrib/verify-commits/trusted-keys",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a443bc6dfbafd2fec5e4658961b74943a62acccd/contrib/verify-commits/trusted-keys",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a443bc6dfbafd2fec5e4658961b74943a62acccd/contrib/verify-commits/trusted-keys",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/trusted-keys?ref=a443bc6dfbafd2fec5e4658961b74943a62acccd",
        "patch": "@@ -4,3 +4,4 @@\n B8B3F1C0E58C15DB6A81D30C3648A882F4316B9B\n CA03882CB1FC067B5D3ACFE4D300116E1C875A3D\n E777299FC265DD04793070EB944D35F9AC3DB76A\n+D1DBF2C4B96F2DEBF4C16654410108112E7EA81F"
      },
      {
        "sha": "b3927b5ec5ba0db86956f6e5c6693b7ebf470ed9",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 24,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=a443bc6dfbafd2fec5e4658961b74943a62acccd",
        "patch": "@@ -451,6 +451,8 @@ class PeerManagerImpl final : public PeerManager\n \n     void ProcessGetData(CNode& pfrom, Peer& peer, const std::atomic<bool>& interruptMsgProc) EXCLUSIVE_LOCKS_REQUIRED(peer.m_getdata_requests_mutex) LOCKS_EXCLUDED(::cs_main);\n \n+    void ProcessBlock(CNode& pfrom, const std::shared_ptr<const CBlock>& pblock, bool fForceProcessing);\n+\n     /** Relay map (txid or wtxid -> CTransactionRef) */\n     typedef std::map<uint256, CTransactionRef> MapRelay;\n     MapRelay mapRelay GUARDED_BY(cs_main);\n@@ -2309,6 +2311,18 @@ void PeerManagerImpl::ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv)\n     m_connman.PushMessage(&peer, std::move(msg));\n }\n \n+void PeerManagerImpl::ProcessBlock(CNode& pfrom, const std::shared_ptr<const CBlock>& pblock, bool fForceProcessing)\n+{\n+    bool fNewBlock = false;\n+    m_chainman.ProcessNewBlock(m_chainparams, pblock, fForceProcessing, &fNewBlock);\n+    if (fNewBlock) {\n+        pfrom.nLastBlockTime = GetTime();\n+    } else {\n+        LOCK(cs_main);\n+        mapBlockSource.erase(pblock->GetHash());\n+    }\n+}\n+\n void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n                                      const std::chrono::microseconds time_received,\n                                      const std::atomic<bool>& interruptMsgProc)\n@@ -3390,7 +3404,6 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 LOCK(cs_main);\n                 mapBlockSource.emplace(pblock->GetHash(), std::make_pair(pfrom.GetId(), false));\n             }\n-            bool fNewBlock = false;\n             // Setting fForceProcessing to true means that we bypass some of\n             // our anti-DoS protections in AcceptBlock, which filters\n             // unrequested blocks that might be trying to waste our resources\n@@ -3400,13 +3413,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // we have a chain with at least nMinimumChainWork), and we ignore\n             // compact blocks with less work than our tip, it is safe to treat\n             // reconstructed compact blocks as having been requested.\n-            m_chainman.ProcessNewBlock(m_chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);\n-            if (fNewBlock) {\n-                pfrom.nLastBlockTime = GetTime();\n-            } else {\n-                LOCK(cs_main);\n-                mapBlockSource.erase(pblock->GetHash());\n-            }\n+            ProcessBlock(pfrom, pblock, /*fForceProcessing=*/true);\n             LOCK(cs_main); // hold cs_main for CBlockIndex::IsValid()\n             if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS)) {\n                 // Clear download state for this block, which is in\n@@ -3483,20 +3490,13 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             }\n         } // Don't hold cs_main when we call into ProcessNewBlock\n         if (fBlockRead) {\n-            bool fNewBlock = false;\n             // Since we requested this block (it was in mapBlocksInFlight), force it to be processed,\n             // even if it would not be a candidate for new tip (missing previous block, chain not long enough, etc)\n             // This bypasses some anti-DoS logic in AcceptBlock (eg to prevent\n             // disk-space attacks), but this should be safe due to the\n             // protections in the compact block handler -- see related comment\n             // in compact block optimistic reconstruction handling.\n-            m_chainman.ProcessNewBlock(m_chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);\n-            if (fNewBlock) {\n-                pfrom.nLastBlockTime = GetTime();\n-            } else {\n-                LOCK(cs_main);\n-                mapBlockSource.erase(pblock->GetHash());\n-            }\n+            ProcessBlock(pfrom, pblock, /*fForceProcessing=*/true);\n         }\n         return;\n     }\n@@ -3551,14 +3551,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // cs_main in ProcessNewBlock is fine.\n             mapBlockSource.emplace(hash, std::make_pair(pfrom.GetId(), true));\n         }\n-        bool fNewBlock = false;\n-        m_chainman.ProcessNewBlock(m_chainparams, pblock, forceProcessing, &fNewBlock);\n-        if (fNewBlock) {\n-            pfrom.nLastBlockTime = GetTime();\n-        } else {\n-            LOCK(cs_main);\n-            mapBlockSource.erase(pblock->GetHash());\n-        }\n+        ProcessBlock(pfrom, pblock, forceProcessing);\n         return;\n     }\n "
      },
      {
        "sha": "13687a6510e856a4a127b53be314a506afa283ce",
        "filename": "src/qt/forms/debugwindow.ui",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/qt/forms/debugwindow.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/qt/forms/debugwindow.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/debugwindow.ui?ref=a443bc6dfbafd2fec5e4658961b74943a62acccd",
        "patch": "@@ -923,9 +923,15 @@\n              <property name=\"tabKeyNavigation\">\n               <bool>false</bool>\n              </property>\n+             <property name=\"textElideMode\">\n+              <enum>Qt::ElideMiddle</enum>\n+             </property>\n              <property name=\"sortingEnabled\">\n               <bool>true</bool>\n              </property>\n+             <property name=\"wordWrap\">\n+              <bool>false</bool>\n+             </property>\n              <attribute name=\"horizontalHeaderHighlightSections\">\n               <bool>false</bool>\n              </attribute>"
      },
      {
        "sha": "e7fd97ee1fcf60b326b72ab964a22390f5d1740a",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 21,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=a443bc6dfbafd2fec5e4658961b74943a62acccd",
        "patch": "@@ -254,7 +254,7 @@ static RPCHelpMan waitfornewblock()\n                 \"\\nWaits for a specific new block and returns useful info about it.\\n\"\n                 \"\\nReturns the current block on timeout or exit.\\n\",\n                 {\n-                    {\"timeout\", RPCArg::Type::NUM, /* default */ \"0\", \"Time in milliseconds to wait for a response. 0 indicates no timeout.\"},\n+                    {\"timeout\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Time in milliseconds to wait for a response. 0 indicates no timeout.\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"\",\n@@ -297,7 +297,7 @@ static RPCHelpMan waitforblock()\n                 \"\\nReturns the current block on timeout or exit.\\n\",\n                 {\n                     {\"blockhash\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"Block hash to wait for.\"},\n-                    {\"timeout\", RPCArg::Type::NUM, /* default */ \"0\", \"Time in milliseconds to wait for a response. 0 indicates no timeout.\"},\n+                    {\"timeout\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Time in milliseconds to wait for a response. 0 indicates no timeout.\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"\",\n@@ -344,7 +344,7 @@ static RPCHelpMan waitforblockheight()\n                 \"\\nReturns the current block on timeout or exit.\\n\",\n                 {\n                     {\"height\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"Block height to wait for.\"},\n-                    {\"timeout\", RPCArg::Type::NUM, /* default */ \"0\", \"Time in milliseconds to wait for a response. 0 indicates no timeout.\"},\n+                    {\"timeout\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Time in milliseconds to wait for a response. 0 indicates no timeout.\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"\",\n@@ -558,8 +558,8 @@ static RPCHelpMan getrawmempool()\n                 \"\\nReturns all transaction ids in memory pool as a json array of string transaction ids.\\n\"\n                 \"\\nHint: use getmempoolentry to fetch a specific transaction from the mempool.\\n\",\n                 {\n-                    {\"verbose\", RPCArg::Type::BOOL, /* default */ \"false\", \"True for a json object, false for array of transaction ids\"},\n-                    {\"mempool_sequence\", RPCArg::Type::BOOL, /* default */ \"false\", \"If verbose=false, returns a json object with transaction list and mempool sequence number attached.\"},\n+                    {\"verbose\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"True for a json object, false for array of transaction ids\"},\n+                    {\"mempool_sequence\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"If verbose=false, returns a json object with transaction list and mempool sequence number attached.\"},\n                 },\n                 {\n                     RPCResult{\"for verbose = false\",\n@@ -608,7 +608,7 @@ static RPCHelpMan getmempoolancestors()\n                 \"\\nIf txid is in the mempool, returns all in-mempool ancestors.\\n\",\n                 {\n                     {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id (must be in mempool)\"},\n-                    {\"verbose\", RPCArg::Type::BOOL, /* default */ \"false\", \"True for a json object, false for array of transaction ids\"},\n+                    {\"verbose\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"True for a json object, false for array of transaction ids\"},\n                 },\n                 {\n                     RPCResult{\"for verbose = false\",\n@@ -672,7 +672,7 @@ static RPCHelpMan getmempooldescendants()\n                 \"\\nIf txid is in the mempool, returns all in-mempool descendants.\\n\",\n                 {\n                     {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id (must be in mempool)\"},\n-                    {\"verbose\", RPCArg::Type::BOOL, /* default */ \"false\", \"True for a json object, false for array of transaction ids\"},\n+                    {\"verbose\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"True for a json object, false for array of transaction ids\"},\n                 },\n                 {\n                     RPCResult{\"for verbose = false\",\n@@ -800,7 +800,7 @@ static RPCHelpMan getblockheader()\n                 \"If verbose is true, returns an Object with information about blockheader <hash>.\\n\",\n                 {\n                     {\"blockhash\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The block hash\"},\n-                    {\"verbose\", RPCArg::Type::BOOL, /* default */ \"true\", \"true for a json object, false for the hex-encoded data\"},\n+                    {\"verbose\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"true for a json object, false for the hex-encoded data\"},\n                 },\n                 {\n                     RPCResult{\"for verbose = true\",\n@@ -902,7 +902,7 @@ static RPCHelpMan getblock()\n                 \"If verbosity is 2, returns an Object with information about block <hash> and information about each transaction. \\n\",\n                 {\n                     {\"blockhash\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The block hash\"},\n-                    {\"verbosity|verbose\", RPCArg::Type::NUM, /* default */ \"1\", \"0 for hex-encoded data, 1 for a json object, and 2 for json object with transaction data\"},\n+                    {\"verbosity|verbose\", RPCArg::Type::NUM, RPCArg::Default{1}, \"0 for hex-encoded data, 1 for a json object, and 2 for json object with transaction data\"},\n                 },\n                 {\n                     RPCResult{\"for verbosity = 0\",\n@@ -955,10 +955,11 @@ static RPCHelpMan getblock()\n \n     int verbosity = 1;\n     if (!request.params[1].isNull()) {\n-        if(request.params[1].isNum())\n-            verbosity = request.params[1].get_int();\n-        else\n+        if (request.params[1].isBool()) {\n             verbosity = request.params[1].get_bool() ? 1 : 0;\n+        } else {\n+            verbosity = request.params[1].get_int();\n+        }\n     }\n \n     CBlock block;\n@@ -1069,7 +1070,7 @@ static RPCHelpMan gettxoutsetinfo()\n                 \"\\nReturns statistics about the unspent transaction output set.\\n\"\n                 \"Note this call may take some time.\\n\",\n                 {\n-                    {\"hash_type\", RPCArg::Type::STR, /* default */ \"hash_serialized_2\", \"Which UTXO set hash should be calculated. Options: 'hash_serialized_2' (the legacy algorithm), 'muhash', 'none'.\"},\n+                    {\"hash_type\", RPCArg::Type::STR, RPCArg::Default{\"hash_serialized_2\"}, \"Which UTXO set hash should be calculated. Options: 'hash_serialized_2' (the legacy algorithm), 'muhash', 'none'.\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"\",\n@@ -1136,7 +1137,7 @@ static RPCHelpMan gettxout()\n         {\n             {\"txid\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The transaction id\"},\n             {\"n\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"vout number\"},\n-            {\"include_mempool\", RPCArg::Type::BOOL, /* default */ \"true\", \"Whether to include the mempool. Note that an unspent output that is spent in the mempool won't appear.\"},\n+            {\"include_mempool\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"Whether to include the mempool. Note that an unspent output that is spent in the mempool won't appear.\"},\n         },\n         {\n             RPCResult{\"If the UTXO was not found\", RPCResult::Type::NONE, \"\", \"\"},\n@@ -1219,9 +1220,9 @@ static RPCHelpMan verifychain()\n     return RPCHelpMan{\"verifychain\",\n                 \"\\nVerifies blockchain database.\\n\",\n                 {\n-                    {\"checklevel\", RPCArg::Type::NUM, /* default */ strprintf(\"%d, range=0-4\", DEFAULT_CHECKLEVEL),\n+                    {\"checklevel\", RPCArg::Type::NUM, RPCArg::DefaultHint{strprintf(\"%d, range=0-4\", DEFAULT_CHECKLEVEL)},\n                         strprintf(\"How thorough the block verification is:\\n - %s\", Join(CHECKLEVEL_DOC, \"\\n- \"))},\n-                    {\"nblocks\", RPCArg::Type::NUM, /* default */ strprintf(\"%d, 0=all\", DEFAULT_CHECKBLOCKS), \"The number of blocks to check.\"},\n+                    {\"nblocks\", RPCArg::Type::NUM, RPCArg::DefaultHint{strprintf(\"%d, 0=all\", DEFAULT_CHECKBLOCKS)}, \"The number of blocks to check.\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::BOOL, \"\", \"Verified or not\"},\n@@ -1703,8 +1704,8 @@ static RPCHelpMan getchaintxstats()\n     return RPCHelpMan{\"getchaintxstats\",\n                 \"\\nCompute statistics about the total number and rate of transactions in the chain.\\n\",\n                 {\n-                    {\"nblocks\", RPCArg::Type::NUM, /* default */ \"one month\", \"Size of the window in number of blocks\"},\n-                    {\"blockhash\", RPCArg::Type::STR_HEX, /* default */ \"chain tip\", \"The hash of the block that ends the window.\"},\n+                    {\"nblocks\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"one month\"}, \"Size of the window in number of blocks\"},\n+                    {\"blockhash\", RPCArg::Type::STR_HEX, RPCArg::DefaultHint{\"chain tip\"}, \"The hash of the block that ends the window.\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"\",\n@@ -1851,7 +1852,7 @@ static RPCHelpMan getblockstats()\n                 \"It won't work for some heights with pruning.\\n\",\n                 {\n                     {\"hash_or_height\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The block hash or height of the target block\", \"\", {\"\", \"string or numeric\"}},\n-                    {\"stats\", RPCArg::Type::ARR, /* default */ \"all values\", \"Values to plot (see result below)\",\n+                    {\"stats\", RPCArg::Type::ARR, RPCArg::DefaultHint{\"all values\"}, \"Values to plot (see result below)\",\n                         {\n                             {\"height\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"Selected statistic\"},\n                             {\"time\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"Selected statistic\"},\n@@ -2220,7 +2221,7 @@ static RPCHelpMan scantxoutset()\n                 {\"\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, \"An object with output descriptor and metadata\",\n                 {\n                     {\"desc\", RPCArg::Type::STR, RPCArg::Optional::NO, \"An output descriptor\"},\n-                    {\"range\", RPCArg::Type::RANGE, /* default */ \"1000\", \"The range of HD chain indexes to explore (either end or [begin,end])\"},\n+                    {\"range\", RPCArg::Type::RANGE, RPCArg::Default{1000}, \"The range of HD chain indexes to explore (either end or [begin,end])\"},\n                 }},\n             },\n                         \"[scanobjects,...]\"},\n@@ -2359,7 +2360,7 @@ static RPCHelpMan getblockfilter()\n                 \"\\nRetrieve a BIP 157 content filter for a particular block.\\n\",\n                 {\n                     {\"blockhash\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The hash of the block\"},\n-                    {\"filtertype\", RPCArg::Type::STR, /*default*/ \"basic\", \"The type name of the filter\"},\n+                    {\"filtertype\", RPCArg::Type::STR, RPCArg::Default{\"basic\"}, \"The type name of the filter\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"\","
      },
      {
        "sha": "32318dd484cff68f19b286479d48953801f2df00",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=a443bc6dfbafd2fec5e4658961b74943a62acccd",
        "patch": "@@ -89,8 +89,8 @@ static RPCHelpMan getnetworkhashps()\n                 \"Pass in [blocks] to override # of blocks, -1 specifies since last difficulty change.\\n\"\n                 \"Pass in [height] to estimate the network speed at the time when a certain block was found.\\n\",\n                 {\n-                    {\"nblocks\", RPCArg::Type::NUM, /* default */ \"120\", \"The number of blocks, or -1 for blocks since last difficulty change.\"},\n-                    {\"height\", RPCArg::Type::NUM, /* default */ \"-1\", \"To estimate at the time of the given height.\"},\n+                    {\"nblocks\", RPCArg::Type::NUM, RPCArg::Default{120}, \"The number of blocks, or -1 for blocks since last difficulty change.\"},\n+                    {\"height\", RPCArg::Type::NUM, RPCArg::Default{-1}, \"To estimate at the time of the given height.\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::NUM, \"\", \"Hashes per second estimated\"},\n@@ -214,7 +214,7 @@ static RPCHelpMan generatetodescriptor()\n         {\n             {\"num_blocks\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"How many blocks are generated immediately.\"},\n             {\"descriptor\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The descriptor to send the newly generated bitcoin to.\"},\n-            {\"maxtries\", RPCArg::Type::NUM, /* default */ ToString(DEFAULT_MAX_TRIES), \"How many iterations to try.\"},\n+            {\"maxtries\", RPCArg::Type::NUM, RPCArg::Default{DEFAULT_MAX_TRIES}, \"How many iterations to try.\"},\n         },\n         RPCResult{\n             RPCResult::Type::ARR, \"\", \"hashes of blocks generated\",\n@@ -258,7 +258,7 @@ static RPCHelpMan generatetoaddress()\n                 {\n                     {\"nblocks\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"How many blocks are generated immediately.\"},\n                     {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The address to send the newly generated bitcoin to.\"},\n-                    {\"maxtries\", RPCArg::Type::NUM, /* default */ ToString(DEFAULT_MAX_TRIES), \"How many iterations to try.\"},\n+                    {\"maxtries\", RPCArg::Type::NUM, RPCArg::Default{DEFAULT_MAX_TRIES}, \"How many iterations to try.\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::ARR, \"\", \"hashes of blocks generated\",\n@@ -525,7 +525,7 @@ static RPCHelpMan getblocktemplate()\n         \"    https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki#getblocktemplate_changes\\n\"\n         \"    https://github.com/bitcoin/bips/blob/master/bip-0145.mediawiki\\n\",\n         {\n-            {\"template_request\", RPCArg::Type::OBJ, \"{}\", \"Format of the template\",\n+            {\"template_request\", RPCArg::Type::OBJ, RPCArg::Default{UniValue::VOBJ}, \"Format of the template\",\n             {\n                 {\"mode\", RPCArg::Type::STR, /* treat as named arg */ RPCArg::Optional::OMITTED_NAMED_ARG, \"This must be set to \\\"template\\\", \\\"proposal\\\" (see BIP 23), or omitted\"},\n                 {\"capabilities\", RPCArg::Type::ARR, /* treat as named arg */ RPCArg::Optional::OMITTED_NAMED_ARG, \"A list of strings\",\n@@ -960,7 +960,7 @@ static RPCHelpMan submitblock()\n         \"See https://en.bitcoin.it/wiki/BIP_0022 for full specification.\\n\",\n         {\n             {\"hexdata\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"the hex-encoded block data to submit\"},\n-            {\"dummy\", RPCArg::Type::STR, /* default */ \"ignored\", \"dummy value, for compatibility with BIP22. This value is ignored.\"},\n+            {\"dummy\", RPCArg::Type::STR, RPCArg::DefaultHint{\"ignored\"}, \"dummy value, for compatibility with BIP22. This value is ignored.\"},\n         },\n         {\n             RPCResult{\"If the block was accepted\", RPCResult::Type::NONE, \"\", \"\"},\n@@ -1069,7 +1069,7 @@ static RPCHelpMan estimatesmartfee()\n         \"in BIP 141 (witness data is discounted).\\n\",\n         {\n             {\"conf_target\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"Confirmation target in blocks (1 - 1008)\"},\n-            {\"estimate_mode\", RPCArg::Type::STR, /* default */ \"conservative\", \"The fee estimate mode.\\n\"\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"conservative\"}, \"The fee estimate mode.\\n\"\n             \"                   Whether to return a more conservative estimate which also satisfies\\n\"\n             \"                   a longer history. A conservative estimate potentially returns a\\n\"\n             \"                   higher feerate and is more likely to be sufficient for the desired\\n\"\n@@ -1140,7 +1140,7 @@ static RPCHelpMan estimaterawfee()\n                 \"defined in BIP 141 (witness data is discounted).\\n\",\n                 {\n                     {\"conf_target\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"Confirmation target in blocks (1 - 1008)\"},\n-                    {\"threshold\", RPCArg::Type::NUM, /* default */ \"0.95\", \"The proportion of transactions in a given feerate range that must have been\\n\"\n+                    {\"threshold\", RPCArg::Type::NUM, RPCArg::Default{0.95}, \"The proportion of transactions in a given feerate range that must have been\\n\"\n             \"               confirmed within conf_target in order to consider those feerates as high enough and proceed to check\\n\"\n             \"               lower buckets.\"},\n                 },"
      },
      {
        "sha": "00a06260ead00b96f5de1051c1d6794eb5d490ec",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=a443bc6dfbafd2fec5e4658961b74943a62acccd",
        "patch": "@@ -90,7 +90,7 @@ static RPCHelpMan createmultisig()\n                         {\n                             {\"key\", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, \"The hex-encoded public key\"},\n                         }},\n-                    {\"address_type\", RPCArg::Type::STR, /* default */ \"legacy\", \"The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n+                    {\"address_type\", RPCArg::Type::STR, RPCArg::Default{\"legacy\"}, \"The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"\",\n@@ -475,7 +475,7 @@ static RPCHelpMan getmemoryinfo()\n     return RPCHelpMan{\"getmemoryinfo\",\n                 \"Returns an object containing information about memory usage.\\n\",\n                 {\n-                    {\"mode\", RPCArg::Type::STR, /* default */ \"\\\"stats\\\"\", \"determines what kind of information is returned.\\n\"\n+                    {\"mode\", RPCArg::Type::STR, RPCArg::Default{\"stats\"}, \"determines what kind of information is returned.\\n\"\n             \"  - \\\"stats\\\" returns general statistics about memory usage in the daemon.\\n\"\n             \"  - \\\"mallocinfo\\\" returns an XML string describing low-level heap state (only available if compiled with glibc 2.10+).\"},\n                 },"
      },
      {
        "sha": "be068edf68fda1c92e87eb9992906807f2df8ac3",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=a443bc6dfbafd2fec5e4658961b74943a62acccd",
        "patch": "@@ -376,8 +376,8 @@ static RPCHelpMan disconnectnode()\n                 \"\\nStrictly one out of 'address' and 'nodeid' can be provided to identify the node.\\n\"\n                 \"\\nTo disconnect by nodeid, either set 'address' to the empty string, or call using the named 'nodeid' argument only.\\n\",\n                 {\n-                    {\"address\", RPCArg::Type::STR, /* default */ \"fallback to nodeid\", \"The IP address/port of the node\"},\n-                    {\"nodeid\", RPCArg::Type::NUM, /* default */ \"fallback to address\", \"The node ID (see getpeerinfo for node IDs)\"},\n+                    {\"address\", RPCArg::Type::STR, RPCArg::DefaultHint{\"fallback to nodeid\"}, \"The IP address/port of the node\"},\n+                    {\"nodeid\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"fallback to address\"}, \"The node ID (see getpeerinfo for node IDs)\"},\n                 },\n                 RPCResult{RPCResult::Type::NONE, \"\", \"\"},\n                 RPCExamples{\n@@ -422,7 +422,7 @@ static RPCHelpMan getaddednodeinfo()\n                 \"\\nReturns information about the given added node, or all added nodes\\n\"\n                 \"(note that onetry addnodes are not listed here)\\n\",\n                 {\n-                    {\"node\", RPCArg::Type::STR, /* default */ \"all nodes\", \"If provided, return information about this specific node, otherwise all nodes are returned.\"},\n+                    {\"node\", RPCArg::Type::STR, RPCArg::DefaultHint{\"all nodes\"}, \"If provided, return information about this specific node, otherwise all nodes are returned.\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::ARR, \"\", \"\",\n@@ -663,8 +663,8 @@ static RPCHelpMan setban()\n                 {\n                     {\"subnet\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The IP/Subnet (see getpeerinfo for nodes IP) with an optional netmask (default is /32 = single IP)\"},\n                     {\"command\", RPCArg::Type::STR, RPCArg::Optional::NO, \"'add' to add an IP/Subnet to the list, 'remove' to remove an IP/Subnet from the list\"},\n-                    {\"bantime\", RPCArg::Type::NUM, /* default */ \"0\", \"time in seconds how long (or until when if [absolute] is set) the IP is banned (0 or empty means using the default time of 24h which can also be overwritten by the -bantime startup argument)\"},\n-                    {\"absolute\", RPCArg::Type::BOOL, /* default */ \"false\", \"If set, the bantime must be an absolute timestamp expressed in \" + UNIX_EPOCH_TIME},\n+                    {\"bantime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"time in seconds how long (or until when if [absolute] is set) the IP is banned (0 or empty means using the default time of 24h which can also be overwritten by the -bantime startup argument)\"},\n+                    {\"absolute\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"If set, the bantime must be an absolute timestamp expressed in \" + UNIX_EPOCH_TIME},\n                 },\n                 RPCResult{RPCResult::Type::NONE, \"\", \"\"},\n                 RPCExamples{\n@@ -842,7 +842,7 @@ static RPCHelpMan getnodeaddresses()\n     return RPCHelpMan{\"getnodeaddresses\",\n                 \"\\nReturn known addresses, which can potentially be used to find new nodes in the network.\\n\",\n                 {\n-                    {\"count\", RPCArg::Type::NUM, /* default */ \"1\", \"The maximum number of addresses to return. Specify 0 to return all known addresses.\"},\n+                    {\"count\", RPCArg::Type::NUM, RPCArg::Default{1}, \"The maximum number of addresses to return. Specify 0 to return all known addresses.\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::ARR, \"\", \"\","
      },
      {
        "sha": "16ca3bb47daceab03e1002ee2ef22423f519d236",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=a443bc6dfbafd2fec5e4658961b74943a62acccd",
        "patch": "@@ -85,7 +85,7 @@ static RPCHelpMan getrawtransaction()\n                 \"If verbose is 'false' or omitted, returns a string that is serialized, hex-encoded data for 'txid'.\\n\",\n                 {\n                     {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n-                    {\"verbose\", RPCArg::Type::BOOL, /* default */ \"false\", \"If false, return a string, otherwise return a json object\"},\n+                    {\"verbose\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"If false, return a string, otherwise return a json object\"},\n                     {\"blockhash\", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED_NAMED_ARG, \"The block in which to look for the transaction\"},\n                 },\n                 {\n@@ -387,7 +387,7 @@ static RPCHelpMan createrawtransaction()\n                                 {\n                                     {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n                                     {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n-                                    {\"sequence\", RPCArg::Type::NUM, /* default */ \"depends on the value of the 'replaceable' and 'locktime' arguments\", \"The sequence number\"},\n+                                    {\"sequence\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"depends on the value of the 'replaceable' and 'locktime' arguments\"}, \"The sequence number\"},\n                                 },\n                                 },\n                         },\n@@ -409,8 +409,8 @@ static RPCHelpMan createrawtransaction()\n                                 },\n                         },\n                         },\n-                    {\"locktime\", RPCArg::Type::NUM, /* default */ \"0\", \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n-                    {\"replaceable\", RPCArg::Type::BOOL, /* default */ \"false\", \"Marks this transaction as BIP125-replaceable.\\n\"\n+                    {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                    {\"replaceable\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Marks this transaction as BIP125-replaceable.\\n\"\n             \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\"},\n                 },\n                 RPCResult{\n@@ -449,7 +449,7 @@ static RPCHelpMan decoderawtransaction()\n                 \"\\nReturn a JSON object representing the serialized, hex-encoded transaction.\\n\",\n                 {\n                     {\"hexstring\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction hex string\"},\n-                    {\"iswitness\", RPCArg::Type::BOOL, /* default */ \"depends on heuristic tests\", \"Whether the transaction hex is a serialized witness transaction.\\n\"\n+                    {\"iswitness\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"depends on heuristic tests\"}, \"Whether the transaction hex is a serialized witness transaction.\\n\"\n                         \"If iswitness is not present, heuristic tests will be used in decoding.\\n\"\n                         \"If true, only witness deserialization will be tried.\\n\"\n                         \"If false, only non-witness deserialization will be tried.\\n\"\n@@ -752,7 +752,7 @@ static RPCHelpMan signrawtransactionwithkey()\n                                 },\n                         },\n                         },\n-                    {\"sighashtype\", RPCArg::Type::STR, /* default */ \"ALL\", \"The signature hash type. Must be one of:\\n\"\n+                    {\"sighashtype\", RPCArg::Type::STR, RPCArg::Default{\"ALL\"}, \"The signature hash type. Must be one of:\\n\"\n             \"       \\\"ALL\\\"\\n\"\n             \"       \\\"NONE\\\"\\n\"\n             \"       \\\"SINGLE\\\"\\n\"\n@@ -832,7 +832,7 @@ static RPCHelpMan sendrawtransaction()\n                 \"\\nRelated RPCs: createrawtransaction, signrawtransactionwithkey\\n\",\n                 {\n                     {\"hexstring\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The hex string of the raw transaction\"},\n-                    {\"maxfeerate\", RPCArg::Type::AMOUNT, /* default */ FormatMoney(DEFAULT_MAX_RAW_TX_FEE_RATE.GetFeePerK()),\n+                    {\"maxfeerate\", RPCArg::Type::AMOUNT, RPCArg::Default{FormatMoney(DEFAULT_MAX_RAW_TX_FEE_RATE.GetFeePerK())},\n                         \"Reject transactions whose fee rate is higher than the specified value, expressed in \" + CURRENCY_UNIT +\n                             \"/kB.\\nSet to 0 to accept any fee rate.\\n\"},\n                 },\n@@ -895,7 +895,7 @@ static RPCHelpMan testmempoolaccept()\n                             {\"rawtx\", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, \"\"},\n                         },\n                         },\n-                    {\"maxfeerate\", RPCArg::Type::AMOUNT, /* default */ FormatMoney(DEFAULT_MAX_RAW_TX_FEE_RATE.GetFeePerK()), \"Reject transactions whose fee rate is higher than the specified value, expressed in \" + CURRENCY_UNIT + \"/kB\\n\"},\n+                    {\"maxfeerate\", RPCArg::Type::AMOUNT, RPCArg::Default{FormatMoney(DEFAULT_MAX_RAW_TX_FEE_RATE.GetFeePerK())}, \"Reject transactions whose fee rate is higher than the specified value, expressed in \" + CURRENCY_UNIT + \"/kB\\n\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::ARR, \"\", \"The result of the mempool acceptance test for each raw transaction in the input array.\\n\"\n@@ -1362,7 +1362,7 @@ static RPCHelpMan finalizepsbt()\n                 \"Implements the Finalizer and Extractor roles.\\n\",\n                 {\n                     {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A base64 string of a PSBT\"},\n-                    {\"extract\", RPCArg::Type::BOOL, /* default */ \"true\", \"If true and the transaction is complete,\\n\"\n+                    {\"extract\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"If true and the transaction is complete,\\n\"\n             \"                             extract and return the complete transaction in normal network serialization instead of the PSBT.\"},\n                 },\n                 RPCResult{\n@@ -1424,7 +1424,7 @@ static RPCHelpMan createpsbt()\n                                 {\n                                     {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n                                     {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n-                                    {\"sequence\", RPCArg::Type::NUM, /* default */ \"depends on the value of the 'replaceable' and 'locktime' arguments\", \"The sequence number\"},\n+                                    {\"sequence\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"depends on the value of the 'replaceable' and 'locktime' arguments\"}, \"The sequence number\"},\n                                 },\n                                 },\n                         },\n@@ -1446,8 +1446,8 @@ static RPCHelpMan createpsbt()\n                                 },\n                         },\n                         },\n-                    {\"locktime\", RPCArg::Type::NUM, /* default */ \"0\", \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n-                    {\"replaceable\", RPCArg::Type::BOOL, /* default */ \"false\", \"Marks this transaction as BIP125 replaceable.\\n\"\n+                    {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                    {\"replaceable\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Marks this transaction as BIP125 replaceable.\\n\"\n                             \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\"},\n                 },\n                 RPCResult{\n@@ -1499,9 +1499,9 @@ static RPCHelpMan converttopsbt()\n                 \"createpsbt and walletcreatefundedpsbt should be used for new applications.\\n\",\n                 {\n                     {\"hexstring\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The hex string of a raw transaction\"},\n-                    {\"permitsigdata\", RPCArg::Type::BOOL, /* default */ \"false\", \"If true, any signatures in the input will be discarded and conversion\\n\"\n+                    {\"permitsigdata\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"If true, any signatures in the input will be discarded and conversion\\n\"\n                             \"                              will continue. If false, RPC will fail if any signatures are present.\"},\n-                    {\"iswitness\", RPCArg::Type::BOOL, /* default */ \"depends on heuristic tests\", \"Whether the transaction hex is a serialized witness transaction.\\n\"\n+                    {\"iswitness\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"depends on heuristic tests\"}, \"Whether the transaction hex is a serialized witness transaction.\\n\"\n                         \"If iswitness is not present, heuristic tests will be used in decoding.\\n\"\n                         \"If true, only witness deserialization will be tried.\\n\"\n                         \"If false, only non-witness deserialization will be tried.\\n\"\n@@ -1571,7 +1571,7 @@ static RPCHelpMan utxoupdatepsbt()\n                     {\"\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"An output descriptor\"},\n                     {\"\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, \"An object with an output descriptor and extra information\", {\n                          {\"desc\", RPCArg::Type::STR, RPCArg::Optional::NO, \"An output descriptor\"},\n-                         {\"range\", RPCArg::Type::RANGE, \"1000\", \"Up to what index HD chains should be explored (either end or [begin,end])\"},\n+                         {\"range\", RPCArg::Type::RANGE, RPCArg::Default{1000}, \"Up to what index HD chains should be explored (either end or [begin,end])\"},\n                     }},\n                 }},\n             },"
      },
      {
        "sha": "cf80b08b96d245dae3500cb472292e634fb39293",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=a443bc6dfbafd2fec5e4658961b74943a62acccd",
        "patch": "@@ -135,7 +135,7 @@ static RPCHelpMan help()\n     return RPCHelpMan{\"help\",\n                 \"\\nList all commands, or get help for a specified command.\\n\",\n                 {\n-                    {\"command\", RPCArg::Type::STR, /* default */ \"all commands\", \"The command to get help on\"},\n+                    {\"command\", RPCArg::Type::STR, RPCArg::DefaultHint{\"all commands\"}, \"The command to get help on\"},\n                 },\n                 {\n                     RPCResult{RPCResult::Type::STR, \"\", \"The help text\"},"
      },
      {
        "sha": "df3ee9f007bdc0c5295a9771beed8986bc00f190",
        "filename": "src/rpc/util.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 2,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/rpc/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/rpc/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.cpp?ref=a443bc6dfbafd2fec5e4658961b74943a62acccd",
        "patch": "@@ -498,6 +498,33 @@ RPCHelpMan::RPCHelpMan(std::string name, std::string description, std::vector<RP\n         for (const std::string& name : names) {\n             CHECK_NONFATAL(named_args.insert(name).second);\n         }\n+        // Default value type should match argument type only when defined\n+        if (arg.m_fallback.index() == 2) {\n+            const RPCArg::Type type = arg.m_type;\n+            switch (std::get<RPCArg::Default>(arg.m_fallback).getType()) {\n+            case UniValue::VOBJ:\n+                CHECK_NONFATAL(type == RPCArg::Type::OBJ);\n+                break;\n+            case UniValue::VARR:\n+                CHECK_NONFATAL(type == RPCArg::Type::ARR);\n+                break;\n+            case UniValue::VSTR:\n+                CHECK_NONFATAL(type == RPCArg::Type::STR || type == RPCArg::Type::STR_HEX || type == RPCArg::Type::AMOUNT);\n+                break;\n+            case UniValue::VNUM:\n+                CHECK_NONFATAL(type == RPCArg::Type::NUM || type == RPCArg::Type::AMOUNT || type == RPCArg::Type::RANGE);\n+                break;\n+            case UniValue::VBOOL:\n+                CHECK_NONFATAL(type == RPCArg::Type::BOOL);\n+                break;\n+            case UniValue::VNULL:\n+                // Null values are accepted in all arguments\n+                break;\n+            default:\n+                CHECK_NONFATAL(false);\n+                break;\n+            }\n+        }\n     }\n }\n \n@@ -646,7 +673,7 @@ std::string RPCArg::GetName() const\n \n bool RPCArg::IsOptional() const\n {\n-    if (m_fallback.index() == 1) {\n+    if (m_fallback.index() != 0) {\n         return true;\n     } else {\n         return RPCArg::Optional::NO != std::get<RPCArg::Optional>(m_fallback);\n@@ -694,7 +721,9 @@ std::string RPCArg::ToDescriptionString() const\n         } // no default case, so the compiler can warn about missing cases\n     }\n     if (m_fallback.index() == 1) {\n-        ret += \", optional, default=\" + std::get<std::string>(m_fallback);\n+        ret += \", optional, default=\" + std::get<RPCArg::DefaultHint>(m_fallback);\n+    } else if (m_fallback.index() == 2) {\n+        ret += \", optional, default=\" + std::get<RPCArg::Default>(m_fallback).write();\n     } else {\n         switch (std::get<RPCArg::Optional>(m_fallback)) {\n         case RPCArg::Optional::OMITTED: {"
      },
      {
        "sha": "8ec18b2f35a14ae4f2b684598f4096e29d37cba9",
        "filename": "src/rpc/util.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/rpc/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/rpc/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.h?ref=a443bc6dfbafd2fec5e4658961b74943a62acccd",
        "patch": "@@ -145,7 +145,9 @@ struct RPCArg {\n          */\n         OMITTED,\n     };\n-    using Fallback = std::variant<Optional, /* default value for optional args */ std::string>;\n+    using DefaultHint = std::string;\n+    using Default = UniValue;\n+    using Fallback = std::variant<Optional, /* hint for default value */ DefaultHint, /* default constant value */ Default>;\n     const std::string m_names; //!< The name of the arg (can be empty for inner args, can contain multiple aliases separated by | for named request arguments)\n     const Type m_type;\n     const bool m_hidden;"
      },
      {
        "sha": "41bebab2a039a704dc700046c4a9b63bfcac4944",
        "filename": "src/test/data/tx_invalid.json",
        "status": "modified",
        "additions": 21,
        "deletions": 21,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/test/data/tx_invalid.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/test/data/tx_invalid.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/tx_invalid.json?ref=a443bc6dfbafd2fec5e4658961b74943a62acccd",
        "patch": "@@ -124,15 +124,15 @@\n [\"CHECKLOCKTIMEVERIFY tests\"],\n \n [\"By-height locks, with argument just beyond tx nLockTime\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"1 CHECKLOCKTIMEVERIFY 1\"]],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"1 CHECKLOCKTIMEVERIFY\"]],\n \"010000000100010000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000\", \"CHECKLOCKTIMEVERIFY\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"499999999 CHECKLOCKTIMEVERIFY 1\"]],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"499999999 CHECKLOCKTIMEVERIFY\"]],\n \"0100000001000100000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000fe64cd1d\", \"CHECKLOCKTIMEVERIFY\"],\n \n [\"By-time locks, with argument just beyond tx nLockTime (but within numerical boundaries)\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"500000001 CHECKLOCKTIMEVERIFY 1\"]],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"500000001 CHECKLOCKTIMEVERIFY\"]],\n \"01000000010001000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000065cd1d\", \"CHECKLOCKTIMEVERIFY\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4294967295 CHECKLOCKTIMEVERIFY 1\"]],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4294967295 CHECKLOCKTIMEVERIFY\"]],\n \"0100000001000100000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000feffffff\", \"CHECKLOCKTIMEVERIFY\"],\n \n [\"Argument missing\"],\n@@ -142,11 +142,11 @@\n \"010000000100010000000000000000000000000000000000000000000000000000000000000000000001b1010000000100000000000000000000000000\", \"CHECKLOCKTIMEVERIFY\"],\n \n [\"Argument negative with by-blockheight nLockTime=0\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"-1 CHECKLOCKTIMEVERIFY 1\"]],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"-1 CHECKLOCKTIMEVERIFY\"]],\n \"010000000100010000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000\", \"CHECKLOCKTIMEVERIFY\"],\n \n [\"Argument negative with by-blocktime nLockTime=500,000,000\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"-1 CHECKLOCKTIMEVERIFY 1\"]],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"-1 CHECKLOCKTIMEVERIFY\"]],\n \"01000000010001000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000065cd1d\", \"CHECKLOCKTIMEVERIFY\"],\n [[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"1\"]],\n \"010000000100010000000000000000000000000000000000000000000000000000000000000000000004005194b1010000000100000000000000000002000000\", \"CHECKLOCKTIMEVERIFY\"],\n@@ -167,19 +167,19 @@\n \"01000000010001000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000065cd1d\", \"CHECKLOCKTIMEVERIFY\"],\n [[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0\"]],\n \"01000000010001000000000000000000000000000000000000000000000000000000000000000000000251b100000000010000000000000000000065cd1d\", \"NONE\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"499999999 CHECKLOCKTIMEVERIFY 1\"]],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"499999999 CHECKLOCKTIMEVERIFY\"]],\n \"01000000010001000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000065cd1d\", \"CHECKLOCKTIMEVERIFY\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"500000000 CHECKLOCKTIMEVERIFY 1\"]],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"500000000 CHECKLOCKTIMEVERIFY\"]],\n \"010000000100010000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000\", \"CHECKLOCKTIMEVERIFY\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"500000000 CHECKLOCKTIMEVERIFY 1\"]],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"500000000 CHECKLOCKTIMEVERIFY\"]],\n \"0100000001000100000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000ff64cd1d\", \"CHECKLOCKTIMEVERIFY\"],\n \n [\"Argument 2^32 with nLockTime=2^32-1\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x050000000001 CHECKLOCKTIMEVERIFY 1\"]],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x050000000001 CHECKLOCKTIMEVERIFY\"]],\n \"0100000001000100000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000ffffffff\", \"CHECKLOCKTIMEVERIFY\"],\n \n [\"Same, but with nLockTime=2^31-1\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"2147483648 CHECKLOCKTIMEVERIFY 1\"]],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"2147483648 CHECKLOCKTIMEVERIFY\"]],\n \"0100000001000100000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000ffffff7f\", \"CHECKLOCKTIMEVERIFY\"],\n \n [\"6 byte non-minimally-encoded arguments are invalid even if their contents are valid\"],\n@@ -201,37 +201,37 @@\n [\"CHECKSEQUENCEVERIFY tests\"],\n \n [\"By-height locks, with argument just beyond txin.nSequence\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"1 CHECKSEQUENCEVERIFY 1\"]],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"1 CHECKSEQUENCEVERIFY\"]],\n \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000\", \"CHECKSEQUENCEVERIFY\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4259839 CHECKSEQUENCEVERIFY 1\"]],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4259839 CHECKSEQUENCEVERIFY\"]],\n \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000feff40000100000000000000000000000000\", \"CHECKSEQUENCEVERIFY\"],\n \n [\"By-time locks, with argument just beyond txin.nSequence (but within numerical boundaries)\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4194305 CHECKSEQUENCEVERIFY 1\"]],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4194305 CHECKSEQUENCEVERIFY\"]],\n \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000040000100000000000000000000000000\", \"CHECKSEQUENCEVERIFY\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4259839 CHECKSEQUENCEVERIFY 1\"]],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4259839 CHECKSEQUENCEVERIFY\"]],\n \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000feff40000100000000000000000000000000\", \"CHECKSEQUENCEVERIFY\"],\n \n [\"Argument missing\"],\n [[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"CHECKSEQUENCEVERIFY 1\"]],\n \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000\", \"CHECKSEQUENCEVERIFY\"],\n \n [\"Argument negative with by-blockheight txin.nSequence=0\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"-1 CHECKSEQUENCEVERIFY 1\"]],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"-1 CHECKSEQUENCEVERIFY\"]],\n \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000\", \"CHECKSEQUENCEVERIFY\"],\n \n [\"Argument negative with by-blocktime txin.nSequence=CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"-1 CHECKSEQUENCEVERIFY 1\"]],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"-1 CHECKSEQUENCEVERIFY\"]],\n \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000040000100000000000000000000000000\", \"CHECKSEQUENCEVERIFY\"],\n \n [\"Argument/tx height/time mismatch, both versions\"],\n [[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0 CHECKSEQUENCEVERIFY 1\"]],\n \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000040000100000000000000000000000000\", \"CHECKSEQUENCEVERIFY\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"65535 CHECKSEQUENCEVERIFY 1\"]],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"65535 CHECKSEQUENCEVERIFY\"]],\n \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000040000100000000000000000000000000\", \"CHECKSEQUENCEVERIFY\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4194304 CHECKSEQUENCEVERIFY 1\"]],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4194304 CHECKSEQUENCEVERIFY\"]],\n \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000\", \"CHECKSEQUENCEVERIFY\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4259839 CHECKSEQUENCEVERIFY 1\"]],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4259839 CHECKSEQUENCEVERIFY\"]],\n \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000\", \"CHECKSEQUENCEVERIFY\"],\n \n [\"6 byte non-minimally-encoded arguments are invalid even if their contents are valid\"],\n@@ -249,7 +249,7 @@\n [\"Failure due to insufficient tx.nVersion (<2)\"],\n [[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0 CHECKSEQUENCEVERIFY 1\"]],\n \"010000000100010000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000\", \"CHECKSEQUENCEVERIFY\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4194304 CHECKSEQUENCEVERIFY 1\"]],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4194304 CHECKSEQUENCEVERIFY\"]],\n \"010000000100010000000000000000000000000000000000000000000000000000000000000000000000000040000100000000000000000000000000\", \"CHECKSEQUENCEVERIFY\"],\n \n [\"Unknown witness program version (with DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)\"],"
      },
      {
        "sha": "b874f6f26ca776f1e644e56637389d5d07ebe580",
        "filename": "src/test/data/tx_valid.json",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/test/data/tx_valid.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/test/data/tx_valid.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/tx_valid.json?ref=a443bc6dfbafd2fec5e4658961b74943a62acccd",
        "patch": "@@ -62,10 +62,6 @@\n   [\"c76168ef1a272a4f176e55e73157ecfce040cfad16a5272f6296eb7089dca846\", 1, \"DUP HASH160 0x14 0x34fea2c5a75414fd945273ae2d029ce1f28dafcf EQUALVERIFY CHECKSIG\"]],\n \"010000000390d31c6107013d754529d8818eff285fe40a3e7635f6930fec5d12eb02107a43010000006b483045022100f40815ae3c81a0dd851cc8d376d6fd226c88416671346a9033468cca2cdcc6c202204f764623903e6c4bed1b734b75d82c40f1725e4471a55ad4f51218f86130ac038321033d710ab45bb54ac99618ad23b3c1da661631aa25f23bfe9d22b41876f1d46e4effffffff3ff04a68e22bdd52e7c8cb848156d2d158bd5515b3c50adabc87d0ca2cd3482d010000006a4730440220598d263c107004008e9e26baa1e770be30fd31ee55ded1898f7c00da05a75977022045536bead322ca246779698b9c3df3003377090f41afeca7fb2ce9e328ec4af2832102b738b531def73020bd637f32935924cc88549c8206976226d968edd3a42fc2d7ffffffff46a8dc8970eb96622f27a516adcf40e0fcec5731e7556e174f2a271aef6861c7010000006b483045022100c5b90a777a9fdc90c208dbef7290d1fc1be651f47151ee4ccff646872a454cf90220640cfbc4550446968fbbe9d12528f3adf7d87b31541569c59e790db8a220482583210391332546e22bbe8fe3af54addfad6f8b83d05fa4f5e047593d4c07ae938795beffffffff028036be26000000001976a914ddfb29efad43a667465ac59ff14dc6442a1adfca88ac3d5cba01000000001976a914b64dde7a505a13ca986c40e86e984a8dc81368b688ac00000000\", \"NONE\"],\n \n-[\"An invalid P2SH Transaction\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"HASH160 0x14 0x7a052c840ba73af26755de42cf01cc9e0a49fef0 EQUAL\"]],\n-\"010000000100010000000000000000000000000000000000000000000000000000000000000000000009085768617420697320ffffffff010000000000000000015100000000\", \"P2SH,CLEANSTACK,WITNESS\"],\n-\n [\"A valid P2SH Transaction using the standard transaction type put forth in BIP 16\"],\n [[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"HASH160 0x14 0x8febbed40483661de6958d957412f82deed8e2f7 EQUAL\"]],\n \"01000000010001000000000000000000000000000000000000000000000000000000000000000000006e493046022100c66c9cdf4c43609586d15424c54707156e316d88b0a1534c9e6b0d4f311406310221009c0fe51dbc9c4ab7cc25d3fdbeccf6679fe6827f08edf2b4a9f16ee3eb0e438a0123210338e8034509af564c62644c07691942e0c056752008a173c89f60ab2a88ac2ebfacffffffff010000000000000000015100000000\", \"LOW_S\"],"
      },
      {
        "sha": "9bbf9567f5ca80c29941b50afd7fe41653877dd2",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 22,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=a443bc6dfbafd2fec5e4658961b74943a62acccd",
        "patch": "@@ -20,6 +20,7 @@\n #include <script/signingprovider.h>\n #include <script/standard.h>\n #include <streams.h>\n+#include <test/util/script.h>\n #include <test/util/transaction_utils.h>\n #include <util/strencodings.h>\n #include <util/string.h>\n@@ -59,6 +60,9 @@ static std::map<std::string, unsigned int> mapFlagNames = {\n     {std::string(\"WITNESS_PUBKEYTYPE\"), (unsigned int)SCRIPT_VERIFY_WITNESS_PUBKEYTYPE},\n     {std::string(\"CONST_SCRIPTCODE\"), (unsigned int)SCRIPT_VERIFY_CONST_SCRIPTCODE},\n     {std::string(\"TAPROOT\"), (unsigned int)SCRIPT_VERIFY_TAPROOT},\n+    {std::string(\"DISCOURAGE_UPGRADABLE_PUBKEYTYPE\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE},\n+    {std::string(\"DISCOURAGE_OP_SUCCESS\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS},\n+    {std::string(\"DISCOURAGE_UPGRADABLE_TAPROOT_VERSION\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION},\n };\n \n unsigned int ParseScriptFlags(std::string strFlags)\n@@ -78,6 +82,16 @@ unsigned int ParseScriptFlags(std::string strFlags)\n     return flags;\n }\n \n+// Check that all flags in STANDARD_SCRIPT_VERIFY_FLAGS are present in mapFlagNames.\n+bool CheckMapFlagNames()\n+{\n+    unsigned int standard_flags_missing{STANDARD_SCRIPT_VERIFY_FLAGS};\n+    for (const auto& pair : mapFlagNames) {\n+        standard_flags_missing &= ~(pair.second);\n+    }\n+    return standard_flags_missing == 0;\n+}\n+\n std::string FormatScriptFlags(unsigned int flags)\n {\n     if (flags == 0) {\n@@ -139,6 +153,7 @@ unsigned int TrimFlags(unsigned int flags)\n \n     // CLEANSTACK requires WITNESS (and transitively CLEANSTACK requires P2SH)\n     if (!(flags & SCRIPT_VERIFY_WITNESS)) flags &= ~(unsigned int)SCRIPT_VERIFY_CLEANSTACK;\n+    Assert(IsValidFlagCombination(flags));\n     return flags;\n }\n \n@@ -149,17 +164,21 @@ unsigned int FillFlags(unsigned int flags)\n \n     // WITNESS implies P2SH (and transitively CLEANSTACK implies P2SH)\n     if (flags & SCRIPT_VERIFY_WITNESS) flags |= SCRIPT_VERIFY_P2SH;\n+    Assert(IsValidFlagCombination(flags));\n     return flags;\n }\n \n-// Return valid flags that are all except one flag for each flag\n-std::vector<unsigned int> ExcludeIndividualFlags(unsigned int flags)\n+// Exclude each possible script verify flag from flags. Returns a set of these flag combinations\n+// that are valid and without duplicates. For example: if flags=1111 and the 4 possible flags are\n+// 0001, 0010, 0100, and 1000, this should return the set {0111, 1011, 1101, 1110}.\n+// Assumes that mapFlagNames contains all script verify flags.\n+std::set<unsigned int> ExcludeIndividualFlags(unsigned int flags)\n {\n-    std::vector<unsigned int> flags_combos;\n-    for (unsigned int i = 0; i < mapFlagNames.size(); ++i) {\n-        const unsigned int flags_excluding_i = TrimFlags(flags & ~(1U << i));\n-        if (flags != flags_excluding_i && std::find(flags_combos.begin(), flags_combos.end(), flags_excluding_i) != flags_combos.end()) {\n-            flags_combos.push_back(flags_excluding_i);\n+    std::set<unsigned int> flags_combos;\n+    for (const auto& pair : mapFlagNames) {\n+        const unsigned int flags_excluding_one = TrimFlags(flags & ~(pair.second));\n+        if (flags != flags_excluding_one) {\n+            flags_combos.insert(flags_excluding_one);\n         }\n     }\n     return flags_combos;\n@@ -169,6 +188,7 @@ BOOST_FIXTURE_TEST_SUITE(transaction_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(tx_valid)\n {\n+    BOOST_CHECK_MESSAGE(CheckMapFlagNames(), \"mapFlagNames is missing a script verification flag\");\n     // Read tests from test/data/tx_valid.json\n     UniValue tests = read_json(std::string(json_tests::tx_valid, json_tests::tx_valid + sizeof(json_tests::tx_valid)));\n \n@@ -228,16 +248,15 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n                 BOOST_ERROR(\"Bad test flags: \" << strTest);\n             }\n \n-            if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, ~verify_flags, txdata, strTest, /* expect_valid */ true)) {\n-                BOOST_ERROR(\"Tx unexpectedly failed: \" << strTest);\n-            }\n+            BOOST_CHECK_MESSAGE(CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, ~verify_flags, txdata, strTest, /* expect_valid */ true),\n+                                \"Tx unexpectedly failed: \" << strTest);\n \n             // Backwards compatibility of script verification flags: Removing any flag(s) should not invalidate a valid transaction\n-            for (size_t i = 0; i < mapFlagNames.size(); ++i) {\n+            for (const auto& [name, flag] : mapFlagNames) {\n                 // Removing individual flags\n-                unsigned int flags = TrimFlags(~(verify_flags | (1U << i)));\n+                unsigned int flags = TrimFlags(~(verify_flags | flag));\n                 if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, flags, txdata, strTest, /* expect_valid */ true)) {\n-                    BOOST_ERROR(\"Tx unexpectedly failed with flag \" << ToString(i) << \" unset: \" << strTest);\n+                    BOOST_ERROR(\"Tx unexpectedly failed with flag \" << name << \" unset: \" << strTest);\n                 }\n                 // Removing random combinations of flags\n                 flags = TrimFlags(~(verify_flags | (unsigned int)InsecureRandBits(mapFlagNames.size())));\n@@ -247,7 +266,7 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n             }\n \n             // Check that flags are maximal: transaction should fail if any unset flags are set.\n-            for (auto flags_excluding_one: ExcludeIndividualFlags(verify_flags)) {\n+            for (auto flags_excluding_one : ExcludeIndividualFlags(verify_flags)) {\n                 if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, ~flags_excluding_one, txdata, strTest, /* expect_valid */ false)) {\n                     BOOST_ERROR(\"Too many flags unset: \" << strTest);\n                 }\n@@ -314,27 +333,31 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n             PrecomputedTransactionData txdata(tx);\n             unsigned int verify_flags = ParseScriptFlags(test[2].get_str());\n \n-            // Not using FillFlags() in the main test, in order to detect invalid verifyFlags combination\n-            if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, verify_flags, txdata, strTest, /* expect_valid */ false)) {\n-                BOOST_ERROR(\"Tx unexpectedly passed: \" << strTest);\n+            // Check that the test gives a valid combination of flags (otherwise VerifyScript will throw). Don't edit the flags.\n+            if (verify_flags != FillFlags(verify_flags)) {\n+                BOOST_ERROR(\"Bad test flags: \" << strTest);\n             }\n \n+            // Not using FillFlags() in the main test, in order to detect invalid verifyFlags combination\n+            BOOST_CHECK_MESSAGE(CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, verify_flags, txdata, strTest, /* expect_valid */ false),\n+                                \"Tx unexpectedly passed: \" << strTest);\n+\n             // Backwards compatibility of script verification flags: Adding any flag(s) should not validate an invalid transaction\n-            for (size_t i = 0; i < mapFlagNames.size(); i++) {\n-                unsigned int flags = FillFlags(verify_flags | (1U << i));\n+            for (const auto& [name, flag] : mapFlagNames) {\n+                unsigned int flags = FillFlags(verify_flags | flag);\n                 // Adding individual flags\n                 if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, flags, txdata, strTest, /* expect_valid */ false)) {\n-                    BOOST_ERROR(\"Tx unexpectedly passed with flag \" << ToString(i) << \" set: \" << strTest);\n+                    BOOST_ERROR(\"Tx unexpectedly passed with flag \" << name << \" set: \" << strTest);\n                 }\n                 // Adding random combinations of flags\n                 flags = FillFlags(verify_flags | (unsigned int)InsecureRandBits(mapFlagNames.size()));\n                 if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, flags, txdata, strTest, /* expect_valid */ false)) {\n-                    BOOST_ERROR(\"Tx unexpectedly passed with random flags \" << ToString(flags) << \": \" << strTest);\n+                    BOOST_ERROR(\"Tx unexpectedly passed with random flags \" << name << \": \" << strTest);\n                 }\n             }\n \n             // Check that flags are minimal: transaction should succeed if any set flags are unset.\n-            for (auto flags_excluding_one: ExcludeIndividualFlags(verify_flags)) {\n+            for (auto flags_excluding_one : ExcludeIndividualFlags(verify_flags)) {\n                 if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, flags_excluding_one, txdata, strTest, /* expect_valid */ true)) {\n                     BOOST_ERROR(\"Too many flags set: \" << strTest);\n                 }"
      },
      {
        "sha": "653dbdfc1d4ccf10a56a4b5543fe222498130c99",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=a443bc6dfbafd2fec5e4658961b74943a62acccd",
        "patch": "@@ -100,8 +100,8 @@ RPCHelpMan importprivkey()\n             \"Note: Use \\\"getwalletinfo\\\" to query the scanning progress.\\n\",\n                 {\n                     {\"privkey\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The private key (see dumpprivkey)\"},\n-                    {\"label\", RPCArg::Type::STR, /* default */ \"current label if address exists, otherwise \\\"\\\"\", \"An optional label\"},\n-                    {\"rescan\", RPCArg::Type::BOOL, /* default */ \"true\", \"Rescan the wallet for transactions\"},\n+                    {\"label\", RPCArg::Type::STR, RPCArg::DefaultHint{\"current label if address exists, otherwise \\\"\\\"\"}, \"An optional label\"},\n+                    {\"rescan\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"Rescan the wallet for transactions\"},\n                 },\n                 RPCResult{RPCResult::Type::NONE, \"\", \"\"},\n                 RPCExamples{\n@@ -232,9 +232,9 @@ RPCHelpMan importaddress()\n             \"Note: Use \\\"getwalletinfo\\\" to query the scanning progress.\\n\",\n                 {\n                     {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The Bitcoin address (or hex-encoded script)\"},\n-                    {\"label\", RPCArg::Type::STR, /* default */ \"\\\"\\\"\", \"An optional label\"},\n-                    {\"rescan\", RPCArg::Type::BOOL, /* default */ \"true\", \"Rescan the wallet for transactions\"},\n-                    {\"p2sh\", RPCArg::Type::BOOL, /* default */ \"false\", \"Add the P2SH version of the script as well\"},\n+                    {\"label\", RPCArg::Type::STR, RPCArg::Default{\"\"}, \"An optional label\"},\n+                    {\"rescan\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"Rescan the wallet for transactions\"},\n+                    {\"p2sh\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Add the P2SH version of the script as well\"},\n                 },\n                 RPCResult{RPCResult::Type::NONE, \"\", \"\"},\n                 RPCExamples{\n@@ -426,8 +426,8 @@ RPCHelpMan importpubkey()\n             \"Note: Use \\\"getwalletinfo\\\" to query the scanning progress.\\n\",\n                 {\n                     {\"pubkey\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The hex-encoded public key\"},\n-                    {\"label\", RPCArg::Type::STR, /* default */ \"\\\"\\\"\", \"An optional label\"},\n-                    {\"rescan\", RPCArg::Type::BOOL, /* default */ \"true\", \"Rescan the wallet for transactions\"},\n+                    {\"label\", RPCArg::Type::STR, RPCArg::Default{\"\"}, \"An optional label\"},\n+                    {\"rescan\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"Rescan the wallet for transactions\"},\n                 },\n                 RPCResult{RPCResult::Type::NONE, \"\", \"\"},\n                 RPCExamples{\n@@ -1279,28 +1279,28 @@ RPCHelpMan importmulti()\n                                     },\n                                     {\"redeemscript\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"Allowed only if the scriptPubKey is a P2SH or P2SH-P2WSH address/scriptPubKey\"},\n                                     {\"witnessscript\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"Allowed only if the scriptPubKey is a P2SH-P2WSH or P2WSH address/scriptPubKey\"},\n-                                    {\"pubkeys\", RPCArg::Type::ARR, /* default */ \"empty array\", \"Array of strings giving pubkeys to import. They must occur in P2PKH or P2WPKH scripts. They are not required when the private key is also provided (see the \\\"keys\\\" argument).\",\n+                                    {\"pubkeys\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Array of strings giving pubkeys to import. They must occur in P2PKH or P2WPKH scripts. They are not required when the private key is also provided (see the \\\"keys\\\" argument).\",\n                                         {\n                                             {\"pubKey\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"\"},\n                                         }\n                                     },\n-                                    {\"keys\", RPCArg::Type::ARR, /* default */ \"empty array\", \"Array of strings giving private keys to import. The corresponding public keys must occur in the output or redeemscript.\",\n+                                    {\"keys\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Array of strings giving private keys to import. The corresponding public keys must occur in the output or redeemscript.\",\n                                         {\n                                             {\"key\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"\"},\n                                         }\n                                     },\n                                     {\"range\", RPCArg::Type::RANGE, RPCArg::Optional::OMITTED, \"If a ranged descriptor is used, this specifies the end or the range (in the form [begin,end]) to import\"},\n-                                    {\"internal\", RPCArg::Type::BOOL, /* default */ \"false\", \"Stating whether matching outputs should be treated as not incoming payments (also known as change)\"},\n-                                    {\"watchonly\", RPCArg::Type::BOOL, /* default */ \"false\", \"Stating whether matching outputs should be considered watchonly.\"},\n-                                    {\"label\", RPCArg::Type::STR, /* default */ \"''\", \"Label to assign to the address, only allowed with internal=false\"},\n-                                    {\"keypool\", RPCArg::Type::BOOL, /* default */ \"false\", \"Stating whether imported public keys should be added to the keypool for when users request new addresses. Only allowed when wallet private keys are disabled\"},\n+                                    {\"internal\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Stating whether matching outputs should be treated as not incoming payments (also known as change)\"},\n+                                    {\"watchonly\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Stating whether matching outputs should be considered watchonly.\"},\n+                                    {\"label\", RPCArg::Type::STR, RPCArg::Default{\"\"}, \"Label to assign to the address, only allowed with internal=false\"},\n+                                    {\"keypool\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Stating whether imported public keys should be added to the keypool for when users request new addresses. Only allowed when wallet private keys are disabled\"},\n                                 },\n                             },\n                         },\n                         \"\\\"requests\\\"\"},\n                     {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n                         {\n-                            {\"rescan\", RPCArg::Type::BOOL, /* default */ \"true\", \"Stating if should rescan the blockchain after all imports\"},\n+                            {\"rescan\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"Stating if should rescan the blockchain after all imports\"},\n                         },\n                         \"\\\"options\\\"\"},\n                 },\n@@ -1591,7 +1591,7 @@ RPCHelpMan importdescriptors()\n                             {\"\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, \"\",\n                                 {\n                                     {\"desc\", RPCArg::Type::STR, RPCArg::Optional::NO, \"Descriptor to import.\"},\n-                                    {\"active\", RPCArg::Type::BOOL, /* default */ \"false\", \"Set this descriptor to be the active descriptor for the corresponding output type/externality\"},\n+                                    {\"active\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Set this descriptor to be the active descriptor for the corresponding output type/externality\"},\n                                     {\"range\", RPCArg::Type::RANGE, RPCArg::Optional::OMITTED, \"If a ranged descriptor is used, this specifies the end or the range (in the form [begin,end]) to import\"},\n                                     {\"next_index\", RPCArg::Type::NUM, RPCArg::Optional::OMITTED, \"If a ranged descriptor is set to active, this specifies the next index to generate addresses from\"},\n                                     {\"timestamp\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"Time from which to start rescanning the blockchain for this descriptor, in \" + UNIX_EPOCH_TIME + \"\\n\"\n@@ -1601,8 +1601,8 @@ RPCHelpMan importdescriptors()\n         \"                                                              of all descriptors being imported will be scanned.\",\n                                         /* oneline_description */ \"\", {\"timestamp | \\\"now\\\"\", \"integer / string\"}\n                                     },\n-                                    {\"internal\", RPCArg::Type::BOOL, /* default */ \"false\", \"Whether matching outputs should be treated as not incoming payments (e.g. change)\"},\n-                                    {\"label\", RPCArg::Type::STR, /* default */ \"''\", \"Label to assign to the address, only allowed with internal=false\"},\n+                                    {\"internal\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Whether matching outputs should be treated as not incoming payments (e.g. change)\"},\n+                                    {\"label\", RPCArg::Type::STR, RPCArg::Default{\"\"}, \"Label to assign to the address, only allowed with internal=false\"},\n                                 },\n                             },\n                         },"
      },
      {
        "sha": "67d9d561333f830192355e1ec36b8fcca21250ff",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 113,
        "deletions": 113,
        "changes": 226,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a443bc6dfbafd2fec5e4658961b74943a62acccd/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=a443bc6dfbafd2fec5e4658961b74943a62acccd",
        "patch": "@@ -237,8 +237,8 @@ static RPCHelpMan getnewaddress()\n                 \"If 'label' is specified, it is added to the address book \\n\"\n                 \"so payments received with the address will be associated with 'label'.\\n\",\n                 {\n-                    {\"label\", RPCArg::Type::STR, /* default */ \"\\\"\\\"\", \"The label name for the address to be linked to. It can also be set to the empty string \\\"\\\" to represent the default label. The label does not need to exist, it will be created if there is no label by the given name.\"},\n-                    {\"address_type\", RPCArg::Type::STR, /* default */ \"set by -addresstype\", \"The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n+                    {\"label\", RPCArg::Type::STR, RPCArg::Default{\"\"}, \"The label name for the address to be linked to. It can also be set to the empty string \\\"\\\" to represent the default label. The label does not need to exist, it will be created if there is no label by the given name.\"},\n+                    {\"address_type\", RPCArg::Type::STR, RPCArg::DefaultHint{\"set by -addresstype\"}, \"The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::STR, \"address\", \"The new bitcoin address\"\n@@ -287,7 +287,7 @@ static RPCHelpMan getrawchangeaddress()\n                 \"\\nReturns a new Bitcoin address, for receiving change.\\n\"\n                 \"This is for use with raw transactions, NOT normal use.\\n\",\n                 {\n-                    {\"address_type\", RPCArg::Type::STR, /* default */ \"set by -changetype\", \"The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n+                    {\"address_type\", RPCArg::Type::STR, RPCArg::DefaultHint{\"set by -changetype\"}, \"The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::STR, \"address\", \"The address\"\n@@ -439,16 +439,16 @@ static RPCHelpMan sendtoaddress()\n                     {\"comment_to\", RPCArg::Type::STR, RPCArg::Optional::OMITTED_NAMED_ARG, \"A comment to store the name of the person or organization\\n\"\n                                          \"to which you're sending the transaction. This is not part of the \\n\"\n                                          \"transaction, just kept in your wallet.\"},\n-                    {\"subtractfeefromamount\", RPCArg::Type::BOOL, /* default */ \"false\", \"The fee will be deducted from the amount being sent.\\n\"\n+                    {\"subtractfeefromamount\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"The fee will be deducted from the amount being sent.\\n\"\n                                          \"The recipient will receive less bitcoins than you enter in the amount field.\"},\n-                    {\"replaceable\", RPCArg::Type::BOOL, /* default */ \"wallet default\", \"Allow this transaction to be replaced by a transaction with higher fees via BIP 125\"},\n-                    {\"conf_target\", RPCArg::Type::NUM, /* default */ \"wallet -txconfirmtarget\", \"Confirmation target in blocks\"},\n-                    {\"estimate_mode\", RPCArg::Type::STR, /* default */ \"unset\", std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                    {\"replaceable\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"wallet default\"}, \"Allow this transaction to be replaced by a transaction with higher fees via BIP 125\"},\n+                    {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+                    {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n             \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n-                    {\"avoid_reuse\", RPCArg::Type::BOOL, /* default */ \"true\", \"(only available if avoid_reuse wallet flag is set) Avoid spending from dirty addresses; addresses are considered\\n\"\n+                    {\"avoid_reuse\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"(only available if avoid_reuse wallet flag is set) Avoid spending from dirty addresses; addresses are considered\\n\"\n                                          \"dirty if they have previously been used in a transaction.\"},\n-                    {\"fee_rate\", RPCArg::Type::AMOUNT, /* default */ \"not set, fall back to wallet fee estimation\", \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n-                    {\"verbose\", RPCArg::Type::BOOL, /* default */ \"false\", \"If true, return extra information about the transaction.\"},\n+                    {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                    {\"verbose\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"If true, return extra information about the transaction.\"},\n                 },\n                 {\n                     RPCResult{\"if verbose is not set or set to false\",\n@@ -697,7 +697,7 @@ static RPCHelpMan getreceivedbyaddress()\n                 \"\\nReturns the total amount received by the given address in transactions with at least minconf confirmations.\\n\",\n                 {\n                     {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The bitcoin address for transactions.\"},\n-                    {\"minconf\", RPCArg::Type::NUM, /* default */ \"1\", \"Only include transactions confirmed at least this many times.\"},\n+                    {\"minconf\", RPCArg::Type::NUM, RPCArg::Default{1}, \"Only include transactions confirmed at least this many times.\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::STR_AMOUNT, \"amount\", \"The total amount in \" + CURRENCY_UNIT + \" received at this address.\"\n@@ -735,7 +735,7 @@ static RPCHelpMan getreceivedbylabel()\n                 \"\\nReturns the total amount received by addresses with <label> in transactions with at least [minconf] confirmations.\\n\",\n                 {\n                     {\"label\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The selected label, may be the default label using \\\"\\\".\"},\n-                    {\"minconf\", RPCArg::Type::NUM, /* default */ \"1\", \"Only include transactions confirmed at least this many times.\"},\n+                    {\"minconf\", RPCArg::Type::NUM, RPCArg::Default{1}, \"Only include transactions confirmed at least this many times.\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::STR_AMOUNT, \"amount\", \"The total amount in \" + CURRENCY_UNIT + \" received for this label.\"\n@@ -775,9 +775,9 @@ static RPCHelpMan getbalance()\n                 \"thus affected by options which limit spendability such as -spendzeroconfchange.\\n\",\n                 {\n                     {\"dummy\", RPCArg::Type::STR, RPCArg::Optional::OMITTED_NAMED_ARG, \"Remains for backward compatibility. Must be excluded or set to \\\"*\\\".\"},\n-                    {\"minconf\", RPCArg::Type::NUM, /* default */ \"0\", \"Only include transactions confirmed at least this many times.\"},\n-                    {\"include_watchonly\", RPCArg::Type::BOOL, /* default */ \"true for watch-only wallets, otherwise false\", \"Also include balance in watch-only addresses (see 'importaddress')\"},\n-                    {\"avoid_reuse\", RPCArg::Type::BOOL, /* default */ \"true\", \"(only available if avoid_reuse wallet flag is set) Do not include balance in dirty outputs; addresses are considered dirty if they have previously been used in a transaction.\"},\n+                    {\"minconf\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Only include transactions confirmed at least this many times.\"},\n+                    {\"include_watchonly\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also include balance in watch-only addresses (see 'importaddress')\"},\n+                    {\"avoid_reuse\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"(only available if avoid_reuse wallet flag is set) Do not include balance in dirty outputs; addresses are considered dirty if they have previously been used in a transaction.\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::STR_AMOUNT, \"amount\", \"The total amount in \" + CURRENCY_UNIT + \" received for this wallet.\"\n@@ -868,12 +868,12 @@ static RPCHelpMan sendmany()\n                             {\"address\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"Subtract fee from this address\"},\n                         },\n                     },\n-                    {\"replaceable\", RPCArg::Type::BOOL, /* default */ \"wallet default\", \"Allow this transaction to be replaced by a transaction with higher fees via BIP 125\"},\n-                    {\"conf_target\", RPCArg::Type::NUM, /* default */ \"wallet -txconfirmtarget\", \"Confirmation target in blocks\"},\n-                    {\"estimate_mode\", RPCArg::Type::STR, /* default */ \"unset\", std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                    {\"replaceable\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"wallet default\"}, \"Allow this transaction to be replaced by a transaction with higher fees via BIP 125\"},\n+                    {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+                    {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n             \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n-                    {\"fee_rate\", RPCArg::Type::AMOUNT, /* default */ \"not set, fall back to wallet fee estimation\", \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n-                    {\"verbose\", RPCArg::Type::BOOL, /* default */ \"false\", \"If true, return extra infomration about the transaction.\"},\n+                    {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                    {\"verbose\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"If true, return extra infomration about the transaction.\"},\n                 },\n                 {\n                     RPCResult{\"if verbose is not set or set to false\",\n@@ -956,7 +956,7 @@ static RPCHelpMan addmultisigaddress()\n                         },\n                         },\n                     {\"label\", RPCArg::Type::STR, RPCArg::Optional::OMITTED_NAMED_ARG, \"A label to assign the addresses to.\"},\n-                    {\"address_type\", RPCArg::Type::STR, /* default */ \"set by -addresstype\", \"The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n+                    {\"address_type\", RPCArg::Type::STR, RPCArg::DefaultHint{\"set by -addresstype\"}, \"The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"\",\n@@ -1185,9 +1185,9 @@ static RPCHelpMan listreceivedbyaddress()\n     return RPCHelpMan{\"listreceivedbyaddress\",\n                 \"\\nList balances by receiving address.\\n\",\n                 {\n-                    {\"minconf\", RPCArg::Type::NUM, /* default */ \"1\", \"The minimum number of confirmations before payments are included.\"},\n-                    {\"include_empty\", RPCArg::Type::BOOL, /* default */ \"false\", \"Whether to include addresses that haven't received any payments.\"},\n-                    {\"include_watchonly\", RPCArg::Type::BOOL, /* default */ \"true for watch-only wallets, otherwise false\", \"Whether to include watch-only addresses (see 'importaddress')\"},\n+                    {\"minconf\", RPCArg::Type::NUM, RPCArg::Default{1}, \"The minimum number of confirmations before payments are included.\"},\n+                    {\"include_empty\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Whether to include addresses that haven't received any payments.\"},\n+                    {\"include_watchonly\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Whether to include watch-only addresses (see 'importaddress')\"},\n                     {\"address_filter\", RPCArg::Type::STR, RPCArg::Optional::OMITTED_NAMED_ARG, \"If present, only return information on this address.\"},\n                 },\n                 RPCResult{\n@@ -1234,9 +1234,9 @@ static RPCHelpMan listreceivedbylabel()\n     return RPCHelpMan{\"listreceivedbylabel\",\n                 \"\\nList received transactions by label.\\n\",\n                 {\n-                    {\"minconf\", RPCArg::Type::NUM, /* default */ \"1\", \"The minimum number of confirmations before payments are included.\"},\n-                    {\"include_empty\", RPCArg::Type::BOOL, /* default */ \"false\", \"Whether to include labels that haven't received any payments.\"},\n-                    {\"include_watchonly\", RPCArg::Type::BOOL, /* default */ \"true for watch-only wallets, otherwise false\", \"Whether to include watch-only addresses (see 'importaddress')\"},\n+                    {\"minconf\", RPCArg::Type::NUM, RPCArg::Default{1}, \"The minimum number of confirmations before payments are included.\"},\n+                    {\"include_empty\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Whether to include labels that haven't received any payments.\"},\n+                    {\"include_watchonly\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Whether to include watch-only addresses (see 'importaddress')\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::ARR, \"\", \"\",\n@@ -1396,9 +1396,9 @@ static RPCHelpMan listtransactions()\n                 {\n                     {\"label|dummy\", RPCArg::Type::STR, RPCArg::Optional::OMITTED_NAMED_ARG, \"If set, should be a valid label name to return only incoming transactions\\n\"\n                           \"with the specified label, or \\\"*\\\" to disable filtering and return all transactions.\"},\n-                    {\"count\", RPCArg::Type::NUM, /* default */ \"10\", \"The number of transactions to return\"},\n-                    {\"skip\", RPCArg::Type::NUM, /* default */ \"0\", \"The number of transactions to skip\"},\n-                    {\"include_watchonly\", RPCArg::Type::BOOL, /* default */ \"true for watch-only wallets, otherwise false\", \"Include transactions to watch-only addresses (see 'importaddress')\"},\n+                    {\"count\", RPCArg::Type::NUM, RPCArg::Default{10}, \"The number of transactions to return\"},\n+                    {\"skip\", RPCArg::Type::NUM, RPCArg::Default{0}, \"The number of transactions to skip\"},\n+                    {\"include_watchonly\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Include transactions to watch-only addresses (see 'importaddress')\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::ARR, \"\", \"\",\n@@ -1507,9 +1507,9 @@ static RPCHelpMan listsinceblock()\n                 \"Additionally, if include_removed is set, transactions affecting the wallet which were removed are returned in the \\\"removed\\\" array.\\n\",\n                 {\n                     {\"blockhash\", RPCArg::Type::STR, RPCArg::Optional::OMITTED_NAMED_ARG, \"If set, the block hash to list transactions since, otherwise list all transactions.\"},\n-                    {\"target_confirmations\", RPCArg::Type::NUM, /* default */ \"1\", \"Return the nth block hash from the main chain. e.g. 1 would mean the best block hash. Note: this is not used as a filter, but only affects [lastblock] in the return value\"},\n-                    {\"include_watchonly\", RPCArg::Type::BOOL, /* default */ \"true for watch-only wallets, otherwise false\", \"Include transactions to watch-only addresses (see 'importaddress')\"},\n-                    {\"include_removed\", RPCArg::Type::BOOL, /* default */ \"true\", \"Show transactions that were removed due to a reorg in the \\\"removed\\\" array\\n\"\n+                    {\"target_confirmations\", RPCArg::Type::NUM, RPCArg::Default{1}, \"Return the nth block hash from the main chain. e.g. 1 would mean the best block hash. Note: this is not used as a filter, but only affects [lastblock] in the return value\"},\n+                    {\"include_watchonly\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Include transactions to watch-only addresses (see 'importaddress')\"},\n+                    {\"include_removed\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"Show transactions that were removed due to a reorg in the \\\"removed\\\" array\\n\"\n                                                                        \"(not guaranteed to work on pruned nodes)\"},\n                 },\n                 RPCResult{\n@@ -1645,9 +1645,9 @@ static RPCHelpMan gettransaction()\n                 \"\\nGet detailed information about in-wallet transaction <txid>\\n\",\n                 {\n                     {\"txid\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The transaction id\"},\n-                    {\"include_watchonly\", RPCArg::Type::BOOL, /* default */ \"true for watch-only wallets, otherwise false\",\n+                    {\"include_watchonly\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"},\n                             \"Whether to include watch-only addresses in balance calculation and details[]\"},\n-                    {\"verbose\", RPCArg::Type::BOOL, /* default */ \"false\",\n+                    {\"verbose\", RPCArg::Type::BOOL, RPCArg::Default{false},\n                             \"Whether to include a `decoded` field containing the decoded transaction (equivalent to RPC decoderawtransaction)\"},\n                 },\n                 RPCResult{\n@@ -1832,7 +1832,7 @@ static RPCHelpMan keypoolrefill()\n                 \"\\nFills the keypool.\"+\n         HELP_REQUIRING_PASSPHRASE,\n                 {\n-                    {\"newsize\", RPCArg::Type::NUM, /* default */ \"100\", \"The new keypool size\"},\n+                    {\"newsize\", RPCArg::Type::NUM, RPCArg::Default{100}, \"The new keypool size\"},\n                 },\n                 RPCResult{RPCResult::Type::NONE, \"\", \"\"},\n                 RPCExamples{\n@@ -2124,7 +2124,7 @@ static RPCHelpMan lockunspent()\n                 \"Also see the listunspent call\\n\",\n                 {\n                     {\"unlock\", RPCArg::Type::BOOL, RPCArg::Optional::NO, \"Whether to unlock (true) or lock (false) the specified transactions\"},\n-                    {\"transactions\", RPCArg::Type::ARR, /* default */ \"empty array\", \"The transaction outputs and within each, the txid (string) vout (numeric).\",\n+                    {\"transactions\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"The transaction outputs and within each, the txid (string) vout (numeric).\",\n                         {\n                             {\"\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, \"\",\n                                 {\n@@ -2567,7 +2567,7 @@ static RPCHelpMan loadwallet()\n                 \"\\napplied to the new wallet (eg -rescan, etc).\\n\",\n                 {\n                     {\"filename\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The wallet directory or .dat file.\"},\n-                    {\"load_on_startup\", RPCArg::Type::BOOL, /* default */ \"null\", \"Save wallet name to persistent settings and load on startup. True to add wallet to startup list, false to remove, null to leave unchanged.\"},\n+                    {\"load_on_startup\", RPCArg::Type::BOOL, RPCArg::Default{UniValue::VNULL}, \"Save wallet name to persistent settings and load on startup. True to add wallet to startup list, false to remove, null to leave unchanged.\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"\",\n@@ -2630,7 +2630,7 @@ static RPCHelpMan setwalletflag()\n                 \"\\nChange the state of the given wallet flag for a wallet.\\n\",\n                 {\n                     {\"flag\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The name of the flag to change. Current available flags: \" + flags},\n-                    {\"value\", RPCArg::Type::BOOL, /* default */ \"true\", \"The new state.\"},\n+                    {\"value\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"The new state.\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"\",\n@@ -2693,13 +2693,13 @@ static RPCHelpMan createwallet()\n         \"\\nCreates and loads a new wallet.\\n\",\n         {\n             {\"wallet_name\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The name for the new wallet. If this is a path, the wallet will be created at the path location.\"},\n-            {\"disable_private_keys\", RPCArg::Type::BOOL, /* default */ \"false\", \"Disable the possibility of private keys (only watchonlys are possible in this mode).\"},\n-            {\"blank\", RPCArg::Type::BOOL, /* default */ \"false\", \"Create a blank wallet. A blank wallet has no keys or HD seed. One can be set using sethdseed.\"},\n+            {\"disable_private_keys\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Disable the possibility of private keys (only watchonlys are possible in this mode).\"},\n+            {\"blank\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Create a blank wallet. A blank wallet has no keys or HD seed. One can be set using sethdseed.\"},\n             {\"passphrase\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"Encrypt the wallet with this passphrase.\"},\n-            {\"avoid_reuse\", RPCArg::Type::BOOL, /* default */ \"false\", \"Keep track of coin reuse, and treat dirty and clean coins differently with privacy considerations in mind.\"},\n-            {\"descriptors\", RPCArg::Type::BOOL, /* default */ \"false\", \"Create a native descriptor wallet. The wallet will use descriptors internally to handle address creation\"},\n-            {\"load_on_startup\", RPCArg::Type::BOOL, /* default */ \"null\", \"Save wallet name to persistent settings and load on startup. True to add wallet to startup list, false to remove, null to leave unchanged.\"},\n-            {\"external_signer\", RPCArg::Type::BOOL, /* default */ \"false\", \"Use an external signer such as a hardware wallet. Requires -signer to be configured. Wallet creation will fail if keys cannot be fetched. Requires disable_private_keys and descriptors set to true.\"},\n+            {\"avoid_reuse\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Keep track of coin reuse, and treat dirty and clean coins differently with privacy considerations in mind.\"},\n+            {\"descriptors\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Create a native descriptor wallet. The wallet will use descriptors internally to handle address creation\"},\n+            {\"load_on_startup\", RPCArg::Type::BOOL, RPCArg::Default{UniValue::VNULL}, \"Save wallet name to persistent settings and load on startup. True to add wallet to startup list, false to remove, null to leave unchanged.\"},\n+            {\"external_signer\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Use an external signer such as a hardware wallet. Requires -signer to be configured. Wallet creation will fail if keys cannot be fetched. Requires disable_private_keys and descriptors set to true.\"},\n         },\n         RPCResult{\n             RPCResult::Type::OBJ, \"\", \"\",\n@@ -2788,8 +2788,8 @@ static RPCHelpMan unloadwallet()\n                 \"Unloads the wallet referenced by the request endpoint otherwise unloads the wallet specified in the argument.\\n\"\n                 \"Specifying the wallet name on a wallet endpoint is invalid.\",\n                 {\n-                    {\"wallet_name\", RPCArg::Type::STR, /* default */ \"the wallet name from the RPC endpoint\", \"The name of the wallet to unload. If provided both here and in the RPC endpoint, the two must be identical.\"},\n-                    {\"load_on_startup\", RPCArg::Type::BOOL, /* default */ \"null\", \"Save wallet name to persistent settings and load on startup. True to add wallet to startup list, false to remove, null to leave unchanged.\"},\n+                    {\"wallet_name\", RPCArg::Type::STR, RPCArg::DefaultHint{\"the wallet name from the RPC endpoint\"}, \"The name of the wallet to unload. If provided both here and in the RPC endpoint, the two must be identical.\"},\n+                    {\"load_on_startup\", RPCArg::Type::BOOL, RPCArg::Default{UniValue::VNULL}, \"Save wallet name to persistent settings and load on startup. True to add wallet to startup list, false to remove, null to leave unchanged.\"},\n                 },\n                 RPCResult{RPCResult::Type::OBJ, \"\", \"\", {\n                     {RPCResult::Type::STR, \"warning\", \"Warning message if wallet was not unloaded cleanly.\"},\n@@ -2840,21 +2840,21 @@ static RPCHelpMan listunspent()\n                 \"with between minconf and maxconf (inclusive) confirmations.\\n\"\n                 \"Optionally filter to only include txouts paid to specified addresses.\\n\",\n                 {\n-                    {\"minconf\", RPCArg::Type::NUM, /* default */ \"1\", \"The minimum confirmations to filter\"},\n-                    {\"maxconf\", RPCArg::Type::NUM, /* default */ \"9999999\", \"The maximum confirmations to filter\"},\n-                    {\"addresses\", RPCArg::Type::ARR, /* default */ \"empty array\", \"The bitcoin addresses to filter\",\n+                    {\"minconf\", RPCArg::Type::NUM, RPCArg::Default{1}, \"The minimum confirmations to filter\"},\n+                    {\"maxconf\", RPCArg::Type::NUM, RPCArg::Default{9999999}, \"The maximum confirmations to filter\"},\n+                    {\"addresses\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"The bitcoin addresses to filter\",\n                         {\n                             {\"address\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"bitcoin address\"},\n                         },\n                     },\n-                    {\"include_unsafe\", RPCArg::Type::BOOL, /* default */ \"true\", \"Include outputs that are not safe to spend\\n\"\n+                    {\"include_unsafe\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"Include outputs that are not safe to spend\\n\"\n                               \"See description of \\\"safe\\\" attribute below.\"},\n                     {\"query_options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"JSON with query options\",\n                         {\n-                            {\"minimumAmount\", RPCArg::Type::AMOUNT, /* default */ \"0\", \"Minimum value of each UTXO in \" + CURRENCY_UNIT + \"\"},\n-                            {\"maximumAmount\", RPCArg::Type::AMOUNT, /* default */ \"unlimited\", \"Maximum value of each UTXO in \" + CURRENCY_UNIT + \"\"},\n-                            {\"maximumCount\", RPCArg::Type::NUM, /* default */ \"unlimited\", \"Maximum number of UTXOs\"},\n-                            {\"minimumSumAmount\", RPCArg::Type::AMOUNT, /* default */ \"unlimited\", \"Minimum sum value of all UTXOs in \" + CURRENCY_UNIT + \"\"},\n+                            {\"minimumAmount\", RPCArg::Type::AMOUNT, RPCArg::Default{FormatMoney(0)}, \"Minimum value of each UTXO in \" + CURRENCY_UNIT + \"\"},\n+                            {\"maximumAmount\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"unlimited\"}, \"Maximum value of each UTXO in \" + CURRENCY_UNIT + \"\"},\n+                            {\"maximumCount\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"unlimited\"}, \"Maximum number of UTXOs\"},\n+                            {\"minimumSumAmount\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"unlimited\"}, \"Minimum sum value of all UTXOs in \" + CURRENCY_UNIT + \"\"},\n                         },\n                         \"query_options\"},\n                 },\n@@ -3204,32 +3204,32 @@ static RPCHelpMan fundrawtransaction()\n                     {\"hexstring\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The hex string of the raw transaction\"},\n                     {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"for backward compatibility: passing in a true instead of an object will result in {\\\"includeWatching\\\":true}\",\n                         {\n-                            {\"add_inputs\", RPCArg::Type::BOOL, /* default */ \"true\", \"For a transaction with existing inputs, automatically include more if they are not enough.\"},\n-                            {\"changeAddress\", RPCArg::Type::STR, /* default */ \"pool address\", \"The bitcoin address to receive the change\"},\n-                            {\"changePosition\", RPCArg::Type::NUM, /* default */ \"random\", \"The index of the change output\"},\n-                            {\"change_type\", RPCArg::Type::STR, /* default */ \"set by -changetype\", \"The output type to use. Only valid if changeAddress is not specified. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n-                            {\"includeWatching\", RPCArg::Type::BOOL, /* default */ \"true for watch-only wallets, otherwise false\", \"Also select inputs which are watch only.\\n\"\n+                            {\"add_inputs\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"For a transaction with existing inputs, automatically include more if they are not enough.\"},\n+                            {\"changeAddress\", RPCArg::Type::STR, RPCArg::DefaultHint{\"pool address\"}, \"The bitcoin address to receive the change\"},\n+                            {\"changePosition\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"random\"}, \"The index of the change output\"},\n+                            {\"change_type\", RPCArg::Type::STR, RPCArg::DefaultHint{\"set by -changetype\"}, \"The output type to use. Only valid if changeAddress is not specified. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n+                            {\"includeWatching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n                                                           \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n                                                           \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n-                            {\"lockUnspents\", RPCArg::Type::BOOL, /* default */ \"false\", \"Lock selected unspent outputs\"},\n-                            {\"fee_rate\", RPCArg::Type::AMOUNT, /* default */ \"not set, fall back to wallet fee estimation\", \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n-                            {\"feeRate\", RPCArg::Type::AMOUNT, /* default */ \"not set, fall back to wallet fee estimation\", \"Specify a fee rate in \" + CURRENCY_UNIT + \"/kvB.\"},\n-                            {\"subtractFeeFromOutputs\", RPCArg::Type::ARR, /* default */ \"empty array\", \"The integers.\\n\"\n+                            {\"lockUnspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                            {\"feeRate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_UNIT + \"/kvB.\"},\n+                            {\"subtractFeeFromOutputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"The integers.\\n\"\n                                                           \"The fee will be equally deducted from the amount of each specified output.\\n\"\n                                                           \"Those recipients will receive less bitcoins than you enter in their corresponding amount field.\\n\"\n                                                           \"If no outputs are specified here, the sender pays the fee.\",\n                                 {\n                                     {\"vout_index\", RPCArg::Type::NUM, RPCArg::Optional::OMITTED, \"The zero-based output index, before a change output is added.\"},\n                                 },\n                             },\n-                            {\"replaceable\", RPCArg::Type::BOOL, /* default */ \"wallet default\", \"Marks this transaction as BIP125 replaceable.\\n\"\n+                            {\"replaceable\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"wallet default\"}, \"Marks this transaction as BIP125 replaceable.\\n\"\n                                                           \"Allows this transaction to be replaced by a transaction with higher fees\"},\n-                            {\"conf_target\", RPCArg::Type::NUM, /* default */ \"wallet -txconfirmtarget\", \"Confirmation target in blocks\"},\n-                            {\"estimate_mode\", RPCArg::Type::STR, /* default */ \"unset\", std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+                            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n                             \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n                         },\n                         \"options\"},\n-                    {\"iswitness\", RPCArg::Type::BOOL, /* default */ \"depends on heuristic tests\", \"Whether the transaction hex is a serialized witness transaction.\\n\"\n+                    {\"iswitness\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"depends on heuristic tests\"}, \"Whether the transaction hex is a serialized witness transaction.\\n\"\n                         \"If iswitness is not present, heuristic tests will be used in decoding.\\n\"\n                         \"If true, only witness deserialization will be tried.\\n\"\n                         \"If false, only non-witness deserialization will be tried.\\n\"\n@@ -3310,7 +3310,7 @@ RPCHelpMan signrawtransactionwithwallet()\n                             },\n                         },\n                     },\n-                    {\"sighashtype\", RPCArg::Type::STR, /* default */ \"ALL\", \"The signature hash type. Must be one of\\n\"\n+                    {\"sighashtype\", RPCArg::Type::STR, RPCArg::Default{\"ALL\"}, \"The signature hash type. Must be one of\\n\"\n             \"       \\\"ALL\\\"\\n\"\n             \"       \\\"NONE\\\"\\n\"\n             \"       \\\"SINGLE\\\"\\n\"\n@@ -3402,19 +3402,19 @@ static RPCHelpMan bumpfee_helper(std::string method_name)\n             {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The txid to be bumped\"},\n             {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n                 {\n-                    {\"conf_target\", RPCArg::Type::NUM, /* default */ \"wallet -txconfirmtarget\", \"Confirmation target in blocks\\n\"},\n-                    {\"fee_rate\", RPCArg::Type::AMOUNT, /* default */ \"not set, fall back to wallet fee estimation\",\n+                    {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\\n\"},\n+                    {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"},\n                              \"\\nSpecify a fee rate in \" + CURRENCY_ATOM + \"/vB instead of relying on the built-in fee estimator.\\n\"\n                              \"Must be at least \" + incremental_fee + \" higher than the current transaction fee rate.\\n\"\n                              \"WARNING: before version 0.21, fee_rate was in \" + CURRENCY_UNIT + \"/kvB. As of 0.21, fee_rate is in \" + CURRENCY_ATOM + \"/vB.\\n\"},\n-                    {\"replaceable\", RPCArg::Type::BOOL, /* default */ \"true\", \"Whether the new transaction should still be\\n\"\n+                    {\"replaceable\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"Whether the new transaction should still be\\n\"\n                              \"marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n                              \"be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n                              \"original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n                              \"so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n                              \"still be replaceable in practice, for example if it has unconfirmed ancestors which\\n\"\n                              \"are replaceable).\\n\"},\n-                    {\"estimate_mode\", RPCArg::Type::STR, /* default */ \"unset\", std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                    {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, \"The fee estimate mode, must be one of (case insensitive):\\n\"\n                              \"\\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n                 },\n                 \"options\"},\n@@ -3564,7 +3564,7 @@ static RPCHelpMan rescanblockchain()\n                 \"\\nRescan the local blockchain for wallet related transactions.\\n\"\n                 \"Note: Use \\\"getwalletinfo\\\" to query the scanning progress.\\n\",\n                 {\n-                    {\"start_height\", RPCArg::Type::NUM, /* default */ \"0\", \"block height where the rescan should start\"},\n+                    {\"start_height\", RPCArg::Type::NUM, RPCArg::Default{0}, \"block height where the rescan should start\"},\n                     {\"stop_height\", RPCArg::Type::NUM, RPCArg::Optional::OMITTED_NAMED_ARG, \"the last block height that should be scanned. If none is provided it will rescan up to the tip at return time of this call.\"},\n                 },\n                 RPCResult{\n@@ -4023,43 +4023,43 @@ static RPCHelpMan send()\n                     },\n                 },\n             },\n-            {\"conf_target\", RPCArg::Type::NUM, /* default */ \"wallet -txconfirmtarget\", \"Confirmation target in blocks\"},\n-            {\"estimate_mode\", RPCArg::Type::STR, /* default */ \"unset\", std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n                         \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n-            {\"fee_rate\", RPCArg::Type::AMOUNT, /* default */ \"not set, fall back to wallet fee estimation\", \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n             {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n                 {\n-                    {\"add_inputs\", RPCArg::Type::BOOL, /* default */ \"false\", \"If inputs are specified, automatically include more if they are not enough.\"},\n-                    {\"add_to_wallet\", RPCArg::Type::BOOL, /* default */ \"true\", \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n-                    {\"change_address\", RPCArg::Type::STR_HEX, /* default */ \"pool address\", \"The bitcoin address to receive the change\"},\n-                    {\"change_position\", RPCArg::Type::NUM, /* default */ \"random\", \"The index of the change output\"},\n-                    {\"change_type\", RPCArg::Type::STR, /* default */ \"set by -changetype\", \"The output type to use. Only valid if change_address is not specified. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n-                    {\"conf_target\", RPCArg::Type::NUM, /* default */ \"wallet -txconfirmtarget\", \"Confirmation target in blocks\"},\n-                    {\"estimate_mode\", RPCArg::Type::STR, /* default */ \"unset\", std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                    {\"add_inputs\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"If inputs are specified, automatically include more if they are not enough.\"},\n+                    {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                    {\"change_address\", RPCArg::Type::STR_HEX, RPCArg::DefaultHint{\"pool address\"}, \"The bitcoin address to receive the change\"},\n+                    {\"change_position\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"random\"}, \"The index of the change output\"},\n+                    {\"change_type\", RPCArg::Type::STR, RPCArg::DefaultHint{\"set by -changetype\"}, \"The output type to use. Only valid if change_address is not specified. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n+                    {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+                    {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n             \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n-                    {\"fee_rate\", RPCArg::Type::AMOUNT, /* default */ \"not set, fall back to wallet fee estimation\", \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n-                    {\"include_watching\", RPCArg::Type::BOOL, /* default */ \"true for watch-only wallets, otherwise false\", \"Also select inputs which are watch only.\\n\"\n+                    {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                    {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n                                           \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n                                           \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n-                    {\"inputs\", RPCArg::Type::ARR, /* default */ \"empty array\", \"Specify inputs instead of adding them automatically. A JSON array of JSON objects\",\n+                    {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Specify inputs instead of adding them automatically. A JSON array of JSON objects\",\n                         {\n                             {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n                             {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n                             {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n                         },\n                     },\n-                    {\"locktime\", RPCArg::Type::NUM, /* default */ \"0\", \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n-                    {\"lock_unspents\", RPCArg::Type::BOOL, /* default */ \"false\", \"Lock selected unspent outputs\"},\n-                    {\"psbt\", RPCArg::Type::BOOL,  /* default */ \"automatic\", \"Always return a PSBT, implies add_to_wallet=false.\"},\n-                    {\"subtract_fee_from_outputs\", RPCArg::Type::ARR, /* default */ \"empty array\", \"Outputs to subtract the fee from, specified as integer indices.\\n\"\n+                    {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                    {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                    {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                    {\"subtract_fee_from_outputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Outputs to subtract the fee from, specified as integer indices.\\n\"\n                     \"The fee will be equally deducted from the amount of each specified output.\\n\"\n                     \"Those recipients will receive less bitcoins than you enter in their corresponding amount field.\\n\"\n                     \"If no outputs are specified here, the sender pays the fee.\",\n                         {\n                             {\"vout_index\", RPCArg::Type::NUM, RPCArg::Optional::OMITTED, \"The zero-based output index, before a change output is added.\"},\n                         },\n                     },\n-                    {\"replaceable\", RPCArg::Type::BOOL, /* default */ \"wallet default\", \"Marks this transaction as BIP125 replaceable.\\n\"\n+                    {\"replaceable\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"wallet default\"}, \"Marks this transaction as BIP125 replaceable.\\n\"\n                                                   \"Allows this transaction to be replaced by a transaction with higher fees\"},\n                 },\n                 \"options\"},\n@@ -4207,11 +4207,11 @@ static RPCHelpMan sethdseed()\n                 \"\\nNote that you will need to MAKE A NEW BACKUP of your wallet after setting the HD wallet seed.\" +\n         HELP_REQUIRING_PASSPHRASE,\n                 {\n-                    {\"newkeypool\", RPCArg::Type::BOOL, /* default */ \"true\", \"Whether to flush old unused addresses, including change addresses, from the keypool and regenerate it.\\n\"\n+                    {\"newkeypool\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"Whether to flush old unused addresses, including change addresses, from the keypool and regenerate it.\\n\"\n                                          \"If true, the next address from getnewaddress and change address from getrawchangeaddress will be from this new seed.\\n\"\n                                          \"If false, addresses (including change addresses if the wallet already had HD Chain Split enabled) from the existing\\n\"\n                                          \"keypool will be used until it has been depleted.\"},\n-                    {\"seed\", RPCArg::Type::STR, /* default */ \"random seed\", \"The WIF private key to use as the new HD seed.\\n\"\n+                    {\"seed\", RPCArg::Type::STR, RPCArg::DefaultHint{\"random seed\"}, \"The WIF private key to use as the new HD seed.\\n\"\n                                          \"The seed value can be retrieved using the dumpwallet command. It is the private key marked hdseed=1\"},\n                 },\n                 RPCResult{RPCResult::Type::NONE, \"\", \"\"},\n@@ -4278,15 +4278,15 @@ static RPCHelpMan walletprocesspsbt()\n         HELP_REQUIRING_PASSPHRASE,\n                 {\n                     {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The transaction base64 string\"},\n-                    {\"sign\", RPCArg::Type::BOOL, /* default */ \"true\", \"Also sign the transaction when updating\"},\n-                    {\"sighashtype\", RPCArg::Type::STR, /* default */ \"ALL\", \"The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"\n+                    {\"sign\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"Also sign the transaction when updating\"},\n+                    {\"sighashtype\", RPCArg::Type::STR, RPCArg::Default{\"ALL\"}, \"The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"\n             \"       \\\"ALL\\\"\\n\"\n             \"       \\\"NONE\\\"\\n\"\n             \"       \\\"SINGLE\\\"\\n\"\n             \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n             \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n             \"       \\\"SINGLE|ANYONECANPAY\\\"\"},\n-                    {\"bip32derivs\", RPCArg::Type::BOOL, /* default */ \"true\", \"Include BIP 32 derivation paths for public keys if we know them\"},\n+                    {\"bip32derivs\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"Include BIP 32 derivation paths for public keys if we know them\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"\",\n@@ -4347,7 +4347,7 @@ static RPCHelpMan walletcreatefundedpsbt()\n                                 {\n                                     {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n                                     {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n-                                    {\"sequence\", RPCArg::Type::NUM, /* default */ \"depends on the value of the 'locktime' and 'options.replaceable' arguments\", \"The sequence number\"},\n+                                    {\"sequence\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"depends on the value of the 'locktime' and 'options.replaceable' arguments\"}, \"The sequence number\"},\n                                 },\n                             },\n                         },\n@@ -4369,33 +4369,33 @@ static RPCHelpMan walletcreatefundedpsbt()\n                             },\n                         },\n                     },\n-                    {\"locktime\", RPCArg::Type::NUM, /* default */ \"0\", \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                    {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n                     {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n                         {\n-                            {\"add_inputs\", RPCArg::Type::BOOL, /* default */ \"false\", \"If inputs are specified, automatically include more if they are not enough.\"},\n-                            {\"changeAddress\", RPCArg::Type::STR_HEX, /* default */ \"pool address\", \"The bitcoin address to receive the change\"},\n-                            {\"changePosition\", RPCArg::Type::NUM, /* default */ \"random\", \"The index of the change output\"},\n-                            {\"change_type\", RPCArg::Type::STR, /* default */ \"set by -changetype\", \"The output type to use. Only valid if changeAddress is not specified. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n-                            {\"includeWatching\", RPCArg::Type::BOOL, /* default */ \"true for watch-only wallets, otherwise false\", \"Also select inputs which are watch only\"},\n-                            {\"lockUnspents\", RPCArg::Type::BOOL, /* default */ \"false\", \"Lock selected unspent outputs\"},\n-                            {\"fee_rate\", RPCArg::Type::AMOUNT, /* default */ \"not set, fall back to wallet fee estimation\", \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n-                            {\"feeRate\", RPCArg::Type::AMOUNT, /* default */ \"not set, fall back to wallet fee estimation\", \"Specify a fee rate in \" + CURRENCY_UNIT + \"/kvB.\"},\n-                            {\"subtractFeeFromOutputs\", RPCArg::Type::ARR, /* default */ \"empty array\", \"The outputs to subtract the fee from.\\n\"\n+                            {\"add_inputs\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"If inputs are specified, automatically include more if they are not enough.\"},\n+                            {\"changeAddress\", RPCArg::Type::STR_HEX, RPCArg::DefaultHint{\"pool address\"}, \"The bitcoin address to receive the change\"},\n+                            {\"changePosition\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"random\"}, \"The index of the change output\"},\n+                            {\"change_type\", RPCArg::Type::STR, RPCArg::DefaultHint{\"set by -changetype\"}, \"The output type to use. Only valid if changeAddress is not specified. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n+                            {\"includeWatching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only\"},\n+                            {\"lockUnspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                            {\"feeRate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_UNIT + \"/kvB.\"},\n+                            {\"subtractFeeFromOutputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"The outputs to subtract the fee from.\\n\"\n                                                           \"The fee will be equally deducted from the amount of each specified output.\\n\"\n                                                           \"Those recipients will receive less bitcoins than you enter in their corresponding amount field.\\n\"\n                                                           \"If no outputs are specified here, the sender pays the fee.\",\n                                 {\n                                     {\"vout_index\", RPCArg::Type::NUM, RPCArg::Optional::OMITTED, \"The zero-based output index, before a change output is added.\"},\n                                 },\n                             },\n-                            {\"replaceable\", RPCArg::Type::BOOL, /* default */ \"wallet default\", \"Marks this transaction as BIP125 replaceable.\\n\"\n+                            {\"replaceable\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"wallet default\"}, \"Marks this transaction as BIP125 replaceable.\\n\"\n                                                           \"Allows this transaction to be replaced by a transaction with higher fees\"},\n-                            {\"conf_target\", RPCArg::Type::NUM, /* default */ \"wallet -txconfirmtarget\", \"Confirmation target in blocks\"},\n-                            {\"estimate_mode\", RPCArg::Type::STR, /* default */ \"unset\", std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+                            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n                             \"         \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n                         },\n                         \"options\"},\n-                    {\"bip32derivs\", RPCArg::Type::BOOL, /* default */ \"true\", \"Include BIP 32 derivation paths for public keys if we know them\"},\n+                    {\"bip32derivs\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"Include BIP 32 derivation paths for public keys if we know them\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"\",\n@@ -4468,7 +4468,7 @@ static RPCHelpMan upgradewallet()\n         \"\\nUpgrade the wallet. Upgrades to the latest version if no version number is specified.\\n\"\n         \"New keys may be generated and a new wallet backup will need to be made.\",\n         {\n-            {\"version\", RPCArg::Type::NUM, /* default */ strprintf(\"%d\", FEATURE_LATEST), \"The version number to upgrade to. Default is the latest wallet version.\"}\n+            {\"version\", RPCArg::Type::NUM, RPCArg::Default{FEATURE_LATEST}, \"The version number to upgrade to. Default is the latest wallet version.\"}\n         },\n         RPCResult{\n             RPCResult::Type::OBJ, \"\", \"\","
      },
      {
        "sha": "8fa3f52de8d1d144c8280008039b0563b148d0fd",
        "filename": "test/functional/feature_csv_activation.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a443bc6dfbafd2fec5e4658961b74943a62acccd/test/functional/feature_csv_activation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a443bc6dfbafd2fec5e4658961b74943a62acccd/test/functional/feature_csv_activation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_csv_activation.py?ref=a443bc6dfbafd2fec5e4658961b74943a62acccd",
        "patch": "@@ -9,8 +9,8 @@\n BIP 112 - CHECKSEQUENCEVERIFY\n BIP 113 - MedianTimePast semantics for nLockTime\n \n-mine 82 blocks whose coinbases will be used to generate inputs for our tests\n-mine 345 blocks and seed block chain with the 82 inputs will use for our tests at height 427\n+mine 83 blocks whose coinbases will be used to generate inputs for our tests\n+mine 344 blocks and seed block chain with the 83 inputs used for our tests at height 427\n mine 2 blocks and verify soft fork not yet activated\n mine 1 block and test that soft fork is activated (rules enforced for next block)\n Test BIP 113 is enforced"
      },
      {
        "sha": "ac53a280b4a41853f63d8db9e686dc2bad36a5e7",
        "filename": "test/functional/rpc_blockchain.py",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a443bc6dfbafd2fec5e4658961b74943a62acccd/test/functional/rpc_blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a443bc6dfbafd2fec5e4658961b74943a62acccd/test/functional/rpc_blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_blockchain.py?ref=a443bc6dfbafd2fec5e4658961b74943a62acccd",
        "patch": "@@ -410,6 +410,9 @@ def _test_getblock(self):\n         self.log.info(\"Test that getblock with verbosity 2 still works with pruned Undo data\")\n         datadir = get_datadir_path(self.options.tmpdir, 0)\n \n+        self.log.info(\"Test that getblock with invalid verbosity type returns proper error message\")\n+        assert_raises_rpc_error(-1, \"JSON value is not an integer as expected\", node.getblock, blockhash, \"2\")\n+\n         def move_block_file(old, new):\n             old_path = os.path.join(datadir, self.chain, 'blocks', old)\n             new_path = os.path.join(datadir, self.chain, 'blocks', new)"
      }
    ]
  },
  {
    "sha": "7959c56d9efde643ff7f119c828833c0b6e2e67f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3OTU5YzU2ZDllZmRlNjQzZmY3ZjExOWM4Mjg4MzNjMGI2ZTJlNjdm",
    "commit": {
      "author": {
        "name": "J0hn",
        "email": "songjh.john@gmail.com",
        "date": "2021-04-29T18:11:14Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-04-29T18:11:14Z"
      },
      "message": "Merge pull request #10 from bitcoin/master\n\nGUI",
      "tree": {
        "sha": "03a66810a283114acb016257bb34ccf3b5473484",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/03a66810a283114acb016257bb34ccf3b5473484"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7959c56d9efde643ff7f119c828833c0b6e2e67f",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgivbCCRBK7hj4Ov3rIwAASBgIABqNvCjiUh1eWAW7oWUa/syJ\ne7ESdHsvfqhotOFHEhauAhZSJk7prL1+c52g1VNcR0IpYcH9uNRWLRwRFSlOhDDD\n/z9APRNYELqj/jOaVw6DIZjv08e8VHlENjkIdBim1AZwI+nqpItNqqsYdVF5CsJT\naCGsUqIG3RqIjYeQZhhltGExHlQk5aTdITyILgMhNx8ksWJ5Szm0zo8vsagdrDdY\nYCIEkAtk25TBqaPO1cwTfHadA/yKzjuzH7QzhOgSznGQr1S3rBjAF0eF0+vxjMJs\nzeWO2jysEnG7tiuqH5x2QAKg+5sl+asqMBwK6fqJFUzf9yVK4n32V8xkjsuAYlk=\n=xw5C\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 03a66810a283114acb016257bb34ccf3b5473484\nparent a443bc6dfbafd2fec5e4658961b74943a62acccd\nparent d9ae6ec8929e739187740baab206daa55cde61d1\nauthor J0hn <songjh.john@gmail.com> 1619719874 +0100\ncommitter GitHub <noreply@github.com> 1619719874 +0100\n\nMerge pull request #10 from bitcoin/master\n\nGUI"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7959c56d9efde643ff7f119c828833c0b6e2e67f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7959c56d9efde643ff7f119c828833c0b6e2e67f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7959c56d9efde643ff7f119c828833c0b6e2e67f/comments",
    "author": {
      "login": "Rqcker",
      "id": 20661419,
      "node_id": "MDQ6VXNlcjIwNjYxNDE5",
      "avatar_url": "https://avatars.githubusercontent.com/u/20661419?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Rqcker",
      "html_url": "https://github.com/Rqcker",
      "followers_url": "https://api.github.com/users/Rqcker/followers",
      "following_url": "https://api.github.com/users/Rqcker/following{/other_user}",
      "gists_url": "https://api.github.com/users/Rqcker/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Rqcker/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Rqcker/subscriptions",
      "organizations_url": "https://api.github.com/users/Rqcker/orgs",
      "repos_url": "https://api.github.com/users/Rqcker/repos",
      "events_url": "https://api.github.com/users/Rqcker/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Rqcker/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a443bc6dfbafd2fec5e4658961b74943a62acccd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a443bc6dfbafd2fec5e4658961b74943a62acccd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a443bc6dfbafd2fec5e4658961b74943a62acccd"
      },
      {
        "sha": "d9ae6ec8929e739187740baab206daa55cde61d1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d9ae6ec8929e739187740baab206daa55cde61d1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d9ae6ec8929e739187740baab206daa55cde61d1"
      }
    ],
    "stats": {
      "total": 10741,
      "additions": 9114,
      "deletions": 1627
    },
    "files": [
      {
        "sha": "fb95876c3677a2f58d4ec9263e5ed17b5a1e94ac",
        "filename": ".appveyor.yml",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/.appveyor.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/.appveyor.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.appveyor.yml?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -7,9 +7,9 @@ clone_depth: 5\n environment:\n   PATH: 'C:\\Python37-x64;C:\\Python37-x64\\Scripts;%PATH%'\n   PYTHONUTF8: 1\n-  QT_DOWNLOAD_URL: 'https://github.com/sipsorcery/qt_win_binary/releases/download/qt598x64_vs2019_v1681/qt598_x64_vs2019_1681.zip'\n-  QT_DOWNLOAD_HASH: '00cf7327818c07d74e0b1a4464ffe987c2728b00d49d4bf333065892af0515c3'\n-  QT_LOCAL_PATH: 'C:\\Qt5.9.8_x64_static_vs2019'\n+  QT_DOWNLOAD_URL: 'https://github.com/sipsorcery/qt_win_binary/releases/download/qt51210x64_vs2019_1694/Qt5.12.10_x64_static_vs2019_1694.zip'\n+  QT_DOWNLOAD_HASH: '3035a1307e8302bb3a76eba9bb3102979f945ab4022cc3bc2e1583edd44bdc99'\n+  QT_LOCAL_PATH: 'C:\\Qt5.12.10_x64_static_vs2019_1694'\n   VCPKG_TAG: '75522bb1f2e7d863078bcd06322348f053a9e33f'\n install:\n # Disable zmq test for now since python zmq library on Windows would cause Access violation sometimes."
      },
      {
        "sha": "e353101eccf861035439154822a9b6a37ebfdbf6",
        "filename": ".cirrus.yml",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/.cirrus.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/.cirrus.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.cirrus.yml?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -143,10 +143,10 @@ task:\n     FILE_ENV: \"./ci/test/00_setup_env_native_msan.sh\"\n \n task:\n-  name: '[no depends, sanitizers: address/leak (ASan + LSan) + undefined (UBSan) + integer] [focal]'\n+  name: '[no depends, sanitizers: address/leak (ASan + LSan) + undefined (UBSan) + integer] [hirsute]'\n   << : *GLOBAL_TASK_TEMPLATE\n   container:\n-    image: ubuntu:focal\n+    image: ubuntu:hirsute\n   env:\n     << : *CIRRUS_EPHEMERAL_WORKER_TEMPLATE_ENV\n     FILE_ENV: \"./ci/test/00_setup_env_native_asan.sh\""
      },
      {
        "sha": "232d481e1879886ca913715d37b369164142f023",
        "filename": ".tx/config",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/.tx/config",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/.tx/config",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.tx/config?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -1,7 +1,7 @@\n [main]\n host = https://www.transifex.com\n \n-[bitcoin.qt-translation-021x]\n-file_filter = src/qt/locale/bitcoin_<lang>.ts\n-source_file = src/qt/locale/bitcoin_en.ts\n+[bitcoin.qt-translation-022x]\n+file_filter = src/qt/locale/bitcoin_<lang>.xlf\n+source_file = src/qt/locale/bitcoin_en.xlf\n source_lang = en"
      },
      {
        "sha": "0995ef1406e71d4e318b57a81299b3738d077eaf",
        "filename": "build-aux/m4/bitcoin_qt.m4",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/build-aux/m4/bitcoin_qt.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/build-aux/m4/bitcoin_qt.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_qt.m4?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -225,6 +225,7 @@ AC_DEFUN([BITCOIN_QT_CONFIGURE],[\n   BITCOIN_QT_PATH_PROGS([RCC], [rcc-qt5 rcc5 rcc], $qt_bin_path)\n   BITCOIN_QT_PATH_PROGS([LRELEASE], [lrelease-qt5 lrelease5 lrelease], $qt_bin_path)\n   BITCOIN_QT_PATH_PROGS([LUPDATE], [lupdate-qt5 lupdate5 lupdate],$qt_bin_path, yes)\n+  BITCOIN_QT_PATH_PROGS([LCONVERT], [lconvert-qt5 lconvert5 lconvert], $qt_bin_path, yes)\n \n   MOC_DEFS='-DHAVE_CONFIG_H -I$(srcdir)'\n   case $host in\n@@ -258,7 +259,10 @@ AC_DEFUN([BITCOIN_QT_CONFIGURE],[\n       AC_MSG_ERROR([libQtDBus not found. Install libQtDBus or remove --with-qtdbus.])\n     fi\n     if test \"x$LUPDATE\" = x; then\n-      AC_MSG_WARN([lupdate is required to update qt translations])\n+      AC_MSG_WARN([lupdate tool is required to update Qt translations.])\n+    fi\n+    if test \"x$LCONVERT\" = x; then\n+      AC_MSG_WARN([lconvert tool is required to update Qt translations.])\n     fi\n   ],[\n     bitcoin_enable_qt=no"
      },
      {
        "sha": "5ce0f6cde400b9956881be9c1781a37aeb49043d",
        "filename": "build_msvc/README.md",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/build_msvc/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/build_msvc/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/README.md?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -27,7 +27,11 @@ Options for installing the dependencies in a Visual Studio compatible manner are\n - Download the source code, build each dependency, add the required include paths, link libraries and binary tools to the Visual Studio project files.\n - Use [nuget](https://www.nuget.org/) packages with the understanding that any binary files have been compiled by an untrusted third party.\n \n-The [external dependencies](https://github.com/bitcoin/bitcoin/blob/master/doc/dependencies.md) required for building are listed in the `build_msvc/vcpkg.json` file. The `msbuild` project files are configured to automatically install the `vcpkg` dependencies.\n+The [external dependencies](https://github.com/bitcoin/bitcoin/blob/master/doc/dependencies.md) required for building are listed in the `build_msvc/vcpkg.json` file. To ensure `msbuild` project files automatically install the `vcpkg` dependencies use:\n+\n+```\n+vcpkg integrate install\n+```\n \n Qt\n ---------------------"
      },
      {
        "sha": "c2c32af8380801513340bc9b154ad9e4862cb4f1",
        "filename": "build_msvc/bitcoind/bitcoind.vcxproj",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/build_msvc/bitcoind/bitcoind.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/build_msvc/bitcoind/bitcoind.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/bitcoind/bitcoind.vcxproj?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -10,6 +10,9 @@\n   </PropertyGroup>\n   <ItemGroup>\n     <ClCompile Include=\"..\\..\\src\\bitcoind.cpp\" />\n+    <ClCompile Include=\"..\\..\\src\\init\\bitcoind.cpp\">\n+      <ObjectFileName>$(IntDir)init_bitcoind.obj</ObjectFileName>\n+    </ClCompile>\n   </ItemGroup>\n   <ItemGroup>\n     <ProjectReference Include=\"..\\libbitcoinconsensus\\libbitcoinconsensus.vcxproj\">"
      },
      {
        "sha": "837c0884510f261440ba63453f21967ae7f73f94",
        "filename": "build_msvc/common.qt.init.vcxproj",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/build_msvc/common.qt.init.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/build_msvc/common.qt.init.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/common.qt.init.vcxproj?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -2,15 +2,15 @@\n <Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n \n   <PropertyGroup Label=\"QtGlobals\">\n-    <QtBaseDir>C:\\Qt5.9.8_x64_static_vs2019</QtBaseDir>\n+    <QtBaseDir>C:\\Qt5.12.10_x64_static_vs2019_1694</QtBaseDir>\n     <QtPluginsLibraryDir>$(QtBaseDir)\\plugins</QtPluginsLibraryDir>\n     <QtLibraryDir>$(QtBaseDir)\\lib</QtLibraryDir>\n     <QtIncludeDir>$(QtBaseDir)\\include</QtIncludeDir>\n     <QtIncludes>$(QtIncludeDir);$(QtIncludeDir)\\QtNetwork;$(QtIncludeDir)\\QtCore;$(QtIncludeDir)\\QtWidgets;$(QtIncludeDir)\\QtGui;</QtIncludes>\n     <GeneratedFilesOutDir>.\\QtGeneratedFiles\\qt</GeneratedFilesOutDir>\n     <QtToolsDir>$(QtBaseDir)\\bin</QtToolsDir>\n-    <QtReleaseLibraries>$(QtPluginsLibraryDir)\\platforms\\qminimal.lib;$(QtPluginsLibraryDir)\\platforms\\qwindows.lib;$(QtLibraryDir)\\qtfreetype.lib;$(QtLibraryDir)\\qtharfbuzz.lib;$(QtLibraryDir)\\qtlibpng.lib;$(QtLibraryDir)\\qtpcre2.lib;$(QtLibraryDir)\\Qt5AccessibilitySupport.lib;$(QtLibraryDir)\\Qt5Core.lib;$(QtLibraryDir)\\Qt5Concurrent.lib;$(QtLibraryDir)\\Qt5EventDispatcherSupport.lib;$(QtLibraryDir)\\Qt5FontDatabaseSupport.lib;$(QtLibraryDir)\\Qt5Gui.lib;$(QtLibraryDir)\\Qt5Network.lib;$(QtLibraryDir)\\Qt5PlatformCompositorSupport.lib;$(QtLibraryDir)\\Qt5ThemeSupport.lib;$(QtLibraryDir)\\Qt5Widgets.lib;$(QtLibraryDir)\\Qt5WinExtras.lib;$(QtLibraryDir)\\qtmain.lib;userenv.lib;netapi32.lib;imm32.lib;Dwmapi.lib;version.lib;winmm.lib;UxTheme.lib</QtReleaseLibraries>\n-    <QtDebugLibraries>$(QtPluginsLibraryDir)\\platforms\\qwindowsd.lib;$(QtPluginsLibraryDir)\\platforms\\qminimald.lib;$(QtLibraryDir)\\*d.lib;crypt32.lib;userenv.lib;netapi32.lib;imm32.lib;Dwmapi.lib;version.lib;winmm.lib;UxTheme.lib</QtDebugLibraries>\n+    <QtReleaseLibraries>$(QtPluginsLibraryDir)\\platforms\\qminimal.lib;$(QtPluginsLibraryDir)\\platforms\\qwindows.lib;$(QtLibraryDir)\\Qt5WindowsUIAutomationSupport.lib;$(QtLibraryDir)\\qtfreetype.lib;$(QtLibraryDir)\\qtharfbuzz.lib;$(QtLibraryDir)\\qtlibpng.lib;$(QtLibraryDir)\\qtpcre2.lib;$(QtLibraryDir)\\Qt5AccessibilitySupport.lib;$(QtLibraryDir)\\Qt5Core.lib;$(QtLibraryDir)\\Qt5Concurrent.lib;$(QtLibraryDir)\\Qt5EventDispatcherSupport.lib;$(QtLibraryDir)\\Qt5FontDatabaseSupport.lib;$(QtLibraryDir)\\Qt5Gui.lib;$(QtLibraryDir)\\Qt5Network.lib;$(QtLibraryDir)\\Qt5PlatformCompositorSupport.lib;$(QtLibraryDir)\\Qt5ThemeSupport.lib;$(QtLibraryDir)\\Qt5Widgets.lib;$(QtLibraryDir)\\Qt5WinExtras.lib;$(QtLibraryDir)\\qtmain.lib;Wtsapi32.lib;userenv.lib;netapi32.lib;imm32.lib;Dwmapi.lib;version.lib;winmm.lib;UxTheme.lib</QtReleaseLibraries>\n+    <QtDebugLibraries>$(QtPluginsLibraryDir)\\platforms\\qwindowsd.lib;$(QtPluginsLibraryDir)\\platforms\\qminimald.lib;$(QtLibraryDir)\\*d.lib;Wtsapi32.lib;crypt32.lib;userenv.lib;netapi32.lib;imm32.lib;Dwmapi.lib;version.lib;winmm.lib;UxTheme.lib</QtDebugLibraries>\n   </PropertyGroup>\n \n </Project>"
      },
      {
        "sha": "96bb5843758b3db65e5987f261e949cef447ba5e",
        "filename": "build_msvc/libbitcoin_qt/libbitcoin_qt.vcxproj",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/build_msvc/libbitcoin_qt/libbitcoin_qt.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/build_msvc/libbitcoin_qt/libbitcoin_qt.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/libbitcoin_qt/libbitcoin_qt.vcxproj?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -34,6 +34,7 @@\n     <ClCompile Include=\"..\\..\\src\\qt\\overviewpage.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\paymentserver.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\peertablemodel.cpp\" />\n+    <ClCompile Include=\"..\\..\\src\\qt\\peertablesortproxy.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\platformstyle.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\psbtoperationsdialog.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\qrimagewidget.cpp\" />\n@@ -87,6 +88,7 @@\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_overviewpage.cpp\" />\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_paymentserver.cpp\" />\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_peertablemodel.cpp\" />\n+    <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_peertablesortproxy.cpp\" />\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_platformstyle.cpp\" />\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_psbtoperationsdialog.cpp\" />\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_qrimagewidget.cpp\" />"
      },
      {
        "sha": "92af98aa9ba30e6b7eb69a4d7ca7cbea3be46682",
        "filename": "ci/test/00_setup_env_native_asan.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/ci/test/00_setup_env_native_asan.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/ci/test/00_setup_env_native_asan.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_native_asan.sh?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -8,7 +8,7 @@ export LC_ALL=C.UTF-8\n \n export CONTAINER_NAME=ci_native_asan\n export PACKAGES=\"clang llvm python3-zmq qtbase5-dev qttools5-dev-tools libevent-dev bsdmainutils libboost-dev libboost-system-dev libboost-filesystem-dev libboost-test-dev libdb5.3++-dev libminiupnpc-dev libnatpmp-dev libzmq3-dev libqrencode-dev libsqlite3-dev\"\n-export DOCKER_NAME_TAG=ubuntu:20.04\n+export DOCKER_NAME_TAG=ubuntu:hirsute\n export NO_DEPENDS=1\n export GOAL=\"install\"\n export BITCOIN_CONFIG=\"--enable-zmq --with-incompatible-bdb --with-gui=qt5 CPPFLAGS='-DARENA_DEBUG -DDEBUG_LOCKORDER' --with-sanitizers=address,integer,undefined CC=clang CXX=clang++ --enable-external-signer\""
      },
      {
        "sha": "d1707dfd64cf3947eaf50c6925d59ee4ce4ffd9e",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -1640,6 +1640,10 @@ if test \"x$use_ccache\" != \"xno\"; then\n     CXX=\"$ac_cv_path_CCACHE $CXX\"\n   fi\n   AC_MSG_RESULT($use_ccache)\n+  if test \"x$use_ccache\" = \"xyes\"; then\n+    AX_CHECK_COMPILE_FLAG([-fdebug-prefix-map=A=B],[DEBUG_CXXFLAGS=\"$DEBUG_CXXFLAGS -fdebug-prefix-map=\\$(abs_srcdir)=.\"],,[[$CXXFLAG_WERROR]])\n+    AX_CHECK_PREPROC_FLAG([-fmacro-prefix-map=A=B],[DEBUG_CPPFLAGS=\"$DEBUG_CPPFLAGS -fmacro-prefix-map=\\$(abs_srcdir)=.\"],,[[$CXXFLAG_WERROR]])\n+  fi\n fi\n \n dnl enable wallet"
      },
      {
        "sha": "9b5f5d7e07a6b97e1a191bc502bd38d05ce6d0ca",
        "filename": "contrib/gitian-descriptors/gitian-linux.yml",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/contrib/gitian-descriptors/gitian-linux.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/contrib/gitian-descriptors/gitian-linux.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-linux.yml?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -55,7 +55,6 @@ script: |\n   HOST_CXXFLAGS=\"-O2 -g\"\n   HOST_LDFLAGS_BASE=\"-static-libstdc++ -Wl,-O2\"\n \n-  export QT_RCC_TEST=1\n   export QT_RCC_SOURCE_DATE_OVERRIDE=1\n   export TZ=\"UTC\"\n   export BUILD_DIR=\"$PWD\""
      },
      {
        "sha": "c1bd545501c69701686f9e593aa3c1afeae44e9e",
        "filename": "contrib/gitian-descriptors/gitian-osx.yml",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/contrib/gitian-descriptors/gitian-osx.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/contrib/gitian-descriptors/gitian-osx.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-osx.yml?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -41,7 +41,6 @@ script: |\n   FAKETIME_HOST_PROGS=\"\"\n   FAKETIME_PROGS=\"ar ranlib date dmg xorrisofs\"\n \n-  export QT_RCC_TEST=1\n   export QT_RCC_SOURCE_DATE_OVERRIDE=1\n   export TZ=\"UTC\"\n   export BUILD_DIR=\"$PWD\""
      },
      {
        "sha": "dbf1e8cc67b68884908d3f251807797b8b30f4f4",
        "filename": "contrib/gitian-descriptors/gitian-win.yml",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/contrib/gitian-descriptors/gitian-win.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/contrib/gitian-descriptors/gitian-win.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-win.yml?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -37,7 +37,6 @@ script: |\n   HOST_CFLAGS=\"-O2 -g -fno-ident\"\n   HOST_CXXFLAGS=\"-O2 -g -fno-ident\"\n \n-  export QT_RCC_TEST=1\n   export QT_RCC_SOURCE_DATE_OVERRIDE=1\n   export TZ=\"UTC\"\n   export BUILD_DIR=\"$PWD\""
      },
      {
        "sha": "6ea32329ba2861a864fab2578642ba7cda5b7110",
        "filename": "contrib/guix/libexec/build.sh",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/contrib/guix/libexec/build.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/contrib/guix/libexec/build.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/libexec/build.sh?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -175,7 +175,6 @@ case \"$HOST\" in\n esac\n \n # Environment variables for determinism\n-export QT_RCC_TEST=1\n export QT_RCC_SOURCE_DATE_OVERRIDE=1\n export TAR_OPTIONS=\"--owner=0 --group=0 --numeric-owner --mtime='@${SOURCE_DATE_EPOCH}' --sort=name\"\n export TZ=\"UTC\""
      },
      {
        "sha": "50e1a32c706338d6990f7de722a2d060d0d08158",
        "filename": "depends/README.md",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/depends/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/depends/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/README.md?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -49,6 +49,11 @@ The paths are automatically configured and no other options are needed unless ta\n \n     sudo apt-get install curl librsvg2-bin libtiff-tools bsdmainutils cmake imagemagick libz-dev python3-setuptools libtinfo5 xorriso\n \n+Note: You must obtain the macOS SDK before proceeding with a cross-compile.\n+Under the depends directory, create a subdirectory named `SDKs`.\n+Then, place the extracted SDK under this new directory.\n+For more information, see [SDK Extraction](../contrib/macdeploy/README.md#sdk-extraction).\n+\n #### For Win64 cross compilation\n \n - see [build-windows.md](../doc/build-windows.md#cross-compilation-for-ubuntu-and-windows-subsystem-for-linux)"
      },
      {
        "sha": "14653ce9fb0b70a110ee8d80c743a6833f60c21b",
        "filename": "depends/packages/native_libmultiprocess.mk",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/depends/packages/native_libmultiprocess.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/depends/packages/native_libmultiprocess.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/native_libmultiprocess.mk?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -1,8 +1,8 @@\n package=native_libmultiprocess\n-$(package)_version=5741d750a04e644a03336090d8979c6d033e32c0\n+$(package)_version=d576d975debdc9090bd2582f83f49c76c0061698\n $(package)_download_path=https://github.com/chaincodelabs/libmultiprocess/archive\n $(package)_file_name=$($(package)_version).tar.gz\n-$(package)_sha256_hash=ac848db49a6ed53e423c62d54bd87f1f08cbb0326254a8667e10bbfe5bf032a4\n+$(package)_sha256_hash=9f8b055c8bba755dc32fe799b67c20b91e7b13e67cadafbc54c0f1def057a370\n $(package)_dependencies=native_capnp\n \n define $(package)_config_cmds"
      },
      {
        "sha": "783f87ca7c0438f1c84b7354b352d74bbc8b1a37",
        "filename": "depends/packages/native_mac_alias.mk",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/depends/packages/native_mac_alias.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/depends/packages/native_mac_alias.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/native_mac_alias.mk?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -1,8 +1,8 @@\n package=native_mac_alias\n-$(package)_version=2.1.1\n+$(package)_version=2.2.0\n $(package)_download_path=https://github.com/al45tair/mac_alias/archive/\n $(package)_file_name=v$($(package)_version).tar.gz\n-$(package)_sha256_hash=c0ffceee14f7d04a6eb323fb7b8217dc3f373b346198d2ca42300a8362db7efa\n+$(package)_sha256_hash=421e6d7586d1f155c7db3e7da01ca0dacc9649a509a253ad7077b70174426499\n $(package)_install_libdir=$(build_prefix)/lib/python3/dist-packages\n \n define $(package)_build_cmds"
      },
      {
        "sha": "0133eee920e7ae2f49071a88daf8d4c409e530b4",
        "filename": "depends/packages/qt.mk",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/depends/packages/qt.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/depends/packages/qt.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/qt.mk?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -173,7 +173,6 @@ $(package)_config_opts_armv7a_android += -android-arch armeabi-v7a\n $(package)_config_opts_x86_64_android += -android-arch x86_64\n $(package)_config_opts_i686_android += -android-arch i686\n \n-$(package)_build_env  = QT_RCC_TEST=1\n $(package)_build_env += QT_RCC_SOURCE_DATE_OVERRIDE=1\n endef\n \n@@ -261,20 +260,23 @@ define $(package)_config_cmds\n   qtbase/bin/qmake -o qttranslations/Makefile qttranslations/qttranslations.pro && \\\n   qtbase/bin/qmake -o qttranslations/translations/Makefile qttranslations/translations/translations.pro && \\\n   qtbase/bin/qmake -o qttools/src/linguist/lrelease/Makefile qttools/src/linguist/lrelease/lrelease.pro && \\\n-  qtbase/bin/qmake -o qttools/src/linguist/lupdate/Makefile qttools/src/linguist/lupdate/lupdate.pro\n+  qtbase/bin/qmake -o qttools/src/linguist/lupdate/Makefile qttools/src/linguist/lupdate/lupdate.pro && \\\n+  qtbase/bin/qmake -o qttools/src/linguist/lconvert/Makefile qttools/src/linguist/lconvert/lconvert.pro\n endef\n \n define $(package)_build_cmds\n   $(MAKE) -C qtbase/src $(addprefix sub-,$($(package)_qt_libs)) && \\\n   $(MAKE) -C qttools/src/linguist/lrelease && \\\n   $(MAKE) -C qttools/src/linguist/lupdate && \\\n+  $(MAKE) -C qttools/src/linguist/lconvert && \\\n   $(MAKE) -C qttranslations\n endef\n \n define $(package)_stage_cmds\n   $(MAKE) -C qtbase/src INSTALL_ROOT=$($(package)_staging_dir) $(addsuffix -install_subtargets,$(addprefix sub-,$($(package)_qt_libs))) && \\\n   $(MAKE) -C qttools/src/linguist/lrelease INSTALL_ROOT=$($(package)_staging_dir) install_target && \\\n   $(MAKE) -C qttools/src/linguist/lupdate INSTALL_ROOT=$($(package)_staging_dir) install_target && \\\n+  $(MAKE) -C qttools/src/linguist/lconvert INSTALL_ROOT=$($(package)_staging_dir) install_target && \\\n   $(MAKE) -C qttranslations INSTALL_ROOT=$($(package)_staging_dir) install_subtargets\n endef\n "
      },
      {
        "sha": "e3f389a6d3f89481b33e0dd9f1f398f699f96339",
        "filename": "doc/multiprocess.md",
        "status": "modified",
        "additions": 38,
        "deletions": 1,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/doc/multiprocess.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/doc/multiprocess.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/multiprocess.md?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -15,7 +15,7 @@ Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102\n \n ## Debugging\n \n-After [#10102](https://github.com/bitcoin/bitcoin/pull/10102), the `-debug=ipc` command line option can be used to see requests and responses between processes.\n+The `-debug=ipc` command line option can be used to see requests and responses between processes.\n \n ## Installation\n \n@@ -33,3 +33,40 @@ BITCOIND=bitcoin-node test/functional/test_runner.py\n The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n \n Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess#installation) section of the libmultiprocess readme for install steps. See [build-unix.md](build-unix.md) and [build-osx.md](build-osx.md) for information about installing dependencies in general.\n+\n+## IPC implementation details\n+\n+Cross process Node, Wallet, and Chain interfaces are defined in\n+[`src/interfaces/`](../src/interfaces/). These are C++ classes which follow\n+[conventions](developer-notes.md#internal-interface-guidelines), like passing\n+serializable arguments so they can be called from different processes, and\n+making methods pure virtual so they can have proxy implementations that forward\n+calls between processes.\n+\n+When Wallet, Node, and Chain code is running in the same process, calling any\n+interface method invokes the implementation directly. When code is running in\n+different processes, calling an interface method invokes a proxy interface\n+implementation that communicates with a remote process and invokes the real\n+implementation in the remote process. The\n+[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n+generation tool internally generates proxy client classes and proxy server\n+classes for this purpose that are thin wrappers around Cap'n Proto\n+[client](https://capnproto.org/cxxrpc.html#clients) and\n+[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n+actual serialization and socket communication.\n+\n+As much as possible, calls between processes are meant to work the same as\n+calls within a single process without adding limitations or requiring extra\n+implementation effort. Processes communicate with each other by calling regular\n+[C++ interface methods](../src/interfaces/README.md). Method arguments and\n+return values are automatically serialized and sent between processes. Object\n+references and `std::function` arguments are automatically tracked and mapped\n+to allow invoked code to call back into invoking code at any time, and there is\n+a 1:1 threading model where any thread invoking a method in another process has\n+a corresponding thread in the invoked process responsible for executing all\n+method calls from the source thread, without blocking I/O or holding up another\n+call, and using the same thread local variables, locks, and callbacks between\n+calls. The forwarding, tracking, and threading is implemented inside the\n+[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n+which has the design goal of making calls between processes look like calls in\n+the same process to the extent possible."
      },
      {
        "sha": "874b919f08d9ea959fee6d974e1765a9c6f34a1a",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -136,6 +136,12 @@ Changes to Wallet or GUI related settings can be found in the GUI or Wallet sect\n Tools and Utilities\n -------------------\n \n+- A new CLI `-addrinfo` command returns the number of addresses known to the\n+  node per network type (including Tor v2 versus v3) and total. This can be\n+  useful to see if the node knows enough addresses in a network to use options\n+  like `-onlynet=<network>` or to upgrade to current and future Tor releases\n+  that support Tor v3 addresses only.  (#21595)\n+\n Wallet\n ------\n "
      },
      {
        "sha": "447015fc6694be8d461080606bc2ed90529ef8b2",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 47,
        "deletions": 3,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -74,6 +74,7 @@ EXTRA_LIBRARIES += \\\n   $(LIBBITCOIN_CONSENSUS) \\\n   $(LIBBITCOIN_SERVER) \\\n   $(LIBBITCOIN_CLI) \\\n+  $(LIBBITCOIN_IPC) \\\n   $(LIBBITCOIN_WALLET) \\\n   $(LIBBITCOIN_WALLET_TOOL) \\\n   $(LIBBITCOIN_ZMQ)\n@@ -156,8 +157,12 @@ BITCOIN_CORE_H = \\\n   index/txindex.h \\\n   indirectmap.h \\\n   init.h \\\n+  init/common.h \\\n   interfaces/chain.h \\\n+  interfaces/echo.h \\\n   interfaces/handler.h \\\n+  interfaces/init.h \\\n+  interfaces/ipc.h \\\n   interfaces/node.h \\\n   interfaces/wallet.h \\\n   key.h \\\n@@ -199,6 +204,7 @@ BITCOIN_CORE_H = \\\n   rpc/blockchain.h \\\n   rpc/client.h \\\n   rpc/mining.h \\\n+  rpc/net.h \\\n   rpc/protocol.h \\\n   rpc/rawtransaction_util.h \\\n   rpc/register.h \\\n@@ -297,6 +303,8 @@ obj/build.h: FORCE\n \t  \"$(abs_top_srcdir)\"\n libbitcoin_util_a-clientversion.$(OBJEXT): obj/build.h\n \n+ipc/capnp/libbitcoin_ipc_a-ipc.$(OBJEXT): $(libbitcoin_ipc_mpgen_input:=.h)\n+\n # server: shared between bitcoind and bitcoin-qt\n # Contains code accessing mempool and chain state that is meant to be separated\n # from wallet and gui code (see node/README.md). Shared code should go in\n@@ -520,6 +528,7 @@ libbitcoin_common_a_SOURCES = \\\n   core_read.cpp \\\n   core_write.cpp \\\n   external_signer.cpp \\\n+  init/common.cpp \\\n   key.cpp \\\n   key_io.cpp \\\n   merkleblock.cpp \\\n@@ -555,7 +564,9 @@ libbitcoin_util_a_SOURCES = \\\n   compat/glibcxx_sanity.cpp \\\n   compat/strnlen.cpp \\\n   fs.cpp \\\n+  interfaces/echo.cpp \\\n   interfaces/handler.cpp \\\n+  interfaces/init.cpp \\\n   logging.cpp \\\n   random.cpp \\\n   randomenv.cpp \\\n@@ -631,17 +642,17 @@ bitcoin_bin_ldadd = \\\n \n bitcoin_bin_ldadd += $(BOOST_LIBS) $(BDB_LIBS) $(MINIUPNPC_LIBS) $(NATPMP_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(ZMQ_LIBS) $(SQLITE_LIBS)\n \n-bitcoind_SOURCES = $(bitcoin_daemon_sources)\n+bitcoind_SOURCES = $(bitcoin_daemon_sources) init/bitcoind.cpp\n bitcoind_CPPFLAGS = $(bitcoin_bin_cppflags)\n bitcoind_CXXFLAGS = $(bitcoin_bin_cxxflags)\n bitcoind_LDFLAGS = $(bitcoin_bin_ldflags)\n bitcoind_LDADD = $(LIBBITCOIN_SERVER) $(bitcoin_bin_ldadd)\n \n-bitcoin_node_SOURCES = $(bitcoin_daemon_sources)\n+bitcoin_node_SOURCES = $(bitcoin_daemon_sources) init/bitcoin-node.cpp\n bitcoin_node_CPPFLAGS = $(bitcoin_bin_cppflags)\n bitcoin_node_CXXFLAGS = $(bitcoin_bin_cxxflags)\n bitcoin_node_LDFLAGS = $(bitcoin_bin_ldflags)\n-bitcoin_node_LDADD = $(LIBBITCOIN_SERVER) $(bitcoin_bin_ldadd)\n+bitcoin_node_LDADD = $(LIBBITCOIN_SERVER) $(bitcoin_bin_ldadd) $(LIBBITCOIN_IPC) $(LIBMULTIPROCESS_LIBS)\n \n # bitcoin-cli binary #\n bitcoin_cli_SOURCES = bitcoin-cli.cpp\n@@ -805,6 +816,39 @@ if HARDEN\n \t$(AM_V_at) OBJDUMP=$(OBJDUMP) OTOOL=$(OTOOL) $(PYTHON) $(top_srcdir)/contrib/devtools/security-check.py $(bin_PROGRAMS)\n endif\n \n+libbitcoin_ipc_mpgen_input = \\\n+  ipc/capnp/echo.capnp \\\n+  ipc/capnp/init.capnp\n+EXTRA_DIST += $(libbitcoin_ipc_mpgen_input)\n+%.capnp:\n+\n+if BUILD_MULTIPROCESS\n+LIBBITCOIN_IPC=libbitcoin_ipc.a\n+libbitcoin_ipc_a_SOURCES = \\\n+  ipc/capnp/init-types.h \\\n+  ipc/capnp/protocol.cpp \\\n+  ipc/capnp/protocol.h \\\n+  ipc/exception.h \\\n+  ipc/interfaces.cpp \\\n+  ipc/process.cpp \\\n+  ipc/process.h \\\n+  ipc/protocol.h\n+libbitcoin_ipc_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+libbitcoin_ipc_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS) $(LIBMULTIPROCESS_CFLAGS)\n+\n+include $(MPGEN_PREFIX)/include/mpgen.mk\n+libbitcoin_ipc_mpgen_output = \\\n+  $(libbitcoin_ipc_mpgen_input:=.c++) \\\n+  $(libbitcoin_ipc_mpgen_input:=.h) \\\n+  $(libbitcoin_ipc_mpgen_input:=.proxy-client.c++) \\\n+  $(libbitcoin_ipc_mpgen_input:=.proxy-server.c++) \\\n+  $(libbitcoin_ipc_mpgen_input:=.proxy-types.c++) \\\n+  $(libbitcoin_ipc_mpgen_input:=.proxy-types.h) \\\n+  $(libbitcoin_ipc_mpgen_input:=.proxy.h)\n+nodist_libbitcoin_ipc_a_SOURCES = $(libbitcoin_ipc_mpgen_output)\n+CLEANFILES += $(libbitcoin_ipc_mpgen_output)\n+endif\n+\n if EMBEDDED_LEVELDB\n include Makefile.crc32c.include\n include Makefile.leveldb.include"
      },
      {
        "sha": "caa8500ffa8898182c9f0e6268acce955415fad7",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -61,6 +61,7 @@ QT_MOC_CPP = \\\n   qt/moc_optionsmodel.cpp \\\n   qt/moc_overviewpage.cpp \\\n   qt/moc_peertablemodel.cpp \\\n+  qt/moc_peertablesortproxy.cpp \\\n   qt/moc_paymentserver.cpp \\\n   qt/moc_psbtoperationsdialog.cpp \\\n   qt/moc_qrimagewidget.cpp \\\n@@ -134,6 +135,7 @@ BITCOIN_QT_H = \\\n   qt/overviewpage.h \\\n   qt/paymentserver.h \\\n   qt/peertablemodel.h \\\n+  qt/peertablesortproxy.h \\\n   qt/platformstyle.h \\\n   qt/psbtoperationsdialog.h \\\n   qt/qrimagewidget.h \\\n@@ -232,6 +234,7 @@ BITCOIN_QT_BASE_CPP = \\\n   qt/optionsdialog.cpp \\\n   qt/optionsmodel.cpp \\\n   qt/peertablemodel.cpp \\\n+  qt/peertablesortproxy.cpp \\\n   qt/platformstyle.cpp \\\n   qt/qvalidatedlineedit.cpp \\\n   qt/qvaluecombobox.cpp \\\n@@ -356,6 +359,8 @@ $(srcdir)/qt/bitcoinstrings.cpp: FORCE\n translate: $(srcdir)/qt/bitcoinstrings.cpp $(QT_FORMS_UI) $(QT_FORMS_UI) $(BITCOIN_QT_BASE_CPP) qt/bitcoin.cpp $(BITCOIN_QT_WINDOWS_CPP) $(BITCOIN_QT_WALLET_CPP) $(BITCOIN_QT_H) $(BITCOIN_MM)\n \t@test -n $(LUPDATE) || echo \"lupdate is required for updating translations\"\n \t$(AM_V_GEN) QT_SELECT=$(QT_SELECT) $(LUPDATE) $^ -locations relative -no-obsolete -ts $(srcdir)/qt/locale/bitcoin_en.ts\n+\t@test -n $(LCONVERT) || echo \"lconvert is required for updating translations\"\n+\t$(AM_V_GEN) QT_SELECT=$(QT_SELECT) $(LCONVERT) -o $(srcdir)/qt/locale/bitcoin_en.xlf -i $(srcdir)/qt/locale/bitcoin_en.ts\n \n $(QT_QRC_LOCALE_CPP): $(QT_QRC_LOCALE) $(QT_QM)\n \t@test -f $(RCC)"
      },
      {
        "sha": "efddc5e8c42173b67952ec58c622fb60e3faa64d",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -274,6 +274,7 @@ test_fuzz_fuzz_SOURCES = \\\n  test/fuzz/random.cpp \\\n  test/fuzz/rbf.cpp \\\n  test/fuzz/rolling_bloom_filter.cpp \\\n+ test/fuzz/rpc.cpp \\\n  test/fuzz/script.cpp \\\n  test/fuzz/script_assets_test_minimizer.cpp \\\n  test/fuzz/script_bitcoin_consensus.cpp \\"
      },
      {
        "sha": "4a4710ea3afcfdb2299b4af93a0a1d46a54fe103",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 67,
        "deletions": 11,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -42,6 +42,7 @@ static const char DEFAULT_RPCCONNECT[] = \"127.0.0.1\";\n static const int DEFAULT_HTTP_CLIENT_TIMEOUT=900;\n static const bool DEFAULT_NAMED=false;\n static const int CONTINUE_EXECUTION=-1;\n+static constexpr int8_t UNKNOWN_NETWORK{-1};\n \n /** Default number of blocks to generate for RPC generatetoaddress. */\n static const std::string DEFAULT_NBLOCKS = \"1\";\n@@ -59,6 +60,7 @@ static void SetupCliArgs(ArgsManager& argsman)\n     argsman.AddArg(\"-conf=<file>\", strprintf(\"Specify configuration file. Relative paths will be prefixed by datadir location. (default: %s)\", BITCOIN_CONF_FILENAME), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     argsman.AddArg(\"-datadir=<dir>\", \"Specify data directory\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     argsman.AddArg(\"-generate\", strprintf(\"Generate blocks immediately, equivalent to RPC getnewaddress followed by RPC generatetoaddress. Optional positional integer arguments are number of blocks to generate (default: %s) and maximum iterations to try (default: %s), equivalent to RPC generatetoaddress nblocks and maxtries arguments. Example: bitcoin-cli -generate 4 1000\", DEFAULT_NBLOCKS, DEFAULT_MAX_TRIES), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+    argsman.AddArg(\"-addrinfo\", \"Get the number of addresses known to the node, per network and total.\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     argsman.AddArg(\"-getinfo\", \"Get general information from the remote server. Note that unlike server-side RPC calls, the results of -getinfo is the result of multiple non-atomic requests. Some entries in the result may represent results from different states (e.g. wallet balance may be as of a different block from the chain state reported)\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     argsman.AddArg(\"-netinfo\", \"Get network peer connection information from the remote server. An optional integer argument from 0 to 4 can be passed for different peers listings (default: 0). Pass \\\"help\\\" for detailed help documentation.\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n \n@@ -228,6 +230,60 @@ class BaseRequestHandler\n     virtual UniValue ProcessReply(const UniValue &batch_in) = 0;\n };\n \n+/** Process addrinfo requests */\n+class AddrinfoRequestHandler : public BaseRequestHandler\n+{\n+private:\n+    static constexpr std::array m_networks{\"ipv4\", \"ipv6\", \"torv2\", \"torv3\", \"i2p\"};\n+    int8_t NetworkStringToId(const std::string& str) const\n+    {\n+        for (size_t i = 0; i < m_networks.size(); ++i) {\n+            if (str == m_networks.at(i)) return i;\n+        }\n+        return UNKNOWN_NETWORK;\n+    }\n+\n+public:\n+    UniValue PrepareRequest(const std::string& method, const std::vector<std::string>& args) override\n+    {\n+        if (!args.empty()) {\n+            throw std::runtime_error(\"-addrinfo takes no arguments\");\n+        }\n+        UniValue params{RPCConvertValues(\"getnodeaddresses\", std::vector<std::string>{{\"0\"}})};\n+        return JSONRPCRequestObj(\"getnodeaddresses\", params, 1);\n+    }\n+\n+    UniValue ProcessReply(const UniValue& reply) override\n+    {\n+        if (!reply[\"error\"].isNull()) return reply;\n+        const std::vector<UniValue>& nodes{reply[\"result\"].getValues()};\n+        if (!nodes.empty() && nodes.at(0)[\"network\"].isNull()) {\n+            throw std::runtime_error(\"-addrinfo requires bitcoind server to be running v22.0 and up\");\n+        }\n+        // Count the number of peers we know by network, including torv2 versus torv3.\n+        std::array<uint64_t, m_networks.size()> counts{{}};\n+        for (const UniValue& node : nodes) {\n+            std::string network_name{node[\"network\"].get_str()};\n+            if (network_name == \"onion\") {\n+                network_name = node[\"address\"].get_str().size() > 22 ? \"torv3\" : \"torv2\";\n+            }\n+            const int8_t network_id{NetworkStringToId(network_name)};\n+            if (network_id == UNKNOWN_NETWORK) continue;\n+            ++counts.at(network_id);\n+        }\n+        // Prepare result to return to user.\n+        UniValue result{UniValue::VOBJ}, addresses{UniValue::VOBJ};\n+        uint64_t total{0}; // Total address count\n+        for (size_t i = 0; i < m_networks.size(); ++i) {\n+            addresses.pushKV(m_networks.at(i), counts.at(i));\n+            total += counts.at(i);\n+        }\n+        addresses.pushKV(\"total\", total);\n+        result.pushKV(\"addresses_known\", addresses);\n+        return JSONRPCReplyObj(result, NullUniValue, 1);\n+    }\n+};\n+\n /** Process getinfo requests */\n class GetinfoRequestHandler: public BaseRequestHandler\n {\n@@ -299,16 +355,14 @@ class GetinfoRequestHandler: public BaseRequestHandler\n class NetinfoRequestHandler : public BaseRequestHandler\n {\n private:\n-    static constexpr int8_t UNKNOWN_NETWORK{-1};\n-    static constexpr uint8_t m_networks_size{4};\n     static constexpr uint8_t MAX_DETAIL_LEVEL{4};\n-    const std::array<std::string, m_networks_size> m_networks{{\"ipv4\", \"ipv6\", \"onion\", \"i2p\"}};\n-    std::array<std::array<uint16_t, m_networks_size + 1>, 3> m_counts{{{}}}; //!< Peer counts by (in/out/total, networks/total)\n+    static constexpr std::array m_networks{\"ipv4\", \"ipv6\", \"onion\", \"i2p\"};\n+    std::array<std::array<uint16_t, m_networks.size() + 1>, 3> m_counts{{{}}}; //!< Peer counts by (in/out/total, networks/total)\n     uint8_t m_block_relay_peers_count{0};\n     uint8_t m_manual_peers_count{0};\n     int8_t NetworkStringToId(const std::string& str) const\n     {\n-        for (uint8_t i = 0; i < m_networks_size; ++i) {\n+        for (size_t i = 0; i < m_networks.size(); ++i) {\n             if (str == m_networks.at(i)) return i;\n         }\n         return UNKNOWN_NETWORK;\n@@ -405,10 +459,10 @@ class NetinfoRequestHandler : public BaseRequestHandler\n             const bool is_outbound{!peer[\"inbound\"].get_bool()};\n             const bool is_block_relay{!peer[\"relaytxes\"].get_bool()};\n             const std::string conn_type{peer[\"connection_type\"].get_str()};\n-            ++m_counts.at(is_outbound).at(network_id);      // in/out by network\n-            ++m_counts.at(is_outbound).at(m_networks_size); // in/out overall\n-            ++m_counts.at(2).at(network_id);                // total by network\n-            ++m_counts.at(2).at(m_networks_size);           // total overall\n+            ++m_counts.at(is_outbound).at(network_id);        // in/out by network\n+            ++m_counts.at(is_outbound).at(m_networks.size()); // in/out overall\n+            ++m_counts.at(2).at(network_id);                  // total by network\n+            ++m_counts.at(2).at(m_networks.size());           // total overall\n             if (conn_type == \"block-relay-only\") ++m_block_relay_peers_count;\n             if (conn_type == \"manual\") ++m_manual_peers_count;\n             if (DetailsRequested()) {\n@@ -478,11 +532,11 @@ class NetinfoRequestHandler : public BaseRequestHandler\n         if (any_i2p_peers) result += \"     i2p\";\n         result += \"   total   block\";\n         if (m_manual_peers_count) result += \"  manual\";\n-        const std::array<std::string, 3> rows{{\"in\", \"out\", \"total\"}};\n+        const std::array rows{\"in\", \"out\", \"total\"};\n         for (uint8_t i = 0; i < 3; ++i) {\n             result += strprintf(\"\\n%-5s  %5i   %5i   %5i\", rows.at(i), m_counts.at(i).at(0), m_counts.at(i).at(1), m_counts.at(i).at(2)); // ipv4/ipv6/onion peers counts\n             if (any_i2p_peers) result += strprintf(\"   %5i\", m_counts.at(i).at(3)); // i2p peers count\n-            result += strprintf(\"   %5i\", m_counts.at(i).at(m_networks_size)); // total peers count\n+            result += strprintf(\"   %5i\", m_counts.at(i).at(m_networks.size())); // total peers count\n             if (i == 1) { // the outbound row has two extra columns for block relay and manual peer counts\n                 result += strprintf(\"   %5i\", m_block_relay_peers_count);\n                 if (m_manual_peers_count) result += strprintf(\"   %5i\", m_manual_peers_count);\n@@ -914,6 +968,8 @@ static int CommandLineRPC(int argc, char *argv[])\n             } else {\n                 ParseError(error, strPrint, nRet);\n             }\n+        } else if (gArgs.GetBoolArg(\"-addrinfo\", false)) {\n+            rh.reset(new AddrinfoRequestHandler());\n         } else {\n             rh.reset(new DefaultRequestHandler());\n             if (args.size() < 1) {"
      },
      {
        "sha": "cf9e4fad44d9c17c862c802ade9d0326a1263910",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 4,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -12,6 +12,7 @@\n #include <compat.h>\n #include <init.h>\n #include <interfaces/chain.h>\n+#include <interfaces/init.h>\n #include <node/context.h>\n #include <node/ui_interface.h>\n #include <noui.h>\n@@ -104,10 +105,8 @@ int fork_daemon(bool nochdir, bool noclose, TokenPipeEnd& endpoint)\n \n #endif\n \n-static bool AppInit(int argc, char* argv[])\n+static bool AppInit(NodeContext& node, int argc, char* argv[])\n {\n-    NodeContext node;\n-\n     bool fRet = false;\n \n     util::ThreadSetInternalName(\"init\");\n@@ -254,10 +253,18 @@ int main(int argc, char* argv[])\n     util::WinCmdLineArgs winArgs;\n     std::tie(argc, argv) = winArgs.get();\n #endif\n+\n+    NodeContext node;\n+    int exit_status;\n+    std::unique_ptr<interfaces::Init> init = interfaces::MakeNodeInit(node, argc, argv, exit_status);\n+    if (!init) {\n+        return exit_status;\n+    }\n+\n     SetupEnvironment();\n \n     // Connect bitcoind signal handlers\n     noui_connect();\n \n-    return (AppInit(argc, argv) ? EXIT_SUCCESS : EXIT_FAILURE);\n+    return (AppInit(node, argc, argv) ? EXIT_SUCCESS : EXIT_FAILURE);\n }"
      },
      {
        "sha": "ef3135e7a5d0b7a2802cea8ce88e837eb94d306b",
        "filename": "src/compressor.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/compressor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/compressor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compressor.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -52,7 +52,7 @@ static bool IsToPubKey(const CScript& script, CPubKey &pubkey)\n     return false;\n }\n \n-bool CompressScript(const CScript& script, std::vector<unsigned char> &out)\n+bool CompressScript(const CScript& script, CompressedScript& out)\n {\n     CKeyID keyID;\n     if (IsToKeyID(script, keyID)) {\n@@ -92,7 +92,7 @@ unsigned int GetSpecialScriptSize(unsigned int nSize)\n     return 0;\n }\n \n-bool DecompressScript(CScript& script, unsigned int nSize, const std::vector<unsigned char> &in)\n+bool DecompressScript(CScript& script, unsigned int nSize, const CompressedScript& in)\n {\n     switch(nSize) {\n     case 0x00:"
      },
      {
        "sha": "40b2496f06e81c0eb345c830d4372bad87441146",
        "filename": "src/compressor.h",
        "status": "modified",
        "additions": 16,
        "deletions": 4,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/compressor.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/compressor.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compressor.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -6,14 +6,26 @@\n #ifndef BITCOIN_COMPRESSOR_H\n #define BITCOIN_COMPRESSOR_H\n \n+#include <prevector.h>\n #include <primitives/transaction.h>\n #include <script/script.h>\n #include <serialize.h>\n #include <span.h>\n \n-bool CompressScript(const CScript& script, std::vector<unsigned char> &out);\n+/**\n+ * This saves us from making many heap allocations when serializing\n+ * and deserializing compressed scripts.\n+ *\n+ * This prevector size is determined by the largest .resize() in the\n+ * CompressScript function. The largest compressed script format is a\n+ * compressed public key, which is 33 bytes.\n+ */\n+using CompressedScript = prevector<33, unsigned char>;\n+\n+\n+bool CompressScript(const CScript& script, CompressedScript& out);\n unsigned int GetSpecialScriptSize(unsigned int nSize);\n-bool DecompressScript(CScript& script, unsigned int nSize, const std::vector<unsigned char> &out);\n+bool DecompressScript(CScript& script, unsigned int nSize, const CompressedScript& in);\n \n /**\n  * Compress amount.\n@@ -51,7 +63,7 @@ struct ScriptCompression\n \n     template<typename Stream>\n     void Ser(Stream &s, const CScript& script) {\n-        std::vector<unsigned char> compr;\n+        CompressedScript compr;\n         if (CompressScript(script, compr)) {\n             s << MakeSpan(compr);\n             return;\n@@ -66,7 +78,7 @@ struct ScriptCompression\n         unsigned int nSize = 0;\n         s >> VARINT(nSize);\n         if (nSize < nSpecialScripts) {\n-            std::vector<unsigned char> vch(GetSpecialScriptSize(nSize), 0x00);\n+            CompressedScript vch(GetSpecialScriptSize(nSize), 0x00);\n             s >> MakeSpan(vch);\n             DecompressScript(script, nSize, vch);\n             return;"
      },
      {
        "sha": "3f9838f2e0fa86c4b24745f3ce3f7067900198d7",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 166,
        "changes": 195,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -22,9 +22,9 @@\n #include <httpserver.h>\n #include <index/blockfilterindex.h>\n #include <index/txindex.h>\n+#include <init/common.h>\n #include <interfaces/chain.h>\n #include <interfaces/node.h>\n-#include <key.h>\n #include <mapport.h>\n #include <miner.h>\n #include <net.h>\n@@ -151,8 +151,6 @@ static fs::path GetPidFile(const ArgsManager& args)\n // shutdown thing.\n //\n \n-static std::unique_ptr<ECCVerifyHandle> globalVerifyHandle;\n-\n void Interrupt(NodeContext& node)\n {\n     InterruptHTTPServer();\n@@ -196,20 +194,7 @@ void Shutdown(NodeContext& node)\n     // Because these depend on each-other, we make sure that neither can be\n     // using the other before destroying them.\n     if (node.peerman) UnregisterValidationInterface(node.peerman.get());\n-    // Follow the lock order requirements:\n-    // * CheckForStaleTipAndEvictPeers locks cs_main before indirectly calling GetExtraFullOutboundCount\n-    //   which locks cs_vNodes.\n-    // * ProcessMessage locks cs_main and g_cs_orphans before indirectly calling ForEachNode which\n-    //   locks cs_vNodes.\n-    // * CConnman::Stop calls DeleteNode, which calls FinalizeNode, which locks cs_main and calls\n-    //   EraseOrphansFor, which locks g_cs_orphans.\n-    //\n-    // Thus the implicit locking order requirement is: (1) cs_main, (2) g_cs_orphans, (3) cs_vNodes.\n-    if (node.connman) {\n-        node.connman->StopThreads();\n-        LOCK2(::cs_main, ::g_cs_orphans);\n-        node.connman->StopNodes();\n-    }\n+    if (node.connman) node.connman->Stop();\n \n     StopTorControl();\n \n@@ -286,8 +271,7 @@ void Shutdown(NodeContext& node)\n     node.chain_clients.clear();\n     UnregisterAllValidationInterfaces();\n     GetMainSignals().UnregisterBackgroundSignalScheduler();\n-    globalVerifyHandle.reset();\n-    ECC_Stop();\n+    init::UnsetGlobals();\n     node.mempool.reset();\n     node.fee_estimator.reset();\n     node.chainman = nullptr;\n@@ -363,6 +347,8 @@ void SetupServerArgs(NodeContext& node)\n     SetupHelpOptions(argsman);\n     argsman.AddArg(\"-help-debug\", \"Print help message with debugging options and exit\", ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST); // server-only for now\n \n+    init::AddLoggingArgs(argsman);\n+\n     const auto defaultBaseParams = CreateBaseChainParams(CBaseChainParams::MAIN);\n     const auto testnetBaseParams = CreateBaseChainParams(CBaseChainParams::TESTNET);\n     const auto signetBaseParams = CreateBaseChainParams(CBaseChainParams::SIGNET);\n@@ -394,7 +380,6 @@ void SetupServerArgs(NodeContext& node)\n     argsman.AddArg(\"-datadir=<dir>\", \"Specify data directory\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     argsman.AddArg(\"-dbbatchsize\", strprintf(\"Maximum database write batch size in bytes (default: %u)\", nDefaultDbBatchSize), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::OPTIONS);\n     argsman.AddArg(\"-dbcache=<n>\", strprintf(\"Maximum database cache size <n> MiB (%d to %d, default: %d). In addition, unused mempool memory is shared for this cache (see -maxmempool).\", nMinDbCache, nMaxDbCache, nDefaultDbCache), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n-    argsman.AddArg(\"-debuglogfile=<file>\", strprintf(\"Specify location of debug log file. Relative paths will be prefixed by a net-specific datadir location. (-nodebuglogfile to disable; default: %s)\", DEFAULT_DEBUGLOGFILE), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     argsman.AddArg(\"-feefilter\", strprintf(\"Tell other nodes to filter invs to us by our mempool min fee (default: %u)\", DEFAULT_FEEFILTER), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::OPTIONS);\n     argsman.AddArg(\"-includeconf=<file>\", \"Specify additional configuration file, relative to the -datadir path (only useable from configuration file, not command line)\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     argsman.AddArg(\"-loadblock=<file>\", \"Imports blocks from external file on startup\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n@@ -522,25 +507,10 @@ void SetupServerArgs(NodeContext& node)\n     argsman.AddArg(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-addrmantest\", \"Allows to test address relay on localhost\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-capturemessages\", \"Capture all P2P messages to disk\", ArgsManager::ALLOW_BOOL | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n-    argsman.AddArg(\"-debug=<category>\", \"Output debugging information (default: -nodebug, supplying <category> is optional). \"\n-        \"If <category> is not supplied or if <category> = 1, output all debugging information. <category> can be: \" + LogInstance().LogCategoriesString() + \". This option can be specified multiple times to output multiple categories.\",\n-        ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n-    argsman.AddArg(\"-debugexclude=<category>\", strprintf(\"Exclude debugging information for a category. Can be used in conjunction with -debug=1 to output debug logs for all categories except the specified category. This option can be specified multiple times to exclude multiple categories.\"), ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n-    argsman.AddArg(\"-logips\", strprintf(\"Include IP addresses in debug output (default: %u)\", DEFAULT_LOGIPS), ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n-    argsman.AddArg(\"-logtimestamps\", strprintf(\"Prepend debug output with timestamp (default: %u)\", DEFAULT_LOGTIMESTAMPS), ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n-#ifdef HAVE_THREAD_LOCAL\n-    argsman.AddArg(\"-logthreadnames\", strprintf(\"Prepend debug output with name of the originating thread (only available on platforms supporting thread_local) (default: %u)\", DEFAULT_LOGTHREADNAMES), ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n-#else\n-    hidden_args.emplace_back(\"-logthreadnames\");\n-#endif\n-    argsman.AddArg(\"-logsourcelocations\", strprintf(\"Prepend debug output with name of the originating source location (source file, line number and function name) (default: %u)\", DEFAULT_LOGSOURCELOCATIONS), ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n-    argsman.AddArg(\"-logtimemicros\", strprintf(\"Add microsecond precision to debug timestamps (default: %u)\", DEFAULT_LOGTIMEMICROS), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-mocktime=<n>\", \"Replace actual time with \" + UNIX_EPOCH_TIME + \" (default: 0)\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-maxsigcachesize=<n>\", strprintf(\"Limit sum of signature cache and script execution cache sizes to <n> MiB (default: %u)\", DEFAULT_MAX_SIG_CACHE_SIZE), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-maxtipage=<n>\", strprintf(\"Maximum tip age in seconds to consider node in initial block download (default: %u)\", DEFAULT_MAX_TIP_AGE), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-printpriority\", strprintf(\"Log transaction fee per kB when mining blocks (default: %u)\", DEFAULT_PRINTPRIORITY), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n-    argsman.AddArg(\"-printtoconsole\", \"Send trace/debug info to console (default: 1 when no -daemon. To disable logging to file, set -nodebuglogfile)\", ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n-    argsman.AddArg(\"-shrinkdebugfile\", \"Shrink debug.log file on client startup (default: 1 when no -debug)\", ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-uacomment=<cmt>\", \"Append comment to the user agent string\", ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n \n     SetupChainParamsBaseOptions(argsman);\n@@ -637,7 +607,7 @@ static void CleanupBlockRevFiles()\n     // Remove the rev files immediately and insert the blk file paths into an\n     // ordered map keyed by block file index.\n     LogPrintf(\"Removing unusable blk?????.dat and rev?????.dat files for -reindex with -prune\\n\");\n-    fs::path blocksdir = GetBlocksDir();\n+    fs::path blocksdir = gArgs.GetBlocksDirPath();\n     for (fs::directory_iterator it(blocksdir); it != fs::directory_iterator(); it++) {\n         if (fs::is_regular_file(*it) &&\n             it->path().filename().string().length() == 12 &&\n@@ -675,30 +645,6 @@ static void StartupNotify(const ArgsManager& args)\n }\n #endif\n \n-/** Sanity checks\n- *  Ensure that Bitcoin is running in a usable environment with all\n- *  necessary library support.\n- */\n-static bool InitSanityCheck()\n-{\n-    if (!ECC_InitSanityCheck()) {\n-        return InitError(Untranslated(\"Elliptic curve cryptography sanity check failure. Aborting.\"));\n-    }\n-\n-    if (!glibcxx_sanity_test())\n-        return false;\n-\n-    if (!Random_SanityCheck()) {\n-        return InitError(Untranslated(\"OS cryptographic RNG sanity check failure. Aborting.\"));\n-    }\n-\n-    if (!ChronoSanityCheck()) {\n-        return InitError(Untranslated(\"Clock epoch mismatch. Aborting.\"));\n-    }\n-\n-    return true;\n-}\n-\n static bool AppInitServers(NodeContext& node)\n {\n     const ArgsManager& args = *Assert(node.args);\n@@ -796,25 +742,8 @@ void InitParameterInteraction(ArgsManager& args)\n  */\n void InitLogging(const ArgsManager& args)\n {\n-    LogInstance().m_print_to_file = !args.IsArgNegated(\"-debuglogfile\");\n-    LogInstance().m_file_path = AbsPathForConfigVal(args.GetArg(\"-debuglogfile\", DEFAULT_DEBUGLOGFILE));\n-    LogInstance().m_print_to_console = args.GetBoolArg(\"-printtoconsole\", !args.GetBoolArg(\"-daemon\", false));\n-    LogInstance().m_log_timestamps = args.GetBoolArg(\"-logtimestamps\", DEFAULT_LOGTIMESTAMPS);\n-    LogInstance().m_log_time_micros = args.GetBoolArg(\"-logtimemicros\", DEFAULT_LOGTIMEMICROS);\n-#ifdef HAVE_THREAD_LOCAL\n-    LogInstance().m_log_threadnames = args.GetBoolArg(\"-logthreadnames\", DEFAULT_LOGTHREADNAMES);\n-#endif\n-    LogInstance().m_log_sourcelocations = args.GetBoolArg(\"-logsourcelocations\", DEFAULT_LOGSOURCELOCATIONS);\n-\n-    fLogIPs = args.GetBoolArg(\"-logips\", DEFAULT_LOGIPS);\n-\n-    std::string version_string = FormatFullVersion();\n-#ifdef DEBUG\n-    version_string += \" (debug build)\";\n-#else\n-    version_string += \" (release build)\";\n-#endif\n-    LogPrintf(PACKAGE_NAME \" version %s\\n\", version_string);\n+    init::SetLoggingOptions(args);\n+    init::LogPackageVersion();\n }\n \n namespace { // Variables internal to initialization process only\n@@ -919,7 +848,7 @@ bool AppInitParameterInteraction(const ArgsManager& args)\n         InitWarning(warnings);\n     }\n \n-    if (!fs::is_directory(GetBlocksDir())) {\n+    if (!fs::is_directory(gArgs.GetBlocksDirPath())) {\n         return InitError(strprintf(_(\"Specified blocks directory \\\"%s\\\" does not exist.\"), args.GetArg(\"-blocksdir\", \"\")));\n     }\n \n@@ -982,26 +911,7 @@ bool AppInitParameterInteraction(const ArgsManager& args)\n         InitWarning(strprintf(_(\"Reducing -maxconnections from %d to %d, because of system limitations.\"), nUserMaxConnections, nMaxConnections));\n \n     // ********************************************************* Step 3: parameter-to-internal-flags\n-    if (args.IsArgSet(\"-debug\")) {\n-        // Special-case: if -debug=0/-nodebug is set, turn off debugging messages\n-        const std::vector<std::string> categories = args.GetArgs(\"-debug\");\n-\n-        if (std::none_of(categories.begin(), categories.end(),\n-            [](std::string cat){return cat == \"0\" || cat == \"none\";})) {\n-            for (const auto& cat : categories) {\n-                if (!LogInstance().EnableCategory(cat)) {\n-                    InitWarning(strprintf(_(\"Unsupported logging category %s=%s.\"), \"-debug\", cat));\n-                }\n-            }\n-        }\n-    }\n-\n-    // Now remove the logging categories which were explicitly excluded\n-    for (const std::string& cat : args.GetArgs(\"-debugexclude\")) {\n-        if (!LogInstance().DisableCategory(cat)) {\n-            InitWarning(strprintf(_(\"Unsupported logging category %s=%s.\"), \"-debugexclude\", cat));\n-        }\n-    }\n+    init::SetLoggingCategories(args);\n \n     fCheckBlockIndex = args.GetBoolArg(\"-checkblockindex\", chainparams.DefaultConsistencyChecks());\n     fCheckpointsEnabled = args.GetBoolArg(\"-checkpoints\", DEFAULT_CHECKPOINTS_ENABLED);\n@@ -1148,16 +1058,11 @@ bool AppInitSanityChecks()\n {\n     // ********************************************************* Step 4: sanity checks\n \n-    // Initialize elliptic curve code\n-    std::string sha256_algo = SHA256AutoDetect();\n-    LogPrintf(\"Using the '%s' SHA256 implementation\\n\", sha256_algo);\n-    RandomInit();\n-    ECC_Start();\n-    globalVerifyHandle.reset(new ECCVerifyHandle());\n+    init::SetGlobals();\n \n-    // Sanity check\n-    if (!InitSanityCheck())\n+    if (!init::SanityChecks()) {\n         return InitError(strprintf(_(\"Initialization sanity check failed. %s is shutting down.\"), PACKAGE_NAME));\n+    }\n \n     // Probe the data directory lock to give an early error message, if possible\n     // We cannot hold the data directory lock here, as the forking for daemon() hasn't yet happened,\n@@ -1197,38 +1102,11 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n         // Detailed error printed inside CreatePidFile().\n         return false;\n     }\n-    if (LogInstance().m_print_to_file) {\n-        if (args.GetBoolArg(\"-shrinkdebugfile\", LogInstance().DefaultShrinkDebugFile())) {\n-            // Do this first since it both loads a bunch of debug.log into memory,\n-            // and because this needs to happen before any other debug.log printing\n-            LogInstance().ShrinkDebugFile();\n-        }\n-    }\n-    if (!LogInstance().StartLogging()) {\n-            return InitError(strprintf(Untranslated(\"Could not open debug log file %s\"),\n-                LogInstance().m_file_path.string()));\n-    }\n-\n-    if (!LogInstance().m_log_timestamps)\n-        LogPrintf(\"Startup time: %s\\n\", FormatISO8601DateTime(GetTime()));\n-    LogPrintf(\"Default data directory %s\\n\", GetDefaultDataDir().string());\n-    LogPrintf(\"Using data directory %s\\n\", GetDataDir().string());\n-\n-    // Only log conf file usage message if conf file actually exists.\n-    fs::path config_file_path = GetConfigFile(args.GetArg(\"-conf\", BITCOIN_CONF_FILENAME));\n-    if (fs::exists(config_file_path)) {\n-        LogPrintf(\"Config file: %s\\n\", config_file_path.string());\n-    } else if (args.IsArgSet(\"-conf\")) {\n-        // Warn if no conf file exists at path provided by user\n-        InitWarning(strprintf(_(\"The specified config file %s does not exist\"), config_file_path.string()));\n-    } else {\n-        // Not categorizing as \"Warning\" because it's the default behavior\n-        LogPrintf(\"Config file: %s (not found, skipping)\\n\", config_file_path.string());\n+    if (!init::StartLogging(args)) {\n+        // Detailed error printed inside StartLogging().\n+        return false;\n     }\n \n-    // Log the config arguments to debug.log\n-    args.LogArgs();\n-\n     LogPrintf(\"Using at most %i automatic connections (%i file descriptors available)\\n\", nMaxConnections, nFD);\n \n     // Warn about relative -datadir path.\n@@ -1492,7 +1370,7 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n \n     bool fLoaded = false;\n     while (!fLoaded && !ShutdownRequested()) {\n-        bool fReset = fReindex;\n+        const bool fReset = fReindex;\n         auto is_coinsview_empty = [&](CChainState* chainstate) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n             return fReset || fReindexChainState || chainstate->CoinsTip().GetBestBlock().IsNull();\n         };\n@@ -1613,29 +1491,17 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n                 break;\n             }\n \n-            bool failed_rewind{false};\n-            // Can't hold cs_main while calling RewindBlockIndex, so retrieve the relevant\n-            // chainstates beforehand.\n-            for (CChainState* chainstate : WITH_LOCK(::cs_main, return chainman.GetAll())) {\n-                if (!fReset) {\n-                    // Note that RewindBlockIndex MUST run even if we're about to -reindex-chainstate.\n-                    // It both disconnects blocks based on the chainstate, and drops block data in\n-                    // BlockIndex() based on lack of available witness data.\n-                    uiInterface.InitMessage(_(\"Rewinding blocks...\").translated);\n-                    if (!chainstate->RewindBlockIndex(chainparams)) {\n-                        strLoadError = _(\n-                            \"Unable to rewind the database to a pre-fork state. \"\n-                            \"You will need to redownload the blockchain\");\n-                        failed_rewind = true;\n-                        break; // out of the per-chainstate loop\n-                    }\n+            if (!fReset) {\n+                LOCK(cs_main);\n+                auto chainstates{chainman.GetAll()};\n+                if (std::any_of(chainstates.begin(), chainstates.end(),\n+                                [&chainparams](const CChainState* cs) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { return cs->NeedsRedownload(chainparams); })) {\n+                    strLoadError = strprintf(_(\"Witness data for blocks after height %d requires validation. Please restart with -reindex.\"),\n+                                             chainparams.GetConsensus().SegwitHeight);\n+                    break;\n                 }\n             }\n \n-            if (failed_rewind) {\n-                break; // out of the chainstate activation do-while\n-            }\n-\n             bool failed_verification = false;\n \n             try {\n@@ -1659,11 +1525,8 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n                             break;\n                         }\n \n-                        // Only verify the DB of the active chainstate. This is fixed in later\n-                        // work when we allow VerifyDB to be parameterized by chainstate.\n-                        if (&::ChainstateActive() == chainstate &&\n-                            !CVerifyDB().VerifyDB(\n-                                chainparams, *chainstate, &chainstate->CoinsDB(),\n+                        if (!CVerifyDB().VerifyDB(\n+                                *chainstate, chainparams, chainstate->CoinsDB(),\n                                 args.GetArg(\"-checklevel\", DEFAULT_CHECKLEVEL),\n                                 args.GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS))) {\n                             strLoadError = _(\"Corrupted block database detected\");\n@@ -1759,8 +1622,8 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n         InitError(strprintf(_(\"Error: Disk space is low for %s\"), GetDataDir()));\n         return false;\n     }\n-    if (!CheckDiskSpace(GetBlocksDir())) {\n-        InitError(strprintf(_(\"Error: Disk space is low for %s\"), GetBlocksDir()));\n+    if (!CheckDiskSpace(gArgs.GetBlocksDirPath())) {\n+        InitError(strprintf(_(\"Error: Disk space is low for %s\"), gArgs.GetBlocksDirPath()));\n         return false;\n     }\n "
      },
      {
        "sha": "49684ede83eabf8870f788491d8ec24857a4d888",
        "filename": "src/init/bitcoin-node.cpp",
        "status": "added",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/init/bitcoin-node.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/init/bitcoin-node.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init/bitcoin-node.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,45 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <interfaces/echo.h>\n+#include <interfaces/init.h>\n+#include <interfaces/ipc.h>\n+#include <node/context.h>\n+\n+#include <memory>\n+\n+namespace init {\n+namespace {\n+const char* EXE_NAME = \"bitcoin-node\";\n+\n+class BitcoinNodeInit : public interfaces::Init\n+{\n+public:\n+    BitcoinNodeInit(NodeContext& node, const char* arg0)\n+        : m_node(node),\n+          m_ipc(interfaces::MakeIpc(EXE_NAME, arg0, *this))\n+    {\n+        m_node.init = this;\n+    }\n+    std::unique_ptr<interfaces::Echo> makeEcho() override { return interfaces::MakeEcho(); }\n+    interfaces::Ipc* ipc() override { return m_ipc.get(); }\n+    NodeContext& m_node;\n+    std::unique_ptr<interfaces::Ipc> m_ipc;\n+};\n+} // namespace\n+} // namespace init\n+\n+namespace interfaces {\n+std::unique_ptr<Init> MakeNodeInit(NodeContext& node, int argc, char* argv[], int& exit_status)\n+{\n+    auto init = std::make_unique<init::BitcoinNodeInit>(node, argc > 0 ? argv[0] : \"\");\n+    // Check if bitcoin-node is being invoked as an IPC server. If so, then\n+    // bypass normal execution and just respond to requests over the IPC\n+    // channel and return null.\n+    if (init->m_ipc->startSpawnedProcess(argc, argv, exit_status)) {\n+        return nullptr;\n+    }\n+    return init;\n+}\n+} // namespace interfaces"
      },
      {
        "sha": "1e17ce4d3ca1d2b884f29c6c45fbc94597d54d88",
        "filename": "src/init/bitcoind.cpp",
        "status": "added",
        "additions": 29,
        "deletions": 0,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/init/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/init/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init/bitcoind.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,29 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <interfaces/init.h>\n+#include <node/context.h>\n+\n+#include <memory>\n+\n+namespace init {\n+namespace {\n+class BitcoindInit : public interfaces::Init\n+{\n+public:\n+    BitcoindInit(NodeContext& node) : m_node(node)\n+    {\n+        m_node.init = this;\n+    }\n+    NodeContext& m_node;\n+};\n+} // namespace\n+} // namespace init\n+\n+namespace interfaces {\n+std::unique_ptr<Init> MakeNodeInit(NodeContext& node, int argc, char* argv[], int& exit_status)\n+{\n+    return std::make_unique<init::BitcoindInit>(node);\n+}\n+} // namespace interfaces"
      },
      {
        "sha": "79e0c9da782e09e83ea652e9f33d2a586ff9a8f1",
        "filename": "src/init/common.cpp",
        "status": "added",
        "additions": 167,
        "deletions": 0,
        "changes": 167,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/init/common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/init/common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init/common.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,167 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <clientversion.h>\n+#include <compat/sanity.h>\n+#include <crypto/sha256.h>\n+#include <key.h>\n+#include <logging.h>\n+#include <node/ui_interface.h>\n+#include <pubkey.h>\n+#include <random.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+#include <util/translation.h>\n+\n+#include <memory>\n+\n+static std::unique_ptr<ECCVerifyHandle> globalVerifyHandle;\n+\n+namespace init {\n+void SetGlobals()\n+{\n+    std::string sha256_algo = SHA256AutoDetect();\n+    LogPrintf(\"Using the '%s' SHA256 implementation\\n\", sha256_algo);\n+    RandomInit();\n+    ECC_Start();\n+    globalVerifyHandle.reset(new ECCVerifyHandle());\n+}\n+\n+void UnsetGlobals()\n+{\n+    globalVerifyHandle.reset();\n+    ECC_Stop();\n+}\n+\n+bool SanityChecks()\n+{\n+    if (!ECC_InitSanityCheck()) {\n+        return InitError(Untranslated(\"Elliptic curve cryptography sanity check failure. Aborting.\"));\n+    }\n+\n+    if (!glibcxx_sanity_test())\n+        return false;\n+\n+    if (!Random_SanityCheck()) {\n+        return InitError(Untranslated(\"OS cryptographic RNG sanity check failure. Aborting.\"));\n+    }\n+\n+    if (!ChronoSanityCheck()) {\n+        return InitError(Untranslated(\"Clock epoch mismatch. Aborting.\"));\n+    }\n+\n+    return true;\n+}\n+\n+void AddLoggingArgs(ArgsManager& argsman)\n+{\n+    argsman.AddArg(\"-debuglogfile=<file>\", strprintf(\"Specify location of debug log file. Relative paths will be prefixed by a net-specific datadir location. (-nodebuglogfile to disable; default: %s)\", DEFAULT_DEBUGLOGFILE), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+    argsman.AddArg(\"-debug=<category>\", \"Output debugging information (default: -nodebug, supplying <category> is optional). \"\n+        \"If <category> is not supplied or if <category> = 1, output all debugging information. <category> can be: \" + LogInstance().LogCategoriesString() + \". This option can be specified multiple times to output multiple categories.\",\n+        ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n+    argsman.AddArg(\"-debugexclude=<category>\", strprintf(\"Exclude debugging information for a category. Can be used in conjunction with -debug=1 to output debug logs for all categories except the specified category. This option can be specified multiple times to exclude multiple categories.\"), ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n+    argsman.AddArg(\"-logips\", strprintf(\"Include IP addresses in debug output (default: %u)\", DEFAULT_LOGIPS), ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n+    argsman.AddArg(\"-logtimestamps\", strprintf(\"Prepend debug output with timestamp (default: %u)\", DEFAULT_LOGTIMESTAMPS), ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n+#ifdef HAVE_THREAD_LOCAL\n+    argsman.AddArg(\"-logthreadnames\", strprintf(\"Prepend debug output with name of the originating thread (only available on platforms supporting thread_local) (default: %u)\", DEFAULT_LOGTHREADNAMES), ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n+#else\n+    argsman.AddHiddenArgs({\"-logthreadnames\"});\n+#endif\n+    argsman.AddArg(\"-logsourcelocations\", strprintf(\"Prepend debug output with name of the originating source location (source file, line number and function name) (default: %u)\", DEFAULT_LOGSOURCELOCATIONS), ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n+    argsman.AddArg(\"-logtimemicros\", strprintf(\"Add microsecond precision to debug timestamps (default: %u)\", DEFAULT_LOGTIMEMICROS), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n+    argsman.AddArg(\"-printtoconsole\", \"Send trace/debug info to console (default: 1 when no -daemon. To disable logging to file, set -nodebuglogfile)\", ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n+    argsman.AddArg(\"-shrinkdebugfile\", \"Shrink debug.log file on client startup (default: 1 when no -debug)\", ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n+}\n+\n+void SetLoggingOptions(const ArgsManager& args)\n+{\n+    LogInstance().m_print_to_file = !args.IsArgNegated(\"-debuglogfile\");\n+    LogInstance().m_file_path = AbsPathForConfigVal(args.GetArg(\"-debuglogfile\", DEFAULT_DEBUGLOGFILE));\n+    LogInstance().m_print_to_console = args.GetBoolArg(\"-printtoconsole\", !args.GetBoolArg(\"-daemon\", false));\n+    LogInstance().m_log_timestamps = args.GetBoolArg(\"-logtimestamps\", DEFAULT_LOGTIMESTAMPS);\n+    LogInstance().m_log_time_micros = args.GetBoolArg(\"-logtimemicros\", DEFAULT_LOGTIMEMICROS);\n+#ifdef HAVE_THREAD_LOCAL\n+    LogInstance().m_log_threadnames = args.GetBoolArg(\"-logthreadnames\", DEFAULT_LOGTHREADNAMES);\n+#endif\n+    LogInstance().m_log_sourcelocations = args.GetBoolArg(\"-logsourcelocations\", DEFAULT_LOGSOURCELOCATIONS);\n+\n+    fLogIPs = args.GetBoolArg(\"-logips\", DEFAULT_LOGIPS);\n+}\n+\n+void SetLoggingCategories(const ArgsManager& args)\n+{\n+    if (args.IsArgSet(\"-debug\")) {\n+        // Special-case: if -debug=0/-nodebug is set, turn off debugging messages\n+        const std::vector<std::string> categories = args.GetArgs(\"-debug\");\n+\n+        if (std::none_of(categories.begin(), categories.end(),\n+            [](std::string cat){return cat == \"0\" || cat == \"none\";})) {\n+            for (const auto& cat : categories) {\n+                if (!LogInstance().EnableCategory(cat)) {\n+                    InitWarning(strprintf(_(\"Unsupported logging category %s=%s.\"), \"-debug\", cat));\n+                }\n+            }\n+        }\n+    }\n+\n+    // Now remove the logging categories which were explicitly excluded\n+    for (const std::string& cat : args.GetArgs(\"-debugexclude\")) {\n+        if (!LogInstance().DisableCategory(cat)) {\n+            InitWarning(strprintf(_(\"Unsupported logging category %s=%s.\"), \"-debugexclude\", cat));\n+        }\n+    }\n+}\n+\n+bool StartLogging(const ArgsManager& args)\n+{\n+    if (LogInstance().m_print_to_file) {\n+        if (args.GetBoolArg(\"-shrinkdebugfile\", LogInstance().DefaultShrinkDebugFile())) {\n+            // Do this first since it both loads a bunch of debug.log into memory,\n+            // and because this needs to happen before any other debug.log printing\n+            LogInstance().ShrinkDebugFile();\n+        }\n+    }\n+    if (!LogInstance().StartLogging()) {\n+            return InitError(strprintf(Untranslated(\"Could not open debug log file %s\"),\n+                LogInstance().m_file_path.string()));\n+    }\n+\n+    if (!LogInstance().m_log_timestamps)\n+        LogPrintf(\"Startup time: %s\\n\", FormatISO8601DateTime(GetTime()));\n+    LogPrintf(\"Default data directory %s\\n\", GetDefaultDataDir().string());\n+    LogPrintf(\"Using data directory %s\\n\", GetDataDir().string());\n+\n+    // Only log conf file usage message if conf file actually exists.\n+    fs::path config_file_path = GetConfigFile(args.GetArg(\"-conf\", BITCOIN_CONF_FILENAME));\n+    if (fs::exists(config_file_path)) {\n+        LogPrintf(\"Config file: %s\\n\", config_file_path.string());\n+    } else if (args.IsArgSet(\"-conf\")) {\n+        // Warn if no conf file exists at path provided by user\n+        InitWarning(strprintf(_(\"The specified config file %s does not exist\"), config_file_path.string()));\n+    } else {\n+        // Not categorizing as \"Warning\" because it's the default behavior\n+        LogPrintf(\"Config file: %s (not found, skipping)\\n\", config_file_path.string());\n+    }\n+\n+    // Log the config arguments to debug.log\n+    args.LogArgs();\n+\n+    return true;\n+}\n+\n+void LogPackageVersion()\n+{\n+    std::string version_string = FormatFullVersion();\n+#ifdef DEBUG\n+    version_string += \" (debug build)\";\n+#else\n+    version_string += \" (release build)\";\n+#endif\n+    LogPrintf(PACKAGE_NAME \" version %s\\n\", version_string);\n+}\n+} // namespace init"
      },
      {
        "sha": "fc4bc1b28009ee65fa95436fa13517a8551eb9a1",
        "filename": "src/init/common.h",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/init/common.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/init/common.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init/common.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,28 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+//! @file\n+//! @brief Common init functions shared by bitcoin-node, bitcoin-wallet, etc.\n+\n+#ifndef BITCOIN_INIT_COMMON_H\n+#define BITCOIN_INIT_COMMON_H\n+\n+class ArgsManager;\n+\n+namespace init {\n+void SetGlobals();\n+void UnsetGlobals();\n+/**\n+ *  Ensure a usable environment with all\n+ *  necessary library support.\n+ */\n+bool SanityChecks();\n+void AddLoggingArgs(ArgsManager& args);\n+void SetLoggingOptions(const ArgsManager& args);\n+void SetLoggingCategories(const ArgsManager& args);\n+bool StartLogging(const ArgsManager& args);\n+void LogPackageVersion();\n+} // namespace init\n+\n+#endif // BITCOIN_INIT_COMMON_H"
      },
      {
        "sha": "97167d5298f0f042efea8295abd5545547dae72c",
        "filename": "src/interfaces/README.md",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/interfaces/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/interfaces/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/README.md?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -12,6 +12,8 @@ The following interfaces are defined here:\n \n * [`Handler`](handler.h) \u2014 returned by `handleEvent` methods on interfaces above and used to manage lifetimes of event handlers.\n \n-* [`Init`](init.h) \u2014 used by multiprocess code to access interfaces above on startup. Added in [#10102](https://github.com/bitcoin/bitcoin/pull/10102).\n+* [`Init`](init.h) \u2014 used by multiprocess code to access interfaces above on startup. Added in [#19160](https://github.com/bitcoin/bitcoin/pull/19160).\n \n-The interfaces above define boundaries between major components of bitcoin code (node, wallet, and gui), making it possible for them to run in different processes, and be tested, developed, and understood independently. These interfaces are not currently designed to be stable or to be used externally.\n+* [`Ipc`](ipc.h) \u2014 used by multiprocess code to access `Init` interface across processes. Added in [#19160](https://github.com/bitcoin/bitcoin/pull/19160).\n+\n+The interfaces above define boundaries between major components of bitcoin code (node, wallet, and gui), making it possible for them to run in [different processes](../../doc/multiprocess.md), and be tested, developed, and understood independently. These interfaces are not currently designed to be stable or to be used externally."
      },
      {
        "sha": "9bbb42217b02687a219367a1fe9e9a8694b64212",
        "filename": "src/interfaces/echo.cpp",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/interfaces/echo.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/interfaces/echo.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/echo.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,18 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <interfaces/echo.h>\n+\n+#include <memory>\n+\n+namespace interfaces {\n+namespace {\n+class EchoImpl : public Echo\n+{\n+public:\n+    std::string echo(const std::string& echo) override { return echo; }\n+};\n+} // namespace\n+std::unique_ptr<Echo> MakeEcho() { return std::make_unique<EchoImpl>(); }\n+} // namespace interfaces"
      },
      {
        "sha": "5578d9d9e62395805cb819508704906f3b4e2d5f",
        "filename": "src/interfaces/echo.h",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/interfaces/echo.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/interfaces/echo.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/echo.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,26 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INTERFACES_ECHO_H\n+#define BITCOIN_INTERFACES_ECHO_H\n+\n+#include <memory>\n+#include <string>\n+\n+namespace interfaces {\n+//! Simple string echoing interface for testing.\n+class Echo\n+{\n+public:\n+    virtual ~Echo() {}\n+\n+    //! Echo provided string.\n+    virtual std::string echo(const std::string& echo) = 0;\n+};\n+\n+//! Return implementation of Echo interface.\n+std::unique_ptr<Echo> MakeEcho();\n+} // namespace interfaces\n+\n+#endif // BITCOIN_INTERFACES_ECHO_H"
      },
      {
        "sha": "a3c949e6169d1d230a15d725eeb191410eb6c5df",
        "filename": "src/interfaces/init.cpp",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/interfaces/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/interfaces/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/init.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,17 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <interfaces/chain.h>\n+#include <interfaces/echo.h>\n+#include <interfaces/init.h>\n+#include <interfaces/node.h>\n+#include <interfaces/wallet.h>\n+\n+namespace interfaces {\n+std::unique_ptr<Node> Init::makeNode() { return {}; }\n+std::unique_ptr<Chain> Init::makeChain() { return {}; }\n+std::unique_ptr<WalletClient> Init::makeWalletClient(Chain& chain) { return {}; }\n+std::unique_ptr<Echo> Init::makeEcho() { return {}; }\n+Ipc* Init::ipc() { return nullptr; }\n+} // namespace interfaces"
      },
      {
        "sha": "2a38054a172fb285c5522b50b2d689103ede01ae",
        "filename": "src/interfaces/init.h",
        "status": "added",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/interfaces/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/interfaces/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/init.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,52 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INTERFACES_INIT_H\n+#define BITCOIN_INTERFACES_INIT_H\n+\n+#include <memory>\n+\n+struct NodeContext;\n+\n+namespace interfaces {\n+class Chain;\n+class Echo;\n+class Ipc;\n+class Node;\n+class WalletClient;\n+\n+//! Initial interface created when a process is first started, and used to give\n+//! and get access to other interfaces (Node, Chain, Wallet, etc).\n+//!\n+//! There is a different Init interface implementation for each process\n+//! (bitcoin-gui, bitcoin-node, bitcoin-wallet, bitcoind, bitcoin-qt) and each\n+//! implementation can implement the make methods for interfaces it supports.\n+//! The default make methods all return null.\n+class Init\n+{\n+public:\n+    virtual ~Init() = default;\n+    virtual std::unique_ptr<Node> makeNode();\n+    virtual std::unique_ptr<Chain> makeChain();\n+    virtual std::unique_ptr<WalletClient> makeWalletClient(Chain& chain);\n+    virtual std::unique_ptr<Echo> makeEcho();\n+    virtual Ipc* ipc();\n+};\n+\n+//! Return implementation of Init interface for the node process. If the argv\n+//! indicates that this is a child process spawned to handle requests from a\n+//! parent process, this blocks and handles requests, then returns null and a\n+//! status code to exit with. If this returns non-null, the caller can start up\n+//! normally and use the Init object to spawn and connect to other processes\n+//! while it is running.\n+std::unique_ptr<Init> MakeNodeInit(NodeContext& node, int argc, char* argv[], int& exit_status);\n+\n+//! Return implementation of Init interface for the wallet process.\n+std::unique_ptr<Init> MakeWalletInit(int argc, char* argv[], int& exit_status);\n+\n+//! Return implementation of Init interface for the gui process.\n+std::unique_ptr<Init> MakeGuiInit(int argc, char* argv[]);\n+} // namespace interfaces\n+\n+#endif // BITCOIN_INTERFACES_INIT_H"
      },
      {
        "sha": "e9e6c78053d3e3a0ea411c28ba47c84c657cd992",
        "filename": "src/interfaces/ipc.h",
        "status": "added",
        "additions": 71,
        "deletions": 0,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/interfaces/ipc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/interfaces/ipc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/ipc.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,71 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INTERFACES_IPC_H\n+#define BITCOIN_INTERFACES_IPC_H\n+\n+#include <functional>\n+#include <memory>\n+#include <typeindex>\n+\n+namespace interfaces {\n+class Init;\n+\n+//! Interface providing access to interprocess-communication (IPC)\n+//! functionality. The IPC implementation is responsible for establishing\n+//! connections between a controlling process and a process being controlled.\n+//! When a connection is established, the process being controlled returns an\n+//! interfaces::Init pointer to the controlling process, which the controlling\n+//! process can use to get access to other interfaces and functionality.\n+//!\n+//! When spawning a new process, the steps are:\n+//!\n+//! 1. The controlling process calls interfaces::Ipc::spawnProcess(), which\n+//!    calls ipc::Process::spawn(), which spawns a new process and returns a\n+//!    socketpair file descriptor for communicating with it.\n+//!    interfaces::Ipc::spawnProcess() then calls ipc::Protocol::connect()\n+//!    passing the socketpair descriptor, which returns a local proxy\n+//!    interfaces::Init implementation calling remote interfaces::Init methods.\n+//! 2. The spawned process calls interfaces::Ipc::startSpawnProcess(), which\n+//!    calls ipc::Process::checkSpawned() to read command line arguments and\n+//!    determine whether it is a spawned process and what socketpair file\n+//!    descriptor it should use. It then calls ipc::Protocol::serve() to handle\n+//!    incoming requests from the socketpair and invoke interfaces::Init\n+//!    interface methods, and exit when the socket is closed.\n+//! 3. The controlling process calls local proxy interfaces::Init object methods\n+//!    to make other proxy objects calling other remote interfaces. It can also\n+//!    destroy the initial interfaces::Init object to close the connection and\n+//!    shut down the spawned process.\n+class Ipc\n+{\n+public:\n+    virtual ~Ipc() = default;\n+\n+    //! Spawn a child process returning pointer to its Init interface.\n+    virtual std::unique_ptr<Init> spawnProcess(const char* exe_name) = 0;\n+\n+    //! If this is a spawned process, block and handle requests from the parent\n+    //! process by forwarding them to this process's Init interface, then return\n+    //! true. If this is not a spawned child process, return false.\n+    virtual bool startSpawnedProcess(int argc, char* argv[], int& exit_status) = 0;\n+\n+    //! Add cleanup callback to remote interface that will run when the\n+    //! interface is deleted.\n+    template<typename Interface>\n+    void addCleanup(Interface& iface, std::function<void()> cleanup)\n+    {\n+        addCleanup(typeid(Interface), &iface, std::move(cleanup));\n+    }\n+\n+protected:\n+    //! Internal implementation of public addCleanup method (above) as a\n+    //! type-erased virtual function, since template functions can't be virtual.\n+    virtual void addCleanup(std::type_index type, void* iface, std::function<void()> cleanup) = 0;\n+};\n+\n+//! Return implementation of Ipc interface.\n+std::unique_ptr<Ipc> MakeIpc(const char* exe_name, const char* process_argv0, Init& init);\n+} // namespace interfaces\n+\n+#endif // BITCOIN_INTERFACES_IPC_H"
      },
      {
        "sha": "036df1430c5610b5286a9f675c7a5906f95b647f",
        "filename": "src/ipc/capnp/.gitignore",
        "status": "added",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/capnp/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/capnp/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ipc/capnp/.gitignore?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,2 @@\n+# capnp generated files\n+*.capnp.*"
      },
      {
        "sha": "df36ee0de376c2e7aab19dd80ae4b33e1d53d373",
        "filename": "src/ipc/capnp/echo.capnp",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/capnp/echo.capnp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/capnp/echo.capnp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ipc/capnp/echo.capnp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,17 @@\n+# Copyright (c) 2021 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+@0x888b4f7f51e691f7;\n+\n+using Cxx = import \"/capnp/c++.capnp\";\n+$Cxx.namespace(\"ipc::capnp::messages\");\n+\n+using Proxy = import \"/mp/proxy.capnp\";\n+$Proxy.include(\"interfaces/echo.h\");\n+$Proxy.include(\"ipc/capnp/echo.capnp.h\");\n+\n+interface Echo $Proxy.wrap(\"interfaces::Echo\") {\n+    destroy @0 (context :Proxy.Context) -> ();\n+    echo @1 (context :Proxy.Context, echo: Text) -> (result :Text);\n+}"
      },
      {
        "sha": "42031441b597c5795ed96ce1d513938d19e2e1e1",
        "filename": "src/ipc/capnp/init-types.h",
        "status": "added",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/capnp/init-types.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/capnp/init-types.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ipc/capnp/init-types.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,10 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_IPC_CAPNP_INIT_TYPES_H\n+#define BITCOIN_IPC_CAPNP_INIT_TYPES_H\n+\n+#include <ipc/capnp/echo.capnp.proxy-types.h>\n+\n+#endif // BITCOIN_IPC_CAPNP_INIT_TYPES_H"
      },
      {
        "sha": "e6d358c66556e4f5f0914b58ba3716dd7b140d7c",
        "filename": "src/ipc/capnp/init.capnp",
        "status": "added",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/capnp/init.capnp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/capnp/init.capnp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ipc/capnp/init.capnp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,20 @@\n+# Copyright (c) 2021 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+@0xf2c5cfa319406aa6;\n+\n+using Cxx = import \"/capnp/c++.capnp\";\n+$Cxx.namespace(\"ipc::capnp::messages\");\n+\n+using Proxy = import \"/mp/proxy.capnp\";\n+$Proxy.include(\"interfaces/echo.h\");\n+$Proxy.include(\"interfaces/init.h\");\n+$Proxy.includeTypes(\"ipc/capnp/init-types.h\");\n+\n+using Echo = import \"echo.capnp\";\n+\n+interface Init $Proxy.wrap(\"interfaces::Init\") {\n+    construct @0 (threadMap: Proxy.ThreadMap) -> (threadMap :Proxy.ThreadMap);\n+    makeEcho @1 (context :Proxy.Context) -> (result :Echo.Echo);\n+}"
      },
      {
        "sha": "74c66c899acf488a7e35334a2a052545ac287da0",
        "filename": "src/ipc/capnp/protocol.cpp",
        "status": "added",
        "additions": 90,
        "deletions": 0,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/capnp/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/capnp/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ipc/capnp/protocol.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,90 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <interfaces/init.h>\n+#include <ipc/capnp/init.capnp.h>\n+#include <ipc/capnp/init.capnp.proxy.h>\n+#include <ipc/capnp/protocol.h>\n+#include <ipc/exception.h>\n+#include <ipc/protocol.h>\n+#include <kj/async.h>\n+#include <logging.h>\n+#include <mp/proxy-io.h>\n+#include <mp/proxy-types.h>\n+#include <mp/util.h>\n+#include <util/threadnames.h>\n+\n+#include <assert.h>\n+#include <errno.h>\n+#include <future>\n+#include <memory>\n+#include <mutex>\n+#include <optional>\n+#include <string>\n+#include <thread>\n+\n+namespace ipc {\n+namespace capnp {\n+namespace {\n+void IpcLogFn(bool raise, std::string message)\n+{\n+    LogPrint(BCLog::IPC, \"%s\\n\", message);\n+    if (raise) throw Exception(message);\n+}\n+\n+class CapnpProtocol : public Protocol\n+{\n+public:\n+    ~CapnpProtocol() noexcept(true)\n+    {\n+        if (m_loop) {\n+            std::unique_lock<std::mutex> lock(m_loop->m_mutex);\n+            m_loop->removeClient(lock);\n+        }\n+        if (m_loop_thread.joinable()) m_loop_thread.join();\n+        assert(!m_loop);\n+    };\n+    std::unique_ptr<interfaces::Init> connect(int fd, const char* exe_name) override\n+    {\n+        startLoop(exe_name);\n+        return mp::ConnectStream<messages::Init>(*m_loop, fd);\n+    }\n+    void serve(int fd, const char* exe_name, interfaces::Init& init) override\n+    {\n+        assert(!m_loop);\n+        mp::g_thread_context.thread_name = mp::ThreadName(exe_name);\n+        m_loop.emplace(exe_name, &IpcLogFn, nullptr);\n+        mp::ServeStream<messages::Init>(*m_loop, fd, init);\n+        m_loop->loop();\n+        m_loop.reset();\n+    }\n+    void addCleanup(std::type_index type, void* iface, std::function<void()> cleanup) override\n+    {\n+        mp::ProxyTypeRegister::types().at(type)(iface).cleanup.emplace_back(std::move(cleanup));\n+    }\n+    void startLoop(const char* exe_name)\n+    {\n+        if (m_loop) return;\n+        std::promise<void> promise;\n+        m_loop_thread = std::thread([&] {\n+            util::ThreadRename(\"capnp-loop\");\n+            m_loop.emplace(exe_name, &IpcLogFn, nullptr);\n+            {\n+                std::unique_lock<std::mutex> lock(m_loop->m_mutex);\n+                m_loop->addClient(lock);\n+            }\n+            promise.set_value();\n+            m_loop->loop();\n+            m_loop.reset();\n+        });\n+        promise.get_future().wait();\n+    }\n+    std::thread m_loop_thread;\n+    std::optional<mp::EventLoop> m_loop;\n+};\n+} // namespace\n+\n+std::unique_ptr<Protocol> MakeCapnpProtocol() { return std::make_unique<CapnpProtocol>(); }\n+} // namespace capnp\n+} // namespace ipc"
      },
      {
        "sha": "eb057949d28f61f1d14311e412f0b694f6bcca19",
        "filename": "src/ipc/capnp/protocol.h",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/capnp/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/capnp/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ipc/capnp/protocol.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,17 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_IPC_CAPNP_PROTOCOL_H\n+#define BITCOIN_IPC_CAPNP_PROTOCOL_H\n+\n+#include <memory>\n+\n+namespace ipc {\n+class Protocol;\n+namespace capnp {\n+std::unique_ptr<Protocol> MakeCapnpProtocol();\n+} // namespace capnp\n+} // namespace ipc\n+\n+#endif // BITCOIN_IPC_CAPNP_PROTOCOL_H"
      },
      {
        "sha": "53dee8124ae374407673c4497cb7209e3040915d",
        "filename": "src/ipc/exception.h",
        "status": "added",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/exception.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/exception.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ipc/exception.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,20 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_IPC_EXCEPTION_H\n+#define BITCOIN_IPC_EXCEPTION_H\n+\n+#include <stdexcept>\n+\n+namespace ipc {\n+//! Exception class thrown when a call to remote method fails due to an IPC\n+//! error, like a socket getting disconnected.\n+class Exception : public std::runtime_error\n+{\n+public:\n+    using std::runtime_error::runtime_error;\n+};\n+} // namespace ipc\n+\n+#endif // BITCOIN_IPC_EXCEPTION_H"
      },
      {
        "sha": "ad4b78ed8126259fcb07cebfeda475060b1c41d4",
        "filename": "src/ipc/interfaces.cpp",
        "status": "added",
        "additions": 77,
        "deletions": 0,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ipc/interfaces.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,77 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <fs.h>\n+#include <interfaces/init.h>\n+#include <interfaces/ipc.h>\n+#include <ipc/capnp/protocol.h>\n+#include <ipc/process.h>\n+#include <ipc/protocol.h>\n+#include <logging.h>\n+#include <tinyformat.h>\n+#include <util/system.h>\n+\n+#include <functional>\n+#include <memory>\n+#include <stdexcept>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <string>\n+#include <unistd.h>\n+#include <utility>\n+#include <vector>\n+\n+namespace ipc {\n+namespace {\n+class IpcImpl : public interfaces::Ipc\n+{\n+public:\n+    IpcImpl(const char* exe_name, const char* process_argv0, interfaces::Init& init)\n+        : m_exe_name(exe_name), m_process_argv0(process_argv0), m_init(init),\n+          m_protocol(ipc::capnp::MakeCapnpProtocol()), m_process(ipc::MakeProcess())\n+    {\n+    }\n+    std::unique_ptr<interfaces::Init> spawnProcess(const char* new_exe_name) override\n+    {\n+        int pid;\n+        int fd = m_process->spawn(new_exe_name, m_process_argv0, pid);\n+        LogPrint(::BCLog::IPC, \"Process %s pid %i launched\\n\", new_exe_name, pid);\n+        auto init = m_protocol->connect(fd, m_exe_name);\n+        Ipc::addCleanup(*init, [this, new_exe_name, pid] {\n+            int status = m_process->waitSpawned(pid);\n+            LogPrint(::BCLog::IPC, \"Process %s pid %i exited with status %i\\n\", new_exe_name, pid, status);\n+        });\n+        return init;\n+    }\n+    bool startSpawnedProcess(int argc, char* argv[], int& exit_status) override\n+    {\n+        exit_status = EXIT_FAILURE;\n+        int32_t fd = -1;\n+        if (!m_process->checkSpawned(argc, argv, fd)) {\n+            return false;\n+        }\n+        m_protocol->serve(fd, m_exe_name, m_init);\n+        exit_status = EXIT_SUCCESS;\n+        return true;\n+    }\n+    void addCleanup(std::type_index type, void* iface, std::function<void()> cleanup) override\n+    {\n+        m_protocol->addCleanup(type, iface, std::move(cleanup));\n+    }\n+    const char* m_exe_name;\n+    const char* m_process_argv0;\n+    interfaces::Init& m_init;\n+    std::unique_ptr<Protocol> m_protocol;\n+    std::unique_ptr<Process> m_process;\n+};\n+} // namespace\n+} // namespace ipc\n+\n+namespace interfaces {\n+std::unique_ptr<Ipc> MakeIpc(const char* exe_name, const char* process_argv0, Init& init)\n+{\n+    return std::make_unique<ipc::IpcImpl>(exe_name, process_argv0, init);\n+}\n+} // namespace interfaces"
      },
      {
        "sha": "43ed1f1baeb0205a10dfc901b04e18dc90f7114e",
        "filename": "src/ipc/process.cpp",
        "status": "added",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/process.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/process.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ipc/process.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,61 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <fs.h>\n+#include <ipc/process.h>\n+#include <ipc/protocol.h>\n+#include <mp/util.h>\n+#include <tinyformat.h>\n+#include <util/strencodings.h>\n+\n+#include <cstdint>\n+#include <exception>\n+#include <iostream>\n+#include <stdexcept>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <system_error>\n+#include <unistd.h>\n+#include <utility>\n+#include <vector>\n+\n+namespace ipc {\n+namespace {\n+class ProcessImpl : public Process\n+{\n+public:\n+    int spawn(const std::string& new_exe_name, const fs::path& argv0_path, int& pid) override\n+    {\n+        return mp::SpawnProcess(pid, [&](int fd) {\n+            fs::path path = argv0_path;\n+            path.remove_filename();\n+            path.append(new_exe_name);\n+            return std::vector<std::string>{path.string(), \"-ipcfd\", strprintf(\"%i\", fd)};\n+        });\n+    }\n+    int waitSpawned(int pid) override { return mp::WaitProcess(pid); }\n+    bool checkSpawned(int argc, char* argv[], int& fd) override\n+    {\n+        // If this process was not started with a single -ipcfd argument, it is\n+        // not a process spawned by the spawn() call above, so return false and\n+        // do not try to serve requests.\n+        if (argc != 3 || strcmp(argv[1], \"-ipcfd\") != 0) {\n+            return false;\n+        }\n+        // If a single -ipcfd argument was provided, return true and get the\n+        // file descriptor so Protocol::serve() can be called to handle\n+        // requests from the parent process. The -ipcfd argument is not valid\n+        // in combination with other arguments because the parent process\n+        // should be able to control the child process through the IPC protocol\n+        // without passing information out of band.\n+        if (!ParseInt32(argv[2], &fd)) {\n+            throw std::runtime_error(strprintf(\"Invalid -ipcfd number '%s'\", argv[2]));\n+        }\n+        return true;\n+    }\n+};\n+} // namespace\n+\n+std::unique_ptr<Process> MakeProcess() { return std::make_unique<ProcessImpl>(); }\n+} // namespace ipc"
      },
      {
        "sha": "4bb2930d9c3d00428ec3cd1639f67312a8149699",
        "filename": "src/ipc/process.h",
        "status": "added",
        "additions": 42,
        "deletions": 0,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/process.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/process.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ipc/process.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,42 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_IPC_PROCESS_H\n+#define BITCOIN_IPC_PROCESS_H\n+\n+#include <memory>\n+#include <string>\n+\n+namespace ipc {\n+class Protocol;\n+\n+//! IPC process interface for spawning bitcoin processes and serving requests\n+//! in processes that have been spawned.\n+//!\n+//! There will be different implementations of this interface depending on the\n+//! platform (e.g. unix, windows).\n+class Process\n+{\n+public:\n+    virtual ~Process() = default;\n+\n+    //! Spawn process and return socket file descriptor for communicating with\n+    //! it.\n+    virtual int spawn(const std::string& new_exe_name, const fs::path& argv0_path, int& pid) = 0;\n+\n+    //! Wait for spawned process to exit and return its exit code.\n+    virtual int waitSpawned(int pid) = 0;\n+\n+    //! Parse command line and determine if current process is a spawned child\n+    //! process. If so, return true and a file descriptor for communicating\n+    //! with the parent process.\n+    virtual bool checkSpawned(int argc, char* argv[], int& fd) = 0;\n+};\n+\n+//! Constructor for Process interface. Implementation will vary depending on\n+//! the platform (unix or windows).\n+std::unique_ptr<Process> MakeProcess();\n+} // namespace ipc\n+\n+#endif // BITCOIN_IPC_PROCESS_H"
      },
      {
        "sha": "af955b000786e55df99f039c5557bdbe048962f2",
        "filename": "src/ipc/protocol.h",
        "status": "added",
        "additions": 39,
        "deletions": 0,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/ipc/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ipc/protocol.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,39 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_IPC_PROTOCOL_H\n+#define BITCOIN_IPC_PROTOCOL_H\n+\n+#include <interfaces/init.h>\n+\n+#include <functional>\n+#include <memory>\n+#include <typeindex>\n+\n+namespace ipc {\n+//! IPC protocol interface for calling IPC methods over sockets.\n+//!\n+//! There may be different implementations of this interface for different IPC\n+//! protocols (e.g. Cap'n Proto, gRPC, JSON-RPC, or custom protocols).\n+class Protocol\n+{\n+public:\n+    virtual ~Protocol() = default;\n+\n+    //! Return Init interface that forwards requests over given socket descriptor.\n+    //! Socket communication is handled on a background thread.\n+    virtual std::unique_ptr<interfaces::Init> connect(int fd, const char* exe_name) = 0;\n+\n+    //! Handle requests on provided socket descriptor, forwarding them to the\n+    //! provided Init interface. Socket communication is handled on the\n+    //! current thread, and this call blocks until the socket is closed.\n+    virtual void serve(int fd, const char* exe_name, interfaces::Init& init) = 0;\n+\n+    //! Add cleanup callback to interface that will run when the interface is\n+    //! deleted.\n+    virtual void addCleanup(std::type_index type, void* iface, std::function<void()> cleanup) = 0;\n+};\n+} // namespace ipc\n+\n+#endif // BITCOIN_IPC_PROTOCOL_H"
      },
      {
        "sha": "e5187fd5962da8dff2b610950fbd8ae1128d3843",
        "filename": "src/logging.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/logging.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/logging.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -157,6 +157,7 @@ const CLogCategoryDesc LogCategories[] =\n     {BCLog::LEVELDB, \"leveldb\"},\n     {BCLog::VALIDATION, \"validation\"},\n     {BCLog::I2P, \"i2p\"},\n+    {BCLog::IPC, \"ipc\"},\n     {BCLog::ALL, \"1\"},\n     {BCLog::ALL, \"all\"},\n };"
      },
      {
        "sha": "d04bc992680d6d8f8e67af6354c3202eeb44b01a",
        "filename": "src/logging.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/logging.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/logging.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -58,6 +58,7 @@ namespace BCLog {\n         LEVELDB     = (1 << 20),\n         VALIDATION  = (1 << 21),\n         I2P         = (1 << 22),\n+        IPC         = (1 << 23),\n         ALL         = ~(uint32_t)0,\n     };\n "
      },
      {
        "sha": "fe1a0dfdedb24ca40db24fca313b6a8038b99b74",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 25,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -1732,7 +1732,7 @@ void CConnman::ProcessAddrFetch()\n     }\n }\n \n-bool CConnman::GetTryNewOutboundPeer()\n+bool CConnman::GetTryNewOutboundPeer() const\n {\n     return m_try_another_outbound_peer;\n }\n@@ -1749,7 +1749,7 @@ void CConnman::SetTryNewOutboundPeer(bool flag)\n // Also exclude peers that haven't finished initial connection handshake yet\n // (so that we don't decide we're over our desired connection limit, and then\n // evict some peer that has finished the handshake)\n-int CConnman::GetExtraFullOutboundCount()\n+int CConnman::GetExtraFullOutboundCount() const\n {\n     int full_outbound_peers = 0;\n     {\n@@ -1763,7 +1763,7 @@ int CConnman::GetExtraFullOutboundCount()\n     return std::max(full_outbound_peers - m_max_outbound_full_relay, 0);\n }\n \n-int CConnman::GetExtraBlockRelayCount()\n+int CConnman::GetExtraBlockRelayCount() const\n {\n     int block_relay_peers = 0;\n     {\n@@ -2061,7 +2061,7 @@ std::vector<CAddress> CConnman::GetCurrentBlockRelayOnlyConns() const\n     return ret;\n }\n \n-std::vector<AddedNodeInfo> CConnman::GetAddedNodeInfo()\n+std::vector<AddedNodeInfo> CConnman::GetAddedNodeInfo() const\n {\n     std::vector<AddedNodeInfo> ret;\n \n@@ -2635,23 +2635,26 @@ void CConnman::StopNodes()\n         }\n     }\n \n-    // Close sockets\n-    LOCK(cs_vNodes);\n-    for (CNode* pnode : vNodes)\n+    // Delete peer connections.\n+    std::vector<CNode*> nodes;\n+    WITH_LOCK(cs_vNodes, nodes.swap(vNodes));\n+    for (CNode* pnode : nodes) {\n         pnode->CloseSocketDisconnect();\n-    for (ListenSocket& hListenSocket : vhListenSocket)\n-        if (hListenSocket.socket != INVALID_SOCKET)\n-            if (!CloseSocket(hListenSocket.socket))\n-                LogPrintf(\"CloseSocket(hListenSocket) failed with error %s\\n\", NetworkErrorString(WSAGetLastError()));\n-\n-    // clean up some globals (to help leak detection)\n-    for (CNode* pnode : vNodes) {\n         DeleteNode(pnode);\n     }\n+\n+    // Close listening sockets.\n+    for (ListenSocket& hListenSocket : vhListenSocket) {\n+        if (hListenSocket.socket != INVALID_SOCKET) {\n+            if (!CloseSocket(hListenSocket.socket)) {\n+                LogPrintf(\"CloseSocket(hListenSocket) failed with error %s\\n\", NetworkErrorString(WSAGetLastError()));\n+            }\n+        }\n+    }\n+\n     for (CNode* pnode : vNodesDisconnected) {\n         DeleteNode(pnode);\n     }\n-    vNodes.clear();\n     vNodesDisconnected.clear();\n     vhListenSocket.clear();\n     semOutbound.reset();\n@@ -2671,7 +2674,7 @@ CConnman::~CConnman()\n     Stop();\n }\n \n-std::vector<CAddress> CConnman::GetAddresses(size_t max_addresses, size_t max_pct)\n+std::vector<CAddress> CConnman::GetAddresses(size_t max_addresses, size_t max_pct) const\n {\n     std::vector<CAddress> addresses = addrman.GetAddr(max_addresses, max_pct);\n     if (m_banman) {\n@@ -2746,7 +2749,7 @@ bool CConnman::RemoveAddedNode(const std::string& strNode)\n     return false;\n }\n \n-size_t CConnman::GetNodeCount(ConnectionDirection flags)\n+size_t CConnman::GetNodeCount(ConnectionDirection flags) const\n {\n     LOCK(cs_vNodes);\n     if (flags == ConnectionDirection::Both) // Shortcut if we want total\n@@ -2762,7 +2765,7 @@ size_t CConnman::GetNodeCount(ConnectionDirection flags)\n     return nNum;\n }\n \n-void CConnman::GetNodeStats(std::vector<CNodeStats>& vstats)\n+void CConnman::GetNodeStats(std::vector<CNodeStats>& vstats) const\n {\n     vstats.clear();\n     LOCK(cs_vNodes);\n@@ -2839,18 +2842,18 @@ void CConnman::RecordBytesSent(uint64_t bytes)\n     nMaxOutboundTotalBytesSentInCycle += bytes;\n }\n \n-uint64_t CConnman::GetMaxOutboundTarget()\n+uint64_t CConnman::GetMaxOutboundTarget() const\n {\n     LOCK(cs_totalBytesSent);\n     return nMaxOutboundLimit;\n }\n \n-std::chrono::seconds CConnman::GetMaxOutboundTimeframe()\n+std::chrono::seconds CConnman::GetMaxOutboundTimeframe() const\n {\n     return MAX_UPLOAD_TIMEFRAME;\n }\n \n-std::chrono::seconds CConnman::GetMaxOutboundTimeLeftInCycle()\n+std::chrono::seconds CConnman::GetMaxOutboundTimeLeftInCycle() const\n {\n     LOCK(cs_totalBytesSent);\n     if (nMaxOutboundLimit == 0)\n@@ -2864,7 +2867,7 @@ std::chrono::seconds CConnman::GetMaxOutboundTimeLeftInCycle()\n     return (cycleEndTime < now) ? 0s : cycleEndTime - now;\n }\n \n-bool CConnman::OutboundTargetReached(bool historicalBlockServingLimit)\n+bool CConnman::OutboundTargetReached(bool historicalBlockServingLimit) const\n {\n     LOCK(cs_totalBytesSent);\n     if (nMaxOutboundLimit == 0)\n@@ -2884,7 +2887,7 @@ bool CConnman::OutboundTargetReached(bool historicalBlockServingLimit)\n     return false;\n }\n \n-uint64_t CConnman::GetOutboundTargetBytesLeft()\n+uint64_t CConnman::GetOutboundTargetBytesLeft() const\n {\n     LOCK(cs_totalBytesSent);\n     if (nMaxOutboundLimit == 0)\n@@ -2893,13 +2896,13 @@ uint64_t CConnman::GetOutboundTargetBytesLeft()\n     return (nMaxOutboundTotalBytesSentInCycle >= nMaxOutboundLimit) ? 0 : nMaxOutboundLimit - nMaxOutboundTotalBytesSentInCycle;\n }\n \n-uint64_t CConnman::GetTotalBytesRecv()\n+uint64_t CConnman::GetTotalBytesRecv() const\n {\n     LOCK(cs_totalBytesRecv);\n     return nTotalBytesRecv;\n }\n \n-uint64_t CConnman::GetTotalBytesSent()\n+uint64_t CConnman::GetTotalBytesSent() const\n {\n     LOCK(cs_totalBytesSent);\n     return nTotalBytesSent;"
      },
      {
        "sha": "6b9a7ef1366139648f169403bb1deb9b672e6308",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -923,7 +923,7 @@ class CConnman\n     };\n \n     // Addrman functions\n-    std::vector<CAddress> GetAddresses(size_t max_addresses, size_t max_pct);\n+    std::vector<CAddress> GetAddresses(size_t max_addresses, size_t max_pct) const;\n     /**\n      * Cache is used to minimize topology leaks, so it should\n      * be used for all non-trusted calls, for example, p2p.\n@@ -935,7 +935,7 @@ class CConnman\n     // This allows temporarily exceeding m_max_outbound_full_relay, with the goal of finding\n     // a peer that is better than all our current peers.\n     void SetTryNewOutboundPeer(bool flag);\n-    bool GetTryNewOutboundPeer();\n+    bool GetTryNewOutboundPeer() const;\n \n     void StartExtraBlockRelayPeers() {\n         LogPrint(BCLog::NET, \"net: enabling extra block-relay-only peers\\n\");\n@@ -948,13 +948,13 @@ class CConnman\n     // return a value less than (num_outbound_connections - num_outbound_slots)\n     // in cases where some outbound connections are not yet fully connected, or\n     // not yet fully disconnected.\n-    int GetExtraFullOutboundCount();\n+    int GetExtraFullOutboundCount() const;\n     // Count the number of block-relay-only peers we have over our limit.\n-    int GetExtraBlockRelayCount();\n+    int GetExtraBlockRelayCount() const;\n \n     bool AddNode(const std::string& node);\n     bool RemoveAddedNode(const std::string& node);\n-    std::vector<AddedNodeInfo> GetAddedNodeInfo();\n+    std::vector<AddedNodeInfo> GetAddedNodeInfo() const;\n \n     /**\n      * Attempts to open a connection. Currently only used from tests.\n@@ -969,8 +969,8 @@ class CConnman\n      */\n     bool AddConnection(const std::string& address, ConnectionType conn_type);\n \n-    size_t GetNodeCount(ConnectionDirection);\n-    void GetNodeStats(std::vector<CNodeStats>& vstats);\n+    size_t GetNodeCount(ConnectionDirection) const;\n+    void GetNodeStats(std::vector<CNodeStats>& vstats) const;\n     bool DisconnectNode(const std::string& node);\n     bool DisconnectNode(const CSubNet& subnet);\n     bool DisconnectNode(const CNetAddr& addr);\n@@ -984,24 +984,24 @@ class CConnman\n     //! that peer during `net_processing.cpp:PushNodeVersion()`.\n     ServiceFlags GetLocalServices() const;\n \n-    uint64_t GetMaxOutboundTarget();\n-    std::chrono::seconds GetMaxOutboundTimeframe();\n+    uint64_t GetMaxOutboundTarget() const;\n+    std::chrono::seconds GetMaxOutboundTimeframe() const;\n \n     //! check if the outbound target is reached\n     //! if param historicalBlockServingLimit is set true, the function will\n     //! response true if the limit for serving historical blocks has been reached\n-    bool OutboundTargetReached(bool historicalBlockServingLimit);\n+    bool OutboundTargetReached(bool historicalBlockServingLimit) const;\n \n     //! response the bytes left in the current max outbound cycle\n     //! in case of no limit, it will always response 0\n-    uint64_t GetOutboundTargetBytesLeft();\n+    uint64_t GetOutboundTargetBytesLeft() const;\n \n     //! returns the time left in the current max outbound cycle\n     //! in case of no limit, it will always return 0\n-    std::chrono::seconds GetMaxOutboundTimeLeftInCycle();\n+    std::chrono::seconds GetMaxOutboundTimeLeftInCycle() const;\n \n-    uint64_t GetTotalBytesRecv();\n-    uint64_t GetTotalBytesSent();\n+    uint64_t GetTotalBytesRecv() const;\n+    uint64_t GetTotalBytesSent() const;\n \n     /** Get a unique deterministic randomizer. */\n     CSipHasher GetDeterministicRandomizer(uint64_t id) const;\n@@ -1106,8 +1106,8 @@ class CConnman\n     static bool NodeFullyConnected(const CNode* pnode);\n \n     // Network usage totals\n-    RecursiveMutex cs_totalBytesRecv;\n-    RecursiveMutex cs_totalBytesSent;\n+    mutable RecursiveMutex cs_totalBytesRecv;\n+    mutable RecursiveMutex cs_totalBytesSent;\n     uint64_t nTotalBytesRecv GUARDED_BY(cs_totalBytesRecv) {0};\n     uint64_t nTotalBytesSent GUARDED_BY(cs_totalBytesSent) {0};\n \n@@ -1133,7 +1133,7 @@ class CConnman\n     std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n     RecursiveMutex m_addr_fetches_mutex;\n     std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);\n-    RecursiveMutex cs_vAddedNodes;\n+    mutable RecursiveMutex cs_vAddedNodes;\n     std::vector<CNode*> vNodes GUARDED_BY(cs_vNodes);\n     std::list<CNode*> vNodesDisconnected;\n     mutable RecursiveMutex cs_vNodes;"
      },
      {
        "sha": "2201caf7d2196543d4594e37714f84b90e5e6beb",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -246,7 +246,7 @@ class PeerManagerImpl final : public PeerManager\n \n     /** Implement PeerManager */\n     void CheckForStaleTipAndEvictPeers() override;\n-    bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) override;\n+    bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) const override;\n     bool IgnoresIncomingTxs() override { return m_ignore_incoming_txs; }\n     void SendPings() override;\n     void RelayTransaction(const uint256& txid, const uint256& wtxid) override;\n@@ -1103,7 +1103,7 @@ PeerRef PeerManagerImpl::RemovePeer(NodeId id)\n     return ret;\n }\n \n-bool PeerManagerImpl::GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats)\n+bool PeerManagerImpl::GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) const\n {\n     {\n         LOCK(cs_main);"
      },
      {
        "sha": "67252acbb6b56c5a32086a7f517e0fdb80e03b8b",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -43,7 +43,7 @@ class PeerManager : public CValidationInterface, public NetEventsInterface\n     virtual ~PeerManager() { }\n \n     /** Get statistics from node state */\n-    virtual bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) = 0;\n+    virtual bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) const = 0;\n \n     /** Whether this node ignores txs received over p2p. */\n     virtual bool IgnoresIncomingTxs() = 0;"
      },
      {
        "sha": "d56ae78e92ecd7e0169e525764039ce04648d465",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -551,6 +551,11 @@ enum Network CNetAddr::GetNetwork() const\n     return m_net;\n }\n \n+static std::string IPv4ToString(Span<const uint8_t> a)\n+{\n+    return strprintf(\"%u.%u.%u.%u\", a[0], a[1], a[2], a[3]);\n+}\n+\n static std::string IPv6ToString(Span<const uint8_t> a)\n {\n     assert(a.size() == ADDR_IPV6_SIZE);\n@@ -571,6 +576,7 @@ std::string CNetAddr::ToStringIP() const\n {\n     switch (m_net) {\n     case NET_IPV4:\n+        return IPv4ToString(m_addr);\n     case NET_IPV6: {\n         CService serv(*this, 0);\n         struct sockaddr_storage sockaddr;\n@@ -581,9 +587,6 @@ std::string CNetAddr::ToStringIP() const\n                              sizeof(name), nullptr, 0, NI_NUMERICHOST))\n                 return std::string(name);\n         }\n-        if (m_net == NET_IPV4) {\n-            return strprintf(\"%u.%u.%u.%u\", m_addr[0], m_addr[1], m_addr[2], m_addr[3]);\n-        }\n         return IPv6ToString(m_addr);\n     }\n     case NET_ONION:"
      },
      {
        "sha": "06adb33a80e9ac6f98c641d9287d39c7597e45fc",
        "filename": "src/node/context.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/node/context.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/node/context.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/context.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -22,6 +22,7 @@ class PeerManager;\n namespace interfaces {\n class Chain;\n class ChainClient;\n+class Init;\n class WalletClient;\n } // namespace interfaces\n \n@@ -36,6 +37,8 @@ class WalletClient;\n //! any member functions. It should just be a collection of references that can\n //! be used without pulling in unwanted dependencies or functionality.\n struct NodeContext {\n+    //! Init interface for initializing current process and connecting to other processes.\n+    interfaces::Init* init{nullptr};\n     std::unique_ptr<CAddrMan> addrman;\n     std::unique_ptr<CConnman> connman;\n     std::unique_ptr<CTxMemPool> mempool;"
      },
      {
        "sha": "a816a0764c0bc1f9686b93f6dff27b34ddab8904",
        "filename": "src/qt/addressbookpage.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 22,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/addressbookpage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/addressbookpage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addressbookpage.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -112,29 +112,17 @@ AddressBookPage::AddressBookPage(const PlatformStyle *platformStyle, Mode _mode,\n         break;\n     }\n \n-    // Context menu actions\n-    QAction *copyAddressAction = new QAction(tr(\"&Copy Address\"), this);\n-    QAction *copyLabelAction = new QAction(tr(\"Copy &Label\"), this);\n-    QAction *editAction = new QAction(tr(\"&Edit\"), this);\n-    deleteAction = new QAction(ui->deleteAddress->text(), this);\n-\n     // Build context menu\n     contextMenu = new QMenu(this);\n-    contextMenu->addAction(copyAddressAction);\n-    contextMenu->addAction(copyLabelAction);\n-    contextMenu->addAction(editAction);\n-    if(tab == SendingTab)\n-        contextMenu->addAction(deleteAction);\n-    contextMenu->addSeparator();\n-\n-    // Connect signals for context menu actions\n-    connect(copyAddressAction, &QAction::triggered, this, &AddressBookPage::on_copyAddress_clicked);\n-    connect(copyLabelAction, &QAction::triggered, this, &AddressBookPage::onCopyLabelAction);\n-    connect(editAction, &QAction::triggered, this, &AddressBookPage::onEditAction);\n-    connect(deleteAction, &QAction::triggered, this, &AddressBookPage::on_deleteAddress_clicked);\n+    contextMenu->addAction(tr(\"Copy Address\"), this, &AddressBookPage::on_copyAddress_clicked);\n+    contextMenu->addAction(tr(\"Copy Label\"), this, &AddressBookPage::onCopyLabelAction);\n+    contextMenu->addAction(tr(\"Edit\"), this, &AddressBookPage::onEditAction);\n \n-    connect(ui->tableView, &QWidget::customContextMenuRequested, this, &AddressBookPage::contextualMenu);\n+    if (tab == SendingTab) {\n+        contextMenu->addAction(tr(\"Delete\"), this, &AddressBookPage::on_deleteAddress_clicked);\n+    }\n \n+    connect(ui->tableView, &QWidget::customContextMenuRequested, this, &AddressBookPage::contextualMenu);\n     connect(ui->closeButton, &QPushButton::clicked, this, &QDialog::accept);\n \n     GUIUtil::handleCloseWindowShortcut(this);\n@@ -249,13 +237,11 @@ void AddressBookPage::selectionChanged()\n             // In sending tab, allow deletion of selection\n             ui->deleteAddress->setEnabled(true);\n             ui->deleteAddress->setVisible(true);\n-            deleteAction->setEnabled(true);\n             break;\n         case ReceivingTab:\n             // Deleting receiving addresses, however, is not allowed\n             ui->deleteAddress->setEnabled(false);\n             ui->deleteAddress->setVisible(false);\n-            deleteAction->setEnabled(false);\n             break;\n         }\n         ui->copyAddress->setEnabled(true);\n@@ -309,7 +295,8 @@ void AddressBookPage::on_exportButton_clicked()\n \n     if(!writer.write()) {\n         QMessageBox::critical(this, tr(\"Exporting Failed\"),\n-            tr(\"There was an error trying to save the address list to %1. Please try again.\").arg(filename));\n+            //: %1 is a name of the file (e.g., \"addrbook.csv\") that the bitcoin addresses were exported to.\n+            tr(\"There was an error trying to save the address list to %1. Please try again.\", \"An error message.\").arg(filename));\n     }\n }\n "
      },
      {
        "sha": "93feac9e2365e63277ccee6a9dc538e53af0e605",
        "filename": "src/qt/addressbookpage.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/addressbookpage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/addressbookpage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addressbookpage.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -55,7 +55,6 @@ public Q_SLOTS:\n     QString returnValue;\n     AddressBookSortFilterProxyModel *proxyModel;\n     QMenu *contextMenu;\n-    QAction *deleteAction; // to be able to explicitly disable it\n     QString newAddressToSelect;\n \n private Q_SLOTS:"
      },
      {
        "sha": "3e29d8e1326e54ce472de2f2770aca78e6533c39",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -1468,11 +1468,8 @@ void UnitDisplayStatusBarControl::mousePressEvent(QMouseEvent *event)\n void UnitDisplayStatusBarControl::createContextMenu()\n {\n     menu = new QMenu(this);\n-    for (const BitcoinUnits::Unit u : BitcoinUnits::availableUnits())\n-    {\n-        QAction *menuAction = new QAction(QString(BitcoinUnits::longName(u)), this);\n-        menuAction->setData(QVariant(u));\n-        menu->addAction(menuAction);\n+    for (const BitcoinUnits::Unit u : BitcoinUnits::availableUnits()) {\n+        menu->addAction(BitcoinUnits::longName(u))->setData(QVariant(u));\n     }\n     connect(menu, &QMenu::triggered, this, &UnitDisplayStatusBarControl::onMenuSelection);\n }"
      },
      {
        "sha": "ab631459fbb3e3bc721f922b7b526417315e913e",
        "filename": "src/qt/bitcoinstrings.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 8,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/bitcoinstrings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/bitcoinstrings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinstrings.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -17,31 +17,53 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"-maxtxfee is set very high! Fees this large could be paid on a single \"\n \"transaction.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Cannot downgrade wallet from version %i to version %i. Wallet version \"\n+\"unchanged.\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Cannot obtain a lock on data directory %s. %s is probably already running.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Cannot provide specific connections and have addrman find outgoing \"\n \"connections at the same.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"Cannot upgrade a non HD split wallet without upgrading to support pre split \"\n-\"keypool. Please use version 169900 or no version specified.\"),\n+\"Cannot upgrade a non HD split wallet from version %i to version %i without \"\n+\"upgrading to support pre-split keypool. Please use version %i or no version \"\n+\"specified.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Distributed under the MIT software license, see the accompanying file %s or \"\n \"%s\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Error reading %s! All keys read correctly, but transaction data or address \"\n \"book entries might be missing or incorrect.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Error: Dumpfile format record is incorrect. Got \\\"%s\\\", expected \\\"format\\\".\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Error: Dumpfile identifier record is incorrect. Got \\\"%s\\\", expected \\\"%s\\\".\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Error: Dumpfile version is not supported. This version of bitcoin-wallet \"\n+\"only supports version 1 dumpfiles. Got dumpfile with version %s\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Error: Listening for incoming connections failed (listen returned error %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -\"\n \"fallbackfee.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"File %s already exists. If you are sure this is what you want, move it out \"\n+\"of the way first.\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Invalid amount for -maxtxfee=<amount>: '%s' (must be at least the minrelay \"\n \"fee of %s to prevent stuck transactions)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"More than one onion bind address is provided. Using %s for the automatically \"\n \"created Tor onion service.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"No dump file provided. To use createfromdump, -dumpfile=<filename> must be \"\n+\"provided.\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"No dump file provided. To use dump, -dumpfile=<filename> must be provided.\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"No wallet file format provided. To use createfromdump, -format=<format> must \"\n+\"be provided.\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Please check that your computer's date and time are correct! If your clock \"\n \"is wrong, %s will not work properly.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n@@ -96,10 +118,13 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Unable to rewind the database to a pre-fork state. You will need to \"\n \"redownload the blockchain\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"Warning: Private keys detected in wallet {%s} with disabled private keys\"),\n+\"Unknown wallet file format \\\"%s\\\" provided. Please provide one of \\\"bdb\\\" or \"\n+\"\\\"sqlite\\\".\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"Warning: The network does not appear to fully agree! Some miners appear to \"\n-\"be experiencing issues.\"),\n+\"Warning: Dumpfile wallet format \\\"%s\\\" does not match command line specified \"\n+\"format \\\"%s\\\".\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Warning: Private keys detected in wallet {%s} with disabled private keys\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Warning: We do not appear to fully agree with our peers! You may need to \"\n \"upgrade, or other nodes may need to upgrade.\"),\n@@ -109,7 +134,6 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"%s is set very high!\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"-maxmempool must be at least %d MB\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"A fatal internal error occurred, see debug.log for details\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Cannot downgrade wallet\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Cannot resolve -%s address: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Cannot set -peerblockfilters without -blockfilterindex.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Cannot write to data directory '%s'; check permissions.\"),\n@@ -122,6 +146,8 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Could not parse asmap file %s\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Disk space is too low!\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Do you want to rebuild the block database now?\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Done loading\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Dump file %s does not exist.\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error creating %s\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error initializing block database\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error initializing wallet database environment %s!\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading %s\"),\n@@ -131,9 +157,17 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading %s: Wallet requires newer versi\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading block database\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error opening block database\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error reading from database, shutting down.\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error reading next record from wallet database\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error upgrading chainstate database\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error: Couldn't create cursor into database\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error: Disk space is low for %s\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error: Dumpfile checksum does not match. Computed %s, expected %s\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error: Got key that was not hex: %s\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error: Got value that was not hex: %s\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error: Keypool ran out, please call keypoolrefill first\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error: Missing checksum\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error: Unable to parse version %u as a uint32_t\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error: Unable to write record to new wallet\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Failed to listen on any port. Use -listen=0 if you want this.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Failed to rescan the wallet during initialization\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Failed to verify database\"),\n@@ -143,6 +177,7 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Importing...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Incorrect or no genesis block found. Wrong datadir for network?\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Initialization sanity check failed. %s is shutting down.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Insufficient funds\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid -i2psam address or hostname: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid -onion address or hostname: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid -proxy address or hostname: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid P2P permission: '%s'\"),\n@@ -159,7 +194,6 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Need to specify a port with -whitebind: '%s'\"\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"No proxy server specified. Use -proxy=<ip> or -proxy=<ip:port>.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Not enough file descriptors available.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Prune cannot be configured with a negative value.\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Prune mode is incompatible with -blockfilterindex.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Prune mode is incompatible with -txindex.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Pruning blockstore...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Reducing -maxconnections from %d to %d, because of system limitations.\"),\n@@ -180,7 +214,7 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Specified -walletdir \\\"%s\\\" is not a director\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Specified blocks directory \\\"%s\\\" does not exist.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Starting network threads...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"The source code is available from %s.\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"The specified config file %s does not exist\\n\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"The specified config file %s does not exist\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"The transaction amount is too small to pay the fee\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"The wallet will avoid paying less than the minimum relay fee.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"This is experimental software.\"),\n@@ -197,6 +231,7 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unable to bind to %s on this computer. %s is\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unable to create the PID file '%s': %s\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unable to generate initial keys\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unable to generate keys\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unable to open %s for writing\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unable to start HTTP server. See debug log for details.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unknown -blockfilterindex value %s.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unknown address type '%s'\"),"
      },
      {
        "sha": "04161020b2763dda523fa91a0658b1e81e9357bb",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -8,6 +8,7 @@\n #include <qt/guiconstants.h>\n #include <qt/guiutil.h>\n #include <qt/peertablemodel.h>\n+#include <qt/peertablesortproxy.h>\n \n #include <clientversion.h>\n #include <interfaces/handler.h>\n@@ -38,7 +39,11 @@ ClientModel::ClientModel(interfaces::Node& node, OptionsModel *_optionsModel, QO\n {\n     cachedBestHeaderHeight = -1;\n     cachedBestHeaderTime = -1;\n+\n     peerTableModel = new PeerTableModel(m_node, this);\n+    m_peer_table_sort_proxy = new PeerTableSortProxy(this);\n+    m_peer_table_sort_proxy->setSourceModel(peerTableModel);\n+\n     banTableModel = new BanTableModel(m_node, this);\n \n     QTimer* timer = new QTimer;\n@@ -184,6 +189,11 @@ PeerTableModel *ClientModel::getPeerTableModel()\n     return peerTableModel;\n }\n \n+PeerTableSortProxy* ClientModel::peerTableSortProxy()\n+{\n+    return m_peer_table_sort_proxy;\n+}\n+\n BanTableModel *ClientModel::getBanTableModel()\n {\n     return banTableModel;\n@@ -216,7 +226,7 @@ QString ClientModel::dataDir() const\n \n QString ClientModel::blocksDir() const\n {\n-    return GUIUtil::boostPathToQString(GetBlocksDir());\n+    return GUIUtil::boostPathToQString(gArgs.GetBlocksDirPath());\n }\n \n void ClientModel::updateBanlist()"
      },
      {
        "sha": "7a199ef19cbde5dc3c3131ed999b53a38f389f5b",
        "filename": "src/qt/clientmodel.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/clientmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/clientmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -17,6 +17,7 @@ class BanTableModel;\n class CBlockIndex;\n class OptionsModel;\n class PeerTableModel;\n+class PeerTableSortProxy;\n enum class SynchronizationState;\n \n namespace interfaces {\n@@ -54,6 +55,7 @@ class ClientModel : public QObject\n     interfaces::Node& node() const { return m_node; }\n     OptionsModel *getOptionsModel();\n     PeerTableModel *getPeerTableModel();\n+    PeerTableSortProxy* peerTableSortProxy();\n     BanTableModel *getBanTableModel();\n \n     //! Return number of connections, default is in- and outbound (total)\n@@ -96,6 +98,7 @@ class ClientModel : public QObject\n     std::unique_ptr<interfaces::Handler> m_handler_notify_header_tip;\n     OptionsModel *optionsModel;\n     PeerTableModel *peerTableModel;\n+    PeerTableSortProxy* m_peer_table_sort_proxy{nullptr};\n     BanTableModel *banTableModel;\n \n     //! A thread to interact with m_node asynchronously"
      },
      {
        "sha": "daea2f9cab92806001434990e37159ddb2118656",
        "filename": "src/qt/coincontroldialog.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 22,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/coincontroldialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/coincontroldialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -50,32 +50,16 @@ CoinControlDialog::CoinControlDialog(CCoinControl& coin_control, WalletModel* _m\n {\n     ui->setupUi(this);\n \n-    // context menu actions\n-    QAction *copyAddressAction = new QAction(tr(\"Copy address\"), this);\n-    QAction *copyLabelAction = new QAction(tr(\"Copy label\"), this);\n-    QAction *copyAmountAction = new QAction(tr(\"Copy amount\"), this);\n-             copyTransactionHashAction = new QAction(tr(\"Copy transaction ID\"), this);  // we need to enable/disable this\n-             lockAction = new QAction(tr(\"Lock unspent\"), this);                        // we need to enable/disable this\n-             unlockAction = new QAction(tr(\"Unlock unspent\"), this);                    // we need to enable/disable this\n-\n     // context menu\n     contextMenu = new QMenu(this);\n-    contextMenu->addAction(copyAddressAction);\n-    contextMenu->addAction(copyLabelAction);\n-    contextMenu->addAction(copyAmountAction);\n-    contextMenu->addAction(copyTransactionHashAction);\n+    contextMenu->addAction(tr(\"Copy address\"), this, &CoinControlDialog::copyAddress);\n+    contextMenu->addAction(tr(\"Copy label\"), this, &CoinControlDialog::copyLabel);\n+    contextMenu->addAction(tr(\"Copy amount\"), this, &CoinControlDialog::copyAmount);\n+    copyTransactionHashAction = contextMenu->addAction(tr(\"Copy transaction ID\"), this, &CoinControlDialog::copyTransactionHash);\n     contextMenu->addSeparator();\n-    contextMenu->addAction(lockAction);\n-    contextMenu->addAction(unlockAction);\n-\n-    // context menu signals\n+    lockAction = contextMenu->addAction(tr(\"Lock unspent\"), this, &CoinControlDialog::lockCoin);\n+    unlockAction = contextMenu->addAction(tr(\"Unlock unspent\"), this, &CoinControlDialog::unlockCoin);\n     connect(ui->treeWidget, &QWidget::customContextMenuRequested, this, &CoinControlDialog::showMenu);\n-    connect(copyAddressAction, &QAction::triggered, this, &CoinControlDialog::copyAddress);\n-    connect(copyLabelAction, &QAction::triggered, this, &CoinControlDialog::copyLabel);\n-    connect(copyAmountAction, &QAction::triggered, this, &CoinControlDialog::copyAmount);\n-    connect(copyTransactionHashAction, &QAction::triggered, this, &CoinControlDialog::copyTransactionHash);\n-    connect(lockAction, &QAction::triggered, this, &CoinControlDialog::lockCoin);\n-    connect(unlockAction, &QAction::triggered, this, &CoinControlDialog::unlockCoin);\n \n     // clipboard actions\n     QAction *clipboardQuantityAction = new QAction(tr(\"Copy quantity\"), this);"
      },
      {
        "sha": "e2640c88848ca6aa8a317f2c1047fca1ffca83e3",
        "filename": "src/qt/locale/bitcoin_en.ts",
        "status": "modified",
        "additions": 610,
        "deletions": 306,
        "changes": 916,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/locale/bitcoin_en.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/locale/bitcoin_en.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_en.ts?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -116,17 +116,20 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n     </message>\n     <message>\n         <location line=\"+1\"/>\n-        <source>Comma separated file (*.csv)</source>\n+        <source>Comma separated file</source>\n+        <comment>Name of CSV file format</comment>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+13\"/>\n-        <source>Exporting Failed</source>\n+        <location line=\"+15\"/>\n+        <source>There was an error trying to save the address list to %1. Please try again.</source>\n+        <comment>An error message.</comment>\n+        <extracomment>%1 is a name of the file (e.g., &quot;addrbook.csv&quot;) that the bitcoin addresses were exported to.</extracomment>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+1\"/>\n-        <source>There was an error trying to save the address list to %1. Please try again.</source>\n+        <location line=\"-2\"/>\n+        <source>Exporting Failed</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n </context>\n@@ -143,7 +146,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+36\"/>\n+        <location line=\"+38\"/>\n         <source>(no label)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -190,16 +193,6 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <source>Unlock wallet</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n-    <message>\n-        <location line=\"+3\"/>\n-        <source>This operation needs your wallet passphrase to decrypt the wallet.</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+5\"/>\n-        <source>Decrypt wallet</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n     <message>\n         <location line=\"+3\"/>\n         <source>Change passphrase</source>\n@@ -221,18 +214,18 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+19\"/>\n-        <location line=\"+57\"/>\n+        <location line=\"+18\"/>\n+        <location line=\"+44\"/>\n         <source>Wallet encrypted</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-147\"/>\n+        <location line=\"-125\"/>\n         <source>Enter the new passphrase for the wallet.&lt;br/&gt;Please use a passphrase of &lt;b&gt;ten or more random characters&lt;/b&gt;, or &lt;b&gt;eight or more words&lt;/b&gt;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+23\"/>\n+        <location line=\"+15\"/>\n         <source>Enter the old passphrase and new passphrase for the wallet.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -252,7 +245,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+8\"/>\n+        <location line=\"+7\"/>\n         <source>Your wallet is now encrypted. </source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -262,49 +255,43 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n+        <location line=\"+6\"/>\n         <location line=\"+8\"/>\n-        <location line=\"+8\"/>\n-        <location line=\"+43\"/>\n+        <location line=\"+32\"/>\n         <location line=\"+6\"/>\n         <source>Wallet encryption failed</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-56\"/>\n+        <location line=\"-45\"/>\n         <source>Wallet encryption failed due to an internal error. Your wallet was not encrypted.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n         <location line=\"+8\"/>\n-        <location line=\"+49\"/>\n+        <location line=\"+38\"/>\n         <source>The supplied passphrases do not match.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-38\"/>\n+        <location line=\"-27\"/>\n         <location line=\"+6\"/>\n         <source>Wallet unlock failed</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n         <location line=\"-5\"/>\n-        <location line=\"+12\"/>\n-        <location line=\"+19\"/>\n+        <location line=\"+20\"/>\n         <source>The passphrase entered for the wallet decryption was incorrect.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-20\"/>\n-        <source>Wallet decryption failed</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+14\"/>\n+        <location line=\"-6\"/>\n         <source>Wallet passphrase was successfully changed.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+47\"/>\n+        <location line=\"+46\"/>\n         <location line=\"+33\"/>\n         <source>Warning: The Caps Lock key is on!</source>\n         <translation type=\"unfinished\"></translation>\n@@ -313,7 +300,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n <context>\n     <name>BanTableModel</name>\n     <message>\n-        <location filename=\"../bantablemodel.cpp\" line=\"+86\"/>\n+        <location filename=\"../bantablemodel.cpp\" line=\"+85\"/>\n         <source>IP/Netmask</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -323,20 +310,43 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n </context>\n+<context>\n+    <name>BitcoinApplication</name>\n+    <message>\n+        <location filename=\"../bitcoin.cpp\" line=\"+423\"/>\n+        <source>Runaway exception</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+1\"/>\n+        <source>A fatal error occurred. %1 can no longer continue safely and will quit.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+9\"/>\n+        <source>Internal error</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+1\"/>\n+        <source>An internal error occurred. %1 will attempt to continue safely. This is an unexpected bug which can be reported as described below.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+</context>\n <context>\n     <name>BitcoinGUI</name>\n     <message>\n-        <location filename=\"../bitcoingui.cpp\" line=\"+322\"/>\n+        <location filename=\"../bitcoingui.cpp\" line=\"+325\"/>\n         <source>Sign &amp;message...</source>\n         <translation>Sign &amp;message...</translation>\n     </message>\n     <message>\n-        <location line=\"+669\"/>\n+        <location line=\"+668\"/>\n         <source>Synchronizing with network...</source>\n         <translation>Synchronizing with network...</translation>\n     </message>\n     <message>\n-        <location line=\"-747\"/>\n+        <location line=\"-746\"/>\n         <source>&amp;Overview</source>\n         <translation>&amp;Overview</translation>\n     </message>\n@@ -426,7 +436,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+210\"/>\n+        <location line=\"+209\"/>\n         <source>Wallet:</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -461,7 +471,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-1065\"/>\n+        <location line=\"-1064\"/>\n         <source>Send coins to a Bitcoin address</source>\n         <translation>Send coins to a Bitcoin address</translation>\n     </message>\n@@ -556,7 +566,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message numerus=\"yes\">\n-        <location line=\"+556\"/>\n+        <location line=\"+555\"/>\n         <source>%n active connection(s) to Bitcoin network</source>\n         <translation>\n             <numerusform>%n active connection to Bitcoin network</numerusform>\n@@ -617,7 +627,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation>Up to date</translation>\n     </message>\n     <message>\n-        <location line=\"-695\"/>\n+        <location line=\"-694\"/>\n         <source>&amp;Load PSBT from file...</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -737,7 +747,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+246\"/>\n+        <location line=\"+245\"/>\n         <source>%1 client</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -833,15 +843,10 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation>Wallet is &lt;b&gt;encrypted&lt;/b&gt; and currently &lt;b&gt;locked&lt;/b&gt;</translation>\n     </message>\n     <message>\n-        <location line=\"+129\"/>\n+        <location line=\"+121\"/>\n         <source>Original message:</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n-    <message>\n-        <location filename=\"../bitcoin.cpp\" line=\"+418\"/>\n-        <source>A fatal error occurred. %1 can no longer continue safely and will quit.</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n </context>\n <context>\n     <name>CoinControlDialog</name>\n@@ -1036,7 +1041,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n <context>\n     <name>CreateWalletActivity</name>\n     <message>\n-        <location filename=\"../walletcontroller.cpp\" line=\"+241\"/>\n+        <location filename=\"../walletcontroller.cpp\" line=\"+250\"/>\n         <source>Creating Wallet &lt;b&gt;%1&lt;/b&gt;...</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -1059,12 +1064,17 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+38\"/>\n+        <location line=\"+11\"/>\n         <source>Wallet Name</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n         <location line=\"+13\"/>\n+        <source>Wallet</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+9\"/>\n         <source>Encrypt the wallet. The wallet will be encrypted with a passphrase of your choice.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -1074,7 +1084,12 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+19\"/>\n+        <location line=\"+26\"/>\n+        <source>Advanced Options</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+9\"/>\n         <source>Disable private keys for this wallet. Wallets with private keys disabled will have no private keys and cannot have an HD seed or imported private keys. This is ideal for watch-only wallets.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -1084,7 +1099,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+13\"/>\n+        <location line=\"+7\"/>\n         <source>Make a blank wallet. Blank wallets do not initially have private keys or scripts. Private keys and addresses can be imported, or an HD seed can be set, at a later time.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -1094,7 +1109,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+13\"/>\n+        <location line=\"+7\"/>\n         <source>Use descriptors for scriptPubKey management</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -1104,12 +1119,12 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location filename=\"../createwalletdialog.cpp\" line=\"+19\"/>\n+        <location filename=\"../createwalletdialog.cpp\" line=\"+21\"/>\n         <source>Create</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+20\"/>\n+        <location line=\"+42\"/>\n         <source>Compiled without sqlite support (required for descriptor wallets)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -1475,7 +1490,12 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+72\"/>\n+        <location line=\"+22\"/>\n+        <source>Enabling pruning significantly reduces the disk space required to store transactions. All blocks are still fully validated. Reverting this setting requires re-downloading the entire blockchain.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+50\"/>\n         <source>Size of &amp;database cache</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -1485,7 +1505,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+161\"/>\n+        <location line=\"+171\"/>\n         <location line=\"+187\"/>\n         <source>IP address of the proxy (e.g. IPv4: 127.0.0.1 / IPv6: ::1)</source>\n         <translation type=\"unfinished\"></translation>\n@@ -1498,17 +1518,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+146\"/>\n-        <source>Hide the icon from the system tray.</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+3\"/>\n-        <source>&amp;Hide tray icon</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+17\"/>\n+        <location line=\"+169\"/>\n         <source>Minimize instead of exit the application when the window is closed. When this option is enabled, the application will be closed only after selecting Exit in the menu.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -1519,7 +1529,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+79\"/>\n+        <location line=\"+179\"/>\n         <source>Open the %1 configuration file from the working directory.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -1539,17 +1549,12 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation>&amp;Reset Options</translation>\n     </message>\n     <message>\n-        <location line=\"-532\"/>\n+        <location line=\"-645\"/>\n         <source>&amp;Network</source>\n         <translation>&amp;Network</translation>\n     </message>\n     <message>\n-        <location line=\"-191\"/>\n-        <source>Disables some advanced features but all blocks will still be fully validated. Reverting this setting requires re-downloading the entire blockchain. Actual disk usage may be somewhat higher.</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+3\"/>\n+        <location line=\"-188\"/>\n         <source>Prune &amp;block storage to</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -1608,6 +1613,16 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <source>Map port using &amp;UPnP</source>\n         <translation>Map port using &amp;UPnP</translation>\n     </message>\n+    <message>\n+        <location line=\"+7\"/>\n+        <source>Automatically open the Bitcoin client port on the router. This only works when your router supports NAT-PMP and it is enabled. The external port could be random.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+3\"/>\n+        <source>Map port using NA&amp;T-PMP</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n     <message>\n         <location line=\"+7\"/>\n         <source>Accept connections from outside.</source>\n@@ -1672,7 +1687,17 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation>&amp;Window</translation>\n     </message>\n     <message>\n-        <location line=\"+16\"/>\n+        <location line=\"+6\"/>\n+        <source>Show the icon in the system tray.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+3\"/>\n+        <source>&amp;Show tray icon</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+10\"/>\n         <source>Show only a tray icon after minimizing the window.</source>\n         <translation>Show only a tray icon after minimizing the window.</translation>\n     </message>\n@@ -1712,12 +1737,12 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation>Choose the default subdivision unit to show in the interface and when sending coins.</translation>\n     </message>\n     <message>\n-        <location line=\"-450\"/>\n+        <location line=\"-463\"/>\n         <source>Whether to show coin control features or not.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+250\"/>\n+        <location line=\"+260\"/>\n         <source>Connect to the Bitcoin network through a separate SOCKS5 proxy for Tor onion services.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -1727,12 +1752,39 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+211\"/>\n+        <location line=\"+214\"/>\n         <source>&amp;Third party transaction URLs</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+44\"/>\n+        <location line=\"+22\"/>\n+        <source>Monospaced font in the Overview tab:</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+8\"/>\n+        <source>embedded &quot;%1&quot;</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+22\"/>\n+        <location line=\"+49\"/>\n+        <source>111.11111111 BTC</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"-42\"/>\n+        <location line=\"+49\"/>\n+        <source>909.09090909 BTC</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"-29\"/>\n+        <source>closest matching &quot;%1&quot;</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+65\"/>\n         <source>Options set in this dialog are overridden by the command line or in the configuration file:</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -1747,28 +1799,28 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation>&amp;Cancel</translation>\n     </message>\n     <message>\n-        <location filename=\"../optionsdialog.cpp\" line=\"+96\"/>\n+        <location filename=\"../optionsdialog.cpp\" line=\"+104\"/>\n         <source>default</source>\n         <translation>default</translation>\n     </message>\n     <message>\n-        <location line=\"+67\"/>\n+        <location line=\"+81\"/>\n         <source>none</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+89\"/>\n+        <location line=\"+91\"/>\n         <source>Confirm options reset</source>\n         <translation>Confirm options reset</translation>\n     </message>\n     <message>\n         <location line=\"+1\"/>\n-        <location line=\"+60\"/>\n+        <location line=\"+57\"/>\n         <source>Client restart required to activate changes.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-60\"/>\n+        <location line=\"-57\"/>\n         <source>Client will be shut down. Do you want to proceed?</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -1793,7 +1845,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+43\"/>\n+        <location line=\"+40\"/>\n         <source>This change would require a client restart.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -1812,12 +1864,12 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n     </message>\n     <message>\n         <location line=\"+62\"/>\n-        <location line=\"+394\"/>\n+        <location line=\"+335\"/>\n         <source>The displayed information may be out of date. Your wallet automatically synchronizes with the Bitcoin network after a connection is established, but this process has not completed yet.</source>\n         <translation>The displayed information may be out of date. Your wallet automatically synchronizes with the Bitcoin network after a connection is established, but this process has not completed yet.</translation>\n     </message>\n     <message>\n-        <location line=\"-141\"/>\n+        <location line=\"-127\"/>\n         <source>Watch-only:</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -1827,22 +1879,22 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+17\"/>\n+        <location line=\"+10\"/>\n         <source>Your current spendable balance</source>\n         <translation>Your current spendable balance</translation>\n     </message>\n     <message>\n-        <location line=\"+42\"/>\n+        <location line=\"+35\"/>\n         <source>Pending:</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-242\"/>\n+        <location line=\"-200\"/>\n         <source>Total of transactions that have yet to be confirmed, and do not yet count toward the spendable balance</source>\n         <translation>Total of transactions that have yet to be confirmed, and do not yet count toward the spendable balance</translation>\n     </message>\n     <message>\n-        <location line=\"+114\"/>\n+        <location line=\"+100\"/>\n         <source>Immature:</source>\n         <translation>Immature:</translation>\n     </message>\n@@ -1852,22 +1904,22 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation>Mined balance that has not yet matured</translation>\n     </message>\n     <message>\n-        <location line=\"-181\"/>\n+        <location line=\"-150\"/>\n         <source>Balances</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+164\"/>\n+        <location line=\"+140\"/>\n         <source>Total:</source>\n         <translation>Total:</translation>\n     </message>\n     <message>\n-        <location line=\"+63\"/>\n+        <location line=\"+49\"/>\n         <source>Your current total balance</source>\n         <translation>Your current total balance</translation>\n     </message>\n     <message>\n-        <location line=\"+95\"/>\n+        <location line=\"+74\"/>\n         <source>Your current balance in watch-only addresses</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -1882,22 +1934,22 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-324\"/>\n+        <location line=\"-275\"/>\n         <source>Unconfirmed transactions to watch-only addresses</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+52\"/>\n+        <location line=\"+38\"/>\n         <source>Mined balance in watch-only addresses that has not yet matured</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+131\"/>\n+        <location line=\"+110\"/>\n         <source>Current total balance in watch-only addresses</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location filename=\"../overviewpage.cpp\" line=\"+166\"/>\n+        <location filename=\"../overviewpage.cpp\" line=\"+191\"/>\n         <source>Privacy mode activated for the Overview tab. To unmask the values, uncheck Settings-&gt;Mask values.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -1986,7 +2038,8 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n     </message>\n     <message>\n         <location line=\"+1\"/>\n-        <source>Partially Signed Transaction (Binary) (*.psbt)</source>\n+        <source>Partially Signed Transaction (Binary)</source>\n+        <comment>Name of binary PSBT file format</comment>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n@@ -2058,7 +2111,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n <context>\n     <name>PaymentServer</name>\n     <message>\n-        <location filename=\"../paymentserver.cpp\" line=\"+174\"/>\n+        <location filename=\"../paymentserver.cpp\" line=\"+173\"/>\n         <source>Payment request error</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2083,23 +2136,13 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n     <message>\n         <location line=\"+14\"/>\n         <location line=\"+23\"/>\n-        <source>Cannot process payment request because BIP70 is not supported.</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"-22\"/>\n-        <location line=\"+23\"/>\n-        <source>Due to widespread security flaws in BIP70 it&apos;s strongly recommended that any merchant instructions to switch wallets be ignored.</source>\n+        <source>Cannot process payment request because BIP70 is not supported.\n+Due to widespread security flaws in BIP70 it&apos;s strongly recommended that any merchant instructions to switch wallets be ignored.\n+If you are receiving this error you should request the merchant provide a BIP21 compatible URI.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-22\"/>\n-        <location line=\"+23\"/>\n-        <source>If you are receiving this error you should request the merchant provide a BIP21 compatible URI.</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"-20\"/>\n+        <location line=\"-18\"/>\n         <source>Invalid payment address %1</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2117,50 +2160,105 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n <context>\n     <name>PeerTableModel</name>\n     <message>\n-        <location filename=\"../peertablemodel.cpp\" line=\"+107\"/>\n+        <location filename=\"../peertablemodel.h\" line=\"+91\"/>\n         <source>User Agent</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n         <location line=\"+0\"/>\n-        <source>Node/Service</source>\n+        <source>Ping</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n         <location line=\"+0\"/>\n-        <source>NodeId</source>\n+        <source>Sent</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n         <location line=\"+0\"/>\n-        <source>Ping</source>\n+        <source>Received</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n         <location line=\"+0\"/>\n-        <source>Sent</source>\n+        <source>Peer Id</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n         <location line=\"+0\"/>\n-        <source>Received</source>\n+        <source>Address</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+0\"/>\n+        <source>Type</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n+    <message>\n+        <location line=\"+0\"/>\n+        <source>Network</source>\n+        <translation type=\"unfinished\">Network</translation>\n+    </message>\n </context>\n <context>\n     <name>QObject</name>\n     <message>\n-        <location filename=\"../bitcoinunits.cpp\" line=\"+209\"/>\n+        <location filename=\"../bitcoinunits.cpp\" line=\"+213\"/>\n         <source>Amount</source>\n         <translation type=\"unfinished\">Amount</translation>\n     </message>\n     <message>\n-        <location filename=\"../guiutil.cpp\" line=\"+108\"/>\n+        <location filename=\"../guiutil.cpp\" line=\"+118\"/>\n         <source>Enter a Bitcoin address (e.g. %1)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+652\"/>\n+        <location line=\"+532\"/>\n+        <source>Unroutable</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+6\"/>\n+        <source>Internal</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+10\"/>\n+        <source>Inbound</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+0\"/>\n+        <source>Outbound</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+4\"/>\n+        <source>Full Relay</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+1\"/>\n+        <source>Block Relay</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+1\"/>\n+        <source>Manual</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+1\"/>\n+        <source>Feeler</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+1\"/>\n+        <source>Address Fetch</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+14\"/>\n         <source>%1 d</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2176,22 +2274,22 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n     </message>\n     <message>\n         <location line=\"+2\"/>\n-        <location line=\"+26\"/>\n+        <location line=\"+28\"/>\n         <source>%1 s</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-10\"/>\n+        <location line=\"-12\"/>\n         <source>None</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+5\"/>\n+        <location line=\"+6\"/>\n         <source>N/A</source>\n         <translation type=\"unfinished\">N/A</translation>\n     </message>\n     <message>\n-        <location line=\"+0\"/>\n+        <location line=\"+1\"/>\n         <source>%1 ms</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2256,7 +2354,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n     </message>\n     <message>\n         <location line=\"+2\"/>\n-        <source>%1 KB</source>\n+        <source>%1 kB</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n@@ -2270,7 +2368,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location filename=\"../bitcoin.cpp\" line=\"+105\"/>\n+        <location filename=\"../bitcoin.cpp\" line=\"+111\"/>\n         <source>Error: Specified data directory &quot;%1&quot; does not exist.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2328,13 +2426,14 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+32\"/>\n+        <location line=\"+30\"/>\n         <source>Save QR Code</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+0\"/>\n-        <source>PNG Image (*.png)</source>\n+        <location line=\"+1\"/>\n+        <source>PNG Image</source>\n+        <comment>Name of PNG file format</comment>\n         <translation type=\"unfinished\"></translation>\n     </message>\n </context>\n@@ -2344,7 +2443,6 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <location filename=\"../forms/debugwindow.ui\" line=\"+75\"/>\n         <location line=\"+26\"/>\n         <location line=\"+26\"/>\n-        <location line=\"+26\"/>\n         <location line=\"+29\"/>\n         <location line=\"+26\"/>\n         <location line=\"+36\"/>\n@@ -2354,14 +2452,19 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <location line=\"+36\"/>\n         <location line=\"+23\"/>\n         <location line=\"+710\"/>\n+        <location line=\"+26\"/>\n+        <location line=\"+26\"/>\n         <location line=\"+23\"/>\n         <location line=\"+23\"/>\n         <location line=\"+23\"/>\n+        <location line=\"+26\"/>\n+        <location line=\"+26\"/>\n         <location line=\"+23\"/>\n         <location line=\"+23\"/>\n         <location line=\"+23\"/>\n         <location line=\"+23\"/>\n-        <location line=\"+23\"/>\n+        <location line=\"+26\"/>\n+        <location line=\"+26\"/>\n         <location line=\"+23\"/>\n         <location line=\"+23\"/>\n         <location line=\"+23\"/>\n@@ -2371,13 +2474,12 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <location line=\"+23\"/>\n         <location line=\"+23\"/>\n         <location line=\"+26\"/>\n-        <location filename=\"../rpcconsole.cpp\" line=\"+1127\"/>\n-        <location line=\"+8\"/>\n+        <location filename=\"../rpcconsole.h\" line=\"+141\"/>\n         <source>N/A</source>\n         <translation>N/A</translation>\n     </message>\n     <message>\n-        <location line=\"-1427\"/>\n+        <location line=\"-1534\"/>\n         <source>Client version</source>\n         <translation>Client version</translation>\n     </message>\n@@ -2393,11 +2495,6 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n     </message>\n     <message>\n         <location line=\"+56\"/>\n-        <source>Using BerkeleyDB version</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+26\"/>\n         <source>Datadir</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2423,11 +2520,12 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n     </message>\n     <message>\n         <location line=\"+29\"/>\n+        <location line=\"+910\"/>\n         <source>Network</source>\n         <translation>Network</translation>\n     </message>\n     <message>\n-        <location line=\"+7\"/>\n+        <location line=\"-903\"/>\n         <source>Name</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2473,18 +2571,18 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n     </message>\n     <message>\n         <location line=\"+80\"/>\n-        <location line=\"+560\"/>\n+        <location line=\"+693\"/>\n         <source>Received</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-480\"/>\n-        <location line=\"+457\"/>\n+        <location line=\"-613\"/>\n+        <location line=\"+590\"/>\n         <source>Sent</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-416\"/>\n+        <location line=\"-549\"/>\n         <source>&amp;Peers</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2495,23 +2593,17 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n     </message>\n     <message>\n         <location line=\"+65\"/>\n-        <location filename=\"../rpcconsole.cpp\" line=\"-637\"/>\n-        <location line=\"+766\"/>\n+        <location filename=\"../rpcconsole.cpp\" line=\"+1104\"/>\n         <source>Select a peer to view detailed information.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+54\"/>\n-        <source>Direction</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+23\"/>\n+        <location line=\"+106\"/>\n         <source>Version</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+69\"/>\n+        <location line=\"+121\"/>\n         <source>Starting Block</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2526,7 +2618,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+233\"/>\n+        <location line=\"+285\"/>\n         <source>The mapped Autonomous System used for diversifying peer selection.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2536,18 +2628,18 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-1394\"/>\n-        <location line=\"+1066\"/>\n+        <location line=\"-1501\"/>\n+        <location line=\"+1069\"/>\n         <source>User Agent</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-1140\"/>\n+        <location line=\"-1143\"/>\n         <source>Node window</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+279\"/>\n+        <location line=\"+253\"/>\n         <source>Current block height</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2572,15 +2664,70 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+92\"/>\n+        <location line=\"+23\"/>\n+        <source>The direction and type of peer connection: %1</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+3\"/>\n+        <source>Direction/Type</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+23\"/>\n+        <source>The network protocol this peer is connected through: IPv4, IPv6, Onion, I2P, or CJDNS.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+72\"/>\n         <source>Services</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n+    <message>\n+        <location line=\"+23\"/>\n+        <source>Whether the peer requested us to relay transactions.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+3\"/>\n+        <source>Wants Tx Relay</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+23\"/>\n+        <source>High bandwidth BIP152 compact block relay: %1</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+3\"/>\n+        <source>High Bandwidth</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n     <message>\n         <location line=\"+92\"/>\n         <source>Connection Time</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n+    <message>\n+        <location line=\"+23\"/>\n+        <source>Elapsed time since a novel block passing initial validity checks was received from this peer.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+3\"/>\n+        <source>Last Block</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+23\"/>\n+        <source>Elapsed time since a novel transaction accepted into our mempool was received from this peer.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+3\"/>\n+        <source>Last Tx</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n     <message>\n         <location line=\"+23\"/>\n         <source>Last Send</source>\n@@ -2617,7 +2764,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-1140\"/>\n+        <location line=\"-1273\"/>\n         <source>Last block time</source>\n         <translation>Last block time</translation>\n     </message>\n@@ -2642,7 +2789,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location filename=\"../rpcconsole.cpp\" line=\"-416\"/>\n+        <location filename=\"../rpcconsole.cpp\" line=\"-242\"/>\n         <source>In:</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2662,7 +2809,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation>Clear console</translation>\n     </message>\n     <message>\n-        <location filename=\"../rpcconsole.cpp\" line=\"-243\"/>\n+        <location filename=\"../rpcconsole.cpp\" line=\"-242\"/>\n         <source>1 &amp;hour</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2686,88 +2833,138 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <source>&amp;Disconnect</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n+    <message>\n+        <location filename=\"../rpcconsole.h\" line=\"-1\"/>\n+        <source>Yes</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+0\"/>\n+        <source>No</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+0\"/>\n+        <source>To</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+0\"/>\n+        <source>From</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n     <message>\n         <location line=\"+1\"/>\n+        <source>Ban for</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+37\"/>\n+        <source>Never</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location filename=\"../rpcconsole.cpp\" line=\"-155\"/>\n+        <source>Inbound: initiated by peer</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n         <location line=\"+1\"/>\n+        <source>Outbound Full Relay: default</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n         <location line=\"+1\"/>\n-        <location line=\"+1\"/>\n-        <source>Ban for</source>\n+        <source>Outbound Block Relay: does not relay transactions or addresses</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+38\"/>\n-        <source>&amp;Unban</source>\n+        <location line=\"+1\"/>\n+        <source>Outbound Manual: added using RPC %1 or %2/%3 configuration options</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+164\"/>\n-        <source>Welcome to the %1 RPC console.</source>\n+        <location line=\"+4\"/>\n+        <source>Outbound Feeler: short-lived, for testing addresses</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n         <location line=\"+1\"/>\n-        <source>Use up and down arrows to navigate history, and %1 to clear screen.</source>\n+        <source>Outbound Address Fetch: short-lived, for soliciting addresses</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+4\"/>\n+        <source>we selected the peer for high bandwidth relay</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n         <location line=\"+1\"/>\n-        <source>Type %1 for an overview of available commands.</source>\n+        <source>the peer selected us for high bandwidth relay</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n         <location line=\"+1\"/>\n-        <source>For more information on using this console type %1.</source>\n+        <source>no high bandwidth relay selected</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+2\"/>\n-        <source>WARNING: Scammers have been active, telling users to type commands here, stealing their wallet contents. Do not use this console without fully understanding the ramifications of a command.</source>\n+        <location line=\"+182\"/>\n+        <source>&amp;Unban</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+36\"/>\n-        <source>Network activity disabled</source>\n+        <location line=\"+164\"/>\n+        <source>Welcome to the %1 RPC console.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+66\"/>\n-        <source>Executing command without any wallet</source>\n+        <location line=\"+1\"/>\n+        <source>Use up and down arrows to navigate history, and %1 to clear screen.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+1\"/>\n+        <source>Type %1 for an overview of available commands.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+1\"/>\n+        <source>For more information on using this console type %1.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-2\"/>\n-        <source>Executing command using &quot;%1&quot; wallet</source>\n+        <location line=\"+2\"/>\n+        <source>WARNING: Scammers have been active, telling users to type commands here, stealing their wallet contents. Do not use this console without fully understanding the ramifications of a command.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+192\"/>\n-        <source>(node id: %1)</source>\n+        <location line=\"+36\"/>\n+        <source>Network activity disabled</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+2\"/>\n-        <source>via %1</source>\n+        <location line=\"+66\"/>\n+        <source>Executing command without any wallet</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+3\"/>\n-        <location line=\"+1\"/>\n-        <source>never</source>\n+        <location line=\"+178\"/>\n+        <source>(peer id: %1)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+10\"/>\n-        <source>Inbound</source>\n+        <location line=\"-180\"/>\n+        <source>Executing command using &quot;%1&quot; wallet</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+0\"/>\n-        <source>Outbound</source>\n+        <location line=\"+182\"/>\n+        <source>via %1</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+20\"/>\n-        <location line=\"+6\"/>\n+        <location filename=\"../rpcconsole.h\" line=\"-37\"/>\n         <source>Unknown</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2871,10 +3068,15 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location filename=\"../receivecoinsdialog.cpp\" line=\"+45\"/>\n+        <location filename=\"../receivecoinsdialog.cpp\" line=\"+46\"/>\n         <source>Copy URI</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n+    <message>\n+        <location line=\"+1\"/>\n+        <source>Copy address</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n     <message>\n         <location line=\"+1\"/>\n         <source>Copy label</source>\n@@ -2891,7 +3093,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+131\"/>\n+        <location line=\"+140\"/>\n         <source>Could not unlock wallet.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2977,7 +3179,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+39\"/>\n+        <location line=\"+41\"/>\n         <source>(no label)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -3001,7 +3203,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n     <name>SendCoinsDialog</name>\n     <message>\n         <location filename=\"../forms/sendcoinsdialog.ui\" line=\"+14\"/>\n-        <location filename=\"../sendcoinsdialog.cpp\" line=\"+664\"/>\n+        <location filename=\"../sendcoinsdialog.cpp\" line=\"+673\"/>\n         <source>Send Coins</source>\n         <translation>Send Coins</translation>\n     </message>\n@@ -3188,7 +3390,7 @@ Note:  Since the fee is calculated on a per-byte basis, a fee of &quot;100 satos\n         <translation>S&amp;end</translation>\n     </message>\n     <message>\n-        <location filename=\"../sendcoinsdialog.cpp\" line=\"-572\"/>\n+        <location filename=\"../sendcoinsdialog.cpp\" line=\"-581\"/>\n         <source>Copy quantity</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -3223,12 +3425,12 @@ Note:  Since the fee is calculated on a per-byte basis, a fee of &quot;100 satos\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+74\"/>\n+        <location line=\"+76\"/>\n         <source>%1 (%2 blocks)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+22\"/>\n+        <location line=\"+29\"/>\n         <source>Cr&amp;eate Unsigned</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -3273,12 +3475,7 @@ Note:  Since the fee is calculated on a per-byte basis, a fee of &quot;100 satos\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+1\"/>\n-        <source>Partially Signed Transaction (Binary) (*.psbt)</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+7\"/>\n+        <location line=\"+8\"/>\n         <source>PSBT saved</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -3338,7 +3535,13 @@ Note:  Since the fee is calculated on a per-byte basis, a fee of &quot;100 satos\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+228\"/>\n+        <location line=\"+45\"/>\n+        <source>Partially Signed Transaction (Binary)</source>\n+        <comment>Name of binary PSBT file format</comment>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+183\"/>\n         <source>Watch-only balance:</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -3743,7 +3946,7 @@ Note:  Since the fee is calculated on a per-byte basis, a fee of &quot;100 satos\n     <name>TrafficGraphWidget</name>\n     <message>\n         <location filename=\"../trafficgraphwidget.cpp\" line=\"+82\"/>\n-        <source>KB/s</source>\n+        <source>kB/s</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n </context>\n@@ -3996,7 +4199,7 @@ Note:  Since the fee is calculated on a per-byte basis, a fee of &quot;100 satos\n <context>\n     <name>TransactionTableModel</name>\n     <message>\n-        <location filename=\"../transactiontablemodel.cpp\" line=\"+251\"/>\n+        <location filename=\"../transactiontablemodel.cpp\" line=\"+252\"/>\n         <source>Date</source>\n         <translation type=\"unfinished\">Date</translation>\n     </message>\n@@ -4011,7 +4214,7 @@ Note:  Since the fee is calculated on a per-byte basis, a fee of &quot;100 satos\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message numerus=\"yes\">\n-        <location line=\"+58\"/>\n+        <location line=\"+62\"/>\n         <source>Open for %n more block(s)</source>\n         <translation>\n             <numerusform>Open for %n more block</numerusform>\n@@ -4094,7 +4297,7 @@ Note:  Since the fee is calculated on a per-byte basis, a fee of &quot;100 satos\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+208\"/>\n+        <location line=\"+210\"/>\n         <source>(no label)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4132,7 +4335,7 @@ Note:  Since the fee is calculated on a per-byte basis, a fee of &quot;100 satos\n <context>\n     <name>TransactionView</name>\n     <message>\n-        <location filename=\"../transactionview.cpp\" line=\"+69\"/>\n+        <location filename=\"../transactionview.cpp\" line=\"+70\"/>\n         <location line=\"+16\"/>\n         <source>All</source>\n         <translation type=\"unfinished\"></translation>\n@@ -4203,7 +4406,7 @@ Note:  Since the fee is calculated on a per-byte basis, a fee of &quot;100 satos\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+51\"/>\n+        <location line=\"+63\"/>\n         <source>Abandon transaction</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4244,26 +4447,27 @@ Note:  Since the fee is calculated on a per-byte basis, a fee of &quot;100 satos\n     </message>\n     <message>\n         <location line=\"+1\"/>\n-        <source>Edit label</source>\n+        <source>Edit address label</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+1\"/>\n-        <source>Show transaction details</source>\n+        <location line=\"+186\"/>\n+        <source>Comma separated file</source>\n+        <comment>Name of CSV file format</comment>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+194\"/>\n-        <source>Export Transaction History</source>\n+        <location line=\"-185\"/>\n+        <source>Show transaction details</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+1\"/>\n-        <source>Comma separated file (*.csv)</source>\n+        <location line=\"+184\"/>\n+        <source>Export Transaction History</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+9\"/>\n+        <location line=\"+10\"/>\n         <source>Confirmed</source>\n         <translation type=\"unfinished\">Confirmed</translation>\n     </message>\n@@ -4339,7 +4543,7 @@ Note:  Since the fee is calculated on a per-byte basis, a fee of &quot;100 satos\n <context>\n     <name>WalletController</name>\n     <message>\n-        <location filename=\"../walletcontroller.cpp\" line=\"-238\"/>\n+        <location filename=\"../walletcontroller.cpp\" line=\"-247\"/>\n         <source>Close wallet</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4382,20 +4586,20 @@ Go to File &gt; Open Wallet to load a wallet.\n <context>\n     <name>WalletModel</name>\n     <message>\n-        <location filename=\"../walletmodel.cpp\" line=\"+214\"/>\n+        <location filename=\"../walletmodel.cpp\" line=\"+218\"/>\n         <source>Send Coins</source>\n         <translation type=\"unfinished\">Send Coins</translation>\n     </message>\n     <message>\n-        <location line=\"+282\"/>\n-        <location line=\"+45\"/>\n+        <location line=\"+279\"/>\n+        <location line=\"+52\"/>\n         <location line=\"+13\"/>\n         <location line=\"+5\"/>\n         <source>Fee bump error</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-63\"/>\n+        <location line=\"-70\"/>\n         <source>Increasing transaction fee failed</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4425,7 +4629,12 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+4\"/>\n+        <location line=\"+8\"/>\n+        <source>Warning: This may pay the additional fee by reducing change outputs or adding inputs, when necessary. It may add a new change output if one does not already exist. These changes may potentially leak privacy.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+3\"/>\n         <source>Confirm fee bump</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4506,7 +4715,8 @@ Go to File &gt; Open Wallet to load a wallet.\n     </message>\n     <message>\n         <location line=\"+1\"/>\n-        <source>Wallet Data (*.dat)</source>\n+        <source>Wallet Data</source>\n+        <comment>Name of wallet data file format</comment>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n@@ -4538,12 +4748,12 @@ Go to File &gt; Open Wallet to load a wallet.\n <context>\n     <name>bitcoin-core</name>\n     <message>\n-        <location filename=\"../bitcoinstrings.cpp\" line=\"+27\"/>\n+        <location filename=\"../bitcoinstrings.cpp\" line=\"+31\"/>\n         <source>Distributed under the MIT software license, see the accompanying file %s or %s</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+23\"/>\n+        <location line=\"+41\"/>\n         <source>Prune configured below the minimum of %d MiB.  Please use a higher number.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4553,22 +4763,22 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+112\"/>\n+        <location line=\"+124\"/>\n         <source>Pruning blockstore...</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+36\"/>\n+        <location line=\"+37\"/>\n         <source>Unable to start HTTP server. See debug log for details.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-188\"/>\n+        <location line=\"-223\"/>\n         <source>The %s developers</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+7\"/>\n+        <location line=\"+10\"/>\n         <source>Cannot obtain a lock on data directory %s. %s is probably already running.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4578,17 +4788,17 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+9\"/>\n+        <location line=\"+10\"/>\n         <source>Error reading %s! All keys read correctly, but transaction data or address book entries might be missing or incorrect.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+11\"/>\n+        <location line=\"+21\"/>\n         <source>More than one onion bind address is provided. Using %s for the automatically created Tor onion service.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+3\"/>\n+        <location line=\"+11\"/>\n         <source>Please check that your computer&apos;s date and time are correct! If your clock is wrong, %s will not work properly.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4638,12 +4848,7 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+5\"/>\n-        <source>Warning: The network does not appear to fully agree! Some miners appear to be experiencing issues.</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+3\"/>\n+        <location line=\"+11\"/>\n         <source>Warning: We do not appear to fully agree with our peers! You may need to upgrade, or other nodes may need to upgrade.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4653,7 +4858,7 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+3\"/>\n+        <location line=\"+2\"/>\n         <source>Cannot resolve -%s address: &apos;%s&apos;</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4694,6 +4899,16 @@ Go to File &gt; Open Wallet to load a wallet.\n     </message>\n     <message>\n         <location line=\"+2\"/>\n+        <source>Dump file %s does not exist.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+1\"/>\n+        <source>Error creating %s</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+1\"/>\n         <source>Error initializing block database</source>\n         <translation>Error initializing block database</translation>\n     </message>\n@@ -4733,7 +4948,47 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation>Error opening block database</translation>\n     </message>\n     <message>\n-        <location line=\"+5\"/>\n+        <location line=\"+2\"/>\n+        <source>Error reading next record from wallet database</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+2\"/>\n+        <source>Error: Couldn&apos;t create cursor into database</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+2\"/>\n+        <source>Error: Dumpfile checksum does not match. Computed %s, expected %s</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+1\"/>\n+        <source>Error: Got key that was not hex: %s</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+1\"/>\n+        <source>Error: Got value that was not hex: %s</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+2\"/>\n+        <source>Error: Missing checksum</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+1\"/>\n+        <source>Error: Unable to parse version %u as a uint32_t</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+1\"/>\n+        <source>Error: Unable to write record to new wallet</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+1\"/>\n         <source>Failed to listen on any port. Use -listen=0 if you want this.</source>\n         <translation>Failed to listen on any port. Use -listen=0 if you want this.</translation>\n     </message>\n@@ -4768,7 +5023,12 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+4\"/>\n+        <location line=\"+2\"/>\n+        <source>Invalid -i2psam address or hostname: &apos;%s&apos;</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+3\"/>\n         <source>Invalid P2P permission: &apos;%s&apos;</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4788,7 +5048,7 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+18\"/>\n+        <location line=\"+17\"/>\n         <source>SQLiteDatabase: Failed to execute statement to verify database: %s</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4823,7 +5083,17 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+22\"/>\n+        <location line=\"+3\"/>\n+        <source>The specified config file %s does not exist</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+17\"/>\n+        <source>Unable to open %s for writing</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+3\"/>\n         <source>Unknown address type &apos;%s&apos;</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4843,7 +5113,62 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+1\"/>\n+        <location line=\"-170\"/>\n+        <source>Cannot downgrade wallet from version %i to version %i. Wallet version unchanged.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+8\"/>\n+        <source>Cannot upgrade a non HD split wallet from version %i to version %i without upgrading to support pre-split keypool. Please use version %i or no version specified.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+10\"/>\n+        <source>Error: Dumpfile format record is incorrect. Got &quot;%s&quot;, expected &quot;format&quot;.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+2\"/>\n+        <source>Error: Dumpfile identifier record is incorrect. Got &quot;%s&quot;, expected &quot;%s&quot;.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+2\"/>\n+        <source>Error: Dumpfile version is not supported. This version of bitcoin-wallet only supports version 1 dumpfiles. Got dumpfile with version %s</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+8\"/>\n+        <source>File %s already exists. If you are sure this is what you want, move it out of the way first.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+9\"/>\n+        <source>No dump file provided. To use createfromdump, -dumpfile=&lt;filename&gt; must be provided.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+3\"/>\n+        <source>No dump file provided. To use dump, -dumpfile=&lt;filename&gt; must be provided.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+2\"/>\n+        <source>No wallet file format provided. To use createfromdump, -format=&lt;format&gt; must be provided.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+57\"/>\n+        <source>Unknown wallet file format &quot;%s&quot; provided. Please provide one of &quot;bdb&quot; or &quot;sqlite&quot;.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+3\"/>\n+        <source>Warning: Dumpfile wallet format &quot;%s&quot; does not match command line specified format &quot;%s&quot;.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+67\"/>\n         <source>Loading banlist...</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4858,7 +5183,7 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+2\"/>\n+        <location line=\"+1\"/>\n         <source>Prune mode is incompatible with -txindex.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4893,7 +5218,7 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+6\"/>\n+        <location line=\"+7\"/>\n         <source>Unsupported logging category %s=%s.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4918,27 +5243,22 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-178\"/>\n+        <location line=\"-202\"/>\n         <source>Error: Listening for incoming connections failed (listen returned error %s)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-20\"/>\n+        <location line=\"-31\"/>\n         <source>%s corrupt. Try using the wallet tool bitcoin-wallet to salvage or restoring a backup.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+11\"/>\n-        <source>Cannot upgrade a non HD split wallet without upgrading to support pre split keypool. Please use version 169900 or no version specified.</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+14\"/>\n+        <location line=\"+39\"/>\n         <source>Invalid amount for -maxtxfee=&lt;amount&gt;: &apos;%s&apos; (must be at least the minrelay fee of %s to prevent stuck transactions)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+31\"/>\n+        <location line=\"+39\"/>\n         <source>The transaction amount is too small to send after the fee has been deducted</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4958,7 +5278,7 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+17\"/>\n+        <location line=\"+20\"/>\n         <source>You need to rebuild the database using -reindex to go back to unpruned mode.  This will redownload the entire blockchain</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4968,7 +5288,7 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+3\"/>\n+        <location line=\"+2\"/>\n         <source>Cannot set -peerblockfilters without -blockfilterindex.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4978,32 +5298,32 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+11\"/>\n+        <location line=\"+13\"/>\n         <source>Error reading from database, shutting down.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+1\"/>\n+        <location line=\"+2\"/>\n         <source>Error upgrading chainstate database</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+1\"/>\n+        <location line=\"+2\"/>\n         <source>Error: Disk space is low for %s</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+1\"/>\n+        <location line=\"+4\"/>\n         <source>Error: Keypool ran out, please call keypoolrefill first</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+4\"/>\n+        <location line=\"+7\"/>\n         <source>Fee rate (%s) is lower than the minimum fee rate setting (%s)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+6\"/>\n+        <location line=\"+7\"/>\n         <source>Invalid -onion address or hostname: &apos;%s&apos;</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -5033,12 +5353,7 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+3\"/>\n-        <source>Prune mode is incompatible with -blockfilterindex.</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+3\"/>\n+        <location line=\"+5\"/>\n         <source>Reducing -maxconnections from %d to %d, because of system limitations.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -5068,13 +5383,7 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+4\"/>\n-        <source>The specified config file %s does not exist\n-</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+1\"/>\n+        <location line=\"+5\"/>\n         <source>The transaction amount is too small to pay the fee</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -5109,7 +5418,7 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+3\"/>\n+        <location line=\"+4\"/>\n         <source>Unknown -blockfilterindex value %s.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -5124,12 +5433,12 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-196\"/>\n+        <location line=\"-231\"/>\n         <source>-maxtxfee is set very high! Fees this large could be paid on a single transaction.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+68\"/>\n+        <location line=\"+90\"/>\n         <source>This is the transaction fee you may pay when fee estimates are not available.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -5139,12 +5448,12 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+23\"/>\n+        <location line=\"+26\"/>\n         <source>%s is set very high!</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+72\"/>\n+        <location line=\"+81\"/>\n         <source>Starting network threads...</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -5179,32 +5488,32 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+11\"/>\n+        <location line=\"+12\"/>\n         <source>Unknown network specified in -onlynet: &apos;%s&apos;</source>\n         <translation>Unknown network specified in -onlynet: &apos;%s&apos;</translation>\n     </message>\n     <message>\n-        <location line=\"-59\"/>\n+        <location line=\"-60\"/>\n         <source>Insufficient funds</source>\n         <translation>Insufficient funds</translation>\n     </message>\n     <message>\n-        <location line=\"-110\"/>\n+        <location line=\"-133\"/>\n         <source>Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+63\"/>\n+        <location line=\"+80\"/>\n         <source>Warning: Private keys detected in wallet {%s} with disabled private keys</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+17\"/>\n+        <location line=\"+13\"/>\n         <source>Cannot write to data directory &apos;%s&apos;; check permissions.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+41\"/>\n+        <location line=\"+52\"/>\n         <source>Loading block index...</source>\n         <translation>Loading block index...</translation>\n     </message>\n@@ -5214,17 +5523,12 @@ Go to File &gt; Open Wallet to load a wallet.\n         <translation>Loading wallet...</translation>\n     </message>\n     <message>\n-        <location line=\"-45\"/>\n-        <source>Cannot downgrade wallet</source>\n-        <translation>Cannot downgrade wallet</translation>\n-    </message>\n-    <message>\n-        <location line=\"+55\"/>\n+        <location line=\"+9\"/>\n         <source>Rescanning...</source>\n         <translation>Rescanning...</translation>\n     </message>\n     <message>\n-        <location line=\"-43\"/>\n+        <location line=\"-53\"/>\n         <source>Done loading</source>\n         <translation>Done loading</translation>\n     </message>"
      },
      {
        "sha": "a8a5f57f150a882e621f47dcdffe58a30f786d7c",
        "filename": "src/qt/locale/bitcoin_en.xlf",
        "status": "added",
        "additions": 5688,
        "deletions": 0,
        "changes": 5688,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/locale/bitcoin_en.xlf",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/locale/bitcoin_en.xlf",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_en.xlf?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f"
      },
      {
        "sha": "6c4e32601199e530879f8e8aa0f9178c2225bb9b",
        "filename": "src/qt/peertablemodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 68,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/peertablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/peertablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/peertablemodel.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -11,56 +11,19 @@\n \n #include <utility>\n \n-#include <QDebug>\n #include <QList>\n #include <QTimer>\n \n-bool NodeLessThan::operator()(const CNodeCombinedStats &left, const CNodeCombinedStats &right) const\n-{\n-    const CNodeStats *pLeft = &(left.nodeStats);\n-    const CNodeStats *pRight = &(right.nodeStats);\n-\n-    if (order == Qt::DescendingOrder)\n-        std::swap(pLeft, pRight);\n-\n-    switch (static_cast<PeerTableModel::ColumnIndex>(column)) {\n-    case PeerTableModel::NetNodeId:\n-        return pLeft->nodeid < pRight->nodeid;\n-    case PeerTableModel::Address:\n-        return pLeft->addrName.compare(pRight->addrName) < 0;\n-    case PeerTableModel::ConnectionType:\n-        return pLeft->m_conn_type < pRight->m_conn_type;\n-    case PeerTableModel::Network:\n-        return pLeft->m_network < pRight->m_network;\n-    case PeerTableModel::Ping:\n-        return pLeft->m_min_ping_time < pRight->m_min_ping_time;\n-    case PeerTableModel::Sent:\n-        return pLeft->nSendBytes < pRight->nSendBytes;\n-    case PeerTableModel::Received:\n-        return pLeft->nRecvBytes < pRight->nRecvBytes;\n-    case PeerTableModel::Subversion:\n-        return pLeft->cleanSubVer.compare(pRight->cleanSubVer) < 0;\n-    } // no default case, so the compiler can warn about missing cases\n-    assert(false);\n-}\n-\n // private implementation\n class PeerTablePriv\n {\n public:\n     /** Local cache of peer information */\n     QList<CNodeCombinedStats> cachedNodeStats;\n-    /** Column to sort nodes by (default to unsorted) */\n-    int sortColumn{-1};\n-    /** Order (ascending or descending) to sort nodes by */\n-    Qt::SortOrder sortOrder;\n-    /** Index of rows by node ID */\n-    std::map<NodeId, int> mapNodeRows;\n \n     /** Pull a full list of peers from vNodes into our cache */\n     void refreshPeers(interfaces::Node& node)\n     {\n-        {\n             cachedNodeStats.clear();\n \n             interfaces::Node::NodesStats nodes_stats;\n@@ -74,17 +37,6 @@ class PeerTablePriv\n                 stats.nodeStateStats = std::get<2>(node_stats);\n                 cachedNodeStats.append(stats);\n             }\n-        }\n-\n-        if (sortColumn >= 0)\n-            // sort cacheNodeStats (use stable sort to prevent rows jumping around unnecessarily)\n-            std::stable_sort(cachedNodeStats.begin(), cachedNodeStats.end(), NodeLessThan(sortColumn, sortOrder));\n-\n-        // build index map\n-        mapNodeRows.clear();\n-        int row = 0;\n-        for (const CNodeCombinedStats& stats : cachedNodeStats)\n-            mapNodeRows.insert(std::pair<NodeId, int>(stats.nodeStats.nodeid, row++));\n     }\n \n     int size() const\n@@ -194,10 +146,7 @@ QVariant PeerTableModel::data(const QModelIndex &index, int role) const\n         } // no default case, so the compiler can warn about missing cases\n         assert(false);\n     } else if (role == StatsRole) {\n-        switch (index.column()) {\n-        case NetNodeId: return QVariant::fromValue(rec);\n-        default: return QVariant();\n-        }\n+        return QVariant::fromValue(rec);\n     }\n \n     return QVariant();\n@@ -239,19 +188,3 @@ void PeerTableModel::refresh()\n     priv->refreshPeers(m_node);\n     Q_EMIT layoutChanged();\n }\n-\n-int PeerTableModel::getRowByNodeId(NodeId nodeid)\n-{\n-    std::map<NodeId, int>::iterator it = priv->mapNodeRows.find(nodeid);\n-    if (it == priv->mapNodeRows.end())\n-        return -1;\n-\n-    return it->second;\n-}\n-\n-void PeerTableModel::sort(int column, Qt::SortOrder order)\n-{\n-    priv->sortColumn = column;\n-    priv->sortOrder = order;\n-    refresh();\n-}"
      },
      {
        "sha": "9c7bc25da21695761a73cf480525e2025f8b3767",
        "filename": "src/qt/peertablemodel.h",
        "status": "modified",
        "additions": 0,
        "deletions": 14,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/peertablemodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/peertablemodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/peertablemodel.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -30,18 +30,6 @@ struct CNodeCombinedStats {\n };\n Q_DECLARE_METATYPE(CNodeCombinedStats*)\n \n-class NodeLessThan\n-{\n-public:\n-    NodeLessThan(int nColumn, Qt::SortOrder fOrder) :\n-        column(nColumn), order(fOrder) {}\n-    bool operator()(const CNodeCombinedStats &left, const CNodeCombinedStats &right) const;\n-\n-private:\n-    int column;\n-    Qt::SortOrder order;\n-};\n-\n /**\n    Qt model providing information about connected peers, similar to the\n    \"getpeerinfo\" RPC call. Used by the rpc console UI.\n@@ -53,7 +41,6 @@ class PeerTableModel : public QAbstractTableModel\n public:\n     explicit PeerTableModel(interfaces::Node& node, QObject* parent);\n     ~PeerTableModel();\n-    int getRowByNodeId(NodeId nodeid);\n     void startAutoRefresh();\n     void stopAutoRefresh();\n \n@@ -80,7 +67,6 @@ class PeerTableModel : public QAbstractTableModel\n     QVariant headerData(int section, Qt::Orientation orientation, int role) const override;\n     QModelIndex index(int row, int column, const QModelIndex &parent) const override;\n     Qt::ItemFlags flags(const QModelIndex &index) const override;\n-    void sort(int column, Qt::SortOrder order) override;\n     /*@}*/\n \n public Q_SLOTS:"
      },
      {
        "sha": "78932da8d4808788b04aca859c93f48df392d44b",
        "filename": "src/qt/peertablesortproxy.cpp",
        "status": "added",
        "additions": 43,
        "deletions": 0,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/peertablesortproxy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/peertablesortproxy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/peertablesortproxy.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,43 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <qt/peertablesortproxy.h>\n+\n+#include <qt/peertablemodel.h>\n+#include <util/check.h>\n+\n+#include <QModelIndex>\n+#include <QString>\n+#include <QVariant>\n+\n+PeerTableSortProxy::PeerTableSortProxy(QObject* parent)\n+    : QSortFilterProxyModel(parent)\n+{\n+}\n+\n+bool PeerTableSortProxy::lessThan(const QModelIndex& left_index, const QModelIndex& right_index) const\n+{\n+    const CNodeStats left_stats = Assert(sourceModel()->data(left_index, PeerTableModel::StatsRole).value<CNodeCombinedStats*>())->nodeStats;\n+    const CNodeStats right_stats = Assert(sourceModel()->data(right_index, PeerTableModel::StatsRole).value<CNodeCombinedStats*>())->nodeStats;\n+\n+    switch (static_cast<PeerTableModel::ColumnIndex>(left_index.column())) {\n+    case PeerTableModel::NetNodeId:\n+        return left_stats.nodeid < right_stats.nodeid;\n+    case PeerTableModel::Address:\n+        return left_stats.addrName.compare(right_stats.addrName) < 0;\n+    case PeerTableModel::ConnectionType:\n+        return left_stats.m_conn_type < right_stats.m_conn_type;\n+    case PeerTableModel::Network:\n+        return left_stats.m_network < right_stats.m_network;\n+    case PeerTableModel::Ping:\n+        return left_stats.m_min_ping_time < right_stats.m_min_ping_time;\n+    case PeerTableModel::Sent:\n+        return left_stats.nSendBytes < right_stats.nSendBytes;\n+    case PeerTableModel::Received:\n+        return left_stats.nRecvBytes < right_stats.nRecvBytes;\n+    case PeerTableModel::Subversion:\n+        return left_stats.cleanSubVer.compare(right_stats.cleanSubVer) < 0;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}"
      },
      {
        "sha": "1879f6b400bc17ff68ce693edf1a47acb846ba5f",
        "filename": "src/qt/peertablesortproxy.h",
        "status": "added",
        "additions": 25,
        "deletions": 0,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/peertablesortproxy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/peertablesortproxy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/peertablesortproxy.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,25 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_QT_PEERTABLESORTPROXY_H\n+#define BITCOIN_QT_PEERTABLESORTPROXY_H\n+\n+#include <QSortFilterProxyModel>\n+\n+QT_BEGIN_NAMESPACE\n+class QModelIndex;\n+QT_END_NAMESPACE\n+\n+class PeerTableSortProxy : public QSortFilterProxyModel\n+{\n+    Q_OBJECT\n+\n+public:\n+    explicit PeerTableSortProxy(QObject* parent = nullptr);\n+\n+protected:\n+    bool lessThan(const QModelIndex& left_index, const QModelIndex& right_index) const override;\n+};\n+\n+#endif // BITCOIN_QT_PEERTABLESORTPROXY_H"
      },
      {
        "sha": "df6757ffd6721f60483d8be1bcbb7084cc3646af",
        "filename": "src/qt/qrimagewidget.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 6,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/qrimagewidget.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/qrimagewidget.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/qrimagewidget.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -27,12 +27,8 @@ QRImageWidget::QRImageWidget(QWidget *parent):\n     QLabel(parent), contextMenu(nullptr)\n {\n     contextMenu = new QMenu(this);\n-    QAction *saveImageAction = new QAction(tr(\"&Save Image...\"), this);\n-    connect(saveImageAction, &QAction::triggered, this, &QRImageWidget::saveImage);\n-    contextMenu->addAction(saveImageAction);\n-    QAction *copyImageAction = new QAction(tr(\"&Copy Image\"), this);\n-    connect(copyImageAction, &QAction::triggered, this, &QRImageWidget::copyImage);\n-    contextMenu->addAction(copyImageAction);\n+    contextMenu->addAction(tr(\"Save Image...\"), this, &QRImageWidget::saveImage);\n+    contextMenu->addAction(tr(\"Copy Image\"), this, &QRImageWidget::copyImage);\n }\n \n bool QRImageWidget::setQR(const QString& data, const QString& text)"
      },
      {
        "sha": "3f4d7f85e69688c2605f7a2eec46aed5f5a94d42",
        "filename": "src/qt/receivecoinsdialog.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 19,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/receivecoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/receivecoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receivecoinsdialog.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -42,28 +42,14 @@ ReceiveCoinsDialog::ReceiveCoinsDialog(const PlatformStyle *_platformStyle, QWid\n         ui->removeRequestButton->setIcon(_platformStyle->SingleColorIcon(\":/icons/remove\"));\n     }\n \n-    // context menu actions\n-    QAction *copyURIAction = new QAction(tr(\"Copy URI\"), this);\n-    QAction* copyAddressAction = new QAction(tr(\"Copy address\"), this);\n-    copyLabelAction = new QAction(tr(\"Copy label\"), this);\n-    copyMessageAction = new QAction(tr(\"Copy message\"), this);\n-    copyAmountAction = new QAction(tr(\"Copy amount\"), this);\n-\n     // context menu\n     contextMenu = new QMenu(this);\n-    contextMenu->addAction(copyURIAction);\n-    contextMenu->addAction(copyAddressAction);\n-    contextMenu->addAction(copyLabelAction);\n-    contextMenu->addAction(copyMessageAction);\n-    contextMenu->addAction(copyAmountAction);\n-\n-    // context menu signals\n+    contextMenu->addAction(tr(\"Copy URI\"), this, &ReceiveCoinsDialog::copyURI);\n+    contextMenu->addAction(tr(\"Copy address\"), this, &ReceiveCoinsDialog::copyAddress);\n+    copyLabelAction = contextMenu->addAction(tr(\"Copy label\"), this, &ReceiveCoinsDialog::copyLabel);\n+    copyMessageAction = contextMenu->addAction(tr(\"Copy message\"), this, &ReceiveCoinsDialog::copyMessage);\n+    copyAmountAction = contextMenu->addAction(tr(\"Copy amount\"), this, &ReceiveCoinsDialog::copyAmount);\n     connect(ui->recentRequestsView, &QWidget::customContextMenuRequested, this, &ReceiveCoinsDialog::showMenu);\n-    connect(copyURIAction, &QAction::triggered, this, &ReceiveCoinsDialog::copyURI);\n-    connect(copyAddressAction, &QAction::triggered, this, &ReceiveCoinsDialog::copyAddress);\n-    connect(copyLabelAction, &QAction::triggered, this, &ReceiveCoinsDialog::copyLabel);\n-    connect(copyMessageAction, &QAction::triggered, this, &ReceiveCoinsDialog::copyMessage);\n-    connect(copyAmountAction, &QAction::triggered, this, &ReceiveCoinsDialog::copyAmount);\n \n     connect(ui->clearButton, &QPushButton::clicked, this, &ReceiveCoinsDialog::clear);\n "
      },
      {
        "sha": "006f60e7a1c53a9458397d32433c4ecc468116da",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 96,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -9,13 +9,14 @@\n #include <qt/rpcconsole.h>\n #include <qt/forms/ui_debugwindow.h>\n \n+#include <chainparams.h>\n+#include <interfaces/node.h>\n+#include <netbase.h>\n #include <qt/bantablemodel.h>\n #include <qt/clientmodel.h>\n+#include <qt/peertablesortproxy.h>\n #include <qt/platformstyle.h>\n #include <qt/walletmodel.h>\n-#include <chainparams.h>\n-#include <interfaces/node.h>\n-#include <netbase.h>\n #include <rpc/client.h>\n #include <rpc/server.h>\n #include <util/strencodings.h>\n@@ -606,7 +607,7 @@ void RPCConsole::setClientModel(ClientModel *model, int bestblock_height, int64_\n         connect(model, &ClientModel::mempoolSizeChanged, this, &RPCConsole::setMempoolSize);\n \n         // set up peer table\n-        ui->peerWidget->setModel(model->getPeerTableModel());\n+        ui->peerWidget->setModel(model->peerTableSortProxy());\n         ui->peerWidget->verticalHeader()->hide();\n         ui->peerWidget->setSelectionBehavior(QAbstractItemView::SelectRows);\n         ui->peerWidget->setSelectionMode(QAbstractItemView::ExtendedSelection);\n@@ -616,36 +617,18 @@ void RPCConsole::setClientModel(ClientModel *model, int bestblock_height, int64_\n         ui->peerWidget->setColumnWidth(PeerTableModel::Ping, PING_COLUMN_WIDTH);\n         ui->peerWidget->horizontalHeader()->setStretchLastSection(true);\n \n-        // create peer table context menu actions\n-        QAction* disconnectAction = new QAction(tr(\"&Disconnect\"), this);\n-        QAction* banAction1h = new QAction(ts.ban_for + \" \" + tr(\"1 &hour\"), this);\n-        QAction* banAction24h = new QAction(ts.ban_for + \" \" + tr(\"1 &day\"), this);\n-        QAction* banAction7d = new QAction(ts.ban_for + \" \" + tr(\"1 &week\"), this);\n-        QAction* banAction365d = new QAction(ts.ban_for + \" \" + tr(\"1 &year\"), this);\n-\n         // create peer table context menu\n         peersTableContextMenu = new QMenu(this);\n-        peersTableContextMenu->addAction(disconnectAction);\n-        peersTableContextMenu->addAction(banAction1h);\n-        peersTableContextMenu->addAction(banAction24h);\n-        peersTableContextMenu->addAction(banAction7d);\n-        peersTableContextMenu->addAction(banAction365d);\n-\n-        connect(banAction1h, &QAction::triggered, [this] { banSelectedNode(60 * 60); });\n-        connect(banAction24h, &QAction::triggered, [this] { banSelectedNode(60 * 60 * 24); });\n-        connect(banAction7d, &QAction::triggered, [this] { banSelectedNode(60 * 60 * 24 * 7); });\n-        connect(banAction365d, &QAction::triggered, [this] { banSelectedNode(60 * 60 * 24 * 365); });\n-\n-        // peer table context menu signals\n+        peersTableContextMenu->addAction(tr(\"Disconnect\"), this, &RPCConsole::disconnectSelectedNode);\n+        peersTableContextMenu->addAction(ts.ban_for + \" \" + tr(\"1 hour\"), [this] { banSelectedNode(60 * 60); });\n+        peersTableContextMenu->addAction(ts.ban_for + \" \" + tr(\"1 day\"), [this] { banSelectedNode(60 * 60 * 24); });\n+        peersTableContextMenu->addAction(ts.ban_for + \" \" + tr(\"1 week\"), [this] { banSelectedNode(60 * 60 * 24 * 7); });\n+        peersTableContextMenu->addAction(ts.ban_for + \" \" + tr(\"1 year\"), [this] { banSelectedNode(60 * 60 * 24 * 365); });\n         connect(ui->peerWidget, &QTableView::customContextMenuRequested, this, &RPCConsole::showPeersTableContextMenu);\n-        connect(disconnectAction, &QAction::triggered, this, &RPCConsole::disconnectSelectedNode);\n \n         // peer table signal handling - update peer details when selecting new node\n         connect(ui->peerWidget->selectionModel(), &QItemSelectionModel::selectionChanged, this, &RPCConsole::updateDetailWidget);\n-        // peer table signal handling - update peer details when new nodes are added to the model\n-        connect(model->getPeerTableModel(), &PeerTableModel::layoutChanged, this, &RPCConsole::peerLayoutChanged);\n-        // peer table signal handling - cache selected node ids\n-        connect(model->getPeerTableModel(), &PeerTableModel::layoutAboutToBeChanged, this, &RPCConsole::peerLayoutAboutToChange);\n+        connect(model->getPeerTableModel(), &PeerTableModel::layoutChanged, this, &RPCConsole::updateDetailWidget);\n \n         // set up ban table\n         ui->banlistWidget->setModel(model->getBanTableModel());\n@@ -657,16 +640,10 @@ void RPCConsole::setClientModel(ClientModel *model, int bestblock_height, int64_\n         ui->banlistWidget->setColumnWidth(BanTableModel::Bantime, BANTIME_COLUMN_WIDTH);\n         ui->banlistWidget->horizontalHeader()->setStretchLastSection(true);\n \n-        // create ban table context menu action\n-        QAction* unbanAction = new QAction(tr(\"&Unban\"), this);\n-\n         // create ban table context menu\n         banTableContextMenu = new QMenu(this);\n-        banTableContextMenu->addAction(unbanAction);\n-\n-        // ban table context menu signals\n+        banTableContextMenu->addAction(tr(\"Unban\"), this, &RPCConsole::unbanSelectedNode);\n         connect(ui->banlistWidget, &QTableView::customContextMenuRequested, this, &RPCConsole::showBanTableContextMenu);\n-        connect(unbanAction, &QAction::triggered, this, &RPCConsole::unbanSelectedNode);\n \n         // ban table signal handling - clear peer details when clicking a peer in the ban table\n         connect(ui->banlistWidget, &QTableView::clicked, this, &RPCConsole::clearSelectedNode);\n@@ -1035,67 +1012,6 @@ void RPCConsole::updateTrafficStats(quint64 totalBytesIn, quint64 totalBytesOut)\n     ui->lblBytesOut->setText(GUIUtil::formatBytes(totalBytesOut));\n }\n \n-void RPCConsole::peerLayoutAboutToChange()\n-{\n-    cachedNodeids.clear();\n-    for (const QModelIndex& peer : GUIUtil::getEntryData(ui->peerWidget, PeerTableModel::NetNodeId)) {\n-        const auto stats = peer.data(PeerTableModel::StatsRole).value<CNodeCombinedStats*>();\n-        cachedNodeids.append(stats->nodeStats.nodeid);\n-    }\n-}\n-\n-void RPCConsole::peerLayoutChanged()\n-{\n-    if (!clientModel || !clientModel->getPeerTableModel())\n-        return;\n-\n-    bool fUnselect = false;\n-    bool fReselect = false;\n-\n-    if (cachedNodeids.empty()) // no node selected yet\n-        return;\n-\n-    // find the currently selected row\n-    int selectedRow = -1;\n-    QModelIndexList selectedModelIndex = ui->peerWidget->selectionModel()->selectedIndexes();\n-    if (!selectedModelIndex.isEmpty()) {\n-        selectedRow = selectedModelIndex.first().row();\n-    }\n-\n-    // check if our detail node has a row in the table (it may not necessarily\n-    // be at selectedRow since its position can change after a layout change)\n-    int detailNodeRow = clientModel->getPeerTableModel()->getRowByNodeId(cachedNodeids.first());\n-\n-    if (detailNodeRow < 0)\n-    {\n-        // detail node disappeared from table (node disconnected)\n-        fUnselect = true;\n-    }\n-    else\n-    {\n-        if (detailNodeRow != selectedRow)\n-        {\n-            // detail node moved position\n-            fUnselect = true;\n-            fReselect = true;\n-        }\n-    }\n-\n-    if (fUnselect && selectedRow >= 0) {\n-        clearSelectedNode();\n-    }\n-\n-    if (fReselect)\n-    {\n-        for(int i = 0; i < cachedNodeids.size(); i++)\n-        {\n-            ui->peerWidget->selectRow(clientModel->getPeerTableModel()->getRowByNodeId(cachedNodeids.at(i)));\n-        }\n-    }\n-\n-    updateDetailWidget();\n-}\n-\n void RPCConsole::updateDetailWidget()\n {\n     const QList<QModelIndex> selected_peers = GUIUtil::getEntryData(ui->peerWidget, PeerTableModel::NetNodeId);"
      },
      {
        "sha": "5182d60a0d73ddb2bf98a76cdfcda005b5316719",
        "filename": "src/qt/rpcconsole.h",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/rpcconsole.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/rpcconsole.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -118,10 +118,6 @@ public Q_SLOTS:\n     void browseHistory(int offset);\n     /** Scroll console view to end */\n     void scrollToEnd();\n-    /** Handle selection caching before update */\n-    void peerLayoutAboutToChange();\n-    /** Handle updated peer information */\n-    void peerLayoutChanged();\n     /** Disconnect a selected node on the Peers tab */\n     void disconnectSelectedNode();\n     /** Ban a selected node on the Peers tab */"
      },
      {
        "sha": "e1a4faa266f53e431d1e7c332139d59d7b4cca79",
        "filename": "src/qt/sendcoinsdialog.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 11,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/sendcoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/sendcoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -271,7 +271,7 @@ bool SendCoinsDialog::PrepareSendText(QString& question_string, QString& informa\n     m_current_transaction = std::make_unique<WalletModelTransaction>(recipients);\n     WalletModel::SendCoinsReturn prepareStatus;\n \n-    updateCoinControlState(*m_coin_control);\n+    updateCoinControlState();\n \n     prepareStatus = model->prepareTransaction(*m_current_transaction, *m_coin_control);\n \n@@ -740,19 +740,19 @@ void SendCoinsDialog::updateFeeMinimizedLabel()\n     }\n }\n \n-void SendCoinsDialog::updateCoinControlState(CCoinControl& ctrl)\n+void SendCoinsDialog::updateCoinControlState()\n {\n     if (ui->radioCustomFee->isChecked()) {\n-        ctrl.m_feerate = CFeeRate(ui->customFee->value());\n+        m_coin_control->m_feerate = CFeeRate(ui->customFee->value());\n     } else {\n-        ctrl.m_feerate.reset();\n+        m_coin_control->m_feerate.reset();\n     }\n     // Avoid using global defaults when sending money from the GUI\n     // Either custom fee will be used or if not selected, the confirmation target from dropdown box\n-    ctrl.m_confirm_target = getConfTargetForIndex(ui->confTargetSelector->currentIndex());\n-    ctrl.m_signal_bip125_rbf = ui->optInRBF->isChecked();\n+    m_coin_control->m_confirm_target = getConfTargetForIndex(ui->confTargetSelector->currentIndex());\n+    m_coin_control->m_signal_bip125_rbf = ui->optInRBF->isChecked();\n     // Include watch-only for wallets without private key\n-    ctrl.fAllowWatchOnly = model->wallet().privateKeysDisabled();\n+    m_coin_control->fAllowWatchOnly = model->wallet().privateKeysDisabled();\n }\n \n void SendCoinsDialog::updateNumberOfBlocks(int count, const QDateTime& blockDate, double nVerificationProgress, bool headers, SynchronizationState sync_state) {\n@@ -765,7 +765,7 @@ void SendCoinsDialog::updateSmartFeeLabel()\n {\n     if(!model || !model->getOptionsModel())\n         return;\n-    updateCoinControlState(*m_coin_control);\n+    updateCoinControlState();\n     m_coin_control->m_feerate.reset(); // Explicitly use only fee estimation rate for smart fee labels\n     int returned_target;\n     FeeReason reason;\n@@ -839,8 +839,9 @@ void SendCoinsDialog::coinControlFeatureChanged(bool checked)\n {\n     ui->frameCoinControl->setVisible(checked);\n \n-    if (!checked && model) // coin control features disabled\n-        m_coin_control->SetNull();\n+    if (!checked && model) { // coin control features disabled\n+        m_coin_control = std::make_unique<CCoinControl>();\n+    }\n \n     coinControlUpdateLabels();\n }\n@@ -928,7 +929,7 @@ void SendCoinsDialog::coinControlUpdateLabels()\n     if (!model || !model->getOptionsModel())\n         return;\n \n-    updateCoinControlState(*m_coin_control);\n+    updateCoinControlState();\n \n     // set pay amounts\n     CoinControlDialog::payAmounts.clear();"
      },
      {
        "sha": "33736f8095bacb3a60522fa37a1ec80d62dea1ca",
        "filename": "src/qt/sendcoinsdialog.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/sendcoinsdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/sendcoinsdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -76,8 +76,7 @@ public Q_SLOTS:\n     // Format confirmation message\n     bool PrepareSendText(QString& question_string, QString& informative_text, QString& detailed_text);\n     void updateFeeMinimizedLabel();\n-    // Update the passed in CCoinControl with state from the GUI\n-    void updateCoinControlState(CCoinControl& ctrl);\n+    void updateCoinControlState();\n \n private Q_SLOTS:\n     void sendButtonClicked(bool checked);"
      },
      {
        "sha": "890d1a1740fe0252ce8cb6f520180307876026a9",
        "filename": "src/qt/transactionview.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 33,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/transactionview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/qt/transactionview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -161,32 +161,21 @@ TransactionView::TransactionView(const PlatformStyle *platformStyle, QWidget *pa\n         transactionView->horizontalHeader()->setStretchLastSection(true);\n     }\n \n-    // Actions\n-    abandonAction = new QAction(tr(\"Abandon transaction\"), this);\n-    bumpFeeAction = new QAction(tr(\"Increase transaction fee\"), this);\n-    bumpFeeAction->setObjectName(\"bumpFeeAction\");\n-    copyAddressAction = new QAction(tr(\"Copy address\"), this);\n-    copyLabelAction = new QAction(tr(\"Copy label\"), this);\n-    QAction *copyAmountAction = new QAction(tr(\"Copy amount\"), this);\n-    QAction *copyTxIDAction = new QAction(tr(\"Copy transaction ID\"), this);\n-    QAction *copyTxHexAction = new QAction(tr(\"Copy raw transaction\"), this);\n-    QAction *copyTxPlainText = new QAction(tr(\"Copy full transaction details\"), this);\n-    QAction *editLabelAction = new QAction(tr(\"Edit address label\"), this);\n-    QAction *showDetailsAction = new QAction(tr(\"Show transaction details\"), this);\n-\n     contextMenu = new QMenu(this);\n     contextMenu->setObjectName(\"contextMenu\");\n-    contextMenu->addAction(copyAddressAction);\n-    contextMenu->addAction(copyLabelAction);\n-    contextMenu->addAction(copyAmountAction);\n-    contextMenu->addAction(copyTxIDAction);\n-    contextMenu->addAction(copyTxHexAction);\n-    contextMenu->addAction(copyTxPlainText);\n-    contextMenu->addAction(showDetailsAction);\n+    copyAddressAction = contextMenu->addAction(tr(\"Copy address\"), this, &TransactionView::copyAddress);\n+    copyLabelAction = contextMenu->addAction(tr(\"Copy label\"), this, &TransactionView::copyLabel);\n+    contextMenu->addAction(tr(\"Copy amount\"), this, &TransactionView::copyAmount);\n+    contextMenu->addAction(tr(\"Copy transaction ID\"), this, &TransactionView::copyTxID);\n+    contextMenu->addAction(tr(\"Copy raw transaction\"), this, &TransactionView::copyTxHex);\n+    contextMenu->addAction(tr(\"Copy full transaction details\"), this, &TransactionView::copyTxPlainText);\n+    contextMenu->addAction(tr(\"Show transaction details\"), this, &TransactionView::showDetails);\n     contextMenu->addSeparator();\n-    contextMenu->addAction(bumpFeeAction);\n-    contextMenu->addAction(abandonAction);\n-    contextMenu->addAction(editLabelAction);\n+    bumpFeeAction = contextMenu->addAction(tr(\"Increase transaction fee\"));\n+    GUIUtil::ExceptionSafeConnect(bumpFeeAction, &QAction::triggered, this, &TransactionView::bumpFee);\n+    bumpFeeAction->setObjectName(\"bumpFeeAction\");\n+    abandonAction = contextMenu->addAction(tr(\"Abandon transaction\"), this, &TransactionView::abandonTx);\n+    contextMenu->addAction(tr(\"Edit address label\"), this, &TransactionView::editLabel);\n \n     connect(dateWidget, static_cast<void (QComboBox::*)(int)>(&QComboBox::activated), this, &TransactionView::chooseDate);\n     connect(typeWidget, static_cast<void (QComboBox::*)(int)>(&QComboBox::activated), this, &TransactionView::chooseType);\n@@ -199,16 +188,6 @@ TransactionView::TransactionView(const PlatformStyle *platformStyle, QWidget *pa\n     connect(transactionView, &QTableView::doubleClicked, this, &TransactionView::doubleClicked);\n     connect(transactionView, &QTableView::customContextMenuRequested, this, &TransactionView::contextualMenu);\n \n-    GUIUtil::ExceptionSafeConnect(bumpFeeAction, &QAction::triggered, this, &TransactionView::bumpFee);\n-    connect(abandonAction, &QAction::triggered, this, &TransactionView::abandonTx);\n-    connect(copyAddressAction, &QAction::triggered, this, &TransactionView::copyAddress);\n-    connect(copyLabelAction, &QAction::triggered, this, &TransactionView::copyLabel);\n-    connect(copyAmountAction, &QAction::triggered, this, &TransactionView::copyAmount);\n-    connect(copyTxIDAction, &QAction::triggered, this, &TransactionView::copyTxID);\n-    connect(copyTxHexAction, &QAction::triggered, this, &TransactionView::copyTxHex);\n-    connect(copyTxPlainText, &QAction::triggered, this, &TransactionView::copyTxPlainText);\n-    connect(editLabelAction, &QAction::triggered, this, &TransactionView::editLabel);\n-    connect(showDetailsAction, &QAction::triggered, this, &TransactionView::showDetails);\n     // Double-clicking on a transaction on the transaction history page shows details\n     connect(this, &TransactionView::doubleClicked, this, &TransactionView::showDetails);\n     // Highlight transaction after fee bump"
      },
      {
        "sha": "d36814716bbbef0da5757f7baa2165570708d04b",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -1239,7 +1239,8 @@ static RPCHelpMan verifychain()\n     LOCK(cs_main);\n \n     CChainState& active_chainstate = chainman.ActiveChainstate();\n-    return CVerifyDB().VerifyDB(Params(), active_chainstate, &active_chainstate.CoinsTip(), check_level, check_depth);\n+    return CVerifyDB().VerifyDB(\n+        active_chainstate, Params(), active_chainstate.CoinsTip(), check_level, check_depth);\n },\n     };\n }"
      },
      {
        "sha": "f7cf1a785179d7c9471b41fc204b949c080b7204",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -18,6 +18,7 @@\n #include <pow.h>\n #include <rpc/blockchain.h>\n #include <rpc/mining.h>\n+#include <rpc/net.h>\n #include <rpc/server.h>\n #include <rpc/util.h>\n #include <script/descriptor.h>\n@@ -671,11 +672,9 @@ static RPCHelpMan getblocktemplate()\n     if (strMode != \"template\")\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid mode\");\n \n-    if(!node.connman)\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n-\n     if (!Params().IsTestChain()) {\n-        if (node.connman->GetNodeCount(ConnectionDirection::Both) == 0) {\n+        const CConnman& connman = EnsureConnman(node);\n+        if (connman.GetNodeCount(ConnectionDirection::Both) == 0) {\n             throw JSONRPCError(RPC_CLIENT_NOT_CONNECTED, PACKAGE_NAME \" is not connected!\");\n         }\n "
      },
      {
        "sha": "09b32345a28abb69232b422ec378075f7e6fc200",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 0,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -7,6 +7,9 @@\n #include <index/blockfilterindex.h>\n #include <index/txindex.h>\n #include <interfaces/chain.h>\n+#include <interfaces/echo.h>\n+#include <interfaces/init.h>\n+#include <interfaces/ipc.h>\n #include <key_io.h>\n #include <node/context.h>\n #include <outputtype.h>\n@@ -644,6 +647,43 @@ static RPCHelpMan echo(const std::string& name)\n static RPCHelpMan echo() { return echo(\"echo\"); }\n static RPCHelpMan echojson() { return echo(\"echojson\"); }\n \n+static RPCHelpMan echoipc()\n+{\n+    return RPCHelpMan{\n+        \"echoipc\",\n+        \"\\nEcho back the input argument, passing it through a spawned process in a multiprocess build.\\n\"\n+        \"This command is for testing.\\n\",\n+        {{\"arg\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The string to echo\",}},\n+        RPCResult{RPCResult::Type::STR, \"echo\", \"The echoed string.\"},\n+        RPCExamples{HelpExampleCli(\"echo\", \"\\\"Hello world\\\"\") +\n+                    HelpExampleRpc(\"echo\", \"\\\"Hello world\\\"\")},\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue {\n+            std::unique_ptr<interfaces::Echo> echo;\n+            if (interfaces::Ipc* ipc = Assert(EnsureAnyNodeContext(request.context).init)->ipc()) {\n+                // Spawn a new bitcoin-node process and call makeEcho to get a\n+                // client pointer to a interfaces::Echo instance running in\n+                // that process. This is just for testing. A slightly more\n+                // realistic test spawning a different executable instead of\n+                // the same executable would add a new bitcoin-echo executable,\n+                // and spawn bitcoin-echo below instead of bitcoin-node. But\n+                // using bitcoin-node avoids the need to build and install a\n+                // new executable just for this one test.\n+                auto init = ipc->spawnProcess(\"bitcoin-node\");\n+                echo = init->makeEcho();\n+                ipc->addCleanup(*echo, [init = init.release()] { delete init; });\n+            } else {\n+                // IPC support is not available because this is a bitcoind\n+                // process not a bitcoind-node process, so just create a local\n+                // interfaces::Echo object and return it so the `echoipc` RPC\n+                // method will work, and the python test calling `echoipc`\n+                // can expect the same result.\n+                echo = interfaces::MakeEcho();\n+            }\n+            return echo->echo(request.params[0].get_str());\n+        },\n+    };\n+}\n+\n static UniValue SummaryToJSON(const IndexSummary&& summary, std::string index_name)\n {\n     UniValue ret_summary(UniValue::VOBJ);\n@@ -719,6 +759,7 @@ static const CRPCCommand commands[] =\n     { \"hidden\",             &mockscheduler,           },\n     { \"hidden\",             &echo,                    },\n     { \"hidden\",             &echojson,                },\n+    { \"hidden\",             &echoipc,                 },\n };\n // clang-format on\n     for (const auto& c : commands) {"
      },
      {
        "sha": "2bfcaeafc98877e843f2a4bf3e9c9e738127157c",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 51,
        "deletions": 47,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -39,6 +39,22 @@ const std::vector<std::string> CONNECTION_TYPE_DOC{\n         \"feeler (short-lived automatic connection for testing addresses)\"\n };\n \n+CConnman& EnsureConnman(const NodeContext& node)\n+{\n+    if (!node.connman) {\n+        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n+    }\n+    return *node.connman;\n+}\n+\n+PeerManager& EnsurePeerman(const NodeContext& node)\n+{\n+    if (!node.peerman) {\n+        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n+    }\n+    return *node.peerman;\n+}\n+\n static RPCHelpMan getconnectioncount()\n {\n     return RPCHelpMan{\"getconnectioncount\",\n@@ -54,10 +70,9 @@ static RPCHelpMan getconnectioncount()\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n     NodeContext& node = EnsureAnyNodeContext(request.context);\n-    if(!node.connman)\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n+    const CConnman& connman = EnsureConnman(node);\n \n-    return (int)node.connman->GetNodeCount(ConnectionDirection::Both);\n+    return (int)connman.GetNodeCount(ConnectionDirection::Both);\n },\n     };\n }\n@@ -77,12 +92,10 @@ static RPCHelpMan ping()\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n     NodeContext& node = EnsureAnyNodeContext(request.context);\n-    if (!node.peerman) {\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n-    }\n+    PeerManager& peerman = EnsurePeerman(node);\n \n     // Request that each node send a ping during next message processing pass\n-    node.peerman->SendPings();\n+    peerman.SendPings();\n     return NullUniValue;\n },\n     };\n@@ -166,19 +179,18 @@ static RPCHelpMan getpeerinfo()\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n     NodeContext& node = EnsureAnyNodeContext(request.context);\n-    if(!node.connman || !node.peerman) {\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n-    }\n+    const CConnman& connman = EnsureConnman(node);\n+    const PeerManager& peerman = EnsurePeerman(node);\n \n     std::vector<CNodeStats> vstats;\n-    node.connman->GetNodeStats(vstats);\n+    connman.GetNodeStats(vstats);\n \n     UniValue ret(UniValue::VARR);\n \n     for (const CNodeStats& stats : vstats) {\n         UniValue obj(UniValue::VOBJ);\n         CNodeStateStats statestats;\n-        bool fStateStats = node.peerman->GetNodeStateStats(stats.nodeid, statestats);\n+        bool fStateStats = peerman.GetNodeStateStats(stats.nodeid, statestats);\n         obj.pushKV(\"id\", stats.nodeid);\n         obj.pushKV(\"addr\", stats.addrName);\n         if (stats.addrBind.IsValid()) {\n@@ -286,27 +298,28 @@ static RPCHelpMan addnode()\n     }\n \n     NodeContext& node = EnsureAnyNodeContext(request.context);\n-    if(!node.connman)\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n+    CConnman& connman = EnsureConnman(node);\n \n     std::string strNode = request.params[0].get_str();\n \n     if (strCommand == \"onetry\")\n     {\n         CAddress addr;\n-        node.connman->OpenNetworkConnection(addr, false, nullptr, strNode.c_str(), ConnectionType::MANUAL);\n+        connman.OpenNetworkConnection(addr, false, nullptr, strNode.c_str(), ConnectionType::MANUAL);\n         return NullUniValue;\n     }\n \n     if (strCommand == \"add\")\n     {\n-        if(!node.connman->AddNode(strNode))\n+        if (!connman.AddNode(strNode)) {\n             throw JSONRPCError(RPC_CLIENT_NODE_ALREADY_ADDED, \"Error: Node already added\");\n+        }\n     }\n     else if(strCommand == \"remove\")\n     {\n-        if(!node.connman->RemoveAddedNode(strNode))\n+        if (!connman.RemoveAddedNode(strNode)) {\n             throw JSONRPCError(RPC_CLIENT_NODE_NOT_ADDED, \"Error: Node could not be removed. It has not been added previously.\");\n+        }\n     }\n \n     return NullUniValue;\n@@ -351,11 +364,9 @@ static RPCHelpMan addconnection()\n     }\n \n     NodeContext& node = EnsureAnyNodeContext(request.context);\n-    if (!node.connman) {\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled.\");\n-    }\n+    CConnman& connman = EnsureConnman(node);\n \n-    const bool success = node.connman->AddConnection(address, conn_type);\n+    const bool success = connman.AddConnection(address, conn_type);\n     if (!success) {\n         throw JSONRPCError(RPC_CLIENT_NODE_CAPACITY_REACHED, \"Error: Already at capacity for specified connection type.\");\n     }\n@@ -389,20 +400,19 @@ static RPCHelpMan disconnectnode()\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n     NodeContext& node = EnsureAnyNodeContext(request.context);\n-    if(!node.connman)\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n+    CConnman& connman = EnsureConnman(node);\n \n     bool success;\n     const UniValue &address_arg = request.params[0];\n     const UniValue &id_arg = request.params[1];\n \n     if (!address_arg.isNull() && id_arg.isNull()) {\n         /* handle disconnect-by-address */\n-        success = node.connman->DisconnectNode(address_arg.get_str());\n+        success = connman.DisconnectNode(address_arg.get_str());\n     } else if (!id_arg.isNull() && (address_arg.isNull() || (address_arg.isStr() && address_arg.get_str().empty()))) {\n         /* handle disconnect-by-id */\n         NodeId nodeid = (NodeId) id_arg.get_int64();\n-        success = node.connman->DisconnectNode(nodeid);\n+        success = connman.DisconnectNode(nodeid);\n     } else {\n         throw JSONRPCError(RPC_INVALID_PARAMS, \"Only one of address and nodeid should be provided.\");\n     }\n@@ -449,10 +459,9 @@ static RPCHelpMan getaddednodeinfo()\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n     NodeContext& node = EnsureAnyNodeContext(request.context);\n-    if(!node.connman)\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n+    const CConnman& connman = EnsureConnman(node);\n \n-    std::vector<AddedNodeInfo> vInfo = node.connman->GetAddedNodeInfo();\n+    std::vector<AddedNodeInfo> vInfo = connman.GetAddedNodeInfo();\n \n     if (!request.params[0].isNull()) {\n         bool found = false;\n@@ -520,21 +529,20 @@ static RPCHelpMan getnettotals()\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n     NodeContext& node = EnsureAnyNodeContext(request.context);\n-    if(!node.connman)\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n+    const CConnman& connman = EnsureConnman(node);\n \n     UniValue obj(UniValue::VOBJ);\n-    obj.pushKV(\"totalbytesrecv\", node.connman->GetTotalBytesRecv());\n-    obj.pushKV(\"totalbytessent\", node.connman->GetTotalBytesSent());\n+    obj.pushKV(\"totalbytesrecv\", connman.GetTotalBytesRecv());\n+    obj.pushKV(\"totalbytessent\", connman.GetTotalBytesSent());\n     obj.pushKV(\"timemillis\", GetTimeMillis());\n \n     UniValue outboundLimit(UniValue::VOBJ);\n-    outboundLimit.pushKV(\"timeframe\", count_seconds(node.connman->GetMaxOutboundTimeframe()));\n-    outboundLimit.pushKV(\"target\", node.connman->GetMaxOutboundTarget());\n-    outboundLimit.pushKV(\"target_reached\", node.connman->OutboundTargetReached(false));\n-    outboundLimit.pushKV(\"serve_historical_blocks\", !node.connman->OutboundTargetReached(true));\n-    outboundLimit.pushKV(\"bytes_left_in_cycle\", node.connman->GetOutboundTargetBytesLeft());\n-    outboundLimit.pushKV(\"time_left_in_cycle\", count_seconds(node.connman->GetMaxOutboundTimeLeftInCycle()));\n+    outboundLimit.pushKV(\"timeframe\", count_seconds(connman.GetMaxOutboundTimeframe()));\n+    outboundLimit.pushKV(\"target\", connman.GetMaxOutboundTarget());\n+    outboundLimit.pushKV(\"target_reached\", connman.OutboundTargetReached(false));\n+    outboundLimit.pushKV(\"serve_historical_blocks\", !connman.OutboundTargetReached(true));\n+    outboundLimit.pushKV(\"bytes_left_in_cycle\", connman.GetOutboundTargetBytesLeft());\n+    outboundLimit.pushKV(\"time_left_in_cycle\", count_seconds(connman.GetMaxOutboundTimeLeftInCycle()));\n     obj.pushKV(\"uploadtarget\", outboundLimit);\n     return obj;\n },\n@@ -826,13 +834,11 @@ static RPCHelpMan setnetworkactive()\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n     NodeContext& node = EnsureAnyNodeContext(request.context);\n-    if (!node.connman) {\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n-    }\n+    CConnman& connman = EnsureConnman(node);\n \n-    node.connman->SetNetworkActive(request.params[0].get_bool());\n+    connman.SetNetworkActive(request.params[0].get_bool());\n \n-    return node.connman->GetNetworkActive();\n+    return connman.GetNetworkActive();\n },\n     };\n }\n@@ -864,15 +870,13 @@ static RPCHelpMan getnodeaddresses()\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n     NodeContext& node = EnsureAnyNodeContext(request.context);\n-    if (!node.connman) {\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n-    }\n+    const CConnman& connman = EnsureConnman(node);\n \n     const int count{request.params[0].isNull() ? 1 : request.params[0].get_int()};\n     if (count < 0) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Address count out of range\");\n \n     // returns a shuffled list of CAddress\n-    const std::vector<CAddress> vAddr{node.connman->GetAddresses(count, /* max_pct */ 0)};\n+    const std::vector<CAddress> vAddr{connman.GetAddresses(count, /* max_pct */ 0)};\n     UniValue ret(UniValue::VARR);\n \n     for (const CAddress& addr : vAddr) {"
      },
      {
        "sha": "7a4d8440ba45b95cbdbd027171bc8f8121e4566a",
        "filename": "src/rpc/net.h",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/rpc/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/rpc/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,15 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RPC_NET_H\n+#define BITCOIN_RPC_NET_H\n+\n+class CConnman;\n+class PeerManager;\n+struct NodeContext;\n+\n+CConnman& EnsureConnman(const NodeContext& node);\n+PeerManager& EnsurePeerman(const NodeContext& node);\n+\n+#endif // BITCOIN_RPC_NET_H"
      },
      {
        "sha": "f1433553bc1e817d35ec491a619844fa306e7bf8",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 107,
        "deletions": 82,
        "changes": 189,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -481,34 +481,35 @@ class DescriptorImpl : public Descriptor\n     const std::string m_name;\n \n protected:\n-    //! The sub-descriptor argument (nullptr for everything but SH and WSH).\n+    //! The sub-descriptor arguments (empty for everything but SH and WSH).\n     //! In doc/descriptors.m this is referred to as SCRIPT expressions sh(SCRIPT)\n     //! and wsh(SCRIPT), and distinct from KEY expressions and ADDR expressions.\n-    const std::unique_ptr<DescriptorImpl> m_subdescriptor_arg;\n+    //! Subdescriptors can only ever generate a single script.\n+    const std::vector<std::unique_ptr<DescriptorImpl>> m_subdescriptor_args;\n \n     //! Return a serialization of anything except pubkey and script arguments, to be prepended to those.\n     virtual std::string ToStringExtra() const { return \"\"; }\n \n     /** A helper function to construct the scripts for this descriptor.\n      *\n-     *  This function is invoked once for every CScript produced by evaluating\n-     *  m_subdescriptor_arg, or just once in case m_subdescriptor_arg is nullptr.\n-\n+     *  This function is invoked once by ExpandHelper.\n+     *\n      *  @param pubkeys The evaluations of the m_pubkey_args field.\n-     *  @param script The evaluation of m_subdescriptor_arg (or nullptr when m_subdescriptor_arg is nullptr).\n+     *  @param scripts The evaluations of m_subdescriptor_args (one for each m_subdescriptor_args element).\n      *  @param out A FlatSigningProvider to put scripts or public keys in that are necessary to the solver.\n-     *             The script arguments to this function are automatically added, as is the origin info of the provided pubkeys.\n+     *             The origin info of the provided pubkeys is automatically added.\n      *  @return A vector with scriptPubKeys for this descriptor.\n      */\n-    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, const CScript* script, FlatSigningProvider& out) const = 0;\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, Span<const CScript> scripts, FlatSigningProvider& out) const = 0;\n \n public:\n-    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkey_args(std::move(pubkeys)), m_name(name), m_subdescriptor_arg(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, const std::string& name) : m_pubkey_args(std::move(pubkeys)), m_name(name), m_subdescriptor_args() {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkey_args(std::move(pubkeys)), m_name(name), m_subdescriptor_args(Vector(std::move(script))) {}\n \n     bool IsSolvable() const override\n     {\n-        if (m_subdescriptor_arg) {\n-            if (!m_subdescriptor_arg->IsSolvable()) return false;\n+        for (const auto& arg : m_subdescriptor_args) {\n+            if (!arg->IsSolvable()) return false;\n         }\n         return true;\n     }\n@@ -518,12 +519,24 @@ class DescriptorImpl : public Descriptor\n         for (const auto& pubkey : m_pubkey_args) {\n             if (pubkey->IsRange()) return true;\n         }\n-        if (m_subdescriptor_arg) {\n-            if (m_subdescriptor_arg->IsRange()) return true;\n+        for (const auto& arg : m_subdescriptor_args) {\n+            if (arg->IsRange()) return true;\n         }\n         return false;\n     }\n \n+    virtual bool ToStringSubScriptHelper(const SigningProvider* arg, std::string& ret, bool priv, bool normalized) const\n+    {\n+        size_t pos = 0;\n+        for (const auto& scriptarg : m_subdescriptor_args) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!scriptarg->ToStringHelper(arg, tmp, priv, normalized)) return false;\n+            ret += std::move(tmp);\n+        }\n+        return true;\n+    }\n+\n     bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv, bool normalized) const\n     {\n         std::string extra = ToStringExtra();\n@@ -541,13 +554,10 @@ class DescriptorImpl : public Descriptor\n             }\n             ret += std::move(tmp);\n         }\n-        if (m_subdescriptor_arg) {\n-            if (pos++) ret += \",\";\n-            std::string tmp;\n-            if (!m_subdescriptor_arg->ToStringHelper(arg, tmp, priv, normalized)) return false;\n-            ret += std::move(tmp);\n-        }\n-        out = std::move(ret) + \")\";\n+        std::string subscript;\n+        if (!ToStringSubScriptHelper(arg, subscript, priv, normalized)) return false;\n+        if (pos && subscript.size()) ret += ',';\n+        out = std::move(ret) + std::move(subscript) + \")\";\n         return true;\n     }\n \n@@ -577,35 +587,29 @@ class DescriptorImpl : public Descriptor\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n         entries.reserve(m_pubkey_args.size());\n \n-        // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n+        // Construct temporary data in `entries`, `subscripts`, and `subprovider` to avoid producing output in case of failure.\n         for (const auto& p : m_pubkey_args) {\n             entries.emplace_back();\n             if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second, read_cache, write_cache)) return false;\n         }\n         std::vector<CScript> subscripts;\n-        if (m_subdescriptor_arg) {\n-            FlatSigningProvider subprovider;\n-            if (!m_subdescriptor_arg->ExpandHelper(pos, arg, read_cache, subscripts, subprovider, write_cache)) return false;\n-            out = Merge(out, subprovider);\n+        FlatSigningProvider subprovider;\n+        for (const auto& subarg : m_subdescriptor_args) {\n+            std::vector<CScript> outscripts;\n+            if (!subarg->ExpandHelper(pos, arg, read_cache, outscripts, subprovider, write_cache)) return false;\n+            assert(outscripts.size() == 1);\n+            subscripts.emplace_back(std::move(outscripts[0]));\n         }\n+        out = Merge(std::move(out), std::move(subprovider));\n \n         std::vector<CPubKey> pubkeys;\n         pubkeys.reserve(entries.size());\n         for (auto& entry : entries) {\n             pubkeys.push_back(entry.first);\n             out.origins.emplace(entry.first.GetID(), std::make_pair<CPubKey, KeyOriginInfo>(CPubKey(entry.first), std::move(entry.second)));\n         }\n-        if (m_subdescriptor_arg) {\n-            for (const auto& subscript : subscripts) {\n-                out.scripts.emplace(CScriptID(subscript), subscript);\n-                std::vector<CScript> addscripts = MakeScripts(pubkeys, &subscript, out);\n-                for (auto& addscript : addscripts) {\n-                    output_scripts.push_back(std::move(addscript));\n-                }\n-            }\n-        } else {\n-            output_scripts = MakeScripts(pubkeys, nullptr, out);\n-        }\n+\n+        output_scripts = MakeScripts(pubkeys, MakeSpan(subscripts), out);\n         return true;\n     }\n \n@@ -626,10 +630,8 @@ class DescriptorImpl : public Descriptor\n             if (!p->GetPrivKey(pos, provider, key)) continue;\n             out.keys.emplace(key.GetPubKey().GetID(), key);\n         }\n-        if (m_subdescriptor_arg) {\n-            FlatSigningProvider subprovider;\n-            m_subdescriptor_arg->ExpandPrivate(pos, provider, subprovider);\n-            out = Merge(out, subprovider);\n+        for (const auto& arg : m_subdescriptor_args) {\n+            arg->ExpandPrivate(pos, provider, out);\n         }\n     }\n \n@@ -642,9 +644,9 @@ class AddressDescriptor final : public DescriptorImpl\n     const CTxDestination m_destination;\n protected:\n     std::string ToStringExtra() const override { return EncodeDestination(m_destination); }\n-    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript*, FlatSigningProvider&) const override { return Vector(GetScriptForDestination(m_destination)); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, Span<const CScript>, FlatSigningProvider&) const override { return Vector(GetScriptForDestination(m_destination)); }\n public:\n-    AddressDescriptor(CTxDestination destination) : DescriptorImpl({}, {}, \"addr\"), m_destination(std::move(destination)) {}\n+    AddressDescriptor(CTxDestination destination) : DescriptorImpl({}, \"addr\"), m_destination(std::move(destination)) {}\n     bool IsSolvable() const final { return false; }\n \n     std::optional<OutputType> GetOutputType() const override\n@@ -668,9 +670,9 @@ class RawDescriptor final : public DescriptorImpl\n     const CScript m_script;\n protected:\n     std::string ToStringExtra() const override { return HexStr(m_script); }\n-    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript*, FlatSigningProvider&) const override { return Vector(m_script); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, Span<const CScript>, FlatSigningProvider&) const override { return Vector(m_script); }\n public:\n-    RawDescriptor(CScript script) : DescriptorImpl({}, {}, \"raw\"), m_script(std::move(script)) {}\n+    RawDescriptor(CScript script) : DescriptorImpl({}, \"raw\"), m_script(std::move(script)) {}\n     bool IsSolvable() const final { return false; }\n \n     std::optional<OutputType> GetOutputType() const override\n@@ -694,24 +696,24 @@ class RawDescriptor final : public DescriptorImpl\n class PKDescriptor final : public DescriptorImpl\n {\n protected:\n-    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, const CScript*, FlatSigningProvider&) const override { return Vector(GetScriptForRawPubKey(keys[0])); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, Span<const CScript>, FlatSigningProvider&) const override { return Vector(GetScriptForRawPubKey(keys[0])); }\n public:\n-    PKDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Vector(std::move(prov)), {}, \"pk\") {}\n+    PKDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Vector(std::move(prov)), \"pk\") {}\n     bool IsSingleType() const final { return true; }\n };\n \n /** A parsed pkh(P) descriptor. */\n class PKHDescriptor final : public DescriptorImpl\n {\n protected:\n-    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, const CScript*, FlatSigningProvider& out) const override\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, Span<const CScript>, FlatSigningProvider& out) const override\n     {\n         CKeyID id = keys[0].GetID();\n         out.pubkeys.emplace(id, keys[0]);\n         return Vector(GetScriptForDestination(PKHash(id)));\n     }\n public:\n-    PKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Vector(std::move(prov)), {}, \"pkh\") {}\n+    PKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Vector(std::move(prov)), \"pkh\") {}\n     std::optional<OutputType> GetOutputType() const override { return OutputType::LEGACY; }\n     bool IsSingleType() const final { return true; }\n };\n@@ -720,14 +722,14 @@ class PKHDescriptor final : public DescriptorImpl\n class WPKHDescriptor final : public DescriptorImpl\n {\n protected:\n-    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, const CScript*, FlatSigningProvider& out) const override\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, Span<const CScript>, FlatSigningProvider& out) const override\n     {\n         CKeyID id = keys[0].GetID();\n         out.pubkeys.emplace(id, keys[0]);\n         return Vector(GetScriptForDestination(WitnessV0KeyHash(id)));\n     }\n public:\n-    WPKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Vector(std::move(prov)), {}, \"wpkh\") {}\n+    WPKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Vector(std::move(prov)), \"wpkh\") {}\n     std::optional<OutputType> GetOutputType() const override { return OutputType::BECH32; }\n     bool IsSingleType() const final { return true; }\n };\n@@ -736,7 +738,7 @@ class WPKHDescriptor final : public DescriptorImpl\n class ComboDescriptor final : public DescriptorImpl\n {\n protected:\n-    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, const CScript*, FlatSigningProvider& out) const override\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, Span<const CScript>, FlatSigningProvider& out) const override\n     {\n         std::vector<CScript> ret;\n         CKeyID id = keys[0].GetID();\n@@ -752,7 +754,7 @@ class ComboDescriptor final : public DescriptorImpl\n         return ret;\n     }\n public:\n-    ComboDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Vector(std::move(prov)), {}, \"combo\") {}\n+    ComboDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Vector(std::move(prov)), \"combo\") {}\n     bool IsSingleType() const final { return false; }\n };\n \n@@ -763,7 +765,7 @@ class MultisigDescriptor final : public DescriptorImpl\n     const bool m_sorted;\n protected:\n     std::string ToStringExtra() const override { return strprintf(\"%i\", m_threshold); }\n-    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, const CScript*, FlatSigningProvider&) const override {\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, Span<const CScript>, FlatSigningProvider&) const override {\n         if (m_sorted) {\n             std::vector<CPubKey> sorted_keys(keys);\n             std::sort(sorted_keys.begin(), sorted_keys.end());\n@@ -772,22 +774,27 @@ class MultisigDescriptor final : public DescriptorImpl\n         return Vector(GetScriptForMultisig(m_threshold, keys));\n     }\n public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers, bool sorted = false) : DescriptorImpl(std::move(providers), {}, sorted ? \"sortedmulti\" : \"multi\"), m_threshold(threshold), m_sorted(sorted) {}\n+    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers, bool sorted = false) : DescriptorImpl(std::move(providers), sorted ? \"sortedmulti\" : \"multi\"), m_threshold(threshold), m_sorted(sorted) {}\n     bool IsSingleType() const final { return true; }\n };\n \n /** A parsed sh(...) descriptor. */\n class SHDescriptor final : public DescriptorImpl\n {\n protected:\n-    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript* script, FlatSigningProvider&) const override { return Vector(GetScriptForDestination(ScriptHash(*script))); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, Span<const CScript> scripts, FlatSigningProvider& out) const override\n+    {\n+        auto ret = Vector(GetScriptForDestination(ScriptHash(scripts[0])));\n+        if (ret.size()) out.scripts.emplace(CScriptID(scripts[0]), scripts[0]);\n+        return ret;\n+    }\n public:\n     SHDescriptor(std::unique_ptr<DescriptorImpl> desc) : DescriptorImpl({}, std::move(desc), \"sh\") {}\n \n     std::optional<OutputType> GetOutputType() const override\n     {\n-        assert(m_subdescriptor_arg);\n-        if (m_subdescriptor_arg->GetOutputType() == OutputType::BECH32) return OutputType::P2SH_SEGWIT;\n+        assert(m_subdescriptor_args.size() == 1);\n+        if (m_subdescriptor_args[0]->GetOutputType() == OutputType::BECH32) return OutputType::P2SH_SEGWIT;\n         return OutputType::LEGACY;\n     }\n     bool IsSingleType() const final { return true; }\n@@ -797,7 +804,12 @@ class SHDescriptor final : public DescriptorImpl\n class WSHDescriptor final : public DescriptorImpl\n {\n protected:\n-    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript* script, FlatSigningProvider&) const override { return Vector(GetScriptForDestination(WitnessV0ScriptHash(*script))); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, Span<const CScript> scripts, FlatSigningProvider& out) const override\n+    {\n+        auto ret = Vector(GetScriptForDestination(WitnessV0ScriptHash(scripts[0])));\n+        if (ret.size()) out.scripts.emplace(CScriptID(scripts[0]), scripts[0]);\n+        return ret;\n+    }\n public:\n     WSHDescriptor(std::unique_ptr<DescriptorImpl> desc) : DescriptorImpl({}, std::move(desc), \"wsh\") {}\n     std::optional<OutputType> GetOutputType() const override { return OutputType::BECH32; }\n@@ -809,9 +821,10 @@ class WSHDescriptor final : public DescriptorImpl\n ////////////////////////////////////////////////////////////////////////////\n \n enum class ParseScriptContext {\n-    TOP,\n-    P2SH,\n-    P2WSH,\n+    TOP,     //!< Top-level context (script goes directly in scriptPubKey)\n+    P2SH,    //!< Inside sh() (script becomes P2SH redeemScript)\n+    P2WPKH,  //!< Inside wpkh() (no script, pubkey only)\n+    P2WSH,   //!< Inside wsh() (script becomes v0 witness script)\n };\n \n /** Parse a key path, being passed a split list of elements (the first element is ignored). */\n@@ -838,10 +851,11 @@ enum class ParseScriptContext {\n }\n \n /** Parse a public key that excludes origin information. */\n-std::unique_ptr<PubkeyProvider> ParsePubkeyInner(uint32_t key_exp_index, const Span<const char>& sp, bool permit_uncompressed, FlatSigningProvider& out, std::string& error)\n+std::unique_ptr<PubkeyProvider> ParsePubkeyInner(uint32_t key_exp_index, const Span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     using namespace spanparsing;\n \n+    bool permit_uncompressed = ctx == ParseScriptContext::TOP || ctx == ParseScriptContext::P2SH;\n     auto split = Split(sp, '/');\n     std::string str(split[0].begin(), split[0].end());\n     if (str.size() == 0) {\n@@ -899,7 +913,7 @@ std::unique_ptr<PubkeyProvider> ParsePubkeyInner(uint32_t key_exp_index, const S\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::unique_ptr<PubkeyProvider> ParsePubkey(uint32_t key_exp_index, const Span<const char>& sp, bool permit_uncompressed, FlatSigningProvider& out, std::string& error)\n+std::unique_ptr<PubkeyProvider> ParsePubkey(uint32_t key_exp_index, const Span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     using namespace spanparsing;\n \n@@ -908,7 +922,7 @@ std::unique_ptr<PubkeyProvider> ParsePubkey(uint32_t key_exp_index, const Span<c\n         error = \"Multiple ']' characters found for a single pubkey\";\n         return nullptr;\n     }\n-    if (origin_split.size() == 1) return ParsePubkeyInner(key_exp_index, origin_split[0], permit_uncompressed, out, error);\n+    if (origin_split.size() == 1) return ParsePubkeyInner(key_exp_index, origin_split[0], ctx, out, error);\n     if (origin_split[0].empty() || origin_split[0][0] != '[') {\n         error = strprintf(\"Key origin start '[ character expected but not found, got '%c' instead\",\n                           origin_split[0].empty() ? /** empty, implies split char */ ']' : origin_split[0][0]);\n@@ -930,34 +944,37 @@ std::unique_ptr<PubkeyProvider> ParsePubkey(uint32_t key_exp_index, const Span<c\n     assert(fpr_bytes.size() == 4);\n     std::copy(fpr_bytes.begin(), fpr_bytes.end(), info.fingerprint);\n     if (!ParseKeyPath(slash_split, info.path, error)) return nullptr;\n-    auto provider = ParsePubkeyInner(key_exp_index, origin_split[1], permit_uncompressed, out, error);\n+    auto provider = ParsePubkeyInner(key_exp_index, origin_split[1], ctx, out, error);\n     if (!provider) return nullptr;\n     return std::make_unique<OriginPubkeyProvider>(key_exp_index, std::move(info), std::move(provider));\n }\n \n /** Parse a script in a particular context. */\n-std::unique_ptr<DescriptorImpl> ParseScript(uint32_t key_exp_index, Span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+std::unique_ptr<DescriptorImpl> ParseScript(uint32_t& key_exp_index, Span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     using namespace spanparsing;\n \n     auto expr = Expr(sp);\n     bool sorted_multi = false;\n     if (Func(\"pk\", expr)) {\n-        auto pubkey = ParsePubkey(key_exp_index, expr, ctx != ParseScriptContext::P2WSH, out, error);\n+        auto pubkey = ParsePubkey(key_exp_index, expr, ctx, out, error);\n         if (!pubkey) return nullptr;\n+        ++key_exp_index;\n         return std::make_unique<PKDescriptor>(std::move(pubkey));\n     }\n     if (Func(\"pkh\", expr)) {\n-        auto pubkey = ParsePubkey(key_exp_index, expr, ctx != ParseScriptContext::P2WSH, out, error);\n+        auto pubkey = ParsePubkey(key_exp_index, expr, ctx, out, error);\n         if (!pubkey) return nullptr;\n+        ++key_exp_index;\n         return std::make_unique<PKHDescriptor>(std::move(pubkey));\n     }\n     if (ctx == ParseScriptContext::TOP && Func(\"combo\", expr)) {\n-        auto pubkey = ParsePubkey(key_exp_index, expr, true, out, error);\n+        auto pubkey = ParsePubkey(key_exp_index, expr, ctx, out, error);\n         if (!pubkey) return nullptr;\n+        ++key_exp_index;\n         return std::make_unique<ComboDescriptor>(std::move(pubkey));\n-    } else if (ctx != ParseScriptContext::TOP && Func(\"combo\", expr)) {\n-        error = \"Cannot have combo in non-top level\";\n+    } else if (Func(\"combo\", expr)) {\n+        error = \"Can only have combo() at top level\";\n         return nullptr;\n     }\n     if ((sorted_multi = Func(\"sortedmulti\", expr)) || Func(\"multi\", expr)) {\n@@ -975,7 +992,7 @@ std::unique_ptr<DescriptorImpl> ParseScript(uint32_t key_exp_index, Span<const c\n                 return nullptr;\n             }\n             auto arg = Expr(expr);\n-            auto pk = ParsePubkey(key_exp_index, arg, ctx != ParseScriptContext::P2WSH, out, error);\n+            auto pk = ParsePubkey(key_exp_index, arg, ctx, out, error);\n             if (!pk) return nullptr;\n             script_size += pk->GetSize() + 1;\n             providers.emplace_back(std::move(pk));\n@@ -1005,28 +1022,29 @@ std::unique_ptr<DescriptorImpl> ParseScript(uint32_t key_exp_index, Span<const c\n         }\n         return std::make_unique<MultisigDescriptor>(thres, std::move(providers), sorted_multi);\n     }\n-    if (ctx != ParseScriptContext::P2WSH && Func(\"wpkh\", expr)) {\n-        auto pubkey = ParsePubkey(key_exp_index, expr, false, out, error);\n+    if ((ctx == ParseScriptContext::TOP || ctx == ParseScriptContext::P2SH) && Func(\"wpkh\", expr)) {\n+        auto pubkey = ParsePubkey(key_exp_index, expr, ParseScriptContext::P2WPKH, out, error);\n         if (!pubkey) return nullptr;\n+        key_exp_index++;\n         return std::make_unique<WPKHDescriptor>(std::move(pubkey));\n-    } else if (ctx == ParseScriptContext::P2WSH && Func(\"wpkh\", expr)) {\n-        error = \"Cannot have wpkh within wsh\";\n+    } else if (Func(\"wpkh\", expr)) {\n+        error = \"Can only have wpkh() at top level or inside sh()\";\n         return nullptr;\n     }\n     if (ctx == ParseScriptContext::TOP && Func(\"sh\", expr)) {\n         auto desc = ParseScript(key_exp_index, expr, ParseScriptContext::P2SH, out, error);\n         if (!desc || expr.size()) return nullptr;\n         return std::make_unique<SHDescriptor>(std::move(desc));\n-    } else if (ctx != ParseScriptContext::TOP && Func(\"sh\", expr)) {\n-        error = \"Cannot have sh in non-top level\";\n+    } else if (Func(\"sh\", expr)) {\n+        error = \"Can only have sh() at top level\";\n         return nullptr;\n     }\n-    if (ctx != ParseScriptContext::P2WSH && Func(\"wsh\", expr)) {\n+    if ((ctx == ParseScriptContext::TOP || ctx == ParseScriptContext::P2SH) && Func(\"wsh\", expr)) {\n         auto desc = ParseScript(key_exp_index, expr, ParseScriptContext::P2WSH, out, error);\n         if (!desc || expr.size()) return nullptr;\n         return std::make_unique<WSHDescriptor>(std::move(desc));\n-    } else if (ctx == ParseScriptContext::P2WSH && Func(\"wsh\", expr)) {\n-        error = \"Cannot have wsh within wsh\";\n+    } else if (Func(\"wsh\", expr)) {\n+        error = \"Can only have wsh() at top level or inside sh()\";\n         return nullptr;\n     }\n     if (ctx == ParseScriptContext::TOP && Func(\"addr\", expr)) {\n@@ -1036,6 +1054,9 @@ std::unique_ptr<DescriptorImpl> ParseScript(uint32_t key_exp_index, Span<const c\n             return nullptr;\n         }\n         return std::make_unique<AddressDescriptor>(std::move(dest));\n+    } else if (Func(\"addr\", expr)) {\n+        error = \"Can only have addr() at top level\";\n+        return nullptr;\n     }\n     if (ctx == ParseScriptContext::TOP && Func(\"raw\", expr)) {\n         std::string str(expr.begin(), expr.end());\n@@ -1045,6 +1066,9 @@ std::unique_ptr<DescriptorImpl> ParseScript(uint32_t key_exp_index, Span<const c\n         }\n         auto bytes = ParseHex(str);\n         return std::make_unique<RawDescriptor>(CScript(bytes.begin(), bytes.end()));\n+    } else if (Func(\"raw\", expr)) {\n+        error = \"Can only have raw() at top level\";\n+        return nullptr;\n     }\n     if (ctx == ParseScriptContext::P2SH) {\n         error = \"A function is needed within P2SH\";\n@@ -1174,7 +1198,8 @@ std::unique_ptr<Descriptor> Parse(const std::string& descriptor, FlatSigningProv\n {\n     Span<const char> sp{descriptor};\n     if (!CheckChecksum(sp, require_checksum, error)) return nullptr;\n-    auto ret = ParseScript(0, sp, ParseScriptContext::TOP, out, error);\n+    uint32_t key_exp_index = 0;\n+    auto ret = ParseScript(key_exp_index, sp, ParseScriptContext::TOP, out, error);\n     if (sp.size() == 0 && ret) return std::unique_ptr<Descriptor>(std::move(ret));\n     return nullptr;\n }"
      },
      {
        "sha": "7b661a0d1da9f08fe95a2f1e6615bd3c8a1dac2a",
        "filename": "src/test/compress_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/compress_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/compress_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/compress_tests.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -72,7 +72,7 @@ BOOST_AUTO_TEST_CASE(compress_script_to_ckey_id)\n     CScript script = CScript() << OP_DUP << OP_HASH160 << ToByteVector(pubkey.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n     BOOST_CHECK_EQUAL(script.size(), 25U);\n \n-    std::vector<unsigned char> out;\n+    CompressedScript out;\n     bool done = CompressScript(script, out);\n     BOOST_CHECK_EQUAL(done, true);\n \n@@ -89,7 +89,7 @@ BOOST_AUTO_TEST_CASE(compress_script_to_cscript_id)\n     script << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n     BOOST_CHECK_EQUAL(script.size(), 23U);\n \n-    std::vector<unsigned char> out;\n+    CompressedScript out;\n     bool done = CompressScript(script, out);\n     BOOST_CHECK_EQUAL(done, true);\n \n@@ -107,7 +107,7 @@ BOOST_AUTO_TEST_CASE(compress_script_to_compressed_pubkey_id)\n     CScript script = CScript() << ToByteVector(key.GetPubKey()) << OP_CHECKSIG; // COMPRESSED_PUBLIC_KEY_SIZE (33)\n     BOOST_CHECK_EQUAL(script.size(), 35U);\n \n-    std::vector<unsigned char> out;\n+    CompressedScript out;\n     bool done = CompressScript(script, out);\n     BOOST_CHECK_EQUAL(done, true);\n \n@@ -124,7 +124,7 @@ BOOST_AUTO_TEST_CASE(compress_script_to_uncompressed_pubkey_id)\n     CScript script =  CScript() << ToByteVector(key.GetPubKey()) << OP_CHECKSIG; // PUBLIC_KEY_SIZE (65)\n     BOOST_CHECK_EQUAL(script.size(), 67U);                   // 1 char code + 65 char pubkey + OP_CHECKSIG\n \n-    std::vector<unsigned char> out;\n+    CompressedScript out;\n     bool done = CompressScript(script, out);\n     BOOST_CHECK_EQUAL(done, true);\n "
      },
      {
        "sha": "b5f3bb2fa4ca8b0fe38e9443171a264bce38a652",
        "filename": "src/test/dbwrapper_tests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/dbwrapper_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/dbwrapper_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/dbwrapper_tests.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -26,7 +26,7 @@ BOOST_AUTO_TEST_CASE(dbwrapper)\n {\n     // Perform tests both obfuscated and non-obfuscated.\n     for (const bool obfuscate : {false, true}) {\n-        fs::path ph = GetDataDir() / (obfuscate ? \"dbwrapper_obfuscate_true\" : \"dbwrapper_obfuscate_false\");\n+        fs::path ph = m_args.GetDataDirPath() / (obfuscate ? \"dbwrapper_obfuscate_true\" : \"dbwrapper_obfuscate_false\");\n         CDBWrapper dbw(ph, (1 << 20), true, false, obfuscate);\n         char key = 'k';\n         uint256 in = InsecureRand256();\n@@ -45,7 +45,7 @@ BOOST_AUTO_TEST_CASE(dbwrapper_basic_data)\n {\n     // Perform tests both obfuscated and non-obfuscated.\n     for (bool obfuscate : {false, true}) {\n-        fs::path ph = GetDataDir() / (obfuscate ? \"dbwrapper_1_obfuscate_true\" : \"dbwrapper_1_obfuscate_false\");\n+        fs::path ph = m_args.GetDataDirPath() / (obfuscate ? \"dbwrapper_1_obfuscate_true\" : \"dbwrapper_1_obfuscate_false\");\n         CDBWrapper dbw(ph, (1 << 20), false, true, obfuscate);\n \n         uint256 res;\n@@ -126,7 +126,7 @@ BOOST_AUTO_TEST_CASE(dbwrapper_batch)\n {\n     // Perform tests both obfuscated and non-obfuscated.\n     for (const bool obfuscate : {false, true}) {\n-        fs::path ph = GetDataDir() / (obfuscate ? \"dbwrapper_batch_obfuscate_true\" : \"dbwrapper_batch_obfuscate_false\");\n+        fs::path ph = m_args.GetDataDirPath() / (obfuscate ? \"dbwrapper_batch_obfuscate_true\" : \"dbwrapper_batch_obfuscate_false\");\n         CDBWrapper dbw(ph, (1 << 20), true, false, obfuscate);\n \n         char key = 'i';\n@@ -162,7 +162,7 @@ BOOST_AUTO_TEST_CASE(dbwrapper_iterator)\n {\n     // Perform tests both obfuscated and non-obfuscated.\n     for (const bool obfuscate : {false, true}) {\n-        fs::path ph = GetDataDir() / (obfuscate ? \"dbwrapper_iterator_obfuscate_true\" : \"dbwrapper_iterator_obfuscate_false\");\n+        fs::path ph = m_args.GetDataDirPath() / (obfuscate ? \"dbwrapper_iterator_obfuscate_true\" : \"dbwrapper_iterator_obfuscate_false\");\n         CDBWrapper dbw(ph, (1 << 20), true, false, obfuscate);\n \n         // The two keys are intentionally chosen for ordering\n@@ -202,7 +202,7 @@ BOOST_AUTO_TEST_CASE(dbwrapper_iterator)\n BOOST_AUTO_TEST_CASE(existing_data_no_obfuscate)\n {\n     // We're going to share this fs::path between two wrappers\n-    fs::path ph = GetDataDir() / \"existing_data_no_obfuscate\";\n+    fs::path ph = m_args.GetDataDirPath() / \"existing_data_no_obfuscate\";\n     create_directories(ph);\n \n     // Set up a non-obfuscated wrapper to write some initial data.\n@@ -243,7 +243,7 @@ BOOST_AUTO_TEST_CASE(existing_data_no_obfuscate)\n BOOST_AUTO_TEST_CASE(existing_data_reindex)\n {\n     // We're going to share this fs::path between two wrappers\n-    fs::path ph = GetDataDir() / \"existing_data_reindex\";\n+    fs::path ph = m_args.GetDataDirPath() / \"existing_data_reindex\";\n     create_directories(ph);\n \n     // Set up a non-obfuscated wrapper to write some initial data.\n@@ -278,7 +278,7 @@ BOOST_AUTO_TEST_CASE(existing_data_reindex)\n \n BOOST_AUTO_TEST_CASE(iterator_ordering)\n {\n-    fs::path ph = GetDataDir() / \"iterator_ordering\";\n+    fs::path ph = m_args.GetDataDirPath() / \"iterator_ordering\";\n     CDBWrapper dbw(ph, (1 << 20), true, false, false);\n     for (int x=0x00; x<256; ++x) {\n         uint8_t key = x;\n@@ -358,7 +358,7 @@ BOOST_AUTO_TEST_CASE(iterator_string_ordering)\n {\n     char buf[10];\n \n-    fs::path ph = GetDataDir() / \"iterator_string_ordering\";\n+    fs::path ph = m_args.GetDataDirPath() / \"iterator_string_ordering\";\n     CDBWrapper dbw(ph, (1 << 20), true, false, false);\n     for (int x=0x00; x<10; ++x) {\n         for (int y = 0; y < 10; y++) {\n@@ -404,7 +404,7 @@ BOOST_AUTO_TEST_CASE(unicodepath)\n     // On Windows this test will fail if the directory is created using\n     // the ANSI CreateDirectoryA call and the code page isn't UTF8.\n     // It will succeed if created with CreateDirectoryW.\n-    fs::path ph = GetDataDir() / \"test_runner_\u20bf_\ud83c\udfc3_20191128_104644\";\n+    fs::path ph = m_args.GetDataDirPath() / \"test_runner_\u20bf_\ud83c\udfc3_20191128_104644\";\n     CDBWrapper dbw(ph, (1 << 20));\n \n     fs::path lockPath = ph / \"LOCK\";"
      },
      {
        "sha": "ddf0e0ca907110d4a289a64b089c7aef7c246f6b",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -208,7 +208,7 @@ BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n BOOST_AUTO_TEST_CASE(peer_discouragement)\n {\n     const CChainParams& chainparams = Params();\n-    auto banman = std::make_unique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n+    auto banman = std::make_unique<BanMan>(m_args.GetDataDirPath() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     auto connman = std::make_unique<CConnmanTest>(0x1337, 0x1337, *m_node.addrman);\n     auto peerLogic = PeerManager::make(chainparams, *connman, *m_node.addrman, banman.get(),\n                                        *m_node.scheduler, *m_node.chainman, *m_node.mempool, false);\n@@ -302,7 +302,7 @@ BOOST_AUTO_TEST_CASE(peer_discouragement)\n BOOST_AUTO_TEST_CASE(DoS_bantime)\n {\n     const CChainParams& chainparams = Params();\n-    auto banman = std::make_unique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n+    auto banman = std::make_unique<BanMan>(m_args.GetDataDirPath() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     auto connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman);\n     auto peerLogic = PeerManager::make(chainparams, *connman, *m_node.addrman, banman.get(),\n                                        *m_node.scheduler, *m_node.chainman, *m_node.mempool, false);"
      },
      {
        "sha": "ea41a0372843bfcc90ce5a216a222962c495ca3d",
        "filename": "src/test/descriptor_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/descriptor_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/descriptor_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/descriptor_tests.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -24,7 +24,7 @@ void CheckUnparsable(const std::string& prv, const std::string& pub, const std::\n     auto parse_pub = Parse(pub, keys_pub, error);\n     BOOST_CHECK_MESSAGE(!parse_priv, prv);\n     BOOST_CHECK_MESSAGE(!parse_pub, pub);\n-    BOOST_CHECK(error == expected_error);\n+    BOOST_CHECK_EQUAL(error, expected_error);\n }\n \n constexpr int DEFAULT = 0;\n@@ -355,12 +355,12 @@ BOOST_AUTO_TEST_CASE(descriptor_test)\n \n     // Check for invalid nesting of structures\n     CheckUnparsable(\"sh(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)\", \"sh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)\", \"A function is needed within P2SH\"); // P2SH needs a script, not a key\n-    CheckUnparsable(\"sh(combo(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1))\", \"sh(combo(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd))\", \"Cannot have combo in non-top level\"); // Old must be top level\n+    CheckUnparsable(\"sh(combo(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1))\", \"sh(combo(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd))\", \"Can only have combo() at top level\"); // Old must be top level\n     CheckUnparsable(\"wsh(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)\", \"wsh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)\", \"A function is needed within P2WSH\"); // P2WSH needs a script, not a key\n-    CheckUnparsable(\"wsh(wpkh(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1))\", \"wsh(wpkh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd))\", \"Cannot have wpkh within wsh\"); // Cannot embed witness inside witness\n-    CheckUnparsable(\"wsh(sh(pk(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)))\", \"wsh(sh(pk(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)))\", \"Cannot have sh in non-top level\"); // Cannot embed P2SH inside P2WSH\n-    CheckUnparsable(\"sh(sh(pk(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)))\", \"sh(sh(pk(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)))\", \"Cannot have sh in non-top level\"); // Cannot embed P2SH inside P2SH\n-    CheckUnparsable(\"wsh(wsh(pk(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)))\", \"wsh(wsh(pk(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)))\", \"Cannot have wsh within wsh\"); // Cannot embed P2WSH inside P2WSH\n+    CheckUnparsable(\"wsh(wpkh(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1))\", \"wsh(wpkh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd))\", \"Can only have wpkh() at top level or inside sh()\"); // Cannot embed witness inside witness\n+    CheckUnparsable(\"wsh(sh(pk(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)))\", \"wsh(sh(pk(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)))\", \"Can only have sh() at top level\"); // Cannot embed P2SH inside P2WSH\n+    CheckUnparsable(\"sh(sh(pk(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)))\", \"sh(sh(pk(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)))\", \"Can only have sh() at top level\"); // Cannot embed P2SH inside P2SH\n+    CheckUnparsable(\"wsh(wsh(pk(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)))\", \"wsh(wsh(pk(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)))\", \"Can only have wsh() at top level or inside sh()\"); // Cannot embed P2WSH inside P2WSH\n \n     // Checksums\n     Check(\"sh(multi(2,[00000000/111'/222]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0))#ggrsrxfy\", \"sh(multi(2,[00000000/111'/222]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0))#tjg09x5t\", \"sh(multi(2,[00000000/111'/222]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0))#ggrsrxfy\", \"sh(multi(2,[00000000/111'/222]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0))#tjg09x5t\", DEFAULT, {{\"a91445a9a622a8b0a1269944be477640eedc447bbd8487\"}}, OutputType::LEGACY, {{0x8000006FUL,222},{0}});"
      },
      {
        "sha": "9194ed8130d0ea5af21933bd62c79ce9b5cb9223",
        "filename": "src/test/flatfile_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/flatfile_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/flatfile_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/flatfile_tests.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -14,7 +14,7 @@ BOOST_FIXTURE_TEST_SUITE(flatfile_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(flatfile_filename)\n {\n-    const auto data_dir = GetDataDir();\n+    const auto data_dir = m_args.GetDataDirPath();\n \n     FlatFilePos pos(456, 789);\n \n@@ -27,7 +27,7 @@ BOOST_AUTO_TEST_CASE(flatfile_filename)\n \n BOOST_AUTO_TEST_CASE(flatfile_open)\n {\n-    const auto data_dir = GetDataDir();\n+    const auto data_dir = m_args.GetDataDirPath();\n     FlatFileSeq seq(data_dir, \"a\", 16 * 1024);\n \n     std::string line1(\"A purely peer-to-peer version of electronic cash would allow online \"\n@@ -88,7 +88,7 @@ BOOST_AUTO_TEST_CASE(flatfile_open)\n \n BOOST_AUTO_TEST_CASE(flatfile_allocate)\n {\n-    const auto data_dir = GetDataDir();\n+    const auto data_dir = m_args.GetDataDirPath();\n     FlatFileSeq seq(data_dir, \"a\", 100);\n \n     bool out_of_space;\n@@ -108,7 +108,7 @@ BOOST_AUTO_TEST_CASE(flatfile_allocate)\n \n BOOST_AUTO_TEST_CASE(flatfile_flush)\n {\n-    const auto data_dir = GetDataDir();\n+    const auto data_dir = m_args.GetDataDirPath();\n     FlatFileSeq seq(data_dir, \"a\", 100);\n \n     bool out_of_space;"
      },
      {
        "sha": "452bc06bbb2c1395b336f6190ef7687715a972c2",
        "filename": "src/test/fs_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/fs_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/fs_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fs_tests.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -13,7 +13,7 @@ BOOST_FIXTURE_TEST_SUITE(fs_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(fsbridge_fstream)\n {\n-    fs::path tmpfolder = GetDataDir();\n+    fs::path tmpfolder = m_args.GetDataDirPath();\n     // tmpfile1 should be the same as tmpfile2\n     fs::path tmpfile1 = tmpfolder / \"fs_tests_\u20bf_\ud83c\udfc3\";\n     fs::path tmpfile2 = tmpfolder / \"fs_tests_\u20bf_\ud83c\udfc3\";"
      },
      {
        "sha": "7b99193ad04f208acbc3da51f393b03674fd6c8f",
        "filename": "src/test/fuzz/process_message.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/fuzz/process_message.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/fuzz/process_message.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/process_message.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -100,7 +100,6 @@ void fuzz_target(FuzzBufferType buffer, const std::string& LIMIT_TO_MESSAGE_TYPE\n         g_setup->m_node.peerman->SendMessages(&p2p_node);\n     }\n     SyncWithValidationInterfaceQueue();\n-    LOCK2(::cs_main, g_cs_orphans); // See init.cpp for rationale for implicit locking order requirement\n     g_setup->m_node.connman->StopNodes();\n }\n "
      },
      {
        "sha": "11b236c9bdda207c4702a4422eccce624db81855",
        "filename": "src/test/fuzz/process_messages.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/fuzz/process_messages.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/fuzz/process_messages.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/process_messages.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -80,6 +80,5 @@ FUZZ_TARGET_INIT(process_messages, initialize_process_messages)\n         }\n     }\n     SyncWithValidationInterfaceQueue();\n-    LOCK2(::cs_main, g_cs_orphans); // See init.cpp for rationale for implicit locking order requirement\n     g_setup->m_node.connman->StopNodes();\n }"
      },
      {
        "sha": "dae6f6b6a76946b0c034454c1b60093ac607d6c5",
        "filename": "src/test/fuzz/rpc.cpp",
        "status": "added",
        "additions": 378,
        "deletions": 0,
        "changes": 378,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/fuzz/rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/fuzz/rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/rpc.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -0,0 +1,378 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <base58.h>\n+#include <chainparamsbase.h>\n+#include <core_io.h>\n+#include <interfaces/chain.h>\n+#include <key.h>\n+#include <key_io.h>\n+#include <node/context.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <psbt.h>\n+#include <rpc/blockchain.h>\n+#include <rpc/client.h>\n+#include <rpc/request.h>\n+#include <rpc/server.h>\n+#include <rpc/util.h>\n+#include <span.h>\n+#include <streams.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <tinyformat.h>\n+#include <univalue.h>\n+#include <util/strencodings.h>\n+#include <util/string.h>\n+#include <util/time.h>\n+\n+#include <cstdint>\n+#include <iostream>\n+#include <memory>\n+#include <optional>\n+#include <stdexcept>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+struct RPCFuzzTestingSetup : public TestingSetup {\n+    RPCFuzzTestingSetup(const std::string& chain_name, const std::vector<const char*>& extra_args) : TestingSetup{chain_name, extra_args}\n+    {\n+    }\n+\n+    UniValue CallRPC(const std::string& rpc_method, const std::vector<std::string>& arguments)\n+    {\n+        JSONRPCRequest request;\n+        request.context = &m_node;\n+        request.strMethod = rpc_method;\n+        request.params = RPCConvertValues(rpc_method, arguments);\n+        return tableRPC.execute(request);\n+    }\n+\n+    std::vector<std::string> GetRPCCommands() const\n+    {\n+        return tableRPC.listCommands();\n+    }\n+};\n+\n+RPCFuzzTestingSetup* rpc_testing_setup = nullptr;\n+std::string g_limit_to_rpc_command;\n+\n+// RPC commands which are not appropriate for fuzzing: such as RPC commands\n+// reading or writing to a filename passed as an RPC parameter, RPC commands\n+// resulting in network activity, etc.\n+const std::vector<std::string> RPC_COMMANDS_NOT_SAFE_FOR_FUZZING{\n+    \"addconnection\",  // avoid DNS lookups\n+    \"addnode\",        // avoid DNS lookups\n+    \"addpeeraddress\", // avoid DNS lookups\n+    \"analyzepsbt\",    // avoid signed integer overflow in CFeeRate::GetFee(unsigned long) (https://github.com/bitcoin/bitcoin/issues/20607)\n+    \"dumptxoutset\",   // avoid writing to disk\n+#ifdef ENABLE_WALLET\n+    \"dumpwallet\", // avoid writing to disk\n+#endif\n+    \"echoipc\",           // avoid assertion failure (Assertion `\"EnsureAnyNodeContext(request.context).init\" && check' failed.)\n+    \"generatetoaddress\", // avoid timeout\n+    \"gettxoutproof\",     // avoid slow execution\n+#ifdef ENABLE_WALLET\n+    \"importwallet\", // avoid reading from disk\n+    \"loadwallet\",   // avoid reading from disk\n+#endif\n+    \"mockscheduler\",         // avoid assertion failure (Assertion `delta_seconds.count() > 0 && delta_seconds < std::chrono::hours{1}' failed.)\n+    \"prioritisetransaction\", // avoid signed integer overflow in CTxMemPool::PrioritiseTransaction(uint256 const&, long const&) (https://github.com/bitcoin/bitcoin/issues/20626)\n+    \"setban\",                // avoid DNS lookups\n+    \"stop\",                  // avoid shutdown state\n+};\n+\n+// RPC commands which are safe for fuzzing.\n+const std::vector<std::string> RPC_COMMANDS_SAFE_FOR_FUZZING{\n+    \"clearbanned\",\n+    \"combinepsbt\",\n+    \"combinerawtransaction\",\n+    \"converttopsbt\",\n+    \"createmultisig\",\n+    \"createpsbt\",\n+    \"createrawtransaction\",\n+    \"decodepsbt\",\n+    \"decoderawtransaction\",\n+    \"decodescript\",\n+    \"deriveaddresses\",\n+    \"disconnectnode\",\n+    \"echo\",\n+    \"echojson\",\n+    \"estimaterawfee\",\n+    \"estimatesmartfee\",\n+    \"finalizepsbt\",\n+    \"generate\",\n+    \"generateblock\",\n+    \"generatetodescriptor\",\n+    \"getaddednodeinfo\",\n+    \"getbestblockhash\",\n+    \"getblock\",\n+    \"getblockchaininfo\",\n+    \"getblockcount\",\n+    \"getblockfilter\",\n+    \"getblockhash\",\n+    \"getblockheader\",\n+    \"getblockstats\",\n+    \"getblocktemplate\",\n+    \"getchaintips\",\n+    \"getchaintxstats\",\n+    \"getconnectioncount\",\n+    \"getdescriptorinfo\",\n+    \"getdifficulty\",\n+    \"getindexinfo\",\n+    \"getmemoryinfo\",\n+    \"getmempoolancestors\",\n+    \"getmempooldescendants\",\n+    \"getmempoolentry\",\n+    \"getmempoolinfo\",\n+    \"getmininginfo\",\n+    \"getnettotals\",\n+    \"getnetworkhashps\",\n+    \"getnetworkinfo\",\n+    \"getnodeaddresses\",\n+    \"getpeerinfo\",\n+    \"getrawmempool\",\n+    \"getrawtransaction\",\n+    \"getrpcinfo\",\n+    \"gettxout\",\n+    \"gettxoutsetinfo\",\n+    \"help\",\n+    \"invalidateblock\",\n+    \"joinpsbts\",\n+    \"listbanned\",\n+    \"logging\",\n+    \"ping\",\n+    \"preciousblock\",\n+    \"pruneblockchain\",\n+    \"reconsiderblock\",\n+    \"savemempool\",\n+    \"scantxoutset\",\n+    \"sendrawtransaction\",\n+    \"setmocktime\",\n+    \"setnetworkactive\",\n+    \"signmessagewithprivkey\",\n+    \"signrawtransactionwithkey\",\n+    \"submitblock\",\n+    \"submitheader\",\n+    \"syncwithvalidationinterfacequeue\",\n+    \"testmempoolaccept\",\n+    \"uptime\",\n+    \"utxoupdatepsbt\",\n+    \"validateaddress\",\n+    \"verifychain\",\n+    \"verifymessage\",\n+    \"verifytxoutproof\",\n+    \"waitforblock\",\n+    \"waitforblockheight\",\n+    \"waitfornewblock\",\n+};\n+\n+std::string ConsumeScalarRPCArgument(FuzzedDataProvider& fuzzed_data_provider)\n+{\n+    const size_t max_string_length = 4096;\n+    std::string r;\n+    CallOneOf(\n+        fuzzed_data_provider,\n+        [&] {\n+            // string argument\n+            r = fuzzed_data_provider.ConsumeRandomLengthString(max_string_length);\n+        },\n+        [&] {\n+            // base64 argument\n+            r = EncodeBase64(fuzzed_data_provider.ConsumeRandomLengthString(max_string_length));\n+        },\n+        [&] {\n+            // hex argument\n+            r = HexStr(fuzzed_data_provider.ConsumeRandomLengthString(max_string_length));\n+        },\n+        [&] {\n+            // bool argument\n+            r = fuzzed_data_provider.ConsumeBool() ? \"true\" : \"false\";\n+        },\n+        [&] {\n+            // range argument\n+            r = \"[\" + ToString(fuzzed_data_provider.ConsumeIntegral<int64_t>()) + \",\" + ToString(fuzzed_data_provider.ConsumeIntegral<int64_t>()) + \"]\";\n+        },\n+        [&] {\n+            // integral argument (int64_t)\n+            r = ToString(fuzzed_data_provider.ConsumeIntegral<int64_t>());\n+        },\n+        [&] {\n+            // integral argument (uint64_t)\n+            r = ToString(fuzzed_data_provider.ConsumeIntegral<uint64_t>());\n+        },\n+        [&] {\n+            // floating point argument\n+            r = strprintf(\"%f\", fuzzed_data_provider.ConsumeFloatingPoint<double>());\n+        },\n+        [&] {\n+            // tx destination argument\n+            r = EncodeDestination(ConsumeTxDestination(fuzzed_data_provider));\n+        },\n+        [&] {\n+            // uint160 argument\n+            r = ConsumeUInt160(fuzzed_data_provider).ToString();\n+        },\n+        [&] {\n+            // uint256 argument\n+            r = ConsumeUInt256(fuzzed_data_provider).ToString();\n+        },\n+        [&] {\n+            // base32 argument\n+            r = EncodeBase32(fuzzed_data_provider.ConsumeRandomLengthString(max_string_length));\n+        },\n+        [&] {\n+            // base58 argument\n+            r = EncodeBase58(MakeUCharSpan(fuzzed_data_provider.ConsumeRandomLengthString(max_string_length)));\n+        },\n+        [&] {\n+            // base58 argument with checksum\n+            r = EncodeBase58Check(MakeUCharSpan(fuzzed_data_provider.ConsumeRandomLengthString(max_string_length)));\n+        },\n+        [&] {\n+            // hex encoded block\n+            std::optional<CBlock> opt_block = ConsumeDeserializable<CBlock>(fuzzed_data_provider);\n+            if (!opt_block) {\n+                return;\n+            }\n+            CDataStream data_stream{SER_NETWORK, PROTOCOL_VERSION};\n+            data_stream << *opt_block;\n+            r = HexStr(data_stream);\n+        },\n+        [&] {\n+            // hex encoded block header\n+            std::optional<CBlockHeader> opt_block_header = ConsumeDeserializable<CBlockHeader>(fuzzed_data_provider);\n+            if (!opt_block_header) {\n+                return;\n+            }\n+            CDataStream data_stream{SER_NETWORK, PROTOCOL_VERSION};\n+            data_stream << *opt_block_header;\n+            r = HexStr(data_stream);\n+        },\n+        [&] {\n+            // hex encoded tx\n+            std::optional<CMutableTransaction> opt_tx = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+            if (!opt_tx) {\n+                return;\n+            }\n+            CDataStream data_stream{SER_NETWORK, fuzzed_data_provider.ConsumeBool() ? PROTOCOL_VERSION : (PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS)};\n+            data_stream << *opt_tx;\n+            r = HexStr(data_stream);\n+        },\n+        [&] {\n+            // base64 encoded psbt\n+            std::optional<PartiallySignedTransaction> opt_psbt = ConsumeDeserializable<PartiallySignedTransaction>(fuzzed_data_provider);\n+            if (!opt_psbt) {\n+                return;\n+            }\n+            CDataStream data_stream{SER_NETWORK, PROTOCOL_VERSION};\n+            data_stream << *opt_psbt;\n+            r = EncodeBase64({data_stream.begin(), data_stream.end()});\n+        },\n+        [&] {\n+            // base58 encoded key\n+            const std::vector<uint8_t> random_bytes = fuzzed_data_provider.ConsumeBytes<uint8_t>(32);\n+            CKey key;\n+            key.Set(random_bytes.begin(), random_bytes.end(), fuzzed_data_provider.ConsumeBool());\n+            if (!key.IsValid()) {\n+                return;\n+            }\n+            r = EncodeSecret(key);\n+        },\n+        [&] {\n+            // hex encoded pubkey\n+            const std::vector<uint8_t> random_bytes = fuzzed_data_provider.ConsumeBytes<uint8_t>(32);\n+            CKey key;\n+            key.Set(random_bytes.begin(), random_bytes.end(), fuzzed_data_provider.ConsumeBool());\n+            if (!key.IsValid()) {\n+                return;\n+            }\n+            r = HexStr(key.GetPubKey());\n+        });\n+    return r;\n+}\n+\n+std::string ConsumeArrayRPCArgument(FuzzedDataProvider& fuzzed_data_provider)\n+{\n+    std::vector<std::string> scalar_arguments;\n+    while (fuzzed_data_provider.ConsumeBool()) {\n+        scalar_arguments.push_back(ConsumeScalarRPCArgument(fuzzed_data_provider));\n+    }\n+    return \"[\\\"\" + Join(scalar_arguments, \"\\\",\\\"\") + \"\\\"]\";\n+}\n+\n+std::string ConsumeRPCArgument(FuzzedDataProvider& fuzzed_data_provider)\n+{\n+    return fuzzed_data_provider.ConsumeBool() ? ConsumeScalarRPCArgument(fuzzed_data_provider) : ConsumeArrayRPCArgument(fuzzed_data_provider);\n+}\n+\n+RPCFuzzTestingSetup* InitializeRPCFuzzTestingSetup()\n+{\n+    static const auto setup = MakeNoLogFileContext<RPCFuzzTestingSetup>();\n+    SetRPCWarmupFinished();\n+    return setup.get();\n+}\n+}; // namespace\n+\n+void initialize_rpc()\n+{\n+    rpc_testing_setup = InitializeRPCFuzzTestingSetup();\n+    const std::vector<std::string> supported_rpc_commands = rpc_testing_setup->GetRPCCommands();\n+    for (const std::string& rpc_command : supported_rpc_commands) {\n+        const bool safe_for_fuzzing = std::find(RPC_COMMANDS_SAFE_FOR_FUZZING.begin(), RPC_COMMANDS_SAFE_FOR_FUZZING.end(), rpc_command) != RPC_COMMANDS_SAFE_FOR_FUZZING.end();\n+        const bool not_safe_for_fuzzing = std::find(RPC_COMMANDS_NOT_SAFE_FOR_FUZZING.begin(), RPC_COMMANDS_NOT_SAFE_FOR_FUZZING.end(), rpc_command) != RPC_COMMANDS_NOT_SAFE_FOR_FUZZING.end();\n+        if (!(safe_for_fuzzing || not_safe_for_fuzzing)) {\n+            std::cerr << \"Error: RPC command \\\"\" << rpc_command << \"\\\" not found in RPC_COMMANDS_SAFE_FOR_FUZZING or RPC_COMMANDS_NOT_SAFE_FOR_FUZZING. Please update \" << __FILE__ << \".\\n\";\n+            std::terminate();\n+        }\n+        if (safe_for_fuzzing && not_safe_for_fuzzing) {\n+            std::cerr << \"Error: RPC command \\\"\" << rpc_command << \"\\\" found in *both* RPC_COMMANDS_SAFE_FOR_FUZZING and RPC_COMMANDS_NOT_SAFE_FOR_FUZZING. Please update \" << __FILE__ << \".\\n\";\n+            std::terminate();\n+        }\n+    }\n+    for (const std::string& rpc_command : RPC_COMMANDS_SAFE_FOR_FUZZING) {\n+        const bool supported_rpc_command = std::find(supported_rpc_commands.begin(), supported_rpc_commands.end(), rpc_command) != supported_rpc_commands.end();\n+        if (!supported_rpc_command) {\n+            std::cerr << \"Error: Unknown RPC command \\\"\" << rpc_command << \"\\\" found in RPC_COMMANDS_SAFE_FOR_FUZZING. Please update \" << __FILE__ << \".\\n\";\n+            std::terminate();\n+        }\n+    }\n+    for (const std::string& rpc_command : RPC_COMMANDS_NOT_SAFE_FOR_FUZZING) {\n+        const bool supported_rpc_command = std::find(supported_rpc_commands.begin(), supported_rpc_commands.end(), rpc_command) != supported_rpc_commands.end();\n+        if (!supported_rpc_command) {\n+            std::cerr << \"Error: Unknown RPC command \\\"\" << rpc_command << \"\\\" found in RPC_COMMANDS_NOT_SAFE_FOR_FUZZING. Please update \" << __FILE__ << \".\\n\";\n+            std::terminate();\n+        }\n+    }\n+    const char* limit_to_rpc_command_env = std::getenv(\"LIMIT_TO_RPC_COMMAND\");\n+    if (limit_to_rpc_command_env != nullptr) {\n+        g_limit_to_rpc_command = std::string{limit_to_rpc_command_env};\n+    }\n+}\n+\n+FUZZ_TARGET_INIT(rpc, initialize_rpc)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    const std::string rpc_command = fuzzed_data_provider.ConsumeRandomLengthString(64);\n+    if (!g_limit_to_rpc_command.empty() && rpc_command != g_limit_to_rpc_command) {\n+        return;\n+    }\n+    const bool safe_for_fuzzing = std::find(RPC_COMMANDS_SAFE_FOR_FUZZING.begin(), RPC_COMMANDS_SAFE_FOR_FUZZING.end(), rpc_command) != RPC_COMMANDS_SAFE_FOR_FUZZING.end();\n+    if (!safe_for_fuzzing) {\n+        return;\n+    }\n+    std::vector<std::string> arguments;\n+    while (fuzzed_data_provider.ConsumeBool()) {\n+        arguments.push_back(ConsumeRPCArgument(fuzzed_data_provider));\n+    }\n+    try {\n+        rpc_testing_setup->CallRPC(rpc_command, arguments);\n+    } catch (const UniValue&) {\n+    } catch (const std::runtime_error&) {\n+    }\n+}"
      },
      {
        "sha": "b87bcf2ef5f4d7754bca952e749537502c9c9306",
        "filename": "src/test/fuzz/script.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 13,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/fuzz/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/fuzz/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/script.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -43,7 +43,7 @@ FUZZ_TARGET_INIT(script, initialize_script)\n     if (!script_opt) return;\n     const CScript script{*script_opt};\n \n-    std::vector<unsigned char> compressed;\n+    CompressedScript compressed;\n     if (CompressScript(script, compressed)) {\n         const unsigned int size = compressed[0];\n         compressed.erase(compressed.begin());\n@@ -55,22 +55,45 @@ FUZZ_TARGET_INIT(script, initialize_script)\n     }\n \n     CTxDestination address;\n-    (void)ExtractDestination(script, address);\n-\n     TxoutType type_ret;\n     std::vector<CTxDestination> addresses;\n     int required_ret;\n-    (void)ExtractDestinations(script, type_ret, addresses, required_ret);\n-\n-    const FlatSigningProvider signing_provider;\n-    (void)InferDescriptor(script, signing_provider);\n-\n-    (void)IsSegWitOutput(signing_provider, script);\n-\n-    (void)IsSolvable(signing_provider, script);\n+    bool extract_destinations_ret = ExtractDestinations(script, type_ret, addresses, required_ret);\n+    bool extract_destination_ret = ExtractDestination(script, address);\n+    if (!extract_destinations_ret) {\n+        assert(!extract_destination_ret);\n+        if (type_ret == TxoutType::MULTISIG) {\n+            assert(addresses.empty() && required_ret == 0);\n+        } else {\n+            assert(type_ret == TxoutType::PUBKEY ||\n+                   type_ret == TxoutType::NONSTANDARD ||\n+                   type_ret == TxoutType::NULL_DATA);\n+        }\n+    } else {\n+        assert(required_ret >= 1 && required_ret <= 16);\n+        assert((unsigned long)required_ret == addresses.size());\n+        assert(type_ret == TxoutType::MULTISIG || required_ret == 1);\n+    }\n+    if (type_ret == TxoutType::NONSTANDARD || type_ret == TxoutType::NULL_DATA) {\n+        assert(!extract_destinations_ret);\n+    }\n+    if (!extract_destination_ret) {\n+        assert(type_ret == TxoutType::PUBKEY ||\n+               type_ret == TxoutType::NONSTANDARD ||\n+               type_ret == TxoutType::NULL_DATA ||\n+               type_ret == TxoutType::MULTISIG);\n+    } else {\n+        assert(address == addresses[0]);\n+    }\n+    if (type_ret == TxoutType::NONSTANDARD ||\n+        type_ret == TxoutType::NULL_DATA ||\n+        type_ret == TxoutType::MULTISIG) {\n+        assert(!extract_destination_ret);\n+    }\n \n     TxoutType which_type;\n     bool is_standard_ret = IsStandard(script, which_type);\n+    assert(type_ret == which_type);\n     if (!is_standard_ret) {\n         assert(which_type == TxoutType::NONSTANDARD ||\n                which_type == TxoutType::NULL_DATA ||\n@@ -87,6 +110,11 @@ FUZZ_TARGET_INIT(script, initialize_script)\n                which_type == TxoutType::NONSTANDARD);\n     }\n \n+    const FlatSigningProvider signing_provider;\n+    (void)InferDescriptor(script, signing_provider);\n+    (void)IsSegWitOutput(signing_provider, script);\n+    (void)IsSolvable(signing_provider, script);\n+\n     (void)RecursiveDynamicUsage(script);\n \n     std::vector<std::vector<unsigned char>> solutions;\n@@ -115,10 +143,12 @@ FUZZ_TARGET_INIT(script, initialize_script)\n \n     {\n         const std::vector<uint8_t> bytes = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+        CompressedScript compressed_script;\n+        compressed_script.assign(bytes.begin(), bytes.end());\n         // DecompressScript(..., ..., bytes) is not guaranteed to be defined if the bytes vector is too short\n-        if (bytes.size() >= 32) {\n+        if (compressed_script.size() >= 32) {\n             CScript decompressed_script;\n-            DecompressScript(decompressed_script, fuzzed_data_provider.ConsumeIntegral<unsigned int>(), bytes);\n+            DecompressScript(decompressed_script, fuzzed_data_provider.ConsumeIntegral<unsigned int>(), compressed_script);\n         }\n     }\n "
      },
      {
        "sha": "1278dc87d45b20813bd4fadc97de83c2403225cc",
        "filename": "src/test/fuzz/script_flags.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/fuzz/script_flags.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/fuzz/script_flags.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/script_flags.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -41,6 +41,10 @@ FUZZ_TARGET_INIT(script_flags, initialize_script_flags)\n         for (unsigned i = 0; i < tx.vin.size(); ++i) {\n             CTxOut prevout;\n             ds >> prevout;\n+            if (!MoneyRange(prevout.nValue)) {\n+                // prevouts should be consensus-valid\n+                prevout.nValue = 1;\n+            }\n             spent_outputs.push_back(prevout);\n         }\n         PrecomputedTransactionData txdata;"
      },
      {
        "sha": "2a217f3455e6404fb1ff791eccf6ac9c5012d7a0",
        "filename": "src/test/getarg_tests.cpp",
        "status": "modified",
        "additions": 60,
        "deletions": 60,
        "changes": 120,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/getarg_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/getarg_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/getarg_tests.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -18,7 +18,7 @@ namespace getarg_tests{\n         protected:\n         void SetupArgs(const std::vector<std::pair<std::string, unsigned int>>& args);\n         void ResetArgs(const std::string& strArg);\n-        ArgsManager m_args;\n+        ArgsManager m_local_args;\n     };\n }\n \n@@ -39,14 +39,14 @@ void LocalTestingSetup :: ResetArgs(const std::string& strArg)\n         vecChar.push_back(s.c_str());\n \n     std::string error;\n-    BOOST_CHECK(m_args.ParseParameters(vecChar.size(), vecChar.data(), error));\n+    BOOST_CHECK(m_local_args.ParseParameters(vecChar.size(), vecChar.data(), error));\n }\n \n void LocalTestingSetup :: SetupArgs(const std::vector<std::pair<std::string, unsigned int>>& args)\n {\n-    m_args.ClearArgs();\n+    m_local_args.ClearArgs();\n     for (const auto& arg : args) {\n-        m_args.AddArg(arg.first, \"\", arg.second, OptionsCategory::OPTIONS);\n+        m_local_args.AddArg(arg.first, \"\", arg.second, OptionsCategory::OPTIONS);\n     }\n }\n \n@@ -55,52 +55,52 @@ BOOST_AUTO_TEST_CASE(boolarg)\n     const auto foo = std::make_pair(\"-foo\", ArgsManager::ALLOW_ANY);\n     SetupArgs({foo});\n     ResetArgs(\"-foo\");\n-    BOOST_CHECK(m_args.GetBoolArg(\"-foo\", false));\n-    BOOST_CHECK(m_args.GetBoolArg(\"-foo\", true));\n+    BOOST_CHECK(m_local_args.GetBoolArg(\"-foo\", false));\n+    BOOST_CHECK(m_local_args.GetBoolArg(\"-foo\", true));\n \n-    BOOST_CHECK(!m_args.GetBoolArg(\"-fo\", false));\n-    BOOST_CHECK(m_args.GetBoolArg(\"-fo\", true));\n+    BOOST_CHECK(!m_local_args.GetBoolArg(\"-fo\", false));\n+    BOOST_CHECK(m_local_args.GetBoolArg(\"-fo\", true));\n \n-    BOOST_CHECK(!m_args.GetBoolArg(\"-fooo\", false));\n-    BOOST_CHECK(m_args.GetBoolArg(\"-fooo\", true));\n+    BOOST_CHECK(!m_local_args.GetBoolArg(\"-fooo\", false));\n+    BOOST_CHECK(m_local_args.GetBoolArg(\"-fooo\", true));\n \n     ResetArgs(\"-foo=0\");\n-    BOOST_CHECK(!m_args.GetBoolArg(\"-foo\", false));\n-    BOOST_CHECK(!m_args.GetBoolArg(\"-foo\", true));\n+    BOOST_CHECK(!m_local_args.GetBoolArg(\"-foo\", false));\n+    BOOST_CHECK(!m_local_args.GetBoolArg(\"-foo\", true));\n \n     ResetArgs(\"-foo=1\");\n-    BOOST_CHECK(m_args.GetBoolArg(\"-foo\", false));\n-    BOOST_CHECK(m_args.GetBoolArg(\"-foo\", true));\n+    BOOST_CHECK(m_local_args.GetBoolArg(\"-foo\", false));\n+    BOOST_CHECK(m_local_args.GetBoolArg(\"-foo\", true));\n \n     // New 0.6 feature: auto-map -nosomething to !-something:\n     ResetArgs(\"-nofoo\");\n-    BOOST_CHECK(!m_args.GetBoolArg(\"-foo\", false));\n-    BOOST_CHECK(!m_args.GetBoolArg(\"-foo\", true));\n+    BOOST_CHECK(!m_local_args.GetBoolArg(\"-foo\", false));\n+    BOOST_CHECK(!m_local_args.GetBoolArg(\"-foo\", true));\n \n     ResetArgs(\"-nofoo=1\");\n-    BOOST_CHECK(!m_args.GetBoolArg(\"-foo\", false));\n-    BOOST_CHECK(!m_args.GetBoolArg(\"-foo\", true));\n+    BOOST_CHECK(!m_local_args.GetBoolArg(\"-foo\", false));\n+    BOOST_CHECK(!m_local_args.GetBoolArg(\"-foo\", true));\n \n     ResetArgs(\"-foo -nofoo\");  // -nofoo should win\n-    BOOST_CHECK(!m_args.GetBoolArg(\"-foo\", false));\n-    BOOST_CHECK(!m_args.GetBoolArg(\"-foo\", true));\n+    BOOST_CHECK(!m_local_args.GetBoolArg(\"-foo\", false));\n+    BOOST_CHECK(!m_local_args.GetBoolArg(\"-foo\", true));\n \n     ResetArgs(\"-foo=1 -nofoo=1\");  // -nofoo should win\n-    BOOST_CHECK(!m_args.GetBoolArg(\"-foo\", false));\n-    BOOST_CHECK(!m_args.GetBoolArg(\"-foo\", true));\n+    BOOST_CHECK(!m_local_args.GetBoolArg(\"-foo\", false));\n+    BOOST_CHECK(!m_local_args.GetBoolArg(\"-foo\", true));\n \n     ResetArgs(\"-foo=0 -nofoo=0\");  // -nofoo=0 should win\n-    BOOST_CHECK(m_args.GetBoolArg(\"-foo\", false));\n-    BOOST_CHECK(m_args.GetBoolArg(\"-foo\", true));\n+    BOOST_CHECK(m_local_args.GetBoolArg(\"-foo\", false));\n+    BOOST_CHECK(m_local_args.GetBoolArg(\"-foo\", true));\n \n     // New 0.6 feature: treat -- same as -:\n     ResetArgs(\"--foo=1\");\n-    BOOST_CHECK(m_args.GetBoolArg(\"-foo\", false));\n-    BOOST_CHECK(m_args.GetBoolArg(\"-foo\", true));\n+    BOOST_CHECK(m_local_args.GetBoolArg(\"-foo\", false));\n+    BOOST_CHECK(m_local_args.GetBoolArg(\"-foo\", true));\n \n     ResetArgs(\"--nofoo=1\");\n-    BOOST_CHECK(!m_args.GetBoolArg(\"-foo\", false));\n-    BOOST_CHECK(!m_args.GetBoolArg(\"-foo\", true));\n+    BOOST_CHECK(!m_local_args.GetBoolArg(\"-foo\", false));\n+    BOOST_CHECK(!m_local_args.GetBoolArg(\"-foo\", true));\n \n }\n \n@@ -110,24 +110,24 @@ BOOST_AUTO_TEST_CASE(stringarg)\n     const auto bar = std::make_pair(\"-bar\", ArgsManager::ALLOW_ANY);\n     SetupArgs({foo, bar});\n     ResetArgs(\"\");\n-    BOOST_CHECK_EQUAL(m_args.GetArg(\"-foo\", \"\"), \"\");\n-    BOOST_CHECK_EQUAL(m_args.GetArg(\"-foo\", \"eleven\"), \"eleven\");\n+    BOOST_CHECK_EQUAL(m_local_args.GetArg(\"-foo\", \"\"), \"\");\n+    BOOST_CHECK_EQUAL(m_local_args.GetArg(\"-foo\", \"eleven\"), \"eleven\");\n \n     ResetArgs(\"-foo -bar\");\n-    BOOST_CHECK_EQUAL(m_args.GetArg(\"-foo\", \"\"), \"\");\n-    BOOST_CHECK_EQUAL(m_args.GetArg(\"-foo\", \"eleven\"), \"\");\n+    BOOST_CHECK_EQUAL(m_local_args.GetArg(\"-foo\", \"\"), \"\");\n+    BOOST_CHECK_EQUAL(m_local_args.GetArg(\"-foo\", \"eleven\"), \"\");\n \n     ResetArgs(\"-foo=\");\n-    BOOST_CHECK_EQUAL(m_args.GetArg(\"-foo\", \"\"), \"\");\n-    BOOST_CHECK_EQUAL(m_args.GetArg(\"-foo\", \"eleven\"), \"\");\n+    BOOST_CHECK_EQUAL(m_local_args.GetArg(\"-foo\", \"\"), \"\");\n+    BOOST_CHECK_EQUAL(m_local_args.GetArg(\"-foo\", \"eleven\"), \"\");\n \n     ResetArgs(\"-foo=11\");\n-    BOOST_CHECK_EQUAL(m_args.GetArg(\"-foo\", \"\"), \"11\");\n-    BOOST_CHECK_EQUAL(m_args.GetArg(\"-foo\", \"eleven\"), \"11\");\n+    BOOST_CHECK_EQUAL(m_local_args.GetArg(\"-foo\", \"\"), \"11\");\n+    BOOST_CHECK_EQUAL(m_local_args.GetArg(\"-foo\", \"eleven\"), \"11\");\n \n     ResetArgs(\"-foo=eleven\");\n-    BOOST_CHECK_EQUAL(m_args.GetArg(\"-foo\", \"\"), \"eleven\");\n-    BOOST_CHECK_EQUAL(m_args.GetArg(\"-foo\", \"eleven\"), \"eleven\");\n+    BOOST_CHECK_EQUAL(m_local_args.GetArg(\"-foo\", \"\"), \"eleven\");\n+    BOOST_CHECK_EQUAL(m_local_args.GetArg(\"-foo\", \"eleven\"), \"eleven\");\n \n }\n \n@@ -137,20 +137,20 @@ BOOST_AUTO_TEST_CASE(intarg)\n     const auto bar = std::make_pair(\"-bar\", ArgsManager::ALLOW_ANY);\n     SetupArgs({foo, bar});\n     ResetArgs(\"\");\n-    BOOST_CHECK_EQUAL(m_args.GetArg(\"-foo\", 11), 11);\n-    BOOST_CHECK_EQUAL(m_args.GetArg(\"-foo\", 0), 0);\n+    BOOST_CHECK_EQUAL(m_local_args.GetArg(\"-foo\", 11), 11);\n+    BOOST_CHECK_EQUAL(m_local_args.GetArg(\"-foo\", 0), 0);\n \n     ResetArgs(\"-foo -bar\");\n-    BOOST_CHECK_EQUAL(m_args.GetArg(\"-foo\", 11), 0);\n-    BOOST_CHECK_EQUAL(m_args.GetArg(\"-bar\", 11), 0);\n+    BOOST_CHECK_EQUAL(m_local_args.GetArg(\"-foo\", 11), 0);\n+    BOOST_CHECK_EQUAL(m_local_args.GetArg(\"-bar\", 11), 0);\n \n     ResetArgs(\"-foo=11 -bar=12\");\n-    BOOST_CHECK_EQUAL(m_args.GetArg(\"-foo\", 0), 11);\n-    BOOST_CHECK_EQUAL(m_args.GetArg(\"-bar\", 11), 12);\n+    BOOST_CHECK_EQUAL(m_local_args.GetArg(\"-foo\", 0), 11);\n+    BOOST_CHECK_EQUAL(m_local_args.GetArg(\"-bar\", 11), 12);\n \n     ResetArgs(\"-foo=NaN -bar=NotANumber\");\n-    BOOST_CHECK_EQUAL(m_args.GetArg(\"-foo\", 1), 0);\n-    BOOST_CHECK_EQUAL(m_args.GetArg(\"-bar\", 11), 0);\n+    BOOST_CHECK_EQUAL(m_local_args.GetArg(\"-foo\", 1), 0);\n+    BOOST_CHECK_EQUAL(m_local_args.GetArg(\"-bar\", 11), 0);\n }\n \n BOOST_AUTO_TEST_CASE(doubledash)\n@@ -159,11 +159,11 @@ BOOST_AUTO_TEST_CASE(doubledash)\n     const auto bar = std::make_pair(\"-bar\", ArgsManager::ALLOW_ANY);\n     SetupArgs({foo, bar});\n     ResetArgs(\"--foo\");\n-    BOOST_CHECK_EQUAL(m_args.GetBoolArg(\"-foo\", false), true);\n+    BOOST_CHECK_EQUAL(m_local_args.GetBoolArg(\"-foo\", false), true);\n \n     ResetArgs(\"--foo=verbose --bar=1\");\n-    BOOST_CHECK_EQUAL(m_args.GetArg(\"-foo\", \"\"), \"verbose\");\n-    BOOST_CHECK_EQUAL(m_args.GetArg(\"-bar\", 0), 1);\n+    BOOST_CHECK_EQUAL(m_local_args.GetArg(\"-foo\", \"\"), \"verbose\");\n+    BOOST_CHECK_EQUAL(m_local_args.GetArg(\"-bar\", 0), 1);\n }\n \n BOOST_AUTO_TEST_CASE(boolargno)\n@@ -172,24 +172,24 @@ BOOST_AUTO_TEST_CASE(boolargno)\n     const auto bar = std::make_pair(\"-bar\", ArgsManager::ALLOW_ANY);\n     SetupArgs({foo, bar});\n     ResetArgs(\"-nofoo\");\n-    BOOST_CHECK(!m_args.GetBoolArg(\"-foo\", true));\n-    BOOST_CHECK(!m_args.GetBoolArg(\"-foo\", false));\n+    BOOST_CHECK(!m_local_args.GetBoolArg(\"-foo\", true));\n+    BOOST_CHECK(!m_local_args.GetBoolArg(\"-foo\", false));\n \n     ResetArgs(\"-nofoo=1\");\n-    BOOST_CHECK(!m_args.GetBoolArg(\"-foo\", true));\n-    BOOST_CHECK(!m_args.GetBoolArg(\"-foo\", false));\n+    BOOST_CHECK(!m_local_args.GetBoolArg(\"-foo\", true));\n+    BOOST_CHECK(!m_local_args.GetBoolArg(\"-foo\", false));\n \n     ResetArgs(\"-nofoo=0\");\n-    BOOST_CHECK(m_args.GetBoolArg(\"-foo\", true));\n-    BOOST_CHECK(m_args.GetBoolArg(\"-foo\", false));\n+    BOOST_CHECK(m_local_args.GetBoolArg(\"-foo\", true));\n+    BOOST_CHECK(m_local_args.GetBoolArg(\"-foo\", false));\n \n     ResetArgs(\"-foo --nofoo\"); // --nofoo should win\n-    BOOST_CHECK(!m_args.GetBoolArg(\"-foo\", true));\n-    BOOST_CHECK(!m_args.GetBoolArg(\"-foo\", false));\n+    BOOST_CHECK(!m_local_args.GetBoolArg(\"-foo\", true));\n+    BOOST_CHECK(!m_local_args.GetBoolArg(\"-foo\", false));\n \n     ResetArgs(\"-nofoo -foo\"); // foo always wins:\n-    BOOST_CHECK(m_args.GetBoolArg(\"-foo\", true));\n-    BOOST_CHECK(m_args.GetBoolArg(\"-foo\", false));\n+    BOOST_CHECK(m_local_args.GetBoolArg(\"-foo\", true));\n+    BOOST_CHECK(m_local_args.GetBoolArg(\"-foo\", false));\n }\n \n BOOST_AUTO_TEST_CASE(logargs)\n@@ -209,7 +209,7 @@ BOOST_AUTO_TEST_CASE(logargs)\n         });\n \n     // Log the arguments\n-    m_args.LogArgs();\n+    m_local_args.LogArgs();\n \n     LogInstance().DeleteCallback(print_connection);\n     // Check that what should appear does, and what shouldn't doesn't."
      },
      {
        "sha": "f5ae9f86d1308a4d09a800253b052bac815a4c6e",
        "filename": "src/test/settings_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/settings_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/settings_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/settings_tests.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -45,7 +45,7 @@ BOOST_FIXTURE_TEST_SUITE(settings_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(ReadWrite)\n {\n-    fs::path path = GetDataDir() / \"settings.json\";\n+    fs::path path = m_args.GetDataDirPath() / \"settings.json\";\n \n     WriteText(path, R\"({\n         \"string\": \"string\","
      },
      {
        "sha": "ffc5115145800a2685707d35c9fbdadd33646c97",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -71,7 +71,8 @@ std::ostream& operator<<(std::ostream& os, const uint256& num)\n }\n \n BasicTestingSetup::BasicTestingSetup(const std::string& chainName, const std::vector<const char*>& extra_args)\n-    : m_path_root{fs::temp_directory_path() / \"test_common_\" PACKAGE_NAME / g_insecure_rand_ctx_temp_path.rand256().ToString()}\n+    : m_path_root{fs::temp_directory_path() / \"test_common_\" PACKAGE_NAME / g_insecure_rand_ctx_temp_path.rand256().ToString()},\n+      m_args{}\n {\n     const std::vector<const char*> arguments = Cat(\n         {\n@@ -87,8 +88,9 @@ BasicTestingSetup::BasicTestingSetup(const std::string& chainName, const std::ve\n         extra_args);\n     util::ThreadRename(\"test\");\n     fs::create_directories(m_path_root);\n+    m_args.ForceSetArg(\"-datadir\", m_path_root.string());\n     gArgs.ForceSetArg(\"-datadir\", m_path_root.string());\n-    ClearDatadirCache();\n+    gArgs.ClearPathCache();\n     {\n         SetupServerArgs(m_node);\n         std::string error;\n@@ -191,7 +193,7 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n     }\n \n     m_node.addrman = std::make_unique<CAddrMan>();\n-    m_node.banman = std::make_unique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n+    m_node.banman = std::make_unique<BanMan>(m_args.GetDataDirPath() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     m_node.connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman); // Deterministic randomness for tests.\n     m_node.peerman = PeerManager::make(chainparams, *m_node.connman, *m_node.addrman,\n                                        m_node.banman.get(), *m_node.scheduler, *m_node.chainman,"
      },
      {
        "sha": "b19dd757656ac74ddd022597268002572ffd72e4",
        "filename": "src/test/util/setup_common.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/util/setup_common.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/util/setup_common.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -8,6 +8,7 @@\n #include <chainparamsbase.h>\n #include <fs.h>\n #include <key.h>\n+#include <util/system.h>\n #include <node/context.h>\n #include <pubkey.h>\n #include <random.h>\n@@ -80,6 +81,7 @@ struct BasicTestingSetup {\n     ~BasicTestingSetup();\n \n     const fs::path m_path_root;\n+    ArgsManager m_args;\n };\n \n /** Testing setup that performs all steps up until right before"
      },
      {
        "sha": "04b908829bf2d3a88b6d71a863366024a8713741",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 19,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -49,24 +49,27 @@ BOOST_FIXTURE_TEST_SUITE(util_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(util_datadir)\n {\n-    ClearDatadirCache();\n-    const fs::path dd_norm = GetDataDir();\n+    // Use local args variable instead of m_args to avoid making assumptions about test setup\n+    ArgsManager args;\n+    args.ForceSetArg(\"-datadir\", m_path_root.string());\n \n-    gArgs.ForceSetArg(\"-datadir\", dd_norm.string() + \"/\");\n-    ClearDatadirCache();\n-    BOOST_CHECK_EQUAL(dd_norm, GetDataDir());\n+    const fs::path dd_norm = args.GetDataDirPath();\n \n-    gArgs.ForceSetArg(\"-datadir\", dd_norm.string() + \"/.\");\n-    ClearDatadirCache();\n-    BOOST_CHECK_EQUAL(dd_norm, GetDataDir());\n+    args.ForceSetArg(\"-datadir\", dd_norm.string() + \"/\");\n+    args.ClearPathCache();\n+    BOOST_CHECK_EQUAL(dd_norm, args.GetDataDirPath());\n \n-    gArgs.ForceSetArg(\"-datadir\", dd_norm.string() + \"/./\");\n-    ClearDatadirCache();\n-    BOOST_CHECK_EQUAL(dd_norm, GetDataDir());\n+    args.ForceSetArg(\"-datadir\", dd_norm.string() + \"/.\");\n+    args.ClearPathCache();\n+    BOOST_CHECK_EQUAL(dd_norm, args.GetDataDirPath());\n \n-    gArgs.ForceSetArg(\"-datadir\", dd_norm.string() + \"/.//\");\n-    ClearDatadirCache();\n-    BOOST_CHECK_EQUAL(dd_norm, GetDataDir());\n+    args.ForceSetArg(\"-datadir\", dd_norm.string() + \"/./\");\n+    args.ClearPathCache();\n+    BOOST_CHECK_EQUAL(dd_norm, args.GetDataDirPath());\n+\n+    args.ForceSetArg(\"-datadir\", dd_norm.string() + \"/.//\");\n+    args.ClearPathCache();\n+    BOOST_CHECK_EQUAL(dd_norm, args.GetDataDirPath());\n }\n \n BOOST_AUTO_TEST_CASE(util_check)\n@@ -1143,21 +1146,23 @@ BOOST_AUTO_TEST_CASE(util_ReadWriteSettings)\n {\n     // Test writing setting.\n     TestArgsManager args1;\n+    args1.ForceSetArg(\"-datadir\", m_path_root.string());\n     args1.LockSettings([&](util::Settings& settings) { settings.rw_settings[\"name\"] = \"value\"; });\n     args1.WriteSettingsFile();\n \n     // Test reading setting.\n     TestArgsManager args2;\n+    args2.ForceSetArg(\"-datadir\", m_path_root.string());\n     args2.ReadSettingsFile();\n     args2.LockSettings([&](util::Settings& settings) { BOOST_CHECK_EQUAL(settings.rw_settings[\"name\"].get_str(), \"value\"); });\n \n     // Test error logging, and remove previously written setting.\n     {\n         ASSERT_DEBUG_LOG(\"Failed renaming settings file\");\n-        fs::remove(GetDataDir() / \"settings.json\");\n-        fs::create_directory(GetDataDir() / \"settings.json\");\n+        fs::remove(args1.GetDataDirPath() / \"settings.json\");\n+        fs::create_directory(args1.GetDataDirPath() / \"settings.json\");\n         args2.WriteSettingsFile();\n-        fs::remove(GetDataDir() / \"settings.json\");\n+        fs::remove(args1.GetDataDirPath() / \"settings.json\");\n     }\n }\n \n@@ -1796,7 +1801,7 @@ static constexpr char ExitCommand = 'X';\n \n BOOST_AUTO_TEST_CASE(test_LockDirectory)\n {\n-    fs::path dirname = GetDataDir() / \"lock_dir\";\n+    fs::path dirname = m_args.GetDataDirPath() / \"lock_dir\";\n     const std::string lockname = \".lock\";\n #ifndef WIN32\n     // Revert SIGCHLD to default, otherwise boost.test will catch and fail on\n@@ -1885,7 +1890,7 @@ BOOST_AUTO_TEST_CASE(test_LockDirectory)\n BOOST_AUTO_TEST_CASE(test_DirIsWritable)\n {\n     // Should be able to write to the data dir.\n-    fs::path tmpdirname = GetDataDir();\n+    fs::path tmpdirname = m_args.GetDataDirPath();\n     BOOST_CHECK_EQUAL(DirIsWritable(tmpdirname), true);\n \n     // Should not be able to write to a non-existent dir."
      },
      {
        "sha": "304cd8feb07afef4865fe016d780f5f565bb6f7c",
        "filename": "src/test/versionbits_tests.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 40,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/versionbits_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/test/versionbits_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/versionbits_tests.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -81,11 +81,9 @@ class VersionBitsTester\n     TestNeverActiveConditionChecker checker_never[CHECKERS];\n \n     // Test counter (to identify failures)\n-    int num;\n+    int num{1000};\n \n public:\n-    VersionBitsTester() : num(1000) {}\n-\n     VersionBitsTester& Reset() {\n         // Have each group of tests be counted by the 1000s part, starting at 1000\n         num = num - (num % 1000) + 1000;\n@@ -257,39 +255,6 @@ BOOST_AUTO_TEST_CASE(versionbits_test)\n     }\n }\n \n-BOOST_AUTO_TEST_CASE(versionbits_sanity)\n-{\n-    // Sanity checks of version bit deployments\n-    const auto chainParams = CreateChainParams(*m_node.args, CBaseChainParams::MAIN);\n-    const Consensus::Params &mainnetParams = chainParams->GetConsensus();\n-    for (int i=0; i<(int) Consensus::MAX_VERSION_BITS_DEPLOYMENTS; i++) {\n-        uint32_t bitmask = VersionBitsMask(mainnetParams, static_cast<Consensus::DeploymentPos>(i));\n-        // Make sure that no deployment tries to set an invalid bit.\n-        BOOST_CHECK_EQUAL(bitmask & ~(uint32_t)VERSIONBITS_TOP_MASK, bitmask);\n-\n-        // Check min_activation_height is on a retarget boundary\n-        BOOST_CHECK_EQUAL(mainnetParams.vDeployments[i].min_activation_height % mainnetParams.nMinerConfirmationWindow, 0);\n-        // Check min_activation_height is 0 for ALWAYS_ACTIVE and never active deployments\n-        if (mainnetParams.vDeployments[i].nStartTime == Consensus::BIP9Deployment::ALWAYS_ACTIVE || mainnetParams.vDeployments[i].nStartTime == Consensus::BIP9Deployment::NEVER_ACTIVE) {\n-            BOOST_CHECK_EQUAL(mainnetParams.vDeployments[i].min_activation_height, 0);\n-        }\n-\n-        // Verify that the deployment windows of different deployment using the\n-        // same bit are disjoint.\n-        // This test may need modification at such time as a new deployment\n-        // is proposed that reuses the bit of an activated soft fork, before the\n-        // end time of that soft fork.  (Alternatively, the end time of that\n-        // activated soft fork could be later changed to be earlier to avoid\n-        // overlap.)\n-        for (int j=i+1; j<(int) Consensus::MAX_VERSION_BITS_DEPLOYMENTS; j++) {\n-            if (VersionBitsMask(mainnetParams, static_cast<Consensus::DeploymentPos>(j)) == bitmask) {\n-                BOOST_CHECK(mainnetParams.vDeployments[j].nStartTime > mainnetParams.vDeployments[i].nTimeout ||\n-                        mainnetParams.vDeployments[i].nStartTime > mainnetParams.vDeployments[j].nTimeout);\n-            }\n-        }\n-    }\n-}\n-\n /** Check that ComputeBlockVersion will set the appropriate bit correctly */\n static void check_computeblockversion(const Consensus::Params& params, Consensus::DeploymentPos dep)\n {\n@@ -305,16 +270,25 @@ static void check_computeblockversion(const Consensus::Params& params, Consensus\n     BOOST_CHECK_EQUAL(ComputeBlockVersion(nullptr, params), VERSIONBITS_TOP_BITS);\n \n     // always/never active deployments shouldn't need to be tested further\n-    if (nStartTime == Consensus::BIP9Deployment::ALWAYS_ACTIVE) return;\n-    if (nStartTime == Consensus::BIP9Deployment::NEVER_ACTIVE) return;\n+    if (nStartTime == Consensus::BIP9Deployment::ALWAYS_ACTIVE ||\n+        nStartTime == Consensus::BIP9Deployment::NEVER_ACTIVE)\n+    {\n+        BOOST_CHECK_EQUAL(min_activation_height, 0);\n+        return;\n+    }\n \n     BOOST_REQUIRE(nStartTime < nTimeout);\n     BOOST_REQUIRE(nStartTime >= 0);\n     BOOST_REQUIRE(nTimeout <= std::numeric_limits<uint32_t>::max() || nTimeout == Consensus::BIP9Deployment::NO_TIMEOUT);\n     BOOST_REQUIRE(0 <= bit && bit < 32);\n+    // Make sure that no deployment tries to set an invalid bit.\n     BOOST_REQUIRE(((1 << bit) & VERSIONBITS_TOP_MASK) == 0);\n     BOOST_REQUIRE(min_activation_height >= 0);\n-    BOOST_REQUIRE_EQUAL(min_activation_height % params.nMinerConfirmationWindow, 0);\n+    // Check min_activation_height is on a retarget boundary\n+    BOOST_REQUIRE_EQUAL(min_activation_height % params.nMinerConfirmationWindow, 0U);\n+\n+    const uint32_t bitmask{VersionBitsMask(params, dep)};\n+    BOOST_CHECK_EQUAL(bitmask, uint32_t{1} << bit);\n \n     // In the first chain, test that the bit is set by CBV until it has failed.\n     // In the second chain, test the bit is set by CBV while STARTED and\n@@ -443,8 +417,18 @@ BOOST_AUTO_TEST_CASE(versionbits_computeblockversion)\n     // ACTIVE and FAILED states in roughly the way we expect\n     for (const auto& chain_name : {CBaseChainParams::MAIN, CBaseChainParams::TESTNET, CBaseChainParams::SIGNET, CBaseChainParams::REGTEST}) {\n         const auto chainParams = CreateChainParams(*m_node.args, chain_name);\n+        uint32_t chain_all_vbits{0};\n         for (int i = 0; i < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++i) {\n-            check_computeblockversion(chainParams->GetConsensus(), static_cast<Consensus::DeploymentPos>(i));\n+            const auto dep = static_cast<Consensus::DeploymentPos>(i);\n+            // Check that no bits are re-used (within the same chain). This is\n+            // disallowed because the transition to FAILED (on timeout) does\n+            // not take precedence over STARTED/LOCKED_IN. So all softforks on\n+            // the same bit might overlap, even when non-overlapping start-end\n+            // times are picked.\n+            const uint32_t dep_mask{VersionBitsMask(chainParams->GetConsensus(), dep)};\n+            BOOST_CHECK(!(chain_all_vbits & dep_mask));\n+            chain_all_vbits |= dep_mask;\n+            check_computeblockversion(chainParams->GetConsensus(), dep);\n         }\n     }\n "
      },
      {
        "sha": "9b3bd46b386aa21a9cc20703e9236e2a0170cce8",
        "filename": "src/util/system.cpp",
        "status": "modified",
        "additions": 82,
        "deletions": 82,
        "changes": 164,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/util/system.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/util/system.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/system.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -235,6 +235,19 @@ static bool CheckValid(const std::string& key, const util::SettingsValue& val, u\n     return true;\n }\n \n+namespace {\n+fs::path StripRedundantLastElementsOfPath(const fs::path& path)\n+{\n+    auto result = path;\n+    while (result.filename().string() == \".\") {\n+        result = result.parent_path();\n+    }\n+\n+    assert(fs::equivalent(result, path));\n+    return result;\n+}\n+} // namespace\n+\n // Define default constructor and destructor that are not inline, so code instantiating this class doesn't need to\n // #include class definitions for all members.\n // For example, m_settings has an internal dependency on univalue.\n@@ -375,6 +388,72 @@ std::optional<unsigned int> ArgsManager::GetArgFlags(const std::string& name) co\n     return std::nullopt;\n }\n \n+const fs::path& ArgsManager::GetBlocksDirPath()\n+{\n+    LOCK(cs_args);\n+    fs::path& path = m_cached_blocks_path;\n+\n+    // Cache the path to avoid calling fs::create_directories on every call of\n+    // this function\n+    if (!path.empty()) return path;\n+\n+    if (IsArgSet(\"-blocksdir\")) {\n+        path = fs::system_complete(GetArg(\"-blocksdir\", \"\"));\n+        if (!fs::is_directory(path)) {\n+            path = \"\";\n+            return path;\n+        }\n+    } else {\n+        path = GetDataDirPath(false);\n+    }\n+\n+    path /= BaseParams().DataDir();\n+    path /= \"blocks\";\n+    fs::create_directories(path);\n+    path = StripRedundantLastElementsOfPath(path);\n+    return path;\n+}\n+\n+const fs::path& ArgsManager::GetDataDirPath(bool net_specific) const\n+{\n+    LOCK(cs_args);\n+    fs::path& path = net_specific ? m_cached_network_datadir_path : m_cached_datadir_path;\n+\n+    // Cache the path to avoid calling fs::create_directories on every call of\n+    // this function\n+    if (!path.empty()) return path;\n+\n+    std::string datadir = GetArg(\"-datadir\", \"\");\n+    if (!datadir.empty()) {\n+        path = fs::system_complete(datadir);\n+        if (!fs::is_directory(path)) {\n+            path = \"\";\n+            return path;\n+        }\n+    } else {\n+        path = GetDefaultDataDir();\n+    }\n+    if (net_specific)\n+        path /= BaseParams().DataDir();\n+\n+    if (fs::create_directories(path)) {\n+        // This is the first run, create wallets subdirectory too\n+        fs::create_directories(path / \"wallets\");\n+    }\n+\n+    path = StripRedundantLastElementsOfPath(path);\n+    return path;\n+}\n+\n+void ArgsManager::ClearPathCache()\n+{\n+    LOCK(cs_args);\n+\n+    m_cached_datadir_path = fs::path();\n+    m_cached_network_datadir_path = fs::path();\n+    m_cached_blocks_path = fs::path();\n+}\n+\n std::optional<const ArgsManager::Command> ArgsManager::GetCommand() const\n {\n     Command ret;\n@@ -434,7 +513,7 @@ bool ArgsManager::GetSettingsPath(fs::path* filepath, bool temp) const\n     }\n     if (filepath) {\n         std::string settings = GetArg(\"-settings\", BITCOIN_SETTINGS_FILENAME);\n-        *filepath = fsbridge::AbsPathJoin(GetDataDir(/* net_specific= */ true), temp ? settings + \".tmp\" : settings);\n+        *filepath = fsbridge::AbsPathJoin(GetDataDirPath(/* net_specific= */ true), temp ? settings + \".tmp\" : settings);\n     }\n     return true;\n }\n@@ -723,79 +802,9 @@ fs::path GetDefaultDataDir()\n #endif\n }\n \n-namespace {\n-fs::path StripRedundantLastElementsOfPath(const fs::path& path)\n-{\n-    auto result = path;\n-    while (result.filename().string() == \".\") {\n-        result = result.parent_path();\n-    }\n-\n-    assert(fs::equivalent(result, path));\n-    return result;\n-}\n-} // namespace\n-\n-static fs::path g_blocks_path_cache_net_specific;\n-static fs::path pathCached;\n-static fs::path pathCachedNetSpecific;\n-static RecursiveMutex csPathCached;\n-\n-const fs::path &GetBlocksDir()\n-{\n-    LOCK(csPathCached);\n-    fs::path &path = g_blocks_path_cache_net_specific;\n-\n-    // Cache the path to avoid calling fs::create_directories on every call of\n-    // this function\n-    if (!path.empty()) return path;\n-\n-    if (gArgs.IsArgSet(\"-blocksdir\")) {\n-        path = fs::system_complete(gArgs.GetArg(\"-blocksdir\", \"\"));\n-        if (!fs::is_directory(path)) {\n-            path = \"\";\n-            return path;\n-        }\n-    } else {\n-        path = GetDataDir(false);\n-    }\n-\n-    path /= BaseParams().DataDir();\n-    path /= \"blocks\";\n-    fs::create_directories(path);\n-    path = StripRedundantLastElementsOfPath(path);\n-    return path;\n-}\n-\n const fs::path &GetDataDir(bool fNetSpecific)\n {\n-    LOCK(csPathCached);\n-    fs::path &path = fNetSpecific ? pathCachedNetSpecific : pathCached;\n-\n-    // Cache the path to avoid calling fs::create_directories on every call of\n-    // this function\n-    if (!path.empty()) return path;\n-\n-    std::string datadir = gArgs.GetArg(\"-datadir\", \"\");\n-    if (!datadir.empty()) {\n-        path = fs::system_complete(datadir);\n-        if (!fs::is_directory(path)) {\n-            path = \"\";\n-            return path;\n-        }\n-    } else {\n-        path = GetDefaultDataDir();\n-    }\n-    if (fNetSpecific)\n-        path /= BaseParams().DataDir();\n-\n-    if (fs::create_directories(path)) {\n-        // This is the first run, create wallets subdirectory too\n-        fs::create_directories(path / \"wallets\");\n-    }\n-\n-    path = StripRedundantLastElementsOfPath(path);\n-    return path;\n+    return gArgs.GetDataDirPath(fNetSpecific);\n }\n \n bool CheckDataDirOption()\n@@ -804,15 +813,6 @@ bool CheckDataDirOption()\n     return datadir.empty() || fs::is_directory(fs::system_complete(datadir));\n }\n \n-void ClearDatadirCache()\n-{\n-    LOCK(csPathCached);\n-\n-    pathCached = fs::path();\n-    pathCachedNetSpecific = fs::path();\n-    g_blocks_path_cache_net_specific = fs::path();\n-}\n-\n fs::path GetConfigFile(const std::string& confPath)\n {\n     return AbsPathForConfigVal(fs::path(confPath), false);\n@@ -971,7 +971,7 @@ bool ArgsManager::ReadConfigFiles(std::string& error, bool ignore_invalid_keys)\n     }\n \n     // If datadir is changed in .conf file:\n-    ClearDatadirCache();\n+    gArgs.ClearPathCache();\n     if (!CheckDataDirOption()) {\n         error = strprintf(\"specified data directory \\\"%s\\\" does not exist.\", GetArg(\"-datadir\", \"\"));\n         return false;"
      },
      {
        "sha": "61f862c93a6d66d9f500a0ddf31546a010a8935f",
        "filename": "src/util/system.h",
        "status": "modified",
        "additions": 24,
        "deletions": 4,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/util/system.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/util/system.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/system.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -91,13 +91,9 @@ void ReleaseDirectoryLocks();\n \n bool TryCreateDirectories(const fs::path& p);\n fs::path GetDefaultDataDir();\n-// The blocks directory is always net specific.\n-const fs::path &GetBlocksDir();\n const fs::path &GetDataDir(bool fNetSpecific = true);\n // Return true if -datadir option points to a valid directory or is not specified.\n bool CheckDataDirOption();\n-/** Tests only */\n-void ClearDatadirCache();\n fs::path GetConfigFile(const std::string& confPath);\n #ifdef WIN32\n fs::path GetSpecialFolderPath(int nFolder, bool fCreate = true);\n@@ -200,6 +196,9 @@ class ArgsManager\n     std::map<OptionsCategory, std::map<std::string, Arg>> m_available_args GUARDED_BY(cs_args);\n     bool m_accept_any_command GUARDED_BY(cs_args){true};\n     std::list<SectionInfo> m_config_sections GUARDED_BY(cs_args);\n+    fs::path m_cached_blocks_path GUARDED_BY(cs_args);\n+    mutable fs::path m_cached_datadir_path GUARDED_BY(cs_args);\n+    mutable fs::path m_cached_network_datadir_path GUARDED_BY(cs_args);\n \n     [[nodiscard]] bool ReadConfigStream(std::istream& stream, const std::string& filepath, std::string& error, bool ignore_invalid_keys = false);\n \n@@ -263,6 +262,27 @@ class ArgsManager\n      */\n     std::optional<const Command> GetCommand() const;\n \n+    /**\n+     * Get blocks directory path\n+     *\n+     * @return Blocks path which is network specific\n+     */\n+    const fs::path& GetBlocksDirPath();\n+\n+    /**\n+     * Get data directory path\n+     *\n+     * @param net_specific Append network identifier to the returned path\n+     * @return Absolute path on success, otherwise an empty path when a non-directory path would be returned\n+     * @post Returned directory path is created unless it is empty\n+     */\n+    const fs::path& GetDataDirPath(bool net_specific = true) const;\n+\n+    /**\n+     * Clear cached directory paths\n+     */\n+    void ClearPathCache();\n+\n     /**\n      * Return a vector of strings of the given argument\n      *"
      },
      {
        "sha": "1ddafa561309a1776fadfa6eb06748ba7d6f6c1e",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 152,
        "changes": 194,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -2204,7 +2204,7 @@ bool CChainState::FlushStateToDisk(\n         // Write blocks and block index to disk.\n         if (fDoFullFlush || fPeriodicWrite) {\n             // Depend on nMinDiskSpace to ensure we can write block index\n-            if (!CheckDiskSpace(GetBlocksDir())) {\n+            if (!CheckDiskSpace(gArgs.GetBlocksDirPath())) {\n                 return AbortNode(state, \"Disk space is too low!\", _(\"Disk space is too low!\"));\n             }\n             {\n@@ -3890,12 +3890,12 @@ void BlockManager::FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPr\n \n static FlatFileSeq BlockFileSeq()\n {\n-    return FlatFileSeq(GetBlocksDir(), \"blk\", gArgs.GetBoolArg(\"-fastprune\", false) ? 0x4000 /* 16kb */ : BLOCKFILE_CHUNK_SIZE);\n+    return FlatFileSeq(gArgs.GetBlocksDirPath(), \"blk\", gArgs.GetBoolArg(\"-fastprune\", false) ? 0x4000 /* 16kb */ : BLOCKFILE_CHUNK_SIZE);\n }\n \n static FlatFileSeq UndoFileSeq()\n {\n-    return FlatFileSeq(GetBlocksDir(), \"rev\", UNDOFILE_CHUNK_SIZE);\n+    return FlatFileSeq(gArgs.GetBlocksDirPath(), \"rev\", UNDOFILE_CHUNK_SIZE);\n }\n \n FILE* OpenBlockFile(const FlatFilePos &pos, bool fReadOnly) {\n@@ -4101,38 +4101,46 @@ CVerifyDB::~CVerifyDB()\n     uiInterface.ShowProgress(\"\", 100, false);\n }\n \n-bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CChainState& active_chainstate, CCoinsView *coinsview, int nCheckLevel, int nCheckDepth)\n+bool CVerifyDB::VerifyDB(\n+    CChainState& chainstate,\n+    const CChainParams& chainparams,\n+    CCoinsView& coinsview,\n+    int nCheckLevel, int nCheckDepth)\n {\n     AssertLockHeld(cs_main);\n \n-    assert(std::addressof(::ChainstateActive()) == std::addressof(active_chainstate));\n-    if (active_chainstate.m_chain.Tip() == nullptr || active_chainstate.m_chain.Tip()->pprev == nullptr)\n+    assert(std::addressof(::ChainstateActive()) == std::addressof(chainstate));\n+    if (chainstate.m_chain.Tip() == nullptr || chainstate.m_chain.Tip()->pprev == nullptr)\n         return true;\n \n     // Verify blocks in the best chain\n-    if (nCheckDepth <= 0 || nCheckDepth > active_chainstate.m_chain.Height())\n-        nCheckDepth = active_chainstate.m_chain.Height();\n+    if (nCheckDepth <= 0 || nCheckDepth > chainstate.m_chain.Height())\n+        nCheckDepth = chainstate.m_chain.Height();\n     nCheckLevel = std::max(0, std::min(4, nCheckLevel));\n     LogPrintf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel);\n-    CCoinsViewCache coins(coinsview);\n+    CCoinsViewCache coins(&coinsview);\n     CBlockIndex* pindex;\n     CBlockIndex* pindexFailure = nullptr;\n     int nGoodTransactions = 0;\n     BlockValidationState state;\n     int reportDone = 0;\n     LogPrintf(\"[0%%]...\"); /* Continued */\n-    for (pindex = active_chainstate.m_chain.Tip(); pindex && pindex->pprev; pindex = pindex->pprev) {\n-        const int percentageDone = std::max(1, std::min(99, (int)(((double)(active_chainstate.m_chain.Height() - pindex->nHeight)) / (double)nCheckDepth * (nCheckLevel >= 4 ? 50 : 100))));\n+\n+    bool is_snapshot_cs = !chainstate.m_from_snapshot_blockhash.IsNull();\n+\n+    for (pindex = chainstate.m_chain.Tip(); pindex && pindex->pprev; pindex = pindex->pprev) {\n+        const int percentageDone = std::max(1, std::min(99, (int)(((double)(chainstate.m_chain.Height() - pindex->nHeight)) / (double)nCheckDepth * (nCheckLevel >= 4 ? 50 : 100))));\n         if (reportDone < percentageDone/10) {\n             // report every 10% step\n             LogPrintf(\"[%d%%]...\", percentageDone); /* Continued */\n             reportDone = percentageDone/10;\n         }\n         uiInterface.ShowProgress(_(\"Verifying blocks...\").translated, percentageDone, false);\n-        if (pindex->nHeight <= active_chainstate.m_chain.Height()-nCheckDepth)\n+        if (pindex->nHeight <= chainstate.m_chain.Height()-nCheckDepth)\n             break;\n-        if (fPruneMode && !(pindex->nStatus & BLOCK_HAVE_DATA)) {\n-            // If pruning, only go back as far as we have data.\n+        if ((fPruneMode || is_snapshot_cs) && !(pindex->nStatus & BLOCK_HAVE_DATA)) {\n+            // If pruning or running under an assumeutxo snapshot, only go\n+            // back as far as we have data.\n             LogPrintf(\"VerifyDB(): block verification stopping at height %d (pruning, no data)\\n\", pindex->nHeight);\n             break;\n         }\n@@ -4154,9 +4162,11 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CChainState& active_ch\n             }\n         }\n         // check level 3: check for inconsistencies during memory-only disconnect of tip blocks\n-        if (nCheckLevel >= 3 && (coins.DynamicMemoryUsage() + active_chainstate.CoinsTip().DynamicMemoryUsage()) <= active_chainstate.m_coinstip_cache_size_bytes) {\n+        size_t curr_coins_usage = coins.DynamicMemoryUsage() + chainstate.CoinsTip().DynamicMemoryUsage();\n+\n+        if (nCheckLevel >= 3 && curr_coins_usage <= chainstate.m_coinstip_cache_size_bytes) {\n             assert(coins.GetBestBlock() == pindex->GetBlockHash());\n-            DisconnectResult res = active_chainstate.DisconnectBlock(block, pindex, coins);\n+            DisconnectResult res = chainstate.DisconnectBlock(block, pindex, coins);\n             if (res == DISCONNECT_FAILED) {\n                 return error(\"VerifyDB(): *** irrecoverable inconsistency in block data at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n             }\n@@ -4170,26 +4180,26 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CChainState& active_ch\n         if (ShutdownRequested()) return true;\n     }\n     if (pindexFailure)\n-        return error(\"VerifyDB(): *** coin database inconsistencies found (last %i blocks, %i good transactions before that)\\n\", active_chainstate.m_chain.Height() - pindexFailure->nHeight + 1, nGoodTransactions);\n+        return error(\"VerifyDB(): *** coin database inconsistencies found (last %i blocks, %i good transactions before that)\\n\", chainstate.m_chain.Height() - pindexFailure->nHeight + 1, nGoodTransactions);\n \n     // store block count as we move pindex at check level >= 4\n-    int block_count = active_chainstate.m_chain.Height() - pindex->nHeight;\n+    int block_count = chainstate.m_chain.Height() - pindex->nHeight;\n \n     // check level 4: try reconnecting blocks\n     if (nCheckLevel >= 4) {\n-        while (pindex != active_chainstate.m_chain.Tip()) {\n-            const int percentageDone = std::max(1, std::min(99, 100 - (int)(((double)(active_chainstate.m_chain.Height() - pindex->nHeight)) / (double)nCheckDepth * 50)));\n+        while (pindex != chainstate.m_chain.Tip()) {\n+            const int percentageDone = std::max(1, std::min(99, 100 - (int)(((double)(chainstate.m_chain.Height() - pindex->nHeight)) / (double)nCheckDepth * 50)));\n             if (reportDone < percentageDone/10) {\n                 // report every 10% step\n                 LogPrintf(\"[%d%%]...\", percentageDone); /* Continued */\n                 reportDone = percentageDone/10;\n             }\n             uiInterface.ShowProgress(_(\"Verifying blocks...\").translated, percentageDone, false);\n-            pindex = active_chainstate.m_chain.Next(pindex);\n+            pindex = chainstate.m_chain.Next(pindex);\n             CBlock block;\n             if (!ReadBlockFromDisk(block, pindex, chainparams.GetConsensus()))\n                 return error(\"VerifyDB(): *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n-            if (!active_chainstate.ConnectBlock(block, state, pindex, coins, chainparams))\n+            if (!chainstate.ConnectBlock(block, state, pindex, coins, chainparams))\n                 return error(\"VerifyDB(): *** found unconnectable block at %d, hash=%s (%s)\", pindex->nHeight, pindex->GetBlockHash().ToString(), state.ToString());\n             if (ShutdownRequested()) return true;\n         }\n@@ -4289,143 +4299,23 @@ bool CChainState::ReplayBlocks(const CChainParams& params)\n     return true;\n }\n \n-//! Helper for CChainState::RewindBlockIndex\n-void CChainState::EraseBlockData(CBlockIndex* index)\n+bool CChainState::NeedsRedownload(const CChainParams& params) const\n {\n     AssertLockHeld(cs_main);\n-    assert(!m_chain.Contains(index)); // Make sure this block isn't active\n-\n-    // Reduce validity\n-    index->nStatus = std::min<unsigned int>(index->nStatus & BLOCK_VALID_MASK, BLOCK_VALID_TREE) | (index->nStatus & ~BLOCK_VALID_MASK);\n-    // Remove have-data flags.\n-    index->nStatus &= ~(BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO);\n-    // Remove storage location.\n-    index->nFile = 0;\n-    index->nDataPos = 0;\n-    index->nUndoPos = 0;\n-    // Remove various other things\n-    index->nTx = 0;\n-    index->nChainTx = 0;\n-    index->nSequenceId = 0;\n-    // Make sure it gets written.\n-    setDirtyBlockIndex.insert(index);\n-    // Update indexes\n-    setBlockIndexCandidates.erase(index);\n-    auto ret = m_blockman.m_blocks_unlinked.equal_range(index->pprev);\n-    while (ret.first != ret.second) {\n-        if (ret.first->second == index) {\n-            m_blockman.m_blocks_unlinked.erase(ret.first++);\n-        } else {\n-            ++ret.first;\n-        }\n-    }\n-    // Mark parent as eligible for main chain again\n-    if (index->pprev && index->pprev->IsValid(BLOCK_VALID_TRANSACTIONS) && index->pprev->HaveTxsDownloaded()) {\n-        setBlockIndexCandidates.insert(index->pprev);\n-    }\n-}\n-\n-bool CChainState::RewindBlockIndex(const CChainParams& params)\n-{\n-    // Note that during -reindex-chainstate we are called with an empty m_chain!\n-\n-    // First erase all post-segwit blocks without witness not in the main chain,\n-    // as this can we done without costly DisconnectTip calls. Active\n-    // blocks will be dealt with below (releasing cs_main in between).\n-    {\n-        LOCK(cs_main);\n-        for (const auto& entry : m_blockman.m_block_index) {\n-            if (IsWitnessEnabled(entry.second->pprev, params.GetConsensus()) && !(entry.second->nStatus & BLOCK_OPT_WITNESS) && !m_chain.Contains(entry.second)) {\n-                EraseBlockData(entry.second);\n-            }\n-        }\n-    }\n-\n-    // Find what height we need to reorganize to.\n-    CBlockIndex *tip;\n-    int nHeight = 1;\n-    {\n-        LOCK(cs_main);\n-        while (nHeight <= m_chain.Height()) {\n-            // Although SCRIPT_VERIFY_WITNESS is now generally enforced on all\n-            // blocks in ConnectBlock, we don't need to go back and\n-            // re-download/re-verify blocks from before segwit actually activated.\n-            if (IsWitnessEnabled(m_chain[nHeight - 1], params.GetConsensus()) && !(m_chain[nHeight]->nStatus & BLOCK_OPT_WITNESS)) {\n-                break;\n-            }\n-            nHeight++;\n-        }\n \n-        tip = m_chain.Tip();\n-    }\n-    // nHeight is now the height of the first insufficiently-validated block, or tipheight + 1\n+    // At and above params.SegwitHeight, segwit consensus rules must be validated\n+    CBlockIndex* block{m_chain.Tip()};\n+    const int segwit_height{params.GetConsensus().SegwitHeight};\n \n-    BlockValidationState state;\n-    // Loop until the tip is below nHeight, or we reach a pruned block.\n-    while (!ShutdownRequested()) {\n-        {\n-            LOCK(cs_main);\n-            LOCK(m_mempool.cs);\n-            // Make sure nothing changed from under us (this won't happen because RewindBlockIndex runs before importing/network are active)\n-            assert(tip == m_chain.Tip());\n-            if (tip == nullptr || tip->nHeight < nHeight) break;\n-            if (fPruneMode && !(tip->nStatus & BLOCK_HAVE_DATA)) {\n-                // If pruning, don't try rewinding past the HAVE_DATA point;\n-                // since older blocks can't be served anyway, there's\n-                // no need to walk further, and trying to DisconnectTip()\n-                // will fail (and require a needless reindex/redownload\n-                // of the blockchain).\n-                break;\n-            }\n-\n-            // Disconnect block\n-            if (!DisconnectTip(state, params, nullptr)) {\n-                return error(\"RewindBlockIndex: unable to disconnect block at height %i (%s)\", tip->nHeight, state.ToString());\n-            }\n-\n-            // Reduce validity flag and have-data flags.\n-            // We do this after actual disconnecting, otherwise we'll end up writing the lack of data\n-            // to disk before writing the chainstate, resulting in a failure to continue if interrupted.\n-            // Note: If we encounter an insufficiently validated block that\n-            // is on m_chain, it must be because we are a pruning node, and\n-            // this block or some successor doesn't HAVE_DATA, so we were unable to\n-            // rewind all the way.  Blocks remaining on m_chain at this point\n-            // must not have their validity reduced.\n-            EraseBlockData(tip);\n-\n-            tip = tip->pprev;\n-        }\n-        // Make sure the queue of validation callbacks doesn't grow unboundedly.\n-        LimitValidationInterfaceQueue();\n-\n-        // Occasionally flush state to disk.\n-        if (!FlushStateToDisk(params, state, FlushStateMode::PERIODIC)) {\n-            LogPrintf(\"RewindBlockIndex: unable to flush state to disk (%s)\\n\", state.ToString());\n-            return false;\n-        }\n-    }\n-\n-    {\n-        LOCK(cs_main);\n-        if (m_chain.Tip() != nullptr) {\n-            // We can't prune block index candidates based on our tip if we have\n-            // no tip due to m_chain being empty!\n-            PruneBlockIndexCandidates();\n-\n-            CheckBlockIndex(params.GetConsensus());\n-\n-            // FlushStateToDisk can possibly read ::ChainActive(). Be conservative\n-            // and skip it here, we're about to -reindex-chainstate anyway, so\n-            // it'll get called a bunch real soon.\n-            BlockValidationState state;\n-            if (!FlushStateToDisk(params, state, FlushStateMode::ALWAYS)) {\n-                LogPrintf(\"RewindBlockIndex: unable to flush state to disk (%s)\\n\", state.ToString());\n-                return false;\n-            }\n+    while (block != nullptr && block->nHeight >= segwit_height) {\n+        if (!(block->nStatus & BLOCK_OPT_WITNESS)) {\n+            // block is insufficiently validated for a segwit client\n+            return true;\n         }\n+        block = block->pprev;\n     }\n \n-    return true;\n+    return false;\n }\n \n void CChainState::UnloadBlockIndex() {"
      },
      {
        "sha": "ed1ba4310c9a47c31e30fc894e723b52815c84c6",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 17,
        "deletions": 11,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -195,14 +195,14 @@ struct MempoolAcceptResult {\n         VALID, //!> Fully validated, valid.\n         INVALID, //!> Invalid.\n     };\n-    ResultType m_result_type;\n-    TxValidationState m_state;\n+    const ResultType m_result_type;\n+    const TxValidationState m_state;\n \n     // The following fields are only present when m_result_type = ResultType::VALID\n     /** Mempool transactions replaced by the tx per BIP 125 rules. */\n-    std::optional<std::list<CTransactionRef>> m_replaced_transactions;\n-    /** Raw base fees. */\n-    std::optional<CAmount> m_base_fees;\n+    const std::optional<std::list<CTransactionRef>> m_replaced_transactions;\n+    /** Raw base fees in satoshis. */\n+    const std::optional<CAmount> m_base_fees;\n \n     /** Constructor for failure case */\n     explicit MempoolAcceptResult(TxValidationState state)\n@@ -212,7 +212,7 @@ struct MempoolAcceptResult {\n \n     /** Constructor for success case */\n     explicit MempoolAcceptResult(std::list<CTransactionRef>&& replaced_txns, CAmount fees)\n-        : m_result_type(ResultType::VALID), m_state(TxValidationState{}),\n+        : m_result_type(ResultType::VALID),\n         m_replaced_transactions(std::move(replaced_txns)), m_base_fees(fees) {}\n };\n \n@@ -329,7 +329,12 @@ class CVerifyDB {\n public:\n     CVerifyDB();\n     ~CVerifyDB();\n-    bool VerifyDB(const CChainParams& chainparams, CChainState& active_chainstate, CCoinsView *coinsview, int nCheckLevel, int nCheckDepth) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool VerifyDB(\n+        CChainState& chainstate,\n+        const CChainParams& chainparams,\n+        CCoinsView& coinsview,\n+        int nCheckLevel,\n+        int nCheckDepth) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n };\n \n enum DisconnectResult\n@@ -713,7 +718,9 @@ class CChainState\n \n     /** Replay blocks that aren't fully applied to the database. */\n     bool ReplayBlocks(const CChainParams& params);\n-    bool RewindBlockIndex(const CChainParams& params) LOCKS_EXCLUDED(cs_main);\n+\n+    /** Whether the chain state needs to be redownloaded due to lack of witness data */\n+    [[nodiscard]] bool NeedsRedownload(const CChainParams& params) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     /** Ensures we have a genesis block in the block tree, possibly writing one to disk. */\n     bool LoadGenesisBlock(const CChainParams& chainparams);\n \n@@ -760,9 +767,6 @@ class CChainState\n \n     bool RollforwardBlock(const CBlockIndex* pindex, CCoinsViewCache& inputs, const CChainParams& params) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-    //! Mark a block as not having block data\n-    void EraseBlockData(CBlockIndex* index) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n     void CheckForkWarningConditions() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     void InvalidChainFound(CBlockIndex* pindexNew) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n@@ -914,6 +918,8 @@ class ChainstateManager\n         return m_blockman.m_block_index;\n     }\n \n+    //! @returns true if a snapshot-based chainstate is in use. Also implies\n+    //!          that a background validation chainstate is also in use.\n     bool IsSnapshotActive() const;\n \n     std::optional<uint256> SnapshotBlockhash() const;"
      },
      {
        "sha": "598c5f082c880cbb36811c6295a1002b8bd13bcc",
        "filename": "src/wallet/coincontrol.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 15,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/wallet/coincontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/wallet/coincontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coincontrol.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -6,21 +6,7 @@\n \n #include <util/system.h>\n \n-void CCoinControl::SetNull()\n+CCoinControl::CCoinControl()\n {\n-    destChange = CNoDestination();\n-    m_change_type.reset();\n-    m_add_inputs = true;\n-    fAllowOtherInputs = false;\n-    fAllowWatchOnly = false;\n     m_avoid_partial_spends = gArgs.GetBoolArg(\"-avoidpartialspends\", DEFAULT_AVOIDPARTIALSPENDS);\n-    m_avoid_address_reuse = false;\n-    setSelected.clear();\n-    m_feerate.reset();\n-    fOverrideFeeRate = false;\n-    m_confirm_target.reset();\n-    m_signal_bip125_rbf.reset();\n-    m_fee_mode = FeeEstimateMode::UNSET;\n-    m_min_depth = DEFAULT_MIN_DEPTH;\n-    m_max_depth = DEFAULT_MAX_DEPTH;\n }"
      },
      {
        "sha": "716e1922fe932308ff26676e51e1bc3de2117420",
        "filename": "src/wallet/coincontrol.h",
        "status": "modified",
        "additions": 9,
        "deletions": 14,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/wallet/coincontrol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/wallet/coincontrol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coincontrol.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -24,40 +24,35 @@ class CCoinControl\n {\n public:\n     //! Custom change destination, if not set an address is generated\n-    CTxDestination destChange;\n+    CTxDestination destChange = CNoDestination();\n     //! Override the default change type if set, ignored if destChange is set\n     std::optional<OutputType> m_change_type;\n     //! If false, only selected inputs are used\n-    bool m_add_inputs;\n+    bool m_add_inputs = true;\n     //! If false, allows unselected inputs, but requires all selected inputs be used\n-    bool fAllowOtherInputs;\n+    bool fAllowOtherInputs = false;\n     //! Includes watch only addresses which are solvable\n-    bool fAllowWatchOnly;\n+    bool fAllowWatchOnly = false;\n     //! Override automatic min/max checks on fee, m_feerate must be set if true\n-    bool fOverrideFeeRate;\n+    bool fOverrideFeeRate = false;\n     //! Override the wallet's m_pay_tx_fee if set\n     std::optional<CFeeRate> m_feerate;\n     //! Override the default confirmation target if set\n     std::optional<unsigned int> m_confirm_target;\n     //! Override the wallet's m_signal_rbf if set\n     std::optional<bool> m_signal_bip125_rbf;\n     //! Avoid partial use of funds sent to a given address\n-    bool m_avoid_partial_spends;\n+    bool m_avoid_partial_spends = DEFAULT_AVOIDPARTIALSPENDS;\n     //! Forbids inclusion of dirty (previously used) addresses\n-    bool m_avoid_address_reuse;\n+    bool m_avoid_address_reuse = false;\n     //! Fee estimation mode to control arguments to estimateSmartFee\n-    FeeEstimateMode m_fee_mode;\n+    FeeEstimateMode m_fee_mode = FeeEstimateMode::UNSET;\n     //! Minimum chain depth value for coin availability\n     int m_min_depth = DEFAULT_MIN_DEPTH;\n     //! Maximum chain depth value for coin availability\n     int m_max_depth = DEFAULT_MAX_DEPTH;\n \n-    CCoinControl()\n-    {\n-        SetNull();\n-    }\n-\n-    void SetNull();\n+    CCoinControl();\n \n     bool HasSelected() const\n     {"
      },
      {
        "sha": "5c1b36be6e32e649289dd046b7735bb2eeca997b",
        "filename": "src/wallet/coinselection.h",
        "status": "modified",
        "additions": 29,
        "deletions": 1,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/wallet/coinselection.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/wallet/coinselection.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -15,6 +15,7 @@ static constexpr CAmount MIN_CHANGE{COIN / 100};\n //! final minimum change amount after paying for fees\n static const CAmount MIN_FINAL_CHANGE = MIN_CHANGE/2;\n \n+/** A UTXO under consideration for use in funding a new transaction. */\n class CInputCoin {\n public:\n     CInputCoin(const CTransactionRef& tx, unsigned int i)\n@@ -56,31 +57,58 @@ class CInputCoin {\n     }\n };\n \n+/** Parameters for filtering which OutputGroups we may use in coin selection.\n+ * We start by being very selective and requiring multiple confirmations and\n+ * then get more permissive if we cannot fund the transaction. */\n struct CoinEligibilityFilter\n {\n+    /** Minimum number of confirmations for outputs that we sent to ourselves.\n+     * We may use unconfirmed UTXOs sent from ourselves, e.g. change outputs. */\n     const int conf_mine;\n+    /** Minimum number of confirmations for outputs received from a different\n+     * wallet. We never spend unconfirmed foreign outputs as we cannot rely on these funds yet. */\n     const int conf_theirs;\n+    /** Maximum number of unconfirmed ancestors aggregated across all UTXOs in an OutputGroup. */\n     const uint64_t max_ancestors;\n+    /** Maximum number of descendants that a single UTXO in the OutputGroup may have. */\n     const uint64_t max_descendants;\n-    const bool m_include_partial_groups{false}; //! Include partial destination groups when avoid_reuse and there are full groups\n+    /** When avoid_reuse=true and there are full groups (OUTPUT_GROUP_MAX_ENTRIES), whether or not to use any partial groups.*/\n+    const bool m_include_partial_groups{false};\n \n     CoinEligibilityFilter(int conf_mine, int conf_theirs, uint64_t max_ancestors) : conf_mine(conf_mine), conf_theirs(conf_theirs), max_ancestors(max_ancestors), max_descendants(max_ancestors) {}\n     CoinEligibilityFilter(int conf_mine, int conf_theirs, uint64_t max_ancestors, uint64_t max_descendants) : conf_mine(conf_mine), conf_theirs(conf_theirs), max_ancestors(max_ancestors), max_descendants(max_descendants) {}\n     CoinEligibilityFilter(int conf_mine, int conf_theirs, uint64_t max_ancestors, uint64_t max_descendants, bool include_partial) : conf_mine(conf_mine), conf_theirs(conf_theirs), max_ancestors(max_ancestors), max_descendants(max_descendants), m_include_partial_groups(include_partial) {}\n };\n \n+/** A group of UTXOs paid to the same output script. */\n struct OutputGroup\n {\n+    /** The list of UTXOs contained in this output group. */\n     std::vector<CInputCoin> m_outputs;\n+    /** Whether the UTXOs were sent by the wallet to itself. This is relevant because we may want at\n+     * least a certain number of confirmations on UTXOs received from outside wallets while trusting\n+     * our own UTXOs more. */\n     bool m_from_me{true};\n+    /** The total value of the UTXOs in sum. */\n     CAmount m_value{0};\n+    /** The minimum number of confirmations the UTXOs in the group have. Unconfirmed is 0. */\n     int m_depth{999};\n+    /** The aggregated count of unconfirmed ancestors of all UTXOs in this\n+     * group. Not deduplicated and may overestimate when ancestors are shared. */\n     size_t m_ancestors{0};\n+    /** The maximum count of descendants of a single UTXO in this output group. */\n     size_t m_descendants{0};\n+    /** The value of the UTXOs after deducting the cost of spending them at the effective feerate. */\n     CAmount effective_value{0};\n+    /** The fee to spend these UTXOs at the effective feerate. */\n     CAmount fee{0};\n+    /** The target feerate of the transaction we're trying to build. */\n     CFeeRate m_effective_feerate{0};\n+    /** The fee to spend these UTXOs at the long term feerate. */\n     CAmount long_term_fee{0};\n+    /** The feerate for spending a created change output eventually (i.e. not urgently, and thus at\n+     * a lower feerate). Calculated using long term fee estimate. This is used to decide whether\n+     * it could be economical to create a change output. */\n     CFeeRate m_long_term_feerate{0};\n \n     OutputGroup() {}"
      },
      {
        "sha": "f0aaee7e4ea37e8a1d546fd5a3cf04ab3b7554c3",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 13,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -2478,7 +2478,7 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n         }\n     }\n \n-    // remove preset inputs from vCoins\n+    // remove preset inputs from vCoins so that Coin Selection doesn't pick them.\n     for (std::vector<COutput>::iterator it = vCoins.begin(); it != vCoins.end() && coin_control.HasSelected();)\n     {\n         if (setPresetCoins.count(it->GetInputCoin()))\n@@ -2490,9 +2490,9 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n     unsigned int limit_ancestor_count = 0;\n     unsigned int limit_descendant_count = 0;\n     chain().getPackageLimits(limit_ancestor_count, limit_descendant_count);\n-    size_t max_ancestors = (size_t)std::max<int64_t>(1, limit_ancestor_count);\n-    size_t max_descendants = (size_t)std::max<int64_t>(1, limit_descendant_count);\n-    bool fRejectLongChains = gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS);\n+    const size_t max_ancestors = (size_t)std::max<int64_t>(1, limit_ancestor_count);\n+    const size_t max_descendants = (size_t)std::max<int64_t>(1, limit_descendant_count);\n+    const bool fRejectLongChains = gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS);\n \n     // form groups from remaining coins; note that preset coins will not\n     // automatically have their associated (same address) coins included\n@@ -2502,16 +2502,53 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n         // explicitly shuffling the outputs before processing\n         Shuffle(vCoins.begin(), vCoins.end(), FastRandomContext());\n     }\n-    bool res = value_to_select <= 0 ||\n-        SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used) ||\n-        SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1, true /* include_partial_groups */), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n-        (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max(), std::numeric_limits<uint64_t>::max(), true /* include_partial_groups */), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n \n-    // because SelectCoinsMinConf clears the setCoinsRet, we now add the possible inputs to the coinset\n+    // Coin Selection attempts to select inputs from a pool of eligible UTXOs to fund the\n+    // transaction at a target feerate. If an attempt fails, more attempts may be made using a more\n+    // permissive CoinEligibilityFilter.\n+    const bool res = [&] {\n+        // Pre-selected inputs already cover the target amount.\n+        if (value_to_select <= 0) return true;\n+\n+        // If possible, fund the transaction with confirmed UTXOs only. Prefer at least six\n+        // confirmations on outputs received from other wallets and only spend confirmed change.\n+        if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) return true;\n+        if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) return true;\n+\n+        // Fall back to using zero confirmation change (but with as few ancestors in the mempool as\n+        // possible) if we cannot fund the transaction otherwise. We never spend unconfirmed\n+        // outputs received from other wallets.\n+        if (m_spend_zero_conf_change) {\n+            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) return true;\n+            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)),\n+                                   vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) {\n+                return true;\n+            }\n+            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2),\n+                                   vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) {\n+                return true;\n+            }\n+            // If partial groups are allowed, relax the requirement of spending OutputGroups (groups\n+            // of UTXOs sent to the same address, which are obviously controlled by a single wallet)\n+            // in their entirety.\n+            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1, true /* include_partial_groups */),\n+                                   vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) {\n+                return true;\n+            }\n+            // Try with unlimited ancestors/descendants. The transaction will still need to meet\n+            // mempool ancestor/descendant policy to be accepted to mempool and broadcasted, but\n+            // OutputGroups use heuristics that may overestimate ancestor/descendant counts.\n+            if (!fRejectLongChains && SelectCoinsMinConf(value_to_select,\n+                                      CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max(), std::numeric_limits<uint64_t>::max(), true /* include_partial_groups */),\n+                                      vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) {\n+                return true;\n+            }\n+        }\n+        // Coin Selection failed.\n+        return false;\n+    }();\n+\n+    // SelectCoinsMinConf clears setCoinsRet, so add the preset inputs from coin_control to the coinset\n     util::insert(setCoinsRet, setPresetCoins);\n \n     // add preset inputs to the total value selected"
      },
      {
        "sha": "03adca7a896bd62c9273602ce5e3d783fcc4e937",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 64,
        "deletions": 18,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -368,7 +368,7 @@ class CWalletTx\n \n     CTransactionRef tx;\n \n-    /* New transactions start as UNCONFIRMED. At BlockConnected,\n+    /** New transactions start as UNCONFIRMED. At BlockConnected,\n      * they will transition to CONFIRMED. In case of reorg, at BlockDisconnected,\n      * they roll back to UNCONFIRMED. If we detect a conflicting transaction at\n      * block connection, we update conflicted tx and its dependencies as CONFLICTED.\n@@ -383,7 +383,7 @@ class CWalletTx\n         ABANDONED\n     };\n \n-    /* Confirmation includes tx status and a triplet of {block height/block hash/tx index in block}\n+    /** Confirmation includes tx status and a triplet of {block height/block hash/tx index in block}\n      * at which tx has been confirmed. All three are set to 0 if tx is unconfirmed or abandoned.\n      * Meaning of these fields changes with CONFLICTED state where they instead point to block hash\n      * and block height of the deepest conflicting tx.\n@@ -481,7 +481,7 @@ class CWalletTx\n     CAmount GetImmatureWatchOnlyCredit(const bool fUseCache = true) const;\n     CAmount GetChange() const;\n \n-    // Get the marginal bytes if spending the specified output from this transaction\n+    /** Get the marginal bytes if spending the specified output from this transaction */\n     int GetSpendSize(unsigned int out, bool use_max_sig = false) const\n     {\n         return CalculateMaximumSignedInputSize(tx->vout[out], pwallet, use_max_sig);\n@@ -495,15 +495,15 @@ class CWalletTx\n         return (GetDebit(filter) > 0);\n     }\n \n-    // True if only scriptSigs are different\n+    /** True if only scriptSigs are different */\n     bool IsEquivalentTo(const CWalletTx& tx) const;\n \n     bool InMempool() const;\n     bool IsTrusted() const;\n \n     int64_t GetTxTime() const;\n \n-    // Pass this transaction to node for mempool insertion and relay to peers if flag set to true\n+    /** Pass this transaction to node for mempool insertion and relay to peers if flag set to true */\n     bool SubmitMemoryPoolAndRelay(std::string& err_string, bool relay);\n \n     // TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n@@ -564,7 +564,15 @@ class COutput\n {\n public:\n     const CWalletTx *tx;\n+\n+    /** Index in tx->vout. */\n     int i;\n+\n+    /**\n+     * Depth in block chain.\n+     * If > 0: the tx is on chain and has this many confirmations.\n+     * If = 0: the tx is waiting confirmation.\n+     * If < 0: a conflicting tx is on chain and has this many confirmations. */\n     int nDepth;\n \n     /** Pre-computed estimated size of this output as a fully-signed input in a transaction. Can be -1 if it could not be calculated */\n@@ -604,17 +612,30 @@ class COutput\n     }\n };\n \n+/** Parameters for one iteration of Coin Selection. */\n struct CoinSelectionParams\n {\n+    /** Toggles use of Branch and Bound instead of Knapsack solver. */\n     bool use_bnb = true;\n+    /** Size of a change output in bytes, determined by the output type. */\n     size_t change_output_size = 0;\n+    /** Size of the input to spend a change output in virtual bytes. */\n     size_t change_spend_size = 0;\n+    /** The targeted feerate of the transaction being built. */\n     CFeeRate m_effective_feerate;\n+    /** The feerate estimate used to estimate an upper bound on what should be sufficient to spend\n+     * the change output sometime in the future. */\n     CFeeRate m_long_term_feerate;\n+    /** If the cost to spend a change output at the discard feerate exceeds its value, drop it to fees. */\n     CFeeRate m_discard_feerate;\n+    /** Size of the transaction before coin selection, consisting of the header and recipient\n+     * output(s), excluding the inputs and change output(s). */\n     size_t tx_noinputs_size = 0;\n-    //! Indicate that we are subtracting the fee from outputs\n+    /** Indicate that we are subtracting the fee from outputs */\n     bool m_subtract_fee_outputs = false;\n+    /** When true, always spend all (up to OUTPUT_GROUP_MAX_ENTRIES) or none of the outputs\n+     * associated with the same address. This helps reduce privacy leaks resulting from address\n+     * reuse. Dust outputs are not eligible to be added to output groups and thus not considered. */\n     bool m_avoid_partial_spends = false;\n \n     CoinSelectionParams(bool use_bnb, size_t change_output_size, size_t change_spend_size, CFeeRate effective_feerate,\n@@ -652,7 +673,10 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     //! the current wallet version: clients below this version are not able to load the wallet\n     int nWalletVersion GUARDED_BY(cs_wallet){FEATURE_BASE};\n \n+    /** The next scheduled rebroadcast of wallet transactions. */\n     int64_t nNextResend = 0;\n+    /** Whether this wallet will submit newly created transactions to the node's mempool and\n+     * prompt rebroadcasts (see ResendWalletTransactions()). */\n     bool fBroadcastTransactions = false;\n     // Local time that the tip block was received. Used to schedule wallet rebroadcasts.\n     std::atomic<int64_t> m_best_block_time {0};\n@@ -682,10 +706,10 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      */\n     bool AddToWalletIfInvolvingMe(const CTransactionRef& tx, CWalletTx::Confirmation confirm, bool fUpdate) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n-    /* Mark a transaction (and its in-wallet descendants) as conflicting with a particular block. */\n+    /** Mark a transaction (and its in-wallet descendants) as conflicting with a particular block. */\n     void MarkConflicted(const uint256& hashBlock, int conflicting_height, const uint256& hashTx);\n \n-    /* Mark a transaction's inputs dirty, thus forcing the outputs to be recomputed */\n+    /** Mark a transaction's inputs dirty, thus forcing the outputs to be recomputed */\n     void MarkInputsDirty(const CTransactionRef& tx) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     void SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator>) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n@@ -694,6 +718,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      * Should be called with non-zero block_hash and posInBlock if this is for a transaction that is included in a block. */\n     void SyncTransaction(const CTransactionRef& tx, CWalletTx::Confirmation confirm, bool update_tx = true) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n+    /** WalletFlags set on this wallet. */\n     std::atomic<uint64_t> m_wallet_flags{0};\n \n     bool SetAddressBookWithDB(WalletBatch& batch, const CTxDestination& address, const std::string& strName, const std::string& strPurpose);\n@@ -722,7 +747,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      */\n     uint256 m_last_block_processed GUARDED_BY(cs_wallet);\n \n-    /* Height of last block processed is used by wallet to know depth of transactions\n+    /** Height of last block processed is used by wallet to know depth of transactions\n      * without relying on Chain interface beyond asynchronous updates. For safety, we\n      * initialize it to -1. Height is a pointer on node's tip and doesn't imply\n      * that the wallet has scanned sequentially all blocks up to this one.\n@@ -739,7 +764,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     bool CreateTransactionInternal(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, const CCoinControl& coin_control, FeeCalculation& fee_calc_out, bool sign);\n \n public:\n-    /*\n+    /**\n      * Main wallet lock.\n      * This lock protects all the fields added by CWallet.\n      */\n@@ -753,8 +778,11 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n \n     /**\n      * Select a set of coins such that nValueRet >= nTargetValue and at least\n-     * all coins from coinControl are selected; Never select unconfirmed coins\n-     * if they are not ours\n+     * all coins from coin_control are selected; never select unconfirmed coins if they are not ours\n+     * param@[out]  setCoinsRet         Populated with inputs including pre-selected inputs from\n+     *                                  coin_control and Coin Selection if successful.\n+     * param@[out]  nValueRet           Total value of selected coins including pre-selected ones\n+     *                                  from coin_control and Coin Selection if successful.\n      */\n     bool SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet,\n                     const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params, bool& bnb_used) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n@@ -788,6 +816,8 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     /** Interface to assert chain access */\n     bool HaveChain() const { return m_chain ? true : false; }\n \n+    /** Map from txid to CWalletTx for all transactions this wallet is\n+     * interested in, including received and sent transactions. */\n     std::map<uint256, CWalletTx> mapWallet GUARDED_BY(cs_wallet);\n \n     typedef std::multimap<int64_t, CWalletTx*> TxItems;\n@@ -799,6 +829,10 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     std::map<CTxDestination, CAddressBookData> m_address_book GUARDED_BY(cs_wallet);\n     const CAddressBookData* FindAddressBookEntry(const CTxDestination&, bool allow_change = false) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n+    /** Set of Coins owned by this wallet that we won't try to spend from. A\n+     * Coin may be locked if it has already been used to fund a transaction\n+     * that hasn't confirmed yet. We wouldn't consider the Coin spent already,\n+     * but also shouldn't try to use it again. */\n     std::set<COutPoint> setLockedCoins GUARDED_BY(cs_wallet);\n \n     /** Registered interfaces::Chain::Notifications handler. */\n@@ -833,6 +867,11 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      * small change; This method is stochastic for some inputs and upon\n      * completion the coin set and corresponding actual target value is\n      * assembled\n+     * param@[in]   coins           Set of UTXOs to consider. These will be categorized into\n+     *                              OutputGroups and filtered using eligibility_filter before\n+     *                              selecting coins.\n+     * param@[out]  setCoinsRet     Populated with the coins selected if successful.\n+     * param@[out]  nValueRet       Used to return the total value of selected coins.\n      */\n     bool SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> coins,\n         std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const;\n@@ -956,9 +995,9 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      * calling CreateTransaction();\n      */\n     bool FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, CCoinControl);\n-    // Fetch the inputs and sign with SIGHASH_ALL.\n+    /** Fetch the inputs and sign with SIGHASH_ALL. */\n     bool SignTransaction(CMutableTransaction& tx) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    // Sign the tx given the input coins and sighash.\n+    /** Sign the tx given the input coins and sighash. */\n     bool SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, std::string>& input_errors) const;\n     SigningResult SignMessage(const std::string& message, const PKHash& pkhash, std::string& str_sig) const;\n \n@@ -1015,6 +1054,8 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n \n     CFeeRate m_pay_tx_fee{DEFAULT_PAY_TX_FEE};\n     unsigned int m_confirm_target{DEFAULT_TX_CONFIRM_TARGET};\n+    /** Allow Coin Selection to pick unconfirmed UTXOs that were sent from our own wallet if it\n+     * cannot fund the transaction otherwise. */\n     bool m_spend_zero_conf_change{DEFAULT_SPEND_ZEROCONF_CHANGE};\n     bool m_signal_rbf{DEFAULT_WALLET_RBF};\n     bool m_allow_fallback_fee{true}; //!< will be false if -fallbackfee=0\n@@ -1025,7 +1066,12 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      * Override with -fallbackfee\n      */\n     CFeeRate m_fallback_fee{DEFAULT_FALLBACK_FEE};\n+\n+     /** If the cost to spend a change output at this feerate is greater than the value of the\n+      * output itself, just drop it to fees. */\n     CFeeRate m_discard_rate{DEFAULT_DISCARD_FEE};\n+\n+    /** The maximum fee amount we're willing to pay to prioritize partial spend avoidance. */\n     CAmount m_max_aps_fee{DEFAULT_MAX_AVOIDPARTIALSPEND_FEE}; //!< note: this is absolute fee, not fee rate\n     OutputType m_default_address_type{DEFAULT_ADDRESS_TYPE};\n     /**\n@@ -1333,10 +1379,10 @@ class WalletRescanReserver\n     }\n };\n \n-// Calculate the size of the transaction assuming all signatures are max size\n-// Use DummySignatureCreator, which inserts 71 byte signatures everywhere.\n-// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n-// be IsAllFromMe).\n+/** Calculate the size of the transaction assuming all signatures are max size\n+* Use DummySignatureCreator, which inserts 71 byte signatures everywhere.\n+* NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+* be IsAllFromMe). */\n std::pair<int64_t, int64_t> CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, bool use_max_sig = false) EXCLUSIVE_LOCKS_REQUIRED(wallet->cs_wallet);\n std::pair<int64_t, int64_t> CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, const std::vector<CTxOut>& txouts, bool use_max_sig = false);\n "
      },
      {
        "sha": "bada791fba8feb7c1ffc0b4763b400c6a0ce3171",
        "filename": "test/functional/feature_blockfilterindex_prune.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/feature_blockfilterindex_prune.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/feature_blockfilterindex_prune.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_blockfilterindex_prune.py?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -33,7 +33,7 @@ def run_test(self):\n \n         self.log.info(\"prune some blocks\")\n         pruneheight = self.nodes[0].pruneblockchain(400)\n-        assert_equal(pruneheight, 250)\n+        assert_equal(pruneheight, 248)\n \n         self.log.info(\"check if we can access the tips blockfilter when we have pruned some blocks\")\n         assert_greater_than(len(self.nodes[0].getblockfilter(self.nodes[0].getbestblockhash())['filter']), 0)"
      },
      {
        "sha": "f2130fb588b3f0b462affc020ea9aae0d6031f8a",
        "filename": "test/functional/feature_cltv.py",
        "status": "modified",
        "additions": 111,
        "deletions": 61,
        "changes": 172,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/feature_cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/feature_cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_cltv.py?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -8,10 +8,24 @@\n 1351.\n \"\"\"\n \n-from test_framework.blocktools import create_coinbase, create_block, create_transaction\n-from test_framework.messages import CTransaction, msg_block, ToHex\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+    create_transaction,\n+)\n+from test_framework.messages import (\n+    CTransaction,\n+    ToHex,\n+    msg_block,\n+)\n from test_framework.p2p import P2PInterface\n-from test_framework.script import CScript, OP_1NEGATE, OP_CHECKLOCKTIMEVERIFY, OP_DROP, CScriptNum\n+from test_framework.script import (\n+    CScript,\n+    CScriptNum,\n+    OP_1NEGATE,\n+    OP_CHECKLOCKTIMEVERIFY,\n+    OP_DROP,\n+)\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n@@ -23,32 +37,54 @@\n CLTV_HEIGHT = 1351\n \n \n-def cltv_invalidate(tx):\n-    '''Modify the signature in vin 0 of the tx to fail CLTV\n+# Helper function to modify a transaction by\n+# 1) prepending a given script to the scriptSig of vin 0 and\n+# 2) (optionally) modify the nSequence of vin 0 and the tx's nLockTime\n+def cltv_modify_tx(node, tx, prepend_scriptsig, nsequence=None, nlocktime=None):\n+    if nsequence is not None:\n+        tx.vin[0].nSequence = nsequence\n+        tx.nLockTime = nlocktime\n+\n+        # Need to re-sign, since nSequence and nLockTime changed\n+        signed_result = node.signrawtransactionwithwallet(ToHex(tx))\n+        new_tx = CTransaction()\n+        new_tx.deserialize(BytesIO(hex_str_to_bytes(signed_result['hex'])))\n+    else:\n+        new_tx = tx\n+\n+    new_tx.vin[0].scriptSig = CScript(prepend_scriptsig + list(CScript(new_tx.vin[0].scriptSig)))\n+    return new_tx\n+\n \n-    Prepends -1 CLTV DROP in the scriptSig itself.\n+def cltv_invalidate(node, tx, failure_reason):\n+    # Modify the signature in vin 0 and nSequence/nLockTime of the tx to fail CLTV\n+    #\n+    # According to BIP65, OP_CHECKLOCKTIMEVERIFY can fail due the following reasons:\n+    # 1) the stack is empty\n+    # 2) the top item on the stack is less than 0\n+    # 3) the lock-time type (height vs. timestamp) of the top stack item and the\n+    #    nLockTime field are not the same\n+    # 4) the top stack item is greater than the transaction's nLockTime field\n+    # 5) the nSequence field of the txin is 0xffffffff\n+    assert failure_reason in range(5)\n+    scheme = [\n+        # | Script to prepend to scriptSig                  | nSequence  | nLockTime    |\n+        # +-------------------------------------------------+------------+--------------+\n+        [[OP_CHECKLOCKTIMEVERIFY],                            None,       None],\n+        [[OP_1NEGATE, OP_CHECKLOCKTIMEVERIFY, OP_DROP],       None,       None],\n+        [[CScriptNum(1000), OP_CHECKLOCKTIMEVERIFY, OP_DROP], 0,          1296688602],  # timestamp of genesis block\n+        [[CScriptNum(1000), OP_CHECKLOCKTIMEVERIFY, OP_DROP], 0,          500],\n+        [[CScriptNum(500),  OP_CHECKLOCKTIMEVERIFY, OP_DROP], 0xffffffff, 500],\n+    ][failure_reason]\n+\n+    return cltv_modify_tx(node, tx, prepend_scriptsig=scheme[0], nsequence=scheme[1], nlocktime=scheme[2])\n \n-    TODO: test more ways that transactions using CLTV could be invalid (eg\n-    locktime requirements fail, sequence time requirements fail, etc).\n-    '''\n-    tx.vin[0].scriptSig = CScript([OP_1NEGATE, OP_CHECKLOCKTIMEVERIFY, OP_DROP] +\n-                                  list(CScript(tx.vin[0].scriptSig)))\n \n def cltv_validate(node, tx, height):\n-    '''Modify the signature in vin 0 of the tx to pass CLTV\n-    Prepends <height> CLTV DROP in the scriptSig, and sets\n-    the locktime to height'''\n-    tx.vin[0].nSequence = 0\n-    tx.nLockTime = height\n-\n-    # Need to re-sign, since nSequence and nLockTime changed\n-    signed_result = node.signrawtransactionwithwallet(ToHex(tx))\n-    new_tx = CTransaction()\n-    new_tx.deserialize(BytesIO(hex_str_to_bytes(signed_result['hex'])))\n-\n-    new_tx.vin[0].scriptSig = CScript([CScriptNum(height), OP_CHECKLOCKTIMEVERIFY, OP_DROP] +\n-                                  list(CScript(new_tx.vin[0].scriptSig)))\n-    return new_tx\n+    # Modify the signature in vin 0 and nSequence/nLockTime of the tx to pass CLTV\n+    scheme = [[CScriptNum(height), OP_CHECKLOCKTIMEVERIFY, OP_DROP], 0, height]\n+\n+    return cltv_modify_tx(node, tx, prepend_scriptsig=scheme[0], nsequence=scheme[1], nlocktime=scheme[2])\n \n \n class BIP65Test(BitcoinTestFramework):\n@@ -66,8 +102,7 @@ def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n     def test_cltv_info(self, *, is_active):\n-        assert_equal(self.nodes[0].getblockchaininfo()['softforks']['bip65'],\n-            {\n+        assert_equal(self.nodes[0].getblockchaininfo()['softforks']['bip65'], {\n                 \"active\": is_active,\n                 \"height\": CLTV_HEIGHT,\n                 \"type\": \"buried\",\n@@ -83,18 +118,22 @@ def run_test(self):\n         self.coinbase_txids = [self.nodes[0].getblock(b)['tx'][0] for b in self.nodes[0].generate(CLTV_HEIGHT - 2)]\n         self.nodeaddress = self.nodes[0].getnewaddress()\n \n-        self.log.info(\"Test that an invalid-according-to-CLTV transaction can still appear in a block\")\n+        self.log.info(\"Test that invalid-according-to-CLTV transactions can still appear in a block\")\n \n-        spendtx = create_transaction(self.nodes[0], self.coinbase_txids[0],\n-                self.nodeaddress, amount=1.0)\n-        cltv_invalidate(spendtx)\n-        spendtx.rehash()\n+        # create one invalid tx per CLTV failure reason (5 in total) and collect them\n+        invalid_ctlv_txs = []\n+        for i in range(5):\n+            spendtx = create_transaction(self.nodes[0], self.coinbase_txids[i],\n+                                         self.nodeaddress, amount=1.0)\n+            spendtx = cltv_invalidate(self.nodes[0], spendtx, i)\n+            spendtx.rehash()\n+            invalid_ctlv_txs.append(spendtx)\n \n         tip = self.nodes[0].getbestblockhash()\n         block_time = self.nodes[0].getblockheader(tip)['mediantime'] + 1\n         block = create_block(int(tip, 16), create_coinbase(CLTV_HEIGHT - 1), block_time)\n         block.nVersion = 3\n-        block.vtx.append(spendtx)\n+        block.vtx.extend(invalid_ctlv_txs)\n         block.hashMerkleRoot = block.calc_merkle_root()\n         block.solve()\n \n@@ -115,35 +154,46 @@ def run_test(self):\n             assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n             peer.sync_with_ping()\n \n-        self.log.info(\"Test that invalid-according-to-cltv transactions cannot appear in a block\")\n+        self.log.info(\"Test that invalid-according-to-CLTV transactions cannot appear in a block\")\n         block.nVersion = 4\n-\n-        spendtx = create_transaction(self.nodes[0], self.coinbase_txids[1],\n-                self.nodeaddress, amount=1.0)\n-        cltv_invalidate(spendtx)\n-        spendtx.rehash()\n-\n-        # First we show that this tx is valid except for CLTV by getting it\n-        # rejected from the mempool for exactly that reason.\n-        assert_equal(\n-            [{\n-                'txid': spendtx.hash,\n-                'wtxid': spendtx.getwtxid(),\n-                'allowed': False,\n-                'reject-reason': 'non-mandatory-script-verify-flag (Negative locktime)',\n-            }],\n-            self.nodes[0].testmempoolaccept(rawtxs=[spendtx.serialize().hex()], maxfeerate=0),\n-        )\n-\n-        # Now we verify that a block with this transaction is also invalid.\n-        block.vtx.append(spendtx)\n-        block.hashMerkleRoot = block.calc_merkle_root()\n-        block.solve()\n-\n-        with self.nodes[0].assert_debug_log(expected_msgs=['CheckInputScripts on {} failed with non-mandatory-script-verify-flag (Negative locktime)'.format(block.vtx[-1].hash)]):\n-            peer.send_and_ping(msg_block(block))\n-            assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n-            peer.sync_with_ping()\n+        block.vtx.append(CTransaction()) # dummy tx after coinbase that will be replaced later\n+\n+        # create and test one invalid tx per CLTV failure reason (5 in total)\n+        for i in range(5):\n+            spendtx = create_transaction(self.nodes[0], self.coinbase_txids[10+i],\n+                                         self.nodeaddress, amount=1.0)\n+            spendtx = cltv_invalidate(self.nodes[0], spendtx, i)\n+            spendtx.rehash()\n+\n+            expected_cltv_reject_reason = [\n+                \"non-mandatory-script-verify-flag (Operation not valid with the current stack size)\",\n+                \"non-mandatory-script-verify-flag (Negative locktime)\",\n+                \"non-mandatory-script-verify-flag (Locktime requirement not satisfied)\",\n+                \"non-mandatory-script-verify-flag (Locktime requirement not satisfied)\",\n+                \"non-mandatory-script-verify-flag (Locktime requirement not satisfied)\",\n+            ][i]\n+            # First we show that this tx is valid except for CLTV by getting it\n+            # rejected from the mempool for exactly that reason.\n+            assert_equal(\n+                [{\n+                    'txid': spendtx.hash,\n+                    'wtxid': spendtx.getwtxid(),\n+                    'allowed': False,\n+                    'reject-reason': expected_cltv_reject_reason,\n+                }],\n+                self.nodes[0].testmempoolaccept(rawtxs=[spendtx.serialize().hex()], maxfeerate=0),\n+            )\n+\n+            # Now we verify that a block with this transaction is also invalid.\n+            block.vtx[1] = spendtx\n+            block.hashMerkleRoot = block.calc_merkle_root()\n+            block.solve()\n+\n+            with self.nodes[0].assert_debug_log(expected_msgs=['CheckInputScripts on {} failed with {}'.format(\n+                                                block.vtx[-1].hash, expected_cltv_reject_reason)]):\n+                peer.send_and_ping(msg_block(block))\n+                assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n+                peer.sync_with_ping()\n \n         self.log.info(\"Test that a version 4 block with a valid-according-to-CLTV transaction is accepted\")\n         spendtx = cltv_validate(self.nodes[0], spendtx, CLTV_HEIGHT - 1)"
      },
      {
        "sha": "6fc8773ee3c9fca2e565af76a0a0b52906d09bf6",
        "filename": "test/functional/feature_notifications.py",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/feature_notifications.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/feature_notifications.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_notifications.py?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -166,6 +166,8 @@ def expect_wallet_notify(self, tx_details):\n         # Should now verify contents of each file\n         for tx_id, blockheight, blockhash in tx_details:\n             fname = os.path.join(self.walletnotify_dir, notify_outputname(self.wallet, tx_id))\n+            # Wait for the cached writes to hit storage\n+            self.wait_until(lambda: os.path.getsize(fname) > 0, timeout=10)\n             with open(fname, 'rt', encoding='utf-8') as f:\n                 text = f.read()\n                 # Universal newline ensures '\\n' on 'nt'"
      },
      {
        "sha": "b900aa0b9c14eafd507ae468690c51227d16c132",
        "filename": "test/functional/mempool_spend_coinbase.py",
        "status": "modified",
        "additions": 18,
        "deletions": 17,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/mempool_spend_coinbase.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/mempool_spend_coinbase.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_spend_coinbase.py?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -20,40 +20,41 @@\n class MempoolSpendCoinbaseTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n-        self.setup_clean_chain = True\n \n     def run_test(self):\n         wallet = MiniWallet(self.nodes[0])\n \n-        wallet.generate(200)\n-        chain_height = self.nodes[0].getblockcount()\n-        assert_equal(chain_height, 200)\n+        # Invalidate two blocks, so that miniwallet has access to a coin that will mature in the next block\n+        chain_height = 198\n+        self.nodes[0].invalidateblock(self.nodes[0].getblockhash(chain_height + 1))\n+        assert_equal(chain_height, self.nodes[0].getblockcount())\n \n         # Coinbase at height chain_height-100+1 ok in mempool, should\n         # get mined. Coinbase at height chain_height-100+2 is\n         # too immature to spend.\n-        b = [self.nodes[0].getblockhash(n) for n in range(101, 103)]\n-        coinbase_txids = [self.nodes[0].getblock(h)['tx'][0] for h in b]\n-        utxo_101 = wallet.get_utxo(txid=coinbase_txids[0])\n-        utxo_102 = wallet.get_utxo(txid=coinbase_txids[1])\n+        wallet.scan_blocks(start=chain_height - 100 + 1, num=1)\n+        utxo_mature = wallet.get_utxo()\n+        wallet.scan_blocks(start=chain_height - 100 + 2, num=1)\n+        utxo_immature = wallet.get_utxo()\n \n-        spend_101_id = wallet.send_self_transfer(from_node=self.nodes[0], utxo_to_spend=utxo_101)[\"txid\"]\n+        spend_mature_id = wallet.send_self_transfer(from_node=self.nodes[0], utxo_to_spend=utxo_mature)[\"txid\"]\n \n-        # coinbase at height 102 should be too immature to spend\n+        # other coinbase should be too immature to spend\n+        immature_tx = wallet.create_self_transfer(from_node=self.nodes[0], utxo_to_spend=utxo_immature, mempool_valid=False)\n         assert_raises_rpc_error(-26,\n                                 \"bad-txns-premature-spend-of-coinbase\",\n-                                lambda: wallet.send_self_transfer(from_node=self.nodes[0], utxo_to_spend=utxo_102))\n+                                lambda: self.nodes[0].sendrawtransaction(immature_tx['hex']))\n \n-        # mempool should have just spend_101:\n-        assert_equal(self.nodes[0].getrawmempool(), [spend_101_id])\n+        # mempool should have just the mature one\n+        assert_equal(self.nodes[0].getrawmempool(), [spend_mature_id])\n \n-        # mine a block, spend_101 should get confirmed\n+        # mine a block, mature one should get confirmed\n         self.nodes[0].generate(1)\n         assert_equal(set(self.nodes[0].getrawmempool()), set())\n \n-        # ... and now height 102 can be spent:\n-        spend_102_id = wallet.send_self_transfer(from_node=self.nodes[0], utxo_to_spend=utxo_102)[\"txid\"]\n-        assert_equal(self.nodes[0].getrawmempool(), [spend_102_id])\n+        # ... and now previously immature can be spent:\n+        spend_new_id = self.nodes[0].sendrawtransaction(immature_tx['hex'])\n+        assert_equal(self.nodes[0].getrawmempool(), [spend_new_id])\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "87297989baf7588fbeda1ed9e7d5f7cb9f2c2234",
        "filename": "test/functional/p2p_addr_relay.py",
        "status": "modified",
        "additions": 148,
        "deletions": 22,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/p2p_addr_relay.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/p2p_addr_relay.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_addr_relay.py?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -11,6 +11,7 @@\n     NODE_NETWORK,\n     NODE_WITNESS,\n     msg_addr,\n+    msg_getaddr\n )\n from test_framework.p2p import P2PInterface\n from test_framework.test_framework import BitcoinTestFramework\n@@ -19,18 +20,6 @@\n )\n import time\n \n-# Keep this with length <= 10. Addresses from larger messages are not relayed.\n-ADDRS = []\n-num_ipv4_addrs = 10\n-\n-for i in range(num_ipv4_addrs):\n-    addr = CAddress()\n-    addr.time = int(time.time()) + i\n-    addr.nServices = NODE_NETWORK | NODE_WITNESS\n-    addr.ip = \"123.123.123.{}\".format(i % 256)\n-    addr.port = 8333 + i\n-    ADDRS.append(addr)\n-\n \n class AddrReceiver(P2PInterface):\n     num_ipv4_received = 0\n@@ -44,36 +33,87 @@ def on_addr(self, message):\n             self.num_ipv4_received += 1\n \n \n+class GetAddrStore(P2PInterface):\n+    getaddr_received = False\n+    num_ipv4_received = 0\n+\n+    def on_getaddr(self, message):\n+        self.getaddr_received = True\n+\n+    def on_addr(self, message):\n+        for addr in message.addrs:\n+            self.num_ipv4_received += 1\n+\n+    def addr_received(self):\n+        return self.num_ipv4_received != 0\n+\n+\n class AddrTest(BitcoinTestFramework):\n+    counter = 0\n+    mocktime = int(time.time())\n+\n     def set_test_params(self):\n         self.num_nodes = 1\n \n     def run_test(self):\n-        self.log.info('Create connection that sends addr messages')\n-        addr_source = self.nodes[0].add_p2p_connection(P2PInterface())\n+        self.oversized_addr_test()\n+        self.relay_tests()\n+        self.getaddr_tests()\n+        self.blocksonly_mode_tests()\n+\n+    def setup_addr_msg(self, num):\n+        addrs = []\n+        for i in range(num):\n+            addr = CAddress()\n+            addr.time = self.mocktime + i\n+            addr.nServices = NODE_NETWORK | NODE_WITNESS\n+            addr.ip = f\"123.123.123.{self.counter % 256}\"\n+            addr.port = 8333 + i\n+            addrs.append(addr)\n+            self.counter += 1\n+\n         msg = msg_addr()\n+        msg.addrs = addrs\n+        return msg\n+\n+    def send_addr_msg(self, source, msg, receivers):\n+        source.send_and_ping(msg)\n+        # pop m_next_addr_send timer\n+        self.mocktime += 5 * 60\n+        self.nodes[0].setmocktime(self.mocktime)\n+        for peer in receivers:\n+            peer.sync_send_with_ping()\n \n-        self.log.info('Send too-large addr message')\n-        msg.addrs = ADDRS * 101  # more than 1000 addresses in one message\n+    def oversized_addr_test(self):\n+        self.log.info('Send an addr message that is too large')\n+        addr_source = self.nodes[0].add_p2p_connection(P2PInterface())\n+\n+        msg = self.setup_addr_msg(1010)\n         with self.nodes[0].assert_debug_log(['addr message size = 1010']):\n             addr_source.send_and_ping(msg)\n \n+        self.nodes[0].disconnect_p2ps()\n+\n+    def relay_tests(self):\n+        self.log.info('Test address relay')\n         self.log.info('Check that addr message content is relayed and added to addrman')\n+        addr_source = self.nodes[0].add_p2p_connection(P2PInterface())\n         num_receivers = 7\n         receivers = []\n         for _ in range(num_receivers):\n             receivers.append(self.nodes[0].add_p2p_connection(AddrReceiver()))\n-        msg.addrs = ADDRS\n+\n+        # Keep this with length <= 10. Addresses from larger messages are not\n+        # relayed.\n+        num_ipv4_addrs = 10\n+        msg = self.setup_addr_msg(num_ipv4_addrs)\n         with self.nodes[0].assert_debug_log(\n             [\n                 'Added {} addresses from 127.0.0.1: 0 tried'.format(num_ipv4_addrs),\n-                'received: addr (301 bytes) peer=0',\n+                'received: addr (301 bytes) peer=1',\n             ]\n         ):\n-            addr_source.send_and_ping(msg)\n-            self.nodes[0].setmocktime(int(time.time()) + 30 * 60)\n-            for receiver in receivers:\n-                receiver.sync_with_ping()\n+            self.send_addr_msg(addr_source, msg, receivers)\n \n         total_ipv4_received = sum(r.num_ipv4_received for r in receivers)\n \n@@ -82,6 +122,92 @@ def run_test(self):\n         ipv4_branching_factor = 2\n         assert_equal(total_ipv4_received, num_ipv4_addrs * ipv4_branching_factor)\n \n+        self.nodes[0].disconnect_p2ps()\n+\n+        self.log.info('Check relay of addresses received from outbound peers')\n+        inbound_peer = self.nodes[0].add_p2p_connection(AddrReceiver())\n+        full_outbound_peer = self.nodes[0].add_outbound_p2p_connection(GetAddrStore(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        msg = self.setup_addr_msg(2)\n+        self.send_addr_msg(full_outbound_peer, msg, [inbound_peer])\n+        self.log.info('Check that the first addr message received from an outbound peer is not relayed')\n+        # Currently, there is a flag that prevents the first addr message received\n+        # from a new outbound peer to be relayed to others. Originally meant to prevent\n+        # large GETADDR responses from being relayed, it now typically affects the self-announcement\n+        # of the outbound peer which is often sent before the GETADDR response.\n+        assert_equal(inbound_peer.num_ipv4_received, 0)\n+\n+        self.log.info('Check that subsequent addr messages sent from an outbound peer are relayed')\n+        msg2 = self.setup_addr_msg(2)\n+        self.send_addr_msg(full_outbound_peer, msg2, [inbound_peer])\n+        assert_equal(inbound_peer.num_ipv4_received, 2)\n+\n+        self.log.info('Check address relay to outbound peers')\n+        block_relay_peer = self.nodes[0].add_outbound_p2p_connection(GetAddrStore(), p2p_idx=1, connection_type=\"block-relay-only\")\n+        msg3 = self.setup_addr_msg(2)\n+        self.send_addr_msg(inbound_peer, msg3, [full_outbound_peer, block_relay_peer])\n+\n+        self.log.info('Check that addresses are relayed to full outbound peers')\n+        assert_equal(full_outbound_peer.num_ipv4_received, 2)\n+        self.log.info('Check that addresses are not relayed to block-relay-only outbound peers')\n+        assert_equal(block_relay_peer.num_ipv4_received, 0)\n+\n+        self.nodes[0].disconnect_p2ps()\n+\n+    def getaddr_tests(self):\n+        self.log.info('Test getaddr behavior')\n+        self.log.info('Check that we send a getaddr message upon connecting to an outbound-full-relay peer')\n+        full_outbound_peer = self.nodes[0].add_outbound_p2p_connection(GetAddrStore(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        full_outbound_peer.sync_with_ping()\n+        assert full_outbound_peer.getaddr_received\n+\n+        self.log.info('Check that we do not send a getaddr message upon connecting to a block-relay-only peer')\n+        block_relay_peer = self.nodes[0].add_outbound_p2p_connection(GetAddrStore(), p2p_idx=1, connection_type=\"block-relay-only\")\n+        block_relay_peer.sync_with_ping()\n+        assert_equal(block_relay_peer.getaddr_received, False)\n+\n+        self.log.info('Check that we answer getaddr messages only from inbound peers')\n+        inbound_peer = self.nodes[0].add_p2p_connection(GetAddrStore())\n+        inbound_peer.sync_with_ping()\n+\n+        # Add some addresses to addrman\n+        for i in range(1000):\n+            first_octet = i >> 8\n+            second_octet = i % 256\n+            a = f\"{first_octet}.{second_octet}.1.1\"\n+            self.nodes[0].addpeeraddress(a, 8333)\n+\n+        full_outbound_peer.send_and_ping(msg_getaddr())\n+        block_relay_peer.send_and_ping(msg_getaddr())\n+        inbound_peer.send_and_ping(msg_getaddr())\n+\n+        self.mocktime += 5 * 60\n+        self.nodes[0].setmocktime(self.mocktime)\n+        inbound_peer.wait_until(inbound_peer.addr_received)\n+\n+        assert_equal(full_outbound_peer.num_ipv4_received, 0)\n+        assert_equal(block_relay_peer.num_ipv4_received, 0)\n+        assert inbound_peer.num_ipv4_received > 100\n+\n+        self.nodes[0].disconnect_p2ps()\n+\n+    def blocksonly_mode_tests(self):\n+        self.log.info('Test addr relay in -blocksonly mode')\n+        self.restart_node(0, [\"-blocksonly\"])\n+        self.mocktime = int(time.time())\n+\n+        self.log.info('Check that we send getaddr messages')\n+        full_outbound_peer = self.nodes[0].add_outbound_p2p_connection(GetAddrStore(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        full_outbound_peer.sync_with_ping()\n+        assert full_outbound_peer.getaddr_received\n+\n+        self.log.info('Check that we relay address messages')\n+        addr_source = self.nodes[0].add_p2p_connection(P2PInterface())\n+        msg = self.setup_addr_msg(2)\n+        self.send_addr_msg(addr_source, msg, [full_outbound_peer])\n+        assert_equal(full_outbound_peer.num_ipv4_received, 2)\n+\n+        self.nodes[0].disconnect_p2ps()\n+\n \n if __name__ == '__main__':\n     AddrTest().main()"
      },
      {
        "sha": "445cea6186db72466a56d0f0031d133be6e97595",
        "filename": "test/functional/p2p_blocksonly.py",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/p2p_blocksonly.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/p2p_blocksonly.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_blocksonly.py?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -89,11 +89,7 @@ def blocks_relay_conn_tests(self):\n         # Bump time forward to ensure nNextInvSend timer pops\n         self.nodes[0].setmocktime(int(time.time()) + 60)\n \n-        # Calling sync_with_ping twice requires that the node calls\n-        # `ProcessMessage` twice, and thus ensures `SendMessages` must have\n-        # been called at least once\n-        conn.sync_with_ping()\n-        conn.sync_with_ping()\n+        conn.sync_send_with_ping()\n         assert(int(txid, 16) not in conn.get_invs())\n \n     def check_p2p_tx_violation(self, index=1):"
      },
      {
        "sha": "359cfb9c346ef0d66c6920fba06ee0383dfda176",
        "filename": "test/functional/p2p_filter.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/p2p_filter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/p2p_filter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_filter.py?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -174,8 +174,7 @@ def test_filter(self, filter_peer):\n         filter_peer.merkleblock_received = False\n         filter_peer.tx_received = False\n         self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 90)\n-        filter_peer.sync_with_ping()\n-        filter_peer.sync_with_ping()\n+        filter_peer.sync_send_with_ping()\n         assert not filter_peer.merkleblock_received\n         assert not filter_peer.tx_received\n "
      },
      {
        "sha": "1b6e122ee4686f8b79f4dfc386b9b013ec68195a",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 28,
        "deletions": 17,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -164,7 +164,7 @@ def on_getdata(self, message):\n     def on_wtxidrelay(self, message):\n         self.last_wtxidrelay.append(message)\n \n-    def announce_tx_and_wait_for_getdata(self, tx, timeout=60, success=True, use_wtxid=False):\n+    def announce_tx_and_wait_for_getdata(self, tx, success=True, use_wtxid=False):\n         if success:\n             # sanity check\n             assert (self.wtxidrelay and use_wtxid) or (not self.wtxidrelay and not use_wtxid)\n@@ -178,11 +178,11 @@ def announce_tx_and_wait_for_getdata(self, tx, timeout=60, success=True, use_wtx\n \n         if success:\n             if use_wtxid:\n-                self.wait_for_getdata([wtxid], timeout)\n+                self.wait_for_getdata([wtxid])\n             else:\n-                self.wait_for_getdata([tx.sha256], timeout)\n+                self.wait_for_getdata([tx.sha256])\n         else:\n-            time.sleep(timeout)\n+            time.sleep(5)\n             assert not self.last_message.get(\"getdata\")\n \n     def announce_block_and_wait_for_getdata(self, block, use_header, timeout=60):\n@@ -604,7 +604,7 @@ def test_witness_tx_relay_before_segwit_activation(self):\n \n         # Since we haven't delivered the tx yet, inv'ing the same tx from\n         # a witness transaction ought not result in a getdata.\n-        self.test_node.announce_tx_and_wait_for_getdata(tx, timeout=2, success=False)\n+        self.test_node.announce_tx_and_wait_for_getdata(tx, success=False)\n \n         # Delivering this transaction with witness should fail (no matter who\n         # its from)\n@@ -1461,7 +1461,7 @@ def test_segwit_versions(self):\n         self.std_node.announce_tx_and_wait_for_getdata(tx3)\n         test_transaction_acceptance(self.nodes[1], self.std_node, tx3, with_witness=True, accepted=False, reason=\"bad-txns-nonstandard-inputs\")\n         # Now the node will no longer ask for getdata of this transaction when advertised by same txid\n-        self.std_node.announce_tx_and_wait_for_getdata(tx3, timeout=5, success=False)\n+        self.std_node.announce_tx_and_wait_for_getdata(tx3, success=False)\n \n         # Spending a higher version witness output is not allowed by policy,\n         # even with fRequireStandard=false.\n@@ -1956,22 +1956,33 @@ def test_non_standard_witness(self):\n     def test_upgrade_after_activation(self):\n         \"\"\"Test the behavior of starting up a segwit-aware node after the softfork has activated.\"\"\"\n \n-        self.restart_node(2, extra_args=[\"-segwitheight={}\".format(SEGWIT_HEIGHT)])\n+        # All nodes are caught up and node 2 is a pre-segwit node that will soon upgrade.\n+        for n in range(2):\n+            assert_equal(self.nodes[n].getblockcount(), self.nodes[2].getblockcount())\n+            assert softfork_active(self.nodes[n], \"segwit\")\n+        assert SEGWIT_HEIGHT < self.nodes[2].getblockcount()\n+        assert 'segwit' not in self.nodes[2].getblockchaininfo()['softforks']\n+\n+        # Restarting node 2 should result in a shutdown because the blockchain consists of\n+        # insufficiently validated blocks per segwit consensus rules.\n+        self.stop_node(2)\n+        with self.nodes[2].assert_debug_log(expected_msgs=[\n+                f\"Witness data for blocks after height {SEGWIT_HEIGHT} requires validation. Please restart with -reindex.\"], timeout=10):\n+            self.nodes[2].start([f\"-segwitheight={SEGWIT_HEIGHT}\"])\n+\n+        # As directed, the user restarts the node with -reindex\n+        self.start_node(2, extra_args=[\"-reindex\", f\"-segwitheight={SEGWIT_HEIGHT}\"])\n+\n+        # With the segwit consensus rules, the node is able to validate only up to SEGWIT_HEIGHT - 1\n+        assert_equal(self.nodes[2].getblockcount(), SEGWIT_HEIGHT - 1)\n         self.connect_nodes(0, 2)\n \n         # We reconnect more than 100 blocks, give it plenty of time\n+        # sync_blocks() also verifies the best block hash is the same for all nodes\n         self.sync_blocks(timeout=240)\n \n-        # Make sure that this peer thinks segwit has activated.\n-        assert softfork_active(self.nodes[2], 'segwit')\n-\n-        # Make sure this peer's blocks match those of node0.\n-        height = self.nodes[2].getblockcount()\n-        while height >= 0:\n-            block_hash = self.nodes[2].getblockhash(height)\n-            assert_equal(block_hash, self.nodes[0].getblockhash(height))\n-            assert_equal(self.nodes[0].getblock(block_hash), self.nodes[2].getblock(block_hash))\n-            height -= 1\n+        # The upgraded node should now have segwit activated\n+        assert softfork_active(self.nodes[2], \"segwit\")\n \n     @subtest  # type: ignore\n     def test_witness_sigops(self):"
      },
      {
        "sha": "a80fa596cd9eead0a2b7297895953502ea8e00a5",
        "filename": "test/functional/rpc_misc.py",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/rpc_misc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/rpc_misc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_misc.py?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -61,6 +61,9 @@ def run_test(self):\n         node.logging(include=['qt'])\n         assert_equal(node.logging()['qt'], True)\n \n+        self.log.info(\"test echoipc (testing spawned process in multiprocess build)\")\n+        assert_equal(node.echoipc(\"hello\"), \"hello\")\n+\n         self.log.info(\"test getindexinfo\")\n         # Without any indices running the RPC returns an empty object\n         assert_equal(node.getindexinfo(), {})"
      },
      {
        "sha": "cc80b543cd74909187d108d6682722b3c06f59f7",
        "filename": "test/functional/test_framework/p2p.py",
        "status": "modified",
        "additions": 9,
        "deletions": 1,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/test_framework/p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/test_framework/p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/p2p.py?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -539,8 +539,16 @@ def send_and_ping(self, message, timeout=60):\n         self.send_message(message)\n         self.sync_with_ping(timeout=timeout)\n \n-    # Sync up with the node\n+    def sync_send_with_ping(self, timeout=60):\n+        \"\"\"Ensure SendMessages is called on this connection\"\"\"\n+        # Calling sync_with_ping twice requires that the node calls\n+        # `ProcessMessage` twice, and thus ensures `SendMessages` must have\n+        # been called at least once\n+        self.sync_with_ping()\n+        self.sync_with_ping()\n+\n     def sync_with_ping(self, timeout=60):\n+        \"\"\"Ensure ProcessMessages is called on this connection\"\"\"\n         self.send_message(msg_ping(nonce=self.ping_counter))\n \n         def test_function():"
      },
      {
        "sha": "0ff4ee0a6230bad80f1f4d684705fd928b557e42",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -739,11 +739,12 @@ def _initialize_chain(self):\n             # block in the cache does not age too much (have an old tip age).\n             # This is needed so that we are out of IBD when the test starts,\n             # see the tip age check in IsInitialBlockDownload().\n-            gen_addresses = [k.address for k in TestNode.PRIV_KEYS] + [ADDRESS_BCRT1_P2WSH_OP_TRUE]\n+            gen_addresses = [k.address for k in TestNode.PRIV_KEYS][:3] + [ADDRESS_BCRT1_P2WSH_OP_TRUE]\n+            assert_equal(len(gen_addresses), 4)\n             for i in range(8):\n                 cache_node.generatetoaddress(\n                     nblocks=25 if i != 7 else 24,\n-                    address=gen_addresses[i % 4],\n+                    address=gen_addresses[i % len(gen_addresses)],\n                 )\n \n             assert_equal(cache_node.getblockchaininfo()[\"blocks\"], 199)"
      },
      {
        "sha": "59ef18635b4a2a2120db572fbccf32c736467e4d",
        "filename": "test/functional/test_framework/wallet.py",
        "status": "modified",
        "additions": 21,
        "deletions": 7,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/test_framework/wallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/functional/test_framework/wallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/wallet.py?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -37,9 +37,13 @@ def scan_blocks(self, *, start=1, num):\n         for i in range(start, start + num):\n             block = self._test_node.getblock(blockhash=self._test_node.getblockhash(i), verbosity=2)\n             for tx in block['tx']:\n-                for out in tx['vout']:\n-                    if out['scriptPubKey']['hex'] == self._scriptPubKey.hex():\n-                        self._utxos.append({'txid': tx['txid'], 'vout': out['n'], 'value': out['value']})\n+                self.scan_tx(tx)\n+\n+    def scan_tx(self, tx):\n+        \"\"\"Scan the tx for self._scriptPubKey outputs and add them to self._utxos\"\"\"\n+        for out in tx['vout']:\n+            if out['scriptPubKey']['hex'] == self._scriptPubKey.hex():\n+                self._utxos.append({'txid': tx['txid'], 'vout': out['n'], 'value': out['value']})\n \n     def generate(self, num_blocks):\n         \"\"\"Generate blocks with coinbase outputs to the internal address, and append the outputs to the internal list\"\"\"\n@@ -69,6 +73,12 @@ def get_utxo(self, *, txid=''):\n \n     def send_self_transfer(self, *, fee_rate=Decimal(\"0.003\"), from_node, utxo_to_spend=None):\n         \"\"\"Create and send a tx with the specified fee_rate. Fee may be exact or at most one satoshi higher than needed.\"\"\"\n+        tx = self.create_self_transfer(fee_rate=fee_rate, from_node=from_node, utxo_to_spend=utxo_to_spend)\n+        self.sendrawtransaction(from_node=from_node, tx_hex=tx['hex'])\n+        return tx\n+\n+    def create_self_transfer(self, *, fee_rate=Decimal(\"0.003\"), from_node, utxo_to_spend=None, mempool_valid=True):\n+        \"\"\"Create and return a tx with the specified fee_rate. Fee may be exact or at most one satoshi higher than needed.\"\"\"\n         self._utxos = sorted(self._utxos, key=lambda k: k['value'])\n         utxo_to_spend = utxo_to_spend or self._utxos.pop()  # Pick the largest utxo (if none provided) and hope it covers the fee\n         vsize = Decimal(96)\n@@ -84,8 +94,12 @@ def send_self_transfer(self, *, fee_rate=Decimal(\"0.003\"), from_node, utxo_to_sp\n         tx_hex = tx.serialize().hex()\n \n         tx_info = from_node.testmempoolaccept([tx_hex])[0]\n-        self._utxos.append({'txid': tx_info['txid'], 'vout': 0, 'value': send_value})\n-        from_node.sendrawtransaction(tx_hex)\n-        assert_equal(tx_info['vsize'], vsize)\n-        assert_equal(tx_info['fees']['base'], fee)\n+        assert_equal(mempool_valid, tx_info['allowed'])\n+        if mempool_valid:\n+            assert_equal(tx_info['vsize'], vsize)\n+            assert_equal(tx_info['fees']['base'], fee)\n         return {'txid': tx_info['txid'], 'wtxid': tx_info['wtxid'], 'hex': tx_hex}\n+\n+    def sendrawtransaction(self, *, from_node, tx_hex):\n+        from_node.sendrawtransaction(tx_hex)\n+        self.scan_tx(from_node.decoderawtransaction(tx_hex))"
      },
      {
        "sha": "c23b903bce1ded63ba82d0a8e6f673bd7aad4647",
        "filename": "test/lint/lint-include-guards.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/lint/lint-include-guards.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/lint/lint-include-guards.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-include-guards.sh?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -15,7 +15,7 @@ REGEXP_EXCLUDE_FILES_WITH_PREFIX=\"src/(crypto/ctaes/|leveldb/|crc32c/|secp256k1/\n EXIT_CODE=0\n for HEADER_FILE in $(git ls-files -- \"*.h\" | grep -vE \"^${REGEXP_EXCLUDE_FILES_WITH_PREFIX}\")\n do\n-    HEADER_ID_BASE=$(cut -f2- -d/ <<< \"${HEADER_FILE}\" | sed \"s/\\.h$//g\" | tr / _ | tr \"[:lower:]\" \"[:upper:]\")\n+    HEADER_ID_BASE=$(cut -f2- -d/ <<< \"${HEADER_FILE}\" | sed \"s/\\.h$//g\" | tr / _ | tr - _ | tr \"[:lower:]\" \"[:upper:]\")\n     HEADER_ID=\"${HEADER_ID_PREFIX}${HEADER_ID_BASE}${HEADER_ID_SUFFIX}\"\n     if [[ $(grep -cE \"^#(ifndef|define) ${HEADER_ID}\" \"${HEADER_FILE}\") != 2 ]]; then\n         echo \"${HEADER_FILE} seems to be missing the expected include guard:\""
      },
      {
        "sha": "3bcc554acb24b91c9e0f840a905a11f8b1d70a43",
        "filename": "test/sanitizer_suppressions/ubsan",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/sanitizer_suppressions/ubsan",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7959c56d9efde643ff7f119c828833c0b6e2e67f/test/sanitizer_suppressions/ubsan",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/sanitizer_suppressions/ubsan?ref=7959c56d9efde643ff7f119c828833c0b6e2e67f",
        "patch": "@@ -96,6 +96,7 @@ implicit-unsigned-integer-truncation:crypto/\n implicit-unsigned-integer-truncation:leveldb/\n # std::variant warning fixed in https://github.com/gcc-mirror/gcc/commit/074436cf8cdd2a9ce75cadd36deb8301f00e55b9\n implicit-unsigned-integer-truncation:std::__detail::__variant::_Variant_storage\n+shift-base:nanobench.h\n shift-base:*/include/c++/\n shift-base:arith_uint256.cpp\n shift-base:crypto/"
      }
    ]
  }
]