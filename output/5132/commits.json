[
  {
    "sha": "dcb98466b4f8193fc28656d17b2317f21665fa3a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkY2I5ODQ2NmI0ZjgxOTNmYzI4NjU2ZDE3YjIzMTdmMjE2NjVmYTNh",
    "commit": {
      "author": {
        "name": "Daniel Kraft",
        "email": "d@domob.eu",
        "date": "2014-10-20T12:14:04Z"
      },
      "committer": {
        "name": "Daniel Kraft",
        "email": "d@domob.eu",
        "date": "2014-10-24T06:53:04Z"
      },
      "message": "Extend getchaintips RPC test.\n\nAdd the capability to simulate network splits to the RPC test framework\nand use it to do more extensive testing of 'getchaintips'.",
      "tree": {
        "sha": "af414ee4e69a16a680ec364ab51c2ac5b7f549c0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/af414ee4e69a16a680ec364ab51c2ac5b7f549c0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dcb98466b4f8193fc28656d17b2317f21665fa3a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dcb98466b4f8193fc28656d17b2317f21665fa3a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dcb98466b4f8193fc28656d17b2317f21665fa3a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dcb98466b4f8193fc28656d17b2317f21665fa3a/comments",
    "author": {
      "login": "domob1812",
      "id": 4943644,
      "node_id": "MDQ6VXNlcjQ5NDM2NDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/domob1812",
      "html_url": "https://github.com/domob1812",
      "followers_url": "https://api.github.com/users/domob1812/followers",
      "following_url": "https://api.github.com/users/domob1812/following{/other_user}",
      "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions",
      "organizations_url": "https://api.github.com/users/domob1812/orgs",
      "repos_url": "https://api.github.com/users/domob1812/repos",
      "events_url": "https://api.github.com/users/domob1812/events{/privacy}",
      "received_events_url": "https://api.github.com/users/domob1812/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "domob1812",
      "id": 4943644,
      "node_id": "MDQ6VXNlcjQ5NDM2NDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/domob1812",
      "html_url": "https://github.com/domob1812",
      "followers_url": "https://api.github.com/users/domob1812/followers",
      "following_url": "https://api.github.com/users/domob1812/following{/other_user}",
      "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions",
      "organizations_url": "https://api.github.com/users/domob1812/orgs",
      "repos_url": "https://api.github.com/users/domob1812/repos",
      "events_url": "https://api.github.com/users/domob1812/events{/privacy}",
      "received_events_url": "https://api.github.com/users/domob1812/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3552d4b859d56726cd25baa6f1e5988050bdad33",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3552d4b859d56726cd25baa6f1e5988050bdad33",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3552d4b859d56726cd25baa6f1e5988050bdad33"
      }
    ],
    "stats": {
      "total": 342,
      "additions": 207,
      "deletions": 135
    },
    "files": [
      {
        "sha": "23bfb74175e03a51f0d3304af4a827ae80b4f99f",
        "filename": "qa/rpc-tests/forknotify.py",
        "status": "modified",
        "additions": 17,
        "deletions": 18,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dcb98466b4f8193fc28656d17b2317f21665fa3a/qa/rpc-tests/forknotify.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dcb98466b4f8193fc28656d17b2317f21665fa3a/qa/rpc-tests/forknotify.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/forknotify.py?ref=dcb98466b4f8193fc28656d17b2317f21665fa3a",
        "patch": "@@ -17,31 +17,30 @@ class ForkNotifyTest(BitcoinTestFramework):\n \n     alert_filename = None  # Set by setup_network\n \n-    def setup_network(self, test_dir):\n-        nodes = []\n-        self.alert_filename = os.path.join(test_dir, \"alert.txt\")\n+    def setup_network(self):\n+        self.nodes = []\n+        self.alert_filename = os.path.join(self.options.tmpdir, \"alert.txt\")\n         with open(self.alert_filename, 'w') as f:\n             pass  # Just open then close to create zero-length file\n-        nodes.append(start_node(0, test_dir,\n+        self.nodes.append(start_node(0, self.options.tmpdir,\n                             [\"-blockversion=2\", \"-alertnotify=echo %s >> '\" + self.alert_filename + \"'\"]))\n         # Node1 mines block.version=211 blocks\n-        nodes.append(start_node(1, test_dir,\n+        self.nodes.append(start_node(1, self.options.tmpdir,\n                                 [\"-blockversion=211\"]))\n-        connect_nodes(nodes[1], 0)\n+        connect_nodes(self.nodes[1], 0)\n \n-        sync_blocks(nodes)\n-        return nodes\n-        \n+        self.is_network_split = False\n+        self.sync_all()\n \n-    def run_test(self, nodes):\n+    def run_test(self):\n         # Mine 51 up-version blocks\n-        nodes[1].setgenerate(True, 51)\n-        sync_blocks(nodes)\n+        self.nodes[1].setgenerate(True, 51)\n+        self.sync_all()\n         # -alertnotify should trigger on the 51'st,\n         # but mine and sync another to give\n         # -alertnotify time to write\n-        nodes[1].setgenerate(True, 1)\n-        sync_blocks(nodes)\n+        self.nodes[1].setgenerate(True, 1)\n+        self.sync_all()\n \n         with open(self.alert_filename, 'r') as f:\n             alert_text = f.read()\n@@ -50,10 +49,10 @@ def run_test(self, nodes):\n             raise AssertionError(\"-alertnotify did not warn of up-version blocks\")\n \n         # Mine more up-version blocks, should not get more alerts:\n-        nodes[1].setgenerate(True, 1)\n-        sync_blocks(nodes)\n-        nodes[1].setgenerate(True, 1)\n-        sync_blocks(nodes)\n+        self.nodes[1].setgenerate(True, 1)\n+        self.sync_all()\n+        self.nodes[1].setgenerate(True, 1)\n+        self.sync_all()\n \n         with open(self.alert_filename, 'r') as f:\n             alert_text2 = f.read()"
      },
      {
        "sha": "5ae5d096013d5d85bdfb60f2705448fb6f17c57c",
        "filename": "qa/rpc-tests/getblocktemplate.py",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dcb98466b4f8193fc28656d17b2317f21665fa3a/qa/rpc-tests/getblocktemplate.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dcb98466b4f8193fc28656d17b2317f21665fa3a/qa/rpc-tests/getblocktemplate.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/getblocktemplate.py?ref=dcb98466b4f8193fc28656d17b2317f21665fa3a",
        "patch": "@@ -51,40 +51,40 @@ class GetBlockTemplateTest(BitcoinTestFramework):\n     Test longpolling with getblocktemplate.\n     '''\n \n-    def run_test(self, nodes):\n+    def run_test(self):\n         print \"Warning: this test will take about 70 seconds in the best case. Be patient.\"\n-        nodes[0].setgenerate(True, 10)\n-        templat = nodes[0].getblocktemplate()\n+        self.nodes[0].setgenerate(True, 10)\n+        templat = self.nodes[0].getblocktemplate()\n         longpollid = templat['longpollid']\n         # longpollid should not change between successive invocations if nothing else happens\n-        templat2 = nodes[0].getblocktemplate()\n+        templat2 = self.nodes[0].getblocktemplate()\n         assert(templat2['longpollid'] == longpollid)\n \n         # Test 1: test that the longpolling wait if we do nothing\n-        thr = LongpollThread(nodes[0])\n+        thr = LongpollThread(self.nodes[0])\n         thr.start()\n         # check that thread still lives\n         thr.join(5)  # wait 5 seconds or until thread exits\n         assert(thr.is_alive())\n \n         # Test 2: test that longpoll will terminate if another node generates a block\n-        nodes[1].setgenerate(True, 1)  # generate a block on another node\n+        self.nodes[1].setgenerate(True, 1)  # generate a block on another node\n         # check that thread will exit now that new transaction entered mempool\n         thr.join(5)  # wait 5 seconds or until thread exits\n         assert(not thr.is_alive())\n \n         # Test 3: test that longpoll will terminate if we generate a block ourselves\n-        thr = LongpollThread(nodes[0])\n+        thr = LongpollThread(self.nodes[0])\n         thr.start()\n-        nodes[0].setgenerate(True, 1)  # generate a block on another node\n+        self.nodes[0].setgenerate(True, 1)  # generate a block on another node\n         thr.join(5)  # wait 5 seconds or until thread exits\n         assert(not thr.is_alive())\n \n         # Test 4: test that introducing a new transaction into the mempool will terminate the longpoll\n-        thr = LongpollThread(nodes[0])\n+        thr = LongpollThread(self.nodes[0])\n         thr.start()\n         # generate a random transaction and submit it\n-        (txid, txhex, fee) = random_transaction(nodes, Decimal(\"1.1\"), Decimal(\"0.0\"), Decimal(\"0.001\"), 20)\n+        (txid, txhex, fee) = random_transaction(self.nodes, Decimal(\"1.1\"), Decimal(\"0.0\"), Decimal(\"0.001\"), 20)\n         # after one minute, every 10 seconds the mempool is probed, so in 80 seconds it should have returned\n         thr.join(60 + 20)\n         assert(not thr.is_alive())"
      },
      {
        "sha": "842fcad2b2821a067f3425f851468f440c9ef35b",
        "filename": "qa/rpc-tests/getchaintips.py",
        "status": "modified",
        "additions": 40,
        "deletions": 10,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dcb98466b4f8193fc28656d17b2317f21665fa3a/qa/rpc-tests/getchaintips.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dcb98466b4f8193fc28656d17b2317f21665fa3a/qa/rpc-tests/getchaintips.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/getchaintips.py?ref=dcb98466b4f8193fc28656d17b2317f21665fa3a",
        "patch": "@@ -3,22 +3,52 @@\n # Distributed under the MIT/X11 software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-# Exercise the getchaintips API.\n-\n-# Since the test framework does not generate orphan blocks, we can\n-# unfortunately not check for them!\n+# Exercise the getchaintips API.  We introduce a network split, work\n+# on chains of different lengths, and join the network together again.\n+# This gives us two tips, verify that it works.\n \n from test_framework import BitcoinTestFramework\n from util import assert_equal\n \n class GetChainTipsTest (BitcoinTestFramework):\n \n-    def run_test (self, nodes):\n-        res = nodes[0].getchaintips ()\n-        assert_equal (len (res), 1)\n-        res = res[0]\n-        assert_equal (res['branchlen'], 0)\n-        assert_equal (res['height'], 200)\n+    def run_test (self):\n+        BitcoinTestFramework.run_test (self)\n+\n+        tips = self.nodes[0].getchaintips ()\n+        assert_equal (len (tips), 1)\n+        assert_equal (tips[0]['branchlen'], 0)\n+        assert_equal (tips[0]['height'], 200)\n+\n+        # Split the network and build two chains of different lengths.\n+        self.split_network ()\n+        self.nodes[0].setgenerate (True, 10);\n+        self.nodes[2].setgenerate (True, 20);\n+        self.sync_all ()\n+\n+        tips = self.nodes[1].getchaintips ()\n+        assert_equal (len (tips), 1)\n+        shortTip = tips[0]\n+        assert_equal (shortTip['branchlen'], 0)\n+        assert_equal (shortTip['height'], 210)\n+\n+        tips = self.nodes[3].getchaintips ()\n+        assert_equal (len (tips), 1)\n+        longTip = tips[0]\n+        assert_equal (longTip['branchlen'], 0)\n+        assert_equal (longTip['height'], 220)\n+\n+        # Join the network halves and check that we now have two tips\n+        # (at least at the nodes that previously had the short chain).\n+        self.join_network ()\n+\n+        tips = self.nodes[0].getchaintips ()\n+        assert_equal (len (tips), 2)\n+        assert_equal (tips[0], longTip)\n+\n+        assert_equal (tips[1]['branchlen'], 10)\n+        tips[1]['branchlen'] = 0;\n+        assert_equal (tips[1], shortTip)\n \n if __name__ == '__main__':\n     GetChainTipsTest ().main ()"
      },
      {
        "sha": "6102052a6f97715091c598a3f68926ab82e9951b",
        "filename": "qa/rpc-tests/listtransactions.py",
        "status": "modified",
        "additions": 26,
        "deletions": 24,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dcb98466b4f8193fc28656d17b2317f21665fa3a/qa/rpc-tests/listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dcb98466b4f8193fc28656d17b2317f21665fa3a/qa/rpc-tests/listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/listtransactions.py?ref=dcb98466b4f8193fc28656d17b2317f21665fa3a",
        "patch": "@@ -33,62 +33,64 @@ def check_array_result(object_array, to_match, expected):\n \n class ListTransactionsTest(BitcoinTestFramework):\n \n-    def run_test(self, nodes):\n+    def run_test(self):\n         # Simple send, 0 to 1:\n-        txid = nodes[0].sendtoaddress(nodes[1].getnewaddress(), 0.1)\n-        sync_mempools(nodes)\n-        check_array_result(nodes[0].listtransactions(),\n+        txid = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.1)\n+        self.sync_all()\n+        check_array_result(self.nodes[0].listtransactions(),\n                            {\"txid\":txid},\n                            {\"category\":\"send\",\"account\":\"\",\"amount\":Decimal(\"-0.1\"),\"confirmations\":0})\n-        check_array_result(nodes[1].listtransactions(),\n+        check_array_result(self.nodes[1].listtransactions(),\n                            {\"txid\":txid},\n                            {\"category\":\"receive\",\"account\":\"\",\"amount\":Decimal(\"0.1\"),\"confirmations\":0})\n         # mine a block, confirmations should change:\n-        nodes[0].setgenerate(True, 1)\n-        sync_blocks(nodes)\n-        check_array_result(nodes[0].listtransactions(),\n+        self.nodes[0].setgenerate(True, 1)\n+        self.sync_all()\n+        check_array_result(self.nodes[0].listtransactions(),\n                            {\"txid\":txid},\n                            {\"category\":\"send\",\"account\":\"\",\"amount\":Decimal(\"-0.1\"),\"confirmations\":1})\n-        check_array_result(nodes[1].listtransactions(),\n+        check_array_result(self.nodes[1].listtransactions(),\n                            {\"txid\":txid},\n                            {\"category\":\"receive\",\"account\":\"\",\"amount\":Decimal(\"0.1\"),\"confirmations\":1})\n \n         # send-to-self:\n-        txid = nodes[0].sendtoaddress(nodes[0].getnewaddress(), 0.2)\n-        check_array_result(nodes[0].listtransactions(),\n+        txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.2)\n+        check_array_result(self.nodes[0].listtransactions(),\n                            {\"txid\":txid, \"category\":\"send\"},\n                            {\"amount\":Decimal(\"-0.2\")})\n-        check_array_result(nodes[0].listtransactions(),\n+        check_array_result(self.nodes[0].listtransactions(),\n                            {\"txid\":txid, \"category\":\"receive\"},\n                            {\"amount\":Decimal(\"0.2\")})\n \n         # sendmany from node1: twice to self, twice to node2:\n-        send_to = { nodes[0].getnewaddress() : 0.11, nodes[1].getnewaddress() : 0.22,\n-                    nodes[0].getaccountaddress(\"from1\") : 0.33, nodes[1].getaccountaddress(\"toself\") : 0.44 }\n-        txid = nodes[1].sendmany(\"\", send_to)\n-        sync_mempools(nodes)\n-        check_array_result(nodes[1].listtransactions(),\n+        send_to = { self.nodes[0].getnewaddress() : 0.11,\n+                    self.nodes[1].getnewaddress() : 0.22,\n+                    self.nodes[0].getaccountaddress(\"from1\") : 0.33,\n+                    self.nodes[1].getaccountaddress(\"toself\") : 0.44 }\n+        txid = self.nodes[1].sendmany(\"\", send_to)\n+        self.sync_all()\n+        check_array_result(self.nodes[1].listtransactions(),\n                            {\"category\":\"send\",\"amount\":Decimal(\"-0.11\")},\n                            {\"txid\":txid} )\n-        check_array_result(nodes[0].listtransactions(),\n+        check_array_result(self.nodes[0].listtransactions(),\n                            {\"category\":\"receive\",\"amount\":Decimal(\"0.11\")},\n                            {\"txid\":txid} )\n-        check_array_result(nodes[1].listtransactions(),\n+        check_array_result(self.nodes[1].listtransactions(),\n                            {\"category\":\"send\",\"amount\":Decimal(\"-0.22\")},\n                            {\"txid\":txid} )\n-        check_array_result(nodes[1].listtransactions(),\n+        check_array_result(self.nodes[1].listtransactions(),\n                            {\"category\":\"receive\",\"amount\":Decimal(\"0.22\")},\n                            {\"txid\":txid} )\n-        check_array_result(nodes[1].listtransactions(),\n+        check_array_result(self.nodes[1].listtransactions(),\n                            {\"category\":\"send\",\"amount\":Decimal(\"-0.33\")},\n                            {\"txid\":txid} )\n-        check_array_result(nodes[0].listtransactions(),\n+        check_array_result(self.nodes[0].listtransactions(),\n                            {\"category\":\"receive\",\"amount\":Decimal(\"0.33\")},\n                            {\"txid\":txid, \"account\" : \"from1\"} )\n-        check_array_result(nodes[1].listtransactions(),\n+        check_array_result(self.nodes[1].listtransactions(),\n                            {\"category\":\"send\",\"amount\":Decimal(\"-0.44\")},\n                            {\"txid\":txid, \"account\" : \"\"} )\n-        check_array_result(nodes[1].listtransactions(),\n+        check_array_result(self.nodes[1].listtransactions(),\n                            {\"category\":\"receive\",\"amount\":Decimal(\"0.44\")},\n                            {\"txid\":txid, \"account\" : \"toself\"} )\n "
      },
      {
        "sha": "717025524211f3ed2e398e3b102628e34f603784",
        "filename": "qa/rpc-tests/receivedby.py",
        "status": "modified",
        "additions": 34,
        "deletions": 34,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dcb98466b4f8193fc28656d17b2317f21665fa3a/qa/rpc-tests/receivedby.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dcb98466b4f8193fc28656d17b2317f21665fa3a/qa/rpc-tests/receivedby.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/receivedby.py?ref=dcb98466b4f8193fc28656d17b2317f21665fa3a",
        "patch": "@@ -54,102 +54,102 @@ def check_array_result(object_array, to_match, expected, should_not_find = False\n \n class ReceivedByTest(BitcoinTestFramework):\n \n-    def run_test(self, nodes):\n+    def run_test(self):\n         '''\n         listreceivedbyaddress Test\n         '''\n         # Send from node 0 to 1\n-        addr = nodes[1].getnewaddress()\n-        txid = nodes[0].sendtoaddress(addr, 0.1)\n-        sync_mempools(nodes)\n+        addr = self.nodes[1].getnewaddress()\n+        txid = self.nodes[0].sendtoaddress(addr, 0.1)\n+        self.sync_all()\n \n         #Check not listed in listreceivedbyaddress because has 0 confirmations\n-        check_array_result(nodes[1].listreceivedbyaddress(),\n+        check_array_result(self.nodes[1].listreceivedbyaddress(),\n                            {\"address\":addr},\n                            { },\n                            True)\n         #Bury Tx under 10 block so it will be returned by listreceivedbyaddress\n-        nodes[1].setgenerate(True, 10)\n-        sync_blocks(nodes)\n-        check_array_result(nodes[1].listreceivedbyaddress(),\n+        self.nodes[1].setgenerate(True, 10)\n+        self.sync_all()\n+        check_array_result(self.nodes[1].listreceivedbyaddress(),\n                            {\"address\":addr},\n                            {\"address\":addr, \"account\":\"\", \"amount\":Decimal(\"0.1\"), \"confirmations\":10, \"txids\":[txid,]})\n         #With min confidence < 10\n-        check_array_result(nodes[1].listreceivedbyaddress(5),\n+        check_array_result(self.nodes[1].listreceivedbyaddress(5),\n                            {\"address\":addr},\n                            {\"address\":addr, \"account\":\"\", \"amount\":Decimal(\"0.1\"), \"confirmations\":10, \"txids\":[txid,]})\n         #With min confidence > 10, should not find Tx\n-        check_array_result(nodes[1].listreceivedbyaddress(11),{\"address\":addr},{ },True)\n+        check_array_result(self.nodes[1].listreceivedbyaddress(11),{\"address\":addr},{ },True)\n \n         #Empty Tx\n-        addr = nodes[1].getnewaddress()\n-        check_array_result(nodes[1].listreceivedbyaddress(0,True),\n+        addr = self.nodes[1].getnewaddress()\n+        check_array_result(self.nodes[1].listreceivedbyaddress(0,True),\n                            {\"address\":addr},\n                            {\"address\":addr, \"account\":\"\", \"amount\":0, \"confirmations\":0, \"txids\":[]})\n \n         '''\n             getreceivedbyaddress Test\n         '''\n         # Send from node 0 to 1\n-        addr = nodes[1].getnewaddress()\n-        txid = nodes[0].sendtoaddress(addr, 0.1)\n-        sync_mempools(nodes)\n+        addr = self.nodes[1].getnewaddress()\n+        txid = self.nodes[0].sendtoaddress(addr, 0.1)\n+        self.sync_all()\n \n         #Check balance is 0 because of 0 confirmations\n-        balance = nodes[1].getreceivedbyaddress(addr)\n+        balance = self.nodes[1].getreceivedbyaddress(addr)\n         if balance != Decimal(\"0.0\"):\n             raise AssertionError(\"Wrong balance returned by getreceivedbyaddress, %0.2f\"%(balance))\n \n         #Check balance is 0.1\n-        balance = nodes[1].getreceivedbyaddress(addr,0)\n+        balance = self.nodes[1].getreceivedbyaddress(addr,0)\n         if balance != Decimal(\"0.1\"):\n             raise AssertionError(\"Wrong balance returned by getreceivedbyaddress, %0.2f\"%(balance))\n \n         #Bury Tx under 10 block so it will be returned by the default getreceivedbyaddress\n-        nodes[1].setgenerate(True, 10)\n-        sync_blocks(nodes)\n-        balance = nodes[1].getreceivedbyaddress(addr)\n+        self.nodes[1].setgenerate(True, 10)\n+        self.sync_all()\n+        balance = self.nodes[1].getreceivedbyaddress(addr)\n         if balance != Decimal(\"0.1\"):\n             raise AssertionError(\"Wrong balance returned by getreceivedbyaddress, %0.2f\"%(balance))\n \n         '''\n             listreceivedbyaccount + getreceivedbyaccount Test\n         '''\n         #set pre-state\n-        addrArr = nodes[1].getnewaddress()\n-        account = nodes[1].getaccount(addrArr)\n-        received_by_account_json = get_sub_array_from_array(nodes[1].listreceivedbyaccount(),{\"account\":account})\n+        addrArr = self.nodes[1].getnewaddress()\n+        account = self.nodes[1].getaccount(addrArr)\n+        received_by_account_json = get_sub_array_from_array(self.nodes[1].listreceivedbyaccount(),{\"account\":account})\n         if len(received_by_account_json) == 0:\n             raise AssertionError(\"No accounts found in node\")\n-        balance_by_account = rec_by_accountArr = nodes[1].getreceivedbyaccount(account)\n+        balance_by_account = rec_by_accountArr = self.nodes[1].getreceivedbyaccount(account)\n \n-        txid = nodes[0].sendtoaddress(addr, 0.1)\n+        txid = self.nodes[0].sendtoaddress(addr, 0.1)\n \n         # listreceivedbyaccount should return received_by_account_json because of 0 confirmations\n-        check_array_result(nodes[1].listreceivedbyaccount(),\n+        check_array_result(self.nodes[1].listreceivedbyaccount(),\n                            {\"account\":account},\n                            received_by_account_json)\n \n         # getreceivedbyaddress should return same balance because of 0 confirmations\n-        balance = nodes[1].getreceivedbyaccount(account)\n+        balance = self.nodes[1].getreceivedbyaccount(account)\n         if balance != balance_by_account:\n             raise AssertionError(\"Wrong balance returned by getreceivedbyaccount, %0.2f\"%(balance))\n \n-        nodes[1].setgenerate(True, 10)\n-        sync_blocks(nodes)\n+        self.nodes[1].setgenerate(True, 10)\n+        self.sync_all()\n         # listreceivedbyaccount should return updated account balance\n-        check_array_result(nodes[1].listreceivedbyaccount(),\n+        check_array_result(self.nodes[1].listreceivedbyaccount(),\n                            {\"account\":account},\n                            {\"account\":received_by_account_json[\"account\"], \"amount\":(received_by_account_json[\"amount\"] + Decimal(\"0.1\"))})\n \n         # getreceivedbyaddress should return updates balance\n-        balance = nodes[1].getreceivedbyaccount(account)\n+        balance = self.nodes[1].getreceivedbyaccount(account)\n         if balance != balance_by_account + Decimal(\"0.1\"):\n             raise AssertionError(\"Wrong balance returned by getreceivedbyaccount, %0.2f\"%(balance))\n \n         #Create a new account named \"mynewaccount\" that has a 0 balance\n-        nodes[1].getaccountaddress(\"mynewaccount\")\n-        received_by_account_json = get_sub_array_from_array(nodes[1].listreceivedbyaccount(0,True),{\"account\":\"mynewaccount\"})\n+        self.nodes[1].getaccountaddress(\"mynewaccount\")\n+        received_by_account_json = get_sub_array_from_array(self.nodes[1].listreceivedbyaccount(0,True),{\"account\":\"mynewaccount\"})\n         if len(received_by_account_json) == 0:\n             raise AssertionError(\"No accounts found in node\")\n \n@@ -158,7 +158,7 @@ def run_test(self, nodes):\n             raise AssertionError(\"Wrong balance returned by listreceivedbyaccount, %0.2f\"%(received_by_account_json[\"amount\"]))\n \n         # Test getreceivedbyaccount for 0 amount accounts\n-        balance = nodes[1].getreceivedbyaccount(\"mynewaccount\")\n+        balance = self.nodes[1].getreceivedbyaccount(\"mynewaccount\")\n         if balance != Decimal(\"0.0\"):\n             raise AssertionError(\"Wrong balance returned by getreceivedbyaccount, %0.2f\"%(balance))\n "
      },
      {
        "sha": "065bdb01c3366bcc616fcdac96bc76f1c228ccdc",
        "filename": "qa/rpc-tests/smartfees.py",
        "status": "modified",
        "additions": 24,
        "deletions": 24,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dcb98466b4f8193fc28656d17b2317f21665fa3a/qa/rpc-tests/smartfees.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dcb98466b4f8193fc28656d17b2317f21665fa3a/qa/rpc-tests/smartfees.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/smartfees.py?ref=dcb98466b4f8193fc28656d17b2317f21665fa3a",
        "patch": "@@ -10,48 +10,48 @@\n \n class EstimateFeeTest(BitcoinTestFramework):\n \n-    def setup_network(self, test_dir):\n-        nodes = []\n-        nodes.append(start_node(0, test_dir,\n+    def setup_network(self):\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir,\n                             [\"-debug=mempool\", \"-debug=estimatefee\"]))\n         # Node1 mines small-but-not-tiny blocks, and allows free transactions.\n         # NOTE: the CreateNewBlock code starts counting block size at 1,000 bytes,\n         # so blockmaxsize of 2,000 is really just 1,000 bytes (room enough for\n         # 6 or 7 transactions)\n-        nodes.append(start_node(1, test_dir,\n+        self.nodes.append(start_node(1, self.options.tmpdir,\n                                 [\"-blockprioritysize=1500\", \"-blockmaxsize=2000\",\n                                  \"-debug=mempool\", \"-debug=estimatefee\"]))\n-        connect_nodes(nodes[1], 0)\n+        connect_nodes(self.nodes[1], 0)\n \n         # Node2 is a stingy miner, that\n         # produces very small blocks (room for only 3 or so transactions)\n         node2args = [ \"-blockprioritysize=0\", \"-blockmaxsize=1500\",\n                       \"-debug=mempool\", \"-debug=estimatefee\"]\n-        nodes.append(start_node(2, test_dir, node2args))\n-        connect_nodes(nodes[2], 0)\n+        self.nodes.append(start_node(2, self.options.tmpdir, node2args))\n+        connect_nodes(self.nodes[2], 0)\n \n-        sync_blocks(nodes)\n-        return nodes\n+        self.is_network_split = False\n+        self.sync_all()\n         \n \n-    def run_test(self, nodes):\n+    def run_test(self):\n         # Prime the memory pool with pairs of transactions\n         # (high-priority, random fee and zero-priority, random fee)\n         min_fee = Decimal(\"0.001\")\n         fees_per_kb = [];\n         for i in range(12):\n-            (txid, txhex, fee) = random_zeropri_transaction(nodes, Decimal(\"1.1\"),\n+            (txid, txhex, fee) = random_zeropri_transaction(self.nodes, Decimal(\"1.1\"),\n                                                             min_fee, min_fee, 20)\n             tx_kbytes = (len(txhex)/2)/1000.0\n             fees_per_kb.append(float(fee)/tx_kbytes)\n \n         # Mine blocks with node2 until the memory pool clears:\n-        count_start = nodes[2].getblockcount()\n-        while len(nodes[2].getrawmempool()) > 0:\n-            nodes[2].setgenerate(True, 1)\n-            sync_blocks(nodes)\n+        count_start = self.nodes[2].getblockcount()\n+        while len(self.nodes[2].getrawmempool()) > 0:\n+            self.nodes[2].setgenerate(True, 1)\n+            self.sync_all()\n \n-        all_estimates = [ nodes[0].estimatefee(i) for i in range(1,20) ]\n+        all_estimates = [ self.nodes[0].estimatefee(i) for i in range(1,20) ]\n         print(\"Fee estimates, super-stingy miner: \"+str([str(e) for e in all_estimates]))\n \n         # Estimates should be within the bounds of what transactions fees actually were:\n@@ -63,25 +63,25 @@ def run_test(self, nodes):\n         # Generate transactions while mining 30 more blocks, this time with node1:\n         for i in range(30):\n             for j in range(random.randrange(6-4,6+4)):\n-                (txid, txhex, fee) = random_transaction(nodes, Decimal(\"1.1\"),\n+                (txid, txhex, fee) = random_transaction(self.nodes, Decimal(\"1.1\"),\n                                                         Decimal(\"0.0\"), min_fee, 20)\n                 tx_kbytes = (len(txhex)/2)/1000.0\n                 fees_per_kb.append(float(fee)/tx_kbytes)\n-            nodes[1].setgenerate(True, 1)\n-            sync_blocks(nodes)\n+            self.nodes[1].setgenerate(True, 1)\n+            self.sync_all()\n \n-        all_estimates = [ nodes[0].estimatefee(i) for i in range(1,20) ]\n+        all_estimates = [ self.nodes[0].estimatefee(i) for i in range(1,20) ]\n         print(\"Fee estimates, more generous miner: \"+str([ str(e) for e in all_estimates]))\n         for e in filter(lambda x: x >= 0, all_estimates):\n             if float(e)+delta < min(fees_per_kb) or float(e)-delta > max(fees_per_kb):\n                 raise AssertionError(\"Estimated fee (%f) out of range (%f,%f)\"%(float(e), min_fee_kb, max_fee_kb))\n \n         # Finish by mining a normal-sized block:\n-        while len(nodes[0].getrawmempool()) > 0:\n-            nodes[0].setgenerate(True, 1)\n-            sync_blocks(nodes)\n+        while len(self.nodes[0].getrawmempool()) > 0:\n+            self.nodes[0].setgenerate(True, 1)\n+            self.sync_all()\n \n-        final_estimates = [ nodes[0].estimatefee(i) for i in range(1,20) ]\n+        final_estimates = [ self.nodes[0].estimatefee(i) for i in range(1,20) ]\n         print(\"Final fee estimates: \"+str([ str(e) for e in final_estimates]))\n \n "
      },
      {
        "sha": "f226496d0fc55ba3bfe3c58f2df55d490fafee76",
        "filename": "qa/rpc-tests/test_framework.py",
        "status": "modified",
        "additions": 56,
        "deletions": 15,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dcb98466b4f8193fc28656d17b2317f21665fa3a/qa/rpc-tests/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dcb98466b4f8193fc28656d17b2317f21665fa3a/qa/rpc-tests/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework.py?ref=dcb98466b4f8193fc28656d17b2317f21665fa3a",
        "patch": "@@ -21,22 +21,64 @@\n class BitcoinTestFramework(object):\n \n     # These may be over-ridden by subclasses:\n-    def run_test(self, nodes):\n+    def run_test(self):\n+        for node in self.nodes:\n             assert_equal(node.getblockcount(), 200)\n             assert_equal(node.getbalance(), 25*50)\n \n     def add_options(self, parser):\n         pass\n \n-    def setup_chain(self, tmp_directory):\n-        print(\"Initializing test directory \"+tmp_directory)\n-        initialize_chain(tmp_directory)\n-\n-    def setup_network(self, tmp_directory):\n-        nodes = start_nodes(2, tmp_directory)\n-        connect_nodes(nodes[1], 0)\n-        sync_blocks(nodes)\n-        return nodes\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain(self.options.tmpdir)\n+\n+    def setup_network(self, split = False):\n+        self.nodes = start_nodes(4, self.options.tmpdir)\n+\n+        # Connect the nodes as a \"chain\".  This allows us\n+        # to split the network between nodes 1 and 2 to get\n+        # two halves that can work on competing chains.\n+\n+        # If we joined network halves, connect the nodes from the joint\n+        # on outward.  This ensures that chains are properly reorganised.\n+        if not split:\n+            connect_nodes(self.nodes[2], 1)\n+            sync_blocks(self.nodes[1:2])\n+            sync_mempools(self.nodes[1:2])\n+\n+        connect_nodes(self.nodes[1], 0)\n+        connect_nodes(self.nodes[3], 2)\n+        self.is_network_split = split\n+        self.sync_all()\n+\n+    def split_network(self):\n+        \"\"\"\n+        Split the network of four nodes into nodes 0/1 and 2/3.\n+        \"\"\"\n+        assert not self.is_network_split\n+        stop_nodes(self.nodes)\n+        wait_bitcoinds()\n+        self.setup_network(True)\n+\n+    def sync_all(self):\n+        if self.is_network_split:\n+            sync_blocks(self.nodes[:1])\n+            sync_blocks(self.nodes[2:])\n+            sync_mempools(self.nodes[:1])\n+            sync_mempools(self.nodes[2:])\n+        else:\n+            sync_blocks(self.nodes)\n+            sync_mempools(self.nodes)\n+\n+    def join_network(self):\n+        \"\"\"\n+        Join the (previously split) network halves together.\n+        \"\"\"\n+        assert self.is_network_split\n+        stop_nodes(self.nodes)\n+        wait_bitcoinds()\n+        self.setup_network(False)\n \n     def main(self):\n         import optparse\n@@ -56,15 +98,14 @@ def main(self):\n         check_json_precision()\n \n         success = False\n-        nodes = []\n         try:\n             if not os.path.isdir(self.options.tmpdir):\n                 os.makedirs(self.options.tmpdir)\n-            self.setup_chain(self.options.tmpdir)\n+            self.setup_chain()\n \n-            nodes = self.setup_network(self.options.tmpdir)\n+            self.setup_network()\n \n-            self.run_test(nodes)\n+            self.run_test()\n \n             success = True\n \n@@ -80,7 +121,7 @@ def main(self):\n \n         if not self.options.nocleanup:\n             print(\"Cleaning up\")\n-            stop_nodes(nodes)\n+            stop_nodes(self.nodes)\n             wait_bitcoinds()\n             shutil.rmtree(self.options.tmpdir)\n "
      }
    ]
  },
  {
    "sha": "2290ed01bc1b4176a0c6b976707bf7dd6bc49f43",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMjkwZWQwMWJjMWI0MTc2YTBjNmI5NzY3MDdiZjdkZDZiYzQ5ZjQz",
    "commit": {
      "author": {
        "name": "Daniel Kraft",
        "email": "d@domob.eu",
        "date": "2014-10-24T07:06:37Z"
      },
      "committer": {
        "name": "Daniel Kraft",
        "email": "d@domob.eu",
        "date": "2014-10-24T07:06:37Z"
      },
      "message": "Work around #5113.",
      "tree": {
        "sha": "c42bba84957b04ed1c2b9b83cc723128842a95b7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c42bba84957b04ed1c2b9b83cc723128842a95b7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2290ed01bc1b4176a0c6b976707bf7dd6bc49f43",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2290ed01bc1b4176a0c6b976707bf7dd6bc49f43",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2290ed01bc1b4176a0c6b976707bf7dd6bc49f43",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2290ed01bc1b4176a0c6b976707bf7dd6bc49f43/comments",
    "author": {
      "login": "domob1812",
      "id": 4943644,
      "node_id": "MDQ6VXNlcjQ5NDM2NDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/domob1812",
      "html_url": "https://github.com/domob1812",
      "followers_url": "https://api.github.com/users/domob1812/followers",
      "following_url": "https://api.github.com/users/domob1812/following{/other_user}",
      "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions",
      "organizations_url": "https://api.github.com/users/domob1812/orgs",
      "repos_url": "https://api.github.com/users/domob1812/repos",
      "events_url": "https://api.github.com/users/domob1812/events{/privacy}",
      "received_events_url": "https://api.github.com/users/domob1812/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "domob1812",
      "id": 4943644,
      "node_id": "MDQ6VXNlcjQ5NDM2NDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/domob1812",
      "html_url": "https://github.com/domob1812",
      "followers_url": "https://api.github.com/users/domob1812/followers",
      "following_url": "https://api.github.com/users/domob1812/following{/other_user}",
      "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions",
      "organizations_url": "https://api.github.com/users/domob1812/orgs",
      "repos_url": "https://api.github.com/users/domob1812/repos",
      "events_url": "https://api.github.com/users/domob1812/events{/privacy}",
      "received_events_url": "https://api.github.com/users/domob1812/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dcb98466b4f8193fc28656d17b2317f21665fa3a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dcb98466b4f8193fc28656d17b2317f21665fa3a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dcb98466b4f8193fc28656d17b2317f21665fa3a"
      }
    ],
    "stats": {
      "total": 10,
      "additions": 7,
      "deletions": 3
    },
    "files": [
      {
        "sha": "1746294691ba63df53d5ad9ce42388c1d14513a2",
        "filename": "qa/rpc-tests/test_framework.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2290ed01bc1b4176a0c6b976707bf7dd6bc49f43/qa/rpc-tests/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2290ed01bc1b4176a0c6b976707bf7dd6bc49f43/qa/rpc-tests/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework.py?ref=2290ed01bc1b4176a0c6b976707bf7dd6bc49f43",
        "patch": "@@ -43,12 +43,12 @@ def setup_network(self, split = False):\n         # If we joined network halves, connect the nodes from the joint\n         # on outward.  This ensures that chains are properly reorganised.\n         if not split:\n-            connect_nodes(self.nodes[2], 1)\n+            connect_nodes_bi(self.nodes, 1, 2)\n             sync_blocks(self.nodes[1:2])\n             sync_mempools(self.nodes[1:2])\n \n-        connect_nodes(self.nodes[1], 0)\n-        connect_nodes(self.nodes[3], 2)\n+        connect_nodes_bi(self.nodes, 0, 1)\n+        connect_nodes_bi(self.nodes, 2, 3)\n         self.is_network_split = split\n         self.sync_all()\n "
      },
      {
        "sha": "036ac577e6a20970ffaf9c88066827c6b9ced775",
        "filename": "qa/rpc-tests/util.py",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2290ed01bc1b4176a0c6b976707bf7dd6bc49f43/qa/rpc-tests/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2290ed01bc1b4176a0c6b976707bf7dd6bc49f43/qa/rpc-tests/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/util.py?ref=2290ed01bc1b4176a0c6b976707bf7dd6bc49f43",
        "patch": "@@ -194,6 +194,10 @@ def connect_nodes(from_connection, node_num):\n     while any(peer['version'] == 0 for peer in from_connection.getpeerinfo()):\n         time.sleep(0.1)\n \n+def connect_nodes_bi(nodes, a, b):\n+    connect_nodes(nodes[a], b)\n+    connect_nodes(nodes[b], a)\n+\n def find_output(node, txid, amount):\n     \"\"\"\n     Return index to output of txid with value amount"
      }
    ]
  }
]