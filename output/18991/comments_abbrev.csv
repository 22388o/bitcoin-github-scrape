naumenkogs,2020-05-17 01:24:07,cc @EthanHeilman ,https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-629728699,629728699,
tryphe,2020-05-17 02:24:21,"Concept ACK\n\nSuggestion: Instead of modifying `CConnman` and net.h, add all these changes into `CAddrMan` and add a new function `CAddrMan::GetAddrCache`, so the functionality is local to that class, since there's a lot of similar stuff going on in there.\n\nOther thoughts: I wonder what implications this might have in advertising new peers, i.e. suppose the 24 hour window rolls over right b",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-629732890,629732890,
naumenkogs,2020-05-17 02:44:09,">Suggestion: Instead of modifying CConnman and net.h, add all these changes into CAddrMan and add a new function CAddrMan::GetAddrCache, so the functionality is local to that class, since there's a lot of similar stuff going on in there.\n\nTo me it feels like CConman is the perfect place for this cache. It's really something making sense only in the p2p context. We would never use this cache fo",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-629734215,629734215,
DrahtBot,2020-05-17 03:32:09,"<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #17428 (p2p: Try to preserve outbound block-relay-only connections during restart by hebasto)\n\nIf you consider this pull",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-629737483,629737483,
practicalswift,2020-05-17 05:25:37,Concept ACK: nice simple idea - that's the best kind of idea! :),https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-629745569,629745569,
practicalswift,2020-05-17 05:30:47,"Would it make sense to have one cache per network type so that the answer cannot be used to fingerprint a node across network types?\n\n(I know there are other ways to do such fingerprinting, but no reason to add yet another one :))",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-629745947,629745947,
naumenkogs,2020-05-17 15:09:10,"@practicalswift good observation re: across net fingerprinting!\nTo be clear, my PR as it is now doesn't introduce another fingerprinting, but just makes it a little easier for a spy. Previously they would have to make 100 requests and compare across nodes, now they'd have to make just one.\n\nBut it would be indeed nice to not make it easier, and ideally even mitigate the fingerprinting you me",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-629813210,629813210,
MarcoFalke,2020-05-21 12:14:00,What effect does this have on nodes that explicitly want to fan out onion addresses on the ipv4 net? Do they not exist?,https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-632053037,632053037,
naumenkogs,2020-05-22 06:50:31,">What effect does this have on nodes that explicitly want to fan out onion addresses on the ipv4 net? Do they not exist?\n\nI don't touch that behaviour at all! I introduce two separate caches, but both of them are filled the same way as before. The separation is based on *who requests* (onion or regular), not the type of AddrMan records.\n\nSo, if this relay was possible before, it still is.",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-632522048,632522048,
ariard,2020-05-22 08:25:14,"With regards to fingerprint, I think we have a more signaling _descriptor_, i.e address, and changing this one would force cleaning the cache, thus it doesn't introduce a more severe one ?",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-632567081,632567081,
naumenkogs,2020-05-25 08:41:16,">On network topology, the change I can foresee is a decrease in freshness of received address and therefore for bootstrapping nodes nudge towards connecting to older nodes ?\n\nI talk about this [here](https://github.com/bitcoin/bitcoin/pull/18991#discussion_r429776733).\n\n>With regards to fingerprint, I think we have a more signaling descriptor, i.e address, and changing this one would force",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-633455146,633455146,
naumenkogs,2020-05-30 16:26:56,After the numerous requests I introduced cache per `Network`. I think we should make it more fine-grained when addrv2 proposal goes through.,https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-636353826,636353826,
ariard,2020-06-02 00:26:12,"> Can you elaborate? Not sure I'm following.\n\nI was thinking we should have a clear idea of node descriptors leveraged for fingerprinting, like your announced address, your mempool, your chain tip or cached blocks... Thus when you introduce a new one like your cache, if we have an already more severe one like the address, and updating address would also clear the cache it's okay to introduce i",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-637196285,637196285,
naumenkogs,2020-06-02 04:03:06,">I was thinking we should have a clear idea of node descriptors leveraged for fingerprinting, like your announced address, your mempool, your chain tip or cached blocks... \n\nOh, I see. Well, I would say currently it's the worst: AddrMan is very identifiable and easy to scrape. With caches, it becomes at least very hard to scrape.\nAnything beyond would be interesting as a follow-up research, ",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-637257861,637257861,
luke-jr,2020-06-02 19:34:45,"> To be clear, my PR as it is now doesn't introduce another fingerprinting, but just makes it a little easier for a spy. Previously they would have to make 100 requests and compare across nodes, now they'd have to make just one.\n\nFor the record, I think you're wrong: it did introduce a new fingerprinting. Previously, you couldn't realistically fingerprint non-listening peers.",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-637762128,637762128,
naumenkogs,2020-06-03 01:59:35,">For the record, I think you're wrong: it did introduce a new fingerprinting. Previously, you couldn't realistically fingerprint non-listening peers.\n\nHow would you fingerprint it after my PR? Nodes [do not](https://github.com/bitcoin/bitcoin/blob/3657aee2d25ce1ffefc6817af3eead7120b1d755/src/net_processing.cpp#L3315) respond to GETADDR from outbound.",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-637907831,637907831,
luke-jr,2020-06-14 07:42:39,"Seems to have an intermittent test error :(\n\n```\n2020-06-14T07:39:48.638000Z TestFramework (INFO): Initializing test directory /tmp/bitcoin_func_test_rr8f1aik\n2020-06-14T07:39:49.959000Z TestFramework (INFO): Create connection that sends and requests addr messages\n2020-06-14T07:39:50.061000Z TestFramework (INFO): Fill peer AddrMan with a lot of records\n2020-06-14T07:39:50.127000Z TestF",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-643731428,643731428,
naumenkogs,2020-06-14 13:51:35,"@luke-jr good catch, thank you! I think Poisson timer varied too much, I made it more straightforward.",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-643769482,643769482,
luke-jr,2020-06-14 20:11:02,"Looking at the [older] code, I see two possible causes (and no clear good solutions):\n\n1. Not enough addresses to ensure the new set is distinct\n2. `PoissonNextSend` may be choosing a >3 day delay.",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-643816102,643816102,
luke-jr,2020-06-14 20:38:24,"Regarding the new version, you've switched from a 60+% chance of <24h, to only times between 24h-27h. I guess that's fine, but might be more fingerprintable?",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-643819135,643819135,
naumenkogs,2020-06-15 05:17:47,"@luke-jr I'm pretty sure the problem was (2), because I did a bunch of experiments (like ran tests 1,000 times before and after my recent force push).\n\nRegarding the interval, I think we should just focus average ~24h (my last commit has sloppy 25.5h, making it 24h now) as we discussed before.\n\nA. Not sure why Poisson(24h) would have a 60% chance of <24h? (less important)\nB. Not sure why",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-643907638,643907638,
naumenkogs,2020-06-17 07:38:05,Addressed feedback from @mzumsande: added PF_ADDR to the fuzzer and fixed the comment.,https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-645207913,645207913,
laanwj,2020-06-18 11:22:05,"> I don't touch that behaviour at all! I introduce two separate caches, but both of them are filled the same way as before. The separation is based on who requests (onion or regular), not the type of AddrMan records.\n\nJust a question: How do you recognize an incoming ONION connection? They look like incoming IPv4 connections, that tend to come from `127.0.0.1`. I think until #8973 is implement",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-645953952,645953952,
naumenkogs,2020-06-18 12:11:03,"@laanwj good point! I actually don't have much hands-on experience with Tor inbounds.\nI can't verify what you say atm, but yeah, *if* they look like 127.0.0.1, they will be grouped with ""comes from localhost"" until #8973.\n\nI think it's fine to merge it as-is, and then when #8973 comes the grouping can be improved.",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-645976349,645976349,
fjahr,2020-06-25 10:34:43,"I am not sure I understand how big the privacy gain is from this. Couldn't the spy just take the ~1000 records we send them and then send all of them a GETADDR and still get a very good view of the topology of the network within a few minutes? Granted, they may still be missing a few of our connections after that. But then maybe a simpler approach would be to keep a few connections 'secret' and ne",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-649457045,649457045,
naumenkogs,2020-06-25 11:03:13,">Couldn't the spy just take the ~1000 records we send them and then send all of them a GETADDR and still get a very good view of the topology of the network within a few minutes?\n\nI don't know how to exploit what you're describing :) Like, yeah, you send them all a GETADDR, but then what?\n\nI'm talking about a different set of attacks here. One example is mapping two virtual identities (Tor",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-649470276,649470276,
fjahr,2020-06-28 17:16:30,"> I don't know how to exploit what you're describing :) Like, yeah, you send them all a GETADDR, but then what?\n> \n> I'm talking about a different set of attacks here. One example is mapping two virtual identities (Tor and ipv4) of the same node together. If you can scrape all their AddrMan records and compare timings, it's very easy to tell if they're the same physical node. After my change, ",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-650795822,650795822,
naumenkogs,2020-06-29 06:10:35,">how much more protected is my privacy when the attacks are launched with the complete set of the victim's peers vs. launching the same attack with a set of peers collected from the whole network.\n\nI see the confusion! In my opinion (and it seems to be the threat model other people share), just a *list* of all nodes in the network (or all nodes a victim has) is not private info. Sure, it does ",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-650941757,650941757,
achow101,2020-06-29 19:24:10,ACK 52d22a3c235bfed8a772b7cccbe470efdfa10291,https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-651312198,651312198,
andrewtoth,2020-06-30 03:07:10,Concept ACK.,https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-651497389,651497389,
pinheadmz,2020-07-01 13:46:11,"Dunno if this has been mentioned already but if you rebase to include https://github.com/bitcoin/bitcoin/pull/19192 you can add a `help` description of the new net permission `addr`.\n\nhttps://github.com/bitcoin/bitcoin/blob/bb588669f9e84011969b67f807f12c3480489955/src/net_permissions.cpp#L11-L17",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-652428229,652428229,
willcl-ark,2020-07-01 14:09:49,"tACK.\n\nPR passed tests with MacOS 10.15 on both this branch and cherry-picked on top of master at 2af56d6d5c387c3208d3d5aae8d428a3d610446f.\n\nI like the general approach of the PR: there seems like little danger associated with a rolling ADDR cache and certainly some possible privacy upside if the assumptions in the first post (e.g. being able to infer direct peers) are correct.",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-652441451,652441451,
rajarshimaitra,2020-07-01 15:03:52,"tACK. \nCompiled and tests passing. Need to think more on attack surfaces but so far with the above discussion from more competent people, it seems to be fine. And the gains are rational.\nSo far my only thought is there is a replication of addresses happening in the cache as per network types. How much is the memory of consumption for this cache? It seems to be at least 3 times (ipv4/ipv6/local",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-652473133,652473133,
troygiorshev,2020-07-01 17:03:43,"ACK 52d22a3c235bfed8a772b7cccbe470efdfa10291\n\nReviewed, tested.\n\nWithout checking, I'm not worried about the memory usage for `m_addr_response_caches`.\n\nI need to look further at the justification of 24h and 1000 cached addresses.\n\nI think this change may have larger (positive) consequences than described in the description, though I would like to make that more precise.\n\nSome ",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-652539122,652539122,
Emzy,2020-07-01 18:19:02,"My concern would be nodes that change there IP address often. \nFor example in Germany it is often the case that the ISP will give you every 24 hours a new IPv4 address and a new IPv6 prefix.  \n\nI think these nodes would get less incoming connections, because it will take between 0-24 hours to get their new address in the P2P network and also to DNS seeds.\n\nIt could be that this is not re",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-652574507,652574507,
naumenkogs,2020-07-15 08:48:36,"I believe I resolved all the outstanding feedback (some things be better in a follow-up), looking for code acks now :)",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-658636295,658636295,
jnewbery,2020-07-15 09:54:54,netbase_tests/netpermissions_test is failing: check strings.size() == 6U has failed [7 != 6],https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-658671625,658671625,
jnewbery,2020-07-21 16:55:25,Changes look good but p2p_permissions.py seems to be broken.,https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-661980580,661980580,
jnewbery,2020-07-23 09:38:37,utACK 130655a09054e7fe4388a4383ed320f4ce7de103,https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-662912718,662912718,
jnewbery,2020-07-23 17:34:31,"@naumenkogs - I have a branch at https://github.com/jnewbery/bitcoin/tree/2020-07-addrman-get that allows addresses to be added to AddrMan manually over RPC. With that branch, I'm very easily able to add thousands of addresses, which would make it possible to test the edge conditions of this PR. It conflicts with this branch, so I'm not planning to open it as a PR yet, but perhaps you'd like to ta",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-663137439,663137439,
hebasto,2020-07-24 07:53:06,Concept ACK.,https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-663394972,663394972,
naumenkogs,2020-07-24 15:06:04,Addressed nits suggested by @MarcoFalke ,https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-663584778,663584778,
hebasto,2020-07-25 03:49:42,"@naumenkogs @sipa \nWould these changes affect the reference [bitcoin-seeder](https://github.com/sipa/bitcoin-seeder/blob/529a667f30c799d2281f862570df9d34e50899f0/bitcoin.cpp#L92)?",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-663803431,663803431,
MarcoFalke,2020-07-25 06:44:52,re-run ci,https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-663818659,663818659,
naumenkogs,2020-07-27 09:14:42,"@hebasto I think there might be a very limited effect: seeders might be getting/serving slightly outdated timestamps.\nBut this effect is very limited, because the cache lifetime is only 24h. Addrs are considered to be non-terrible (see `isTerrible`) if they're less than 30 days old. It was somewhat discussed at the [review club](https://bitcoincore.reviews/18991.html), sipa was also there.",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-664228902,664228902,
jonatack,2020-07-27 09:59:46,"@naumenkogs My unresolved worry with this change is expressed in the second review club log [here](https://bitcoincore.reviews/18991.html#l-347), lines 347-370. WDYT?",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-664252772,664252772,
naumenkogs,2020-07-27 10:39:29,"@jonatack Since we currently don't have a good way to measure all those AddrMan properties and have a high-level ""roadmap"" of moving forward, I think we should focus on the outstanding problems.\n\nThere is a problem with AddrMan privacy. This PR clearly improves upon that direction. How does it affect other properties? Not much, the only consequence is lists being _a bit more outdated_.\nI hav",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-664298482,664298482,
jonatack,2020-07-27 10:53:25,I'm onboard with improved privacy; what I'm still working out are the consequences of adversely affecting discovery of newly online peers or ones who change IP address frequently. The former case is one I'm observing closely nowadays using a custom peer connections dashboard WRT notably peer discovery and inbounds evictions. Do you have a branch for the self announcements to feelers? ,https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-664318166,664318166,
naumenkogs,2020-07-27 11:01:21,"@jonatack no, I don't have that branch, it's only an idea right now. \n\nSo your concern is that some peers would be easier deprioritized and maybe evicted more often?\nYeah, it's a valid one, but again:\n- I don't think this PR makes it much worse. There are probably easy ways to affect that stuff already.\n- I don't think the publicity of AddrMan is the right solution to the problem you're ",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-664328884,664328884,
EthanHeilman,2020-07-28 16:29:09,">I'm onboard with improved privacy; what I'm still working out are the consequences of adversely affecting discovery of newly online peers or ones who change IP address frequently.\n\nCan we build some sort of simulation to test what the effects of this are? If getaddr is the main way that new IPs are propagated, then this would seriously hurt new IP propagation. If, as I suspect, getadddr isn't",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-665141756,665141756,
naumenkogs,2020-07-29 07:48:36,">With out this PR I would have to make a few hundred connections to re-identify a node. Maybe this fingerprinting attack isn't a concern due to how bitcoin is used?\n\n1. True, but I wouldn't rely on this ""protection"" at all, because creating 100 connections (from the same source IP) is easy.\n2. Your argument also reminded me that this PR protects from mapping IP<->Tor identities of the same n",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-665496828,665496828,
EthanHeilman,2020-07-29 14:56:16,">After this PR, there will be separate caches for every net, so an attacker would have to spend weeks to achieve the same precision.\n\nThat seems like a pretty big win, although do we know how private Bitcoin nodes on tor are?",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-665714546,665714546,
naumenkogs,2020-07-29 15:18:19,">That seems like a pretty big win, although do we know how private Bitcoin nodes on tor are?\n\nThere is a decent number of them (couple thousand listening all the time, and more non-listening I guess), but I think we don't really know how many of them configured everything properly :)\n\nThere are maybe still a couple places in the p2p protocol where a spy can correlate ip<->Tor (need more re",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-665727767,665727767,
jnewbery,2020-07-30 11:43:52,reACK 3bd67ba5a4ef3c20ef1f873b63c9f53a6c8608b6,https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-666316077,666316077,
naumenkogs,2020-08-03 07:21:35,"Thanks for the reviews!\nIt's currently Code review ACKs from ariard, jnewbery and promag on the up-to-date commit, several of Concept ACKs before, and several tested ACKs on the version (before minor refactoring) we discussed at the review club.\n\nThe latest suggestions seem to be couple nits and discussion points, so for the sake of review efficiency let's not address them for now :)",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-667853698,667853698,
promag,2020-08-03 12:49:19,"Don't forget https://github.com/bitcoin/bitcoin/pull/18991#discussion_r464082065, seems it wasn't previously discussed.",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-668004207,668004207,
laanwj,2020-08-03 13:06:38,"> Don't forget #18991 (comment), seems it wasn't previously discussed.\n\nSorry, hadn't noticed this before merging. As it's a question, I think discussion can simply continue here, and if further changes are necessary it can be in a follow-up PR?",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-668012028,668012028,
sipa,2020-08-03 20:13:10,"Random thought: there is a (rather uncommon, I suspect) scenario in which this definitely worsens node identity discoverability: if a peer has multiple listening addresses associated with one network. I don't think this is a big concern, but it's also fairly easy to address: make the cache map not indexed by just Network, but also add the local socket address (see `getsockname`).",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-668219345,668219345,
naumenkogs,2020-08-04 07:16:19,"> scenario in which this definitely worsens node identity discoverability: if a peer has multiple listening addresses associated with one network\n\nYou probably mean *makes it easier to discover [...]*. True, although again, it was already trivial (just make 100 GETADDR even from the same host) and see timestamps, so I won't say this degradation is a big deal at all. I believe @ariard raised th",https://github.com/bitcoin/bitcoin/pull/18991#issuecomment-668425062,668425062,
ariard,2020-05-22 07:12:54,"A way to simplify code IMO:\n\n```\nif (use_cache == ADDR_CACHE_NONE) {\n    return addrman.GetAddr();\n}\nCachedAddrResponse* cache;\nif (use_cache == ADDR_CACHE_REGULAR) {\n     cache = &m_cached_addr_response_regular;\n} else {\n     cache = &m_cached_addr_response_other;\n}\nconst std::chrono::microseconds current_time = GetTime<std::chrono::microseconds>();\nif (cache->m_update_a",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r429080574,429080574,src/net.cpp
ariard,2020-05-22 07:39:17,"Unless you think it's too serious for now, I would comment the full privacy leak.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r429091118,429091118,src/net.h
ariard,2020-05-22 07:48:46,"What's your rational for coming with 24h in average ? You announce this fix prevent tracking real-time changes in local node topology. I think to be effective you need to define real-time further with regards to expected topology changes, which for outbound peers is only stale tip or them falling offline ?\n\nOr say differently does natural outbound full-relay peer rotation is faster that 24 hou",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r429095360,429095360,src/net.h
ariard,2020-05-22 07:59:39,"Please explain how cross-network node identity would operate, i.e a spy connecting first on regular, querying cache, reconnecting on other, querying again cache and testing for equality.\n\nGoing further, shouldn't you cache based on address announced ? Isn't this a fingerprint for multi-homed nodes ?",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r429100181,429100181,src/net.h
naumenkogs,2020-05-25 06:52:30,Agree.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r429760098,429760098,src/net.cpp
naumenkogs,2020-05-25 07:33:37,"I would say 24h is pretty arbitrary, but reasonable. Let me explain.\n\nUpper bound:\nShouldn't be too long so that the returned records are still relevant for GETADDR requestor. Although currently `IsTerrible` is fine with everything in last 30 days, we also should make sure that nodes in the response are not dead. I can't find the data, but I remember reading that the churn among reachable no",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r429776733,429776733,src/net.h
naumenkogs,2020-05-25 08:25:13,Adding more info without talking too much specifics.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r429801896,429801896,src/net.h
naumenkogs,2020-05-25 08:38:14,"Adding more documentation.\n\n>Going further, shouldn't you cache based on address announced ? Isn't this a fingerprint for multi-homed nodes ?\n\nWhat makes you think so?",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r429808188,429808188,src/net.h
glowang,2020-05-28 14:46:35,"My understand is you want to use `ADDR_CACHE_OTHER` for privacy-preserving networks, so that the caches returned from these networks  are not mapped 1-1 with caches returned from identifying networks like ipv4, is that right?  \n\nIf this is the case, I believe NET_TEREDO peers and any peers with NET_UNKNOWN will also hit the `else` case and use the same cache as Tor's? Do NET_TEREDO and NET_UNK",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r431895174,431895174,src/net_processing.cpp
glowang,2020-05-28 15:24:37,"if you initialized `m_update_addr_response` to be 0 with `std::chrono::microseconds m_update_addr_response{0};`, wouldn't this clause always be true?",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r431923293,431923293,src/net.cpp
naumenkogs,2020-05-29 15:06:33,">My understand is you want to use ADDR_CACHE_OTHER for privacy-preserving networks, so that the caches returned from these networks are not mapped 1-1 with caches returned from identifying networks like ipv4, is that right?\n\nYes. I mean, ideally not just private/identifying networks. Ideally, if a node is hosted on Tor AND i2p AND ipv4, neither of them should be mapped together. But allocating",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r432549585,432549585,src/net_processing.cpp
naumenkogs,2020-05-29 15:22:27,"It is true on the first ever iteration, but then `cache->m_update_addr_response = PoissonNextSend(current_time, AVG_ADDRESS_RESPONSE_UPDATE_INTERVAL);` in the conditional branch executes and makes it non-zero right away. So that it will be true again only after AVG_ADDRESS_RESPONSE_UPDATE_INTERVAL",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r432559588,432559588,src/net.cpp
sipa,2020-05-29 16:59:03,Why not one for every network? 1000 addresses per network is still only a tiny amount of memory.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r432616969,432616969,src/net.h
ariard,2020-06-01 23:55:59,"If you announce 2 different IPv4 addresses, `requestor_network` is going to be the same (`NET_IPV4`) for both and hit the same cache ?",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r433548779,433548779,src/net.h
ariard,2020-06-02 00:19:20,"We should dissociate network _churn_, i.e how many peers fall offline after X and peers _rotation_, i.e changes among our connections demography after same X. I think for counter-measure to be efficient you need rotation to be high enough to blur adversary guess of your peers topology. \n\nObviously, a higher rotation target is likely to come with a higher churn, and therefore decrease validity ",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r433555155,433555155,src/net.h
naumenkogs,2020-06-02 03:59:51,"Oh, I see, you mean *own* address announced. That's pretty crazy, I'm not even sure our software currently can do this.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r433606996,433606996,src/net.h
glowang,2020-06-02 15:07:18,"As for rotation of outbound peers, I don't know if we actually have any mechanism to do that programmatically. This idea was discussed [here](https://github.com/bitcoin/bitcoin/pull/4723/files) but the PR was closed as further research is needed. As rotation of inbound peers, does anyone know whether that even exists & how it is done?  ",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r433949352,433949352,src/net.h
luke-jr,2020-06-02 19:31:32,What is all this for?,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r434127596,434127596,src/net.cpp
luke-jr,2020-06-02 19:32:40,"I think this should probably be a whitelist flag, not an assumption internal nodes are non-malicious",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r434128219,434128219,src/net.h
naumenkogs,2020-06-03 01:55:05,"Oh, oops, me being sloppy.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r434266333,434266333,src/net.cpp
naumenkogs,2020-06-03 12:25:21,"Inbound rotation is something I've never heard of :)\n\nIt practice it just means dropping an existing connection someone made to us... It doesn't feel useful from the first glance, unless that peer was malicious or broken. \nAn inbound connection can't be immediately replaced, so this seems like a loose-loose w.r.t security. We can drop a spy, true, but right now that is solved by slower relay",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r434526926,434526926,src/net.h
luke-jr,2020-06-07 17:56:37,File needs +x permisison,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r436386929,436386929,test/functional/p2p_getaddr_caching.py
mzumsande,2020-06-15 22:12:11,nit: move the `)`  until after `whitelisted node`,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r440475693,440475693,src/net.h
mzumsande,2020-06-16 21:12:20,"Since all addresses go into the same bucket, I think that only 64 of them will be kept in addrman, 14 of which will be returned in response to each `GETADDR` - so creating 1000 addresses instead of less does not add randomness to the `GETADDR` responses - though it's fine of course if you want to test the 1000 address limit for `ADDR`.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r441145065,441145065,test/functional/p2p_getaddr_caching.py
naumenkogs,2020-06-17 07:22:18,nice catch! Let's keep it this way just in case e.g. bucketing logic is changed in the future.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r441333812,441333812,test/functional/p2p_getaddr_caching.py
achow101,2020-06-25 18:10:23,This seems unnecessary. `get_value_or` only matters if the Optional is nullopt and a nullopt can't reach this code path.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r445745268,445745268,src/net.cpp
andrewtoth,2020-06-30 03:05:08,"Can you elaborate on why a whitelisted node should avoid using the cache? If there are no real downsides to caching for 24 hours then this shouldn't matter, right?",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r447380482,447380482,src/net.h
naumenkogs,2020-06-30 12:13:05,"Some hypothetical examples which *might* make sense in a trusted setting (which doesn't really make sense in a public trust-minimized setting):\n- 2 remote nodes exchanging each others AddrMan and compare to make sure no poisoning is happening\n- one node learns full AddrMan (or more than 1 cached list) from its *trusted* peer\n\nI don't have a strong justification for this feature, but I thou",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r447634719,447634719,src/net.h
andrewtoth,2020-06-30 13:55:14,Yeah I don't see any downsides to maintaining the current behaviour for trusted callers. I was just confused at seeing it in the implementation but no mention of it in the PR description or discussion.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r447701783,447701783,src/net.h
jnewbery,2020-06-30 21:05:56,"It feels to me like this would be more natural as an overloaded function rather than passing an optional:\n\n- `GetAddresses()` returns an uncached vector of addresses from addrman as now\n- `GetAddresses(Network)` returns the cached vector of addresses for that network.\n\nWhy? Because the logic for those two cases is entirely separated in the implementation, it avoids packing and unpacking ",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r447978865,447978865,src/net.h
jnewbery,2020-06-30 21:07:32,"This is a good place for an `auto`. The return type of `GetTime<std::chrono::microseconds>()` is obvious, so there's no need to type it out.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r447979641,447979641,src/net.cpp
jnewbery,2020-06-30 21:09:14,What are the additional memory requirements for this structure? Could you add that to the comment?,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r447980442,447980442,src/net.h
jnewbery,2020-06-30 21:21:37,"Perhaps this filtering out banned addresses shouldn't happen if we're sending from the cache. If an address in the cache is banned during the cache's lifetime, subsequent GETADDR requests will receive a different response, which could be a marginal privacy leak.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r447986548,447986548,src/net_processing.cpp
jnewbery,2020-06-30 21:23:06,"Merge these two lines? No need for a local `peer_network` variable (the compiled code will be exactly the same, but creating a local variable that won't be used again signals the wrong intent in the code)",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r447987270,447987270,src/net_processing.cpp
jnewbery,2020-06-30 21:23:37,nit: docstrings should be one line if there's only one line of text. Join these lines.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r447987505,447987505,test/functional/p2p_getaddr_caching.py
jnewbery,2020-06-30 21:24:48,nit: spaces around `+`. Same below in line 95.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r447988106,447988106,test/functional/p2p_getaddr_caching.py
jnewbery,2020-06-30 21:27:50,prefer `(i >> 8) % 256` to avoid having to convert between ints and floats (and better signal that you're removing the bottom 8 bits for the third section of the IP address). Better yet: `i >> 8` since your loop doesn't go over 256^2.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r447989605,447989605,test/functional/p2p_getaddr_caching.py
jnewbery,2020-06-30 21:52:14,"I have a general distaste for asserting on log contents (logs aren't part of a stable API, so can change between releases, and it's annoying if that causes tests to break). I suggest just removing the `assert_debug_log()`",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r448000483,448000483,test/functional/p2p_getaddr_caching.py
jnewbery,2020-06-30 21:53:36,"Again, there's no need for this assert_debug_log(). You're already asserting on the contents of the response.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r448001035,448001035,test/functional/p2p_getaddr_caching.py
jnewbery,2020-06-30 21:56:35,why is this change in mocktime between the send and the wait_until? Presumably it can go afterwards just as easily? Splitting up the send and wait_until response makes this marginally more difficult to follow.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r448002310,448002310,test/functional/p2p_getaddr_caching.py
jnewbery,2020-06-30 21:56:46,no need for custom timeouts here.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r448002384,448002384,test/functional/p2p_getaddr_caching.py
jnewbery,2020-06-30 21:57:28,I don't think this setmocktime is necessary.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r448002684,448002684,test/functional/p2p_getaddr_caching.py
jnewbery,2020-06-30 21:58:46,This change can be squashed into commit _Add whitelist flag enabling non-cached addr sharing_,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r448003195,448003195,src/test/fuzz/net_permissions.cpp
naumenkogs,2020-07-01 08:27:50,"Agreed, will update.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r448202417,448202417,src/net.h
pinheadmz,2020-07-01 14:12:42,"Does it make sense to start off the node with > 1000 addresses? If I understand this test correctly, after the cache timeout the only thing that changes is the sequence of the same 1000 addresses in the message. I'm not sure if its worth it but we could also ensure that different addresses were sent after the timeout.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r448392147,448392147,test/functional/p2p_getaddr_caching.py
jnewbery,2020-07-01 14:22:35,"In fact, I think this filtering out of banned addresses should move to `CConnman::GetAddresses()`. The only other client of that function is `getnodeaddresses` in rpc/net, and that probably doesn't want to know about banned addresses either.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r448398932,448398932,src/net_processing.cpp
pinheadmz,2020-07-01 14:33:10,"This might be an insane edge case, but if `pfrom.addr.GetNetwork()` is `NET_UNROUTABLE`, the value will be `0` (and falsey ?) and break the intent of this logic. I'm not sure how an attacker could use an unroutable address to break your cache though so probably moot.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r448406297,448406297,src/net.cpp
naumenkogs,2020-07-01 14:40:51,"Are you sure Optional(0) would be ``false``? Would be useful to double-check the optional spec, but I expected that any value present (including 0) would give ``true``",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r448411682,448411682,src/net.cpp
pinheadmz,2020-07-01 15:21:36,"Confirmed, you are right. Thanks!",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r448439192,448439192,src/net.cpp
naumenkogs,2020-07-04 09:09:13,"See AVG_ADDRESS_BROADCAST_INTERVAL, this code is necessary to bypass it (same below).\nMaybe I don't understand your suggestion.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r449755317,449755317,test/functional/p2p_getaddr_caching.py
jnewbery,2020-07-04 16:22:34,"Ah, you're right. I misunderstood how the ADDR response is batched/delayed.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r449785930,449785930,test/functional/p2p_getaddr_caching.py
jnewbery,2020-07-04 16:23:01,"As above, this is incorrect. Disregard.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r449785955,449785955,test/functional/p2p_getaddr_caching.py
jnewbery,2020-07-04 16:41:35,"This is less efficient than the current code because you're creating a new vector and individually copying elements to it. This is also going to involve a lot of reallocations, since `addresses` can potentially grow as large as 2500.\n\nInstead, assign `addresses` to be the return value from `GetAddr()` (which should be a move because of RVO), and then use the [remove-erase idiom](https://en.cpp",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r449787348,449787348,src/net.cpp
jnewbery,2020-07-04 16:42:52,nit: prefer to use doxygen-style comments for function declaration comments.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r449787438,449787438,src/net.h
jnewbery,2020-07-04 16:44:12,This comment about nullopt is outdated,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r449787497,449787497,src/net.h
jnewbery,2020-07-04 16:49:17,Where did you get 1000 from? The maximum number of `CAddress` objects returned by `CAddrMan::GetAddr()` is `ADDRMAN_GETADDR_MAX`(2500),https://github.com/bitcoin/bitcoin/pull/18991#discussion_r449787907,449787907,src/net.h
jnewbery,2020-07-04 16:56:11,"It's a bit of a shame that the return has to copy the vector rather than eg returning a reference to const. But it's a lot better than the current code, which iterates through the entire AddrMan on each GetAddresses call. A follow-up PR could potentially make this more efficient.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r449788393,449788393,src/net.cpp
jnewbery,2020-07-04 17:13:26,"Well this is fascinating. Because of the way we call `PushAddress()` serially with the elements of the vector in order, and each call after `vAddrToSend` is full evicts a random element, then repeatedly sending `GETADDR` will result in `ADDR` responses that leak the entire `m_addr_response_caches[requestor_network].m_addrs_response_cache` _and the order of elements in that vector_. I don't think t",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r449789621,449789621,src/net_processing.cpp
jnewbery,2020-07-04 17:30:45,"I think that @mzumsande is right. Because these go into the same bucket, only a small number of them will be kept in addrman, and only 23% of those will be returned by `CAddrMan::GetAddr()`. I haven't verified the numbers 64 and 14, but that sounds right to me.\n\nI suspect if we changed this to load >4000 addresses into addrman, then the test would fail, because responses to `GETADDR` messages ",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r449790883,449790883,test/functional/p2p_getaddr_caching.py
naumenkogs,2020-07-07 07:53:14,"Right, I was considering this option, but for some reason I thought it's even more expensive... Now that I re-read [this explainer](https://www.geeksforgeeks.org/difference-between-stdremove-and-vectorerase-for-vectors/) it actually makes sense. Thanks!",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r450676019,450676019,src/net.cpp
naumenkogs,2020-07-07 08:40:45,"You are right, 1000 limit is applied later, ""receiver rejects addr messages larger than 1000""",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r450702751,450702751,src/net.h
naumenkogs,2020-07-07 10:25:17,"Can we discuss this a bit more?\nI don't mind adding that code, I just don't see the motivation. As you point out, this particular leak doesn't matter, because cache is public data. Why limiting to 1000? Maybe another motivation is saving 300 KB of RAM?\n",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r450763661,450763661,src/net_processing.cpp
naumenkogs,2020-07-07 10:46:38,"As someone [points out](https://github.com/bitcoin/bitcoin/issues/19458), there's a slight non-useful inconsistency. Do you think we should address it within this PR?",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r450774323,450774323,src/net_processing.cpp
jnewbery,2020-07-07 16:11:10,"> I just don't see the motivation\n\nAs far as I can tell, the intent for this PR was that for each network, we'd create a cache of 1000 addresses, and serve the same list of 1000 addresses (less banned/discouraged) in response to each GETADDR request. Indeed, that's what the functional test is testing for. Instead, we create a cache of 2500, and serve a random 1000 of them to each GETADDR reque",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r450981679,450981679,src/net_processing.cpp
naumenkogs,2020-07-07 16:39:38,"Right, I guess I'll put together a separate commit just to address 2500/1000 confusion we had even before this PR",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r450999333,450999333,src/net_processing.cpp
jnewbery,2020-07-07 16:51:26,"> I'll put together a separate commit just to address 2500/1000 confusion\n\nThat'd be great. I think it can be a separate PR. My suggestion: remove the `ADDRMAN_GETADDR_MAX_PCT` and `ADDRMAN_GETADDR_MAX` constants from addrman and make it the caller's responsibility to set max records/percentage values. Net processing can use 1000/23 and rpc/net can set no max, potentially exposing all address ",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r451006518,451006518,src/net_processing.cpp
sipa,2020-07-07 19:40:16,@jnewbery I think that's the right approach.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r451099313,451099313,src/net_processing.cpp
naumenkogs,2020-07-08 08:45:41,"Added the basic fix and updated the test, leaving moving responsibilities for a future PR.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r451383066,451383066,src/net_processing.cpp
jnewbery,2020-07-08 14:00:59,I think it'd be more appropriate to use `MAX_ADDR_TO_SEND` as the constant here (and below),https://github.com/bitcoin/bitcoin/pull/18991#discussion_r451567900,451567900,src/net_processing.cpp
jnewbery,2020-07-08 14:21:51,Maybe add a static_assert in net.h that `MAX_ADDR_TO_SEND` is the same as `ADDRMAN_GETADDR_MAX` (with a TODO to remove `ADDRMAN_GETADDR_MAX`),https://github.com/bitcoin/bitcoin/pull/18991#discussion_r451583970,451583970,src/addrman.h
jnewbery,2020-07-08 14:23:49,nit: please doxygen-format these comments too,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r451585494,451585494,src/net.h
jnewbery,2020-07-08 14:39:16,"This doesn't appear to fill the addrman with 10,000 address records. If I run the `getnodeaddresses` RPC after this repeatedly and keep a set of all of the address records returned, I only get to around 3500 (it varies on each test run).",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r451597127,451597127,test/functional/p2p_getaddr_caching.py
naumenkogs,2020-07-08 20:38:59,"Sure, but my goal here was to make it more than 1,000; just in case. Any particular suggestion?",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r451811788,451811788,test/functional/p2p_getaddr_caching.py
jnewbery,2020-07-08 20:59:01,"Because of the limit of returning 23% of records in GetAddr(), there need to be ~4350 records for the cache to be filled with 1000 records.\n\nI haven't looked into how CAddress records in ADDR messages are saved to AddrMan, so I can't offer any insight into why only ~3500 are being saved here.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r451821698,451821698,test/functional/p2p_getaddr_caching.py
naumenkogs,2020-07-08 21:29:48,"Sorry, I'm still not sure what we're trying to accomplish here... I think as long as we use 1,000 and not 2,500 for max cache size, either actual cache size (less or equal then 1,000) is fine.\n\nI just chose this 10,000 value so that it's *big enough*, just to hit some potential corner case.  I don't see a real reason to go beyond that (for example, to have a cache with 1,000 records). I can pr",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r451836231,451836231,test/functional/p2p_getaddr_caching.py
jnewbery,2020-07-09 05:27:20,"The motivation is that the tests should test the limits of the new functionality. The cache can have up to 1000 entries in it. What's the behavior like when that cache is full?\n\nThe description of this PR says:\n\n> cache responses to GETADDR on a daily basis, so that an attacker gets at most 1,000 records per day\n\nThe test should test that an attacker is actually only able to get 1,000 ",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r451971464,451971464,test/functional/p2p_getaddr_caching.py
naumenkogs,2020-07-09 08:52:24,"I updated the test and I think these 2 checks are sort of sufficient here:\n1. All responses during the day are same\n2. They are less than 1000 records\nI think (1) is much more interesting then (2), and the second part of the test confirms that (1) is only day-long cache.\n\nI'll take a look why it's not exact cache size of 1000 later, but I still think it's not that substantial.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r452065346,452065346,test/functional/p2p_getaddr_caching.py
naumenkogs,2020-07-14 13:31:35,"Alright, so the issue is that we map every *source* of the ADDRs to 64 buckets 64 slots each -> one *source* can add at most 64x64=4096 records. This results in at most 4096*0.23=942 records returned from AddrMan.\n\nAs far as I know, there is currently no good way to work around this per-source limit while testing, so leaving it as is for now.\nAs I mention above, I think this is not critical ",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r454357727,454357727,test/functional/p2p_getaddr_caching.py
jnewbery,2020-07-14 15:42:17,This should check whether `m_banman` exists before dereferencing.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r454453491,454453491,src/net.cpp
jnewbery,2020-07-14 16:48:05,"ok, sounds reasonable. It's a shame that our testing framework won't allow us to fully test the edges of this, but that shouldn't hold this PR up.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r454497331,454497331,test/functional/p2p_getaddr_caching.py
MarcoFalke,2020-07-15 10:23:04,why extend this further? legacy should die,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r454948843,454948843,src/net.cpp
MarcoFalke,2020-07-15 16:37:51,"whitelist is deprecated, please mention the exact permission flag. See also #19474 ",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r455183430,455183430,src/net.h
jnewbery,2020-07-16 09:51:10,and the one below please!,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r455665585,455665585,src/net.h
jnewbery,2020-07-16 09:51:53,This is incorrect. It should be 1000 CAddress records.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r455666044,455666044,src/net.h
jnewbery,2020-07-16 09:56:36,"I think it's worth a comment here explaining https://github.com/bitcoin/bitcoin/pull/18991#discussion_r454357727, otherwise people reading this test will expect there to be 10,000 entries in addrman.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r455668874,455668874,test/functional/p2p_getaddr_caching.py
jnewbery,2020-07-16 09:57:27,Place standard library imports before local project imports.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r455669335,455669335,test/functional/p2p_getaddr_caching.py
jnewbery,2020-07-16 10:00:01,You should really take mininode_lock before reading this field (or better - add a getter method to AddrReceiver that takes the lock internally and returns a list),https://github.com/bitcoin/bitcoin/pull/18991#discussion_r455670835,455670835,test/functional/p2p_getaddr_caching.py
jnewbery,2020-07-16 10:00:25,"as above, this requires mininode_lock",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r455671114,455671114,test/functional/p2p_getaddr_caching.py
MarcoFalke,2020-07-23 18:10:35,why is this changed?,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r459636047,459636047,test/functional/p2p_blocksonly.py
MarcoFalke,2020-07-23 18:12:44,"```suggestion\n                        [this](const CAddress& addr){return m_banman->IsDiscouraged(addr) || m_banman->IsBanned(addr);}),\n```\n\nAny reason to use this style, as opposed to the project's style?",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r459637266,459637266,src/net.cpp
MarcoFalke,2020-07-23 18:14:19,"```suggestion\n            addr_receiver.wait_until(addr_receiver.addr_received)\n```",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r459638138,459638138,test/functional/p2p_getaddr_caching.py
MarcoFalke,2020-07-23 18:14:28,same,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r459638213,459638213,test/functional/p2p_getaddr_caching.py
jnewbery,2020-07-30 10:43:30,Can you make this a doxygen style comment please :pray: ,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r462910122,462910122,src/net.h
promag,2020-08-02 13:58:07,"acd6135b43941fa51d52f5fcdb2ce944280ad01e\n\nUse iterator instead:\n```cpp\nauto i = m_addr_response_caches.find(requestor_network);\nif (i == m_addr_response_caches.end() || i->m_update_addr_response < current_time)\n```\n",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r464081434,464081434,src/net.cpp
promag,2020-08-02 14:04:34,"acd6135b43941fa51d52f5fcdb2ce944280ad01e\n\nI think you could explain this expiration duration. Looks like it could be a lot less and still prevent spying?",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r464082065,464082065,src/net.cpp
promag,2020-08-02 14:07:10,"acd6135b43941fa51d52f5fcdb2ce944280ad01e\n\nnit, no need for `m_` prefix in structs (?).",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r464082309,464082309,src/net.h
jnewbery,2020-08-02 16:57:29,I assumed that all member variables (of classes and structs) should have the `m_` prefix.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r464099719,464099719,src/net.h
ariard,2020-08-03 00:04:24,nit: I think that's a slight perfomance regression as you will iterate twice on the non-erased vector elements. Likely not to matter as it's not a hot point.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r464140251,464140251,src/net.cpp
ariard,2020-08-03 00:16:02,"I think commit message could be clearer, it doesn't remove the limit on AddrMan queries, rather bound it to the maximum size of ADDR message ?",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r464141600,464141600,src/addrman.h
ariard,2020-08-03 00:19:58,"It sounds you compare a verb `m_update_addr_response` to a noun `current_time`. IMO, `m_cache_expiration_time` would be more meaningful",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r464142053,464142053,src/net.h
ariard,2020-08-03 00:37:49,"You may underscore that the cache is global and not per-peer thus being uniform to who ever is querying during the cache period. I think a per-peer cache would be worst, unless you have first a global and announce random subset from it.\n\nThat said, an area of research could be to tie the cache in function of the subnet/ASN of requestors to nudge their connections towards a more diversified gra",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r464144483,464144483,src/net.h
naumenkogs,2020-08-03 07:12:31,Yeah Ive got the same impression.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r464232727,464232727,src/net.h
jnewbery,2020-08-03 10:15:04,No. remove-erase removes unwanted elements in a single pass.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r464322841,464322841,src/net.cpp
promag,2020-08-03 10:49:28,See some recently added structs. Nit anyway.,https://github.com/bitcoin/bitcoin/pull/18991#discussion_r464337985,464337985,src/net.h
ariard,2020-08-03 12:31:58,"Previously, in net_processing, we iterate on `vAddr` and filter out discouraged/banned elements before to push them in `vAddrToSend`. So that's a single pass.\n\nNow, in net.cpp we iterate on `addresses` on every element, then in net_processing we iterate again on `vAddr` to push  elements in `vAddrToSend`. So that's two pass on the valid set ?",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r464382855,464382855,src/net.cpp
jnewbery,2020-08-03 13:12:18,"The idea is to prevent peers scraping our addrman. The shorter the cache duration, the less time it would take a peer to get an (almost) complete scan of addrman.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r464403628,464403628,src/net.cpp
jnewbery,2020-08-03 13:21:07,"Ah, ok. Yes, you're right that for peers with ""addr"" permissions, we'll iterate through the list twice (although the list will be max size 1000 instead of 2500, so still fewer items). However, in the common case, we'll only iterate through the cached list once, and not have to call IsDiscouraged() or IsBanned() on that list.",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r464408605,464408605,src/net.cpp
naumenkogs,2020-08-03 17:26:26,"But yeah, it's hard to justify 24h vs 1h cache without a good analytical model of the whole addr relay.\n\nRight now cache lifetime is 0, so it takes like 0 seconds to scrape it. If cache was 1h, it would take about 100h (because ~100 requests are usually needed). However, during those 100h sensitive data might be already overwritten, so an attacker might not get useful info. It feels like 100h ",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r464554765,464554765,src/net.cpp
naumenkogs,2020-08-11 10:37:48,"It doesn't really work because it requires ""i->second"" :(",https://github.com/bitcoin/bitcoin/pull/18991#discussion_r468485759,468485759,src/net.cpp
naumenkogs,2020-08-11 10:41:14,I see e.g. `TxDownloadState` has `m_` prefix :),https://github.com/bitcoin/bitcoin/pull/18991#discussion_r468487425,468487425,src/net.h
