[
  {
    "sha": "e07c943ce8df6c6cb3ece3fc676911ddb43ca184",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMDdjOTQzY2U4ZGY2YzZjYjNlY2UzZmM2NzY5MTFkZGI0M2NhMTg0",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-04-15T10:43:17Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-04-17T14:46:01Z"
      },
      "message": "Add AssertLockHeld for cs_main to ChainActive-using functions\n\nAll functions that use ChainActive but do not aquire the cs_main\nlock themselves, need to be called with the cs_main lock held.\n\nThis commit adds assertions to all externally callable functions\nthat use chainActive or chainMostWork.\n\nThis will flag usages when built with -DDEBUG_LOCKORDER.",
      "tree": {
        "sha": "c195a933389b7dc8f9eaf99730488dd35ee66206",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c195a933389b7dc8f9eaf99730488dd35ee66206"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e07c943ce8df6c6cb3ece3fc676911ddb43ca184",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e07c943ce8df6c6cb3ece3fc676911ddb43ca184",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e07c943ce8df6c6cb3ece3fc676911ddb43ca184",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e07c943ce8df6c6cb3ece3fc676911ddb43ca184/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2f3308f2d2d46dd1f8f4a38a14e2cf1216b06afe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f3308f2d2d46dd1f8f4a38a14e2cf1216b06afe",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2f3308f2d2d46dd1f8f4a38a14e2cf1216b06afe"
      }
    ],
    "stats": {
      "total": 18,
      "additions": 18,
      "deletions": 0
    },
    "files": [
      {
        "sha": "456754353c407f44261597886e878c5b11b7dcb2",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e07c943ce8df6c6cb3ece3fc676911ddb43ca184/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e07c943ce8df6c6cb3ece3fc676911ddb43ca184/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=e07c943ce8df6c6cb3ece3fc676911ddb43ca184",
        "patch": "@@ -474,6 +474,7 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n \n bool IsStandardTx(const CTransaction& tx, string& reason)\n {\n+    AssertLockHeld(cs_main);\n     if (tx.nVersion > CTransaction::CURRENT_VERSION || tx.nVersion < 1) {\n         reason = \"version\";\n         return false;\n@@ -556,6 +557,7 @@ bool IsStandardTx(const CTransaction& tx, string& reason)\n \n bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime)\n {\n+    AssertLockHeld(cs_main);\n     // Time based nLockTime implemented in 0.1.6\n     if (tx.nLockTime == 0)\n         return true;\n@@ -667,6 +669,7 @@ unsigned int GetP2SHSigOpCount(const CTransaction& tx, CCoinsViewCache& inputs)\n \n int CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n {\n+    AssertLockHeld(cs_main);\n     CBlock blockTmp;\n \n     if (pblock == NULL) {\n@@ -813,6 +816,7 @@ int64_t GetMinFee(const CTransaction& tx, unsigned int nBytes, bool fAllowFree,\n bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransaction &tx, bool fLimitFree,\n                         bool* pfMissingInputs, bool fRejectInsaneFee)\n {\n+    AssertLockHeld(cs_main);\n     if (pfMissingInputs)\n         *pfMissingInputs = false;\n \n@@ -958,6 +962,7 @@ int CMerkleTx::GetDepthInMainChainINTERNAL(CBlockIndex* &pindexRet) const\n {\n     if (hashBlock == 0 || nIndex == -1)\n         return 0;\n+    AssertLockHeld(cs_main);\n \n     // Find the block it claims to be in\n     map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n@@ -981,6 +986,7 @@ int CMerkleTx::GetDepthInMainChainINTERNAL(CBlockIndex* &pindexRet) const\n \n int CMerkleTx::GetDepthInMainChain(CBlockIndex* &pindexRet) const\n {\n+    AssertLockHeld(cs_main);\n     int nResult = GetDepthInMainChainINTERNAL(pindexRet);\n     if (nResult == 0 && !mempool.exists(GetHash()))\n         return -1; // Not in chain, not in mempool\n@@ -1304,6 +1310,7 @@ int GetNumBlocksOfPeers()\n \n bool IsInitialBlockDownload()\n {\n+    AssertLockHeld(cs_main);\n     if (fImporting || fReindex || chainActive.Height() < Checkpoints::GetTotalBlocksEstimate())\n         return true;\n     static int64_t nLastUpdate;\n@@ -1323,6 +1330,7 @@ CBlockIndex *pindexBestForkTip = NULL, *pindexBestForkBase = NULL;\n \n void CheckForkWarningConditions()\n {\n+    AssertLockHeld(cs_main);\n     // Before we get past initial download, we cannot reliably alert about forks\n     // (we assume we don't get stuck on a fork before the last checkpoint)\n     if (IsInitialBlockDownload())\n@@ -1368,6 +1376,7 @@ void CheckForkWarningConditions()\n \n void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip)\n {\n+    AssertLockHeld(cs_main);\n     // If we are on a fork that is sufficiently large, set a warning flag\n     CBlockIndex* pfork = pindexNewForkTip;\n     CBlockIndex* plonger = chainActive.Tip();\n@@ -2078,6 +2087,7 @@ void static FindMostWorkChain() {\n \n // Try to activate to the most-work chain (thereby connecting it).\n bool ActivateBestChain(CValidationState &state) {\n+    AssertLockHeld(cs_main);\n     CBlockIndex *pindexOldTip = chainActive.Tip();\n     bool fComplete = false;\n     while (!fComplete) {\n@@ -2126,6 +2136,7 @@ bool ActivateBestChain(CValidationState &state) {\n \n bool AddToBlockIndex(CBlock& block, CValidationState& state, const CDiskBlockPos& pos)\n {\n+    AssertLockHeld(cs_main);\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n     if (mapBlockIndex.count(hash))\n@@ -2344,6 +2355,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n \n bool AcceptBlock(CBlock& block, CValidationState& state, CDiskBlockPos* dbp)\n {\n+    AssertLockHeld(cs_main);\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n     if (mapBlockIndex.count(hash))\n@@ -2455,6 +2467,7 @@ bool CBlockIndex::IsSuperMajority(int minVersion, const CBlockIndex* pstart, uns\n \n int64_t CBlockIndex::GetMedianTime() const\n {\n+    AssertLockHeld(cs_main);\n     const CBlockIndex* pindex = this;\n     for (int i = 0; i < nMedianTimeSpan/2; i++)\n     {\n@@ -2467,6 +2480,7 @@ int64_t CBlockIndex::GetMedianTime() const\n \n void PushGetBlocks(CNode* pnode, CBlockIndex* pindexBegin, uint256 hashEnd)\n {\n+    AssertLockHeld(cs_main);\n     // Filter out duplicate requests\n     if (pindexBegin == pnode->pindexLastGetBlocksBegin && hashEnd == pnode->hashLastGetBlocksEnd)\n         return;\n@@ -2983,6 +2997,7 @@ bool InitBlockIndex() {\n \n void PrintBlockTree()\n {\n+    AssertLockHeld(cs_main);\n     // pre-compute tree structure\n     map<CBlockIndex*, vector<CBlockIndex*> > mapNext;\n     for (map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)"
      },
      {
        "sha": "6391f9bc19ec9aaf65b1256e43859af6bfdeda5e",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e07c943ce8df6c6cb3ece3fc676911ddb43ca184/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e07c943ce8df6c6cb3ece3fc676911ddb43ca184/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=e07c943ce8df6c6cb3ece3fc676911ddb43ca184",
        "patch": "@@ -20,6 +20,7 @@\n \n QString TransactionDesc::FormatTxStatus(const CWalletTx& wtx)\n {\n+    AssertLockHeld(cs_main);\n     if (!IsFinalTx(wtx, chainActive.Height() + 1))\n     {\n         if (wtx.nLockTime < LOCKTIME_THRESHOLD)"
      },
      {
        "sha": "5a3728f49883c21c0e70ea6ecbab723d76e87fea",
        "filename": "src/qt/transactionrecord.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e07c943ce8df6c6cb3ece3fc676911ddb43ca184/src/qt/transactionrecord.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e07c943ce8df6c6cb3ece3fc676911ddb43ca184/src/qt/transactionrecord.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.cpp?ref=e07c943ce8df6c6cb3ece3fc676911ddb43ca184",
        "patch": "@@ -150,6 +150,7 @@ QList<TransactionRecord> TransactionRecord::decomposeTransaction(const CWallet *\n \n void TransactionRecord::updateStatus(const CWalletTx &wtx)\n {\n+    AssertLockHeld(cs_main);\n     // Determine transaction status\n \n     // Find the block the tx is in\n@@ -234,6 +235,7 @@ void TransactionRecord::updateStatus(const CWalletTx &wtx)\n \n bool TransactionRecord::statusUpdateNeeded()\n {\n+    AssertLockHeld(cs_main);\n     return status.cur_num_blocks != chainActive.Height();\n }\n "
      }
    ]
  },
  {
    "sha": "55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NWExZGI0ZmEyY2Y2MmI5NzY2ZWYzODJjMWUxNGIzZWNiZGY2N2Zl",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-04-15T15:38:25Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-04-18T10:49:41Z"
      },
      "message": "Solve chainActive-related locking issues\n\n- In wallet and GUI code LOCK cs_main as well as cs_wallet when\n  necessary\n- In main.cpp SendMessages move the TRY_LOCK(cs_main) up, to encompass the call\n  to IsInitialBlockDownload.\n- Make ActivateBestChain, AddToBlockIndex, IsInitialBlockDownload,\n  InitBlockIndex acquire the cs_main lock\n\nFixes #3997",
      "tree": {
        "sha": "1ff19f533ab0221e27dd16c3d401c4d54dfbca7b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1ff19f533ab0221e27dd16c3d401c4d54dfbca7b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e07c943ce8df6c6cb3ece3fc676911ddb43ca184",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e07c943ce8df6c6cb3ece3fc676911ddb43ca184",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e07c943ce8df6c6cb3ece3fc676911ddb43ca184"
      }
    ],
    "stats": {
      "total": 507,
      "additions": 252,
      "deletions": 255
    },
    "files": [
      {
        "sha": "0bbe8337051602c6b5e70cb695fca69737eceef2",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe",
        "patch": "@@ -1310,7 +1310,7 @@ int GetNumBlocksOfPeers()\n \n bool IsInitialBlockDownload()\n {\n-    AssertLockHeld(cs_main);\n+    LOCK(cs_main);\n     if (fImporting || fReindex || chainActive.Height() < Checkpoints::GetTotalBlocksEstimate())\n         return true;\n     static int64_t nLastUpdate;\n@@ -2087,7 +2087,7 @@ void static FindMostWorkChain() {\n \n // Try to activate to the most-work chain (thereby connecting it).\n bool ActivateBestChain(CValidationState &state) {\n-    AssertLockHeld(cs_main);\n+    LOCK(cs_main);\n     CBlockIndex *pindexOldTip = chainActive.Tip();\n     bool fComplete = false;\n     while (!fComplete) {\n@@ -2136,7 +2136,6 @@ bool ActivateBestChain(CValidationState &state) {\n \n bool AddToBlockIndex(CBlock& block, CValidationState& state, const CDiskBlockPos& pos)\n {\n-    AssertLockHeld(cs_main);\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n     if (mapBlockIndex.count(hash))\n@@ -2173,6 +2172,7 @@ bool AddToBlockIndex(CBlock& block, CValidationState& state, const CDiskBlockPos\n     if (!ActivateBestChain(state))\n         return false;\n \n+    LOCK(cs_main);\n     if (pindexNew == chainActive.Tip())\n     {\n         // Clear fork warning if its no longer applicable\n@@ -2962,6 +2962,7 @@ bool LoadBlockIndex()\n \n \n bool InitBlockIndex() {\n+    LOCK(cs_main);\n     // Check whether we're already initialized\n     if (chainActive.Genesis() != NULL)\n         return true;\n@@ -4201,6 +4202,10 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n             }\n         }\n \n+        TRY_LOCK(cs_main, lockMain); // Acquire cs_main for IsInitialBlockDownload() and CNodeState()\n+        if (!lockMain)\n+            return true;\n+\n         // Address refresh broadcast\n         static int64_t nLastRebroadcast;\n         if (!IsInitialBlockDownload() && (GetTime() - nLastRebroadcast > 24 * 60 * 60))\n@@ -4251,10 +4256,6 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n                 pto->PushMessage(\"addr\", vAddr);\n         }\n \n-        TRY_LOCK(cs_main, lockMain);\n-        if (!lockMain)\n-            return true;\n-\n         CNodeState &state = *State(pto->GetId());\n         if (state.fShouldBan) {\n             if (pto->addr.IsLocal())"
      },
      {
        "sha": "287296644c27ad94a76d003eb564b3c2c05c5502",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe",
        "patch": "@@ -55,6 +55,7 @@ int ClientModel::getNumConnections(unsigned int flags) const\n \n int ClientModel::getNumBlocks() const\n {\n+    LOCK(cs_main);\n     return chainActive.Height();\n }\n \n@@ -76,6 +77,7 @@ quint64 ClientModel::getTotalBytesSent() const\n \n QDateTime ClientModel::getLastBlockDate() const\n {\n+    LOCK(cs_main);\n     if (chainActive.Tip())\n         return QDateTime::fromTime_t(chainActive.Tip()->GetBlockTime());\n     else\n@@ -84,6 +86,7 @@ QDateTime ClientModel::getLastBlockDate() const\n \n double ClientModel::getVerificationProgress() const\n {\n+    LOCK(cs_main);\n     return Checkpoints::GuessVerificationProgress(chainActive.Tip());\n }\n "
      },
      {
        "sha": "45fb3d40c2ae6c603edadb3bb70b35477aacd371",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 200,
        "deletions": 205,
        "changes": 405,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe",
        "patch": "@@ -46,263 +46,258 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, int vout, int u\n {\n     QString strHTML;\n \n+    LOCK2(cs_main, wallet->cs_wallet);\n+    strHTML.reserve(4000);\n+    strHTML += \"<html><font face='verdana, arial, helvetica, sans-serif'>\";\n+\n+    int64_t nTime = wtx.GetTxTime();\n+    int64_t nCredit = wtx.GetCredit();\n+    int64_t nDebit = wtx.GetDebit();\n+    int64_t nNet = nCredit - nDebit;\n+\n+    strHTML += \"<b>\" + tr(\"Status\") + \":</b> \" + FormatTxStatus(wtx);\n+    int nRequests = wtx.GetRequestCount();\n+    if (nRequests != -1)\n     {\n-        LOCK(wallet->cs_wallet);\n-        strHTML.reserve(4000);\n-        strHTML += \"<html><font face='verdana, arial, helvetica, sans-serif'>\";\n-\n-        int64_t nTime = wtx.GetTxTime();\n-        int64_t nCredit = wtx.GetCredit();\n-        int64_t nDebit = wtx.GetDebit();\n-        int64_t nNet = nCredit - nDebit;\n-\n-        strHTML += \"<b>\" + tr(\"Status\") + \":</b> \" + FormatTxStatus(wtx);\n-        int nRequests = wtx.GetRequestCount();\n-        if (nRequests != -1)\n-        {\n-            if (nRequests == 0)\n-                strHTML += tr(\", has not been successfully broadcast yet\");\n-            else if (nRequests > 0)\n-                strHTML += tr(\", broadcast through %n node(s)\", \"\", nRequests);\n-        }\n-        strHTML += \"<br>\";\n+        if (nRequests == 0)\n+            strHTML += tr(\", has not been successfully broadcast yet\");\n+        else if (nRequests > 0)\n+            strHTML += tr(\", broadcast through %n node(s)\", \"\", nRequests);\n+    }\n+    strHTML += \"<br>\";\n \n-        strHTML += \"<b>\" + tr(\"Date\") + \":</b> \" + (nTime ? GUIUtil::dateTimeStr(nTime) : \"\") + \"<br>\";\n+    strHTML += \"<b>\" + tr(\"Date\") + \":</b> \" + (nTime ? GUIUtil::dateTimeStr(nTime) : \"\") + \"<br>\";\n \n-        //\n-        // From\n-        //\n-        if (wtx.IsCoinBase())\n-        {\n-            strHTML += \"<b>\" + tr(\"Source\") + \":</b> \" + tr(\"Generated\") + \"<br>\";\n-        }\n-        else if (wtx.mapValue.count(\"from\") && !wtx.mapValue[\"from\"].empty())\n-        {\n-            // Online transaction\n-            strHTML += \"<b>\" + tr(\"From\") + \":</b> \" + GUIUtil::HtmlEscape(wtx.mapValue[\"from\"]) + \"<br>\";\n-        }\n-        else\n+    //\n+    // From\n+    //\n+    if (wtx.IsCoinBase())\n+    {\n+        strHTML += \"<b>\" + tr(\"Source\") + \":</b> \" + tr(\"Generated\") + \"<br>\";\n+    }\n+    else if (wtx.mapValue.count(\"from\") && !wtx.mapValue[\"from\"].empty())\n+    {\n+        // Online transaction\n+        strHTML += \"<b>\" + tr(\"From\") + \":</b> \" + GUIUtil::HtmlEscape(wtx.mapValue[\"from\"]) + \"<br>\";\n+    }\n+    else\n+    {\n+        // Offline transaction\n+        if (nNet > 0)\n         {\n-            // Offline transaction\n-            if (nNet > 0)\n+            // Credit\n+            BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n             {\n-                // Credit\n-                BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n+                if (wallet->IsMine(txout))\n                 {\n-                    if (wallet->IsMine(txout))\n+                    CTxDestination address;\n+                    if (ExtractDestination(txout.scriptPubKey, address) && IsMine(*wallet, address))\n                     {\n-                        CTxDestination address;\n-                        if (ExtractDestination(txout.scriptPubKey, address) && IsMine(*wallet, address))\n+                        if (wallet->mapAddressBook.count(address))\n                         {\n-                            if (wallet->mapAddressBook.count(address))\n-                            {\n-                                strHTML += \"<b>\" + tr(\"From\") + \":</b> \" + tr(\"unknown\") + \"<br>\";\n-                                strHTML += \"<b>\" + tr(\"To\") + \":</b> \";\n-                                strHTML += GUIUtil::HtmlEscape(CBitcoinAddress(address).ToString());\n-                                if (!wallet->mapAddressBook[address].name.empty())\n-                                    strHTML += \" (\" + tr(\"own address\") + \", \" + tr(\"label\") + \": \" + GUIUtil::HtmlEscape(wallet->mapAddressBook[address].name) + \")\";\n-                                else\n-                                    strHTML += \" (\" + tr(\"own address\") + \")\";\n-                                strHTML += \"<br>\";\n-                            }\n+                            strHTML += \"<b>\" + tr(\"From\") + \":</b> \" + tr(\"unknown\") + \"<br>\";\n+                            strHTML += \"<b>\" + tr(\"To\") + \":</b> \";\n+                            strHTML += GUIUtil::HtmlEscape(CBitcoinAddress(address).ToString());\n+                            if (!wallet->mapAddressBook[address].name.empty())\n+                                strHTML += \" (\" + tr(\"own address\") + \", \" + tr(\"label\") + \": \" + GUIUtil::HtmlEscape(wallet->mapAddressBook[address].name) + \")\";\n+                            else\n+                                strHTML += \" (\" + tr(\"own address\") + \")\";\n+                            strHTML += \"<br>\";\n                         }\n-                        break;\n                     }\n+                    break;\n                 }\n             }\n         }\n+    }\n+\n+    //\n+    // To\n+    //\n+    if (wtx.mapValue.count(\"to\") && !wtx.mapValue[\"to\"].empty())\n+    {\n+        // Online transaction\n+        std::string strAddress = wtx.mapValue[\"to\"];\n+        strHTML += \"<b>\" + tr(\"To\") + \":</b> \";\n+        CTxDestination dest = CBitcoinAddress(strAddress).Get();\n+        if (wallet->mapAddressBook.count(dest) && !wallet->mapAddressBook[dest].name.empty())\n+            strHTML += GUIUtil::HtmlEscape(wallet->mapAddressBook[dest].name) + \" \";\n+        strHTML += GUIUtil::HtmlEscape(strAddress) + \"<br>\";\n+    }\n \n+    //\n+    // Amount\n+    //\n+    if (wtx.IsCoinBase() && nCredit == 0)\n+    {\n         //\n-        // To\n+        // Coinbase\n         //\n-        if (wtx.mapValue.count(\"to\") && !wtx.mapValue[\"to\"].empty())\n-        {\n-            // Online transaction\n-            std::string strAddress = wtx.mapValue[\"to\"];\n-            strHTML += \"<b>\" + tr(\"To\") + \":</b> \";\n-            CTxDestination dest = CBitcoinAddress(strAddress).Get();\n-            if (wallet->mapAddressBook.count(dest) && !wallet->mapAddressBook[dest].name.empty())\n-                strHTML += GUIUtil::HtmlEscape(wallet->mapAddressBook[dest].name) + \" \";\n-            strHTML += GUIUtil::HtmlEscape(strAddress) + \"<br>\";\n-        }\n-\n+        int64_t nUnmatured = 0;\n+        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n+            nUnmatured += wallet->GetCredit(txout);\n+        strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \";\n+        if (wtx.IsInMainChain())\n+            strHTML += BitcoinUnits::formatWithUnit(unit, nUnmatured)+ \" (\" + tr(\"matures in %n more block(s)\", \"\", wtx.GetBlocksToMaturity()) + \")\";\n+        else\n+            strHTML += \"(\" + tr(\"not accepted\") + \")\";\n+        strHTML += \"<br>\";\n+    }\n+    else if (nNet > 0)\n+    {\n         //\n-        // Amount\n+        // Credit\n         //\n-        if (wtx.IsCoinBase() && nCredit == 0)\n-        {\n-            //\n-            // Coinbase\n-            //\n-            int64_t nUnmatured = 0;\n-            BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-                nUnmatured += wallet->GetCredit(txout);\n-            strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \";\n-            if (wtx.IsInMainChain())\n-                strHTML += BitcoinUnits::formatWithUnit(unit, nUnmatured)+ \" (\" + tr(\"matures in %n more block(s)\", \"\", wtx.GetBlocksToMaturity()) + \")\";\n-            else\n-                strHTML += \"(\" + tr(\"not accepted\") + \")\";\n-            strHTML += \"<br>\";\n-        }\n-        else if (nNet > 0)\n+        strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, nNet) + \"<br>\";\n+    }\n+    else\n+    {\n+        bool fAllFromMe = true;\n+        BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n+            fAllFromMe = fAllFromMe && wallet->IsMine(txin);\n+\n+        bool fAllToMe = true;\n+        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n+            fAllToMe = fAllToMe && wallet->IsMine(txout);\n+\n+        if (fAllFromMe)\n         {\n             //\n-            // Credit\n+            // Debit\n             //\n-            strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, nNet) + \"<br>\";\n-        }\n-        else\n-        {\n-            bool fAllFromMe = true;\n-            BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n-                fAllFromMe = fAllFromMe && wallet->IsMine(txin);\n-\n-            bool fAllToMe = true;\n             BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-                fAllToMe = fAllToMe && wallet->IsMine(txout);\n-\n-            if (fAllFromMe)\n             {\n-                //\n-                // Debit\n-                //\n-                BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-                {\n-                    if (wallet->IsMine(txout))\n-                        continue;\n+                if (wallet->IsMine(txout))\n+                    continue;\n \n-                    if (!wtx.mapValue.count(\"to\") || wtx.mapValue[\"to\"].empty())\n+                if (!wtx.mapValue.count(\"to\") || wtx.mapValue[\"to\"].empty())\n+                {\n+                    // Offline transaction\n+                    CTxDestination address;\n+                    if (ExtractDestination(txout.scriptPubKey, address))\n                     {\n-                        // Offline transaction\n-                        CTxDestination address;\n-                        if (ExtractDestination(txout.scriptPubKey, address))\n-                        {\n-                            strHTML += \"<b>\" + tr(\"To\") + \":</b> \";\n-                            if (wallet->mapAddressBook.count(address) && !wallet->mapAddressBook[address].name.empty())\n-                                strHTML += GUIUtil::HtmlEscape(wallet->mapAddressBook[address].name) + \" \";\n-                            strHTML += GUIUtil::HtmlEscape(CBitcoinAddress(address).ToString());\n-                            strHTML += \"<br>\";\n-                        }\n+                        strHTML += \"<b>\" + tr(\"To\") + \":</b> \";\n+                        if (wallet->mapAddressBook.count(address) && !wallet->mapAddressBook[address].name.empty())\n+                            strHTML += GUIUtil::HtmlEscape(wallet->mapAddressBook[address].name) + \" \";\n+                        strHTML += GUIUtil::HtmlEscape(CBitcoinAddress(address).ToString());\n+                        strHTML += \"<br>\";\n                     }\n-\n-                    strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, -txout.nValue) + \"<br>\";\n-                }\n-\n-                if (fAllToMe)\n-                {\n-                    // Payment to self\n-                    int64_t nChange = wtx.GetChange();\n-                    int64_t nValue = nCredit - nChange;\n-                    strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, -nValue) + \"<br>\";\n-                    strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, nValue) + \"<br>\";\n                 }\n \n-                int64_t nTxFee = nDebit - wtx.GetValueOut();\n-                if (nTxFee > 0)\n-                    strHTML += \"<b>\" + tr(\"Transaction fee\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, -nTxFee) + \"<br>\";\n+                strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, -txout.nValue) + \"<br>\";\n             }\n-            else\n+\n+            if (fAllToMe)\n             {\n-                //\n-                // Mixed debit transaction\n-                //\n-                BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n-                    if (wallet->IsMine(txin))\n-                        strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, -wallet->GetDebit(txin)) + \"<br>\";\n-                BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-                    if (wallet->IsMine(txout))\n-                        strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, wallet->GetCredit(txout)) + \"<br>\";\n+                // Payment to self\n+                int64_t nChange = wtx.GetChange();\n+                int64_t nValue = nCredit - nChange;\n+                strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, -nValue) + \"<br>\";\n+                strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, nValue) + \"<br>\";\n             }\n+\n+            int64_t nTxFee = nDebit - wtx.GetValueOut();\n+            if (nTxFee > 0)\n+                strHTML += \"<b>\" + tr(\"Transaction fee\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, -nTxFee) + \"<br>\";\n         }\n+        else\n+        {\n+            //\n+            // Mixed debit transaction\n+            //\n+            BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n+                if (wallet->IsMine(txin))\n+                    strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, -wallet->GetDebit(txin)) + \"<br>\";\n+            BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n+                if (wallet->IsMine(txout))\n+                    strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, wallet->GetCredit(txout)) + \"<br>\";\n+        }\n+    }\n \n-        strHTML += \"<b>\" + tr(\"Net amount\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, nNet, true) + \"<br>\";\n+    strHTML += \"<b>\" + tr(\"Net amount\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, nNet, true) + \"<br>\";\n \n-        //\n-        // Message\n-        //\n-        if (wtx.mapValue.count(\"message\") && !wtx.mapValue[\"message\"].empty())\n-            strHTML += \"<br><b>\" + tr(\"Message\") + \":</b><br>\" + GUIUtil::HtmlEscape(wtx.mapValue[\"message\"], true) + \"<br>\";\n-        if (wtx.mapValue.count(\"comment\") && !wtx.mapValue[\"comment\"].empty())\n-            strHTML += \"<br><b>\" + tr(\"Comment\") + \":</b><br>\" + GUIUtil::HtmlEscape(wtx.mapValue[\"comment\"], true) + \"<br>\";\n+    //\n+    // Message\n+    //\n+    if (wtx.mapValue.count(\"message\") && !wtx.mapValue[\"message\"].empty())\n+        strHTML += \"<br><b>\" + tr(\"Message\") + \":</b><br>\" + GUIUtil::HtmlEscape(wtx.mapValue[\"message\"], true) + \"<br>\";\n+    if (wtx.mapValue.count(\"comment\") && !wtx.mapValue[\"comment\"].empty())\n+        strHTML += \"<br><b>\" + tr(\"Comment\") + \":</b><br>\" + GUIUtil::HtmlEscape(wtx.mapValue[\"comment\"], true) + \"<br>\";\n \n-        strHTML += \"<b>\" + tr(\"Transaction ID\") + \":</b> \" + TransactionRecord::formatSubTxId(wtx.GetHash(), vout) + \"<br>\";\n+    strHTML += \"<b>\" + tr(\"Transaction ID\") + \":</b> \" + TransactionRecord::formatSubTxId(wtx.GetHash(), vout) + \"<br>\";\n \n-        // Message from normal bitcoin:URI (bitcoin:123...?message=example)\n-        foreach (const PAIRTYPE(string, string)& r, wtx.vOrderForm)\n-            if (r.first == \"Message\")\n-                strHTML += \"<br><b>\" + tr(\"Message\") + \":</b><br>\" + GUIUtil::HtmlEscape(r.second, true) + \"<br>\";\n+    // Message from normal bitcoin:URI (bitcoin:123...?message=example)\n+    foreach (const PAIRTYPE(string, string)& r, wtx.vOrderForm)\n+        if (r.first == \"Message\")\n+            strHTML += \"<br><b>\" + tr(\"Message\") + \":</b><br>\" + GUIUtil::HtmlEscape(r.second, true) + \"<br>\";\n \n-        //\n-        // PaymentRequest info:\n-        //\n-        foreach (const PAIRTYPE(string, string)& r, wtx.vOrderForm)\n+    //\n+    // PaymentRequest info:\n+    //\n+    foreach (const PAIRTYPE(string, string)& r, wtx.vOrderForm)\n+    {\n+        if (r.first == \"PaymentRequest\")\n         {\n-            if (r.first == \"PaymentRequest\")\n-            {\n-                PaymentRequestPlus req;\n-                req.parse(QByteArray::fromRawData(r.second.data(), r.second.size()));\n-                QString merchant;\n-                if (req.getMerchant(PaymentServer::getCertStore(), merchant))\n-                    strHTML += \"<b>\" + tr(\"Merchant\") + \":</b> \" + GUIUtil::HtmlEscape(merchant) + \"<br>\";\n-            }\n+            PaymentRequestPlus req;\n+            req.parse(QByteArray::fromRawData(r.second.data(), r.second.size()));\n+            QString merchant;\n+            if (req.getMerchant(PaymentServer::getCertStore(), merchant))\n+                strHTML += \"<b>\" + tr(\"Merchant\") + \":</b> \" + GUIUtil::HtmlEscape(merchant) + \"<br>\";\n         }\n+    }\n \n-        if (wtx.IsCoinBase())\n-        {\n-            quint32 numBlocksToMaturity = COINBASE_MATURITY +  1;\n-            strHTML += \"<br>\" + tr(\"Generated coins must mature %1 blocks before they can be spent. When you generated this block, it was broadcast to the network to be added to the block chain. If it fails to get into the chain, its state will change to \\\"not accepted\\\" and it won't be spendable. This may occasionally happen if another node generates a block within a few seconds of yours.\").arg(QString::number(numBlocksToMaturity)) + \"<br>\";\n-        }\n+    if (wtx.IsCoinBase())\n+    {\n+        quint32 numBlocksToMaturity = COINBASE_MATURITY +  1;\n+        strHTML += \"<br>\" + tr(\"Generated coins must mature %1 blocks before they can be spent. When you generated this block, it was broadcast to the network to be added to the block chain. If it fails to get into the chain, its state will change to \\\"not accepted\\\" and it won't be spendable. This may occasionally happen if another node generates a block within a few seconds of yours.\").arg(QString::number(numBlocksToMaturity)) + \"<br>\";\n+    }\n \n-        //\n-        // Debug view\n-        //\n-        if (fDebug)\n-        {\n-            strHTML += \"<hr><br>\" + tr(\"Debug information\") + \"<br><br>\";\n-            BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n-                if(wallet->IsMine(txin))\n-                    strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, -wallet->GetDebit(txin)) + \"<br>\";\n-            BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-                if(wallet->IsMine(txout))\n-                    strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, wallet->GetCredit(txout)) + \"<br>\";\n+    //\n+    // Debug view\n+    //\n+    if (fDebug)\n+    {\n+        strHTML += \"<hr><br>\" + tr(\"Debug information\") + \"<br><br>\";\n+        BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n+            if(wallet->IsMine(txin))\n+                strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, -wallet->GetDebit(txin)) + \"<br>\";\n+        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n+            if(wallet->IsMine(txout))\n+                strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, wallet->GetCredit(txout)) + \"<br>\";\n+\n+        strHTML += \"<br><b>\" + tr(\"Transaction\") + \":</b><br>\";\n+        strHTML += GUIUtil::HtmlEscape(wtx.ToString(), true);\n \n-            strHTML += \"<br><b>\" + tr(\"Transaction\") + \":</b><br>\";\n-            strHTML += GUIUtil::HtmlEscape(wtx.ToString(), true);\n+        strHTML += \"<br><b>\" + tr(\"Inputs\") + \":</b>\";\n+        strHTML += \"<ul>\";\n \n-            strHTML += \"<br><b>\" + tr(\"Inputs\") + \":</b>\";\n-            strHTML += \"<ul>\";\n+        BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n+        {\n+            COutPoint prevout = txin.prevout;\n \n+            CCoins prev;\n+            if(pcoinsTip->GetCoins(prevout.hash, prev))\n             {\n-                LOCK(wallet->cs_wallet);\n-                BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n+                if (prevout.n < prev.vout.size())\n                 {\n-                    COutPoint prevout = txin.prevout;\n-\n-                    CCoins prev;\n-                    if(pcoinsTip->GetCoins(prevout.hash, prev))\n+                    strHTML += \"<li>\";\n+                    const CTxOut &vout = prev.vout[prevout.n];\n+                    CTxDestination address;\n+                    if (ExtractDestination(vout.scriptPubKey, address))\n                     {\n-                        if (prevout.n < prev.vout.size())\n-                        {\n-                            strHTML += \"<li>\";\n-                            const CTxOut &vout = prev.vout[prevout.n];\n-                            CTxDestination address;\n-                            if (ExtractDestination(vout.scriptPubKey, address))\n-                            {\n-                                if (wallet->mapAddressBook.count(address) && !wallet->mapAddressBook[address].name.empty())\n-                                    strHTML += GUIUtil::HtmlEscape(wallet->mapAddressBook[address].name) + \" \";\n-                                strHTML += QString::fromStdString(CBitcoinAddress(address).ToString());\n-                            }\n-                            strHTML = strHTML + \" \" + tr(\"Amount\") + \"=\" + BitcoinUnits::formatWithUnit(unit, vout.nValue);\n-                            strHTML = strHTML + \" IsMine=\" + (wallet->IsMine(vout) ? tr(\"true\") : tr(\"false\")) + \"</li>\";\n-                        }\n+                        if (wallet->mapAddressBook.count(address) && !wallet->mapAddressBook[address].name.empty())\n+                            strHTML += GUIUtil::HtmlEscape(wallet->mapAddressBook[address].name) + \" \";\n+                        strHTML += QString::fromStdString(CBitcoinAddress(address).ToString());\n                     }\n+                    strHTML = strHTML + \" \" + tr(\"Amount\") + \"=\" + BitcoinUnits::formatWithUnit(unit, vout.nValue);\n+                    strHTML = strHTML + \" IsMine=\" + (wallet->IsMine(vout) ? tr(\"true\") : tr(\"false\")) + \"</li>\";\n                 }\n             }\n-\n-            strHTML += \"</ul>\";\n         }\n \n-        strHTML += \"</font></html>\";\n+        strHTML += \"</ul>\";\n     }\n+\n+    strHTML += \"</font></html>\";\n     return strHTML;\n }"
      },
      {
        "sha": "aaecf88c2582fc4c0c06be67dd8369a44fd68036",
        "filename": "src/qt/transactiontablemodel.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 26,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe/src/qt/transactiontablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe/src/qt/transactiontablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.cpp?ref=55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe",
        "patch": "@@ -78,7 +78,7 @@ class TransactionTablePriv\n         qDebug() << \"TransactionTablePriv::refreshWallet\";\n         cachedWallet.clear();\n         {\n-            LOCK(wallet->cs_wallet);\n+            LOCK2(cs_main, wallet->cs_wallet);\n             for(std::map<uint256, CWalletTx>::iterator it = wallet->mapWallet.begin(); it != wallet->mapWallet.end(); ++it)\n             {\n                 if(TransactionRecord::showTransaction(it->second))\n@@ -96,7 +96,7 @@ class TransactionTablePriv\n     {\n         qDebug() << \"TransactionTablePriv::updateWallet : \" + QString::fromStdString(hash.ToString()) + \" \" + QString::number(status);\n         {\n-            LOCK(wallet->cs_wallet);\n+            LOCK2(cs_main, wallet->cs_wallet);\n \n             // Find transaction in wallet\n             std::map<uint256, CWalletTx>::iterator mi = wallet->mapWallet.find(hash);\n@@ -190,16 +190,14 @@ class TransactionTablePriv\n             // If a status update is needed (blocks came in since last check),\n             //  update the status of this transaction from the wallet. Otherwise,\n             // simply re-use the cached status.\n+            LOCK2(cs_main, wallet->cs_wallet);\n             if(rec->statusUpdateNeeded())\n             {\n-                {\n-                    LOCK(wallet->cs_wallet);\n-                    std::map<uint256, CWalletTx>::iterator mi = wallet->mapWallet.find(rec->hash);\n+                std::map<uint256, CWalletTx>::iterator mi = wallet->mapWallet.find(rec->hash);\n \n-                    if(mi != wallet->mapWallet.end())\n-                    {\n-                        rec->updateStatus(mi->second);\n-                    }\n+                if(mi != wallet->mapWallet.end())\n+                {\n+                    rec->updateStatus(mi->second);\n                 }\n             }\n             return rec;\n@@ -213,7 +211,7 @@ class TransactionTablePriv\n     QString describe(TransactionRecord *rec, int unit)\n     {\n         {\n-            LOCK(wallet->cs_wallet);\n+            LOCK2(cs_main, wallet->cs_wallet);\n             std::map<uint256, CWalletTx>::iterator mi = wallet->mapWallet.find(rec->hash);\n             if(mi != wallet->mapWallet.end())\n             {\n@@ -228,17 +226,12 @@ TransactionTableModel::TransactionTableModel(CWallet* wallet, WalletModel *paren\n         QAbstractTableModel(parent),\n         wallet(wallet),\n         walletModel(parent),\n-        priv(new TransactionTablePriv(wallet, this)),\n-        cachedNumBlocks(0)\n+        priv(new TransactionTablePriv(wallet, this))\n {\n     columns << QString() << tr(\"Date\") << tr(\"Type\") << tr(\"Address\") << tr(\"Amount\");\n \n     priv->refreshWallet();\n \n-    QTimer *timer = new QTimer(this);\n-    connect(timer, SIGNAL(timeout()), this, SLOT(updateConfirmations()));\n-    timer->start(MODEL_UPDATE_DELAY);\n-\n     connect(walletModel->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(updateDisplayUnit()));\n }\n \n@@ -257,16 +250,12 @@ void TransactionTableModel::updateTransaction(const QString &hash, int status)\n \n void TransactionTableModel::updateConfirmations()\n {\n-    if(chainActive.Height() != cachedNumBlocks)\n-    {\n-        cachedNumBlocks = chainActive.Height();\n-        // Blocks came in since last poll.\n-        // Invalidate status (number of confirmations) and (possibly) description\n-        //  for all rows. Qt is smart enough to only actually request the data for the\n-        //  visible rows.\n-        emit dataChanged(index(0, Status), index(priv->size()-1, Status));\n-        emit dataChanged(index(0, ToAddress), index(priv->size()-1, ToAddress));\n-    }\n+    // Blocks came in since last poll.\n+    // Invalidate status (number of confirmations) and (possibly) description\n+    //  for all rows. Qt is smart enough to only actually request the data for the\n+    //  visible rows.\n+    emit dataChanged(index(0, Status), index(priv->size()-1, Status));\n+    emit dataChanged(index(0, ToAddress), index(priv->size()-1, ToAddress));\n }\n \n int TransactionTableModel::rowCount(const QModelIndex &parent) const"
      },
      {
        "sha": "04b5291f422fec8d0767cc4695e6ec5d368e6ff3",
        "filename": "src/qt/transactiontablemodel.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe/src/qt/transactiontablemodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe/src/qt/transactiontablemodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.h?ref=55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe",
        "patch": "@@ -69,7 +69,6 @@ class TransactionTableModel : public QAbstractTableModel\n     WalletModel *walletModel;\n     QStringList columns;\n     TransactionTablePriv *priv;\n-    int cachedNumBlocks;\n \n     QString lookupAddress(const std::string &address, bool tooltip) const;\n     QVariant addressColor(const TransactionRecord *wtx) const;"
      },
      {
        "sha": "61f26107afc6a197913fb1d27d1d0c0c31bd6bbb",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 10,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe",
        "patch": "@@ -98,11 +98,21 @@ void WalletModel::updateStatus()\n \n void WalletModel::pollBalanceChanged()\n {\n-    if(chainActive.Height() != cachedNumBlocks)\n+    bool heightChanged = false;\n+    {\n+        LOCK(cs_main);\n+        if(chainActive.Height() != cachedNumBlocks)\n+        {\n+            // Balance and number of transactions might have changed\n+            cachedNumBlocks = chainActive.Height();\n+            heightChanged = true;\n+        }\n+    }\n+    if(heightChanged)\n     {\n-        // Balance and number of transactions might have changed\n-        cachedNumBlocks = chainActive.Height();\n         checkBalanceChanged();\n+        if(transactionTableModel)\n+            transactionTableModel->updateConfirmations();\n     }\n }\n \n@@ -520,7 +530,7 @@ bool WalletModel::getPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const\n // returns a list of COutputs from COutPoints\n void WalletModel::getOutputs(const std::vector<COutPoint>& vOutpoints, std::vector<COutput>& vOutputs)\n {\n-    LOCK(wallet->cs_wallet);\n+    LOCK2(cs_main, wallet->cs_wallet);\n     BOOST_FOREACH(const COutPoint& outpoint, vOutpoints)\n     {\n         if (!wallet->mapWallet.count(outpoint.hash)) continue;\n@@ -533,7 +543,7 @@ void WalletModel::getOutputs(const std::vector<COutPoint>& vOutpoints, std::vect\n \n bool WalletModel::isSpent(const COutPoint& outpoint) const\n {\n-    LOCK(wallet->cs_wallet);\n+    LOCK2(cs_main, wallet->cs_wallet);\n     return wallet->IsSpent(outpoint.hash, outpoint.n);\n }\n \n@@ -543,7 +553,7 @@ void WalletModel::listCoins(std::map<QString, std::vector<COutput> >& mapCoins)\n     std::vector<COutput> vCoins;\n     wallet->AvailableCoins(vCoins);\n \n-    LOCK(wallet->cs_wallet); // ListLockedCoins, mapWallet\n+    LOCK2(cs_main, wallet->cs_wallet); // ListLockedCoins, mapWallet\n     std::vector<COutPoint> vLockedCoins;\n     wallet->ListLockedCoins(vLockedCoins);\n \n@@ -575,25 +585,25 @@ void WalletModel::listCoins(std::map<QString, std::vector<COutput> >& mapCoins)\n \n bool WalletModel::isLockedCoin(uint256 hash, unsigned int n) const\n {\n-    LOCK(wallet->cs_wallet);\n+    LOCK2(cs_main, wallet->cs_wallet);\n     return wallet->IsLockedCoin(hash, n);\n }\n \n void WalletModel::lockCoin(COutPoint& output)\n {\n-    LOCK(wallet->cs_wallet);\n+    LOCK2(cs_main, wallet->cs_wallet);\n     wallet->LockCoin(output);\n }\n \n void WalletModel::unlockCoin(COutPoint& output)\n {\n-    LOCK(wallet->cs_wallet);\n+    LOCK2(cs_main, wallet->cs_wallet);\n     wallet->UnlockCoin(output);\n }\n \n void WalletModel::listLockedCoins(std::vector<COutPoint>& vOutpts)\n {\n-    LOCK(wallet->cs_wallet);\n+    LOCK2(cs_main, wallet->cs_wallet);\n     wallet->ListLockedCoins(vOutpts);\n }\n "
      },
      {
        "sha": "6b0c604a3457dd66e94bcd33efaae6c1df5cd000",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=55a1db4fa2cf62b9766ef382c1e14b3ecbdf67fe",
        "patch": "@@ -606,7 +606,7 @@ bool CWallet::AddToWalletIfInvolvingMe(const uint256 &hash, const CTransaction&\n \n void CWallet::SyncTransaction(const uint256 &hash, const CTransaction& tx, const CBlock* pblock)\n {\n-    LOCK(cs_wallet);\n+    LOCK2(cs_main, cs_wallet);\n     if (!AddToWalletIfInvolvingMe(hash, tx, pblock, true))\n         return; // Not one of ours\n \n@@ -834,7 +834,7 @@ int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n \n     CBlockIndex* pindex = pindexStart;\n     {\n-        LOCK(cs_wallet);\n+        LOCK2(cs_main, cs_wallet);\n \n         // no need to read and scan block, if block was created before\n         // our wallet birthday (as adjusted for block time variability)\n@@ -869,7 +869,7 @@ int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n \n void CWallet::ReacceptWalletTransactions()\n {\n-    LOCK(cs_wallet);\n+    LOCK2(cs_main, cs_wallet);\n     BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n     {\n         const uint256& wtxid = item.first;\n@@ -964,7 +964,7 @@ int64_t CWallet::GetBalance() const\n {\n     int64_t nTotal = 0;\n     {\n-        LOCK(cs_wallet);\n+        LOCK2(cs_main, cs_wallet);\n         for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n@@ -980,7 +980,7 @@ int64_t CWallet::GetUnconfirmedBalance() const\n {\n     int64_t nTotal = 0;\n     {\n-        LOCK(cs_wallet);\n+        LOCK2(cs_main, cs_wallet);\n         for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n@@ -995,7 +995,7 @@ int64_t CWallet::GetImmatureBalance() const\n {\n     int64_t nTotal = 0;\n     {\n-        LOCK(cs_wallet);\n+        LOCK2(cs_main, cs_wallet);\n         for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;"
      }
    ]
  }
]