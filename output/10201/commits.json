[
  {
    "sha": "24980a3e40284d375ac8c19da25fa399ee883830",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNDk4MGEzZTQwMjg0ZDM3NWFjOGMxOWRhMjVmYTM5OWVlODgzODMw",
    "commit": {
      "author": {
        "name": "Mario Dian",
        "email": "mariodian@gmail.com",
        "date": "2017-04-21T18:45:30Z"
      },
      "committer": {
        "name": "Mario Dian",
        "email": "mariodian@gmail.com",
        "date": "2017-06-06T14:21:30Z"
      },
      "message": "Make functions in validation.cpp static and pass chainparams\n\nFix bugs as per PR comment\n\nChange bool static to static bool",
      "tree": {
        "sha": "856884a0328cc0302f0fdc31b6df86f5dc810225",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/856884a0328cc0302f0fdc31b6df86f5dc810225"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/24980a3e40284d375ac8c19da25fa399ee883830",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/24980a3e40284d375ac8c19da25fa399ee883830",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/24980a3e40284d375ac8c19da25fa399ee883830",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/24980a3e40284d375ac8c19da25fa399ee883830/comments",
    "author": {
      "login": "mariodian",
      "id": 3636406,
      "node_id": "MDQ6VXNlcjM2MzY0MDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3636406?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mariodian",
      "html_url": "https://github.com/mariodian",
      "followers_url": "https://api.github.com/users/mariodian/followers",
      "following_url": "https://api.github.com/users/mariodian/following{/other_user}",
      "gists_url": "https://api.github.com/users/mariodian/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mariodian/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mariodian/subscriptions",
      "organizations_url": "https://api.github.com/users/mariodian/orgs",
      "repos_url": "https://api.github.com/users/mariodian/repos",
      "events_url": "https://api.github.com/users/mariodian/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mariodian/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mariodian",
      "id": 3636406,
      "node_id": "MDQ6VXNlcjM2MzY0MDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3636406?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mariodian",
      "html_url": "https://github.com/mariodian",
      "followers_url": "https://api.github.com/users/mariodian/followers",
      "following_url": "https://api.github.com/users/mariodian/following{/other_user}",
      "gists_url": "https://api.github.com/users/mariodian/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mariodian/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mariodian/subscriptions",
      "organizations_url": "https://api.github.com/users/mariodian/orgs",
      "repos_url": "https://api.github.com/users/mariodian/repos",
      "events_url": "https://api.github.com/users/mariodian/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mariodian/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "300f8e7a828f3ffaa3a3e9d979a6dc90f15d0203",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/300f8e7a828f3ffaa3a3e9d979a6dc90f15d0203",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/300f8e7a828f3ffaa3a3e9d979a6dc90f15d0203"
      }
    ],
    "stats": {
      "total": 151,
      "additions": 71,
      "deletions": 80
    },
    "files": [
      {
        "sha": "eaefa954113286d6863ebea8883c4d9c10103397",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 71,
        "deletions": 40,
        "changes": 111,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/24980a3e40284d375ac8c19da25fa399ee883830/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/24980a3e40284d375ac8c19da25fa399ee883830/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=24980a3e40284d375ac8c19da25fa399ee883830",
        "patch": "@@ -186,8 +186,11 @@ enum FlushStateMode {\n };\n \n // See definition for documentation\n-bool static FlushStateToDisk(CValidationState &state, FlushStateMode mode, int nManualPruneHeight=0);\n-void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight);\n+static bool FlushStateToDisk(const CChainParams& chainParams, CValidationState &state, FlushStateMode mode, int nManualPruneHeight=0);\n+static void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight);\n+static void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight);\n+static bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = NULL);\n+static FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n \n bool CheckFinalTx(const CTransaction &tx, int flags)\n {\n@@ -309,7 +312,7 @@ bool CheckSequenceLocks(const CTransaction &tx, int flags, LockPoints* lp, bool\n     return EvaluateSequenceLocks(index, lockPair);\n }\n \n-void LimitMempoolSize(CTxMemPool& pool, size_t limit, unsigned long age) {\n+static void LimitMempoolSize(CTxMemPool& pool, size_t limit, unsigned long age) {\n     int expired = pool.Expire(GetTime() - age);\n     if (expired != 0) {\n         LogPrint(BCLog::MEMPOOL, \"Expired %i transactions from the memory pool\\n\", expired);\n@@ -392,7 +395,7 @@ void UpdateMempoolForReorg(DisconnectedBlockTransactions &disconnectpool, bool f\n     LimitMempoolSize(mempool, GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n }\n \n-bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx, bool fLimitFree,\n+static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx, bool fLimitFree,\n                               bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n                               bool fOverrideMempoolLimit, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache)\n {\n@@ -410,7 +413,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         return state.DoS(100, false, REJECT_INVALID, \"coinbase\");\n \n     // Reject transactions with witness before segregated witness activates (override with -prematurewitness)\n-    bool witnessEnabled = IsWitnessEnabled(chainActive.Tip(), Params().GetConsensus());\n+    bool witnessEnabled = IsWitnessEnabled(chainActive.Tip(), chainparams.GetConsensus());\n     if (!GetBoolArg(\"-prematurewitness\",false) && tx.HasWitness() && !witnessEnabled) {\n         return state.DoS(0, false, REJECT_NONSTANDARD, \"no-witness-yet\", true);\n     }\n@@ -739,7 +742,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         }\n \n         unsigned int scriptVerifyFlags = STANDARD_SCRIPT_VERIFY_FLAGS;\n-        if (!Params().RequireStandard()) {\n+        if (!chainparams.RequireStandard()) {\n             scriptVerifyFlags = GetArg(\"-promiscuousmempoolflags\", scriptVerifyFlags);\n         }\n \n@@ -809,27 +812,29 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n     return true;\n }\n \n-bool AcceptToMemoryPoolWithTime(CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx, bool fLimitFree,\n+/** (try to) add transaction to memory pool with a specified acceptance time **/\n+static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx, bool fLimitFree,\n                         bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n                         bool fOverrideMempoolLimit, const CAmount nAbsurdFee)\n {\n     std::vector<COutPoint> coins_to_uncache;\n-    bool res = AcceptToMemoryPoolWorker(pool, state, tx, fLimitFree, pfMissingInputs, nAcceptTime, plTxnReplaced, fOverrideMempoolLimit, nAbsurdFee, coins_to_uncache);\n+    bool res = AcceptToMemoryPoolWorker(chainparams, pool, state, tx, fLimitFree, pfMissingInputs, nAcceptTime, plTxnReplaced, fOverrideMempoolLimit, nAbsurdFee, coins_to_uncache);\n     if (!res) {\n         BOOST_FOREACH(const COutPoint& hashTx, coins_to_uncache)\n             pcoinsTip->Uncache(hashTx);\n     }\n     // After we've (potentially) uncached entries, ensure our coins cache is still within its size limits\n     CValidationState stateDummy;\n-    FlushStateToDisk(stateDummy, FLUSH_STATE_PERIODIC);\n+    FlushStateToDisk(chainparams, stateDummy, FLUSH_STATE_PERIODIC);\n     return res;\n }\n \n bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx, bool fLimitFree,\n                         bool* pfMissingInputs, std::list<CTransactionRef>* plTxnReplaced,\n                         bool fOverrideMempoolLimit, const CAmount nAbsurdFee)\n {\n-    return AcceptToMemoryPoolWithTime(pool, state, tx, fLimitFree, pfMissingInputs, GetTime(), plTxnReplaced, fOverrideMempoolLimit, nAbsurdFee);\n+    const CChainParams& chainparams = Params();\n+    return AcceptToMemoryPoolWithTime(chainparams, pool, state, tx, fLimitFree, pfMissingInputs, GetTime(), plTxnReplaced, fOverrideMempoolLimit, nAbsurdFee);\n }\n \n /** Return transaction in txOut, and if it was found inside a block, its hash is placed in hashBlock */\n@@ -898,7 +903,7 @@ bool GetTransaction(const uint256 &hash, CTransactionRef &txOut, const Consensus\n // CBlock and CBlockIndex\n //\n \n-bool WriteBlockToDisk(const CBlock& block, CDiskBlockPos& pos, const CMessageHeader::MessageStartChars& messageStart)\n+static bool WriteBlockToDisk(const CBlock& block, CDiskBlockPos& pos, const CMessageHeader::MessageStartChars& messageStart)\n {\n     // Open history file to append\n     CAutoFile fileout(OpenBlockFile(pos), SER_DISK, CLIENT_VERSION);\n@@ -1011,7 +1016,7 @@ static void AlertNotify(const std::string& strMessage)\n     boost::thread t(runCommand, strCmd); // thread runs free\n }\n \n-void CheckForkWarningConditions()\n+static void CheckForkWarningConditions()\n {\n     AssertLockHeld(cs_main);\n     // Before we get past initial download, we cannot reliably alert about forks\n@@ -1052,7 +1057,7 @@ void CheckForkWarningConditions()\n     }\n }\n \n-void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip)\n+static void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip)\n {\n     AssertLockHeld(cs_main);\n     // If we are on a fork that is sufficiently large, set a warning flag\n@@ -1144,7 +1149,12 @@ int GetSpendHeight(const CCoinsViewCache& inputs)\n     return pindexPrev->nHeight + 1;\n }\n \n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)\n+/**\n+ * Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)\n+ * This does not modify the UTXO set. If pvChecks is not NULL, script checks are pushed onto it\n+ * instead of being performed inline.\n+ */\n+static bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)\n {\n     if (!tx.IsCoinBase())\n     {\n@@ -1411,7 +1421,7 @@ void static FlushBlockFile(bool fFinalize = false)\n     }\n }\n \n-bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigned int nAddSize);\n+static bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigned int nAddSize);\n \n static CCheckQueue<CScriptCheck> scriptcheckqueue(128);\n \n@@ -1730,9 +1740,8 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n  * if they're too large, if it's been a while since the last write,\n  * or always and in all cases if we're in prune mode and are deleting files.\n  */\n-bool static FlushStateToDisk(CValidationState &state, FlushStateMode mode, int nManualPruneHeight) {\n+bool static FlushStateToDisk(const CChainParams& chainparams, CValidationState &state, FlushStateMode mode, int nManualPruneHeight) {\n     int64_t nMempoolUsage = mempool.DynamicMemoryUsage();\n-    const CChainParams& chainparams = Params();\n     LOCK2(cs_main, cs_LastBlockFile);\n     static int64_t nLastWrite = 0;\n     static int64_t nLastFlush = 0;\n@@ -1836,13 +1845,15 @@ bool static FlushStateToDisk(CValidationState &state, FlushStateMode mode, int n\n \n void FlushStateToDisk() {\n     CValidationState state;\n-    FlushStateToDisk(state, FLUSH_STATE_ALWAYS);\n+    const CChainParams& chainparams = Params();\n+    FlushStateToDisk(chainparams, state, FLUSH_STATE_ALWAYS);\n }\n \n void PruneAndFlush() {\n     CValidationState state;\n     fCheckForPruning = true;\n-    FlushStateToDisk(state, FLUSH_STATE_NONE);\n+    const CChainParams& chainparams = Params();\n+    FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE);\n }\n \n static void DoWarning(const std::string& strWarning)\n@@ -1939,7 +1950,7 @@ bool static DisconnectTip(CValidationState& state, const CChainParams& chainpara\n     }\n     LogPrint(BCLog::BENCH, \"- Disconnect block: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n     // Write the chain state to disk, if necessary.\n-    if (!FlushStateToDisk(state, FLUSH_STATE_IF_NEEDED))\n+    if (!FlushStateToDisk(chainparams, state, FLUSH_STATE_IF_NEEDED))\n         return false;\n \n     if (disconnectpool) {\n@@ -2076,7 +2087,7 @@ bool static ConnectTip(CValidationState& state, const CChainParams& chainparams,\n     int64_t nTime4 = GetTimeMicros(); nTimeFlush += nTime4 - nTime3;\n     LogPrint(BCLog::BENCH, \"  - Flush: %.2fms [%.2fs]\\n\", (nTime4 - nTime3) * 0.001, nTimeFlush * 0.000001);\n     // Write the chain state to disk, if necessary.\n-    if (!FlushStateToDisk(state, FLUSH_STATE_IF_NEEDED))\n+    if (!FlushStateToDisk(chainparams, state, FLUSH_STATE_IF_NEEDED))\n         return false;\n     int64_t nTime5 = GetTimeMicros(); nTimeChainState += nTime5 - nTime4;\n     LogPrint(BCLog::BENCH, \"  - Writing chainstate: %.2fms [%.2fs]\\n\", (nTime5 - nTime4) * 0.001, nTimeChainState * 0.000001);\n@@ -2336,7 +2347,7 @@ bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams,\n     CheckBlockIndex(chainparams.GetConsensus());\n \n     // Write changes periodically to disk, after relay.\n-    if (!FlushStateToDisk(state, FLUSH_STATE_PERIODIC)) {\n+    if (!FlushStateToDisk(chainparams, state, FLUSH_STATE_PERIODIC)) {\n         return false;\n     }\n \n@@ -2453,7 +2464,7 @@ bool ResetBlockFailureFlags(CBlockIndex *pindex) {\n     return true;\n }\n \n-CBlockIndex* AddToBlockIndex(const CBlockHeader& block)\n+static CBlockIndex* AddToBlockIndex(const CBlockHeader& block)\n {\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n@@ -2537,7 +2548,7 @@ static bool ReceivedBlockTransactions(const CBlock &block, CValidationState& sta\n     return true;\n }\n \n-bool FindBlockPos(CValidationState &state, CDiskBlockPos &pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown = false)\n+static bool FindBlockPos(CValidationState &state, CDiskBlockPos &pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown = false)\n {\n     LOCK(cs_LastBlockFile);\n \n@@ -2594,7 +2605,7 @@ bool FindBlockPos(CValidationState &state, CDiskBlockPos &pos, unsigned int nAdd\n     return true;\n }\n \n-bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigned int nAddSize)\n+static bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigned int nAddSize)\n {\n     pos.nFile = nFile;\n \n@@ -2625,7 +2636,7 @@ bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigne\n     return true;\n }\n \n-bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW)\n+static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW = true)\n {\n     // Check proof of work matches claimed amount\n     if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))\n@@ -2775,7 +2786,10 @@ std::vector<unsigned char> GenerateCoinbaseCommitment(CBlock& block, const CBloc\n     return commitment;\n }\n \n-bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev, int64_t nAdjustedTime)\n+/** Context-dependent validity checks.\n+ *  By \"context\", we mean only the previous block headers, but not the UTXO\n+ *  set; UTXO-related validity checks are done in ConnectBlock(). */\n+static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev, int64_t nAdjustedTime)\n {\n     assert(pindexPrev != NULL);\n     const int nHeight = pindexPrev->nHeight + 1;\n@@ -2802,7 +2816,7 @@ bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& sta\n     return true;\n }\n \n-bool ContextualCheckBlock(const CBlock& block, CValidationState& state, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev)\n+static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev)\n {\n     const int nHeight = pindexPrev == NULL ? 0 : pindexPrev->nHeight + 1;\n \n@@ -3026,7 +3040,7 @@ static bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidation\n     }\n \n     if (fCheckForPruning)\n-        FlushStateToDisk(state, FLUSH_STATE_NONE); // we just allocated more disk space for block files\n+        FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE); // we just allocated more disk space for block files\n \n     return true;\n }\n@@ -3094,7 +3108,7 @@ bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams,\n  */\n \n /* Calculate the amount of disk space the block & undo files currently use */\n-uint64_t CalculateCurrentUsage()\n+static uint64_t CalculateCurrentUsage()\n {\n     uint64_t retval = 0;\n     BOOST_FOREACH(const CBlockFileInfo &file, vinfoBlockFile) {\n@@ -3147,7 +3161,7 @@ void UnlinkPrunedFiles(const std::set<int>& setFilesToPrune)\n }\n \n /* Calculate the block/rev files to delete based on height specified by user with RPC command pruneblockchain */\n-void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight)\n+static void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight)\n {\n     assert(fPruneMode && nManualPruneHeight > 0);\n \n@@ -3172,11 +3186,26 @@ void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeig\n void PruneBlockFilesManual(int nManualPruneHeight)\n {\n     CValidationState state;\n-    FlushStateToDisk(state, FLUSH_STATE_NONE, nManualPruneHeight);\n+    const CChainParams& chainparams = Params();\n+    FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE, nManualPruneHeight);\n }\n \n-/* Calculate the block/rev files that should be deleted to remain under target*/\n-void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight)\n+/**\n+ * Prune block and undo files (blk???.dat and undo???.dat) so that the disk space used is less than a user-defined target.\n+ * The user sets the target (in MB) on the command line or in config file.  This will be run on startup and whenever new\n+ * space is allocated in a block or undo file, staying below the target. Changing back to unpruned requires a reindex\n+ * (which in this case means the blockchain must be re-downloaded.)\n+ *\n+ * Pruning functions are called from FlushStateToDisk when the global fCheckForPruning flag has been set.\n+ * Block and undo files are deleted in lock-step (when blk00003.dat is deleted, so is rev00003.dat.)\n+ * Pruning cannot take place until the longest chain is at least a certain length (100000 on mainnet, 1000 on testnet, 1000 on regtest).\n+ * Pruning will never delete a block within a defined distance (currently 288) from the active chain's tip.\n+ * The block index is updated by unsetting HAVE_DATA and HAVE_UNDO for any blocks that were stored in the deleted files.\n+ * A db flag records the fact that at least some block files have been pruned.\n+ *\n+ * @param[out]   setFilesToPrune   The set of file indices that can be unlinked will be returned\n+ */\n+static void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight)\n {\n     LOCK2(cs_main, cs_LastBlockFile);\n     if (chainActive.Tip() == NULL || nPruneTarget == 0) {\n@@ -3234,7 +3263,7 @@ bool CheckDiskSpace(uint64_t nAdditionalBytes)\n     return true;\n }\n \n-FILE* OpenDiskFile(const CDiskBlockPos &pos, const char *prefix, bool fReadOnly)\n+static FILE* OpenDiskFile(const CDiskBlockPos &pos, const char *prefix, bool fReadOnly)\n {\n     if (pos.IsNull())\n         return NULL;\n@@ -3261,7 +3290,8 @@ FILE* OpenBlockFile(const CDiskBlockPos &pos, bool fReadOnly) {\n     return OpenDiskFile(pos, \"blk\", fReadOnly);\n }\n \n-FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly) {\n+/** Open an undo file (rev?????.dat) */\n+static FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly) {\n     return OpenDiskFile(pos, \"rev\", fReadOnly);\n }\n \n@@ -3533,7 +3563,7 @@ bool RewindBlockIndex(const CChainParams& params)\n             return error(\"RewindBlockIndex: unable to disconnect block at height %i\", pindex->nHeight);\n         }\n         // Occasionally flush state to disk.\n-        if (!FlushStateToDisk(state, FLUSH_STATE_PERIODIC))\n+        if (!FlushStateToDisk(params, state, FLUSH_STATE_PERIODIC))\n             return false;\n     }\n \n@@ -3582,7 +3612,7 @@ bool RewindBlockIndex(const CChainParams& params)\n \n     CheckBlockIndex(params.GetConsensus());\n \n-    if (!FlushStateToDisk(state, FLUSH_STATE_ALWAYS)) {\n+    if (!FlushStateToDisk(params, state, FLUSH_STATE_ALWAYS)) {\n         return false;\n     }\n \n@@ -3655,7 +3685,7 @@ bool InitBlockIndex(const CChainParams& chainparams)\n             if (!ReceivedBlockTransactions(block, state, pindex, blockPos, chainparams.GetConsensus()))\n                 return error(\"LoadBlockIndex(): genesis block not accepted\");\n             // Force a chainstate write so that when we VerifyDB in a moment, it doesn't check stale data\n-            return FlushStateToDisk(state, FLUSH_STATE_ALWAYS);\n+            return FlushStateToDisk(chainparams, state, FLUSH_STATE_ALWAYS);\n         } catch (const std::runtime_error& e) {\n             return error(\"LoadBlockIndex(): failed to initialize block database: %s\", e.what());\n         }\n@@ -3997,6 +4027,7 @@ static const uint64_t MEMPOOL_DUMP_VERSION = 1;\n \n bool LoadMempool(void)\n {\n+    const CChainParams& chainparams = Params();\n     int64_t nExpiryTimeout = GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60;\n     FILE* filestr = fsbridge::fopen(GetDataDir() / \"mempool.dat\", \"rb\");\n     CAutoFile file(filestr, SER_DISK, CLIENT_VERSION);\n@@ -4033,7 +4064,7 @@ bool LoadMempool(void)\n             CValidationState state;\n             if (nTime + nExpiryTimeout > nNow) {\n                 LOCK(cs_main);\n-                AcceptToMemoryPoolWithTime(mempool, state, tx, true, NULL, nTime);\n+                AcceptToMemoryPoolWithTime(chainparams, mempool, state, tx, true, NULL, nTime, NULL, false, 0);\n                 if (state.IsValid()) {\n                     ++count;\n                 } else {"
      },
      {
        "sha": "3a7f7cf1bc9528c6a4c45e2cc6ee9a55782cb440",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 0,
        "deletions": 40,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/24980a3e40284d375ac8c19da25fa399ee883830/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/24980a3e40284d375ac8c19da25fa399ee883830/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=24980a3e40284d375ac8c19da25fa399ee883830",
        "patch": "@@ -255,8 +255,6 @@ bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& block, CValidationS\n bool CheckDiskSpace(uint64_t nAdditionalBytes = 0);\n /** Open a block file (blk?????.dat) */\n FILE* OpenBlockFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n-/** Open an undo file (rev?????.dat) */\n-FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n /** Translation to a filesystem path */\n fs::path GetBlockPosFilename(const CDiskBlockPos &pos, const char *prefix);\n /** Import blocks from an external file */\n@@ -288,23 +286,6 @@ CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams);\n /** Guess verification progress (as a fraction between 0.0=genesis and 1.0=current tip). */\n double GuessVerificationProgress(const ChainTxData& data, CBlockIndex* pindex);\n \n-/**\n- * Prune block and undo files (blk???.dat and undo???.dat) so that the disk space used is less than a user-defined target.\n- * The user sets the target (in MB) on the command line or in config file.  This will be run on startup and whenever new\n- * space is allocated in a block or undo file, staying below the target. Changing back to unpruned requires a reindex\n- * (which in this case means the blockchain must be re-downloaded.)\n- *\n- * Pruning functions are called from FlushStateToDisk when the global fCheckForPruning flag has been set.\n- * Block and undo files are deleted in lock-step (when blk00003.dat is deleted, so is rev00003.dat.)\n- * Pruning cannot take place until the longest chain is at least a certain length (100000 on mainnet, 1000 on testnet, 1000 on regtest).\n- * Pruning will never delete a block within a defined distance (currently 288) from the active chain's tip.\n- * The block index is updated by unsetting HAVE_DATA and HAVE_UNDO for any blocks that were stored in the deleted files.\n- * A db flag records the fact that at least some block files have been pruned.\n- *\n- * @param[out]   setFilesToPrune   The set of file indices that can be unlinked will be returned\n- */\n-void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight);\n-\n /**\n  *  Mark one block file as pruned.\n  */\n@@ -330,11 +311,6 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                         bool* pfMissingInputs, std::list<CTransactionRef>* plTxnReplaced = NULL,\n                         bool fOverrideMempoolLimit=false, const CAmount nAbsurdFee=0);\n \n-/** (try to) add transaction to memory pool with a specified acceptance time **/\n-bool AcceptToMemoryPoolWithTime(CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx, bool fLimitFree,\n-                        bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced = NULL,\n-                        bool fOverrideMempoolLimit=false, const CAmount nAbsurdFee=0);\n-\n /** Convert CValidationState to a human-readable message for logging */\n std::string FormatStateMessage(const CValidationState &state);\n \n@@ -348,14 +324,6 @@ BIP9Stats VersionBitsTipStatistics(const Consensus::Params& params, Consensus::D\n int VersionBitsTipStateSinceHeight(const Consensus::Params& params, Consensus::DeploymentPos pos);\n \n \n-/**\n- * Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)\n- * This does not modify the UTXO set. If pvChecks is not NULL, script checks are pushed onto it\n- * instead of being performed inline.\n- */\n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &view, bool fScriptChecks,\n-                 unsigned int flags, bool cacheStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = NULL);\n-\n /** Apply the effects of this transaction on the UTXO set represented by view */\n void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, int nHeight);\n \n@@ -428,22 +396,14 @@ class CScriptCheck\n \n \n /** Functions for disk access for blocks */\n-bool WriteBlockToDisk(const CBlock& block, CDiskBlockPos& pos, const CMessageHeader::MessageStartChars& messageStart);\n bool ReadBlockFromDisk(CBlock& block, const CDiskBlockPos& pos, const Consensus::Params& consensusParams);\n bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex, const Consensus::Params& consensusParams);\n \n /** Functions for validating blocks and updating the block tree */\n \n /** Context-independent validity checks */\n-bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW = true);\n bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW = true, bool fCheckMerkleRoot = true);\n \n-/** Context-dependent validity checks.\n- *  By \"context\", we mean only the previous block headers, but not the UTXO\n- *  set; UTXO-related validity checks are done in ConnectBlock(). */\n-bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev, int64_t nAdjustedTime);\n-bool ContextualCheckBlock(const CBlock& block, CValidationState& state, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev);\n-\n /** Check a block is completely valid from start to finish (only works on top of our current best block, with cs_main held) */\n bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckPOW = true, bool fCheckMerkleRoot = true);\n "
      }
    ]
  }
]