ajtowns,2019-12-10 08:20:24,"Specifying the alignment requirement at the prevector level instead of for `prevector::_union` would also work (ie, `class alignas(char*) prevector {`) and would be a smaller change, but it would be more fragile (breaking if `N*sizeof(T)` isn't a multiple of `alignof(size_type)`, or `sizeof(size_type)*2` didn't match `alignof(char*)`) , so keeping the pack pragma covering only the code that it abs",https://github.com/bitcoin/bitcoin/pull/17708#issuecomment-563920041,563920041,
practicalswift,2019-12-10 09:00:43,"Concept ACK: it would be really nice to be able to run with UndefinedBehaviorSanitizer (UBSan) without having to use any suppressions. \n\nReviewers of this PR are encouraged to review also the related PR #17208 (""Make all tests pass UBSan without using any UBSan suppressions"").",https://github.com/bitcoin/bitcoin/pull/17708#issuecomment-563934250,563934250,
laanwj,2019-12-10 09:10:00,ACK on the prevector.h and ubsan change,https://github.com/bitcoin/bitcoin/pull/17708#issuecomment-563937703,563937703,
vasild,2019-12-10 09:44:12,"ACK 0df2f79c0, I have tested the code",https://github.com/bitcoin/bitcoin/pull/17708#issuecomment-563951470,563951470,
DrahtBot,2019-12-10 09:49:58,"<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #18088 (build: ensure we aren't using GNU extensions by fanquake)\n* #17208 (Make all tests pass UBSan without using any U",https://github.com/bitcoin/bitcoin/pull/17708#issuecomment-563953994,563953994,
laanwj,2019-12-10 11:07:10,ACK 5f26855f109af53a336d5f98ed0ae584e7a31f84,https://github.com/bitcoin/bitcoin/pull/17708#issuecomment-563983915,563983915,
practicalswift,2019-12-10 16:17:46,"ACK 5f26855f109af53a336d5f98ed0ae584e7a31f84\n\nVery glad to see two UBSan suppressions go away! :)",https://github.com/bitcoin/bitcoin/pull/17708#issuecomment-564110088,564110088,
dongcarl,2019-12-10 17:18:03,@jamesob Might wanna benchmark this one instead of the previous attempt if you haven't already :relaxed:,https://github.com/bitcoin/bitcoin/pull/17708#issuecomment-564138304,564138304,
laanwj,2019-12-12 11:25:45,"I'm pretty sure the change, as it is now, doesn't modify the layout of any of the data structures used in UTXO caching.\n\nI think the only case where `CScript` ended up non-aligned in practice was on the stack in some cases (esp. the fuzzing tests).",https://github.com/bitcoin/bitcoin/pull/17708#issuecomment-564967479,564967479,
sipa,2019-12-12 19:24:21,@laanwj Agree.,https://github.com/bitcoin/bitcoin/pull/17708#issuecomment-565148154,565148154,
sipa,2019-12-12 19:43:35,"This just feels like there must be a better solution. What we're trying to accomplish here should be completely legal, and shouldn't require pragma pack at all.\n\nReally the problem is that we want either (size, size, pointer) or (size, bytearray). If we could have a union between those two, with a guarantee the two first fields are merged, we'd be done. But because the language forces us to co",https://github.com/bitcoin/bitcoin/pull/17708#issuecomment-565155911,565155911,
JeremyRubin,2019-12-13 02:17:37,"I'm pretty sure that it's valid to just union them and access the first size from either.\n\nhttps://en.cppreference.com/w/cpp/language/data_members\n\nC++11 & before\n> If a standard-layout union holds two (or more) standard-layout classes as members, and these classes have a common initial sequence of data members, it is well-defined to examine any member of that common initial sequence reg",https://github.com/bitcoin/bitcoin/pull/17708#issuecomment-565271516,565271516,
laanwj,2019-12-13 09:33:11,"> I'm pretty sure that it's valid to just union them and access the first size from either.\n\nYes, my first impulse was also ""move the size into the union"", but the last decade of C++ (often enough, something allowed or even recommended one day becomes UB the next) made me scared of these kind of assumptions. I think we're looking at ""aliasing"" here as there will be two paths to access the same",https://github.com/bitcoin/bitcoin/pull/17708#issuecomment-565370069,565370069,
JeremyRubin,2019-12-13 17:37:24,"It's worth noting that this behavior is very well defined in C99 and C++.\n\nThe standard seems pretty clear to me:\n\n>If two union members are standard-layout types, it's well-defined to examine their common subsequence on any compiler. \n\nhttps://en.cppreference.com/w/cpp/language/union\n\nThe aliasing rules should only come into play when the field is written to; which we shouldn't ha",https://github.com/bitcoin/bitcoin/pull/17708#issuecomment-565534743,565534743,
laanwj,2019-12-15 11:23:25,"> I have mixed feeling overall on if #pragma pack is less edge casey as it in fact does exploit compiler-specific \n\nThe `pragma pack` was there already for years, and as far as we know, never gave any issues.\n\nI think this PR does not make anything *less* safe than it was before. It adds constraints to make sure the previous usage, which already happened to be safe (due to how the data str",https://github.com/bitcoin/bitcoin/pull/17708#issuecomment-565800387,565800387,
practicalswift,2020-01-06 21:36:57,"Review beg for this PR which currently has three fresh ACKs (@laanwj, @sipa and me) and one stale ACK (@vasild) - anyone else interested in reviewing? :)\n\nWould be great to have this merged :)",https://github.com/bitcoin/bitcoin/pull/17708#issuecomment-571325382,571325382,
ajtowns,2020-01-09 02:10:42,"> It's worth noting that this behavior is very well defined in C99 and C++.\n\nFWIW, I think @JeremyRubin is right in that that's both safe and a better approach; but in the short term at least it seems to be a much more intrusive change both to merge `_size` into the union (as `_direct._size` and `_indirect._size` or similar) and more importantly to update the `_size` field in the correct sub-s",https://github.com/bitcoin/bitcoin/pull/17708#issuecomment-572348343,572348343,
practicalswift,2020-01-29 21:07:04,"I was really hoping to see this fix making it to 0.19.1 :\\n\nCan we move forward with this one?\n\nDoesn't feel good to ship with a known misaligned pointer use in `ProduceSignature(â€¦)` :(\n\nReachability:\n\n```\nprevector.h:453:19: runtime error: reference binding to misaligned address 0x7f24765a4c22 for type 'prevector<28, unsigned char, unsigned int, int>::size_type' (aka 'unsigned i",https://github.com/bitcoin/bitcoin/pull/17708#issuecomment-579959567,579959567,
JeremyRubin,2020-01-29 21:40:21,I agree with @ajtowns above and support moving forward with fixing this (and following up in the future with a pragma free version if needed).,https://github.com/bitcoin/bitcoin/pull/17708#issuecomment-579972527,579972527,
MarcoFalke,2020-04-26 17:53:06,"It seems this had a performance related silent merge conflict.\n\nThe commit itself increases performance:\n\n```\n$ git log -1 --oneline --no-decorate && ./src/bench/bench_bitcoin --filter=PrevectorDeserializeNontrivial\n5f26855f10 test: Remove ubsan alignment suppressions\n# Benchmark, evals, iterations, total, min, max, median\nPrevectorDeserializeNontrivial, 5, 6800, 2.56196, 7.44051e-",https://github.com/bitcoin/bitcoin/pull/17708#issuecomment-619594531,619594531,
ajtowns,2020-05-26 12:41:31,"> It seems this had a performance related silent merge conflict.\n\nIt makes sense for this to make things worse in the benchmark I think -- the nontrivial constructor prevector in the benchmark is a 116 or 120 byte object (28 4-byte nontrivials, a 4-byte size_t with the number of non-trivials, all aligned to a pointer so padded 4-bytes if pointers are 8-bytes), and the size has moved to the end",https://github.com/bitcoin/bitcoin/pull/17708#issuecomment-633999688,633999688,
laanwj,2019-12-10 09:09:31,"I don't like statically asserting numbers here. It may differ per platform, architecture.",https://github.com/bitcoin/bitcoin/pull/17708#discussion_r355916325,355916325,src/coins.cpp
vasild,2019-12-10 09:30:22,"nit: `assert(A && B);` is equivalent to `assert(A); assert(B);`, however the former has the (small) problem that if it fails it is not clear from the message which one of `A` or `B` is false.",https://github.com/bitcoin/bitcoin/pull/17708#discussion_r355926888,355926888,src/prevector.h
laanwj,2019-12-10 09:47:57,"I don't think it should be a compile error if these are too small or big. This means that for any field added/removed to the structure, or possible for new compilers/architectures, these lines have to be updated.",https://github.com/bitcoin/bitcoin/pull/17708#discussion_r355936160,355936160,src/coins.cpp
ajtowns,2019-12-10 11:00:40,"Agree, mostly wanted them in there to check that there weren't any unexpected changes at least on any of the architectures travis checks. (It's 44/48 for 4-byte pointers and 48/56 for 8-byte pointers). Rebased without that commit.",https://github.com/bitcoin/bitcoin/pull/17708#discussion_r355972284,355972284,src/coins.cpp
laanwj,2019-12-10 11:06:48,"Yeah, it's good for that.\nI later realized there could be a case for checking *CScript*'s size because it's supposed to be 32 bytes no matter the architecture (assuming pointer sizes <= 128 bit  :smiley: ), and it's unlikely for fields to be added to it. But I dunno.",https://github.com/bitcoin/bitcoin/pull/17708#discussion_r355974938,355974938,src/coins.cpp
ajtowns,2019-12-10 11:21:43,"CScript seems like it ought to be reasonably robust, and it's got that `28` constant already. Maybe if #17060 or the like makes progress could add some checks then? Figure it only makes sense to worry about the size of the things you're caching a bazillion of...",https://github.com/bitcoin/bitcoin/pull/17708#discussion_r355981321,355981321,src/coins.cpp
sipa,2019-12-12 19:17:55,"`sizeof(X)` is always a multiple of `alignof(X)`, so I think the second half here is just redundant.",https://github.com/bitcoin/bitcoin/pull/17708#discussion_r357323996,357323996,src/prevector.h
JeremyRubin,2019-12-13 02:01:14,"Actually I think to a degree CScript being 32 is non obvious... e.g. the size could be shifted greater if that were expected to be the ""hot case"" for fitting most CScripts. It does kind of seem like 28 might be too small, and worth re-measuring. P2SH fits in 32, but a segwit output should be 33 bytes long... unless I'm missing some case where 28 is a common size nowadays.",https://github.com/bitcoin/bitcoin/pull/17708#discussion_r357456591,357456591,src/coins.cpp
ajtowns,2020-01-09 01:58:05,"p2pkh, p2sh and p2wpkh should all fit; p2wsh won't fit though (and neither will p2taproot if/when it exists)",https://github.com/bitcoin/bitcoin/pull/17708#discussion_r364529016,364529016,src/coins.cpp
