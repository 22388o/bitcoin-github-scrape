[
  {
    "sha": "cc9ee809ad19a63ca284d2fbc327ac1cbcee31e4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYzllZTgwOWFkMTlhNjNjYTI4NGQyZmJjMzI3YWMxY2JjZWUzMWU0",
    "commit": {
      "author": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2017-10-04T22:29:34Z"
      },
      "committer": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2017-10-10T22:49:16Z"
      },
      "message": "Improve ZMQ functional test",
      "tree": {
        "sha": "d306c28cb84e76334c05a74672d1d09406e1b005",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d306c28cb84e76334c05a74672d1d09406e1b005"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cc9ee809ad19a63ca284d2fbc327ac1cbcee31e4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc9ee809ad19a63ca284d2fbc327ac1cbcee31e4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cc9ee809ad19a63ca284d2fbc327ac1cbcee31e4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc9ee809ad19a63ca284d2fbc327ac1cbcee31e4/comments",
    "author": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e022463a4b238750476430d08b45bc9171791e6f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e022463a4b238750476430d08b45bc9171791e6f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e022463a4b238750476430d08b45bc9171791e6f"
      }
    ],
    "stats": {
      "total": 172,
      "additions": 70,
      "deletions": 102
    },
    "files": [
      {
        "sha": "165f9192ddd74040c85db1258c5973f36f56ca15",
        "filename": "test/functional/zmq_test.py",
        "status": "modified",
        "additions": 70,
        "deletions": 102,
        "changes": 172,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc9ee809ad19a63ca284d2fbc327ac1cbcee31e4/test/functional/zmq_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc9ee809ad19a63ca284d2fbc327ac1cbcee31e4/test/functional/zmq_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/zmq_test.py?ref=cc9ee809ad19a63ca284d2fbc327ac1cbcee31e4",
        "patch": "@@ -2,7 +2,7 @@\n # Copyright (c) 2015-2016 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Test the ZMQ API.\"\"\"\n+\"\"\"Test the ZMQ notification interface.\"\"\"\n import configparser\n import os\n import struct\n@@ -13,6 +13,25 @@\n                                  hash256,\n                                 )\n \n+class ZMQSubscriber:\n+    def __init__(self, socket, topic):\n+        self.sequence = 0\n+        self.socket = socket\n+        self.topic = topic\n+\n+        import zmq\n+        self.socket.setsockopt(zmq.SUBSCRIBE, self.topic)\n+\n+    def receive(self):\n+        topic, body, seq = self.socket.recv_multipart()\n+        # Topic should match the subscriber topic.\n+        assert_equal(topic, self.topic)\n+        # Sequence should be incremental.\n+        assert_equal(struct.unpack('<I', seq)[-1], self.sequence)\n+        self.sequence += 1\n+        return body\n+\n+\n class ZMQTest (BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 2\n@@ -24,130 +43,79 @@ def setup_nodes(self):\n         except ImportError:\n             raise SkipTest(\"python3-zmq module not available.\")\n \n-        # Check that bitcoin has been built with ZMQ enabled\n+        # Check that bitcoin has been built with ZMQ enabled.\n         config = configparser.ConfigParser()\n         if not self.options.configfile:\n-            self.options.configfile = os.path.dirname(__file__) + \"/../config.ini\"\n+            self.options.configfile = os.path.abspath(os.path.join(os.path.dirname(__file__), \"../config.ini\"))\n         config.read_file(open(self.options.configfile))\n \n         if not config[\"components\"].getboolean(\"ENABLE_ZMQ\"):\n             raise SkipTest(\"bitcoind has not been built with zmq enabled.\")\n \n-        self.zmqContext = zmq.Context()\n-        self.zmqSubSocket = self.zmqContext.socket(zmq.SUB)\n-        self.zmqSubSocket.set(zmq.RCVTIMEO, 60000)\n-        self.zmqSubSocket.setsockopt(zmq.SUBSCRIBE, b\"hashblock\")\n-        self.zmqSubSocket.setsockopt(zmq.SUBSCRIBE, b\"hashtx\")\n-        self.zmqSubSocket.setsockopt(zmq.SUBSCRIBE, b\"rawblock\")\n-        self.zmqSubSocket.setsockopt(zmq.SUBSCRIBE, b\"rawtx\")\n-        ip_address = \"tcp://127.0.0.1:28332\"\n-        self.zmqSubSocket.connect(ip_address)\n-        self.extra_args = [['-zmqpubhashblock=%s' % ip_address, '-zmqpubhashtx=%s' % ip_address,\n-                       '-zmqpubrawblock=%s' % ip_address, '-zmqpubrawtx=%s' % ip_address], []]\n+        # Initialize ZMQ context and socket.\n+        # All messages are received in the same socket which means\n+        # that this test fails if the publishing order changes.\n+        # Note that the publishing order is not defined in the documentation and\n+        # is subject to change.\n+        address = \"tcp://127.0.0.1:28332\"\n+        self.zmq_context = zmq.Context()\n+        socket = self.zmq_context.socket(zmq.SUB)\n+        socket.set(zmq.RCVTIMEO, 60000)\n+        socket.connect(address)\n+\n+        # Subscribe to all available topics.\n+        self.hashblock = ZMQSubscriber(socket, b\"hashblock\")\n+        self.hashtx = ZMQSubscriber(socket, b\"hashtx\")\n+        self.rawblock = ZMQSubscriber(socket, b\"rawblock\")\n+        self.rawtx = ZMQSubscriber(socket, b\"rawtx\")\n+\n+        self.extra_args = [[\"-zmqpub%s=%s\" % (sub.topic.decode(), address) for sub in [self.hashblock, self.hashtx, self.rawblock, self.rawtx]], []]\n         self.add_nodes(self.num_nodes, self.extra_args)\n         self.start_nodes()\n \n     def run_test(self):\n         try:\n             self._zmq_test()\n         finally:\n-            # Destroy the zmq context\n-            self.log.debug(\"Destroying zmq context\")\n-            self.zmqContext.destroy(linger=None)\n+            # Destroy the ZMQ context.\n+            self.log.debug(\"Destroying ZMQ context\")\n+            self.zmq_context.destroy(linger=None)\n \n     def _zmq_test(self):\n-        genhashes = self.nodes[0].generate(1)\n+        num_blocks = 5\n+        self.log.info(\"Generate %(n)d blocks (and %(n)d coinbase txes)\" % {\"n\": num_blocks})\n+        genhashes = self.nodes[0].generate(num_blocks)\n         self.sync_all()\n \n-        self.log.info(\"Wait for tx\")\n-        msg = self.zmqSubSocket.recv_multipart()\n-        topic = msg[0]\n-        assert_equal(topic, b\"hashtx\")\n-        txhash = msg[1]\n-        msgSequence = struct.unpack('<I', msg[-1])[-1]\n-        assert_equal(msgSequence, 0)  # must be sequence 0 on hashtx\n-\n-        # rawtx\n-        msg = self.zmqSubSocket.recv_multipart()\n-        topic = msg[0]\n-        assert_equal(topic, b\"rawtx\")\n-        body = msg[1]\n-        msgSequence = struct.unpack('<I', msg[-1])[-1]\n-        assert_equal(msgSequence, 0) # must be sequence 0 on rawtx\n-\n-        # Check that the rawtx hashes to the hashtx\n-        assert_equal(hash256(body), txhash)\n-\n-        self.log.info(\"Wait for block\")\n-        msg = self.zmqSubSocket.recv_multipart()\n-        topic = msg[0]\n-        assert_equal(topic, b\"hashblock\")\n-        body = msg[1]\n-        msgSequence = struct.unpack('<I', msg[-1])[-1]\n-        assert_equal(msgSequence, 0)  # must be sequence 0 on hashblock\n-        blkhash = bytes_to_hex_str(body)\n-        assert_equal(genhashes[0], blkhash)  # blockhash from generate must be equal to the hash received over zmq\n-\n-        # rawblock\n-        msg = self.zmqSubSocket.recv_multipart()\n-        topic = msg[0]\n-        assert_equal(topic, b\"rawblock\")\n-        body = msg[1]\n-        msgSequence = struct.unpack('<I', msg[-1])[-1]\n-        assert_equal(msgSequence, 0) #must be sequence 0 on rawblock\n-\n-        # Check the hash of the rawblock's header matches generate\n-        assert_equal(genhashes[0], bytes_to_hex_str(hash256(body[:80])))\n-\n-        self.log.info(\"Generate 10 blocks (and 10 coinbase txes)\")\n-        n = 10\n-        genhashes = self.nodes[1].generate(n)\n-        self.sync_all()\n+        for x in range(num_blocks):\n+            # Should receive the coinbase txid.\n+            txid = self.hashtx.receive()\n+\n+            # Should receive the coinbase raw transaction.\n+            hex = self.rawtx.receive()\n+            assert_equal(hash256(hex), txid)\n \n-        zmqHashes = []\n-        zmqRawHashed = []\n-        blockcount = 0\n-        for x in range(n * 4):\n-            msg = self.zmqSubSocket.recv_multipart()\n-            topic = msg[0]\n-            body = msg[1]\n-            if topic == b\"hashblock\":\n-                zmqHashes.append(bytes_to_hex_str(body))\n-                msgSequence = struct.unpack('<I', msg[-1])[-1]\n-                assert_equal(msgSequence, blockcount + 1)\n-                blockcount += 1\n-            if topic == b\"rawblock\":\n-                zmqRawHashed.append(bytes_to_hex_str(hash256(body[:80])))\n-                msgSequence = struct.unpack('<I', msg[-1])[-1]\n-                assert_equal(msgSequence, blockcount)\n-\n-        for x in range(n):\n-            assert_equal(genhashes[x], zmqHashes[x])  # blockhash from generate must be equal to the hash received over zmq\n-            assert_equal(genhashes[x], zmqRawHashed[x])\n+            # Should receive the generated block hash.\n+            hash = bytes_to_hex_str(self.hashblock.receive())\n+            assert_equal(genhashes[x], hash)\n+            # The block should only have the coinbase txid.\n+            assert_equal([bytes_to_hex_str(txid)], self.nodes[1].getblock(hash)[\"tx\"])\n+\n+            # Should receive the generated raw block.\n+            block = self.rawblock.receive()\n+            assert_equal(genhashes[x], bytes_to_hex_str(hash256(block[:80])))\n \n         self.log.info(\"Wait for tx from second node\")\n-        # test tx from a second node\n-        hashRPC = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n+        payment_txid = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n         self.sync_all()\n \n-        # now we should receive a zmq msg because the tx was broadcast\n-        msg = self.zmqSubSocket.recv_multipart()\n-        topic = msg[0]\n-        assert_equal(topic, b\"hashtx\")\n-        body = msg[1]\n-        hashZMQ = bytes_to_hex_str(body)\n-        msgSequence = struct.unpack('<I', msg[-1])[-1]\n-        assert_equal(msgSequence, blockcount + 1)\n-\n-        msg = self.zmqSubSocket.recv_multipart()\n-        topic = msg[0]\n-        assert_equal(topic, b\"rawtx\")\n-        body = msg[1]\n-        hashedZMQ = bytes_to_hex_str(hash256(body))\n-        msgSequence = struct.unpack('<I', msg[-1])[-1]\n-        assert_equal(msgSequence, blockcount+1)\n-        assert_equal(hashRPC, hashZMQ)  # txid from sendtoaddress must be equal to the hash received over zmq\n-        assert_equal(hashRPC, hashedZMQ)\n+        # Should receive the broadcasted txid.\n+        txid = self.hashtx.receive()\n+        assert_equal(payment_txid, bytes_to_hex_str(txid))\n+\n+        # Should receive the broadcasted raw transaction.\n+        hex = self.rawtx.receive()\n+        assert_equal(payment_txid, bytes_to_hex_str(hash256(hex)))\n \n if __name__ == '__main__':\n     ZMQTest().main()"
      }
    ]
  }
]