[
  {
    "sha": "34628a18070064e75b35f28fd6a43d5c23832eb8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNDYyOGExODA3MDA2NGU3NWIzNWYyOGZkNmE0M2Q1YzIzODMyZWI4",
    "commit": {
      "author": {
        "name": "Ashley Holman",
        "email": "dscvlt@gmail.com",
        "date": "2015-06-24T08:32:20Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2015-09-19T17:22:40Z"
      },
      "message": "TxMemPool: Change mapTx to a boost::multi_index_container\n\nIndexes on:\n- Tx Hash\n- Fee Rate (fee-per-kb)",
      "tree": {
        "sha": "e73c13d25d04212b5bbbb5b0c3829421f7616d6b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e73c13d25d04212b5bbbb5b0c3829421f7616d6b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/34628a18070064e75b35f28fd6a43d5c23832eb8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34628a18070064e75b35f28fd6a43d5c23832eb8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/34628a18070064e75b35f28fd6a43d5c23832eb8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34628a18070064e75b35f28fd6a43d5c23832eb8/comments",
    "author": {
      "login": "ashleyholman",
      "id": 549484,
      "node_id": "MDQ6VXNlcjU0OTQ4NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/549484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ashleyholman",
      "html_url": "https://github.com/ashleyholman",
      "followers_url": "https://api.github.com/users/ashleyholman/followers",
      "following_url": "https://api.github.com/users/ashleyholman/following{/other_user}",
      "gists_url": "https://api.github.com/users/ashleyholman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ashleyholman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ashleyholman/subscriptions",
      "organizations_url": "https://api.github.com/users/ashleyholman/orgs",
      "repos_url": "https://api.github.com/users/ashleyholman/repos",
      "events_url": "https://api.github.com/users/ashleyholman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ashleyholman/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d5d1d2e65a1c3b91452d2428410f701bca1e53cc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d5d1d2e65a1c3b91452d2428410f701bca1e53cc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d5d1d2e65a1c3b91452d2428410f701bca1e53cc"
      }
    ],
    "stats": {
      "total": 159,
      "additions": 127,
      "deletions": 32
    },
    "files": [
      {
        "sha": "b2a356e52d4d29a6badec3bfb373fc7c75da2754",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34628a18070064e75b35f28fd6a43d5c23832eb8/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34628a18070064e75b35f28fd6a43d5c23832eb8/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=34628a18070064e75b35f28fd6a43d5c23832eb8",
        "patch": "@@ -158,10 +158,10 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n         // This vector will be sorted into a priority queue:\n         vector<TxPriority> vecPriority;\n         vecPriority.reserve(mempool.mapTx.size());\n-        for (map<uint256, CTxMemPoolEntry>::iterator mi = mempool.mapTx.begin();\n+        for (CTxMemPool::indexed_transaction_set::iterator mi = mempool.mapTx.begin();\n              mi != mempool.mapTx.end(); ++mi)\n         {\n-            const CTransaction& tx = mi->second.GetTx();\n+            const CTransaction& tx = mi->GetTx();\n             if (tx.IsCoinBase() || !IsFinalTx(tx, nHeight, pblock->nTime))\n                 continue;\n \n@@ -196,7 +196,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n                     }\n                     mapDependers[txin.prevout.hash].push_back(porphan);\n                     porphan->setDependsOn.insert(txin.prevout.hash);\n-                    nTotalIn += mempool.mapTx[txin.prevout.hash].GetTx().vout[txin.prevout.n].nValue;\n+                    nTotalIn += mempool.mapTx.find(txin.prevout.hash)->GetTx().vout[txin.prevout.n].nValue;\n                     continue;\n                 }\n                 const CCoins* coins = view.AccessCoins(txin.prevout.hash);\n@@ -226,7 +226,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n                 porphan->feeRate = feeRate;\n             }\n             else\n-                vecPriority.push_back(TxPriority(dPriority, feeRate, &mi->second.GetTx()));\n+                vecPriority.push_back(TxPriority(dPriority, feeRate, &(mi->GetTx())));\n         }\n \n         // Collect transactions into block"
      },
      {
        "sha": "a1da31b616698150c7d8d517aa5d59ce6307ebd9",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34628a18070064e75b35f28fd6a43d5c23832eb8/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34628a18070064e75b35f28fd6a43d5c23832eb8/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=34628a18070064e75b35f28fd6a43d5c23832eb8",
        "patch": "@@ -181,10 +181,9 @@ UniValue mempoolToJSON(bool fVerbose = false)\n     {\n         LOCK(mempool.cs);\n         UniValue o(UniValue::VOBJ);\n-        BOOST_FOREACH(const PAIRTYPE(uint256, CTxMemPoolEntry)& entry, mempool.mapTx)\n+        BOOST_FOREACH(const CTxMemPoolEntry& e, mempool.mapTx)\n         {\n-            const uint256& hash = entry.first;\n-            const CTxMemPoolEntry& e = entry.second;\n+            const uint256& hash = e.GetTx().GetHash();\n             UniValue info(UniValue::VOBJ);\n             info.push_back(Pair(\"size\", (int)e.GetTxSize()));\n             info.push_back(Pair(\"fee\", ValueFromAmount(e.GetFee())));"
      },
      {
        "sha": "7f82a61bf30cf91bc78db3c26e4598996991a65e",
        "filename": "src/test/mempool_tests.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34628a18070064e75b35f28fd6a43d5c23832eb8/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34628a18070064e75b35f28fd6a43d5c23832eb8/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=34628a18070064e75b35f28fd6a43d5c23832eb8",
        "patch": "@@ -100,4 +100,56 @@ BOOST_AUTO_TEST_CASE(MempoolRemoveTest)\n     removed.clear();\n }\n \n+BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n+{\n+    CTxMemPool pool(CFeeRate(0));\n+\n+    /* 3rd highest fee */\n+    CMutableTransaction tx1 = CMutableTransaction();\n+    tx1.vout.resize(1);\n+    tx1.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx1.vout[0].nValue = 10 * COIN;\n+    pool.addUnchecked(tx1.GetHash(), CTxMemPoolEntry(tx1, 10000LL, 0, 10.0, 1, true));\n+\n+    /* highest fee */\n+    CMutableTransaction tx2 = CMutableTransaction();\n+    tx2.vout.resize(1);\n+    tx2.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx2.vout[0].nValue = 2 * COIN;\n+    pool.addUnchecked(tx2.GetHash(), CTxMemPoolEntry(tx2, 20000LL, 0, 9.0, 1, true));\n+\n+    /* lowest fee */\n+    CMutableTransaction tx3 = CMutableTransaction();\n+    tx3.vout.resize(1);\n+    tx3.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx3.vout[0].nValue = 5 * COIN;\n+    pool.addUnchecked(tx3.GetHash(), CTxMemPoolEntry(tx3, 0LL, 0, 100.0, 1, true));\n+\n+    /* 2nd highest fee */\n+    CMutableTransaction tx4 = CMutableTransaction();\n+    tx4.vout.resize(1);\n+    tx4.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx4.vout[0].nValue = 6 * COIN;\n+    pool.addUnchecked(tx4.GetHash(), CTxMemPoolEntry(tx4, 15000LL, 0, 1.0, 1, true));\n+\n+    /* equal fee rate to tx1, but newer */\n+    CMutableTransaction tx5 = CMutableTransaction();\n+    tx5.vout.resize(1);\n+    tx5.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx5.vout[0].nValue = 11 * COIN;\n+    pool.addUnchecked(tx5.GetHash(), CTxMemPoolEntry(tx5, 10000LL, 1, 10.0, 1, true));\n+\n+    // there should be 4 transactions in the mempool\n+    BOOST_CHECK_EQUAL(pool.size(), 5);\n+\n+    // Check the fee-rate index is in order, should be tx2, tx4, tx1, tx5, tx3\n+    CTxMemPool::indexed_transaction_set::nth_index<1>::type::iterator it = pool.mapTx.get<1>().begin();\n+    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx2.GetHash().ToString());\n+    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx4.GetHash().ToString());\n+    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx1.GetHash().ToString());\n+    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx5.GetHash().ToString());\n+    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx3.GetHash().ToString());\n+    BOOST_CHECK(it == pool.mapTx.get<1>().end());\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "c410cd08323b2b28b7cc7b4c159af37896eebc19",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 24,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34628a18070064e75b35f28fd6a43d5c23832eb8/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34628a18070064e75b35f28fd6a43d5c23832eb8/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=34628a18070064e75b35f28fd6a43d5c23832eb8",
        "patch": "@@ -32,6 +32,7 @@ CTxMemPoolEntry::CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,\n     nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n     nModSize = tx.CalculateModifiedSize(nTxSize);\n     nUsageSize = RecursiveDynamicUsage(tx);\n+    feeRate = CFeeRate(nFee, nTxSize);\n }\n \n CTxMemPoolEntry::CTxMemPoolEntry(const CTxMemPoolEntry& other)\n@@ -96,8 +97,8 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,\n     // Used by main.cpp AcceptToMemoryPool(), which DOES do\n     // all the appropriate checks.\n     LOCK(cs);\n-    mapTx[hash] = entry;\n-    const CTransaction& tx = mapTx[hash].GetTx();\n+    mapTx.insert(entry);\n+    const CTransaction& tx = mapTx.find(hash)->GetTx();\n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n         mapNextTx[tx.vin[i].prevout] = CInPoint(&tx, i);\n     nTransactionsUpdated++;\n@@ -134,7 +135,7 @@ void CTxMemPool::remove(const CTransaction &origTx, std::list<CTransaction>& rem\n             txToRemove.pop_front();\n             if (!mapTx.count(hash))\n                 continue;\n-            const CTransaction& tx = mapTx[hash].GetTx();\n+            const CTransaction& tx = mapTx.find(hash)->GetTx();\n             if (fRecursive) {\n                 for (unsigned int i = 0; i < tx.vout.size(); i++) {\n                     std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(hash, i));\n@@ -147,8 +148,8 @@ void CTxMemPool::remove(const CTransaction &origTx, std::list<CTransaction>& rem\n                 mapNextTx.erase(txin.prevout);\n \n             removed.push_back(tx);\n-            totalTxSize -= mapTx[hash].GetTxSize();\n-            cachedInnerUsage -= mapTx[hash].DynamicMemoryUsage();\n+            totalTxSize -= mapTx.find(hash)->GetTxSize();\n+            cachedInnerUsage -= mapTx.find(hash)->DynamicMemoryUsage();\n             mapTx.erase(hash);\n             nTransactionsUpdated++;\n             minerPolicyEstimator->removeTx(hash);\n@@ -161,10 +162,10 @@ void CTxMemPool::removeCoinbaseSpends(const CCoinsViewCache *pcoins, unsigned in\n     // Remove transactions spending a coinbase which are now immature\n     LOCK(cs);\n     list<CTransaction> transactionsToRemove;\n-    for (std::map<uint256, CTxMemPoolEntry>::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n-        const CTransaction& tx = it->second.GetTx();\n+    for (indexed_transaction_set::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n+        const CTransaction& tx = it->GetTx();\n         BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n-            std::map<uint256, CTxMemPoolEntry>::const_iterator it2 = mapTx.find(txin.prevout.hash);\n+            indexed_transaction_set::const_iterator it2 = mapTx.find(txin.prevout.hash);\n             if (it2 != mapTx.end())\n                 continue;\n             const CCoins *coins = pcoins->AccessCoins(txin.prevout.hash);\n@@ -209,8 +210,10 @@ void CTxMemPool::removeForBlock(const std::vector<CTransaction>& vtx, unsigned i\n     BOOST_FOREACH(const CTransaction& tx, vtx)\n     {\n         uint256 hash = tx.GetHash();\n-        if (mapTx.count(hash))\n-            entries.push_back(mapTx[hash]);\n+\n+        indexed_transaction_set::iterator i = mapTx.find(hash);\n+        if (i != mapTx.end())\n+            entries.push_back(*i);\n     }\n     BOOST_FOREACH(const CTransaction& tx, vtx)\n     {\n@@ -247,17 +250,17 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n \n     LOCK(cs);\n     list<const CTxMemPoolEntry*> waitingOnDependants;\n-    for (std::map<uint256, CTxMemPoolEntry>::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n+    for (indexed_transaction_set::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n         unsigned int i = 0;\n-        checkTotal += it->second.GetTxSize();\n-        innerUsage += it->second.DynamicMemoryUsage();\n-        const CTransaction& tx = it->second.GetTx();\n+        checkTotal += it->GetTxSize();\n+        innerUsage += it->DynamicMemoryUsage();\n+        const CTransaction& tx = it->GetTx();\n         bool fDependsWait = false;\n         BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n             // Check that every mempool transaction's inputs refer to available coins, or other mempool tx's.\n-            std::map<uint256, CTxMemPoolEntry>::const_iterator it2 = mapTx.find(txin.prevout.hash);\n+            indexed_transaction_set::const_iterator it2 = mapTx.find(txin.prevout.hash);\n             if (it2 != mapTx.end()) {\n-                const CTransaction& tx2 = it2->second.GetTx();\n+                const CTransaction& tx2 = it2->GetTx();\n                 assert(tx2.vout.size() > txin.prevout.n && !tx2.vout[txin.prevout.n].IsNull());\n                 fDependsWait = true;\n             } else {\n@@ -272,7 +275,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n             i++;\n         }\n         if (fDependsWait)\n-            waitingOnDependants.push_back(&it->second);\n+            waitingOnDependants.push_back(&(*it));\n         else {\n             CValidationState state;\n             assert(CheckInputs(tx, state, mempoolDuplicate, false, 0, false, NULL));\n@@ -296,8 +299,8 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n     }\n     for (std::map<COutPoint, CInPoint>::const_iterator it = mapNextTx.begin(); it != mapNextTx.end(); it++) {\n         uint256 hash = it->second.ptx->GetHash();\n-        map<uint256, CTxMemPoolEntry>::const_iterator it2 = mapTx.find(hash);\n-        const CTransaction& tx = it2->second.GetTx();\n+        indexed_transaction_set::const_iterator it2 = mapTx.find(hash);\n+        const CTransaction& tx = it2->GetTx();\n         assert(it2 != mapTx.end());\n         assert(&tx == it->second.ptx);\n         assert(tx.vin.size() > it->second.n);\n@@ -314,16 +317,16 @@ void CTxMemPool::queryHashes(vector<uint256>& vtxid)\n \n     LOCK(cs);\n     vtxid.reserve(mapTx.size());\n-    for (map<uint256, CTxMemPoolEntry>::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi)\n-        vtxid.push_back((*mi).first);\n+    for (indexed_transaction_set::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi)\n+        vtxid.push_back(mi->GetTx().GetHash());\n }\n \n bool CTxMemPool::lookup(uint256 hash, CTransaction& result) const\n {\n     LOCK(cs);\n-    map<uint256, CTxMemPoolEntry>::const_iterator i = mapTx.find(hash);\n+    indexed_transaction_set::const_iterator i = mapTx.find(hash);\n     if (i == mapTx.end()) return false;\n-    result = i->second.GetTx();\n+    result = i->GetTx();\n     return true;\n }\n \n@@ -429,5 +432,6 @@ bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) const {\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n     LOCK(cs);\n-    return memusage::DynamicUsage(mapTx) + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n+    // Estimate the overhead of mapTx to be 6 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 6 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n }"
      },
      {
        "sha": "6b6b05454a4eee3fd1dda5bc13993c5f3a2578bc",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 41,
        "deletions": 1,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34628a18070064e75b35f28fd6a43d5c23832eb8/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34628a18070064e75b35f28fd6a43d5c23832eb8/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=34628a18070064e75b35f28fd6a43d5c23832eb8",
        "patch": "@@ -13,6 +13,10 @@\n #include \"primitives/transaction.h\"\n #include \"sync.h\"\n \n+#undef foreach\n+#include \"boost/multi_index_container.hpp\"\n+#include \"boost/multi_index/ordered_index.hpp\"\n+\n class CAutoFile;\n \n inline double AllowFreeThreshold()\n@@ -41,6 +45,7 @@ class CTxMemPoolEntry\n     size_t nTxSize; //! ... and avoid recomputing tx size\n     size_t nModSize; //! ... and modified size for priority\n     size_t nUsageSize; //! ... and total memory usage\n+    CFeeRate feeRate; //! ... and fee per kB\n     int64_t nTime; //! Local time when entering the mempool\n     double dPriority; //! Priority when entering the mempool\n     unsigned int nHeight; //! Chain height when entering the mempool\n@@ -55,13 +60,35 @@ class CTxMemPoolEntry\n     const CTransaction& GetTx() const { return this->tx; }\n     double GetPriority(unsigned int currentHeight) const;\n     CAmount GetFee() const { return nFee; }\n+    CFeeRate GetFeeRate() const { return feeRate; }\n     size_t GetTxSize() const { return nTxSize; }\n     int64_t GetTime() const { return nTime; }\n     unsigned int GetHeight() const { return nHeight; }\n     bool WasClearAtEntry() const { return hadNoDependencies; }\n     size_t DynamicMemoryUsage() const { return nUsageSize; }\n };\n \n+// extracts a TxMemPoolEntry's transaction hash\n+struct mempoolentry_txid\n+{\n+    typedef uint256 result_type;\n+    result_type operator() (const CTxMemPoolEntry &entry) const\n+    {\n+        return entry.GetTx().GetHash();\n+    }\n+};\n+\n+class CompareTxMemPoolEntryByFee\n+{\n+public:\n+    bool operator()(const CTxMemPoolEntry& a, const CTxMemPoolEntry& b)\n+    {\n+        if (a.GetFeeRate() == b.GetFeeRate())\n+            return a.GetTime() < b.GetTime();\n+        return a.GetFeeRate() > b.GetFeeRate();\n+    }\n+};\n+\n class CBlockPolicyEstimator;\n \n /** An inpoint - a combination of a transaction and an index n into its vin */\n@@ -99,8 +126,21 @@ class CTxMemPool\n     uint64_t cachedInnerUsage; //! sum of dynamic memory usage of all the map elements (NOT the maps themselves)\n \n public:\n+    typedef boost::multi_index_container<\n+        CTxMemPoolEntry,\n+        boost::multi_index::indexed_by<\n+            // sorted by txid\n+            boost::multi_index::ordered_unique<mempoolentry_txid>,\n+            // sorted by fee rate\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::identity<CTxMemPoolEntry>,\n+                CompareTxMemPoolEntryByFee\n+            >\n+        >\n+    > indexed_transaction_set;\n+\n     mutable CCriticalSection cs;\n-    std::map<uint256, CTxMemPoolEntry> mapTx;\n+    indexed_transaction_set mapTx;\n     std::map<COutPoint, CInPoint> mapNextTx;\n     std::map<uint256, std::pair<double, CAmount> > mapDeltas;\n "
      }
    ]
  },
  {
    "sha": "5add7a74a672cb12b0a2a630d318d9bc64dd0f77",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1YWRkN2E3NGE2NzJjYjEyYjBhMmE2MzBkMzE4ZDliYzY0ZGQwZjc3",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-07-15T18:47:45Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2015-09-19T17:25:48Z"
      },
      "message": "Track transaction packages in CTxMemPoolEntry\n\nAssociate with each CTxMemPoolEntry all the size/fees of descendant\nmempool transactions.  Sort mempool by max(feerate of entry, feerate\nof descendants).  Update statistics on-the-fly as transactions enter\nor leave the mempool.\n\nAlso add ancestor and descendant limiting, so that transactions can\nbe rejected if the number or size of unconfirmed ancestors exceeds\na target, or if adding a transaction would cause some other mempool\nentry to have too many (or too large) a set of unconfirmed in-\nmempool descendants.",
      "tree": {
        "sha": "e8b86acba14f47100af0bbadeb748f6f6a002d58",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e8b86acba14f47100af0bbadeb748f6f6a002d58"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5add7a74a672cb12b0a2a630d318d9bc64dd0f77",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5add7a74a672cb12b0a2a630d318d9bc64dd0f77",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5add7a74a672cb12b0a2a630d318d9bc64dd0f77",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5add7a74a672cb12b0a2a630d318d9bc64dd0f77/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "34628a18070064e75b35f28fd6a43d5c23832eb8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34628a18070064e75b35f28fd6a43d5c23832eb8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/34628a18070064e75b35f28fd6a43d5c23832eb8"
      }
    ],
    "stats": {
      "total": 1058,
      "additions": 993,
      "deletions": 65
    },
    "files": [
      {
        "sha": "2e8a7c69ce127ef9b4e52d182d2b8df3cd7b382e",
        "filename": "qa/pull-tester/rpc-tests.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5add7a74a672cb12b0a2a630d318d9bc64dd0f77/qa/pull-tester/rpc-tests.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5add7a74a672cb12b0a2a630d318d9bc64dd0f77/qa/pull-tester/rpc-tests.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.sh?ref=5add7a74a672cb12b0a2a630d318d9bc64dd0f77",
        "patch": "@@ -57,6 +57,7 @@ testScriptsExt=(\n     'invalidblockrequest.py'\n #    'forknotify.py'\n     'p2p-acceptblock.py'\n+    'mempool_packages.py'\n );\n \n #if [ \"x$ENABLE_ZMQ\" = \"x1\" ]; then"
      },
      {
        "sha": "6041f3a3dd9842ee2dc285eac1ed211dbdb72df4",
        "filename": "qa/rpc-tests/mempool_packages.py",
        "status": "added",
        "additions": 107,
        "deletions": 0,
        "changes": 107,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5add7a74a672cb12b0a2a630d318d9bc64dd0f77/qa/rpc-tests/mempool_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5add7a74a672cb12b0a2a630d318d9bc64dd0f77/qa/rpc-tests/mempool_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/mempool_packages.py?ref=5add7a74a672cb12b0a2a630d318d9bc64dd0f77",
        "patch": "@@ -0,0 +1,107 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+# Test descendant package tracking code\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+def satoshi_round(amount):\n+    return  Decimal(amount).quantize(Decimal('0.00000001'), rounding=ROUND_DOWN)\n+\n+class MempoolPackagesTest(BitcoinTestFramework):\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-maxorphantx=1000\", \"-relaypriority=0\"]))\n+        self.is_network_split = False\n+        self.sync_all()\n+\n+    # Build a transaction that spends parent_txid:vout\n+    # Return amount sent\n+    def chain_transaction(self, parent_txid, vout, value, fee, num_outputs):\n+        send_value = satoshi_round((value - fee)/num_outputs)\n+        inputs = [ {'txid' : parent_txid, 'vout' : vout} ]\n+        outputs = {}\n+        for i in xrange(num_outputs):\n+            outputs[self.nodes[0].getnewaddress()] = send_value\n+        rawtx = self.nodes[0].createrawtransaction(inputs, outputs)\n+        signedtx = self.nodes[0].signrawtransaction(rawtx)\n+        txid = self.nodes[0].sendrawtransaction(signedtx['hex'])\n+        fulltx = self.nodes[0].getrawtransaction(txid, 1)\n+        assert(len(fulltx['vout']) == num_outputs) # make sure we didn't generate a change output\n+        return (txid, send_value)\n+\n+    def run_test(self):\n+        ''' Mine some blocks and have them mature. '''\n+        self.nodes[0].generate(101)\n+        utxo = self.nodes[0].listunspent(10)\n+        txid = utxo[0]['txid']\n+        vout = utxo[0]['vout']\n+        value = utxo[0]['amount']\n+\n+        fee = Decimal(\"0.0001\")\n+        # 100 transactions off a confirmed tx should be fine\n+        chain = []\n+        for i in xrange(100):\n+            (txid, sent_value) = self.chain_transaction(txid, 0, value, fee, 1)\n+            value = sent_value\n+            chain.append(txid)\n+\n+        # Check mempool has 100 transactions in it, and descendant\n+        # count and fees should look correct\n+        mempool = self.nodes[0].getrawmempool(True)\n+        assert_equal(len(mempool), 100)\n+        descendant_count = 1\n+        descendant_fees = 0\n+        descendant_size = 0\n+        SATOSHIS = 100000000\n+\n+        for x in reversed(chain):\n+            assert_equal(mempool[x]['descendantcount'], descendant_count)\n+            descendant_fees += mempool[x]['fee']\n+            assert_equal(mempool[x]['descendantfees'], SATOSHIS*descendant_fees)\n+            descendant_size += mempool[x]['size']\n+            assert_equal(mempool[x]['descendantsize'], descendant_size)\n+            descendant_count += 1\n+\n+        # Adding one more transaction on to the chain should fail.\n+        try:\n+            self.chain_transaction(txid, vout, value, fee, 1)\n+        except JSONRPCException as e:\n+            print \"too-long-ancestor-chain successfully rejected\"\n+\n+        # TODO: test ancestor size limits\n+\n+        # Now test descendant chain limits\n+        txid = utxo[1]['txid']\n+        value = utxo[1]['amount']\n+        vout = utxo[1]['vout']\n+\n+        transaction_package = []\n+        # First create one parent tx with 10 children\n+        (txid, sent_value) = self.chain_transaction(txid, vout, value, fee, 10)\n+        parent_transaction = txid\n+        for i in xrange(10):\n+            transaction_package.append({'txid': txid, 'vout': i, 'amount': sent_value})\n+\n+        for i in xrange(1000):\n+            utxo = transaction_package.pop(0)\n+            try:\n+                (txid, sent_value) = self.chain_transaction(utxo['txid'], utxo['vout'], utxo['amount'], fee, 10)\n+                for j in xrange(10):\n+                    transaction_package.append({'txid': txid, 'vout': j, 'amount': sent_value})\n+                if i == 998:\n+                    mempool = self.nodes[0].getrawmempool(True)\n+                    assert_equal(mempool[parent_transaction]['descendantcount'], 1000)\n+            except JSONRPCException as e:\n+                print e.error['message']\n+                assert_equal(i, 999)\n+                print \"tx that would create too large descendant package successfully rejected\"\n+\n+        # TODO: test descendant size limits\n+\n+if __name__ == '__main__':\n+    MempoolPackagesTest().main()"
      },
      {
        "sha": "9f1c1f6864e08152cdb7fc1cded75f8e8c9bb99e",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5add7a74a672cb12b0a2a630d318d9bc64dd0f77/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5add7a74a672cb12b0a2a630d318d9bc64dd0f77/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=5add7a74a672cb12b0a2a630d318d9bc64dd0f77",
        "patch": "@@ -411,6 +411,10 @@ std::string HelpMessage(HelpMessageMode mode)\n         strUsage += HelpMessageOpt(\"-fuzzmessagestest=<n>\", \"Randomly fuzz 1 of every <n> network messages\");\n         strUsage += HelpMessageOpt(\"-flushwallet\", strprintf(\"Run a thread to flush wallet periodically (default: %u)\", 1));\n         strUsage += HelpMessageOpt(\"-stopafterblockimport\", strprintf(\"Stop running after importing blocks from disk (default: %u)\", 0));\n+        strUsage += HelpMessageOpt(\"-limitancestorcount=<n>\", strprintf(\"Do not accept transactions if number of in-mempool ancestors is <n> or more (default: %u)\", DEFAULT_ANCESTOR_LIMIT));\n+        strUsage += HelpMessageOpt(\"-limitancestorsize=<n>\", strprintf(\"Do not accept transactions whose size with all in-mempool ancestors exceeds <n> kilobytes (default: %u)\", DEFAULT_ANCESTOR_SIZE_LIMIT));\n+        strUsage += HelpMessageOpt(\"-limitdescendantcount=<n>\", strprintf(\"Do not accept transactions if any ancestor would have <n> or more in-mempool descendants (default: %u)\", DEFAULT_DESCENDANT_LIMIT));\n+        strUsage += HelpMessageOpt(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT));\n     }\n     string debugCategories = \"addrman, alert, bench, coindb, db, lock, rand, rpc, selectcoins, mempool, mempoolrej, net, proxy, prune, http\"; // Don't translate these and qt below\n     if (mode == HMM_BITCOIN_QT)"
      },
      {
        "sha": "2a24d38e52760e2a5286a482832552e9d7986154",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 3,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5add7a74a672cb12b0a2a630d318d9bc64dd0f77/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5add7a74a672cb12b0a2a630d318d9bc64dd0f77/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=5add7a74a672cb12b0a2a630d318d9bc64dd0f77",
        "patch": "@@ -921,6 +921,17 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, ::minRelayTxFee.GetFee(nSize) * 10000));\n \n+        // Calculate in-mempool ancestors, up to a limit.\n+        CTxMemPool::setEntries setAncestors;\n+        size_t nLimitAncestors = GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        size_t nLimitAncestorSize = GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n+        size_t nLimitDescendants = GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        size_t nLimitDescendantSize = GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+        std::string errString;\n+        if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n+            return state.DoS(0, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", false, errString);\n+        }\n+\n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n         if (!CheckInputs(tx, state, view, true, STANDARD_SCRIPT_VERIFY_FLAGS, true))\n@@ -942,7 +953,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         }\n \n         // Store transaction in memory\n-        pool.addUnchecked(hash, entry, !IsInitialBlockDownload());\n+        pool.addUnchecked(hash, entry, setAncestors, !IsInitialBlockDownload());\n     }\n \n     SyncWithWallets(tx, NULL);\n@@ -2033,13 +2044,23 @@ bool static DisconnectTip(CValidationState &state) {\n     if (!FlushStateToDisk(state, FLUSH_STATE_IF_NEEDED))\n         return false;\n     // Resurrect mempool transactions from the disconnected block.\n+    std::vector<uint256> vHashUpdate;\n     BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n         // ignore validation errors in resurrected transactions\n         list<CTransaction> removed;\n         CValidationState stateDummy;\n-        if (tx.IsCoinBase() || !AcceptToMemoryPool(mempool, stateDummy, tx, false, NULL))\n+        if (tx.IsCoinBase() || !AcceptToMemoryPool(mempool, stateDummy, tx, false, NULL)) {\n             mempool.remove(tx, removed, true);\n+        } else if (mempool.exists(tx.GetHash())) {\n+            vHashUpdate.push_back(tx.GetHash());\n+        }\n     }\n+    // AcceptToMemoryPool/addUnchecked all assume that new mempool entries have\n+    // no in-mempool children, which is generally not true when adding\n+    // previously-confirmed transactions back to the mempool.\n+    // UpdateTransactionsFromBlock finds descendants of any transactions in this\n+    // block that were added back and cleans up the mempool state.\n+    mempool.UpdateTransactionsFromBlock(vHashUpdate);\n     mempool.removeCoinbaseSpends(pcoinsTip, pindexDelete->nHeight);\n     mempool.check(pcoinsTip);\n     // Update chainActive and related variables.\n@@ -4258,7 +4279,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             LogPrint(\"mempool\", \"AcceptToMemoryPool: peer=%d %s: accepted %s (poolsz %u)\\n\",\n                 pfrom->id, pfrom->cleanSubVer,\n                 tx.GetHash().ToString(),\n-                mempool.mapTx.size());\n+                mempool.size());\n \n             // Recursively process any orphan transactions that depended on this one\n             set<NodeId> setMisbehaving;"
      },
      {
        "sha": "a6001eed8f1c6823f80cd7ba127c5c781848ee5d",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5add7a74a672cb12b0a2a630d318d9bc64dd0f77/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5add7a74a672cb12b0a2a630d318d9bc64dd0f77/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=5add7a74a672cb12b0a2a630d318d9bc64dd0f77",
        "patch": "@@ -43,6 +43,14 @@ struct CNodeStateStats;\n static const bool DEFAULT_ALERTS = true;\n /** Default for -maxorphantx, maximum number of orphan transactions kept in memory */\n static const unsigned int DEFAULT_MAX_ORPHAN_TRANSACTIONS = 100;\n+/** Default for -limitancestorcount, max number of in-mempool ancestors */\n+static const unsigned int DEFAULT_ANCESTOR_LIMIT = 100;\n+/** Default for -limitancestorsize, maximum kilobytes of tx + all in-mempool ancestors */\n+static const unsigned int DEFAULT_ANCESTOR_SIZE_LIMIT = 900;\n+/** Default for -limitdescendantcount, max number of in-mempool descendants */\n+static const unsigned int DEFAULT_DESCENDANT_LIMIT = 1000;\n+/** Default for -limitdescendantsize, maximum kilobytes of in-mempool descendants */\n+static const unsigned int DEFAULT_DESCENDANT_SIZE_LIMIT = 2500;\n /** The maximum size of a blk?????.dat file (since 0.8) */\n static const unsigned int MAX_BLOCKFILE_SIZE = 0x8000000; // 128 MiB\n /** The pre-allocation chunk size for blk?????.dat files (since 0.8) */"
      },
      {
        "sha": "b475c3313b20004b4403604b58d77caec3e1c1fb",
        "filename": "src/memusage.h",
        "status": "modified",
        "additions": 15,
        "deletions": 3,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5add7a74a672cb12b0a2a630d318d9bc64dd0f77/src/memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5add7a74a672cb12b0a2a630d318d9bc64dd0f77/src/memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/memusage.h?ref=5add7a74a672cb12b0a2a630d318d9bc64dd0f77",
        "patch": "@@ -74,18 +74,30 @@ static inline size_t DynamicUsage(const std::vector<X>& v)\n     return MallocUsage(v.capacity() * sizeof(X));\n }\n \n-template<typename X>\n-static inline size_t DynamicUsage(const std::set<X>& s)\n+template<typename X, typename Y>\n+static inline size_t DynamicUsage(const std::set<X, Y>& s)\n {\n     return MallocUsage(sizeof(stl_tree_node<X>)) * s.size();\n }\n \n template<typename X, typename Y>\n-static inline size_t DynamicUsage(const std::map<X, Y>& m)\n+static inline size_t IncrementalDynamicUsage(const std::set<X, Y>& s)\n+{\n+    return MallocUsage(sizeof(stl_tree_node<X>));\n+}\n+\n+template<typename X, typename Y, typename Z>\n+static inline size_t DynamicUsage(const std::map<X, Y, Z>& m)\n {\n     return MallocUsage(sizeof(stl_tree_node<std::pair<const X, Y> >)) * m.size();\n }\n \n+template<typename X, typename Y, typename Z>\n+static inline size_t IncrementalDynamicUsage(const std::map<X, Y, Z>& m)\n+{\n+    return MallocUsage(sizeof(stl_tree_node<std::pair<const X, Y> >));\n+}\n+\n // Boost data structures\n \n template<typename X>"
      },
      {
        "sha": "1c201ef99d16efd9666282eb790bc4b23c925592",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5add7a74a672cb12b0a2a630d318d9bc64dd0f77/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5add7a74a672cb12b0a2a630d318d9bc64dd0f77/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=5add7a74a672cb12b0a2a630d318d9bc64dd0f77",
        "patch": "@@ -191,6 +191,9 @@ UniValue mempoolToJSON(bool fVerbose = false)\n             info.push_back(Pair(\"height\", (int)e.GetHeight()));\n             info.push_back(Pair(\"startingpriority\", e.GetPriority(e.GetHeight())));\n             info.push_back(Pair(\"currentpriority\", e.GetPriority(chainActive.Height())));\n+            info.push_back(Pair(\"descendantcount\", e.GetCountWithDescendants()));\n+            info.push_back(Pair(\"descendantsize\", e.GetSizeWithDescendants()));\n+            info.push_back(Pair(\"descendantfees\", e.GetFeesWithDescendants()));\n             const CTransaction& tx = e.GetTx();\n             set<string> setDepends;\n             BOOST_FOREACH(const CTxIn& txin, tx.vin)\n@@ -245,6 +248,9 @@ UniValue getrawmempool(const UniValue& params, bool fHelp)\n             \"    \\\"height\\\" : n,           (numeric) block height when transaction entered pool\\n\"\n             \"    \\\"startingpriority\\\" : n, (numeric) priority when transaction entered pool\\n\"\n             \"    \\\"currentpriority\\\" : n,  (numeric) transaction priority now\\n\"\n+            \"    \\\"descendantcount\\\" : n,  (numeric) number of in-mempool descendant transactions (including this one)\\n\"\n+            \"    \\\"descendantsize\\\" : n,   (numeric) size of in-mempool descendants (including this one)\\n\"\n+            \"    \\\"descendantfees\\\" : n,   (numeric) fees of in-mempool descendants (including this one)\\n\"\n             \"    \\\"depends\\\" : [           (array) unconfirmed transactions used as inputs for this transaction\\n\"\n             \"        \\\"transactionid\\\",    (string) parent transaction id\\n\"\n             \"       ... ]\\n\""
      },
      {
        "sha": "5bf1e98e8f5156ed9638efe3865ee235e3aeb75d",
        "filename": "src/test/mempool_tests.cpp",
        "status": "modified",
        "additions": 139,
        "deletions": 10,
        "changes": 149,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5add7a74a672cb12b0a2a630d318d9bc64dd0f77/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5add7a74a672cb12b0a2a630d318d9bc64dd0f77/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=5add7a74a672cb12b0a2a630d318d9bc64dd0f77",
        "patch": "@@ -9,6 +9,7 @@\n \n #include <boost/test/unit_test.hpp>\n #include <list>\n+#include <vector>\n \n BOOST_FIXTURE_TEST_SUITE(mempool_tests, TestingSetup)\n \n@@ -100,6 +101,16 @@ BOOST_AUTO_TEST_CASE(MempoolRemoveTest)\n     removed.clear();\n }\n \n+void CheckSort(CTxMemPool &pool, std::vector<std::string> &sortedOrder)\n+{\n+    BOOST_CHECK_EQUAL(pool.size(), sortedOrder.size());\n+    CTxMemPool::indexed_transaction_set::nth_index<1>::type::iterator it = pool.mapTx.get<1>().begin();\n+    int count=0;\n+    for (; it != pool.mapTx.get<1>().end(); ++it, ++count) {\n+        BOOST_CHECK_EQUAL(it->GetTx().GetHash().ToString(), sortedOrder[count]);\n+    }\n+}\n+\n BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n {\n     CTxMemPool pool(CFeeRate(0));\n@@ -138,18 +149,136 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     tx5.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx5.vout[0].nValue = 11 * COIN;\n     pool.addUnchecked(tx5.GetHash(), CTxMemPoolEntry(tx5, 10000LL, 1, 10.0, 1, true));\n-\n-    // there should be 4 transactions in the mempool\n     BOOST_CHECK_EQUAL(pool.size(), 5);\n \n-    // Check the fee-rate index is in order, should be tx2, tx4, tx1, tx5, tx3\n-    CTxMemPool::indexed_transaction_set::nth_index<1>::type::iterator it = pool.mapTx.get<1>().begin();\n-    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx2.GetHash().ToString());\n-    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx4.GetHash().ToString());\n-    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx1.GetHash().ToString());\n-    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx5.GetHash().ToString());\n-    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx3.GetHash().ToString());\n-    BOOST_CHECK(it == pool.mapTx.get<1>().end());\n+    std::vector<std::string> sortedOrder;\n+    sortedOrder.resize(5);\n+    sortedOrder[0] = tx2.GetHash().ToString(); // 20000\n+    sortedOrder[1] = tx4.GetHash().ToString(); // 15000\n+    sortedOrder[2] = tx1.GetHash().ToString(); // 10000\n+    sortedOrder[3] = tx5.GetHash().ToString(); // 10000\n+    sortedOrder[4] = tx3.GetHash().ToString(); // 0\n+    CheckSort(pool, sortedOrder);\n+\n+    /* low fee but with high fee child */\n+    /* tx6 -> tx7 -> tx8, tx9 -> tx10 */\n+    CMutableTransaction tx6 = CMutableTransaction();\n+    tx6.vout.resize(1);\n+    tx6.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx6.vout[0].nValue = 20 * COIN;\n+    pool.addUnchecked(tx6.GetHash(), CTxMemPoolEntry(tx6, 0LL, 1, 10.0, 1, true));\n+    BOOST_CHECK_EQUAL(pool.size(), 6);\n+    // Check that at this point, tx6 is sorted low\n+    sortedOrder.push_back(tx6.GetHash().ToString());\n+    CheckSort(pool, sortedOrder);\n+\n+    CTxMemPool::setEntries setAncestors;\n+    setAncestors.insert(pool.mapTx.find(tx6.GetHash()));\n+    CMutableTransaction tx7 = CMutableTransaction();\n+    tx7.vin.resize(1);\n+    tx7.vin[0].prevout = COutPoint(tx6.GetHash(), 0);\n+    tx7.vin[0].scriptSig = CScript() << OP_11;\n+    tx7.vout.resize(2);\n+    tx7.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx7.vout[0].nValue = 10 * COIN;\n+    tx7.vout[1].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx7.vout[1].nValue = 1 * COIN;\n+\n+    CTxMemPool::setEntries setAncestorsCalculated;\n+    std::string dummy;\n+    CTxMemPoolEntry entry7(tx7, 2000000LL, 1, 10.0, 1, true);\n+    BOOST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(entry7, setAncestorsCalculated, 100, 1000000, 1000, 1000000, dummy), true);\n+    BOOST_CHECK(setAncestorsCalculated == setAncestors);\n+\n+    pool.addUnchecked(tx7.GetHash(), CTxMemPoolEntry(tx7, 2000000LL, 1, 10.0, 1, true), setAncestors);\n+    BOOST_CHECK_EQUAL(pool.size(), 7);\n+\n+    // Now tx6 should be sorted higher (high fee child): tx7, tx6, tx2, ...\n+    sortedOrder.erase(sortedOrder.end()-1);\n+    sortedOrder.insert(sortedOrder.begin(), tx6.GetHash().ToString());\n+    sortedOrder.insert(sortedOrder.begin(), tx7.GetHash().ToString());\n+    CheckSort(pool, sortedOrder);\n+\n+    /* low fee child of tx7 */\n+    CMutableTransaction tx8 = CMutableTransaction();\n+    tx8.vin.resize(1);\n+    tx8.vin[0].prevout = COutPoint(tx7.GetHash(), 0);\n+    tx8.vin[0].scriptSig = CScript() << OP_11;\n+    tx8.vout.resize(1);\n+    tx8.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx8.vout[0].nValue = 10 * COIN;\n+    setAncestors.insert(pool.mapTx.find(tx7.GetHash()));\n+    pool.addUnchecked(tx8.GetHash(), CTxMemPoolEntry(tx8, 0LL, 2, 10.0, 1, true), setAncestors);\n+\n+    // Now tx8 should be sorted low, but tx6/tx both high\n+    sortedOrder.push_back(tx8.GetHash().ToString());\n+    CheckSort(pool, sortedOrder);\n+\n+    /* low fee child of tx7 */\n+    CMutableTransaction tx9 = CMutableTransaction();\n+    tx9.vin.resize(1);\n+    tx9.vin[0].prevout = COutPoint(tx7.GetHash(), 1);\n+    tx9.vin[0].scriptSig = CScript() << OP_11;\n+    tx9.vout.resize(1);\n+    tx9.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx9.vout[0].nValue = 1 * COIN;\n+    pool.addUnchecked(tx9.GetHash(), CTxMemPoolEntry(tx9, 0LL, 3, 10.0, 1, true), setAncestors);\n+\n+    // tx9 should be sorted low\n+    BOOST_CHECK_EQUAL(pool.size(), 9);\n+    sortedOrder.push_back(tx9.GetHash().ToString());\n+    CheckSort(pool, sortedOrder);\n+\n+    std::vector<std::string> snapshotOrder = sortedOrder;\n+\n+    setAncestors.insert(pool.mapTx.find(tx8.GetHash()));\n+    setAncestors.insert(pool.mapTx.find(tx9.GetHash()));\n+    /* tx10 depends on tx8 and tx9 and has a high fee*/\n+    CMutableTransaction tx10 = CMutableTransaction();\n+    tx10.vin.resize(2);\n+    tx10.vin[0].prevout = COutPoint(tx8.GetHash(), 0);\n+    tx10.vin[0].scriptSig = CScript() << OP_11;\n+    tx10.vin[1].prevout = COutPoint(tx9.GetHash(), 0);\n+    tx10.vin[1].scriptSig = CScript() << OP_11;\n+    tx10.vout.resize(1);\n+    tx10.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx10.vout[0].nValue = 10 * COIN;\n+\n+    setAncestorsCalculated.clear();\n+    CTxMemPoolEntry entry10(tx10, 200000LL, 4, 10.0, 1, true);\n+    BOOST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(entry10, setAncestorsCalculated, 100, 1000000, 1000, 1000000, dummy), true);\n+    BOOST_CHECK(setAncestorsCalculated == setAncestors);\n+\n+    pool.addUnchecked(tx10.GetHash(), CTxMemPoolEntry(tx10, 200000LL, 4, 10.0, 1, true), setAncestors);\n+\n+    /**\n+     *  tx8 and tx9 should both now be sorted higher\n+     *  Final order after tx10 is added:\n+     *\n+     *  tx7 = 2.2M (4 txs)\n+     *  tx6 = 2.2M (5 txs)\n+     *  tx10 = 200k (1 tx)\n+     *  tx8 = 200k (2 txs)\n+     *  tx9 = 200k (2 txs)\n+     *  tx2 = 20000 (1)\n+     *  tx4 = 15000 (1)\n+     *  tx1 = 10000 (1)\n+     *  tx5 = 10000 (1)\n+     *  tx3 = 0 (1)\n+     */\n+    sortedOrder.erase(sortedOrder.end()-2, sortedOrder.end()); // take out tx8, tx9 from the end\n+    sortedOrder.insert(sortedOrder.begin()+2, tx10.GetHash().ToString()); // tx10 is after tx6\n+    sortedOrder.insert(sortedOrder.begin()+3, tx9.GetHash().ToString());\n+    sortedOrder.insert(sortedOrder.begin()+3, tx8.GetHash().ToString());\n+    CheckSort(pool, sortedOrder);\n+\n+    // there should be 10 transactions in the mempool\n+    BOOST_CHECK_EQUAL(pool.size(), 10);\n+\n+    // Now try removing tx10 and verify the sort order returns to normal\n+    std::list<CTransaction> removed;\n+    pool.remove(pool.mapTx.find(tx10.GetHash())->GetTx(), removed, true);\n+    CheckSort(pool, snapshotOrder);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "2f603e3c9fbd459ab2b25ad0a54a6cd9019a1bea",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 423,
        "deletions": 42,
        "changes": 465,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5add7a74a672cb12b0a2a630d318d9bc64dd0f77/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5add7a74a672cb12b0a2a630d318d9bc64dd0f77/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=5add7a74a672cb12b0a2a630d318d9bc64dd0f77",
        "patch": "@@ -17,12 +17,6 @@\n \n using namespace std;\n \n-CTxMemPoolEntry::CTxMemPoolEntry():\n-    nFee(0), nTxSize(0), nModSize(0), nUsageSize(0), nTime(0), dPriority(0.0), hadNoDependencies(false)\n-{\n-    nHeight = MEMPOOL_HEIGHT;\n-}\n-\n CTxMemPoolEntry::CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,\n                                  int64_t _nTime, double _dPriority,\n                                  unsigned int _nHeight, bool poolHasNoInputsOf):\n@@ -32,7 +26,10 @@ CTxMemPoolEntry::CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,\n     nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n     nModSize = tx.CalculateModifiedSize(nTxSize);\n     nUsageSize = RecursiveDynamicUsage(tx);\n-    feeRate = CFeeRate(nFee, nTxSize);\n+\n+    nCountWithDescendants = 1;\n+    nSizeWithDescendants = nTxSize;\n+    nFeesWithDescendants = nFee;\n }\n \n CTxMemPoolEntry::CTxMemPoolEntry(const CTxMemPoolEntry& other)\n@@ -49,6 +46,244 @@ CTxMemPoolEntry::GetPriority(unsigned int currentHeight) const\n     return dResult;\n }\n \n+// Update the given tx for any in-mempool descendants.\n+// Assumes that setMemPoolChildren is correct for the given tx and all\n+// descendants.\n+bool CTxMemPool::UpdateForDescendants(txiter updateIt, int maxDescendantsToVisit, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+{\n+    // Track the number of entries (outside setExclude) that we'd need to visit\n+    // (will bail out if it exceeds maxDescendantsToVisit)\n+    int nChildrenToVisit = 0;\n+\n+    setEntries stageEntries, setAllDescendants;\n+    stageEntries = GetMemPoolChildren(updateIt);\n+\n+    while (!stageEntries.empty()) {\n+        const txiter cit = *stageEntries.begin();\n+        if (cit->IsDirty()) {\n+            // Don't consider any more children if any descendant is dirty\n+            return false;\n+        }\n+        setAllDescendants.insert(cit);\n+        stageEntries.erase(cit);\n+        const setEntries &setChildren = GetMemPoolChildren(cit);\n+        BOOST_FOREACH(const txiter childEntry, setChildren) {\n+            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n+            if (cacheIt != cachedDescendants.end()) {\n+                // We've already calculated this one, just add the entries for this set\n+                // but don't traverse again.\n+                BOOST_FOREACH(const txiter cacheEntry, cacheIt->second) {\n+                    // update visit count only for new child transactions\n+                    // (outside of setExclude and stageEntries)\n+                    if (setAllDescendants.insert(cacheEntry).second &&\n+                            !setExclude.count(cacheEntry->GetTx().GetHash()) &&\n+                            !stageEntries.count(cacheEntry)) {\n+                        nChildrenToVisit++;\n+                    }\n+                }\n+            } else if (!setAllDescendants.count(childEntry)) {\n+                // Schedule for later processing and update our visit count\n+                if (stageEntries.insert(childEntry).second && !setExclude.count(childEntry->GetTx().GetHash())) {\n+                        nChildrenToVisit++;\n+                }\n+            }\n+            if (nChildrenToVisit > maxDescendantsToVisit) {\n+                return false;\n+            }\n+        }\n+    }\n+    // setAllDescendants now contains all in-mempool descendants of updateIt.\n+    // Update and add to cached descendant map\n+    int64_t modifySize = 0;\n+    CAmount modifyFee = 0;\n+    int64_t modifyCount = 0;\n+    BOOST_FOREACH(txiter cit, setAllDescendants) {\n+        if (!setExclude.count(cit->GetTx().GetHash())) {\n+            modifySize += cit->GetTxSize();\n+            modifyFee += cit->GetFee();\n+            modifyCount++;\n+            cachedDescendants[updateIt].insert(cit);\n+        }\n+    }\n+    mapTx.modify(updateIt, update_descendant_state(modifySize, modifyFee, modifyCount));\n+    return true;\n+}\n+\n+// vHashesToUpdate is the set of transaction hashes from a disconnected block\n+// which has been re-added to the mempool.\n+// for each entry, look for descendants that are outside hashesToUpdate, and\n+// add fee/size information for such descendants to the parent.\n+void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256> &vHashesToUpdate)\n+{\n+    LOCK(cs);\n+    // For each entry in vHashesToUpdate, store the set of in-mempool, but not\n+    // in-vHashesToUpdate transactions, so that we don't have to recalculate\n+    // descendants when we come across a previously seen entry.\n+    cacheMap mapMemPoolDescendantsToUpdate;\n+\n+    // Use a set for lookups into vHashesToUpdate (these entries are already\n+    // accounted for in the state of their ancestors)\n+    std::set<uint256> setAlreadyIncluded(vHashesToUpdate.begin(), vHashesToUpdate.end());\n+\n+    // Iterate in reverse, so that whenever we are looking at at a transaction\n+    // we are sure that all in-mempool descendants have already been processed.\n+    // This maximizes the benefit of the descendant cache and guarantees that\n+    // setMemPoolChildren will be updated, an assumption made in\n+    // UpdateForDescendants.\n+    BOOST_REVERSE_FOREACH(const uint256 &hash, vHashesToUpdate) {\n+        // we cache the in-mempool children to avoid duplicate updates\n+        setEntries setChildren;\n+        // calculate children from mapNextTx\n+        txiter it = mapTx.find(hash);\n+        if (it == mapTx.end()) {\n+            continue;\n+        }\n+        std::map<COutPoint, CInPoint>::iterator iter = mapNextTx.lower_bound(COutPoint(hash, 0));\n+        // First calculate the children, and update setMemPoolChildren to\n+        // include them, and update their setMemPoolParents to include this tx.\n+        for (; iter != mapNextTx.end() && iter->first.hash == hash; ++iter) {\n+            const uint256 &childHash = iter->second.ptx->GetHash();\n+            txiter childIter = mapTx.find(childHash);\n+            assert(childIter != mapTx.end());\n+            // We can skip updating entries we've encountered before or that\n+            // are in the block (which are already accounted for).\n+            if (setChildren.insert(childIter).second && !setAlreadyIncluded.count(childHash)) {\n+                UpdateChild(it, childIter, true);\n+                UpdateParent(childIter, it, true);\n+            }\n+        }\n+        if (!UpdateForDescendants(it, 100, mapMemPoolDescendantsToUpdate, setAlreadyIncluded)) {\n+            // Mark as dirty if we can't do the calculation.\n+            mapTx.modify(it, set_dirty());\n+        }\n+    }\n+}\n+\n+bool CTxMemPool::CalculateMemPoolAncestors(const CTxMemPoolEntry &entry, setEntries &setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string &errString)\n+{\n+    setEntries parentHashes;\n+    const CTransaction &tx = entry.GetTx();\n+\n+    // Get parents of this transaction that are in the mempool\n+    // Entry may or may not already be in the mempool, and GetMemPoolParents()\n+    // is only valid for entries in the mempool, so we iterate mapTx to find\n+    // parents.\n+    // TODO: optimize this so that we only check limits and walk\n+    // tx.vin when called on entries not already in the mempool.\n+    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+        txiter piter = mapTx.find(tx.vin[i].prevout.hash);\n+        if (piter != mapTx.end()) {\n+            parentHashes.insert(piter);\n+            if (parentHashes.size() + 1 > limitAncestorCount) {\n+                errString = strprintf(\"too many unconfirmed parents [limit: %u]\", limitAncestorCount);\n+                return false;\n+            }\n+        }\n+    }\n+\n+    size_t totalSizeWithAncestors = entry.GetTxSize();\n+\n+    while (!parentHashes.empty()) {\n+        txiter stageit = *parentHashes.begin();\n+\n+        setAncestors.insert(stageit);\n+        parentHashes.erase(stageit);\n+        totalSizeWithAncestors += stageit->GetTxSize();\n+\n+        if (stageit->GetSizeWithDescendants() + entry.GetTxSize() > limitDescendantSize) {\n+            errString = strprintf(\"exceeds descendant size limit for tx %s [limit: %u]\", stageit->GetTx().GetHash().ToString(), limitDescendantSize);\n+            return false;\n+        } else if (stageit->GetCountWithDescendants() + 1 > limitDescendantCount) {\n+            errString = strprintf(\"too many descendants for tx %s [limit: %u]\", stageit->GetTx().GetHash().ToString(), limitDescendantCount);\n+            return false;\n+        } else if (totalSizeWithAncestors > limitAncestorSize) {\n+            errString = strprintf(\"exceeds ancestor size limit [limit: %u]\", limitAncestorSize);\n+            return false;\n+        }\n+\n+        const setEntries & setMemPoolParents = GetMemPoolParents(stageit);\n+        BOOST_FOREACH(const txiter &phash, setMemPoolParents) {\n+            // If this is a new ancestor, add it.\n+            if (setAncestors.count(phash) == 0) {\n+                parentHashes.insert(phash);\n+            }\n+            if (parentHashes.size() + setAncestors.size() + 1 > limitAncestorCount) {\n+                errString = strprintf(\"too many unconfirmed ancestors [limit: %u]\", limitAncestorCount);\n+                return false;\n+            }\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+void CTxMemPool::UpdateAncestorsOf(bool add, txiter it, setEntries &setAncestors)\n+{\n+    setEntries parentIters = GetMemPoolParents(it);\n+    // add or remove this tx as a child of each parent\n+    BOOST_FOREACH(txiter piter, parentIters) {\n+        UpdateChild(piter, it, add);\n+    }\n+    const int64_t updateCount = (add ? 1 : -1);\n+    const int64_t updateSize = updateCount * it->GetTxSize();\n+    const CAmount updateFee = updateCount * it->GetFee();\n+    BOOST_FOREACH(txiter ancestorIt, setAncestors) {\n+        mapTx.modify(ancestorIt, update_descendant_state(updateSize, updateFee, updateCount));\n+    }\n+}\n+\n+void CTxMemPool::UpdateChildrenForRemoval(txiter it)\n+{\n+    const setEntries &setMemPoolChildren = GetMemPoolChildren(it);\n+    BOOST_FOREACH(txiter updateIt, setMemPoolChildren) {\n+        UpdateParent(updateIt, it, false);\n+    }\n+}\n+\n+void CTxMemPool::UpdateForRemoveFromMempool(const setEntries &entriesToRemove)\n+{\n+    // For each entry, walk back all ancestors and decrement size associated with this\n+    // transaction\n+    const uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();\n+    BOOST_FOREACH(txiter removeIt, entriesToRemove) {\n+        setEntries setAncestors;\n+        const CTxMemPoolEntry &entry = *removeIt;\n+        std::string dummy;\n+        CalculateMemPoolAncestors(entry, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy);\n+        // Note that UpdateAncestorsOf severs the child links that point to\n+        // removeIt in the entries for the parents of removeIt.  This is\n+        // fine since we don't need to use the mempool children of any entries\n+        // to walk back over our ancestors (but we do need the mempool\n+        // parents!)\n+        UpdateAncestorsOf(false, removeIt, setAncestors);\n+    }\n+    // After updating all the ancestor sizes, we can now sever the link between each\n+    // transaction being removed and any mempool children (ie, update setMemPoolParents\n+    // for each direct child of a transaction being removed).\n+    BOOST_FOREACH(txiter removeIt, entriesToRemove) {\n+        UpdateChildrenForRemoval(removeIt);\n+    }\n+}\n+\n+void CTxMemPoolEntry::SetDirty()\n+{\n+    nCountWithDescendants = 0;\n+    nSizeWithDescendants = nTxSize;\n+    nFeesWithDescendants = nFee;\n+}\n+\n+void CTxMemPoolEntry::UpdateState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount)\n+{\n+    if (!IsDirty()) {\n+        nSizeWithDescendants += modifySize;\n+        assert(int64_t(nSizeWithDescendants) > 0);\n+        nFeesWithDescendants += modifyFee;\n+        assert(nFeesWithDescendants >= 0);\n+        nCountWithDescendants += modifyCount;\n+        assert(int64_t(nCountWithDescendants) > 0);\n+    }\n+}\n+\n CTxMemPool::CTxMemPool(const CFeeRate& _minRelayFee) :\n     nTransactionsUpdated(0)\n {\n@@ -90,34 +325,103 @@ void CTxMemPool::AddTransactionsUpdated(unsigned int n)\n     nTransactionsUpdated += n;\n }\n \n-\n-bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, bool fCurrentEstimate)\n+bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, setEntries &setAncestors, bool fCurrentEstimate)\n {\n     // Add to memory pool without checking anything.\n     // Used by main.cpp AcceptToMemoryPool(), which DOES do\n     // all the appropriate checks.\n     LOCK(cs);\n-    mapTx.insert(entry);\n-    const CTransaction& tx = mapTx.find(hash)->GetTx();\n-    for (unsigned int i = 0; i < tx.vin.size(); i++)\n+    indexed_transaction_set::iterator newit = mapTx.insert(entry).first;\n+    mapLinks.insert(make_pair(newit, TxLinks()));\n+\n+    // Update cachedInnerUsage to include contained transaction's usage.\n+    // (When we update the entry for in-mempool parents, memory usage will be\n+    // further updated.)\n+    cachedInnerUsage += entry.DynamicMemoryUsage();\n+\n+    const CTransaction& tx = newit->GetTx();\n+    std::set<uint256> setParentTransactions;\n+    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n         mapNextTx[tx.vin[i].prevout] = CInPoint(&tx, i);\n+        setParentTransactions.insert(tx.vin[i].prevout.hash);\n+    }\n+    // Don't bother worrying about child transactions of this one.\n+    // Normal case of a new transaction arriving is that there can't be any\n+    // children, because such children would be orphans.\n+    // An exception to that is if a transaction enters that used to be in a block.\n+    // In that case, our disconnect block logic will call UpdateTransactionsFromBlock\n+    // to clean up the mess we're leaving here.\n+\n+    // Update ancestors with information about this tx\n+    BOOST_FOREACH (const uint256 &phash, setParentTransactions) {\n+        txiter pit = mapTx.find(phash);\n+        if (pit != mapTx.end()) {\n+            UpdateParent(newit, pit, true);\n+        }\n+    }\n+    UpdateAncestorsOf(true, newit, setAncestors);\n+\n     nTransactionsUpdated++;\n     totalTxSize += entry.GetTxSize();\n-    cachedInnerUsage += entry.DynamicMemoryUsage();\n     minerPolicyEstimator->processTransaction(entry, fCurrentEstimate);\n \n     return true;\n }\n \n+void CTxMemPool::removeUnchecked(txiter it)\n+{\n+    const uint256 hash = it->GetTx().GetHash();\n+    BOOST_FOREACH(const CTxIn& txin, it->GetTx().vin)\n+        mapNextTx.erase(txin.prevout);\n+\n+    totalTxSize -= it->GetTxSize();\n+    cachedInnerUsage -= it->DynamicMemoryUsage();\n+    cachedInnerUsage -= memusage::DynamicUsage(mapLinks[it].parents) + memusage::DynamicUsage(mapLinks[it].children);\n+    mapLinks.erase(it);\n+    mapTx.erase(it);\n+    nTransactionsUpdated++;\n+    minerPolicyEstimator->removeTx(hash);\n+}\n+\n+// Calculates descendants of entry that are not already in setDescendants, and adds to\n+// setDescendants. Assumes entryit is already a tx in the mempool and setMemPoolChildren\n+// is correct for tx and all descendants.\n+// Also assumes that if an entry is in setDescendants already, then all\n+// in-mempool descendants of it are already in setDescendants as well, so that we\n+// can save time by not iterating over those entries.\n+void CTxMemPool::CalculateDescendants(txiter entryit, setEntries &setDescendants)\n+{\n+    setEntries stage;\n+    if (setDescendants.count(entryit) == 0) {\n+        stage.insert(entryit);\n+    }\n+    // Traverse down the children of entry, only adding children that are not\n+    // accounted for in setDescendants already (because those children have either\n+    // already been walked, or will be walked in this iteration).\n+    while (!stage.empty()) {\n+        txiter it = *stage.begin();\n+        setDescendants.insert(it);\n+        stage.erase(it);\n+\n+        const setEntries &setChildren = GetMemPoolChildren(it);\n+        BOOST_FOREACH(const txiter &childiter, setChildren) {\n+            if (!setDescendants.count(childiter)) {\n+                stage.insert(childiter);\n+            }\n+        }\n+    }\n+}\n \n void CTxMemPool::remove(const CTransaction &origTx, std::list<CTransaction>& removed, bool fRecursive)\n {\n     // Remove transaction from memory pool\n     {\n         LOCK(cs);\n-        std::deque<uint256> txToRemove;\n-        txToRemove.push_back(origTx.GetHash());\n-        if (fRecursive && !mapTx.count(origTx.GetHash())) {\n+        setEntries txToRemove;\n+        txiter origit = mapTx.find(origTx.GetHash());\n+        if (origit != mapTx.end()) {\n+            txToRemove.insert(origit);\n+        } else if (fRecursive) {\n             // If recursively removing but origTx isn't in the mempool\n             // be sure to remove any children that are in the pool. This can\n             // happen during chain re-orgs if origTx isn't re-accepted into\n@@ -126,34 +430,23 @@ void CTxMemPool::remove(const CTransaction &origTx, std::list<CTransaction>& rem\n                 std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(origTx.GetHash(), i));\n                 if (it == mapNextTx.end())\n                     continue;\n-                txToRemove.push_back(it->second.ptx->GetHash());\n+                txiter nextit = mapTx.find(it->second.ptx->GetHash());\n+                assert(nextit != mapTx.end());\n+                txToRemove.insert(nextit);\n             }\n         }\n-        while (!txToRemove.empty())\n-        {\n-            uint256 hash = txToRemove.front();\n-            txToRemove.pop_front();\n-            if (!mapTx.count(hash))\n-                continue;\n-            const CTransaction& tx = mapTx.find(hash)->GetTx();\n-            if (fRecursive) {\n-                for (unsigned int i = 0; i < tx.vout.size(); i++) {\n-                    std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(hash, i));\n-                    if (it == mapNextTx.end())\n-                        continue;\n-                    txToRemove.push_back(it->second.ptx->GetHash());\n-                }\n+        setEntries setAllRemoves;\n+        if (fRecursive) {\n+            BOOST_FOREACH(txiter it, txToRemove) {\n+                CalculateDescendants(it, setAllRemoves);\n             }\n-            BOOST_FOREACH(const CTxIn& txin, tx.vin)\n-                mapNextTx.erase(txin.prevout);\n-\n-            removed.push_back(tx);\n-            totalTxSize -= mapTx.find(hash)->GetTxSize();\n-            cachedInnerUsage -= mapTx.find(hash)->DynamicMemoryUsage();\n-            mapTx.erase(hash);\n-            nTransactionsUpdated++;\n-            minerPolicyEstimator->removeTx(hash);\n+        } else {\n+            setAllRemoves.swap(txToRemove);\n+        }\n+        BOOST_FOREACH(txiter it, setAllRemoves) {\n+            removed.push_back(it->GetTx());\n         }\n+        RemoveStaged(setAllRemoves);\n     }\n }\n \n@@ -229,6 +522,7 @@ void CTxMemPool::removeForBlock(const std::vector<CTransaction>& vtx, unsigned i\n void CTxMemPool::clear()\n {\n     LOCK(cs);\n+    mapLinks.clear();\n     mapTx.clear();\n     mapNextTx.clear();\n     totalTxSize = 0;\n@@ -255,14 +549,20 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n         checkTotal += it->GetTxSize();\n         innerUsage += it->DynamicMemoryUsage();\n         const CTransaction& tx = it->GetTx();\n+        txlinksMap::const_iterator linksiter = mapLinks.find(it);\n+        assert(linksiter != mapLinks.end());\n+        const TxLinks &links = linksiter->second;\n+        innerUsage += memusage::DynamicUsage(links.parents) + memusage::DynamicUsage(links.children);\n         bool fDependsWait = false;\n+        setEntries setParentCheck;\n         BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n             // Check that every mempool transaction's inputs refer to available coins, or other mempool tx's.\n             indexed_transaction_set::const_iterator it2 = mapTx.find(txin.prevout.hash);\n             if (it2 != mapTx.end()) {\n                 const CTransaction& tx2 = it2->GetTx();\n                 assert(tx2.vout.size() > txin.prevout.n && !tx2.vout[txin.prevout.n].IsNull());\n                 fDependsWait = true;\n+                setParentCheck.insert(it2);\n             } else {\n                 const CCoins* coins = pcoins->AccessCoins(txin.prevout.hash);\n                 assert(coins && coins->IsAvailable(txin.prevout.n));\n@@ -274,6 +574,33 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n             assert(it3->second.n == i);\n             i++;\n         }\n+        assert(setParentCheck == GetMemPoolParents(it));\n+        // Check children against mapNextTx\n+        CTxMemPool::setEntries setChildrenCheck;\n+        std::map<COutPoint, CInPoint>::const_iterator iter = mapNextTx.lower_bound(COutPoint(it->GetTx().GetHash(), 0));\n+        int64_t childSizes = 0;\n+        CAmount childFees = 0;\n+        for (; iter != mapNextTx.end() && iter->first.hash == it->GetTx().GetHash(); ++iter) {\n+            txiter childit = mapTx.find(iter->second.ptx->GetHash());\n+            assert(childit != mapTx.end()); // mapNextTx points to in-mempool transactions\n+            if (setChildrenCheck.insert(childit).second) {\n+                childSizes += childit->GetTxSize();\n+                childFees += childit->GetFee();\n+            }\n+        }\n+        assert(setChildrenCheck == GetMemPoolChildren(it));\n+        // Also check to make sure size/fees is greater than sum with immediate children.\n+        // just a sanity check, not definitive that this calc is correct...\n+        // also check that the size is less than the size of the entire mempool.\n+        if (!it->IsDirty()) {\n+            assert(it->GetSizeWithDescendants() >= childSizes + it->GetTxSize());\n+            assert(it->GetFeesWithDescendants() >= childFees + it->GetFee());\n+        } else {\n+            assert(it->GetSizeWithDescendants() == it->GetTxSize());\n+            assert(it->GetFeesWithDescendants() == it->GetFee());\n+        }\n+        assert(it->GetFeesWithDescendants() >= 0);\n+\n         if (fDependsWait)\n             waitingOnDependants.push_back(&(*it));\n         else {\n@@ -432,6 +759,60 @@ bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) const {\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n     LOCK(cs);\n-    // Estimate the overhead of mapTx to be 6 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n-    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 6 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n+    // Estimate the overhead of mapTx to be 9 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + memusage::DynamicUsage(mapLinks) + cachedInnerUsage;\n+}\n+\n+void CTxMemPool::RemoveStaged(setEntries &stage) {\n+    AssertLockHeld(cs);\n+    UpdateForRemoveFromMempool(stage);\n+    BOOST_FOREACH(const txiter& it, stage) {\n+        removeUnchecked(it);\n+    }\n+}\n+\n+bool CTxMemPool::addUnchecked(const uint256&hash, const CTxMemPoolEntry &entry, bool fCurrentEstimate)\n+{\n+    LOCK(cs);\n+    setEntries setAncestors;\n+    uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();\n+    std::string dummy;\n+    CalculateMemPoolAncestors(entry, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy);\n+    return addUnchecked(hash, entry, setAncestors, fCurrentEstimate);\n+}\n+\n+void CTxMemPool::UpdateChild(txiter entry, txiter child, bool add)\n+{\n+    setEntries s;\n+    if (add && mapLinks[entry].children.insert(child).second) {\n+        cachedInnerUsage += memusage::IncrementalDynamicUsage(s);\n+    } else if (!add && mapLinks[entry].children.erase(child)) {\n+        cachedInnerUsage -= memusage::IncrementalDynamicUsage(s);\n+    }\n+}\n+\n+void CTxMemPool::UpdateParent(txiter entry, txiter parent, bool add)\n+{\n+    setEntries s;\n+    if (add && mapLinks[entry].parents.insert(parent).second) {\n+        cachedInnerUsage += memusage::IncrementalDynamicUsage(s);\n+    } else if (!add && mapLinks[entry].parents.erase(parent)) {\n+        cachedInnerUsage -= memusage::IncrementalDynamicUsage(s);\n+    }\n+}\n+\n+const CTxMemPool::setEntries & CTxMemPool::GetMemPoolParents(txiter entry) const\n+{\n+    assert (entry != mapTx.end());\n+    txlinksMap::const_iterator it = mapLinks.find(entry);\n+    assert(it != mapLinks.end());\n+    return it->second.parents;\n+}\n+\n+const CTxMemPool::setEntries & CTxMemPool::GetMemPoolChildren(txiter entry) const\n+{\n+    assert (entry != mapTx.end());\n+    txlinksMap::const_iterator it = mapLinks.find(entry);\n+    assert(it != mapLinks.end());\n+    return it->second.children;\n }"
      },
      {
        "sha": "f0c3f7e0f1fe31647574f801a7ea8753115df22b",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 266,
        "deletions": 7,
        "changes": 273,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5add7a74a672cb12b0a2a630d318d9bc64dd0f77/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5add7a74a672cb12b0a2a630d318d9bc64dd0f77/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=5add7a74a672cb12b0a2a630d318d9bc64dd0f77",
        "patch": "@@ -7,6 +7,7 @@\n #define BITCOIN_TXMEMPOOL_H\n \n #include <list>\n+#include <set>\n \n #include \"amount.h\"\n #include \"coins.h\"\n@@ -34,9 +35,25 @@ inline bool AllowFree(double dPriority)\n /** Fake height value used in CCoins to signify they are only in the memory pool (since 0.8) */\n static const unsigned int MEMPOOL_HEIGHT = 0x7FFFFFFF;\n \n-/**\n- * CTxMemPool stores these:\n+class CTxMemPool;\n+\n+/** \\class CTxMemPoolEntry\n+ *\n+ * CTxMemPoolEntry stores data about the correponding transaction, as well\n+ * as data about all in-mempool transactions that depend on the transaction\n+ * (\"descendant\" transactions).\n+ *\n+ * When a new entry is added to the mempool, we update the descendant state\n+ * (nCountWithDescendants, nSizeWithDescendants, and nFeesWithDescendants) for\n+ * all ancestors of the newly added transaction.\n+ *\n+ * If updating the descendant state is skipped, we can mark the entry as\n+ * \"dirty\", and set nSizeWithDescendants/nFeesWithDescendants to equal nTxSize/\n+ * nTxFee. (This can potentially happen during a reorg, where we limit the\n+ * amount of work we're willing to do to avoid consuming too much CPU.)\n+ *\n  */\n+\n class CTxMemPoolEntry\n {\n private:\n@@ -45,27 +62,69 @@ class CTxMemPoolEntry\n     size_t nTxSize; //! ... and avoid recomputing tx size\n     size_t nModSize; //! ... and modified size for priority\n     size_t nUsageSize; //! ... and total memory usage\n-    CFeeRate feeRate; //! ... and fee per kB\n     int64_t nTime; //! Local time when entering the mempool\n     double dPriority; //! Priority when entering the mempool\n     unsigned int nHeight; //! Chain height when entering the mempool\n     bool hadNoDependencies; //! Not dependent on any other txs when it entered the mempool\n \n+    // Information about descendants of this transaction that are in the\n+    // mempool; if we remove this transaction we must remove all of these\n+    // descendants as well.  if nCountWithDescendants is 0, treat this entry as\n+    // dirty, and nSizeWithDescendants and nFeesWithDescendants will not be\n+    // correct.\n+    uint64_t nCountWithDescendants; //! number of descendant transactions\n+    uint64_t nSizeWithDescendants;  //! ... and size\n+    CAmount nFeesWithDescendants;  //! ... and total fees (all including us)\n+\n public:\n     CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,\n                     int64_t _nTime, double _dPriority, unsigned int _nHeight, bool poolHasNoInputsOf = false);\n-    CTxMemPoolEntry();\n     CTxMemPoolEntry(const CTxMemPoolEntry& other);\n \n     const CTransaction& GetTx() const { return this->tx; }\n     double GetPriority(unsigned int currentHeight) const;\n     CAmount GetFee() const { return nFee; }\n-    CFeeRate GetFeeRate() const { return feeRate; }\n     size_t GetTxSize() const { return nTxSize; }\n     int64_t GetTime() const { return nTime; }\n     unsigned int GetHeight() const { return nHeight; }\n     bool WasClearAtEntry() const { return hadNoDependencies; }\n     size_t DynamicMemoryUsage() const { return nUsageSize; }\n+\n+    // Adjusts the descendant state, if this entry is not dirty.\n+    void UpdateState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount);\n+\n+    /** We can set the entry to be dirty if doing the full calculation of in-\n+     *  mempool descendants will be too expensive, which can potentially happen\n+     *  when re-adding transactions from a block back to the mempool.\n+     */\n+    void SetDirty();\n+    bool IsDirty() const { return nCountWithDescendants == 0; }\n+\n+    uint64_t GetCountWithDescendants() const { return nCountWithDescendants; }\n+    uint64_t GetSizeWithDescendants() const { return nSizeWithDescendants; }\n+    CAmount GetFeesWithDescendants() const { return nFeesWithDescendants; }\n+};\n+\n+// Helpers for modifying CTxMemPool::mapTx, which is a boost multi_index.\n+struct update_descendant_state\n+{\n+    update_descendant_state(int64_t _modifySize, CAmount _modifyFee, int64_t _modifyCount) :\n+        modifySize(_modifySize), modifyFee(_modifyFee), modifyCount(_modifyCount)\n+    {}\n+\n+    void operator() (CTxMemPoolEntry &e)\n+        { e.UpdateState(modifySize, modifyFee, modifyCount); }\n+\n+    private:\n+        int64_t modifySize;\n+        CAmount modifyFee;\n+        int64_t modifyCount;\n+};\n+\n+struct set_dirty\n+{\n+    void operator() (CTxMemPoolEntry &e)\n+        { e.SetDirty(); }\n };\n \n // extracts a TxMemPoolEntry's transaction hash\n@@ -78,14 +137,49 @@ struct mempoolentry_txid\n     }\n };\n \n+/** \\class CompareTxMemPoolEntryByFee\n+ *\n+ *  Sort an entry by max(feerate of entry's tx, feerate with all descendants).\n+ */\n class CompareTxMemPoolEntryByFee\n {\n public:\n     bool operator()(const CTxMemPoolEntry& a, const CTxMemPoolEntry& b)\n     {\n-        if (a.GetFeeRate() == b.GetFeeRate())\n+        bool fUseADescendants = UseDescendantFeeRate(a);\n+        bool fUseBDescendants = UseDescendantFeeRate(b);\n+\n+        double aFees = fUseADescendants ? a.GetFeesWithDescendants() : a.GetFee();\n+        double aSize = fUseADescendants ? a.GetSizeWithDescendants() : a.GetTxSize();\n+\n+        double bFees = fUseBDescendants ? b.GetFeesWithDescendants() : b.GetFee();\n+        double bSize = fUseBDescendants ? b.GetSizeWithDescendants() : b.GetTxSize();\n+\n+        // Avoid division by rewriting (a/b > c/d) as (a*d > c*b).\n+        double f1 = aFees * bSize;\n+        double f2 = aSize * bFees;\n+\n+        if (f1 == f2) {\n             return a.GetTime() < b.GetTime();\n-        return a.GetFeeRate() > b.GetFeeRate();\n+        }\n+        return f1 > f2;\n+    }\n+\n+    // Calculate which feerate to use for an entry (avoiding division).\n+    bool UseDescendantFeeRate(const CTxMemPoolEntry &a)\n+    {\n+        double f1 = (double)a.GetFee() * a.GetSizeWithDescendants();\n+        double f2 = (double)a.GetFeesWithDescendants() * a.GetTxSize();\n+        return f2 > f1;\n+    }\n+};\n+\n+class CompareTxMemPoolEntryByEntryTime\n+{\n+public:\n+    bool operator()(const CTxMemPoolEntry& a, const CTxMemPoolEntry& b)\n+    {\n+        return a.GetTime() < b.GetTime();\n     }\n };\n \n@@ -114,6 +208,71 @@ class CInPoint\n  * are added to the pool: if a new transaction double-spends\n  * an input of a transaction in the pool, it is dropped,\n  * as are non-standard transactions.\n+ *\n+ * CTxMemPool::mapTx, and CTxMemPoolEntry bookkeeping:\n+ *\n+ * mapTx is a boost::multi_index that sorts the mempool on 2 criteria:\n+ * - transaction hash\n+ * - feerate [we use max(feerate of tx, feerate of tx with all descendants)]\n+ *\n+ * Note: the term \"descendant\" refers to in-mempool transactions that depend on\n+ * this one, while \"ancestor\" refers to in-mempool transactions that a given\n+ * transaction depends on.\n+ *\n+ * In order for the feerate sort to remain correct, we must update transactions\n+ * in the mempool when new descendants arrive.  To facilitate this, we track\n+ * the set of in-mempool direct parents and direct children in mapLinks.  Within\n+ * each CTxMemPoolEntry, we track the size and fees of all descendants.\n+ *\n+ * Usually when a new transaction is added to the mempool, it has no in-mempool\n+ * children (because any such children would be an orphan).  So in\n+ * addUnchecked(), we:\n+ * - update a new entry's setMemPoolParents to include all in-mempool parents\n+ * - update the new entry's direct parents to include the new tx as a child\n+ * - update all ancestors of the transaction to include the new tx's size/fee\n+ *\n+ * When a transaction is removed from the mempool, we must:\n+ * - update all in-mempool parents to not track the tx in setMemPoolChildren\n+ * - update all ancestors to not include the tx's size/fees in descendant state\n+ * - update all in-mempool children to not include it as a parent\n+ *\n+ * These happen in UpdateForRemoveFromMempool().  (Note that when removing a\n+ * transaction along with its descendants, we must calculate that set of\n+ * transactions to be removed before doing the removal, or else the mempool can\n+ * be in an inconsistent state where it's impossible to walk the ancestors of\n+ * a transaction.)\n+ *\n+ * In the event of a reorg, the assumption that a newly added tx has no\n+ * in-mempool children is false.  In particular, the mempool is in an\n+ * inconsistent state while new transactions are being added, because there may\n+ * be descendant transactions of a tx coming from a disconnected block that are\n+ * unreachable from just looking at transactions in the mempool (the linking\n+ * transactions may also be in the disconnected block, waiting to be added).\n+ * Because of this, there's not much benefit in trying to search for in-mempool\n+ * children in addUnchecked().  Instead, in the special case of transactions\n+ * being added from a disconnected block, we require the caller to clean up the\n+ * state, to account for in-mempool, out-of-block descendants for all the\n+ * in-block transactions by calling UpdateTransactionsFromBlock().  Note that\n+ * until this is called, the mempool state is not consistent, and in particular\n+ * mapLinks may not be correct (and therefore functions like\n+ * CalculateMemPoolAncestors() and CalculateDescendants() that rely\n+ * on them to walk the mempool are not generally safe to use).\n+ *\n+ * Computational limits:\n+ *\n+ * Updating all in-mempool ancestors of a newly added transaction can be slow,\n+ * if no bound exists on how many in-mempool ancestors there may be.\n+ * CalculateMemPoolAncestors() takes configurable limits that are designed to\n+ * prevent these calculations from being too CPU intensive.\n+ *\n+ * Adding transactions from a disconnected block can be very time consuming,\n+ * because we don't have a way to limit the number of in-mempool descendants.\n+ * To bound CPU processing, we limit the amount of work we're willing to do\n+ * to properly update the descendant information for a tx being added from\n+ * a disconnected block.  If we would exceed the limit, then we instead mark\n+ * the entry as \"dirty\", and set the feerate for sorting purposes to be equal\n+ * the feerate of the transaction without any descendants.\n+ *\n  */\n class CTxMemPool\n {\n@@ -141,6 +300,31 @@ class CTxMemPool\n \n     mutable CCriticalSection cs;\n     indexed_transaction_set mapTx;\n+    typedef indexed_transaction_set::nth_index<0>::type::iterator txiter;\n+    struct CompareIteratorByHash {\n+        bool operator()(const txiter &a, const txiter &b) const {\n+            return a->GetTx().GetHash() < b->GetTx().GetHash();\n+        }\n+    };\n+    typedef std::set<txiter, CompareIteratorByHash> setEntries;\n+\n+private:\n+    typedef std::map<txiter, setEntries, CompareIteratorByHash> cacheMap;\n+\n+    struct TxLinks {\n+        setEntries parents;\n+        setEntries children;\n+    };\n+\n+    typedef std::map<txiter, TxLinks, CompareIteratorByHash> txlinksMap;\n+    txlinksMap mapLinks;\n+\n+    const setEntries & GetMemPoolParents(txiter entry) const;\n+    const setEntries & GetMemPoolChildren(txiter entry) const;\n+    void UpdateParent(txiter entry, txiter parent, bool add);\n+    void UpdateChild(txiter entry, txiter child, bool add);\n+\n+public:\n     std::map<COutPoint, CInPoint> mapNextTx;\n     std::map<uint256, std::pair<double, CAmount> > mapDeltas;\n \n@@ -156,7 +340,13 @@ class CTxMemPool\n     void check(const CCoinsViewCache *pcoins) const;\n     void setSanityCheck(bool _fSanityCheck) { fSanityCheck = _fSanityCheck; }\n \n+    // addUnchecked must updated state for all ancestors of a given transaction,\n+    // to track size/count of descendant transactions.  First version of\n+    // addUnchecked can be used to have it call CalculateMemPoolAncestors(), and\n+    // then invoke the second version.\n     bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, bool fCurrentEstimate = true);\n+    bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, setEntries &setAncestors, bool fCurrentEstimate = true);\n+\n     void remove(const CTransaction &tx, std::list<CTransaction>& removed, bool fRecursive = false);\n     void removeCoinbaseSpends(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight);\n     void removeConflicts(const CTransaction &tx, std::list<CTransaction>& removed);\n@@ -178,6 +368,33 @@ class CTxMemPool\n     void ApplyDeltas(const uint256 hash, double &dPriorityDelta, CAmount &nFeeDelta);\n     void ClearPrioritisation(const uint256 hash);\n \n+public:\n+    /** Remove a set of transactions from the mempool.\n+     *  If a transaction is in this set, then all in-mempool descendants must\n+     *  also be in the set.*/\n+    void RemoveStaged(setEntries &stage);\n+\n+    /** When adding transactions from a disconnected block back to the mempool,\n+     *  new mempool entries may have children in the mempool (which is generally\n+     *  not the case when otherwise adding transactions).\n+     *  UpdateTransactionsFromBlock() will find child transactions and update the\n+     *  descendant state for each transaction in hashesToUpdate (excluding any\n+     *  child transactions present in hashesToUpdate, which are already accounted\n+     *  for).  Note: hashesToUpdate should be the set of transactions from the\n+     *  disconnected block that have been accepted back into the mempool.\n+     */\n+    void UpdateTransactionsFromBlock(const std::vector<uint256> &hashesToUpdate);\n+\n+    /** Try to calculate all in-mempool ancestors of entry.\n+     *  (these are all calculated including the tx itself)\n+     *  limitAncestorCount = max number of ancestors\n+     *  limitAncestorSize = max size of ancestors\n+     *  limitDescendantCount = max number of descendants any ancestor can have\n+     *  limitDescendantSize = max size of descendants any ancestor can have\n+     *  errString = populated with error reason if any limits are hit\n+     */\n+    bool CalculateMemPoolAncestors(const CTxMemPoolEntry &entry, setEntries &setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string &errString);\n+\n     unsigned long size()\n     {\n         LOCK(cs);\n@@ -209,6 +426,48 @@ class CTxMemPool\n     bool ReadFeeEstimates(CAutoFile& filein);\n \n     size_t DynamicMemoryUsage() const;\n+\n+private:\n+    /** UpdateForDescendants is used by UpdateTransactionsFromBlock to update\n+     *  the descendants for a single transaction that has been added to the\n+     *  mempool but may have child transactions in the mempool, eg during a\n+     *  chain reorg.  setExclude is the set of descendant transactions in the\n+     *  mempool that must not be accounted for (because any descendants in\n+     *  setExclude were added to the mempool after the transaction being\n+     *  updated and hence their state is already reflected in the parent\n+     *  state).\n+     *\n+     *  If updating an entry requires looking at more than maxDescendantsToVisit\n+     *  transactions, outside of the ones in setExclude, then give up.\n+     *\n+     *  cachedDescendants will be updated with the descendants of the transaction\n+     *  being updated, so that future invocations don't need to walk the\n+     *  same transaction again, if encountered in another transaction chain.\n+     */\n+    bool UpdateForDescendants(txiter updateIt,\n+            int maxDescendantsToVisit,\n+            cacheMap &cachedDescendants,\n+            const std::set<uint256> &setExclude);\n+    /** Update ancestors of hash to add/remove it as a descendant transaction. */\n+    void UpdateAncestorsOf(bool add, txiter hash, setEntries &setAncestors);\n+    /** For each transaction being removed, update ancestors and any direct children. */\n+    void UpdateForRemoveFromMempool(const setEntries &entriesToRemove);\n+    /** Sever link between specified transaction and direct children. */\n+    void UpdateChildrenForRemoval(txiter entry);\n+    /** Populate setDescendants with all in-mempool descendants of hash.\n+     *  Assumes that setDescendants includes all in-mempool descendants of anything\n+     *  already in it.  */\n+    void CalculateDescendants(txiter it, setEntries &setDescendants);\n+\n+    /** Before calling removeUnchecked for a given transaction,\n+     *  UpdateForRemoveFromMempool must be called on the entire (dependent) set\n+     *  of transactions being removed at the same time.  We use each\n+     *  CTxMemPoolEntry's setMemPoolParents in order to walk ancestors of a\n+     *  given transaction that is removed, so we can't remove intermediate\n+     *  transactions in a chain before we've updated all the state for the\n+     *  removal.\n+     */\n+    void removeUnchecked(txiter entry);\n };\n \n /** "
      }
    ]
  }
]