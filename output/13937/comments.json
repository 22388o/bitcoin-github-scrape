[
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/412092374",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13937#issuecomment-412092374",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13937",
    "id": 412092374,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMjA5MjM3NA==",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-10T14:04:40Z",
    "updated_at": "2018-08-10T14:04:40Z",
    "author_association": "MEMBER",
    "body": "cc @TheBlueMatt, @MarcoFalke, @jamesob as this touches your work\r\n\r\ncc @jonasschnelli  since you reviewed the original PR (@skeees did too, but only the commit that I dropped)  ",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/412092374/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/412134370",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13937#issuecomment-412134370",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13937",
    "id": 412134370,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMjEzNDM3MA==",
    "user": {
      "login": "DrahtBot",
      "id": 39886733,
      "node_id": "MDQ6VXNlcjM5ODg2NzMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/39886733?u=3c1e73d828cf5a5850dfc25c8397c1cf751db5ac&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DrahtBot",
      "html_url": "https://github.com/DrahtBot",
      "followers_url": "https://api.github.com/users/DrahtBot/followers",
      "following_url": "https://api.github.com/users/DrahtBot/following{/other_user}",
      "gists_url": "https://api.github.com/users/DrahtBot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
      "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
      "repos_url": "https://api.github.com/users/DrahtBot/repos",
      "events_url": "https://api.github.com/users/DrahtBot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-10T16:24:50Z",
    "updated_at": "2018-11-13T19:17:02Z",
    "author_association": "CONTRIBUTOR",
    "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#14624](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14624.html) (Some simple improvements to the RNG code by sipa)\n* [#12151](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/12151.html) (rpc: Remove cs_main lock from blockToJSON and blockheaderToJSON by promag)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/412134370/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/416041790",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13937#issuecomment-416041790",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13937",
    "id": 416041790,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxNjA0MTc5MA==",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-26T14:12:28Z",
    "updated_at": "2018-08-26T14:26:43Z",
    "author_association": "MEMBER",
    "body": "Rebased.\r\n\r\nI added commits to explicitly handle cases where `GetBestHeader()` returns `nullptr` in `validation.cpp`. Both cases are UI related and don't seem very important, so they're handled in a fairly lazy way.\r\n\r\nI added a commit to make header count fall back to block height in `getblockchaininfo` (`rpc/blockchain.cpp`).\r\n\r\nThat leaves `net_processing.cpp`, where I'm not sure what to do:\r\n\r\n* one existing assert in:\r\n https://github.com/bitcoin/bitcoin/blob/9ce44d8156576c58390a10007b60f507d107d042/src/net_processing.cpp#L3308\r\n* one deference `->GetBlockTime()` in `BlockRequestAllowed`\r\n* one dereference in `->GetBlockTime()`` in `ProcessGetBlockData`\r\n* one passing the pointer on to `connman` in `ProcessHeadersMessage`\r\n* passing into `chainActive.GetLocator` in `ProcessMessage`\r\n\r\nOriginal commit where `pindexBestHeader` was replaced by `GetBestHeader()` for reference: https://github.com/bitcoin/bitcoin/pull/12138/commits/8525f50c369e737098f785c6867d89f392b77f95\r\n\r\nI'm not sure if those are safe.\r\n\r\nPerhaps there should be a guarantee that `GetBestHeader()` returns the last known valid block (worst case genesis), by inserting that whenever the last entry is deleted?",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/416041790/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/434218370",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13937#issuecomment-434218370",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13937",
    "id": 434218370,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNDIxODM3MA==",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-30T08:50:11Z",
    "updated_at": "2018-10-30T08:50:11Z",
    "author_association": "MEMBER",
    "body": "Rebased. I'll hold back on addressing specific feedback until there's some high level agreement on whether this is useful at all.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/434218370/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/443168600",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13937#issuecomment-443168600",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13937",
    "id": 443168600,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MzE2ODYwMA==",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-30T10:58:35Z",
    "updated_at": "2018-11-30T10:58:35Z",
    "author_association": "MEMBER",
    "body": "Abandoning for now. Consider it up for grabs, but I suggest getting concept ACKs before trying to rebase.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/443168600/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/443773740",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13937#issuecomment-443773740",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13937",
    "id": 443773740,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0Mzc3Mzc0MA==",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-03T16:30:19Z",
    "updated_at": "2018-12-03T16:30:19Z",
    "author_association": "CONTRIBUTOR",
    "body": "Since this is marked up for grabs, it might be useful to say what motivations for this change are.\r\n\r\nIt looks like it was brought up in IRC on 12/1 in the context of \"SPV sync\" but the relationship seems unclear. (I believe \"SPV sync\" refers to downloading blocks out of order during initial sync so wallet can show unvalidated transactions and be usable before the sync finishes.)",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/443773740/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/444039967",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13937#issuecomment-444039967",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13937",
    "id": 444039967,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0NDAzOTk2Nw==",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-04T09:55:11Z",
    "updated_at": "2018-12-04T09:56:08Z",
    "author_association": "MEMBER",
    "body": "@ryanofsky it started out here: https://github.com/bitcoin/bitcoin/pull/9483#issuecomment-349790765, so just one step to make it easier to sync headers and fresh blocks first, and then catch up on historical blocks later.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/444039967/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209315966",
    "pull_request_review_id": 145312412,
    "id": 209315966,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTMxNTk2Ng==",
    "diff_hunk": "@@ -1290,6 +1319,130 @@ static void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip)\n     CheckForkWarningConditions();\n }\n \n+/**\n+ * Called when a header (re-)reached BLOCK_VALID_TREE.\n+ *\n+ * setBlockIndexHeaderCandidates is a bit more complicated than\n+ * setBlockIndexCandidates as setBlockIndexCandidates can be rather lazy\n+ * as everything in it is about to be connected. In our case, we may have many\n+ * headers above the tip leading down different chains, for which we really\n+ * only want to keep the tip of each chain.\n+ *\n+ * Works even if chainActive is empty!\n+ *\n+ * If chain_ordered_inertion, we assume that if pindex->pprev was previously a\n+ * header candidate, it will be when we're called. ie we assume that there are\n+ * no header candidates which are parents of us except for possibly our direct\n+ * parent.\n+ *\n+ * no_descendants allows us to make a similar, but inverted, assumption -\n+ * assuming no descendant blocks may be header candidates.\n+ */\n+void CChainState::MaybeAddNewHeaderCandidate(CBlockIndex* pindex, bool chain_ordered_insertion, bool no_descendants) {\n+    if (!pindex->IsValid(BLOCK_VALID_TREE)) return; // We only want things that have a valid header tree\n+\n+    bool lower_work = chainActive.Tip() != nullptr && chainActive.Tip()->nChainWork > pindex->nChainWork;\n+    if (lower_work) return; // We don't want things with less work than our current tip\n+\n+    bool parent_present = false;\n+    if (pindex->pprev && setBlockIndexHeaderCandidates.count(pindex->pprev)) {\n+        // If the parent is a previous candidate, then no parents of it could\n+        // be candidates, either. This is the only thing we need to check by\n+        // definition of chain_ordered_insertion, however even in the case of\n+        // !chain_ordered_insertion, if this is true, no need to do a full\n+        // parent scan (as no further-up parent can be a candidate, either).\n+        setBlockIndexHeaderCandidates.erase(pindex->pprev);\n+        parent_present = true;\n+    } else if (!chain_ordered_insertion) {\n+        // We are being called in a for(p : mapBlockIndex) loop, so can make no\n+        // assumptions about existing entries. Scan all other entries to check\n+        // if we're a descendant of some other candidate.\n+        for (auto it = setBlockIndexHeaderCandidates.begin(); it != setBlockIndexHeaderCandidates.end() && (*it)->nChainWork < pindex->nChainWork; it++) {\n+            if (pindex->GetAncestor((*it)->nHeight) == *it) {\n+                // it should be removed - we only keep the tip of potential\n+                // chains, not anything in them. At this point we should be\n+                // consistent by adding pindex, there should be more more work\n+                // to do here.\n+                setBlockIndexHeaderCandidates.erase(it);\n+                break;\n+                parent_present = true;\n+            }\n+        }\n+    }\n+\n+    if (!parent_present && !no_descendants) {\n+        // Scan higher-work entries to check that we're not a parent of some\n+        // other candidate(s). If a parent of ours was already present then we\n+        // can be certain that no such child is also a candidate, so we can\n+        // skip the whole scan.\n+        for (auto it = setBlockIndexHeaderCandidates.rbegin(); it != setBlockIndexHeaderCandidates.rend() && (*it)->nChainWork > pindex->nChainWork; it++) {\n+            if ((*it)->GetAncestor(pindex->nHeight) == pindex) {\n+                // pindex is useless - even if there are other tips based on it\n+                // which we want in setBlockIndexHeaderCandidates, we're not\n+                // gonna find them here.\n+                return;\n+            }\n+        }\n+    }\n+\n+    setBlockIndexHeaderCandidates.insert(pindex);\n+}\n+\n+const CBlockIndex* CChainState::GetBestHeader() {\n+    LOCK(cs_main);\n+    auto it = setBlockIndexHeaderCandidates.rbegin();\n+    if (it == setBlockIndexHeaderCandidates.rend())\n+        return nullptr;\n+    return *it;\n+}\n+\n+const CBlockIndex* GetBestHeader() {\n+    return g_chainstate.GetBestHeader();\n+}\n+\n+// Helper for PruneInvalidBlockIndexCandidates\n+static void PruneInvalidIndexCandidatesInSet(CBlockIndex* pindexInvalid, std::set<CBlockIndex*, CBlockIndexWorkComparator>& set_candidates) {\n+    // Iterate set_candidates downwards, deleting parents of pindexInvalid,\n+    // until we get to headers which are lower total-work than pindexInvalid\n+    // (at which point they can't be parents of pindexInvalid).\n+    std::set<CBlockIndex*, CBlockIndexWorkComparator>::reverse_iterator it = set_candidates.rbegin();\n+    while (it != set_candidates.rend() && (*it)->nChainWork > pindexInvalid->nChainWork) {\n+        if ((*it)->GetAncestor(pindexInvalid->nHeight) == pindexInvalid) {\n+            CBlockIndex* pindexInvalidTip = *it;\n+            if (!pindexBestInvalid || pindexInvalidTip->nChainWork > pindexBestInvalid->nChainWork)\n+                pindexBestInvalid = pindexInvalidTip;\n+\n+            while (pindexInvalidTip != pindexInvalid) {\n+                if (!(pindexInvalidTip->nStatus & BLOCK_FAILED_MASK)) {\n+                    pindexInvalidTip->nStatus |= BLOCK_FAILED_CHILD;\n+                    setDirtyBlockIndex.insert(pindexInvalidTip);\n+                }\n+                pindexInvalidTip = pindexInvalidTip->pprev;\n+            }\n+            std::set<CBlockIndex*, CBlockIndexWorkComparator>::iterator forward_it = it.base(); // Is one past it\n+            forward_it--; // Now points to it\n+            forward_it = set_candidates.erase(forward_it);\n+            it = std::set<CBlockIndex*, CBlockIndexWorkComparator>::reverse_iterator(forward_it);\n+            // forward_it == it.base() now points to one-past previous it, making it point to one-before previous it.",
    "path": "src/validation.cpp",
    "position": 203,
    "original_position": 207,
    "commit_id": "bdaf9f96937769ae68ae6ca81193e12fc26a29ae",
    "original_commit_id": "7b2a938fa5ddbf3e91ada314bce65b4b86c66982",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Note: I find the above reverse-to-forward iterator dance remarkably confusing.",
    "created_at": "2018-08-10T16:29:30Z",
    "updated_at": "2018-10-30T08:48:35Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13937#discussion_r209315966",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13937",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209315966"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13937#discussion_r209315966"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13937"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209315966/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1422,
    "original_line": 1422,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209428169",
    "pull_request_review_id": 145448107,
    "id": 209428169,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTQyODE2OQ==",
    "diff_hunk": "@@ -1290,6 +1319,130 @@ static void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip)\n     CheckForkWarningConditions();\n }\n \n+/**\n+ * Called when a header (re-)reached BLOCK_VALID_TREE.\n+ *\n+ * setBlockIndexHeaderCandidates is a bit more complicated than\n+ * setBlockIndexCandidates as setBlockIndexCandidates can be rather lazy\n+ * as everything in it is about to be connected. In our case, we may have many\n+ * headers above the tip leading down different chains, for which we really\n+ * only want to keep the tip of each chain.\n+ *\n+ * Works even if chainActive is empty!\n+ *\n+ * If chain_ordered_inertion, we assume that if pindex->pprev was previously a\n+ * header candidate, it will be when we're called. ie we assume that there are\n+ * no header candidates which are parents of us except for possibly our direct\n+ * parent.\n+ *\n+ * no_descendants allows us to make a similar, but inverted, assumption -\n+ * assuming no descendant blocks may be header candidates.\n+ */\n+void CChainState::MaybeAddNewHeaderCandidate(CBlockIndex* pindex, bool chain_ordered_insertion, bool no_descendants) {\n+    if (!pindex->IsValid(BLOCK_VALID_TREE)) return; // We only want things that have a valid header tree\n+\n+    bool lower_work = chainActive.Tip() != nullptr && chainActive.Tip()->nChainWork > pindex->nChainWork;\n+    if (lower_work) return; // We don't want things with less work than our current tip\n+\n+    bool parent_present = false;\n+    if (pindex->pprev && setBlockIndexHeaderCandidates.count(pindex->pprev)) {\n+        // If the parent is a previous candidate, then no parents of it could\n+        // be candidates, either. This is the only thing we need to check by\n+        // definition of chain_ordered_insertion, however even in the case of\n+        // !chain_ordered_insertion, if this is true, no need to do a full\n+        // parent scan (as no further-up parent can be a candidate, either).\n+        setBlockIndexHeaderCandidates.erase(pindex->pprev);\n+        parent_present = true;\n+    } else if (!chain_ordered_insertion) {\n+        // We are being called in a for(p : mapBlockIndex) loop, so can make no\n+        // assumptions about existing entries. Scan all other entries to check\n+        // if we're a descendant of some other candidate.\n+        for (auto it = setBlockIndexHeaderCandidates.begin(); it != setBlockIndexHeaderCandidates.end() && (*it)->nChainWork < pindex->nChainWork; it++) {\n+            if (pindex->GetAncestor((*it)->nHeight) == *it) {\n+                // it should be removed - we only keep the tip of potential\n+                // chains, not anything in them. At this point we should be\n+                // consistent by adding pindex, there should be more more work\n+                // to do here.\n+                setBlockIndexHeaderCandidates.erase(it);\n+                break;\n+                parent_present = true;\n+            }\n+        }\n+    }\n+\n+    if (!parent_present && !no_descendants) {\n+        // Scan higher-work entries to check that we're not a parent of some\n+        // other candidate(s). If a parent of ours was already present then we\n+        // can be certain that no such child is also a candidate, so we can\n+        // skip the whole scan.\n+        for (auto it = setBlockIndexHeaderCandidates.rbegin(); it != setBlockIndexHeaderCandidates.rend() && (*it)->nChainWork > pindex->nChainWork; it++) {\n+            if ((*it)->GetAncestor(pindex->nHeight) == pindex) {\n+                // pindex is useless - even if there are other tips based on it\n+                // which we want in setBlockIndexHeaderCandidates, we're not\n+                // gonna find them here.\n+                return;\n+            }\n+        }\n+    }\n+\n+    setBlockIndexHeaderCandidates.insert(pindex);\n+}\n+\n+const CBlockIndex* CChainState::GetBestHeader() {\n+    LOCK(cs_main);\n+    auto it = setBlockIndexHeaderCandidates.rbegin();\n+    if (it == setBlockIndexHeaderCandidates.rend())\n+        return nullptr;",
    "path": "src/validation.cpp",
    "position": 172,
    "original_position": 176,
    "commit_id": "bdaf9f96937769ae68ae6ca81193e12fc26a29ae",
    "original_commit_id": "7b2a938fa5ddbf3e91ada314bce65b4b86c66982",
    "user": {
      "login": "donaloconnor",
      "id": 6394033,
      "node_id": "MDQ6VXNlcjYzOTQwMzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6394033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/donaloconnor",
      "html_url": "https://github.com/donaloconnor",
      "followers_url": "https://api.github.com/users/donaloconnor/followers",
      "following_url": "https://api.github.com/users/donaloconnor/following{/other_user}",
      "gists_url": "https://api.github.com/users/donaloconnor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/donaloconnor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/donaloconnor/subscriptions",
      "organizations_url": "https://api.github.com/users/donaloconnor/orgs",
      "repos_url": "https://api.github.com/users/donaloconnor/repos",
      "events_url": "https://api.github.com/users/donaloconnor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/donaloconnor/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Numerous places call this function but no nullptr check is performed and dereferences are executed on the ptr.\r\nCan this return null in any case where this function is called?",
    "created_at": "2018-08-11T14:28:18Z",
    "updated_at": "2018-10-30T08:48:35Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13937#discussion_r209428169",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13937",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209428169"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13937#discussion_r209428169"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13937"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209428169/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1391,
    "original_line": 1391,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209428514",
    "pull_request_review_id": 145448107,
    "id": 209428514,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTQyODUxNA==",
    "diff_hunk": "@@ -152,10 +152,10 @@ class NodeImpl : public Node\n     size_t getMempoolDynamicUsage() override { return ::mempool.DynamicMemoryUsage(); }\n     bool getHeaderTip(int& height, int64_t& block_time) override\n     {\n-        LOCK(::cs_main);\n-        if (::pindexBestHeader) {\n-            height = ::pindexBestHeader->nHeight;\n-            block_time = ::pindexBestHeader->GetBlockTime();\n+        const CBlockIndex* best_header = ::GetBestHeader();\n+        if (best_header) {",
    "path": "src/interfaces/node.cpp",
    "position": 9,
    "original_position": 9,
    "commit_id": "bdaf9f96937769ae68ae6ca81193e12fc26a29ae",
    "original_commit_id": "7b2a938fa5ddbf3e91ada314bce65b4b86c66982",
    "user": {
      "login": "donaloconnor",
      "id": 6394033,
      "node_id": "MDQ6VXNlcjYzOTQwMzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6394033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/donaloconnor",
      "html_url": "https://github.com/donaloconnor",
      "followers_url": "https://api.github.com/users/donaloconnor/followers",
      "following_url": "https://api.github.com/users/donaloconnor/following{/other_user}",
      "gists_url": "https://api.github.com/users/donaloconnor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/donaloconnor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/donaloconnor/subscriptions",
      "organizations_url": "https://api.github.com/users/donaloconnor/orgs",
      "repos_url": "https://api.github.com/users/donaloconnor/repos",
      "events_url": "https://api.github.com/users/donaloconnor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/donaloconnor/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Possible race condition here since we don't lock cs_main? Can the best_head data be deleted between time we call GetBestHeader() and when we use the ptr?\r\n\r\nI'm not familiar with the code enough to know the answer to this so just putting it here in case.",
    "created_at": "2018-08-11T14:41:52Z",
    "updated_at": "2018-10-30T08:48:35Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13937#discussion_r209428514",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13937",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209428514"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13937#discussion_r209428514"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13937"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209428514/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 157,
    "original_line": 157,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212822708",
    "pull_request_review_id": 149534822,
    "id": 212822708,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMjgyMjcwOA==",
    "diff_hunk": "@@ -152,10 +152,10 @@ class NodeImpl : public Node\n     size_t getMempoolDynamicUsage() override { return ::mempool.DynamicMemoryUsage(); }\n     bool getHeaderTip(int& height, int64_t& block_time) override\n     {\n-        LOCK(::cs_main);\n-        if (::pindexBestHeader) {\n-            height = ::pindexBestHeader->nHeight;\n-            block_time = ::pindexBestHeader->GetBlockTime();\n+        const CBlockIndex* best_header = ::GetBestHeader();\n+        if (best_header) {",
    "path": "src/interfaces/node.cpp",
    "position": 9,
    "original_position": 9,
    "commit_id": "bdaf9f96937769ae68ae6ca81193e12fc26a29ae",
    "original_commit_id": "7b2a938fa5ddbf3e91ada314bce65b4b86c66982",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "~It sounds like it would be safer to also make a PR for https://github.com/bitcoin/bitcoin/commit/a9db3dada0119c183d16627805e90c4dbca05c6a that I left out?~ (nvm that was already merged in #13023)\r\n\r\nI'll see if I can understand the potential race condition you mention.",
    "created_at": "2018-08-26T11:21:38Z",
    "updated_at": "2018-10-30T08:48:35Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13937#discussion_r212822708",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13937",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212822708"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13937#discussion_r212822708"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13937"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212822708/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 157,
    "original_line": 157,
    "side": "RIGHT",
    "in_reply_to_id": 209428514
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212825173",
    "pull_request_review_id": 149537265,
    "id": 212825173,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMjgyNTE3Mw==",
    "diff_hunk": "@@ -1290,6 +1319,130 @@ static void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip)\n     CheckForkWarningConditions();\n }\n \n+/**\n+ * Called when a header (re-)reached BLOCK_VALID_TREE.\n+ *\n+ * setBlockIndexHeaderCandidates is a bit more complicated than\n+ * setBlockIndexCandidates as setBlockIndexCandidates can be rather lazy\n+ * as everything in it is about to be connected. In our case, we may have many\n+ * headers above the tip leading down different chains, for which we really\n+ * only want to keep the tip of each chain.\n+ *\n+ * Works even if chainActive is empty!\n+ *\n+ * If chain_ordered_inertion, we assume that if pindex->pprev was previously a\n+ * header candidate, it will be when we're called. ie we assume that there are\n+ * no header candidates which are parents of us except for possibly our direct\n+ * parent.\n+ *\n+ * no_descendants allows us to make a similar, but inverted, assumption -\n+ * assuming no descendant blocks may be header candidates.\n+ */\n+void CChainState::MaybeAddNewHeaderCandidate(CBlockIndex* pindex, bool chain_ordered_insertion, bool no_descendants) {\n+    if (!pindex->IsValid(BLOCK_VALID_TREE)) return; // We only want things that have a valid header tree\n+\n+    bool lower_work = chainActive.Tip() != nullptr && chainActive.Tip()->nChainWork > pindex->nChainWork;\n+    if (lower_work) return; // We don't want things with less work than our current tip\n+\n+    bool parent_present = false;\n+    if (pindex->pprev && setBlockIndexHeaderCandidates.count(pindex->pprev)) {\n+        // If the parent is a previous candidate, then no parents of it could\n+        // be candidates, either. This is the only thing we need to check by\n+        // definition of chain_ordered_insertion, however even in the case of\n+        // !chain_ordered_insertion, if this is true, no need to do a full\n+        // parent scan (as no further-up parent can be a candidate, either).\n+        setBlockIndexHeaderCandidates.erase(pindex->pprev);\n+        parent_present = true;\n+    } else if (!chain_ordered_insertion) {\n+        // We are being called in a for(p : mapBlockIndex) loop, so can make no\n+        // assumptions about existing entries. Scan all other entries to check\n+        // if we're a descendant of some other candidate.\n+        for (auto it = setBlockIndexHeaderCandidates.begin(); it != setBlockIndexHeaderCandidates.end() && (*it)->nChainWork < pindex->nChainWork; it++) {\n+            if (pindex->GetAncestor((*it)->nHeight) == *it) {\n+                // it should be removed - we only keep the tip of potential\n+                // chains, not anything in them. At this point we should be\n+                // consistent by adding pindex, there should be more more work\n+                // to do here.\n+                setBlockIndexHeaderCandidates.erase(it);\n+                break;\n+                parent_present = true;\n+            }\n+        }\n+    }\n+\n+    if (!parent_present && !no_descendants) {\n+        // Scan higher-work entries to check that we're not a parent of some\n+        // other candidate(s). If a parent of ours was already present then we\n+        // can be certain that no such child is also a candidate, so we can\n+        // skip the whole scan.\n+        for (auto it = setBlockIndexHeaderCandidates.rbegin(); it != setBlockIndexHeaderCandidates.rend() && (*it)->nChainWork > pindex->nChainWork; it++) {\n+            if ((*it)->GetAncestor(pindex->nHeight) == pindex) {\n+                // pindex is useless - even if there are other tips based on it\n+                // which we want in setBlockIndexHeaderCandidates, we're not\n+                // gonna find them here.\n+                return;\n+            }\n+        }\n+    }\n+\n+    setBlockIndexHeaderCandidates.insert(pindex);\n+}\n+\n+const CBlockIndex* CChainState::GetBestHeader() {\n+    LOCK(cs_main);\n+    auto it = setBlockIndexHeaderCandidates.rbegin();\n+    if (it == setBlockIndexHeaderCandidates.rend())\n+        return nullptr;",
    "path": "src/validation.cpp",
    "position": 172,
    "original_position": 176,
    "commit_id": "bdaf9f96937769ae68ae6ca81193e12fc26a29ae",
    "original_commit_id": "7b2a938fa5ddbf3e91ada314bce65b4b86c66982",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "That seems problematic indeed. There's an `assert` for this in https://github.com/bitcoin/bitcoin/blame/7b1ab22384d944f638c514f838e25b391204ef67/src/net_processing.cpp#L3308, but not in the calls from validation.cpp:\r\n* in `NotifyHeaderTip()`: here it's compared with `pindexHeaderOld` which is a `nullptr` initially, but would non-null the next time. It's not dereferenced in that function, but it is passed on to `uiInterface.NotifyHeaderTip`. I could add an assert inside`if (fNotify)`\r\n* in `IsCurrentForFeeEstimation()`: I could add an `assert` directly above the if statement that deferences it\r\n\r\nThe comment in `InvalidBlockFound` suggests that sometimes `setBlockIndexHeaderCandidates` can be empty, so the above wouldn't be enough. Rather than `assert` I could explicitly check for `nullptr` in both functions and deal with them, as well as put a warning where this set is defined. ",
    "created_at": "2018-08-26T12:49:03Z",
    "updated_at": "2018-10-30T08:48:35Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13937#discussion_r212825173",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13937",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212825173"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13937#discussion_r212825173"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13937"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212825173/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1391,
    "original_line": 1391,
    "side": "RIGHT",
    "in_reply_to_id": 209428169
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229479718",
    "pull_request_review_id": 169991931,
    "id": 229479718,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTQ3OTcxOA==",
    "diff_hunk": "@@ -1281,6 +1315,130 @@ static void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip) E\n     CheckForkWarningConditions();\n }\n \n+/**\n+ * Called when a header (re-)reached BLOCK_VALID_TREE.\n+ *\n+ * setBlockIndexHeaderCandidates is a bit more complicated than\n+ * setBlockIndexCandidates as setBlockIndexCandidates can be rather lazy\n+ * as everything in it is about to be connected. In our case, we may have many\n+ * headers above the tip leading down different chains, for which we really\n+ * only want to keep the tip of each chain.\n+ *\n+ * Works even if chainActive is empty!\n+ *\n+ * If chain_ordered_inertion, we assume that if pindex->pprev was previously a\n+ * header candidate, it will be when we're called. ie we assume that there are\n+ * no header candidates which are parents of us except for possibly our direct\n+ * parent.\n+ *\n+ * no_descendants allows us to make a similar, but inverted, assumption -\n+ * assuming no descendant blocks may be header candidates.\n+ */\n+void CChainState::MaybeAddNewHeaderCandidate(CBlockIndex* pindex, bool chain_ordered_insertion, bool no_descendants) {\n+    if (!pindex->IsValid(BLOCK_VALID_TREE)) return; // We only want things that have a valid header tree\n+\n+    bool lower_work = chainActive.Tip() != nullptr && chainActive.Tip()->nChainWork > pindex->nChainWork;\n+    if (lower_work) return; // We don't want things with less work than our current tip\n+\n+    bool parent_present = false;\n+    if (pindex->pprev && setBlockIndexHeaderCandidates.count(pindex->pprev)) {\n+        // If the parent is a previous candidate, then no parents of it could\n+        // be candidates, either. This is the only thing we need to check by\n+        // definition of chain_ordered_insertion, however even in the case of\n+        // !chain_ordered_insertion, if this is true, no need to do a full\n+        // parent scan (as no further-up parent can be a candidate, either).\n+        setBlockIndexHeaderCandidates.erase(pindex->pprev);\n+        parent_present = true;\n+    } else if (!chain_ordered_insertion) {\n+        // We are being called in a for(p : mapBlockIndex) loop, so can make no\n+        // assumptions about existing entries. Scan all other entries to check\n+        // if we're a descendant of some other candidate.\n+        for (auto it = setBlockIndexHeaderCandidates.begin(); it != setBlockIndexHeaderCandidates.end() && (*it)->nChainWork < pindex->nChainWork; it++) {\n+            if (pindex->GetAncestor((*it)->nHeight) == *it) {\n+                // it should be removed - we only keep the tip of potential\n+                // chains, not anything in them. At this point we should be\n+                // consistent by adding pindex, there should be more more work\n+                // to do here.\n+                setBlockIndexHeaderCandidates.erase(it);\n+                break;\n+                parent_present = true;",
    "path": "src/validation.cpp",
    "position": 145,
    "original_position": 145,
    "commit_id": "bdaf9f96937769ae68ae6ca81193e12fc26a29ae",
    "original_commit_id": "bdaf9f96937769ae68ae6ca81193e12fc26a29ae",
    "user": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This is dead code. The `parent_present = true;` is not meant to be after `break;` in this scope? :-)",
    "created_at": "2018-10-30T20:46:47Z",
    "updated_at": "2018-10-30T20:46:48Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13937#discussion_r229479718",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13937",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229479718"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13937#discussion_r229479718"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13937"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229479718/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1364,
    "original_line": 1364,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229479982",
    "pull_request_review_id": 169992259,
    "id": 229479982,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTQ3OTk4Mg==",
    "diff_hunk": "@@ -1281,6 +1315,130 @@ static void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip) E\n     CheckForkWarningConditions();\n }\n \n+/**\n+ * Called when a header (re-)reached BLOCK_VALID_TREE.\n+ *\n+ * setBlockIndexHeaderCandidates is a bit more complicated than\n+ * setBlockIndexCandidates as setBlockIndexCandidates can be rather lazy\n+ * as everything in it is about to be connected. In our case, we may have many\n+ * headers above the tip leading down different chains, for which we really\n+ * only want to keep the tip of each chain.\n+ *\n+ * Works even if chainActive is empty!\n+ *\n+ * If chain_ordered_inertion, we assume that if pindex->pprev was previously a\n+ * header candidate, it will be when we're called. ie we assume that there are\n+ * no header candidates which are parents of us except for possibly our direct\n+ * parent.\n+ *\n+ * no_descendants allows us to make a similar, but inverted, assumption -\n+ * assuming no descendant blocks may be header candidates.\n+ */\n+void CChainState::MaybeAddNewHeaderCandidate(CBlockIndex* pindex, bool chain_ordered_insertion, bool no_descendants) {\n+    if (!pindex->IsValid(BLOCK_VALID_TREE)) return; // We only want things that have a valid header tree\n+\n+    bool lower_work = chainActive.Tip() != nullptr && chainActive.Tip()->nChainWork > pindex->nChainWork;\n+    if (lower_work) return; // We don't want things with less work than our current tip\n+\n+    bool parent_present = false;\n+    if (pindex->pprev && setBlockIndexHeaderCandidates.count(pindex->pprev)) {\n+        // If the parent is a previous candidate, then no parents of it could\n+        // be candidates, either. This is the only thing we need to check by\n+        // definition of chain_ordered_insertion, however even in the case of\n+        // !chain_ordered_insertion, if this is true, no need to do a full\n+        // parent scan (as no further-up parent can be a candidate, either).\n+        setBlockIndexHeaderCandidates.erase(pindex->pprev);\n+        parent_present = true;\n+    } else if (!chain_ordered_insertion) {\n+        // We are being called in a for(p : mapBlockIndex) loop, so can make no\n+        // assumptions about existing entries. Scan all other entries to check\n+        // if we're a descendant of some other candidate.\n+        for (auto it = setBlockIndexHeaderCandidates.begin(); it != setBlockIndexHeaderCandidates.end() && (*it)->nChainWork < pindex->nChainWork; it++) {\n+            if (pindex->GetAncestor((*it)->nHeight) == *it) {\n+                // it should be removed - we only keep the tip of potential\n+                // chains, not anything in them. At this point we should be\n+                // consistent by adding pindex, there should be more more work\n+                // to do here.\n+                setBlockIndexHeaderCandidates.erase(it);\n+                break;\n+                parent_present = true;\n+            }\n+        }\n+    }\n+\n+    if (!parent_present && !no_descendants) {\n+        // Scan higher-work entries to check that we're not a parent of some\n+        // other candidate(s). If a parent of ours was already present then we\n+        // can be certain that no such child is also a candidate, so we can\n+        // skip the whole scan.\n+        for (auto it = setBlockIndexHeaderCandidates.rbegin(); it != setBlockIndexHeaderCandidates.rend() && (*it)->nChainWork > pindex->nChainWork; it++) {\n+            if ((*it)->GetAncestor(pindex->nHeight) == pindex) {\n+                // pindex is useless - even if there are other tips based on it\n+                // which we want in setBlockIndexHeaderCandidates, we're not\n+                // gonna find them here.",
    "path": "src/validation.cpp",
    "position": 159,
    "original_position": 159,
    "commit_id": "bdaf9f96937769ae68ae6ca81193e12fc26a29ae",
    "original_commit_id": "bdaf9f96937769ae68ae6ca81193e12fc26a29ae",
    "user": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "\"going to find them here.\" :-)",
    "created_at": "2018-10-30T20:47:32Z",
    "updated_at": "2018-10-30T20:47:33Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13937#discussion_r229479982",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13937",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229479982"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13937#discussion_r229479982"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13937"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229479982/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1378,
    "original_line": 1378,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229480065",
    "pull_request_review_id": 169992375,
    "id": 229480065,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTQ4MDA2NQ==",
    "diff_hunk": "@@ -1281,6 +1315,130 @@ static void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip) E\n     CheckForkWarningConditions();\n }\n \n+/**\n+ * Called when a header (re-)reached BLOCK_VALID_TREE.\n+ *\n+ * setBlockIndexHeaderCandidates is a bit more complicated than\n+ * setBlockIndexCandidates as setBlockIndexCandidates can be rather lazy\n+ * as everything in it is about to be connected. In our case, we may have many\n+ * headers above the tip leading down different chains, for which we really\n+ * only want to keep the tip of each chain.\n+ *\n+ * Works even if chainActive is empty!\n+ *\n+ * If chain_ordered_inertion, we assume that if pindex->pprev was previously a",
    "path": "src/validation.cpp",
    "position": 110,
    "original_position": 110,
    "commit_id": "bdaf9f96937769ae68ae6ca81193e12fc26a29ae",
    "original_commit_id": "bdaf9f96937769ae68ae6ca81193e12fc26a29ae",
    "user": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Should be insertion?",
    "created_at": "2018-10-30T20:47:48Z",
    "updated_at": "2018-10-30T20:47:48Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13937#discussion_r229480065",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13937",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229480065"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13937#discussion_r229480065"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13937"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229480065/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1329,
    "original_line": 1329,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229480577",
    "pull_request_review_id": 169993028,
    "id": 229480577,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTQ4MDU3Nw==",
    "diff_hunk": "@@ -107,10 +108,36 @@ class CChainState {\n private:\n     /**\n      * The set of all CBlockIndex entries with BLOCK_VALID_TRANSACTIONS (for itself and all ancestors) and\n-     * as good as our current tip or better. Entries may be failed, though, and pruning nodes may be\n-     * missing the data for the block.\n+     * as good as our current tip or better. Pruning nodes may be missing the data for the block.\n      */\n     std::set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexCandidates;\n+    /**\n+     * The set of all leaf CBlockIndex entries with BLOCK_VALID_TREE (for itself and all ancestors) and\n+     * as good as our current tip or better. Entries here are potential future candidates for insertion\n+     * into setBlockIndexCandidates, once we get all the required block data. Thus, entries here\n+     * represent chains on which we should be actively downloading block data.\n+     *\n+     * Note that we define \"as good as our current tip or better\" slightly differently here than in\n+     * setBlockIndexCandidates - we include things which will have a higher nSequence (but have the\n+     * same chain work) here, but do not include such entries in setBlockIndexCandidates. This is\n+     * because we prefer to also download towards chains which have the same total work as our current\n+     * chain (as an optimization since a reorg is very possible in such cases).\n+     *\n+     * Note that, unlike setBlockIndexCandidates, we only store \"leaf\" entries here, as we are not as\n+     * aggressively prune-able (setBlockIndexCandidates are things which we can, and usually do, try to\n+     * connect immediately, and thus entries dont stick around for long). Thus, it may be the case that",
    "path": "src/validation.cpp",
    "position": 31,
    "original_position": 31,
    "commit_id": "bdaf9f96937769ae68ae6ca81193e12fc26a29ae",
    "original_commit_id": "bdaf9f96937769ae68ae6ca81193e12fc26a29ae",
    "user": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "\"Don't\" :-)",
    "created_at": "2018-10-30T20:49:19Z",
    "updated_at": "2018-10-30T20:49:19Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13937#discussion_r229480577",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13937",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229480577"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13937#discussion_r229480577"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13937"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229480577/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 128,
    "original_line": 128,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229480628",
    "pull_request_review_id": 169993101,
    "id": 229480628,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTQ4MDYyOA==",
    "diff_hunk": "@@ -3470,31 +3675,38 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n     // not process unrequested blocks.\n     bool fTooFarAhead = (pindex->nHeight > int(chainActive.Height() + MIN_BLOCKS_TO_KEEP));\n \n-    // TODO: Decouple this function from the block download logic by removing fRequested\n-    // This requires some new chain data structure to efficiently look up if a\n-    // block is in a chain leading to a candidate for best tip, despite not\n-    // being such a candidate itself.\n-\n     // TODO: deal better with return value and error conditions for duplicate\n     // and unrequested blocks.\n     if (fAlreadyHave) return true;\n-    if (!fRequested) {  // If we didn't ask for it:\n-        if (pindex->nTx != 0) return true;    // This is a previously-processed block that was pruned\n-        if (!fHasMoreOrSameWork) return true; // Don't process less-work chains\n-        if (fTooFarAhead) return true;        // Block height is too high\n-\n-        // Protect against DoS attacks from low-work chains.\n-        // If our tip is behind, a peer could try to send us\n-        // low-work blocks on a fake chain that we would never\n-        // request; don't process these.\n-        if (pindex->nChainWork < nMinimumChainWork) return true;\n+    if (!pindex->IsValid(BLOCK_VALID_TREE)) return true; // Parent block somewhere is invalid\n+    if (pindex->nTx != 0) return true;                   // This is a previously-processed block that was pruned\n+    if (fTooFarAhead) return true;                       // Block height is too high\n+\n+    bool parent_of_header_candidate = false;\n+    bool parent_of_min_chainwork_header_candidate = false;\n+    for (auto it = setBlockIndexHeaderCandidates.rbegin(); it != setBlockIndexHeaderCandidates.rend(); it++) {\n+        if ((*it)->GetAncestor(pindex->nHeight) == pindex) {\n+            parent_of_header_candidate = true;\n+            // Protect against DoS attacks from low-work chains.\n+            // If our tip is behind, a peer could try to send us\n+            // low-work blocks on a fake chain that we would never\n+            // request; don't process these.\n+            if ((*it)->nChainWork >= nMinimumChainWork) {\n+                parent_of_min_chainwork_header_candidate = true;\n+                break;\n+            }\n+        }\n+    }\n+    if (!fHasMoreOrSameWork && !parent_of_header_candidate) return true; // We dont think this block leads somewhere interesting",
    "path": "src/validation.cpp",
    "position": 507,
    "original_position": 507,
    "commit_id": "bdaf9f96937769ae68ae6ca81193e12fc26a29ae",
    "original_commit_id": "bdaf9f96937769ae68ae6ca81193e12fc26a29ae",
    "user": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "\"Don't\" :-)",
    "created_at": "2018-10-30T20:49:29Z",
    "updated_at": "2018-10-30T20:49:30Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13937#discussion_r229480628",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13937",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229480628"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13937#discussion_r229480628"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13937"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229480628/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 3700,
    "original_line": 3700,
    "side": "RIGHT"
  }
]