[
  {
    "sha": "fab1553de23cf52060ec4b494b7fa149c990f9e3",
    "node_id": "C_kwDOABII59oAKGZhYjE1NTNkZTIzY2Y1MjA2MGVjNGI0OTRiN2ZhMTQ5Yzk5MGY5ZTM",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-09-14T14:17:10Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-11-18T19:22:30Z"
      },
      "message": "scripted-diff: Use clang-tidy syntax for C++ named arguments\n\n-BEGIN VERIFY SCRIPT-\n sed -i --regexp-extended -e 's_(\\(|\\{|, ?)\\/\\* ?([^=* ]+) ?\\*\\/ ?_\\1/*\\2=*/_g' $( git grep -l --extended-regexp ', ?\\/\\* ?[^=* ]+ ?\\*\\/' ./src )\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "b11d0d28295b6000bebe06b9d118c907e61120d7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b11d0d28295b6000bebe06b9d118c907e61120d7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fab1553de23cf52060ec4b494b7fa149c990f9e3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUhJigv+JT4bYrTfEWPkfefHiaLyfIb4VdOnHGxYUK6Jau+MO41YHZWXk35PyCXY\nmKuewbfl18WLCjkoB14vjkRR4itqEHjR7b26a7723ga7HUxI7dlyabdOk/eDQGbc\nDxnFfp0EzkscH8v4oCw5N8nyIfN3wkf9/C7dnmfm+pnI48lAL8cuh+bZAzJnqIqM\nNAcvkamch8Gydl2sV2ojAhanjaS4Y9aF5pcBtBJ4gPLwpGUPIRHD/aN+/LaWAPRd\nfDHYoIoYafU7fmkei8jPggCXHlN5dp2miQpc/VpX6DtpVgL60ex0xQO3Sr6+kufa\nHR2wBHI/ANg1E9CF7JVmS9B7Y6BwLWw7ckZge8w1abujbMGtIMrqmr3B7Z3IoSt9\nifEDiuhi6mv6USJMSqSgpBytle5IknDwFe7XIjaDFP64yBO6fCECPvPID+QlRANc\nZgZMisf+0XsynPk6g8q5VFzsEaYdktxZ5JH3zd8lFXg9/zAVbVru867/mFS1P6qD\n8urovqTG\n=HWgs\n-----END PGP SIGNATURE-----",
        "payload": "tree b11d0d28295b6000bebe06b9d118c907e61120d7\nparent fe03f7a37fd0ef05149161f6b95a25493e1fe38f\nauthor MarcoFalke <falke.marco@gmail.com> 1631629030 +0200\ncommitter MarcoFalke <falke.marco@gmail.com> 1637263350 +0100\n\nscripted-diff: Use clang-tidy syntax for C++ named arguments\n\n-BEGIN VERIFY SCRIPT-\n sed -i --regexp-extended -e 's_(\\(|\\{|, ?)\\/\\* ?([^=* ]+) ?\\*\\/ ?_\\1/*\\2=*/_g' $( git grep -l --extended-regexp ', ?\\/\\* ?[^=* ]+ ?\\*\\/' ./src )\n-END VERIFY SCRIPT-\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fab1553de23cf52060ec4b494b7fa149c990f9e3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fab1553de23cf52060ec4b494b7fa149c990f9e3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fab1553de23cf52060ec4b494b7fa149c990f9e3/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fe03f7a37fd0ef05149161f6b95a25493e1fe38f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fe03f7a37fd0ef05149161f6b95a25493e1fe38f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fe03f7a37fd0ef05149161f6b95a25493e1fe38f"
      }
    ],
    "stats": {
      "total": 694,
      "additions": 347,
      "deletions": 347
    },
    "files": [
      {
        "sha": "84681713e0522525fefef56c390606f54fa107f1",
        "filename": "src/addrdb.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/addrdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/addrdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -184,7 +184,7 @@ void ReadFromStream(AddrMan& addr, CDataStream& ssPeers)\n std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const ArgsManager& args, std::unique_ptr<AddrMan>& addrman)\n {\n     auto check_addrman = std::clamp<int32_t>(args.GetIntArg(\"-checkaddrman\", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);\n-    addrman = std::make_unique<AddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n+    addrman = std::make_unique<AddrMan>(asmap, /*deterministic=*/false, /*consistency_check_ratio=*/check_addrman);\n \n     int64_t nStart = GetTimeMillis();\n     const auto path_addr{args.GetDataDirNet() / \"peers.dat\"};\n@@ -193,7 +193,7 @@ std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const A\n         LogPrintf(\"Loaded %i addresses from peers.dat  %dms\\n\", addrman->size(), GetTimeMillis() - nStart);\n     } catch (const DbNotFoundError&) {\n         // Addrman can be in an inconsistent state after failure, reset it\n-        addrman = std::make_unique<AddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n+        addrman = std::make_unique<AddrMan>(asmap, /*deterministic=*/false, /*consistency_check_ratio=*/check_addrman);\n         LogPrintf(\"Creating peers.dat because the file was not found (%s)\\n\", fs::quoted(fs::PathToString(path_addr)));\n         DumpPeerAddresses(args, *addrman);\n     } catch (const std::exception& e) {"
      },
      {
        "sha": "68a5a39ee9966cec8b8ce730b18cdda9f7204872",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -1053,7 +1053,7 @@ void AddrManImpl::Good(const CService& addr, int64_t nTime)\n {\n     LOCK(cs);\n     Check();\n-    Good_(addr, /* test_before_evict */ true, nTime);\n+    Good_(addr, /*test_before_evict=*/true, nTime);\n     Check();\n }\n "
      },
      {
        "sha": "c46fbde7c797a75c8ef1bdec15f418719fa68fd6",
        "filename": "src/bench/addrman.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/bench/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/bench/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/addrman.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -74,14 +74,14 @@ static void AddrManAdd(benchmark::Bench& bench)\n     CreateAddresses();\n \n     bench.run([&] {\n-        AddrMan addrman{/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0};\n+        AddrMan addrman{/*asmap=*/std::vector<bool>(), /*deterministic=*/false, /*consistency_check_ratio=*/0};\n         AddAddressesToAddrMan(addrman);\n     });\n }\n \n static void AddrManSelect(benchmark::Bench& bench)\n {\n-    AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addrman(/*asmap=*/std::vector<bool>(), /*deterministic=*/false, /*consistency_check_ratio=*/0);\n \n     FillAddrMan(addrman);\n \n@@ -93,12 +93,12 @@ static void AddrManSelect(benchmark::Bench& bench)\n \n static void AddrManGetAddr(benchmark::Bench& bench)\n {\n-    AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addrman(/*asmap=*/std::vector<bool>(), /*deterministic=*/false, /*consistency_check_ratio=*/0);\n \n     FillAddrMan(addrman);\n \n     bench.run([&] {\n-        const auto& addresses = addrman.GetAddr(/* max_addresses */ 2500, /* max_pct */ 23, /* network */ std::nullopt);\n+        const auto& addresses = addrman.GetAddr(/*max_addresses=*/2500, /*max_pct=*/23, /*network=*/std::nullopt);\n         assert(addresses.size() > 0);\n     });\n }\n@@ -122,7 +122,7 @@ static void AddrManAddThenGood(benchmark::Bench& bench)\n         //\n         // This has some overhead (exactly the result of AddrManAdd benchmark), but that overhead is constant so improvements in\n         // AddrMan::Good() will still be noticeable.\n-        AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+        AddrMan addrman(/*asmap=*/std::vector<bool>(), /*deterministic=*/false, /*consistency_check_ratio=*/0);\n         AddAddressesToAddrMan(addrman);\n \n         markSomeAsGood(addrman);"
      },
      {
        "sha": "aa65b5b016745d8836524874b0424d922b7a59cc",
        "filename": "src/bench/mempool_stress.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/bench/mempool_stress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/bench/mempool_stress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/mempool_stress.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -86,7 +86,7 @@ static void ComplexMemPool(benchmark::Bench& bench)\n     if (bench.complexityN() > 1) {\n         childTxs = static_cast<int>(bench.complexityN());\n     }\n-    std::vector<CTransactionRef> ordered_coins = CreateOrderedCoins(det_rand, childTxs, /* min_ancestors */ 1);\n+    std::vector<CTransactionRef> ordered_coins = CreateOrderedCoins(det_rand, childTxs, /*min_ancestors=*/1);\n     const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(CBaseChainParams::MAIN);\n     CTxMemPool pool;\n     LOCK2(cs_main, pool.cs);\n@@ -103,15 +103,15 @@ static void MempoolCheck(benchmark::Bench& bench)\n {\n     FastRandomContext det_rand{true};\n     const int childTxs = bench.complexityN() > 1 ? static_cast<int>(bench.complexityN()) : 2000;\n-    const std::vector<CTransactionRef> ordered_coins = CreateOrderedCoins(det_rand, childTxs, /* min_ancestors */ 5);\n+    const std::vector<CTransactionRef> ordered_coins = CreateOrderedCoins(det_rand, childTxs, /*min_ancestors=*/5);\n     const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(CBaseChainParams::MAIN, {\"-checkmempool=1\"});\n     CTxMemPool pool;\n     LOCK2(cs_main, pool.cs);\n     const CCoinsViewCache& coins_tip = testing_setup.get()->m_node.chainman->ActiveChainstate().CoinsTip();\n     for (auto& tx : ordered_coins) AddTx(tx, pool);\n \n     bench.run([&]() NO_THREAD_SAFETY_ANALYSIS {\n-        pool.check(coins_tip, /* spendheight */ 2);\n+        pool.check(coins_tip, /*spendheight=*/2);\n     });\n }\n "
      },
      {
        "sha": "4c82269bb9b9248e3ecbc4fb03c5fe62e8192141",
        "filename": "src/bench/rpc_mempool.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/bench/rpc_mempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/bench/rpc_mempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/rpc_mempool.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -29,11 +29,11 @@ static void RpcMempool(benchmark::Bench& bench)\n         tx.vout[0].scriptPubKey = CScript() << OP_1 << OP_EQUAL;\n         tx.vout[0].nValue = i;\n         const CTransactionRef tx_r{MakeTransactionRef(tx)};\n-        AddTx(tx_r, /* fee */ i, pool);\n+        AddTx(tx_r, /*fee=*/i, pool);\n     }\n \n     bench.run([&] {\n-        (void)MempoolToJSON(pool, /*verbose*/ true);\n+        (void)MempoolToJSON(pool, /*verbose=*/true);\n     });\n }\n "
      },
      {
        "sha": "9b2fb0258a3202492099e6c12d6a44f7c39d2d98",
        "filename": "src/bench/wallet_balance.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/bench/wallet_balance.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/bench/wallet_balance.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/wallet_balance.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -46,10 +46,10 @@ static void WalletBalance(benchmark::Bench& bench, const bool set_dirty, const b\n     });\n }\n \n-static void WalletBalanceDirty(benchmark::Bench& bench) { WalletBalance(bench, /* set_dirty */ true, /* add_mine */ true); }\n-static void WalletBalanceClean(benchmark::Bench& bench) { WalletBalance(bench, /* set_dirty */ false, /* add_mine */ true); }\n-static void WalletBalanceMine(benchmark::Bench& bench) { WalletBalance(bench, /* set_dirty */ false, /* add_mine */ true); }\n-static void WalletBalanceWatch(benchmark::Bench& bench) { WalletBalance(bench, /* set_dirty */ false, /* add_mine */ false); }\n+static void WalletBalanceDirty(benchmark::Bench& bench) { WalletBalance(bench, /*set_dirty=*/true, /*add_mine=*/true); }\n+static void WalletBalanceClean(benchmark::Bench& bench) { WalletBalance(bench, /*set_dirty=*/false, /*add_mine=*/true); }\n+static void WalletBalanceMine(benchmark::Bench& bench) { WalletBalance(bench, /*set_dirty=*/false, /*add_mine=*/true); }\n+static void WalletBalanceWatch(benchmark::Bench& bench) { WalletBalance(bench, /*set_dirty=*/false, /*add_mine=*/false); }\n \n BENCHMARK(WalletBalanceDirty);\n BENCHMARK(WalletBalanceClean);"
      },
      {
        "sha": "6395ebfc1569272c20aa6e51b155de8bc743ec5b",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -144,7 +144,7 @@ std::string EncodeHexTx(const CTransaction& tx, const int serializeFlags)\n \n void ScriptToUniv(const CScript& script, UniValue& out)\n {\n-    ScriptPubKeyToUniv(script, out, /* include_hex */ true, /* include_address */ false);\n+    ScriptPubKeyToUniv(script, out, /*include_hex=*/true, /*include_address=*/false);\n }\n \n void ScriptPubKeyToUniv(const CScript& scriptPubKey, UniValue& out, bool include_hex, bool include_address)\n@@ -215,7 +215,7 @@ void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry,\n \n                 case TxVerbosity::SHOW_DETAILS_AND_PREVOUT:\n                     UniValue o_script_pub_key(UniValue::VOBJ);\n-                    ScriptPubKeyToUniv(prev_txout.scriptPubKey, o_script_pub_key, /* includeHex */ true);\n+                    ScriptPubKeyToUniv(prev_txout.scriptPubKey, o_script_pub_key, /*includeHex=*/true);\n \n                     UniValue p(UniValue::VOBJ);\n                     p.pushKV(\"generated\", bool(prev_coin.fCoinBase));"
      },
      {
        "sha": "99ae40d80c5de5fc6787138e3331a42d5119ff87",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -504,7 +504,7 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n     if (!addr_bind.IsValid()) {\n         addr_bind = GetBindAddress(sock->Get());\n     }\n-    CNode* pnode = new CNode(id, nLocalServices, sock->Release(), addrConnect, CalculateKeyedNetGroup(addrConnect), nonce, addr_bind, pszDest ? pszDest : \"\", conn_type, /* inbound_onion */ false);\n+    CNode* pnode = new CNode(id, nLocalServices, sock->Release(), addrConnect, CalculateKeyedNetGroup(addrConnect), nonce, addr_bind, pszDest ? pszDest : \"\", conn_type, /*inbound_onion=*/false);\n     pnode->AddRef();\n \n     // We're making a new connection, harvest entropy from the time (and our peer count)\n@@ -925,7 +925,7 @@ void ProtectEvictionCandidatesByRatio(std::vector<NodeEvictionCandidate>& evicti\n     // array members have first opportunity to recover unused slots from the previous iteration.\n     struct Net { bool is_local; Network id; size_t count; };\n     std::array<Net, 3> networks{\n-        {{false, NET_I2P, 0}, {/* localhost */ true, NET_MAX, 0}, {false, NET_ONION, 0}}};\n+        {{false, NET_I2P, 0}, {/*localhost=*/true, NET_MAX, 0}, {false, NET_ONION, 0}}};\n \n     // Count and store the number of eviction candidates per network.\n     for (Net& n : networks) {\n@@ -2757,7 +2757,7 @@ std::vector<CAddress> CConnman::GetAddresses(CNode& requestor, size_t max_addres\n     auto r = m_addr_response_caches.emplace(cache_id, CachedAddrResponse{});\n     CachedAddrResponse& cache_entry = r.first->second;\n     if (cache_entry.m_cache_entry_expiration < current_time) { // If emplace() added new one it has expiration 0.\n-        cache_entry.m_addrs_response_cache = GetAddresses(max_addresses, max_pct, /* network */ std::nullopt);\n+        cache_entry.m_addrs_response_cache = GetAddresses(max_addresses, max_pct, /*network=*/std::nullopt);\n         // Choosing a proper cache lifetime is a trade-off between the privacy leak minimization\n         // and the usefulness of ADDR responses to honest users.\n         //"
      },
      {
        "sha": "63a1be83e4482634277fdc619aa9184c6c884b2c",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -3437,7 +3437,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         BlockValidationState state;\n         if (!m_chainman.ProcessNewBlockHeaders({cmpctblock.header}, state, m_chainparams, &pindex)) {\n             if (state.IsInvalid()) {\n-                MaybePunishNodeForBlock(pfrom.GetId(), state, /*via_compact_block*/ true, \"invalid header via cmpctblock\");\n+                MaybePunishNodeForBlock(pfrom.GetId(), state, /*via_compact_block=*/true, \"invalid header via cmpctblock\");\n                 return;\n             }\n         }\n@@ -3777,7 +3777,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         peer->m_addrs_to_send.clear();\n         std::vector<CAddress> vAddr;\n         if (pfrom.HasPermission(NetPermissionFlags::Addr)) {\n-            vAddr = m_connman.GetAddresses(MAX_ADDR_TO_SEND, MAX_PCT_ADDR_TO_SEND, /* network */ std::nullopt);\n+            vAddr = m_connman.GetAddresses(MAX_ADDR_TO_SEND, MAX_PCT_ADDR_TO_SEND, /*network=*/std::nullopt);\n         } else {\n             vAddr = m_connman.GetAddresses(pfrom, MAX_ADDR_TO_SEND, MAX_PCT_ADDR_TO_SEND);\n         }"
      },
      {
        "sha": "8df1e910630a40b6f4aea14cac2a14fc9ea12432",
        "filename": "src/node/interfaces.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/node/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/node/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/interfaces.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -592,7 +592,7 @@ class ChainImpl : public Chain\n         bool relay,\n         std::string& err_string) override\n     {\n-        const TransactionError err = BroadcastTransaction(m_node, tx, err_string, max_tx_fee, relay, /*wait_callback*/ false);\n+        const TransactionError err = BroadcastTransaction(m_node, tx, err_string, max_tx_fee, relay, /*wait_callback=*/false);\n         // Chain clients only care about failures to accept the tx to the mempool. Disregard non-mempool related failures.\n         // Note: this will need to be updated if BroadcastTransactions() is updated to return other non-mempool failures\n         // that Chain clients do not need to know about."
      },
      {
        "sha": "e7ba3243d8bb5cc54a8b5bb058cbbd2b0550b533",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -846,7 +846,7 @@ void BitcoinGUI::aboutClicked()\n     if(!clientModel)\n         return;\n \n-    auto dlg = new HelpMessageDialog(this, /* about */ true);\n+    auto dlg = new HelpMessageDialog(this, /*about=*/true);\n     GUIUtil::ShowModalDialogAndDeleteOnClose(dlg);\n }\n "
      },
      {
        "sha": "675883c5f27f1fce2d80d692e3385d04a6f2fc44",
        "filename": "src/qt/peertablemodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/qt/peertablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/qt/peertablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/peertablemodel.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -80,7 +80,7 @@ QVariant PeerTableModel::data(const QModelIndex& index, int role) const\n                                //: An Outbound Connection to a Peer.\n                                tr(\"Outbound\"));\n         case ConnectionType:\n-            return GUIUtil::ConnectionTypeToQString(rec->nodeStats.m_conn_type, /* prepend_direction */ false);\n+            return GUIUtil::ConnectionTypeToQString(rec->nodeStats.m_conn_type, /*prepend_direction=*/false);\n         case Network:\n             return GUIUtil::NetworkToQString(rec->nodeStats.m_network);\n         case Ping:"
      },
      {
        "sha": "7a380b5acbb9a20f581fcc8fde96b53802c29fcd",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -844,7 +844,7 @@ void RPCConsole::setFontSize(int newSize)\n \n     // clear console (reset icon sizes, default stylesheet) and re-add the content\n     float oldPosFactor = 1.0 / ui->messagesWidget->verticalScrollBar()->maximum() * ui->messagesWidget->verticalScrollBar()->value();\n-    clear(/* keep_prompt */ true);\n+    clear(/*keep_prompt=*/true);\n     ui->messagesWidget->setHtml(str);\n     ui->messagesWidget->verticalScrollBar()->setValue(oldPosFactor * ui->messagesWidget->verticalScrollBar()->maximum());\n }\n@@ -1181,7 +1181,7 @@ void RPCConsole::updateDetailWidget()\n     ui->timeoffset->setText(GUIUtil::formatTimeOffset(stats->nodeStats.nTimeOffset));\n     ui->peerVersion->setText(QString::number(stats->nodeStats.nVersion));\n     ui->peerSubversion->setText(QString::fromStdString(stats->nodeStats.cleanSubVer));\n-    ui->peerConnectionType->setText(GUIUtil::ConnectionTypeToQString(stats->nodeStats.m_conn_type, /* prepend_direction */ true));\n+    ui->peerConnectionType->setText(GUIUtil::ConnectionTypeToQString(stats->nodeStats.m_conn_type, /*prepend_direction=*/true));\n     ui->peerNetwork->setText(GUIUtil::NetworkToQString(stats->nodeStats.m_network));\n     if (stats->nodeStats.m_permissionFlags == NetPermissionFlags::None) {\n         ui->peerPermissions->setText(ts.na);"
      },
      {
        "sha": "40a0a904731c0461be2ee5c5eb15be061c417676",
        "filename": "src/qt/transactiontablemodel.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/qt/transactiontablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/qt/transactiontablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -32,11 +32,11 @@\n \n // Amount column is right-aligned it contains numbers\n static int column_alignments[] = {\n-        Qt::AlignLeft|Qt::AlignVCenter, /* status */\n-        Qt::AlignLeft|Qt::AlignVCenter, /* watchonly */\n-        Qt::AlignLeft|Qt::AlignVCenter, /* date */\n-        Qt::AlignLeft|Qt::AlignVCenter, /* type */\n-        Qt::AlignLeft|Qt::AlignVCenter, /* address */\n+        Qt::AlignLeft|Qt::AlignVCenter, /*status=*/\n+        Qt::AlignLeft|Qt::AlignVCenter, /*watchonly=*/\n+        Qt::AlignLeft|Qt::AlignVCenter, /*date=*/\n+        Qt::AlignLeft|Qt::AlignVCenter, /*type=*/\n+        Qt::AlignLeft|Qt::AlignVCenter, /*address=*/\n         Qt::AlignRight|Qt::AlignVCenter /* amount */\n     };\n "
      },
      {
        "sha": "ca634672cbe1290731e96bab6373dab6389e5f98",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 52,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -858,8 +858,8 @@ static RPCHelpMan getblockheader()\n                             {RPCResult::Type::NUM, \"difficulty\", \"The difficulty\"},\n                             {RPCResult::Type::STR_HEX, \"chainwork\", \"Expected number of hashes required to produce the current chain\"},\n                             {RPCResult::Type::NUM, \"nTx\", \"The number of transactions in the block\"},\n-                            {RPCResult::Type::STR_HEX, \"previousblockhash\", /* optional */ true, \"The hash of the previous block (if available)\"},\n-                            {RPCResult::Type::STR_HEX, \"nextblockhash\", /* optional */ true, \"The hash of the next block (if available)\"},\n+                            {RPCResult::Type::STR_HEX, \"previousblockhash\", /*optional=*/true, \"The hash of the previous block (if available)\"},\n+                            {RPCResult::Type::STR_HEX, \"nextblockhash\", /*optional=*/true, \"The hash of the next block (if available)\"},\n                         }},\n                     RPCResult{\"for verbose=false\",\n                         RPCResult::Type::STR_HEX, \"\", \"A string that is serialized, hex-encoded data for block 'hash'\"},\n@@ -968,8 +968,8 @@ static RPCHelpMan getblock()\n                     {RPCResult::Type::NUM, \"difficulty\", \"The difficulty\"},\n                     {RPCResult::Type::STR_HEX, \"chainwork\", \"Expected number of hashes required to produce the chain up to this block (in hex)\"},\n                     {RPCResult::Type::NUM, \"nTx\", \"The number of transactions in the block\"},\n-                    {RPCResult::Type::STR_HEX, \"previousblockhash\", /* optional */ true, \"The hash of the previous block (if available)\"},\n-                    {RPCResult::Type::STR_HEX, \"nextblockhash\", /* optional */ true, \"The hash of the next block (if available)\"},\n+                    {RPCResult::Type::STR_HEX, \"previousblockhash\", /*optional=*/true, \"The hash of the previous block (if available)\"},\n+                    {RPCResult::Type::STR_HEX, \"nextblockhash\", /*optional=*/true, \"The hash of the next block (if available)\"},\n                 }},\n                     RPCResult{\"for verbosity = 2\",\n                 RPCResult::Type::OBJ, \"\", \"\",\n@@ -1130,13 +1130,13 @@ static RPCHelpMan gettxoutsetinfo()\n                         {RPCResult::Type::STR_HEX, \"bestblock\", \"The hash of the block at which these statistics are calculated\"},\n                         {RPCResult::Type::NUM, \"txouts\", \"The number of unspent transaction outputs\"},\n                         {RPCResult::Type::NUM, \"bogosize\", \"Database-independent, meaningless metric indicating the UTXO set size\"},\n-                        {RPCResult::Type::STR_HEX, \"hash_serialized_2\", /* optional */ true, \"The serialized hash (only present if 'hash_serialized_2' hash_type is chosen)\"},\n-                        {RPCResult::Type::STR_HEX, \"muhash\", /* optional */ true, \"The serialized hash (only present if 'muhash' hash_type is chosen)\"},\n-                        {RPCResult::Type::NUM, \"transactions\", /* optional */ true, \"The number of transactions with unspent outputs (not available when coinstatsindex is used)\"},\n-                        {RPCResult::Type::NUM, \"disk_size\", /* optional */ true, \"The estimated size of the chainstate on disk (not available when coinstatsindex is used)\"},\n+                        {RPCResult::Type::STR_HEX, \"hash_serialized_2\", /*optional=*/true, \"The serialized hash (only present if 'hash_serialized_2' hash_type is chosen)\"},\n+                        {RPCResult::Type::STR_HEX, \"muhash\", /*optional=*/true, \"The serialized hash (only present if 'muhash' hash_type is chosen)\"},\n+                        {RPCResult::Type::NUM, \"transactions\", /*optional=*/true, \"The number of transactions with unspent outputs (not available when coinstatsindex is used)\"},\n+                        {RPCResult::Type::NUM, \"disk_size\", /*optional=*/true, \"The estimated size of the chainstate on disk (not available when coinstatsindex is used)\"},\n                         {RPCResult::Type::STR_AMOUNT, \"total_amount\", \"The total amount of coins in the UTXO set\"},\n-                        {RPCResult::Type::STR_AMOUNT, \"total_unspendable_amount\", /* optional */ true, \"The total amount of coins permanently excluded from the UTXO set (only available if coinstatsindex is used)\"},\n-                        {RPCResult::Type::OBJ, \"block_info\", /* optional */ true, \"Info on amounts in the block at this block height (only available if coinstatsindex is used)\",\n+                        {RPCResult::Type::STR_AMOUNT, \"total_unspendable_amount\", /*optional=*/true, \"The total amount of coins permanently excluded from the UTXO set (only available if coinstatsindex is used)\"},\n+                        {RPCResult::Type::OBJ, \"block_info\", /*optional=*/true, \"Info on amounts in the block at this block height (only available if coinstatsindex is used)\",\n                         {\n                             {RPCResult::Type::STR_AMOUNT, \"prevout_spent\", \"Total amount of all prevouts spent in this block\"},\n                             {RPCResult::Type::STR_AMOUNT, \"coinbase\", \"Coinbase subsidy amount of this block\"},\n@@ -1274,7 +1274,7 @@ static RPCHelpMan gettxout()\n                     {RPCResult::Type::STR, \"asm\", \"\"},\n                     {RPCResult::Type::STR_HEX, \"hex\", \"\"},\n                     {RPCResult::Type::STR, \"type\", \"The type, eg pubkeyhash\"},\n-                    {RPCResult::Type::STR, \"address\", /* optional */ true, \"The Bitcoin address (only if a well-defined address exists)\"},\n+                    {RPCResult::Type::STR, \"address\", /*optional=*/true, \"The Bitcoin address (only if a well-defined address exists)\"},\n                 }},\n                 {RPCResult::Type::BOOL, \"coinbase\", \"Coinbase or not\"},\n             }},\n@@ -1450,32 +1450,32 @@ RPCHelpMan getblockchaininfo()\n                         {RPCResult::Type::STR_HEX, \"chainwork\", \"total amount of work in active chain, in hexadecimal\"},\n                         {RPCResult::Type::NUM, \"size_on_disk\", \"the estimated size of the block and undo files on disk\"},\n                         {RPCResult::Type::BOOL, \"pruned\", \"if the blocks are subject to pruning\"},\n-                        {RPCResult::Type::NUM, \"pruneheight\", /* optional */ true, \"lowest-height complete block stored (only present if pruning is enabled)\"},\n-                        {RPCResult::Type::BOOL, \"automatic_pruning\", /* optional */ true, \"whether automatic pruning is enabled (only present if pruning is enabled)\"},\n-                        {RPCResult::Type::NUM, \"prune_target_size\", /* optional */ true, \"the target size used by pruning (only present if automatic pruning is enabled)\"},\n+                        {RPCResult::Type::NUM, \"pruneheight\", /*optional=*/true, \"lowest-height complete block stored (only present if pruning is enabled)\"},\n+                        {RPCResult::Type::BOOL, \"automatic_pruning\", /*optional=*/true, \"whether automatic pruning is enabled (only present if pruning is enabled)\"},\n+                        {RPCResult::Type::NUM, \"prune_target_size\", /*optional=*/true, \"the target size used by pruning (only present if automatic pruning is enabled)\"},\n                         {RPCResult::Type::OBJ_DYN, \"softforks\", \"status of softforks\",\n                         {\n                             {RPCResult::Type::OBJ, \"xxxx\", \"name of the softfork\",\n                             {\n                                 {RPCResult::Type::STR, \"type\", \"one of \\\"buried\\\", \\\"bip9\\\"\"},\n-                                {RPCResult::Type::OBJ, \"bip9\", /* optional */ true, \"status of bip9 softforks (only for \\\"bip9\\\" type)\",\n+                                {RPCResult::Type::OBJ, \"bip9\", /*optional=*/true, \"status of bip9 softforks (only for \\\"bip9\\\" type)\",\n                                 {\n                                     {RPCResult::Type::STR, \"status\", \"one of \\\"defined\\\", \\\"started\\\", \\\"locked_in\\\", \\\"active\\\", \\\"failed\\\"\"},\n-                                    {RPCResult::Type::NUM, \"bit\", /* optional */ true, \"the bit (0-28) in the block version field used to signal this softfork (only for \\\"started\\\" and \\\"locked_in\\\" status)\"},\n+                                    {RPCResult::Type::NUM, \"bit\", /*optional=*/true, \"the bit (0-28) in the block version field used to signal this softfork (only for \\\"started\\\" and \\\"locked_in\\\" status)\"},\n                                     {RPCResult::Type::NUM_TIME, \"start_time\", \"the minimum median time past of a block at which the bit gains its meaning\"},\n                                     {RPCResult::Type::NUM_TIME, \"timeout\", \"the median time past of a block at which the deployment is considered failed if not yet locked in\"},\n                                     {RPCResult::Type::NUM, \"since\", \"height of the first block to which the status applies\"},\n                                     {RPCResult::Type::NUM, \"min_activation_height\", \"minimum height of blocks for which the rules may be enforced\"},\n-                                    {RPCResult::Type::OBJ, \"statistics\", /* optional */ true, \"numeric statistics about signalling for a softfork (only for \\\"started\\\" and \\\"locked_in\\\" status)\",\n+                                    {RPCResult::Type::OBJ, \"statistics\", /*optional=*/true, \"numeric statistics about signalling for a softfork (only for \\\"started\\\" and \\\"locked_in\\\" status)\",\n                                     {\n                                         {RPCResult::Type::NUM, \"period\", \"the length in blocks of the signalling period\"},\n-                                        {RPCResult::Type::NUM, \"threshold\", /* optional */ true, \"the number of blocks with the version bit set required to activate the feature (only for \\\"started\\\" status)\"},\n+                                        {RPCResult::Type::NUM, \"threshold\", /*optional=*/true, \"the number of blocks with the version bit set required to activate the feature (only for \\\"started\\\" status)\"},\n                                         {RPCResult::Type::NUM, \"elapsed\", \"the number of blocks elapsed since the beginning of the current period\"},\n                                         {RPCResult::Type::NUM, \"count\", \"the number of blocks with the version bit set in the current period\"},\n-                                        {RPCResult::Type::BOOL, \"possible\", /* optional */ true, \"returns false if there are not enough blocks left in this period to pass activation threshold (only for \\\"started\\\" status)\"},\n+                                        {RPCResult::Type::BOOL, \"possible\", /*optional=*/true, \"returns false if there are not enough blocks left in this period to pass activation threshold (only for \\\"started\\\" status)\"},\n                                     }},\n                                 }},\n-                                {RPCResult::Type::NUM, \"height\", /* optional */ true, \"height of the first block which the rules are or will be enforced (only for \\\"buried\\\" type, or \\\"bip9\\\" type with \\\"active\\\" status)\"},\n+                                {RPCResult::Type::NUM, \"height\", /*optional=*/true, \"height of the first block which the rules are or will be enforced (only for \\\"buried\\\" type, or \\\"bip9\\\" type with \\\"active\\\" status)\"},\n                                 {RPCResult::Type::BOOL, \"active\", \"true if the rules are enforced for the mempool and the next block\"},\n                             }},\n                         }},\n@@ -1838,9 +1838,9 @@ static RPCHelpMan getchaintxstats()\n                         {RPCResult::Type::STR_HEX, \"window_final_block_hash\", \"The hash of the final block in the window\"},\n                         {RPCResult::Type::NUM, \"window_final_block_height\", \"The height of the final block in the window.\"},\n                         {RPCResult::Type::NUM, \"window_block_count\", \"Size of the window in number of blocks\"},\n-                        {RPCResult::Type::NUM, \"window_tx_count\", /* optional */ true, \"The number of transactions in the window. Only returned if \\\"window_block_count\\\" is > 0\"},\n-                        {RPCResult::Type::NUM, \"window_interval\", /* optional */ true, \"The elapsed time in the window in seconds. Only returned if \\\"window_block_count\\\" is > 0\"},\n-                        {RPCResult::Type::NUM, \"txrate\", /* optional */ true, \"The average rate of transactions per second in the window. Only returned if \\\"window_interval\\\" is > 0\"},\n+                        {RPCResult::Type::NUM, \"window_tx_count\", /*optional=*/true, \"The number of transactions in the window. Only returned if \\\"window_block_count\\\" is > 0\"},\n+                        {RPCResult::Type::NUM, \"window_interval\", /*optional=*/true, \"The elapsed time in the window in seconds. Only returned if \\\"window_block_count\\\" is > 0\"},\n+                        {RPCResult::Type::NUM, \"txrate\", /*optional=*/true, \"The average rate of transactions per second in the window. Only returned if \\\"window_interval\\\" is > 0\"},\n                     }},\n                 RPCExamples{\n                     HelpExampleCli(\"getchaintxstats\", \"\")\n@@ -1975,42 +1975,42 @@ static RPCHelpMan getblockstats()\n                 RPCResult{\n             RPCResult::Type::OBJ, \"\", \"\",\n             {\n-                {RPCResult::Type::NUM, \"avgfee\", /* optional */ true, \"Average fee in the block\"},\n-                {RPCResult::Type::NUM, \"avgfeerate\", /* optional */ true, \"Average feerate (in satoshis per virtual byte)\"},\n-                {RPCResult::Type::NUM, \"avgtxsize\", /* optional */ true, \"Average transaction size\"},\n-                {RPCResult::Type::STR_HEX, \"blockhash\", /* optional */ true, \"The block hash (to check for potential reorgs)\"},\n-                {RPCResult::Type::ARR_FIXED, \"feerate_percentiles\", /* optional */ true, \"Feerates at the 10th, 25th, 50th, 75th, and 90th percentile weight unit (in satoshis per virtual byte)\",\n+                {RPCResult::Type::NUM, \"avgfee\", /*optional=*/true, \"Average fee in the block\"},\n+                {RPCResult::Type::NUM, \"avgfeerate\", /*optional=*/true, \"Average feerate (in satoshis per virtual byte)\"},\n+                {RPCResult::Type::NUM, \"avgtxsize\", /*optional=*/true, \"Average transaction size\"},\n+                {RPCResult::Type::STR_HEX, \"blockhash\", /*optional=*/true, \"The block hash (to check for potential reorgs)\"},\n+                {RPCResult::Type::ARR_FIXED, \"feerate_percentiles\", /*optional=*/true, \"Feerates at the 10th, 25th, 50th, 75th, and 90th percentile weight unit (in satoshis per virtual byte)\",\n                 {\n                     {RPCResult::Type::NUM, \"10th_percentile_feerate\", \"The 10th percentile feerate\"},\n                     {RPCResult::Type::NUM, \"25th_percentile_feerate\", \"The 25th percentile feerate\"},\n                     {RPCResult::Type::NUM, \"50th_percentile_feerate\", \"The 50th percentile feerate\"},\n                     {RPCResult::Type::NUM, \"75th_percentile_feerate\", \"The 75th percentile feerate\"},\n                     {RPCResult::Type::NUM, \"90th_percentile_feerate\", \"The 90th percentile feerate\"},\n                 }},\n-                {RPCResult::Type::NUM, \"height\", /* optional */ true, \"The height of the block\"},\n-                {RPCResult::Type::NUM, \"ins\", /* optional */ true, \"The number of inputs (excluding coinbase)\"},\n-                {RPCResult::Type::NUM, \"maxfee\", /* optional */ true, \"Maximum fee in the block\"},\n-                {RPCResult::Type::NUM, \"maxfeerate\", /* optional */ true, \"Maximum feerate (in satoshis per virtual byte)\"},\n-                {RPCResult::Type::NUM, \"maxtxsize\", /* optional */ true, \"Maximum transaction size\"},\n-                {RPCResult::Type::NUM, \"medianfee\", /* optional */ true, \"Truncated median fee in the block\"},\n-                {RPCResult::Type::NUM, \"mediantime\", /* optional */ true, \"The block median time past\"},\n-                {RPCResult::Type::NUM, \"mediantxsize\", /* optional */ true, \"Truncated median transaction size\"},\n-                {RPCResult::Type::NUM, \"minfee\", /* optional */ true, \"Minimum fee in the block\"},\n-                {RPCResult::Type::NUM, \"minfeerate\", /* optional */ true, \"Minimum feerate (in satoshis per virtual byte)\"},\n-                {RPCResult::Type::NUM, \"mintxsize\", /* optional */ true, \"Minimum transaction size\"},\n-                {RPCResult::Type::NUM, \"outs\", /* optional */ true, \"The number of outputs\"},\n-                {RPCResult::Type::NUM, \"subsidy\", /* optional */ true, \"The block subsidy\"},\n-                {RPCResult::Type::NUM, \"swtotal_size\", /* optional */ true, \"Total size of all segwit transactions\"},\n-                {RPCResult::Type::NUM, \"swtotal_weight\", /* optional */ true, \"Total weight of all segwit transactions\"},\n-                {RPCResult::Type::NUM, \"swtxs\", /* optional */ true, \"The number of segwit transactions\"},\n-                {RPCResult::Type::NUM, \"time\", /* optional */ true, \"The block time\"},\n-                {RPCResult::Type::NUM, \"total_out\", /* optional */ true, \"Total amount in all outputs (excluding coinbase and thus reward [ie subsidy + totalfee])\"},\n-                {RPCResult::Type::NUM, \"total_size\", /* optional */ true, \"Total size of all non-coinbase transactions\"},\n-                {RPCResult::Type::NUM, \"total_weight\", /* optional */ true, \"Total weight of all non-coinbase transactions\"},\n-                {RPCResult::Type::NUM, \"totalfee\", /* optional */ true, \"The fee total\"},\n-                {RPCResult::Type::NUM, \"txs\", /* optional */ true, \"The number of transactions (including coinbase)\"},\n-                {RPCResult::Type::NUM, \"utxo_increase\", /* optional */ true, \"The increase/decrease in the number of unspent outputs\"},\n-                {RPCResult::Type::NUM, \"utxo_size_inc\", /* optional */ true, \"The increase/decrease in size for the utxo index (not discounting op_return and similar)\"},\n+                {RPCResult::Type::NUM, \"height\", /*optional=*/true, \"The height of the block\"},\n+                {RPCResult::Type::NUM, \"ins\", /*optional=*/true, \"The number of inputs (excluding coinbase)\"},\n+                {RPCResult::Type::NUM, \"maxfee\", /*optional=*/true, \"Maximum fee in the block\"},\n+                {RPCResult::Type::NUM, \"maxfeerate\", /*optional=*/true, \"Maximum feerate (in satoshis per virtual byte)\"},\n+                {RPCResult::Type::NUM, \"maxtxsize\", /*optional=*/true, \"Maximum transaction size\"},\n+                {RPCResult::Type::NUM, \"medianfee\", /*optional=*/true, \"Truncated median fee in the block\"},\n+                {RPCResult::Type::NUM, \"mediantime\", /*optional=*/true, \"The block median time past\"},\n+                {RPCResult::Type::NUM, \"mediantxsize\", /*optional=*/true, \"Truncated median transaction size\"},\n+                {RPCResult::Type::NUM, \"minfee\", /*optional=*/true, \"Minimum fee in the block\"},\n+                {RPCResult::Type::NUM, \"minfeerate\", /*optional=*/true, \"Minimum feerate (in satoshis per virtual byte)\"},\n+                {RPCResult::Type::NUM, \"mintxsize\", /*optional=*/true, \"Minimum transaction size\"},\n+                {RPCResult::Type::NUM, \"outs\", /*optional=*/true, \"The number of outputs\"},\n+                {RPCResult::Type::NUM, \"subsidy\", /*optional=*/true, \"The block subsidy\"},\n+                {RPCResult::Type::NUM, \"swtotal_size\", /*optional=*/true, \"Total size of all segwit transactions\"},\n+                {RPCResult::Type::NUM, \"swtotal_weight\", /*optional=*/true, \"Total weight of all segwit transactions\"},\n+                {RPCResult::Type::NUM, \"swtxs\", /*optional=*/true, \"The number of segwit transactions\"},\n+                {RPCResult::Type::NUM, \"time\", /*optional=*/true, \"The block time\"},\n+                {RPCResult::Type::NUM, \"total_out\", /*optional=*/true, \"Total amount in all outputs (excluding coinbase and thus reward [ie subsidy + totalfee])\"},\n+                {RPCResult::Type::NUM, \"total_size\", /*optional=*/true, \"Total size of all non-coinbase transactions\"},\n+                {RPCResult::Type::NUM, \"total_weight\", /*optional=*/true, \"Total weight of all non-coinbase transactions\"},\n+                {RPCResult::Type::NUM, \"totalfee\", /*optional=*/true, \"The fee total\"},\n+                {RPCResult::Type::NUM, \"txs\", /*optional=*/true, \"The number of transactions (including coinbase)\"},\n+                {RPCResult::Type::NUM, \"utxo_increase\", /*optional=*/true, \"The increase/decrease in the number of unspent outputs\"},\n+                {RPCResult::Type::NUM, \"utxo_size_inc\", /*optional=*/true, \"The increase/decrease in size for the utxo index (not discounting op_return and similar)\"},\n             }},\n                 RPCExamples{\n                     HelpExampleCli(\"getblockstats\", R\"('\"00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09\"' '[\"minfeerate\",\"avgfeerate\"]')\") +"
      },
      {
        "sha": "82aa6f9516fa389afbfc980cfe4c4f499a273569",
        "filename": "src/rpc/external_signer.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/rpc/external_signer.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/rpc/external_signer.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/external_signer.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -22,7 +22,7 @@ static RPCHelpMan enumeratesigners()\n         RPCResult{\n             RPCResult::Type::OBJ, \"\", \"\",\n             {\n-                {RPCResult::Type::ARR, \"signers\", /* optional */ false, \"\",\n+                {RPCResult::Type::ARR, \"signers\", /*optional=*/false, \"\",\n                 {\n                     {RPCResult::Type::OBJ, \"\", \"\",\n                     {"
      },
      {
        "sha": "5fe72fa97494076e83ef7f319ce7f40f16a18d31",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -412,8 +412,8 @@ static RPCHelpMan getmininginfo()\n                     RPCResult::Type::OBJ, \"\", \"\",\n                     {\n                         {RPCResult::Type::NUM, \"blocks\", \"The current block\"},\n-                        {RPCResult::Type::NUM, \"currentblockweight\", /* optional */ true, \"The block weight of the last assembled block (only present if a block was ever assembled)\"},\n-                        {RPCResult::Type::NUM, \"currentblocktx\", /* optional */ true, \"The number of block transactions of the last assembled block (only present if a block was ever assembled)\"},\n+                        {RPCResult::Type::NUM, \"currentblockweight\", /*optional=*/true, \"The block weight of the last assembled block (only present if a block was ever assembled)\"},\n+                        {RPCResult::Type::NUM, \"currentblocktx\", /*optional=*/true, \"The number of block transactions of the last assembled block (only present if a block was ever assembled)\"},\n                         {RPCResult::Type::NUM, \"difficulty\", \"The current difficulty\"},\n                         {RPCResult::Type::NUM, \"networkhashps\", \"The network hashes per second\"},\n                         {RPCResult::Type::NUM, \"pooledtx\", \"The size of the mempool\"},\n@@ -590,12 +590,12 @@ static RPCHelpMan getblocktemplate()\n                 {RPCResult::Type::STR_HEX, \"noncerange\", \"A range of valid nonces\"},\n                 {RPCResult::Type::NUM, \"sigoplimit\", \"limit of sigops in blocks\"},\n                 {RPCResult::Type::NUM, \"sizelimit\", \"limit of block size\"},\n-                {RPCResult::Type::NUM, \"weightlimit\", /* optional */ true, \"limit of block weight\"},\n+                {RPCResult::Type::NUM, \"weightlimit\", /*optional=*/true, \"limit of block weight\"},\n                 {RPCResult::Type::NUM_TIME, \"curtime\", \"current timestamp in \" + UNIX_EPOCH_TIME},\n                 {RPCResult::Type::STR, \"bits\", \"compressed target of next block\"},\n                 {RPCResult::Type::NUM, \"height\", \"The height of the next block\"},\n-                {RPCResult::Type::STR_HEX, \"signet_challenge\", /* optional */ true, \"Only on signet\"},\n-                {RPCResult::Type::STR_HEX, \"default_witness_commitment\", /* optional */ true, \"a valid witness commitment for the unmodified block template\"},\n+                {RPCResult::Type::STR_HEX, \"signet_challenge\", /*optional=*/true, \"Only on signet\"},\n+                {RPCResult::Type::STR_HEX, \"default_witness_commitment\", /*optional=*/true, \"a valid witness commitment for the unmodified block template\"},\n             }},\n         },\n         RPCExamples{\n@@ -1082,8 +1082,8 @@ static RPCHelpMan estimatesmartfee()\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"\",\n                     {\n-                        {RPCResult::Type::NUM, \"feerate\", /* optional */ true, \"estimate fee rate in \" + CURRENCY_UNIT + \"/kvB (only present if no errors were encountered)\"},\n-                        {RPCResult::Type::ARR, \"errors\", /* optional */ true, \"Errors encountered during processing (if there are any)\",\n+                        {RPCResult::Type::NUM, \"feerate\", /*optional=*/true, \"estimate fee rate in \" + CURRENCY_UNIT + \"/kvB (only present if no errors were encountered)\"},\n+                        {RPCResult::Type::ARR, \"errors\", /*optional=*/true, \"Errors encountered during processing (if there are any)\",\n                             {\n                                 {RPCResult::Type::STR, \"\", \"error\"},\n                             }},\n@@ -1155,12 +1155,12 @@ static RPCHelpMan estimaterawfee()\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"Results are returned for any horizon which tracks blocks up to the confirmation target\",\n                     {\n-                        {RPCResult::Type::OBJ, \"short\", /* optional */ true, \"estimate for short time horizon\",\n+                        {RPCResult::Type::OBJ, \"short\", /*optional=*/true, \"estimate for short time horizon\",\n                             {\n-                                {RPCResult::Type::NUM, \"feerate\", /* optional */ true, \"estimate fee rate in \" + CURRENCY_UNIT + \"/kvB\"},\n+                                {RPCResult::Type::NUM, \"feerate\", /*optional=*/true, \"estimate fee rate in \" + CURRENCY_UNIT + \"/kvB\"},\n                                 {RPCResult::Type::NUM, \"decay\", \"exponential decay (per block) for historical moving average of confirmation data\"},\n                                 {RPCResult::Type::NUM, \"scale\", \"The resolution of confirmation targets at this time horizon\"},\n-                                {RPCResult::Type::OBJ, \"pass\", /* optional */ true, \"information about the lowest range of feerates to succeed in meeting the threshold\",\n+                                {RPCResult::Type::OBJ, \"pass\", /*optional=*/true, \"information about the lowest range of feerates to succeed in meeting the threshold\",\n                                 {\n                                         {RPCResult::Type::NUM, \"startrange\", \"start of feerate range\"},\n                                         {RPCResult::Type::NUM, \"endrange\", \"end of feerate range\"},\n@@ -1169,20 +1169,20 @@ static RPCHelpMan estimaterawfee()\n                                         {RPCResult::Type::NUM, \"inmempool\", \"current number of txs in mempool in the feerate range unconfirmed for at least target blocks\"},\n                                         {RPCResult::Type::NUM, \"leftmempool\", \"number of txs over history horizon in the feerate range that left mempool unconfirmed after target\"},\n                                 }},\n-                                {RPCResult::Type::OBJ, \"fail\", /* optional */ true, \"information about the highest range of feerates to fail to meet the threshold\",\n+                                {RPCResult::Type::OBJ, \"fail\", /*optional=*/true, \"information about the highest range of feerates to fail to meet the threshold\",\n                                 {\n                                     {RPCResult::Type::ELISION, \"\", \"\"},\n                                 }},\n-                                {RPCResult::Type::ARR, \"errors\", /* optional */ true, \"Errors encountered during processing (if there are any)\",\n+                                {RPCResult::Type::ARR, \"errors\", /*optional=*/true, \"Errors encountered during processing (if there are any)\",\n                                 {\n                                     {RPCResult::Type::STR, \"error\", \"\"},\n                                 }},\n                         }},\n-                        {RPCResult::Type::OBJ, \"medium\", /* optional */ true, \"estimate for medium time horizon\",\n+                        {RPCResult::Type::OBJ, \"medium\", /*optional=*/true, \"estimate for medium time horizon\",\n                         {\n                             {RPCResult::Type::ELISION, \"\", \"\"},\n                         }},\n-                        {RPCResult::Type::OBJ, \"long\", /* optional */ true, \"estimate for long time horizon\",\n+                        {RPCResult::Type::OBJ, \"long\", /*optional=*/true, \"estimate for long time horizon\",\n                         {\n                             {RPCResult::Type::ELISION, \"\", \"\"},\n                         }},"
      },
      {
        "sha": "ce0baff0aac1d83bfe81c8109877e94f4a5cea1a",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -45,13 +45,13 @@ static RPCHelpMan validateaddress()\n                     RPCResult::Type::OBJ, \"\", \"\",\n                     {\n                         {RPCResult::Type::BOOL, \"isvalid\", \"If the address is valid or not\"},\n-                        {RPCResult::Type::STR, \"address\", /* optional */ true, \"The bitcoin address validated\"},\n-                        {RPCResult::Type::STR_HEX, \"scriptPubKey\", /* optional */ true, \"The hex-encoded scriptPubKey generated by the address\"},\n-                        {RPCResult::Type::BOOL, \"isscript\", /* optional */ true, \"If the key is a script\"},\n-                        {RPCResult::Type::BOOL, \"iswitness\", /* optional */ true, \"If the address is a witness address\"},\n-                        {RPCResult::Type::NUM, \"witness_version\", /* optional */ true, \"The version number of the witness program\"},\n-                        {RPCResult::Type::STR_HEX, \"witness_program\", /* optional */ true, \"The hex value of the witness program\"},\n-                        {RPCResult::Type::STR, \"error\", /* optional */ true, \"Error message, if any\"},\n+                        {RPCResult::Type::STR, \"address\", /*optional=*/true, \"The bitcoin address validated\"},\n+                        {RPCResult::Type::STR_HEX, \"scriptPubKey\", /*optional=*/true, \"The hex-encoded scriptPubKey generated by the address\"},\n+                        {RPCResult::Type::BOOL, \"isscript\", /*optional=*/true, \"If the key is a script\"},\n+                        {RPCResult::Type::BOOL, \"iswitness\", /*optional=*/true, \"If the address is a witness address\"},\n+                        {RPCResult::Type::NUM, \"witness_version\", /*optional=*/true, \"The version number of the witness program\"},\n+                        {RPCResult::Type::STR_HEX, \"witness_program\", /*optional=*/true, \"The hex value of the witness program\"},\n+                        {RPCResult::Type::STR, \"error\", /*optional=*/true, \"Error message, if any\"},\n                     }\n                 },\n                 RPCExamples{"
      },
      {
        "sha": "d7cb02887472b08630382af6327c7bcff38c6592",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -116,10 +116,10 @@ static RPCHelpMan getpeerinfo()\n                             {\n                             {RPCResult::Type::NUM, \"id\", \"Peer index\"},\n                             {RPCResult::Type::STR, \"addr\", \"(host:port) The IP address and port of the peer\"},\n-                            {RPCResult::Type::STR, \"addrbind\", /* optional */ true, \"(ip:port) Bind address of the connection to the peer\"},\n-                            {RPCResult::Type::STR, \"addrlocal\", /* optional */ true, \"(ip:port) Local address as reported by the peer\"},\n-                            {RPCResult::Type::STR, \"network\", \"Network (\" + Join(GetNetworkNames(/* append_unroutable */ true), \", \") + \")\"},\n-                            {RPCResult::Type::NUM, \"mapped_as\", /* optional */ true, \"The AS in the BGP route to the peer used for diversifying\\n\"\n+                            {RPCResult::Type::STR, \"addrbind\", /*optional=*/true, \"(ip:port) Bind address of the connection to the peer\"},\n+                            {RPCResult::Type::STR, \"addrlocal\", /*optional=*/true, \"(ip:port) Local address as reported by the peer\"},\n+                            {RPCResult::Type::STR, \"network\", \"Network (\" + Join(GetNetworkNames(/*append_unroutable=*/true), \", \") + \")\"},\n+                            {RPCResult::Type::NUM, \"mapped_as\", /*optional=*/true, \"The AS in the BGP route to the peer used for diversifying\\n\"\n                                                                 \"peer selection (only available if the asmap config flag is set)\"},\n                             {RPCResult::Type::STR_HEX, \"services\", \"The services offered\"},\n                             {RPCResult::Type::ARR, \"servicesnames\", \"the services offered, in human-readable form\",\n@@ -135,9 +135,9 @@ static RPCHelpMan getpeerinfo()\n                             {RPCResult::Type::NUM, \"bytesrecv\", \"The total bytes received\"},\n                             {RPCResult::Type::NUM_TIME, \"conntime\", \"The \" + UNIX_EPOCH_TIME + \" of the connection\"},\n                             {RPCResult::Type::NUM, \"timeoffset\", \"The time offset in seconds\"},\n-                            {RPCResult::Type::NUM, \"pingtime\", /* optional */ true, \"ping time (if available)\"},\n-                            {RPCResult::Type::NUM, \"minping\", /* optional */ true, \"minimum observed ping time (if any at all)\"},\n-                            {RPCResult::Type::NUM, \"pingwait\", /* optional */ true, \"ping wait (if non-zero)\"},\n+                            {RPCResult::Type::NUM, \"pingtime\", /*optional=*/true, \"ping time (if available)\"},\n+                            {RPCResult::Type::NUM, \"minping\", /*optional=*/true, \"minimum observed ping time (if any at all)\"},\n+                            {RPCResult::Type::NUM, \"pingwait\", /*optional=*/true, \"ping wait (if non-zero)\"},\n                             {RPCResult::Type::NUM, \"version\", \"The peer version, such as 70001\"},\n                             {RPCResult::Type::STR, \"subver\", \"The string version\"},\n                             {RPCResult::Type::BOOL, \"inbound\", \"Inbound (true) or Outbound (false)\"},\n@@ -897,7 +897,7 @@ static RPCHelpMan getnodeaddresses()\n     }\n \n     // returns a shuffled list of CAddress\n-    const std::vector<CAddress> vAddr{connman.GetAddresses(count, /* max_pct */ 0, network)};\n+    const std::vector<CAddress> vAddr{connman.GetAddresses(count, /*max_pct=*/0, network)};\n     UniValue ret(UniValue::VARR);\n \n     for (const CAddress& addr : vAddr) {"
      },
      {
        "sha": "2be8e390afc1dd53e1cc83900c7ae16d558150fe",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 58,
        "deletions": 58,
        "changes": 116,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -95,7 +95,7 @@ static RPCHelpMan getrawtransaction()\n                      RPCResult{\"if verbose is set to true\",\n                          RPCResult::Type::OBJ, \"\", \"\",\n                          {\n-                             {RPCResult::Type::BOOL, \"in_active_chain\", /* optional */ true, \"Whether specified block is in the active chain or not (only present with explicit \\\"blockhash\\\" argument)\"},\n+                             {RPCResult::Type::BOOL, \"in_active_chain\", /*optional=*/true, \"Whether specified block is in the active chain or not (only present with explicit \\\"blockhash\\\" argument)\"},\n                              {RPCResult::Type::STR_HEX, \"hex\", \"The serialized, hex-encoded data for 'txid'\"},\n                              {RPCResult::Type::STR_HEX, \"txid\", \"The transaction id (same as provided)\"},\n                              {RPCResult::Type::STR_HEX, \"hash\", \"The transaction hash (differs from txid for witness transactions)\"},\n@@ -116,7 +116,7 @@ static RPCHelpMan getrawtransaction()\n                                          {RPCResult::Type::STR_HEX, \"hex\", \"hex\"},\n                                      }},\n                                      {RPCResult::Type::NUM, \"sequence\", \"The script sequence number\"},\n-                                     {RPCResult::Type::ARR, \"txinwitness\", /* optional */ true, \"\",\n+                                     {RPCResult::Type::ARR, \"txinwitness\", /*optional=*/true, \"\",\n                                      {\n                                          {RPCResult::Type::STR_HEX, \"hex\", \"hex-encoded witness data (if any)\"},\n                                      }},\n@@ -133,14 +133,14 @@ static RPCHelpMan getrawtransaction()\n                                          {RPCResult::Type::STR, \"asm\", \"the asm\"},\n                                          {RPCResult::Type::STR, \"hex\", \"the hex\"},\n                                          {RPCResult::Type::STR, \"type\", \"The type, eg 'pubkeyhash'\"},\n-                                         {RPCResult::Type::STR, \"address\", /* optional */ true, \"The Bitcoin address (only if a well-defined address exists)\"},\n+                                         {RPCResult::Type::STR, \"address\", /*optional=*/true, \"The Bitcoin address (only if a well-defined address exists)\"},\n                                      }},\n                                  }},\n                              }},\n-                             {RPCResult::Type::STR_HEX, \"blockhash\", /* optional */ true, \"the block hash\"},\n-                             {RPCResult::Type::NUM, \"confirmations\", /* optional */ true, \"The confirmations\"},\n-                             {RPCResult::Type::NUM_TIME, \"blocktime\", /* optional */ true, \"The block time expressed in \" + UNIX_EPOCH_TIME},\n-                             {RPCResult::Type::NUM, \"time\", /* optional */ true, \"Same as \\\"blocktime\\\"\"},\n+                             {RPCResult::Type::STR_HEX, \"blockhash\", /*optional=*/true, \"the block hash\"},\n+                             {RPCResult::Type::NUM, \"confirmations\", /*optional=*/true, \"The confirmations\"},\n+                             {RPCResult::Type::NUM_TIME, \"blocktime\", /*optional=*/true, \"The block time expressed in \" + UNIX_EPOCH_TIME},\n+                             {RPCResult::Type::NUM, \"time\", /*optional=*/true, \"Same as \\\"blocktime\\\"\"},\n                         }\n                     },\n                 },\n@@ -285,7 +285,7 @@ static RPCHelpMan gettxoutproof()\n     LOCK(cs_main);\n \n     if (pblockindex == nullptr) {\n-        const CTransactionRef tx = GetTransaction(/* block_index */ nullptr, /* mempool */ nullptr, *setTxids.begin(), Params().GetConsensus(), hashBlock);\n+        const CTransactionRef tx = GetTransaction(/*block_index=*/nullptr, /*mempool=*/nullptr, *setTxids.begin(), Params().GetConsensus(), hashBlock);\n         if (!tx || hashBlock.IsNull()) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction not yet in block\");\n         }\n@@ -466,15 +466,15 @@ static RPCHelpMan decoderawtransaction()\n                         {\n                             {RPCResult::Type::OBJ, \"\", \"\",\n                             {\n-                                {RPCResult::Type::STR_HEX, \"coinbase\", /* optional */ true, \"\"},\n-                                {RPCResult::Type::STR_HEX, \"txid\", /* optional */ true, \"The transaction id\"},\n-                                {RPCResult::Type::NUM, \"vout\", /* optional */ true, \"The output number\"},\n-                                {RPCResult::Type::OBJ, \"scriptSig\", /* optional */ true, \"The script\",\n+                                {RPCResult::Type::STR_HEX, \"coinbase\", /*optional=*/true, \"\"},\n+                                {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id\"},\n+                                {RPCResult::Type::NUM, \"vout\", /*optional=*/true, \"The output number\"},\n+                                {RPCResult::Type::OBJ, \"scriptSig\", /*optional=*/true, \"The script\",\n                                 {\n                                     {RPCResult::Type::STR, \"asm\", \"asm\"},\n                                     {RPCResult::Type::STR_HEX, \"hex\", \"hex\"},\n                                 }},\n-                                {RPCResult::Type::ARR, \"txinwitness\", /* optional */ true, \"\",\n+                                {RPCResult::Type::ARR, \"txinwitness\", /*optional=*/true, \"\",\n                                 {\n                                     {RPCResult::Type::STR_HEX, \"hex\", \"hex-encoded witness data (if any)\"},\n                                 }},\n@@ -492,7 +492,7 @@ static RPCHelpMan decoderawtransaction()\n                                     {RPCResult::Type::STR, \"asm\", \"the asm\"},\n                                     {RPCResult::Type::STR_HEX, \"hex\", \"the hex\"},\n                                     {RPCResult::Type::STR, \"type\", \"The type, eg 'pubkeyhash'\"},\n-                                    {RPCResult::Type::STR, \"address\", /* optional */ true, \"The Bitcoin address (only if a well-defined address exists)\"},\n+                                    {RPCResult::Type::STR, \"address\", /*optional=*/true, \"The Bitcoin address (only if a well-defined address exists)\"},\n                                 }},\n                             }},\n                         }},\n@@ -545,14 +545,14 @@ static RPCHelpMan decodescript()\n                     {\n                         {RPCResult::Type::STR, \"asm\", \"Script public key\"},\n                         {RPCResult::Type::STR, \"type\", \"The output type (e.g. \"+GetAllOutputTypes()+\")\"},\n-                        {RPCResult::Type::STR, \"address\", /* optional */ true, \"The Bitcoin address (only if a well-defined address exists)\"},\n-                        {RPCResult::Type::STR, \"p2sh\", /* optional */ true, \"address of P2SH script wrapping this redeem script (not returned if the script is already a P2SH)\"},\n-                        {RPCResult::Type::OBJ, \"segwit\", /* optional */ true, \"Result of a witness script public key wrapping this redeem script (not returned if the script is a P2SH or witness)\",\n+                        {RPCResult::Type::STR, \"address\", /*optional=*/true, \"The Bitcoin address (only if a well-defined address exists)\"},\n+                        {RPCResult::Type::STR, \"p2sh\", /*optional=*/true, \"address of P2SH script wrapping this redeem script (not returned if the script is already a P2SH)\"},\n+                        {RPCResult::Type::OBJ, \"segwit\", /*optional=*/true, \"Result of a witness script public key wrapping this redeem script (not returned if the script is a P2SH or witness)\",\n                         {\n                             {RPCResult::Type::STR, \"asm\", \"String representation of the script public key\"},\n                             {RPCResult::Type::STR_HEX, \"hex\", \"Hex string of the script public key\"},\n                             {RPCResult::Type::STR, \"type\", \"The type of the script public key (e.g. witness_v0_keyhash or witness_v0_scripthash)\"},\n-                            {RPCResult::Type::STR, \"address\", /* optional */ true, \"The Bitcoin address (only if a well-defined address exists)\"},\n+                            {RPCResult::Type::STR, \"address\", /*optional=*/true, \"The Bitcoin address (only if a well-defined address exists)\"},\n                             {RPCResult::Type::STR, \"p2sh-segwit\", \"address of the P2SH script wrapping this witness redeem script\"},\n                         }},\n                     }\n@@ -573,7 +573,7 @@ static RPCHelpMan decodescript()\n     } else {\n         // Empty scripts are valid\n     }\n-    ScriptPubKeyToUniv(script, r, /* include_hex */ false);\n+    ScriptPubKeyToUniv(script, r, /*include_hex=*/false);\n \n     UniValue type;\n     type = find_value(r, \"type\");\n@@ -607,7 +607,7 @@ static RPCHelpMan decodescript()\n                 // Newer segwit program versions should be considered when then become available.\n                 segwitScr = GetScriptForDestination(WitnessV0ScriptHash(script));\n             }\n-            ScriptPubKeyToUniv(segwitScr, sr, /* include_hex */ true);\n+            ScriptPubKeyToUniv(segwitScr, sr, /*include_hex=*/true);\n             sr.pushKV(\"p2sh-segwit\", EncodeDestination(ScriptHash(segwitScr)));\n             r.pushKV(\"segwit\", sr);\n         }\n@@ -748,7 +748,7 @@ static RPCHelpMan signrawtransactionwithkey()\n                     {\n                         {RPCResult::Type::STR_HEX, \"hex\", \"The hex-encoded raw transaction with signature(s)\"},\n                         {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n-                        {RPCResult::Type::ARR, \"errors\", /* optional */ true, \"Script verification errors (if there are any)\",\n+                        {RPCResult::Type::ARR, \"errors\", /*optional=*/true, \"Script verification errors (if there are any)\",\n                         {\n                             {RPCResult::Type::OBJ, \"\", \"\",\n                             {\n@@ -858,7 +858,7 @@ static RPCHelpMan sendrawtransaction()\n     std::string err_string;\n     AssertLockNotHeld(cs_main);\n     NodeContext& node = EnsureAnyNodeContext(request.context);\n-    const TransactionError err = BroadcastTransaction(node, tx, err_string, max_raw_tx_fee, /*relay*/ true, /*wait_callback*/ true);\n+    const TransactionError err = BroadcastTransaction(node, tx, err_string, max_raw_tx_fee, /*relay=*/true, /*wait_callback=*/true);\n     if (TransactionError::OK != err) {\n         throw JSONRPCTransactionError(err, err_string);\n     }\n@@ -895,15 +895,15 @@ static RPCHelpMan testmempoolaccept()\n                         {\n                             {RPCResult::Type::STR_HEX, \"txid\", \"The transaction hash in hex\"},\n                             {RPCResult::Type::STR_HEX, \"wtxid\", \"The transaction witness hash in hex\"},\n-                            {RPCResult::Type::STR, \"package-error\", /* optional */ true, \"Package validation error, if any (only possible if rawtxs had more than 1 transaction).\"},\n-                            {RPCResult::Type::BOOL, \"allowed\", /* optional */ true, \"Whether this tx would be accepted to the mempool and pass client-specified maxfeerate. \"\n+                            {RPCResult::Type::STR, \"package-error\", /*optional=*/true, \"Package validation error, if any (only possible if rawtxs had more than 1 transaction).\"},\n+                            {RPCResult::Type::BOOL, \"allowed\", /*optional=*/true, \"Whether this tx would be accepted to the mempool and pass client-specified maxfeerate. \"\n                                                                \"If not present, the tx was not fully validated due to a failure in another tx in the list.\"},\n-                            {RPCResult::Type::NUM, \"vsize\", /* optional */ true, \"Virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted (only present when 'allowed' is true)\"},\n-                            {RPCResult::Type::OBJ, \"fees\", /* optional */ true, \"Transaction fees (only present if 'allowed' is true)\",\n+                            {RPCResult::Type::NUM, \"vsize\", /*optional=*/true, \"Virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted (only present when 'allowed' is true)\"},\n+                            {RPCResult::Type::OBJ, \"fees\", /*optional=*/true, \"Transaction fees (only present if 'allowed' is true)\",\n                             {\n                                 {RPCResult::Type::STR_AMOUNT, \"base\", \"transaction fee in \" + CURRENCY_UNIT},\n                             }},\n-                            {RPCResult::Type::STR, \"reject-reason\", /* optional */ true, \"Rejection string (only present when 'allowed' is false)\"},\n+                            {RPCResult::Type::STR, \"reject-reason\", /*optional=*/true, \"Rejection string (only present when 'allowed' is false)\"},\n                         }},\n                     }\n                 },\n@@ -950,7 +950,7 @@ static RPCHelpMan testmempoolaccept()\n     CChainState& chainstate = chainman.ActiveChainstate();\n     const PackageMempoolAcceptResult package_result = [&] {\n         LOCK(::cs_main);\n-        if (txns.size() > 1) return ProcessNewPackage(chainstate, mempool, txns, /* test_accept */ true);\n+        if (txns.size() > 1) return ProcessNewPackage(chainstate, mempool, txns, /*test_accept=*/true);\n         return PackageMempoolAcceptResult(txns[0]->GetWitnessHash(),\n                chainman.ProcessTransaction(txns[0], /*test_accept=*/ true));\n     }();\n@@ -1031,39 +1031,39 @@ static RPCHelpMan decodepsbt()\n                         {\n                             {RPCResult::Type::OBJ, \"\", \"\",\n                             {\n-                                {RPCResult::Type::OBJ, \"non_witness_utxo\", /* optional */ true, \"Decoded network transaction for non-witness UTXOs\",\n+                                {RPCResult::Type::OBJ, \"non_witness_utxo\", /*optional=*/true, \"Decoded network transaction for non-witness UTXOs\",\n                                 {\n                                     {RPCResult::Type::ELISION, \"\",\"\"},\n                                 }},\n-                                {RPCResult::Type::OBJ, \"witness_utxo\", /* optional */ true, \"Transaction output for witness UTXOs\",\n+                                {RPCResult::Type::OBJ, \"witness_utxo\", /*optional=*/true, \"Transaction output for witness UTXOs\",\n                                 {\n                                     {RPCResult::Type::NUM, \"amount\", \"The value in \" + CURRENCY_UNIT},\n                                     {RPCResult::Type::OBJ, \"scriptPubKey\", \"\",\n                                     {\n                                         {RPCResult::Type::STR, \"asm\", \"The asm\"},\n                                         {RPCResult::Type::STR_HEX, \"hex\", \"The hex\"},\n                                         {RPCResult::Type::STR, \"type\", \"The type, eg 'pubkeyhash'\"},\n-                                        {RPCResult::Type::STR, \"address\", /* optional */ true, \"The Bitcoin address (only if a well-defined address exists)\"},\n+                                        {RPCResult::Type::STR, \"address\", /*optional=*/true, \"The Bitcoin address (only if a well-defined address exists)\"},\n                                     }},\n                                 }},\n-                                {RPCResult::Type::OBJ_DYN, \"partial_signatures\", /* optional */ true, \"\",\n+                                {RPCResult::Type::OBJ_DYN, \"partial_signatures\", /*optional=*/true, \"\",\n                                 {\n                                     {RPCResult::Type::STR, \"pubkey\", \"The public key and signature that corresponds to it.\"},\n                                 }},\n-                                {RPCResult::Type::STR, \"sighash\", /* optional */ true, \"The sighash type to be used\"},\n-                                {RPCResult::Type::OBJ, \"redeem_script\", /* optional */ true, \"\",\n+                                {RPCResult::Type::STR, \"sighash\", /*optional=*/true, \"The sighash type to be used\"},\n+                                {RPCResult::Type::OBJ, \"redeem_script\", /*optional=*/true, \"\",\n                                 {\n                                     {RPCResult::Type::STR, \"asm\", \"The asm\"},\n                                     {RPCResult::Type::STR_HEX, \"hex\", \"The hex\"},\n                                     {RPCResult::Type::STR, \"type\", \"The type, eg 'pubkeyhash'\"},\n                                 }},\n-                                {RPCResult::Type::OBJ, \"witness_script\", /* optional */ true, \"\",\n+                                {RPCResult::Type::OBJ, \"witness_script\", /*optional=*/true, \"\",\n                                 {\n                                     {RPCResult::Type::STR, \"asm\", \"The asm\"},\n                                     {RPCResult::Type::STR_HEX, \"hex\", \"The hex\"},\n                                     {RPCResult::Type::STR, \"type\", \"The type, eg 'pubkeyhash'\"},\n                                 }},\n-                                {RPCResult::Type::ARR, \"bip32_derivs\", /* optional */ true, \"\",\n+                                {RPCResult::Type::ARR, \"bip32_derivs\", /*optional=*/true, \"\",\n                                 {\n                                     {RPCResult::Type::OBJ, \"\", \"\",\n                                     {\n@@ -1072,16 +1072,16 @@ static RPCHelpMan decodepsbt()\n                                         {RPCResult::Type::STR, \"path\", \"The path\"},\n                                     }},\n                                 }},\n-                                {RPCResult::Type::OBJ, \"final_scriptSig\", /* optional */ true, \"\",\n+                                {RPCResult::Type::OBJ, \"final_scriptSig\", /*optional=*/true, \"\",\n                                 {\n                                     {RPCResult::Type::STR, \"asm\", \"The asm\"},\n                                     {RPCResult::Type::STR, \"hex\", \"The hex\"},\n                                 }},\n-                                {RPCResult::Type::ARR, \"final_scriptwitness\", /* optional */ true, \"\",\n+                                {RPCResult::Type::ARR, \"final_scriptwitness\", /*optional=*/true, \"\",\n                                 {\n                                     {RPCResult::Type::STR_HEX, \"\", \"hex-encoded witness data (if any)\"},\n                                 }},\n-                                {RPCResult::Type::OBJ_DYN, \"unknown\", /* optional */ true, \"The unknown global fields\",\n+                                {RPCResult::Type::OBJ_DYN, \"unknown\", /*optional=*/true, \"The unknown global fields\",\n                                 {\n                                     {RPCResult::Type::STR_HEX, \"key\", \"(key-value pair) An unknown key-value pair\"},\n                                 }},\n@@ -1091,19 +1091,19 @@ static RPCHelpMan decodepsbt()\n                         {\n                             {RPCResult::Type::OBJ, \"\", \"\",\n                             {\n-                                {RPCResult::Type::OBJ, \"redeem_script\", /* optional */ true, \"\",\n+                                {RPCResult::Type::OBJ, \"redeem_script\", /*optional=*/true, \"\",\n                                 {\n                                     {RPCResult::Type::STR, \"asm\", \"The asm\"},\n                                     {RPCResult::Type::STR_HEX, \"hex\", \"The hex\"},\n                                     {RPCResult::Type::STR, \"type\", \"The type, eg 'pubkeyhash'\"},\n                                 }},\n-                                {RPCResult::Type::OBJ, \"witness_script\", /* optional */ true, \"\",\n+                                {RPCResult::Type::OBJ, \"witness_script\", /*optional=*/true, \"\",\n                                 {\n                                     {RPCResult::Type::STR, \"asm\", \"The asm\"},\n                                     {RPCResult::Type::STR_HEX, \"hex\", \"The hex\"},\n                                     {RPCResult::Type::STR, \"type\", \"The type, eg 'pubkeyhash'\"},\n                                 }},\n-                                {RPCResult::Type::ARR, \"bip32_derivs\", /* optional */ true, \"\",\n+                                {RPCResult::Type::ARR, \"bip32_derivs\", /*optional=*/true, \"\",\n                                 {\n                                     {RPCResult::Type::OBJ, \"\", \"\",\n                                     {\n@@ -1112,13 +1112,13 @@ static RPCHelpMan decodepsbt()\n                                         {RPCResult::Type::STR, \"path\", \"The path\"},\n                                     }},\n                                 }},\n-                                {RPCResult::Type::OBJ_DYN, \"unknown\", /* optional */ true, \"The unknown global fields\",\n+                                {RPCResult::Type::OBJ_DYN, \"unknown\", /*optional=*/true, \"The unknown global fields\",\n                                 {\n                                     {RPCResult::Type::STR_HEX, \"key\", \"(key-value pair) An unknown key-value pair\"},\n                                 }},\n                             }},\n                         }},\n-                        {RPCResult::Type::STR_AMOUNT, \"fee\", /* optional */ true, \"The transaction fee paid if all UTXOs slots in the PSBT have been filled.\"},\n+                        {RPCResult::Type::STR_AMOUNT, \"fee\", /*optional=*/true, \"The transaction fee paid if all UTXOs slots in the PSBT have been filled.\"},\n                     }\n                 },\n                 RPCExamples{\n@@ -1163,7 +1163,7 @@ static RPCHelpMan decodepsbt()\n             txout = input.witness_utxo;\n \n             UniValue o(UniValue::VOBJ);\n-            ScriptPubKeyToUniv(txout.scriptPubKey, o, /* include_hex */ true);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, /*include_hex=*/true);\n \n             UniValue out(UniValue::VOBJ);\n             out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n@@ -1386,8 +1386,8 @@ static RPCHelpMan finalizepsbt()\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"\",\n                     {\n-                        {RPCResult::Type::STR, \"psbt\", /* optional */ true, \"The base64-encoded partially signed transaction if not extracted\"},\n-                        {RPCResult::Type::STR_HEX, \"hex\", /* optional */ true, \"The hex-encoded network transaction if extracted\"},\n+                        {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"The base64-encoded partially signed transaction if not extracted\"},\n+                        {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"The hex-encoded network transaction if extracted\"},\n                         {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n                     }\n                 },\n@@ -1779,33 +1779,33 @@ static RPCHelpMan analyzepsbt()\n             RPCResult {\n                 RPCResult::Type::OBJ, \"\", \"\",\n                 {\n-                    {RPCResult::Type::ARR, \"inputs\", /* optional */ true, \"\",\n+                    {RPCResult::Type::ARR, \"inputs\", /*optional=*/true, \"\",\n                     {\n                         {RPCResult::Type::OBJ, \"\", \"\",\n                         {\n                             {RPCResult::Type::BOOL, \"has_utxo\", \"Whether a UTXO is provided\"},\n                             {RPCResult::Type::BOOL, \"is_final\", \"Whether the input is finalized\"},\n-                            {RPCResult::Type::OBJ, \"missing\", /* optional */ true, \"Things that are missing that are required to complete this input\",\n+                            {RPCResult::Type::OBJ, \"missing\", /*optional=*/true, \"Things that are missing that are required to complete this input\",\n                             {\n-                                {RPCResult::Type::ARR, \"pubkeys\", /* optional */ true, \"\",\n+                                {RPCResult::Type::ARR, \"pubkeys\", /*optional=*/true, \"\",\n                                 {\n                                     {RPCResult::Type::STR_HEX, \"keyid\", \"Public key ID, hash160 of the public key, of a public key whose BIP 32 derivation path is missing\"},\n                                 }},\n-                                {RPCResult::Type::ARR, \"signatures\", /* optional */ true, \"\",\n+                                {RPCResult::Type::ARR, \"signatures\", /*optional=*/true, \"\",\n                                 {\n                                     {RPCResult::Type::STR_HEX, \"keyid\", \"Public key ID, hash160 of the public key, of a public key whose signature is missing\"},\n                                 }},\n-                                {RPCResult::Type::STR_HEX, \"redeemscript\", /* optional */ true, \"Hash160 of the redeemScript that is missing\"},\n-                                {RPCResult::Type::STR_HEX, \"witnessscript\", /* optional */ true, \"SHA256 of the witnessScript that is missing\"},\n+                                {RPCResult::Type::STR_HEX, \"redeemscript\", /*optional=*/true, \"Hash160 of the redeemScript that is missing\"},\n+                                {RPCResult::Type::STR_HEX, \"witnessscript\", /*optional=*/true, \"SHA256 of the witnessScript that is missing\"},\n                             }},\n-                            {RPCResult::Type::STR, \"next\", /* optional */ true, \"Role of the next person that this input needs to go to\"},\n+                            {RPCResult::Type::STR, \"next\", /*optional=*/true, \"Role of the next person that this input needs to go to\"},\n                         }},\n                     }},\n-                    {RPCResult::Type::NUM, \"estimated_vsize\", /* optional */ true, \"Estimated vsize of the final signed transaction\"},\n-                    {RPCResult::Type::STR_AMOUNT, \"estimated_feerate\", /* optional */ true, \"Estimated feerate of the final signed transaction in \" + CURRENCY_UNIT + \"/kvB. Shown only if all UTXO slots in the PSBT have been filled\"},\n-                    {RPCResult::Type::STR_AMOUNT, \"fee\", /* optional */ true, \"The transaction fee paid. Shown only if all UTXO slots in the PSBT have been filled\"},\n+                    {RPCResult::Type::NUM, \"estimated_vsize\", /*optional=*/true, \"Estimated vsize of the final signed transaction\"},\n+                    {RPCResult::Type::STR_AMOUNT, \"estimated_feerate\", /*optional=*/true, \"Estimated feerate of the final signed transaction in \" + CURRENCY_UNIT + \"/kvB. Shown only if all UTXO slots in the PSBT have been filled\"},\n+                    {RPCResult::Type::STR_AMOUNT, \"fee\", /*optional=*/true, \"The transaction fee paid. Shown only if all UTXO slots in the PSBT have been filled\"},\n                     {RPCResult::Type::STR, \"next\", \"Role of the next person that this psbt needs to go to\"},\n-                    {RPCResult::Type::STR, \"error\", /* optional */ true, \"Error message (if there is one)\"},\n+                    {RPCResult::Type::STR, \"error\", /*optional=*/true, \"Error message (if there is one)\"},\n                 }\n             },\n             RPCExamples {"
      },
      {
        "sha": "9b29f904eb7193a386d7c44826c1dc05f4ccdd47",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -167,7 +167,7 @@ static RPCHelpMan stop()\n     // to the client (intended for testing)\n                 \"\\nRequest a graceful shutdown of \" PACKAGE_NAME \".\",\n                 {\n-                    {\"wait\", RPCArg::Type::NUM, RPCArg::Optional::OMITTED_NAMED_ARG, \"how long to wait in ms\", \"\", {}, /* hidden */ true},\n+                    {\"wait\", RPCArg::Type::NUM, RPCArg::Optional::OMITTED_NAMED_ARG, \"how long to wait in ms\", \"\", {}, /*hidden=*/true},\n                 },\n                 RPCResult{RPCResult::Type::STR, \"\", \"A string with the content '\" + RESULT + \"'\"},\n                 RPCExamples{\"\"},"
      },
      {
        "sha": "ec06671c59a41fff41b39c44943c3ea906da55eb",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -2006,7 +2006,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n                 // The scriptSig must be _exactly_ CScript(), otherwise we reintroduce malleability.\n                 return set_error(serror, SCRIPT_ERR_WITNESS_MALLEATED);\n             }\n-            if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror, /* is_p2sh */ false)) {\n+            if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror, /*is_p2sh=*/false)) {\n                 return false;\n             }\n             // Bypass the cleanstack check at the end. The actual stack is obviously not clean\n@@ -2051,7 +2051,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n                     // reintroduce malleability.\n                     return set_error(serror, SCRIPT_ERR_WITNESS_MALLEATED_P2SH);\n                 }\n-                if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror, /* is_p2sh */ true)) {\n+                if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror, /*is_p2sh=*/true)) {\n                     return false;\n                 }\n                 // Bypass the cleanstack check at the end. The actual stack is obviously not clean"
      },
      {
        "sha": "fefbb179358b3f22f7edfab8a77c3734023e1e6b",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -631,7 +631,7 @@ bool SignTransaction(CMutableTransaction& mtx, const SigningProvider* keystore,\n         CTxIn& txin = mtx.vin[i];\n         auto coin = coins.find(txin.prevout);\n         if (coin == coins.end() || coin->second.IsSpent()) {\n-            txdata.Init(txConst, /* spent_outputs */ {}, /* force */ true);\n+            txdata.Init(txConst, /*spent_outputs=*/{}, /*force=*/true);\n             break;\n         } else {\n             spent_outputs.emplace_back(coin->second.out.nValue, coin->second.out.scriptPubKey);"
      },
      {
        "sha": "31f30d0379475930b9869cfea02c1ceaf97cacf5",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -26,7 +26,7 @@ class AddrManTest : public AddrMan\n {\n public:\n     explicit AddrManTest(std::vector<bool> asmap = std::vector<bool>())\n-        : AddrMan(asmap, /*deterministic=*/true, /* consistency_check_ratio */ 100)\n+        : AddrMan(asmap, /*deterministic=*/true, /*consistency_check_ratio=*/100)\n     {}\n \n     AddrInfo* Find(const CService& addr)\n@@ -376,7 +376,7 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     // Test: Sanity check, GetAddr should never return anything if addrman\n     //  is empty.\n     BOOST_CHECK_EQUAL(addrman.size(), 0U);\n-    std::vector<CAddress> vAddr1 = addrman.GetAddr(/* max_addresses */ 0, /* max_pct */ 0, /* network */ std::nullopt);\n+    std::vector<CAddress> vAddr1 = addrman.GetAddr(/*max_addresses=*/0, /*max_pct=*/0, /*network=*/std::nullopt);\n     BOOST_CHECK_EQUAL(vAddr1.size(), 0U);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.250.2.1\", 8333), NODE_NONE);\n@@ -396,15 +396,15 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     BOOST_CHECK(addrman.Add({addr1, addr3, addr5}, source1));\n     BOOST_CHECK(addrman.Add({addr2, addr4}, source2));\n \n-    BOOST_CHECK_EQUAL(addrman.GetAddr(/* max_addresses */ 0, /* max_pct */ 0, /* network */ std::nullopt).size(), 5U);\n+    BOOST_CHECK_EQUAL(addrman.GetAddr(/*max_addresses=*/0, /*max_pct=*/0, /*network=*/std::nullopt).size(), 5U);\n     // Net processing asks for 23% of addresses. 23% of 5 is 1 rounded down.\n-    BOOST_CHECK_EQUAL(addrman.GetAddr(/* max_addresses */ 2500, /* max_pct */ 23, /* network */ std::nullopt).size(), 1U);\n+    BOOST_CHECK_EQUAL(addrman.GetAddr(/*max_addresses=*/2500, /*max_pct=*/23, /*network=*/std::nullopt).size(), 1U);\n \n     // Test: Ensure GetAddr works with new and tried addresses.\n     addrman.Good(CAddress(addr1, NODE_NONE));\n     addrman.Good(CAddress(addr2, NODE_NONE));\n-    BOOST_CHECK_EQUAL(addrman.GetAddr(/* max_addresses */ 0, /* max_pct */ 0, /* network */ std::nullopt).size(), 5U);\n-    BOOST_CHECK_EQUAL(addrman.GetAddr(/* max_addresses */ 2500, /* max_pct */ 23, /* network */ std::nullopt).size(), 1U);\n+    BOOST_CHECK_EQUAL(addrman.GetAddr(/*max_addresses=*/0, /*max_pct=*/0, /*network=*/std::nullopt).size(), 5U);\n+    BOOST_CHECK_EQUAL(addrman.GetAddr(/*max_addresses=*/2500, /*max_pct=*/23, /*network=*/std::nullopt).size(), 1U);\n \n     // Test: Ensure GetAddr still returns 23% when addrman has many addrs.\n     for (unsigned int i = 1; i < (8 * 256); i++) {\n@@ -419,7 +419,7 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n         if (i % 8 == 0)\n             addrman.Good(addr);\n     }\n-    std::vector<CAddress> vAddr = addrman.GetAddr(/* max_addresses */ 2500, /* max_pct */ 23, /* network */ std::nullopt);\n+    std::vector<CAddress> vAddr = addrman.GetAddr(/*max_addresses=*/2500, /*max_pct=*/23, /*network=*/std::nullopt);\n \n     size_t percent23 = (addrman.size() * 23) / 100;\n     BOOST_CHECK_EQUAL(vAddr.size(), percent23);\n@@ -973,7 +973,7 @@ BOOST_AUTO_TEST_CASE(load_addrman)\n     // Test that the de-serialization does not throw an exception.\n     CDataStream ssPeers1 = AddrmanToStream(addrman);\n     bool exceptionThrown = false;\n-    AddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman1(/*asmap=*/std::vector<bool>(), /*deterministic=*/false, /*consistency_check_ratio=*/100);\n \n     BOOST_CHECK(addrman1.size() == 0);\n     try {\n@@ -990,7 +990,7 @@ BOOST_AUTO_TEST_CASE(load_addrman)\n     // Test that ReadFromStream creates an addrman with the correct number of addrs.\n     CDataStream ssPeers2 = AddrmanToStream(addrman);\n \n-    AddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman2(/*asmap=*/std::vector<bool>(), /*deterministic=*/false, /*consistency_check_ratio=*/100);\n     BOOST_CHECK(addrman2.size() == 0);\n     ReadFromStream(addrman2, ssPeers2);\n     BOOST_CHECK(addrman2.size() == 3);\n@@ -1028,7 +1028,7 @@ BOOST_AUTO_TEST_CASE(load_addrman_corrupted)\n     // Test that the de-serialization of corrupted peers.dat throws an exception.\n     CDataStream ssPeers1 = MakeCorruptPeersDat();\n     bool exceptionThrown = false;\n-    AddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman1(/*asmap=*/std::vector<bool>(), /*deterministic=*/false, /*consistency_check_ratio=*/100);\n     BOOST_CHECK(addrman1.size() == 0);\n     try {\n         unsigned char pchMsgTmp[4];\n@@ -1044,7 +1044,7 @@ BOOST_AUTO_TEST_CASE(load_addrman_corrupted)\n     // Test that ReadFromStream fails if peers.dat is corrupt\n     CDataStream ssPeers2 = MakeCorruptPeersDat();\n \n-    AddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman2(/*asmap=*/std::vector<bool>(), /*deterministic=*/false, /*consistency_check_ratio=*/100);\n     BOOST_CHECK(addrman2.size() == 0);\n     BOOST_CHECK_THROW(ReadFromStream(addrman2, ssPeers2), std::ios_base::failure);\n }"
      },
      {
        "sha": "91218511bdde03014f031153d779f4ed35517dae",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -269,7 +269,7 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n     CCoinsViewTest base;\n     SimulationTest(&base, false);\n \n-    CCoinsViewDB db_base{\"test\", /*nCacheSize*/ 1 << 23, /*fMemory*/ true, /*fWipe*/ false};\n+    CCoinsViewDB db_base{\"test\", /*nCacheSize=*/1 << 23, /*fMemory=*/true, /*fWipe=*/false};\n     SimulationTest(&db_base, true);\n }\n "
      },
      {
        "sha": "f0fc42eb9f347ab7859a6dbb2a36767fa203c50e",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -219,7 +219,7 @@ BOOST_AUTO_TEST_CASE(peer_discouragement)\n     peerLogic->InitializeNode(nodes[0]);\n     nodes[0]->fSuccessfullyConnected = true;\n     connman->AddTestNode(*nodes[0]);\n-    peerLogic->Misbehaving(nodes[0]->GetId(), DISCOURAGEMENT_THRESHOLD, /* message */ \"\"); // Should be discouraged\n+    peerLogic->Misbehaving(nodes[0]->GetId(), DISCOURAGEMENT_THRESHOLD, /*message=*/\"\"); // Should be discouraged\n     {\n         LOCK(nodes[0]->cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(nodes[0]));\n@@ -235,7 +235,7 @@ BOOST_AUTO_TEST_CASE(peer_discouragement)\n     peerLogic->InitializeNode(nodes[1]);\n     nodes[1]->fSuccessfullyConnected = true;\n     connman->AddTestNode(*nodes[1]);\n-    peerLogic->Misbehaving(nodes[1]->GetId(), DISCOURAGEMENT_THRESHOLD - 1, /* message */ \"\");\n+    peerLogic->Misbehaving(nodes[1]->GetId(), DISCOURAGEMENT_THRESHOLD - 1, /*message=*/\"\");\n     {\n         LOCK(nodes[1]->cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(nodes[1]));\n@@ -246,7 +246,7 @@ BOOST_AUTO_TEST_CASE(peer_discouragement)\n     // [1] is not discouraged/disconnected yet.\n     BOOST_CHECK(!banman->IsDiscouraged(addr[1]));\n     BOOST_CHECK(!nodes[1]->fDisconnect);\n-    peerLogic->Misbehaving(nodes[1]->GetId(), 1, /* message */ \"\"); // [1] reaches discouragement threshold\n+    peerLogic->Misbehaving(nodes[1]->GetId(), 1, /*message=*/\"\"); // [1] reaches discouragement threshold\n     {\n         LOCK(nodes[1]->cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(nodes[1]));\n@@ -266,7 +266,7 @@ BOOST_AUTO_TEST_CASE(peer_discouragement)\n     peerLogic->InitializeNode(nodes[2]);\n     nodes[2]->fSuccessfullyConnected = true;\n     connman->AddTestNode(*nodes[2]);\n-    peerLogic->Misbehaving(nodes[2]->GetId(), DISCOURAGEMENT_THRESHOLD, /* message */ \"\");\n+    peerLogic->Misbehaving(nodes[2]->GetId(), DISCOURAGEMENT_THRESHOLD, /*message=*/\"\");\n     {\n         LOCK(nodes[2]->cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(nodes[2]));\n@@ -302,7 +302,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     peerLogic->InitializeNode(&dummyNode);\n     dummyNode.fSuccessfullyConnected = true;\n \n-    peerLogic->Misbehaving(dummyNode.GetId(), DISCOURAGEMENT_THRESHOLD, /* message */ \"\");\n+    peerLogic->Misbehaving(dummyNode.GetId(), DISCOURAGEMENT_THRESHOLD, /*message=*/\"\");\n     {\n         LOCK(dummyNode.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode));\n@@ -334,7 +334,7 @@ static void MakeNewKeyWithFastRandomContext(CKey& key)\n {\n     std::vector<unsigned char> keydata;\n     keydata = g_insecure_rand_ctx.randbytes(32);\n-    key.Set(keydata.data(), keydata.data() + keydata.size(), /*fCompressedIn*/ true);\n+    key.Set(keydata.data(), keydata.data() + keydata.size(), /*fCompressedIn=*/true);\n     assert(key.IsValid());\n }\n "
      },
      {
        "sha": "e54e453ab231b688bbf5cf21f22442971aa92531",
        "filename": "src/test/fuzz/addrman.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/addrman.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -29,7 +29,7 @@ FUZZ_TARGET_INIT(data_stream_addr_man, initialize_addrman)\n {\n     FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n     CDataStream data_stream = ConsumeDataStream(fuzzed_data_provider);\n-    AddrMan addr_man(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addr_man(/*asmap=*/std::vector<bool>(), /*deterministic=*/false, /*consistency_check_ratio=*/0);\n     try {\n         ReadFromStream(addr_man, data_stream);\n     } catch (const std::exception&) {\n@@ -113,7 +113,7 @@ class AddrManDeterministic : public AddrMan\n {\n public:\n     explicit AddrManDeterministic(std::vector<bool> asmap, FuzzedDataProvider& fuzzed_data_provider)\n-        : AddrMan(std::move(asmap), /* deterministic */ true, /* consistency_check_ratio */ 0)\n+        : AddrMan(std::move(asmap), /*deterministic=*/true, /*consistency_check_ratio=*/0)\n     {\n         WITH_LOCK(m_impl->cs, m_impl->insecure_rand = FastRandomContext{ConsumeUInt256(fuzzed_data_provider)});\n     }"
      },
      {
        "sha": "b2969ecdc00384ea4c38c36d5cc954a7f9359043",
        "filename": "src/test/fuzz/banman.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/banman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/banman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/banman.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -58,7 +58,7 @@ FUZZ_TARGET_INIT(banman, initialize_banman)\n     }\n \n     {\n-        BanMan ban_man{banlist_file, /* client_interface */ nullptr, /* default_ban_time */ ConsumeBanTimeOffset(fuzzed_data_provider)};\n+        BanMan ban_man{banlist_file, /*client_interface=*/nullptr, /*default_ban_time=*/ConsumeBanTimeOffset(fuzzed_data_provider)};\n         // The complexity is O(N^2), where N is the input size, because each call\n         // might call DumpBanlist (or other methods that are at least linear\n         // complexity of the input size).\n@@ -105,7 +105,7 @@ FUZZ_TARGET_INIT(banman, initialize_banman)\n             SetMockTime(ConsumeTime(fuzzed_data_provider));\n             banmap_t banmap;\n             ban_man.GetBanned(banmap);\n-            BanMan ban_man_read{banlist_file, /* client_interface */ nullptr, /* default_ban_time */ 0};\n+            BanMan ban_man_read{banlist_file, /*client_interface=*/nullptr, /*default_ban_time=*/0};\n             banmap_t banmap_read;\n             ban_man_read.GetBanned(banmap_read);\n             assert(banmap == banmap_read);"
      },
      {
        "sha": "15f3dc82f1cbf07132506df46d683afe6ad9696d",
        "filename": "src/test/fuzz/connman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/connman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/connman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/connman.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -25,7 +25,7 @@ FUZZ_TARGET_INIT(connman, initialize_connman)\n {\n     FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n-    AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addrman(/*asmap=*/std::vector<bool>(), /*deterministic=*/false, /*consistency_check_ratio=*/0);\n     CConnman connman{fuzzed_data_provider.ConsumeIntegral<uint64_t>(), fuzzed_data_provider.ConsumeIntegral<uint64_t>(), addrman, fuzzed_data_provider.ConsumeBool()};\n     CNetAddr random_netaddr;\n     CNode random_node = ConsumeNode(fuzzed_data_provider);"
      },
      {
        "sha": "48574d71cca42ea5be89c2d1532d4ce2ed5e34c0",
        "filename": "src/test/fuzz/deserialize.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/deserialize.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/deserialize.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/deserialize.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -189,7 +189,7 @@ FUZZ_TARGET_DESERIALIZE(blockmerkleroot, {\n     BlockMerkleRoot(block, &mutated);\n })\n FUZZ_TARGET_DESERIALIZE(addrman_deserialize, {\n-    AddrMan am(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan am(/*asmap=*/std::vector<bool>(), /*deterministic=*/false, /*consistency_check_ratio=*/0);\n     DeserializeFromFuzzingInput(buffer, am);\n })\n FUZZ_TARGET_DESERIALIZE(blockheader_deserialize, {"
      },
      {
        "sha": "e4d95f72a074133d70fe1f32d34ab1b01fbce349",
        "filename": "src/test/fuzz/policy_estimator.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/policy_estimator.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/policy_estimator.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/policy_estimator.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -35,7 +35,7 @@ FUZZ_TARGET_INIT(policy_estimator, initialize_policy_estimator)\n                 const CTransaction tx{*mtx};\n                 block_policy_estimator.processTransaction(ConsumeTxMemPoolEntry(fuzzed_data_provider, tx), fuzzed_data_provider.ConsumeBool());\n                 if (fuzzed_data_provider.ConsumeBool()) {\n-                    (void)block_policy_estimator.removeTx(tx.GetHash(), /* inBlock */ fuzzed_data_provider.ConsumeBool());\n+                    (void)block_policy_estimator.removeTx(tx.GetHash(), /*inBlock=*/fuzzed_data_provider.ConsumeBool());\n                 }\n             },\n             [&] {\n@@ -56,7 +56,7 @@ FUZZ_TARGET_INIT(policy_estimator, initialize_policy_estimator)\n                 block_policy_estimator.processBlock(fuzzed_data_provider.ConsumeIntegral<unsigned int>(), ptrs);\n             },\n             [&] {\n-                (void)block_policy_estimator.removeTx(ConsumeUInt256(fuzzed_data_provider), /* inBlock */ fuzzed_data_provider.ConsumeBool());\n+                (void)block_policy_estimator.removeTx(ConsumeUInt256(fuzzed_data_provider), /*inBlock=*/fuzzed_data_provider.ConsumeBool());\n             },\n             [&] {\n                 block_policy_estimator.FlushUnconfirmed();"
      },
      {
        "sha": "94a71859e9d8cb04fcdf992d6591a76f3e83b687",
        "filename": "src/test/fuzz/process_message.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/process_message.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/process_message.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/process_message.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -83,7 +83,7 @@ void fuzz_target(FuzzBufferType buffer, const std::string& LIMIT_TO_MESSAGE_TYPE\n     p2p_node.fSuccessfullyConnected = successfully_connected;\n     connman.AddTestNode(p2p_node);\n     g_setup->m_node.peerman->InitializeNode(&p2p_node);\n-    FillNode(fuzzed_data_provider, p2p_node, /* init_version */ successfully_connected);\n+    FillNode(fuzzed_data_provider, p2p_node, /*init_version=*/successfully_connected);\n \n     const auto mock_time = ConsumeTime(fuzzed_data_provider);\n     SetMockTime(mock_time);"
      },
      {
        "sha": "21a959315e804e5ebb3091514ce2d1d0e97fa326",
        "filename": "src/test/fuzz/process_messages.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/process_messages.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/process_messages.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/process_messages.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -50,7 +50,7 @@ FUZZ_TARGET_INIT(process_messages, initialize_process_messages)\n         p2p_node.fSuccessfullyConnected = successfully_connected;\n         p2p_node.fPauseSend = false;\n         g_setup->m_node.peerman->InitializeNode(&p2p_node);\n-        FillNode(fuzzed_data_provider, p2p_node, /* init_version */ successfully_connected);\n+        FillNode(fuzzed_data_provider, p2p_node, /*init_version=*/successfully_connected);\n \n         connman.AddTestNode(p2p_node);\n     }"
      },
      {
        "sha": "4669f783aa00b6005964d766208d19cdef4a350f",
        "filename": "src/test/fuzz/script_assets_test_minimizer.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/script_assets_test_minimizer.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/script_assets_test_minimizer.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/script_assets_test_minimizer.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -190,7 +190,7 @@ void test_init()\n     static ECCVerifyHandle handle;\n }\n \n-FUZZ_TARGET_INIT_HIDDEN(script_assets_test_minimizer, test_init, /* hidden */ true)\n+FUZZ_TARGET_INIT_HIDDEN(script_assets_test_minimizer, test_init, /*hidden=*/true)\n {\n     if (buffer.size() < 2 || buffer.back() != '\\n' || buffer[buffer.size() - 2] != ',') return;\n     const std::string str((const char*)buffer.data(), buffer.size() - 2);"
      },
      {
        "sha": "8b6ca42a6e556dc6ab584b7d9625f71a14e3b819",
        "filename": "src/test/fuzz/transaction.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/transaction.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -103,6 +103,6 @@ FUZZ_TARGET_INIT(transaction, initialize_transaction)\n     (void)IsWitnessStandard(tx, coins_view_cache);\n \n     UniValue u(UniValue::VOBJ);\n-    TxToUniv(tx, /* hashBlock */ uint256::ZERO, u);\n-    TxToUniv(tx, /* hashBlock */ uint256::ONE, u);\n+    TxToUniv(tx, /*hashBlock=*/uint256::ZERO, u);\n+    TxToUniv(tx, /*hashBlock=*/uint256::ONE, u);\n }"
      },
      {
        "sha": "bf66fcef413dabf0f41ce954165e899b33dfd1fd",
        "filename": "src/test/fuzz/tx_pool.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/tx_pool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/tx_pool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/tx_pool.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -85,7 +85,7 @@ void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, CCh\n     {\n         BlockAssembler::Options options;\n         options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n-        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /* max */ COIN)};\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n         auto assembler = BlockAssembler{chainstate, *static_cast<CTxMemPool*>(&tx_pool), ::Params(), options};\n         auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n         Assert(block_template->block.vtx.size() >= 1);\n@@ -131,7 +131,7 @@ FUZZ_TARGET_INIT(tx_pool_standard, initialize_tx_pool)\n     // The sum of the values of all spendable outpoints\n     constexpr CAmount SUPPLY_TOTAL{COINBASE_MATURITY * 50 * COIN};\n \n-    CTxMemPool tx_pool_{/* estimator */ nullptr, /* check_ratio */ 1};\n+    CTxMemPool tx_pool_{/*estimator=*/nullptr, /*check_ratio=*/1};\n     MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n \n     // Helper to query an amount\n@@ -267,10 +267,10 @@ FUZZ_TARGET_INIT(tx_pool_standard, initialize_tx_pool)\n             // Outpoints that no longer count toward the total supply\n             std::set<COutPoint> consumed_supply;\n             for (const auto& removed_tx : removed) {\n-                insert_tx(/* created_by_tx */ {consumed_erased}, /* consumed_by_tx */ {outpoints_supply}, /* tx */ *removed_tx);\n+                insert_tx(/*created_by_tx=*/{consumed_erased}, /*consumed_by_tx=*/{outpoints_supply}, /*tx=*/*removed_tx);\n             }\n             for (const auto& added_tx : added) {\n-                insert_tx(/* created_by_tx */ {outpoints_supply, outpoints_rbf}, /* consumed_by_tx */ {consumed_supply}, /* tx */ *added_tx);\n+                insert_tx(/*created_by_tx=*/{outpoints_supply, outpoints_rbf}, /*consumed_by_tx=*/{consumed_supply}, /*tx=*/*added_tx);\n             }\n             for (const auto& p : consumed_erased) {\n                 Assert(outpoints_supply.erase(p) == 1);\n@@ -303,7 +303,7 @@ FUZZ_TARGET_INIT(tx_pool, initialize_tx_pool)\n         txids.push_back(ConsumeUInt256(fuzzed_data_provider));\n     }\n \n-    CTxMemPool tx_pool_{/* estimator */ nullptr, /* check_ratio */ 1};\n+    CTxMemPool tx_pool_{/*estimator=*/nullptr, /*check_ratio=*/1};\n     MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n \n     LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)"
      },
      {
        "sha": "02039cba81a75eddc38d33e9e5dde7abfec054e8",
        "filename": "src/test/fuzz/utxo_snapshot.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/utxo_snapshot.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/fuzz/utxo_snapshot.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/utxo_snapshot.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -49,7 +49,7 @@ FUZZ_TARGET_INIT(utxo_snapshot, initialize_chain)\n         } catch (const std::ios_base::failure&) {\n             return false;\n         }\n-        return chainman.ActivateSnapshot(infile, metadata, /* in_memory */ true);\n+        return chainman.ActivateSnapshot(infile, metadata, /*in_memory=*/true);\n     }};\n \n     if (fuzzed_data_provider.ConsumeBool()) {"
      },
      {
        "sha": "005752d508fc205d7b536271c563ce2965904e5a",
        "filename": "src/test/mempool_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -602,7 +602,7 @@ BOOST_AUTO_TEST_CASE(MempoolAncestryTests)\n     //\n     // [tx1]\n     //\n-    CTransactionRef tx1 = make_tx(/* output_values */ {10 * COIN});\n+    CTransactionRef tx1 = make_tx(/*output_values=*/{10 * COIN});\n     pool.addUnchecked(entry.Fee(10000LL).FromTx(tx1));\n \n     // Ancestors / descendants should be 1 / 1 (itself / itself)\n@@ -614,7 +614,7 @@ BOOST_AUTO_TEST_CASE(MempoolAncestryTests)\n     //\n     // [tx1].0 <- [tx2]\n     //\n-    CTransactionRef tx2 = make_tx(/* output_values */ {495 * CENT, 5 * COIN}, /* inputs */ {tx1});\n+    CTransactionRef tx2 = make_tx(/*output_values=*/{495 * CENT, 5 * COIN}, /*inputs=*/{tx1});\n     pool.addUnchecked(entry.Fee(10000LL).FromTx(tx2));\n \n     // Ancestors / descendants should be:\n@@ -633,7 +633,7 @@ BOOST_AUTO_TEST_CASE(MempoolAncestryTests)\n     //\n     // [tx1].0 <- [tx2].0 <- [tx3]\n     //\n-    CTransactionRef tx3 = make_tx(/* output_values */ {290 * CENT, 200 * CENT}, /* inputs */ {tx2});\n+    CTransactionRef tx3 = make_tx(/*output_values=*/{290 * CENT, 200 * CENT}, /*inputs=*/{tx2});\n     pool.addUnchecked(entry.Fee(10000LL).FromTx(tx3));\n \n     // Ancestors / descendants should be:\n@@ -658,7 +658,7 @@ BOOST_AUTO_TEST_CASE(MempoolAncestryTests)\n     //              |\n     //              \\---1 <- [tx4]\n     //\n-    CTransactionRef tx4 = make_tx(/* output_values */ {290 * CENT, 250 * CENT}, /* inputs */ {tx2}, /* input_indices */ {1});\n+    CTransactionRef tx4 = make_tx(/*output_values=*/{290 * CENT, 250 * CENT}, /*inputs=*/{tx2}, /*input_indices=*/{1});\n     pool.addUnchecked(entry.Fee(10000LL).FromTx(tx4));\n \n     // Ancestors / descendants should be:\n@@ -694,14 +694,14 @@ BOOST_AUTO_TEST_CASE(MempoolAncestryTests)\n     CAmount v = 5 * COIN;\n     for (uint64_t i = 0; i < 5; i++) {\n         CTransactionRef& tyi = *ty[i];\n-        tyi = make_tx(/* output_values */ {v}, /* inputs */ i > 0 ? std::vector<CTransactionRef>{*ty[i - 1]} : std::vector<CTransactionRef>{});\n+        tyi = make_tx(/*output_values=*/{v}, /*inputs=*/i > 0 ? std::vector<CTransactionRef>{*ty[i - 1]} : std::vector<CTransactionRef>{});\n         v -= 50 * CENT;\n         pool.addUnchecked(entry.Fee(10000LL).FromTx(tyi));\n         pool.GetTransactionAncestry(tyi->GetHash(), ancestors, descendants);\n         BOOST_CHECK_EQUAL(ancestors, i+1);\n         BOOST_CHECK_EQUAL(descendants, i+1);\n     }\n-    CTransactionRef ty6 = make_tx(/* output_values */ {5 * COIN}, /* inputs */ {tx3, ty5});\n+    CTransactionRef ty6 = make_tx(/*output_values=*/{5 * COIN}, /*inputs=*/{tx3, ty5});\n     pool.addUnchecked(entry.Fee(10000LL).FromTx(ty6));\n \n     // Ancestors / descendants should be:\n@@ -755,10 +755,10 @@ BOOST_AUTO_TEST_CASE(MempoolAncestryTests)\n     //            \\---1 <- [tc].0 --<--/\n     //\n     CTransactionRef ta, tb, tc, td;\n-    ta = make_tx(/* output_values */ {10 * COIN});\n-    tb = make_tx(/* output_values */ {5 * COIN, 3 * COIN}, /* inputs */  {ta});\n-    tc = make_tx(/* output_values */ {2 * COIN}, /* inputs */ {tb}, /* input_indices */ {1});\n-    td = make_tx(/* output_values */ {6 * COIN}, /* inputs */ {tb, tc}, /* input_indices */ {0, 0});\n+    ta = make_tx(/*output_values=*/{10 * COIN});\n+    tb = make_tx(/*output_values=*/{5 * COIN, 3 * COIN}, /*inputs=*/ {ta});\n+    tc = make_tx(/*output_values=*/{2 * COIN}, /*inputs=*/{tb}, /*input_indices=*/{1});\n+    td = make_tx(/*output_values=*/{6 * COIN}, /*inputs=*/{tb, tc}, /*input_indices=*/{0, 0});\n     pool.clear();\n     pool.addUnchecked(entry.Fee(10000LL).FromTx(ta));\n     pool.addUnchecked(entry.Fee(10000LL).FromTx(tb));"
      },
      {
        "sha": "c5bd9c73fdc88b4955fffb6a34200553df6527a1",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -607,7 +607,7 @@ BOOST_AUTO_TEST_CASE(ipv4_peer_with_ipv6_addrMe_test)\n     in_addr ipv4AddrPeer;\n     ipv4AddrPeer.s_addr = 0xa0b0c001;\n     CAddress addr = CAddress(CService(ipv4AddrPeer, 7777), NODE_NETWORK);\n-    std::unique_ptr<CNode> pnode = std::make_unique<CNode>(0, NODE_NETWORK, INVALID_SOCKET, addr, /* nKeyedNetGroupIn */ 0, /* nLocalHostNonceIn */ 0, CAddress{}, /* pszDest */ std::string{}, ConnectionType::OUTBOUND_FULL_RELAY, /* inbound_onion */ false);\n+    std::unique_ptr<CNode> pnode = std::make_unique<CNode>(0, NODE_NETWORK, INVALID_SOCKET, addr, /*nKeyedNetGroupIn=*/0, /*nLocalHostNonceIn=*/0, CAddress{}, /*pszDest=*/std::string{}, ConnectionType::OUTBOUND_FULL_RELAY, /*inbound_onion=*/false);\n     pnode->fSuccessfullyConnected.store(true);\n \n     // the peer claims to be reaching us via IPv6"
      },
      {
        "sha": "db4122ac022d4b2a95569494f677149b0cd891e7",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -249,26 +249,26 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n                 BOOST_ERROR(\"Bad test flags: \" << strTest);\n             }\n \n-            BOOST_CHECK_MESSAGE(CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, ~verify_flags, txdata, strTest, /* expect_valid */ true),\n+            BOOST_CHECK_MESSAGE(CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, ~verify_flags, txdata, strTest, /*expect_valid=*/true),\n                                 \"Tx unexpectedly failed: \" << strTest);\n \n             // Backwards compatibility of script verification flags: Removing any flag(s) should not invalidate a valid transaction\n             for (const auto& [name, flag] : mapFlagNames) {\n                 // Removing individual flags\n                 unsigned int flags = TrimFlags(~(verify_flags | flag));\n-                if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, flags, txdata, strTest, /* expect_valid */ true)) {\n+                if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, flags, txdata, strTest, /*expect_valid=*/true)) {\n                     BOOST_ERROR(\"Tx unexpectedly failed with flag \" << name << \" unset: \" << strTest);\n                 }\n                 // Removing random combinations of flags\n                 flags = TrimFlags(~(verify_flags | (unsigned int)InsecureRandBits(mapFlagNames.size())));\n-                if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, flags, txdata, strTest, /* expect_valid */ true)) {\n+                if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, flags, txdata, strTest, /*expect_valid=*/true)) {\n                     BOOST_ERROR(\"Tx unexpectedly failed with random flags \" << ToString(flags) << \": \" << strTest);\n                 }\n             }\n \n             // Check that flags are maximal: transaction should fail if any unset flags are set.\n             for (auto flags_excluding_one : ExcludeIndividualFlags(verify_flags)) {\n-                if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, ~flags_excluding_one, txdata, strTest, /* expect_valid */ false)) {\n+                if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, ~flags_excluding_one, txdata, strTest, /*expect_valid=*/false)) {\n                     BOOST_ERROR(\"Too many flags unset: \" << strTest);\n                 }\n             }\n@@ -340,26 +340,26 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n             }\n \n             // Not using FillFlags() in the main test, in order to detect invalid verifyFlags combination\n-            BOOST_CHECK_MESSAGE(CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, verify_flags, txdata, strTest, /* expect_valid */ false),\n+            BOOST_CHECK_MESSAGE(CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, verify_flags, txdata, strTest, /*expect_valid=*/false),\n                                 \"Tx unexpectedly passed: \" << strTest);\n \n             // Backwards compatibility of script verification flags: Adding any flag(s) should not validate an invalid transaction\n             for (const auto& [name, flag] : mapFlagNames) {\n                 unsigned int flags = FillFlags(verify_flags | flag);\n                 // Adding individual flags\n-                if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, flags, txdata, strTest, /* expect_valid */ false)) {\n+                if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, flags, txdata, strTest, /*expect_valid=*/false)) {\n                     BOOST_ERROR(\"Tx unexpectedly passed with flag \" << name << \" set: \" << strTest);\n                 }\n                 // Adding random combinations of flags\n                 flags = FillFlags(verify_flags | (unsigned int)InsecureRandBits(mapFlagNames.size()));\n-                if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, flags, txdata, strTest, /* expect_valid */ false)) {\n+                if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, flags, txdata, strTest, /*expect_valid=*/false)) {\n                     BOOST_ERROR(\"Tx unexpectedly passed with random flags \" << name << \": \" << strTest);\n                 }\n             }\n \n             // Check that flags are minimal: transaction should succeed if any set flags are unset.\n             for (auto flags_excluding_one : ExcludeIndividualFlags(verify_flags)) {\n-                if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, flags_excluding_one, txdata, strTest, /* expect_valid */ true)) {\n+                if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, flags_excluding_one, txdata, strTest, /*expect_valid=*/true)) {\n                     BOOST_ERROR(\"Too many flags set: \" << strTest);\n                 }\n             }"
      },
      {
        "sha": "3db3c2de0b9941883f42f9837b0bb8f612e9d25a",
        "filename": "src/test/txpackage_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/txpackage_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/txpackage_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txpackage_tests.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -87,7 +87,7 @@ BOOST_FIXTURE_TEST_CASE(package_validation_tests, TestChain100Setup)\n                                                    /*output_destination */ child_locking_script,\n                                                    /*output_amount=*/ CAmount(48 * COIN), /*submit=*/false);\n     CTransactionRef tx_child = MakeTransactionRef(mtx_child);\n-    const auto result_parent_child = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, {tx_parent, tx_child}, /* test_accept */ true);\n+    const auto result_parent_child = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, {tx_parent, tx_child}, /*test_accept=*/true);\n     BOOST_CHECK_MESSAGE(result_parent_child.m_state.IsValid(),\n                         \"Package validation unexpectedly failed: \" << result_parent_child.m_state.GetRejectReason());\n     auto it_parent = result_parent_child.m_tx_results.find(tx_parent->GetWitnessHash());\n@@ -103,7 +103,7 @@ BOOST_FIXTURE_TEST_CASE(package_validation_tests, TestChain100Setup)\n     // A single, giant transaction submitted through ProcessNewPackage fails on single tx policy.\n     CTransactionRef giant_ptx = create_placeholder_tx(999, 999);\n     BOOST_CHECK(GetVirtualTransactionSize(*giant_ptx) > MAX_PACKAGE_SIZE * 1000);\n-    auto result_single_large = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, {giant_ptx}, /* test_accept */ true);\n+    auto result_single_large = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, {giant_ptx}, /*test_accept=*/true);\n     BOOST_CHECK(result_single_large.m_state.IsInvalid());\n     BOOST_CHECK_EQUAL(result_single_large.m_state.GetResult(), PackageValidationResult::PCKG_TX);\n     BOOST_CHECK_EQUAL(result_single_large.m_state.GetRejectReason(), \"transaction failed\");"
      },
      {
        "sha": "555979d94e7cca0d0ae4eb6363aa16882876cd1a",
        "filename": "src/test/util/chainstate.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/util/chainstate.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/util/chainstate.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/chainstate.h?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -47,7 +47,7 @@ CreateAndActivateUTXOSnapshot(NodeContext& node, const fs::path root, F malleati\n \n     malleation(auto_infile, metadata);\n \n-    return node.chainman->ActivateSnapshot(auto_infile, metadata, /*in_memory*/ true);\n+    return node.chainman->ActivateSnapshot(auto_infile, metadata, /*in_memory=*/true);\n }\n \n "
      },
      {
        "sha": "7bc305bcbcd37ab97e57de00cffd005bd1ef4e85",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -179,7 +179,7 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n \n     m_node.chainman->InitializeChainstate(m_node.mempool.get());\n     m_node.chainman->ActiveChainstate().InitCoinsDB(\n-        /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);\n+        /* cache_size_bytes */ 1 << 23, /*in_memory=*/true, /*should_wipe=*/false);\n     assert(!m_node.chainman->ActiveChainstate().CanFlushToDisk());\n     m_node.chainman->ActiveChainstate().InitCoinsCache(1 << 23);\n     assert(m_node.chainman->ActiveChainstate().CanFlushToDisk());\n@@ -192,7 +192,7 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n         throw std::runtime_error(strprintf(\"ActivateBestChain failed. (%s)\", state.ToString()));\n     }\n \n-    m_node.addrman = std::make_unique<AddrMan>(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    m_node.addrman = std::make_unique<AddrMan>(/*asmap=*/std::vector<bool>(), /*deterministic=*/false, /*consistency_check_ratio=*/0);\n     m_node.banman = std::make_unique<BanMan>(m_args.GetDataDirBase() / \"banlist\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     m_node.connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman); // Deterministic randomness for tests.\n     m_node.peerman = PeerManager::make(chainparams, *m_node.connman, *m_node.addrman,"
      },
      {
        "sha": "b2f4e3b3679bc366a9e7e7375e347455d026ec9e",
        "filename": "src/test/validation_chainstate_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/validation_chainstate_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/validation_chainstate_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_chainstate_tests.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -41,7 +41,7 @@ BOOST_AUTO_TEST_CASE(validation_chainstate_resize_caches)\n \n     CChainState& c1 = WITH_LOCK(cs_main, return manager.InitializeChainstate(&mempool));\n     c1.InitCoinsDB(\n-        /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);\n+        /* cache_size_bytes */ 1 << 23, /*in_memory=*/true, /*should_wipe=*/false);\n     WITH_LOCK(::cs_main, c1.InitCoinsCache(1 << 23));\n \n     // Add a coin to the in-memory cache, upsize once, then downsize."
      },
      {
        "sha": "c2ccbc64cc21483923c6bdd254b09d7b59619934",
        "filename": "src/test/validation_chainstatemanager_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/validation_chainstatemanager_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/validation_chainstatemanager_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_chainstatemanager_tests.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -39,7 +39,7 @@ BOOST_AUTO_TEST_CASE(chainstatemanager)\n     CChainState& c1 = WITH_LOCK(::cs_main, return manager.InitializeChainstate(&mempool));\n     chainstates.push_back(&c1);\n     c1.InitCoinsDB(\n-        /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);\n+        /* cache_size_bytes */ 1 << 23, /*in_memory=*/true, /*should_wipe=*/false);\n     WITH_LOCK(::cs_main, c1.InitCoinsCache(1 << 23));\n \n     BOOST_CHECK(!manager.IsSnapshotActive());\n@@ -68,7 +68,7 @@ BOOST_AUTO_TEST_CASE(chainstatemanager)\n     BOOST_CHECK_EQUAL(manager.SnapshotBlockhash().value(), snapshot_blockhash);\n \n     c2.InitCoinsDB(\n-        /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);\n+        /* cache_size_bytes */ 1 << 23, /*in_memory=*/true, /*should_wipe=*/false);\n     WITH_LOCK(::cs_main, c2.InitCoinsCache(1 << 23));\n     // Unlike c1, which doesn't have any blocks. Gets us different tip, height.\n     c2.LoadGenesisBlock();\n@@ -118,7 +118,7 @@ BOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)\n     CChainState& c1 = WITH_LOCK(cs_main, return manager.InitializeChainstate(&mempool));\n     chainstates.push_back(&c1);\n     c1.InitCoinsDB(\n-        /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);\n+        /* cache_size_bytes */ 1 << 23, /*in_memory=*/true, /*should_wipe=*/false);\n \n     {\n         LOCK(::cs_main);\n@@ -136,7 +136,7 @@ BOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)\n     CChainState& c2 = WITH_LOCK(cs_main, return manager.InitializeChainstate(&mempool, GetRandHash()));\n     chainstates.push_back(&c2);\n     c2.InitCoinsDB(\n-        /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);\n+        /* cache_size_bytes */ 1 << 23, /*in_memory=*/true, /*should_wipe=*/false);\n \n     {\n         LOCK(::cs_main);"
      },
      {
        "sha": "b4daceb72c98d4bff43ccfa2e3ce30291884b2af",
        "filename": "src/test/validation_flush_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/validation_flush_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/test/validation_flush_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_flush_tests.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -21,7 +21,7 @@ BOOST_AUTO_TEST_CASE(getcoinscachesizestate)\n     CTxMemPool mempool;\n     BlockManager blockman{};\n     CChainState chainstate{&mempool, blockman, *Assert(m_node.chainman)};\n-    chainstate.InitCoinsDB(/*cache_size_bytes*/ 1 << 10, /*in_memory*/ true, /*should_wipe*/ false);\n+    chainstate.InitCoinsDB(/*cache_size_bytes=*/1 << 10, /*in_memory=*/true, /*should_wipe=*/false);\n     WITH_LOCK(::cs_main, chainstate.InitCoinsCache(1 << 10));\n \n     constexpr bool is_64_bit = sizeof(void*) == 8;\n@@ -56,7 +56,7 @@ BOOST_AUTO_TEST_CASE(getcoinscachesizestate)\n \n     // Without any coins in the cache, we shouldn't need to flush.\n     BOOST_CHECK_EQUAL(\n-        chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes*/ 0),\n+        chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes=*/0),\n         CoinsCacheSizeState::OK);\n \n     // If the initial memory allocations of cacheCoins don't match these common\n@@ -71,7 +71,7 @@ BOOST_AUTO_TEST_CASE(getcoinscachesizestate)\n         }\n \n         BOOST_CHECK_EQUAL(\n-            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes*/ 0),\n+            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes=*/0),\n             CoinsCacheSizeState::CRITICAL);\n \n         BOOST_TEST_MESSAGE(\"Exiting cache flush tests early due to unsupported arch\");\n@@ -92,34 +92,34 @@ BOOST_AUTO_TEST_CASE(getcoinscachesizestate)\n         print_view_mem_usage(view);\n         BOOST_CHECK_EQUAL(view.AccessCoin(res).DynamicMemoryUsage(), COIN_SIZE);\n         BOOST_CHECK_EQUAL(\n-            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes*/ 0),\n+            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes=*/0),\n             CoinsCacheSizeState::OK);\n     }\n \n     // Adding some additional coins will push us over the edge to CRITICAL.\n     for (int i{0}; i < 4; ++i) {\n         add_coin(view);\n         print_view_mem_usage(view);\n-        if (chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes*/ 0) ==\n+        if (chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes=*/0) ==\n             CoinsCacheSizeState::CRITICAL) {\n             break;\n         }\n     }\n \n     BOOST_CHECK_EQUAL(\n-        chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes*/ 0),\n+        chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes=*/0),\n         CoinsCacheSizeState::CRITICAL);\n \n     // Passing non-zero max mempool usage should allow us more headroom.\n     BOOST_CHECK_EQUAL(\n-        chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes*/ 1 << 10),\n+        chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes=*/1 << 10),\n         CoinsCacheSizeState::OK);\n \n     for (int i{0}; i < 3; ++i) {\n         add_coin(view);\n         print_view_mem_usage(view);\n         BOOST_CHECK_EQUAL(\n-            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes*/ 1 << 10),\n+            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes=*/1 << 10),\n             CoinsCacheSizeState::OK);\n     }\n "
      },
      {
        "sha": "3f347669135c64ce906943ad6c52ca8a12a7f21a",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -76,7 +76,7 @@ void CCoinsViewDB::ResizeCache(size_t new_cache_size)\n         // filesystem lock.\n         m_db.reset();\n         m_db = std::make_unique<CDBWrapper>(\n-            m_ldb_path, new_cache_size, m_is_memory, /*fWipe*/ false, /*obfuscate*/ true);\n+            m_ldb_path, new_cache_size, m_is_memory, /*fWipe=*/false, /*obfuscate=*/true);\n     }\n }\n "
      },
      {
        "sha": "2d85baa3e47779e88dc98bf33d4c26a5ca2c3778",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -321,7 +321,7 @@ bool CTxMemPool::CalculateMemPoolAncestors(const CTxMemPoolEntry &entry,\n         staged_ancestors = it->GetMemPoolParentsConst();\n     }\n \n-    return CalculateAncestorsAndCheckLimits(entry.GetTxSize(), /* entry_count */ 1,\n+    return CalculateAncestorsAndCheckLimits(entry.GetTxSize(), /*entry_count=*/1,\n                                             setAncestors, staged_ancestors,\n                                             limitAncestorCount, limitAncestorSize,\n                                             limitDescendantCount, limitDescendantSize, errString);"
      },
      {
        "sha": "1fc6f24d932f5ca5be55660f577619ea954003c9",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -456,7 +456,7 @@ class MemPoolAccept\n         static ATMPArgs SingleAccept(const CChainParams& chainparams, int64_t accept_time,\n                                      bool bypass_limits, std::vector<COutPoint>& coins_to_uncache,\n                                      bool test_accept) {\n-            return ATMPArgs{/* m_chainparams */ chainparams,\n+            return ATMPArgs{/*m_chainparams=*/chainparams,\n                             /* m_accept_time */ accept_time,\n                             /* m_bypass_limits */ bypass_limits,\n                             /* m_coins_to_uncache */ coins_to_uncache,\n@@ -468,7 +468,7 @@ class MemPoolAccept\n         /** Parameters for test package mempool validation through testmempoolaccept. */\n         static ATMPArgs PackageTestAccept(const CChainParams& chainparams, int64_t accept_time,\n                                           std::vector<COutPoint>& coins_to_uncache) {\n-            return ATMPArgs{/* m_chainparams */ chainparams,\n+            return ATMPArgs{/*m_chainparams=*/chainparams,\n                             /* m_accept_time */ accept_time,\n                             /* m_bypass_limits */ false,\n                             /* m_coins_to_uncache */ coins_to_uncache,\n@@ -4913,7 +4913,7 @@ bool ChainstateManager::PopulateAndValidateSnapshot(\n \n             if (snapshot_cache_state >=\n                     CoinsCacheSizeState::CRITICAL) {\n-                LogPrintf(\"[snapshot] flushing coins cache (%.2f MB)... \", /* Continued */\n+                LogPrintf(\"[snapshot] flushing coins cache (%.2f MB)... \", /*Continued=*/\n                     coins_cache.DynamicMemoryUsage() / (1000 * 1000));\n                 flush_now = GetTimeMillis();\n "
      },
      {
        "sha": "6174404b65f268dedaf33308e0eba6117a048a0f",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -134,7 +134,7 @@ static CFeeRate EstimateFeeRate(const CWallet& wallet, const CWalletTx& wtx, con\n     feerate += std::max(node_incremental_relay_fee, wallet_incremental_relay_fee);\n \n     // Fee rate must also be at least the wallet's GetMinimumFeeRate\n-    CFeeRate min_feerate(GetMinimumFeeRate(wallet, coin_control, /* feeCalc */ nullptr));\n+    CFeeRate min_feerate(GetMinimumFeeRate(wallet, coin_control, /*feeCalc=*/nullptr));\n \n     // Set the required fee rate for the replacement transaction in coin control.\n     return std::max(feerate, min_feerate);"
      },
      {
        "sha": "6fb0b6983f7d79a7732a76ac81ccbf41b85d21b6",
        "filename": "src/wallet/receive.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/wallet/receive.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/wallet/receive.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/receive.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -326,8 +326,8 @@ Balance GetBalance(const CWallet& wallet, const int min_depth, bool avoid_reuse)\n             const CWalletTx& wtx = entry.second;\n             const bool is_trusted{CachedTxIsTrusted(wallet, wtx, trusted_parents)};\n             const int tx_depth{wallet.GetTxDepthInMainChain(wtx)};\n-            const CAmount tx_credit_mine{CachedTxGetAvailableCredit(wallet, wtx, /* fUseCache */ true, ISMINE_SPENDABLE | reuse_filter)};\n-            const CAmount tx_credit_watchonly{CachedTxGetAvailableCredit(wallet, wtx, /* fUseCache */ true, ISMINE_WATCH_ONLY | reuse_filter)};\n+            const CAmount tx_credit_mine{CachedTxGetAvailableCredit(wallet, wtx, /*fUseCache=*/true, ISMINE_SPENDABLE | reuse_filter)};\n+            const CAmount tx_credit_watchonly{CachedTxGetAvailableCredit(wallet, wtx, /*fUseCache=*/true, ISMINE_WATCH_ONLY | reuse_filter)};\n             if (is_trusted && tx_depth >= min_depth) {\n                 ret.m_mine_trusted += tx_credit_mine;\n                 ret.m_watchonly_trusted += tx_credit_watchonly;"
      },
      {
        "sha": "ad749986e5be9dd367895df58dadcd4ef8fd962b",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -1328,11 +1328,11 @@ RPCHelpMan importmulti()\n                         {RPCResult::Type::OBJ, \"\", \"\",\n                         {\n                             {RPCResult::Type::BOOL, \"success\", \"\"},\n-                            {RPCResult::Type::ARR, \"warnings\", /* optional */ true, \"\",\n+                            {RPCResult::Type::ARR, \"warnings\", /*optional=*/true, \"\",\n                             {\n                                 {RPCResult::Type::STR, \"\", \"\"},\n                             }},\n-                            {RPCResult::Type::OBJ, \"error\", /* optional */ true, \"\",\n+                            {RPCResult::Type::OBJ, \"error\", /*optional=*/true, \"\",\n                             {\n                                 {RPCResult::Type::ELISION, \"\", \"JSONRPC error\"},\n                             }},\n@@ -1643,11 +1643,11 @@ RPCHelpMan importdescriptors()\n                         {RPCResult::Type::OBJ, \"\", \"\",\n                         {\n                             {RPCResult::Type::BOOL, \"success\", \"\"},\n-                            {RPCResult::Type::ARR, \"warnings\", /* optional */ true, \"\",\n+                            {RPCResult::Type::ARR, \"warnings\", /*optional=*/true, \"\",\n                             {\n                                 {RPCResult::Type::STR, \"\", \"\"},\n                             }},\n-                            {RPCResult::Type::OBJ, \"error\", /* optional */ true, \"\",\n+                            {RPCResult::Type::OBJ, \"error\", /*optional=*/true, \"\",\n                             {\n                                 {RPCResult::Type::ELISION, \"\", \"JSONRPC error\"},\n                             }},"
      },
      {
        "sha": "9bdb576dcc79cd6e84f63853ca76b9e0b251eb8d",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 76,
        "deletions": 76,
        "changes": 152,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -232,7 +232,7 @@ static void SetFeeEstimateMode(const CWallet& wallet, CCoinControl& cc, const Un\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot specify both estimate_mode and fee_rate\");\n         }\n         // Fee rates in sat/vB cannot represent more than 3 significant digits.\n-        cc.m_feerate = CFeeRate{AmountFromValue(fee_rate, /* decimals */ 3)};\n+        cc.m_feerate = CFeeRate{AmountFromValue(fee_rate, /*decimals=*/3)};\n         if (override_min_fee) cc.fOverrideFeeRate = true;\n         // Default RBF to true for explicit fee_rate, if unset.\n         if (!cc.m_signal_bip125_rbf) cc.m_signal_bip125_rbf = true;\n@@ -531,7 +531,7 @@ static RPCHelpMan sendtoaddress()\n     // We also enable partial spend avoidance if reuse avoidance is set.\n     coin_control.m_avoid_partial_spends |= coin_control.m_avoid_address_reuse;\n \n-    SetFeeEstimateMode(*pwallet, coin_control, /* conf_target */ request.params[6], /* estimate_mode */ request.params[7], /* fee_rate */ request.params[9], /* override_min_fee */ false);\n+    SetFeeEstimateMode(*pwallet, coin_control, /*conf_target=*/request.params[6], /*estimate_mode=*/request.params[7], /*fee_rate=*/request.params[9], /*override_min_fee=*/false);\n \n     EnsureWalletIsUnlocked(*pwallet);\n \n@@ -568,7 +568,7 @@ static RPCHelpMan listaddressgroupings()\n                             {\n                                 {RPCResult::Type::STR, \"address\", \"The bitcoin address\"},\n                                 {RPCResult::Type::STR_AMOUNT, \"amount\", \"The amount in \" + CURRENCY_UNIT},\n-                                {RPCResult::Type::STR, \"label\", /* optional */ true, \"The label\"},\n+                                {RPCResult::Type::STR, \"label\", /*optional=*/true, \"The label\"},\n                             }},\n                         }},\n                     }\n@@ -747,7 +747,7 @@ static RPCHelpMan getreceivedbyaddress()\n \n     LOCK(pwallet->cs_wallet);\n \n-    return ValueFromAmount(GetReceived(*pwallet, request.params, /* by_label */ false));\n+    return ValueFromAmount(GetReceived(*pwallet, request.params, /*by_label=*/false));\n },\n     };\n }\n@@ -785,7 +785,7 @@ static RPCHelpMan getreceivedbylabel()\n \n     LOCK(pwallet->cs_wallet);\n \n-    return ValueFromAmount(GetReceived(*pwallet, request.params, /* by_label */ true));\n+    return ValueFromAmount(GetReceived(*pwallet, request.params, /*by_label=*/true));\n },\n     };\n }\n@@ -952,7 +952,7 @@ static RPCHelpMan sendmany()\n         coin_control.m_signal_bip125_rbf = request.params[5].get_bool();\n     }\n \n-    SetFeeEstimateMode(*pwallet, coin_control, /* conf_target */ request.params[6], /* estimate_mode */ request.params[7], /* fee_rate */ request.params[8], /* override_min_fee */ false);\n+    SetFeeEstimateMode(*pwallet, coin_control, /*conf_target=*/request.params[6], /*estimate_mode=*/request.params[7], /*fee_rate=*/request.params[8], /*override_min_fee=*/false);\n \n     std::vector<CRecipient> recipients;\n     ParseRecipients(sendTo, subtractFeeFromAmount, recipients);\n@@ -1223,7 +1223,7 @@ static RPCHelpMan listreceivedbyaddress()\n                     {\n                         {RPCResult::Type::OBJ, \"\", \"\",\n                         {\n-                            {RPCResult::Type::BOOL, \"involvesWatchonly\", /* optional */ true, \"Only returns true if imported addresses were involved in transaction\"},\n+                            {RPCResult::Type::BOOL, \"involvesWatchonly\", /*optional=*/true, \"Only returns true if imported addresses were involved in transaction\"},\n                             {RPCResult::Type::STR, \"address\", \"The receiving address\"},\n                             {RPCResult::Type::STR_AMOUNT, \"amount\", \"The total amount in \" + CURRENCY_UNIT + \" received by the address\"},\n                             {RPCResult::Type::NUM, \"confirmations\", \"The number of confirmations of the most recent transaction included\"},\n@@ -1271,7 +1271,7 @@ static RPCHelpMan listreceivedbylabel()\n                     {\n                         {RPCResult::Type::OBJ, \"\", \"\",\n                         {\n-                            {RPCResult::Type::BOOL, \"involvesWatchonly\", /* optional */ true, \"Only returns true if imported addresses were involved in transaction\"},\n+                            {RPCResult::Type::BOOL, \"involvesWatchonly\", /*optional=*/true, \"Only returns true if imported addresses were involved in transaction\"},\n                             {RPCResult::Type::STR_AMOUNT, \"amount\", \"The total amount received by addresses with this label\"},\n                             {RPCResult::Type::NUM, \"confirmations\", \"The number of confirmations of the most recent transaction included\"},\n                             {RPCResult::Type::STR, \"label\", \"The label of the receiving address. The default label is \\\"\\\"\"},\n@@ -1398,25 +1398,25 @@ static const std::vector<RPCResult> TransactionDescriptionString()\n {\n     return{{RPCResult::Type::NUM, \"confirmations\", \"The number of confirmations for the transaction. Negative confirmations means the\\n\"\n                \"transaction conflicted that many blocks ago.\"},\n-           {RPCResult::Type::BOOL, \"generated\", /* optional */ true, \"Only present if the transaction's only input is a coinbase one.\"},\n-           {RPCResult::Type::BOOL, \"trusted\", /* optional */ true, \"Whether we consider the transaction to be trusted and safe to spend from.\\n\"\n+           {RPCResult::Type::BOOL, \"generated\", /*optional=*/true, \"Only present if the transaction's only input is a coinbase one.\"},\n+           {RPCResult::Type::BOOL, \"trusted\", /*optional=*/true, \"Whether we consider the transaction to be trusted and safe to spend from.\\n\"\n                 \"Only present when the transaction has 0 confirmations (or negative confirmations, if conflicted).\"},\n-           {RPCResult::Type::STR_HEX, \"blockhash\", /* optional */ true, \"The block hash containing the transaction.\"},\n-           {RPCResult::Type::NUM, \"blockheight\", /* optional */ true, \"The block height containing the transaction.\"},\n-           {RPCResult::Type::NUM, \"blockindex\", /* optional */ true, \"The index of the transaction in the block that includes it.\"},\n-           {RPCResult::Type::NUM_TIME, \"blocktime\", /* optional */ true, \"The block time expressed in \" + UNIX_EPOCH_TIME + \".\"},\n+           {RPCResult::Type::STR_HEX, \"blockhash\", /*optional=*/true, \"The block hash containing the transaction.\"},\n+           {RPCResult::Type::NUM, \"blockheight\", /*optional=*/true, \"The block height containing the transaction.\"},\n+           {RPCResult::Type::NUM, \"blockindex\", /*optional=*/true, \"The index of the transaction in the block that includes it.\"},\n+           {RPCResult::Type::NUM_TIME, \"blocktime\", /*optional=*/true, \"The block time expressed in \" + UNIX_EPOCH_TIME + \".\"},\n            {RPCResult::Type::STR_HEX, \"txid\", \"The transaction id.\"},\n            {RPCResult::Type::ARR, \"walletconflicts\", \"Conflicting transaction ids.\",\n            {\n                {RPCResult::Type::STR_HEX, \"txid\", \"The transaction id.\"},\n            }},\n-           {RPCResult::Type::STR_HEX, \"replaced_by_txid\", /* optional */ true, \"The txid if this tx was replaced.\"},\n-           {RPCResult::Type::STR_HEX, \"replaces_txid\", /* optional */ true, \"The txid if the tx replaces one.\"},\n-           {RPCResult::Type::STR, \"comment\", /* optional */ true, \"\"},\n-           {RPCResult::Type::STR, \"to\", /* optional */ true, \"If a comment to is associated with the transaction.\"},\n+           {RPCResult::Type::STR_HEX, \"replaced_by_txid\", /*optional=*/true, \"The txid if this tx was replaced.\"},\n+           {RPCResult::Type::STR_HEX, \"replaces_txid\", /*optional=*/true, \"The txid if the tx replaces one.\"},\n+           {RPCResult::Type::STR, \"comment\", /*optional=*/true, \"\"},\n+           {RPCResult::Type::STR, \"to\", /*optional=*/true, \"If a comment to is associated with the transaction.\"},\n            {RPCResult::Type::NUM_TIME, \"time\", \"The transaction time expressed in \" + UNIX_EPOCH_TIME + \".\"},\n            {RPCResult::Type::NUM_TIME, \"timereceived\", \"The time received expressed in \" + UNIX_EPOCH_TIME + \".\"},\n-           {RPCResult::Type::STR, \"comment\", /* optional */ true, \"If a comment is associated with the transaction, only present if not empty.\"},\n+           {RPCResult::Type::STR, \"comment\", /*optional=*/true, \"If a comment is associated with the transaction, only present if not empty.\"},\n            {RPCResult::Type::STR, \"bip125-replaceable\", \"(\\\"yes|no|unknown\\\") Whether this transaction could be replaced due to BIP125 (replace-by-fee);\\n\"\n                \"may be unknown for unconfirmed transactions not in the mempool.\"}};\n }\n@@ -1438,7 +1438,7 @@ static RPCHelpMan listtransactions()\n                     {\n                         {RPCResult::Type::OBJ, \"\", \"\", Cat(Cat<std::vector<RPCResult>>(\n                         {\n-                            {RPCResult::Type::BOOL, \"involvesWatchonly\", /* optional */ true, \"Only returns true if imported addresses were involved in transaction.\"},\n+                            {RPCResult::Type::BOOL, \"involvesWatchonly\", /*optional=*/true, \"Only returns true if imported addresses were involved in transaction.\"},\n                             {RPCResult::Type::STR, \"address\", \"The bitcoin address of the transaction.\"},\n                             {RPCResult::Type::STR, \"category\", \"The transaction category.\\n\"\n                                 \"\\\"send\\\"                  Transactions sent.\\n\"\n@@ -1448,14 +1448,14 @@ static RPCHelpMan listtransactions()\n                                 \"\\\"orphan\\\"                Orphaned coinbase transactions received.\"},\n                             {RPCResult::Type::STR_AMOUNT, \"amount\", \"The amount in \" + CURRENCY_UNIT + \". This is negative for the 'send' category, and is positive\\n\"\n                                 \"for all other categories\"},\n-                            {RPCResult::Type::STR, \"label\", /* optional */ true, \"A comment for the address/transaction, if any\"},\n+                            {RPCResult::Type::STR, \"label\", /*optional=*/true, \"A comment for the address/transaction, if any\"},\n                             {RPCResult::Type::NUM, \"vout\", \"the vout value\"},\n-                            {RPCResult::Type::STR_AMOUNT, \"fee\", /* optional */ true, \"The amount of the fee in \" + CURRENCY_UNIT + \". This is negative and only available for the\\n\"\n+                            {RPCResult::Type::STR_AMOUNT, \"fee\", /*optional=*/true, \"The amount of the fee in \" + CURRENCY_UNIT + \". This is negative and only available for the\\n\"\n                                  \"'send' category of transactions.\"},\n                         },\n                         TransactionDescriptionString()),\n                         {\n-                            {RPCResult::Type::BOOL, \"abandoned\", /* optional */ true, \"'true' if the transaction has been abandoned (inputs are respendable). Only available for the \\n\"\n+                            {RPCResult::Type::BOOL, \"abandoned\", /*optional=*/true, \"'true' if the transaction has been abandoned (inputs are respendable). Only available for the \\n\"\n                                  \"'send' category of transactions.\"},\n                         })},\n                     }\n@@ -1552,7 +1552,7 @@ static RPCHelpMan listsinceblock()\n                         {\n                             {RPCResult::Type::OBJ, \"\", \"\", Cat(Cat<std::vector<RPCResult>>(\n                             {\n-                                {RPCResult::Type::BOOL, \"involvesWatchonly\", /* optional */ true, \"Only returns true if imported addresses were involved in transaction.\"},\n+                                {RPCResult::Type::BOOL, \"involvesWatchonly\", /*optional=*/true, \"Only returns true if imported addresses were involved in transaction.\"},\n                                 {RPCResult::Type::STR, \"address\", \"The bitcoin address of the transaction.\"},\n                                 {RPCResult::Type::STR, \"category\", \"The transaction category.\\n\"\n                                     \"\\\"send\\\"                  Transactions sent.\\n\"\n@@ -1563,17 +1563,17 @@ static RPCHelpMan listsinceblock()\n                                 {RPCResult::Type::STR_AMOUNT, \"amount\", \"The amount in \" + CURRENCY_UNIT + \". This is negative for the 'send' category, and is positive\\n\"\n                                     \"for all other categories\"},\n                                 {RPCResult::Type::NUM, \"vout\", \"the vout value\"},\n-                                {RPCResult::Type::STR_AMOUNT, \"fee\", /* optional */ true, \"The amount of the fee in \" + CURRENCY_UNIT + \". This is negative and only available for the\\n\"\n+                                {RPCResult::Type::STR_AMOUNT, \"fee\", /*optional=*/true, \"The amount of the fee in \" + CURRENCY_UNIT + \". This is negative and only available for the\\n\"\n                                      \"'send' category of transactions.\"},\n                             },\n                             TransactionDescriptionString()),\n                             {\n-                                {RPCResult::Type::BOOL, \"abandoned\", /* optional */ true, \"'true' if the transaction has been abandoned (inputs are respendable). Only available for the \\n\"\n+                                {RPCResult::Type::BOOL, \"abandoned\", /*optional=*/true, \"'true' if the transaction has been abandoned (inputs are respendable). Only available for the \\n\"\n                                      \"'send' category of transactions.\"},\n-                                {RPCResult::Type::STR, \"label\", /* optional */ true, \"A comment for the address/transaction, if any\"},\n+                                {RPCResult::Type::STR, \"label\", /*optional=*/true, \"A comment for the address/transaction, if any\"},\n                             })},\n                         }},\n-                        {RPCResult::Type::ARR, \"removed\", /* optional */ true, \"<structure is the same as \\\"transactions\\\" above, only present if include_removed=true>\\n\"\n+                        {RPCResult::Type::ARR, \"removed\", /*optional=*/true, \"<structure is the same as \\\"transactions\\\" above, only present if include_removed=true>\\n\"\n                             \"Note: transactions that were re-added in the active chain will appear as-is in this array, and may thus have a positive confirmation count.\"\n                         , {{RPCResult::Type::ELISION, \"\", \"\"},}},\n                         {RPCResult::Type::STR_HEX, \"lastblock\", \"The hash of the block (target_confirmations-1) from the best block on the main chain, or the genesis hash if the referenced block does not exist yet. This is typically used to feed back into listsinceblock the next time you call it. So you would generally use a target_confirmations of say 6, so you will be continually re-notified of transactions until they've reached 6 confirmations plus any new ones\"},\n@@ -1686,7 +1686,7 @@ static RPCHelpMan gettransaction()\n                     RPCResult::Type::OBJ, \"\", \"\", Cat(Cat<std::vector<RPCResult>>(\n                     {\n                         {RPCResult::Type::STR_AMOUNT, \"amount\", \"The amount in \" + CURRENCY_UNIT},\n-                        {RPCResult::Type::STR_AMOUNT, \"fee\", /* optional */ true, \"The amount of the fee in \" + CURRENCY_UNIT + \". This is negative and only available for the\\n\"\n+                        {RPCResult::Type::STR_AMOUNT, \"fee\", /*optional=*/true, \"The amount of the fee in \" + CURRENCY_UNIT + \". This is negative and only available for the\\n\"\n                                      \"'send' category of transactions.\"},\n                     },\n                     TransactionDescriptionString()),\n@@ -1695,25 +1695,25 @@ static RPCHelpMan gettransaction()\n                         {\n                             {RPCResult::Type::OBJ, \"\", \"\",\n                             {\n-                                {RPCResult::Type::BOOL, \"involvesWatchonly\", /* optional */ true, \"Only returns true if imported addresses were involved in transaction.\"},\n-                                {RPCResult::Type::STR, \"address\", /* optional */ true, \"The bitcoin address involved in the transaction.\"},\n+                                {RPCResult::Type::BOOL, \"involvesWatchonly\", /*optional=*/true, \"Only returns true if imported addresses were involved in transaction.\"},\n+                                {RPCResult::Type::STR, \"address\", /*optional=*/true, \"The bitcoin address involved in the transaction.\"},\n                                 {RPCResult::Type::STR, \"category\", \"The transaction category.\\n\"\n                                     \"\\\"send\\\"                  Transactions sent.\\n\"\n                                     \"\\\"receive\\\"               Non-coinbase transactions received.\\n\"\n                                     \"\\\"generate\\\"              Coinbase transactions received with more than 100 confirmations.\\n\"\n                                     \"\\\"immature\\\"              Coinbase transactions received with 100 or fewer confirmations.\\n\"\n                                     \"\\\"orphan\\\"                Orphaned coinbase transactions received.\"},\n                                 {RPCResult::Type::STR_AMOUNT, \"amount\", \"The amount in \" + CURRENCY_UNIT},\n-                                {RPCResult::Type::STR, \"label\", /* optional */ true, \"A comment for the address/transaction, if any\"},\n+                                {RPCResult::Type::STR, \"label\", /*optional=*/true, \"A comment for the address/transaction, if any\"},\n                                 {RPCResult::Type::NUM, \"vout\", \"the vout value\"},\n-                                {RPCResult::Type::STR_AMOUNT, \"fee\", /* optional */ true, \"The amount of the fee in \" + CURRENCY_UNIT + \". This is negative and only available for the \\n\"\n+                                {RPCResult::Type::STR_AMOUNT, \"fee\", /*optional=*/true, \"The amount of the fee in \" + CURRENCY_UNIT + \". This is negative and only available for the \\n\"\n                                     \"'send' category of transactions.\"},\n-                                {RPCResult::Type::BOOL, \"abandoned\", /* optional */ true, \"'true' if the transaction has been abandoned (inputs are respendable). Only available for the \\n\"\n+                                {RPCResult::Type::BOOL, \"abandoned\", /*optional=*/true, \"'true' if the transaction has been abandoned (inputs are respendable). Only available for the \\n\"\n                                      \"'send' category of transactions.\"},\n                             }},\n                         }},\n                         {RPCResult::Type::STR_HEX, \"hex\", \"Raw data for transaction\"},\n-                        {RPCResult::Type::OBJ, \"decoded\", /* optional */ true, \"The decoded transaction (only present when `verbose` is passed)\",\n+                        {RPCResult::Type::OBJ, \"decoded\", /*optional=*/true, \"The decoded transaction (only present when `verbose` is passed)\",\n                         {\n                             {RPCResult::Type::ELISION, \"\", \"Equivalent to the RPC decoderawtransaction method, or the RPC getrawtransaction method when `verbose` is passed.\"},\n                         }},\n@@ -2418,9 +2418,9 @@ static RPCHelpMan getbalances()\n                     {RPCResult::Type::STR_AMOUNT, \"trusted\", \"trusted balance (outputs created by the wallet or confirmed outputs)\"},\n                     {RPCResult::Type::STR_AMOUNT, \"untrusted_pending\", \"untrusted pending balance (outputs created by others that are in the mempool)\"},\n                     {RPCResult::Type::STR_AMOUNT, \"immature\", \"balance from immature coinbase outputs\"},\n-                    {RPCResult::Type::STR_AMOUNT, \"used\", /* optional */ true, \"(only present if avoid_reuse is set) balance from coins sent to addresses that were previously spent from (potentially privacy violating)\"},\n+                    {RPCResult::Type::STR_AMOUNT, \"used\", /*optional=*/true, \"(only present if avoid_reuse is set) balance from coins sent to addresses that were previously spent from (potentially privacy violating)\"},\n                 }},\n-                {RPCResult::Type::OBJ, \"watchonly\", /* optional */ true, \"watchonly balances (not present if wallet does not watch anything)\",\n+                {RPCResult::Type::OBJ, \"watchonly\", /*optional=*/true, \"watchonly balances (not present if wallet does not watch anything)\",\n                 {\n                     {RPCResult::Type::STR_AMOUNT, \"trusted\", \"trusted balance (outputs created by the wallet or confirmed outputs)\"},\n                     {RPCResult::Type::STR_AMOUNT, \"untrusted_pending\", \"untrusted pending balance (outputs created by others that are in the mempool)\"},\n@@ -2487,12 +2487,12 @@ static RPCHelpMan getwalletinfo()\n                         {RPCResult::Type::STR_AMOUNT, \"unconfirmed_balance\", \"DEPRECATED. Identical to getbalances().mine.untrusted_pending\"},\n                         {RPCResult::Type::STR_AMOUNT, \"immature_balance\", \"DEPRECATED. Identical to getbalances().mine.immature\"},\n                         {RPCResult::Type::NUM, \"txcount\", \"the total number of transactions in the wallet\"},\n-                        {RPCResult::Type::NUM_TIME, \"keypoololdest\", /* optional */ true, \"the \" + UNIX_EPOCH_TIME + \" of the oldest pre-generated key in the key pool. Legacy wallets only.\"},\n+                        {RPCResult::Type::NUM_TIME, \"keypoololdest\", /*optional=*/true, \"the \" + UNIX_EPOCH_TIME + \" of the oldest pre-generated key in the key pool. Legacy wallets only.\"},\n                         {RPCResult::Type::NUM, \"keypoolsize\", \"how many new keys are pre-generated (only counts external keys)\"},\n-                        {RPCResult::Type::NUM, \"keypoolsize_hd_internal\", /* optional */ true, \"how many new keys are pre-generated for internal use (used for change outputs, only appears if the wallet is using this feature, otherwise external keys are used)\"},\n-                        {RPCResult::Type::NUM_TIME, \"unlocked_until\", /* optional */ true, \"the \" + UNIX_EPOCH_TIME + \" until which the wallet is unlocked for transfers, or 0 if the wallet is locked (only present for passphrase-encrypted wallets)\"},\n+                        {RPCResult::Type::NUM, \"keypoolsize_hd_internal\", /*optional=*/true, \"how many new keys are pre-generated for internal use (used for change outputs, only appears if the wallet is using this feature, otherwise external keys are used)\"},\n+                        {RPCResult::Type::NUM_TIME, \"unlocked_until\", /*optional=*/true, \"the \" + UNIX_EPOCH_TIME + \" until which the wallet is unlocked for transfers, or 0 if the wallet is locked (only present for passphrase-encrypted wallets)\"},\n                         {RPCResult::Type::STR_AMOUNT, \"paytxfee\", \"the transaction fee configuration, set in \" + CURRENCY_UNIT + \"/kvB\"},\n-                        {RPCResult::Type::STR_HEX, \"hdseedid\", /* optional */ true, \"the Hash160 of the HD seed (only present when HD is enabled)\"},\n+                        {RPCResult::Type::STR_HEX, \"hdseedid\", /*optional=*/true, \"the Hash160 of the HD seed (only present when HD is enabled)\"},\n                         {RPCResult::Type::BOOL, \"private_keys_enabled\", \"false if privatekeys are disabled for this wallet (enforced watch-only wallet)\"},\n                         {RPCResult::Type::BOOL, \"avoid_reuse\", \"whether this wallet tracks clean/dirty coins in terms of reuse\"},\n                         {RPCResult::Type::OBJ, \"scanning\", \"current scanning details, or false if no scan is in progress\",\n@@ -3010,20 +3010,20 @@ static RPCHelpMan listunspent()\n                         {\n                             {RPCResult::Type::STR_HEX, \"txid\", \"the transaction id\"},\n                             {RPCResult::Type::NUM, \"vout\", \"the vout value\"},\n-                            {RPCResult::Type::STR, \"address\", /* optional */ true, \"the bitcoin address\"},\n-                            {RPCResult::Type::STR, \"label\", /* optional */ true, \"The associated label, or \\\"\\\" for the default label\"},\n+                            {RPCResult::Type::STR, \"address\", /*optional=*/true, \"the bitcoin address\"},\n+                            {RPCResult::Type::STR, \"label\", /*optional=*/true, \"The associated label, or \\\"\\\" for the default label\"},\n                             {RPCResult::Type::STR, \"scriptPubKey\", \"the script key\"},\n                             {RPCResult::Type::STR_AMOUNT, \"amount\", \"the transaction output amount in \" + CURRENCY_UNIT},\n                             {RPCResult::Type::NUM, \"confirmations\", \"The number of confirmations\"},\n-                            {RPCResult::Type::NUM, \"ancestorcount\", /* optional */ true, \"The number of in-mempool ancestor transactions, including this one (if transaction is in the mempool)\"},\n-                            {RPCResult::Type::NUM, \"ancestorsize\", /* optional */ true, \"The virtual transaction size of in-mempool ancestors, including this one (if transaction is in the mempool)\"},\n-                            {RPCResult::Type::STR_AMOUNT, \"ancestorfees\", /* optional */ true, \"The total fees of in-mempool ancestors (including this one) with fee deltas used for mining priority in \" + CURRENCY_ATOM + \" (if transaction is in the mempool)\"},\n-                            {RPCResult::Type::STR_HEX, \"redeemScript\", /* optional */ true, \"The redeemScript if scriptPubKey is P2SH\"},\n-                            {RPCResult::Type::STR, \"witnessScript\", /* optional */ true, \"witnessScript if the scriptPubKey is P2WSH or P2SH-P2WSH\"},\n+                            {RPCResult::Type::NUM, \"ancestorcount\", /*optional=*/true, \"The number of in-mempool ancestor transactions, including this one (if transaction is in the mempool)\"},\n+                            {RPCResult::Type::NUM, \"ancestorsize\", /*optional=*/true, \"The virtual transaction size of in-mempool ancestors, including this one (if transaction is in the mempool)\"},\n+                            {RPCResult::Type::STR_AMOUNT, \"ancestorfees\", /*optional=*/true, \"The total fees of in-mempool ancestors (including this one) with fee deltas used for mining priority in \" + CURRENCY_ATOM + \" (if transaction is in the mempool)\"},\n+                            {RPCResult::Type::STR_HEX, \"redeemScript\", /*optional=*/true, \"The redeemScript if scriptPubKey is P2SH\"},\n+                            {RPCResult::Type::STR, \"witnessScript\", /*optional=*/true, \"witnessScript if the scriptPubKey is P2WSH or P2SH-P2WSH\"},\n                             {RPCResult::Type::BOOL, \"spendable\", \"Whether we have the private keys to spend this output\"},\n                             {RPCResult::Type::BOOL, \"solvable\", \"Whether we know how to spend this output, ignoring the lack of keys\"},\n-                            {RPCResult::Type::BOOL, \"reused\", /* optional */ true, \"(only present if avoid_reuse is set) Whether this output is reused/dirty (sent to an address that was previously spent from)\"},\n-                            {RPCResult::Type::STR, \"desc\", /* optional */ true, \"(only when solvable) A descriptor for spending this output\"},\n+                            {RPCResult::Type::BOOL, \"reused\", /*optional=*/true, \"(only present if avoid_reuse is set) Whether this output is reused/dirty (sent to an address that was previously spent from)\"},\n+                            {RPCResult::Type::STR, \"desc\", /*optional=*/true, \"(only when solvable) A descriptor for spending this output\"},\n                             {RPCResult::Type::BOOL, \"safe\", \"Whether this output is considered safe to spend. Unconfirmed transactions\\n\"\n                                                             \"from outside keys and unconfirmed replacement transactions are considered unsafe\\n\"\n                                                             \"and are not eligible for spending by fundrawtransaction and sendtoaddress.\"},\n@@ -3530,7 +3530,7 @@ static RPCHelpMan fundrawtransaction()\n     CCoinControl coin_control;\n     // Automatically select (additional) coins. Can be overridden by options.add_inputs.\n     coin_control.m_add_inputs = true;\n-    FundTransaction(*pwallet, tx, fee, change_position, request.params[1], coin_control, /* override_min_fee */ true);\n+    FundTransaction(*pwallet, tx, fee, change_position, request.params[1], coin_control, /*override_min_fee=*/true);\n \n     UniValue result(UniValue::VOBJ);\n     result.pushKV(\"hex\", EncodeHexTx(CTransaction(tx)));\n@@ -3579,7 +3579,7 @@ RPCHelpMan signrawtransactionwithwallet()\n                     {\n                         {RPCResult::Type::STR_HEX, \"hex\", \"The hex-encoded raw transaction with signature(s)\"},\n                         {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n-                        {RPCResult::Type::ARR, \"errors\", /* optional */ true, \"Script verification errors (if there are any)\",\n+                        {RPCResult::Type::ARR, \"errors\", /*optional=*/true, \"Script verification errors (if there are any)\",\n                         {\n                             {RPCResult::Type::OBJ, \"\", \"\",\n                             {\n@@ -3735,7 +3735,7 @@ static RPCHelpMan bumpfee_helper(std::string method_name)\n         if (options.exists(\"replaceable\")) {\n             coin_control.m_signal_bip125_rbf = options[\"replaceable\"].get_bool();\n         }\n-        SetFeeEstimateMode(*pwallet, coin_control, conf_target, options[\"estimate_mode\"], options[\"fee_rate\"], /* override_min_fee */ false);\n+        SetFeeEstimateMode(*pwallet, coin_control, conf_target, options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n     }\n \n     // Make sure the results are valid at least up to the most recent block\n@@ -4027,33 +4027,33 @@ RPCHelpMan getaddressinfo()\n                         {RPCResult::Type::BOOL, \"ismine\", \"If the address is yours.\"},\n                         {RPCResult::Type::BOOL, \"iswatchonly\", \"If the address is watchonly.\"},\n                         {RPCResult::Type::BOOL, \"solvable\", \"If we know how to spend coins sent to this address, ignoring the possible lack of private keys.\"},\n-                        {RPCResult::Type::STR, \"desc\", /* optional */ true, \"A descriptor for spending coins sent to this address (only when solvable).\"},\n-                        {RPCResult::Type::STR, \"parent_desc\", /* optional */ true, \"The descriptor used to derive this address if this is a descriptor wallet\"},\n+                        {RPCResult::Type::STR, \"desc\", /*optional=*/true, \"A descriptor for spending coins sent to this address (only when solvable).\"},\n+                        {RPCResult::Type::STR, \"parent_desc\", /*optional=*/true, \"The descriptor used to derive this address if this is a descriptor wallet\"},\n                         {RPCResult::Type::BOOL, \"isscript\", \"If the key is a script.\"},\n                         {RPCResult::Type::BOOL, \"ischange\", \"If the address was used for change output.\"},\n                         {RPCResult::Type::BOOL, \"iswitness\", \"If the address is a witness address.\"},\n-                        {RPCResult::Type::NUM, \"witness_version\", /* optional */ true, \"The version number of the witness program.\"},\n-                        {RPCResult::Type::STR_HEX, \"witness_program\", /* optional */ true, \"The hex value of the witness program.\"},\n-                        {RPCResult::Type::STR, \"script\", /* optional */ true, \"The output script type. Only if isscript is true and the redeemscript is known. Possible\\n\"\n+                        {RPCResult::Type::NUM, \"witness_version\", /*optional=*/true, \"The version number of the witness program.\"},\n+                        {RPCResult::Type::STR_HEX, \"witness_program\", /*optional=*/true, \"The hex value of the witness program.\"},\n+                        {RPCResult::Type::STR, \"script\", /*optional=*/true, \"The output script type. Only if isscript is true and the redeemscript is known. Possible\\n\"\n                                                                      \"types: nonstandard, pubkey, pubkeyhash, scripthash, multisig, nulldata, witness_v0_keyhash,\\n\"\n                             \"witness_v0_scripthash, witness_unknown.\"},\n-                        {RPCResult::Type::STR_HEX, \"hex\", /* optional */ true, \"The redeemscript for the p2sh address.\"},\n-                        {RPCResult::Type::ARR, \"pubkeys\", /* optional */ true, \"Array of pubkeys associated with the known redeemscript (only if script is multisig).\",\n+                        {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"The redeemscript for the p2sh address.\"},\n+                        {RPCResult::Type::ARR, \"pubkeys\", /*optional=*/true, \"Array of pubkeys associated with the known redeemscript (only if script is multisig).\",\n                         {\n                             {RPCResult::Type::STR, \"pubkey\", \"\"},\n                         }},\n-                        {RPCResult::Type::NUM, \"sigsrequired\", /* optional */ true, \"The number of signatures required to spend multisig output (only if script is multisig).\"},\n-                        {RPCResult::Type::STR_HEX, \"pubkey\", /* optional */ true, \"The hex value of the raw public key for single-key addresses (possibly embedded in P2SH or P2WSH).\"},\n-                        {RPCResult::Type::OBJ, \"embedded\", /* optional */ true, \"Information about the address embedded in P2SH or P2WSH, if relevant and known.\",\n+                        {RPCResult::Type::NUM, \"sigsrequired\", /*optional=*/true, \"The number of signatures required to spend multisig output (only if script is multisig).\"},\n+                        {RPCResult::Type::STR_HEX, \"pubkey\", /*optional=*/true, \"The hex value of the raw public key for single-key addresses (possibly embedded in P2SH or P2WSH).\"},\n+                        {RPCResult::Type::OBJ, \"embedded\", /*optional=*/true, \"Information about the address embedded in P2SH or P2WSH, if relevant and known.\",\n                         {\n                             {RPCResult::Type::ELISION, \"\", \"Includes all getaddressinfo output fields for the embedded address, excluding metadata (timestamp, hdkeypath, hdseedid)\\n\"\n                             \"and relation to the wallet (ismine, iswatchonly).\"},\n                         }},\n-                        {RPCResult::Type::BOOL, \"iscompressed\", /* optional */ true, \"If the pubkey is compressed.\"},\n-                        {RPCResult::Type::NUM_TIME, \"timestamp\", /* optional */ true, \"The creation time of the key, if available, expressed in \" + UNIX_EPOCH_TIME + \".\"},\n-                        {RPCResult::Type::STR, \"hdkeypath\", /* optional */ true, \"The HD keypath, if the key is HD and available.\"},\n-                        {RPCResult::Type::STR_HEX, \"hdseedid\", /* optional */ true, \"The Hash160 of the HD seed.\"},\n-                        {RPCResult::Type::STR_HEX, \"hdmasterfingerprint\", /* optional */ true, \"The fingerprint of the master key.\"},\n+                        {RPCResult::Type::BOOL, \"iscompressed\", /*optional=*/true, \"If the pubkey is compressed.\"},\n+                        {RPCResult::Type::NUM_TIME, \"timestamp\", /*optional=*/true, \"The creation time of the key, if available, expressed in \" + UNIX_EPOCH_TIME + \".\"},\n+                        {RPCResult::Type::STR, \"hdkeypath\", /*optional=*/true, \"The HD keypath, if the key is HD and available.\"},\n+                        {RPCResult::Type::STR_HEX, \"hdseedid\", /*optional=*/true, \"The Hash160 of the HD seed.\"},\n+                        {RPCResult::Type::STR_HEX, \"hdmasterfingerprint\", /*optional=*/true, \"The fingerprint of the master key.\"},\n                         {RPCResult::Type::ARR, \"labels\", \"Array of labels associated with the address. Currently limited to one label but returned\\n\"\n                             \"as an array to keep the API stable if multiple labels are enabled in the future.\",\n                         {\n@@ -4111,7 +4111,7 @@ RPCHelpMan getaddressinfo()\n     DescriptorScriptPubKeyMan* desc_spk_man = dynamic_cast<DescriptorScriptPubKeyMan*>(pwallet->GetScriptPubKeyMan(scriptPubKey));\n     if (desc_spk_man) {\n         std::string desc_str;\n-        if (desc_spk_man->GetDescriptorString(desc_str, /* priv */ false)) {\n+        if (desc_spk_man->GetDescriptorString(desc_str, /*priv=*/false)) {\n             ret.pushKV(\"parent_desc\", desc_str);\n         }\n     }\n@@ -4331,9 +4331,9 @@ static RPCHelpMan send()\n             RPCResult::Type::OBJ, \"\", \"\",\n                 {\n                     {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n-                    {RPCResult::Type::STR_HEX, \"txid\", /* optional */ true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n-                    {RPCResult::Type::STR_HEX, \"hex\", /* optional */ true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n-                    {RPCResult::Type::STR, \"psbt\", /* optional */ true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n                 }\n         },\n         RPCExamples{\"\"\n@@ -4413,7 +4413,7 @@ static RPCHelpMan send()\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n-            FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n+            FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /*override_min_fee=*/false);\n \n             bool add_to_wallet = true;\n             if (options.exists(\"add_to_wallet\")) {\n@@ -4715,7 +4715,7 @@ static RPCHelpMan walletcreatefundedpsbt()\n     // Automatically select coins, unless at least one is manually selected. Can\n     // be overridden by options.add_inputs.\n     coin_control.m_add_inputs = rawTx.vin.size() == 0;\n-    FundTransaction(wallet, rawTx, fee, change_position, request.params[3], coin_control, /* override_min_fee */ true);\n+    FundTransaction(wallet, rawTx, fee, change_position, request.params[3], coin_control, /*override_min_fee=*/true);\n \n     // Make a blank psbt\n     PartiallySignedTransaction psbtx(rawTx);\n@@ -4755,8 +4755,8 @@ static RPCHelpMan upgradewallet()\n                 {RPCResult::Type::STR, \"wallet_name\", \"Name of wallet this operation was performed on\"},\n                 {RPCResult::Type::NUM, \"previous_version\", \"Version of wallet before this operation\"},\n                 {RPCResult::Type::NUM, \"current_version\", \"Version of wallet after this operation\"},\n-                {RPCResult::Type::STR, \"result\", /* optional */ true, \"Description of result, if no error\"},\n-                {RPCResult::Type::STR, \"error\", /* optional */ true, \"Error message (if there is one)\"}\n+                {RPCResult::Type::STR, \"result\", /*optional=*/true, \"Description of result, if no error\"},\n+                {RPCResult::Type::STR, \"error\", /*optional=*/true, \"Error message (if there is one)\"}\n             },\n         },\n         RPCExamples{"
      },
      {
        "sha": "26a93d3490c6e59565237f4a0d375dc998f36408",
        "filename": "src/wallet/spend.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/wallet/spend.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/wallet/spend.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/spend.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -470,7 +470,7 @@ bool SelectCoins(const CWallet& wallet, const std::vector<COutput>& vAvailableCo\n                 // Not ours, and we don't have solving data.\n                 return false;\n             }\n-            input_bytes = CalculateMaximumSignedInputSize(txout, &coin_control.m_external_provider, /* use_max_sig */ true);\n+            input_bytes = CalculateMaximumSignedInputSize(txout, &coin_control.m_external_provider, /*use_max_sig=*/true);\n         }\n \n         CInputCoin coin(outpoint, txout, input_bytes);\n@@ -768,7 +768,7 @@ static bool CreateTransactionInternal(\n     // Choose coins to use\n     CAmount inputs_sum = 0;\n     std::set<CInputCoin> setCoins;\n-    if (!SelectCoins(wallet, vAvailableCoins, /* nTargetValue */ selection_target, setCoins, inputs_sum, coin_control, coin_selection_params))\n+    if (!SelectCoins(wallet, vAvailableCoins, /*nTargetValue=*/selection_target, setCoins, inputs_sum, coin_control, coin_selection_params))\n     {\n         error = _(\"Insufficient funds\");\n         return false;"
      },
      {
        "sha": "35fef288a107c95e3376676f8623863f97695ebc",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -133,7 +133,7 @@ inline std::vector<OutputGroup>& KnapsackGroupOutputs(const std::vector<COutput>\n                                               /* long_term_feerate= */ CFeeRate(0), /* discard_feerate= */ CFeeRate(0),\n                                               /* tx_noinputs_size= */ 0, /* avoid_partial= */ false);\n     static std::vector<OutputGroup> static_groups;\n-    static_groups = GroupOutputs(wallet, coins, coin_selection_params, filter, /* positive_only */false);\n+    static_groups = GroupOutputs(wallet, coins, coin_selection_params, filter, /*positive_only=*/false);\n     return static_groups;\n }\n \n@@ -733,7 +733,7 @@ BOOST_AUTO_TEST_CASE(waste_test)\n     add_coin(1 * COIN, 1, selection, fee, fee);\n     add_coin(2 * COIN, 2, selection, fee, fee);\n     const CAmount exact_target{in_amt - fee * 2};\n-    BOOST_CHECK_EQUAL(0, GetSelectionWaste(selection, /* change_cost */ 0, exact_target));\n+    BOOST_CHECK_EQUAL(0, GetSelectionWaste(selection, /*change_cost=*/0, exact_target));\n     selection.clear();\n \n     // No Waste when (fee - long_term_fee) == (-cost_of_change), and no excess"
      },
      {
        "sha": "9f37d196ad06176353dd2ae45737380fc3dd37c4",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -1645,7 +1645,7 @@ CWallet::ScanResult CWallet::ScanForWalletTransactions(const uint256& start_bloc\n                 break;\n             }\n             for (size_t posInBlock = 0; posInBlock < block.vtx.size(); ++posInBlock) {\n-                SyncTransaction(block.vtx[posInBlock], {CWalletTx::Status::CONFIRMED, block_height, block_hash, (int)posInBlock}, fUpdate, /* rescanning_old_block */ true);\n+                SyncTransaction(block.vtx[posInBlock], {CWalletTx::Status::CONFIRMED, block_height, block_hash, (int)posInBlock}, fUpdate, /*rescanning_old_block=*/true);\n             }\n             // scan succeeded, record block as most recent successfully scanned\n             result.last_scanned_block = block_hash;"
      },
      {
        "sha": "df87751899fe6030d26c32903c81924287575659",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab1553de23cf52060ec4b494b7fa149c990f9e3/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=fab1553de23cf52060ec4b494b7fa149c990f9e3",
        "patch": "@@ -849,10 +849,10 @@ DBErrors WalletBatch::LoadWallet(CWallet* pwallet)\n \n     // Set the active ScriptPubKeyMans\n     for (auto spk_man_pair : wss.m_active_external_spks) {\n-        pwallet->LoadActiveScriptPubKeyMan(spk_man_pair.second, spk_man_pair.first, /* internal */ false);\n+        pwallet->LoadActiveScriptPubKeyMan(spk_man_pair.second, spk_man_pair.first, /*internal=*/false);\n     }\n     for (auto spk_man_pair : wss.m_active_internal_spks) {\n-        pwallet->LoadActiveScriptPubKeyMan(spk_man_pair.second, spk_man_pair.first, /* internal */ true);\n+        pwallet->LoadActiveScriptPubKeyMan(spk_man_pair.second, spk_man_pair.first, /*internal=*/true);\n     }\n \n     // Set the descriptor caches"
      }
    ]
  }
]