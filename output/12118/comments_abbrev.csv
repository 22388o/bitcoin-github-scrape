sdaftuar,2018-01-09T16:02:14Z,"@promag Thanks for taking a look.  I mimicked `CompareTxMempoolEntryByDescendantScore` in this PR to make review easier, since the two concepts have a symmetry.\n\nThe use of `double` for the intermediate value is to prevent overflow of an int64_t, which is theoretically possible.  That's also why there's an explicit double cast before multiplication.\n\nI'll rewrite the helper function along ",https://github.com/bitcoin/bitcoin/pull/12118#issuecomment-356327874,356327874,
promag,2018-01-09T23:57:57Z,"> The use of double for the intermediate value is to prevent overflow of an int64_t, which is theoretically possible.\n\nHow about http://releases.llvm.org/4.0.0/tools/clang/docs/LanguageExtensions.html#checked-arithmetic-builtins?",https://github.com/bitcoin/bitcoin/pull/12118#issuecomment-356453583,356453583,
sdaftuar,2018-01-10T15:19:01Z,"@promag The style of where to put the `&` doesn't seem to be in our style guide and is inconsistent already in this file, so I'm going to leave it the way I have it (which happens to be my preference for where to put the `&` :) ).\n\nI don't think it's a problem for code-correctness if the arithmetic overflows, so I'd rather just handle it as we currently do than introduce complication from calc",https://github.com/bitcoin/bitcoin/pull/12118#issuecomment-356633351,356633351,
promag,2018-01-10T15:45:00Z,"utACK 9a51319.\n\n> I'm going to leave it the way I have it\n\nFine.\n\n> so I'd rather just handle it as we currently do\n\nIt was just curiosity. Maybe `GetModFeeAndSize` values could be cached in `CTxMemPoolEntry` to improve even further? (adding 128 bytes per entry)",https://github.com/bitcoin/bitcoin/pull/12118#issuecomment-356641676,356641676,
sdaftuar,2018-01-11T02:21:46Z,">>I measured this as approximately a 5% speedup in removeForBlock.\n\n>I'm always interested to know how you benchmark these things, in case you want to post details.\n\n@ryanofsky I ran through nearly 3 months of historical block & transaction data (roughly March-May 2017), which I record and can play back to a patched bitcoind.  I ran two historical studies, one with this patch and one witho",https://github.com/bitcoin/bitcoin/pull/12118#issuecomment-356803845,356803845,
TheBlueMatt,2018-01-11T17:59:44Z,utACK 9a51319578091234fdd218a1eb144d517ea82b85,https://github.com/bitcoin/bitcoin/pull/12118#issuecomment-357009787,357009787,
gmaxwell,2018-01-11T20:34:03Z,ACK,https://github.com/bitcoin/bitcoin/pull/12118#issuecomment-357052870,357052870,
jimpo,2018-01-12T08:32:59Z,Maybe augment the `MempoolAncestorIndexingTest` with a case of a higher fee parent with a lower fee child (for which the sort order has changed).,https://github.com/bitcoin/bitcoin/pull/12118#issuecomment-357174960,357174960,
sdaftuar,2018-01-12T17:43:58Z,@jimpo Sounds good; I added a test.,https://github.com/bitcoin/bitcoin/pull/12118#issuecomment-357306399,357306399,
sdaftuar,2018-01-13T21:07:51Z,I just remembered that the mining code had this ancestor feerate sorting logic duplicated; I just added a commit that attempts to re-use the mempool code so that the new behavior will apply there as well.,https://github.com/bitcoin/bitcoin/pull/12118#issuecomment-357467313,357467313,
laanwj,2018-01-15T14:27:32Z,utACK 0a22a5291,https://github.com/bitcoin/bitcoin/pull/12118#issuecomment-357697399,357697399,
promag,2018-01-15T14:43:22Z,re-utACK 0a22a52. Added test looks good.,https://github.com/bitcoin/bitcoin/pull/12118#issuecomment-357701732,357701732,
promag,2018-01-08T23:51:55Z,Remove double cast?,https://github.com/bitcoin/bitcoin/pull/12118#discussion_r160286983,160286983,src/txmempool.h
promag,2018-01-08T23:54:29Z,"Why floating point? Aren't these all 64 integers?\n  ",https://github.com/bitcoin/bitcoin/pull/12118#discussion_r160287321,160287321,src/txmempool.h
promag,2018-01-09T00:01:41Z,"Instead of factoring out `UseAncestorScore`, do (missing comments):\n```cpp\nvoid GetModFeeAndSize(const CTxMemPoolEntry& a, int64_t& mod_fee, int64_t& size) {\n    int64_t f1 = a.GetModifiedFee() * a.GetSizeWithAncestors();\n    int64_t f2 = a.GetModFeesWithAncestors() * a.GetTxSize();\n    if (f1 > f2) {\n        mod_fee = a.GetModFeesWithAncestors();\n        size = a.GetSizeWithAncestor",https://github.com/bitcoin/bitcoin/pull/12118#discussion_r160288272,160288272,src/txmempool.h
promag,2018-01-09T00:01:59Z,"Nit, missing `.`.",https://github.com/bitcoin/bitcoin/pull/12118#discussion_r160288319,160288319,src/txmempool.h
TheBlueMatt,2018-01-14T17:30:24Z,"Just to check my understanding, this should have zero effect, correct? The highest element in mapTx and mapModifiedTx should always be the element we want, if the min() is hit, it will never have sorted as the top element in either mapModifedTx *or* mapTx, as all modifiedTx entries also have their parents in modifiedTx?",https://github.com/bitcoin/bitcoin/pull/12118#discussion_r161404506,161404506,src/miner.cpp
sdaftuar,2018-01-16T14:01:10Z,"Yes -- this change was only because I wanted to delete the code for CompareModifiedEntry, which is otherwise no longer needed.\n\n> all modifiedTx entries also have their parents in modifiedTx\n\nNot quite -- the parents of entries in mapModifiedTx are not in mapModifiedTx if they have been included in the candidate block.  Also a parent could be missing from mapModifiedTx if we already consid",https://github.com/bitcoin/bitcoin/pull/12118#discussion_r161764266,161764266,src/miner.cpp
