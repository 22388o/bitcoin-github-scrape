[
  {
    "sha": "1d13c44a4cb02b0acef6c6a108410cfc7eb20f71",
    "node_id": "C_kwDOABII59oAKDFkMTNjNDRhNGNiMDJiMGFjZWY2YzZhMTA4NDEwY2ZjN2ViMjBmNzE",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-19T22:41:05Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-19T22:41:05Z"
      },
      "message": "tests: Use descriptors for feature_segwit multisig setup\n\nWhen setting up the multisig addresses in feature_segwit.py, use\ndescriptors rather than addmultisigaddress.",
      "tree": {
        "sha": "f1549d3b8770ac936185c92da66bd1b384521881",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f1549d3b8770ac936185c92da66bd1b384521881"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1d13c44a4cb02b0acef6c6a108410cfc7eb20f71",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1d13c44a4cb02b0acef6c6a108410cfc7eb20f71",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1d13c44a4cb02b0acef6c6a108410cfc7eb20f71",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1d13c44a4cb02b0acef6c6a108410cfc7eb20f71/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "986003aff93c099c400c9285b4a2ed63f4b3f180",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/986003aff93c099c400c9285b4a2ed63f4b3f180",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/986003aff93c099c400c9285b4a2ed63f4b3f180"
      }
    ],
    "stats": {
      "total": 38,
      "additions": 34,
      "deletions": 4
    },
    "files": [
      {
        "sha": "362120e42e73dc572075587e22b7c81ff869bde5",
        "filename": "test/functional/feature_segwit.py",
        "status": "modified",
        "additions": 34,
        "deletions": 4,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1d13c44a4cb02b0acef6c6a108410cfc7eb20f71/test/functional/feature_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1d13c44a4cb02b0acef6c6a108410cfc7eb20f71/test/functional/feature_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_segwit.py?ref=1d13c44a4cb02b0acef6c6a108410cfc7eb20f71",
        "patch": "@@ -17,6 +17,7 @@\n     send_to_witness,\n     witness_script,\n )\n+from test_framework.descriptors import descsum_create\n from test_framework.messages import (\n     COIN,\n     COutPoint,\n@@ -49,6 +50,9 @@\n     assert_raises_rpc_error,\n     try_rpc,\n )\n+from test_framework.wallet_util import (\n+    get_generate_key,\n+)\n \n NODE_0 = 0\n NODE_2 = 2\n@@ -142,13 +146,39 @@ def run_test(self):\n         p2sh_ids = []  # p2sh_ids[NODE][TYPE] is an array of txids that spend to P2WPKH (TYPE=0) or P2WSH (TYPE=1) scripts to an address for NODE embedded in p2sh\n         wit_ids = []  # wit_ids[NODE][TYPE] is an array of txids that spend to P2WPKH (TYPE=0) or P2WSH (TYPE=1) scripts to an address for NODE via bare witness\n         for i in range(3):\n-            newaddress = self.nodes[i].getnewaddress()\n-            self.pubkey.append(self.nodes[i].getaddressinfo(newaddress)[\"pubkey\"])\n+            key = get_generate_key()\n+            self.pubkey.append(key.pubkey)\n+\n             multiscript = CScript([OP_1, bytes.fromhex(self.pubkey[-1]), OP_1, OP_CHECKMULTISIG])\n-            p2sh_ms_addr = self.nodes[i].addmultisigaddress(1, [self.pubkey[-1]], '', 'p2sh-segwit')['address']\n-            bip173_ms_addr = self.nodes[i].addmultisigaddress(1, [self.pubkey[-1]], '', 'bech32')['address']\n+            p2sh_ms_addr = self.nodes[i].createmultisig(1, [self.pubkey[-1]], 'p2sh-segwit')['address']\n+            bip173_ms_addr = self.nodes[i].createmultisig(1, [self.pubkey[-1]], 'bech32')['address']\n             assert_equal(p2sh_ms_addr, script_to_p2sh_p2wsh(multiscript))\n             assert_equal(bip173_ms_addr, script_to_p2wsh(multiscript))\n+\n+            p2sh_ms_desc = descsum_create(f\"sh(wsh(multi(1,{key.privkey})))\")\n+            bip173_ms_desc = descsum_create(f\"wsh(multi(1,{key.privkey}))\")\n+            assert_equal(self.nodes[i].deriveaddresses(p2sh_ms_desc)[0], p2sh_ms_addr)\n+            assert_equal(self.nodes[i].deriveaddresses(bip173_ms_desc)[0], bip173_ms_addr)\n+\n+            sh_wpkh_desc = descsum_create(f\"sh(wpkh({key.privkey}))\")\n+            wpkh_desc = descsum_create(f\"wpkh({key.privkey})\")\n+            assert_equal(self.nodes[i].deriveaddresses(sh_wpkh_desc)[0], key.p2sh_p2wpkh_addr)\n+            assert_equal(self.nodes[i].deriveaddresses(wpkh_desc)[0], key.p2wpkh_addr)\n+\n+            if self.options.descriptors:\n+                res = self.nodes[i].importdescriptors([\n+                {\"desc\": p2sh_ms_desc, \"timestamp\": \"now\"},\n+                {\"desc\": bip173_ms_desc, \"timestamp\": \"now\"},\n+                {\"desc\": sh_wpkh_desc, \"timestamp\": \"now\"},\n+                {\"desc\": wpkh_desc, \"timestamp\": \"now\"},\n+            ])\n+            else:\n+                # The nature of the legacy wallet is that this import results in also adding all of the necessary scripts\n+                res = self.nodes[i].importmulti([\n+                    {\"desc\": p2sh_ms_desc, \"timestamp\": \"now\"},\n+                ])\n+            assert all([r[\"success\"] for r in res])\n+\n             p2sh_ids.append([])\n             wit_ids.append([])\n             for _ in range(2):"
      }
    ]
  },
  {
    "sha": "ae6cbcc90926b65099ed8747e7a13a4aefba787a",
    "node_id": "C_kwDOABII59oAKGFlNmNiY2M5MDkyNmI2NTA5OWVkODc0N2U3YTEzYTRhZWZiYTc4N2E",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-19T22:41:46Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-19T22:41:46Z"
      },
      "message": "tests: restrict feature_segwit legacy wallet import tests\n\nA portion of feature_segwit deals with the legacy wallet IsMine and\nimport behavior. This is now hidden behind --legacy-wallet",
      "tree": {
        "sha": "098b355f9fb2287070235df003b42177824a435f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/098b355f9fb2287070235df003b42177824a435f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ae6cbcc90926b65099ed8747e7a13a4aefba787a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ae6cbcc90926b65099ed8747e7a13a4aefba787a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ae6cbcc90926b65099ed8747e7a13a4aefba787a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ae6cbcc90926b65099ed8747e7a13a4aefba787a/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1d13c44a4cb02b0acef6c6a108410cfc7eb20f71",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1d13c44a4cb02b0acef6c6a108410cfc7eb20f71",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1d13c44a4cb02b0acef6c6a108410cfc7eb20f71"
      }
    ],
    "stats": {
      "total": 557,
      "additions": 279,
      "deletions": 278
    },
    "files": [
      {
        "sha": "5abe989e55c27f2c2bad09ff8184ce62c4253dd9",
        "filename": "test/functional/feature_segwit.py",
        "status": "modified",
        "additions": 279,
        "deletions": 278,
        "changes": 557,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae6cbcc90926b65099ed8747e7a13a4aefba787a/test/functional/feature_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae6cbcc90926b65099ed8747e7a13a4aefba787a/test/functional/feature_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_segwit.py?ref=ae6cbcc90926b65099ed8747e7a13a4aefba787a",
        "patch": "@@ -341,284 +341,285 @@ def run_test(self):\n         # Mine a block to clear the gbt cache again.\n         self.generate(self.nodes[0], 1)\n \n-        self.log.info(\"Verify behaviour of importaddress and listunspent\")\n-\n-        # Some public keys to be used later\n-        pubkeys = [\n-            \"0363D44AABD0F1699138239DF2F042C3282C0671CC7A76826A55C8203D90E39242\",  # cPiM8Ub4heR9NBYmgVzJQiUH1if44GSBGiqaeJySuL2BKxubvgwb\n-            \"02D3E626B3E616FC8662B489C123349FECBFC611E778E5BE739B257EAE4721E5BF\",  # cPpAdHaD6VoYbW78kveN2bsvb45Q7G5PhaPApVUGwvF8VQ9brD97\n-            \"04A47F2CBCEFFA7B9BCDA184E7D5668D3DA6F9079AD41E422FA5FD7B2D458F2538A62F5BD8EC85C2477F39650BD391EA6250207065B2A81DA8B009FC891E898F0E\",  # 91zqCU5B9sdWxzMt1ca3VzbtVm2YM6Hi5Rxn4UDtxEaN9C9nzXV\n-            \"02A47F2CBCEFFA7B9BCDA184E7D5668D3DA6F9079AD41E422FA5FD7B2D458F2538\",  # cPQFjcVRpAUBG8BA9hzr2yEzHwKoMgLkJZBBtK9vJnvGJgMjzTbd\n-            \"036722F784214129FEB9E8129D626324F3F6716555B603FFE8300BBCB882151228\",  # cQGtcm34xiLjB1v7bkRa4V3aAc9tS2UTuBZ1UnZGeSeNy627fN66\n-            \"0266A8396EE936BF6D99D17920DB21C6C7B1AB14C639D5CD72B300297E416FD2EC\",  # cTW5mR5M45vHxXkeChZdtSPozrFwFgmEvTNnanCW6wrqwaCZ1X7K\n-            \"0450A38BD7F0AC212FEBA77354A9B036A32E0F7C81FC4E0C5ADCA7C549C4505D2522458C2D9AE3CEFD684E039194B72C8A10F9CB9D4764AB26FCC2718D421D3B84\",  # 92h2XPssjBpsJN5CqSP7v9a7cf2kgDunBC6PDFwJHMACM1rrVBJ\n-        ]\n-\n-        # Import a compressed key and an uncompressed key, generate some multisig addresses\n-        self.nodes[0].importprivkey(\"92e6XLo5jVAVwrQKPNTs93oQco8f8sDNBcpv73Dsrs397fQtFQn\")\n-        uncompressed_spendable_address = [\"mvozP4UwyGD2mGZU4D2eMvMLPB9WkMmMQu\"]\n-        self.nodes[0].importprivkey(\"cNC8eQ5dg3mFAVePDX4ddmPYpPbw41r9bm2jd1nLJT77e6RrzTRR\")\n-        compressed_spendable_address = [\"mmWQubrDomqpgSYekvsU7HWEVjLFHAakLe\"]\n-        assert not self.nodes[0].getaddressinfo(uncompressed_spendable_address[0])['iscompressed']\n-        assert self.nodes[0].getaddressinfo(compressed_spendable_address[0])['iscompressed']\n-\n-        self.nodes[0].importpubkey(pubkeys[0])\n-        compressed_solvable_address = [key_to_p2pkh(pubkeys[0])]\n-        self.nodes[0].importpubkey(pubkeys[1])\n-        compressed_solvable_address.append(key_to_p2pkh(pubkeys[1]))\n-        self.nodes[0].importpubkey(pubkeys[2])\n-        uncompressed_solvable_address = [key_to_p2pkh(pubkeys[2])]\n-\n-        spendable_anytime = []                      # These outputs should be seen anytime after importprivkey and addmultisigaddress\n-        spendable_after_importaddress = []          # These outputs should be seen after importaddress\n-        solvable_after_importaddress = []           # These outputs should be seen after importaddress but not spendable\n-        unsolvable_after_importaddress = []         # These outputs should be unsolvable after importaddress\n-        solvable_anytime = []                       # These outputs should be solvable after importpubkey\n-        unseen_anytime = []                         # These outputs should never be seen\n-\n-        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], compressed_spendable_address[0]])['address'])\n-        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], uncompressed_spendable_address[0]])['address'])\n-        compressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_spendable_address[0]])['address'])\n-        uncompressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], uncompressed_solvable_address[0]])['address'])\n-        compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_solvable_address[0]])['address'])\n-        compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_solvable_address[0], compressed_solvable_address[1]])['address'])\n-\n-        # Test multisig_without_privkey\n-        # We have 2 public keys without private keys, use addmultisigaddress to add to wallet.\n-        # Money sent to P2SH of multisig of this should only be seen after importaddress with the BASE58 P2SH address.\n-\n-        multisig_without_privkey_address = self.nodes[0].addmultisigaddress(2, [pubkeys[3], pubkeys[4]])['address']\n-        script = CScript([OP_2, bytes.fromhex(pubkeys[3]), bytes.fromhex(pubkeys[4]), OP_2, OP_CHECKMULTISIG])\n-        solvable_after_importaddress.append(script_to_p2sh_script(script))\n-\n-        for i in compressed_spendable_address:\n-            v = self.nodes[0].getaddressinfo(i)\n-            if v['isscript']:\n-                [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n-                # p2sh multisig with compressed keys should always be spendable\n-                spendable_anytime.extend([p2sh])\n-                # bare multisig can be watched and signed, but is not treated as ours\n-                solvable_after_importaddress.extend([bare])\n-                # P2WSH and P2SH(P2WSH) multisig with compressed keys are spendable after direct importaddress\n-                spendable_after_importaddress.extend([p2wsh, p2sh_p2wsh])\n-            else:\n-                [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n-                # normal P2PKH and P2PK with compressed keys should always be spendable\n-                spendable_anytime.extend([p2pkh, p2pk])\n-                # P2SH_P2PK, P2SH_P2PKH with compressed keys are spendable after direct importaddress\n-                spendable_after_importaddress.extend([p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n-                # P2WPKH and P2SH_P2WPKH with compressed keys should always be spendable\n-                spendable_anytime.extend([p2wpkh, p2sh_p2wpkh])\n-\n-        for i in uncompressed_spendable_address:\n-            v = self.nodes[0].getaddressinfo(i)\n-            if v['isscript']:\n-                [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n-                # p2sh multisig with uncompressed keys should always be spendable\n-                spendable_anytime.extend([p2sh])\n-                # bare multisig can be watched and signed, but is not treated as ours\n-                solvable_after_importaddress.extend([bare])\n-                # P2WSH and P2SH(P2WSH) multisig with uncompressed keys are never seen\n-                unseen_anytime.extend([p2wsh, p2sh_p2wsh])\n-            else:\n-                [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n-                # normal P2PKH and P2PK with uncompressed keys should always be spendable\n-                spendable_anytime.extend([p2pkh, p2pk])\n-                # P2SH_P2PK and P2SH_P2PKH are spendable after direct importaddress\n-                spendable_after_importaddress.extend([p2sh_p2pk, p2sh_p2pkh])\n-                # Witness output types with uncompressed keys are never seen\n-                unseen_anytime.extend([p2wpkh, p2sh_p2wpkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n-\n-        for i in compressed_solvable_address:\n-            v = self.nodes[0].getaddressinfo(i)\n-            if v['isscript']:\n-                # Multisig without private is not seen after addmultisigaddress, but seen after importaddress\n-                [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n-                solvable_after_importaddress.extend([bare, p2sh, p2wsh, p2sh_p2wsh])\n-            else:\n-                [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n-                # normal P2PKH, P2PK, P2WPKH and P2SH_P2WPKH with compressed keys should always be seen\n-                solvable_anytime.extend([p2pkh, p2pk, p2wpkh, p2sh_p2wpkh])\n-                # P2SH_P2PK, P2SH_P2PKH with compressed keys are seen after direct importaddress\n-                solvable_after_importaddress.extend([p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n-\n-        for i in uncompressed_solvable_address:\n-            v = self.nodes[0].getaddressinfo(i)\n-            if v['isscript']:\n-                [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n-                # Base uncompressed multisig without private is not seen after addmultisigaddress, but seen after importaddress\n-                solvable_after_importaddress.extend([bare, p2sh])\n-                # P2WSH and P2SH(P2WSH) multisig with uncompressed keys are never seen\n-                unseen_anytime.extend([p2wsh, p2sh_p2wsh])\n-            else:\n-                [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n-                # normal P2PKH and P2PK with uncompressed keys should always be seen\n-                solvable_anytime.extend([p2pkh, p2pk])\n-                # P2SH_P2PK, P2SH_P2PKH with uncompressed keys are seen after direct importaddress\n-                solvable_after_importaddress.extend([p2sh_p2pk, p2sh_p2pkh])\n-                # Witness output types with uncompressed keys are never seen\n-                unseen_anytime.extend([p2wpkh, p2sh_p2wpkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n-\n-        op1 = CScript([OP_1])\n-        op0 = CScript([OP_0])\n-        # 2N7MGY19ti4KDMSzRfPAssP6Pxyuxoi6jLe is the P2SH(P2PKH) version of mjoE3sSrb8ByYEvgnC3Aox86u1CHnfJA4V\n-        unsolvable_address_key = bytes.fromhex(\"02341AEC7587A51CDE5279E0630A531AEA2615A9F80B17E8D9376327BAEAA59E3D\")\n-        unsolvablep2pkh = key_to_p2pkh_script(unsolvable_address_key)\n-        unsolvablep2wshp2pkh = script_to_p2wsh_script(unsolvablep2pkh)\n-        p2shop0 = script_to_p2sh_script(op0)\n-        p2wshop1 = script_to_p2wsh_script(op1)\n-        unsolvable_after_importaddress.append(unsolvablep2pkh)\n-        unsolvable_after_importaddress.append(unsolvablep2wshp2pkh)\n-        unsolvable_after_importaddress.append(op1)  # OP_1 will be imported as script\n-        unsolvable_after_importaddress.append(p2wshop1)\n-        unseen_anytime.append(op0)  # OP_0 will be imported as P2SH address with no script provided\n-        unsolvable_after_importaddress.append(p2shop0)\n-\n-        spendable_txid = []\n-        solvable_txid = []\n-        spendable_txid.append(self.mine_and_test_listunspent(spendable_anytime, 2))\n-        solvable_txid.append(self.mine_and_test_listunspent(solvable_anytime, 1))\n-        self.mine_and_test_listunspent(spendable_after_importaddress + solvable_after_importaddress + unseen_anytime + unsolvable_after_importaddress, 0)\n-\n-        importlist = []\n-        for i in compressed_spendable_address + uncompressed_spendable_address + compressed_solvable_address + uncompressed_solvable_address:\n-            v = self.nodes[0].getaddressinfo(i)\n-            if v['isscript']:\n-                bare = bytes.fromhex(v['hex'])\n-                importlist.append(bare.hex())\n-                importlist.append(script_to_p2wsh_script(bare).hex())\n-            else:\n-                pubkey = bytes.fromhex(v['pubkey'])\n-                p2pk = key_to_p2pk_script(pubkey)\n-                p2pkh = key_to_p2pkh_script(pubkey)\n-                importlist.append(p2pk.hex())\n-                importlist.append(p2pkh.hex())\n-                importlist.append(key_to_p2wpkh_script(pubkey).hex())\n-                importlist.append(script_to_p2wsh_script(p2pk).hex())\n-                importlist.append(script_to_p2wsh_script(p2pkh).hex())\n-\n-        importlist.append(unsolvablep2pkh.hex())\n-        importlist.append(unsolvablep2wshp2pkh.hex())\n-        importlist.append(op1.hex())\n-        importlist.append(p2wshop1.hex())\n-\n-        for i in importlist:\n-            # import all generated addresses. The wallet already has the private keys for some of these, so catch JSON RPC\n-            # exceptions and continue.\n-            try_rpc(-4, \"The wallet already contains the private key for this address or script\", self.nodes[0].importaddress, i, \"\", False, True)\n-\n-        self.nodes[0].importaddress(script_to_p2sh(op0))  # import OP_0 as address only\n-        self.nodes[0].importaddress(multisig_without_privkey_address)  # Test multisig_without_privkey\n-\n-        spendable_txid.append(self.mine_and_test_listunspent(spendable_anytime + spendable_after_importaddress, 2))\n-        solvable_txid.append(self.mine_and_test_listunspent(solvable_anytime + solvable_after_importaddress, 1))\n-        self.mine_and_test_listunspent(unsolvable_after_importaddress, 1)\n-        self.mine_and_test_listunspent(unseen_anytime, 0)\n-\n-        spendable_txid.append(self.mine_and_test_listunspent(spendable_anytime + spendable_after_importaddress, 2))\n-        solvable_txid.append(self.mine_and_test_listunspent(solvable_anytime + solvable_after_importaddress, 1))\n-        self.mine_and_test_listunspent(unsolvable_after_importaddress, 1)\n-        self.mine_and_test_listunspent(unseen_anytime, 0)\n-\n-        # Repeat some tests. This time we don't add witness scripts with importaddress\n-        # Import a compressed key and an uncompressed key, generate some multisig addresses\n-        self.nodes[0].importprivkey(\"927pw6RW8ZekycnXqBQ2JS5nPyo1yRfGNN8oq74HeddWSpafDJH\")\n-        uncompressed_spendable_address = [\"mguN2vNSCEUh6rJaXoAVwY3YZwZvEmf5xi\"]\n-        self.nodes[0].importprivkey(\"cMcrXaaUC48ZKpcyydfFo8PxHAjpsYLhdsp6nmtB3E2ER9UUHWnw\")\n-        compressed_spendable_address = [\"n1UNmpmbVUJ9ytXYXiurmGPQ3TRrXqPWKL\"]\n-\n-        self.nodes[0].importpubkey(pubkeys[5])\n-        compressed_solvable_address = [key_to_p2pkh(pubkeys[5])]\n-        self.nodes[0].importpubkey(pubkeys[6])\n-        uncompressed_solvable_address = [key_to_p2pkh(pubkeys[6])]\n-\n-        unseen_anytime = []                         # These outputs should never be seen\n-        solvable_anytime = []                       # These outputs should be solvable after importpubkey\n-        unseen_anytime = []                         # These outputs should never be seen\n-\n-        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], compressed_spendable_address[0]])['address'])\n-        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], uncompressed_spendable_address[0]])['address'])\n-        compressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_spendable_address[0]])['address'])\n-        uncompressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_solvable_address[0], uncompressed_solvable_address[0]])['address'])\n-        compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_solvable_address[0]])['address'])\n-\n-        premature_witaddress = []\n-\n-        for i in compressed_spendable_address:\n-            v = self.nodes[0].getaddressinfo(i)\n-            if v['isscript']:\n-                [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n-                premature_witaddress.append(script_to_p2sh(p2wsh))\n-            else:\n-                [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n-                # P2WPKH, P2SH_P2WPKH are always spendable\n-                spendable_anytime.extend([p2wpkh, p2sh_p2wpkh])\n-\n-        for i in uncompressed_spendable_address + uncompressed_solvable_address:\n-            v = self.nodes[0].getaddressinfo(i)\n-            if v['isscript']:\n-                [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n-                # P2WSH and P2SH(P2WSH) multisig with uncompressed keys are never seen\n-                unseen_anytime.extend([p2wsh, p2sh_p2wsh])\n-            else:\n-                [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n-                # P2WPKH, P2SH_P2WPKH with uncompressed keys are never seen\n-                unseen_anytime.extend([p2wpkh, p2sh_p2wpkh])\n-\n-        for i in compressed_solvable_address:\n-            v = self.nodes[0].getaddressinfo(i)\n-            if v['isscript']:\n-                [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n-                premature_witaddress.append(script_to_p2sh(p2wsh))\n-            else:\n-                [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n-                # P2SH_P2PK, P2SH_P2PKH with compressed keys are always solvable\n-                solvable_anytime.extend([p2wpkh, p2sh_p2wpkh])\n-\n-        self.mine_and_test_listunspent(spendable_anytime, 2)\n-        self.mine_and_test_listunspent(solvable_anytime, 1)\n-        self.mine_and_test_listunspent(unseen_anytime, 0)\n-\n-        # Check that createrawtransaction/decoderawtransaction with non-v0 Bech32 works\n-        v1_addr = program_to_witness(1, [3, 5])\n-        v1_tx = self.nodes[0].createrawtransaction([getutxo(spendable_txid[0])], {v1_addr: 1})\n-        v1_decoded = self.nodes[1].decoderawtransaction(v1_tx)\n-        assert_equal(v1_decoded['vout'][0]['scriptPubKey']['address'], v1_addr)\n-        assert_equal(v1_decoded['vout'][0]['scriptPubKey']['hex'], \"51020305\")\n-\n-        # Check that spendable outputs are really spendable\n-        self.create_and_mine_tx_from_txids(spendable_txid)\n-\n-        # import all the private keys so solvable addresses become spendable\n-        self.nodes[0].importprivkey(\"cPiM8Ub4heR9NBYmgVzJQiUH1if44GSBGiqaeJySuL2BKxubvgwb\")\n-        self.nodes[0].importprivkey(\"cPpAdHaD6VoYbW78kveN2bsvb45Q7G5PhaPApVUGwvF8VQ9brD97\")\n-        self.nodes[0].importprivkey(\"91zqCU5B9sdWxzMt1ca3VzbtVm2YM6Hi5Rxn4UDtxEaN9C9nzXV\")\n-        self.nodes[0].importprivkey(\"cPQFjcVRpAUBG8BA9hzr2yEzHwKoMgLkJZBBtK9vJnvGJgMjzTbd\")\n-        self.nodes[0].importprivkey(\"cQGtcm34xiLjB1v7bkRa4V3aAc9tS2UTuBZ1UnZGeSeNy627fN66\")\n-        self.nodes[0].importprivkey(\"cTW5mR5M45vHxXkeChZdtSPozrFwFgmEvTNnanCW6wrqwaCZ1X7K\")\n-        self.create_and_mine_tx_from_txids(solvable_txid)\n-\n-        # Test that importing native P2WPKH/P2WSH scripts works\n-        for use_p2wsh in [False, True]:\n-            if use_p2wsh:\n-                scriptPubKey = \"00203a59f3f56b713fdcf5d1a57357f02c44342cbf306ffe0c4741046837bf90561a\"\n-                transaction = \"01000000000100e1f505000000002200203a59f3f56b713fdcf5d1a57357f02c44342cbf306ffe0c4741046837bf90561a00000000\"\n-            else:\n-                scriptPubKey = \"a9142f8c469c2f0084c48e11f998ffbe7efa7549f26d87\"\n-                transaction = \"01000000000100e1f5050000000017a9142f8c469c2f0084c48e11f998ffbe7efa7549f26d8700000000\"\n-\n-            self.nodes[1].importaddress(scriptPubKey, \"\", False)\n-            rawtxfund = self.nodes[1].fundrawtransaction(transaction)['hex']\n-            rawtxfund = self.nodes[1].signrawtransactionwithwallet(rawtxfund)[\"hex\"]\n-            txid = self.nodes[1].sendrawtransaction(rawtxfund)\n-\n-            assert_equal(self.nodes[1].gettransaction(txid, True)[\"txid\"], txid)\n-            assert_equal(self.nodes[1].listtransactions(\"*\", 1, 0, True)[0][\"txid\"], txid)\n-\n-            # Assert it is properly saved\n-            self.restart_node(1)\n-            assert_equal(self.nodes[1].gettransaction(txid, True)[\"txid\"], txid)\n-            assert_equal(self.nodes[1].listtransactions(\"*\", 1, 0, True)[0][\"txid\"], txid)\n+        if not self.options.descriptors:\n+            self.log.info(\"Verify behaviour of importaddress and listunspent\")\n+\n+            # Some public keys to be used later\n+            pubkeys = [\n+                \"0363D44AABD0F1699138239DF2F042C3282C0671CC7A76826A55C8203D90E39242\",  # cPiM8Ub4heR9NBYmgVzJQiUH1if44GSBGiqaeJySuL2BKxubvgwb\n+                \"02D3E626B3E616FC8662B489C123349FECBFC611E778E5BE739B257EAE4721E5BF\",  # cPpAdHaD6VoYbW78kveN2bsvb45Q7G5PhaPApVUGwvF8VQ9brD97\n+                \"04A47F2CBCEFFA7B9BCDA184E7D5668D3DA6F9079AD41E422FA5FD7B2D458F2538A62F5BD8EC85C2477F39650BD391EA6250207065B2A81DA8B009FC891E898F0E\",  # 91zqCU5B9sdWxzMt1ca3VzbtVm2YM6Hi5Rxn4UDtxEaN9C9nzXV\n+                \"02A47F2CBCEFFA7B9BCDA184E7D5668D3DA6F9079AD41E422FA5FD7B2D458F2538\",  # cPQFjcVRpAUBG8BA9hzr2yEzHwKoMgLkJZBBtK9vJnvGJgMjzTbd\n+                \"036722F784214129FEB9E8129D626324F3F6716555B603FFE8300BBCB882151228\",  # cQGtcm34xiLjB1v7bkRa4V3aAc9tS2UTuBZ1UnZGeSeNy627fN66\n+                \"0266A8396EE936BF6D99D17920DB21C6C7B1AB14C639D5CD72B300297E416FD2EC\",  # cTW5mR5M45vHxXkeChZdtSPozrFwFgmEvTNnanCW6wrqwaCZ1X7K\n+                \"0450A38BD7F0AC212FEBA77354A9B036A32E0F7C81FC4E0C5ADCA7C549C4505D2522458C2D9AE3CEFD684E039194B72C8A10F9CB9D4764AB26FCC2718D421D3B84\",  # 92h2XPssjBpsJN5CqSP7v9a7cf2kgDunBC6PDFwJHMACM1rrVBJ\n+            ]\n+\n+            # Import a compressed key and an uncompressed key, generate some multisig addresses\n+            self.nodes[0].importprivkey(\"92e6XLo5jVAVwrQKPNTs93oQco8f8sDNBcpv73Dsrs397fQtFQn\")\n+            uncompressed_spendable_address = [\"mvozP4UwyGD2mGZU4D2eMvMLPB9WkMmMQu\"]\n+            self.nodes[0].importprivkey(\"cNC8eQ5dg3mFAVePDX4ddmPYpPbw41r9bm2jd1nLJT77e6RrzTRR\")\n+            compressed_spendable_address = [\"mmWQubrDomqpgSYekvsU7HWEVjLFHAakLe\"]\n+            assert not self.nodes[0].getaddressinfo(uncompressed_spendable_address[0])['iscompressed']\n+            assert self.nodes[0].getaddressinfo(compressed_spendable_address[0])['iscompressed']\n+\n+            self.nodes[0].importpubkey(pubkeys[0])\n+            compressed_solvable_address = [key_to_p2pkh(pubkeys[0])]\n+            self.nodes[0].importpubkey(pubkeys[1])\n+            compressed_solvable_address.append(key_to_p2pkh(pubkeys[1]))\n+            self.nodes[0].importpubkey(pubkeys[2])\n+            uncompressed_solvable_address = [key_to_p2pkh(pubkeys[2])]\n+\n+            spendable_anytime = []                      # These outputs should be seen anytime after importprivkey and addmultisigaddress\n+            spendable_after_importaddress = []          # These outputs should be seen after importaddress\n+            solvable_after_importaddress = []           # These outputs should be seen after importaddress but not spendable\n+            unsolvable_after_importaddress = []         # These outputs should be unsolvable after importaddress\n+            solvable_anytime = []                       # These outputs should be solvable after importpubkey\n+            unseen_anytime = []                         # These outputs should never be seen\n+\n+            uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], compressed_spendable_address[0]])['address'])\n+            uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], uncompressed_spendable_address[0]])['address'])\n+            compressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_spendable_address[0]])['address'])\n+            uncompressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], uncompressed_solvable_address[0]])['address'])\n+            compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_solvable_address[0]])['address'])\n+            compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_solvable_address[0], compressed_solvable_address[1]])['address'])\n+\n+            # Test multisig_without_privkey\n+            # We have 2 public keys without private keys, use addmultisigaddress to add to wallet.\n+            # Money sent to P2SH of multisig of this should only be seen after importaddress with the BASE58 P2SH address.\n+\n+            multisig_without_privkey_address = self.nodes[0].addmultisigaddress(2, [pubkeys[3], pubkeys[4]])['address']\n+            script = CScript([OP_2, bytes.fromhex(pubkeys[3]), bytes.fromhex(pubkeys[4]), OP_2, OP_CHECKMULTISIG])\n+            solvable_after_importaddress.append(script_to_p2sh_script(script))\n+\n+            for i in compressed_spendable_address:\n+                v = self.nodes[0].getaddressinfo(i)\n+                if v['isscript']:\n+                    [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n+                    # p2sh multisig with compressed keys should always be spendable\n+                    spendable_anytime.extend([p2sh])\n+                    # bare multisig can be watched and signed, but is not treated as ours\n+                    solvable_after_importaddress.extend([bare])\n+                    # P2WSH and P2SH(P2WSH) multisig with compressed keys are spendable after direct importaddress\n+                    spendable_after_importaddress.extend([p2wsh, p2sh_p2wsh])\n+                else:\n+                    [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n+                    # normal P2PKH and P2PK with compressed keys should always be spendable\n+                    spendable_anytime.extend([p2pkh, p2pk])\n+                    # P2SH_P2PK, P2SH_P2PKH with compressed keys are spendable after direct importaddress\n+                    spendable_after_importaddress.extend([p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n+                    # P2WPKH and P2SH_P2WPKH with compressed keys should always be spendable\n+                    spendable_anytime.extend([p2wpkh, p2sh_p2wpkh])\n+\n+            for i in uncompressed_spendable_address:\n+                v = self.nodes[0].getaddressinfo(i)\n+                if v['isscript']:\n+                    [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n+                    # p2sh multisig with uncompressed keys should always be spendable\n+                    spendable_anytime.extend([p2sh])\n+                    # bare multisig can be watched and signed, but is not treated as ours\n+                    solvable_after_importaddress.extend([bare])\n+                    # P2WSH and P2SH(P2WSH) multisig with uncompressed keys are never seen\n+                    unseen_anytime.extend([p2wsh, p2sh_p2wsh])\n+                else:\n+                    [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n+                    # normal P2PKH and P2PK with uncompressed keys should always be spendable\n+                    spendable_anytime.extend([p2pkh, p2pk])\n+                    # P2SH_P2PK and P2SH_P2PKH are spendable after direct importaddress\n+                    spendable_after_importaddress.extend([p2sh_p2pk, p2sh_p2pkh])\n+                    # Witness output types with uncompressed keys are never seen\n+                    unseen_anytime.extend([p2wpkh, p2sh_p2wpkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n+\n+            for i in compressed_solvable_address:\n+                v = self.nodes[0].getaddressinfo(i)\n+                if v['isscript']:\n+                    # Multisig without private is not seen after addmultisigaddress, but seen after importaddress\n+                    [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n+                    solvable_after_importaddress.extend([bare, p2sh, p2wsh, p2sh_p2wsh])\n+                else:\n+                    [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n+                    # normal P2PKH, P2PK, P2WPKH and P2SH_P2WPKH with compressed keys should always be seen\n+                    solvable_anytime.extend([p2pkh, p2pk, p2wpkh, p2sh_p2wpkh])\n+                    # P2SH_P2PK, P2SH_P2PKH with compressed keys are seen after direct importaddress\n+                    solvable_after_importaddress.extend([p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n+\n+            for i in uncompressed_solvable_address:\n+                v = self.nodes[0].getaddressinfo(i)\n+                if v['isscript']:\n+                    [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n+                    # Base uncompressed multisig without private is not seen after addmultisigaddress, but seen after importaddress\n+                    solvable_after_importaddress.extend([bare, p2sh])\n+                    # P2WSH and P2SH(P2WSH) multisig with uncompressed keys are never seen\n+                    unseen_anytime.extend([p2wsh, p2sh_p2wsh])\n+                else:\n+                    [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n+                    # normal P2PKH and P2PK with uncompressed keys should always be seen\n+                    solvable_anytime.extend([p2pkh, p2pk])\n+                    # P2SH_P2PK, P2SH_P2PKH with uncompressed keys are seen after direct importaddress\n+                    solvable_after_importaddress.extend([p2sh_p2pk, p2sh_p2pkh])\n+                    # Witness output types with uncompressed keys are never seen\n+                    unseen_anytime.extend([p2wpkh, p2sh_p2wpkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n+\n+            op1 = CScript([OP_1])\n+            op0 = CScript([OP_0])\n+            # 2N7MGY19ti4KDMSzRfPAssP6Pxyuxoi6jLe is the P2SH(P2PKH) version of mjoE3sSrb8ByYEvgnC3Aox86u1CHnfJA4V\n+            unsolvable_address_key = bytes.fromhex(\"02341AEC7587A51CDE5279E0630A531AEA2615A9F80B17E8D9376327BAEAA59E3D\")\n+            unsolvablep2pkh = key_to_p2pkh_script(unsolvable_address_key)\n+            unsolvablep2wshp2pkh = script_to_p2wsh_script(unsolvablep2pkh)\n+            p2shop0 = script_to_p2sh_script(op0)\n+            p2wshop1 = script_to_p2wsh_script(op1)\n+            unsolvable_after_importaddress.append(unsolvablep2pkh)\n+            unsolvable_after_importaddress.append(unsolvablep2wshp2pkh)\n+            unsolvable_after_importaddress.append(op1)  # OP_1 will be imported as script\n+            unsolvable_after_importaddress.append(p2wshop1)\n+            unseen_anytime.append(op0)  # OP_0 will be imported as P2SH address with no script provided\n+            unsolvable_after_importaddress.append(p2shop0)\n+\n+            spendable_txid = []\n+            solvable_txid = []\n+            spendable_txid.append(self.mine_and_test_listunspent(spendable_anytime, 2))\n+            solvable_txid.append(self.mine_and_test_listunspent(solvable_anytime, 1))\n+            self.mine_and_test_listunspent(spendable_after_importaddress + solvable_after_importaddress + unseen_anytime + unsolvable_after_importaddress, 0)\n+\n+            importlist = []\n+            for i in compressed_spendable_address + uncompressed_spendable_address + compressed_solvable_address + uncompressed_solvable_address:\n+                v = self.nodes[0].getaddressinfo(i)\n+                if v['isscript']:\n+                    bare = bytes.fromhex(v['hex'])\n+                    importlist.append(bare.hex())\n+                    importlist.append(script_to_p2wsh_script(bare).hex())\n+                else:\n+                    pubkey = bytes.fromhex(v['pubkey'])\n+                    p2pk = key_to_p2pk_script(pubkey)\n+                    p2pkh = key_to_p2pkh_script(pubkey)\n+                    importlist.append(p2pk.hex())\n+                    importlist.append(p2pkh.hex())\n+                    importlist.append(key_to_p2wpkh_script(pubkey).hex())\n+                    importlist.append(script_to_p2wsh_script(p2pk).hex())\n+                    importlist.append(script_to_p2wsh_script(p2pkh).hex())\n+\n+            importlist.append(unsolvablep2pkh.hex())\n+            importlist.append(unsolvablep2wshp2pkh.hex())\n+            importlist.append(op1.hex())\n+            importlist.append(p2wshop1.hex())\n+\n+            for i in importlist:\n+                # import all generated addresses. The wallet already has the private keys for some of these, so catch JSON RPC\n+                # exceptions and continue.\n+                try_rpc(-4, \"The wallet already contains the private key for this address or script\", self.nodes[0].importaddress, i, \"\", False, True)\n+\n+            self.nodes[0].importaddress(script_to_p2sh(op0))  # import OP_0 as address only\n+            self.nodes[0].importaddress(multisig_without_privkey_address)  # Test multisig_without_privkey\n+\n+            spendable_txid.append(self.mine_and_test_listunspent(spendable_anytime + spendable_after_importaddress, 2))\n+            solvable_txid.append(self.mine_and_test_listunspent(solvable_anytime + solvable_after_importaddress, 1))\n+            self.mine_and_test_listunspent(unsolvable_after_importaddress, 1)\n+            self.mine_and_test_listunspent(unseen_anytime, 0)\n+\n+            spendable_txid.append(self.mine_and_test_listunspent(spendable_anytime + spendable_after_importaddress, 2))\n+            solvable_txid.append(self.mine_and_test_listunspent(solvable_anytime + solvable_after_importaddress, 1))\n+            self.mine_and_test_listunspent(unsolvable_after_importaddress, 1)\n+            self.mine_and_test_listunspent(unseen_anytime, 0)\n+\n+            # Repeat some tests. This time we don't add witness scripts with importaddress\n+            # Import a compressed key and an uncompressed key, generate some multisig addresses\n+            self.nodes[0].importprivkey(\"927pw6RW8ZekycnXqBQ2JS5nPyo1yRfGNN8oq74HeddWSpafDJH\")\n+            uncompressed_spendable_address = [\"mguN2vNSCEUh6rJaXoAVwY3YZwZvEmf5xi\"]\n+            self.nodes[0].importprivkey(\"cMcrXaaUC48ZKpcyydfFo8PxHAjpsYLhdsp6nmtB3E2ER9UUHWnw\")\n+            compressed_spendable_address = [\"n1UNmpmbVUJ9ytXYXiurmGPQ3TRrXqPWKL\"]\n+\n+            self.nodes[0].importpubkey(pubkeys[5])\n+            compressed_solvable_address = [key_to_p2pkh(pubkeys[5])]\n+            self.nodes[0].importpubkey(pubkeys[6])\n+            uncompressed_solvable_address = [key_to_p2pkh(pubkeys[6])]\n+\n+            unseen_anytime = []                         # These outputs should never be seen\n+            solvable_anytime = []                       # These outputs should be solvable after importpubkey\n+            unseen_anytime = []                         # These outputs should never be seen\n+\n+            uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], compressed_spendable_address[0]])['address'])\n+            uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], uncompressed_spendable_address[0]])['address'])\n+            compressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_spendable_address[0]])['address'])\n+            uncompressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_solvable_address[0], uncompressed_solvable_address[0]])['address'])\n+            compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_solvable_address[0]])['address'])\n+\n+            premature_witaddress = []\n+\n+            for i in compressed_spendable_address:\n+                v = self.nodes[0].getaddressinfo(i)\n+                if v['isscript']:\n+                    [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n+                    premature_witaddress.append(script_to_p2sh(p2wsh))\n+                else:\n+                    [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n+                    # P2WPKH, P2SH_P2WPKH are always spendable\n+                    spendable_anytime.extend([p2wpkh, p2sh_p2wpkh])\n+\n+            for i in uncompressed_spendable_address + uncompressed_solvable_address:\n+                v = self.nodes[0].getaddressinfo(i)\n+                if v['isscript']:\n+                    [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n+                    # P2WSH and P2SH(P2WSH) multisig with uncompressed keys are never seen\n+                    unseen_anytime.extend([p2wsh, p2sh_p2wsh])\n+                else:\n+                    [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n+                    # P2WPKH, P2SH_P2WPKH with uncompressed keys are never seen\n+                    unseen_anytime.extend([p2wpkh, p2sh_p2wpkh])\n+\n+            for i in compressed_solvable_address:\n+                v = self.nodes[0].getaddressinfo(i)\n+                if v['isscript']:\n+                    [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n+                    premature_witaddress.append(script_to_p2sh(p2wsh))\n+                else:\n+                    [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n+                    # P2SH_P2PK, P2SH_P2PKH with compressed keys are always solvable\n+                    solvable_anytime.extend([p2wpkh, p2sh_p2wpkh])\n+\n+            self.mine_and_test_listunspent(spendable_anytime, 2)\n+            self.mine_and_test_listunspent(solvable_anytime, 1)\n+            self.mine_and_test_listunspent(unseen_anytime, 0)\n+\n+            # Check that createrawtransaction/decoderawtransaction with non-v0 Bech32 works\n+            v1_addr = program_to_witness(1, [3, 5])\n+            v1_tx = self.nodes[0].createrawtransaction([getutxo(spendable_txid[0])], {v1_addr: 1})\n+            v1_decoded = self.nodes[1].decoderawtransaction(v1_tx)\n+            assert_equal(v1_decoded['vout'][0]['scriptPubKey']['address'], v1_addr)\n+            assert_equal(v1_decoded['vout'][0]['scriptPubKey']['hex'], \"51020305\")\n+\n+            # Check that spendable outputs are really spendable\n+            self.create_and_mine_tx_from_txids(spendable_txid)\n+\n+            # import all the private keys so solvable addresses become spendable\n+            self.nodes[0].importprivkey(\"cPiM8Ub4heR9NBYmgVzJQiUH1if44GSBGiqaeJySuL2BKxubvgwb\")\n+            self.nodes[0].importprivkey(\"cPpAdHaD6VoYbW78kveN2bsvb45Q7G5PhaPApVUGwvF8VQ9brD97\")\n+            self.nodes[0].importprivkey(\"91zqCU5B9sdWxzMt1ca3VzbtVm2YM6Hi5Rxn4UDtxEaN9C9nzXV\")\n+            self.nodes[0].importprivkey(\"cPQFjcVRpAUBG8BA9hzr2yEzHwKoMgLkJZBBtK9vJnvGJgMjzTbd\")\n+            self.nodes[0].importprivkey(\"cQGtcm34xiLjB1v7bkRa4V3aAc9tS2UTuBZ1UnZGeSeNy627fN66\")\n+            self.nodes[0].importprivkey(\"cTW5mR5M45vHxXkeChZdtSPozrFwFgmEvTNnanCW6wrqwaCZ1X7K\")\n+            self.create_and_mine_tx_from_txids(solvable_txid)\n+\n+            # Test that importing native P2WPKH/P2WSH scripts works\n+            for use_p2wsh in [False, True]:\n+                if use_p2wsh:\n+                    scriptPubKey = \"00203a59f3f56b713fdcf5d1a57357f02c44342cbf306ffe0c4741046837bf90561a\"\n+                    transaction = \"01000000000100e1f505000000002200203a59f3f56b713fdcf5d1a57357f02c44342cbf306ffe0c4741046837bf90561a00000000\"\n+                else:\n+                    scriptPubKey = \"a9142f8c469c2f0084c48e11f998ffbe7efa7549f26d87\"\n+                    transaction = \"01000000000100e1f5050000000017a9142f8c469c2f0084c48e11f998ffbe7efa7549f26d8700000000\"\n+\n+                self.nodes[1].importaddress(scriptPubKey, \"\", False)\n+                rawtxfund = self.nodes[1].fundrawtransaction(transaction)['hex']\n+                rawtxfund = self.nodes[1].signrawtransactionwithwallet(rawtxfund)[\"hex\"]\n+                txid = self.nodes[1].sendrawtransaction(rawtxfund)\n+\n+                assert_equal(self.nodes[1].gettransaction(txid, True)[\"txid\"], txid)\n+                assert_equal(self.nodes[1].listtransactions(\"*\", 1, 0, True)[0][\"txid\"], txid)\n+\n+                # Assert it is properly saved\n+                self.restart_node(1)\n+                assert_equal(self.nodes[1].gettransaction(txid, True)[\"txid\"], txid)\n+                assert_equal(self.nodes[1].listtransactions(\"*\", 1, 0, True)[0][\"txid\"], txid)\n \n     def mine_and_test_listunspent(self, script_list, ismine):\n         utxo = find_spendable_utxo(self.nodes[0], 50)"
      }
    ]
  },
  {
    "sha": "e9ade032f3283971025943d750b1305bc8da56fc",
    "node_id": "C_kwDOABII59oAKGU5YWRlMDMyZjMyODM5NzEwMjU5NDNkNzUwYjEzMDViYzhkYTU2ZmM",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-19T22:43:18Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-19T22:43:18Z"
      },
      "message": "tests: Add feature_segwit.py --descriptors to test_runner.py",
      "tree": {
        "sha": "dd7bb2cf0fcd387e49f9baea8659d474d48b4a75",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dd7bb2cf0fcd387e49f9baea8659d474d48b4a75"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e9ade032f3283971025943d750b1305bc8da56fc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9ade032f3283971025943d750b1305bc8da56fc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e9ade032f3283971025943d750b1305bc8da56fc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9ade032f3283971025943d750b1305bc8da56fc/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ae6cbcc90926b65099ed8747e7a13a4aefba787a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ae6cbcc90926b65099ed8747e7a13a4aefba787a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ae6cbcc90926b65099ed8747e7a13a4aefba787a"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "916cd94b79d26010898a11c55952965da03ccf67",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e9ade032f3283971025943d750b1305bc8da56fc/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e9ade032f3283971025943d750b1305bc8da56fc/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=e9ade032f3283971025943d750b1305bc8da56fc",
        "patch": "@@ -100,6 +100,7 @@\n     'p2p_compactblocks.py',\n     'p2p_compactblocks_blocksonly.py',\n     'feature_segwit.py --legacy-wallet',\n+    'feature_segwit.py --descriptors',\n     # vv Tests less than 2m vv\n     'wallet_basic.py --legacy-wallet',\n     'wallet_basic.py --descriptors',"
      }
    ]
  }
]