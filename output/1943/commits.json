[
  {
    "sha": "b5d5f44c95b1010bd6fa53d0a87abd4d6389df8b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNWQ1ZjQ0Yzk1YjEwMTBiZDZmYTUzZDBhODdhYmQ0ZDYzODlkZjhi",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-27T19:01:57Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-11-09T00:06:06Z"
      },
      "message": "Add CBufferedFile",
      "tree": {
        "sha": "b5b4ab23127e67feaae54a17efddc836dcdfe1d4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b5b4ab23127e67feaae54a17efddc836dcdfe1d4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b5d5f44c95b1010bd6fa53d0a87abd4d6389df8b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b5d5f44c95b1010bd6fa53d0a87abd4d6389df8b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b5d5f44c95b1010bd6fa53d0a87abd4d6389df8b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b5d5f44c95b1010bd6fa53d0a87abd4d6389df8b/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "16d9d61f99c2e081585e6634d25da3523804eabf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/16d9d61f99c2e081585e6634d25da3523804eabf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/16d9d61f99c2e081585e6634d25da3523804eabf"
      }
    ],
    "stats": {
      "total": 144,
      "additions": 144,
      "deletions": 0
    },
    "files": [
      {
        "sha": "9e14666faccf311968dc1681824befcde23dc28d",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 144,
        "deletions": 0,
        "changes": 144,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b5d5f44c95b1010bd6fa53d0a87abd4d6389df8b/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b5d5f44c95b1010bd6fa53d0a87abd4d6389df8b/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=b5d5f44c95b1010bd6fa53d0a87abd4d6389df8b",
        "patch": "@@ -1225,4 +1225,148 @@ class CAutoFile\n     }\n };\n \n+/** Wrapper around a FILE* that implements a ring buffer to\n+ *  deserialize from. It guarantees the ability to rewind\n+ *  a given number of bytes. */\n+class CBufferedFile\n+{\n+private:\n+    FILE *src;          // source file\n+    uint64 nSrcPos;     // how many bytes have been read from source\n+    uint64 nReadPos;    // how many bytes have been read from this\n+    uint64 nReadLimit;  // up to which position we're allowed to read\n+    uint64 nRewind;     // how many bytes we guarantee to rewind\n+    std::vector<char> vchBuf; // the buffer\n+\n+    short state;\n+    short exceptmask;\n+\n+protected:\n+    void setstate(short bits, const char *psz) {\n+        state |= bits;\n+        if (state & exceptmask)\n+            throw std::ios_base::failure(psz);\n+    }\n+\n+    // read data from the source to fill the buffer\n+    bool Fill() {\n+        unsigned int pos = nSrcPos % vchBuf.size();\n+        unsigned int readNow = vchBuf.size() - pos;\n+        unsigned int nAvail = vchBuf.size() - (nSrcPos - nReadPos) - nRewind;\n+        if (nAvail < readNow)\n+            readNow = nAvail;\n+        if (readNow == 0)\n+            return false;\n+        size_t read = fread((void*)&vchBuf[pos], 1, readNow, src);\n+        if (read == 0) {\n+            setstate(std::ios_base::failbit, feof(src) ? \"CBufferedFile::Fill : end of file\" : \"CBufferedFile::Fill : fread failed\");\n+            return false;\n+        } else {\n+            nSrcPos += read;\n+            return true;\n+        }\n+    }\n+\n+public:\n+    int nType;\n+    int nVersion;\n+\n+    CBufferedFile(FILE *fileIn, uint64 nBufSize, uint64 nRewindIn, int nTypeIn, int nVersionIn) :\n+        src(fileIn), nSrcPos(0), nReadPos(0), nReadLimit((uint64)(-1)), nRewind(nRewindIn), vchBuf(nBufSize, 0),\n+        state(0), exceptmask(std::ios_base::badbit | std::ios_base::failbit), nType(nTypeIn), nVersion(nVersionIn) {\n+    }\n+\n+    // check whether no error occurred\n+    bool good() const {\n+        return state == 0;\n+    }\n+\n+    // check whether we're at the end of the source file\n+    bool eof() const {\n+        return nReadPos == nSrcPos && feof(src);\n+    }\n+\n+    // read a number of bytes\n+    CBufferedFile& read(char *pch, size_t nSize) {\n+        if (nSize + nReadPos > nReadLimit)\n+            throw std::ios_base::failure(\"Read attempted past buffer limit\");\n+        if (nSize + nRewind > vchBuf.size())\n+            throw std::ios_base::failure(\"Read larger than buffer size\");\n+        while (nSize > 0) {\n+            if (nReadPos == nSrcPos)\n+                Fill();\n+            unsigned int pos = nReadPos % vchBuf.size();\n+            size_t nNow = nSize;\n+            if (nNow + pos > vchBuf.size())\n+                nNow = vchBuf.size() - pos;\n+            if (nNow + nReadPos > nSrcPos)\n+                nNow = nSrcPos - nReadPos;\n+            memcpy(pch, &vchBuf[pos], nNow);\n+            nReadPos += nNow;\n+            pch += nNow;\n+            nSize -= nNow;\n+        }\n+        return (*this);\n+    }\n+\n+    // return the current reading position\n+    uint64 GetPos() {\n+        return nReadPos;\n+    }\n+\n+    // rewind to a given reading position\n+    bool SetPos(uint64 nPos) {\n+        nReadPos = nPos;\n+        if (nReadPos + nRewind < nSrcPos) {\n+            nReadPos = nSrcPos - nRewind;\n+            return false;\n+        } else if (nReadPos > nSrcPos) {\n+            nReadPos = nSrcPos;\n+            return false;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    bool Seek(uint64 nPos) {\n+        long nLongPos = nPos;\n+        if (nPos != (uint64)nLongPos)\n+            return false;\n+        if (fseek(src, nLongPos, SEEK_SET))\n+            return false;\n+        nLongPos = ftell(src);\n+        nSrcPos = nLongPos;\n+        nReadPos = nLongPos;\n+        state = 0;\n+        return true;\n+    }\n+\n+    // prevent reading beyond a certain position\n+    // no argument removes the limit\n+    bool SetLimit(uint64 nPos = (uint64)(-1)) {\n+        if (nPos < nReadPos)\n+            return false;\n+        nReadLimit = nPos;\n+        return true;\n+    }\n+\n+    template<typename T>\n+    CBufferedFile& operator>>(T& obj) {\n+        // Unserialize from this stream\n+        ::Unserialize(*this, obj, nType, nVersion);\n+        return (*this);\n+    }\n+\n+    // search for a given byte in the stream, and remain positioned on it\n+    void FindByte(char ch) {\n+        while (true) {\n+            if (nReadPos == nSrcPos)\n+                Fill();\n+            if (vchBuf[nReadPos % vchBuf.size()] == ch)\n+                break;\n+            nReadPos++;\n+        }\n+    }\n+};\n+\n #endif"
      }
    ]
  },
  {
    "sha": "05d9726805969ff155e8a029579113f05529ea82",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNWQ5NzI2ODA1OTY5ZmYxNTVlOGEwMjk1NzkxMTNmMDU1MjllYTgy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-27T20:01:38Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-11-09T00:06:06Z"
      },
      "message": "LoadExternalBlockFile switched to CBufferedFile",
      "tree": {
        "sha": "15ad2a43d50a9d15ec86ae3e40a323f361f82756",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/15ad2a43d50a9d15ec86ae3e40a323f361f82756"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/05d9726805969ff155e8a029579113f05529ea82",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05d9726805969ff155e8a029579113f05529ea82",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/05d9726805969ff155e8a029579113f05529ea82",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05d9726805969ff155e8a029579113f05529ea82/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b5d5f44c95b1010bd6fa53d0a87abd4d6389df8b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b5d5f44c95b1010bd6fa53d0a87abd4d6389df8b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b5d5f44c95b1010bd6fa53d0a87abd4d6389df8b"
      }
    ],
    "stats": {
      "total": 65,
      "additions": 25,
      "deletions": 40
    },
    "files": [
      {
        "sha": "7a9a32a6265cbe970cc523aa39ba880617d52ab1",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 40,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/05d9726805969ff155e8a029579113f05529ea82/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/05d9726805969ff155e8a029579113f05529ea82/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=05d9726805969ff155e8a029579113f05529ea82",
        "patch": "@@ -2493,55 +2493,40 @@ bool LoadExternalBlockFile(FILE* fileIn)\n \n     int nLoaded = 0;\n     {\n-        try {\n-            CAutoFile blkdat(fileIn, SER_DISK, CLIENT_VERSION);\n-            unsigned int nPos = 0;\n-            while (nPos != (unsigned int)-1 && blkdat.good() && !fRequestShutdown)\n-            {\n-                unsigned char pchData[65536];\n-                do {\n-                    fseek(blkdat, nPos, SEEK_SET);\n-                    int nRead = fread(pchData, 1, sizeof(pchData), blkdat);\n-                    if (nRead <= 8)\n-                    {\n-                        nPos = (unsigned int)-1;\n-                        break;\n-                    }\n-                    void* nFind = memchr(pchData, pchMessageStart[0], nRead+1-sizeof(pchMessageStart));\n-                    if (nFind)\n-                    {\n-                        if (memcmp(nFind, pchMessageStart, sizeof(pchMessageStart))==0)\n-                        {\n-                            nPos += ((unsigned char*)nFind - pchData) + sizeof(pchMessageStart);\n-                            break;\n-                        }\n-                        nPos += ((unsigned char*)nFind - pchData) + 1;\n-                    }\n-                    else\n-                        nPos += sizeof(pchData) - sizeof(pchMessageStart) + 1;\n-                } while(!fRequestShutdown);\n-                if (nPos == (unsigned int)-1)\n-                    break;\n-                fseek(blkdat, nPos, SEEK_SET);\n+        CBufferedFile blkdat(fileIn, 2*MAX_BLOCK_SIZE, MAX_BLOCK_SIZE+8, SER_DISK, CLIENT_VERSION);\n+        uint64 nRewind = blkdat.GetPos();\n+        while (blkdat.good() && !blkdat.eof() && !fShutdown) {\n+            blkdat.SetPos(nRewind);\n+            nRewind++; // start one byte further next time, in case of failure\n+            blkdat.SetLimit(); // remove former limit\n+            try {\n+                // locate a header\n+                unsigned char buf[4];\n+                blkdat.FindByte(pchMessageStart[0]);\n+                nRewind = blkdat.GetPos()+1;\n+                blkdat >> FLATDATA(buf);\n+                if (memcmp(buf, pchMessageStart, 4))\n+                    continue;\n+                // read size\n                 unsigned int nSize;\n                 blkdat >> nSize;\n-                if (nSize > 0 && nSize <= MAX_BLOCK_SIZE)\n+                if (nSize < 80 || nSize > MAX_BLOCK_SIZE)\n+                    continue;\n+                // read block\n+                blkdat.SetLimit(blkdat.GetPos() + nSize);\n+                CBlock block;\n+                blkdat >> block;\n+                nRewind = blkdat.GetPos();\n                 {\n-                    CBlock block;\n-                    blkdat >> block;\n                     LOCK(cs_main);\n                     if (ProcessBlock(NULL,&block))\n-                    {\n                         nLoaded++;\n-                        nPos += 4 + nSize;\n-                    }\n                 }\n+            } catch (std::exception &e) {\n+                printf(\"%s() : Deserialize or I/O error caught during load\\n\", __PRETTY_FUNCTION__);\n             }\n         }\n-        catch (std::exception &e) {\n-            printf(\"%s() : Deserialize or I/O error caught during load\\n\",\n-                   __PRETTY_FUNCTION__);\n-        }\n+        fclose(fileIn);\n     }\n     printf(\"Loaded %i blocks from external file in %\"PRI64d\"ms\\n\", nLoaded, GetTimeMillis() - nStart);\n     return nLoaded > 0;"
      }
    ]
  },
  {
    "sha": "7a5b7535bf3b987c5e2157f25c8b3246033d952e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YTViNzUzNWJmM2I5ODdjNWUyMTU3ZjI1YzhiMzI0NjAzM2Q5NTJl",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-22T20:45:26Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-11-09T00:06:32Z"
      },
      "message": "Move ThreadImport to init.cpp",
      "tree": {
        "sha": "540a9fc5dd1996546818a10f9e61e02cbccf5c31",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/540a9fc5dd1996546818a10f9e61e02cbccf5c31"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7a5b7535bf3b987c5e2157f25c8b3246033d952e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a5b7535bf3b987c5e2157f25c8b3246033d952e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7a5b7535bf3b987c5e2157f25c8b3246033d952e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a5b7535bf3b987c5e2157f25c8b3246033d952e/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "05d9726805969ff155e8a029579113f05529ea82",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05d9726805969ff155e8a029579113f05529ea82",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/05d9726805969ff155e8a029579113f05529ea82"
      }
    ],
    "stats": {
      "total": 89,
      "additions": 45,
      "deletions": 44
    },
    "files": [
      {
        "sha": "6fa8586426953dd9110ed5f27791ff143e46190e",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a5b7535bf3b987c5e2157f25c8b3246033d952e/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a5b7535bf3b987c5e2157f25c8b3246033d952e/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=7a5b7535bf3b987c5e2157f25c8b3246033d952e",
        "patch": "@@ -310,6 +310,50 @@ std::string HelpMessage()\n }\n \n \n+struct CImportingNow\n+{\n+    CImportingNow() {\n+        assert(fImporting == false);\n+        fImporting = true;\n+    }\n+\n+    ~CImportingNow() {\n+        assert(fImporting == true);\n+        fImporting = false;\n+    }\n+};\n+\n+void ThreadImport(void *data) {\n+    std::vector<boost::filesystem::path> *vFiles = reinterpret_cast<std::vector<boost::filesystem::path>*>(data);\n+\n+    RenameThread(\"bitcoin-loadblk\");\n+\n+    CImportingNow imp;\n+    vnThreadsRunning[THREAD_IMPORT]++;\n+\n+    // -loadblock=\n+    BOOST_FOREACH(boost::filesystem::path &path, *vFiles) {\n+        FILE *file = fopen(path.string().c_str(), \"rb\");\n+        if (file)\n+            LoadExternalBlockFile(file);\n+    }\n+\n+    // hardcoded $DATADIR/bootstrap.dat\n+    filesystem::path pathBootstrap = GetDataDir() / \"bootstrap.dat\";\n+    if (filesystem::exists(pathBootstrap)) {\n+        FILE *file = fopen(pathBootstrap.string().c_str(), \"rb\");\n+        if (file) {\n+            filesystem::path pathBootstrapOld = GetDataDir() / \"bootstrap.dat.old\";\n+            LoadExternalBlockFile(file);\n+            RenameOver(pathBootstrap, pathBootstrapOld);\n+        }\n+    }\n+\n+    delete vFiles;\n+\n+    vnThreadsRunning[THREAD_IMPORT]--;\n+}\n+\n /** Initialize bitcoin.\n  *  @pre Parameters should be parsed and config file should be read.\n  */"
      },
      {
        "sha": "64adae8eddbb19d1c7ca3533be14c7b547b5b5c5",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 44,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a5b7535bf3b987c5e2157f25c8b3246033d952e/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a5b7535bf3b987c5e2157f25c8b3246033d952e/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=7a5b7535bf3b987c5e2157f25c8b3246033d952e",
        "patch": "@@ -2532,50 +2532,6 @@ bool LoadExternalBlockFile(FILE* fileIn)\n     return nLoaded > 0;\n }\n \n-struct CImportingNow\n-{\n-    CImportingNow() {\n-        assert(fImporting == false);\n-        fImporting = true;\n-    }\n-\n-    ~CImportingNow() {\n-        assert(fImporting == true);\n-        fImporting = false;\n-    }\n-};\n-\n-void ThreadImport(void *data) {\n-    std::vector<boost::filesystem::path> *vFiles = reinterpret_cast<std::vector<boost::filesystem::path>*>(data);\n-\n-    RenameThread(\"bitcoin-loadblk\");\n-\n-    CImportingNow imp;\n-    vnThreadsRunning[THREAD_IMPORT]++;\n-\n-    // -loadblock=\n-    BOOST_FOREACH(boost::filesystem::path &path, *vFiles) {\n-        FILE *file = fopen(path.string().c_str(), \"rb\");\n-        if (file)\n-            LoadExternalBlockFile(file);\n-    }\n-\n-    // hardcoded $DATADIR/bootstrap.dat\n-    filesystem::path pathBootstrap = GetDataDir() / \"bootstrap.dat\";\n-    if (filesystem::exists(pathBootstrap)) {\n-        FILE *file = fopen(pathBootstrap.string().c_str(), \"rb\");\n-        if (file) {\n-            filesystem::path pathBootstrapOld = GetDataDir() / \"bootstrap.dat.old\";\n-            LoadExternalBlockFile(file);\n-            RenameOver(pathBootstrap, pathBootstrapOld);\n-        }\n-    }\n-\n-    delete vFiles;\n-\n-    vnThreadsRunning[THREAD_IMPORT]--;\n-}\n-\n \n \n "
      },
      {
        "sha": "c2ecefa8f0040d1267a7bba390b7e8099da23674",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a5b7535bf3b987c5e2157f25c8b3246033d952e/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a5b7535bf3b987c5e2157f25c8b3246033d952e/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=7a5b7535bf3b987c5e2157f25c8b3246033d952e",
        "patch": "@@ -113,6 +113,7 @@ bool ProcessBlock(CNode* pfrom, CBlock* pblock);\n bool CheckDiskSpace(uint64 nAdditionalBytes=0);\n FILE* OpenBlockFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n+bool LoadExternalBlockFile(FILE* fileIn);\n bool LoadBlockIndex(bool fAllowNew=true);\n void PrintBlockTree();\n CBlockIndex* FindBlockByHeight(int nHeight);"
      }
    ]
  },
  {
    "sha": "7fea48467442079cd0b4021b580761d7e33fa8a1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZmVhNDg0Njc0NDIwNzljZDBiNDAyMWI1ODA3NjFkN2UzM2ZhOGEx",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-21T19:23:13Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-11-09T00:06:32Z"
      },
      "message": "Add -reindex, to perform in-place reindexing of block chain files\n\nFlushes the blktree/ and coins/ databases, and reindexes the\nblock chain files, as if their contents was loaded via -loadblock.\n\nBased on earlier work by Jeff Garzik.",
      "tree": {
        "sha": "b750e95c08a92a39df49a3325c1f124a3e2c7744",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b750e95c08a92a39df49a3325c1f124a3e2c7744"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7fea48467442079cd0b4021b580761d7e33fa8a1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7fea48467442079cd0b4021b580761d7e33fa8a1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7fea48467442079cd0b4021b580761d7e33fa8a1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7fea48467442079cd0b4021b580761d7e33fa8a1/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7a5b7535bf3b987c5e2157f25c8b3246033d952e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a5b7535bf3b987c5e2157f25c8b3246033d952e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7a5b7535bf3b987c5e2157f25c8b3246033d952e"
      }
    ],
    "stats": {
      "total": 277,
      "additions": 202,
      "deletions": 75
    },
    "files": [
      {
        "sha": "22e78a9d6946888ed93dd792d1a86ecdc05d7316",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 14,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7fea48467442079cd0b4021b580761d7e33fa8a1/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7fea48467442079cd0b4021b580761d7e33fa8a1/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=7fea48467442079cd0b4021b580761d7e33fa8a1",
        "patch": "@@ -294,6 +294,7 @@ std::string HelpMessage()\n         \"  -checkblocks=<n>       \" + _(\"How many blocks to check at startup (default: 2500, 0 = all)\") + \"\\n\" +\n         \"  -checklevel=<n>        \" + _(\"How thorough the block verification is (0-6, default: 1)\") + \"\\n\" +\n         \"  -loadblock=<file>      \" + _(\"Imports blocks from external blk000?.dat file\") + \"\\n\" +\n+        \"  -reindex               \" + _(\"Rebuild blockchain index from current blk000??.dat files\") + \"\\n\" +\n \n         \"\\n\" + _(\"Block creation options:\") + \"\\n\" +\n         \"  -blockminsize=<n>      \"   + _(\"Set minimum block size in bytes (default: 0)\") + \"\\n\" +\n@@ -323,33 +324,65 @@ struct CImportingNow\n     }\n };\n \n+struct CImportData {\n+    std::vector<boost::filesystem::path> vFiles;\n+};\n+\n void ThreadImport(void *data) {\n-    std::vector<boost::filesystem::path> *vFiles = reinterpret_cast<std::vector<boost::filesystem::path>*>(data);\n+    CImportData *import = reinterpret_cast<CImportData*>(data);\n \n     RenameThread(\"bitcoin-loadblk\");\n \n-    CImportingNow imp;\n     vnThreadsRunning[THREAD_IMPORT]++;\n \n-    // -loadblock=\n-    BOOST_FOREACH(boost::filesystem::path &path, *vFiles) {\n-        FILE *file = fopen(path.string().c_str(), \"rb\");\n-        if (file)\n-            LoadExternalBlockFile(file);\n+    // -reindex\n+    if (fReindex) {\n+        CImportingNow imp;\n+        int nFile = 0;\n+        while (!fShutdown) {\n+            CDiskBlockPos pos;\n+            pos.nFile = nFile;\n+            pos.nPos = 0;\n+            FILE *file = OpenBlockFile(pos, true);\n+            if (!file)\n+                break;\n+            printf(\"Reindexing block file blk%05u.dat...\\n\", (unsigned int)nFile);\n+            LoadExternalBlockFile(file, &pos);\n+            nFile++;\n+        }\n+        if (!fShutdown) {\n+            pblocktree->WriteReindexing(false);\n+            fReindex = false;\n+            printf(\"Reindexing finished\\n\");\n+        }\n     }\n \n     // hardcoded $DATADIR/bootstrap.dat\n     filesystem::path pathBootstrap = GetDataDir() / \"bootstrap.dat\";\n-    if (filesystem::exists(pathBootstrap)) {\n+    if (filesystem::exists(pathBootstrap) && !fShutdown) {\n         FILE *file = fopen(pathBootstrap.string().c_str(), \"rb\");\n         if (file) {\n+            CImportingNow imp;\n             filesystem::path pathBootstrapOld = GetDataDir() / \"bootstrap.dat.old\";\n+            printf(\"Importing bootstrap.dat...\\n\");\n             LoadExternalBlockFile(file);\n             RenameOver(pathBootstrap, pathBootstrapOld);\n         }\n     }\n \n-    delete vFiles;\n+    // -loadblock=\n+    BOOST_FOREACH(boost::filesystem::path &path, import->vFiles) {\n+        if (fShutdown)\n+            break;\n+        FILE *file = fopen(path.string().c_str(), \"rb\");\n+        if (file) {\n+            CImportingNow imp;\n+            printf(\"Importing %s...\\n\", path.string().c_str());\n+            LoadExternalBlockFile(file);\n+        }\n+    }\n+\n+    delete import;\n \n     vnThreadsRunning[THREAD_IMPORT]--;\n }\n@@ -686,6 +719,8 @@ bool AppInit2()\n \n     // ********************************************************* Step 7: load block chain\n \n+    fReindex = GetBoolArg(\"-reindex\");\n+\n     if (!bitdb.Open(GetDataDir()))\n     {\n         string msg = strprintf(_(\"Error initializing database environment %s!\"\n@@ -709,10 +744,13 @@ bool AppInit2()\n     uiInterface.InitMessage(_(\"Loading block index...\"));\n     printf(\"Loading block index...\\n\");\n     nStart = GetTimeMillis();\n-    pblocktree = new CBlockTreeDB(nBlockTreeDBCache);\n-    pcoinsdbview = new CCoinsViewDB(nCoinDBCache);\n+    pblocktree = new CBlockTreeDB(nBlockTreeDBCache, false, fReindex);\n+    pcoinsdbview = new CCoinsViewDB(nCoinDBCache, false, fReindex);\n     pcoinsTip = new CCoinsViewCache(*pcoinsdbview);\n \n+    if (fReindex)\n+        pblocktree->WriteReindexing(true);\n+\n     if (!LoadBlockIndex())\n         return InitError(_(\"Error loading blkindex.dat\"));\n \n@@ -845,13 +883,13 @@ bool AppInit2()\n     if (!ConnectBestBlock())\n         strErrors << \"Failed to connect best block\";\n \n-    std::vector<boost::filesystem::path> *vPath = new std::vector<boost::filesystem::path>();\n+    CImportData *pimport = new CImportData();\n     if (mapArgs.count(\"-loadblock\"))\n     {\n         BOOST_FOREACH(string strFile, mapMultiArgs[\"-loadblock\"])\n-            vPath->push_back(strFile);\n+            pimport->vFiles.push_back(strFile);\n     }\n-    NewThread(ThreadImport, vPath);\n+    NewThread(ThreadImport, pimport);\n \n     // ********************************************************* Step 10: load peers\n "
      },
      {
        "sha": "9e2f32a171c3b43d622475ea69844ad916b53a76",
        "filename": "src/leveldb.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7fea48467442079cd0b4021b580761d7e33fa8a1/src/leveldb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7fea48467442079cd0b4021b580761d7e33fa8a1/src/leveldb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb.cpp?ref=7fea48467442079cd0b4021b580761d7e33fa8a1",
        "patch": "@@ -21,7 +21,7 @@ static leveldb::Options GetOptions(size_t nCacheSize) {\n     return options;\n }\n \n-CLevelDB::CLevelDB(const boost::filesystem::path &path, size_t nCacheSize, bool fMemory) {\n+CLevelDB::CLevelDB(const boost::filesystem::path &path, size_t nCacheSize, bool fMemory, bool fWipe) {\n     penv = NULL;\n     readoptions.verify_checksums = true;\n     iteroptions.verify_checksums = true;\n@@ -33,6 +33,10 @@ CLevelDB::CLevelDB(const boost::filesystem::path &path, size_t nCacheSize, bool\n         penv = leveldb::NewMemEnv(leveldb::Env::Default());\n         options.env = penv;\n     } else {\n+        if (fWipe) {\n+            printf(\"Wiping LevelDB in %s\\n\", path.string().c_str());\n+            leveldb::DestroyDB(path.string(), options);\n+        }\n         boost::filesystem::create_directory(path);\n         printf(\"Opening LevelDB in %s\\n\", path.string().c_str());\n     }"
      },
      {
        "sha": "0b834320720ab0f245b5498dfcca04ba628df43e",
        "filename": "src/leveldb.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7fea48467442079cd0b4021b580761d7e33fa8a1/src/leveldb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7fea48467442079cd0b4021b580761d7e33fa8a1/src/leveldb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb.h?ref=7fea48467442079cd0b4021b580761d7e33fa8a1",
        "patch": "@@ -69,7 +69,7 @@ class CLevelDB\n     leveldb::DB *pdb;\n \n public:\n-    CLevelDB(const boost::filesystem::path &path, size_t nCacheSize, bool fMemory = false);\n+    CLevelDB(const boost::filesystem::path &path, size_t nCacheSize, bool fMemory = false, bool fWipe = false);\n     ~CLevelDB();\n \n     template<typename K, typename V> bool Read(const K& key, V& value) {"
      },
      {
        "sha": "0940260f9e1611f11ce6f6274c7d4f811cee2b28",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 89,
        "deletions": 43,
        "changes": 132,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7fea48467442079cd0b4021b580761d7e33fa8a1/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7fea48467442079cd0b4021b580761d7e33fa8a1/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=7fea48467442079cd0b4021b580761d7e33fa8a1",
        "patch": "@@ -41,6 +41,7 @@ CBlockIndex* pindexBest = NULL;\n set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexValid; // may contain all CBlockIndex*'s that have validness >=BLOCK_VALID_TRANSACTIONS, and must contain those who aren't failed\n int64 nTimeBestReceived = 0;\n bool fImporting = false;\n+bool fReindex = false;\n unsigned int nCoinCacheSize = 5000;\n \n CMedianFilter<int> cPeerBlockCounts(5, 0); // Amount of blocks that other nodes claim to have\n@@ -1145,7 +1146,7 @@ int GetNumBlocksOfPeers()\n \n bool IsInitialBlockDownload()\n {\n-    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n+    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate() || fReindex || fImporting)\n         return true;\n     static int64 nLastUpdate;\n     static CBlockIndex* pindexLastBest;\n@@ -1862,35 +1863,45 @@ bool CBlock::AddToBlockIndex(const CDiskBlockPos &pos)\n }\n \n \n-bool FindBlockPos(CDiskBlockPos &pos, unsigned int nAddSize, unsigned int nHeight, uint64 nTime)\n+bool FindBlockPos(CDiskBlockPos &pos, unsigned int nAddSize, unsigned int nHeight, uint64 nTime, bool fKnown = false)\n {\n     bool fUpdatedLast = false;\n \n     LOCK(cs_LastBlockFile);\n \n-    while (infoLastBlockFile.nSize + nAddSize >= MAX_BLOCKFILE_SIZE) {\n-        printf(\"Leaving block file %i: %s\\n\", nLastBlockFile, infoLastBlockFile.ToString().c_str());\n-        FlushBlockFile();\n-        nLastBlockFile++;\n-        infoLastBlockFile.SetNull();\n-        pblocktree->ReadBlockFileInfo(nLastBlockFile, infoLastBlockFile); // check whether data for the new file somehow already exist; can fail just fine\n-        fUpdatedLast = true;\n+    if (fKnown) {\n+        if (nLastBlockFile != pos.nFile) {\n+            nLastBlockFile = pos.nFile;\n+            infoLastBlockFile.SetNull();\n+            pblocktree->ReadBlockFileInfo(nLastBlockFile, infoLastBlockFile);\n+        }\n+    } else {\n+        while (infoLastBlockFile.nSize + nAddSize >= MAX_BLOCKFILE_SIZE) {\n+            printf(\"Leaving block file %i: %s\\n\", nLastBlockFile, infoLastBlockFile.ToString().c_str());\n+            FlushBlockFile();\n+            nLastBlockFile++;\n+            infoLastBlockFile.SetNull();\n+            pblocktree->ReadBlockFileInfo(nLastBlockFile, infoLastBlockFile); // check whether data for the new file somehow already exist; can fail just fine\n+            fUpdatedLast = true;\n+        }\n+        pos.nFile = nLastBlockFile;\n+        pos.nPos = infoLastBlockFile.nSize;\n     }\n \n-    pos.nFile = nLastBlockFile;\n-    pos.nPos = infoLastBlockFile.nSize;\n     infoLastBlockFile.nSize += nAddSize;\n     infoLastBlockFile.AddBlock(nHeight, nTime);\n \n-    unsigned int nOldChunks = (pos.nPos + BLOCKFILE_CHUNK_SIZE - 1) / BLOCKFILE_CHUNK_SIZE;\n-    unsigned int nNewChunks = (infoLastBlockFile.nSize + BLOCKFILE_CHUNK_SIZE - 1) / BLOCKFILE_CHUNK_SIZE;\n-    if (nNewChunks > nOldChunks) {\n-        FILE *file = OpenBlockFile(pos);\n-        if (file) {\n-            printf(\"Pre-allocating up to position 0x%x in blk%05u.dat\\n\", nNewChunks * BLOCKFILE_CHUNK_SIZE, pos.nFile);\n-            AllocateFileRange(file, pos.nPos, nNewChunks * BLOCKFILE_CHUNK_SIZE - pos.nPos);\n+    if (!fKnown) {\n+        unsigned int nOldChunks = (pos.nPos + BLOCKFILE_CHUNK_SIZE - 1) / BLOCKFILE_CHUNK_SIZE;\n+        unsigned int nNewChunks = (infoLastBlockFile.nSize + BLOCKFILE_CHUNK_SIZE - 1) / BLOCKFILE_CHUNK_SIZE;\n+        if (nNewChunks > nOldChunks) {\n+            FILE *file = OpenBlockFile(pos);\n+            if (file) {\n+                printf(\"Pre-allocating up to position 0x%x in blk%05u.dat\\n\", nNewChunks * BLOCKFILE_CHUNK_SIZE, pos.nFile);\n+                AllocateFileRange(file, pos.nPos, nNewChunks * BLOCKFILE_CHUNK_SIZE - pos.nPos);\n+            }\n+            fclose(file);\n         }\n-        fclose(file);\n     }\n \n     if (!pblocktree->WriteBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n@@ -1996,19 +2007,23 @@ bool CBlock::CheckBlock(bool fCheckPOW, bool fCheckMerkleRoot) const\n     return true;\n }\n \n-bool CBlock::AcceptBlock()\n+bool CBlock::AcceptBlock(CDiskBlockPos *dbp)\n {\n     // Check for duplicate\n     uint256 hash = GetHash();\n     if (mapBlockIndex.count(hash))\n         return error(\"AcceptBlock() : block already in mapBlockIndex\");\n \n     // Get prev block index\n+    CBlockIndex* pindexPrev = NULL;\n+    int nHeight = 0;\n+    if (hash != hashGenesisBlock) {\n+\n     map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);\n     if (mi == mapBlockIndex.end())\n         return DoS(10, error(\"AcceptBlock() : prev block not found\"));\n-    CBlockIndex* pindexPrev = (*mi).second;\n-    int nHeight = pindexPrev->nHeight+1;\n+    pindexPrev = (*mi).second;\n+    nHeight = pindexPrev->nHeight+1;\n \n     // Check proof of work\n     if (nBits != GetNextWorkRequired(pindexPrev, this))\n@@ -2048,16 +2063,22 @@ bool CBlock::AcceptBlock()\n                 return DoS(100, error(\"AcceptBlock() : block height mismatch in coinbase\"));\n         }\n     }\n+    }\n \n     // Write block to history file\n     unsigned int nBlockSize = ::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION);\n-    if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))\n-        return error(\"AcceptBlock() : out of disk space\");\n     CDiskBlockPos blockPos;\n-    if (!FindBlockPos(blockPos, nBlockSize+8, nHeight, nTime))\n+    if (dbp == NULL) {\n+        if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))\n+            return error(\"AcceptBlock() : out of disk space\");\n+    } else {\n+        blockPos = *dbp;\n+    }\n+    if (!FindBlockPos(blockPos, nBlockSize+8, nHeight, nTime, dbp != NULL))\n         return error(\"AcceptBlock() : FindBlockPos failed\");\n-    if (!WriteToDisk(blockPos))\n-        return error(\"AcceptBlock() : WriteToDisk failed\");\n+    if (dbp == NULL)\n+        if (!WriteToDisk(blockPos))\n+            return error(\"AcceptBlock() : WriteToDisk failed\");\n     if (!AddToBlockIndex(blockPos))\n         return error(\"AcceptBlock() : AddToBlockIndex failed\");\n \n@@ -2086,7 +2107,7 @@ bool CBlockIndex::IsSuperMajority(int minVersion, const CBlockIndex* pstart, uns\n     return (nFound >= nRequired);\n }\n \n-bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n+bool ProcessBlock(CNode* pfrom, CBlock* pblock, CDiskBlockPos *dbp)\n {\n     // Check for duplicate\n     uint256 hash = pblock->GetHash();\n@@ -2124,7 +2145,7 @@ bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n \n \n     // If we don't already have its previous block, shunt it off to holding area until we get it\n-    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n+    if (pblock->hashPrevBlock != 0 && !mapBlockIndex.count(pblock->hashPrevBlock))\n     {\n         printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n \n@@ -2141,7 +2162,7 @@ bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n     }\n \n     // Store to disk\n-    if (!pblock->AcceptBlock())\n+    if (!pblock->AcceptBlock(dbp))\n         return error(\"ProcessBlock() : AcceptBlock FAILED\");\n \n     // Recursively process any orphan blocks that depended on this one\n@@ -2304,6 +2325,11 @@ bool static LoadBlockIndexDB()\n     // Load bnBestInvalidWork, OK if it doesn't exist\n     pblocktree->ReadBestInvalidWork(bnBestInvalidWork);\n \n+    // Check whether we need to continue reindexing\n+    bool fReindexing = false;\n+    pblocktree->ReadReindexing(fReindexing);\n+    fReindex |= fReindexing;\n+\n     // Verify blocks in the best chain\n     int nCheckLevel = GetArg(\"-checklevel\", 1);\n     int nCheckDepth = GetArg( \"-checkblocks\", 2500);\n@@ -2337,7 +2363,7 @@ bool static LoadBlockIndexDB()\n     return true;\n }\n \n-bool LoadBlockIndex(bool fAllowNew)\n+bool LoadBlockIndex()\n {\n     if (fTestNet)\n     {\n@@ -2348,6 +2374,9 @@ bool LoadBlockIndex(bool fAllowNew)\n         hashGenesisBlock = uint256(\"000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943\");\n     }\n \n+    if (fReindex)\n+        return true;\n+\n     //\n     // Load block index from databases\n     //\n@@ -2359,9 +2388,6 @@ bool LoadBlockIndex(bool fAllowNew)\n     //\n     if (mapBlockIndex.empty())\n     {\n-        if (!fAllowNew)\n-            return false;\n-\n         // Genesis Block:\n         // CBlock(hash=000000000019d6, ver=1, hashPrevBlock=00000000000000, hashMerkleRoot=4a5e1e, nTime=1231006505, nBits=1d00ffff, nNonce=2083236893, vtx=1)\n         //   CTransaction(hash=4a5e1e, ver=1, vin.size=1, vout.size=1, nLockTime=0)\n@@ -2487,18 +2513,28 @@ void PrintBlockTree()\n     }\n }\n \n-bool LoadExternalBlockFile(FILE* fileIn)\n+bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n {\n     int64 nStart = GetTimeMillis();\n \n     int nLoaded = 0;\n     {\n         CBufferedFile blkdat(fileIn, 2*MAX_BLOCK_SIZE, MAX_BLOCK_SIZE+8, SER_DISK, CLIENT_VERSION);\n+        uint64 nStartByte = 0;\n+        if (dbp) {\n+            // (try to) skip already indexed part\n+            CBlockFileInfo info;\n+            if (pblocktree->ReadBlockFileInfo(dbp->nFile, info)) {\n+                nStartByte = info.nSize;\n+                blkdat.Seek(info.nSize);\n+            }\n+        }\n         uint64 nRewind = blkdat.GetPos();\n         while (blkdat.good() && !blkdat.eof() && !fShutdown) {\n             blkdat.SetPos(nRewind);\n             nRewind++; // start one byte further next time, in case of failure\n             blkdat.SetLimit(); // remove former limit\n+            unsigned int nSize = 0;\n             try {\n                 // locate a header\n                 unsigned char buf[4];\n@@ -2508,18 +2544,27 @@ bool LoadExternalBlockFile(FILE* fileIn)\n                 if (memcmp(buf, pchMessageStart, 4))\n                     continue;\n                 // read size\n-                unsigned int nSize;\n                 blkdat >> nSize;\n                 if (nSize < 80 || nSize > MAX_BLOCK_SIZE)\n                     continue;\n+            } catch (std::exception &e) {\n+                // no valid block header found; don't complain\n+                break;\n+            }\n+            try {\n                 // read block\n-                blkdat.SetLimit(blkdat.GetPos() + nSize);\n+                uint64 nBlockPos = blkdat.GetPos();\n+                blkdat.SetLimit(nBlockPos + nSize);\n                 CBlock block;\n                 blkdat >> block;\n                 nRewind = blkdat.GetPos();\n-                {\n+\n+                // process block\n+                if (nBlockPos >= nStartByte) {\n                     LOCK(cs_main);\n-                    if (ProcessBlock(NULL,&block))\n+                    if (dbp)\n+                        dbp->nPos = nBlockPos;\n+                    if (ProcessBlock(NULL, &block, dbp))\n                         nLoaded++;\n                 }\n             } catch (std::exception &e) {\n@@ -2528,7 +2573,8 @@ bool LoadExternalBlockFile(FILE* fileIn)\n         }\n         fclose(fileIn);\n     }\n-    printf(\"Loaded %i blocks from external file in %\"PRI64d\"ms\\n\", nLoaded, GetTimeMillis() - nStart);\n+    if (nLoaded > 0)\n+        printf(\"Loaded %i blocks from external file in %\"PRI64d\"ms\\n\", nLoaded, GetTimeMillis() - nStart);\n     return nLoaded > 0;\n }\n \n@@ -2741,7 +2787,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n         // Ask the first connected node for block updates\n         static int nAskedForBlocks = 0;\n-        if (!pfrom->fClient && !pfrom->fOneShot && !fImporting &&\n+        if (!pfrom->fClient && !pfrom->fOneShot && !fImporting && !fReindex &&\n             (pfrom->nStartingHeight > (nBestHeight - 144)) &&\n             (pfrom->nVersion < NOBLKS_VERSION_START ||\n              pfrom->nVersion >= NOBLKS_VERSION_END) &&\n@@ -2878,7 +2924,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                 printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n \n             if (!fAlreadyHave) {\n-                if (!fImporting)\n+                if (!fImporting && !fReindex)\n                     pfrom->AskFor(inv);\n             } else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n                 pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n@@ -3108,7 +3154,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n     }\n \n \n-    else if (strCommand == \"block\")\n+    else if (strCommand == \"block\" && !fImporting && !fReindex) // Ignore blocks received while importing\n     {\n         CBlock block;\n         vRecv >> block;"
      },
      {
        "sha": "25dddae0f8f7bd58cea42b38e0a341f982e8ee55",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7fea48467442079cd0b4021b580761d7e33fa8a1/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7fea48467442079cd0b4021b580761d7e33fa8a1/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=7fea48467442079cd0b4021b580761d7e33fa8a1",
        "patch": "@@ -88,6 +88,7 @@ extern CCriticalSection cs_setpwalletRegistered;\n extern std::set<CWallet*> setpwalletRegistered;\n extern unsigned char pchMessageStart[4];\n extern bool fImporting;\n+extern bool fReindex;\n extern unsigned int nCoinCacheSize;\n \n // Settings\n@@ -109,12 +110,12 @@ class CCoinsViewCache;\n void RegisterWallet(CWallet* pwalletIn);\n void UnregisterWallet(CWallet* pwalletIn);\n void SyncWithWallets(const uint256 &hash, const CTransaction& tx, const CBlock* pblock = NULL, bool fUpdate = false);\n-bool ProcessBlock(CNode* pfrom, CBlock* pblock);\n+bool ProcessBlock(CNode* pfrom, CBlock* pblock, CDiskBlockPos *dbp = NULL);\n bool CheckDiskSpace(uint64 nAdditionalBytes=0);\n FILE* OpenBlockFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n-bool LoadExternalBlockFile(FILE* fileIn);\n-bool LoadBlockIndex(bool fAllowNew=true);\n+bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp = NULL);\n+bool LoadBlockIndex();\n void PrintBlockTree();\n CBlockIndex* FindBlockByHeight(int nHeight);\n bool ProcessMessages(CNode* pfrom);\n@@ -1262,7 +1263,8 @@ class CBlock\n     bool CheckBlock(bool fCheckPOW=true, bool fCheckMerkleRoot=true) const;\n \n     // Store block on disk\n-    bool AcceptBlock();\n+    // if dbp is provided, the file is known to already reside on disk\n+    bool AcceptBlock(CDiskBlockPos *dbp = NULL);\n };\n \n "
      },
      {
        "sha": "9c47daf85d8f680a2c6e02f87715edb27960b908",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 4,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7fea48467442079cd0b4021b580761d7e33fa8a1/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7fea48467442079cd0b4021b580761d7e33fa8a1/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=7fea48467442079cd0b4021b580761d7e33fa8a1",
        "patch": "@@ -489,7 +489,8 @@ void BitcoinGUI::setNumBlocks(int count, int nTotalBlocks)\n     statusBar()->clearMessage();\n \n     // don't show / hide progress bar and its label if we have no connection to the network\n-    if (!clientModel || (clientModel->getNumConnections() == 0 && !clientModel->isImporting()))\n+    enum BlockSource blockSource = clientModel ? clientModel->getBlockSource() : BLOCK_SOURCE_NONE;\n+    if (blockSource == BLOCK_SOURCE_NONE || (blockSource == BLOCK_SOURCE_NETWORK && clientModel->getNumConnections() == 0))\n     {\n         progressBarLabel->setVisible(false);\n         progressBar->setVisible(false);\n@@ -499,26 +500,37 @@ void BitcoinGUI::setNumBlocks(int count, int nTotalBlocks)\n \n     QString tooltip;\n \n+    QString importText;\n+    switch (blockSource) {\n+    case BLOCK_SOURCE_NONE:\n+    case BLOCK_SOURCE_NETWORK:\n+        importText = tr(\"Synchronizing with network...\");\n+    case BLOCK_SOURCE_DISK:\n+        importText = tr(\"Importing blocks from disk...\");\n+    case BLOCK_SOURCE_REINDEX:\n+        importText = tr(\"Reindexing blocks on disk...\");\n+    }\n+\n     if(count < nTotalBlocks)\n     {\n         int nRemainingBlocks = nTotalBlocks - count;\n         float nPercentageDone = count / (nTotalBlocks * 0.01f);\n \n-        progressBarLabel->setText(tr(clientModel->isImporting() ? \"Importing blocks...\" : \"Synchronizing with network...\"));\n+        progressBarLabel->setText(importText);\n         progressBarLabel->setVisible(true);\n         progressBar->setFormat(tr(\"~%n block(s) remaining\", \"\", nRemainingBlocks));\n         progressBar->setMaximum(nTotalBlocks);\n         progressBar->setValue(count);\n         progressBar->setVisible(true);\n \n-        tooltip = tr(\"Downloaded %1 of %2 blocks of transaction history (%3% done).\").arg(count).arg(nTotalBlocks).arg(nPercentageDone, 0, 'f', 2);\n+        tooltip = tr(\"Processed %1 of %2 blocks of transaction history (%3% done).\").arg(count).arg(nTotalBlocks).arg(nPercentageDone, 0, 'f', 2);\n     }\n     else\n     {\n         progressBarLabel->setVisible(false);\n \n         progressBar->setVisible(false);\n-        tooltip = tr(\"Downloaded %1 blocks of transaction history.\").arg(count);\n+        tooltip = tr(\"Processed %1 blocks of transaction history.\").arg(count);\n     }\n \n     QDateTime lastBlockDate = clientModel->getLastBlockDate();"
      },
      {
        "sha": "9b7362d7571cbc9c432f3e9f0085cfb0984d4194",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7fea48467442079cd0b4021b580761d7e33fa8a1/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7fea48467442079cd0b4021b580761d7e33fa8a1/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=7fea48467442079cd0b4021b580761d7e33fa8a1",
        "patch": "@@ -101,9 +101,13 @@ bool ClientModel::inInitialBlockDownload() const\n     return IsInitialBlockDownload();\n }\n \n-bool ClientModel::isImporting() const\n+enum BlockSource ClientModel::getBlockSource() const\n {\n-    return fImporting;\n+    if (fReindex)\n+        return BLOCK_SOURCE_REINDEX;\n+    if (fImporting)\n+        return BLOCK_SOURCE_DISK;\n+    return BLOCK_SOURCE_NETWORK;\n }\n \n int ClientModel::getNumBlocksOfPeers() const"
      },
      {
        "sha": "7d6401ab25749b0081ee7e840c8583b2e27287c6",
        "filename": "src/qt/clientmodel.h",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7fea48467442079cd0b4021b580761d7e33fa8a1/src/qt/clientmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7fea48467442079cd0b4021b580761d7e33fa8a1/src/qt/clientmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.h?ref=7fea48467442079cd0b4021b580761d7e33fa8a1",
        "patch": "@@ -13,6 +13,13 @@ class QDateTime;\n class QTimer;\n QT_END_NAMESPACE\n \n+enum BlockSource {\n+    BLOCK_SOURCE_NONE,\n+    BLOCK_SOURCE_NETWORK,\n+    BLOCK_SOURCE_DISK,\n+    BLOCK_SOURCE_REINDEX\n+};\n+\n /** Model for Bitcoin network client. */\n class ClientModel : public QObject\n {\n@@ -34,7 +41,7 @@ class ClientModel : public QObject\n     //! Return true if core is doing initial block download\n     bool inInitialBlockDownload() const;\n     //! Return true if core is importing blocks\n-    bool isImporting() const;\n+    enum BlockSource getBlockSource() const;\n     //! Return conservative estimate of total number of blocks, or 0 if unknown\n     int getNumBlocksOfPeers() const;\n     //! Return warnings to be displayed in status bar"
      },
      {
        "sha": "c8a565af3a899d7343f51153c31022b94d391239",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7fea48467442079cd0b4021b580761d7e33fa8a1/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7fea48467442079cd0b4021b580761d7e33fa8a1/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=7fea48467442079cd0b4021b580761d7e33fa8a1",
        "patch": "@@ -22,7 +22,7 @@ struct TestingSetup {\n         pblocktree = new CBlockTreeDB(true);\n         pcoinsdbview = new CCoinsViewDB(true);\n         pcoinsTip = new CCoinsViewCache(*pcoinsdbview);\n-        LoadBlockIndex(true);\n+        LoadBlockIndex();\n         bool fFirstRun;\n         pwalletMain = new CWallet(\"wallet.dat\");\n         pwalletMain->LoadWallet(fFirstRun);"
      },
      {
        "sha": "93c5f23d8b3d8fe32a9944e678367f0b942c7b6e",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 2,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7fea48467442079cd0b4021b580761d7e33fa8a1/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7fea48467442079cd0b4021b580761d7e33fa8a1/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=7fea48467442079cd0b4021b580761d7e33fa8a1",
        "patch": "@@ -19,7 +19,7 @@ void static BatchWriteHashBestChain(CLevelDBBatch &batch, const uint256 &hash) {\n     batch.Write('B', hash);\n }\n \n-CCoinsViewDB::CCoinsViewDB(size_t nCacheSize, bool fMemory) : db(GetDataDir() / \"coins\", nCacheSize, fMemory) {\n+CCoinsViewDB::CCoinsViewDB(size_t nCacheSize, bool fMemory, bool fWipe) : db(GetDataDir() / \"coins\", nCacheSize, fMemory, fWipe) {\n }\n \n bool CCoinsViewDB::GetCoins(uint256 txid, CCoins &coins) { \n@@ -64,7 +64,7 @@ bool CCoinsViewDB::BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockI\n     return db.WriteBatch(batch);\n }\n \n-CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory) : CLevelDB(GetDataDir() / \"blktree\", nCacheSize, fMemory) {\n+CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory, bool fWipe) : CLevelDB(GetDataDir() / \"blktree\", nCacheSize, fMemory, fWipe) {\n }\n \n bool CBlockTreeDB::WriteBlockIndex(const CDiskBlockIndex& blockindex)\n@@ -94,6 +94,18 @@ bool CBlockTreeDB::WriteLastBlockFile(int nFile) {\n     return Write('l', nFile);\n }\n \n+bool CBlockTreeDB::WriteReindexing(bool fReindexing) {\n+    if (fReindexing)\n+        return Write('R', '1');\n+    else\n+        return Erase('R');\n+}\n+\n+bool CBlockTreeDB::ReadReindexing(bool &fReindexing) {\n+    fReindexing = Exists('R');\n+    return true;\n+}\n+\n bool CBlockTreeDB::ReadLastBlockFile(int &nFile) {\n     return Read('l', nFile);\n }"
      },
      {
        "sha": "d7d327069fc6fcb070640b4c83d2de5b75e12174",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7fea48467442079cd0b4021b580761d7e33fa8a1/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7fea48467442079cd0b4021b580761d7e33fa8a1/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=7fea48467442079cd0b4021b580761d7e33fa8a1",
        "patch": "@@ -14,7 +14,7 @@ class CCoinsViewDB : public CCoinsView\n protected:\n     CLevelDB db;\n public:\n-    CCoinsViewDB(size_t nCacheSize, bool fMemory = false);\n+    CCoinsViewDB(size_t nCacheSize, bool fMemory = false, bool fWipe = false);\n \n     bool GetCoins(uint256 txid, CCoins &coins);\n     bool SetCoins(uint256 txid, const CCoins &coins);\n@@ -29,7 +29,7 @@ class CCoinsViewDB : public CCoinsView\n class CBlockTreeDB : public CLevelDB\n {\n public:\n-    CBlockTreeDB(size_t nCacheSize, bool fMemory = false);\n+    CBlockTreeDB(size_t nCacheSize, bool fMemory = false, bool fWipe = false);\n private:\n     CBlockTreeDB(const CBlockTreeDB&);\n     void operator=(const CBlockTreeDB&);\n@@ -41,6 +41,8 @@ class CBlockTreeDB : public CLevelDB\n     bool WriteBlockFileInfo(int nFile, const CBlockFileInfo &fileinfo);\n     bool ReadLastBlockFile(int &nFile);\n     bool WriteLastBlockFile(int nFile);\n+    bool WriteReindexing(bool fReindex);\n+    bool ReadReindexing(bool &fReindex);\n     bool LoadBlockIndexGuts();\n };\n "
      }
    ]
  }
]