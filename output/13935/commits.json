[
  {
    "sha": "a9910d82c3750e422c886a68a2cb24211db84ec6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphOTkxMGQ4MmMzNzUwZTQyMmM4ODZhNjhhMmNiMjQyMTFkYjg0ZWM2",
    "commit": {
      "author": {
        "name": "Akio Nakamura",
        "email": "nakamura@dgtechnologies.co.jp",
        "date": "2018-08-06T11:22:31Z"
      },
      "committer": {
        "name": "Akio Nakamura",
        "email": "nakamura@dgtechnologies.co.jp",
        "date": "2018-08-27T11:14:47Z"
      },
      "message": "contrib: Adjust output to current test format\n\nAjust the outputs of gen_base58_test_vectors.py to current test format.\n\n1. Add bech32 vector generation.\n2. Add Script-fragments to hexrepr in the format expected by the test.\n3. Modify the metadata.\n  1) Change 'isTestnet' to 'chain' (main/test/regtest)\n  2) Remove 'addrType'\n  3) Add 'tryCaseFlip' (True/False on bech32)",
      "tree": {
        "sha": "6177449b1ae6a9ea82e2447b9f86657397ea388f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6177449b1ae6a9ea82e2447b9f86657397ea388f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a9910d82c3750e422c886a68a2cb24211db84ec6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a9910d82c3750e422c886a68a2cb24211db84ec6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a9910d82c3750e422c886a68a2cb24211db84ec6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a9910d82c3750e422c886a68a2cb24211db84ec6/comments",
    "author": {
      "login": "AkioNak",
      "id": 24285095,
      "node_id": "MDQ6VXNlcjI0Mjg1MDk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/24285095?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AkioNak",
      "html_url": "https://github.com/AkioNak",
      "followers_url": "https://api.github.com/users/AkioNak/followers",
      "following_url": "https://api.github.com/users/AkioNak/following{/other_user}",
      "gists_url": "https://api.github.com/users/AkioNak/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AkioNak/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AkioNak/subscriptions",
      "organizations_url": "https://api.github.com/users/AkioNak/orgs",
      "repos_url": "https://api.github.com/users/AkioNak/repos",
      "events_url": "https://api.github.com/users/AkioNak/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AkioNak/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "AkioNak",
      "id": 24285095,
      "node_id": "MDQ6VXNlcjI0Mjg1MDk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/24285095?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AkioNak",
      "html_url": "https://github.com/AkioNak",
      "followers_url": "https://api.github.com/users/AkioNak/followers",
      "following_url": "https://api.github.com/users/AkioNak/following{/other_user}",
      "gists_url": "https://api.github.com/users/AkioNak/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AkioNak/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AkioNak/subscriptions",
      "organizations_url": "https://api.github.com/users/AkioNak/orgs",
      "repos_url": "https://api.github.com/users/AkioNak/repos",
      "events_url": "https://api.github.com/users/AkioNak/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AkioNak/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e13a820f995606f0ed7aa74233c94c0d977e222d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e13a820f995606f0ed7aa74233c94c0d977e222d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e13a820f995606f0ed7aa74233c94c0d977e222d"
      }
    ],
    "stats": {
      "total": 385,
      "additions": 251,
      "deletions": 134
    },
    "files": [
      {
        "sha": "580ed541cf7d68ffd24287bdae78fe6484ee2da2",
        "filename": "contrib/testgen/README.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9910d82c3750e422c886a68a2cb24211db84ec6/contrib/testgen/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9910d82c3750e422c886a68a2cb24211db84ec6/contrib/testgen/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/testgen/README.md?ref=a9910d82c3750e422c886a68a2cb24211db84ec6",
        "patch": "@@ -4,5 +4,5 @@ Utilities to generate test vectors for the data-driven Bitcoin tests.\n \n Usage: \n \n-    gen_base58_test_vectors.py valid 50 > ../../src/test/data/base58_keys_valid.json\n-    gen_base58_test_vectors.py invalid 50 > ../../src/test/data/base58_keys_invalid.json\n\\ No newline at end of file\n+    PYTHONPATH=../../test/functional/test_framework ./gen_key_io_test_vectors.py valid 50 > ../../src/test/data/key_io_keys_valid.json\n+    PYTHONPATH=../../test/functional/test_framework ./gen_key_io_test_vectors.py invalid 50 > ../../src/test/data/key_io_keys_invalid.json"
      },
      {
        "sha": "c76de5ce750e3d328a83c5d407e74bf901bb9d85",
        "filename": "contrib/testgen/gen_base58_test_vectors.py",
        "status": "removed",
        "additions": 0,
        "deletions": 132,
        "changes": 132,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e13a820f995606f0ed7aa74233c94c0d977e222d/contrib/testgen/gen_base58_test_vectors.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e13a820f995606f0ed7aa74233c94c0d977e222d/contrib/testgen/gen_base58_test_vectors.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/testgen/gen_base58_test_vectors.py?ref=e13a820f995606f0ed7aa74233c94c0d977e222d",
        "patch": "@@ -1,132 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2012-2018 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-'''\n-Generate valid and invalid base58 address and private key test vectors.\n-\n-Usage:\n-    gen_base58_test_vectors.py valid 50 > ../../src/test/data/base58_keys_valid.json\n-    gen_base58_test_vectors.py invalid 50 > ../../src/test/data/base58_keys_invalid.json\n-'''\n-# 2012 Wladimir J. van der Laan\n-# Released under MIT License\n-import os\n-from itertools import islice\n-from base58 import b58encode_chk, b58decode_chk, b58chars\n-import random\n-from binascii import b2a_hex\n-\n-# key types\n-PUBKEY_ADDRESS = 0\n-SCRIPT_ADDRESS = 5\n-PUBKEY_ADDRESS_TEST = 111\n-SCRIPT_ADDRESS_TEST = 196\n-PRIVKEY = 128\n-PRIVKEY_TEST = 239\n-\n-metadata_keys = ['isPrivkey', 'isTestnet', 'addrType', 'isCompressed']\n-# templates for valid sequences\n-templates = [\n-  # prefix, payload_size, suffix, metadata\n-  #                                  None = N/A\n-  ((PUBKEY_ADDRESS,),      20, (),   (False, False, 'pubkey', None)),\n-  ((SCRIPT_ADDRESS,),      20, (),   (False, False, 'script',  None)),\n-  ((PUBKEY_ADDRESS_TEST,), 20, (),   (False, True,  'pubkey', None)),\n-  ((SCRIPT_ADDRESS_TEST,), 20, (),   (False, True,  'script',  None)),\n-  ((PRIVKEY,),             32, (),   (True,  False, None,  False)),\n-  ((PRIVKEY,),             32, (1,), (True,  False, None,  True)),\n-  ((PRIVKEY_TEST,),        32, (),   (True,  True,  None,  False)),\n-  ((PRIVKEY_TEST,),        32, (1,), (True,  True,  None,  True))\n-]\n-\n-def is_valid(v):\n-    '''Check vector v for validity'''\n-    result = b58decode_chk(v)\n-    if result is None:\n-        return False\n-    for template in templates:\n-        prefix = bytearray(template[0])\n-        suffix = bytearray(template[2])\n-        if result.startswith(prefix) and result.endswith(suffix):\n-            if (len(result) - len(prefix) - len(suffix)) == template[1]:\n-                return True\n-    return False\n-\n-def gen_valid_vectors():\n-    '''Generate valid test vectors'''\n-    while True:\n-        for template in templates:\n-            prefix = bytearray(template[0])\n-            payload = bytearray(os.urandom(template[1]))\n-            suffix = bytearray(template[2])\n-            rv = b58encode_chk(prefix + payload + suffix)\n-            assert is_valid(rv)\n-            metadata = {x: y for x, y in zip(metadata_keys,template[3]) if y is not None}\n-            hexrepr = b2a_hex(payload)\n-            if isinstance(hexrepr, bytes):\n-                hexrepr = hexrepr.decode('utf8')\n-            yield (rv, hexrepr, metadata)\n-\n-def gen_invalid_vector(template, corrupt_prefix, randomize_payload_size, corrupt_suffix):\n-    '''Generate possibly invalid vector'''\n-    if corrupt_prefix:\n-        prefix = os.urandom(1)\n-    else:\n-        prefix = bytearray(template[0])\n-\n-    if randomize_payload_size:\n-        payload = os.urandom(max(int(random.expovariate(0.5)), 50))\n-    else:\n-        payload = os.urandom(template[1])\n-\n-    if corrupt_suffix:\n-        suffix = os.urandom(len(template[2]))\n-    else:\n-        suffix = bytearray(template[2])\n-\n-    return b58encode_chk(prefix + payload + suffix)\n-\n-def randbool(p = 0.5):\n-    '''Return True with P(p)'''\n-    return random.random() < p\n-\n-def gen_invalid_vectors():\n-    '''Generate invalid test vectors'''\n-    # start with some manual edge-cases\n-    yield \"\",\n-    yield \"x\",\n-    while True:\n-        # kinds of invalid vectors:\n-        #   invalid prefix\n-        #   invalid payload length\n-        #   invalid (randomized) suffix (add random data)\n-        #   corrupt checksum\n-        for template in templates:\n-            val = gen_invalid_vector(template, randbool(0.2), randbool(0.2), randbool(0.2))\n-            if random.randint(0,10)<1: # line corruption\n-                if randbool(): # add random character to end\n-                    val += random.choice(b58chars)\n-                else: # replace random character in the middle\n-                    n = random.randint(0, len(val))\n-                    val = val[0:n] + random.choice(b58chars) + val[n+1:]\n-            if not is_valid(val):\n-                yield val,\n-\n-if __name__ == '__main__':\n-    import sys\n-    import json\n-    iters = {'valid':gen_valid_vectors, 'invalid':gen_invalid_vectors}\n-    try:\n-        uiter = iters[sys.argv[1]]\n-    except IndexError:\n-        uiter = gen_valid_vectors\n-    try:\n-        count = int(sys.argv[2])\n-    except IndexError:\n-        count = 0\n-\n-    data = list(islice(uiter(), count))\n-    json.dump(data, sys.stdout, sort_keys=True, indent=4)\n-    sys.stdout.write('\\n')\n-"
      },
      {
        "sha": "a00acb1f41fe478fd332ba1deab7729dbaf19be1",
        "filename": "contrib/testgen/gen_key_io_test_vectors.py",
        "status": "added",
        "additions": 249,
        "deletions": 0,
        "changes": 249,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9910d82c3750e422c886a68a2cb24211db84ec6/contrib/testgen/gen_key_io_test_vectors.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9910d82c3750e422c886a68a2cb24211db84ec6/contrib/testgen/gen_key_io_test_vectors.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/testgen/gen_key_io_test_vectors.py?ref=a9910d82c3750e422c886a68a2cb24211db84ec6",
        "patch": "@@ -0,0 +1,249 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2012-2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+'''\n+Generate valid and invalid base58 address and private key test vectors.\n+\n+Usage:\n+    PYTHONPATH=../../test/functional/test_framework ./gen_key_io_test_vectors.py valid 50 > ../../src/test/data/key_io_valid.json\n+    PYTHONPATH=../../test/functional/test_framework ./gen_key_io_test_vectors.py invalid 50 > ../../src/test/data/key_io_invalid.json\n+'''\n+# 2012 Wladimir J. van der Laan\n+# Released under MIT License\n+import os\n+from itertools import islice\n+from base58 import b58encode_chk, b58decode_chk, b58chars\n+import random\n+from binascii import b2a_hex\n+from segwit_addr import bech32_encode, decode, convertbits, CHARSET\n+\n+# key types\n+PUBKEY_ADDRESS = 0\n+SCRIPT_ADDRESS = 5\n+PUBKEY_ADDRESS_TEST = 111\n+SCRIPT_ADDRESS_TEST = 196\n+PUBKEY_ADDRESS_REGTEST = 111\n+SCRIPT_ADDRESS_REGTEST = 196\n+PRIVKEY = 128\n+PRIVKEY_TEST = 239\n+PRIVKEY_REGTEST = 239\n+\n+# script\n+OP_0 = 0x00\n+OP_1 = 0x51\n+OP_2 = 0x52\n+OP_16 = 0x60\n+OP_DUP = 0x76\n+OP_EQUAL = 0x87\n+OP_EQUALVERIFY = 0x88\n+OP_HASH160 = 0xa9\n+OP_CHECKSIG = 0xac\n+pubkey_prefix = (OP_DUP, OP_HASH160, 20)\n+pubkey_suffix = (OP_EQUALVERIFY, OP_CHECKSIG)\n+script_prefix = (OP_HASH160, 20)\n+script_suffix = (OP_EQUAL,)\n+p2wpkh_prefix = (OP_0, 20)\n+p2wsh_prefix = (OP_0, 32)\n+\n+metadata_keys = ['isPrivkey', 'chain', 'isCompressed', 'tryCaseFlip']\n+# templates for valid sequences\n+templates = [\n+  # prefix, payload_size, suffix, metadata, output_prefix, output_suffix\n+  #                                  None = N/A\n+  ((PUBKEY_ADDRESS,),         20, (),   (False, 'main',    None,  None), pubkey_prefix, pubkey_suffix),\n+  ((SCRIPT_ADDRESS,),         20, (),   (False, 'main',    None,  None), script_prefix, script_suffix),\n+  ((PUBKEY_ADDRESS_TEST,),    20, (),   (False, 'test',    None,  None), pubkey_prefix, pubkey_suffix),\n+  ((SCRIPT_ADDRESS_TEST,),    20, (),   (False, 'test',    None,  None), script_prefix, script_suffix),\n+  ((PUBKEY_ADDRESS_REGTEST,), 20, (),   (False, 'regtest', None,  None), pubkey_prefix, pubkey_suffix),\n+  ((SCRIPT_ADDRESS_REGTEST,), 20, (),   (False, 'regtest', None,  None), script_prefix, script_suffix),\n+  ((PRIVKEY,),                32, (),   (True,  'main',    False, None), (),            ()),\n+  ((PRIVKEY,),                32, (1,), (True,  'main',    True,  None), (),            ()),\n+  ((PRIVKEY_TEST,),           32, (),   (True,  'test',    False, None), (),            ()),\n+  ((PRIVKEY_TEST,),           32, (1,), (True,  'test',    True,  None), (),            ()),\n+  ((PRIVKEY_REGTEST,),        32, (),   (True,  'regtest', False, None), (),            ()),\n+  ((PRIVKEY_REGTEST,),        32, (1,), (True,  'regtest', True,  None), (),            ())\n+]\n+# templates for valid bech32 sequences\n+bech32_templates = [\n+  # hrp, version, witprog_size, metadata, output_prefix\n+  ('bc',    0, 20, (False, 'main',    None, True), p2wpkh_prefix),\n+  ('bc',    0, 32, (False, 'main',    None, True), p2wsh_prefix),\n+  ('bc',    1,  2, (False, 'main',    None, True), (OP_1, 2)),\n+  ('tb',    0, 20, (False, 'test',    None, True), p2wpkh_prefix),\n+  ('tb',    0, 32, (False, 'test',    None, True), p2wsh_prefix),\n+  ('tb',    2, 16, (False, 'test',    None, True), (OP_2, 16)),\n+  ('bcrt',  0, 20, (False, 'regtest', None, True), p2wpkh_prefix),\n+  ('bcrt',  0, 32, (False, 'regtest', None, True), p2wsh_prefix),\n+  ('bcrt', 16, 40, (False, 'regtest', None, True), (OP_16, 40))\n+]\n+# templates for invalid bech32 sequences\n+bech32_ng_templates = [\n+  # hrp, version, witprog_size, invalid_bech32, invalid_checksum, invalid_char\n+  ('tc',    0, 20, False, False, False),\n+  ('tb',   17, 32, False, False, False),\n+  ('bcrt',  3,  1, False, False, False),\n+  ('bc',   15, 41, False, False, False),\n+  ('tb',    0, 16, False, False, False),\n+  ('bcrt',  0, 32, True,  False, False),\n+  ('bc',    0, 16, True,  False, False),\n+  ('tb',    0, 32, False, True,  False),\n+  ('bcrt',  0, 20, False, False, True)\n+]\n+\n+def is_valid(v):\n+    '''Check vector v for validity'''\n+    if len(set(v) - set(b58chars)) > 0:\n+        return is_valid_bech32(v)\n+    result = b58decode_chk(v)\n+    if result is None:\n+        return is_valid_bech32(v)\n+    for template in templates:\n+        prefix = bytearray(template[0])\n+        suffix = bytearray(template[2])\n+        if result.startswith(prefix) and result.endswith(suffix):\n+            if (len(result) - len(prefix) - len(suffix)) == template[1]:\n+                return True\n+    return is_valid_bech32(v)\n+\n+def is_valid_bech32(v):\n+    '''Check vector v for bech32 validity'''\n+    for hrp in ['bc', 'tb', 'bcrt']:\n+        if decode(hrp, v) != (None, None):\n+            return True\n+    return False\n+\n+def gen_valid_base58_vector(template):\n+    '''Generate valid base58 vector'''\n+    prefix = bytearray(template[0])\n+    payload = bytearray(os.urandom(template[1]))\n+    suffix = bytearray(template[2])\n+    dst_prefix = bytearray(template[4])\n+    dst_suffix = bytearray(template[5])\n+    rv = b58encode_chk(prefix + payload + suffix)\n+    return rv, dst_prefix + payload + dst_suffix\n+\n+def gen_valid_bech32_vector(template):\n+    '''Generate valid bech32 vector'''\n+    hrp = template[0]\n+    witver = template[1]\n+    witprog = bytearray(os.urandom(template[2]))\n+    dst_prefix = bytearray(template[4])\n+    rv = bech32_encode(hrp, [witver] + convertbits(witprog, 8, 5))\n+    return rv, dst_prefix + witprog\n+\n+def gen_valid_vectors():\n+    '''Generate valid test vectors'''\n+    glist = [gen_valid_base58_vector, gen_valid_bech32_vector]\n+    tlist = [templates, bech32_templates]\n+    while True:\n+        for template, valid_vector_generator in [(t, g) for g, l in zip(glist, tlist) for t in l]:\n+            rv, payload = valid_vector_generator(template)\n+            assert is_valid(rv)\n+            metadata = {x: y for x, y in zip(metadata_keys,template[3]) if y is not None}\n+            hexrepr = b2a_hex(payload)\n+            if isinstance(hexrepr, bytes):\n+                hexrepr = hexrepr.decode('utf8')\n+            yield (rv, hexrepr, metadata)\n+\n+def gen_invalid_base58_vector(template):\n+    '''Generate possibly invalid vector'''\n+    # kinds of invalid vectors:\n+    #   invalid prefix\n+    #   invalid payload length\n+    #   invalid (randomized) suffix (add random data)\n+    #   corrupt checksum\n+    corrupt_prefix = randbool(0.2)\n+    randomize_payload_size = randbool(0.2)\n+    corrupt_suffix = randbool(0.2)\n+\n+    if corrupt_prefix:\n+        prefix = os.urandom(1)\n+    else:\n+        prefix = bytearray(template[0])\n+\n+    if randomize_payload_size:\n+        payload = os.urandom(max(int(random.expovariate(0.5)), 50))\n+    else:\n+        payload = os.urandom(template[1])\n+\n+    if corrupt_suffix:\n+        suffix = os.urandom(len(template[2]))\n+    else:\n+        suffix = bytearray(template[2])\n+\n+    val = b58encode_chk(prefix + payload + suffix)\n+    if random.randint(0,10)<1: # line corruption\n+        if randbool(): # add random character to end\n+            val += random.choice(b58chars)\n+        else: # replace random character in the middle\n+            n = random.randint(0, len(val))\n+            val = val[0:n] + random.choice(b58chars) + val[n+1:]\n+\n+    return val\n+\n+def gen_invalid_bech32_vector(template):\n+    '''Generate possibly invalid bech32 vector'''\n+    no_data = randbool(0.1)\n+    to_upper = randbool(0.1)\n+    hrp = template[0]\n+    witver = template[1]\n+    witprog = bytearray(os.urandom(template[2]))\n+\n+    if no_data:\n+        rv = bech32_encode(hrp, [])\n+    else:\n+        data = [witver] + convertbits(witprog, 8, 5)\n+        if template[3] and not no_data:\n+            if template[2] % 5 in {2, 4}:\n+                data[-1] |= 1\n+            else:\n+                data.append(0)\n+        rv = bech32_encode(hrp, data)\n+\n+    if template[4]:\n+        i = len(rv) - random.randrange(1, 7)\n+        rv = rv[:i] + random.choice(CHARSET.replace(rv[i], '')) + rv[i + 1:]\n+    if template[5]:\n+        i = len(hrp) + 1 + random.randrange(0, len(rv) - len(hrp) - 4)\n+        rv = rv[:i] + rv[i:i + 4].upper() + rv[i + 4:]\n+\n+    if to_upper:\n+        rv = rv.swapcase()\n+\n+    return rv\n+\n+def randbool(p = 0.5):\n+    '''Return True with P(p)'''\n+    return random.random() < p\n+\n+def gen_invalid_vectors():\n+    '''Generate invalid test vectors'''\n+    # start with some manual edge-cases\n+    yield \"\",\n+    yield \"x\",\n+    glist = [gen_invalid_base58_vector, gen_invalid_bech32_vector]\n+    tlist = [templates, bech32_ng_templates]\n+    while True:\n+        for template, invalid_vector_generator in [(t, g) for g, l in zip(glist, tlist) for t in l]:\n+            val = invalid_vector_generator(template)\n+            if not is_valid(val):\n+                yield val,\n+\n+if __name__ == '__main__':\n+    import sys\n+    import json\n+    iters = {'valid':gen_valid_vectors, 'invalid':gen_invalid_vectors}\n+    try:\n+        uiter = iters[sys.argv[1]]\n+    except IndexError:\n+        uiter = gen_valid_vectors\n+    try:\n+        count = int(sys.argv[2])\n+    except IndexError:\n+        count = 0\n+\n+    data = list(islice(uiter(), count))\n+    json.dump(data, sys.stdout, sort_keys=True, indent=4)\n+    sys.stdout.write('\\n')\n+"
      }
    ]
  }
]