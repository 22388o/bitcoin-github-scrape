[
  {
    "sha": "ee11354b78d20911131821a9dbb58eb849d79def",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZTExMzU0Yjc4ZDIwOTExMTMxODIxYTlkYmI1OGViODQ5ZDc5ZGVm",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-11T19:38:56Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-11T21:25:12Z"
      },
      "message": "Rewrite p2p-acceptblock in preparation for slight behavior changes\n\nRemoves checking whitelisted behavior (which will be removed, the\ndifference in behavior here makes little sense) and no longer\nrequires that blocks at the same work as our tip be dropped if not\nrequested (in part because we *do* request those blocks).",
      "tree": {
        "sha": "29cf261e1b3e5ffe48b4a9c55793f898b3c51e03",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/29cf261e1b3e5ffe48b4a9c55793f898b3c51e03"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ee11354b78d20911131821a9dbb58eb849d79def",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ee11354b78d20911131821a9dbb58eb849d79def",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ee11354b78d20911131821a9dbb58eb849d79def",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ee11354b78d20911131821a9dbb58eb849d79def/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "892809309c1bc370677241a715e57a2744f94323",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/892809309c1bc370677241a715e57a2744f94323",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/892809309c1bc370677241a715e57a2744f94323"
      }
    ],
    "stats": {
      "total": 222,
      "additions": 115,
      "deletions": 107
    },
    "files": [
      {
        "sha": "a55a8760888db863768b5a1d71986f92969cdfb1",
        "filename": "test/functional/p2p-acceptblock.py",
        "status": "modified",
        "additions": 115,
        "deletions": 107,
        "changes": 222,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ee11354b78d20911131821a9dbb58eb849d79def/test/functional/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ee11354b78d20911131821a9dbb58eb849d79def/test/functional/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-acceptblock.py?ref=ee11354b78d20911131821a9dbb58eb849d79def",
        "patch": "@@ -4,35 +4,24 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test processing of unrequested blocks.\n \n-Since behavior differs when receiving unrequested blocks from whitelisted peers\n-versus non-whitelisted peers, this tests the behavior of both (effectively two\n-separate tests running in parallel).\n-\n-Setup: two nodes, node0 and node1, not connected to each other.  Node0 does not\n-whitelist localhost, but node1 does. They will each be on their own chain for\n-this test.\n-\n-We have one NodeConn connection to each, test_node and white_node respectively.\n+We create one NodeConn connection to test_node.\n \n The test:\n-1. Generate one block on each node, to leave IBD.\n+1. Generate one block, to leave IBD.\n \n-2. Mine a new block on each tip, and deliver to each node from node's peer.\n+2. Mine a new block on the tip, and deliver from node's peer.\n    The tip should advance.\n \n-3. Mine a block that forks the previous block, and deliver to each node from\n-   corresponding peer.\n-   Node0 should not process this block (just accept the header), because it is\n-   unrequested and doesn't have more work than the tip.\n-   Node1 should process because this is coming from a whitelisted peer.\n+3. Mine a block that forks from the genesis block, and deliver to test_node.\n+   Node should not process this block (just accept the header), because it is\n+   unrequested and doesn't have more or equal work to the tip.\n \n-4. Send another block that builds on the forking block.\n-   Node0 should process this block but be stuck on the shorter chain, because\n-   it's missing an intermediate block.\n-   Node1 should reorg to this longer chain.\n+4. Send another two blocks that builds on the forking block.\n+   Node should process the second block but be stuck on the shorter chain,\n+   because it's missing an intermediate block.\n \n-4b.Send 288 more blocks on the longer chain.\n-   Node0 should process all but the last block (too far ahead in height).\n+4c.Send 288 more blocks on the longer chain.\n+   Node should process all but the last block (too far ahead in height).\n    Send all headers to Node1, and then send the last block in that chain.\n    Node1 should accept the block because it's coming from a whitelisted peer.\n \n@@ -62,8 +51,8 @@ def add_options(self, parser):\n \n     def set_test_params(self):\n         self.setup_clean_chain = True\n-        self.num_nodes = 2\n-        self.extra_args = [[], [\"-whitelist=127.0.0.1\"]]\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n \n     def setup_network(self):\n         # Node0 will be used to test behavior of processing unrequested blocks\n@@ -73,123 +62,141 @@ def setup_network(self):\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n-        test_node = NodeConnCB()   # connects to node0 (not whitelisted)\n-        white_node = NodeConnCB()  # connects to node1 (whitelisted)\n+        test_node = NodeConnCB()   # connects to node (not whitelisted)\n \n         connections = []\n         connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1], white_node))\n         test_node.add_connection(connections[0])\n-        white_node.add_connection(connections[1])\n \n         NetworkThread().start() # Start up network handling in another thread\n \n         # Test logic begins here\n         test_node.wait_for_verack()\n-        white_node.wait_for_verack()\n \n-        # 1. Have both nodes mine a block (leave IBD)\n-        [ n.generate(1) for n in self.nodes ]\n-        tips = [ int(\"0x\" + n.getbestblockhash(), 0) for n in self.nodes ]\n+        # 1. Have nodes mine a block (leave IBD)\n+        self.nodes[0].generate(1)\n+        tip = int(\"0x\" + self.nodes[0].getbestblockhash(), 0)\n \n-        # 2. Send one block that builds on each tip.\n+        # 2. Send one block that builds on the tip.\n         # This should be accepted.\n-        blocks_h2 = []  # the height 2 blocks on each node's chain\n         block_time = int(time.time()) + 1\n-        for i in range(2):\n-            blocks_h2.append(create_block(tips[i], create_coinbase(2), block_time))\n-            blocks_h2[i].solve()\n-            block_time += 1\n-        test_node.send_message(msg_block(blocks_h2[0]))\n-        white_node.send_message(msg_block(blocks_h2[1]))\n-\n-        [ x.sync_with_ping() for x in [test_node, white_node] ]\n+        block_h2 = create_block(tip, create_coinbase(2), block_time)\n+        block_h2.solve()\n+        block_time += 1\n+        test_node.send_message(msg_block(block_h2))\n+\n+        test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 2)\n-        assert_equal(self.nodes[1].getblockcount(), 2)\n-        self.log.info(\"First height 2 block accepted by both nodes\")\n-\n-        # 3. Send another block that builds on the original tip.\n-        blocks_h2f = []  # Blocks at height 2 that fork off the main chain\n-        for i in range(2):\n-            blocks_h2f.append(create_block(tips[i], create_coinbase(2), blocks_h2[i].nTime+1))\n-            blocks_h2f[i].solve()\n-        test_node.send_message(msg_block(blocks_h2f[0]))\n-        white_node.send_message(msg_block(blocks_h2f[1]))\n-\n-        [ x.sync_with_ping() for x in [test_node, white_node] ]\n+        self.log.info(\"First height 2 block accepted by node\")\n+\n+        # 3. Send another block that builds on genesis.\n+        block_h1f = create_block(int(\"0x\" + self.nodes[0].getblockhash(0), 0), create_coinbase(1), block_time)\n+        block_time += 1\n+        block_h1f.solve()\n+        test_node.send_message(msg_block(block_h1f))\n+\n+        test_node.sync_with_ping()\n+        tip_entry_found = False\n         for x in self.nodes[0].getchaintips():\n-            if x['hash'] == blocks_h2f[0].hash:\n+            if x['hash'] == block_h1f.hash:\n                 assert_equal(x['status'], \"headers-only\")\n+                tip_entry_found = True\n+        assert(tip_entry_found)\n \n-        for x in self.nodes[1].getchaintips():\n-            if x['hash'] == blocks_h2f[1].hash:\n-                assert_equal(x['status'], \"valid-headers\")\n+        # 4. Send another two block that build on the fork.\n+        block_h2f = []  # Blocks at height 2 that fork off the main chain\n+        block_h2f = create_block(block_h1f.sha256, create_coinbase(2), block_time)\n+        block_time += 1\n+        block_h2f.solve()\n+        test_node.send_message(msg_block(block_h2f))\n \n-        self.log.info(\"Second height 2 block accepted only from whitelisted peer\")\n+        test_node.sync_with_ping()\n+        # Since the earlier block was not processed by node, the new block\n+        # can't be fully validated.\n+        tip_entry_found = False\n+        for x in self.nodes[0].getchaintips():\n+            if x['hash'] == block_h2f.hash:\n+                assert_equal(x['status'], \"headers-only\")\n+                tip_entry_found = True\n+        assert(tip_entry_found)\n+\n+        # But this block should be accepted by node since it has equal work.\n+        # TODO: We currently drop this block but likely shouldn't\n+        #self.nodes[0].getblock(block_h2f.hash)\n+        self.log.info(\"Second height 2 block accepted, but not reorg'ed to\")\n \n-        # 4. Now send another block that builds on the forking chain.\n-        blocks_h3 = []\n-        for i in range(2):\n-            blocks_h3.append(create_block(blocks_h2f[i].sha256, create_coinbase(3), blocks_h2f[i].nTime+1))\n-            blocks_h3[i].solve()\n-        test_node.send_message(msg_block(blocks_h3[0]))\n-        white_node.send_message(msg_block(blocks_h3[1]))\n+        # 4b. Now send another block that builds on the forking chain.\n+        block_h3 = create_block(block_h2f.sha256, create_coinbase(3), block_h2f.nTime+1)\n+        block_h3.solve()\n+        test_node.send_message(msg_block(block_h3))\n \n-        [ x.sync_with_ping() for x in [test_node, white_node] ]\n-        # Since the earlier block was not processed by node0, the new block\n+        test_node.sync_with_ping()\n+        # Since the earlier block was not processed by node, the new block\n         # can't be fully validated.\n+        tip_entry_found = False\n         for x in self.nodes[0].getchaintips():\n-            if x['hash'] == blocks_h3[0].hash:\n+            if x['hash'] == block_h3.hash:\n                 assert_equal(x['status'], \"headers-only\")\n+                tip_entry_found = True\n+        assert(tip_entry_found)\n \n-        # But this block should be accepted by node0 since it has more work.\n-        self.nodes[0].getblock(blocks_h3[0].hash)\n+        # But this block should be accepted by node since it has more work.\n+        self.nodes[0].getblock(block_h3.hash)\n         self.log.info(\"Unrequested more-work block accepted from non-whitelisted peer\")\n \n-        # Node1 should have accepted and reorged.\n-        assert_equal(self.nodes[1].getblockcount(), 3)\n-        self.log.info(\"Successfully reorged to length 3 chain from whitelisted peer\")\n+        # 4c. Now mine 288 more blocks and deliver; all should be processed but\n+        # the last (height-too-high) on node (as long as its not missing any headers)\n+        tip = block_h3\n+        all_blocks = []\n+        for i in range(288):\n+            next_block = create_block(tip.sha256, create_coinbase(i + 4), tip.nTime+1)\n+            next_block.solve()\n+            all_blocks.append(next_block)\n+            tip = next_block\n+\n+        # Now send the block at height 5 and check that it wasn't accepted (missing header)\n+        test_node.send_message(msg_block(all_blocks[1]))\n+        test_node.sync_with_ping()\n+        assert_raises_rpc_error(-5, \"Block not found\", self.nodes[0].getblock, all_blocks[1].hash)\n+        assert_raises_rpc_error(-5, \"Block not found\", self.nodes[0].getblockheader, all_blocks[1].hash)\n \n-        # 4b. Now mine 288 more blocks and deliver; all should be processed but\n-        # the last (height-too-high) on node0.  Node1 should process the tip if\n-        # we give it the headers chain leading to the tip.\n-        tips = blocks_h3\n+        # The block at height 5 should be accepted if we provide the missing header, though\n         headers_message = msg_headers()\n-        all_blocks = []   # node0's blocks\n-        for j in range(2):\n-            for i in range(288):\n-                next_block = create_block(tips[j].sha256, create_coinbase(i + 4), tips[j].nTime+1)\n-                next_block.solve()\n-                if j==0:\n-                    test_node.send_message(msg_block(next_block))\n-                    all_blocks.append(next_block)\n-                else:\n-                    headers_message.headers.append(CBlockHeader(next_block))\n-                tips[j] = next_block\n-\n-        time.sleep(2)\n+        headers_message.headers.append(CBlockHeader(all_blocks[0]))\n+        test_node.send_message(headers_message)\n+        test_node.send_message(msg_block(all_blocks[1]))\n+        test_node.sync_with_ping()\n+        self.nodes[0].getblock(all_blocks[1].hash)\n+\n+        # Now send the blocks in all_blocks\n+        for i in range(288):\n+            test_node.send_message(msg_block(all_blocks[i]))\n+        test_node.sync_with_ping()\n+\n         # Blocks 1-287 should be accepted, block 288 should be ignored because it's too far ahead\n         for x in all_blocks[:-1]:\n             self.nodes[0].getblock(x.hash)\n         assert_raises_rpc_error(-1, \"Block not found on disk\", self.nodes[0].getblock, all_blocks[-1].hash)\n \n-        headers_message.headers.pop() # Ensure the last block is unrequested\n-        white_node.send_message(headers_message) # Send headers leading to tip\n-        white_node.send_message(msg_block(tips[1]))  # Now deliver the tip\n-        white_node.sync_with_ping()\n-        self.nodes[1].getblock(tips[1].hash)\n-        self.log.info(\"Unrequested block far ahead of tip accepted from whitelisted peer\")\n-\n         # 5. Test handling of unrequested block on the node that didn't process\n         # Should still not be processed (even though it has a child that has more\n         # work).\n-        test_node.send_message(msg_block(blocks_h2f[0]))\n \n-        # Here, if the sleep is too short, the test could falsely succeed (if the\n-        # node hasn't processed the block by the time the sleep returns, and then\n-        # the node processes it and incorrectly advances the tip).\n-        # But this would be caught later on, when we verify that an inv triggers\n-        # a getdata request for this block.\n+        # The node should have requested the blocks at some point, so\n+        # disconnect/reconnect first\n+        connections[0].disconnect_node()\n+        test_node.wait_for_disconnect()\n+\n+        test_node = NodeConnCB()   # connects to node (not whitelisted)\n+        connections[0] = NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node)\n+        test_node.add_connection(connections[0])\n+\n+        NetworkThread().start() # Start up network handling in another thread\n+\n+        test_node.wait_for_verack()\n+        test_node.send_message(msg_block(block_h1f))\n+        test_node.send_message(msg_block(block_h2f)) # This should not be required\n+\n         test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 2)\n         self.log.info(\"Unrequested block that would complete more-work chain was ignored\")\n@@ -200,18 +207,19 @@ def run_test(self):\n         with mininode_lock:\n             # Clear state so we can check the getdata request\n             test_node.last_message.pop(\"getdata\", None)\n-            test_node.send_message(msg_inv([CInv(2, blocks_h3[0].sha256)]))\n+            test_node.send_message(msg_inv([CInv(2, block_h3.sha256)]))\n \n         test_node.sync_with_ping()\n         with mininode_lock:\n             getdata = test_node.last_message[\"getdata\"]\n \n         # Check that the getdata includes the right block\n-        assert_equal(getdata.inv[0].hash, blocks_h2f[0].sha256)\n+        assert_equal(getdata.inv[0].hash, block_h1f.sha256)\n         self.log.info(\"Inv at tip triggered getdata for unprocessed block\")\n \n         # 7. Send the missing block for the third time (now it is requested)\n-        test_node.send_message(msg_block(blocks_h2f[0]))\n+        test_node.send_message(msg_block(block_h1f))\n+        test_node.send_message(msg_block(block_h2f)) # This should not be required\n \n         test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 290)"
      }
    ]
  },
  {
    "sha": "78814d2fb65014ffdc99c9e796aa44ef0cb06125",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ODgxNGQyZmI2NTAxNGZmZGM5OWM5ZTc5NmFhNDRlZjBjYjA2MTI1",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-11T20:01:51Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-11T21:25:12Z"
      },
      "message": "Stop always storing blocks from whitelisted peers\n\nThere is no reason to wish to store blocks on disk always just\nbecause a peer is whitelisted. This appears to be a historical\nquirk to avoid breaking things when the accept limits were added.",
      "tree": {
        "sha": "f5f16256227d6d6a6b923992053b3e5cfe506b35",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f5f16256227d6d6a6b923992053b3e5cfe506b35"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/78814d2fb65014ffdc99c9e796aa44ef0cb06125",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/78814d2fb65014ffdc99c9e796aa44ef0cb06125",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/78814d2fb65014ffdc99c9e796aa44ef0cb06125",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/78814d2fb65014ffdc99c9e796aa44ef0cb06125/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ee11354b78d20911131821a9dbb58eb849d79def",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ee11354b78d20911131821a9dbb58eb849d79def",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ee11354b78d20911131821a9dbb58eb849d79def"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "1235ace672ce745e7d3af82242bcac35cc9f4470",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78814d2fb65014ffdc99c9e796aa44ef0cb06125/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78814d2fb65014ffdc99c9e796aa44ef0cb06125/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=78814d2fb65014ffdc99c9e796aa44ef0cb06125",
        "patch": "@@ -2396,7 +2396,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // unless we're still syncing with the network.\n         // Such an unrequested block may still be processed, subject to the\n         // conditions in AcceptBlock().\n-        bool forceProcessing = pfrom->fWhitelisted && !IsInitialBlockDownload();\n+        bool forceProcessing = false;\n         const uint256 hash(pblock->GetHash());\n         {\n             LOCK(cs_main);"
      }
    ]
  },
  {
    "sha": "fbb7b47ca75e2c5372feb6add46e3c3efc534938",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYmI3YjQ3Y2E3NWUyYzUzNzJmZWI2YWRkNDZlM2MzZWZjNTM0OTM4",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-11T20:04:13Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-11T21:25:12Z"
      },
      "message": "Accept unrequested blocks with work equal to our tip\n\nThis is a simple cleanup that makes our accept requirements the\nsame as our request requirements.",
      "tree": {
        "sha": "7e4f34f7825679633aa40754d5ecd8b336027ae7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7e4f34f7825679633aa40754d5ecd8b336027ae7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fbb7b47ca75e2c5372feb6add46e3c3efc534938",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fbb7b47ca75e2c5372feb6add46e3c3efc534938",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fbb7b47ca75e2c5372feb6add46e3c3efc534938",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fbb7b47ca75e2c5372feb6add46e3c3efc534938/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "78814d2fb65014ffdc99c9e796aa44ef0cb06125",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/78814d2fb65014ffdc99c9e796aa44ef0cb06125",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/78814d2fb65014ffdc99c9e796aa44ef0cb06125"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 5,
      "deletions": 8
    },
    "files": [
      {
        "sha": "17f6a60d950986e851e178176a70d9b13b262458",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fbb7b47ca75e2c5372feb6add46e3c3efc534938/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fbb7b47ca75e2c5372feb6add46e3c3efc534938/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=fbb7b47ca75e2c5372feb6add46e3c3efc534938",
        "patch": "@@ -3113,7 +3113,7 @@ static bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidation\n     // process an unrequested block if it's new and has enough work to\n     // advance our tip, and isn't too many blocks ahead.\n     bool fAlreadyHave = pindex->nStatus & BLOCK_HAVE_DATA;\n-    bool fHasMoreWork = (chainActive.Tip() ? pindex->nChainWork > chainActive.Tip()->nChainWork : true);\n+    bool fHasMoreOrSameWork = (chainActive.Tip() ? pindex->nChainWork >= chainActive.Tip()->nChainWork : true);\n     // Blocks that are too out-of-order needlessly limit the effectiveness of\n     // pruning, because pruning will not delete block files that contain any\n     // blocks which are too close in height to the tip.  Apply this test\n@@ -3130,9 +3130,9 @@ static bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidation\n     // and unrequested blocks.\n     if (fAlreadyHave) return true;\n     if (!fRequested) {  // If we didn't ask for it:\n-        if (pindex->nTx != 0) return true;  // This is a previously-processed block that was pruned\n-        if (!fHasMoreWork) return true;     // Don't process less-work chains\n-        if (fTooFarAhead) return true;      // Block height is too high\n+        if (pindex->nTx != 0) return true;    // This is a previously-processed block that was pruned\n+        if (!fHasMoreOrSameWork) return true; // Don't process less-work chains\n+        if (fTooFarAhead) return true;        // Block height is too high\n     }\n     if (fNewBlock) *fNewBlock = true;\n "
      },
      {
        "sha": "64cafbffcde3ad298b433e4b2420de83a2d0bfee",
        "filename": "test/functional/p2p-acceptblock.py",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fbb7b47ca75e2c5372feb6add46e3c3efc534938/test/functional/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fbb7b47ca75e2c5372feb6add46e3c3efc534938/test/functional/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-acceptblock.py?ref=fbb7b47ca75e2c5372feb6add46e3c3efc534938",
        "patch": "@@ -121,8 +121,7 @@ def run_test(self):\n         assert(tip_entry_found)\n \n         # But this block should be accepted by node since it has equal work.\n-        # TODO: We currently drop this block but likely shouldn't\n-        #self.nodes[0].getblock(block_h2f.hash)\n+        self.nodes[0].getblock(block_h2f.hash)\n         self.log.info(\"Second height 2 block accepted, but not reorg'ed to\")\n \n         # 4b. Now send another block that builds on the forking chain.\n@@ -195,7 +194,6 @@ def run_test(self):\n \n         test_node.wait_for_verack()\n         test_node.send_message(msg_block(block_h1f))\n-        test_node.send_message(msg_block(block_h2f)) # This should not be required\n \n         test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 2)\n@@ -219,7 +217,6 @@ def run_test(self):\n \n         # 7. Send the missing block for the third time (now it is requested)\n         test_node.send_message(msg_block(block_h1f))\n-        test_node.send_message(msg_block(block_h2f)) # This should not be required\n \n         test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 290)"
      }
    ]
  },
  {
    "sha": "09cf35122a219217f841e4e4f7847386eb0b0b8a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowOWNmMzUxMjJhMjE5MjE3Zjg0MWU0ZTRmNzg0NzM4NmViMGIwYjhh",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-11T21:07:21Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-11T21:25:12Z"
      },
      "message": "Check that new headers are not a descendant of an invalid block\n\nThis is symmetric with the check in FindNextBlocksToDownload.\nBecause we do not mark all children of a failed block as invalid\nduring connection (we cannot walk down the block tree), this may\nprevent accepting an invalid block/header.",
      "tree": {
        "sha": "9ad5bc05997e6823533c6ce641b4397aaec37c70",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9ad5bc05997e6823533c6ce641b4397aaec37c70"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/09cf35122a219217f841e4e4f7847386eb0b0b8a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/09cf35122a219217f841e4e4f7847386eb0b0b8a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/09cf35122a219217f841e4e4f7847386eb0b0b8a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/09cf35122a219217f841e4e4f7847386eb0b0b8a/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fbb7b47ca75e2c5372feb6add46e3c3efc534938",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fbb7b47ca75e2c5372feb6add46e3c3efc534938",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fbb7b47ca75e2c5372feb6add46e3c3efc534938"
      }
    ],
    "stats": {
      "total": 32,
      "additions": 28,
      "deletions": 4
    },
    "files": [
      {
        "sha": "21a7de6c316219a8a5d72952a52c57ceff4f8707",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 4,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/09cf35122a219217f841e4e4f7847386eb0b0b8a/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/09cf35122a219217f841e4e4f7847386eb0b0b8a/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=09cf35122a219217f841e4e4f7847386eb0b0b8a",
        "patch": "@@ -3032,7 +3032,17 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     return true;\n }\n \n-static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex)\n+/**\n+ * Validates and stores a new block header.\n+ *\n+ * Returns the new CBlockIndex in ppindex.\n+ *\n+ * known_not_failed_index may be provided to speed up validation. It must be a\n+ * block which is known to have no failed parents (ie for which that fact was\n+ * checked in the same cs_main context, eg something which was added via\n+ * AcceptBlockHeader in the same cs_main lock).\n+ */\n+static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, CBlockIndex* known_not_failed_index)\n {\n     AssertLockHeld(cs_main);\n     // Check for duplicate\n@@ -3064,6 +3074,20 @@ static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state\n             return state.DoS(100, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n         if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev, GetAdjustedTime()))\n             return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n+\n+        CBlockIndex* walk_index = pindexPrev;\n+        while (walk_index && !walk_index->IsValid(BLOCK_VALID_SCRIPTS) && walk_index != known_not_failed_index) {\n+            if (walk_index->nStatus & BLOCK_FAILED_MASK) {\n+                CBlockIndex* invalid_walk_index = pindexPrev;\n+                while (invalid_walk_index != walk_index) {\n+                    invalid_walk_index->nStatus |= BLOCK_FAILED_CHILD;\n+                    setDirtyBlockIndex.insert(invalid_walk_index);\n+                    invalid_walk_index = invalid_walk_index->pprev;\n+                }\n+                return state.DoS(100, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n+            }\n+            walk_index = walk_index->pprev;\n+        }\n     }\n     if (pindex == nullptr)\n         pindex = AddToBlockIndex(block);\n@@ -3081,9 +3105,9 @@ bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& headers, CValidatio\n {\n     {\n         LOCK(cs_main);\n+        CBlockIndex *pindex = nullptr; // Use a temp pindex instead of ppindex to avoid a const_cast\n         for (const CBlockHeader& header : headers) {\n-            CBlockIndex *pindex = nullptr; // Use a temp pindex instead of ppindex to avoid a const_cast\n-            if (!AcceptBlockHeader(header, state, chainparams, &pindex)) {\n+            if (!AcceptBlockHeader(header, state, chainparams, &pindex, pindex)) {\n                 return false;\n             }\n             if (ppindex) {\n@@ -3106,7 +3130,7 @@ static bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidation\n     CBlockIndex *pindexDummy = nullptr;\n     CBlockIndex *&pindex = ppindex ? *ppindex : pindexDummy;\n \n-    if (!AcceptBlockHeader(block, state, chainparams, &pindex))\n+    if (!AcceptBlockHeader(block, state, chainparams, &pindex, nullptr))\n         return false;\n \n     // Try to process all requested blocks that we don't have, but only"
      }
    ]
  },
  {
    "sha": "7a8e117c659c1245e95b86db8672ac60c0d192cb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YThlMTE3YzY1OWMxMjQ1ZTk1Yjg2ZGI4NjcyYWM2MGMwZDE5MmNi",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-11T20:57:43Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-11T21:25:12Z"
      },
      "message": "[qa] test that invalid blocks on an invalid chain get a disconnect",
      "tree": {
        "sha": "e96ca765b51f4db8a8acbe4fea8905d16df8eed3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e96ca765b51f4db8a8acbe4fea8905d16df8eed3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7a8e117c659c1245e95b86db8672ac60c0d192cb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a8e117c659c1245e95b86db8672ac60c0d192cb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7a8e117c659c1245e95b86db8672ac60c0d192cb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a8e117c659c1245e95b86db8672ac60c0d192cb/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "09cf35122a219217f841e4e4f7847386eb0b0b8a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/09cf35122a219217f841e4e4f7847386eb0b0b8a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/09cf35122a219217f841e4e4f7847386eb0b0b8a"
      }
    ],
    "stats": {
      "total": 76,
      "additions": 75,
      "deletions": 1
    },
    "files": [
      {
        "sha": "2a10572b745ee1dfde53f23ae9ab97ac14c57f50",
        "filename": "test/functional/p2p-acceptblock.py",
        "status": "modified",
        "additions": 75,
        "deletions": 1,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a8e117c659c1245e95b86db8672ac60c0d192cb/test/functional/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a8e117c659c1245e95b86db8672ac60c0d192cb/test/functional/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-acceptblock.py?ref=7a8e117c659c1245e95b86db8672ac60c0d192cb",
        "patch": "@@ -35,13 +35,18 @@\n \n 7. Send Node0 the missing block again.\n    Node0 should process and the tip should advance.\n+\n+8. Create a fork which is invalid at a height longer than the current chain\n+   (ie to which the node will try to reorg) but which has headers built on top\n+   of the invalid block. Check that we get disconnected if we send more headers\n+   on the chain the node now knows to be invalid.\n \"\"\"\n \n from test_framework.mininode import *\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n import time\n-from test_framework.blocktools import create_block, create_coinbase\n+from test_framework.blocktools import create_block, create_coinbase, create_transaction\n \n class AcceptBlockTest(BitcoinTestFramework):\n     def add_options(self, parser):\n@@ -220,8 +225,77 @@ def run_test(self):\n \n         test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 290)\n+        self.nodes[0].getblock(all_blocks[286].hash)\n+        assert_equal(self.nodes[0].getbestblockhash(), all_blocks[286].hash)\n+        assert_raises_rpc_error(-1, \"Block not found on disk\", self.nodes[0].getblock, all_blocks[287].hash)\n         self.log.info(\"Successfully reorged to longer chain from non-whitelisted peer\")\n \n+        # 8. Create a chain which is invalid at a height longer than the\n+        # current chain, but which has more blocks on top of that\n+        block_289f = create_block(all_blocks[284].sha256, create_coinbase(289), all_blocks[284].nTime+1)\n+        block_289f.solve()\n+        block_290f = create_block(block_289f.sha256, create_coinbase(290), block_289f.nTime+1)\n+        block_290f.solve()\n+        block_291 = create_block(block_290f.sha256, create_coinbase(291), block_290f.nTime+1)\n+        # block_291 spends a coinbase below maturity!\n+        block_291.vtx.append(create_transaction(block_290f.vtx[0], 0, b\"42\", 1))\n+        block_291.hashMerkleRoot = block_291.calc_merkle_root()\n+        block_291.solve()\n+        block_292 = create_block(block_291.sha256, create_coinbase(292), block_291.nTime+1)\n+        block_292.solve()\n+\n+        # Now send all the headers on the chain and enough blocks to trigger reorg\n+        headers_message = msg_headers()\n+        headers_message.headers.append(CBlockHeader(block_289f))\n+        headers_message.headers.append(CBlockHeader(block_290f))\n+        headers_message.headers.append(CBlockHeader(block_291))\n+        headers_message.headers.append(CBlockHeader(block_292))\n+        test_node.send_message(headers_message)\n+\n+        test_node.sync_with_ping()\n+        tip_entry_found = False\n+        for x in self.nodes[0].getchaintips():\n+            if x['hash'] == block_292.hash:\n+                assert_equal(x['status'], \"headers-only\")\n+                tip_entry_found = True\n+        assert(tip_entry_found)\n+\n+        test_node.send_message(msg_block(block_289f))\n+        test_node.send_message(msg_block(block_290f))\n+\n+        test_node.sync_with_ping()\n+        self.nodes[0].getblock(block_289f.hash)\n+        self.nodes[0].getblock(block_290f.hash)\n+\n+        test_node.send_message(msg_block(block_291))\n+\n+        # At this point we've sent an obviously-bogus block, wait for full processing\n+        # without assuming whether we will be disconnected or not\n+        try:\n+            test_node.sync_with_ping(timeout=1)\n+        except AssertionError:\n+            test_node.wait_for_disconnect()\n+\n+            test_node = NodeConnCB()   # connects to node (not whitelisted)\n+            connections[0] = NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node)\n+            test_node.add_connection(connections[0])\n+\n+            NetworkThread().start() # Start up network handling in another thread\n+            test_node.wait_for_verack()\n+\n+        # We should have failed reorg and switched back to 290 (but have block 291)\n+        assert_equal(self.nodes[0].getblockcount(), 290)\n+        assert_equal(self.nodes[0].getbestblockhash(), all_blocks[286].hash)\n+        assert_equal(self.nodes[0].getblock(block_291.hash)[\"confirmations\"], -1)\n+\n+        # Now send a new header on the invalid chain, indicating we're forked off, and expect to get disconnected\n+        block_293 = create_block(block_292.sha256, create_coinbase(293), block_292.nTime+1)\n+        block_293.solve()\n+        headers_message = msg_headers()\n+        headers_message.headers.append(CBlockHeader(block_293))\n+        test_node.send_message(headers_message)\n+        test_node.wait_for_disconnect()\n+\n         [ c.disconnect_node() for c in connections ]\n \n if __name__ == '__main__':"
      }
    ]
  }
]