[
  {
    "sha": "e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNmQ3ZTRlZTA5MjAwYzZkMzZlMGM1YmRlZWFlYWY2YTYxNDBlZmM4",
    "commit": {
      "author": {
        "name": "Dan Raviv",
        "email": "dan@soundradix.com",
        "date": "2017-08-25T22:16:02Z"
      },
      "committer": {
        "name": "Dan Raviv",
        "email": "dan@soundradix.com",
        "date": "2017-08-25T22:16:02Z"
      },
      "message": "Use prefix instead of postfix increment/decrement for non-trivial types where the result isn't used.\n\nFollow Scott Meyers' advice in his More Effective C++ book, as well as cppcheck's performance messages, and use prefix instead of postfix increment/decrement for objects of non-trivial type, whenever the result of the increment isn't used, to avoid possible extra copies and maximize performance.\n\nAll the modified files fix this for some objects of non-trivial type. Increments/decrements of trivial types in these files were also converted to prefix instead of postfix (wherever the result isn't used) for consistency.",
      "tree": {
        "sha": "8fc4ee5cb0583665a67939fe83448b2cc04f2120",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8fc4ee5cb0583665a67939fe83448b2cc04f2120"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/comments",
    "author": {
      "login": "danra",
      "id": 84245,
      "node_id": "MDQ6VXNlcjg0MjQ1",
      "avatar_url": "https://avatars.githubusercontent.com/u/84245?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danra",
      "html_url": "https://github.com/danra",
      "followers_url": "https://api.github.com/users/danra/followers",
      "following_url": "https://api.github.com/users/danra/following{/other_user}",
      "gists_url": "https://api.github.com/users/danra/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danra/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danra/subscriptions",
      "organizations_url": "https://api.github.com/users/danra/orgs",
      "repos_url": "https://api.github.com/users/danra/repos",
      "events_url": "https://api.github.com/users/danra/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danra/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "danra",
      "id": 84245,
      "node_id": "MDQ6VXNlcjg0MjQ1",
      "avatar_url": "https://avatars.githubusercontent.com/u/84245?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danra",
      "html_url": "https://github.com/danra",
      "followers_url": "https://api.github.com/users/danra/followers",
      "following_url": "https://api.github.com/users/danra/following{/other_user}",
      "gists_url": "https://api.github.com/users/danra/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danra/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danra/subscriptions",
      "organizations_url": "https://api.github.com/users/danra/orgs",
      "repos_url": "https://api.github.com/users/danra/repos",
      "events_url": "https://api.github.com/users/danra/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danra/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3f726c99f819f97f2ab21b94d34c6b3129cd883a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3f726c99f819f97f2ab21b94d34c6b3129cd883a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3f726c99f819f97f2ab21b94d34c6b3129cd883a"
      }
    ],
    "stats": {
      "total": 550,
      "additions": 275,
      "deletions": 275
    },
    "files": [
      {
        "sha": "6e44fd175f79d512f63b6f9945e8a3bfee29d5ea",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 19,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -121,7 +121,7 @@ void CAddrMan::Delete(int nId)\n     vRandom.pop_back();\n     mapAddr.erase(info);\n     mapInfo.erase(nId);\n-    nNew--;\n+    --nNew;\n }\n \n void CAddrMan::ClearNew(int nUBucket, int nUBucketPos)\n@@ -131,7 +131,7 @@ void CAddrMan::ClearNew(int nUBucket, int nUBucketPos)\n         int nIdDelete = vvNew[nUBucket][nUBucketPos];\n         CAddrInfo& infoDelete = mapInfo[nIdDelete];\n         assert(infoDelete.nRefCount > 0);\n-        infoDelete.nRefCount--;\n+        --infoDelete.nRefCount;\n         vvNew[nUBucket][nUBucketPos] = -1;\n         if (infoDelete.nRefCount == 0) {\n             Delete(nIdDelete);\n@@ -142,14 +142,14 @@ void CAddrMan::ClearNew(int nUBucket, int nUBucketPos)\n void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n {\n     // remove the entry from all new buckets\n-    for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {\n+    for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; ++bucket) {\n         int pos = info.GetBucketPosition(nKey, true, bucket);\n         if (vvNew[bucket][pos] == nId) {\n             vvNew[bucket][pos] = -1;\n-            info.nRefCount--;\n+            --info.nRefCount;\n         }\n     }\n-    nNew--;\n+    --nNew;\n \n     assert(info.nRefCount == 0);\n \n@@ -167,7 +167,7 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n         // Remove the to-be-evicted item from the tried set.\n         infoOld.fInTried = false;\n         vvTried[nKBucket][nKBucketPos] = -1;\n-        nTried--;\n+        --nTried;\n \n         // find which new bucket it belongs to\n         int nUBucket = infoOld.GetNewBucket(nKey);\n@@ -178,12 +178,12 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n         // Enter it into the new set again.\n         infoOld.nRefCount = 1;\n         vvNew[nUBucket][nUBucketPos] = nIdEvict;\n-        nNew++;\n+        ++nNew;\n     }\n     assert(vvTried[nKBucket][nKBucketPos] == -1);\n \n     vvTried[nKBucket][nKBucketPos] = nId;\n-    nTried++;\n+    ++nTried;\n     info.fInTried = true;\n }\n \n@@ -219,7 +219,7 @@ void CAddrMan::Good_(const CService& addr, int64_t nTime)\n     // find a bucket it is in now\n     int nRnd = RandomInt(ADDRMAN_NEW_BUCKET_COUNT);\n     int nUBucket = -1;\n-    for (unsigned int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {\n+    for (unsigned int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {\n         int nB = (n + nRnd) % ADDRMAN_NEW_BUCKET_COUNT;\n         int nBpos = info.GetBucketPosition(nKey, true, nB);\n         if (vvNew[nB][nBpos] == nId) {\n@@ -277,14 +277,14 @@ bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimeP\n \n         // stochastic test: previous nRefCount == N: 2^N times harder to increase it\n         int nFactor = 1;\n-        for (int n = 0; n < pinfo->nRefCount; n++)\n+        for (int n = 0; n < pinfo->nRefCount; ++n)\n             nFactor *= 2;\n         if (nFactor > 1 && (RandomInt(nFactor) != 0))\n             return false;\n     } else {\n         pinfo = Create(addr, source, &nId);\n         pinfo->nTime = std::max((int64_t)0, (int64_t)pinfo->nTime - nTimePenalty);\n-        nNew++;\n+        ++nNew;\n         fNew = true;\n     }\n \n@@ -301,7 +301,7 @@ bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimeP\n         }\n         if (fInsert) {\n             ClearNew(nUBucket, nUBucketPos);\n-            pinfo->nRefCount++;\n+            ++pinfo->nRefCount;\n             vvNew[nUBucket][nUBucketPos] = nId;\n         } else {\n             if (pinfo->nRefCount == 0) {\n@@ -330,7 +330,7 @@ void CAddrMan::Attempt_(const CService& addr, bool fCountFailure, int64_t nTime)\n     info.nLastTry = nTime;\n     if (fCountFailure && info.nLastCountAttempt < nLastGood) {\n         info.nLastCountAttempt = nTime;\n-        info.nAttempts++;\n+        ++info.nAttempts;\n     }\n }\n \n@@ -390,7 +390,7 @@ int CAddrMan::Check_()\n     if (vRandom.size() != nTried + nNew)\n         return -7;\n \n-    for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++) {\n+    for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); ++it) {\n         int n = (*it).first;\n         CAddrInfo& info = (*it).second;\n         if (info.fInTried) {\n@@ -421,8 +421,8 @@ int CAddrMan::Check_()\n     if (mapNew.size() != nNew)\n         return -10;\n \n-    for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {\n-        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+    for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; ++n) {\n+        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n              if (vvTried[n][i] != -1) {\n                  if (!setTried.count(vvTried[n][i]))\n                      return -11;\n@@ -435,8 +435,8 @@ int CAddrMan::Check_()\n         }\n     }\n \n-    for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {\n-        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+    for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {\n+        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n             if (vvNew[n][i] != -1) {\n                 if (!mapNew.count(vvNew[n][i]))\n                     return -12;\n@@ -466,7 +466,7 @@ void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr)\n         nNodes = ADDRMAN_GETADDR_MAX;\n \n     // gather a list of random nodes, skipping those of low quality\n-    for (unsigned int n = 0; n < vRandom.size(); n++) {\n+    for (unsigned int n = 0; n < vRandom.size(); ++n) {\n         if (vAddr.size() >= nNodes)\n             break;\n "
      },
      {
        "sha": "20b37f7ca5df9771703aebe50f6a6d4b82eca592",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 23,
        "deletions": 23,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -313,32 +313,32 @@ class CAddrMan\n         s << nUBuckets;\n         std::map<int, int> mapUnkIds;\n         int nIds = 0;\n-        for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); it++) {\n+        for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); ++it) {\n             mapUnkIds[(*it).first] = nIds;\n             const CAddrInfo &info = (*it).second;\n             if (info.nRefCount) {\n                 assert(nIds != nNew); // this means nNew was wrong, oh ow\n                 s << info;\n-                nIds++;\n+                ++nIds;\n             }\n         }\n         nIds = 0;\n-        for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); it++) {\n+        for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); ++it) {\n             const CAddrInfo &info = (*it).second;\n             if (info.fInTried) {\n                 assert(nIds != nTried); // this means nTried was wrong, oh ow\n                 s << info;\n-                nIds++;\n+                ++nIds;\n             }\n         }\n-        for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {\n+        for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; ++bucket) {\n             int nSize = 0;\n-            for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+            for (int i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n                 if (vvNew[bucket][i] != -1)\n-                    nSize++;\n+                    ++nSize;\n             }\n             s << nSize;\n-            for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+            for (int i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n                 if (vvNew[bucket][i] != -1) {\n                     int nIndex = mapUnkIds[vvNew[bucket][i]];\n                     s << nIndex;\n@@ -377,7 +377,7 @@ class CAddrMan\n         }\n \n         // Deserialize entries from the new table.\n-        for (int n = 0; n < nNew; n++) {\n+        for (int n = 0; n < nNew; ++n) {\n             CAddrInfo &info = mapInfo[n];\n             s >> info;\n             mapAddr[info] = n;\n@@ -390,15 +390,15 @@ class CAddrMan\n                 int nUBucketPos = info.GetBucketPosition(nKey, true, nUBucket);\n                 if (vvNew[nUBucket][nUBucketPos] == -1) {\n                     vvNew[nUBucket][nUBucketPos] = n;\n-                    info.nRefCount++;\n+                    ++info.nRefCount;\n                 }\n             }\n         }\n         nIdCount = nNew;\n \n         // Deserialize entries from the tried table.\n         int nLost = 0;\n-        for (int n = 0; n < nTried; n++) {\n+        for (int n = 0; n < nTried; ++n) {\n             CAddrInfo info;\n             s >> info;\n             int nKBucket = info.GetTriedBucket(nKey);\n@@ -410,25 +410,25 @@ class CAddrMan\n                 mapInfo[nIdCount] = info;\n                 mapAddr[info] = nIdCount;\n                 vvTried[nKBucket][nKBucketPos] = nIdCount;\n-                nIdCount++;\n+                ++nIdCount;\n             } else {\n-                nLost++;\n+                ++nLost;\n             }\n         }\n         nTried -= nLost;\n \n         // Deserialize positions in the new table (if possible).\n-        for (int bucket = 0; bucket < nUBuckets; bucket++) {\n+        for (int bucket = 0; bucket < nUBuckets; ++bucket) {\n             int nSize = 0;\n             s >> nSize;\n-            for (int n = 0; n < nSize; n++) {\n+            for (int n = 0; n < nSize; ++n) {\n                 int nIndex = 0;\n                 s >> nIndex;\n                 if (nIndex >= 0 && nIndex < nNew) {\n                     CAddrInfo &info = mapInfo[nIndex];\n                     int nUBucketPos = info.GetBucketPosition(nKey, true, bucket);\n                     if (nVersion == 1 && nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && vvNew[bucket][nUBucketPos] == -1 && info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS) {\n-                        info.nRefCount++;\n+                        ++info.nRefCount;\n                         vvNew[bucket][nUBucketPos] = nIndex;\n                     }\n                 }\n@@ -441,9 +441,9 @@ class CAddrMan\n             if (it->second.fInTried == false && it->second.nRefCount == 0) {\n                 std::map<int, CAddrInfo>::const_iterator itCopy = it++;\n                 Delete(itCopy->first);\n-                nLostUnk++;\n+                ++nLostUnk;\n             } else {\n-                it++;\n+                ++it;\n             }\n         }\n         if (nLost + nLostUnk > 0) {\n@@ -457,13 +457,13 @@ class CAddrMan\n     {\n         std::vector<int>().swap(vRandom);\n         nKey = GetRandHash();\n-        for (size_t bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {\n-            for (size_t entry = 0; entry < ADDRMAN_BUCKET_SIZE; entry++) {\n+        for (size_t bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; ++bucket) {\n+            for (size_t entry = 0; entry < ADDRMAN_BUCKET_SIZE; ++entry) {\n                 vvNew[bucket][entry] = -1;\n             }\n         }\n-        for (size_t bucket = 0; bucket < ADDRMAN_TRIED_BUCKET_COUNT; bucket++) {\n-            for (size_t entry = 0; entry < ADDRMAN_BUCKET_SIZE; entry++) {\n+        for (size_t bucket = 0; bucket < ADDRMAN_TRIED_BUCKET_COUNT; ++bucket) {\n+            for (size_t entry = 0; entry < ADDRMAN_BUCKET_SIZE; ++entry) {\n                 vvTried[bucket][entry] = -1;\n             }\n         }\n@@ -524,7 +524,7 @@ class CAddrMan\n         LOCK(cs);\n         int nAdd = 0;\n         Check();\n-        for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n+        for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); ++it)\n             nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n         Check();\n         if (nAdd) {"
      },
      {
        "sha": "68efb5859df74534eb0cf2298d0d601e9307683e",
        "filename": "src/arith_uint256.h",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/arith_uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/arith_uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/arith_uint256.h?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -33,21 +33,21 @@ class base_uint\n     {\n         static_assert(BITS/32 > 0 && BITS%32 == 0, \"Template parameter BITS must be a positive multiple of 32.\");\n \n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             pn[i] = 0;\n     }\n \n     base_uint(const base_uint& b)\n     {\n         static_assert(BITS/32 > 0 && BITS%32 == 0, \"Template parameter BITS must be a positive multiple of 32.\");\n \n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             pn[i] = b.pn[i];\n     }\n \n     base_uint& operator=(const base_uint& b)\n     {\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             pn[i] = b.pn[i];\n         return *this;\n     }\n@@ -58,15 +58,15 @@ class base_uint\n \n         pn[0] = (unsigned int)b;\n         pn[1] = (unsigned int)(b >> 32);\n-        for (int i = 2; i < WIDTH; i++)\n+        for (int i = 2; i < WIDTH; ++i)\n             pn[i] = 0;\n     }\n \n     explicit base_uint(const std::string& str);\n \n     bool operator!() const\n     {\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             if (pn[i] != 0)\n                 return false;\n         return true;\n@@ -75,17 +75,17 @@ class base_uint\n     const base_uint operator~() const\n     {\n         base_uint ret;\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             ret.pn[i] = ~pn[i];\n         return ret;\n     }\n \n     const base_uint operator-() const\n     {\n         base_uint ret;\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             ret.pn[i] = ~pn[i];\n-        ret++;\n+        ++ret;\n         return ret;\n     }\n \n@@ -95,28 +95,28 @@ class base_uint\n     {\n         pn[0] = (unsigned int)b;\n         pn[1] = (unsigned int)(b >> 32);\n-        for (int i = 2; i < WIDTH; i++)\n+        for (int i = 2; i < WIDTH; ++i)\n             pn[i] = 0;\n         return *this;\n     }\n \n     base_uint& operator^=(const base_uint& b)\n     {\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             pn[i] ^= b.pn[i];\n         return *this;\n     }\n \n     base_uint& operator&=(const base_uint& b)\n     {\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             pn[i] &= b.pn[i];\n         return *this;\n     }\n \n     base_uint& operator|=(const base_uint& b)\n     {\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             pn[i] |= b.pn[i];\n         return *this;\n     }\n@@ -141,7 +141,7 @@ class base_uint\n     base_uint& operator+=(const base_uint& b)\n     {\n         uint64_t carry = 0;\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n         {\n             uint64_t n = carry + pn[i] + b.pn[i];\n             pn[i] = n & 0xffffffff;\n@@ -181,7 +181,7 @@ class base_uint\n         // prefix operator\n         int i = 0;\n         while (i < WIDTH && ++pn[i] == 0)\n-            i++;\n+            ++i;\n         return *this;\n     }\n \n@@ -198,7 +198,7 @@ class base_uint\n         // prefix operator\n         int i = 0;\n         while (i < WIDTH && --pn[i] == (uint32_t)-1)\n-            i++;\n+            ++i;\n         return *this;\n     }\n "
      },
      {
        "sha": "0104651da2c5c18df4214554a814a6827ec952ac",
        "filename": "src/base58.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.cpp?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -22,13 +22,13 @@ bool DecodeBase58(const char* psz, std::vector<unsigned char>& vch)\n {\n     // Skip leading spaces.\n     while (*psz && isspace(*psz))\n-        psz++;\n+        ++psz;\n     // Skip and count leading '1's.\n     int zeroes = 0;\n     int length = 0;\n     while (*psz == '1') {\n-        zeroes++;\n-        psz++;\n+        ++zeroes;\n+        ++psz;\n     }\n     // Allocate enough space in big-endian base256 representation.\n     int size = strlen(psz) * 733 /1000 + 1; // log(58) / log(256), rounded up.\n@@ -49,17 +49,17 @@ bool DecodeBase58(const char* psz, std::vector<unsigned char>& vch)\n         }\n         assert(carry == 0);\n         length = i;\n-        psz++;\n+        ++psz;\n     }\n     // Skip trailing spaces.\n     while (isspace(*psz))\n-        psz++;\n+        ++psz;\n     if (*psz != 0)\n         return false;\n     // Skip leading zeroes in b256.\n     std::vector<unsigned char>::iterator it = b256.begin() + (size - length);\n     while (it != b256.end() && *it == 0)\n-        it++;\n+        ++it;\n     // Copy result into output vector.\n     vch.reserve(zeroes + (b256.end() - it));\n     vch.assign(zeroes, 0x00);\n@@ -74,8 +74,8 @@ std::string EncodeBase58(const unsigned char* pbegin, const unsigned char* pend)\n     int zeroes = 0;\n     int length = 0;\n     while (pbegin != pend && *pbegin == 0) {\n-        pbegin++;\n-        zeroes++;\n+        ++pbegin;\n+        ++zeroes;\n     }\n     // Allocate enough space in big-endian base58 representation.\n     int size = (pend - pbegin) * 138 / 100 + 1; // log(256) / log(58), rounded up.\n@@ -85,20 +85,20 @@ std::string EncodeBase58(const unsigned char* pbegin, const unsigned char* pend)\n         int carry = *pbegin;\n         int i = 0;\n         // Apply \"b58 = b58 * 256 + ch\".\n-        for (std::vector<unsigned char>::reverse_iterator it = b58.rbegin(); (carry != 0 || i < length) && (it != b58.rend()); it++, i++) {\n+        for (std::vector<unsigned char>::reverse_iterator it = b58.rbegin(); (carry != 0 || i < length) && (it != b58.rend()); ++it, ++i) {\n             carry += 256 * (*it);\n             *it = carry % 58;\n             carry /= 58;\n         }\n \n         assert(carry == 0);\n         length = i;\n-        pbegin++;\n+        ++pbegin;\n     }\n     // Skip leading zeroes in base58 result.\n     std::vector<unsigned char>::iterator it = b58.begin() + (size - length);\n     while (it != b58.end() && *it == 0)\n-        it++;\n+        ++it;\n     // Translate the result into a string.\n     std::string str;\n     str.reserve(zeroes + (b58.end() - it));"
      },
      {
        "sha": "f3ab63913d07fb49ff2ce13e10263af8fb203999",
        "filename": "src/bloom.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.cpp?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -59,7 +59,7 @@ void CBloomFilter::insert(const std::vector<unsigned char>& vKey)\n {\n     if (isFull)\n         return;\n-    for (unsigned int i = 0; i < nHashFuncs; i++)\n+    for (unsigned int i = 0; i < nHashFuncs; ++i)\n     {\n         unsigned int nIndex = Hash(i, vKey);\n         // Sets bit nIndex of vData\n@@ -88,7 +88,7 @@ bool CBloomFilter::contains(const std::vector<unsigned char>& vKey) const\n         return true;\n     if (isEmpty)\n         return false;\n-    for (unsigned int i = 0; i < nHashFuncs; i++)\n+    for (unsigned int i = 0; i < nHashFuncs; ++i)\n     {\n         unsigned int nIndex = Hash(i, vKey);\n         // Checks bit nIndex of vData\n@@ -143,7 +143,7 @@ bool CBloomFilter::IsRelevantAndUpdate(const CTransaction& tx)\n     if (contains(hash))\n         fFound = true;\n \n-    for (unsigned int i = 0; i < tx.vout.size(); i++)\n+    for (unsigned int i = 0; i < tx.vout.size(); ++i)\n     {\n         const CTxOut& txout = tx.vout[i];\n         // Match if the filter contains any arbitrary script data element in any scriptPubKey in tx\n@@ -204,7 +204,7 @@ void CBloomFilter::UpdateEmptyFull()\n {\n     bool full = true;\n     bool empty = true;\n-    for (unsigned int i = 0; i < vData.size(); i++)\n+    for (unsigned int i = 0; i < vData.size(); ++i)\n     {\n         full &= vData[i] == 0xff;\n         empty &= vData[i] == 0;\n@@ -249,7 +249,7 @@ void CRollingBloomFilter::insert(const std::vector<unsigned char>& vKey)\n {\n     if (nEntriesThisGeneration == nEntriesPerGeneration) {\n         nEntriesThisGeneration = 0;\n-        nGeneration++;\n+        ++nGeneration;\n         if (nGeneration == 4) {\n             nGeneration = 1;\n         }\n@@ -263,9 +263,9 @@ void CRollingBloomFilter::insert(const std::vector<unsigned char>& vKey)\n             data[p + 1] = p2 & mask;\n         }\n     }\n-    nEntriesThisGeneration++;\n+    ++nEntriesThisGeneration;\n \n-    for (int n = 0; n < nHashFuncs; n++) {\n+    for (int n = 0; n < nHashFuncs; ++n) {\n         uint32_t h = RollingBloomHash(n, nTweak, vKey);\n         int bit = h & 0x3F;\n         uint32_t pos = (h >> 6) % data.size();\n@@ -283,7 +283,7 @@ void CRollingBloomFilter::insert(const uint256& hash)\n \n bool CRollingBloomFilter::contains(const std::vector<unsigned char>& vKey) const\n {\n-    for (int n = 0; n < nHashFuncs; n++) {\n+    for (int n = 0; n < nHashFuncs; ++n) {\n         uint32_t h = RollingBloomHash(n, nTweak, vKey);\n         int bit = h & 0x3F;\n         uint32_t pos = (h >> 6) % data.size();\n@@ -306,7 +306,7 @@ void CRollingBloomFilter::reset()\n     nTweak = GetRand(std::numeric_limits<unsigned int>::max());\n     nEntriesThisGeneration = 0;\n     nGeneration = 1;\n-    for (std::vector<uint64_t>::iterator it = data.begin(); it != data.end(); it++) {\n+    for (std::vector<uint64_t>::iterator it = data.begin(); it != data.end(); ++it) {\n         *it = 0;\n     }\n }"
      },
      {
        "sha": "3cf97646c85bb495654424634c76f0b1da7ae7d0",
        "filename": "src/core_memusage.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/core_memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/core_memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_memusage.h?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -19,7 +19,7 @@ static inline size_t RecursiveDynamicUsage(const COutPoint& out) {\n \n static inline size_t RecursiveDynamicUsage(const CTxIn& in) {\n     size_t mem = RecursiveDynamicUsage(in.scriptSig) + RecursiveDynamicUsage(in.prevout) + memusage::DynamicUsage(in.scriptWitness.stack);\n-    for (std::vector<std::vector<unsigned char> >::const_iterator it = in.scriptWitness.stack.begin(); it != in.scriptWitness.stack.end(); it++) {\n+    for (std::vector<std::vector<unsigned char> >::const_iterator it = in.scriptWitness.stack.begin(); it != in.scriptWitness.stack.end(); ++it) {\n          mem += memusage::DynamicUsage(*it);\n     }\n     return mem;\n@@ -31,21 +31,21 @@ static inline size_t RecursiveDynamicUsage(const CTxOut& out) {\n \n static inline size_t RecursiveDynamicUsage(const CTransaction& tx) {\n     size_t mem = memusage::DynamicUsage(tx.vin) + memusage::DynamicUsage(tx.vout);\n-    for (std::vector<CTxIn>::const_iterator it = tx.vin.begin(); it != tx.vin.end(); it++) {\n+    for (std::vector<CTxIn>::const_iterator it = tx.vin.begin(); it != tx.vin.end(); ++it) {\n         mem += RecursiveDynamicUsage(*it);\n     }\n-    for (std::vector<CTxOut>::const_iterator it = tx.vout.begin(); it != tx.vout.end(); it++) {\n+    for (std::vector<CTxOut>::const_iterator it = tx.vout.begin(); it != tx.vout.end(); ++it) {\n         mem += RecursiveDynamicUsage(*it);\n     }\n     return mem;\n }\n \n static inline size_t RecursiveDynamicUsage(const CMutableTransaction& tx) {\n     size_t mem = memusage::DynamicUsage(tx.vin) + memusage::DynamicUsage(tx.vout);\n-    for (std::vector<CTxIn>::const_iterator it = tx.vin.begin(); it != tx.vin.end(); it++) {\n+    for (std::vector<CTxIn>::const_iterator it = tx.vin.begin(); it != tx.vin.end(); ++it) {\n         mem += RecursiveDynamicUsage(*it);\n     }\n-    for (std::vector<CTxOut>::const_iterator it = tx.vout.begin(); it != tx.vout.end(); it++) {\n+    for (std::vector<CTxOut>::const_iterator it = tx.vout.begin(); it != tx.vout.end(); ++it) {\n         mem += RecursiveDynamicUsage(*it);\n     }\n     return mem;"
      },
      {
        "sha": "7805cfc9bd8c0cffe8fb950b6aec671c2ea319ab",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -80,7 +80,7 @@ class CBasicKeyStore : public CKeyStore\n             while (mi != mapKeys.end())\n             {\n                 setAddress.insert((*mi).first);\n-                mi++;\n+                ++mi;\n             }\n         }\n     }"
      },
      {
        "sha": "456af2c36c5fa2762aa884cca49526cb0bf7f124",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -219,7 +219,7 @@ void BlockAssembler::onlyUnconfirmed(CTxMemPool::setEntries& testSet)\n             testSet.erase(iit++);\n         }\n         else {\n-            iit++;\n+            ++iit;\n         }\n     }\n }"
      },
      {
        "sha": "a4b3fcbb97f302dc2c39f32ae197855ef05c7e7a",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -114,7 +114,7 @@ bool GetLocal(CService& addr, const CNetAddr *paddrPeer)\n     int nBestReachability = -1;\n     {\n         LOCK(cs_mapLocalHost);\n-        for (std::map<CNetAddr, LocalServiceInfo>::iterator it = mapLocalHost.begin(); it != mapLocalHost.end(); it++)\n+        for (std::map<CNetAddr, LocalServiceInfo>::iterator it = mapLocalHost.begin(); it != mapLocalHost.end(); ++it)\n         {\n             int nScore = (*it).second.nScore;\n             int nReachability = (*it).first.GetReachabilityFrom(paddrPeer);\n@@ -272,7 +272,7 @@ bool SeenLocal(const CService& addr)\n         LOCK(cs_mapLocalHost);\n         if (mapLocalHost.count(addr) == 0)\n             return false;\n-        mapLocalHost[addr].nScore++;\n+        ++mapLocalHost[addr].nScore;\n     }\n     return true;\n }\n@@ -478,7 +478,7 @@ void CConnman::ClearBanned()\n bool CConnman::IsBanned(CNetAddr ip)\n {\n     LOCK(cs_setBanned);\n-    for (banmap_t::iterator it = setBanned.begin(); it != setBanned.end(); it++)\n+    for (banmap_t::iterator it = setBanned.begin(); it != setBanned.end(); ++it)\n     {\n         CSubNet subNet = (*it).first;\n         CBanEntry banEntry = (*it).second;\n@@ -869,7 +869,7 @@ size_t CConnman::SocketSendData(CNode *pnode) const\n                 pnode->nSendOffset = 0;\n                 pnode->nSendSize -= data.size();\n                 pnode->fPauseSend = pnode->nSendSize > nSendBufferMaxSize;\n-                it++;\n+                ++it;\n             } else {\n                 // could not send full message; stop sending more\n                 break;\n@@ -1062,7 +1062,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n         LOCK(cs_vNodes);\n         for (CNode* pnode : vNodes)\n             if (pnode->fInbound)\n-                nInbound++;\n+                ++nInbound;\n     }\n \n     if (hSocket == INVALID_SOCKET)\n@@ -1263,7 +1263,7 @@ void CConnman::ThreadSocketHandler()\n             {\n                 int nErr = WSAGetLastError();\n                 LogPrintf(\"socket select error %s\\n\", NetworkErrorString(nErr));\n-                for (unsigned int i = 0; i <= hSocketMax; i++)\n+                for (unsigned int i = 0; i <= hSocketMax; ++i)\n                     FD_SET(i, &fdsetRecv);\n             }\n             FD_ZERO(&fdsetSend);\n@@ -1618,7 +1618,7 @@ void CConnman::ThreadDNSAddressSeed()\n                     CAddress addr = CAddress(CService(ip, Params().GetDefaultPort()), requiredServiceBits);\n                     addr.nTime = GetTime() - 3*nOneDay - GetRand(4*nOneDay); // use a random age between 3 and 7 days old\n                     vAdd.push_back(addr);\n-                    found++;\n+                    ++found;\n                 }\n                 addrman.Add(vAdd, resolveSource);\n             }\n@@ -1679,14 +1679,14 @@ void CConnman::ThreadOpenConnections()\n     // Connect to specific addresses\n     if (gArgs.IsArgSet(\"-connect\"))\n     {\n-        for (int64_t nLoop = 0;; nLoop++)\n+        for (int64_t nLoop = 0;; ++nLoop)\n         {\n             ProcessOneShot();\n             for (const std::string& strAddr : gArgs.GetArgs(\"-connect\"))\n             {\n                 CAddress addr(CService(), NODE_NONE);\n                 OpenNetworkConnection(addr, false, nullptr, strAddr.c_str());\n-                for (int i = 0; i < 10 && i < nLoop; i++)\n+                for (int i = 0; i < 10 && i < nLoop; ++i)\n                 {\n                     if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))\n                         return;\n@@ -1742,15 +1742,15 @@ void CConnman::ThreadOpenConnections()\n \n                     // Count the peers that have all relevant services\n                     if (pnode->fSuccessfullyConnected && !pnode->fFeeler && ((pnode->nServices & nRelevantServices) == nRelevantServices)) {\n-                        nOutboundRelevant++;\n+                        ++nOutboundRelevant;\n                     }\n                     // Netgroups for inbound and addnode peers are not excluded because our goal here\n                     // is to not use multiple of our limited outbound slots on a single netgroup\n                     // but inbound and addnode peers do not use our outbound slots.  Inbound peers\n                     // also have the added issue that they're attacker controlled and could be used\n                     // to prevent us from connecting to particular hosts if we used them here.\n                     setConnected.insert(pnode->addr.GetGroup());\n-                    nOutbound++;\n+                    ++nOutbound;\n                 }\n             }\n         }\n@@ -1791,7 +1791,7 @@ void CConnman::ThreadOpenConnections()\n             // If we didn't find an appropriate destination after trying 100 addresses fetched from addrman,\n             // stop this loop, and let the outer loop run again (which sleeps, adds seed nodes, recalculates\n             // already-connected network ranges, ...) before trying new addrman addresses.\n-            nTries++;\n+            ++nTries;\n             if (nTries > 100)\n                 break;\n \n@@ -2384,13 +2384,13 @@ void CConnman::Interrupt()\n     InterruptSocks5(true);\n \n     if (semOutbound) {\n-        for (int i=0; i<(nMaxOutbound + nMaxFeeler); i++) {\n+        for (int i=0; i<(nMaxOutbound + nMaxFeeler); ++i) {\n             semOutbound->post();\n         }\n     }\n \n     if (semAddnode) {\n-        for (int i=0; i<nMaxAddnode; i++) {\n+        for (int i=0; i<nMaxAddnode; ++i) {\n             semAddnode->post();\n         }\n     }\n@@ -2513,7 +2513,7 @@ size_t CConnman::GetNodeCount(NumConnections flags)\n     int nNum = 0;\n     for(std::vector<CNode*>::const_iterator it = vNodes.begin(); it != vNodes.end(); ++it)\n         if (flags & ((*it)->fInbound ? CONNECTIONS_IN : CONNECTIONS_OUT))\n-            nNum++;\n+            ++nNum;\n \n     return nNum;\n }"
      },
      {
        "sha": "2f826712baedc17a0bc285a3d73c18ad9c34f958",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -283,7 +283,7 @@ void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n     CNodeState *state = State(nodeid);\n \n     if (state->fSyncStarted)\n-        nSyncStarted--;\n+        --nSyncStarted;\n \n     if (state->nMisbehavior == 0 && state->fCurrentlyConnected) {\n         fUpdateConnectionTime = true;\n@@ -318,14 +318,14 @@ bool MarkBlockAsReceived(const uint256& hash) {\n         state->nBlocksInFlightValidHeaders -= itInFlight->second.second->fValidatedHeaders;\n         if (state->nBlocksInFlightValidHeaders == 0 && itInFlight->second.second->fValidatedHeaders) {\n             // Last validated block on the queue was received.\n-            nPeersWithValidatedDownloads--;\n+            --nPeersWithValidatedDownloads;\n         }\n         if (state->vBlocksInFlight.begin() == itInFlight->second.second) {\n             // First block on the queue was received, update the start download time for the next one\n             state->nDownloadingSince = std::max(state->nDownloadingSince, GetTimeMicros());\n         }\n         state->vBlocksInFlight.erase(itInFlight->second.second);\n-        state->nBlocksInFlight--;\n+        --state->nBlocksInFlight;\n         state->nStallingSince = 0;\n         mapBlocksInFlight.erase(itInFlight);\n         return true;\n@@ -354,14 +354,14 @@ bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex*\n \n     std::list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(),\n             {hash, pindex, pindex != nullptr, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&mempool) : nullptr)});\n-    state->nBlocksInFlight++;\n+    ++state->nBlocksInFlight;\n     state->nBlocksInFlightValidHeaders += it->fValidatedHeaders;\n     if (state->nBlocksInFlight == 1) {\n         // We're starting a block download (batch) from this peer.\n         state->nDownloadingSince = GetTimeMicros();\n     }\n     if (state->nBlocksInFlightValidHeaders == 1 && pindex != nullptr) {\n-        nPeersWithValidatedDownloads++;\n+        ++nPeersWithValidatedDownloads;\n     }\n     itInFlight = mapBlocksInFlight.insert(std::make_pair(hash, std::make_pair(nodeid, it))).first;\n     if (pit)\n@@ -410,7 +410,7 @@ void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman& connman) {\n         return;\n     }\n     if (nodestate->fProvidesHeaderAndIDs) {\n-        for (std::list<NodeId>::iterator it = lNodesAnnouncingHeaderAndIDs.begin(); it != lNodesAnnouncingHeaderAndIDs.end(); it++) {\n+        for (std::list<NodeId>::iterator it = lNodesAnnouncingHeaderAndIDs.begin(); it != lNodesAnnouncingHeaderAndIDs.end(); ++it) {\n             if (*it == nodeid) {\n                 lNodesAnnouncingHeaderAndIDs.erase(it);\n                 lNodesAnnouncingHeaderAndIDs.push_back(nodeid);\n@@ -499,7 +499,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n         vToFetch.resize(nToFetch);\n         pindexWalk = state->pindexBestKnownBlock->GetAncestor(pindexWalk->nHeight + nToFetch);\n         vToFetch[nToFetch - 1] = pindexWalk;\n-        for (unsigned int i = nToFetch - 1; i > 0; i--) {\n+        for (unsigned int i = nToFetch - 1; i > 0; --i) {\n             vToFetch[i - 1] = vToFetch[i]->pprev;\n         }\n \n@@ -936,7 +936,7 @@ static void RelayAddress(const CAddress& addr, bool fReachable, CConnman& connma\n     auto sortfunc = [&best, &hasher, nRelayNodes](CNode* pnode) {\n         if (pnode->nVersion >= CADDR_TIME_VERSION) {\n             uint64_t hashKey = CSipHasher(hasher).Write(pnode->GetId()).Finalize();\n-            for (unsigned int i = 0; i < nRelayNodes; i++) {\n+            for (unsigned int i = 0; i < nRelayNodes; ++i) {\n                  if (hashKey > best[i].first) {\n                      std::copy(best.begin() + i, best.begin() + nRelayNodes - 1, best.begin() + i + 1);\n                      best[i] = std::make_pair(hashKey, pnode);\n@@ -947,7 +947,7 @@ static void RelayAddress(const CAddress& addr, bool fReachable, CConnman& connma\n     };\n \n     auto pushfunc = [&addr, &best, nRelayNodes, &insecure_rand] {\n-        for (unsigned int i = 0; i < nRelayNodes && best[i].first != 0; i++) {\n+        for (unsigned int i = 0; i < nRelayNodes && best[i].first != 0; ++i) {\n             best[i].second->PushAddress(addr, insecure_rand);\n         }\n     };\n@@ -972,7 +972,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n             if (interruptMsgProc)\n                 return;\n \n-            it++;\n+            ++it;\n \n             if (inv.type == MSG_BLOCK || inv.type == MSG_FILTERED_BLOCK || inv.type == MSG_CMPCT_BLOCK || inv.type == MSG_WITNESS_BLOCK)\n             {\n@@ -1157,7 +1157,7 @@ uint32_t GetFetchFlags(CNode* pfrom) {\n \n inline void static SendBlockTransactions(const CBlock& block, const BlockTransactionsRequest& req, CNode* pfrom, CConnman& connman) {\n     BlockTransactions resp(req);\n-    for (size_t i = 0; i < req.indexes.size(); i++) {\n+    for (size_t i = 0; i < req.indexes.size(); ++i) {\n         if (req.indexes[i] >= block.vtx.size()) {\n             LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 100);\n@@ -1810,7 +1810,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (!AlreadyHave(inv) && AcceptToMemoryPool(mempool, state, ptx, true, &fMissingInputs, &lRemovedTxn)) {\n             mempool.check(pcoinsTip);\n             RelayTransaction(tx, connman);\n-            for (unsigned int i = 0; i < tx.vout.size(); i++) {\n+            for (unsigned int i = 0; i < tx.vout.size(); ++i) {\n                 vWorkQueue.emplace_back(inv.hash, i);\n             }\n \n@@ -1848,7 +1848,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     if (AcceptToMemoryPool(mempool, stateDummy, porphanTx, true, &fMissingInputs2, &lRemovedTxn)) {\n                         LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n                         RelayTransaction(orphanTx, connman);\n-                        for (unsigned int i = 0; i < orphanTx.vout.size(); i++) {\n+                        for (unsigned int i = 0; i < orphanTx.vout.size(); ++i) {\n                             vWorkQueue.emplace_back(orphanHash, i);\n                         }\n                         vEraseQueue.push_back(orphanHash);\n@@ -2079,7 +2079,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 }\n \n                 BlockTransactionsRequest req;\n-                for (size_t i = 0; i < cmpctblock.BlockTxCount(); i++) {\n+                for (size_t i = 0; i < cmpctblock.BlockTxCount(); ++i) {\n                     if (!partialBlock.IsTxAvailable(i))\n                         req.indexes.push_back(i);\n                 }\n@@ -2247,7 +2247,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return error(\"headers message size = %u\", nCount);\n         }\n         headers.resize(nCount);\n-        for (unsigned int n = 0; n < nCount; n++) {\n+        for (unsigned int n = 0; n < nCount; ++n) {\n             vRecv >> headers[n];\n             ReadCompactSize(vRecv); // ignore tx count; assume it is 0.\n         }\n@@ -2271,7 +2271,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // - Once a headers message is received that is valid and does connect,\n         //   nUnconnectingHeaders gets reset back to 0.\n         if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end() && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n-            nodestate->nUnconnectingHeaders++;\n+            ++nodestate->nUnconnectingHeaders;\n             connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n             LogPrint(BCLog::NET, \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n                     headers[0].GetHash().ToString(),\n@@ -2889,7 +2889,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             if ((nSyncStarted == 0 && fFetch) || pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {\n                 state.fSyncStarted = true;\n                 state.nHeadersSyncTimeout = GetTimeMicros() + HEADERS_DOWNLOAD_TIMEOUT_BASE + HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER * (GetAdjustedTime() - pindexBestHeader->GetBlockTime())/(consensusParams.nPowTargetSpacing);\n-                nSyncStarted++;\n+                ++nSyncStarted;\n                 const CBlockIndex *pindexStart = pindexBestHeader;\n                 /* If possible, start at the block preceding the currently\n                    best known header.  This ensures that we always get a\n@@ -3124,7 +3124,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                 // Produce a vector with all candidates for sending\n                 std::vector<std::set<uint256>::iterator> vInvTx;\n                 vInvTx.reserve(pto->setInventoryTxToSend.size());\n-                for (std::set<uint256>::iterator it = pto->setInventoryTxToSend.begin(); it != pto->setInventoryTxToSend.end(); it++) {\n+                for (std::set<uint256>::iterator it = pto->setInventoryTxToSend.begin(); it != pto->setInventoryTxToSend.end(); ++it) {\n                     vInvTx.push_back(it);\n                 }\n                 CAmount filterrate = 0;\n@@ -3163,7 +3163,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                     if (pto->pfilter && !pto->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                     // Send\n                     vInv.push_back(CInv(MSG_TX, hash));\n-                    nRelayedTransactions++;\n+                    ++nRelayedTransactions;\n                     {\n                         // Expire old relay messages\n                         while (!vRelayExpiration.empty() && vRelayExpiration.front().first < nNow)\n@@ -3234,7 +3234,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                         // getheaders message to be sent to\n                         // this peer (eventually).\n                         state.fSyncStarted = false;\n-                        nSyncStarted--;\n+                        --nSyncStarted;\n                         state.nHeadersSyncTimeout = 0;\n                     }\n                 }"
      },
      {
        "sha": "91952d2845ae61ce12a3bb014aa5a987025d4089",
        "filename": "src/policy/fees.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 28,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/policy/fees.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/policy/fees.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.cpp?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -182,11 +182,11 @@ TxConfirmStats::TxConfirmStats(const std::vector<double>& defaultBuckets,\n     decay = _decay;\n     scale = _scale;\n     confAvg.resize(maxPeriods);\n-    for (unsigned int i = 0; i < maxPeriods; i++) {\n+    for (unsigned int i = 0; i < maxPeriods; ++i) {\n         confAvg[i].resize(buckets.size());\n     }\n     failAvg.resize(maxPeriods);\n-    for (unsigned int i = 0; i < maxPeriods; i++) {\n+    for (unsigned int i = 0; i < maxPeriods; ++i) {\n         failAvg[i].resize(buckets.size());\n     }\n \n@@ -199,7 +199,7 @@ TxConfirmStats::TxConfirmStats(const std::vector<double>& defaultBuckets,\n void TxConfirmStats::resizeInMemoryCounters(size_t newbuckets) {\n     // newbuckets must be passed in because the buckets referred to during Read have not been updated yet.\n     unconfTxs.resize(GetMaxConfirms());\n-    for (unsigned int i = 0; i < unconfTxs.size(); i++) {\n+    for (unsigned int i = 0; i < unconfTxs.size(); ++i) {\n         unconfTxs[i].resize(newbuckets);\n     }\n     oldUnconfTxs.resize(newbuckets);\n@@ -208,7 +208,7 @@ void TxConfirmStats::resizeInMemoryCounters(size_t newbuckets) {\n // Roll the unconfirmed txs circular buffer\n void TxConfirmStats::ClearCurrent(unsigned int nBlockHeight)\n {\n-    for (unsigned int j = 0; j < buckets.size(); j++) {\n+    for (unsigned int j = 0; j < buckets.size(); ++j) {\n         oldUnconfTxs[j] += unconfTxs[nBlockHeight%unconfTxs.size()][j];\n         unconfTxs[nBlockHeight%unconfTxs.size()][j] = 0;\n     }\n@@ -222,19 +222,19 @@ void TxConfirmStats::Record(int blocksToConfirm, double val)\n         return;\n     int periodsToConfirm = (blocksToConfirm + scale - 1)/scale;\n     unsigned int bucketindex = bucketMap.lower_bound(val)->second;\n-    for (size_t i = periodsToConfirm; i <= confAvg.size(); i++) {\n-        confAvg[i - 1][bucketindex]++;\n+    for (size_t i = periodsToConfirm; i <= confAvg.size(); ++i) {\n+        ++confAvg[i - 1][bucketindex];\n     }\n-    txCtAvg[bucketindex]++;\n+    ++txCtAvg[bucketindex];\n     avg[bucketindex] += val;\n }\n \n void TxConfirmStats::UpdateMovingAverages()\n {\n-    for (unsigned int j = 0; j < buckets.size(); j++) {\n-        for (unsigned int i = 0; i < confAvg.size(); i++)\n+    for (unsigned int j = 0; j < buckets.size(); ++j) {\n+        for (unsigned int i = 0; i < confAvg.size(); ++i)\n             confAvg[i][j] = confAvg[i][j] * decay;\n-        for (unsigned int i = 0; i < failAvg.size(); i++)\n+        for (unsigned int i = 0; i < failAvg.size(); ++i)\n             failAvg[i][j] = failAvg[i][j] * decay;\n         avg[j] = avg[j] * decay;\n         txCtAvg[j] = txCtAvg[j] * decay;\n@@ -289,7 +289,7 @@ double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n         nConf += confAvg[periodTarget - 1][bucket];\n         totalNum += txCtAvg[bucket];\n         failNum += failAvg[periodTarget - 1][bucket];\n-        for (unsigned int confct = confTarget; confct < GetMaxConfirms(); confct++)\n+        for (unsigned int confct = confTarget; confct < GetMaxConfirms(); ++confct)\n             extraNum += unconfTxs[(nBlockHeight - confct)%bins][bucket];\n         extraNum += oldUnconfTxs[bucket];\n         // If we have enough transaction data points in this range of buckets,\n@@ -345,12 +345,12 @@ double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n     // and reporting the average which is less accurate\n     unsigned int minBucket = std::min(bestNearBucket, bestFarBucket);\n     unsigned int maxBucket = std::max(bestNearBucket, bestFarBucket);\n-    for (unsigned int j = minBucket; j <= maxBucket; j++) {\n+    for (unsigned int j = minBucket; j <= maxBucket; ++j) {\n         txSum += txCtAvg[j];\n     }\n     if (foundAnswer && txSum != 0) {\n         txSum = txSum / 2;\n-        for (unsigned int j = minBucket; j <= maxBucket; j++) {\n+        for (unsigned int j = minBucket; j <= maxBucket; ++j) {\n             if (txCtAvg[j] < txSum)\n                 txSum -= txCtAvg[j];\n             else { // we're in the right bucket\n@@ -435,7 +435,7 @@ void TxConfirmStats::Read(CAutoFile& filein, int nFileVersion, size_t numBuckets\n     if (maxConfirms <= 0 || maxConfirms > 6 * 24 * 7) { // one week\n         throw std::runtime_error(\"Corrupt estimates file.  Must maintain estimates for between 1 and 1008 (one week) confirms\");\n     }\n-    for (unsigned int i = 0; i < maxPeriods; i++) {\n+    for (unsigned int i = 0; i < maxPeriods; ++i) {\n         if (confAvg[i].size() != numBuckets) {\n             throw std::runtime_error(\"Corrupt estimates file. Mismatch in feerate conf average bucket count\");\n         }\n@@ -446,14 +446,14 @@ void TxConfirmStats::Read(CAutoFile& filein, int nFileVersion, size_t numBuckets\n         if (maxPeriods != failAvg.size()) {\n             throw std::runtime_error(\"Corrupt estimates file. Mismatch in confirms tracked for failures\");\n         }\n-        for (unsigned int i = 0; i < maxPeriods; i++) {\n+        for (unsigned int i = 0; i < maxPeriods; ++i) {\n             if (failAvg[i].size() != numBuckets) {\n                 throw std::runtime_error(\"Corrupt estimates file. Mismatch in one of failure average bucket counts\");\n             }\n         }\n     } else {\n         failAvg.resize(confAvg.size());\n-        for (unsigned int i = 0; i < failAvg.size(); i++) {\n+        for (unsigned int i = 0; i < failAvg.size(); ++i) {\n             failAvg[i].resize(numBuckets);\n         }\n     }\n@@ -470,7 +470,7 @@ unsigned int TxConfirmStats::NewTx(unsigned int nBlockHeight, double val)\n {\n     unsigned int bucketindex = bucketMap.lower_bound(val)->second;\n     unsigned int blockIndex = nBlockHeight % unconfTxs.size();\n-    unconfTxs[blockIndex][bucketindex]++;\n+    ++unconfTxs[blockIndex][bucketindex];\n     return bucketindex;\n }\n \n@@ -487,7 +487,7 @@ void TxConfirmStats::removeTx(unsigned int entryHeight, unsigned int nBestSeenHe\n \n     if (blocksAgo >= (int)unconfTxs.size()) {\n         if (oldUnconfTxs[bucketindex] > 0) {\n-            oldUnconfTxs[bucketindex]--;\n+            --oldUnconfTxs[bucketindex];\n         } else {\n             LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy error, mempool tx removed from >25 blocks,bucketIndex=%u already\\n\",\n                      bucketindex);\n@@ -496,16 +496,16 @@ void TxConfirmStats::removeTx(unsigned int entryHeight, unsigned int nBestSeenHe\n     else {\n         unsigned int blockIndex = entryHeight % unconfTxs.size();\n         if (unconfTxs[blockIndex][bucketindex] > 0) {\n-            unconfTxs[blockIndex][bucketindex]--;\n+            --unconfTxs[blockIndex][bucketindex];\n         } else {\n             LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy error, mempool tx removed from blockIndex=%u,bucketIndex=%u already\\n\",\n                      blockIndex, bucketindex);\n         }\n     }\n     if (!inBlock && (unsigned int)blocksAgo >= scale) { // Only counts as a failure if not confirmed for entire period\n         unsigned int periodsAgo = blocksAgo / scale;\n-        for (size_t i = 0; i < periodsAgo && i < failAvg.size(); i++) {\n-            failAvg[i][bucketindex]++;\n+        for (size_t i = 0; i < periodsAgo && i < failAvg.size(); ++i) {\n+            ++failAvg[i][bucketindex];\n         }\n     }\n }\n@@ -535,7 +535,7 @@ CBlockPolicyEstimator::CBlockPolicyEstimator()\n {\n     static_assert(MIN_BUCKET_FEERATE > 0, \"Min feerate must be nonzero\");\n     size_t bucketIndex = 0;\n-    for (double bucketBoundary = MIN_BUCKET_FEERATE; bucketBoundary <= MAX_BUCKET_FEERATE; bucketBoundary *= FEE_SPACING, bucketIndex++) {\n+    for (double bucketBoundary = MIN_BUCKET_FEERATE; bucketBoundary <= MAX_BUCKET_FEERATE; bucketBoundary *= FEE_SPACING, ++bucketIndex) {\n         buckets.push_back(bucketBoundary);\n         bucketMap[bucketBoundary] = bucketIndex;\n     }\n@@ -577,10 +577,10 @@ void CBlockPolicyEstimator::processTransaction(const CTxMemPoolEntry& entry, boo\n     // Only want to be updating estimates when our blockchain is synced,\n     // otherwise we'll miscalculate how many blocks its taking to get included.\n     if (!validFeeEstimate) {\n-        untrackedTxs++;\n+        ++untrackedTxs;\n         return;\n     }\n-    trackedTxs++;\n+    ++trackedTxs;\n \n     // Feerates are stored and reported as BTC-per-kb:\n     CFeeRate feeRate(entry.GetFee(), entry.GetTxSize());\n@@ -653,7 +653,7 @@ void CBlockPolicyEstimator::processBlock(unsigned int nBlockHeight,\n     // Update averages with data points from current block\n     for (const auto& entry : entries) {\n         if (processBlockTx(nBlockHeight, entry))\n-            countedTxs++;\n+            ++countedTxs;\n     }\n \n     if (firstRecordedHeight == 0 && countedTxs > 0) {\n@@ -965,7 +965,7 @@ bool CBlockPolicyEstimator::Read(CAutoFile& filein)\n             // if nVersionThatWrote < 139900 then another TxConfirmStats (for priority) follows but can be ignored.\n \n             tempMap.clear();\n-            for (unsigned int i = 0; i < tempBuckets.size(); i++) {\n+            for (unsigned int i = 0; i < tempBuckets.size(); ++i) {\n                 tempMap[tempBuckets[i]] = i;\n             }\n         }\n@@ -992,7 +992,7 @@ bool CBlockPolicyEstimator::Read(CAutoFile& filein)\n             // Copy buckets from file and refresh our bucketmap\n             buckets = fileBuckets;\n             bucketMap.clear();\n-            for (unsigned int i = 0; i < buckets.size(); i++) {\n+            for (unsigned int i = 0; i < buckets.size(); ++i) {\n                 bucketMap[buckets[i]] = i;\n             }\n \n@@ -1041,7 +1041,7 @@ CAmount FeeFilterRounder::round(CAmount currentMinFee)\n {\n     std::set<double>::iterator it = feeset.lower_bound(currentMinFee);\n     if ((it != feeset.begin() && insecure_rand.rand32() % 3 != 0) || it == feeset.end()) {\n-        it--;\n+        --it;\n     }\n     return *it;\n }"
      },
      {
        "sha": "ac3bf08862988db82761e73a17cae6f8e9a90320",
        "filename": "src/qt/bantablemodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/qt/bantablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/qt/bantablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bantablemodel.cpp?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -55,7 +55,7 @@ class BanTablePriv\n #if QT_VERSION >= 0x040700\n         cachedBanlist.reserve(banMap.size());\n #endif\n-        for (banmap_t::iterator it = banMap.begin(); it != banMap.end(); it++)\n+        for (banmap_t::iterator it = banMap.begin(); it != banMap.end(); ++it)\n         {\n             CCombinedBan banEntry;\n             banEntry.subnet = (*it).first;"
      },
      {
        "sha": "dbe51de63674f908ef53d3ad1ee25db61b715839",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -569,7 +569,7 @@ UniValue listbanned(const JSONRPCRequest& request)\n     g_connman->GetBanned(banMap);\n \n     UniValue bannedAddresses(UniValue::VARR);\n-    for (banmap_t::iterator it = banMap.begin(); it != banMap.end(); it++)\n+    for (banmap_t::iterator it = banMap.begin(); it != banMap.end(); ++it)\n     {\n         CBanEntry banEntry = (*it).second;\n         UniValue rec(UniValue::VOBJ);\n@@ -641,6 +641,6 @@ static const CRPCCommand commands[] =\n \n void RegisterNetRPCCommands(CRPCTable &t)\n {\n-    for (unsigned int vcidx = 0; vcidx < ARRAYLEN(commands); vcidx++)\n+    for (unsigned int vcidx = 0; vcidx < ARRAYLEN(commands); ++vcidx)\n         t.appendCommand(commands[vcidx].name, &commands[vcidx]);\n }"
      },
      {
        "sha": "4dfa410e6d75d7eda27caacf1682268228173e8f",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -81,7 +81,7 @@ class CCoinsViewCacheTest : public CCoinsViewCache\n         // Manually recompute the dynamic usage of the whole data, and compare it.\n         size_t ret = memusage::DynamicUsage(cacheCoins);\n         size_t count = 0;\n-        for (CCoinsMap::iterator it = cacheCoins.begin(); it != cacheCoins.end(); it++) {\n+        for (CCoinsMap::iterator it = cacheCoins.begin(); it != cacheCoins.end(); ++it) {\n             ret += it->second.coin.DynamicMemoryUsage();\n             ++count;\n         }\n@@ -132,11 +132,11 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n     // Use a limited set of random transaction ids, so we do test overwriting entries.\n     std::vector<uint256> txids;\n     txids.resize(NUM_SIMULATION_ITERATIONS / 8);\n-    for (unsigned int i = 0; i < txids.size(); i++) {\n+    for (unsigned int i = 0; i < txids.size(); ++i) {\n         txids[i] = InsecureRand256();\n     }\n \n-    for (unsigned int i = 0; i < NUM_SIMULATION_ITERATIONS; i++) {\n+    for (unsigned int i = 0; i < NUM_SIMULATION_ITERATIONS; ++i) {\n         // Do a random modification.\n         {\n             uint256 txid = txids[InsecureRandRange(txids.size())]; // txid we're going to modify in this iteration.\n@@ -189,7 +189,7 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n \n         // Once every 1000 iterations and at the end, verify the full cache.\n         if (InsecureRandRange(1000) == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n-            for (auto it = result.begin(); it != result.end(); it++) {\n+            for (auto it = result.begin(); it != result.end(); ++it) {\n                 bool have = stack.back()->HaveCoin(it->first);\n                 const Coin& coin = stack.back()->AccessCoin(it->first);\n                 BOOST_CHECK(have == !coin.IsSpent());\n@@ -293,7 +293,7 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n     std::set<COutPoint> duplicate_coins;\n     std::set<COutPoint> utxoset;\n \n-    for (unsigned int i = 0; i < NUM_SIMULATION_ITERATIONS; i++) {\n+    for (unsigned int i = 0; i < NUM_SIMULATION_ITERATIONS; ++i) {\n         uint32_t randiter = InsecureRand32();\n \n         // 19/20 txs add a new transaction\n@@ -420,7 +420,7 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n \n         // Once every 1000 iterations and at the end, verify the full cache.\n         if (InsecureRandRange(1000) == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n-            for (auto it = result.begin(); it != result.end(); it++) {\n+            for (auto it = result.begin(); it != result.end(); ++it) {\n                 bool have = stack.back()->HaveCoin(it->first);\n                 const Coin& coin = stack.back()->AccessCoin(it->first);\n                 BOOST_CHECK(have == !coin.IsSpent());"
      },
      {
        "sha": "880a9afb2a17d4b4194f902d8a64e4cbe8d1c512",
        "filename": "src/test/limitedmap_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/test/limitedmap_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/test/limitedmap_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/limitedmap_tests.cpp?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -31,7 +31,7 @@ BOOST_AUTO_TEST_CASE(limitedmap_test)\n     BOOST_CHECK(map.count(-1) == 1);\n \n     // insert 10 new items\n-    for (int i = 0; i < 10; i++) {\n+    for (int i = 0; i < 10; ++i) {\n         map.insert(std::pair<int, int>(i, i + 1));\n     }\n \n@@ -43,7 +43,7 @@ BOOST_AUTO_TEST_CASE(limitedmap_test)\n \n     // iterate over the map, both with an index and an iterator\n     limitedmap<int, int>::const_iterator it = map.begin();\n-    for (int i = 0; i < 10; i++) {\n+    for (int i = 0; i < 10; ++i) {\n         // make sure the item is present\n         BOOST_CHECK(map.count(i) == 1);\n \n@@ -58,7 +58,7 @@ BOOST_AUTO_TEST_CASE(limitedmap_test)\n         map.update(it, i + 2);\n         BOOST_CHECK(map.find(i)->second == i + 2);\n \n-        it++;\n+        ++it;\n     }\n \n     // check that we've exhausted the iterator\n@@ -73,7 +73,7 @@ BOOST_AUTO_TEST_CASE(limitedmap_test)\n \n     // check that items less than 5 have been discarded\n     // and items greater than 5 are retained\n-    for (int i = 0; i < 10; i++) {\n+    for (int i = 0; i < 10; ++i) {\n         if (i < 5) {\n             BOOST_CHECK(map.count(i) == 0);\n         } else {\n@@ -90,7 +90,7 @@ BOOST_AUTO_TEST_CASE(limitedmap_test)\n     BOOST_CHECK(map.size() == 5);\n \n     // erase the remaining elements\n-    for (int i = 5; i < 10; i++) {\n+    for (int i = 5; i < 10; ++i) {\n         map.erase(i);\n     }\n "
      },
      {
        "sha": "78f6cb96fde91c941ec7f21c53917dc44a4ae087",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -85,7 +85,7 @@ std::string FormatScriptFlags(unsigned int flags)\n         if (flags & it->second) {\n             ret += it->first + \",\";\n         }\n-        it++;\n+        ++it;\n     }\n     return ret.substr(0, ret.size() - 1);\n }\n@@ -104,7 +104,7 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n     UniValue tests = read_json(std::string(json_tests::tx_valid, json_tests::tx_valid + sizeof(json_tests::tx_valid)));\n \n     ScriptError err;\n-    for (unsigned int idx = 0; idx < tests.size(); idx++) {\n+    for (unsigned int idx = 0; idx < tests.size(); ++idx) {\n         UniValue test = tests[idx];\n         std::string strTest = test.write();\n         if (test[0].isArray())\n@@ -119,7 +119,7 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n             std::map<COutPoint, int64_t> mapprevOutValues;\n             UniValue inputs = test[0].get_array();\n             bool fValid = true;\n-\t    for (unsigned int inpIdx = 0; inpIdx < inputs.size(); inpIdx++) {\n+\t    for (unsigned int inpIdx = 0; inpIdx < inputs.size(); ++inpIdx) {\n \t        const UniValue& input = inputs[inpIdx];\n                 if (!input.isArray())\n                 {\n@@ -154,7 +154,7 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n             BOOST_CHECK(state.IsValid());\n \n             PrecomputedTransactionData txdata(tx);\n-            for (unsigned int i = 0; i < tx.vin.size(); i++)\n+            for (unsigned int i = 0; i < tx.vin.size(); ++i)\n             {\n                 if (!mapprevOutScriptPubKeys.count(tx.vin[i].prevout))\n                 {\n@@ -191,7 +191,7 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n     // Initialize to SCRIPT_ERR_OK. The tests expect err to be changed to a\n     // value other than SCRIPT_ERR_OK.\n     ScriptError err = SCRIPT_ERR_OK;\n-    for (unsigned int idx = 0; idx < tests.size(); idx++) {\n+    for (unsigned int idx = 0; idx < tests.size(); ++idx) {\n         UniValue test = tests[idx];\n         std::string strTest = test.write();\n         if (test[0].isArray())\n@@ -206,7 +206,7 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n             std::map<COutPoint, int64_t> mapprevOutValues;\n             UniValue inputs = test[0].get_array();\n             bool fValid = true;\n-\t    for (unsigned int inpIdx = 0; inpIdx < inputs.size(); inpIdx++) {\n+\t    for (unsigned int inpIdx = 0; inpIdx < inputs.size(); ++inpIdx) {\n \t        const UniValue& input = inputs[inpIdx];\n                 if (!input.isArray())\n                 {\n@@ -240,7 +240,7 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n             fValid = CheckTransaction(tx, state) && state.IsValid();\n \n             PrecomputedTransactionData txdata(tx);\n-            for (unsigned int i = 0; i < tx.vin.size() && fValid; i++)\n+            for (unsigned int i = 0; i < tx.vin.size() && fValid; ++i)\n             {\n                 if (!mapprevOutScriptPubKeys.count(tx.vin[i].prevout))\n                 {\n@@ -293,7 +293,7 @@ SetupDummyInputs(CBasicKeyStore& keystoreRet, CCoinsViewCache& coinsRet)\n \n     // Add some keys to the keystore:\n     CKey key[4];\n-    for (int i = 0; i < 4; i++)\n+    for (int i = 0; i < 4; ++i)\n     {\n         key[i].MakeNewKey(i % 2);\n         keystoreRet.AddKey(key[i]);\n@@ -433,7 +433,7 @@ BOOST_AUTO_TEST_CASE(test_big_witness_transaction) {\n     sigHashes.push_back(SIGHASH_ALL);\n \n     // create a big transaction of 4500 inputs signed by the same key\n-    for(uint32_t ij = 0; ij < 4500; ij++) {\n+    for(uint32_t ij = 0; ij < 4500; ++ij) {\n         uint32_t i = mtx.vin.size();\n         uint256 prevId;\n         prevId.SetHex(\"0000000000000000000000000000000000000000000000000000000000000100\");\n@@ -449,7 +449,7 @@ BOOST_AUTO_TEST_CASE(test_big_witness_transaction) {\n     }\n \n     // sign all inputs\n-    for(uint32_t i = 0; i < mtx.vin.size(); i++) {\n+    for(uint32_t i = 0; i < mtx.vin.size(); ++i) {\n         bool hashSigned = SignSignature(keystore, scriptPubKey, mtx, i, 1000, sigHashes.at(i % sigHashes.size()));\n         assert(hashSigned);\n     }\n@@ -465,11 +465,11 @@ BOOST_AUTO_TEST_CASE(test_big_witness_transaction) {\n     CCheckQueue<CScriptCheck> scriptcheckqueue(128);\n     CCheckQueueControl<CScriptCheck> control(&scriptcheckqueue);\n \n-    for (int i=0; i<20; i++)\n+    for (int i=0; i<20; ++i)\n         threadGroup.create_thread(boost::bind(&CCheckQueue<CScriptCheck>::Thread, boost::ref(scriptcheckqueue)));\n \n     std::vector<Coin> coins;\n-    for(uint32_t i = 0; i < mtx.vin.size(); i++) {\n+    for(uint32_t i = 0; i < mtx.vin.size(); ++i) {\n         Coin coin;\n         coin.nHeight = 1;\n         coin.fCoinBase = false;\n@@ -478,7 +478,7 @@ BOOST_AUTO_TEST_CASE(test_big_witness_transaction) {\n         coins.emplace_back(std::move(coin));\n     }\n \n-    for(uint32_t i = 0; i < mtx.vin.size(); i++) {\n+    for(uint32_t i = 0; i < mtx.vin.size(); ++i) {\n         std::vector<CScriptCheck> vChecks;\n         const CTxOut& output = coins[tx.vin[i].prevout.n].out;\n         CScriptCheck check(output.scriptPubKey, output.nValue, tx, i, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false, &txdata);"
      },
      {
        "sha": "470f01cfc3fc7c3e7d469751dcc5b35cc26bc7ed",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -113,9 +113,9 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n                 batch.Erase(entry);\n             else\n                 batch.Write(entry, it->second.coin);\n-            changed++;\n+            ++changed;\n         }\n-        count++;\n+        ++count;\n         CCoinsMap::iterator itOld = it++;\n         mapCoins.erase(itOld);\n         if (batch.SizeEstimate() > batch_size) {\n@@ -226,11 +226,11 @@ void CCoinsViewDBCursor::Next()\n \n bool CBlockTreeDB::WriteBatchSync(const std::vector<std::pair<int, const CBlockFileInfo*> >& fileInfo, int nLastFile, const std::vector<const CBlockIndex*>& blockinfo) {\n     CDBBatch batch(*this);\n-    for (std::vector<std::pair<int, const CBlockFileInfo*> >::const_iterator it=fileInfo.begin(); it != fileInfo.end(); it++) {\n+    for (std::vector<std::pair<int, const CBlockFileInfo*> >::const_iterator it=fileInfo.begin(); it != fileInfo.end(); ++it) {\n         batch.Write(std::make_pair(DB_BLOCK_FILES, it->first), *it->second);\n     }\n     batch.Write(DB_LAST_BLOCK, nLastFile);\n-    for (std::vector<const CBlockIndex*>::const_iterator it=blockinfo.begin(); it != blockinfo.end(); it++) {\n+    for (std::vector<const CBlockIndex*>::const_iterator it=blockinfo.begin(); it != blockinfo.end(); ++it) {\n         batch.Write(std::make_pair(DB_BLOCK_INDEX, (*it)->GetBlockHash()), CDiskBlockIndex(*it));\n     }\n     return WriteBatch(batch, true);\n@@ -242,7 +242,7 @@ bool CBlockTreeDB::ReadTxIndex(const uint256 &txid, CDiskTxPos &pos) {\n \n bool CBlockTreeDB::WriteTxIndex(const std::vector<std::pair<uint256, CDiskTxPos> >&vect) {\n     CDBBatch batch(*this);\n-    for (std::vector<std::pair<uint256,CDiskTxPos> >::const_iterator it=vect.begin(); it!=vect.end(); it++)\n+    for (std::vector<std::pair<uint256,CDiskTxPos> >::const_iterator it=vect.begin(); it!=vect.end(); ++it)\n         batch.Write(std::make_pair(DB_TXINDEX, it->first), it->second);\n     return WriteBatch(batch);\n }\n@@ -337,16 +337,16 @@ class CCoins\n         while (nMaskCode > 0) {\n             unsigned char chAvail = 0;\n             ::Unserialize(s, chAvail);\n-            for (unsigned int p = 0; p < 8; p++) {\n+            for (unsigned int p = 0; p < 8; ++p) {\n                 bool f = (chAvail & (1 << p)) != 0;\n                 vAvail.push_back(f);\n             }\n             if (chAvail != 0)\n-                nMaskCode--;\n+                --nMaskCode;\n         }\n         // txouts themself\n         vout.assign(vAvail.size(), CTxOut());\n-        for (unsigned int i = 0; i < vAvail.size(); i++) {\n+        for (unsigned int i = 0; i < vAvail.size(); ++i) {\n             if (vAvail[i])\n                 ::Unserialize(s, REF(CTxOutCompressor(vout[i])));\n         }"
      },
      {
        "sha": "06289aebf02a9f2836d1a0ea720027386eb70159",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -97,7 +97,7 @@ void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendan\n         if (!setExclude.count(cit->GetTx().GetHash())) {\n             modifySize += cit->GetTxSize();\n             modifyFee += cit->GetModifiedFee();\n-            modifyCount++;\n+            ++modifyCount;\n             cachedDescendants[updateIt].insert(cit);\n             // Update ancestor state for each descendant\n             mapTx.modify(cit, update_ancestor_state(updateIt->GetTxSize(), updateIt->GetModifiedFee(), 1, updateIt->GetSigOpCost()));\n@@ -165,7 +165,7 @@ bool CTxMemPool::CalculateMemPoolAncestors(const CTxMemPoolEntry &entry, setEntr\n         // Get parents of this transaction that are in the mempool\n         // GetMemPoolParents() is only valid for entries in the mempool, so we\n         // iterate mapTx to find parents.\n-        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+        for (unsigned int i = 0; i < tx.vin.size(); ++i) {\n             txiter piter = mapTx.find(tx.vin[i].prevout.hash);\n             if (piter != mapTx.end()) {\n                 parentHashes.insert(piter);\n@@ -390,7 +390,7 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,\n \n     const CTransaction& tx = newit->GetTx();\n     std::set<uint256> setParentTransactions;\n-    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+    for (unsigned int i = 0; i < tx.vin.size(); ++i) {\n         mapNextTx.insert(std::make_pair(&tx.vin[i].prevout, &tx));\n         setParentTransactions.insert(tx.vin[i].prevout.hash);\n     }\n@@ -411,7 +411,7 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,\n     UpdateAncestorsOf(true, newit, setAncestors);\n     UpdateEntryForAncestors(newit, setAncestors);\n \n-    nTransactionsUpdated++;\n+    ++nTransactionsUpdated;\n     totalTxSize += entry.GetTxSize();\n     if (minerPolicyEstimator) {minerPolicyEstimator->processTransaction(entry, validFeeEstimate);}\n \n@@ -442,7 +442,7 @@ void CTxMemPool::removeUnchecked(txiter it, MemPoolRemovalReason reason)\n     cachedInnerUsage -= memusage::DynamicUsage(mapLinks[it].parents) + memusage::DynamicUsage(mapLinks[it].children);\n     mapLinks.erase(it);\n     mapTx.erase(it);\n-    nTransactionsUpdated++;\n+    ++nTransactionsUpdated;\n     if (minerPolicyEstimator) {minerPolicyEstimator->removeTx(hash, false);}\n }\n \n@@ -489,7 +489,7 @@ void CTxMemPool::removeRecursive(const CTransaction &origTx, MemPoolRemovalReaso\n             // be sure to remove any children that are in the pool. This can\n             // happen during chain re-orgs if origTx isn't re-accepted into\n             // the mempool for any reason.\n-            for (unsigned int i = 0; i < origTx.vout.size(); i++) {\n+            for (unsigned int i = 0; i < origTx.vout.size(); ++i) {\n                 auto it = mapNextTx.find(COutPoint(origTx.GetHash(), i));\n                 if (it == mapNextTx.end())\n                     continue;\n@@ -512,7 +512,7 @@ void CTxMemPool::removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMem\n     // Remove transactions spending a coinbase which are now immature and no-longer-final transactions\n     LOCK(cs);\n     setEntries txToRemove;\n-    for (indexed_transaction_set::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n+    for (indexed_transaction_set::const_iterator it = mapTx.begin(); it != mapTx.end(); ++it) {\n         const CTransaction& tx = it->GetTx();\n         LockPoints lp = it->GetLockPoints();\n         bool validLP =  TestLockPointValidity(&lp);\n@@ -630,7 +630,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n \n     LOCK(cs);\n     std::list<const CTxMemPoolEntry*> waitingOnDependants;\n-    for (indexed_transaction_set::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n+    for (indexed_transaction_set::const_iterator it = mapTx.begin(); it != mapTx.end(); ++it) {\n         unsigned int i = 0;\n         checkTotal += it->GetTxSize();\n         innerUsage += it->DynamicMemoryUsage();\n@@ -662,7 +662,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n             assert(it3 != mapNextTx.end());\n             assert(it3->first == &txin.prevout);\n             assert(it3->second == &tx);\n-            i++;\n+            ++i;\n         }\n         assert(setParentCheck == GetMemPoolParents(it));\n         // Verify ancestor state is correct.\n@@ -719,7 +719,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n         CValidationState state;\n         if (!mempoolDuplicate.HaveInputs(entry->GetTx())) {\n             waitingOnDependants.push_back(entry);\n-            stepsSinceLastRemove++;\n+            ++stepsSinceLastRemove;\n             assert(stepsSinceLastRemove < waitingOnDependants.size());\n         } else {\n             bool fCheckResult = entry->GetTx().IsCoinBase() ||\n@@ -729,7 +729,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n             stepsSinceLastRemove = 0;\n         }\n     }\n-    for (auto it = mapNextTx.cbegin(); it != mapNextTx.cend(); it++) {\n+    for (auto it = mapNextTx.cbegin(); it != mapNextTx.cend(); ++it) {\n         uint256 hash = it->second->GetHash();\n         indexed_transaction_set::const_iterator it2 = mapTx.find(hash);\n         const CTransaction& tx = it2->GetTx();\n@@ -883,7 +883,7 @@ void CTxMemPool::ClearPrioritisation(const uint256 hash)\n \n bool CTxMemPool::HasNoInputsOf(const CTransaction &tx) const\n {\n-    for (unsigned int i = 0; i < tx.vin.size(); i++)\n+    for (unsigned int i = 0; i < tx.vin.size(); ++i)\n         if (exists(tx.vin[i].prevout.hash))\n             return false;\n     return true;\n@@ -927,7 +927,7 @@ int CTxMemPool::Expire(int64_t time) {\n     setEntries toremove;\n     while (it != mapTx.get<entry_time>().end() && it->GetTime() < time) {\n         toremove.insert(mapTx.project<0>(it));\n-        it++;\n+        ++it;\n     }\n     setEntries stage;\n     for (txiter removeit : toremove) {"
      },
      {
        "sha": "4e21313e2744327e44280824f5a80affcb87e65a",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 43,
        "changes": 86,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -272,7 +272,7 @@ bool CheckSequenceLocks(const CTransaction &tx, int flags, LockPoints* lp, bool\n         CCoinsViewMemPool viewMemPool(pcoinsTip, mempool);\n         std::vector<int> prevheights;\n         prevheights.resize(tx.vin.size());\n-        for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n+        for (size_t txinIndex = 0; txinIndex < tx.vin.size(); ++txinIndex) {\n             const CTxIn& txin = tx.vin[txinIndex];\n             Coin coin;\n             if (!viewMemPool.GetCoin(txin.prevout, coin)) {\n@@ -540,7 +540,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             }\n             if (!view.HaveCoin(txin.prevout)) {\n                 // Are inputs missing because we already have the tx?\n-                for (size_t out = 0; out < tx.vout.size(); out++) {\n+                for (size_t out = 0; out < tx.vout.size(); ++out) {\n                     // Optimistically just do efficient check of cache for outputs\n                     if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n                         return state.Invalid(false, REJECT_DUPLICATE, \"txn-already-known\");\n@@ -737,7 +737,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                             maxDescendantsToVisit));\n             }\n \n-            for (unsigned int j = 0; j < tx.vin.size(); j++)\n+            for (unsigned int j = 0; j < tx.vin.size(); ++j)\n             {\n                 // We don't want to accept replacements that require low\n                 // feerate junk to be mined first. Ideally we'd keep track of\n@@ -1271,7 +1271,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                 return true;\n             }\n \n-            for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            for (unsigned int i = 0; i < tx.vin.size(); ++i) {\n                 const COutPoint &prevout = tx.vin[i].prevout;\n                 const Coin& coin = inputs.AccessCoin(prevout);\n                 assert(!coin.IsSpent());\n@@ -1463,14 +1463,14 @@ static DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex*\n     }\n \n     // undo transactions in reverse order\n-    for (int i = block.vtx.size() - 1; i >= 0; i--) {\n+    for (int i = block.vtx.size() - 1; i >= 0; --i) {\n         const CTransaction &tx = *(block.vtx[i]);\n         uint256 hash = tx.GetHash();\n         bool is_coinbase = tx.IsCoinBase();\n \n         // Check that all outputs are available and match the outputs in the block itself\n         // exactly.\n-        for (size_t o = 0; o < tx.vout.size(); o++) {\n+        for (size_t o = 0; o < tx.vout.size(); ++o) {\n             if (!tx.vout[o].scriptPubKey.IsUnspendable()) {\n                 COutPoint out(hash, o);\n                 Coin coin;\n@@ -1544,7 +1544,7 @@ int32_t ComputeBlockVersion(const CBlockIndex* pindexPrev, const Consensus::Para\n     LOCK(cs_main);\n     int32_t nVersion = VERSIONBITS_TOP_BITS;\n \n-    for (int i = 0; i < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; i++) {\n+    for (int i = 0; i < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++i) {\n         ThresholdState state = VersionBitsState(pindexPrev, params, (Consensus::DeploymentPos)i, versionbitscache);\n         if (state == THRESHOLD_LOCKED_IN || state == THRESHOLD_STARTED) {\n             nVersion |= VersionBitsMask(params, (Consensus::DeploymentPos)i);\n@@ -1710,7 +1710,7 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n \n     if (fEnforceBIP30) {\n         for (const auto& tx : block.vtx) {\n-            for (size_t o = 0; o < tx->vout.size(); o++) {\n+            for (size_t o = 0; o < tx->vout.size(); ++o) {\n                 if (view.HaveCoin(COutPoint(tx->GetHash(), o))) {\n                     return state.DoS(100, error(\"ConnectBlock(): tried to overwrite transaction\"),\n                                      REJECT_INVALID, \"bad-txns-BIP30\");\n@@ -1745,7 +1745,7 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n     blockundo.vtxundo.reserve(block.vtx.size() - 1);\n     std::vector<PrecomputedTransactionData> txdata;\n     txdata.reserve(block.vtx.size()); // Required so that pointers to individual PrecomputedTransactionData don't get invalidated\n-    for (unsigned int i = 0; i < block.vtx.size(); i++)\n+    for (unsigned int i = 0; i < block.vtx.size(); ++i)\n     {\n         const CTransaction &tx = *(block.vtx[i]);\n \n@@ -1761,7 +1761,7 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n             // BIP68 lock checks (as opposed to nLockTime checks) must\n             // be in ConnectBlock because they require the UTXO set\n             prevheights.resize(tx.vin.size());\n-            for (size_t j = 0; j < tx.vin.size(); j++) {\n+            for (size_t j = 0; j < tx.vin.size(); ++j) {\n                 prevheights[j] = view.AccessCoin(tx.vin[j].prevout).nHeight;\n             }\n \n@@ -2006,7 +2006,7 @@ void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {\n     {\n         int nUpgraded = 0;\n         const CBlockIndex* pindex = chainActive.Tip();\n-        for (int bit = 0; bit < VERSIONBITS_NUM_BITS; bit++) {\n+        for (int bit = 0; bit < VERSIONBITS_NUM_BITS; ++bit) {\n             WarningBitsConditionChecker checker(bit);\n             ThresholdState state = checker.GetStateFor(pindex, chainParams.GetConsensus(), warningcache[bit]);\n             if (state == THRESHOLD_ACTIVE || state == THRESHOLD_LOCKED_IN) {\n@@ -2019,7 +2019,7 @@ void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {\n             }\n         }\n         // Check the version of the last 100 blocks to see if we need to upgrade:\n-        for (int i = 0; i < 100 && pindex != nullptr; i++)\n+        for (int i = 0; i < 100 && pindex != nullptr; ++i)\n         {\n             int32_t nExpectedVersion = ComputeBlockVersion(pindex->pprev, chainParams.GetConsensus());\n             if (pindex->nVersion > VERSIONBITS_LAST_OLD_BLOCK_VERSION && (pindex->nVersion & ~nExpectedVersion) != 0)\n@@ -2503,7 +2503,7 @@ bool PreciousBlock(CValidationState& state, const CChainParams& params, CBlockIn\n         if (nBlockReverseSequenceId > std::numeric_limits<int32_t>::min()) {\n             // We can't keep reducing the counter if somebody really wants to\n             // call preciousblock 2**31-1 times on the same set of tips...\n-            nBlockReverseSequenceId--;\n+            --nBlockReverseSequenceId;\n         }\n         if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && pindex->nChainTx) {\n             setBlockIndexCandidates.insert(pindex);\n@@ -2550,7 +2550,7 @@ bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, C\n         if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->nChainTx && !setBlockIndexCandidates.value_comp()(it->second, chainActive.Tip())) {\n             setBlockIndexCandidates.insert(it->second);\n         }\n-        it++;\n+        ++it;\n     }\n \n     InvalidChainFound(pindex);\n@@ -2577,7 +2577,7 @@ bool ResetBlockFailureFlags(CBlockIndex *pindex) {\n                 pindexBestInvalid = nullptr;\n             }\n         }\n-        it++;\n+        ++it;\n     }\n \n     // Remove the invalidity flag from all ancestors too.\n@@ -2662,7 +2662,7 @@ static bool ReceivedBlockTransactions(const CBlock &block, CValidationState& sta\n             while (range.first != range.second) {\n                 std::multimap<CBlockIndex*, CBlockIndex*>::iterator it = range.first;\n                 queue.push_back(it->second);\n-                range.first++;\n+                ++range.first;\n                 mapBlocksUnlinked.erase(it);\n             }\n         }\n@@ -2686,7 +2686,7 @@ static bool FindBlockPos(CValidationState &state, CDiskBlockPos &pos, unsigned i\n \n     if (!fKnown) {\n         while (vinfoBlockFile[nFile].nSize + nAddSize >= MAX_BLOCKFILE_SIZE) {\n-            nFile++;\n+            ++nFile;\n             if (vinfoBlockFile.size() <= nFile) {\n                 vinfoBlockFile.resize(nFile + 1);\n             }\n@@ -2811,7 +2811,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n     // First transaction must be coinbase, the rest must not be\n     if (block.vtx.empty() || !block.vtx[0]->IsCoinBase())\n         return state.DoS(100, false, REJECT_INVALID, \"bad-cb-missing\", false, \"first tx is not coinbase\");\n-    for (unsigned int i = 1; i < block.vtx.size(); i++)\n+    for (unsigned int i = 1; i < block.vtx.size(); ++i)\n         if (block.vtx[i]->IsCoinBase())\n             return state.DoS(100, false, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\");\n \n@@ -2847,7 +2847,7 @@ static int GetWitnessCommitmentIndex(const CBlock& block)\n {\n     int commitpos = -1;\n     if (!block.vtx.empty()) {\n-        for (size_t o = 0; o < block.vtx[0]->vout.size(); o++) {\n+        for (size_t o = 0; o < block.vtx[0]->vout.size(); ++o) {\n             if (block.vtx[0]->vout[o].scriptPubKey.size() >= 38 && block.vtx[0]->vout[o].scriptPubKey[0] == OP_RETURN && block.vtx[0]->vout[o].scriptPubKey[1] == 0x24 && block.vtx[0]->vout[o].scriptPubKey[2] == 0xaa && block.vtx[0]->vout[o].scriptPubKey[3] == 0x21 && block.vtx[0]->vout[o].scriptPubKey[4] == 0xa9 && block.vtx[0]->vout[o].scriptPubKey[5] == 0xed) {\n                 commitpos = o;\n             }\n@@ -3252,7 +3252,7 @@ void PruneOneBlockFile(const int fileNumber)\n             std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = mapBlocksUnlinked.equal_range(pindex->pprev);\n             while (range.first != range.second) {\n                 std::multimap<CBlockIndex *, CBlockIndex *>::iterator _it = range.first;\n-                range.first++;\n+                ++range.first;\n                 if (_it->second == pindex) {\n                     mapBlocksUnlinked.erase(_it);\n                 }\n@@ -3287,12 +3287,12 @@ static void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPr\n     // last block to prune is the lesser of (user-specified height, MIN_BLOCKS_TO_KEEP from the tip)\n     unsigned int nLastBlockWeCanPrune = std::min((unsigned)nManualPruneHeight, chainActive.Tip()->nHeight - MIN_BLOCKS_TO_KEEP);\n     int count=0;\n-    for (int fileNumber = 0; fileNumber < nLastBlockFile; fileNumber++) {\n+    for (int fileNumber = 0; fileNumber < nLastBlockFile; ++fileNumber) {\n         if (vinfoBlockFile[fileNumber].nSize == 0 || vinfoBlockFile[fileNumber].nHeightLast > nLastBlockWeCanPrune)\n             continue;\n         PruneOneBlockFile(fileNumber);\n         setFilesToPrune.insert(fileNumber);\n-        count++;\n+        ++count;\n     }\n     LogPrintf(\"Prune (Manual): prune_height=%d removed %d blk/rev pairs\\n\", nLastBlockWeCanPrune, count);\n }\n@@ -3340,7 +3340,7 @@ static void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfte\n     int count=0;\n \n     if (nCurrentUsage + nBuffer >= nPruneTarget) {\n-        for (int fileNumber = 0; fileNumber < nLastBlockFile; fileNumber++) {\n+        for (int fileNumber = 0; fileNumber < nLastBlockFile; ++fileNumber) {\n             nBytesToPrune = vinfoBlockFile[fileNumber].nSize + vinfoBlockFile[fileNumber].nUndoSize;\n \n             if (vinfoBlockFile[fileNumber].nSize == 0)\n@@ -3357,7 +3357,7 @@ static void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfte\n             // Queue up the files for removal\n             setFilesToPrune.insert(fileNumber);\n             nCurrentUsage -= nBytesToPrune;\n-            count++;\n+            ++count;\n         }\n     }\n \n@@ -3484,11 +3484,11 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams)\n     pblocktree->ReadLastBlockFile(nLastBlockFile);\n     vinfoBlockFile.resize(nLastBlockFile + 1);\n     LogPrintf(\"%s: last block file = %i\\n\", __func__, nLastBlockFile);\n-    for (int nFile = 0; nFile <= nLastBlockFile; nFile++) {\n+    for (int nFile = 0; nFile <= nLastBlockFile; ++nFile) {\n         pblocktree->ReadBlockFileInfo(nFile, vinfoBlockFile[nFile]);\n     }\n     LogPrintf(\"%s: last block file info: %s\\n\", __func__, vinfoBlockFile[nLastBlockFile].ToString());\n-    for (int nFile = nLastBlockFile + 1; true; nFile++) {\n+    for (int nFile = nLastBlockFile + 1; true; ++nFile) {\n         CBlockFileInfo info;\n         if (pblocktree->ReadBlockFileInfo(nFile, info)) {\n             vinfoBlockFile.push_back(info);\n@@ -3507,7 +3507,7 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams)\n             setBlkDataFiles.insert(pindex->nFile);\n         }\n     }\n-    for (std::set<int>::iterator it = setBlkDataFiles.begin(); it != setBlkDataFiles.end(); it++)\n+    for (std::set<int>::iterator it = setBlkDataFiles.begin(); it != setBlkDataFiles.end(); ++it)\n     {\n         CDiskBlockPos pos(*it, 0);\n         if (CAutoFile(OpenBlockFile(pos, true), SER_DISK, CLIENT_VERSION).IsNull()) {\n@@ -3762,7 +3762,7 @@ bool RewindBlockIndex(const CChainParams& params)\n         if (IsWitnessEnabled(chainActive[nHeight - 1], params.GetConsensus()) && !(chainActive[nHeight]->nStatus & BLOCK_OPT_WITNESS)) {\n             break;\n         }\n-        nHeight++;\n+        ++nHeight;\n     }\n \n     // nHeight is now the height of the first insufficiently-validated block, or tipheight + 1\n@@ -3788,7 +3788,7 @@ bool RewindBlockIndex(const CChainParams& params)\n     // Reduce validity flag and have-data flags.\n     // We do this after actual disconnecting, otherwise we'll end up writing the lack of data\n     // to disk before writing the chainstate, resulting in a failure to continue if interrupted.\n-    for (BlockMap::iterator it = mapBlockIndex.begin(); it != mapBlockIndex.end(); it++) {\n+    for (BlockMap::iterator it = mapBlockIndex.begin(); it != mapBlockIndex.end(); ++it) {\n         CBlockIndex* pindexIter = it->second;\n \n         // Note: If we encounter an insufficiently validated block that\n@@ -3862,7 +3862,7 @@ void UnloadBlockIndex()\n     setDirtyBlockIndex.clear();\n     setDirtyFileInfo.clear();\n     versionbitscache.Clear();\n-    for (int b = 0; b < VERSIONBITS_NUM_BITS; b++) {\n+    for (int b = 0; b < VERSIONBITS_NUM_BITS; ++b) {\n         warningcache[b].clear();\n     }\n \n@@ -3944,7 +3944,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n             boost::this_thread::interruption_point();\n \n             blkdat.SetPos(nRewind);\n-            nRewind++; // start one byte further next time, in case of failure\n+            ++nRewind; // start one byte further next time, in case of failure\n             blkdat.SetLimit(); // remove former limit\n             unsigned int nSize = 0;\n             try {\n@@ -3990,7 +3990,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n                     LOCK(cs_main);\n                     CValidationState state;\n                     if (AcceptBlock(pblock, state, chainparams, nullptr, true, dbp, nullptr))\n-                        nLoaded++;\n+                        ++nLoaded;\n                     if (state.IsError())\n                         break;\n                 } else if (hash != chainparams.GetConsensus().hashGenesisBlock && mapBlockIndex[hash]->nHeight % 1000 == 0) {\n@@ -4025,11 +4025,11 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n                             CValidationState dummy;\n                             if (AcceptBlock(pblockrecursive, dummy, chainparams, nullptr, true, &it->second, nullptr))\n                             {\n-                                nLoaded++;\n+                                ++nLoaded;\n                                 queue.push_back(pblockrecursive->GetHash());\n                             }\n                         }\n-                        range.first++;\n+                        ++range.first;\n                         mapBlocksUnknownParent.erase(it);\n                         NotifyHeaderTip();\n                     }\n@@ -4064,15 +4064,15 @@ void static CheckBlockIndex(const Consensus::Params& consensusParams)\n \n     // Build forward-pointing map of the entire block tree.\n     std::multimap<CBlockIndex*,CBlockIndex*> forward;\n-    for (BlockMap::iterator it = mapBlockIndex.begin(); it != mapBlockIndex.end(); it++) {\n+    for (BlockMap::iterator it = mapBlockIndex.begin(); it != mapBlockIndex.end(); ++it) {\n         forward.insert(std::make_pair(it->second->pprev, it->second));\n     }\n \n     assert(forward.size() == mapBlockIndex.size());\n \n     std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangeGenesis = forward.equal_range(nullptr);\n     CBlockIndex *pindex = rangeGenesis.first->second;\n-    rangeGenesis.first++;\n+    ++rangeGenesis.first;\n     assert(rangeGenesis.first == rangeGenesis.second); // There is only one index entry with parent nullptr.\n \n     // Iterate over the entire block tree, using depth-first search.\n@@ -4088,7 +4088,7 @@ void static CheckBlockIndex(const Consensus::Params& consensusParams)\n     CBlockIndex* pindexFirstNotChainValid = nullptr; // Oldest ancestor of pindex which does not have BLOCK_VALID_CHAIN (regardless of being valid or not).\n     CBlockIndex* pindexFirstNotScriptsValid = nullptr; // Oldest ancestor of pindex which does not have BLOCK_VALID_SCRIPTS (regardless of being valid or not).\n     while (pindex != nullptr) {\n-        nNodes++;\n+        ++nNodes;\n         if (pindexFirstInvalid == nullptr && pindex->nStatus & BLOCK_FAILED_VALID) pindexFirstInvalid = pindex;\n         if (pindexFirstMissing == nullptr && !(pindex->nStatus & BLOCK_HAVE_DATA)) pindexFirstMissing = pindex;\n         if (pindexFirstNeverProcessed == nullptr && pindex->nTx == 0) pindexFirstNeverProcessed = pindex;\n@@ -4155,7 +4155,7 @@ void static CheckBlockIndex(const Consensus::Params& consensusParams)\n                 foundInUnlinked = true;\n                 break;\n             }\n-            rangeUnlinked.first++;\n+            ++rangeUnlinked.first;\n         }\n         if (pindex->pprev && (pindex->nStatus & BLOCK_HAVE_DATA) && pindexFirstNeverProcessed != nullptr && pindexFirstInvalid == nullptr) {\n             // If this block has block data available, some parent was never received, and has no invalid parents, it must be in mapBlocksUnlinked.\n@@ -4188,7 +4188,7 @@ void static CheckBlockIndex(const Consensus::Params& consensusParams)\n         if (range.first != range.second) {\n             // A subnode was found.\n             pindex = range.first->second;\n-            nHeight++;\n+            ++nHeight;\n             continue;\n         }\n         // This is a leaf node.\n@@ -4209,18 +4209,18 @@ void static CheckBlockIndex(const Consensus::Params& consensusParams)\n             std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangePar = forward.equal_range(pindexPar);\n             while (rangePar.first->second != pindex) {\n                 assert(rangePar.first != rangePar.second); // Our parent must have at least the node we're coming from as child.\n-                rangePar.first++;\n+                ++rangePar.first;\n             }\n             // Proceed to the next one.\n-            rangePar.first++;\n+            ++rangePar.first;\n             if (rangePar.first != rangePar.second) {\n                 // Move to the sibling.\n                 pindex = rangePar.first->second;\n                 break;\n             } else {\n                 // Move up further.\n                 pindex = pindexPar;\n-                nHeight--;\n+                --nHeight;\n                 continue;\n             }\n         }\n@@ -4398,7 +4398,7 @@ class CMainCleanup\n     ~CMainCleanup() {\n         // block headers\n         BlockMap::iterator it1 = mapBlockIndex.begin();\n-        for (; it1 != mapBlockIndex.end(); it1++)\n+        for (; it1 != mapBlockIndex.end(); ++it1)\n             delete (*it1).second;\n         mapBlockIndex.clear();\n     }"
      },
      {
        "sha": "916bbfa21e8bf6c3274d3097ebb920bc71ef7f07",
        "filename": "src/wallet/crypter.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/wallet/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/wallet/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/crypter.h?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -182,7 +182,7 @@ class CCryptoKeyStore : public CBasicKeyStore\n         while (mi != mapCryptedKeys.end())\n         {\n             setAddress.insert((*mi).first);\n-            mi++;\n+            ++mi;\n         }\n     }\n "
      },
      {
        "sha": "535f3e61116ca39585f0d50bcaae2f7c307c6d65",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -587,7 +587,7 @@ void CDBEnv::Flush(bool fShutdown)\n                 LogPrint(BCLog::DB, \"CDBEnv::Flush: %s closed\\n\", strFile);\n                 mapFileUseCount.erase(mi++);\n             } else\n-                mi++;\n+                ++mi;\n         }\n         LogPrint(BCLog::DB, \"CDBEnv::Flush: Flush(%s)%s took %15dms\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\", GetTimeMillis() - nStart);\n         if (fShutdown) {\n@@ -619,7 +619,7 @@ bool CDB::PeriodicFlush(CWalletDBWrapper& dbw)\n         while (mit != env->mapFileUseCount.end())\n         {\n             nRefCount += (*mit).second;\n-            mit++;\n+            ++mit;\n         }\n \n         if (nRefCount == 0)"
      },
      {
        "sha": "ccbf6cac61823e1db4f3c0765f048332dcfe14c4",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -58,7 +58,7 @@ std::string static EncodeDumpString(const std::string &str) {\n \n std::string DecodeDumpString(const std::string &str) {\n     std::stringstream ret;\n-    for (unsigned int pos = 0; pos < str.length(); pos++) {\n+    for (unsigned int pos = 0; pos < str.length(); ++pos) {\n         unsigned char c = str[pos];\n         if (c == '%' && pos+2 < str.length()) {\n             c = (((str[pos+1]>>6)*9+((str[pos+1]-'0')&15)) << 4) | \n@@ -510,7 +510,7 @@ UniValue importwallet(const JSONRPCRequest& request)\n         int64_t nTime = DecodeDumpTime(vstr[1]);\n         std::string strLabel;\n         bool fLabel = true;\n-        for (unsigned int nStr = 2; nStr < vstr.size(); nStr++) {\n+        for (unsigned int nStr = 2; nStr < vstr.size(); ++nStr) {\n             if (boost::algorithm::starts_with(vstr[nStr], \"#\"))\n                 break;\n             if (vstr[nStr] == \"change=1\")\n@@ -654,7 +654,7 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n             file << \"# extended private masterkey: \" << b58extkey.ToString() << \"\\n\\n\";\n         }\n     }\n-    for (std::vector<std::pair<int64_t, CKeyID> >::const_iterator it = vKeyBirth.begin(); it != vKeyBirth.end(); it++) {\n+    for (std::vector<std::pair<int64_t, CKeyID> >::const_iterator it = vKeyBirth.begin(); it != vKeyBirth.end(); ++it) {\n         const CKeyID &keyid = it->second;\n         std::string strTime = EncodeDumpTime(it->first);\n         std::string strAddr = CBitcoinAddress(keyid).ToString();\n@@ -798,7 +798,7 @@ UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int6\n \n             // Import private keys.\n             if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n+                for (size_t i = 0; i < keys.size(); ++i) {\n                     const std::string& privkey = keys[i].get_str();\n \n                     CBitcoinSecret vchSecret;"
      },
      {
        "sha": "ef25c5dcb125c6556302e32641ebb4f6a58d14d1",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 23,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -188,12 +188,12 @@ void CWallet::DeriveNewChildKey(CWalletDB &walletdb, CKeyMetadata& metadata, CKe\n         if (internal) {\n             chainChildKey.Derive(childKey, hdChain.nInternalChainCounter | BIP32_HARDENED_KEY_LIMIT);\n             metadata.hdKeypath = \"m/0'/1'/\" + std::to_string(hdChain.nInternalChainCounter) + \"'\";\n-            hdChain.nInternalChainCounter++;\n+            ++hdChain.nInternalChainCounter;\n         }\n         else {\n             chainChildKey.Derive(childKey, hdChain.nExternalChainCounter | BIP32_HARDENED_KEY_LIMIT);\n             metadata.hdKeypath = \"m/0'/0'/\" + std::to_string(hdChain.nExternalChainCounter) + \"'\";\n-            hdChain.nExternalChainCounter++;\n+            ++hdChain.nExternalChainCounter;\n         }\n     } while (HaveKey(childKey.key.GetPubKey().GetID()));\n     secret = childKey.key;\n@@ -1047,7 +1047,7 @@ bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, const CBlockI\n                         LogPrintf(\"Transaction %s (in block %s) conflicts with wallet transaction %s (both spend %s:%i)\\n\", tx.GetHash().ToString(), pIndex->GetBlockHash().ToString(), range.first->second.ToString(), range.first->first.hash.ToString(), range.first->first.n);\n                         MarkConflicted(pIndex->GetBlockHash(), range.first->second);\n                     }\n-                    range.first++;\n+                    ++range.first;\n                 }\n             }\n         }\n@@ -1143,7 +1143,7 @@ bool CWallet::AbandonTransaction(const uint256& hashTx)\n                 if (!done.count(iter->second)) {\n                     todo.insert(iter->second);\n                 }\n-                iter++;\n+                ++iter;\n             }\n             // If a transaction changes 'conflicted' state, that changes the balance\n             // available of the outputs it spends. So force those to be recomputed\n@@ -1207,7 +1207,7 @@ void CWallet::MarkConflicted(const uint256& hashBlock, const uint256& hashTx)\n                  if (!done.count(iter->second)) {\n                      todo.insert(iter->second);\n                  }\n-                 iter++;\n+                 ++iter;\n             }\n             // If a transaction changes 'conflicted' state, that changes the balance\n             // available of the outputs it spends. So force those to be recomputed\n@@ -1256,7 +1256,7 @@ void CWallet::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const\n     for (const CTransactionRef& ptx : vtxConflicted) {\n         SyncTransaction(ptx);\n     }\n-    for (size_t i = 0; i < pblock->vtx.size(); i++) {\n+    for (size_t i = 0; i < pblock->vtx.size(); ++i) {\n         SyncTransaction(pblock->vtx[i], pindex, i);\n     }\n }\n@@ -1815,7 +1815,7 @@ CAmount CWalletTx::GetAvailableCredit(bool fUseCache) const\n \n     CAmount nCredit = 0;\n     uint256 hashTx = GetHash();\n-    for (unsigned int i = 0; i < tx->vout.size(); i++)\n+    for (unsigned int i = 0; i < tx->vout.size(); ++i)\n     {\n         if (!pwallet->IsSpent(hashTx, i))\n         {\n@@ -1858,7 +1858,7 @@ CAmount CWalletTx::GetAvailableWatchOnlyCredit(const bool& fUseCache) const\n         return nAvailableWatchCreditCached;\n \n     CAmount nCredit = 0;\n-    for (unsigned int i = 0; i < tx->vout.size(); i++)\n+    for (unsigned int i = 0; i < tx->vout.size(); ++i)\n     {\n         if (!pwallet->IsSpent(GetHash(), i))\n         {\n@@ -2205,7 +2205,7 @@ void CWallet::AvailableCoins(std::vector<COutput> &vCoins, bool fOnlySafe, const\n             if (nDepth < nMinDepth || nDepth > nMaxDepth)\n                 continue;\n \n-            for (unsigned int i = 0; i < pcoin->tx->vout.size(); i++) {\n+            for (unsigned int i = 0; i < pcoin->tx->vout.size(); ++i) {\n                 if (pcoin->tx->vout[i].nValue < nMinimumAmount || pcoin->tx->vout[i].nValue > nMaximumAmount)\n                     continue;\n \n@@ -2320,14 +2320,14 @@ static void ApproximateBestSubset(const std::vector<CInputCoin>& vValue, const C\n \n     FastRandomContext insecure_rand;\n \n-    for (int nRep = 0; nRep < iterations && nBest != nTargetValue; nRep++)\n+    for (int nRep = 0; nRep < iterations && nBest != nTargetValue; ++nRep)\n     {\n         vfIncluded.assign(vValue.size(), false);\n         CAmount nTotal = 0;\n         bool fReachedTarget = false;\n-        for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n+        for (int nPass = 0; nPass < 2 && !fReachedTarget; ++nPass)\n         {\n-            for (unsigned int i = 0; i < vValue.size(); i++)\n+            for (unsigned int i = 0; i < vValue.size(); ++i)\n             {\n                 //The solver here uses a randomized algorithm,\n                 //the randomness serves no real security purpose but is just\n@@ -2441,7 +2441,7 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const int nConfMin\n         nValueRet += coinLowestLarger->txout.nValue;\n     }\n     else {\n-        for (unsigned int i = 0; i < vValue.size(); i++)\n+        for (unsigned int i = 0; i < vValue.size(); ++i)\n             if (vfBest[i])\n             {\n                 setCoinsRet.insert(vValue[i]);\n@@ -2450,7 +2450,7 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const int nConfMin\n \n         if (LogAcceptCategory(BCLog::SELECTCOINS)) {\n             LogPrint(BCLog::SELECTCOINS, \"SelectCoins() best subset: \");\n-            for (unsigned int i = 0; i < vValue.size(); i++) {\n+            for (unsigned int i = 0; i < vValue.size(); ++i) {\n                 if (vfBest[i]) {\n                     LogPrint(BCLog::SELECTCOINS, \"%s \", FormatMoney(vValue[i].txout.nValue));\n                 }\n@@ -2550,7 +2550,7 @@ bool CWallet::SignTransaction(CMutableTransaction &tx)\n             return false;\n         }\n         UpdateTransaction(tx, nIn, sigdata);\n-        nIn++;\n+        ++nIn;\n     }\n     return true;\n }\n@@ -2560,7 +2560,7 @@ bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nC\n     std::vector<CRecipient> vecSend;\n \n     // Turn the txout set into a CRecipient vector\n-    for (size_t idx = 0; idx < tx.vout.size(); idx++)\n+    for (size_t idx = 0; idx < tx.vout.size(); ++idx)\n     {\n         const CTxOut& txOut = tx.vout[idx];\n         CRecipient recipient = {txOut.scriptPubKey, txOut.nValue, setSubtractFeeFromOutputs.count(idx) == 1};\n@@ -2586,7 +2586,7 @@ bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nC\n     }\n \n     // Copy output sizes from new transaction; they may have had the fee subtracted from them\n-    for (unsigned int idx = 0; idx < tx.vout.size(); idx++)\n+    for (unsigned int idx = 0; idx < tx.vout.size(); ++idx)\n         tx.vout[idx].nValue = wtx.tx->vout[idx].nValue;\n \n     // Add new txins (keeping original txin scriptSig/order)\n@@ -2635,7 +2635,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n         nValue += recipient.nAmount;\n \n         if (recipient.fSubtractFeeFromAmount)\n-            nSubtractFeeFromAmount++;\n+            ++nSubtractFeeFromAmount;\n     }\n     if (vecSend.empty())\n     {\n@@ -2931,7 +2931,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                     UpdateTransaction(txNew, nIn, sigdata);\n                 }\n \n-                nIn++;\n+                ++nIn;\n             }\n         }\n \n@@ -3480,7 +3480,7 @@ std::map<CTxDestination, CAmount> CWallet::GetAddressBalances()\n             if (nDepth < (pcoin->IsFromMe(ISMINE_ALL) ? 0 : 1))\n                 continue;\n \n-            for (unsigned int i = 0; i < pcoin->tx->vout.size(); i++)\n+            for (unsigned int i = 0; i < pcoin->tx->vout.size(); ++i)\n             {\n                 CTxDestination addr;\n                 if (!IsMine(pcoin->tx->vout[i]))\n@@ -3706,7 +3706,7 @@ void CWallet::ListLockedCoins(std::vector<COutPoint>& vOutpts) const\n {\n     AssertLockHeld(cs_wallet); // setLockedCoins\n     for (std::set<COutPoint>::iterator it = setLockedCoins.begin();\n-         it != setLockedCoins.end(); it++) {\n+         it != setLockedCoins.end(); ++it) {\n         COutPoint outpt = (*it);\n         vOutpts.push_back(outpt);\n     }\n@@ -3742,7 +3742,7 @@ void CWallet::GetKeyBirthTimes(std::map<CTxDestination, int64_t> &mapKeyBirth) c\n \n     // find first block that affects those keys, if there are any left\n     std::vector<CKeyID> vAffected;\n-    for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); it++) {\n+    for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it) {\n         // iterate over all wallet transactions...\n         const CWalletTx &wtx = (*it).second;\n         BlockMap::const_iterator blit = mapBlockIndex.find(wtx.hashBlock);\n@@ -3764,7 +3764,7 @@ void CWallet::GetKeyBirthTimes(std::map<CTxDestination, int64_t> &mapKeyBirth) c\n     }\n \n     // Extract block timestamps for those keys\n-    for (std::map<CKeyID, CBlockIndex*>::const_iterator it = mapKeyFirstBlock.begin(); it != mapKeyFirstBlock.end(); it++)\n+    for (std::map<CKeyID, CBlockIndex*>::const_iterator it = mapKeyFirstBlock.begin(); it != mapKeyFirstBlock.end(); ++it)\n         mapKeyBirth[it->first] = it->second->GetBlockTime() - TIMESTAMP_WINDOW; // block times can be 2h off\n }\n "
      },
      {
        "sha": "0e3a7ddc9c26d1e05a9a9c6bdfba26b6c234fdba",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -316,7 +316,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n         }\n         else if (strType == \"watchs\")\n         {\n-            wss.nWatchKeys++;\n+            ++wss.nWatchKeys;\n             CScript script;\n             ssKey >> script;\n             char fYes;\n@@ -339,7 +339,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n \n             if (strType == \"key\")\n             {\n-                wss.nKeys++;\n+                ++wss.nKeys;\n                 ssValue >> pkey;\n             } else {\n                 CWalletKey wkey;\n@@ -414,7 +414,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             }\n             std::vector<unsigned char> vchPrivKey;\n             ssValue >> vchPrivKey;\n-            wss.nCKeys++;\n+            ++wss.nCKeys;\n \n             if (!pwallet->LoadCryptedKey(vchPubKey, vchPrivKey))\n             {\n@@ -441,7 +441,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n \n             CKeyMetadata keyMeta;\n             ssValue >> keyMeta;\n-            wss.nKeyMeta++;\n+            ++wss.nKeyMeta;\n \n             pwallet->LoadKeyMetadata(keyID, keyMeta);\n         }\n@@ -709,7 +709,7 @@ DBErrors CWalletDB::ZapSelectTx(std::vector<uint256>& vTxHashIn, std::vector<uin\n     std::vector<uint256>::iterator it = vTxHashIn.begin();\n     for (uint256 hash : vTxHash) {\n         while (it < vTxHashIn.end() && (*it) < hash) {\n-            it++;\n+            ++it;\n         }\n         if (it == vTxHashIn.end()) {\n             break;"
      },
      {
        "sha": "1f24e5ba672c48055d212dc44eb456670f5fb997",
        "filename": "src/zmq/zmqnotificationinterface.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/zmq/zmqnotificationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8/src/zmq/zmqnotificationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqnotificationinterface.cpp?ref=e6d7e4ee09200c6d36e0c5bdeeaeaf6a6140efc8",
        "patch": "@@ -134,7 +134,7 @@ void CZMQNotificationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, co\n         CZMQAbstractNotifier *notifier = *i;\n         if (notifier->NotifyBlock(pindexNew))\n         {\n-            i++;\n+            ++i;\n         }\n         else\n         {\n@@ -155,7 +155,7 @@ void CZMQNotificationInterface::TransactionAddedToMempool(const CTransactionRef&\n         CZMQAbstractNotifier *notifier = *i;\n         if (notifier->NotifyTransaction(tx))\n         {\n-            i++;\n+            ++i;\n         }\n         else\n         {"
      }
    ]
  }
]