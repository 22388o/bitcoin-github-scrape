[
  {
    "sha": "70e1dbecd2a84859335c56e106afdf3b879981c0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3MGUxZGJlY2QyYTg0ODU5MzM1YzU2ZTEwNmFmZGYzYjg3OTk4MWMw",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-03-21T17:04:40Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-11-04T14:17:09Z"
      },
      "message": "Remove priority estimation",
      "tree": {
        "sha": "796b4fce9bcbcd9e1640c562a5ad1a0036486453",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/796b4fce9bcbcd9e1640c562a5ad1a0036486453"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/70e1dbecd2a84859335c56e106afdf3b879981c0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/70e1dbecd2a84859335c56e106afdf3b879981c0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/70e1dbecd2a84859335c56e106afdf3b879981c0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/70e1dbecd2a84859335c56e106afdf3b879981c0/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ed64bcec2dde1f4255f3bd5b0c2f01e4dfe260d3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ed64bcec2dde1f4255f3bd5b0c2f01e4dfe260d3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ed64bcec2dde1f4255f3bd5b0c2f01e4dfe260d3"
      }
    ],
    "stats": {
      "total": 352,
      "additions": 101,
      "deletions": 251
    },
    "files": [
      {
        "sha": "f94eba2c96d9bd635f1c92edfe53b96740895435",
        "filename": "src/policy/fees.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 136,
        "changes": 168,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70e1dbecd2a84859335c56e106afdf3b879981c0/src/policy/fees.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70e1dbecd2a84859335c56e106afdf3b879981c0/src/policy/fees.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.cpp?ref=70e1dbecd2a84859335c56e106afdf3b879981c0",
        "patch": "@@ -14,10 +14,9 @@\n #include \"util.h\"\n \n void TxConfirmStats::Initialize(std::vector<double>& defaultBuckets,\n-                                unsigned int maxConfirms, double _decay, std::string _dataTypeString)\n+                                unsigned int maxConfirms, double _decay)\n {\n     decay = _decay;\n-    dataTypeString = _dataTypeString;\n     for (unsigned int i = 0; i < defaultBuckets.size(); i++) {\n         buckets.push_back(defaultBuckets[i]);\n         bucketMap[defaultBuckets[i]] = i;\n@@ -87,10 +86,10 @@ double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n \n     int maxbucketindex = buckets.size() - 1;\n \n-    // requireGreater means we are looking for the lowest fee/priority such that all higher\n-    // values pass, so we start at maxbucketindex (highest fee) and look at successively\n+    // requireGreater means we are looking for the lowest feerate such that all higher\n+    // values pass, so we start at maxbucketindex (highest feerate) and look at successively\n     // smaller buckets until we reach failure.  Otherwise, we are looking for the highest\n-    // fee/priority such that all lower values fail, and we go in the opposite direction.\n+    // feerate such that all lower values fail, and we go in the opposite direction.\n     unsigned int startbucket = requireGreater ? maxbucketindex : 0;\n     int step = requireGreater ? -1 : 1;\n \n@@ -107,7 +106,7 @@ double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n     bool foundAnswer = false;\n     unsigned int bins = unconfTxs.size();\n \n-    // Start counting from highest(default) or lowest fee/pri transactions\n+    // Start counting from highest(default) or lowest feerate transactions\n     for (int bucket = startbucket; bucket >= 0 && bucket <= maxbucketindex; bucket += step) {\n         curFarBucket = bucket;\n         nConf += confAvg[confTarget - 1][bucket];\n@@ -145,8 +144,8 @@ double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n     double median = -1;\n     double txSum = 0;\n \n-    // Calculate the \"average\" fee of the best bucket range that met success conditions\n-    // Find the bucket with the median transaction and then report the average fee from that bucket\n+    // Calculate the \"average\" feerate of the best bucket range that met success conditions\n+    // Find the bucket with the median transaction and then report the average feerate from that bucket\n     // This is a compromise between finding the median which we can't since we don't save all tx's\n     // and reporting the average which is less accurate\n     unsigned int minBucket = bestNearBucket < bestFarBucket ? bestNearBucket : bestFarBucket;\n@@ -166,8 +165,8 @@ double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n         }\n     }\n \n-    LogPrint(\"estimatefee\", \"%3d: For conf success %s %4.2f need %s %s: %12.5g from buckets %8g - %8g  Cur Bucket stats %6.2f%%  %8.1f/(%.1f+%d mempool)\\n\",\n-             confTarget, requireGreater ? \">\" : \"<\", successBreakPoint, dataTypeString,\n+    LogPrint(\"estimatefee\", \"%3d: For conf success %s %4.2f need feerate %s: %12.5g from buckets %8g - %8g  Cur Bucket stats %6.2f%%  %8.1f/(%.1f+%d mempool)\\n\",\n+             confTarget, requireGreater ? \">\" : \"<\", successBreakPoint,\n              requireGreater ? \">\" : \"<\", median, buckets[minBucket], buckets[maxBucket],\n              100 * nConf / (totalNum + extraNum), nConf, totalNum, extraNum);\n \n@@ -200,10 +199,10 @@ void TxConfirmStats::Read(CAutoFile& filein)\n     filein >> fileBuckets;\n     numBuckets = fileBuckets.size();\n     if (numBuckets <= 1 || numBuckets > 1000)\n-        throw std::runtime_error(\"Corrupt estimates file. Must have between 2 and 1000 fee/pri buckets\");\n+        throw std::runtime_error(\"Corrupt estimates file. Must have between 2 and 1000 feerate buckets\");\n     filein >> fileAvg;\n     if (fileAvg.size() != numBuckets)\n-        throw std::runtime_error(\"Corrupt estimates file. Mismatch in fee/pri average bucket count\");\n+        throw std::runtime_error(\"Corrupt estimates file. Mismatch in feerate average bucket count\");\n     filein >> fileTxCtAvg;\n     if (fileTxCtAvg.size() != numBuckets)\n         throw std::runtime_error(\"Corrupt estimates file. Mismatch in tx count bucket count\");\n@@ -213,9 +212,9 @@ void TxConfirmStats::Read(CAutoFile& filein)\n         throw std::runtime_error(\"Corrupt estimates file.  Must maintain estimates for between 1 and 1008 (one week) confirms\");\n     for (unsigned int i = 0; i < maxConfirms; i++) {\n         if (fileConfAvg[i].size() != numBuckets)\n-            throw std::runtime_error(\"Corrupt estimates file. Mismatch in fee/pri conf average bucket count\");\n+            throw std::runtime_error(\"Corrupt estimates file. Mismatch in feerate conf average bucket count\");\n     }\n-    // Now that we've processed the entire fee estimate data file and not\n+    // Now that we've processed the entire feerate estimate data file and not\n     // thrown any errors, we can copy it to our data structures\n     decay = fileDecay;\n     buckets = fileBuckets;\n@@ -242,16 +241,15 @@ void TxConfirmStats::Read(CAutoFile& filein)\n     for (unsigned int i = 0; i < buckets.size(); i++)\n         bucketMap[buckets[i]] = i;\n \n-    LogPrint(\"estimatefee\", \"Reading estimates: %u %s buckets counting confirms up to %u blocks\\n\",\n-             numBuckets, dataTypeString, maxConfirms);\n+    LogPrint(\"estimatefee\", \"Reading estimates: %u buckets counting confirms up to %u blocks\\n\",\n+             numBuckets, maxConfirms);\n }\n \n unsigned int TxConfirmStats::NewTx(unsigned int nBlockHeight, double val)\n {\n     unsigned int bucketindex = bucketMap.lower_bound(val)->second;\n     unsigned int blockIndex = nBlockHeight % unconfTxs.size();\n     unconfTxs[blockIndex][bucketindex]++;\n-    LogPrint(\"estimatefee\", \"adding to %s\", dataTypeString);\n     return bucketindex;\n }\n \n@@ -291,12 +289,10 @@ void CBlockPolicyEstimator::removeTx(uint256 hash)\n                  hash.ToString().c_str());\n         return;\n     }\n-    TxConfirmStats *stats = pos->second.stats;\n     unsigned int entryHeight = pos->second.blockHeight;\n     unsigned int bucketIndex = pos->second.bucketIndex;\n \n-    if (stats != NULL)\n-        stats->removeTx(entryHeight, nBestSeenHeight, bucketIndex);\n+    feeStats.removeTx(entryHeight, nBestSeenHeight, bucketIndex);\n     mapMemPoolTxs.erase(hash);\n }\n \n@@ -309,45 +305,14 @@ CBlockPolicyEstimator::CBlockPolicyEstimator(const CFeeRate& _minRelayFee)\n         vfeelist.push_back(bucketBoundary);\n     }\n     vfeelist.push_back(INF_FEERATE);\n-    feeStats.Initialize(vfeelist, MAX_BLOCK_CONFIRMS, DEFAULT_DECAY, \"FeeRate\");\n-\n-    minTrackedPriority = AllowFreeThreshold() < MIN_PRIORITY ? MIN_PRIORITY : AllowFreeThreshold();\n-    std::vector<double> vprilist;\n-    for (double bucketBoundary = minTrackedPriority; bucketBoundary <= MAX_PRIORITY; bucketBoundary *= PRI_SPACING) {\n-        vprilist.push_back(bucketBoundary);\n-    }\n-    vprilist.push_back(INF_PRIORITY);\n-    priStats.Initialize(vprilist, MAX_BLOCK_CONFIRMS, DEFAULT_DECAY, \"Priority\");\n-\n-    feeUnlikely = CFeeRate(0);\n-    feeLikely = CFeeRate(INF_FEERATE);\n-    priUnlikely = 0;\n-    priLikely = INF_PRIORITY;\n-}\n-\n-bool CBlockPolicyEstimator::isFeeDataPoint(const CFeeRate &fee, double pri)\n-{\n-    if ((pri < minTrackedPriority && fee >= minTrackedFee) ||\n-        (pri < priUnlikely && fee > feeLikely)) {\n-        return true;\n-    }\n-    return false;\n-}\n-\n-bool CBlockPolicyEstimator::isPriDataPoint(const CFeeRate &fee, double pri)\n-{\n-    if ((fee < minTrackedFee && pri >= minTrackedPriority) ||\n-        (fee < feeUnlikely && pri > priLikely)) {\n-        return true;\n-    }\n-    return false;\n+    feeStats.Initialize(vfeelist, MAX_BLOCK_CONFIRMS, DEFAULT_DECAY);\n }\n \n void CBlockPolicyEstimator::processTransaction(const CTxMemPoolEntry& entry, bool fCurrentEstimate)\n {\n     unsigned int txHeight = entry.GetHeight();\n     uint256 hash = entry.GetTx().GetHash();\n-    if (mapMemPoolTxs[hash].stats != NULL) {\n+    if (mapMemPoolTxs.count(hash)) {\n         LogPrint(\"estimatefee\", \"Blockpolicy error mempool tx %s already being tracked\\n\",\n                  hash.ToString().c_str());\n \treturn;\n@@ -371,30 +336,11 @@ void CBlockPolicyEstimator::processTransaction(const CTxMemPoolEntry& entry, boo\n         return;\n     }\n \n-    // Fees are stored and reported as BTC-per-kb:\n+    // Feerates are stored and reported as BTC-per-kb:\n     CFeeRate feeRate(entry.GetFee(), entry.GetTxSize());\n \n-    // Want the priority of the tx at confirmation. However we don't know\n-    // what that will be and its too hard to continue updating it\n-    // so use starting priority as a proxy\n-    double curPri = entry.GetPriority(txHeight);\n     mapMemPoolTxs[hash].blockHeight = txHeight;\n-\n-    LogPrint(\"estimatefee\", \"Blockpolicy mempool tx %s \", hash.ToString().substr(0,10));\n-    // Record this as a priority estimate\n-    if (entry.GetFee() == 0 || isPriDataPoint(feeRate, curPri)) {\n-        mapMemPoolTxs[hash].stats = &priStats;\n-        mapMemPoolTxs[hash].bucketIndex =  priStats.NewTx(txHeight, curPri);\n-    }\n-    // Record this as a fee estimate\n-    else if (isFeeDataPoint(feeRate, curPri)) {\n-        mapMemPoolTxs[hash].stats = &feeStats;\n-        mapMemPoolTxs[hash].bucketIndex = feeStats.NewTx(txHeight, (double)feeRate.GetFeePerK());\n-    }\n-    else {\n-        LogPrint(\"estimatefee\", \"not adding\");\n-    }\n-    LogPrint(\"estimatefee\", \"\\n\");\n+    mapMemPoolTxs[hash].bucketIndex = feeStats.NewTx(txHeight, (double)feeRate.GetFeePerK());\n }\n \n void CBlockPolicyEstimator::processBlockTx(unsigned int nBlockHeight, const CTxMemPoolEntry& entry)\n@@ -417,21 +363,10 @@ void CBlockPolicyEstimator::processBlockTx(unsigned int nBlockHeight, const CTxM\n         return;\n     }\n \n-    // Fees are stored and reported as BTC-per-kb:\n+    // Feerates are stored and reported as BTC-per-kb:\n     CFeeRate feeRate(entry.GetFee(), entry.GetTxSize());\n \n-    // Want the priority of the tx at confirmation.  The priority when it\n-    // entered the mempool could easily be very small and change quickly\n-    double curPri = entry.GetPriority(nBlockHeight);\n-\n-    // Record this as a priority estimate\n-    if (entry.GetFee() == 0 || isPriDataPoint(feeRate, curPri)) {\n-        priStats.Record(blocksToConfirm, curPri);\n-    }\n-    // Record this as a fee estimate\n-    else if (isFeeDataPoint(feeRate, curPri)) {\n-        feeStats.Record(blocksToConfirm, (double)feeRate.GetFeePerK());\n-    }\n+    feeStats.Record(blocksToConfirm, (double)feeRate.GetFeePerK());\n }\n \n void CBlockPolicyEstimator::processBlock(unsigned int nBlockHeight,\n@@ -452,41 +387,15 @@ void CBlockPolicyEstimator::processBlock(unsigned int nBlockHeight,\n     if (!fCurrentEstimate)\n         return;\n \n-    // Update the dynamic cutoffs\n-    // a fee/priority is \"likely\" the reason your tx was included in a block if >85% of such tx's\n-    // were confirmed in 2 blocks and is \"unlikely\" if <50% were confirmed in 10 blocks\n-    LogPrint(\"estimatefee\", \"Blockpolicy recalculating dynamic cutoffs:\\n\");\n-    priLikely = priStats.EstimateMedianVal(2, SUFFICIENT_PRITXS, MIN_SUCCESS_PCT, true, nBlockHeight);\n-    if (priLikely == -1)\n-        priLikely = INF_PRIORITY;\n-\n-    double feeLikelyEst = feeStats.EstimateMedianVal(2, SUFFICIENT_FEETXS, MIN_SUCCESS_PCT, true, nBlockHeight);\n-    if (feeLikelyEst == -1)\n-        feeLikely = CFeeRate(INF_FEERATE);\n-    else\n-        feeLikely = CFeeRate(feeLikelyEst);\n-\n-    priUnlikely = priStats.EstimateMedianVal(10, SUFFICIENT_PRITXS, UNLIKELY_PCT, false, nBlockHeight);\n-    if (priUnlikely == -1)\n-        priUnlikely = 0;\n-\n-    double feeUnlikelyEst = feeStats.EstimateMedianVal(10, SUFFICIENT_FEETXS, UNLIKELY_PCT, false, nBlockHeight);\n-    if (feeUnlikelyEst == -1)\n-        feeUnlikely = CFeeRate(0);\n-    else\n-        feeUnlikely = CFeeRate(feeUnlikelyEst);\n-\n-    // Clear the current block states\n+    // Clear the current block state\n     feeStats.ClearCurrent(nBlockHeight);\n-    priStats.ClearCurrent(nBlockHeight);\n \n     // Repopulate the current block states\n     for (unsigned int i = 0; i < entries.size(); i++)\n         processBlockTx(nBlockHeight, entries[i]);\n \n-    // Update all exponential averages with the current block states\n+    // Update all exponential averages with the current block state\n     feeStats.UpdateMovingAverages();\n-    priStats.UpdateMovingAverages();\n \n     LogPrint(\"estimatefee\", \"Blockpolicy after updating estimates for %u confirmed entries, new mempool map size %u\\n\",\n              entries.size(), mapMemPoolTxs.size());\n@@ -522,7 +431,7 @@ CFeeRate CBlockPolicyEstimator::estimateSmartFee(int confTarget, int *answerFoun\n     if (answerFoundAtTarget)\n         *answerFoundAtTarget = confTarget - 1;\n \n-    // If mempool is limiting txs , return at least the min fee from the mempool\n+    // If mempool is limiting txs , return at least the min feerate from the mempool\n     CAmount minPoolFee = pool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n     if (minPoolFee > 0 && minPoolFee > median)\n         return CFeeRate(minPoolFee);\n@@ -535,51 +444,38 @@ CFeeRate CBlockPolicyEstimator::estimateSmartFee(int confTarget, int *answerFoun\n \n double CBlockPolicyEstimator::estimatePriority(int confTarget)\n {\n-    // Return failure if trying to analyze a target we're not tracking\n-    if (confTarget <= 0 || (unsigned int)confTarget > priStats.GetMaxConfirms())\n-        return -1;\n-\n-    return priStats.EstimateMedianVal(confTarget, SUFFICIENT_PRITXS, MIN_SUCCESS_PCT, true, nBestSeenHeight);\n+    return -1;\n }\n \n double CBlockPolicyEstimator::estimateSmartPriority(int confTarget, int *answerFoundAtTarget, const CTxMemPool& pool)\n {\n     if (answerFoundAtTarget)\n         *answerFoundAtTarget = confTarget;\n-    // Return failure if trying to analyze a target we're not tracking\n-    if (confTarget <= 0 || (unsigned int)confTarget > priStats.GetMaxConfirms())\n-        return -1;\n \n     // If mempool is limiting txs, no priority txs are allowed\n     CAmount minPoolFee = pool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n     if (minPoolFee > 0)\n         return INF_PRIORITY;\n \n-    double median = -1;\n-    while (median < 0 && (unsigned int)confTarget <= priStats.GetMaxConfirms()) {\n-        median = priStats.EstimateMedianVal(confTarget++, SUFFICIENT_PRITXS, MIN_SUCCESS_PCT, true, nBestSeenHeight);\n-    }\n-\n-    if (answerFoundAtTarget)\n-        *answerFoundAtTarget = confTarget - 1;\n-\n-    return median;\n+    return -1;\n }\n \n void CBlockPolicyEstimator::Write(CAutoFile& fileout)\n {\n     fileout << nBestSeenHeight;\n     feeStats.Write(fileout);\n-    priStats.Write(fileout);\n }\n \n-void CBlockPolicyEstimator::Read(CAutoFile& filein)\n+void CBlockPolicyEstimator::Read(CAutoFile& filein, int nVersionRequired)\n {\n     int nFileBestSeenHeight;\n     filein >> nFileBestSeenHeight;\n     feeStats.Read(filein);\n-    priStats.Read(filein);\n     nBestSeenHeight = nFileBestSeenHeight;\n+    if (nVersionRequired < 139900) {\n+        TxConfirmStats priStats;\n+        priStats.Read(filein);\n+    }\n }\n \n FeeFilterRounder::FeeFilterRounder(const CFeeRate& minIncrementalFee)"
      },
      {
        "sha": "c39ccd3c86b8aeecbf33e6951a11e3b64a46c609",
        "filename": "src/policy/fees.h",
        "status": "modified",
        "additions": 44,
        "deletions": 71,
        "changes": 115,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70e1dbecd2a84859335c56e106afdf3b879981c0/src/policy/fees.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70e1dbecd2a84859335c56e106afdf3b879981c0/src/policy/fees.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.h?ref=70e1dbecd2a84859335c56e106afdf3b879981c0",
        "patch": "@@ -19,68 +19,58 @@ class CTxMemPoolEntry;\n class CTxMemPool;\n \n /** \\class CBlockPolicyEstimator\n- * The BlockPolicyEstimator is used for estimating the fee or priority needed\n+ * The BlockPolicyEstimator is used for estimating the feerate needed\n  * for a transaction to be included in a block within a certain number of\n  * blocks.\n  *\n  * At a high level the algorithm works by grouping transactions into buckets\n- * based on having similar priorities or fees and then tracking how long it\n+ * based on having similar feerates and then tracking how long it\n  * takes transactions in the various buckets to be mined.  It operates under\n- * the assumption that in general transactions of higher fee/priority will be\n- * included in blocks before transactions of lower fee/priority.   So for\n- * example if you wanted to know what fee you should put on a transaction to\n+ * the assumption that in general transactions of higher feerate will be\n+ * included in blocks before transactions of lower feerate.   So for\n+ * example if you wanted to know what feerate you should put on a transaction to\n  * be included in a block within the next 5 blocks, you would start by looking\n- * at the bucket with the highest fee transactions and verifying that a\n+ * at the bucket with the highest feerate transactions and verifying that a\n  * sufficiently high percentage of them were confirmed within 5 blocks and\n- * then you would look at the next highest fee bucket, and so on, stopping at\n- * the last bucket to pass the test.   The average fee of transactions in this\n- * bucket will give you an indication of the lowest fee you can put on a\n+ * then you would look at the next highest feerate bucket, and so on, stopping at\n+ * the last bucket to pass the test.   The average feerate of transactions in this\n+ * bucket will give you an indication of the lowest feerate you can put on a\n  * transaction and still have a sufficiently high chance of being confirmed\n  * within your desired 5 blocks.\n  *\n- * When a transaction enters the mempool or is included within a block we\n- * decide whether it can be used as a data point for fee estimation, priority\n- * estimation or neither.  If the value of exactly one of those properties was\n- * below the required minimum it can be used to estimate the other.  In\n- * addition, if a priori our estimation code would indicate that the\n- * transaction would be much more quickly included in a block because of one\n- * of the properties compared to the other, we can also decide to use it as\n- * an estimate for that property.\n- *\n- * Here is a brief description of the implementation for fee estimation.\n- * When a transaction that counts for fee estimation enters the mempool, we\n+ * Here is a brief description of the implementation:\n+ * When a transaction enters the mempool, we\n  * track the height of the block chain at entry.  Whenever a block comes in,\n- * we count the number of transactions in each bucket and the total amount of fee\n+ * we count the number of transactions in each bucket and the total amount of feerate\n  * paid in each bucket. Then we calculate how many blocks Y it took each\n  * transaction to be mined and we track an array of counters in each bucket\n  * for how long it to took transactions to get confirmed from 1 to a max of 25\n  * and we increment all the counters from Y up to 25. This is because for any\n  * number Z>=Y the transaction was successfully mined within Z blocks.  We\n  * want to save a history of this information, so at any time we have a\n- * counter of the total number of transactions that happened in a given fee\n+ * counter of the total number of transactions that happened in a given feerate\n  * bucket and the total number that were confirmed in each number 1-25 blocks\n  * or less for any bucket.   We save this history by keeping an exponentially\n  * decaying moving average of each one of these stats.  Furthermore we also\n  * keep track of the number unmined (in mempool) transactions in each bucket\n  * and for how many blocks they have been outstanding and use that to increase\n- * the number of transactions we've seen in that fee bucket when calculating\n+ * the number of transactions we've seen in that feerate bucket when calculating\n  * an estimate for any number of confirmations below the number of blocks\n  * they've been outstanding.\n  */\n \n /**\n- * We will instantiate two instances of this class, one to track transactions\n- * that were included in a block due to fee, and one for tx's included due to\n- * priority.  We will lump transactions into a bucket according to their approximate\n- * fee or priority and then track how long it took for those txs to be included in a block\n+ * We will instantiate an instance of this class to track transactions that were\n+ * included in a block. We will lump transactions into a bucket according to their\n+ * approximate feerate and then track how long it took for those txs to be included in a block\n  *\n  * The tracking of unconfirmed (mempool) transactions is completely independent of the\n  * historical tracking of transactions that have been confirmed in a block.\n  */\n class TxConfirmStats\n {\n private:\n-    //Define the buckets we will group transactions into (both fee buckets and priority buckets)\n+    //Define the buckets we will group transactions into\n     std::vector<double> buckets;              // The upper-bound of the range for the bucket (inclusive)\n     std::map<double, unsigned int> bucketMap; // Map of bucket upper-bound to index into all vectors by bucket\n \n@@ -97,16 +87,15 @@ class TxConfirmStats\n     // and calculate the totals for the current block to update the moving averages\n     std::vector<std::vector<int> > curBlockConf; // curBlockConf[Y][X]\n \n-    // Sum the total priority/fee of all tx's in each bucket\n+    // Sum the total feerate of all tx's in each bucket\n     // Track the historical moving average of this total over blocks\n     std::vector<double> avg;\n     // and calculate the total for the current block to update the moving average\n     std::vector<double> curBlockVal;\n \n     // Combine the conf counts with tx counts to calculate the confirmation % for each Y,X\n-    // Combine the total value with the tx counts to calculate the avg fee/priority per bucket\n+    // Combine the total value with the tx counts to calculate the avg feerate per bucket\n \n-    std::string dataTypeString;\n     double decay;\n \n     // Mempool counts of outstanding transactions\n@@ -123,17 +112,16 @@ class TxConfirmStats\n      * @param defaultBuckets contains the upper limits for the bucket boundaries\n      * @param maxConfirms max number of confirms to track\n      * @param decay how much to decay the historical moving average per block\n-     * @param dataTypeString for logging purposes\n      */\n-    void Initialize(std::vector<double>& defaultBuckets, unsigned int maxConfirms, double decay, std::string dataTypeString);\n+    void Initialize(std::vector<double>& defaultBuckets, unsigned int maxConfirms, double decay);\n \n     /** Clear the state of the curBlock variables to start counting for the new block */\n     void ClearCurrent(unsigned int nBlockHeight);\n \n     /**\n      * Record a new transaction data point in the current block stats\n      * @param blocksToConfirm the number of blocks it took this transaction to confirm\n-     * @param val either the fee or the priority when entered of the transaction\n+     * @param val the feerate of the transaction\n      * @warning blocksToConfirm is 1-based and has to be >= 1\n      */\n     void Record(int blocksToConfirm, double val);\n@@ -150,14 +138,14 @@ class TxConfirmStats\n     void UpdateMovingAverages();\n \n     /**\n-     * Calculate a fee or priority estimate.  Find the lowest value bucket (or range of buckets\n+     * Calculate a feerate estimate.  Find the lowest value bucket (or range of buckets\n      * to make sure we have enough data points) whose transactions still have sufficient likelihood\n      * of being confirmed within the target number of confirmations\n      * @param confTarget target number of confirmations\n      * @param sufficientTxVal required average number of transactions per block in a bucket range\n      * @param minSuccess the success probability we require\n-     * @param requireGreater return the lowest fee/pri such that all higher values pass minSuccess OR\n-     *        return the highest fee/pri such that all lower values fail minSuccess\n+     * @param requireGreater return the lowest feerate such that all higher values pass minSuccess OR\n+     *        return the highest feerate such that all lower values fail minSuccess\n      * @param nBlockHeight the current block height\n      */\n     double EstimateMedianVal(int confTarget, double sufficientTxVal,\n@@ -184,35 +172,27 @@ static const unsigned int MAX_BLOCK_CONFIRMS = 25;\n /** Decay of .998 is a half-life of 346 blocks or about 2.4 days */\n static const double DEFAULT_DECAY = .998;\n \n-/** Require greater than 95% of X fee transactions to be confirmed within Y blocks for X to be big enough */\n+/** Require greater than 95% of X feerate transactions to be confirmed within Y blocks for X to be big enough */\n static const double MIN_SUCCESS_PCT = .95;\n static const double UNLIKELY_PCT = .5;\n \n-/** Require an avg of 1 tx in the combined fee bucket per block to have stat significance */\n+/** Require an avg of 1 tx in the combined feerate bucket per block to have stat significance */\n static const double SUFFICIENT_FEETXS = 1;\n \n-/** Require only an avg of 1 tx every 5 blocks in the combined pri bucket (way less pri txs) */\n-static const double SUFFICIENT_PRITXS = .2;\n-\n-// Minimum and Maximum values for tracking fees and priorities\n+// Minimum and Maximum values for tracking feerates\n static const double MIN_FEERATE = 10;\n static const double MAX_FEERATE = 1e7;\n static const double INF_FEERATE = MAX_MONEY;\n-static const double MIN_PRIORITY = 10;\n-static const double MAX_PRIORITY = 1e16;\n static const double INF_PRIORITY = 1e9 * MAX_MONEY;\n \n-// We have to lump transactions into buckets based on fee or priority, but we want to be able\n-// to give accurate estimates over a large range of potential fees and priorities\n+// We have to lump transactions into buckets based on feerate, but we want to be able\n+// to give accurate estimates over a large range of potential feerates\n // Therefore it makes sense to exponentially space the buckets\n /** Spacing of FeeRate buckets */\n static const double FEE_SPACING = 1.1;\n \n-/** Spacing of Priority buckets */\n-static const double PRI_SPACING = 2;\n-\n /**\n- *  We want to be able to estimate fees or priorities that are needed on tx's to be included in\n+ *  We want to be able to estimate feerates that are needed on tx's to be included in\n  * a certain number of blocks.  Every time a block is added to the best chain, this class records\n  * stats on the transactions included in that block\n  */\n@@ -235,57 +215,50 @@ class CBlockPolicyEstimator\n     /** Remove a transaction from the mempool tracking stats*/\n     void removeTx(uint256 hash);\n \n-    /** Is this transaction likely included in a block because of its fee?*/\n-    bool isFeeDataPoint(const CFeeRate &fee, double pri);\n-\n-    /** Is this transaction likely included in a block because of its priority?*/\n-    bool isPriDataPoint(const CFeeRate &fee, double pri);\n-\n-    /** Return a fee estimate */\n+    /** Return a feerate estimate */\n     CFeeRate estimateFee(int confTarget);\n \n-    /** Estimate fee rate needed to get be included in a block within\n+    /** Estimate feerate needed to get be included in a block within\n      *  confTarget blocks. If no answer can be given at confTarget, return an\n      *  estimate at the lowest target where one can be given.\n      */\n     CFeeRate estimateSmartFee(int confTarget, int *answerFoundAtTarget, const CTxMemPool& pool);\n \n-    /** Return a priority estimate */\n+    /** Return a priority estimate.\n+     *  DEPRECATED\n+     *  Returns -1\n+     */\n     double estimatePriority(int confTarget);\n \n     /** Estimate priority needed to get be included in a block within\n-     *  confTarget blocks. If no answer can be given at confTarget, return an\n-     *  estimate at the lowest target where one can be given.\n+     *  confTarget blocks.\n+     *  DEPRECATED\n+     *  Returns -1 unless mempool is currently limited then returns INF_PRIORITY\n+     *  answerFoundAtTarget is set to confTarget\n      */\n     double estimateSmartPriority(int confTarget, int *answerFoundAtTarget, const CTxMemPool& pool);\n \n     /** Write estimation data to a file */\n     void Write(CAutoFile& fileout);\n \n     /** Read estimation data from a file */\n-    void Read(CAutoFile& filein);\n+    void Read(CAutoFile& filein, int nVersionRequired);\n \n private:\n     CFeeRate minTrackedFee;    //!< Passed to constructor to avoid dependency on main\n-    double minTrackedPriority; //!< Set to AllowFreeThreshold\n     unsigned int nBestSeenHeight;\n     struct TxStatsInfo\n     {\n-        TxConfirmStats *stats;\n         unsigned int blockHeight;\n         unsigned int bucketIndex;\n-        TxStatsInfo() : stats(NULL), blockHeight(0), bucketIndex(0) {}\n+        TxStatsInfo() : blockHeight(0), bucketIndex(0) {}\n     };\n \n     // map of txids to information about that transaction\n     std::map<uint256, TxStatsInfo> mapMemPoolTxs;\n \n     /** Classes to track historical data on transaction confirmations */\n-    TxConfirmStats feeStats, priStats;\n-\n-    /** Breakpoints to help determine whether a transaction was confirmed by priority or Fee */\n-    CFeeRate feeLikely, feeUnlikely;\n-    double priLikely, priUnlikely;\n+    TxConfirmStats feeStats;\n };\n \n class FeeFilterRounder"
      },
      {
        "sha": "f418262f020a1eee01ad9b0423c4f0b48dac3322",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70e1dbecd2a84859335c56e106afdf3b879981c0/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70e1dbecd2a84859335c56e106afdf3b879981c0/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=70e1dbecd2a84859335c56e106afdf3b879981c0",
        "patch": "@@ -810,7 +810,7 @@ UniValue estimatepriority(const JSONRPCRequest& request)\n     if (request.fHelp || request.params.size() != 1)\n         throw runtime_error(\n             \"estimatepriority nblocks\\n\"\n-            \"\\nEstimates the approximate priority a zero-fee transaction needs to begin\\n\"\n+            \"\\nDEPRECATED. Estimates the approximate priority a zero-fee transaction needs to begin\\n\"\n             \"confirmation within nblocks blocks.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. nblocks     (numeric)\\n\"\n@@ -873,7 +873,7 @@ UniValue estimatesmartpriority(const JSONRPCRequest& request)\n     if (request.fHelp || request.params.size() != 1)\n         throw runtime_error(\n             \"estimatesmartpriority nblocks\\n\"\n-            \"\\nWARNING: This interface is unstable and may disappear or change!\\n\"\n+            \"\\nDEPRECATED. WARNING: This interface is unstable and may disappear or change!\\n\"\n             \"\\nEstimates the approximate priority a zero-fee transaction needs to begin\\n\"\n             \"confirmation within nblocks blocks if possible and return the number of blocks\\n\"\n             \"for which the estimate is valid.\\n\""
      },
      {
        "sha": "38aaaba26723b60817a27a5550d545aa21fd22c5",
        "filename": "src/test/policyestimator_tests.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 39,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70e1dbecd2a84859335c56e106afdf3b879981c0/src/test/policyestimator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70e1dbecd2a84859335c56e106afdf3b879981c0/src/test/policyestimator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/policyestimator_tests.cpp?ref=70e1dbecd2a84859335c56e106afdf3b879981c0",
        "patch": "@@ -19,26 +19,18 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n     CTxMemPool mpool(CFeeRate(1000));\n     TestMemPoolEntryHelper entry;\n     CAmount basefee(2000);\n-    double basepri = 1e6;\n     CAmount deltaFee(100);\n-    double deltaPri=5e5;\n-    std::vector<CAmount> feeV[2];\n-    std::vector<double> priV[2];\n+    std::vector<CAmount> feeV;\n \n-    // Populate vectors of increasing fees or priorities\n+    // Populate vectors of increasing fees\n     for (int j = 0; j < 10; j++) {\n-        //V[0] is for fee transactions\n-        feeV[0].push_back(basefee * (j+1));\n-        priV[0].push_back(0);\n-        //V[1] is for priority transactions\n-        feeV[1].push_back(CAmount(0));\n-        priV[1].push_back(basepri * pow(10, j+1));\n+        feeV.push_back(basefee * (j+1));\n     }\n \n     // Store the hashes of transactions that have been\n-    // added to the mempool by their associate fee/pri\n+    // added to the mempool by their associate fee\n     // txHashes[j] is populated with transactions either of\n-    // fee = basefee * (j+1)  OR  pri = 10^6 * 10^(j+1)\n+    // fee = basefee * (j+1)\n     std::vector<uint256> txHashes[10];\n \n     // Create a transaction template\n@@ -60,19 +52,19 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n     // At a decay .998 and 4 fee transactions per block\n     // This makes the tx count about 1.33 per bucket, above the 1 threshold\n     while (blocknum < 200) {\n-        for (int j = 0; j < 10; j++) { // For each fee/pri multiple\n-            for (int k = 0; k < 5; k++) { // add 4 fee txs for every priority tx\n+        for (int j = 0; j < 10; j++) { // For each fee\n+            for (int k = 0; k < 4; k++) { // add 4 fee txs\n                 tx.vin[0].prevout.n = 10000*blocknum+100*j+k; // make transaction unique\n                 uint256 hash = tx.GetHash();\n-                mpool.addUnchecked(hash, entry.Fee(feeV[k/4][j]).Time(GetTime()).Priority(priV[k/4][j]).Height(blocknum).FromTx(tx, &mpool));\n+                mpool.addUnchecked(hash, entry.Fee(feeV[j]).Time(GetTime()).Priority(0).Height(blocknum).FromTx(tx, &mpool));\n                 txHashes[j].push_back(hash);\n             }\n         }\n-        //Create blocks where higher fee/pri txs are included more often\n+        //Create blocks where higher fee txs are included more often\n         for (int h = 0; h <= blocknum%10; h++) {\n-            // 10/10 blocks add highest fee/pri transactions\n+            // 10/10 blocks add highest fee transactions\n             // 9/10 blocks add 2nd highest and so on until ...\n-            // 1/10 blocks add lowest fee/pri transactions\n+            // 1/10 blocks add lowest fee transactions\n             while (txHashes[9-h].size()) {\n                 std::shared_ptr<const CTransaction> ptx = mpool.get(txHashes[9-h].back());\n                 if (ptx)\n@@ -100,7 +92,6 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n     }\n \n     std::vector<CAmount> origFeeEst;\n-    std::vector<double> origPriEst;\n     // Highest feerate is 10*baseRate and gets in all blocks,\n     // second highest feerate is 9*baseRate and gets in 9/10 blocks = 90%,\n     // third highest feerate is 8*base rate, and gets in 8/10 blocks = 80%,\n@@ -109,16 +100,12 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n     // so estimateFee(2) should return 9*baseRate etc...\n     for (int i = 1; i < 10;i++) {\n         origFeeEst.push_back(mpool.estimateFee(i).GetFeePerK());\n-        origPriEst.push_back(mpool.estimatePriority(i));\n         if (i > 1) { // Fee estimates should be monotonically decreasing\n             BOOST_CHECK(origFeeEst[i-1] <= origFeeEst[i-2]);\n-            BOOST_CHECK(origPriEst[i-1] <= origPriEst[i-2]);\n         }\n         int mult = 11-i;\n         BOOST_CHECK(origFeeEst[i-1] < mult*baseRate.GetFeePerK() + deltaFee);\n         BOOST_CHECK(origFeeEst[i-1] > mult*baseRate.GetFeePerK() - deltaFee);\n-        BOOST_CHECK(origPriEst[i-1] < pow(10,mult) * basepri + deltaPri);\n-        BOOST_CHECK(origPriEst[i-1] > pow(10,mult) * basepri - deltaPri);\n     }\n \n     // Mine 50 more blocks with no transactions happening, estimates shouldn't change\n@@ -129,19 +116,17 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n     for (int i = 1; i < 10;i++) {\n         BOOST_CHECK(mpool.estimateFee(i).GetFeePerK() < origFeeEst[i-1] + deltaFee);\n         BOOST_CHECK(mpool.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n-        BOOST_CHECK(mpool.estimatePriority(i) < origPriEst[i-1] + deltaPri);\n-        BOOST_CHECK(mpool.estimatePriority(i) > origPriEst[i-1] - deltaPri);\n     }\n \n \n     // Mine 15 more blocks with lots of transactions happening and not getting mined\n     // Estimates should go up\n     while (blocknum < 265) {\n-        for (int j = 0; j < 10; j++) { // For each fee/pri multiple\n-            for (int k = 0; k < 5; k++) { // add 4 fee txs for every priority tx\n+        for (int j = 0; j < 10; j++) { // For each fee multiple\n+            for (int k = 0; k < 4; k++) { // add 4 fee txs\n                 tx.vin[0].prevout.n = 10000*blocknum+100*j+k;\n                 uint256 hash = tx.GetHash();\n-                mpool.addUnchecked(hash, entry.Fee(feeV[k/4][j]).Time(GetTime()).Priority(priV[k/4][j]).Height(blocknum).FromTx(tx, &mpool));\n+                mpool.addUnchecked(hash, entry.Fee(feeV[j]).Time(GetTime()).Priority(0).Height(blocknum).FromTx(tx, &mpool));\n                 txHashes[j].push_back(hash);\n             }\n         }\n@@ -152,8 +137,6 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n     for (int i = 1; i < 10;i++) {\n         BOOST_CHECK(mpool.estimateFee(i) == CFeeRate(0) || mpool.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n         BOOST_CHECK(mpool.estimateSmartFee(i, &answerFound).GetFeePerK() > origFeeEst[answerFound-1] - deltaFee);\n-        BOOST_CHECK(mpool.estimatePriority(i) == -1 || mpool.estimatePriority(i) > origPriEst[i-1] - deltaPri);\n-        BOOST_CHECK(mpool.estimateSmartPriority(i, &answerFound) > origPriEst[answerFound-1] - deltaPri);\n     }\n \n     // Mine all those transactions\n@@ -170,36 +153,35 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n     block.clear();\n     for (int i = 1; i < 10;i++) {\n         BOOST_CHECK(mpool.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n-        BOOST_CHECK(mpool.estimatePriority(i) > origPriEst[i-1] - deltaPri);\n     }\n \n     // Mine 200 more blocks where everything is mined every block\n     // Estimates should be below original estimates\n     while (blocknum < 465) {\n-        for (int j = 0; j < 10; j++) { // For each fee/pri multiple\n-            for (int k = 0; k < 5; k++) { // add 4 fee txs for every priority tx\n+        for (int j = 0; j < 10; j++) { // For each fee multiple\n+            for (int k = 0; k < 4; k++) { // add 4 fee txs\n                 tx.vin[0].prevout.n = 10000*blocknum+100*j+k;\n                 uint256 hash = tx.GetHash();\n-                mpool.addUnchecked(hash, entry.Fee(feeV[k/4][j]).Time(GetTime()).Priority(priV[k/4][j]).Height(blocknum).FromTx(tx, &mpool));\n+                mpool.addUnchecked(hash, entry.Fee(feeV[j]).Time(GetTime()).Priority(0).Height(blocknum).FromTx(tx, &mpool));\n                 std::shared_ptr<const CTransaction> ptx = mpool.get(hash);\n                 if (ptx)\n                     block.push_back(*ptx);\n+\n             }\n         }\n         mpool.removeForBlock(block, ++blocknum);\n         block.clear();\n     }\n     for (int i = 1; i < 10; i++) {\n         BOOST_CHECK(mpool.estimateFee(i).GetFeePerK() < origFeeEst[i-1] - deltaFee);\n-        BOOST_CHECK(mpool.estimatePriority(i) < origPriEst[i-1] - deltaPri);\n     }\n \n     // Test that if the mempool is limited, estimateSmartFee won't return a value below the mempool min fee\n     // and that estimateSmartPriority returns essentially an infinite value\n-    mpool.addUnchecked(tx.GetHash(),  entry.Fee(feeV[0][5]).Time(GetTime()).Priority(priV[1][5]).Height(blocknum).FromTx(tx, &mpool));\n-    // evict that transaction which should set a mempool min fee of minRelayTxFee + feeV[0][5]\n+    mpool.addUnchecked(tx.GetHash(),  entry.Fee(feeV[5]).Time(GetTime()).Priority(0).Height(blocknum).FromTx(tx, &mpool));\n+    // evict that transaction which should set a mempool min fee of minRelayTxFee + feeV[5]\n     mpool.TrimToSize(1);\n-    BOOST_CHECK(mpool.GetMinFee(1).GetFeePerK() > feeV[0][5]);\n+    BOOST_CHECK(mpool.GetMinFee(1).GetFeePerK() > feeV[5]);\n     for (int i = 1; i < 10; i++) {\n         BOOST_CHECK(mpool.estimateSmartFee(i).GetFeePerK() >= mpool.estimateFee(i).GetFeePerK());\n         BOOST_CHECK(mpool.estimateSmartFee(i).GetFeePerK() >= mpool.GetMinFee(1).GetFeePerK());"
      },
      {
        "sha": "259348d750f727abf815b766e9a3e6a82db12514",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70e1dbecd2a84859335c56e106afdf3b879981c0/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70e1dbecd2a84859335c56e106afdf3b879981c0/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=70e1dbecd2a84859335c56e106afdf3b879981c0",
        "patch": "@@ -895,7 +895,7 @@ CTxMemPool::WriteFeeEstimates(CAutoFile& fileout) const\n {\n     try {\n         LOCK(cs);\n-        fileout << 109900; // version required to read: 0.10.99 or later\n+        fileout << 139900; // version required to read: 0.13.99 or later\n         fileout << CLIENT_VERSION; // version that wrote the file\n         minerPolicyEstimator->Write(fileout);\n     }\n@@ -914,9 +914,8 @@ CTxMemPool::ReadFeeEstimates(CAutoFile& filein)\n         filein >> nVersionRequired >> nVersionThatWrote;\n         if (nVersionRequired > CLIENT_VERSION)\n             return error(\"CTxMemPool::ReadFeeEstimates(): up-version (%d) fee estimate file\", nVersionRequired);\n-\n         LOCK(cs);\n-        minerPolicyEstimator->Read(filein);\n+        minerPolicyEstimator->Read(filein, nVersionRequired);\n     }\n     catch (const std::exception&) {\n         LogPrintf(\"CTxMemPool::ReadFeeEstimates(): unable to read policy estimator data (non-fatal)\\n\");"
      }
    ]
  },
  {
    "sha": "aacda2276b262234b3da39e83cfafda607c6ad6a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphYWNkYTIyNzZiMjYyMjM0YjNkYTM5ZTgzY2ZhZmRhNjA3YzZhZDZh",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-11-04T14:19:22Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-11-04T14:19:22Z"
      },
      "message": "SQUASHME: slight correction to file versioning",
      "tree": {
        "sha": "1c423d301092b8e94e23d65bce508a0f181b9ac5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1c423d301092b8e94e23d65bce508a0f181b9ac5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/aacda2276b262234b3da39e83cfafda607c6ad6a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aacda2276b262234b3da39e83cfafda607c6ad6a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/aacda2276b262234b3da39e83cfafda607c6ad6a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aacda2276b262234b3da39e83cfafda607c6ad6a/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "70e1dbecd2a84859335c56e106afdf3b879981c0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/70e1dbecd2a84859335c56e106afdf3b879981c0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/70e1dbecd2a84859335c56e106afdf3b879981c0"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 4,
      "deletions": 4
    },
    "files": [
      {
        "sha": "77510b564f42843bea77dee4eb846df4faae6d42",
        "filename": "src/policy/fees.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aacda2276b262234b3da39e83cfafda607c6ad6a/src/policy/fees.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aacda2276b262234b3da39e83cfafda607c6ad6a/src/policy/fees.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.cpp?ref=aacda2276b262234b3da39e83cfafda607c6ad6a",
        "patch": "@@ -466,13 +466,13 @@ void CBlockPolicyEstimator::Write(CAutoFile& fileout)\n     feeStats.Write(fileout);\n }\n \n-void CBlockPolicyEstimator::Read(CAutoFile& filein, int nVersionRequired)\n+void CBlockPolicyEstimator::Read(CAutoFile& filein, int nFileVersion)\n {\n     int nFileBestSeenHeight;\n     filein >> nFileBestSeenHeight;\n     feeStats.Read(filein);\n     nBestSeenHeight = nFileBestSeenHeight;\n-    if (nVersionRequired < 139900) {\n+    if (nFileVersion < 139900) {\n         TxConfirmStats priStats;\n         priStats.Read(filein);\n     }"
      },
      {
        "sha": "b5881afadf0557ecad81cc6f97cfae231e6f3f6c",
        "filename": "src/policy/fees.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aacda2276b262234b3da39e83cfafda607c6ad6a/src/policy/fees.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aacda2276b262234b3da39e83cfafda607c6ad6a/src/policy/fees.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.h?ref=aacda2276b262234b3da39e83cfafda607c6ad6a",
        "patch": "@@ -242,7 +242,7 @@ class CBlockPolicyEstimator\n     void Write(CAutoFile& fileout);\n \n     /** Read estimation data from a file */\n-    void Read(CAutoFile& filein, int nVersionRequired);\n+    void Read(CAutoFile& filein, int nFileVersion);\n \n private:\n     CFeeRate minTrackedFee;    //!< Passed to constructor to avoid dependency on main"
      },
      {
        "sha": "45135a5f7347c4711c48b17bec3373794f04fe9b",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aacda2276b262234b3da39e83cfafda607c6ad6a/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aacda2276b262234b3da39e83cfafda607c6ad6a/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=aacda2276b262234b3da39e83cfafda607c6ad6a",
        "patch": "@@ -915,7 +915,7 @@ CTxMemPool::ReadFeeEstimates(CAutoFile& filein)\n         if (nVersionRequired > CLIENT_VERSION)\n             return error(\"CTxMemPool::ReadFeeEstimates(): up-version (%d) fee estimate file\", nVersionRequired);\n         LOCK(cs);\n-        minerPolicyEstimator->Read(filein, nVersionRequired);\n+        minerPolicyEstimator->Read(filein, nVersionThatWrote);\n     }\n     catch (const std::exception&) {\n         LogPrintf(\"CTxMemPool::ReadFeeEstimates(): unable to read policy estimator data (non-fatal)\\n\");"
      }
    ]
  },
  {
    "sha": "9ea4ed9977928c44967955e152450da1912712ff",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZWE0ZWQ5OTc3OTI4YzQ0OTY3OTU1ZTE1MjQ1MGRhMTkxMjcxMmZm",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-11-04T16:03:35Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-11-04T16:08:55Z"
      },
      "message": "add release notes for removal of priority estimation",
      "tree": {
        "sha": "5bfd214fb64bcf71b7300f49c2c3b0cb186e48d1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5bfd214fb64bcf71b7300f49c2c3b0cb186e48d1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9ea4ed9977928c44967955e152450da1912712ff",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9ea4ed9977928c44967955e152450da1912712ff",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9ea4ed9977928c44967955e152450da1912712ff",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9ea4ed9977928c44967955e152450da1912712ff/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "aacda2276b262234b3da39e83cfafda607c6ad6a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aacda2276b262234b3da39e83cfafda607c6ad6a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/aacda2276b262234b3da39e83cfafda607c6ad6a"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 9,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f511fee22ea465c7a6338276744769bf93b57959",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ea4ed9977928c44967955e152450da1912712ff/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ea4ed9977928c44967955e152450da1912712ff/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=9ea4ed9977928c44967955e152450da1912712ff",
        "patch": "@@ -48,6 +48,15 @@ Low-level RPC changes\n   an optional third arg, which was always ignored. Make sure to never pass more\n   than two arguments.\n \n+Removal of Priority Estimation\n+------------------------------\n+\n+- Estimation of \"priority\" needed for a transaction to be included within a target\n+  number of blocks has been removed.  The rpc calls are deprecated and will either\n+  return -1 or 1e24 appropriately. The format for fee_estimates.dat has also\n+  changed to no longer save these priority estimates. It will automatically be\n+  converted to the new format which is not readable by prior versions of the\n+  software.\n \n 0.14.0 Change log\n ================="
      }
    ]
  }
]