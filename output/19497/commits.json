[
  {
    "sha": "0e95a6f508cc4383fcfecb2e0508897ca02601c4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZTk1YTZmNTA4Y2M0MzgzZmNmZWNiMmUwNTA4ODk3Y2EwMjYwMWM0",
    "commit": {
      "author": {
        "name": "Saahil Shangle",
        "email": "saahilshangle@gmail.com",
        "date": "2020-06-08T00:20:11Z"
      },
      "committer": {
        "name": "Saahil Shangle",
        "email": "saahilshangle@gmail.com",
        "date": "2020-06-08T00:20:11Z"
      },
      "message": "Attempted test where one node sends block to another",
      "tree": {
        "sha": "b051154080cb8e81d72ba12e47955d5fd8ed112f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b051154080cb8e81d72ba12e47955d5fd8ed112f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0e95a6f508cc4383fcfecb2e0508897ca02601c4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e95a6f508cc4383fcfecb2e0508897ca02601c4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0e95a6f508cc4383fcfecb2e0508897ca02601c4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e95a6f508cc4383fcfecb2e0508897ca02601c4/comments",
    "author": {
      "login": "saahilshangle",
      "id": 10226886,
      "node_id": "MDQ6VXNlcjEwMjI2ODg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10226886?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saahilshangle",
      "html_url": "https://github.com/saahilshangle",
      "followers_url": "https://api.github.com/users/saahilshangle/followers",
      "following_url": "https://api.github.com/users/saahilshangle/following{/other_user}",
      "gists_url": "https://api.github.com/users/saahilshangle/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saahilshangle/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saahilshangle/subscriptions",
      "organizations_url": "https://api.github.com/users/saahilshangle/orgs",
      "repos_url": "https://api.github.com/users/saahilshangle/repos",
      "events_url": "https://api.github.com/users/saahilshangle/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saahilshangle/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "saahilshangle",
      "id": 10226886,
      "node_id": "MDQ6VXNlcjEwMjI2ODg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10226886?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saahilshangle",
      "html_url": "https://github.com/saahilshangle",
      "followers_url": "https://api.github.com/users/saahilshangle/followers",
      "following_url": "https://api.github.com/users/saahilshangle/following{/other_user}",
      "gists_url": "https://api.github.com/users/saahilshangle/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saahilshangle/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saahilshangle/subscriptions",
      "organizations_url": "https://api.github.com/users/saahilshangle/orgs",
      "repos_url": "https://api.github.com/users/saahilshangle/repos",
      "events_url": "https://api.github.com/users/saahilshangle/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saahilshangle/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b3091b2be7d1e5ab86d7380a884d4f23a5e9c9b7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b3091b2be7d1e5ab86d7380a884d4f23a5e9c9b7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b3091b2be7d1e5ab86d7380a884d4f23a5e9c9b7"
      }
    ],
    "stats": {
      "total": 224,
      "additions": 224,
      "deletions": 0
    },
    "files": [
      {
        "sha": "87d7100d263b50c88ea90451a601e813aebc0939",
        "filename": "test/functional/p2p_saahil.py",
        "status": "added",
        "additions": 224,
        "deletions": 0,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e95a6f508cc4383fcfecb2e0508897ca02601c4/test/functional/p2p_saahil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e95a6f508cc4383fcfecb2e0508897ca02601c4/test/functional/p2p_saahil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_saahil.py?ref=0e95a6f508cc4383fcfecb2e0508897ca02601c4",
        "patch": "@@ -0,0 +1,224 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"An example functional test\n+\n+The module-level docstring should include a high-level description of\n+what the test is doing. It's the first thing people see when they open\n+the file and should give the reader information about *what* the test\n+is testing and *how* it's being tested\n+\"\"\"\n+# Imports should be in PEP8 ordering (std library first, then third party\n+# libraries then local imports).\n+from collections import defaultdict\n+\n+# Avoid wildcard * imports\n+from test_framework.blocktools import (create_block, create_coinbase)\n+from test_framework.messages import CInv, MSG_BLOCK\n+from test_framework.mininode import (\n+    P2PInterface,\n+    mininode_lock,\n+    msg_block,\n+    msg_getdata,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    connect_nodes,\n+    wait_until,\n+)\n+\n+# P2PInterface is a class containing callbacks to be executed when a P2P\n+# message is received from the node-under-test. Subclass P2PInterface and\n+# override the on_*() methods if you need custom behaviour.\n+class BaseNode(P2PInterface):\n+    def __init__(self):\n+        \"\"\"Initialize the P2PInterface\n+\n+        Used to initialize custom properties for the Node that aren't\n+        included by default in the base class. Be aware that the P2PInterface\n+        base class already stores a counter for each P2P message type and the\n+        last received message of each type, which should be sufficient for the\n+        needs of most tests.\n+\n+        Call super().__init__() first for standard initialization and then\n+        initialize custom properties.\"\"\"\n+        super().__init__()\n+        # Stores a dictionary of all blocks received\n+        self.block_receive_map = defaultdict(int)\n+\n+    def on_block(self, message):\n+        \"\"\"Override the standard on_block callback\n+\n+        Store the hash of a received block in the dictionary.\"\"\"\n+        message.block.calc_sha256()\n+        self.block_receive_map[message.block.sha256] += 1\n+\n+    def on_inv(self, message):\n+        \"\"\"Override the standard on_inv callback\"\"\"\n+        pass\n+\n+def custom_function():\n+    \"\"\"Do some custom behaviour\n+\n+    If this function is more generally useful for other tests, consider\n+    moving it to a module in test_framework.\"\"\"\n+    # self.log.info(\"running custom_function\")  # Oops! Can't run self.log outside the BitcoinTestFramework\n+    pass\n+\n+\n+class ExampleTest(BitcoinTestFramework):\n+    # Each functional test is a subclass of the BitcoinTestFramework class.\n+\n+    # Override the set_test_params(), skip_test_if_missing_module(), add_options(), setup_chain(), setup_network()\n+    # and setup_nodes() methods to customize the test setup as required.\n+\n+    def set_test_params(self):\n+        \"\"\"Override test parameters for your individual test.\n+\n+        This method must be overridden and num_nodes must be explicitly set.\"\"\"\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+        # Use self.extra_args to change command-line arguments for the nodes\n+        self.extra_args = [[], [\"-logips\"], []]\n+\n+        # self.log.info(\"I've finished set_test_params\")  # Oops! Can't run self.log before run_test()\n+\n+    # Use skip_test_if_missing_module() to skip the test if your test requires certain modules to be present.\n+    # This test uses generate which requires wallet to be compiled\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    # Use add_options() to add specific command-line options for your test.\n+    # In practice this is not used very much, since the tests are mostly written\n+    # to be run in automated environments without command-line options.\n+    # def add_options()\n+    #     pass\n+\n+    # Use setup_chain() to customize the node data directories. In practice\n+    # this is not used very much since the default behaviour is almost always\n+    # fine\n+    # def setup_chain():\n+    #     pass\n+\n+    def setup_network(self):\n+        \"\"\"Setup the test network topology\n+\n+        Often you won't need to override this, since the standard network topology\n+        (linear: node0 <-> node1 <-> node2 <-> ...) is fine for most tests.\n+\n+        If you do override this method, remember to start the nodes, assign\n+        them to self.nodes, connect them and then sync.\"\"\"\n+\n+        self.setup_nodes()\n+\n+        # In this test, we're not connecting node2 to node0 or node1. Calls to\n+        # sync_all() should not include node2, since we're not expecting it to\n+        # sync.\n+        #connect_nodes(self.nodes[0], 1)\n+        #self.sync_all(self.nodes[0:2])\n+\n+    # Use setup_nodes() to customize the node start behaviour (for example if\n+    # you don't want to start all nodes at the start of the test).\n+    # def setup_nodes():\n+    #     pass\n+\n+    def custom_method(self):\n+        \"\"\"Do some custom behaviour for this test\n+\n+        Define it in a method here because you're going to use it repeatedly.\n+        If you think it's useful in general, consider moving it to the base\n+        BitcoinTestFramework class so other tests can use it.\"\"\"\n+\n+        self.log.info(\"Running custom_method\")\n+\n+    def run_test(self):\n+        \"\"\"Main test logic\"\"\"\n+\n+        # Create P2P connections will wait for a verack to make sure the connection is fully up\n+        self.nodes[0].add_p2p_connection(BaseNode())\n+\n+        # Generating a block on one of the nodes will get us out of IBD\n+        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n+        self.log.info(\"Number of blocks in node 0: \" + str(self.nodes[0].getblockcount()))\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+        \n+        self.log.info(\"Now sending block from one to the other\")\n+        connect_nodes(self.nodes[0], 1)\n+        self.sync_all(self.nodes[0:2])\n+\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+\n+        # # Notice above how we called an RPC by calling a method with the same\n+        # # name on the node object. Notice also how we used a keyword argument\n+        # # to specify a named RPC argument. Neither of those are defined on the\n+        # # node object. Instead there's some __getattr__() magic going on under\n+        # # the covers to dispatch unrecognised attribute calls to the RPC\n+        # # interface.\n+\n+        # # Logs are nice. Do plenty of them. They can be used in place of comments for\n+        # # breaking the test into sub-sections.\n+        # self.log.info(\"Starting test!\")\n+\n+        # self.log.info(\"Calling a custom function\")\n+        # custom_function()\n+\n+        # self.log.info(\"Calling a custom method\")\n+        # self.custom_method()\n+\n+        # self.log.info(\"Create some blocks\")\n+        # self.tip = int(self.nodes[0].getbestblockhash(), 16)\n+        # self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n+\n+        # height = self.nodes[0].getblockcount()\n+\n+        # for i in range(10):\n+        #     # Use the mininode and blocktools functionality to manually build a block\n+        #     # Calling the generate() rpc is easier, but this allows us to exactly\n+        #     # control the blocks and transactions.\n+        #     block = create_block(self.tip, create_coinbase(height+1), self.block_time)\n+        #     block.solve()\n+        #     block_message = msg_block(block)\n+        #     # Send message is used to send a P2P message to the node over our P2PInterface\n+        #     self.nodes[0].p2p.send_message(block_message)\n+        #     self.tip = block.sha256\n+        #     blocks.append(self.tip)\n+        #     self.block_time += 1\n+        #     height += 1\n+\n+        # self.log.info(\"Wait for node1 to reach current tip (height 11) using RPC\")\n+        # self.nodes[1].waitforblockheight(11)\n+\n+        # self.log.info(\"Connect node2 and node1\")\n+        # connect_nodes(self.nodes[1], 2)\n+\n+        # self.log.info(\"Wait for node2 to receive all the blocks from node1\")\n+        # self.sync_all()\n+\n+        # self.log.info(\"Add P2P connection to node2\")\n+        # self.nodes[0].disconnect_p2ps()\n+\n+        # self.nodes[2].add_p2p_connection(BaseNode())\n+\n+        # self.log.info(\"Test that node2 propagates all the blocks to us\")\n+\n+        # getdata_request = msg_getdata()\n+        # for block in blocks:\n+        #     getdata_request.inv.append(CInv(MSG_BLOCK, block))\n+        # self.nodes[2].p2p.send_message(getdata_request)\n+\n+        # # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n+        # # P2PInterface objects.\n+        # wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n+\n+        # self.log.info(\"Check that each block was received only once\")\n+        # # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving\n+        # # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking\n+        # # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n+        # with mininode_lock:\n+        #     for block in self.nodes[2].p2p.block_receive_map.values():\n+        #         assert_equal(block, 1)\n+\n+if __name__ == '__main__':\n+    ExampleTest().main()"
      }
    ]
  },
  {
    "sha": "1341bd0f3107c45461c7193ffcba444accbea70b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMzQxYmQwZjMxMDdjNDU0NjFjNzE5M2ZmY2JhNDQ0YWNjYmVhNzBi",
    "commit": {
      "author": {
        "name": "Saahil Shangle",
        "email": "saahilshangle@gmail.com",
        "date": "2020-06-13T04:56:32Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2020-06-13T04:56:32Z"
      },
      "message": "Merge pull request #2 from saahilshangle/practice-testing\n\nAttempted test where one node sends block to another",
      "tree": {
        "sha": "b051154080cb8e81d72ba12e47955d5fd8ed112f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b051154080cb8e81d72ba12e47955d5fd8ed112f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1341bd0f3107c45461c7193ffcba444accbea70b",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe5FyACRBK7hj4Ov3rIwAAdHIIAJgUXVft7P9NUCVj8RrV2974\nzrewBpS9E7WOpWRdm51fkj8ChfSxCGUZYkNrm5+Dlk6QLH3Ii1wTjRmHwdxco01N\nnTyUuxD2l1L0yJdLX93/GUUjQLR65UsqjG8o/IPuEKt0Vi9yHe9fBe/D+4bGRtDR\nPl2P/RngAYXyq7rtcYvsS/BJdwLW/JPwRAxli4e+OPfNhO/2aB+NZAPVg1vBPa+W\ngiBPDVE2+epEg7Mzyj4wI+OTEC1xjOzsnEKkZsQqe/tZ5gR+hYQk/3GiLSE4QULm\nLNjRTQpPwFdcMCBU1Q9k7rGXGQ1/NbjOoSEiuktIXMFkPaTLhguFg0D5GuJKvvM=\n=/+Ff\n-----END PGP SIGNATURE-----\n",
        "payload": "tree b051154080cb8e81d72ba12e47955d5fd8ed112f\nparent b3091b2be7d1e5ab86d7380a884d4f23a5e9c9b7\nparent 0e95a6f508cc4383fcfecb2e0508897ca02601c4\nauthor Saahil Shangle <saahilshangle@gmail.com> 1592024192 -0700\ncommitter GitHub <noreply@github.com> 1592024192 -0700\n\nMerge pull request #2 from saahilshangle/practice-testing\n\nAttempted test where one node sends block to another"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1341bd0f3107c45461c7193ffcba444accbea70b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1341bd0f3107c45461c7193ffcba444accbea70b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1341bd0f3107c45461c7193ffcba444accbea70b/comments",
    "author": {
      "login": "saahilshangle",
      "id": 10226886,
      "node_id": "MDQ6VXNlcjEwMjI2ODg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10226886?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saahilshangle",
      "html_url": "https://github.com/saahilshangle",
      "followers_url": "https://api.github.com/users/saahilshangle/followers",
      "following_url": "https://api.github.com/users/saahilshangle/following{/other_user}",
      "gists_url": "https://api.github.com/users/saahilshangle/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saahilshangle/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saahilshangle/subscriptions",
      "organizations_url": "https://api.github.com/users/saahilshangle/orgs",
      "repos_url": "https://api.github.com/users/saahilshangle/repos",
      "events_url": "https://api.github.com/users/saahilshangle/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saahilshangle/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b3091b2be7d1e5ab86d7380a884d4f23a5e9c9b7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b3091b2be7d1e5ab86d7380a884d4f23a5e9c9b7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b3091b2be7d1e5ab86d7380a884d4f23a5e9c9b7"
      },
      {
        "sha": "0e95a6f508cc4383fcfecb2e0508897ca02601c4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e95a6f508cc4383fcfecb2e0508897ca02601c4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0e95a6f508cc4383fcfecb2e0508897ca02601c4"
      }
    ],
    "stats": {
      "total": 224,
      "additions": 224,
      "deletions": 0
    },
    "files": [
      {
        "sha": "87d7100d263b50c88ea90451a601e813aebc0939",
        "filename": "test/functional/p2p_saahil.py",
        "status": "added",
        "additions": 224,
        "deletions": 0,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1341bd0f3107c45461c7193ffcba444accbea70b/test/functional/p2p_saahil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1341bd0f3107c45461c7193ffcba444accbea70b/test/functional/p2p_saahil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_saahil.py?ref=1341bd0f3107c45461c7193ffcba444accbea70b",
        "patch": "@@ -0,0 +1,224 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"An example functional test\n+\n+The module-level docstring should include a high-level description of\n+what the test is doing. It's the first thing people see when they open\n+the file and should give the reader information about *what* the test\n+is testing and *how* it's being tested\n+\"\"\"\n+# Imports should be in PEP8 ordering (std library first, then third party\n+# libraries then local imports).\n+from collections import defaultdict\n+\n+# Avoid wildcard * imports\n+from test_framework.blocktools import (create_block, create_coinbase)\n+from test_framework.messages import CInv, MSG_BLOCK\n+from test_framework.mininode import (\n+    P2PInterface,\n+    mininode_lock,\n+    msg_block,\n+    msg_getdata,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    connect_nodes,\n+    wait_until,\n+)\n+\n+# P2PInterface is a class containing callbacks to be executed when a P2P\n+# message is received from the node-under-test. Subclass P2PInterface and\n+# override the on_*() methods if you need custom behaviour.\n+class BaseNode(P2PInterface):\n+    def __init__(self):\n+        \"\"\"Initialize the P2PInterface\n+\n+        Used to initialize custom properties for the Node that aren't\n+        included by default in the base class. Be aware that the P2PInterface\n+        base class already stores a counter for each P2P message type and the\n+        last received message of each type, which should be sufficient for the\n+        needs of most tests.\n+\n+        Call super().__init__() first for standard initialization and then\n+        initialize custom properties.\"\"\"\n+        super().__init__()\n+        # Stores a dictionary of all blocks received\n+        self.block_receive_map = defaultdict(int)\n+\n+    def on_block(self, message):\n+        \"\"\"Override the standard on_block callback\n+\n+        Store the hash of a received block in the dictionary.\"\"\"\n+        message.block.calc_sha256()\n+        self.block_receive_map[message.block.sha256] += 1\n+\n+    def on_inv(self, message):\n+        \"\"\"Override the standard on_inv callback\"\"\"\n+        pass\n+\n+def custom_function():\n+    \"\"\"Do some custom behaviour\n+\n+    If this function is more generally useful for other tests, consider\n+    moving it to a module in test_framework.\"\"\"\n+    # self.log.info(\"running custom_function\")  # Oops! Can't run self.log outside the BitcoinTestFramework\n+    pass\n+\n+\n+class ExampleTest(BitcoinTestFramework):\n+    # Each functional test is a subclass of the BitcoinTestFramework class.\n+\n+    # Override the set_test_params(), skip_test_if_missing_module(), add_options(), setup_chain(), setup_network()\n+    # and setup_nodes() methods to customize the test setup as required.\n+\n+    def set_test_params(self):\n+        \"\"\"Override test parameters for your individual test.\n+\n+        This method must be overridden and num_nodes must be explicitly set.\"\"\"\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+        # Use self.extra_args to change command-line arguments for the nodes\n+        self.extra_args = [[], [\"-logips\"], []]\n+\n+        # self.log.info(\"I've finished set_test_params\")  # Oops! Can't run self.log before run_test()\n+\n+    # Use skip_test_if_missing_module() to skip the test if your test requires certain modules to be present.\n+    # This test uses generate which requires wallet to be compiled\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    # Use add_options() to add specific command-line options for your test.\n+    # In practice this is not used very much, since the tests are mostly written\n+    # to be run in automated environments without command-line options.\n+    # def add_options()\n+    #     pass\n+\n+    # Use setup_chain() to customize the node data directories. In practice\n+    # this is not used very much since the default behaviour is almost always\n+    # fine\n+    # def setup_chain():\n+    #     pass\n+\n+    def setup_network(self):\n+        \"\"\"Setup the test network topology\n+\n+        Often you won't need to override this, since the standard network topology\n+        (linear: node0 <-> node1 <-> node2 <-> ...) is fine for most tests.\n+\n+        If you do override this method, remember to start the nodes, assign\n+        them to self.nodes, connect them and then sync.\"\"\"\n+\n+        self.setup_nodes()\n+\n+        # In this test, we're not connecting node2 to node0 or node1. Calls to\n+        # sync_all() should not include node2, since we're not expecting it to\n+        # sync.\n+        #connect_nodes(self.nodes[0], 1)\n+        #self.sync_all(self.nodes[0:2])\n+\n+    # Use setup_nodes() to customize the node start behaviour (for example if\n+    # you don't want to start all nodes at the start of the test).\n+    # def setup_nodes():\n+    #     pass\n+\n+    def custom_method(self):\n+        \"\"\"Do some custom behaviour for this test\n+\n+        Define it in a method here because you're going to use it repeatedly.\n+        If you think it's useful in general, consider moving it to the base\n+        BitcoinTestFramework class so other tests can use it.\"\"\"\n+\n+        self.log.info(\"Running custom_method\")\n+\n+    def run_test(self):\n+        \"\"\"Main test logic\"\"\"\n+\n+        # Create P2P connections will wait for a verack to make sure the connection is fully up\n+        self.nodes[0].add_p2p_connection(BaseNode())\n+\n+        # Generating a block on one of the nodes will get us out of IBD\n+        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n+        self.log.info(\"Number of blocks in node 0: \" + str(self.nodes[0].getblockcount()))\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+        \n+        self.log.info(\"Now sending block from one to the other\")\n+        connect_nodes(self.nodes[0], 1)\n+        self.sync_all(self.nodes[0:2])\n+\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+\n+        # # Notice above how we called an RPC by calling a method with the same\n+        # # name on the node object. Notice also how we used a keyword argument\n+        # # to specify a named RPC argument. Neither of those are defined on the\n+        # # node object. Instead there's some __getattr__() magic going on under\n+        # # the covers to dispatch unrecognised attribute calls to the RPC\n+        # # interface.\n+\n+        # # Logs are nice. Do plenty of them. They can be used in place of comments for\n+        # # breaking the test into sub-sections.\n+        # self.log.info(\"Starting test!\")\n+\n+        # self.log.info(\"Calling a custom function\")\n+        # custom_function()\n+\n+        # self.log.info(\"Calling a custom method\")\n+        # self.custom_method()\n+\n+        # self.log.info(\"Create some blocks\")\n+        # self.tip = int(self.nodes[0].getbestblockhash(), 16)\n+        # self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n+\n+        # height = self.nodes[0].getblockcount()\n+\n+        # for i in range(10):\n+        #     # Use the mininode and blocktools functionality to manually build a block\n+        #     # Calling the generate() rpc is easier, but this allows us to exactly\n+        #     # control the blocks and transactions.\n+        #     block = create_block(self.tip, create_coinbase(height+1), self.block_time)\n+        #     block.solve()\n+        #     block_message = msg_block(block)\n+        #     # Send message is used to send a P2P message to the node over our P2PInterface\n+        #     self.nodes[0].p2p.send_message(block_message)\n+        #     self.tip = block.sha256\n+        #     blocks.append(self.tip)\n+        #     self.block_time += 1\n+        #     height += 1\n+\n+        # self.log.info(\"Wait for node1 to reach current tip (height 11) using RPC\")\n+        # self.nodes[1].waitforblockheight(11)\n+\n+        # self.log.info(\"Connect node2 and node1\")\n+        # connect_nodes(self.nodes[1], 2)\n+\n+        # self.log.info(\"Wait for node2 to receive all the blocks from node1\")\n+        # self.sync_all()\n+\n+        # self.log.info(\"Add P2P connection to node2\")\n+        # self.nodes[0].disconnect_p2ps()\n+\n+        # self.nodes[2].add_p2p_connection(BaseNode())\n+\n+        # self.log.info(\"Test that node2 propagates all the blocks to us\")\n+\n+        # getdata_request = msg_getdata()\n+        # for block in blocks:\n+        #     getdata_request.inv.append(CInv(MSG_BLOCK, block))\n+        # self.nodes[2].p2p.send_message(getdata_request)\n+\n+        # # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n+        # # P2PInterface objects.\n+        # wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n+\n+        # self.log.info(\"Check that each block was received only once\")\n+        # # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving\n+        # # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking\n+        # # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n+        # with mininode_lock:\n+        #     for block in self.nodes[2].p2p.block_receive_map.values():\n+        #         assert_equal(block, 1)\n+\n+if __name__ == '__main__':\n+    ExampleTest().main()"
      }
    ]
  },
  {
    "sha": "446128ec094b64170f0272a2cd6d326aa4a47076",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NDYxMjhlYzA5NGI2NDE3MGYwMjcyYTJjZDZkMzI2YWE0YTQ3MDc2",
    "commit": {
      "author": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-06T07:30:09Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:24Z"
      },
      "message": "[rpc] return feereason from send* wallet rpcs",
      "tree": {
        "sha": "00d7558f141daf890b1dc70f27c359b164eb5043",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/00d7558f141daf890b1dc70f27c359b164eb5043"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/446128ec094b64170f0272a2cd6d326aa4a47076",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/446128ec094b64170f0272a2cd6d326aa4a47076",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/446128ec094b64170f0272a2cd6d326aa4a47076",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/446128ec094b64170f0272a2cd6d326aa4a47076/comments",
    "author": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a4eb6a51a7f6eb68c35a90436739e0a7d884ed94",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a4eb6a51a7f6eb68c35a90436739e0a7d884ed94",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a4eb6a51a7f6eb68c35a90436739e0a7d884ed94"
      }
    ],
    "stats": {
      "total": 60,
      "additions": 45,
      "deletions": 15
    },
    "files": [
      {
        "sha": "98d6daa6203b06da599d21ac4cddd27969f13c8c",
        "filename": "src/interfaces/wallet.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/446128ec094b64170f0272a2cd6d326aa4a47076/src/interfaces/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/446128ec094b64170f0272a2cd6d326aa4a47076/src/interfaces/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/wallet.cpp?ref=446128ec094b64170f0272a2cd6d326aa4a47076",
        "patch": "@@ -225,9 +225,10 @@ class WalletImpl : public Wallet\n         bilingual_str& fail_reason) override\n     {\n         LOCK(m_wallet->cs_wallet);\n-        CTransactionRef tx;\n+        CTransactionRef tx; \n+        std::string feeReason; \n         if (!m_wallet->CreateTransaction(recipients, tx, fee, change_pos,\n-                fail_reason, coin_control, sign)) {\n+                fail_reason, coin_control, feeReason, sign)) {\n             return {};\n         }\n         return tx;"
      },
      {
        "sha": "9bc7984975dcb376d180fd6be3077194c995f62f",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/446128ec094b64170f0272a2cd6d326aa4a47076/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/446128ec094b64170f0272a2cd6d326aa4a47076/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=446128ec094b64170f0272a2cd6d326aa4a47076",
        "patch": "@@ -198,9 +198,10 @@ WalletModel::SendCoinsReturn WalletModel::prepareTransaction(WalletModelTransact\n         CAmount nFeeRequired = 0;\n         int nChangePosRet = -1;\n         bilingual_str error;\n+        std::string feeReason;\n \n         auto& newTx = transaction.getWtx();\n-        newTx = m_wallet->createTransaction(vecSend, coinControl, !wallet().privateKeysDisabled() /* sign */, nChangePosRet, nFeeRequired, error);\n+        newTx = m_wallet->createTransaction(vecSend, coinControl, !wallet().privateKeysDisabled() /* sign */, nChangePosRet, nFeeRequired, error, feeReason);\n         transaction.setTransactionFee(nFeeRequired);\n         if (fSubtractFeeFromAmount && newTx)\n             transaction.reassignAmounts(nChangePosRet);"
      },
      {
        "sha": "e8229fc4f18a33e32e035554690f750354ee09eb",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/446128ec094b64170f0272a2cd6d326aa4a47076/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/446128ec094b64170f0272a2cd6d326aa4a47076/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=446128ec094b64170f0272a2cd6d326aa4a47076",
        "patch": "@@ -218,8 +218,9 @@ Result CreateRateBumpTransaction(CWallet& wallet, const uint256& txid, const CCo\n     CTransactionRef tx_new = MakeTransactionRef();\n     CAmount fee_ret;\n     int change_pos_in_out = -1; // No requested location for change\n+    std::string feeReason;\n     bilingual_str fail_reason;\n-    if (!wallet.CreateTransaction(recipients, tx_new, fee_ret, change_pos_in_out, fail_reason, new_coin_control, false)) {\n+    if (!wallet.CreateTransaction(recipients, tx_new, fee_ret, change_pos_in_out, fail_reason, new_coin_control, feeReason, false)) {\n         errors.push_back(Untranslated(\"Unable to create transaction.\") + Untranslated(\" \") + fail_reason);\n         return Result::WALLET_ERROR;\n     }"
      },
      {
        "sha": "baf50ab58232c38951fd09b8fcc5b859f1953d8e",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 7,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/446128ec094b64170f0272a2cd6d326aa4a47076/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/446128ec094b64170f0272a2cd6d326aa4a47076/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=446128ec094b64170f0272a2cd6d326aa4a47076",
        "patch": "@@ -360,7 +360,7 @@ static UniValue setlabel(const JSONRPCRequest& request)\n }\n \n \n-static CTransactionRef SendMoney(CWallet* const pwallet, const CTxDestination& address, CAmount nValue, bool fSubtractFeeFromAmount, const CCoinControl& coin_control, mapValue_t mapValue)\n+static CTransactionRef SendMoney(CWallet* const pwallet, const CTxDestination& address, CAmount nValue, bool fSubtractFeeFromAmount, const CCoinControl& coin_control, mapValue_t mapValue, std::string& feeReason)\n {\n     CAmount curBalance = pwallet->GetBalance(0, coin_control.m_avoid_address_reuse).m_mine_trusted;\n \n@@ -381,8 +381,8 @@ static CTransactionRef SendMoney(CWallet* const pwallet, const CTxDestination& a\n     int nChangePosRet = -1;\n     CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};\n     vecSend.push_back(recipient);\n-    CTransactionRef tx;\n-    if (!pwallet->CreateTransaction(vecSend, tx, nFeeRequired, nChangePosRet, error, coin_control)) {\n+    CTransactionRef tx; \n+    if (!pwallet->CreateTransaction(vecSend, tx, nFeeRequired, nChangePosRet, error, coin_control, feeReason)) {\n         if (!fSubtractFeeFromAmount && nValue + nFeeRequired > curBalance)\n             error = strprintf(Untranslated(\"Error: This transaction requires a transaction fee of at least %s\"), FormatMoney(nFeeRequired));\n         throw JSONRPCError(RPC_WALLET_ERROR, error.original);\n@@ -412,6 +412,8 @@ static UniValue sendtoaddress(const JSONRPCRequest& request)\n             \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n                     {\"avoid_reuse\", RPCArg::Type::BOOL, /* default */ \"true\", \"(only available if avoid_reuse wallet flag is set) Avoid spending from dirty addresses; addresses are considered\\n\"\n             \"                             dirty if they have previously been used in a transaction.\"},\n+                    {\"verbose\", RPCArg::Type::BOOL,  /* default */ \"false\", \n+                            \"Whether to display the fee reason or not.\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::STR_HEX, \"txid\", \"The transaction id.\"\n@@ -470,8 +472,17 @@ static UniValue sendtoaddress(const JSONRPCRequest& request)\n     SetFeeEstimateMode(pwallet, coin_control, request.params[7], request.params[6]);\n \n     EnsureWalletIsUnlocked(pwallet);\n+    UniValue entry(UniValue::VOBJ); \n+    std::string feeReason;\n+    CTransactionRef tx = SendMoney(pwallet, dest, nAmount, fSubtractFeeFromAmount, coin_control, std::move(mapValue), feeReason);\n+    \n+    bool verbose = request.params[9].isNull() ? false : request.params[9].get_bool();\n+    if(verbose){\n+        entry.pushKV(\"hex\", tx->GetHash().GetHex());\n+        entry.pushKV(\"Fee Reason\", feeReason);\n+        return entry;\n+    } \n \n-    CTransactionRef tx = SendMoney(pwallet, dest, nAmount, fSubtractFeeFromAmount, coin_control, std::move(mapValue));\n     return tx->GetHash().GetHex();\n }\n \n@@ -813,6 +824,8 @@ static UniValue sendmany(const JSONRPCRequest& request)\n                     {\"conf_target\", RPCArg::Type::NUM, /* default */ \"wallet default\", \"Confirmation target (in blocks), or fee rate (for \" + CURRENCY_UNIT + \"/kB or \" + CURRENCY_ATOM + \"/B estimate modes)\"},\n                     {\"estimate_mode\", RPCArg::Type::STR, /* default */ \"unset\", std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n             \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+                    {\"verbose\", RPCArg::Type::BOOL,  /* default */ \"false\", \n+                            \"Whether to display the fee reason or not.\"},\n                 },\n                  RPCResult{\n                      RPCResult::Type::STR_HEX, \"txid\", \"The transaction id for the send. Only 1 transaction is created regardless of\\n\"\n@@ -901,10 +914,21 @@ static UniValue sendmany(const JSONRPCRequest& request)\n     int nChangePosRet = -1;\n     bilingual_str error;\n     CTransactionRef tx;\n-    bool fCreated = pwallet->CreateTransaction(vecSend, tx, nFeeRequired, nChangePosRet, error, coin_control);\n+    UniValue entry(UniValue::VOBJ);\n+    std::string feeReason;\n+    bool fCreated = pwallet->CreateTransaction(vecSend, tx, nFeeRequired, nChangePosRet, error, coin_control, feeReason);\n     if (!fCreated)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, error.original);\n     pwallet->CommitTransaction(tx, std::move(mapValue), {} /* orderForm */);\n+    \n+    bool verbose = request.params[8].isNull() ? false : request.params[8].get_bool();\n+\n+    if(verbose){\n+        entry.pushKV(\"hex\", tx->GetHash().GetHex());\n+        entry.pushKV(\"Fee Reason\", feeReason);  \n+        return entry;\n+    } \n+\n     return tx->GetHash().GetHex();\n }\n \n@@ -4198,8 +4222,8 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             \"lockunspent\",                      &lockunspent,                   {\"unlock\",\"transactions\"} },\n     { \"wallet\",             \"removeprunedfunds\",                &removeprunedfunds,             {\"txid\"} },\n     { \"wallet\",             \"rescanblockchain\",                 &rescanblockchain,              {\"start_height\", \"stop_height\"} },\n-    { \"wallet\",             \"sendmany\",                         &sendmany,                      {\"dummy\",\"amounts\",\"minconf\",\"comment\",\"subtractfeefrom\",\"replaceable\",\"conf_target\",\"estimate_mode\"} },\n-    { \"wallet\",             \"sendtoaddress\",                    &sendtoaddress,                 {\"address\",\"amount\",\"comment\",\"comment_to\",\"subtractfeefromamount\",\"replaceable\",\"conf_target\",\"estimate_mode\",\"avoid_reuse\"} },\n+    { \"wallet\",             \"sendmany\",                         &sendmany,                      {\"dummy\",\"amounts\",\"minconf\",\"comment\",\"subtractfeefrom\",\"replaceable\",\"conf_target\",\"estimate_mode\", \"verbose\"} },\n+    { \"wallet\",             \"sendtoaddress\",                    &sendtoaddress,                 {\"address\",\"amount\",\"comment\",\"comment_to\",\"subtractfeefromamount\",\"replaceable\",\"conf_target\",\"estimate_mode\",\"avoid_reuse\", \"verbose\"} },\n     { \"wallet\",             \"sethdseed\",                        &sethdseed,                     {\"newkeypool\",\"seed\"} },\n     { \"wallet\",             \"setlabel\",                         &setlabel,                      {\"address\",\"label\"} },\n     { \"wallet\",             \"settxfee\",                         &settxfee,                      {\"amount\"} },"
      },
      {
        "sha": "9293ee2b0495c286cdefc6fa6d137a425275f40c",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/446128ec094b64170f0272a2cd6d326aa4a47076/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/446128ec094b64170f0272a2cd6d326aa4a47076/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=446128ec094b64170f0272a2cd6d326aa4a47076",
        "patch": "@@ -513,11 +513,12 @@ class ListCoinsTestingSetup : public TestChain100Setup\n     {\n         CTransactionRef tx;\n         CAmount fee;\n+        std::string feeReason;\n         int changePos = -1;\n         bilingual_str error;\n         CCoinControl dummy;\n         {\n-            BOOST_CHECK(wallet->CreateTransaction({recipient}, tx, fee, changePos, error, dummy));\n+            BOOST_CHECK(wallet->CreateTransaction({recipient}, tx, fee, changePos, error, dummy, feeReason));\n         }\n         wallet->CommitTransaction(tx, {}, {});\n         CMutableTransaction blocktx;"
      },
      {
        "sha": "ff4c75b5b4aca4b1ea24be9a3d9b210c476ac815",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/446128ec094b64170f0272a2cd6d326aa4a47076/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/446128ec094b64170f0272a2cd6d326aa4a47076/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=446128ec094b64170f0272a2cd6d326aa4a47076",
        "patch": "@@ -2576,7 +2576,8 @@ bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nC\n     LOCK(cs_wallet);\n \n     CTransactionRef tx_new;\n-    if (!CreateTransaction(vecSend, tx_new, nFeeRet, nChangePosInOut, error, coinControl, false)) {\n+    std::string feeReason;\n+    if (!CreateTransaction(vecSend, tx_new, nFeeRet, nChangePosInOut, error, coinControl, feeReason, false)) {\n         return false;\n     }\n \n@@ -2692,7 +2693,7 @@ OutputType CWallet::TransactionChangeType(const Optional<OutputType>& change_typ\n     return m_default_address_type;\n }\n \n-bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, const CCoinControl& coin_control, bool sign)\n+bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, const CCoinControl& coin_control, std::string& feeReason, bool sign)\n {\n     CAmount nValue = 0;\n     const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n@@ -3035,6 +3036,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n     // Before we return success, we assume any change key will be used to prevent\n     // accidental re-use.\n     reservedest.KeepDestination();\n+    feeReason = StringForFeeReason(feeCalc.reason);\n \n     WalletLogPrintf(\"Fee Calculation: Fee:%d Bytes:%u Needed:%d Tgt:%d (requested %d) Reason:\\\"%s\\\" Decay %.5f: Estimation: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\",\n               nFeeRet, nBytes, nFeeNeeded, feeCalc.returnedTarget, feeCalc.desiredTarget, StringForFeeReason(feeCalc.reason), feeCalc.est.decay,"
      },
      {
        "sha": "be48005563a7be146a81ff0085cb876859f01f16",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/446128ec094b64170f0272a2cd6d326aa4a47076/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/446128ec094b64170f0272a2cd6d326aa4a47076/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=446128ec094b64170f0272a2cd6d326aa4a47076",
        "patch": "@@ -969,7 +969,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      * selected by SelectCoins(); Also create the change output, when needed\n      * @note passing nChangePosInOut as -1 will result in setting a random position\n      */\n-    bool CreateTransaction(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, const CCoinControl& coin_control, bool sign = true);\n+    bool CreateTransaction(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, const CCoinControl& coin_control, std::string& feeReason, bool sign = true);\n     /**\n      * Submit the transaction to the node's mempool and then relay to peers.\n      * Should be called after CreateTransaction unless you want to abort"
      }
    ]
  },
  {
    "sha": "7d9e5a135a27e135e433cd9e9b528dd5a48c2e57",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZDllNWExMzVhMjdlMTM1ZTQzM2NkOWU5YjUyOGRkNWE0OGMyZTU3",
    "commit": {
      "author": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-06T07:37:12Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:24Z"
      },
      "message": "[test] test send* wallet rpcs with verbose=True",
      "tree": {
        "sha": "45ca2e70ba6d90fda8595c313114434f8907cd99",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/45ca2e70ba6d90fda8595c313114434f8907cd99"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7d9e5a135a27e135e433cd9e9b528dd5a48c2e57",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d9e5a135a27e135e433cd9e9b528dd5a48c2e57",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7d9e5a135a27e135e433cd9e9b528dd5a48c2e57",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d9e5a135a27e135e433cd9e9b528dd5a48c2e57/comments",
    "author": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "446128ec094b64170f0272a2cd6d326aa4a47076",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/446128ec094b64170f0272a2cd6d326aa4a47076",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/446128ec094b64170f0272a2cd6d326aa4a47076"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 9,
      "deletions": 0
    },
    "files": [
      {
        "sha": "9554cd9538c4c7a9f2cfdb83615ce57bead4d87e",
        "filename": "test/functional/wallet_basic.py",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9e5a135a27e135e433cd9e9b528dd5a48c2e57/test/functional/wallet_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9e5a135a27e135e433cd9e9b528dd5a48c2e57/test/functional/wallet_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_basic.py?ref=7d9e5a135a27e135e433cd9e9b528dd5a48c2e57",
        "patch": "@@ -650,6 +650,15 @@ def run_test(self):\n         assert_array_result(tx[\"details\"], {\"category\": \"receive\"}, expected_receive_vout)\n         assert_equal(tx[verbose_field], self.nodes[0].decoderawtransaction(tx[\"hex\"]))\n \n+        self.log.info(\"Testing Fee Reason\")\n+        #testing send_rpc_verbose sendtoaddress\n+        address = self.nodes[0].getnewaddress(\"test\") \n+        txid_feeReason_one = self.nodes[2].sendtoaddress(address = address, amount = 10, verbose = True)\n+        assert_equal(str(txid_feeReason_one[\"Fee Reason\"]), \"Fallback fee\")\n+\n+        #testing send_rpc_verbose sendtoaddress\n+        txid_feeReason_two = self.nodes[2].sendmany(dummy = '', amounts = {address: 10}, verbose = True) \n+        assert_equal(str(txid_feeReason_two[\"Fee Reason\"]), \"Fallback fee\")\n \n if __name__ == '__main__':\n     WalletTest().main()"
      }
    ]
  },
  {
    "sha": "5e951109153aae34041c3e3f0953e0d85db71a52",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZTk1MTEwOTE1M2FhZTM0MDQxYzNlM2YwOTUzZTBkODVkYjcxYTUy",
    "commit": {
      "author": {
        "name": "Saahil Shangle",
        "email": "saahilshangle@gmail.com",
        "date": "2020-06-08T00:20:11Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:24Z"
      },
      "message": "Attempted test where one node sends block to another",
      "tree": {
        "sha": "af91fed8e57722f3cdbf2f8feed01062d2d12012",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/af91fed8e57722f3cdbf2f8feed01062d2d12012"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5e951109153aae34041c3e3f0953e0d85db71a52",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e951109153aae34041c3e3f0953e0d85db71a52",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5e951109153aae34041c3e3f0953e0d85db71a52",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e951109153aae34041c3e3f0953e0d85db71a52/comments",
    "author": {
      "login": "saahilshangle",
      "id": 10226886,
      "node_id": "MDQ6VXNlcjEwMjI2ODg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10226886?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saahilshangle",
      "html_url": "https://github.com/saahilshangle",
      "followers_url": "https://api.github.com/users/saahilshangle/followers",
      "following_url": "https://api.github.com/users/saahilshangle/following{/other_user}",
      "gists_url": "https://api.github.com/users/saahilshangle/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saahilshangle/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saahilshangle/subscriptions",
      "organizations_url": "https://api.github.com/users/saahilshangle/orgs",
      "repos_url": "https://api.github.com/users/saahilshangle/repos",
      "events_url": "https://api.github.com/users/saahilshangle/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saahilshangle/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7d9e5a135a27e135e433cd9e9b528dd5a48c2e57",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d9e5a135a27e135e433cd9e9b528dd5a48c2e57",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7d9e5a135a27e135e433cd9e9b528dd5a48c2e57"
      }
    ],
    "stats": {
      "total": 224,
      "additions": 224,
      "deletions": 0
    },
    "files": [
      {
        "sha": "87d7100d263b50c88ea90451a601e813aebc0939",
        "filename": "test/functional/p2p_saahil.py",
        "status": "added",
        "additions": 224,
        "deletions": 0,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e951109153aae34041c3e3f0953e0d85db71a52/test/functional/p2p_saahil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e951109153aae34041c3e3f0953e0d85db71a52/test/functional/p2p_saahil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_saahil.py?ref=5e951109153aae34041c3e3f0953e0d85db71a52",
        "patch": "@@ -0,0 +1,224 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"An example functional test\n+\n+The module-level docstring should include a high-level description of\n+what the test is doing. It's the first thing people see when they open\n+the file and should give the reader information about *what* the test\n+is testing and *how* it's being tested\n+\"\"\"\n+# Imports should be in PEP8 ordering (std library first, then third party\n+# libraries then local imports).\n+from collections import defaultdict\n+\n+# Avoid wildcard * imports\n+from test_framework.blocktools import (create_block, create_coinbase)\n+from test_framework.messages import CInv, MSG_BLOCK\n+from test_framework.mininode import (\n+    P2PInterface,\n+    mininode_lock,\n+    msg_block,\n+    msg_getdata,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    connect_nodes,\n+    wait_until,\n+)\n+\n+# P2PInterface is a class containing callbacks to be executed when a P2P\n+# message is received from the node-under-test. Subclass P2PInterface and\n+# override the on_*() methods if you need custom behaviour.\n+class BaseNode(P2PInterface):\n+    def __init__(self):\n+        \"\"\"Initialize the P2PInterface\n+\n+        Used to initialize custom properties for the Node that aren't\n+        included by default in the base class. Be aware that the P2PInterface\n+        base class already stores a counter for each P2P message type and the\n+        last received message of each type, which should be sufficient for the\n+        needs of most tests.\n+\n+        Call super().__init__() first for standard initialization and then\n+        initialize custom properties.\"\"\"\n+        super().__init__()\n+        # Stores a dictionary of all blocks received\n+        self.block_receive_map = defaultdict(int)\n+\n+    def on_block(self, message):\n+        \"\"\"Override the standard on_block callback\n+\n+        Store the hash of a received block in the dictionary.\"\"\"\n+        message.block.calc_sha256()\n+        self.block_receive_map[message.block.sha256] += 1\n+\n+    def on_inv(self, message):\n+        \"\"\"Override the standard on_inv callback\"\"\"\n+        pass\n+\n+def custom_function():\n+    \"\"\"Do some custom behaviour\n+\n+    If this function is more generally useful for other tests, consider\n+    moving it to a module in test_framework.\"\"\"\n+    # self.log.info(\"running custom_function\")  # Oops! Can't run self.log outside the BitcoinTestFramework\n+    pass\n+\n+\n+class ExampleTest(BitcoinTestFramework):\n+    # Each functional test is a subclass of the BitcoinTestFramework class.\n+\n+    # Override the set_test_params(), skip_test_if_missing_module(), add_options(), setup_chain(), setup_network()\n+    # and setup_nodes() methods to customize the test setup as required.\n+\n+    def set_test_params(self):\n+        \"\"\"Override test parameters for your individual test.\n+\n+        This method must be overridden and num_nodes must be explicitly set.\"\"\"\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+        # Use self.extra_args to change command-line arguments for the nodes\n+        self.extra_args = [[], [\"-logips\"], []]\n+\n+        # self.log.info(\"I've finished set_test_params\")  # Oops! Can't run self.log before run_test()\n+\n+    # Use skip_test_if_missing_module() to skip the test if your test requires certain modules to be present.\n+    # This test uses generate which requires wallet to be compiled\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    # Use add_options() to add specific command-line options for your test.\n+    # In practice this is not used very much, since the tests are mostly written\n+    # to be run in automated environments without command-line options.\n+    # def add_options()\n+    #     pass\n+\n+    # Use setup_chain() to customize the node data directories. In practice\n+    # this is not used very much since the default behaviour is almost always\n+    # fine\n+    # def setup_chain():\n+    #     pass\n+\n+    def setup_network(self):\n+        \"\"\"Setup the test network topology\n+\n+        Often you won't need to override this, since the standard network topology\n+        (linear: node0 <-> node1 <-> node2 <-> ...) is fine for most tests.\n+\n+        If you do override this method, remember to start the nodes, assign\n+        them to self.nodes, connect them and then sync.\"\"\"\n+\n+        self.setup_nodes()\n+\n+        # In this test, we're not connecting node2 to node0 or node1. Calls to\n+        # sync_all() should not include node2, since we're not expecting it to\n+        # sync.\n+        #connect_nodes(self.nodes[0], 1)\n+        #self.sync_all(self.nodes[0:2])\n+\n+    # Use setup_nodes() to customize the node start behaviour (for example if\n+    # you don't want to start all nodes at the start of the test).\n+    # def setup_nodes():\n+    #     pass\n+\n+    def custom_method(self):\n+        \"\"\"Do some custom behaviour for this test\n+\n+        Define it in a method here because you're going to use it repeatedly.\n+        If you think it's useful in general, consider moving it to the base\n+        BitcoinTestFramework class so other tests can use it.\"\"\"\n+\n+        self.log.info(\"Running custom_method\")\n+\n+    def run_test(self):\n+        \"\"\"Main test logic\"\"\"\n+\n+        # Create P2P connections will wait for a verack to make sure the connection is fully up\n+        self.nodes[0].add_p2p_connection(BaseNode())\n+\n+        # Generating a block on one of the nodes will get us out of IBD\n+        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n+        self.log.info(\"Number of blocks in node 0: \" + str(self.nodes[0].getblockcount()))\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+        \n+        self.log.info(\"Now sending block from one to the other\")\n+        connect_nodes(self.nodes[0], 1)\n+        self.sync_all(self.nodes[0:2])\n+\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+\n+        # # Notice above how we called an RPC by calling a method with the same\n+        # # name on the node object. Notice also how we used a keyword argument\n+        # # to specify a named RPC argument. Neither of those are defined on the\n+        # # node object. Instead there's some __getattr__() magic going on under\n+        # # the covers to dispatch unrecognised attribute calls to the RPC\n+        # # interface.\n+\n+        # # Logs are nice. Do plenty of them. They can be used in place of comments for\n+        # # breaking the test into sub-sections.\n+        # self.log.info(\"Starting test!\")\n+\n+        # self.log.info(\"Calling a custom function\")\n+        # custom_function()\n+\n+        # self.log.info(\"Calling a custom method\")\n+        # self.custom_method()\n+\n+        # self.log.info(\"Create some blocks\")\n+        # self.tip = int(self.nodes[0].getbestblockhash(), 16)\n+        # self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n+\n+        # height = self.nodes[0].getblockcount()\n+\n+        # for i in range(10):\n+        #     # Use the mininode and blocktools functionality to manually build a block\n+        #     # Calling the generate() rpc is easier, but this allows us to exactly\n+        #     # control the blocks and transactions.\n+        #     block = create_block(self.tip, create_coinbase(height+1), self.block_time)\n+        #     block.solve()\n+        #     block_message = msg_block(block)\n+        #     # Send message is used to send a P2P message to the node over our P2PInterface\n+        #     self.nodes[0].p2p.send_message(block_message)\n+        #     self.tip = block.sha256\n+        #     blocks.append(self.tip)\n+        #     self.block_time += 1\n+        #     height += 1\n+\n+        # self.log.info(\"Wait for node1 to reach current tip (height 11) using RPC\")\n+        # self.nodes[1].waitforblockheight(11)\n+\n+        # self.log.info(\"Connect node2 and node1\")\n+        # connect_nodes(self.nodes[1], 2)\n+\n+        # self.log.info(\"Wait for node2 to receive all the blocks from node1\")\n+        # self.sync_all()\n+\n+        # self.log.info(\"Add P2P connection to node2\")\n+        # self.nodes[0].disconnect_p2ps()\n+\n+        # self.nodes[2].add_p2p_connection(BaseNode())\n+\n+        # self.log.info(\"Test that node2 propagates all the blocks to us\")\n+\n+        # getdata_request = msg_getdata()\n+        # for block in blocks:\n+        #     getdata_request.inv.append(CInv(MSG_BLOCK, block))\n+        # self.nodes[2].p2p.send_message(getdata_request)\n+\n+        # # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n+        # # P2PInterface objects.\n+        # wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n+\n+        # self.log.info(\"Check that each block was received only once\")\n+        # # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving\n+        # # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking\n+        # # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n+        # with mininode_lock:\n+        #     for block in self.nodes[2].p2p.block_receive_map.values():\n+        #         assert_equal(block, 1)\n+\n+if __name__ == '__main__':\n+    ExampleTest().main()"
      }
    ]
  },
  {
    "sha": "a9389535fd9ff683f80e75bcf994e0002250d50f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphOTM4OTUzNWZkOWZmNjgzZjgwZTc1YmNmOTk0ZTAwMDIyNTBkNTBm",
    "commit": {
      "author": {
        "name": "Fabian Jahr",
        "email": "fjahr@protonmail.com",
        "date": "2020-06-02T21:41:04Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:24Z"
      },
      "message": "refactor: Extract GetBogoSize function",
      "tree": {
        "sha": "45487b010a8d2c9ee72241d10f3244f4af24c3c4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/45487b010a8d2c9ee72241d10f3244f4af24c3c4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a9389535fd9ff683f80e75bcf994e0002250d50f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a9389535fd9ff683f80e75bcf994e0002250d50f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a9389535fd9ff683f80e75bcf994e0002250d50f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a9389535fd9ff683f80e75bcf994e0002250d50f/comments",
    "author": {
      "login": "fjahr",
      "id": 1322187,
      "node_id": "MDQ6VXNlcjEzMjIxODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjahr",
      "html_url": "https://github.com/fjahr",
      "followers_url": "https://api.github.com/users/fjahr/followers",
      "following_url": "https://api.github.com/users/fjahr/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjahr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
      "organizations_url": "https://api.github.com/users/fjahr/orgs",
      "repos_url": "https://api.github.com/users/fjahr/repos",
      "events_url": "https://api.github.com/users/fjahr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjahr/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5e951109153aae34041c3e3f0953e0d85db71a52",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e951109153aae34041c3e3f0953e0d85db71a52",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5e951109153aae34041c3e3f0953e0d85db71a52"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "315861dd03c80e2ac4dcd6823043a52e6474f2e0",
        "filename": "src/node/coinstats.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9389535fd9ff683f80e75bcf994e0002250d50f/src/node/coinstats.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9389535fd9ff683f80e75bcf994e0002250d50f/src/node/coinstats.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coinstats.cpp?ref=a9389535fd9ff683f80e75bcf994e0002250d50f",
        "patch": "@@ -24,7 +24,7 @@ static uint64_t GetBogoSize(const CScript& scriptPubKey)\n            scriptPubKey.size() /* scriptPubKey */;\n }\n \n-static void ApplyStats(CCoinsStats& stats, CHashWriter& ss, const uint256& hash, const std::map<uint32_t, Coin>& outputs)\n+static void ApplyStats(CCoinsStats &stats, CHashWriter& ss, const uint256& hash, const std::map<uint32_t, Coin>& outputs)\n {\n     assert(!outputs.empty());\n     ss << hash;"
      }
    ]
  },
  {
    "sha": "8eb28f0c2f5b1aa8b5be6b6cbc9f533d0501e14c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZWIyOGYwYzJmNWIxYWE4YjViZTZiNmNiYzlmNTMzZDA1MDFlMTRj",
    "commit": {
      "author": {
        "name": "Fabian Jahr",
        "email": "fjahr@protonmail.com",
        "date": "2020-06-02T21:52:34Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:24Z"
      },
      "message": "rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)",
      "tree": {
        "sha": "aa443680952a1d32e3da4345c9f83228570ac6b0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/aa443680952a1d32e3da4345c9f83228570ac6b0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8eb28f0c2f5b1aa8b5be6b6cbc9f533d0501e14c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8eb28f0c2f5b1aa8b5be6b6cbc9f533d0501e14c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8eb28f0c2f5b1aa8b5be6b6cbc9f533d0501e14c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8eb28f0c2f5b1aa8b5be6b6cbc9f533d0501e14c/comments",
    "author": {
      "login": "fjahr",
      "id": 1322187,
      "node_id": "MDQ6VXNlcjEzMjIxODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjahr",
      "html_url": "https://github.com/fjahr",
      "followers_url": "https://api.github.com/users/fjahr/followers",
      "following_url": "https://api.github.com/users/fjahr/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjahr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
      "organizations_url": "https://api.github.com/users/fjahr/orgs",
      "repos_url": "https://api.github.com/users/fjahr/repos",
      "events_url": "https://api.github.com/users/fjahr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjahr/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a9389535fd9ff683f80e75bcf994e0002250d50f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a9389535fd9ff683f80e75bcf994e0002250d50f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a9389535fd9ff683f80e75bcf994e0002250d50f"
      }
    ],
    "stats": {
      "total": 21,
      "additions": 15,
      "deletions": 6
    },
    "files": [
      {
        "sha": "21632263dc6df963de2a898385bb28ae6bf0c146",
        "filename": "src/node/coinstats.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8eb28f0c2f5b1aa8b5be6b6cbc9f533d0501e14c/src/node/coinstats.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8eb28f0c2f5b1aa8b5be6b6cbc9f533d0501e14c/src/node/coinstats.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coinstats.cpp?ref=8eb28f0c2f5b1aa8b5be6b6cbc9f533d0501e14c",
        "patch": "@@ -24,7 +24,7 @@ static uint64_t GetBogoSize(const CScript& scriptPubKey)\n            scriptPubKey.size() /* scriptPubKey */;\n }\n \n-static void ApplyStats(CCoinsStats &stats, CHashWriter& ss, const uint256& hash, const std::map<uint32_t, Coin>& outputs)\n+static void ApplyStats(CCoinsStats& stats, CHashWriter& ss, const uint256& hash, const std::map<uint32_t, Coin>& outputs)\n {\n     assert(!outputs.empty());\n     ss << hash;\n@@ -104,9 +104,6 @@ bool GetUTXOStats(CCoinsView* view, CCoinsStats& stats, CoinStatsHashType hash_t\n         CHashWriter ss(SER_GETHASH, PROTOCOL_VERSION);\n         return GetUTXOStats(view, stats, ss, interruption_point);\n     }\n-    case(CoinStatsHashType::NONE): {\n-        return GetUTXOStats(view, stats, nullptr, interruption_point);\n-    }\n     } // no default case, so the compiler can warn about missing cases\n     assert(false);\n }\n@@ -116,10 +113,8 @@ static void PrepareHash(CHashWriter& ss, CCoinsStats& stats)\n {\n     ss << stats.hashBlock;\n }\n-static void PrepareHash(std::nullptr_t, CCoinsStats& stats) {}\n \n static void FinalizeHash(CHashWriter& ss, CCoinsStats& stats)\n {\n     stats.hashSerialized = ss.GetHash();\n }\n-static void FinalizeHash(std::nullptr_t, CCoinsStats& stats) {}"
      },
      {
        "sha": "42bae90ca203e2e9e49a1d214f13422a7a20ff10",
        "filename": "src/node/coinstats.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8eb28f0c2f5b1aa8b5be6b6cbc9f533d0501e14c/src/node/coinstats.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8eb28f0c2f5b1aa8b5be6b6cbc9f533d0501e14c/src/node/coinstats.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coinstats.h?ref=8eb28f0c2f5b1aa8b5be6b6cbc9f533d0501e14c",
        "patch": "@@ -16,7 +16,10 @@ class CCoinsView;\n \n enum class CoinStatsHashType {\n     HASH_SERIALIZED,\n+<<<<<<< HEAD\n     NONE,\n+=======\n+>>>>>>> rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)\n };\n \n struct CCoinsStats"
      },
      {
        "sha": "1415e4c6fd439e4c972c2b46e87768ef3b9b709e",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8eb28f0c2f5b1aa8b5be6b6cbc9f533d0501e14c/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8eb28f0c2f5b1aa8b5be6b6cbc9f533d0501e14c/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=8eb28f0c2f5b1aa8b5be6b6cbc9f533d0501e14c",
        "patch": "@@ -976,7 +976,11 @@ static UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n                 \"\\nReturns statistics about the unspent transaction output set.\\n\"\n                 \"Note this call may take some time.\\n\",\n                 {\n+<<<<<<< HEAD\n                     {\"hash_type\", RPCArg::Type::STR, /* default */ \"hash_serialized_2\", \"Which UTXO set hash should be calculated. Options: 'hash_serialized_2' (the legacy algorithm), 'none'.\"},\n+=======\n+                    {\"hash_type\", RPCArg::Type::STR, /* default */ \"hash_serialized_2\", \"Which UTXO set hash should be calculated. Options: 'hash_serialized_2' (the legacy algorithm).\"},\n+>>>>>>> rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)\n                 },\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"\",\n@@ -2323,7 +2327,11 @@ UniValue dumptxoutset(const JSONRPCRequest& request)\n \n         ::ChainstateActive().ForceFlushStateToDisk();\n \n+<<<<<<< HEAD\n         if (!GetUTXOStats(&::ChainstateActive().CoinsDB(), stats, CoinStatsHashType::NONE, RpcInterruptionPoint)) {\n+=======\n+        if (!GetUTXOStats(&::ChainstateActive().CoinsDB(), stats, CoinStatsHashType::HASH_SERIALIZED, RpcInterruptionPoint)) {\n+>>>>>>> rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Unable to read UTXO set\");\n         }\n "
      },
      {
        "sha": "7ceadd0696a360d6c1bbd2ff3e4647c1db917b96",
        "filename": "src/rpc/util.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8eb28f0c2f5b1aa8b5be6b6cbc9f533d0501e14c/src/rpc/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8eb28f0c2f5b1aa8b5be6b6cbc9f533d0501e14c/src/rpc/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.cpp?ref=8eb28f0c2f5b1aa8b5be6b6cbc9f533d0501e14c",
        "patch": "@@ -122,8 +122,11 @@ CoinStatsHashType ParseHashType(const UniValue& param, const CoinStatsHashType d\n \n         if (hash_type_input == \"hash_serialized_2\") {\n             return CoinStatsHashType::HASH_SERIALIZED;\n+<<<<<<< HEAD\n         } else if (hash_type_input == \"none\") {\n             return CoinStatsHashType::NONE;\n+=======\n+>>>>>>> rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)\n         } else {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"%d is not a valid hash_type\", hash_type_input));\n         }"
      }
    ]
  },
  {
    "sha": "5b1c1837f1fbd30283ef7b86ceb50507db8dc056",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1YjFjMTgzN2YxZmJkMzAyODNlZjdiODZjZWI1MDUwN2RiOGRjMDU2",
    "commit": {
      "author": {
        "name": "Fabian Jahr",
        "email": "fjahr@protonmail.com",
        "date": "2020-06-02T21:56:28Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:25Z"
      },
      "message": "rpc: Add hash_type NONE to gettxoutsetinfo",
      "tree": {
        "sha": "f0c80a7015d8491b9ec51879aea6b8c86e0f0d1b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f0c80a7015d8491b9ec51879aea6b8c86e0f0d1b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5b1c1837f1fbd30283ef7b86ceb50507db8dc056",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b1c1837f1fbd30283ef7b86ceb50507db8dc056",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5b1c1837f1fbd30283ef7b86ceb50507db8dc056",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b1c1837f1fbd30283ef7b86ceb50507db8dc056/comments",
    "author": {
      "login": "fjahr",
      "id": 1322187,
      "node_id": "MDQ6VXNlcjEzMjIxODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjahr",
      "html_url": "https://github.com/fjahr",
      "followers_url": "https://api.github.com/users/fjahr/followers",
      "following_url": "https://api.github.com/users/fjahr/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjahr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
      "organizations_url": "https://api.github.com/users/fjahr/orgs",
      "repos_url": "https://api.github.com/users/fjahr/repos",
      "events_url": "https://api.github.com/users/fjahr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjahr/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8eb28f0c2f5b1aa8b5be6b6cbc9f533d0501e14c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8eb28f0c2f5b1aa8b5be6b6cbc9f533d0501e14c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8eb28f0c2f5b1aa8b5be6b6cbc9f533d0501e14c"
      }
    ],
    "stats": {
      "total": 21,
      "additions": 18,
      "deletions": 3
    },
    "files": [
      {
        "sha": "fb46ea173148ba39d2ca966502c070ad2dba5783",
        "filename": "src/node/coinstats.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b1c1837f1fbd30283ef7b86ceb50507db8dc056/src/node/coinstats.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b1c1837f1fbd30283ef7b86ceb50507db8dc056/src/node/coinstats.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coinstats.cpp?ref=5b1c1837f1fbd30283ef7b86ceb50507db8dc056",
        "patch": "@@ -104,6 +104,9 @@ bool GetUTXOStats(CCoinsView* view, CCoinsStats& stats, CoinStatsHashType hash_t\n         CHashWriter ss(SER_GETHASH, PROTOCOL_VERSION);\n         return GetUTXOStats(view, stats, ss, interruption_point);\n     }\n+    case(CoinStatsHashType::NONE): {\n+        return GetUTXOStats(view, stats, nullptr, interruption_point);\n+    }\n     } // no default case, so the compiler can warn about missing cases\n     assert(false);\n }\n@@ -113,8 +116,10 @@ static void PrepareHash(CHashWriter& ss, CCoinsStats& stats)\n {\n     ss << stats.hashBlock;\n }\n+static void PrepareHash(std::nullptr_t, CCoinsStats& stats) {}\n \n static void FinalizeHash(CHashWriter& ss, CCoinsStats& stats)\n {\n     stats.hashSerialized = ss.GetHash();\n }\n+static void FinalizeHash(std::nullptr_t, CCoinsStats& stats) {}"
      },
      {
        "sha": "2a7441c10e7bd87aaf0ce648839be719c8a89612",
        "filename": "src/node/coinstats.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b1c1837f1fbd30283ef7b86ceb50507db8dc056/src/node/coinstats.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b1c1837f1fbd30283ef7b86ceb50507db8dc056/src/node/coinstats.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coinstats.h?ref=5b1c1837f1fbd30283ef7b86ceb50507db8dc056",
        "patch": "@@ -16,10 +16,7 @@ class CCoinsView;\n \n enum class CoinStatsHashType {\n     HASH_SERIALIZED,\n-<<<<<<< HEAD\n     NONE,\n-=======\n->>>>>>> rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)\n };\n \n struct CCoinsStats"
      },
      {
        "sha": "7741e364efd275c88e48c20b1fa1543ff0656006",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b1c1837f1fbd30283ef7b86ceb50507db8dc056/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b1c1837f1fbd30283ef7b86ceb50507db8dc056/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=5b1c1837f1fbd30283ef7b86ceb50507db8dc056",
        "patch": "@@ -976,11 +976,15 @@ static UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n                 \"\\nReturns statistics about the unspent transaction output set.\\n\"\n                 \"Note this call may take some time.\\n\",\n                 {\n+<<<<<<< HEAD\n <<<<<<< HEAD\n                     {\"hash_type\", RPCArg::Type::STR, /* default */ \"hash_serialized_2\", \"Which UTXO set hash should be calculated. Options: 'hash_serialized_2' (the legacy algorithm), 'none'.\"},\n =======\n                     {\"hash_type\", RPCArg::Type::STR, /* default */ \"hash_serialized_2\", \"Which UTXO set hash should be calculated. Options: 'hash_serialized_2' (the legacy algorithm).\"},\n >>>>>>> rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)\n+=======\n+                    {\"hash_type\", RPCArg::Type::STR, /* default */ \"hash_serialized_2\", \"Which UTXO set hash should be calculated. Options: 'hash_serialized_2' (the legacy algorithm), 'none'.\"},\n+>>>>>>> rpc: Add hash_type NONE to gettxoutsetinfo\n                 },\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"\",\n@@ -2327,11 +2331,15 @@ UniValue dumptxoutset(const JSONRPCRequest& request)\n \n         ::ChainstateActive().ForceFlushStateToDisk();\n \n+<<<<<<< HEAD\n <<<<<<< HEAD\n         if (!GetUTXOStats(&::ChainstateActive().CoinsDB(), stats, CoinStatsHashType::NONE, RpcInterruptionPoint)) {\n =======\n         if (!GetUTXOStats(&::ChainstateActive().CoinsDB(), stats, CoinStatsHashType::HASH_SERIALIZED, RpcInterruptionPoint)) {\n >>>>>>> rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)\n+=======\n+        if (!GetUTXOStats(&::ChainstateActive().CoinsDB(), stats, CoinStatsHashType::NONE, RpcInterruptionPoint)) {\n+>>>>>>> rpc: Add hash_type NONE to gettxoutsetinfo\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Unable to read UTXO set\");\n         }\n "
      },
      {
        "sha": "3c84b966d516779be21e090ac2df5e218621279b",
        "filename": "src/rpc/util.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b1c1837f1fbd30283ef7b86ceb50507db8dc056/src/rpc/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b1c1837f1fbd30283ef7b86ceb50507db8dc056/src/rpc/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.cpp?ref=5b1c1837f1fbd30283ef7b86ceb50507db8dc056",
        "patch": "@@ -122,11 +122,16 @@ CoinStatsHashType ParseHashType(const UniValue& param, const CoinStatsHashType d\n \n         if (hash_type_input == \"hash_serialized_2\") {\n             return CoinStatsHashType::HASH_SERIALIZED;\n+<<<<<<< HEAD\n <<<<<<< HEAD\n         } else if (hash_type_input == \"none\") {\n             return CoinStatsHashType::NONE;\n =======\n >>>>>>> rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)\n+=======\n+        } else if (hash_type_input == \"none\") {\n+            return CoinStatsHashType::NONE;\n+>>>>>>> rpc: Add hash_type NONE to gettxoutsetinfo\n         } else {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"%d is not a valid hash_type\", hash_type_input));\n         }"
      }
    ]
  },
  {
    "sha": "a8251921c09fbbd17fc5079d523f805d956b12a9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphODI1MTkyMWMwOWZiYmQxN2ZjNTA3OWQ1MjNmODA1ZDk1NmIxMmE5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-09T01:46:53Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:25Z"
      },
      "message": "Replace automatic bans with discouragement filter\n\nThis patch improves performance and resource usage around IP\naddresses that are banned for misbehavior. They're already not\nactually banned, as connections from them are still allowed,\nbut they are preferred for eviction if the inbound connection\nslots are full.\n\nStop treating these like manually banned IP ranges, and instead\njust keep them in a rolling Bloom filter of misbehaving nodes,\nwhich isn't persisted to disk or exposed through the ban\nframework. The effect remains the same: preferred for eviction,\navoided for outgoing connections, and not relayed to other peers.\n\nAlso change the name of this mechanism to better reflect reality;\nthey're not banned, just discouraged.\n\nContains release notes and several interface improvements by\nJohn Newbery.",
      "tree": {
        "sha": "974ef4361748de14ea506b978a460e884f341e8f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/974ef4361748de14ea506b978a460e884f341e8f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a8251921c09fbbd17fc5079d523f805d956b12a9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a8251921c09fbbd17fc5079d523f805d956b12a9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a8251921c09fbbd17fc5079d523f805d956b12a9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a8251921c09fbbd17fc5079d523f805d956b12a9/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5b1c1837f1fbd30283ef7b86ceb50507db8dc056",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b1c1837f1fbd30283ef7b86ceb50507db8dc056",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5b1c1837f1fbd30283ef7b86ceb50507db8dc056"
      }
    ],
    "stats": {
      "total": 54,
      "additions": 51,
      "deletions": 3
    },
    "files": [
      {
        "sha": "d4009105f6bae0f34241dae63c3564bd7ac3dbbe",
        "filename": "src/banman.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 2,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8251921c09fbbd17fc5079d523f805d956b12a9/src/banman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8251921c09fbbd17fc5079d523f805d956b12a9/src/banman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/banman.cpp?ref=a8251921c09fbbd17fc5079d523f805d956b12a9",
        "patch": "@@ -70,14 +70,28 @@ void BanMan::ClearBanned()\n \n bool BanMan::IsDiscouraged(const CNetAddr& net_addr)\n {\n+    // Returns the most severe level of banning that applies to this address.\n+    // 0 - Not banned\n+    // 1 - Automatic misbehavior ban\n+    // 2 - Any other ban\n+    auto current_time = GetTime();\n     LOCK(m_cs_banned);\n-    return m_discouraged.contains(net_addr.GetAddrBytes());\n+    for (const auto& it : m_banned) {\n+        CSubNet sub_net = it.first;\n+        CBanEntry ban_entry = it.second;\n+\n+        if (current_time < ban_entry.nBanUntil && sub_net.Match(net_addr)) {\n+            return 2;\n+        }\n+    }\n+    return m_discouraged.contains(net_addr.GetAddrBytes()) ? 1 : 0;\n }\n \n bool BanMan::IsBanned(const CNetAddr& net_addr)\n {\n     auto current_time = GetTime();\n     LOCK(m_cs_banned);\n+    if (m_discouraged.contains(net_addr.GetAddrBytes())) return true;\n     for (const auto& it : m_banned) {\n         CSubNet sub_net = it.first;\n         CBanEntry ban_entry = it.second;\n@@ -105,6 +119,11 @@ bool BanMan::IsBanned(const CSubNet& sub_net)\n \n void BanMan::Ban(const CNetAddr& net_addr, int64_t ban_time_offset, bool since_unix_epoch)\n {\n+    if (ban_reason == BanReasonNodeMisbehaving) {\n+        LOCK(m_cs_banned);\n+        m_discouraged.insert(net_addr.GetAddrBytes());\n+        return;\n+    }\n     CSubNet sub_net(net_addr);\n     Ban(sub_net, ban_time_offset, since_unix_epoch);\n }\n@@ -117,7 +136,8 @@ void BanMan::Discourage(const CNetAddr& net_addr)\n \n void BanMan::Ban(const CSubNet& sub_net, int64_t ban_time_offset, bool since_unix_epoch)\n {\n-    CBanEntry ban_entry(GetTime());\n+    assert(ban_reason == BanReasonManuallyAdded);\n+    CBanEntry ban_entry(GetTime(), ban_reason);\n \n     int64_t normalized_ban_time_offset = ban_time_offset;\n     bool normalized_since_unix_epoch = since_unix_epoch;"
      },
      {
        "sha": "60da9ae823c01f658bef7be49156650f53faace7",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8251921c09fbbd17fc5079d523f805d956b12a9/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8251921c09fbbd17fc5079d523f805d956b12a9/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=a8251921c09fbbd17fc5079d523f805d956b12a9",
        "patch": "@@ -1011,18 +1011,29 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     // on all platforms.  Set it again here just to be sure.\n     SetSocketNoDelay(hSocket);\n \n+<<<<<<< HEAD\n     // Don't accept connections from banned peers.\n     bool banned = m_banman->IsBanned(addr);\n     if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && banned)\n+=======\n+    int bannedlevel = m_banman ? m_banman->IsBannedLevel(addr) : 0;\n+\n+    // Don't accept connections from banned peers.\n+    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && bannedlevel == 2)\n+>>>>>>> Replace automatic bans with discouragement filter\n     {\n         LogPrint(BCLog::NET, \"connection from %s dropped (banned)\\n\", addr.ToString());\n         CloseSocket(hSocket);\n         return;\n     }\n \n     // Only accept connections from discouraged peers if our inbound slots aren't (almost) full.\n+<<<<<<< HEAD\n     bool discouraged = m_banman->IsDiscouraged(addr);\n     if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && nInbound + 1 >= nMaxInbound && discouraged)\n+=======\n+    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && nInbound + 1 >= nMaxInbound && bannedlevel >= 1)\n+>>>>>>> Replace automatic bans with discouragement filter\n     {\n         LogPrint(BCLog::NET, \"connection from %s dropped (discouraged)\\n\", addr.ToString());\n         CloseSocket(hSocket);"
      },
      {
        "sha": "18cb84792fae154a357e8e027e6ed683235c847c",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8251921c09fbbd17fc5079d523f805d956b12a9/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8251921c09fbbd17fc5079d523f805d956b12a9/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=a8251921c09fbbd17fc5079d523f805d956b12a9",
        "patch": "@@ -1033,7 +1033,11 @@ void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIV\n     if (state->nMisbehavior >= banscore && state->nMisbehavior - howmuch < banscore)\n     {\n         LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d) DISCOURAGE THRESHOLD EXCEEDED%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n+<<<<<<< HEAD\n         state->m_should_discourage = true;\n+=======\n+        state->fShouldBan = true;\n+>>>>>>> Replace automatic bans with discouragement filter\n     } else\n         LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d)%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n }\n@@ -3574,12 +3578,20 @@ bool PeerLogicValidation::MaybeDiscourageAndDisconnect(CNode& pnode)\n             LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pnode.addr.ToString());\n         } else if (pnode.m_manual_connection) {\n             LogPrintf(\"Warning: not punishing manually-connected peer %s!\\n\", pnode.addr.ToString());\n+<<<<<<< HEAD\n         } else if (pnode.addr.IsLocal()) {\n+=======\n+        else if (pnode.addr.IsLocal()) {\n+>>>>>>> Replace automatic bans with discouragement filter\n             // Disconnect but don't discourage this local node\n             LogPrintf(\"Warning: disconnecting but not discouraging local peer %s!\\n\", pnode.addr.ToString());\n             pnode.fDisconnect = true;\n         } else {\n+<<<<<<< HEAD\n             // Disconnect and discourage all nodes sharing the address\n+=======\n+            // Disconnect and ban all nodes sharing the address\n+>>>>>>> Replace automatic bans with discouragement filter\n             LogPrintf(\"Disconnecting and discouraging peer %s!\\n\", pnode.addr.ToString());\n             if (m_banman) {\n                 m_banman->Discourage(pnode.addr);"
      },
      {
        "sha": "5dbe28b00d1dcd4c766c18d0b025c3a4aae6d8ac",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8251921c09fbbd17fc5079d523f805d956b12a9/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8251921c09fbbd17fc5079d523f805d956b12a9/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=a8251921c09fbbd17fc5079d523f805d956b12a9",
        "patch": "@@ -604,7 +604,8 @@ static UniValue setban(const JSONRPCRequest& request)\n \n     if (strCommand == \"add\")\n     {\n-        if (isSubnet ? node.banman->IsBanned(subNet) : node.banman->IsBanned(netAddr)) {\n+        if ((isSubnet && node.banman->IsBanned(subNet)) ||\n+            (!isSubnet && node.banman->IsBannedLevel(netAddr) == BanReasonManuallyAdded)) {\n             throw JSONRPCError(RPC_CLIENT_NODE_ALREADY_ADDED, \"Error: IP/Subnet already banned\");\n         }\n "
      },
      {
        "sha": "859b19c9aa9cf087ee585da6296acbdb8a84d871",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8251921c09fbbd17fc5079d523f805d956b12a9/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8251921c09fbbd17fc5079d523f805d956b12a9/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=a8251921c09fbbd17fc5079d523f805d956b12a9",
        "patch": "@@ -344,7 +344,11 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n         LOCK2(cs_main, dummyNode.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode));\n     }\n+<<<<<<< HEAD\n     BOOST_CHECK(banman->IsDiscouraged(addr));\n+=======\n+    BOOST_CHECK(banman->IsBanned(addr));\n+>>>>>>> Replace automatic bans with discouragement filter\n \n     bool dummy;\n     peerLogic->FinalizeNode(dummyNode.GetId(), dummy);"
      }
    ]
  },
  {
    "sha": "4aac3113aa1a0b3f6d1f1b348221b42260b7be92",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0YWFjMzExM2FhMWEwYjNmNmQxZjFiMzQ4MjIxYjQyMjYwYjdiZTky",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-11T00:11:38Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:25Z"
      },
      "message": "Clean up separated ban/discourage interface",
      "tree": {
        "sha": "2ec7ff20d96ed410de82b21801c81e4f2837df7b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2ec7ff20d96ed410de82b21801c81e4f2837df7b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4aac3113aa1a0b3f6d1f1b348221b42260b7be92",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4aac3113aa1a0b3f6d1f1b348221b42260b7be92",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4aac3113aa1a0b3f6d1f1b348221b42260b7be92",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4aac3113aa1a0b3f6d1f1b348221b42260b7be92/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a8251921c09fbbd17fc5079d523f805d956b12a9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a8251921c09fbbd17fc5079d523f805d956b12a9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a8251921c09fbbd17fc5079d523f805d956b12a9"
      }
    ],
    "stats": {
      "total": 59,
      "additions": 35,
      "deletions": 24
    },
    "files": [
      {
        "sha": "8752185a60df2a145f3456751a02f8fe2eb63d94",
        "filename": "src/banman.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 22,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4aac3113aa1a0b3f6d1f1b348221b42260b7be92/src/banman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4aac3113aa1a0b3f6d1f1b348221b42260b7be92/src/banman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/banman.cpp?ref=4aac3113aa1a0b3f6d1f1b348221b42260b7be92",
        "patch": "@@ -70,28 +70,14 @@ void BanMan::ClearBanned()\n \n bool BanMan::IsDiscouraged(const CNetAddr& net_addr)\n {\n-    // Returns the most severe level of banning that applies to this address.\n-    // 0 - Not banned\n-    // 1 - Automatic misbehavior ban\n-    // 2 - Any other ban\n-    auto current_time = GetTime();\n     LOCK(m_cs_banned);\n-    for (const auto& it : m_banned) {\n-        CSubNet sub_net = it.first;\n-        CBanEntry ban_entry = it.second;\n-\n-        if (current_time < ban_entry.nBanUntil && sub_net.Match(net_addr)) {\n-            return 2;\n-        }\n-    }\n-    return m_discouraged.contains(net_addr.GetAddrBytes()) ? 1 : 0;\n+    return m_discouraged.contains(net_addr.GetAddrBytes());\n }\n \n bool BanMan::IsBanned(const CNetAddr& net_addr)\n {\n     auto current_time = GetTime();\n     LOCK(m_cs_banned);\n-    if (m_discouraged.contains(net_addr.GetAddrBytes())) return true;\n     for (const auto& it : m_banned) {\n         CSubNet sub_net = it.first;\n         CBanEntry ban_entry = it.second;\n@@ -119,11 +105,6 @@ bool BanMan::IsBanned(const CSubNet& sub_net)\n \n void BanMan::Ban(const CNetAddr& net_addr, int64_t ban_time_offset, bool since_unix_epoch)\n {\n-    if (ban_reason == BanReasonNodeMisbehaving) {\n-        LOCK(m_cs_banned);\n-        m_discouraged.insert(net_addr.GetAddrBytes());\n-        return;\n-    }\n     CSubNet sub_net(net_addr);\n     Ban(sub_net, ban_time_offset, since_unix_epoch);\n }\n@@ -136,8 +117,7 @@ void BanMan::Discourage(const CNetAddr& net_addr)\n \n void BanMan::Ban(const CSubNet& sub_net, int64_t ban_time_offset, bool since_unix_epoch)\n {\n-    assert(ban_reason == BanReasonManuallyAdded);\n-    CBanEntry ban_entry(GetTime(), ban_reason);\n+    CBanEntry ban_entry(GetTime());\n \n     int64_t normalized_ban_time_offset = ban_time_offset;\n     bool normalized_since_unix_epoch = since_unix_epoch;"
      },
      {
        "sha": "1be7abaaa3c1e58eb185ca5202572032496b79f5",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4aac3113aa1a0b3f6d1f1b348221b42260b7be92/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4aac3113aa1a0b3f6d1f1b348221b42260b7be92/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=4aac3113aa1a0b3f6d1f1b348221b42260b7be92",
        "patch": "@@ -1011,6 +1011,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     // on all platforms.  Set it again here just to be sure.\n     SetSocketNoDelay(hSocket);\n \n+<<<<<<< HEAD\n <<<<<<< HEAD\n     // Don't accept connections from banned peers.\n     bool banned = m_banman->IsBanned(addr);\n@@ -1021,19 +1022,29 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     // Don't accept connections from banned peers.\n     if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && bannedlevel == 2)\n >>>>>>> Replace automatic bans with discouragement filter\n+=======\n+    // Don't accept connections from banned peers.\n+    bool banned = m_banman->IsBanned(addr);\n+    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && banned)\n+>>>>>>> Clean up separated ban/discourage interface\n     {\n         LogPrint(BCLog::NET, \"connection from %s dropped (banned)\\n\", addr.ToString());\n         CloseSocket(hSocket);\n         return;\n     }\n \n     // Only accept connections from discouraged peers if our inbound slots aren't (almost) full.\n+<<<<<<< HEAD\n <<<<<<< HEAD\n     bool discouraged = m_banman->IsDiscouraged(addr);\n     if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && nInbound + 1 >= nMaxInbound && discouraged)\n =======\n     if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && nInbound + 1 >= nMaxInbound && bannedlevel >= 1)\n >>>>>>> Replace automatic bans with discouragement filter\n+=======\n+    bool discouraged = m_banman->IsDiscouraged(addr);\n+    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && nInbound + 1 >= nMaxInbound && discouraged)\n+>>>>>>> Clean up separated ban/discourage interface\n     {\n         LogPrint(BCLog::NET, \"connection from %s dropped (discouraged)\\n\", addr.ToString());\n         CloseSocket(hSocket);"
      },
      {
        "sha": "4303a3a2227b52f7762cb127dae2c3633a5ba800",
        "filename": "src/net_permissions.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4aac3113aa1a0b3f6d1f1b348221b42260b7be92/src/net_permissions.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4aac3113aa1a0b3f6d1f1b348221b42260b7be92/src/net_permissions.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_permissions.h?ref=4aac3113aa1a0b3f6d1f1b348221b42260b7be92",
        "patch": "@@ -23,10 +23,15 @@ enum NetPermissionFlags {\n     // Always relay transactions from this peer, even if already in mempool\n     // Keep parameter interaction: forcerelay implies relay\n     PF_FORCERELAY = (1U << 2) | PF_RELAY,\n+<<<<<<< HEAD\n     // Allow getheaders during IBD and block-download after maxuploadtarget limit\n     PF_DOWNLOAD = (1U << 6),\n     // Can't be banned/disconnected/discouraged for misbehavior\n     PF_NOBAN = (1U << 4) | PF_DOWNLOAD,\n+=======\n+    // Can't be banned/disconnected/discouraged for misbehavior\n+    PF_NOBAN = (1U << 4),\n+>>>>>>> Clean up separated ban/discourage interface\n     // Can query the mempool\n     PF_MEMPOOL = (1U << 5),\n "
      },
      {
        "sha": "cba168177069afc35d0995c5b5cfc35503ebe9fb",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4aac3113aa1a0b3f6d1f1b348221b42260b7be92/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4aac3113aa1a0b3f6d1f1b348221b42260b7be92/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=4aac3113aa1a0b3f6d1f1b348221b42260b7be92",
        "patch": "@@ -1033,11 +1033,15 @@ void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIV\n     if (state->nMisbehavior >= banscore && state->nMisbehavior - howmuch < banscore)\n     {\n         LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d) DISCOURAGE THRESHOLD EXCEEDED%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n+<<<<<<< HEAD\n <<<<<<< HEAD\n         state->m_should_discourage = true;\n =======\n         state->fShouldBan = true;\n >>>>>>> Replace automatic bans with discouragement filter\n+=======\n+        state->m_should_discourage = true;\n+>>>>>>> Clean up separated ban/discourage interface\n     } else\n         LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d)%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n }\n@@ -3578,20 +3582,28 @@ bool PeerLogicValidation::MaybeDiscourageAndDisconnect(CNode& pnode)\n             LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pnode.addr.ToString());\n         } else if (pnode.m_manual_connection) {\n             LogPrintf(\"Warning: not punishing manually-connected peer %s!\\n\", pnode.addr.ToString());\n+<<<<<<< HEAD\n <<<<<<< HEAD\n         } else if (pnode.addr.IsLocal()) {\n =======\n         else if (pnode.addr.IsLocal()) {\n >>>>>>> Replace automatic bans with discouragement filter\n+=======\n+        } else if (pnode.addr.IsLocal()) {\n+>>>>>>> Clean up separated ban/discourage interface\n             // Disconnect but don't discourage this local node\n             LogPrintf(\"Warning: disconnecting but not discouraging local peer %s!\\n\", pnode.addr.ToString());\n             pnode.fDisconnect = true;\n         } else {\n+<<<<<<< HEAD\n <<<<<<< HEAD\n             // Disconnect and discourage all nodes sharing the address\n =======\n             // Disconnect and ban all nodes sharing the address\n >>>>>>> Replace automatic bans with discouragement filter\n+=======\n+            // Disconnect and discourage all nodes sharing the address\n+>>>>>>> Clean up separated ban/discourage interface\n             LogPrintf(\"Disconnecting and discouraging peer %s!\\n\", pnode.addr.ToString());\n             if (m_banman) {\n                 m_banman->Discourage(pnode.addr);"
      },
      {
        "sha": "9981ea35dff395a774714a1245086acf0cf85236",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4aac3113aa1a0b3f6d1f1b348221b42260b7be92/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4aac3113aa1a0b3f6d1f1b348221b42260b7be92/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=4aac3113aa1a0b3f6d1f1b348221b42260b7be92",
        "patch": "@@ -604,8 +604,7 @@ static UniValue setban(const JSONRPCRequest& request)\n \n     if (strCommand == \"add\")\n     {\n-        if ((isSubnet && node.banman->IsBanned(subNet)) ||\n-            (!isSubnet && node.banman->IsBannedLevel(netAddr) == BanReasonManuallyAdded)) {\n+        if (isSubnet ? node.banman->IsBanned(subNet) : node.banman->IsBanned(netAddr)) {\n             throw JSONRPCError(RPC_CLIENT_NODE_ALREADY_ADDED, \"Error: IP/Subnet already banned\");\n         }\n "
      },
      {
        "sha": "6f52fee039ca1bc8c972bc20a0d122d2a94da271",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4aac3113aa1a0b3f6d1f1b348221b42260b7be92/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4aac3113aa1a0b3f6d1f1b348221b42260b7be92/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=4aac3113aa1a0b3f6d1f1b348221b42260b7be92",
        "patch": "@@ -344,11 +344,15 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n         LOCK2(cs_main, dummyNode.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode));\n     }\n+<<<<<<< HEAD\n <<<<<<< HEAD\n     BOOST_CHECK(banman->IsDiscouraged(addr));\n =======\n     BOOST_CHECK(banman->IsBanned(addr));\n >>>>>>> Replace automatic bans with discouragement filter\n+=======\n+    BOOST_CHECK(banman->IsDiscouraged(addr));\n+>>>>>>> Clean up separated ban/discourage interface\n \n     bool dummy;\n     peerLogic->FinalizeNode(dummyNode.GetId(), dummy);"
      }
    ]
  },
  {
    "sha": "5e1dffaca6ca426cffcc2033e90ad80ef22cdf80",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZTFkZmZhY2E2Y2E0MjZjZmZjYzIwMzNlOTBhZDgwZWYyMmNkZjgw",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-06-20T12:44:42Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:25Z"
      },
      "message": "wallet: Remove confusing double return value ret+success\n\nAlso, remove redundant comments",
      "tree": {
        "sha": "e6a60e5d7b576fbb5b031e661dbf92bfcc5fbc97",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e6a60e5d7b576fbb5b031e661dbf92bfcc5fbc97"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5e1dffaca6ca426cffcc2033e90ad80ef22cdf80",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e1dffaca6ca426cffcc2033e90ad80ef22cdf80",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5e1dffaca6ca426cffcc2033e90ad80ef22cdf80",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e1dffaca6ca426cffcc2033e90ad80ef22cdf80/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4aac3113aa1a0b3f6d1f1b348221b42260b7be92",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4aac3113aa1a0b3f6d1f1b348221b42260b7be92",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4aac3113aa1a0b3f6d1f1b348221b42260b7be92"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 4,
      "deletions": 4
    },
    "files": [
      {
        "sha": "a14744a86fc26cc0bf7864a966f1d3671a0b0ba3",
        "filename": "src/wallet/bdb.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e1dffaca6ca426cffcc2033e90ad80ef22cdf80/src/wallet/bdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e1dffaca6ca426cffcc2033e90ad80ef22cdf80/src/wallet/bdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/bdb.h?ref=5e1dffaca6ca426cffcc2033e90ad80ef22cdf80",
        "patch": "@@ -227,7 +227,7 @@ class BerkeleyBatch\n         ssKey << key;\n \n         CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n-        if (!ReadKey(std::move(ssKey), ssValue)) return false;\n+        if (!ReadKey(ssKey, ssValue)) return false;\n         try {\n             ssValue >> value;\n             return true;\n@@ -247,7 +247,7 @@ class BerkeleyBatch\n         ssValue.reserve(10000);\n         ssValue << value;\n \n-        return WriteKey(std::move(ssKey), std::move(ssValue), fOverwrite);\n+        return WriteKey(ssKey, ssValue, fOverwrite);\n     }\n \n     template <typename K>\n@@ -257,7 +257,7 @@ class BerkeleyBatch\n         ssKey.reserve(1000);\n         ssKey << key;\n \n-        return EraseKey(std::move(ssKey));\n+        return EraseKey(ssKey);\n     }\n \n     template <typename K>\n@@ -267,7 +267,7 @@ class BerkeleyBatch\n         ssKey.reserve(1000);\n         ssKey << key;\n \n-        return HasKey(std::move(ssKey));\n+        return HasKey(ssKey);\n     }\n \n     bool StartCursor();"
      }
    ]
  },
  {
    "sha": "75d1f5aedc9783eb1a324dfd66cafb11c118897c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NWQxZjVhZWRjOTc4M2ViMWEzMjRkZmQ2NmNhZmIxMWMxMTg4OTdj",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-06-20T12:55:07Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:25Z"
      },
      "message": "wallet: Replace CDataStream& with CDataStream&& where appropriate\n\nThe keys and values are only to be used once because their memory is set\nto zero. Make that explicit by moving the bytes into the lower level\nmethods.",
      "tree": {
        "sha": "2ec7ff20d96ed410de82b21801c81e4f2837df7b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2ec7ff20d96ed410de82b21801c81e4f2837df7b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/75d1f5aedc9783eb1a324dfd66cafb11c118897c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75d1f5aedc9783eb1a324dfd66cafb11c118897c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/75d1f5aedc9783eb1a324dfd66cafb11c118897c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75d1f5aedc9783eb1a324dfd66cafb11c118897c/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5e1dffaca6ca426cffcc2033e90ad80ef22cdf80",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e1dffaca6ca426cffcc2033e90ad80ef22cdf80",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5e1dffaca6ca426cffcc2033e90ad80ef22cdf80"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 4,
      "deletions": 4
    },
    "files": [
      {
        "sha": "599319482bea0ebeee0dbcd95757030e5512ddff",
        "filename": "src/wallet/bdb.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75d1f5aedc9783eb1a324dfd66cafb11c118897c/src/wallet/bdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75d1f5aedc9783eb1a324dfd66cafb11c118897c/src/wallet/bdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/bdb.h?ref=75d1f5aedc9783eb1a324dfd66cafb11c118897c",
        "patch": "@@ -227,7 +227,7 @@ class BerkeleyBatch\n         ssKey << key;\n \n         CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n-        if (!ReadKey(ssKey, ssValue)) return false;\n+        if (!ReadKey(std::move(ssKey), ssValue)) return false;\n         try {\n             ssValue >> value;\n             return true;\n@@ -247,7 +247,7 @@ class BerkeleyBatch\n         ssValue.reserve(10000);\n         ssValue << value;\n \n-        return WriteKey(ssKey, ssValue, fOverwrite);\n+        return WriteKey(std::move(ssKey), std::move(ssValue), fOverwrite);\n     }\n \n     template <typename K>\n@@ -257,7 +257,7 @@ class BerkeleyBatch\n         ssKey.reserve(1000);\n         ssKey << key;\n \n-        return EraseKey(ssKey);\n+        return EraseKey(std::move(ssKey));\n     }\n \n     template <typename K>\n@@ -267,7 +267,7 @@ class BerkeleyBatch\n         ssKey.reserve(1000);\n         ssKey << key;\n \n-        return HasKey(ssKey);\n+        return HasKey(std::move(ssKey));\n     }\n \n     bool StartCursor();"
      }
    ]
  },
  {
    "sha": "e3f074c4b379f656f9ceb5716f152a4585c25d74",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplM2YwNzRjNGIzNzlmNjU2ZjljZWI1NzE2ZjE1MmE0NTg1YzI1ZDc0",
    "commit": {
      "author": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-07T06:39:46Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:25Z"
      },
      "message": "Revert \"Attempted test where one node sends block to another\"\n\nThis reverts commit 55cf78aae878ac1e2a8ed5712877465a2e4a938c.",
      "tree": {
        "sha": "70e017472580280d2e330781c0250dad5ecadcc8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/70e017472580280d2e330781c0250dad5ecadcc8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e3f074c4b379f656f9ceb5716f152a4585c25d74",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3f074c4b379f656f9ceb5716f152a4585c25d74",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e3f074c4b379f656f9ceb5716f152a4585c25d74",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3f074c4b379f656f9ceb5716f152a4585c25d74/comments",
    "author": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "75d1f5aedc9783eb1a324dfd66cafb11c118897c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75d1f5aedc9783eb1a324dfd66cafb11c118897c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/75d1f5aedc9783eb1a324dfd66cafb11c118897c"
      }
    ],
    "stats": {
      "total": 224,
      "additions": 0,
      "deletions": 224
    },
    "files": [
      {
        "sha": "87d7100d263b50c88ea90451a601e813aebc0939",
        "filename": "test/functional/p2p_saahil.py",
        "status": "removed",
        "additions": 0,
        "deletions": 224,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75d1f5aedc9783eb1a324dfd66cafb11c118897c/test/functional/p2p_saahil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75d1f5aedc9783eb1a324dfd66cafb11c118897c/test/functional/p2p_saahil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_saahil.py?ref=75d1f5aedc9783eb1a324dfd66cafb11c118897c",
        "patch": "@@ -1,224 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2017-2019 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"An example functional test\n-\n-The module-level docstring should include a high-level description of\n-what the test is doing. It's the first thing people see when they open\n-the file and should give the reader information about *what* the test\n-is testing and *how* it's being tested\n-\"\"\"\n-# Imports should be in PEP8 ordering (std library first, then third party\n-# libraries then local imports).\n-from collections import defaultdict\n-\n-# Avoid wildcard * imports\n-from test_framework.blocktools import (create_block, create_coinbase)\n-from test_framework.messages import CInv, MSG_BLOCK\n-from test_framework.mininode import (\n-    P2PInterface,\n-    mininode_lock,\n-    msg_block,\n-    msg_getdata,\n-)\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (\n-    assert_equal,\n-    connect_nodes,\n-    wait_until,\n-)\n-\n-# P2PInterface is a class containing callbacks to be executed when a P2P\n-# message is received from the node-under-test. Subclass P2PInterface and\n-# override the on_*() methods if you need custom behaviour.\n-class BaseNode(P2PInterface):\n-    def __init__(self):\n-        \"\"\"Initialize the P2PInterface\n-\n-        Used to initialize custom properties for the Node that aren't\n-        included by default in the base class. Be aware that the P2PInterface\n-        base class already stores a counter for each P2P message type and the\n-        last received message of each type, which should be sufficient for the\n-        needs of most tests.\n-\n-        Call super().__init__() first for standard initialization and then\n-        initialize custom properties.\"\"\"\n-        super().__init__()\n-        # Stores a dictionary of all blocks received\n-        self.block_receive_map = defaultdict(int)\n-\n-    def on_block(self, message):\n-        \"\"\"Override the standard on_block callback\n-\n-        Store the hash of a received block in the dictionary.\"\"\"\n-        message.block.calc_sha256()\n-        self.block_receive_map[message.block.sha256] += 1\n-\n-    def on_inv(self, message):\n-        \"\"\"Override the standard on_inv callback\"\"\"\n-        pass\n-\n-def custom_function():\n-    \"\"\"Do some custom behaviour\n-\n-    If this function is more generally useful for other tests, consider\n-    moving it to a module in test_framework.\"\"\"\n-    # self.log.info(\"running custom_function\")  # Oops! Can't run self.log outside the BitcoinTestFramework\n-    pass\n-\n-\n-class ExampleTest(BitcoinTestFramework):\n-    # Each functional test is a subclass of the BitcoinTestFramework class.\n-\n-    # Override the set_test_params(), skip_test_if_missing_module(), add_options(), setup_chain(), setup_network()\n-    # and setup_nodes() methods to customize the test setup as required.\n-\n-    def set_test_params(self):\n-        \"\"\"Override test parameters for your individual test.\n-\n-        This method must be overridden and num_nodes must be explicitly set.\"\"\"\n-        self.setup_clean_chain = True\n-        self.num_nodes = 3\n-        # Use self.extra_args to change command-line arguments for the nodes\n-        self.extra_args = [[], [\"-logips\"], []]\n-\n-        # self.log.info(\"I've finished set_test_params\")  # Oops! Can't run self.log before run_test()\n-\n-    # Use skip_test_if_missing_module() to skip the test if your test requires certain modules to be present.\n-    # This test uses generate which requires wallet to be compiled\n-    def skip_test_if_missing_module(self):\n-        self.skip_if_no_wallet()\n-\n-    # Use add_options() to add specific command-line options for your test.\n-    # In practice this is not used very much, since the tests are mostly written\n-    # to be run in automated environments without command-line options.\n-    # def add_options()\n-    #     pass\n-\n-    # Use setup_chain() to customize the node data directories. In practice\n-    # this is not used very much since the default behaviour is almost always\n-    # fine\n-    # def setup_chain():\n-    #     pass\n-\n-    def setup_network(self):\n-        \"\"\"Setup the test network topology\n-\n-        Often you won't need to override this, since the standard network topology\n-        (linear: node0 <-> node1 <-> node2 <-> ...) is fine for most tests.\n-\n-        If you do override this method, remember to start the nodes, assign\n-        them to self.nodes, connect them and then sync.\"\"\"\n-\n-        self.setup_nodes()\n-\n-        # In this test, we're not connecting node2 to node0 or node1. Calls to\n-        # sync_all() should not include node2, since we're not expecting it to\n-        # sync.\n-        #connect_nodes(self.nodes[0], 1)\n-        #self.sync_all(self.nodes[0:2])\n-\n-    # Use setup_nodes() to customize the node start behaviour (for example if\n-    # you don't want to start all nodes at the start of the test).\n-    # def setup_nodes():\n-    #     pass\n-\n-    def custom_method(self):\n-        \"\"\"Do some custom behaviour for this test\n-\n-        Define it in a method here because you're going to use it repeatedly.\n-        If you think it's useful in general, consider moving it to the base\n-        BitcoinTestFramework class so other tests can use it.\"\"\"\n-\n-        self.log.info(\"Running custom_method\")\n-\n-    def run_test(self):\n-        \"\"\"Main test logic\"\"\"\n-\n-        # Create P2P connections will wait for a verack to make sure the connection is fully up\n-        self.nodes[0].add_p2p_connection(BaseNode())\n-\n-        # Generating a block on one of the nodes will get us out of IBD\n-        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n-        self.log.info(\"Number of blocks in node 0: \" + str(self.nodes[0].getblockcount()))\n-        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n-        \n-        self.log.info(\"Now sending block from one to the other\")\n-        connect_nodes(self.nodes[0], 1)\n-        self.sync_all(self.nodes[0:2])\n-\n-        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n-\n-        # # Notice above how we called an RPC by calling a method with the same\n-        # # name on the node object. Notice also how we used a keyword argument\n-        # # to specify a named RPC argument. Neither of those are defined on the\n-        # # node object. Instead there's some __getattr__() magic going on under\n-        # # the covers to dispatch unrecognised attribute calls to the RPC\n-        # # interface.\n-\n-        # # Logs are nice. Do plenty of them. They can be used in place of comments for\n-        # # breaking the test into sub-sections.\n-        # self.log.info(\"Starting test!\")\n-\n-        # self.log.info(\"Calling a custom function\")\n-        # custom_function()\n-\n-        # self.log.info(\"Calling a custom method\")\n-        # self.custom_method()\n-\n-        # self.log.info(\"Create some blocks\")\n-        # self.tip = int(self.nodes[0].getbestblockhash(), 16)\n-        # self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n-\n-        # height = self.nodes[0].getblockcount()\n-\n-        # for i in range(10):\n-        #     # Use the mininode and blocktools functionality to manually build a block\n-        #     # Calling the generate() rpc is easier, but this allows us to exactly\n-        #     # control the blocks and transactions.\n-        #     block = create_block(self.tip, create_coinbase(height+1), self.block_time)\n-        #     block.solve()\n-        #     block_message = msg_block(block)\n-        #     # Send message is used to send a P2P message to the node over our P2PInterface\n-        #     self.nodes[0].p2p.send_message(block_message)\n-        #     self.tip = block.sha256\n-        #     blocks.append(self.tip)\n-        #     self.block_time += 1\n-        #     height += 1\n-\n-        # self.log.info(\"Wait for node1 to reach current tip (height 11) using RPC\")\n-        # self.nodes[1].waitforblockheight(11)\n-\n-        # self.log.info(\"Connect node2 and node1\")\n-        # connect_nodes(self.nodes[1], 2)\n-\n-        # self.log.info(\"Wait for node2 to receive all the blocks from node1\")\n-        # self.sync_all()\n-\n-        # self.log.info(\"Add P2P connection to node2\")\n-        # self.nodes[0].disconnect_p2ps()\n-\n-        # self.nodes[2].add_p2p_connection(BaseNode())\n-\n-        # self.log.info(\"Test that node2 propagates all the blocks to us\")\n-\n-        # getdata_request = msg_getdata()\n-        # for block in blocks:\n-        #     getdata_request.inv.append(CInv(MSG_BLOCK, block))\n-        # self.nodes[2].p2p.send_message(getdata_request)\n-\n-        # # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n-        # # P2PInterface objects.\n-        # wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n-\n-        # self.log.info(\"Check that each block was received only once\")\n-        # # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving\n-        # # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking\n-        # # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n-        # with mininode_lock:\n-        #     for block in self.nodes[2].p2p.block_receive_map.values():\n-        #         assert_equal(block, 1)\n-\n-if __name__ == '__main__':\n-    ExampleTest().main()"
      }
    ]
  },
  {
    "sha": "2adee2ff32f9b8560db395d200bd7be3b5eb6526",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYWRlZTJmZjMyZjliODU2MGRiMzk1ZDIwMGJkN2JlM2I1ZWI2NTI2",
    "commit": {
      "author": {
        "name": "Saahil Shangle",
        "email": "saahilshangle@gmail.com",
        "date": "2020-06-08T00:20:11Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:25Z"
      },
      "message": "Attempted test where one node sends block to another",
      "tree": {
        "sha": "2ec7ff20d96ed410de82b21801c81e4f2837df7b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2ec7ff20d96ed410de82b21801c81e4f2837df7b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2adee2ff32f9b8560db395d200bd7be3b5eb6526",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2adee2ff32f9b8560db395d200bd7be3b5eb6526",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2adee2ff32f9b8560db395d200bd7be3b5eb6526",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2adee2ff32f9b8560db395d200bd7be3b5eb6526/comments",
    "author": {
      "login": "saahilshangle",
      "id": 10226886,
      "node_id": "MDQ6VXNlcjEwMjI2ODg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10226886?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saahilshangle",
      "html_url": "https://github.com/saahilshangle",
      "followers_url": "https://api.github.com/users/saahilshangle/followers",
      "following_url": "https://api.github.com/users/saahilshangle/following{/other_user}",
      "gists_url": "https://api.github.com/users/saahilshangle/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saahilshangle/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saahilshangle/subscriptions",
      "organizations_url": "https://api.github.com/users/saahilshangle/orgs",
      "repos_url": "https://api.github.com/users/saahilshangle/repos",
      "events_url": "https://api.github.com/users/saahilshangle/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saahilshangle/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e3f074c4b379f656f9ceb5716f152a4585c25d74",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3f074c4b379f656f9ceb5716f152a4585c25d74",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e3f074c4b379f656f9ceb5716f152a4585c25d74"
      }
    ],
    "stats": {
      "total": 224,
      "additions": 224,
      "deletions": 0
    },
    "files": [
      {
        "sha": "87d7100d263b50c88ea90451a601e813aebc0939",
        "filename": "test/functional/p2p_saahil.py",
        "status": "added",
        "additions": 224,
        "deletions": 0,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2adee2ff32f9b8560db395d200bd7be3b5eb6526/test/functional/p2p_saahil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2adee2ff32f9b8560db395d200bd7be3b5eb6526/test/functional/p2p_saahil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_saahil.py?ref=2adee2ff32f9b8560db395d200bd7be3b5eb6526",
        "patch": "@@ -0,0 +1,224 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"An example functional test\n+\n+The module-level docstring should include a high-level description of\n+what the test is doing. It's the first thing people see when they open\n+the file and should give the reader information about *what* the test\n+is testing and *how* it's being tested\n+\"\"\"\n+# Imports should be in PEP8 ordering (std library first, then third party\n+# libraries then local imports).\n+from collections import defaultdict\n+\n+# Avoid wildcard * imports\n+from test_framework.blocktools import (create_block, create_coinbase)\n+from test_framework.messages import CInv, MSG_BLOCK\n+from test_framework.mininode import (\n+    P2PInterface,\n+    mininode_lock,\n+    msg_block,\n+    msg_getdata,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    connect_nodes,\n+    wait_until,\n+)\n+\n+# P2PInterface is a class containing callbacks to be executed when a P2P\n+# message is received from the node-under-test. Subclass P2PInterface and\n+# override the on_*() methods if you need custom behaviour.\n+class BaseNode(P2PInterface):\n+    def __init__(self):\n+        \"\"\"Initialize the P2PInterface\n+\n+        Used to initialize custom properties for the Node that aren't\n+        included by default in the base class. Be aware that the P2PInterface\n+        base class already stores a counter for each P2P message type and the\n+        last received message of each type, which should be sufficient for the\n+        needs of most tests.\n+\n+        Call super().__init__() first for standard initialization and then\n+        initialize custom properties.\"\"\"\n+        super().__init__()\n+        # Stores a dictionary of all blocks received\n+        self.block_receive_map = defaultdict(int)\n+\n+    def on_block(self, message):\n+        \"\"\"Override the standard on_block callback\n+\n+        Store the hash of a received block in the dictionary.\"\"\"\n+        message.block.calc_sha256()\n+        self.block_receive_map[message.block.sha256] += 1\n+\n+    def on_inv(self, message):\n+        \"\"\"Override the standard on_inv callback\"\"\"\n+        pass\n+\n+def custom_function():\n+    \"\"\"Do some custom behaviour\n+\n+    If this function is more generally useful for other tests, consider\n+    moving it to a module in test_framework.\"\"\"\n+    # self.log.info(\"running custom_function\")  # Oops! Can't run self.log outside the BitcoinTestFramework\n+    pass\n+\n+\n+class ExampleTest(BitcoinTestFramework):\n+    # Each functional test is a subclass of the BitcoinTestFramework class.\n+\n+    # Override the set_test_params(), skip_test_if_missing_module(), add_options(), setup_chain(), setup_network()\n+    # and setup_nodes() methods to customize the test setup as required.\n+\n+    def set_test_params(self):\n+        \"\"\"Override test parameters for your individual test.\n+\n+        This method must be overridden and num_nodes must be explicitly set.\"\"\"\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+        # Use self.extra_args to change command-line arguments for the nodes\n+        self.extra_args = [[], [\"-logips\"], []]\n+\n+        # self.log.info(\"I've finished set_test_params\")  # Oops! Can't run self.log before run_test()\n+\n+    # Use skip_test_if_missing_module() to skip the test if your test requires certain modules to be present.\n+    # This test uses generate which requires wallet to be compiled\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    # Use add_options() to add specific command-line options for your test.\n+    # In practice this is not used very much, since the tests are mostly written\n+    # to be run in automated environments without command-line options.\n+    # def add_options()\n+    #     pass\n+\n+    # Use setup_chain() to customize the node data directories. In practice\n+    # this is not used very much since the default behaviour is almost always\n+    # fine\n+    # def setup_chain():\n+    #     pass\n+\n+    def setup_network(self):\n+        \"\"\"Setup the test network topology\n+\n+        Often you won't need to override this, since the standard network topology\n+        (linear: node0 <-> node1 <-> node2 <-> ...) is fine for most tests.\n+\n+        If you do override this method, remember to start the nodes, assign\n+        them to self.nodes, connect them and then sync.\"\"\"\n+\n+        self.setup_nodes()\n+\n+        # In this test, we're not connecting node2 to node0 or node1. Calls to\n+        # sync_all() should not include node2, since we're not expecting it to\n+        # sync.\n+        #connect_nodes(self.nodes[0], 1)\n+        #self.sync_all(self.nodes[0:2])\n+\n+    # Use setup_nodes() to customize the node start behaviour (for example if\n+    # you don't want to start all nodes at the start of the test).\n+    # def setup_nodes():\n+    #     pass\n+\n+    def custom_method(self):\n+        \"\"\"Do some custom behaviour for this test\n+\n+        Define it in a method here because you're going to use it repeatedly.\n+        If you think it's useful in general, consider moving it to the base\n+        BitcoinTestFramework class so other tests can use it.\"\"\"\n+\n+        self.log.info(\"Running custom_method\")\n+\n+    def run_test(self):\n+        \"\"\"Main test logic\"\"\"\n+\n+        # Create P2P connections will wait for a verack to make sure the connection is fully up\n+        self.nodes[0].add_p2p_connection(BaseNode())\n+\n+        # Generating a block on one of the nodes will get us out of IBD\n+        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n+        self.log.info(\"Number of blocks in node 0: \" + str(self.nodes[0].getblockcount()))\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+        \n+        self.log.info(\"Now sending block from one to the other\")\n+        connect_nodes(self.nodes[0], 1)\n+        self.sync_all(self.nodes[0:2])\n+\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+\n+        # # Notice above how we called an RPC by calling a method with the same\n+        # # name on the node object. Notice also how we used a keyword argument\n+        # # to specify a named RPC argument. Neither of those are defined on the\n+        # # node object. Instead there's some __getattr__() magic going on under\n+        # # the covers to dispatch unrecognised attribute calls to the RPC\n+        # # interface.\n+\n+        # # Logs are nice. Do plenty of them. They can be used in place of comments for\n+        # # breaking the test into sub-sections.\n+        # self.log.info(\"Starting test!\")\n+\n+        # self.log.info(\"Calling a custom function\")\n+        # custom_function()\n+\n+        # self.log.info(\"Calling a custom method\")\n+        # self.custom_method()\n+\n+        # self.log.info(\"Create some blocks\")\n+        # self.tip = int(self.nodes[0].getbestblockhash(), 16)\n+        # self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n+\n+        # height = self.nodes[0].getblockcount()\n+\n+        # for i in range(10):\n+        #     # Use the mininode and blocktools functionality to manually build a block\n+        #     # Calling the generate() rpc is easier, but this allows us to exactly\n+        #     # control the blocks and transactions.\n+        #     block = create_block(self.tip, create_coinbase(height+1), self.block_time)\n+        #     block.solve()\n+        #     block_message = msg_block(block)\n+        #     # Send message is used to send a P2P message to the node over our P2PInterface\n+        #     self.nodes[0].p2p.send_message(block_message)\n+        #     self.tip = block.sha256\n+        #     blocks.append(self.tip)\n+        #     self.block_time += 1\n+        #     height += 1\n+\n+        # self.log.info(\"Wait for node1 to reach current tip (height 11) using RPC\")\n+        # self.nodes[1].waitforblockheight(11)\n+\n+        # self.log.info(\"Connect node2 and node1\")\n+        # connect_nodes(self.nodes[1], 2)\n+\n+        # self.log.info(\"Wait for node2 to receive all the blocks from node1\")\n+        # self.sync_all()\n+\n+        # self.log.info(\"Add P2P connection to node2\")\n+        # self.nodes[0].disconnect_p2ps()\n+\n+        # self.nodes[2].add_p2p_connection(BaseNode())\n+\n+        # self.log.info(\"Test that node2 propagates all the blocks to us\")\n+\n+        # getdata_request = msg_getdata()\n+        # for block in blocks:\n+        #     getdata_request.inv.append(CInv(MSG_BLOCK, block))\n+        # self.nodes[2].p2p.send_message(getdata_request)\n+\n+        # # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n+        # # P2PInterface objects.\n+        # wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n+\n+        # self.log.info(\"Check that each block was received only once\")\n+        # # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving\n+        # # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking\n+        # # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n+        # with mininode_lock:\n+        #     for block in self.nodes[2].p2p.block_receive_map.values():\n+        #         assert_equal(block, 1)\n+\n+if __name__ == '__main__':\n+    ExampleTest().main()"
      }
    ]
  },
  {
    "sha": "b212fc28527a3b653021abfd4fe1088ebc0bcf35",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMjEyZmMyODUyN2EzYjY1MzAyMWFiZmQ0ZmUxMDg4ZWJjMGJjZjM1",
    "commit": {
      "author": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-07T06:39:46Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:25Z"
      },
      "message": "Revert \"Attempted test where one node sends block to another\"\n\nThis reverts commit 55cf78aae878ac1e2a8ed5712877465a2e4a938c.",
      "tree": {
        "sha": "70e017472580280d2e330781c0250dad5ecadcc8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/70e017472580280d2e330781c0250dad5ecadcc8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b212fc28527a3b653021abfd4fe1088ebc0bcf35",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b212fc28527a3b653021abfd4fe1088ebc0bcf35",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b212fc28527a3b653021abfd4fe1088ebc0bcf35",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b212fc28527a3b653021abfd4fe1088ebc0bcf35/comments",
    "author": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2adee2ff32f9b8560db395d200bd7be3b5eb6526",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2adee2ff32f9b8560db395d200bd7be3b5eb6526",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2adee2ff32f9b8560db395d200bd7be3b5eb6526"
      }
    ],
    "stats": {
      "total": 224,
      "additions": 0,
      "deletions": 224
    },
    "files": [
      {
        "sha": "87d7100d263b50c88ea90451a601e813aebc0939",
        "filename": "test/functional/p2p_saahil.py",
        "status": "removed",
        "additions": 0,
        "deletions": 224,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2adee2ff32f9b8560db395d200bd7be3b5eb6526/test/functional/p2p_saahil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2adee2ff32f9b8560db395d200bd7be3b5eb6526/test/functional/p2p_saahil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_saahil.py?ref=2adee2ff32f9b8560db395d200bd7be3b5eb6526",
        "patch": "@@ -1,224 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2017-2019 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"An example functional test\n-\n-The module-level docstring should include a high-level description of\n-what the test is doing. It's the first thing people see when they open\n-the file and should give the reader information about *what* the test\n-is testing and *how* it's being tested\n-\"\"\"\n-# Imports should be in PEP8 ordering (std library first, then third party\n-# libraries then local imports).\n-from collections import defaultdict\n-\n-# Avoid wildcard * imports\n-from test_framework.blocktools import (create_block, create_coinbase)\n-from test_framework.messages import CInv, MSG_BLOCK\n-from test_framework.mininode import (\n-    P2PInterface,\n-    mininode_lock,\n-    msg_block,\n-    msg_getdata,\n-)\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (\n-    assert_equal,\n-    connect_nodes,\n-    wait_until,\n-)\n-\n-# P2PInterface is a class containing callbacks to be executed when a P2P\n-# message is received from the node-under-test. Subclass P2PInterface and\n-# override the on_*() methods if you need custom behaviour.\n-class BaseNode(P2PInterface):\n-    def __init__(self):\n-        \"\"\"Initialize the P2PInterface\n-\n-        Used to initialize custom properties for the Node that aren't\n-        included by default in the base class. Be aware that the P2PInterface\n-        base class already stores a counter for each P2P message type and the\n-        last received message of each type, which should be sufficient for the\n-        needs of most tests.\n-\n-        Call super().__init__() first for standard initialization and then\n-        initialize custom properties.\"\"\"\n-        super().__init__()\n-        # Stores a dictionary of all blocks received\n-        self.block_receive_map = defaultdict(int)\n-\n-    def on_block(self, message):\n-        \"\"\"Override the standard on_block callback\n-\n-        Store the hash of a received block in the dictionary.\"\"\"\n-        message.block.calc_sha256()\n-        self.block_receive_map[message.block.sha256] += 1\n-\n-    def on_inv(self, message):\n-        \"\"\"Override the standard on_inv callback\"\"\"\n-        pass\n-\n-def custom_function():\n-    \"\"\"Do some custom behaviour\n-\n-    If this function is more generally useful for other tests, consider\n-    moving it to a module in test_framework.\"\"\"\n-    # self.log.info(\"running custom_function\")  # Oops! Can't run self.log outside the BitcoinTestFramework\n-    pass\n-\n-\n-class ExampleTest(BitcoinTestFramework):\n-    # Each functional test is a subclass of the BitcoinTestFramework class.\n-\n-    # Override the set_test_params(), skip_test_if_missing_module(), add_options(), setup_chain(), setup_network()\n-    # and setup_nodes() methods to customize the test setup as required.\n-\n-    def set_test_params(self):\n-        \"\"\"Override test parameters for your individual test.\n-\n-        This method must be overridden and num_nodes must be explicitly set.\"\"\"\n-        self.setup_clean_chain = True\n-        self.num_nodes = 3\n-        # Use self.extra_args to change command-line arguments for the nodes\n-        self.extra_args = [[], [\"-logips\"], []]\n-\n-        # self.log.info(\"I've finished set_test_params\")  # Oops! Can't run self.log before run_test()\n-\n-    # Use skip_test_if_missing_module() to skip the test if your test requires certain modules to be present.\n-    # This test uses generate which requires wallet to be compiled\n-    def skip_test_if_missing_module(self):\n-        self.skip_if_no_wallet()\n-\n-    # Use add_options() to add specific command-line options for your test.\n-    # In practice this is not used very much, since the tests are mostly written\n-    # to be run in automated environments without command-line options.\n-    # def add_options()\n-    #     pass\n-\n-    # Use setup_chain() to customize the node data directories. In practice\n-    # this is not used very much since the default behaviour is almost always\n-    # fine\n-    # def setup_chain():\n-    #     pass\n-\n-    def setup_network(self):\n-        \"\"\"Setup the test network topology\n-\n-        Often you won't need to override this, since the standard network topology\n-        (linear: node0 <-> node1 <-> node2 <-> ...) is fine for most tests.\n-\n-        If you do override this method, remember to start the nodes, assign\n-        them to self.nodes, connect them and then sync.\"\"\"\n-\n-        self.setup_nodes()\n-\n-        # In this test, we're not connecting node2 to node0 or node1. Calls to\n-        # sync_all() should not include node2, since we're not expecting it to\n-        # sync.\n-        #connect_nodes(self.nodes[0], 1)\n-        #self.sync_all(self.nodes[0:2])\n-\n-    # Use setup_nodes() to customize the node start behaviour (for example if\n-    # you don't want to start all nodes at the start of the test).\n-    # def setup_nodes():\n-    #     pass\n-\n-    def custom_method(self):\n-        \"\"\"Do some custom behaviour for this test\n-\n-        Define it in a method here because you're going to use it repeatedly.\n-        If you think it's useful in general, consider moving it to the base\n-        BitcoinTestFramework class so other tests can use it.\"\"\"\n-\n-        self.log.info(\"Running custom_method\")\n-\n-    def run_test(self):\n-        \"\"\"Main test logic\"\"\"\n-\n-        # Create P2P connections will wait for a verack to make sure the connection is fully up\n-        self.nodes[0].add_p2p_connection(BaseNode())\n-\n-        # Generating a block on one of the nodes will get us out of IBD\n-        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n-        self.log.info(\"Number of blocks in node 0: \" + str(self.nodes[0].getblockcount()))\n-        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n-        \n-        self.log.info(\"Now sending block from one to the other\")\n-        connect_nodes(self.nodes[0], 1)\n-        self.sync_all(self.nodes[0:2])\n-\n-        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n-\n-        # # Notice above how we called an RPC by calling a method with the same\n-        # # name on the node object. Notice also how we used a keyword argument\n-        # # to specify a named RPC argument. Neither of those are defined on the\n-        # # node object. Instead there's some __getattr__() magic going on under\n-        # # the covers to dispatch unrecognised attribute calls to the RPC\n-        # # interface.\n-\n-        # # Logs are nice. Do plenty of them. They can be used in place of comments for\n-        # # breaking the test into sub-sections.\n-        # self.log.info(\"Starting test!\")\n-\n-        # self.log.info(\"Calling a custom function\")\n-        # custom_function()\n-\n-        # self.log.info(\"Calling a custom method\")\n-        # self.custom_method()\n-\n-        # self.log.info(\"Create some blocks\")\n-        # self.tip = int(self.nodes[0].getbestblockhash(), 16)\n-        # self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n-\n-        # height = self.nodes[0].getblockcount()\n-\n-        # for i in range(10):\n-        #     # Use the mininode and blocktools functionality to manually build a block\n-        #     # Calling the generate() rpc is easier, but this allows us to exactly\n-        #     # control the blocks and transactions.\n-        #     block = create_block(self.tip, create_coinbase(height+1), self.block_time)\n-        #     block.solve()\n-        #     block_message = msg_block(block)\n-        #     # Send message is used to send a P2P message to the node over our P2PInterface\n-        #     self.nodes[0].p2p.send_message(block_message)\n-        #     self.tip = block.sha256\n-        #     blocks.append(self.tip)\n-        #     self.block_time += 1\n-        #     height += 1\n-\n-        # self.log.info(\"Wait for node1 to reach current tip (height 11) using RPC\")\n-        # self.nodes[1].waitforblockheight(11)\n-\n-        # self.log.info(\"Connect node2 and node1\")\n-        # connect_nodes(self.nodes[1], 2)\n-\n-        # self.log.info(\"Wait for node2 to receive all the blocks from node1\")\n-        # self.sync_all()\n-\n-        # self.log.info(\"Add P2P connection to node2\")\n-        # self.nodes[0].disconnect_p2ps()\n-\n-        # self.nodes[2].add_p2p_connection(BaseNode())\n-\n-        # self.log.info(\"Test that node2 propagates all the blocks to us\")\n-\n-        # getdata_request = msg_getdata()\n-        # for block in blocks:\n-        #     getdata_request.inv.append(CInv(MSG_BLOCK, block))\n-        # self.nodes[2].p2p.send_message(getdata_request)\n-\n-        # # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n-        # # P2PInterface objects.\n-        # wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n-\n-        # self.log.info(\"Check that each block was received only once\")\n-        # # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving\n-        # # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking\n-        # # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n-        # with mininode_lock:\n-        #     for block in self.nodes[2].p2p.block_receive_map.values():\n-        #         assert_equal(block, 1)\n-\n-if __name__ == '__main__':\n-    ExampleTest().main()"
      }
    ]
  },
  {
    "sha": "f1c8f7312f854e53f5e8456af812d97dff3b92bd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMWM4ZjczMTJmODU0ZTUzZjVlODQ1NmFmODEyZDk3ZGZmM2I5MmJk",
    "commit": {
      "author": {
        "name": "Saahil Shangle",
        "email": "saahilshangle@gmail.com",
        "date": "2020-06-08T00:20:11Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:25Z"
      },
      "message": "Attempted test where one node sends block to another",
      "tree": {
        "sha": "2ec7ff20d96ed410de82b21801c81e4f2837df7b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2ec7ff20d96ed410de82b21801c81e4f2837df7b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f1c8f7312f854e53f5e8456af812d97dff3b92bd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f1c8f7312f854e53f5e8456af812d97dff3b92bd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f1c8f7312f854e53f5e8456af812d97dff3b92bd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f1c8f7312f854e53f5e8456af812d97dff3b92bd/comments",
    "author": {
      "login": "saahilshangle",
      "id": 10226886,
      "node_id": "MDQ6VXNlcjEwMjI2ODg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10226886?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saahilshangle",
      "html_url": "https://github.com/saahilshangle",
      "followers_url": "https://api.github.com/users/saahilshangle/followers",
      "following_url": "https://api.github.com/users/saahilshangle/following{/other_user}",
      "gists_url": "https://api.github.com/users/saahilshangle/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saahilshangle/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saahilshangle/subscriptions",
      "organizations_url": "https://api.github.com/users/saahilshangle/orgs",
      "repos_url": "https://api.github.com/users/saahilshangle/repos",
      "events_url": "https://api.github.com/users/saahilshangle/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saahilshangle/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b212fc28527a3b653021abfd4fe1088ebc0bcf35",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b212fc28527a3b653021abfd4fe1088ebc0bcf35",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b212fc28527a3b653021abfd4fe1088ebc0bcf35"
      }
    ],
    "stats": {
      "total": 224,
      "additions": 224,
      "deletions": 0
    },
    "files": [
      {
        "sha": "87d7100d263b50c88ea90451a601e813aebc0939",
        "filename": "test/functional/p2p_saahil.py",
        "status": "added",
        "additions": 224,
        "deletions": 0,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f1c8f7312f854e53f5e8456af812d97dff3b92bd/test/functional/p2p_saahil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f1c8f7312f854e53f5e8456af812d97dff3b92bd/test/functional/p2p_saahil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_saahil.py?ref=f1c8f7312f854e53f5e8456af812d97dff3b92bd",
        "patch": "@@ -0,0 +1,224 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"An example functional test\n+\n+The module-level docstring should include a high-level description of\n+what the test is doing. It's the first thing people see when they open\n+the file and should give the reader information about *what* the test\n+is testing and *how* it's being tested\n+\"\"\"\n+# Imports should be in PEP8 ordering (std library first, then third party\n+# libraries then local imports).\n+from collections import defaultdict\n+\n+# Avoid wildcard * imports\n+from test_framework.blocktools import (create_block, create_coinbase)\n+from test_framework.messages import CInv, MSG_BLOCK\n+from test_framework.mininode import (\n+    P2PInterface,\n+    mininode_lock,\n+    msg_block,\n+    msg_getdata,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    connect_nodes,\n+    wait_until,\n+)\n+\n+# P2PInterface is a class containing callbacks to be executed when a P2P\n+# message is received from the node-under-test. Subclass P2PInterface and\n+# override the on_*() methods if you need custom behaviour.\n+class BaseNode(P2PInterface):\n+    def __init__(self):\n+        \"\"\"Initialize the P2PInterface\n+\n+        Used to initialize custom properties for the Node that aren't\n+        included by default in the base class. Be aware that the P2PInterface\n+        base class already stores a counter for each P2P message type and the\n+        last received message of each type, which should be sufficient for the\n+        needs of most tests.\n+\n+        Call super().__init__() first for standard initialization and then\n+        initialize custom properties.\"\"\"\n+        super().__init__()\n+        # Stores a dictionary of all blocks received\n+        self.block_receive_map = defaultdict(int)\n+\n+    def on_block(self, message):\n+        \"\"\"Override the standard on_block callback\n+\n+        Store the hash of a received block in the dictionary.\"\"\"\n+        message.block.calc_sha256()\n+        self.block_receive_map[message.block.sha256] += 1\n+\n+    def on_inv(self, message):\n+        \"\"\"Override the standard on_inv callback\"\"\"\n+        pass\n+\n+def custom_function():\n+    \"\"\"Do some custom behaviour\n+\n+    If this function is more generally useful for other tests, consider\n+    moving it to a module in test_framework.\"\"\"\n+    # self.log.info(\"running custom_function\")  # Oops! Can't run self.log outside the BitcoinTestFramework\n+    pass\n+\n+\n+class ExampleTest(BitcoinTestFramework):\n+    # Each functional test is a subclass of the BitcoinTestFramework class.\n+\n+    # Override the set_test_params(), skip_test_if_missing_module(), add_options(), setup_chain(), setup_network()\n+    # and setup_nodes() methods to customize the test setup as required.\n+\n+    def set_test_params(self):\n+        \"\"\"Override test parameters for your individual test.\n+\n+        This method must be overridden and num_nodes must be explicitly set.\"\"\"\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+        # Use self.extra_args to change command-line arguments for the nodes\n+        self.extra_args = [[], [\"-logips\"], []]\n+\n+        # self.log.info(\"I've finished set_test_params\")  # Oops! Can't run self.log before run_test()\n+\n+    # Use skip_test_if_missing_module() to skip the test if your test requires certain modules to be present.\n+    # This test uses generate which requires wallet to be compiled\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    # Use add_options() to add specific command-line options for your test.\n+    # In practice this is not used very much, since the tests are mostly written\n+    # to be run in automated environments without command-line options.\n+    # def add_options()\n+    #     pass\n+\n+    # Use setup_chain() to customize the node data directories. In practice\n+    # this is not used very much since the default behaviour is almost always\n+    # fine\n+    # def setup_chain():\n+    #     pass\n+\n+    def setup_network(self):\n+        \"\"\"Setup the test network topology\n+\n+        Often you won't need to override this, since the standard network topology\n+        (linear: node0 <-> node1 <-> node2 <-> ...) is fine for most tests.\n+\n+        If you do override this method, remember to start the nodes, assign\n+        them to self.nodes, connect them and then sync.\"\"\"\n+\n+        self.setup_nodes()\n+\n+        # In this test, we're not connecting node2 to node0 or node1. Calls to\n+        # sync_all() should not include node2, since we're not expecting it to\n+        # sync.\n+        #connect_nodes(self.nodes[0], 1)\n+        #self.sync_all(self.nodes[0:2])\n+\n+    # Use setup_nodes() to customize the node start behaviour (for example if\n+    # you don't want to start all nodes at the start of the test).\n+    # def setup_nodes():\n+    #     pass\n+\n+    def custom_method(self):\n+        \"\"\"Do some custom behaviour for this test\n+\n+        Define it in a method here because you're going to use it repeatedly.\n+        If you think it's useful in general, consider moving it to the base\n+        BitcoinTestFramework class so other tests can use it.\"\"\"\n+\n+        self.log.info(\"Running custom_method\")\n+\n+    def run_test(self):\n+        \"\"\"Main test logic\"\"\"\n+\n+        # Create P2P connections will wait for a verack to make sure the connection is fully up\n+        self.nodes[0].add_p2p_connection(BaseNode())\n+\n+        # Generating a block on one of the nodes will get us out of IBD\n+        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n+        self.log.info(\"Number of blocks in node 0: \" + str(self.nodes[0].getblockcount()))\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+        \n+        self.log.info(\"Now sending block from one to the other\")\n+        connect_nodes(self.nodes[0], 1)\n+        self.sync_all(self.nodes[0:2])\n+\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+\n+        # # Notice above how we called an RPC by calling a method with the same\n+        # # name on the node object. Notice also how we used a keyword argument\n+        # # to specify a named RPC argument. Neither of those are defined on the\n+        # # node object. Instead there's some __getattr__() magic going on under\n+        # # the covers to dispatch unrecognised attribute calls to the RPC\n+        # # interface.\n+\n+        # # Logs are nice. Do plenty of them. They can be used in place of comments for\n+        # # breaking the test into sub-sections.\n+        # self.log.info(\"Starting test!\")\n+\n+        # self.log.info(\"Calling a custom function\")\n+        # custom_function()\n+\n+        # self.log.info(\"Calling a custom method\")\n+        # self.custom_method()\n+\n+        # self.log.info(\"Create some blocks\")\n+        # self.tip = int(self.nodes[0].getbestblockhash(), 16)\n+        # self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n+\n+        # height = self.nodes[0].getblockcount()\n+\n+        # for i in range(10):\n+        #     # Use the mininode and blocktools functionality to manually build a block\n+        #     # Calling the generate() rpc is easier, but this allows us to exactly\n+        #     # control the blocks and transactions.\n+        #     block = create_block(self.tip, create_coinbase(height+1), self.block_time)\n+        #     block.solve()\n+        #     block_message = msg_block(block)\n+        #     # Send message is used to send a P2P message to the node over our P2PInterface\n+        #     self.nodes[0].p2p.send_message(block_message)\n+        #     self.tip = block.sha256\n+        #     blocks.append(self.tip)\n+        #     self.block_time += 1\n+        #     height += 1\n+\n+        # self.log.info(\"Wait for node1 to reach current tip (height 11) using RPC\")\n+        # self.nodes[1].waitforblockheight(11)\n+\n+        # self.log.info(\"Connect node2 and node1\")\n+        # connect_nodes(self.nodes[1], 2)\n+\n+        # self.log.info(\"Wait for node2 to receive all the blocks from node1\")\n+        # self.sync_all()\n+\n+        # self.log.info(\"Add P2P connection to node2\")\n+        # self.nodes[0].disconnect_p2ps()\n+\n+        # self.nodes[2].add_p2p_connection(BaseNode())\n+\n+        # self.log.info(\"Test that node2 propagates all the blocks to us\")\n+\n+        # getdata_request = msg_getdata()\n+        # for block in blocks:\n+        #     getdata_request.inv.append(CInv(MSG_BLOCK, block))\n+        # self.nodes[2].p2p.send_message(getdata_request)\n+\n+        # # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n+        # # P2PInterface objects.\n+        # wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n+\n+        # self.log.info(\"Check that each block was received only once\")\n+        # # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving\n+        # # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking\n+        # # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n+        # with mininode_lock:\n+        #     for block in self.nodes[2].p2p.block_receive_map.values():\n+        #         assert_equal(block, 1)\n+\n+if __name__ == '__main__':\n+    ExampleTest().main()"
      }
    ]
  },
  {
    "sha": "5e9a537112f7387574787ff7d35b9c324e909cd5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZTlhNTM3MTEyZjczODc1NzQ3ODdmZjdkMzViOWMzMjRlOTA5Y2Q1",
    "commit": {
      "author": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-07T06:39:46Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:25Z"
      },
      "message": "Revert \"Attempted test where one node sends block to another\"\n\nThis reverts commit 55cf78aae878ac1e2a8ed5712877465a2e4a938c.",
      "tree": {
        "sha": "70e017472580280d2e330781c0250dad5ecadcc8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/70e017472580280d2e330781c0250dad5ecadcc8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5e9a537112f7387574787ff7d35b9c324e909cd5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e9a537112f7387574787ff7d35b9c324e909cd5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5e9a537112f7387574787ff7d35b9c324e909cd5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e9a537112f7387574787ff7d35b9c324e909cd5/comments",
    "author": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f1c8f7312f854e53f5e8456af812d97dff3b92bd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f1c8f7312f854e53f5e8456af812d97dff3b92bd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f1c8f7312f854e53f5e8456af812d97dff3b92bd"
      }
    ],
    "stats": {
      "total": 224,
      "additions": 0,
      "deletions": 224
    },
    "files": [
      {
        "sha": "87d7100d263b50c88ea90451a601e813aebc0939",
        "filename": "test/functional/p2p_saahil.py",
        "status": "removed",
        "additions": 0,
        "deletions": 224,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f1c8f7312f854e53f5e8456af812d97dff3b92bd/test/functional/p2p_saahil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f1c8f7312f854e53f5e8456af812d97dff3b92bd/test/functional/p2p_saahil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_saahil.py?ref=f1c8f7312f854e53f5e8456af812d97dff3b92bd",
        "patch": "@@ -1,224 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2017-2019 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"An example functional test\n-\n-The module-level docstring should include a high-level description of\n-what the test is doing. It's the first thing people see when they open\n-the file and should give the reader information about *what* the test\n-is testing and *how* it's being tested\n-\"\"\"\n-# Imports should be in PEP8 ordering (std library first, then third party\n-# libraries then local imports).\n-from collections import defaultdict\n-\n-# Avoid wildcard * imports\n-from test_framework.blocktools import (create_block, create_coinbase)\n-from test_framework.messages import CInv, MSG_BLOCK\n-from test_framework.mininode import (\n-    P2PInterface,\n-    mininode_lock,\n-    msg_block,\n-    msg_getdata,\n-)\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (\n-    assert_equal,\n-    connect_nodes,\n-    wait_until,\n-)\n-\n-# P2PInterface is a class containing callbacks to be executed when a P2P\n-# message is received from the node-under-test. Subclass P2PInterface and\n-# override the on_*() methods if you need custom behaviour.\n-class BaseNode(P2PInterface):\n-    def __init__(self):\n-        \"\"\"Initialize the P2PInterface\n-\n-        Used to initialize custom properties for the Node that aren't\n-        included by default in the base class. Be aware that the P2PInterface\n-        base class already stores a counter for each P2P message type and the\n-        last received message of each type, which should be sufficient for the\n-        needs of most tests.\n-\n-        Call super().__init__() first for standard initialization and then\n-        initialize custom properties.\"\"\"\n-        super().__init__()\n-        # Stores a dictionary of all blocks received\n-        self.block_receive_map = defaultdict(int)\n-\n-    def on_block(self, message):\n-        \"\"\"Override the standard on_block callback\n-\n-        Store the hash of a received block in the dictionary.\"\"\"\n-        message.block.calc_sha256()\n-        self.block_receive_map[message.block.sha256] += 1\n-\n-    def on_inv(self, message):\n-        \"\"\"Override the standard on_inv callback\"\"\"\n-        pass\n-\n-def custom_function():\n-    \"\"\"Do some custom behaviour\n-\n-    If this function is more generally useful for other tests, consider\n-    moving it to a module in test_framework.\"\"\"\n-    # self.log.info(\"running custom_function\")  # Oops! Can't run self.log outside the BitcoinTestFramework\n-    pass\n-\n-\n-class ExampleTest(BitcoinTestFramework):\n-    # Each functional test is a subclass of the BitcoinTestFramework class.\n-\n-    # Override the set_test_params(), skip_test_if_missing_module(), add_options(), setup_chain(), setup_network()\n-    # and setup_nodes() methods to customize the test setup as required.\n-\n-    def set_test_params(self):\n-        \"\"\"Override test parameters for your individual test.\n-\n-        This method must be overridden and num_nodes must be explicitly set.\"\"\"\n-        self.setup_clean_chain = True\n-        self.num_nodes = 3\n-        # Use self.extra_args to change command-line arguments for the nodes\n-        self.extra_args = [[], [\"-logips\"], []]\n-\n-        # self.log.info(\"I've finished set_test_params\")  # Oops! Can't run self.log before run_test()\n-\n-    # Use skip_test_if_missing_module() to skip the test if your test requires certain modules to be present.\n-    # This test uses generate which requires wallet to be compiled\n-    def skip_test_if_missing_module(self):\n-        self.skip_if_no_wallet()\n-\n-    # Use add_options() to add specific command-line options for your test.\n-    # In practice this is not used very much, since the tests are mostly written\n-    # to be run in automated environments without command-line options.\n-    # def add_options()\n-    #     pass\n-\n-    # Use setup_chain() to customize the node data directories. In practice\n-    # this is not used very much since the default behaviour is almost always\n-    # fine\n-    # def setup_chain():\n-    #     pass\n-\n-    def setup_network(self):\n-        \"\"\"Setup the test network topology\n-\n-        Often you won't need to override this, since the standard network topology\n-        (linear: node0 <-> node1 <-> node2 <-> ...) is fine for most tests.\n-\n-        If you do override this method, remember to start the nodes, assign\n-        them to self.nodes, connect them and then sync.\"\"\"\n-\n-        self.setup_nodes()\n-\n-        # In this test, we're not connecting node2 to node0 or node1. Calls to\n-        # sync_all() should not include node2, since we're not expecting it to\n-        # sync.\n-        #connect_nodes(self.nodes[0], 1)\n-        #self.sync_all(self.nodes[0:2])\n-\n-    # Use setup_nodes() to customize the node start behaviour (for example if\n-    # you don't want to start all nodes at the start of the test).\n-    # def setup_nodes():\n-    #     pass\n-\n-    def custom_method(self):\n-        \"\"\"Do some custom behaviour for this test\n-\n-        Define it in a method here because you're going to use it repeatedly.\n-        If you think it's useful in general, consider moving it to the base\n-        BitcoinTestFramework class so other tests can use it.\"\"\"\n-\n-        self.log.info(\"Running custom_method\")\n-\n-    def run_test(self):\n-        \"\"\"Main test logic\"\"\"\n-\n-        # Create P2P connections will wait for a verack to make sure the connection is fully up\n-        self.nodes[0].add_p2p_connection(BaseNode())\n-\n-        # Generating a block on one of the nodes will get us out of IBD\n-        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n-        self.log.info(\"Number of blocks in node 0: \" + str(self.nodes[0].getblockcount()))\n-        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n-        \n-        self.log.info(\"Now sending block from one to the other\")\n-        connect_nodes(self.nodes[0], 1)\n-        self.sync_all(self.nodes[0:2])\n-\n-        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n-\n-        # # Notice above how we called an RPC by calling a method with the same\n-        # # name on the node object. Notice also how we used a keyword argument\n-        # # to specify a named RPC argument. Neither of those are defined on the\n-        # # node object. Instead there's some __getattr__() magic going on under\n-        # # the covers to dispatch unrecognised attribute calls to the RPC\n-        # # interface.\n-\n-        # # Logs are nice. Do plenty of them. They can be used in place of comments for\n-        # # breaking the test into sub-sections.\n-        # self.log.info(\"Starting test!\")\n-\n-        # self.log.info(\"Calling a custom function\")\n-        # custom_function()\n-\n-        # self.log.info(\"Calling a custom method\")\n-        # self.custom_method()\n-\n-        # self.log.info(\"Create some blocks\")\n-        # self.tip = int(self.nodes[0].getbestblockhash(), 16)\n-        # self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n-\n-        # height = self.nodes[0].getblockcount()\n-\n-        # for i in range(10):\n-        #     # Use the mininode and blocktools functionality to manually build a block\n-        #     # Calling the generate() rpc is easier, but this allows us to exactly\n-        #     # control the blocks and transactions.\n-        #     block = create_block(self.tip, create_coinbase(height+1), self.block_time)\n-        #     block.solve()\n-        #     block_message = msg_block(block)\n-        #     # Send message is used to send a P2P message to the node over our P2PInterface\n-        #     self.nodes[0].p2p.send_message(block_message)\n-        #     self.tip = block.sha256\n-        #     blocks.append(self.tip)\n-        #     self.block_time += 1\n-        #     height += 1\n-\n-        # self.log.info(\"Wait for node1 to reach current tip (height 11) using RPC\")\n-        # self.nodes[1].waitforblockheight(11)\n-\n-        # self.log.info(\"Connect node2 and node1\")\n-        # connect_nodes(self.nodes[1], 2)\n-\n-        # self.log.info(\"Wait for node2 to receive all the blocks from node1\")\n-        # self.sync_all()\n-\n-        # self.log.info(\"Add P2P connection to node2\")\n-        # self.nodes[0].disconnect_p2ps()\n-\n-        # self.nodes[2].add_p2p_connection(BaseNode())\n-\n-        # self.log.info(\"Test that node2 propagates all the blocks to us\")\n-\n-        # getdata_request = msg_getdata()\n-        # for block in blocks:\n-        #     getdata_request.inv.append(CInv(MSG_BLOCK, block))\n-        # self.nodes[2].p2p.send_message(getdata_request)\n-\n-        # # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n-        # # P2PInterface objects.\n-        # wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n-\n-        # self.log.info(\"Check that each block was received only once\")\n-        # # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving\n-        # # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking\n-        # # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n-        # with mininode_lock:\n-        #     for block in self.nodes[2].p2p.block_receive_map.values():\n-        #         assert_equal(block, 1)\n-\n-if __name__ == '__main__':\n-    ExampleTest().main()"
      }
    ]
  },
  {
    "sha": "0ca6323a500931d17d12ace5214cf1351fe9904e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowY2E2MzIzYTUwMDkzMWQxN2QxMmFjZTUyMTRjZjEzNTFmZTk5MDRl",
    "commit": {
      "author": {
        "name": "Saahil Shangle",
        "email": "saahilshangle@gmail.com",
        "date": "2020-06-08T00:20:11Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:26Z"
      },
      "message": "Attempted test where one node sends block to another",
      "tree": {
        "sha": "2ec7ff20d96ed410de82b21801c81e4f2837df7b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2ec7ff20d96ed410de82b21801c81e4f2837df7b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0ca6323a500931d17d12ace5214cf1351fe9904e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0ca6323a500931d17d12ace5214cf1351fe9904e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0ca6323a500931d17d12ace5214cf1351fe9904e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0ca6323a500931d17d12ace5214cf1351fe9904e/comments",
    "author": {
      "login": "saahilshangle",
      "id": 10226886,
      "node_id": "MDQ6VXNlcjEwMjI2ODg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10226886?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saahilshangle",
      "html_url": "https://github.com/saahilshangle",
      "followers_url": "https://api.github.com/users/saahilshangle/followers",
      "following_url": "https://api.github.com/users/saahilshangle/following{/other_user}",
      "gists_url": "https://api.github.com/users/saahilshangle/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saahilshangle/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saahilshangle/subscriptions",
      "organizations_url": "https://api.github.com/users/saahilshangle/orgs",
      "repos_url": "https://api.github.com/users/saahilshangle/repos",
      "events_url": "https://api.github.com/users/saahilshangle/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saahilshangle/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5e9a537112f7387574787ff7d35b9c324e909cd5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e9a537112f7387574787ff7d35b9c324e909cd5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5e9a537112f7387574787ff7d35b9c324e909cd5"
      }
    ],
    "stats": {
      "total": 224,
      "additions": 224,
      "deletions": 0
    },
    "files": [
      {
        "sha": "87d7100d263b50c88ea90451a601e813aebc0939",
        "filename": "test/functional/p2p_saahil.py",
        "status": "added",
        "additions": 224,
        "deletions": 0,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ca6323a500931d17d12ace5214cf1351fe9904e/test/functional/p2p_saahil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ca6323a500931d17d12ace5214cf1351fe9904e/test/functional/p2p_saahil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_saahil.py?ref=0ca6323a500931d17d12ace5214cf1351fe9904e",
        "patch": "@@ -0,0 +1,224 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"An example functional test\n+\n+The module-level docstring should include a high-level description of\n+what the test is doing. It's the first thing people see when they open\n+the file and should give the reader information about *what* the test\n+is testing and *how* it's being tested\n+\"\"\"\n+# Imports should be in PEP8 ordering (std library first, then third party\n+# libraries then local imports).\n+from collections import defaultdict\n+\n+# Avoid wildcard * imports\n+from test_framework.blocktools import (create_block, create_coinbase)\n+from test_framework.messages import CInv, MSG_BLOCK\n+from test_framework.mininode import (\n+    P2PInterface,\n+    mininode_lock,\n+    msg_block,\n+    msg_getdata,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    connect_nodes,\n+    wait_until,\n+)\n+\n+# P2PInterface is a class containing callbacks to be executed when a P2P\n+# message is received from the node-under-test. Subclass P2PInterface and\n+# override the on_*() methods if you need custom behaviour.\n+class BaseNode(P2PInterface):\n+    def __init__(self):\n+        \"\"\"Initialize the P2PInterface\n+\n+        Used to initialize custom properties for the Node that aren't\n+        included by default in the base class. Be aware that the P2PInterface\n+        base class already stores a counter for each P2P message type and the\n+        last received message of each type, which should be sufficient for the\n+        needs of most tests.\n+\n+        Call super().__init__() first for standard initialization and then\n+        initialize custom properties.\"\"\"\n+        super().__init__()\n+        # Stores a dictionary of all blocks received\n+        self.block_receive_map = defaultdict(int)\n+\n+    def on_block(self, message):\n+        \"\"\"Override the standard on_block callback\n+\n+        Store the hash of a received block in the dictionary.\"\"\"\n+        message.block.calc_sha256()\n+        self.block_receive_map[message.block.sha256] += 1\n+\n+    def on_inv(self, message):\n+        \"\"\"Override the standard on_inv callback\"\"\"\n+        pass\n+\n+def custom_function():\n+    \"\"\"Do some custom behaviour\n+\n+    If this function is more generally useful for other tests, consider\n+    moving it to a module in test_framework.\"\"\"\n+    # self.log.info(\"running custom_function\")  # Oops! Can't run self.log outside the BitcoinTestFramework\n+    pass\n+\n+\n+class ExampleTest(BitcoinTestFramework):\n+    # Each functional test is a subclass of the BitcoinTestFramework class.\n+\n+    # Override the set_test_params(), skip_test_if_missing_module(), add_options(), setup_chain(), setup_network()\n+    # and setup_nodes() methods to customize the test setup as required.\n+\n+    def set_test_params(self):\n+        \"\"\"Override test parameters for your individual test.\n+\n+        This method must be overridden and num_nodes must be explicitly set.\"\"\"\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+        # Use self.extra_args to change command-line arguments for the nodes\n+        self.extra_args = [[], [\"-logips\"], []]\n+\n+        # self.log.info(\"I've finished set_test_params\")  # Oops! Can't run self.log before run_test()\n+\n+    # Use skip_test_if_missing_module() to skip the test if your test requires certain modules to be present.\n+    # This test uses generate which requires wallet to be compiled\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    # Use add_options() to add specific command-line options for your test.\n+    # In practice this is not used very much, since the tests are mostly written\n+    # to be run in automated environments without command-line options.\n+    # def add_options()\n+    #     pass\n+\n+    # Use setup_chain() to customize the node data directories. In practice\n+    # this is not used very much since the default behaviour is almost always\n+    # fine\n+    # def setup_chain():\n+    #     pass\n+\n+    def setup_network(self):\n+        \"\"\"Setup the test network topology\n+\n+        Often you won't need to override this, since the standard network topology\n+        (linear: node0 <-> node1 <-> node2 <-> ...) is fine for most tests.\n+\n+        If you do override this method, remember to start the nodes, assign\n+        them to self.nodes, connect them and then sync.\"\"\"\n+\n+        self.setup_nodes()\n+\n+        # In this test, we're not connecting node2 to node0 or node1. Calls to\n+        # sync_all() should not include node2, since we're not expecting it to\n+        # sync.\n+        #connect_nodes(self.nodes[0], 1)\n+        #self.sync_all(self.nodes[0:2])\n+\n+    # Use setup_nodes() to customize the node start behaviour (for example if\n+    # you don't want to start all nodes at the start of the test).\n+    # def setup_nodes():\n+    #     pass\n+\n+    def custom_method(self):\n+        \"\"\"Do some custom behaviour for this test\n+\n+        Define it in a method here because you're going to use it repeatedly.\n+        If you think it's useful in general, consider moving it to the base\n+        BitcoinTestFramework class so other tests can use it.\"\"\"\n+\n+        self.log.info(\"Running custom_method\")\n+\n+    def run_test(self):\n+        \"\"\"Main test logic\"\"\"\n+\n+        # Create P2P connections will wait for a verack to make sure the connection is fully up\n+        self.nodes[0].add_p2p_connection(BaseNode())\n+\n+        # Generating a block on one of the nodes will get us out of IBD\n+        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n+        self.log.info(\"Number of blocks in node 0: \" + str(self.nodes[0].getblockcount()))\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+        \n+        self.log.info(\"Now sending block from one to the other\")\n+        connect_nodes(self.nodes[0], 1)\n+        self.sync_all(self.nodes[0:2])\n+\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+\n+        # # Notice above how we called an RPC by calling a method with the same\n+        # # name on the node object. Notice also how we used a keyword argument\n+        # # to specify a named RPC argument. Neither of those are defined on the\n+        # # node object. Instead there's some __getattr__() magic going on under\n+        # # the covers to dispatch unrecognised attribute calls to the RPC\n+        # # interface.\n+\n+        # # Logs are nice. Do plenty of them. They can be used in place of comments for\n+        # # breaking the test into sub-sections.\n+        # self.log.info(\"Starting test!\")\n+\n+        # self.log.info(\"Calling a custom function\")\n+        # custom_function()\n+\n+        # self.log.info(\"Calling a custom method\")\n+        # self.custom_method()\n+\n+        # self.log.info(\"Create some blocks\")\n+        # self.tip = int(self.nodes[0].getbestblockhash(), 16)\n+        # self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n+\n+        # height = self.nodes[0].getblockcount()\n+\n+        # for i in range(10):\n+        #     # Use the mininode and blocktools functionality to manually build a block\n+        #     # Calling the generate() rpc is easier, but this allows us to exactly\n+        #     # control the blocks and transactions.\n+        #     block = create_block(self.tip, create_coinbase(height+1), self.block_time)\n+        #     block.solve()\n+        #     block_message = msg_block(block)\n+        #     # Send message is used to send a P2P message to the node over our P2PInterface\n+        #     self.nodes[0].p2p.send_message(block_message)\n+        #     self.tip = block.sha256\n+        #     blocks.append(self.tip)\n+        #     self.block_time += 1\n+        #     height += 1\n+\n+        # self.log.info(\"Wait for node1 to reach current tip (height 11) using RPC\")\n+        # self.nodes[1].waitforblockheight(11)\n+\n+        # self.log.info(\"Connect node2 and node1\")\n+        # connect_nodes(self.nodes[1], 2)\n+\n+        # self.log.info(\"Wait for node2 to receive all the blocks from node1\")\n+        # self.sync_all()\n+\n+        # self.log.info(\"Add P2P connection to node2\")\n+        # self.nodes[0].disconnect_p2ps()\n+\n+        # self.nodes[2].add_p2p_connection(BaseNode())\n+\n+        # self.log.info(\"Test that node2 propagates all the blocks to us\")\n+\n+        # getdata_request = msg_getdata()\n+        # for block in blocks:\n+        #     getdata_request.inv.append(CInv(MSG_BLOCK, block))\n+        # self.nodes[2].p2p.send_message(getdata_request)\n+\n+        # # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n+        # # P2PInterface objects.\n+        # wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n+\n+        # self.log.info(\"Check that each block was received only once\")\n+        # # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving\n+        # # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking\n+        # # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n+        # with mininode_lock:\n+        #     for block in self.nodes[2].p2p.block_receive_map.values():\n+        #         assert_equal(block, 1)\n+\n+if __name__ == '__main__':\n+    ExampleTest().main()"
      }
    ]
  },
  {
    "sha": "0c54937c3bbad350560d29c2b9dc17d5c2e8aeb5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYzU0OTM3YzNiYmFkMzUwNTYwZDI5YzJiOWRjMTdkNWMyZThhZWI1",
    "commit": {
      "author": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-07T06:39:46Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:26Z"
      },
      "message": "Revert \"Attempted test where one node sends block to another\"\n\nThis reverts commit 55cf78aae878ac1e2a8ed5712877465a2e4a938c.",
      "tree": {
        "sha": "70e017472580280d2e330781c0250dad5ecadcc8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/70e017472580280d2e330781c0250dad5ecadcc8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0c54937c3bbad350560d29c2b9dc17d5c2e8aeb5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0c54937c3bbad350560d29c2b9dc17d5c2e8aeb5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0c54937c3bbad350560d29c2b9dc17d5c2e8aeb5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0c54937c3bbad350560d29c2b9dc17d5c2e8aeb5/comments",
    "author": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0ca6323a500931d17d12ace5214cf1351fe9904e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0ca6323a500931d17d12ace5214cf1351fe9904e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0ca6323a500931d17d12ace5214cf1351fe9904e"
      }
    ],
    "stats": {
      "total": 224,
      "additions": 0,
      "deletions": 224
    },
    "files": [
      {
        "sha": "87d7100d263b50c88ea90451a601e813aebc0939",
        "filename": "test/functional/p2p_saahil.py",
        "status": "removed",
        "additions": 0,
        "deletions": 224,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ca6323a500931d17d12ace5214cf1351fe9904e/test/functional/p2p_saahil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ca6323a500931d17d12ace5214cf1351fe9904e/test/functional/p2p_saahil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_saahil.py?ref=0ca6323a500931d17d12ace5214cf1351fe9904e",
        "patch": "@@ -1,224 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2017-2019 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"An example functional test\n-\n-The module-level docstring should include a high-level description of\n-what the test is doing. It's the first thing people see when they open\n-the file and should give the reader information about *what* the test\n-is testing and *how* it's being tested\n-\"\"\"\n-# Imports should be in PEP8 ordering (std library first, then third party\n-# libraries then local imports).\n-from collections import defaultdict\n-\n-# Avoid wildcard * imports\n-from test_framework.blocktools import (create_block, create_coinbase)\n-from test_framework.messages import CInv, MSG_BLOCK\n-from test_framework.mininode import (\n-    P2PInterface,\n-    mininode_lock,\n-    msg_block,\n-    msg_getdata,\n-)\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (\n-    assert_equal,\n-    connect_nodes,\n-    wait_until,\n-)\n-\n-# P2PInterface is a class containing callbacks to be executed when a P2P\n-# message is received from the node-under-test. Subclass P2PInterface and\n-# override the on_*() methods if you need custom behaviour.\n-class BaseNode(P2PInterface):\n-    def __init__(self):\n-        \"\"\"Initialize the P2PInterface\n-\n-        Used to initialize custom properties for the Node that aren't\n-        included by default in the base class. Be aware that the P2PInterface\n-        base class already stores a counter for each P2P message type and the\n-        last received message of each type, which should be sufficient for the\n-        needs of most tests.\n-\n-        Call super().__init__() first for standard initialization and then\n-        initialize custom properties.\"\"\"\n-        super().__init__()\n-        # Stores a dictionary of all blocks received\n-        self.block_receive_map = defaultdict(int)\n-\n-    def on_block(self, message):\n-        \"\"\"Override the standard on_block callback\n-\n-        Store the hash of a received block in the dictionary.\"\"\"\n-        message.block.calc_sha256()\n-        self.block_receive_map[message.block.sha256] += 1\n-\n-    def on_inv(self, message):\n-        \"\"\"Override the standard on_inv callback\"\"\"\n-        pass\n-\n-def custom_function():\n-    \"\"\"Do some custom behaviour\n-\n-    If this function is more generally useful for other tests, consider\n-    moving it to a module in test_framework.\"\"\"\n-    # self.log.info(\"running custom_function\")  # Oops! Can't run self.log outside the BitcoinTestFramework\n-    pass\n-\n-\n-class ExampleTest(BitcoinTestFramework):\n-    # Each functional test is a subclass of the BitcoinTestFramework class.\n-\n-    # Override the set_test_params(), skip_test_if_missing_module(), add_options(), setup_chain(), setup_network()\n-    # and setup_nodes() methods to customize the test setup as required.\n-\n-    def set_test_params(self):\n-        \"\"\"Override test parameters for your individual test.\n-\n-        This method must be overridden and num_nodes must be explicitly set.\"\"\"\n-        self.setup_clean_chain = True\n-        self.num_nodes = 3\n-        # Use self.extra_args to change command-line arguments for the nodes\n-        self.extra_args = [[], [\"-logips\"], []]\n-\n-        # self.log.info(\"I've finished set_test_params\")  # Oops! Can't run self.log before run_test()\n-\n-    # Use skip_test_if_missing_module() to skip the test if your test requires certain modules to be present.\n-    # This test uses generate which requires wallet to be compiled\n-    def skip_test_if_missing_module(self):\n-        self.skip_if_no_wallet()\n-\n-    # Use add_options() to add specific command-line options for your test.\n-    # In practice this is not used very much, since the tests are mostly written\n-    # to be run in automated environments without command-line options.\n-    # def add_options()\n-    #     pass\n-\n-    # Use setup_chain() to customize the node data directories. In practice\n-    # this is not used very much since the default behaviour is almost always\n-    # fine\n-    # def setup_chain():\n-    #     pass\n-\n-    def setup_network(self):\n-        \"\"\"Setup the test network topology\n-\n-        Often you won't need to override this, since the standard network topology\n-        (linear: node0 <-> node1 <-> node2 <-> ...) is fine for most tests.\n-\n-        If you do override this method, remember to start the nodes, assign\n-        them to self.nodes, connect them and then sync.\"\"\"\n-\n-        self.setup_nodes()\n-\n-        # In this test, we're not connecting node2 to node0 or node1. Calls to\n-        # sync_all() should not include node2, since we're not expecting it to\n-        # sync.\n-        #connect_nodes(self.nodes[0], 1)\n-        #self.sync_all(self.nodes[0:2])\n-\n-    # Use setup_nodes() to customize the node start behaviour (for example if\n-    # you don't want to start all nodes at the start of the test).\n-    # def setup_nodes():\n-    #     pass\n-\n-    def custom_method(self):\n-        \"\"\"Do some custom behaviour for this test\n-\n-        Define it in a method here because you're going to use it repeatedly.\n-        If you think it's useful in general, consider moving it to the base\n-        BitcoinTestFramework class so other tests can use it.\"\"\"\n-\n-        self.log.info(\"Running custom_method\")\n-\n-    def run_test(self):\n-        \"\"\"Main test logic\"\"\"\n-\n-        # Create P2P connections will wait for a verack to make sure the connection is fully up\n-        self.nodes[0].add_p2p_connection(BaseNode())\n-\n-        # Generating a block on one of the nodes will get us out of IBD\n-        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n-        self.log.info(\"Number of blocks in node 0: \" + str(self.nodes[0].getblockcount()))\n-        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n-        \n-        self.log.info(\"Now sending block from one to the other\")\n-        connect_nodes(self.nodes[0], 1)\n-        self.sync_all(self.nodes[0:2])\n-\n-        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n-\n-        # # Notice above how we called an RPC by calling a method with the same\n-        # # name on the node object. Notice also how we used a keyword argument\n-        # # to specify a named RPC argument. Neither of those are defined on the\n-        # # node object. Instead there's some __getattr__() magic going on under\n-        # # the covers to dispatch unrecognised attribute calls to the RPC\n-        # # interface.\n-\n-        # # Logs are nice. Do plenty of them. They can be used in place of comments for\n-        # # breaking the test into sub-sections.\n-        # self.log.info(\"Starting test!\")\n-\n-        # self.log.info(\"Calling a custom function\")\n-        # custom_function()\n-\n-        # self.log.info(\"Calling a custom method\")\n-        # self.custom_method()\n-\n-        # self.log.info(\"Create some blocks\")\n-        # self.tip = int(self.nodes[0].getbestblockhash(), 16)\n-        # self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n-\n-        # height = self.nodes[0].getblockcount()\n-\n-        # for i in range(10):\n-        #     # Use the mininode and blocktools functionality to manually build a block\n-        #     # Calling the generate() rpc is easier, but this allows us to exactly\n-        #     # control the blocks and transactions.\n-        #     block = create_block(self.tip, create_coinbase(height+1), self.block_time)\n-        #     block.solve()\n-        #     block_message = msg_block(block)\n-        #     # Send message is used to send a P2P message to the node over our P2PInterface\n-        #     self.nodes[0].p2p.send_message(block_message)\n-        #     self.tip = block.sha256\n-        #     blocks.append(self.tip)\n-        #     self.block_time += 1\n-        #     height += 1\n-\n-        # self.log.info(\"Wait for node1 to reach current tip (height 11) using RPC\")\n-        # self.nodes[1].waitforblockheight(11)\n-\n-        # self.log.info(\"Connect node2 and node1\")\n-        # connect_nodes(self.nodes[1], 2)\n-\n-        # self.log.info(\"Wait for node2 to receive all the blocks from node1\")\n-        # self.sync_all()\n-\n-        # self.log.info(\"Add P2P connection to node2\")\n-        # self.nodes[0].disconnect_p2ps()\n-\n-        # self.nodes[2].add_p2p_connection(BaseNode())\n-\n-        # self.log.info(\"Test that node2 propagates all the blocks to us\")\n-\n-        # getdata_request = msg_getdata()\n-        # for block in blocks:\n-        #     getdata_request.inv.append(CInv(MSG_BLOCK, block))\n-        # self.nodes[2].p2p.send_message(getdata_request)\n-\n-        # # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n-        # # P2PInterface objects.\n-        # wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n-\n-        # self.log.info(\"Check that each block was received only once\")\n-        # # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving\n-        # # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking\n-        # # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n-        # with mininode_lock:\n-        #     for block in self.nodes[2].p2p.block_receive_map.values():\n-        #         assert_equal(block, 1)\n-\n-if __name__ == '__main__':\n-    ExampleTest().main()"
      }
    ]
  },
  {
    "sha": "c49cc6aa92023f39176790e7153e4248098a2868",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNDljYzZhYTkyMDIzZjM5MTc2NzkwZTcxNTNlNDI0ODA5OGEyODY4",
    "commit": {
      "author": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-09T07:07:31Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:26Z"
      },
      "message": "Revert \"[test] test send* wallet rpcs with verbose=True\"\n\nThis reverts commit d8da095378c307052610119ea207a929ba441685.",
      "tree": {
        "sha": "fcb40fc82cc32a1b1338d7ffc0cd8d8b505366fb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fcb40fc82cc32a1b1338d7ffc0cd8d8b505366fb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c49cc6aa92023f39176790e7153e4248098a2868",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c49cc6aa92023f39176790e7153e4248098a2868",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c49cc6aa92023f39176790e7153e4248098a2868",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c49cc6aa92023f39176790e7153e4248098a2868/comments",
    "author": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0c54937c3bbad350560d29c2b9dc17d5c2e8aeb5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0c54937c3bbad350560d29c2b9dc17d5c2e8aeb5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0c54937c3bbad350560d29c2b9dc17d5c2e8aeb5"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 0,
      "deletions": 9
    },
    "files": [
      {
        "sha": "896236227688f3a3b1dba5ea64aa7d5f5549961d",
        "filename": "test/functional/wallet_basic.py",
        "status": "modified",
        "additions": 0,
        "deletions": 9,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c49cc6aa92023f39176790e7153e4248098a2868/test/functional/wallet_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c49cc6aa92023f39176790e7153e4248098a2868/test/functional/wallet_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_basic.py?ref=c49cc6aa92023f39176790e7153e4248098a2868",
        "patch": "@@ -650,15 +650,6 @@ def run_test(self):\n         assert_array_result(tx[\"details\"], {\"category\": \"receive\"}, expected_receive_vout)\n         assert_equal(tx[verbose_field], self.nodes[0].decoderawtransaction(tx[\"hex\"]))\n \n-        self.log.info(\"Testing Fee Reason\")\n-        #testing send_rpc_verbose sendtoaddress\n-        address = self.nodes[0].getnewaddress(\"test\") \n-        txid_feeReason_one = self.nodes[2].sendtoaddress(address = address, amount = 10, verbose = True)\n-        assert_equal(str(txid_feeReason_one[\"Fee Reason\"]), \"Fallback fee\")\n-\n-        #testing send_rpc_verbose sendtoaddress\n-        txid_feeReason_two = self.nodes[2].sendmany(dummy = '', amounts = {address: 10}, verbose = True) \n-        assert_equal(str(txid_feeReason_two[\"Fee Reason\"]), \"Fallback fee\")\n \n if __name__ == '__main__':\n     WalletTest().main()"
      }
    ]
  },
  {
    "sha": "b19cf0569196f1c7c17cad33649a5596d569fb8c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMTljZjA1NjkxOTZmMWM3YzE3Y2FkMzM2NDlhNTU5NmQ1NjlmYjhj",
    "commit": {
      "author": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:44:38Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:26Z"
      },
      "message": "Fixed Master Merge Conflict",
      "tree": {
        "sha": "d4a67c35d418acb6930aa043c329c9578b283619",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d4a67c35d418acb6930aa043c329c9578b283619"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b19cf0569196f1c7c17cad33649a5596d569fb8c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b19cf0569196f1c7c17cad33649a5596d569fb8c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b19cf0569196f1c7c17cad33649a5596d569fb8c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b19cf0569196f1c7c17cad33649a5596d569fb8c/comments",
    "author": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c49cc6aa92023f39176790e7153e4248098a2868",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c49cc6aa92023f39176790e7153e4248098a2868",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c49cc6aa92023f39176790e7153e4248098a2868"
      }
    ],
    "stats": {
      "total": 102,
      "additions": 9,
      "deletions": 93
    },
    "files": [
      {
        "sha": "fd621dba31d507706bc777cf598583d6f8e4344e",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 23,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b19cf0569196f1c7c17cad33649a5596d569fb8c/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b19cf0569196f1c7c17cad33649a5596d569fb8c/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=b19cf0569196f1c7c17cad33649a5596d569fb8c",
        "patch": "@@ -1011,40 +1011,18 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     // on all platforms.  Set it again here just to be sure.\n     SetSocketNoDelay(hSocket);\n \n-<<<<<<< HEAD\n-<<<<<<< HEAD\n     // Don't accept connections from banned peers.\n     bool banned = m_banman->IsBanned(addr);\n     if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && banned)\n-=======\n-    int bannedlevel = m_banman ? m_banman->IsBannedLevel(addr) : 0;\n-\n-    // Don't accept connections from banned peers.\n-    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && bannedlevel == 2)\n->>>>>>> Replace automatic bans with discouragement filter\n-=======\n-    // Don't accept connections from banned peers.\n-    bool banned = m_banman->IsBanned(addr);\n-    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && banned)\n->>>>>>> Clean up separated ban/discourage interface\n     {\n         LogPrint(BCLog::NET, \"connection from %s dropped (banned)\\n\", addr.ToString());\n         CloseSocket(hSocket);\n         return;\n     }\n \n     // Only accept connections from discouraged peers if our inbound slots aren't (almost) full.\n-<<<<<<< HEAD\n-<<<<<<< HEAD\n-    bool discouraged = m_banman->IsDiscouraged(addr);\n-    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && nInbound + 1 >= nMaxInbound && discouraged)\n-=======\n-    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && nInbound + 1 >= nMaxInbound && bannedlevel >= 1)\n->>>>>>> Replace automatic bans with discouragement filter\n-=======\n     bool discouraged = m_banman->IsDiscouraged(addr);\n-    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && nInbound + 1 >= nMaxInbound && discouraged)\n->>>>>>> Clean up separated ban/discourage interface\n+    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && nInbound + 1 >= nMaxInbound && discouraged) \n     {\n         LogPrint(BCLog::NET, \"connection from %s dropped (discouraged)\\n\", addr.ToString());\n         CloseSocket(hSocket);"
      },
      {
        "sha": "532539edf6dc074c1182d897464d4891b09ee4dd",
        "filename": "src/net_permissions.h",
        "status": "modified",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b19cf0569196f1c7c17cad33649a5596d569fb8c/src/net_permissions.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b19cf0569196f1c7c17cad33649a5596d569fb8c/src/net_permissions.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_permissions.h?ref=b19cf0569196f1c7c17cad33649a5596d569fb8c",
        "patch": "@@ -23,15 +23,8 @@ enum NetPermissionFlags {\n     // Always relay transactions from this peer, even if already in mempool\n     // Keep parameter interaction: forcerelay implies relay\n     PF_FORCERELAY = (1U << 2) | PF_RELAY,\n-<<<<<<< HEAD\n-    // Allow getheaders during IBD and block-download after maxuploadtarget limit\n-    PF_DOWNLOAD = (1U << 6),\n-    // Can't be banned/disconnected/discouraged for misbehavior\n-    PF_NOBAN = (1U << 4) | PF_DOWNLOAD,\n-=======\n     // Can't be banned/disconnected/discouraged for misbehavior\n     PF_NOBAN = (1U << 4),\n->>>>>>> Clean up separated ban/discourage interface\n     // Can query the mempool\n     PF_MEMPOOL = (1U << 5),\n "
      },
      {
        "sha": "5ce5e79327cc5bc42317639b3b54935fbaab42e8",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 28,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b19cf0569196f1c7c17cad33649a5596d569fb8c/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b19cf0569196f1c7c17cad33649a5596d569fb8c/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b19cf0569196f1c7c17cad33649a5596d569fb8c",
        "patch": "@@ -1033,15 +1033,7 @@ void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIV\n     if (state->nMisbehavior >= banscore && state->nMisbehavior - howmuch < banscore)\n     {\n         LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d) DISCOURAGE THRESHOLD EXCEEDED%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n-<<<<<<< HEAD\n-<<<<<<< HEAD\n-        state->m_should_discourage = true;\n-=======\n-        state->fShouldBan = true;\n->>>>>>> Replace automatic bans with discouragement filter\n-=======\n-        state->m_should_discourage = true;\n->>>>>>> Clean up separated ban/discourage interface\n+        state->m_should_discourage = true; \n     } else\n         LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d)%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n }\n@@ -3582,28 +3574,12 @@ bool PeerLogicValidation::MaybeDiscourageAndDisconnect(CNode& pnode)\n             LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pnode.addr.ToString());\n         } else if (pnode.m_manual_connection) {\n             LogPrintf(\"Warning: not punishing manually-connected peer %s!\\n\", pnode.addr.ToString());\n-<<<<<<< HEAD\n-<<<<<<< HEAD\n-        } else if (pnode.addr.IsLocal()) {\n-=======\n-        else if (pnode.addr.IsLocal()) {\n->>>>>>> Replace automatic bans with discouragement filter\n-=======\n-        } else if (pnode.addr.IsLocal()) {\n->>>>>>> Clean up separated ban/discourage interface\n+        } else if (pnode.addr.IsLocal()) { \n             // Disconnect but don't discourage this local node\n             LogPrintf(\"Warning: disconnecting but not discouraging local peer %s!\\n\", pnode.addr.ToString());\n             pnode.fDisconnect = true;\n-        } else {\n-<<<<<<< HEAD\n-<<<<<<< HEAD\n-            // Disconnect and discourage all nodes sharing the address\n-=======\n-            // Disconnect and ban all nodes sharing the address\n->>>>>>> Replace automatic bans with discouragement filter\n-=======\n-            // Disconnect and discourage all nodes sharing the address\n->>>>>>> Clean up separated ban/discourage interface\n+        } else {  \n+            // Disconnect and discourage all nodes sharing the address \n             LogPrintf(\"Disconnecting and discouraging peer %s!\\n\", pnode.addr.ToString());\n             if (m_banman) {\n                 m_banman->Discourage(pnode.addr);"
      },
      {
        "sha": "35f1accb5eaf3c90451cf8e9c28b9e00a6cf206a",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 17,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b19cf0569196f1c7c17cad33649a5596d569fb8c/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b19cf0569196f1c7c17cad33649a5596d569fb8c/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=b19cf0569196f1c7c17cad33649a5596d569fb8c",
        "patch": "@@ -976,15 +976,7 @@ static UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n                 \"\\nReturns statistics about the unspent transaction output set.\\n\"\n                 \"Note this call may take some time.\\n\",\n                 {\n-<<<<<<< HEAD\n-<<<<<<< HEAD\n                     {\"hash_type\", RPCArg::Type::STR, /* default */ \"hash_serialized_2\", \"Which UTXO set hash should be calculated. Options: 'hash_serialized_2' (the legacy algorithm), 'none'.\"},\n-=======\n-                    {\"hash_type\", RPCArg::Type::STR, /* default */ \"hash_serialized_2\", \"Which UTXO set hash should be calculated. Options: 'hash_serialized_2' (the legacy algorithm).\"},\n->>>>>>> rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)\n-=======\n-                    {\"hash_type\", RPCArg::Type::STR, /* default */ \"hash_serialized_2\", \"Which UTXO set hash should be calculated. Options: 'hash_serialized_2' (the legacy algorithm), 'none'.\"},\n->>>>>>> rpc: Add hash_type NONE to gettxoutsetinfo\n                 },\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"\",\n@@ -2331,15 +2323,7 @@ UniValue dumptxoutset(const JSONRPCRequest& request)\n \n         ::ChainstateActive().ForceFlushStateToDisk();\n \n-<<<<<<< HEAD\n-<<<<<<< HEAD\n-        if (!GetUTXOStats(&::ChainstateActive().CoinsDB(), stats, CoinStatsHashType::NONE, RpcInterruptionPoint)) {\n-=======\n-        if (!GetUTXOStats(&::ChainstateActive().CoinsDB(), stats, CoinStatsHashType::HASH_SERIALIZED, RpcInterruptionPoint)) {\n->>>>>>> rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)\n-=======\n-        if (!GetUTXOStats(&::ChainstateActive().CoinsDB(), stats, CoinStatsHashType::NONE, RpcInterruptionPoint)) {\n->>>>>>> rpc: Add hash_type NONE to gettxoutsetinfo\n+        if (!GetUTXOStats(&::ChainstateActive().CoinsDB(), stats, CoinStatsHashType::NONE, RpcInterruptionPoint)) {  \n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Unable to read UTXO set\");\n         }\n "
      },
      {
        "sha": "e3dab84a974d1975ea08fc420741e5887b6130de",
        "filename": "src/rpc/util.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 9,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b19cf0569196f1c7c17cad33649a5596d569fb8c/src/rpc/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b19cf0569196f1c7c17cad33649a5596d569fb8c/src/rpc/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.cpp?ref=b19cf0569196f1c7c17cad33649a5596d569fb8c",
        "patch": "@@ -122,16 +122,8 @@ CoinStatsHashType ParseHashType(const UniValue& param, const CoinStatsHashType d\n \n         if (hash_type_input == \"hash_serialized_2\") {\n             return CoinStatsHashType::HASH_SERIALIZED;\n-<<<<<<< HEAD\n-<<<<<<< HEAD\n         } else if (hash_type_input == \"none\") {\n-            return CoinStatsHashType::NONE;\n-=======\n->>>>>>> rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)\n-=======\n-        } else if (hash_type_input == \"none\") {\n-            return CoinStatsHashType::NONE;\n->>>>>>> rpc: Add hash_type NONE to gettxoutsetinfo\n+            return CoinStatsHashType::NONE; \n         } else {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"%d is not a valid hash_type\", hash_type_input));\n         }"
      },
      {
        "sha": "0eda8734d714f98079f080296e7f6339e89265e4",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 9,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b19cf0569196f1c7c17cad33649a5596d569fb8c/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b19cf0569196f1c7c17cad33649a5596d569fb8c/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=b19cf0569196f1c7c17cad33649a5596d569fb8c",
        "patch": "@@ -344,15 +344,8 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n         LOCK2(cs_main, dummyNode.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode));\n     }\n-<<<<<<< HEAD\n-<<<<<<< HEAD\n-    BOOST_CHECK(banman->IsDiscouraged(addr));\n-=======\n-    BOOST_CHECK(banman->IsBanned(addr));\n->>>>>>> Replace automatic bans with discouragement filter\n-=======\n-    BOOST_CHECK(banman->IsDiscouraged(addr));\n->>>>>>> Clean up separated ban/discourage interface\n+\n+    BOOST_CHECK(banman->IsDiscouraged(addr)); \n \n     bool dummy;\n     peerLogic->FinalizeNode(dummyNode.GetId(), dummy);"
      }
    ]
  },
  {
    "sha": "080e8fceeb050e61c2c1f13bb7e3e87cf391836b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowODBlOGZjZWViMDUwZTYxYzJjMWYxM2JiN2UzZTg3Y2YzOTE4MzZi",
    "commit": {
      "author": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-06T07:37:12Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:27Z"
      },
      "message": "[test] test send* wallet rpcs with verbose=True",
      "tree": {
        "sha": "595bdd940d5262a4789680b9ac2764c7431f7ab4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/595bdd940d5262a4789680b9ac2764c7431f7ab4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/080e8fceeb050e61c2c1f13bb7e3e87cf391836b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/080e8fceeb050e61c2c1f13bb7e3e87cf391836b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/080e8fceeb050e61c2c1f13bb7e3e87cf391836b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/080e8fceeb050e61c2c1f13bb7e3e87cf391836b/comments",
    "author": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b19cf0569196f1c7c17cad33649a5596d569fb8c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b19cf0569196f1c7c17cad33649a5596d569fb8c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b19cf0569196f1c7c17cad33649a5596d569fb8c"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 9,
      "deletions": 0
    },
    "files": [
      {
        "sha": "9554cd9538c4c7a9f2cfdb83615ce57bead4d87e",
        "filename": "test/functional/wallet_basic.py",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/080e8fceeb050e61c2c1f13bb7e3e87cf391836b/test/functional/wallet_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/080e8fceeb050e61c2c1f13bb7e3e87cf391836b/test/functional/wallet_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_basic.py?ref=080e8fceeb050e61c2c1f13bb7e3e87cf391836b",
        "patch": "@@ -650,6 +650,15 @@ def run_test(self):\n         assert_array_result(tx[\"details\"], {\"category\": \"receive\"}, expected_receive_vout)\n         assert_equal(tx[verbose_field], self.nodes[0].decoderawtransaction(tx[\"hex\"]))\n \n+        self.log.info(\"Testing Fee Reason\")\n+        #testing send_rpc_verbose sendtoaddress\n+        address = self.nodes[0].getnewaddress(\"test\") \n+        txid_feeReason_one = self.nodes[2].sendtoaddress(address = address, amount = 10, verbose = True)\n+        assert_equal(str(txid_feeReason_one[\"Fee Reason\"]), \"Fallback fee\")\n+\n+        #testing send_rpc_verbose sendtoaddress\n+        txid_feeReason_two = self.nodes[2].sendmany(dummy = '', amounts = {address: 10}, verbose = True) \n+        assert_equal(str(txid_feeReason_two[\"Fee Reason\"]), \"Fallback fee\")\n \n if __name__ == '__main__':\n     WalletTest().main()"
      }
    ]
  },
  {
    "sha": "89725bc07379f1cffd2fb9c8041259f3b5bf23f1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4OTcyNWJjMDczNzlmMWNmZmQyZmI5YzgwNDEyNTlmM2I1YmYyM2Yx",
    "commit": {
      "author": {
        "name": "Saahil Shangle",
        "email": "saahilshangle@gmail.com",
        "date": "2020-06-08T00:20:11Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:27Z"
      },
      "message": "Attempted test where one node sends block to another",
      "tree": {
        "sha": "83ddd649a48213cff6233c0ac1feacbd98bb7a1a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/83ddd649a48213cff6233c0ac1feacbd98bb7a1a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/89725bc07379f1cffd2fb9c8041259f3b5bf23f1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/89725bc07379f1cffd2fb9c8041259f3b5bf23f1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/89725bc07379f1cffd2fb9c8041259f3b5bf23f1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/89725bc07379f1cffd2fb9c8041259f3b5bf23f1/comments",
    "author": {
      "login": "saahilshangle",
      "id": 10226886,
      "node_id": "MDQ6VXNlcjEwMjI2ODg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10226886?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saahilshangle",
      "html_url": "https://github.com/saahilshangle",
      "followers_url": "https://api.github.com/users/saahilshangle/followers",
      "following_url": "https://api.github.com/users/saahilshangle/following{/other_user}",
      "gists_url": "https://api.github.com/users/saahilshangle/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saahilshangle/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saahilshangle/subscriptions",
      "organizations_url": "https://api.github.com/users/saahilshangle/orgs",
      "repos_url": "https://api.github.com/users/saahilshangle/repos",
      "events_url": "https://api.github.com/users/saahilshangle/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saahilshangle/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "080e8fceeb050e61c2c1f13bb7e3e87cf391836b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/080e8fceeb050e61c2c1f13bb7e3e87cf391836b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/080e8fceeb050e61c2c1f13bb7e3e87cf391836b"
      }
    ],
    "stats": {
      "total": 224,
      "additions": 224,
      "deletions": 0
    },
    "files": [
      {
        "sha": "87d7100d263b50c88ea90451a601e813aebc0939",
        "filename": "test/functional/p2p_saahil.py",
        "status": "added",
        "additions": 224,
        "deletions": 0,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/89725bc07379f1cffd2fb9c8041259f3b5bf23f1/test/functional/p2p_saahil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/89725bc07379f1cffd2fb9c8041259f3b5bf23f1/test/functional/p2p_saahil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_saahil.py?ref=89725bc07379f1cffd2fb9c8041259f3b5bf23f1",
        "patch": "@@ -0,0 +1,224 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"An example functional test\n+\n+The module-level docstring should include a high-level description of\n+what the test is doing. It's the first thing people see when they open\n+the file and should give the reader information about *what* the test\n+is testing and *how* it's being tested\n+\"\"\"\n+# Imports should be in PEP8 ordering (std library first, then third party\n+# libraries then local imports).\n+from collections import defaultdict\n+\n+# Avoid wildcard * imports\n+from test_framework.blocktools import (create_block, create_coinbase)\n+from test_framework.messages import CInv, MSG_BLOCK\n+from test_framework.mininode import (\n+    P2PInterface,\n+    mininode_lock,\n+    msg_block,\n+    msg_getdata,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    connect_nodes,\n+    wait_until,\n+)\n+\n+# P2PInterface is a class containing callbacks to be executed when a P2P\n+# message is received from the node-under-test. Subclass P2PInterface and\n+# override the on_*() methods if you need custom behaviour.\n+class BaseNode(P2PInterface):\n+    def __init__(self):\n+        \"\"\"Initialize the P2PInterface\n+\n+        Used to initialize custom properties for the Node that aren't\n+        included by default in the base class. Be aware that the P2PInterface\n+        base class already stores a counter for each P2P message type and the\n+        last received message of each type, which should be sufficient for the\n+        needs of most tests.\n+\n+        Call super().__init__() first for standard initialization and then\n+        initialize custom properties.\"\"\"\n+        super().__init__()\n+        # Stores a dictionary of all blocks received\n+        self.block_receive_map = defaultdict(int)\n+\n+    def on_block(self, message):\n+        \"\"\"Override the standard on_block callback\n+\n+        Store the hash of a received block in the dictionary.\"\"\"\n+        message.block.calc_sha256()\n+        self.block_receive_map[message.block.sha256] += 1\n+\n+    def on_inv(self, message):\n+        \"\"\"Override the standard on_inv callback\"\"\"\n+        pass\n+\n+def custom_function():\n+    \"\"\"Do some custom behaviour\n+\n+    If this function is more generally useful for other tests, consider\n+    moving it to a module in test_framework.\"\"\"\n+    # self.log.info(\"running custom_function\")  # Oops! Can't run self.log outside the BitcoinTestFramework\n+    pass\n+\n+\n+class ExampleTest(BitcoinTestFramework):\n+    # Each functional test is a subclass of the BitcoinTestFramework class.\n+\n+    # Override the set_test_params(), skip_test_if_missing_module(), add_options(), setup_chain(), setup_network()\n+    # and setup_nodes() methods to customize the test setup as required.\n+\n+    def set_test_params(self):\n+        \"\"\"Override test parameters for your individual test.\n+\n+        This method must be overridden and num_nodes must be explicitly set.\"\"\"\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+        # Use self.extra_args to change command-line arguments for the nodes\n+        self.extra_args = [[], [\"-logips\"], []]\n+\n+        # self.log.info(\"I've finished set_test_params\")  # Oops! Can't run self.log before run_test()\n+\n+    # Use skip_test_if_missing_module() to skip the test if your test requires certain modules to be present.\n+    # This test uses generate which requires wallet to be compiled\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    # Use add_options() to add specific command-line options for your test.\n+    # In practice this is not used very much, since the tests are mostly written\n+    # to be run in automated environments without command-line options.\n+    # def add_options()\n+    #     pass\n+\n+    # Use setup_chain() to customize the node data directories. In practice\n+    # this is not used very much since the default behaviour is almost always\n+    # fine\n+    # def setup_chain():\n+    #     pass\n+\n+    def setup_network(self):\n+        \"\"\"Setup the test network topology\n+\n+        Often you won't need to override this, since the standard network topology\n+        (linear: node0 <-> node1 <-> node2 <-> ...) is fine for most tests.\n+\n+        If you do override this method, remember to start the nodes, assign\n+        them to self.nodes, connect them and then sync.\"\"\"\n+\n+        self.setup_nodes()\n+\n+        # In this test, we're not connecting node2 to node0 or node1. Calls to\n+        # sync_all() should not include node2, since we're not expecting it to\n+        # sync.\n+        #connect_nodes(self.nodes[0], 1)\n+        #self.sync_all(self.nodes[0:2])\n+\n+    # Use setup_nodes() to customize the node start behaviour (for example if\n+    # you don't want to start all nodes at the start of the test).\n+    # def setup_nodes():\n+    #     pass\n+\n+    def custom_method(self):\n+        \"\"\"Do some custom behaviour for this test\n+\n+        Define it in a method here because you're going to use it repeatedly.\n+        If you think it's useful in general, consider moving it to the base\n+        BitcoinTestFramework class so other tests can use it.\"\"\"\n+\n+        self.log.info(\"Running custom_method\")\n+\n+    def run_test(self):\n+        \"\"\"Main test logic\"\"\"\n+\n+        # Create P2P connections will wait for a verack to make sure the connection is fully up\n+        self.nodes[0].add_p2p_connection(BaseNode())\n+\n+        # Generating a block on one of the nodes will get us out of IBD\n+        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n+        self.log.info(\"Number of blocks in node 0: \" + str(self.nodes[0].getblockcount()))\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+        \n+        self.log.info(\"Now sending block from one to the other\")\n+        connect_nodes(self.nodes[0], 1)\n+        self.sync_all(self.nodes[0:2])\n+\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+\n+        # # Notice above how we called an RPC by calling a method with the same\n+        # # name on the node object. Notice also how we used a keyword argument\n+        # # to specify a named RPC argument. Neither of those are defined on the\n+        # # node object. Instead there's some __getattr__() magic going on under\n+        # # the covers to dispatch unrecognised attribute calls to the RPC\n+        # # interface.\n+\n+        # # Logs are nice. Do plenty of them. They can be used in place of comments for\n+        # # breaking the test into sub-sections.\n+        # self.log.info(\"Starting test!\")\n+\n+        # self.log.info(\"Calling a custom function\")\n+        # custom_function()\n+\n+        # self.log.info(\"Calling a custom method\")\n+        # self.custom_method()\n+\n+        # self.log.info(\"Create some blocks\")\n+        # self.tip = int(self.nodes[0].getbestblockhash(), 16)\n+        # self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n+\n+        # height = self.nodes[0].getblockcount()\n+\n+        # for i in range(10):\n+        #     # Use the mininode and blocktools functionality to manually build a block\n+        #     # Calling the generate() rpc is easier, but this allows us to exactly\n+        #     # control the blocks and transactions.\n+        #     block = create_block(self.tip, create_coinbase(height+1), self.block_time)\n+        #     block.solve()\n+        #     block_message = msg_block(block)\n+        #     # Send message is used to send a P2P message to the node over our P2PInterface\n+        #     self.nodes[0].p2p.send_message(block_message)\n+        #     self.tip = block.sha256\n+        #     blocks.append(self.tip)\n+        #     self.block_time += 1\n+        #     height += 1\n+\n+        # self.log.info(\"Wait for node1 to reach current tip (height 11) using RPC\")\n+        # self.nodes[1].waitforblockheight(11)\n+\n+        # self.log.info(\"Connect node2 and node1\")\n+        # connect_nodes(self.nodes[1], 2)\n+\n+        # self.log.info(\"Wait for node2 to receive all the blocks from node1\")\n+        # self.sync_all()\n+\n+        # self.log.info(\"Add P2P connection to node2\")\n+        # self.nodes[0].disconnect_p2ps()\n+\n+        # self.nodes[2].add_p2p_connection(BaseNode())\n+\n+        # self.log.info(\"Test that node2 propagates all the blocks to us\")\n+\n+        # getdata_request = msg_getdata()\n+        # for block in blocks:\n+        #     getdata_request.inv.append(CInv(MSG_BLOCK, block))\n+        # self.nodes[2].p2p.send_message(getdata_request)\n+\n+        # # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n+        # # P2PInterface objects.\n+        # wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n+\n+        # self.log.info(\"Check that each block was received only once\")\n+        # # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving\n+        # # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking\n+        # # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n+        # with mininode_lock:\n+        #     for block in self.nodes[2].p2p.block_receive_map.values():\n+        #         assert_equal(block, 1)\n+\n+if __name__ == '__main__':\n+    ExampleTest().main()"
      }
    ]
  },
  {
    "sha": "5f4c15225aade08ea29b29916d8c0c43cc0ec8a9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZjRjMTUyMjVhYWRlMDhlYTI5YjI5OTE2ZDhjMGM0M2NjMGVjOGE5",
    "commit": {
      "author": {
        "name": "Fabian Jahr",
        "email": "fjahr@protonmail.com",
        "date": "2020-06-02T21:41:04Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:49:47Z"
      },
      "message": "refactor: Extract GetBogoSize function",
      "tree": {
        "sha": "267e538b07f77cd8ab1e9360804e292c018d00e6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/267e538b07f77cd8ab1e9360804e292c018d00e6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5f4c15225aade08ea29b29916d8c0c43cc0ec8a9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5f4c15225aade08ea29b29916d8c0c43cc0ec8a9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5f4c15225aade08ea29b29916d8c0c43cc0ec8a9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5f4c15225aade08ea29b29916d8c0c43cc0ec8a9/comments",
    "author": {
      "login": "fjahr",
      "id": 1322187,
      "node_id": "MDQ6VXNlcjEzMjIxODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjahr",
      "html_url": "https://github.com/fjahr",
      "followers_url": "https://api.github.com/users/fjahr/followers",
      "following_url": "https://api.github.com/users/fjahr/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjahr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
      "organizations_url": "https://api.github.com/users/fjahr/orgs",
      "repos_url": "https://api.github.com/users/fjahr/repos",
      "events_url": "https://api.github.com/users/fjahr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjahr/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "89725bc07379f1cffd2fb9c8041259f3b5bf23f1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/89725bc07379f1cffd2fb9c8041259f3b5bf23f1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/89725bc07379f1cffd2fb9c8041259f3b5bf23f1"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "315861dd03c80e2ac4dcd6823043a52e6474f2e0",
        "filename": "src/node/coinstats.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5f4c15225aade08ea29b29916d8c0c43cc0ec8a9/src/node/coinstats.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5f4c15225aade08ea29b29916d8c0c43cc0ec8a9/src/node/coinstats.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coinstats.cpp?ref=5f4c15225aade08ea29b29916d8c0c43cc0ec8a9",
        "patch": "@@ -24,7 +24,7 @@ static uint64_t GetBogoSize(const CScript& scriptPubKey)\n            scriptPubKey.size() /* scriptPubKey */;\n }\n \n-static void ApplyStats(CCoinsStats& stats, CHashWriter& ss, const uint256& hash, const std::map<uint32_t, Coin>& outputs)\n+static void ApplyStats(CCoinsStats &stats, CHashWriter& ss, const uint256& hash, const std::map<uint32_t, Coin>& outputs)\n {\n     assert(!outputs.empty());\n     ss << hash;"
      }
    ]
  },
  {
    "sha": "4d4c91169aa4bd05b9c6fc509963a047ed331767",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZDRjOTExNjlhYTRiZDA1YjljNmZjNTA5OTYzYTA0N2VkMzMxNzY3",
    "commit": {
      "author": {
        "name": "Fabian Jahr",
        "email": "fjahr@protonmail.com",
        "date": "2020-06-02T21:52:34Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:50:02Z"
      },
      "message": "rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)",
      "tree": {
        "sha": "bc66beb0ada50ab1d60d342d20f11da87bfb2191",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bc66beb0ada50ab1d60d342d20f11da87bfb2191"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4d4c91169aa4bd05b9c6fc509963a047ed331767",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4d4c91169aa4bd05b9c6fc509963a047ed331767",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4d4c91169aa4bd05b9c6fc509963a047ed331767",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4d4c91169aa4bd05b9c6fc509963a047ed331767/comments",
    "author": {
      "login": "fjahr",
      "id": 1322187,
      "node_id": "MDQ6VXNlcjEzMjIxODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjahr",
      "html_url": "https://github.com/fjahr",
      "followers_url": "https://api.github.com/users/fjahr/followers",
      "following_url": "https://api.github.com/users/fjahr/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjahr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
      "organizations_url": "https://api.github.com/users/fjahr/orgs",
      "repos_url": "https://api.github.com/users/fjahr/repos",
      "events_url": "https://api.github.com/users/fjahr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjahr/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5f4c15225aade08ea29b29916d8c0c43cc0ec8a9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5f4c15225aade08ea29b29916d8c0c43cc0ec8a9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5f4c15225aade08ea29b29916d8c0c43cc0ec8a9"
      }
    ],
    "stats": {
      "total": 21,
      "additions": 15,
      "deletions": 6
    },
    "files": [
      {
        "sha": "21632263dc6df963de2a898385bb28ae6bf0c146",
        "filename": "src/node/coinstats.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4d4c91169aa4bd05b9c6fc509963a047ed331767/src/node/coinstats.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4d4c91169aa4bd05b9c6fc509963a047ed331767/src/node/coinstats.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coinstats.cpp?ref=4d4c91169aa4bd05b9c6fc509963a047ed331767",
        "patch": "@@ -24,7 +24,7 @@ static uint64_t GetBogoSize(const CScript& scriptPubKey)\n            scriptPubKey.size() /* scriptPubKey */;\n }\n \n-static void ApplyStats(CCoinsStats &stats, CHashWriter& ss, const uint256& hash, const std::map<uint32_t, Coin>& outputs)\n+static void ApplyStats(CCoinsStats& stats, CHashWriter& ss, const uint256& hash, const std::map<uint32_t, Coin>& outputs)\n {\n     assert(!outputs.empty());\n     ss << hash;\n@@ -104,9 +104,6 @@ bool GetUTXOStats(CCoinsView* view, CCoinsStats& stats, CoinStatsHashType hash_t\n         CHashWriter ss(SER_GETHASH, PROTOCOL_VERSION);\n         return GetUTXOStats(view, stats, ss, interruption_point);\n     }\n-    case(CoinStatsHashType::NONE): {\n-        return GetUTXOStats(view, stats, nullptr, interruption_point);\n-    }\n     } // no default case, so the compiler can warn about missing cases\n     assert(false);\n }\n@@ -116,10 +113,8 @@ static void PrepareHash(CHashWriter& ss, CCoinsStats& stats)\n {\n     ss << stats.hashBlock;\n }\n-static void PrepareHash(std::nullptr_t, CCoinsStats& stats) {}\n \n static void FinalizeHash(CHashWriter& ss, CCoinsStats& stats)\n {\n     stats.hashSerialized = ss.GetHash();\n }\n-static void FinalizeHash(std::nullptr_t, CCoinsStats& stats) {}"
      },
      {
        "sha": "42bae90ca203e2e9e49a1d214f13422a7a20ff10",
        "filename": "src/node/coinstats.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4d4c91169aa4bd05b9c6fc509963a047ed331767/src/node/coinstats.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4d4c91169aa4bd05b9c6fc509963a047ed331767/src/node/coinstats.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coinstats.h?ref=4d4c91169aa4bd05b9c6fc509963a047ed331767",
        "patch": "@@ -16,7 +16,10 @@ class CCoinsView;\n \n enum class CoinStatsHashType {\n     HASH_SERIALIZED,\n+<<<<<<< HEAD\n     NONE,\n+=======\n+>>>>>>> rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)\n };\n \n struct CCoinsStats"
      },
      {
        "sha": "7f36517eb61867ed12e9d3fd4ccb07ae0d9ee5dc",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4d4c91169aa4bd05b9c6fc509963a047ed331767/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4d4c91169aa4bd05b9c6fc509963a047ed331767/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=4d4c91169aa4bd05b9c6fc509963a047ed331767",
        "patch": "@@ -976,7 +976,11 @@ static UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n                 \"\\nReturns statistics about the unspent transaction output set.\\n\"\n                 \"Note this call may take some time.\\n\",\n                 {\n+<<<<<<< HEAD\n                     {\"hash_type\", RPCArg::Type::STR, /* default */ \"hash_serialized_2\", \"Which UTXO set hash should be calculated. Options: 'hash_serialized_2' (the legacy algorithm), 'none'.\"},\n+=======\n+                    {\"hash_type\", RPCArg::Type::STR, /* default */ \"hash_serialized_2\", \"Which UTXO set hash should be calculated. Options: 'hash_serialized_2' (the legacy algorithm).\"},\n+>>>>>>> rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)\n                 },\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"\",\n@@ -2323,7 +2327,11 @@ UniValue dumptxoutset(const JSONRPCRequest& request)\n \n         ::ChainstateActive().ForceFlushStateToDisk();\n \n+<<<<<<< HEAD\n         if (!GetUTXOStats(&::ChainstateActive().CoinsDB(), stats, CoinStatsHashType::NONE, RpcInterruptionPoint)) {  \n+=======\n+        if (!GetUTXOStats(&::ChainstateActive().CoinsDB(), stats, CoinStatsHashType::HASH_SERIALIZED, RpcInterruptionPoint)) {\n+>>>>>>> rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Unable to read UTXO set\");\n         }\n "
      },
      {
        "sha": "9d25b7d5439c47825f95bd753bd451cfce6a93ba",
        "filename": "src/rpc/util.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4d4c91169aa4bd05b9c6fc509963a047ed331767/src/rpc/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4d4c91169aa4bd05b9c6fc509963a047ed331767/src/rpc/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.cpp?ref=4d4c91169aa4bd05b9c6fc509963a047ed331767",
        "patch": "@@ -122,8 +122,11 @@ CoinStatsHashType ParseHashType(const UniValue& param, const CoinStatsHashType d\n \n         if (hash_type_input == \"hash_serialized_2\") {\n             return CoinStatsHashType::HASH_SERIALIZED;\n+<<<<<<< HEAD\n         } else if (hash_type_input == \"none\") {\n             return CoinStatsHashType::NONE; \n+=======\n+>>>>>>> rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)\n         } else {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"%d is not a valid hash_type\", hash_type_input));\n         }"
      }
    ]
  },
  {
    "sha": "b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNTM4MzcwZmFmOGRiZmVkMTdmZmVkYWExYzNmN2Q2ZmVkYjg5ZmE2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-09T01:46:53Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:52:14Z"
      },
      "message": "Replace automatic bans with discouragement filter\n\nThis patch improves performance and resource usage around IP\naddresses that are banned for misbehavior. They're already not\nactually banned, as connections from them are still allowed,\nbut they are preferred for eviction if the inbound connection\nslots are full.\n\nStop treating these like manually banned IP ranges, and instead\njust keep them in a rolling Bloom filter of misbehaving nodes,\nwhich isn't persisted to disk or exposed through the ban\nframework. The effect remains the same: preferred for eviction,\navoided for outgoing connections, and not relayed to other peers.\n\nAlso change the name of this mechanism to better reflect reality;\nthey're not banned, just discouraged.\n\nContains release notes and several interface improvements by\nJohn Newbery.",
      "tree": {
        "sha": "b3a630d55ecd6c6700fbad7a7387bc33b01e7018",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b3a630d55ecd6c6700fbad7a7387bc33b01e7018"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4d4c91169aa4bd05b9c6fc509963a047ed331767",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4d4c91169aa4bd05b9c6fc509963a047ed331767",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4d4c91169aa4bd05b9c6fc509963a047ed331767"
      }
    ],
    "stats": {
      "total": 66,
      "additions": 55,
      "deletions": 11
    },
    "files": [
      {
        "sha": "0b8fa7073f65d16ce4a3ee2a172a9f3f11e662ea",
        "filename": "src/banman.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 0,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6/src/banman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6/src/banman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/banman.cpp?ref=b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6",
        "patch": "@@ -70,14 +70,33 @@ void BanMan::ClearBanned()\n \n bool BanMan::IsDiscouraged(const CNetAddr& net_addr)\n {\n+<<<<<<< HEAD\n     LOCK(m_cs_banned);\n     return m_discouraged.contains(net_addr.GetAddrBytes());\n+=======\n+    // Returns the most severe level of banning that applies to this address.\n+    // 0 - Not banned\n+    // 1 - Automatic misbehavior ban\n+    // 2 - Any other ban\n+    auto current_time = GetTime();\n+    LOCK(m_cs_banned);\n+    for (const auto& it : m_banned) {\n+        CSubNet sub_net = it.first;\n+        CBanEntry ban_entry = it.second;\n+\n+        if (current_time < ban_entry.nBanUntil && sub_net.Match(net_addr)) {\n+            return 2;\n+        }\n+    }\n+    return m_discouraged.contains(net_addr.GetAddrBytes()) ? 1 : 0;\n+>>>>>>> Replace automatic bans with discouragement filter\n }\n \n bool BanMan::IsBanned(const CNetAddr& net_addr)\n {\n     auto current_time = GetTime();\n     LOCK(m_cs_banned);\n+    if (m_discouraged.contains(net_addr.GetAddrBytes())) return true;\n     for (const auto& it : m_banned) {\n         CSubNet sub_net = it.first;\n         CBanEntry ban_entry = it.second;\n@@ -105,6 +124,11 @@ bool BanMan::IsBanned(const CSubNet& sub_net)\n \n void BanMan::Ban(const CNetAddr& net_addr, int64_t ban_time_offset, bool since_unix_epoch)\n {\n+    if (ban_reason == BanReasonNodeMisbehaving) {\n+        LOCK(m_cs_banned);\n+        m_discouraged.insert(net_addr.GetAddrBytes());\n+        return;\n+    }\n     CSubNet sub_net(net_addr);\n     Ban(sub_net, ban_time_offset, since_unix_epoch);\n }\n@@ -117,7 +141,12 @@ void BanMan::Discourage(const CNetAddr& net_addr)\n \n void BanMan::Ban(const CSubNet& sub_net, int64_t ban_time_offset, bool since_unix_epoch)\n {\n+<<<<<<< HEAD\n     CBanEntry ban_entry(GetTime());\n+=======\n+    assert(ban_reason == BanReasonManuallyAdded);\n+    CBanEntry ban_entry(GetTime(), ban_reason);\n+>>>>>>> Replace automatic bans with discouragement filter\n \n     int64_t normalized_ban_time_offset = ban_time_offset;\n     bool normalized_since_unix_epoch = since_unix_epoch;"
      },
      {
        "sha": "768cee30dc636fbf88f9e3c6e69686882ba7eccc",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6",
        "patch": "@@ -1011,18 +1011,29 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     // on all platforms.  Set it again here just to be sure.\n     SetSocketNoDelay(hSocket);\n \n+<<<<<<< HEAD\n     // Don't accept connections from banned peers.\n     bool banned = m_banman->IsBanned(addr);\n     if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && banned)\n+=======\n+    int bannedlevel = m_banman ? m_banman->IsBannedLevel(addr) : 0;\n+\n+    // Don't accept connections from banned peers.\n+    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && bannedlevel == 2)\n+>>>>>>> Replace automatic bans with discouragement filter\n     {\n         LogPrint(BCLog::NET, \"connection from %s dropped (banned)\\n\", addr.ToString());\n         CloseSocket(hSocket);\n         return;\n     }\n \n     // Only accept connections from discouraged peers if our inbound slots aren't (almost) full.\n+<<<<<<< HEAD\n     bool discouraged = m_banman->IsDiscouraged(addr);\n     if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && nInbound + 1 >= nMaxInbound && discouraged) \n+=======\n+    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && nInbound + 1 >= nMaxInbound && bannedlevel >= 1)\n+>>>>>>> Replace automatic bans with discouragement filter\n     {\n         LogPrint(BCLog::NET, \"connection from %s dropped (discouraged)\\n\", addr.ToString());\n         CloseSocket(hSocket);"
      },
      {
        "sha": "b8c019cb55e00c3de6dea91662f9bccb7af7ba96",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6",
        "patch": "@@ -1033,7 +1033,11 @@ void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIV\n     if (state->nMisbehavior >= banscore && state->nMisbehavior - howmuch < banscore)\n     {\n         LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d) DISCOURAGE THRESHOLD EXCEEDED%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n+<<<<<<< HEAD\n         state->m_should_discourage = true; \n+=======\n+        state->fShouldBan = true;\n+>>>>>>> Replace automatic bans with discouragement filter\n     } else\n         LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d)%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n }\n@@ -3574,12 +3578,21 @@ bool PeerLogicValidation::MaybeDiscourageAndDisconnect(CNode& pnode)\n             LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pnode.addr.ToString());\n         } else if (pnode.m_manual_connection) {\n             LogPrintf(\"Warning: not punishing manually-connected peer %s!\\n\", pnode.addr.ToString());\n+<<<<<<< HEAD\n         } else if (pnode.addr.IsLocal()) { \n             // Disconnect but don't discourage this local node\n             LogPrintf(\"Warning: disconnecting but not discouraging local peer %s!\\n\", pnode.addr.ToString());\n             pnode.fDisconnect = true;\n         } else {  \n             // Disconnect and discourage all nodes sharing the address \n+=======\n+        else if (pnode.addr.IsLocal()) {\n+            // Disconnect but don't discourage this local node\n+            LogPrintf(\"Warning: disconnecting but not discouraging local peer %s!\\n\", pnode.addr.ToString());\n+            pnode.fDisconnect = true;\n+        } else {\n+            // Disconnect and ban all nodes sharing the address\n+>>>>>>> Replace automatic bans with discouragement filter\n             LogPrintf(\"Disconnecting and discouraging peer %s!\\n\", pnode.addr.ToString());\n             if (m_banman) {\n                 m_banman->Discourage(pnode.addr);"
      },
      {
        "sha": "2c6d091c3f7f4139bca72cda2e7708916d21a4e1",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6",
        "patch": "@@ -976,11 +976,7 @@ static UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n                 \"\\nReturns statistics about the unspent transaction output set.\\n\"\n                 \"Note this call may take some time.\\n\",\n                 {\n-<<<<<<< HEAD\n-                    {\"hash_type\", RPCArg::Type::STR, /* default */ \"hash_serialized_2\", \"Which UTXO set hash should be calculated. Options: 'hash_serialized_2' (the legacy algorithm), 'none'.\"},\n-=======\n                     {\"hash_type\", RPCArg::Type::STR, /* default */ \"hash_serialized_2\", \"Which UTXO set hash should be calculated. Options: 'hash_serialized_2' (the legacy algorithm).\"},\n->>>>>>> rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)\n                 },\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"\",\n@@ -2327,11 +2323,7 @@ UniValue dumptxoutset(const JSONRPCRequest& request)\n \n         ::ChainstateActive().ForceFlushStateToDisk();\n \n-<<<<<<< HEAD\n-        if (!GetUTXOStats(&::ChainstateActive().CoinsDB(), stats, CoinStatsHashType::NONE, RpcInterruptionPoint)) {  \n-=======\n         if (!GetUTXOStats(&::ChainstateActive().CoinsDB(), stats, CoinStatsHashType::HASH_SERIALIZED, RpcInterruptionPoint)) {\n->>>>>>> rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Unable to read UTXO set\");\n         }\n "
      },
      {
        "sha": "5dbe28b00d1dcd4c766c18d0b025c3a4aae6d8ac",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6",
        "patch": "@@ -604,7 +604,8 @@ static UniValue setban(const JSONRPCRequest& request)\n \n     if (strCommand == \"add\")\n     {\n-        if (isSubnet ? node.banman->IsBanned(subNet) : node.banman->IsBanned(netAddr)) {\n+        if ((isSubnet && node.banman->IsBanned(subNet)) ||\n+            (!isSubnet && node.banman->IsBannedLevel(netAddr) == BanReasonManuallyAdded)) {\n             throw JSONRPCError(RPC_CLIENT_NODE_ALREADY_ADDED, \"Error: IP/Subnet already banned\");\n         }\n "
      },
      {
        "sha": "564a2a00feb7da63eb03a83136c632c79ed724d3",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6",
        "patch": "@@ -345,8 +345,6 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode));\n     }\n \n-    BOOST_CHECK(banman->IsDiscouraged(addr)); \n-\n     bool dummy;\n     peerLogic->FinalizeNode(dummyNode.GetId(), dummy);\n }"
      }
    ]
  },
  {
    "sha": "7c9905669a46829ccc81f2c006cb8989f060c4f6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3Yzk5MDU2NjlhNDY4MjljY2M4MWYyYzAwNmNiODk4OWYwNjBjNGY2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-11T00:11:38Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:52:23Z"
      },
      "message": "Clean up separated ban/discourage interface",
      "tree": {
        "sha": "cd3d4788bf6ff29c555085edd2c6f8523f8aa489",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cd3d4788bf6ff29c555085edd2c6f8523f8aa489"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7c9905669a46829ccc81f2c006cb8989f060c4f6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7c9905669a46829ccc81f2c006cb8989f060c4f6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7c9905669a46829ccc81f2c006cb8989f060c4f6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7c9905669a46829ccc81f2c006cb8989f060c4f6/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b538370faf8dbfed17ffedaa1c3f7d6fedb89fa6"
      }
    ],
    "stats": {
      "total": 55,
      "additions": 47,
      "deletions": 8
    },
    "files": [
      {
        "sha": "767ab0bfa92039a27e06a6ebc1fcaa970afc6212",
        "filename": "src/banman.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 6,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c9905669a46829ccc81f2c006cb8989f060c4f6/src/banman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c9905669a46829ccc81f2c006cb8989f060c4f6/src/banman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/banman.cpp?ref=7c9905669a46829ccc81f2c006cb8989f060c4f6",
        "patch": "@@ -70,6 +70,7 @@ void BanMan::ClearBanned()\n \n bool BanMan::IsDiscouraged(const CNetAddr& net_addr)\n {\n+<<<<<<< HEAD\n <<<<<<< HEAD\n     LOCK(m_cs_banned);\n     return m_discouraged.contains(net_addr.GetAddrBytes());\n@@ -90,13 +91,16 @@ bool BanMan::IsDiscouraged(const CNetAddr& net_addr)\n     }\n     return m_discouraged.contains(net_addr.GetAddrBytes()) ? 1 : 0;\n >>>>>>> Replace automatic bans with discouragement filter\n+=======\n+    LOCK(m_cs_banned);\n+    return m_discouraged.contains(net_addr.GetAddrBytes());\n+>>>>>>> Clean up separated ban/discourage interface\n }\n \n bool BanMan::IsBanned(const CNetAddr& net_addr)\n {\n     auto current_time = GetTime();\n     LOCK(m_cs_banned);\n-    if (m_discouraged.contains(net_addr.GetAddrBytes())) return true;\n     for (const auto& it : m_banned) {\n         CSubNet sub_net = it.first;\n         CBanEntry ban_entry = it.second;\n@@ -124,13 +128,9 @@ bool BanMan::IsBanned(const CSubNet& sub_net)\n \n void BanMan::Ban(const CNetAddr& net_addr, int64_t ban_time_offset, bool since_unix_epoch)\n {\n-    if (ban_reason == BanReasonNodeMisbehaving) {\n-        LOCK(m_cs_banned);\n-        m_discouraged.insert(net_addr.GetAddrBytes());\n-        return;\n-    }\n     CSubNet sub_net(net_addr);\n     Ban(sub_net, ban_time_offset, since_unix_epoch);\n+<<<<<<< HEAD\n }\n \n void BanMan::Discourage(const CNetAddr& net_addr)\n@@ -147,6 +147,19 @@ void BanMan::Ban(const CSubNet& sub_net, int64_t ban_time_offset, bool since_uni\n     assert(ban_reason == BanReasonManuallyAdded);\n     CBanEntry ban_entry(GetTime(), ban_reason);\n >>>>>>> Replace automatic bans with discouragement filter\n+=======\n+}\n+\n+void BanMan::Discourage(const CNetAddr& net_addr)\n+{\n+    LOCK(m_cs_banned);\n+    m_discouraged.insert(net_addr.GetAddrBytes());\n+}\n+\n+void BanMan::Ban(const CSubNet& sub_net, int64_t ban_time_offset, bool since_unix_epoch)\n+{\n+    CBanEntry ban_entry(GetTime());\n+>>>>>>> Clean up separated ban/discourage interface\n \n     int64_t normalized_ban_time_offset = ban_time_offset;\n     bool normalized_since_unix_epoch = since_unix_epoch;"
      },
      {
        "sha": "183b67accf24695d7f5adb61c6c34bfaf85871d4",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c9905669a46829ccc81f2c006cb8989f060c4f6/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c9905669a46829ccc81f2c006cb8989f060c4f6/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=7c9905669a46829ccc81f2c006cb8989f060c4f6",
        "patch": "@@ -1011,6 +1011,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     // on all platforms.  Set it again here just to be sure.\n     SetSocketNoDelay(hSocket);\n \n+<<<<<<< HEAD\n <<<<<<< HEAD\n     // Don't accept connections from banned peers.\n     bool banned = m_banman->IsBanned(addr);\n@@ -1021,19 +1022,29 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     // Don't accept connections from banned peers.\n     if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && bannedlevel == 2)\n >>>>>>> Replace automatic bans with discouragement filter\n+=======\n+    // Don't accept connections from banned peers.\n+    bool banned = m_banman->IsBanned(addr);\n+    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && banned)\n+>>>>>>> Clean up separated ban/discourage interface\n     {\n         LogPrint(BCLog::NET, \"connection from %s dropped (banned)\\n\", addr.ToString());\n         CloseSocket(hSocket);\n         return;\n     }\n \n     // Only accept connections from discouraged peers if our inbound slots aren't (almost) full.\n+<<<<<<< HEAD\n <<<<<<< HEAD\n     bool discouraged = m_banman->IsDiscouraged(addr);\n     if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && nInbound + 1 >= nMaxInbound && discouraged) \n =======\n     if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && nInbound + 1 >= nMaxInbound && bannedlevel >= 1)\n >>>>>>> Replace automatic bans with discouragement filter\n+=======\n+    bool discouraged = m_banman->IsDiscouraged(addr);\n+    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && nInbound + 1 >= nMaxInbound && discouraged)\n+>>>>>>> Clean up separated ban/discourage interface\n     {\n         LogPrint(BCLog::NET, \"connection from %s dropped (discouraged)\\n\", addr.ToString());\n         CloseSocket(hSocket);"
      },
      {
        "sha": "d6f9c1b980862c0f94a91d51e6b2f00b3f2bb8e7",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c9905669a46829ccc81f2c006cb8989f060c4f6/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c9905669a46829ccc81f2c006cb8989f060c4f6/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=7c9905669a46829ccc81f2c006cb8989f060c4f6",
        "patch": "@@ -1033,11 +1033,15 @@ void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIV\n     if (state->nMisbehavior >= banscore && state->nMisbehavior - howmuch < banscore)\n     {\n         LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d) DISCOURAGE THRESHOLD EXCEEDED%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n+<<<<<<< HEAD\n <<<<<<< HEAD\n         state->m_should_discourage = true; \n =======\n         state->fShouldBan = true;\n >>>>>>> Replace automatic bans with discouragement filter\n+=======\n+        state->m_should_discourage = true;\n+>>>>>>> Clean up separated ban/discourage interface\n     } else\n         LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d)%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n }\n@@ -3578,6 +3582,7 @@ bool PeerLogicValidation::MaybeDiscourageAndDisconnect(CNode& pnode)\n             LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pnode.addr.ToString());\n         } else if (pnode.m_manual_connection) {\n             LogPrintf(\"Warning: not punishing manually-connected peer %s!\\n\", pnode.addr.ToString());\n+<<<<<<< HEAD\n <<<<<<< HEAD\n         } else if (pnode.addr.IsLocal()) { \n             // Disconnect but don't discourage this local node\n@@ -3587,12 +3592,19 @@ bool PeerLogicValidation::MaybeDiscourageAndDisconnect(CNode& pnode)\n             // Disconnect and discourage all nodes sharing the address \n =======\n         else if (pnode.addr.IsLocal()) {\n+=======\n+        } else if (pnode.addr.IsLocal()) {\n+>>>>>>> Clean up separated ban/discourage interface\n             // Disconnect but don't discourage this local node\n             LogPrintf(\"Warning: disconnecting but not discouraging local peer %s!\\n\", pnode.addr.ToString());\n             pnode.fDisconnect = true;\n         } else {\n+<<<<<<< HEAD\n             // Disconnect and ban all nodes sharing the address\n >>>>>>> Replace automatic bans with discouragement filter\n+=======\n+            // Disconnect and discourage all nodes sharing the address\n+>>>>>>> Clean up separated ban/discourage interface\n             LogPrintf(\"Disconnecting and discouraging peer %s!\\n\", pnode.addr.ToString());\n             if (m_banman) {\n                 m_banman->Discourage(pnode.addr);"
      },
      {
        "sha": "9981ea35dff395a774714a1245086acf0cf85236",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c9905669a46829ccc81f2c006cb8989f060c4f6/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c9905669a46829ccc81f2c006cb8989f060c4f6/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=7c9905669a46829ccc81f2c006cb8989f060c4f6",
        "patch": "@@ -604,8 +604,7 @@ static UniValue setban(const JSONRPCRequest& request)\n \n     if (strCommand == \"add\")\n     {\n-        if ((isSubnet && node.banman->IsBanned(subNet)) ||\n-            (!isSubnet && node.banman->IsBannedLevel(netAddr) == BanReasonManuallyAdded)) {\n+        if (isSubnet ? node.banman->IsBanned(subNet) : node.banman->IsBanned(netAddr)) {\n             throw JSONRPCError(RPC_CLIENT_NODE_ALREADY_ADDED, \"Error: IP/Subnet already banned\");\n         }\n "
      },
      {
        "sha": "1cc2f81abaebd63d8b262875bb2eb5f716a9322c",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c9905669a46829ccc81f2c006cb8989f060c4f6/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c9905669a46829ccc81f2c006cb8989f060c4f6/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=7c9905669a46829ccc81f2c006cb8989f060c4f6",
        "patch": "@@ -344,6 +344,10 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n         LOCK2(cs_main, dummyNode.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode));\n     }\n+<<<<<<< HEAD\n+=======\n+    BOOST_CHECK(banman->IsDiscouraged(addr));\n+>>>>>>> Clean up separated ban/discourage interface\n \n     bool dummy;\n     peerLogic->FinalizeNode(dummyNode.GetId(), dummy);"
      }
    ]
  },
  {
    "sha": "d0f2439e645897a4aa87f111e9b56366a5f61f0d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMGYyNDM5ZTY0NTg5N2E0YWE4N2YxMTFlOWI1NjM2NmE1ZjYxZjBk",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-06-20T12:44:42Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:54:02Z"
      },
      "message": "wallet: Remove confusing double return value ret+success\n\nAlso, remove redundant comments",
      "tree": {
        "sha": "3938dd8141f02490570dbacfc46e8570b1a1d969",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3938dd8141f02490570dbacfc46e8570b1a1d969"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d0f2439e645897a4aa87f111e9b56366a5f61f0d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0f2439e645897a4aa87f111e9b56366a5f61f0d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d0f2439e645897a4aa87f111e9b56366a5f61f0d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0f2439e645897a4aa87f111e9b56366a5f61f0d/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7c9905669a46829ccc81f2c006cb8989f060c4f6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7c9905669a46829ccc81f2c006cb8989f060c4f6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7c9905669a46829ccc81f2c006cb8989f060c4f6"
      }
    ],
    "stats": {
      "total": 101,
      "additions": 10,
      "deletions": 91
    },
    "files": [
      {
        "sha": "d4009105f6bae0f34241dae63c3564bd7ac3dbbe",
        "filename": "src/banman.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 28,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0f2439e645897a4aa87f111e9b56366a5f61f0d/src/banman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0f2439e645897a4aa87f111e9b56366a5f61f0d/src/banman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/banman.cpp?ref=d0f2439e645897a4aa87f111e9b56366a5f61f0d",
        "patch": "@@ -70,11 +70,6 @@ void BanMan::ClearBanned()\n \n bool BanMan::IsDiscouraged(const CNetAddr& net_addr)\n {\n-<<<<<<< HEAD\n-<<<<<<< HEAD\n-    LOCK(m_cs_banned);\n-    return m_discouraged.contains(net_addr.GetAddrBytes());\n-=======\n     // Returns the most severe level of banning that applies to this address.\n     // 0 - Not banned\n     // 1 - Automatic misbehavior ban\n@@ -90,17 +85,13 @@ bool BanMan::IsDiscouraged(const CNetAddr& net_addr)\n         }\n     }\n     return m_discouraged.contains(net_addr.GetAddrBytes()) ? 1 : 0;\n->>>>>>> Replace automatic bans with discouragement filter\n-=======\n-    LOCK(m_cs_banned);\n-    return m_discouraged.contains(net_addr.GetAddrBytes());\n->>>>>>> Clean up separated ban/discourage interface\n }\n \n bool BanMan::IsBanned(const CNetAddr& net_addr)\n {\n     auto current_time = GetTime();\n     LOCK(m_cs_banned);\n+    if (m_discouraged.contains(net_addr.GetAddrBytes())) return true;\n     for (const auto& it : m_banned) {\n         CSubNet sub_net = it.first;\n         CBanEntry ban_entry = it.second;\n@@ -128,9 +119,13 @@ bool BanMan::IsBanned(const CSubNet& sub_net)\n \n void BanMan::Ban(const CNetAddr& net_addr, int64_t ban_time_offset, bool since_unix_epoch)\n {\n+    if (ban_reason == BanReasonNodeMisbehaving) {\n+        LOCK(m_cs_banned);\n+        m_discouraged.insert(net_addr.GetAddrBytes());\n+        return;\n+    }\n     CSubNet sub_net(net_addr);\n     Ban(sub_net, ban_time_offset, since_unix_epoch);\n-<<<<<<< HEAD\n }\n \n void BanMan::Discourage(const CNetAddr& net_addr)\n@@ -141,25 +136,8 @@ void BanMan::Discourage(const CNetAddr& net_addr)\n \n void BanMan::Ban(const CSubNet& sub_net, int64_t ban_time_offset, bool since_unix_epoch)\n {\n-<<<<<<< HEAD\n-    CBanEntry ban_entry(GetTime());\n-=======\n     assert(ban_reason == BanReasonManuallyAdded);\n     CBanEntry ban_entry(GetTime(), ban_reason);\n->>>>>>> Replace automatic bans with discouragement filter\n-=======\n-}\n-\n-void BanMan::Discourage(const CNetAddr& net_addr)\n-{\n-    LOCK(m_cs_banned);\n-    m_discouraged.insert(net_addr.GetAddrBytes());\n-}\n-\n-void BanMan::Ban(const CSubNet& sub_net, int64_t ban_time_offset, bool since_unix_epoch)\n-{\n-    CBanEntry ban_entry(GetTime());\n->>>>>>> Clean up separated ban/discourage interface\n \n     int64_t normalized_ban_time_offset = ban_time_offset;\n     bool normalized_since_unix_epoch = since_unix_epoch;"
      },
      {
        "sha": "17c737c2e73193a624942880c54c2ce6b30f530f",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 22,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0f2439e645897a4aa87f111e9b56366a5f61f0d/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0f2439e645897a4aa87f111e9b56366a5f61f0d/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=d0f2439e645897a4aa87f111e9b56366a5f61f0d",
        "patch": "@@ -1011,40 +1011,18 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     // on all platforms.  Set it again here just to be sure.\n     SetSocketNoDelay(hSocket);\n \n-<<<<<<< HEAD\n-<<<<<<< HEAD\n-    // Don't accept connections from banned peers.\n-    bool banned = m_banman->IsBanned(addr);\n-    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && banned)\n-=======\n     int bannedlevel = m_banman ? m_banman->IsBannedLevel(addr) : 0;\n \n     // Don't accept connections from banned peers.\n     if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && bannedlevel == 2)\n->>>>>>> Replace automatic bans with discouragement filter\n-=======\n-    // Don't accept connections from banned peers.\n-    bool banned = m_banman->IsBanned(addr);\n-    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && banned)\n->>>>>>> Clean up separated ban/discourage interface\n     {\n         LogPrint(BCLog::NET, \"connection from %s dropped (banned)\\n\", addr.ToString());\n         CloseSocket(hSocket);\n         return;\n     }\n \n     // Only accept connections from discouraged peers if our inbound slots aren't (almost) full.\n-<<<<<<< HEAD\n-<<<<<<< HEAD\n-    bool discouraged = m_banman->IsDiscouraged(addr);\n-    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && nInbound + 1 >= nMaxInbound && discouraged) \n-=======\n     if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && nInbound + 1 >= nMaxInbound && bannedlevel >= 1)\n->>>>>>> Replace automatic bans with discouragement filter\n-=======\n-    bool discouraged = m_banman->IsDiscouraged(addr);\n-    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && nInbound + 1 >= nMaxInbound && discouraged)\n->>>>>>> Clean up separated ban/discourage interface\n     {\n         LogPrint(BCLog::NET, \"connection from %s dropped (discouraged)\\n\", addr.ToString());\n         CloseSocket(hSocket);"
      },
      {
        "sha": "81089b1d24a4aabe6dd0dd25660991811464cbc3",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 25,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0f2439e645897a4aa87f111e9b56366a5f61f0d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0f2439e645897a4aa87f111e9b56366a5f61f0d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=d0f2439e645897a4aa87f111e9b56366a5f61f0d",
        "patch": "@@ -1033,15 +1033,7 @@ void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIV\n     if (state->nMisbehavior >= banscore && state->nMisbehavior - howmuch < banscore)\n     {\n         LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d) DISCOURAGE THRESHOLD EXCEEDED%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n-<<<<<<< HEAD\n-<<<<<<< HEAD\n-        state->m_should_discourage = true; \n-=======\n         state->fShouldBan = true;\n->>>>>>> Replace automatic bans with discouragement filter\n-=======\n-        state->m_should_discourage = true;\n->>>>>>> Clean up separated ban/discourage interface\n     } else\n         LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d)%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n }\n@@ -3582,29 +3574,12 @@ bool PeerLogicValidation::MaybeDiscourageAndDisconnect(CNode& pnode)\n             LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pnode.addr.ToString());\n         } else if (pnode.m_manual_connection) {\n             LogPrintf(\"Warning: not punishing manually-connected peer %s!\\n\", pnode.addr.ToString());\n-<<<<<<< HEAD\n-<<<<<<< HEAD\n-        } else if (pnode.addr.IsLocal()) { \n-            // Disconnect but don't discourage this local node\n-            LogPrintf(\"Warning: disconnecting but not discouraging local peer %s!\\n\", pnode.addr.ToString());\n-            pnode.fDisconnect = true;\n-        } else {  \n-            // Disconnect and discourage all nodes sharing the address \n-=======\n         else if (pnode.addr.IsLocal()) {\n-=======\n-        } else if (pnode.addr.IsLocal()) {\n->>>>>>> Clean up separated ban/discourage interface\n             // Disconnect but don't discourage this local node\n             LogPrintf(\"Warning: disconnecting but not discouraging local peer %s!\\n\", pnode.addr.ToString());\n             pnode.fDisconnect = true;\n         } else {\n-<<<<<<< HEAD\n             // Disconnect and ban all nodes sharing the address\n->>>>>>> Replace automatic bans with discouragement filter\n-=======\n-            // Disconnect and discourage all nodes sharing the address\n->>>>>>> Clean up separated ban/discourage interface\n             LogPrintf(\"Disconnecting and discouraging peer %s!\\n\", pnode.addr.ToString());\n             if (m_banman) {\n                 m_banman->Discourage(pnode.addr);"
      },
      {
        "sha": "1d0270d56db9a36a039bae313af0c6380d7ed9a0",
        "filename": "src/node/coinstats.h",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0f2439e645897a4aa87f111e9b56366a5f61f0d/src/node/coinstats.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0f2439e645897a4aa87f111e9b56366a5f61f0d/src/node/coinstats.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coinstats.h?ref=d0f2439e645897a4aa87f111e9b56366a5f61f0d",
        "patch": "@@ -16,10 +16,6 @@ class CCoinsView;\n \n enum class CoinStatsHashType {\n     HASH_SERIALIZED,\n-<<<<<<< HEAD\n-    NONE,\n-=======\n->>>>>>> rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)\n };\n \n struct CCoinsStats"
      },
      {
        "sha": "8672507591f89b3b0fb5f8334adf6af2cff2aeb2",
        "filename": "src/rpc/util.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0f2439e645897a4aa87f111e9b56366a5f61f0d/src/rpc/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0f2439e645897a4aa87f111e9b56366a5f61f0d/src/rpc/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.cpp?ref=d0f2439e645897a4aa87f111e9b56366a5f61f0d",
        "patch": "@@ -122,11 +122,6 @@ CoinStatsHashType ParseHashType(const UniValue& param, const CoinStatsHashType d\n \n         if (hash_type_input == \"hash_serialized_2\") {\n             return CoinStatsHashType::HASH_SERIALIZED;\n-<<<<<<< HEAD\n-        } else if (hash_type_input == \"none\") {\n-            return CoinStatsHashType::NONE; \n-=======\n->>>>>>> rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)\n         } else {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"%d is not a valid hash_type\", hash_type_input));\n         }"
      },
      {
        "sha": "1fe01fae04fca83988debd49e4a4bd11950881ec",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0f2439e645897a4aa87f111e9b56366a5f61f0d/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0f2439e645897a4aa87f111e9b56366a5f61f0d/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=d0f2439e645897a4aa87f111e9b56366a5f61f0d",
        "patch": "@@ -344,10 +344,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n         LOCK2(cs_main, dummyNode.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode));\n     }\n-<<<<<<< HEAD\n-=======\n     BOOST_CHECK(banman->IsDiscouraged(addr));\n->>>>>>> Clean up separated ban/discourage interface\n \n     bool dummy;\n     peerLogic->FinalizeNode(dummyNode.GetId(), dummy);"
      },
      {
        "sha": "a14744a86fc26cc0bf7864a966f1d3671a0b0ba3",
        "filename": "src/wallet/bdb.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0f2439e645897a4aa87f111e9b56366a5f61f0d/src/wallet/bdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0f2439e645897a4aa87f111e9b56366a5f61f0d/src/wallet/bdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/bdb.h?ref=d0f2439e645897a4aa87f111e9b56366a5f61f0d",
        "patch": "@@ -227,7 +227,7 @@ class BerkeleyBatch\n         ssKey << key;\n \n         CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n-        if (!ReadKey(std::move(ssKey), ssValue)) return false;\n+        if (!ReadKey(ssKey, ssValue)) return false;\n         try {\n             ssValue >> value;\n             return true;\n@@ -247,7 +247,7 @@ class BerkeleyBatch\n         ssValue.reserve(10000);\n         ssValue << value;\n \n-        return WriteKey(std::move(ssKey), std::move(ssValue), fOverwrite);\n+        return WriteKey(ssKey, ssValue, fOverwrite);\n     }\n \n     template <typename K>\n@@ -257,7 +257,7 @@ class BerkeleyBatch\n         ssKey.reserve(1000);\n         ssKey << key;\n \n-        return EraseKey(std::move(ssKey));\n+        return EraseKey(ssKey);\n     }\n \n     template <typename K>\n@@ -267,7 +267,7 @@ class BerkeleyBatch\n         ssKey.reserve(1000);\n         ssKey << key;\n \n-        return HasKey(std::move(ssKey));\n+        return HasKey(ssKey);\n     }\n \n     bool StartCursor();"
      }
    ]
  },
  {
    "sha": "75f7df8968e1328ec85a5f502bef81a3674d0d99",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NWY3ZGY4OTY4ZTEzMjhlYzg1YTVmNTAyYmVmODFhMzY3NGQwZDk5",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-06-20T12:55:07Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:54:02Z"
      },
      "message": "wallet: Replace CDataStream& with CDataStream&& where appropriate\n\nThe keys and values are only to be used once because their memory is set\nto zero. Make that explicit by moving the bytes into the lower level\nmethods.",
      "tree": {
        "sha": "05f9ad7262ea082a6bb38623ea12ef27c8341099",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/05f9ad7262ea082a6bb38623ea12ef27c8341099"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/75f7df8968e1328ec85a5f502bef81a3674d0d99",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75f7df8968e1328ec85a5f502bef81a3674d0d99",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/75f7df8968e1328ec85a5f502bef81a3674d0d99",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75f7df8968e1328ec85a5f502bef81a3674d0d99/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d0f2439e645897a4aa87f111e9b56366a5f61f0d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0f2439e645897a4aa87f111e9b56366a5f61f0d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d0f2439e645897a4aa87f111e9b56366a5f61f0d"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 4,
      "deletions": 4
    },
    "files": [
      {
        "sha": "599319482bea0ebeee0dbcd95757030e5512ddff",
        "filename": "src/wallet/bdb.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75f7df8968e1328ec85a5f502bef81a3674d0d99/src/wallet/bdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75f7df8968e1328ec85a5f502bef81a3674d0d99/src/wallet/bdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/bdb.h?ref=75f7df8968e1328ec85a5f502bef81a3674d0d99",
        "patch": "@@ -227,7 +227,7 @@ class BerkeleyBatch\n         ssKey << key;\n \n         CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n-        if (!ReadKey(ssKey, ssValue)) return false;\n+        if (!ReadKey(std::move(ssKey), ssValue)) return false;\n         try {\n             ssValue >> value;\n             return true;\n@@ -247,7 +247,7 @@ class BerkeleyBatch\n         ssValue.reserve(10000);\n         ssValue << value;\n \n-        return WriteKey(ssKey, ssValue, fOverwrite);\n+        return WriteKey(std::move(ssKey), std::move(ssValue), fOverwrite);\n     }\n \n     template <typename K>\n@@ -257,7 +257,7 @@ class BerkeleyBatch\n         ssKey.reserve(1000);\n         ssKey << key;\n \n-        return EraseKey(ssKey);\n+        return EraseKey(std::move(ssKey));\n     }\n \n     template <typename K>\n@@ -267,7 +267,7 @@ class BerkeleyBatch\n         ssKey.reserve(1000);\n         ssKey << key;\n \n-        return HasKey(ssKey);\n+        return HasKey(std::move(ssKey));\n     }\n \n     bool StartCursor();"
      }
    ]
  },
  {
    "sha": "c2430af280c1575d2c961d037a3752b9cdc9b0bf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMjQzMGFmMjgwYzE1NzVkMmM5NjFkMDM3YTM3NTJiOWNkYzliMGJm",
    "commit": {
      "author": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-07T06:39:46Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:54:02Z"
      },
      "message": "Revert \"Attempted test where one node sends block to another\"\n\nThis reverts commit 55cf78aae878ac1e2a8ed5712877465a2e4a938c.",
      "tree": {
        "sha": "3875d168bea7ac01d72d8e5fce0b6c5cf3ec06f4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3875d168bea7ac01d72d8e5fce0b6c5cf3ec06f4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c2430af280c1575d2c961d037a3752b9cdc9b0bf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c2430af280c1575d2c961d037a3752b9cdc9b0bf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c2430af280c1575d2c961d037a3752b9cdc9b0bf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c2430af280c1575d2c961d037a3752b9cdc9b0bf/comments",
    "author": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "75f7df8968e1328ec85a5f502bef81a3674d0d99",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75f7df8968e1328ec85a5f502bef81a3674d0d99",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/75f7df8968e1328ec85a5f502bef81a3674d0d99"
      }
    ],
    "stats": {
      "total": 224,
      "additions": 0,
      "deletions": 224
    },
    "files": [
      {
        "sha": "87d7100d263b50c88ea90451a601e813aebc0939",
        "filename": "test/functional/p2p_saahil.py",
        "status": "removed",
        "additions": 0,
        "deletions": 224,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75f7df8968e1328ec85a5f502bef81a3674d0d99/test/functional/p2p_saahil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75f7df8968e1328ec85a5f502bef81a3674d0d99/test/functional/p2p_saahil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_saahil.py?ref=75f7df8968e1328ec85a5f502bef81a3674d0d99",
        "patch": "@@ -1,224 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2017-2019 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"An example functional test\n-\n-The module-level docstring should include a high-level description of\n-what the test is doing. It's the first thing people see when they open\n-the file and should give the reader information about *what* the test\n-is testing and *how* it's being tested\n-\"\"\"\n-# Imports should be in PEP8 ordering (std library first, then third party\n-# libraries then local imports).\n-from collections import defaultdict\n-\n-# Avoid wildcard * imports\n-from test_framework.blocktools import (create_block, create_coinbase)\n-from test_framework.messages import CInv, MSG_BLOCK\n-from test_framework.mininode import (\n-    P2PInterface,\n-    mininode_lock,\n-    msg_block,\n-    msg_getdata,\n-)\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (\n-    assert_equal,\n-    connect_nodes,\n-    wait_until,\n-)\n-\n-# P2PInterface is a class containing callbacks to be executed when a P2P\n-# message is received from the node-under-test. Subclass P2PInterface and\n-# override the on_*() methods if you need custom behaviour.\n-class BaseNode(P2PInterface):\n-    def __init__(self):\n-        \"\"\"Initialize the P2PInterface\n-\n-        Used to initialize custom properties for the Node that aren't\n-        included by default in the base class. Be aware that the P2PInterface\n-        base class already stores a counter for each P2P message type and the\n-        last received message of each type, which should be sufficient for the\n-        needs of most tests.\n-\n-        Call super().__init__() first for standard initialization and then\n-        initialize custom properties.\"\"\"\n-        super().__init__()\n-        # Stores a dictionary of all blocks received\n-        self.block_receive_map = defaultdict(int)\n-\n-    def on_block(self, message):\n-        \"\"\"Override the standard on_block callback\n-\n-        Store the hash of a received block in the dictionary.\"\"\"\n-        message.block.calc_sha256()\n-        self.block_receive_map[message.block.sha256] += 1\n-\n-    def on_inv(self, message):\n-        \"\"\"Override the standard on_inv callback\"\"\"\n-        pass\n-\n-def custom_function():\n-    \"\"\"Do some custom behaviour\n-\n-    If this function is more generally useful for other tests, consider\n-    moving it to a module in test_framework.\"\"\"\n-    # self.log.info(\"running custom_function\")  # Oops! Can't run self.log outside the BitcoinTestFramework\n-    pass\n-\n-\n-class ExampleTest(BitcoinTestFramework):\n-    # Each functional test is a subclass of the BitcoinTestFramework class.\n-\n-    # Override the set_test_params(), skip_test_if_missing_module(), add_options(), setup_chain(), setup_network()\n-    # and setup_nodes() methods to customize the test setup as required.\n-\n-    def set_test_params(self):\n-        \"\"\"Override test parameters for your individual test.\n-\n-        This method must be overridden and num_nodes must be explicitly set.\"\"\"\n-        self.setup_clean_chain = True\n-        self.num_nodes = 3\n-        # Use self.extra_args to change command-line arguments for the nodes\n-        self.extra_args = [[], [\"-logips\"], []]\n-\n-        # self.log.info(\"I've finished set_test_params\")  # Oops! Can't run self.log before run_test()\n-\n-    # Use skip_test_if_missing_module() to skip the test if your test requires certain modules to be present.\n-    # This test uses generate which requires wallet to be compiled\n-    def skip_test_if_missing_module(self):\n-        self.skip_if_no_wallet()\n-\n-    # Use add_options() to add specific command-line options for your test.\n-    # In practice this is not used very much, since the tests are mostly written\n-    # to be run in automated environments without command-line options.\n-    # def add_options()\n-    #     pass\n-\n-    # Use setup_chain() to customize the node data directories. In practice\n-    # this is not used very much since the default behaviour is almost always\n-    # fine\n-    # def setup_chain():\n-    #     pass\n-\n-    def setup_network(self):\n-        \"\"\"Setup the test network topology\n-\n-        Often you won't need to override this, since the standard network topology\n-        (linear: node0 <-> node1 <-> node2 <-> ...) is fine for most tests.\n-\n-        If you do override this method, remember to start the nodes, assign\n-        them to self.nodes, connect them and then sync.\"\"\"\n-\n-        self.setup_nodes()\n-\n-        # In this test, we're not connecting node2 to node0 or node1. Calls to\n-        # sync_all() should not include node2, since we're not expecting it to\n-        # sync.\n-        #connect_nodes(self.nodes[0], 1)\n-        #self.sync_all(self.nodes[0:2])\n-\n-    # Use setup_nodes() to customize the node start behaviour (for example if\n-    # you don't want to start all nodes at the start of the test).\n-    # def setup_nodes():\n-    #     pass\n-\n-    def custom_method(self):\n-        \"\"\"Do some custom behaviour for this test\n-\n-        Define it in a method here because you're going to use it repeatedly.\n-        If you think it's useful in general, consider moving it to the base\n-        BitcoinTestFramework class so other tests can use it.\"\"\"\n-\n-        self.log.info(\"Running custom_method\")\n-\n-    def run_test(self):\n-        \"\"\"Main test logic\"\"\"\n-\n-        # Create P2P connections will wait for a verack to make sure the connection is fully up\n-        self.nodes[0].add_p2p_connection(BaseNode())\n-\n-        # Generating a block on one of the nodes will get us out of IBD\n-        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n-        self.log.info(\"Number of blocks in node 0: \" + str(self.nodes[0].getblockcount()))\n-        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n-        \n-        self.log.info(\"Now sending block from one to the other\")\n-        connect_nodes(self.nodes[0], 1)\n-        self.sync_all(self.nodes[0:2])\n-\n-        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n-\n-        # # Notice above how we called an RPC by calling a method with the same\n-        # # name on the node object. Notice also how we used a keyword argument\n-        # # to specify a named RPC argument. Neither of those are defined on the\n-        # # node object. Instead there's some __getattr__() magic going on under\n-        # # the covers to dispatch unrecognised attribute calls to the RPC\n-        # # interface.\n-\n-        # # Logs are nice. Do plenty of them. They can be used in place of comments for\n-        # # breaking the test into sub-sections.\n-        # self.log.info(\"Starting test!\")\n-\n-        # self.log.info(\"Calling a custom function\")\n-        # custom_function()\n-\n-        # self.log.info(\"Calling a custom method\")\n-        # self.custom_method()\n-\n-        # self.log.info(\"Create some blocks\")\n-        # self.tip = int(self.nodes[0].getbestblockhash(), 16)\n-        # self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n-\n-        # height = self.nodes[0].getblockcount()\n-\n-        # for i in range(10):\n-        #     # Use the mininode and blocktools functionality to manually build a block\n-        #     # Calling the generate() rpc is easier, but this allows us to exactly\n-        #     # control the blocks and transactions.\n-        #     block = create_block(self.tip, create_coinbase(height+1), self.block_time)\n-        #     block.solve()\n-        #     block_message = msg_block(block)\n-        #     # Send message is used to send a P2P message to the node over our P2PInterface\n-        #     self.nodes[0].p2p.send_message(block_message)\n-        #     self.tip = block.sha256\n-        #     blocks.append(self.tip)\n-        #     self.block_time += 1\n-        #     height += 1\n-\n-        # self.log.info(\"Wait for node1 to reach current tip (height 11) using RPC\")\n-        # self.nodes[1].waitforblockheight(11)\n-\n-        # self.log.info(\"Connect node2 and node1\")\n-        # connect_nodes(self.nodes[1], 2)\n-\n-        # self.log.info(\"Wait for node2 to receive all the blocks from node1\")\n-        # self.sync_all()\n-\n-        # self.log.info(\"Add P2P connection to node2\")\n-        # self.nodes[0].disconnect_p2ps()\n-\n-        # self.nodes[2].add_p2p_connection(BaseNode())\n-\n-        # self.log.info(\"Test that node2 propagates all the blocks to us\")\n-\n-        # getdata_request = msg_getdata()\n-        # for block in blocks:\n-        #     getdata_request.inv.append(CInv(MSG_BLOCK, block))\n-        # self.nodes[2].p2p.send_message(getdata_request)\n-\n-        # # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n-        # # P2PInterface objects.\n-        # wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n-\n-        # self.log.info(\"Check that each block was received only once\")\n-        # # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving\n-        # # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking\n-        # # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n-        # with mininode_lock:\n-        #     for block in self.nodes[2].p2p.block_receive_map.values():\n-        #         assert_equal(block, 1)\n-\n-if __name__ == '__main__':\n-    ExampleTest().main()"
      }
    ]
  },
  {
    "sha": "bb4b32abd5631d0b90b22143e897b97e0a210215",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiYjRiMzJhYmQ1NjMxZDBiOTBiMjIxNDNlODk3Yjk3ZTBhMjEwMjE1",
    "commit": {
      "author": {
        "name": "Saahil Shangle",
        "email": "saahilshangle@gmail.com",
        "date": "2020-06-08T00:20:11Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:54:02Z"
      },
      "message": "Attempted test where one node sends block to another",
      "tree": {
        "sha": "05f9ad7262ea082a6bb38623ea12ef27c8341099",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/05f9ad7262ea082a6bb38623ea12ef27c8341099"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bb4b32abd5631d0b90b22143e897b97e0a210215",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bb4b32abd5631d0b90b22143e897b97e0a210215",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bb4b32abd5631d0b90b22143e897b97e0a210215",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bb4b32abd5631d0b90b22143e897b97e0a210215/comments",
    "author": {
      "login": "saahilshangle",
      "id": 10226886,
      "node_id": "MDQ6VXNlcjEwMjI2ODg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10226886?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saahilshangle",
      "html_url": "https://github.com/saahilshangle",
      "followers_url": "https://api.github.com/users/saahilshangle/followers",
      "following_url": "https://api.github.com/users/saahilshangle/following{/other_user}",
      "gists_url": "https://api.github.com/users/saahilshangle/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saahilshangle/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saahilshangle/subscriptions",
      "organizations_url": "https://api.github.com/users/saahilshangle/orgs",
      "repos_url": "https://api.github.com/users/saahilshangle/repos",
      "events_url": "https://api.github.com/users/saahilshangle/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saahilshangle/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c2430af280c1575d2c961d037a3752b9cdc9b0bf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c2430af280c1575d2c961d037a3752b9cdc9b0bf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c2430af280c1575d2c961d037a3752b9cdc9b0bf"
      }
    ],
    "stats": {
      "total": 224,
      "additions": 224,
      "deletions": 0
    },
    "files": [
      {
        "sha": "87d7100d263b50c88ea90451a601e813aebc0939",
        "filename": "test/functional/p2p_saahil.py",
        "status": "added",
        "additions": 224,
        "deletions": 0,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bb4b32abd5631d0b90b22143e897b97e0a210215/test/functional/p2p_saahil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bb4b32abd5631d0b90b22143e897b97e0a210215/test/functional/p2p_saahil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_saahil.py?ref=bb4b32abd5631d0b90b22143e897b97e0a210215",
        "patch": "@@ -0,0 +1,224 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"An example functional test\n+\n+The module-level docstring should include a high-level description of\n+what the test is doing. It's the first thing people see when they open\n+the file and should give the reader information about *what* the test\n+is testing and *how* it's being tested\n+\"\"\"\n+# Imports should be in PEP8 ordering (std library first, then third party\n+# libraries then local imports).\n+from collections import defaultdict\n+\n+# Avoid wildcard * imports\n+from test_framework.blocktools import (create_block, create_coinbase)\n+from test_framework.messages import CInv, MSG_BLOCK\n+from test_framework.mininode import (\n+    P2PInterface,\n+    mininode_lock,\n+    msg_block,\n+    msg_getdata,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    connect_nodes,\n+    wait_until,\n+)\n+\n+# P2PInterface is a class containing callbacks to be executed when a P2P\n+# message is received from the node-under-test. Subclass P2PInterface and\n+# override the on_*() methods if you need custom behaviour.\n+class BaseNode(P2PInterface):\n+    def __init__(self):\n+        \"\"\"Initialize the P2PInterface\n+\n+        Used to initialize custom properties for the Node that aren't\n+        included by default in the base class. Be aware that the P2PInterface\n+        base class already stores a counter for each P2P message type and the\n+        last received message of each type, which should be sufficient for the\n+        needs of most tests.\n+\n+        Call super().__init__() first for standard initialization and then\n+        initialize custom properties.\"\"\"\n+        super().__init__()\n+        # Stores a dictionary of all blocks received\n+        self.block_receive_map = defaultdict(int)\n+\n+    def on_block(self, message):\n+        \"\"\"Override the standard on_block callback\n+\n+        Store the hash of a received block in the dictionary.\"\"\"\n+        message.block.calc_sha256()\n+        self.block_receive_map[message.block.sha256] += 1\n+\n+    def on_inv(self, message):\n+        \"\"\"Override the standard on_inv callback\"\"\"\n+        pass\n+\n+def custom_function():\n+    \"\"\"Do some custom behaviour\n+\n+    If this function is more generally useful for other tests, consider\n+    moving it to a module in test_framework.\"\"\"\n+    # self.log.info(\"running custom_function\")  # Oops! Can't run self.log outside the BitcoinTestFramework\n+    pass\n+\n+\n+class ExampleTest(BitcoinTestFramework):\n+    # Each functional test is a subclass of the BitcoinTestFramework class.\n+\n+    # Override the set_test_params(), skip_test_if_missing_module(), add_options(), setup_chain(), setup_network()\n+    # and setup_nodes() methods to customize the test setup as required.\n+\n+    def set_test_params(self):\n+        \"\"\"Override test parameters for your individual test.\n+\n+        This method must be overridden and num_nodes must be explicitly set.\"\"\"\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+        # Use self.extra_args to change command-line arguments for the nodes\n+        self.extra_args = [[], [\"-logips\"], []]\n+\n+        # self.log.info(\"I've finished set_test_params\")  # Oops! Can't run self.log before run_test()\n+\n+    # Use skip_test_if_missing_module() to skip the test if your test requires certain modules to be present.\n+    # This test uses generate which requires wallet to be compiled\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    # Use add_options() to add specific command-line options for your test.\n+    # In practice this is not used very much, since the tests are mostly written\n+    # to be run in automated environments without command-line options.\n+    # def add_options()\n+    #     pass\n+\n+    # Use setup_chain() to customize the node data directories. In practice\n+    # this is not used very much since the default behaviour is almost always\n+    # fine\n+    # def setup_chain():\n+    #     pass\n+\n+    def setup_network(self):\n+        \"\"\"Setup the test network topology\n+\n+        Often you won't need to override this, since the standard network topology\n+        (linear: node0 <-> node1 <-> node2 <-> ...) is fine for most tests.\n+\n+        If you do override this method, remember to start the nodes, assign\n+        them to self.nodes, connect them and then sync.\"\"\"\n+\n+        self.setup_nodes()\n+\n+        # In this test, we're not connecting node2 to node0 or node1. Calls to\n+        # sync_all() should not include node2, since we're not expecting it to\n+        # sync.\n+        #connect_nodes(self.nodes[0], 1)\n+        #self.sync_all(self.nodes[0:2])\n+\n+    # Use setup_nodes() to customize the node start behaviour (for example if\n+    # you don't want to start all nodes at the start of the test).\n+    # def setup_nodes():\n+    #     pass\n+\n+    def custom_method(self):\n+        \"\"\"Do some custom behaviour for this test\n+\n+        Define it in a method here because you're going to use it repeatedly.\n+        If you think it's useful in general, consider moving it to the base\n+        BitcoinTestFramework class so other tests can use it.\"\"\"\n+\n+        self.log.info(\"Running custom_method\")\n+\n+    def run_test(self):\n+        \"\"\"Main test logic\"\"\"\n+\n+        # Create P2P connections will wait for a verack to make sure the connection is fully up\n+        self.nodes[0].add_p2p_connection(BaseNode())\n+\n+        # Generating a block on one of the nodes will get us out of IBD\n+        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n+        self.log.info(\"Number of blocks in node 0: \" + str(self.nodes[0].getblockcount()))\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+        \n+        self.log.info(\"Now sending block from one to the other\")\n+        connect_nodes(self.nodes[0], 1)\n+        self.sync_all(self.nodes[0:2])\n+\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+\n+        # # Notice above how we called an RPC by calling a method with the same\n+        # # name on the node object. Notice also how we used a keyword argument\n+        # # to specify a named RPC argument. Neither of those are defined on the\n+        # # node object. Instead there's some __getattr__() magic going on under\n+        # # the covers to dispatch unrecognised attribute calls to the RPC\n+        # # interface.\n+\n+        # # Logs are nice. Do plenty of them. They can be used in place of comments for\n+        # # breaking the test into sub-sections.\n+        # self.log.info(\"Starting test!\")\n+\n+        # self.log.info(\"Calling a custom function\")\n+        # custom_function()\n+\n+        # self.log.info(\"Calling a custom method\")\n+        # self.custom_method()\n+\n+        # self.log.info(\"Create some blocks\")\n+        # self.tip = int(self.nodes[0].getbestblockhash(), 16)\n+        # self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n+\n+        # height = self.nodes[0].getblockcount()\n+\n+        # for i in range(10):\n+        #     # Use the mininode and blocktools functionality to manually build a block\n+        #     # Calling the generate() rpc is easier, but this allows us to exactly\n+        #     # control the blocks and transactions.\n+        #     block = create_block(self.tip, create_coinbase(height+1), self.block_time)\n+        #     block.solve()\n+        #     block_message = msg_block(block)\n+        #     # Send message is used to send a P2P message to the node over our P2PInterface\n+        #     self.nodes[0].p2p.send_message(block_message)\n+        #     self.tip = block.sha256\n+        #     blocks.append(self.tip)\n+        #     self.block_time += 1\n+        #     height += 1\n+\n+        # self.log.info(\"Wait for node1 to reach current tip (height 11) using RPC\")\n+        # self.nodes[1].waitforblockheight(11)\n+\n+        # self.log.info(\"Connect node2 and node1\")\n+        # connect_nodes(self.nodes[1], 2)\n+\n+        # self.log.info(\"Wait for node2 to receive all the blocks from node1\")\n+        # self.sync_all()\n+\n+        # self.log.info(\"Add P2P connection to node2\")\n+        # self.nodes[0].disconnect_p2ps()\n+\n+        # self.nodes[2].add_p2p_connection(BaseNode())\n+\n+        # self.log.info(\"Test that node2 propagates all the blocks to us\")\n+\n+        # getdata_request = msg_getdata()\n+        # for block in blocks:\n+        #     getdata_request.inv.append(CInv(MSG_BLOCK, block))\n+        # self.nodes[2].p2p.send_message(getdata_request)\n+\n+        # # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n+        # # P2PInterface objects.\n+        # wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n+\n+        # self.log.info(\"Check that each block was received only once\")\n+        # # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving\n+        # # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking\n+        # # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n+        # with mininode_lock:\n+        #     for block in self.nodes[2].p2p.block_receive_map.values():\n+        #         assert_equal(block, 1)\n+\n+if __name__ == '__main__':\n+    ExampleTest().main()"
      }
    ]
  },
  {
    "sha": "d595cb8af63b784a2eda1f6b933775c4879599c5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNTk1Y2I4YWY2M2I3ODRhMmVkYTFmNmI5MzM3NzVjNDg3OTU5OWM1",
    "commit": {
      "author": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-07T06:39:46Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:54:02Z"
      },
      "message": "Revert \"Attempted test where one node sends block to another\"\n\nThis reverts commit 55cf78aae878ac1e2a8ed5712877465a2e4a938c.",
      "tree": {
        "sha": "3875d168bea7ac01d72d8e5fce0b6c5cf3ec06f4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3875d168bea7ac01d72d8e5fce0b6c5cf3ec06f4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d595cb8af63b784a2eda1f6b933775c4879599c5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d595cb8af63b784a2eda1f6b933775c4879599c5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d595cb8af63b784a2eda1f6b933775c4879599c5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d595cb8af63b784a2eda1f6b933775c4879599c5/comments",
    "author": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bb4b32abd5631d0b90b22143e897b97e0a210215",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bb4b32abd5631d0b90b22143e897b97e0a210215",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bb4b32abd5631d0b90b22143e897b97e0a210215"
      }
    ],
    "stats": {
      "total": 224,
      "additions": 0,
      "deletions": 224
    },
    "files": [
      {
        "sha": "87d7100d263b50c88ea90451a601e813aebc0939",
        "filename": "test/functional/p2p_saahil.py",
        "status": "removed",
        "additions": 0,
        "deletions": 224,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bb4b32abd5631d0b90b22143e897b97e0a210215/test/functional/p2p_saahil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bb4b32abd5631d0b90b22143e897b97e0a210215/test/functional/p2p_saahil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_saahil.py?ref=bb4b32abd5631d0b90b22143e897b97e0a210215",
        "patch": "@@ -1,224 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2017-2019 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"An example functional test\n-\n-The module-level docstring should include a high-level description of\n-what the test is doing. It's the first thing people see when they open\n-the file and should give the reader information about *what* the test\n-is testing and *how* it's being tested\n-\"\"\"\n-# Imports should be in PEP8 ordering (std library first, then third party\n-# libraries then local imports).\n-from collections import defaultdict\n-\n-# Avoid wildcard * imports\n-from test_framework.blocktools import (create_block, create_coinbase)\n-from test_framework.messages import CInv, MSG_BLOCK\n-from test_framework.mininode import (\n-    P2PInterface,\n-    mininode_lock,\n-    msg_block,\n-    msg_getdata,\n-)\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (\n-    assert_equal,\n-    connect_nodes,\n-    wait_until,\n-)\n-\n-# P2PInterface is a class containing callbacks to be executed when a P2P\n-# message is received from the node-under-test. Subclass P2PInterface and\n-# override the on_*() methods if you need custom behaviour.\n-class BaseNode(P2PInterface):\n-    def __init__(self):\n-        \"\"\"Initialize the P2PInterface\n-\n-        Used to initialize custom properties for the Node that aren't\n-        included by default in the base class. Be aware that the P2PInterface\n-        base class already stores a counter for each P2P message type and the\n-        last received message of each type, which should be sufficient for the\n-        needs of most tests.\n-\n-        Call super().__init__() first for standard initialization and then\n-        initialize custom properties.\"\"\"\n-        super().__init__()\n-        # Stores a dictionary of all blocks received\n-        self.block_receive_map = defaultdict(int)\n-\n-    def on_block(self, message):\n-        \"\"\"Override the standard on_block callback\n-\n-        Store the hash of a received block in the dictionary.\"\"\"\n-        message.block.calc_sha256()\n-        self.block_receive_map[message.block.sha256] += 1\n-\n-    def on_inv(self, message):\n-        \"\"\"Override the standard on_inv callback\"\"\"\n-        pass\n-\n-def custom_function():\n-    \"\"\"Do some custom behaviour\n-\n-    If this function is more generally useful for other tests, consider\n-    moving it to a module in test_framework.\"\"\"\n-    # self.log.info(\"running custom_function\")  # Oops! Can't run self.log outside the BitcoinTestFramework\n-    pass\n-\n-\n-class ExampleTest(BitcoinTestFramework):\n-    # Each functional test is a subclass of the BitcoinTestFramework class.\n-\n-    # Override the set_test_params(), skip_test_if_missing_module(), add_options(), setup_chain(), setup_network()\n-    # and setup_nodes() methods to customize the test setup as required.\n-\n-    def set_test_params(self):\n-        \"\"\"Override test parameters for your individual test.\n-\n-        This method must be overridden and num_nodes must be explicitly set.\"\"\"\n-        self.setup_clean_chain = True\n-        self.num_nodes = 3\n-        # Use self.extra_args to change command-line arguments for the nodes\n-        self.extra_args = [[], [\"-logips\"], []]\n-\n-        # self.log.info(\"I've finished set_test_params\")  # Oops! Can't run self.log before run_test()\n-\n-    # Use skip_test_if_missing_module() to skip the test if your test requires certain modules to be present.\n-    # This test uses generate which requires wallet to be compiled\n-    def skip_test_if_missing_module(self):\n-        self.skip_if_no_wallet()\n-\n-    # Use add_options() to add specific command-line options for your test.\n-    # In practice this is not used very much, since the tests are mostly written\n-    # to be run in automated environments without command-line options.\n-    # def add_options()\n-    #     pass\n-\n-    # Use setup_chain() to customize the node data directories. In practice\n-    # this is not used very much since the default behaviour is almost always\n-    # fine\n-    # def setup_chain():\n-    #     pass\n-\n-    def setup_network(self):\n-        \"\"\"Setup the test network topology\n-\n-        Often you won't need to override this, since the standard network topology\n-        (linear: node0 <-> node1 <-> node2 <-> ...) is fine for most tests.\n-\n-        If you do override this method, remember to start the nodes, assign\n-        them to self.nodes, connect them and then sync.\"\"\"\n-\n-        self.setup_nodes()\n-\n-        # In this test, we're not connecting node2 to node0 or node1. Calls to\n-        # sync_all() should not include node2, since we're not expecting it to\n-        # sync.\n-        #connect_nodes(self.nodes[0], 1)\n-        #self.sync_all(self.nodes[0:2])\n-\n-    # Use setup_nodes() to customize the node start behaviour (for example if\n-    # you don't want to start all nodes at the start of the test).\n-    # def setup_nodes():\n-    #     pass\n-\n-    def custom_method(self):\n-        \"\"\"Do some custom behaviour for this test\n-\n-        Define it in a method here because you're going to use it repeatedly.\n-        If you think it's useful in general, consider moving it to the base\n-        BitcoinTestFramework class so other tests can use it.\"\"\"\n-\n-        self.log.info(\"Running custom_method\")\n-\n-    def run_test(self):\n-        \"\"\"Main test logic\"\"\"\n-\n-        # Create P2P connections will wait for a verack to make sure the connection is fully up\n-        self.nodes[0].add_p2p_connection(BaseNode())\n-\n-        # Generating a block on one of the nodes will get us out of IBD\n-        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n-        self.log.info(\"Number of blocks in node 0: \" + str(self.nodes[0].getblockcount()))\n-        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n-        \n-        self.log.info(\"Now sending block from one to the other\")\n-        connect_nodes(self.nodes[0], 1)\n-        self.sync_all(self.nodes[0:2])\n-\n-        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n-\n-        # # Notice above how we called an RPC by calling a method with the same\n-        # # name on the node object. Notice also how we used a keyword argument\n-        # # to specify a named RPC argument. Neither of those are defined on the\n-        # # node object. Instead there's some __getattr__() magic going on under\n-        # # the covers to dispatch unrecognised attribute calls to the RPC\n-        # # interface.\n-\n-        # # Logs are nice. Do plenty of them. They can be used in place of comments for\n-        # # breaking the test into sub-sections.\n-        # self.log.info(\"Starting test!\")\n-\n-        # self.log.info(\"Calling a custom function\")\n-        # custom_function()\n-\n-        # self.log.info(\"Calling a custom method\")\n-        # self.custom_method()\n-\n-        # self.log.info(\"Create some blocks\")\n-        # self.tip = int(self.nodes[0].getbestblockhash(), 16)\n-        # self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n-\n-        # height = self.nodes[0].getblockcount()\n-\n-        # for i in range(10):\n-        #     # Use the mininode and blocktools functionality to manually build a block\n-        #     # Calling the generate() rpc is easier, but this allows us to exactly\n-        #     # control the blocks and transactions.\n-        #     block = create_block(self.tip, create_coinbase(height+1), self.block_time)\n-        #     block.solve()\n-        #     block_message = msg_block(block)\n-        #     # Send message is used to send a P2P message to the node over our P2PInterface\n-        #     self.nodes[0].p2p.send_message(block_message)\n-        #     self.tip = block.sha256\n-        #     blocks.append(self.tip)\n-        #     self.block_time += 1\n-        #     height += 1\n-\n-        # self.log.info(\"Wait for node1 to reach current tip (height 11) using RPC\")\n-        # self.nodes[1].waitforblockheight(11)\n-\n-        # self.log.info(\"Connect node2 and node1\")\n-        # connect_nodes(self.nodes[1], 2)\n-\n-        # self.log.info(\"Wait for node2 to receive all the blocks from node1\")\n-        # self.sync_all()\n-\n-        # self.log.info(\"Add P2P connection to node2\")\n-        # self.nodes[0].disconnect_p2ps()\n-\n-        # self.nodes[2].add_p2p_connection(BaseNode())\n-\n-        # self.log.info(\"Test that node2 propagates all the blocks to us\")\n-\n-        # getdata_request = msg_getdata()\n-        # for block in blocks:\n-        #     getdata_request.inv.append(CInv(MSG_BLOCK, block))\n-        # self.nodes[2].p2p.send_message(getdata_request)\n-\n-        # # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n-        # # P2PInterface objects.\n-        # wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n-\n-        # self.log.info(\"Check that each block was received only once\")\n-        # # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving\n-        # # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking\n-        # # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n-        # with mininode_lock:\n-        #     for block in self.nodes[2].p2p.block_receive_map.values():\n-        #         assert_equal(block, 1)\n-\n-if __name__ == '__main__':\n-    ExampleTest().main()"
      }
    ]
  },
  {
    "sha": "657e05697f2740c2ccb564aa954d73a0b4669d6d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NTdlMDU2OTdmMjc0MGMyY2NiNTY0YWE5NTRkNzNhMGI0NjY5ZDZk",
    "commit": {
      "author": {
        "name": "Saahil Shangle",
        "email": "saahilshangle@gmail.com",
        "date": "2020-06-08T00:20:11Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:54:03Z"
      },
      "message": "Attempted test where one node sends block to another",
      "tree": {
        "sha": "05f9ad7262ea082a6bb38623ea12ef27c8341099",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/05f9ad7262ea082a6bb38623ea12ef27c8341099"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/657e05697f2740c2ccb564aa954d73a0b4669d6d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/657e05697f2740c2ccb564aa954d73a0b4669d6d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/657e05697f2740c2ccb564aa954d73a0b4669d6d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/657e05697f2740c2ccb564aa954d73a0b4669d6d/comments",
    "author": {
      "login": "saahilshangle",
      "id": 10226886,
      "node_id": "MDQ6VXNlcjEwMjI2ODg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10226886?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saahilshangle",
      "html_url": "https://github.com/saahilshangle",
      "followers_url": "https://api.github.com/users/saahilshangle/followers",
      "following_url": "https://api.github.com/users/saahilshangle/following{/other_user}",
      "gists_url": "https://api.github.com/users/saahilshangle/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saahilshangle/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saahilshangle/subscriptions",
      "organizations_url": "https://api.github.com/users/saahilshangle/orgs",
      "repos_url": "https://api.github.com/users/saahilshangle/repos",
      "events_url": "https://api.github.com/users/saahilshangle/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saahilshangle/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d595cb8af63b784a2eda1f6b933775c4879599c5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d595cb8af63b784a2eda1f6b933775c4879599c5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d595cb8af63b784a2eda1f6b933775c4879599c5"
      }
    ],
    "stats": {
      "total": 224,
      "additions": 224,
      "deletions": 0
    },
    "files": [
      {
        "sha": "87d7100d263b50c88ea90451a601e813aebc0939",
        "filename": "test/functional/p2p_saahil.py",
        "status": "added",
        "additions": 224,
        "deletions": 0,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/657e05697f2740c2ccb564aa954d73a0b4669d6d/test/functional/p2p_saahil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/657e05697f2740c2ccb564aa954d73a0b4669d6d/test/functional/p2p_saahil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_saahil.py?ref=657e05697f2740c2ccb564aa954d73a0b4669d6d",
        "patch": "@@ -0,0 +1,224 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"An example functional test\n+\n+The module-level docstring should include a high-level description of\n+what the test is doing. It's the first thing people see when they open\n+the file and should give the reader information about *what* the test\n+is testing and *how* it's being tested\n+\"\"\"\n+# Imports should be in PEP8 ordering (std library first, then third party\n+# libraries then local imports).\n+from collections import defaultdict\n+\n+# Avoid wildcard * imports\n+from test_framework.blocktools import (create_block, create_coinbase)\n+from test_framework.messages import CInv, MSG_BLOCK\n+from test_framework.mininode import (\n+    P2PInterface,\n+    mininode_lock,\n+    msg_block,\n+    msg_getdata,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    connect_nodes,\n+    wait_until,\n+)\n+\n+# P2PInterface is a class containing callbacks to be executed when a P2P\n+# message is received from the node-under-test. Subclass P2PInterface and\n+# override the on_*() methods if you need custom behaviour.\n+class BaseNode(P2PInterface):\n+    def __init__(self):\n+        \"\"\"Initialize the P2PInterface\n+\n+        Used to initialize custom properties for the Node that aren't\n+        included by default in the base class. Be aware that the P2PInterface\n+        base class already stores a counter for each P2P message type and the\n+        last received message of each type, which should be sufficient for the\n+        needs of most tests.\n+\n+        Call super().__init__() first for standard initialization and then\n+        initialize custom properties.\"\"\"\n+        super().__init__()\n+        # Stores a dictionary of all blocks received\n+        self.block_receive_map = defaultdict(int)\n+\n+    def on_block(self, message):\n+        \"\"\"Override the standard on_block callback\n+\n+        Store the hash of a received block in the dictionary.\"\"\"\n+        message.block.calc_sha256()\n+        self.block_receive_map[message.block.sha256] += 1\n+\n+    def on_inv(self, message):\n+        \"\"\"Override the standard on_inv callback\"\"\"\n+        pass\n+\n+def custom_function():\n+    \"\"\"Do some custom behaviour\n+\n+    If this function is more generally useful for other tests, consider\n+    moving it to a module in test_framework.\"\"\"\n+    # self.log.info(\"running custom_function\")  # Oops! Can't run self.log outside the BitcoinTestFramework\n+    pass\n+\n+\n+class ExampleTest(BitcoinTestFramework):\n+    # Each functional test is a subclass of the BitcoinTestFramework class.\n+\n+    # Override the set_test_params(), skip_test_if_missing_module(), add_options(), setup_chain(), setup_network()\n+    # and setup_nodes() methods to customize the test setup as required.\n+\n+    def set_test_params(self):\n+        \"\"\"Override test parameters for your individual test.\n+\n+        This method must be overridden and num_nodes must be explicitly set.\"\"\"\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+        # Use self.extra_args to change command-line arguments for the nodes\n+        self.extra_args = [[], [\"-logips\"], []]\n+\n+        # self.log.info(\"I've finished set_test_params\")  # Oops! Can't run self.log before run_test()\n+\n+    # Use skip_test_if_missing_module() to skip the test if your test requires certain modules to be present.\n+    # This test uses generate which requires wallet to be compiled\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    # Use add_options() to add specific command-line options for your test.\n+    # In practice this is not used very much, since the tests are mostly written\n+    # to be run in automated environments without command-line options.\n+    # def add_options()\n+    #     pass\n+\n+    # Use setup_chain() to customize the node data directories. In practice\n+    # this is not used very much since the default behaviour is almost always\n+    # fine\n+    # def setup_chain():\n+    #     pass\n+\n+    def setup_network(self):\n+        \"\"\"Setup the test network topology\n+\n+        Often you won't need to override this, since the standard network topology\n+        (linear: node0 <-> node1 <-> node2 <-> ...) is fine for most tests.\n+\n+        If you do override this method, remember to start the nodes, assign\n+        them to self.nodes, connect them and then sync.\"\"\"\n+\n+        self.setup_nodes()\n+\n+        # In this test, we're not connecting node2 to node0 or node1. Calls to\n+        # sync_all() should not include node2, since we're not expecting it to\n+        # sync.\n+        #connect_nodes(self.nodes[0], 1)\n+        #self.sync_all(self.nodes[0:2])\n+\n+    # Use setup_nodes() to customize the node start behaviour (for example if\n+    # you don't want to start all nodes at the start of the test).\n+    # def setup_nodes():\n+    #     pass\n+\n+    def custom_method(self):\n+        \"\"\"Do some custom behaviour for this test\n+\n+        Define it in a method here because you're going to use it repeatedly.\n+        If you think it's useful in general, consider moving it to the base\n+        BitcoinTestFramework class so other tests can use it.\"\"\"\n+\n+        self.log.info(\"Running custom_method\")\n+\n+    def run_test(self):\n+        \"\"\"Main test logic\"\"\"\n+\n+        # Create P2P connections will wait for a verack to make sure the connection is fully up\n+        self.nodes[0].add_p2p_connection(BaseNode())\n+\n+        # Generating a block on one of the nodes will get us out of IBD\n+        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n+        self.log.info(\"Number of blocks in node 0: \" + str(self.nodes[0].getblockcount()))\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+        \n+        self.log.info(\"Now sending block from one to the other\")\n+        connect_nodes(self.nodes[0], 1)\n+        self.sync_all(self.nodes[0:2])\n+\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+\n+        # # Notice above how we called an RPC by calling a method with the same\n+        # # name on the node object. Notice also how we used a keyword argument\n+        # # to specify a named RPC argument. Neither of those are defined on the\n+        # # node object. Instead there's some __getattr__() magic going on under\n+        # # the covers to dispatch unrecognised attribute calls to the RPC\n+        # # interface.\n+\n+        # # Logs are nice. Do plenty of them. They can be used in place of comments for\n+        # # breaking the test into sub-sections.\n+        # self.log.info(\"Starting test!\")\n+\n+        # self.log.info(\"Calling a custom function\")\n+        # custom_function()\n+\n+        # self.log.info(\"Calling a custom method\")\n+        # self.custom_method()\n+\n+        # self.log.info(\"Create some blocks\")\n+        # self.tip = int(self.nodes[0].getbestblockhash(), 16)\n+        # self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n+\n+        # height = self.nodes[0].getblockcount()\n+\n+        # for i in range(10):\n+        #     # Use the mininode and blocktools functionality to manually build a block\n+        #     # Calling the generate() rpc is easier, but this allows us to exactly\n+        #     # control the blocks and transactions.\n+        #     block = create_block(self.tip, create_coinbase(height+1), self.block_time)\n+        #     block.solve()\n+        #     block_message = msg_block(block)\n+        #     # Send message is used to send a P2P message to the node over our P2PInterface\n+        #     self.nodes[0].p2p.send_message(block_message)\n+        #     self.tip = block.sha256\n+        #     blocks.append(self.tip)\n+        #     self.block_time += 1\n+        #     height += 1\n+\n+        # self.log.info(\"Wait for node1 to reach current tip (height 11) using RPC\")\n+        # self.nodes[1].waitforblockheight(11)\n+\n+        # self.log.info(\"Connect node2 and node1\")\n+        # connect_nodes(self.nodes[1], 2)\n+\n+        # self.log.info(\"Wait for node2 to receive all the blocks from node1\")\n+        # self.sync_all()\n+\n+        # self.log.info(\"Add P2P connection to node2\")\n+        # self.nodes[0].disconnect_p2ps()\n+\n+        # self.nodes[2].add_p2p_connection(BaseNode())\n+\n+        # self.log.info(\"Test that node2 propagates all the blocks to us\")\n+\n+        # getdata_request = msg_getdata()\n+        # for block in blocks:\n+        #     getdata_request.inv.append(CInv(MSG_BLOCK, block))\n+        # self.nodes[2].p2p.send_message(getdata_request)\n+\n+        # # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n+        # # P2PInterface objects.\n+        # wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n+\n+        # self.log.info(\"Check that each block was received only once\")\n+        # # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving\n+        # # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking\n+        # # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n+        # with mininode_lock:\n+        #     for block in self.nodes[2].p2p.block_receive_map.values():\n+        #         assert_equal(block, 1)\n+\n+if __name__ == '__main__':\n+    ExampleTest().main()"
      }
    ]
  },
  {
    "sha": "54d5440f9359b5056d172856dfc4d51c71c8111b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NGQ1NDQwZjkzNTliNTA1NmQxNzI4NTZkZmM0ZDUxYzcxYzgxMTFi",
    "commit": {
      "author": {
        "name": "Fabian Jahr",
        "email": "fjahr@protonmail.com",
        "date": "2020-06-02T21:41:04Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:54:13Z"
      },
      "message": "refactor: Extract GetBogoSize function",
      "tree": {
        "sha": "972888f7b11b9d45802e37b2efd3be21b3173cf0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/972888f7b11b9d45802e37b2efd3be21b3173cf0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/54d5440f9359b5056d172856dfc4d51c71c8111b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54d5440f9359b5056d172856dfc4d51c71c8111b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/54d5440f9359b5056d172856dfc4d51c71c8111b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54d5440f9359b5056d172856dfc4d51c71c8111b/comments",
    "author": {
      "login": "fjahr",
      "id": 1322187,
      "node_id": "MDQ6VXNlcjEzMjIxODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjahr",
      "html_url": "https://github.com/fjahr",
      "followers_url": "https://api.github.com/users/fjahr/followers",
      "following_url": "https://api.github.com/users/fjahr/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjahr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
      "organizations_url": "https://api.github.com/users/fjahr/orgs",
      "repos_url": "https://api.github.com/users/fjahr/repos",
      "events_url": "https://api.github.com/users/fjahr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjahr/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "657e05697f2740c2ccb564aa954d73a0b4669d6d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/657e05697f2740c2ccb564aa954d73a0b4669d6d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/657e05697f2740c2ccb564aa954d73a0b4669d6d"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "aeb7ccd4f835a76bc7b79c0c24cd279a0ec84075",
        "filename": "src/node/coinstats.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54d5440f9359b5056d172856dfc4d51c71c8111b/src/node/coinstats.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54d5440f9359b5056d172856dfc4d51c71c8111b/src/node/coinstats.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coinstats.cpp?ref=54d5440f9359b5056d172856dfc4d51c71c8111b",
        "patch": "@@ -24,7 +24,7 @@ static uint64_t GetBogoSize(const CScript& scriptPubKey)\n            scriptPubKey.size() /* scriptPubKey */;\n }\n \n-static void ApplyStats(CCoinsStats& stats, CHashWriter& ss, const uint256& hash, const std::map<uint32_t, Coin>& outputs)\n+static void ApplyStats(CCoinsStats &stats, CHashWriter& ss, const uint256& hash, const std::map<uint32_t, Coin>& outputs)\n {\n     assert(!outputs.empty());\n     ss << hash;"
      }
    ]
  },
  {
    "sha": "8c738e7cb8836e34bac3246e4e906f274c3b035b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YzczOGU3Y2I4ODM2ZTM0YmFjMzI0NmU0ZTkwNmYyNzRjM2IwMzVi",
    "commit": {
      "author": {
        "name": "Fabian Jahr",
        "email": "fjahr@protonmail.com",
        "date": "2020-06-02T21:52:34Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:54:14Z"
      },
      "message": "rpc: gettxoutsetinfo can specify hash_type (only legacy option for now)",
      "tree": {
        "sha": "05f9ad7262ea082a6bb38623ea12ef27c8341099",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/05f9ad7262ea082a6bb38623ea12ef27c8341099"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8c738e7cb8836e34bac3246e4e906f274c3b035b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c738e7cb8836e34bac3246e4e906f274c3b035b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8c738e7cb8836e34bac3246e4e906f274c3b035b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c738e7cb8836e34bac3246e4e906f274c3b035b/comments",
    "author": {
      "login": "fjahr",
      "id": 1322187,
      "node_id": "MDQ6VXNlcjEzMjIxODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjahr",
      "html_url": "https://github.com/fjahr",
      "followers_url": "https://api.github.com/users/fjahr/followers",
      "following_url": "https://api.github.com/users/fjahr/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjahr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
      "organizations_url": "https://api.github.com/users/fjahr/orgs",
      "repos_url": "https://api.github.com/users/fjahr/repos",
      "events_url": "https://api.github.com/users/fjahr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjahr/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "54d5440f9359b5056d172856dfc4d51c71c8111b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54d5440f9359b5056d172856dfc4d51c71c8111b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/54d5440f9359b5056d172856dfc4d51c71c8111b"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "21632263dc6df963de2a898385bb28ae6bf0c146",
        "filename": "src/node/coinstats.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8c738e7cb8836e34bac3246e4e906f274c3b035b/src/node/coinstats.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8c738e7cb8836e34bac3246e4e906f274c3b035b/src/node/coinstats.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coinstats.cpp?ref=8c738e7cb8836e34bac3246e4e906f274c3b035b",
        "patch": "@@ -24,7 +24,7 @@ static uint64_t GetBogoSize(const CScript& scriptPubKey)\n            scriptPubKey.size() /* scriptPubKey */;\n }\n \n-static void ApplyStats(CCoinsStats &stats, CHashWriter& ss, const uint256& hash, const std::map<uint32_t, Coin>& outputs)\n+static void ApplyStats(CCoinsStats& stats, CHashWriter& ss, const uint256& hash, const std::map<uint32_t, Coin>& outputs)\n {\n     assert(!outputs.empty());\n     ss << hash;"
      }
    ]
  },
  {
    "sha": "c20f46ea7dc98eff281120aff4fb3e5538924e9a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMjBmNDZlYTdkYzk4ZWZmMjgxMTIwYWZmNGZiM2U1NTM4OTI0ZTlh",
    "commit": {
      "author": {
        "name": "Fabian Jahr",
        "email": "fjahr@protonmail.com",
        "date": "2020-06-02T21:56:28Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:54:14Z"
      },
      "message": "rpc: Add hash_type NONE to gettxoutsetinfo",
      "tree": {
        "sha": "a8a780b4c3530f6a2bc54c927603c4a9e7a2c343",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a8a780b4c3530f6a2bc54c927603c4a9e7a2c343"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c20f46ea7dc98eff281120aff4fb3e5538924e9a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c20f46ea7dc98eff281120aff4fb3e5538924e9a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c20f46ea7dc98eff281120aff4fb3e5538924e9a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c20f46ea7dc98eff281120aff4fb3e5538924e9a/comments",
    "author": {
      "login": "fjahr",
      "id": 1322187,
      "node_id": "MDQ6VXNlcjEzMjIxODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjahr",
      "html_url": "https://github.com/fjahr",
      "followers_url": "https://api.github.com/users/fjahr/followers",
      "following_url": "https://api.github.com/users/fjahr/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjahr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
      "organizations_url": "https://api.github.com/users/fjahr/orgs",
      "repos_url": "https://api.github.com/users/fjahr/repos",
      "events_url": "https://api.github.com/users/fjahr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjahr/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8c738e7cb8836e34bac3246e4e906f274c3b035b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c738e7cb8836e34bac3246e4e906f274c3b035b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8c738e7cb8836e34bac3246e4e906f274c3b035b"
      }
    ],
    "stats": {
      "total": 12,
      "additions": 10,
      "deletions": 2
    },
    "files": [
      {
        "sha": "fb46ea173148ba39d2ca966502c070ad2dba5783",
        "filename": "src/node/coinstats.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c20f46ea7dc98eff281120aff4fb3e5538924e9a/src/node/coinstats.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c20f46ea7dc98eff281120aff4fb3e5538924e9a/src/node/coinstats.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coinstats.cpp?ref=c20f46ea7dc98eff281120aff4fb3e5538924e9a",
        "patch": "@@ -104,6 +104,9 @@ bool GetUTXOStats(CCoinsView* view, CCoinsStats& stats, CoinStatsHashType hash_t\n         CHashWriter ss(SER_GETHASH, PROTOCOL_VERSION);\n         return GetUTXOStats(view, stats, ss, interruption_point);\n     }\n+    case(CoinStatsHashType::NONE): {\n+        return GetUTXOStats(view, stats, nullptr, interruption_point);\n+    }\n     } // no default case, so the compiler can warn about missing cases\n     assert(false);\n }\n@@ -113,8 +116,10 @@ static void PrepareHash(CHashWriter& ss, CCoinsStats& stats)\n {\n     ss << stats.hashBlock;\n }\n+static void PrepareHash(std::nullptr_t, CCoinsStats& stats) {}\n \n static void FinalizeHash(CHashWriter& ss, CCoinsStats& stats)\n {\n     stats.hashSerialized = ss.GetHash();\n }\n+static void FinalizeHash(std::nullptr_t, CCoinsStats& stats) {}"
      },
      {
        "sha": "2a7441c10e7bd87aaf0ce648839be719c8a89612",
        "filename": "src/node/coinstats.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c20f46ea7dc98eff281120aff4fb3e5538924e9a/src/node/coinstats.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c20f46ea7dc98eff281120aff4fb3e5538924e9a/src/node/coinstats.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coinstats.h?ref=c20f46ea7dc98eff281120aff4fb3e5538924e9a",
        "patch": "@@ -16,6 +16,7 @@ class CCoinsView;\n \n enum class CoinStatsHashType {\n     HASH_SERIALIZED,\n+    NONE,\n };\n \n struct CCoinsStats"
      },
      {
        "sha": "98d4b2ce819ea2cdd4652aba8d55ef640f6a89d0",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c20f46ea7dc98eff281120aff4fb3e5538924e9a/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c20f46ea7dc98eff281120aff4fb3e5538924e9a/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=c20f46ea7dc98eff281120aff4fb3e5538924e9a",
        "patch": "@@ -976,7 +976,7 @@ static UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n                 \"\\nReturns statistics about the unspent transaction output set.\\n\"\n                 \"Note this call may take some time.\\n\",\n                 {\n-                    {\"hash_type\", RPCArg::Type::STR, /* default */ \"hash_serialized_2\", \"Which UTXO set hash should be calculated. Options: 'hash_serialized_2' (the legacy algorithm).\"},\n+                    {\"hash_type\", RPCArg::Type::STR, /* default */ \"hash_serialized_2\", \"Which UTXO set hash should be calculated. Options: 'hash_serialized_2' (the legacy algorithm), 'none'.\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::OBJ, \"\", \"\",\n@@ -2323,7 +2323,7 @@ UniValue dumptxoutset(const JSONRPCRequest& request)\n \n         ::ChainstateActive().ForceFlushStateToDisk();\n \n-        if (!GetUTXOStats(&::ChainstateActive().CoinsDB(), stats, CoinStatsHashType::HASH_SERIALIZED, RpcInterruptionPoint)) {\n+        if (!GetUTXOStats(&::ChainstateActive().CoinsDB(), stats, CoinStatsHashType::NONE, RpcInterruptionPoint)) {\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Unable to read UTXO set\");\n         }\n "
      },
      {
        "sha": "ca73c699c915cbc45dc1b73e3ff811df0dcc5307",
        "filename": "src/rpc/util.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c20f46ea7dc98eff281120aff4fb3e5538924e9a/src/rpc/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c20f46ea7dc98eff281120aff4fb3e5538924e9a/src/rpc/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.cpp?ref=c20f46ea7dc98eff281120aff4fb3e5538924e9a",
        "patch": "@@ -122,6 +122,8 @@ CoinStatsHashType ParseHashType(const UniValue& param, const CoinStatsHashType d\n \n         if (hash_type_input == \"hash_serialized_2\") {\n             return CoinStatsHashType::HASH_SERIALIZED;\n+        } else if (hash_type_input == \"none\") {\n+            return CoinStatsHashType::NONE;\n         } else {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"%d is not a valid hash_type\", hash_type_input));\n         }"
      }
    ]
  },
  {
    "sha": "d050da7a783f508dc6d0950ee241600fe79597dd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMDUwZGE3YTc4M2Y1MDhkYzZkMDk1MGVlMjQxNjAwZmU3OTU5N2Rk",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-09T01:46:53Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:54:35Z"
      },
      "message": "Replace automatic bans with discouragement filter\n\nThis patch improves performance and resource usage around IP\naddresses that are banned for misbehavior. They're already not\nactually banned, as connections from them are still allowed,\nbut they are preferred for eviction if the inbound connection\nslots are full.\n\nStop treating these like manually banned IP ranges, and instead\njust keep them in a rolling Bloom filter of misbehaving nodes,\nwhich isn't persisted to disk or exposed through the ban\nframework. The effect remains the same: preferred for eviction,\navoided for outgoing connections, and not relayed to other peers.\n\nAlso change the name of this mechanism to better reflect reality;\nthey're not banned, just discouraged.\n\nContains release notes and several interface improvements by\nJohn Newbery.",
      "tree": {
        "sha": "051e2039dfefa6114babeaf99165f9ed004132bc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/051e2039dfefa6114babeaf99165f9ed004132bc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d050da7a783f508dc6d0950ee241600fe79597dd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d050da7a783f508dc6d0950ee241600fe79597dd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d050da7a783f508dc6d0950ee241600fe79597dd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d050da7a783f508dc6d0950ee241600fe79597dd/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c20f46ea7dc98eff281120aff4fb3e5538924e9a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c20f46ea7dc98eff281120aff4fb3e5538924e9a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c20f46ea7dc98eff281120aff4fb3e5538924e9a"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 3,
      "deletions": 8
    },
    "files": [
      {
        "sha": "6cce4f5476b1cb2e46bfa1d048147dba8f5d3f45",
        "filename": "src/banman.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d050da7a783f508dc6d0950ee241600fe79597dd/src/banman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d050da7a783f508dc6d0950ee241600fe79597dd/src/banman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/banman.cpp?ref=d050da7a783f508dc6d0950ee241600fe79597dd",
        "patch": "@@ -129,12 +129,6 @@ void BanMan::Ban(const CNetAddr& net_addr, int64_t ban_time_offset, bool since_u\n }\n \n void BanMan::Discourage(const CNetAddr& net_addr)\n-{\n-    LOCK(m_cs_banned);\n-    m_discouraged.insert(net_addr.GetAddrBytes());\n-}\n-\n-void BanMan::Ban(const CSubNet& sub_net, int64_t ban_time_offset, bool since_unix_epoch)\n {\n     assert(ban_reason == BanReasonManuallyAdded);\n     CBanEntry ban_entry(GetTime(), ban_reason);"
      },
      {
        "sha": "5dbe28b00d1dcd4c766c18d0b025c3a4aae6d8ac",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d050da7a783f508dc6d0950ee241600fe79597dd/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d050da7a783f508dc6d0950ee241600fe79597dd/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=d050da7a783f508dc6d0950ee241600fe79597dd",
        "patch": "@@ -604,7 +604,8 @@ static UniValue setban(const JSONRPCRequest& request)\n \n     if (strCommand == \"add\")\n     {\n-        if (isSubnet ? node.banman->IsBanned(subNet) : node.banman->IsBanned(netAddr)) {\n+        if ((isSubnet && node.banman->IsBanned(subNet)) ||\n+            (!isSubnet && node.banman->IsBannedLevel(netAddr) == BanReasonManuallyAdded)) {\n             throw JSONRPCError(RPC_CLIENT_NODE_ALREADY_ADDED, \"Error: IP/Subnet already banned\");\n         }\n "
      },
      {
        "sha": "67f7e624989b9db92a86662ec91413c949b4f40b",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d050da7a783f508dc6d0950ee241600fe79597dd/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d050da7a783f508dc6d0950ee241600fe79597dd/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=d050da7a783f508dc6d0950ee241600fe79597dd",
        "patch": "@@ -344,7 +344,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n         LOCK2(cs_main, dummyNode.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode));\n     }\n-    BOOST_CHECK(banman->IsDiscouraged(addr));\n+    BOOST_CHECK(banman->IsBanned(addr));\n \n     bool dummy;\n     peerLogic->FinalizeNode(dummyNode.GetId(), dummy);"
      }
    ]
  },
  {
    "sha": "624f3ee301599df9a79e76a603b08b19c6b7cd99",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MjRmM2VlMzAxNTk5ZGY5YTc5ZTc2YTYwM2IwOGIxOWM2YjdjZDk5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-11T00:11:38Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:54:36Z"
      },
      "message": "Clean up separated ban/discourage interface",
      "tree": {
        "sha": "723a6e51bbae30aee237afbc5725c26189424186",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/723a6e51bbae30aee237afbc5725c26189424186"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/624f3ee301599df9a79e76a603b08b19c6b7cd99",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/624f3ee301599df9a79e76a603b08b19c6b7cd99",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/624f3ee301599df9a79e76a603b08b19c6b7cd99",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/624f3ee301599df9a79e76a603b08b19c6b7cd99/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d050da7a783f508dc6d0950ee241600fe79597dd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d050da7a783f508dc6d0950ee241600fe79597dd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d050da7a783f508dc6d0950ee241600fe79597dd"
      }
    ],
    "stats": {
      "total": 49,
      "additions": 17,
      "deletions": 32
    },
    "files": [
      {
        "sha": "8752185a60df2a145f3456751a02f8fe2eb63d94",
        "filename": "src/banman.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 22,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/624f3ee301599df9a79e76a603b08b19c6b7cd99/src/banman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/624f3ee301599df9a79e76a603b08b19c6b7cd99/src/banman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/banman.cpp?ref=624f3ee301599df9a79e76a603b08b19c6b7cd99",
        "patch": "@@ -70,28 +70,14 @@ void BanMan::ClearBanned()\n \n bool BanMan::IsDiscouraged(const CNetAddr& net_addr)\n {\n-    // Returns the most severe level of banning that applies to this address.\n-    // 0 - Not banned\n-    // 1 - Automatic misbehavior ban\n-    // 2 - Any other ban\n-    auto current_time = GetTime();\n     LOCK(m_cs_banned);\n-    for (const auto& it : m_banned) {\n-        CSubNet sub_net = it.first;\n-        CBanEntry ban_entry = it.second;\n-\n-        if (current_time < ban_entry.nBanUntil && sub_net.Match(net_addr)) {\n-            return 2;\n-        }\n-    }\n-    return m_discouraged.contains(net_addr.GetAddrBytes()) ? 1 : 0;\n+    return m_discouraged.contains(net_addr.GetAddrBytes());\n }\n \n bool BanMan::IsBanned(const CNetAddr& net_addr)\n {\n     auto current_time = GetTime();\n     LOCK(m_cs_banned);\n-    if (m_discouraged.contains(net_addr.GetAddrBytes())) return true;\n     for (const auto& it : m_banned) {\n         CSubNet sub_net = it.first;\n         CBanEntry ban_entry = it.second;\n@@ -119,19 +105,19 @@ bool BanMan::IsBanned(const CSubNet& sub_net)\n \n void BanMan::Ban(const CNetAddr& net_addr, int64_t ban_time_offset, bool since_unix_epoch)\n {\n-    if (ban_reason == BanReasonNodeMisbehaving) {\n-        LOCK(m_cs_banned);\n-        m_discouraged.insert(net_addr.GetAddrBytes());\n-        return;\n-    }\n     CSubNet sub_net(net_addr);\n     Ban(sub_net, ban_time_offset, since_unix_epoch);\n }\n \n void BanMan::Discourage(const CNetAddr& net_addr)\n {\n-    assert(ban_reason == BanReasonManuallyAdded);\n-    CBanEntry ban_entry(GetTime(), ban_reason);\n+    LOCK(m_cs_banned);\n+    m_discouraged.insert(net_addr.GetAddrBytes());\n+}\n+\n+void BanMan::Ban(const CSubNet& sub_net, int64_t ban_time_offset, bool since_unix_epoch)\n+{\n+    CBanEntry ban_entry(GetTime());\n \n     int64_t normalized_ban_time_offset = ban_time_offset;\n     bool normalized_since_unix_epoch = since_unix_epoch;"
      },
      {
        "sha": "05ee26f8a50b6b683ceea4fcee2a9b804c06e790",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/624f3ee301599df9a79e76a603b08b19c6b7cd99/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/624f3ee301599df9a79e76a603b08b19c6b7cd99/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=624f3ee301599df9a79e76a603b08b19c6b7cd99",
        "patch": "@@ -1011,18 +1011,18 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     // on all platforms.  Set it again here just to be sure.\n     SetSocketNoDelay(hSocket);\n \n-    int bannedlevel = m_banman ? m_banman->IsBannedLevel(addr) : 0;\n-\n     // Don't accept connections from banned peers.\n-    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && bannedlevel == 2)\n+    bool banned = m_banman->IsBanned(addr);\n+    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && banned)\n     {\n         LogPrint(BCLog::NET, \"connection from %s dropped (banned)\\n\", addr.ToString());\n         CloseSocket(hSocket);\n         return;\n     }\n \n     // Only accept connections from discouraged peers if our inbound slots aren't (almost) full.\n-    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && nInbound + 1 >= nMaxInbound && bannedlevel >= 1)\n+    bool discouraged = m_banman->IsDiscouraged(addr);\n+    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN) && nInbound + 1 >= nMaxInbound && discouraged)\n     {\n         LogPrint(BCLog::NET, \"connection from %s dropped (discouraged)\\n\", addr.ToString());\n         CloseSocket(hSocket);"
      },
      {
        "sha": "7f8944324359b8859674f3a919f2ad8e2482f70f",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/624f3ee301599df9a79e76a603b08b19c6b7cd99/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/624f3ee301599df9a79e76a603b08b19c6b7cd99/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=624f3ee301599df9a79e76a603b08b19c6b7cd99",
        "patch": "@@ -1033,7 +1033,7 @@ void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIV\n     if (state->nMisbehavior >= banscore && state->nMisbehavior - howmuch < banscore)\n     {\n         LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d) DISCOURAGE THRESHOLD EXCEEDED%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n-        state->fShouldBan = true;\n+        state->m_should_discourage = true;\n     } else\n         LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d)%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n }\n@@ -3574,12 +3574,12 @@ bool PeerLogicValidation::MaybeDiscourageAndDisconnect(CNode& pnode)\n             LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pnode.addr.ToString());\n         } else if (pnode.m_manual_connection) {\n             LogPrintf(\"Warning: not punishing manually-connected peer %s!\\n\", pnode.addr.ToString());\n-        else if (pnode.addr.IsLocal()) {\n+        } else if (pnode.addr.IsLocal()) {\n             // Disconnect but don't discourage this local node\n             LogPrintf(\"Warning: disconnecting but not discouraging local peer %s!\\n\", pnode.addr.ToString());\n             pnode.fDisconnect = true;\n         } else {\n-            // Disconnect and ban all nodes sharing the address\n+            // Disconnect and discourage all nodes sharing the address\n             LogPrintf(\"Disconnecting and discouraging peer %s!\\n\", pnode.addr.ToString());\n             if (m_banman) {\n                 m_banman->Discourage(pnode.addr);"
      },
      {
        "sha": "9981ea35dff395a774714a1245086acf0cf85236",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/624f3ee301599df9a79e76a603b08b19c6b7cd99/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/624f3ee301599df9a79e76a603b08b19c6b7cd99/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=624f3ee301599df9a79e76a603b08b19c6b7cd99",
        "patch": "@@ -604,8 +604,7 @@ static UniValue setban(const JSONRPCRequest& request)\n \n     if (strCommand == \"add\")\n     {\n-        if ((isSubnet && node.banman->IsBanned(subNet)) ||\n-            (!isSubnet && node.banman->IsBannedLevel(netAddr) == BanReasonManuallyAdded)) {\n+        if (isSubnet ? node.banman->IsBanned(subNet) : node.banman->IsBanned(netAddr)) {\n             throw JSONRPCError(RPC_CLIENT_NODE_ALREADY_ADDED, \"Error: IP/Subnet already banned\");\n         }\n "
      },
      {
        "sha": "1fe01fae04fca83988debd49e4a4bd11950881ec",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/624f3ee301599df9a79e76a603b08b19c6b7cd99/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/624f3ee301599df9a79e76a603b08b19c6b7cd99/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=624f3ee301599df9a79e76a603b08b19c6b7cd99",
        "patch": "@@ -344,7 +344,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n         LOCK2(cs_main, dummyNode.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode));\n     }\n-    BOOST_CHECK(banman->IsBanned(addr));\n+    BOOST_CHECK(banman->IsDiscouraged(addr));\n \n     bool dummy;\n     peerLogic->FinalizeNode(dummyNode.GetId(), dummy);"
      }
    ]
  },
  {
    "sha": "a1becd444600e3991bc20fe4dce4ac9caaa15366",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMWJlY2Q0NDQ2MDBlMzk5MWJjMjBmZTRkY2U0YWM5Y2FhYTE1MzY2",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-06-20T12:44:42Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:54:55Z"
      },
      "message": "wallet: Remove confusing double return value ret+success\n\nAlso, remove redundant comments",
      "tree": {
        "sha": "9d6b89e481afb8482b0c49c5f757fe44f2495735",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9d6b89e481afb8482b0c49c5f757fe44f2495735"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a1becd444600e3991bc20fe4dce4ac9caaa15366",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a1becd444600e3991bc20fe4dce4ac9caaa15366",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a1becd444600e3991bc20fe4dce4ac9caaa15366",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a1becd444600e3991bc20fe4dce4ac9caaa15366/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "624f3ee301599df9a79e76a603b08b19c6b7cd99",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/624f3ee301599df9a79e76a603b08b19c6b7cd99",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/624f3ee301599df9a79e76a603b08b19c6b7cd99"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 4,
      "deletions": 4
    },
    "files": [
      {
        "sha": "a14744a86fc26cc0bf7864a966f1d3671a0b0ba3",
        "filename": "src/wallet/bdb.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a1becd444600e3991bc20fe4dce4ac9caaa15366/src/wallet/bdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a1becd444600e3991bc20fe4dce4ac9caaa15366/src/wallet/bdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/bdb.h?ref=a1becd444600e3991bc20fe4dce4ac9caaa15366",
        "patch": "@@ -227,7 +227,7 @@ class BerkeleyBatch\n         ssKey << key;\n \n         CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n-        if (!ReadKey(std::move(ssKey), ssValue)) return false;\n+        if (!ReadKey(ssKey, ssValue)) return false;\n         try {\n             ssValue >> value;\n             return true;\n@@ -247,7 +247,7 @@ class BerkeleyBatch\n         ssValue.reserve(10000);\n         ssValue << value;\n \n-        return WriteKey(std::move(ssKey), std::move(ssValue), fOverwrite);\n+        return WriteKey(ssKey, ssValue, fOverwrite);\n     }\n \n     template <typename K>\n@@ -257,7 +257,7 @@ class BerkeleyBatch\n         ssKey.reserve(1000);\n         ssKey << key;\n \n-        return EraseKey(std::move(ssKey));\n+        return EraseKey(ssKey);\n     }\n \n     template <typename K>\n@@ -267,7 +267,7 @@ class BerkeleyBatch\n         ssKey.reserve(1000);\n         ssKey << key;\n \n-        return HasKey(std::move(ssKey));\n+        return HasKey(ssKey);\n     }\n \n     bool StartCursor();"
      }
    ]
  },
  {
    "sha": "21181db59564209eca38dba29d7b80e976f66978",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMTE4MWRiNTk1NjQyMDllY2EzOGRiYTI5ZDdiODBlOTc2ZjY2OTc4",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-06-20T12:55:07Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:54:55Z"
      },
      "message": "wallet: Replace CDataStream& with CDataStream&& where appropriate\n\nThe keys and values are only to be used once because their memory is set\nto zero. Make that explicit by moving the bytes into the lower level\nmethods.",
      "tree": {
        "sha": "723a6e51bbae30aee237afbc5725c26189424186",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/723a6e51bbae30aee237afbc5725c26189424186"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/21181db59564209eca38dba29d7b80e976f66978",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/21181db59564209eca38dba29d7b80e976f66978",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/21181db59564209eca38dba29d7b80e976f66978",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/21181db59564209eca38dba29d7b80e976f66978/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a1becd444600e3991bc20fe4dce4ac9caaa15366",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a1becd444600e3991bc20fe4dce4ac9caaa15366",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a1becd444600e3991bc20fe4dce4ac9caaa15366"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 4,
      "deletions": 4
    },
    "files": [
      {
        "sha": "599319482bea0ebeee0dbcd95757030e5512ddff",
        "filename": "src/wallet/bdb.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21181db59564209eca38dba29d7b80e976f66978/src/wallet/bdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21181db59564209eca38dba29d7b80e976f66978/src/wallet/bdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/bdb.h?ref=21181db59564209eca38dba29d7b80e976f66978",
        "patch": "@@ -227,7 +227,7 @@ class BerkeleyBatch\n         ssKey << key;\n \n         CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n-        if (!ReadKey(ssKey, ssValue)) return false;\n+        if (!ReadKey(std::move(ssKey), ssValue)) return false;\n         try {\n             ssValue >> value;\n             return true;\n@@ -247,7 +247,7 @@ class BerkeleyBatch\n         ssValue.reserve(10000);\n         ssValue << value;\n \n-        return WriteKey(ssKey, ssValue, fOverwrite);\n+        return WriteKey(std::move(ssKey), std::move(ssValue), fOverwrite);\n     }\n \n     template <typename K>\n@@ -257,7 +257,7 @@ class BerkeleyBatch\n         ssKey.reserve(1000);\n         ssKey << key;\n \n-        return EraseKey(ssKey);\n+        return EraseKey(std::move(ssKey));\n     }\n \n     template <typename K>\n@@ -267,7 +267,7 @@ class BerkeleyBatch\n         ssKey.reserve(1000);\n         ssKey << key;\n \n-        return HasKey(ssKey);\n+        return HasKey(std::move(ssKey));\n     }\n \n     bool StartCursor();"
      }
    ]
  },
  {
    "sha": "9a9afb25ae69b1d0a3d4020b37bf58de9b56749b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YTlhZmIyNWFlNjliMWQwYTNkNDAyMGIzN2JmNThkZTliNTY3NDli",
    "commit": {
      "author": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-07T06:39:46Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:54:55Z"
      },
      "message": "Revert \"Attempted test where one node sends block to another\"\n\nThis reverts commit 55cf78aae878ac1e2a8ed5712877465a2e4a938c.",
      "tree": {
        "sha": "c1106f8528a1bf448bc3c83e7a8051c62d560ac7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c1106f8528a1bf448bc3c83e7a8051c62d560ac7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9a9afb25ae69b1d0a3d4020b37bf58de9b56749b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9a9afb25ae69b1d0a3d4020b37bf58de9b56749b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9a9afb25ae69b1d0a3d4020b37bf58de9b56749b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9a9afb25ae69b1d0a3d4020b37bf58de9b56749b/comments",
    "author": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "21181db59564209eca38dba29d7b80e976f66978",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/21181db59564209eca38dba29d7b80e976f66978",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/21181db59564209eca38dba29d7b80e976f66978"
      }
    ],
    "stats": {
      "total": 224,
      "additions": 0,
      "deletions": 224
    },
    "files": [
      {
        "sha": "87d7100d263b50c88ea90451a601e813aebc0939",
        "filename": "test/functional/p2p_saahil.py",
        "status": "removed",
        "additions": 0,
        "deletions": 224,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21181db59564209eca38dba29d7b80e976f66978/test/functional/p2p_saahil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21181db59564209eca38dba29d7b80e976f66978/test/functional/p2p_saahil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_saahil.py?ref=21181db59564209eca38dba29d7b80e976f66978",
        "patch": "@@ -1,224 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2017-2019 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"An example functional test\n-\n-The module-level docstring should include a high-level description of\n-what the test is doing. It's the first thing people see when they open\n-the file and should give the reader information about *what* the test\n-is testing and *how* it's being tested\n-\"\"\"\n-# Imports should be in PEP8 ordering (std library first, then third party\n-# libraries then local imports).\n-from collections import defaultdict\n-\n-# Avoid wildcard * imports\n-from test_framework.blocktools import (create_block, create_coinbase)\n-from test_framework.messages import CInv, MSG_BLOCK\n-from test_framework.mininode import (\n-    P2PInterface,\n-    mininode_lock,\n-    msg_block,\n-    msg_getdata,\n-)\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (\n-    assert_equal,\n-    connect_nodes,\n-    wait_until,\n-)\n-\n-# P2PInterface is a class containing callbacks to be executed when a P2P\n-# message is received from the node-under-test. Subclass P2PInterface and\n-# override the on_*() methods if you need custom behaviour.\n-class BaseNode(P2PInterface):\n-    def __init__(self):\n-        \"\"\"Initialize the P2PInterface\n-\n-        Used to initialize custom properties for the Node that aren't\n-        included by default in the base class. Be aware that the P2PInterface\n-        base class already stores a counter for each P2P message type and the\n-        last received message of each type, which should be sufficient for the\n-        needs of most tests.\n-\n-        Call super().__init__() first for standard initialization and then\n-        initialize custom properties.\"\"\"\n-        super().__init__()\n-        # Stores a dictionary of all blocks received\n-        self.block_receive_map = defaultdict(int)\n-\n-    def on_block(self, message):\n-        \"\"\"Override the standard on_block callback\n-\n-        Store the hash of a received block in the dictionary.\"\"\"\n-        message.block.calc_sha256()\n-        self.block_receive_map[message.block.sha256] += 1\n-\n-    def on_inv(self, message):\n-        \"\"\"Override the standard on_inv callback\"\"\"\n-        pass\n-\n-def custom_function():\n-    \"\"\"Do some custom behaviour\n-\n-    If this function is more generally useful for other tests, consider\n-    moving it to a module in test_framework.\"\"\"\n-    # self.log.info(\"running custom_function\")  # Oops! Can't run self.log outside the BitcoinTestFramework\n-    pass\n-\n-\n-class ExampleTest(BitcoinTestFramework):\n-    # Each functional test is a subclass of the BitcoinTestFramework class.\n-\n-    # Override the set_test_params(), skip_test_if_missing_module(), add_options(), setup_chain(), setup_network()\n-    # and setup_nodes() methods to customize the test setup as required.\n-\n-    def set_test_params(self):\n-        \"\"\"Override test parameters for your individual test.\n-\n-        This method must be overridden and num_nodes must be explicitly set.\"\"\"\n-        self.setup_clean_chain = True\n-        self.num_nodes = 3\n-        # Use self.extra_args to change command-line arguments for the nodes\n-        self.extra_args = [[], [\"-logips\"], []]\n-\n-        # self.log.info(\"I've finished set_test_params\")  # Oops! Can't run self.log before run_test()\n-\n-    # Use skip_test_if_missing_module() to skip the test if your test requires certain modules to be present.\n-    # This test uses generate which requires wallet to be compiled\n-    def skip_test_if_missing_module(self):\n-        self.skip_if_no_wallet()\n-\n-    # Use add_options() to add specific command-line options for your test.\n-    # In practice this is not used very much, since the tests are mostly written\n-    # to be run in automated environments without command-line options.\n-    # def add_options()\n-    #     pass\n-\n-    # Use setup_chain() to customize the node data directories. In practice\n-    # this is not used very much since the default behaviour is almost always\n-    # fine\n-    # def setup_chain():\n-    #     pass\n-\n-    def setup_network(self):\n-        \"\"\"Setup the test network topology\n-\n-        Often you won't need to override this, since the standard network topology\n-        (linear: node0 <-> node1 <-> node2 <-> ...) is fine for most tests.\n-\n-        If you do override this method, remember to start the nodes, assign\n-        them to self.nodes, connect them and then sync.\"\"\"\n-\n-        self.setup_nodes()\n-\n-        # In this test, we're not connecting node2 to node0 or node1. Calls to\n-        # sync_all() should not include node2, since we're not expecting it to\n-        # sync.\n-        #connect_nodes(self.nodes[0], 1)\n-        #self.sync_all(self.nodes[0:2])\n-\n-    # Use setup_nodes() to customize the node start behaviour (for example if\n-    # you don't want to start all nodes at the start of the test).\n-    # def setup_nodes():\n-    #     pass\n-\n-    def custom_method(self):\n-        \"\"\"Do some custom behaviour for this test\n-\n-        Define it in a method here because you're going to use it repeatedly.\n-        If you think it's useful in general, consider moving it to the base\n-        BitcoinTestFramework class so other tests can use it.\"\"\"\n-\n-        self.log.info(\"Running custom_method\")\n-\n-    def run_test(self):\n-        \"\"\"Main test logic\"\"\"\n-\n-        # Create P2P connections will wait for a verack to make sure the connection is fully up\n-        self.nodes[0].add_p2p_connection(BaseNode())\n-\n-        # Generating a block on one of the nodes will get us out of IBD\n-        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n-        self.log.info(\"Number of blocks in node 0: \" + str(self.nodes[0].getblockcount()))\n-        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n-        \n-        self.log.info(\"Now sending block from one to the other\")\n-        connect_nodes(self.nodes[0], 1)\n-        self.sync_all(self.nodes[0:2])\n-\n-        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n-\n-        # # Notice above how we called an RPC by calling a method with the same\n-        # # name on the node object. Notice also how we used a keyword argument\n-        # # to specify a named RPC argument. Neither of those are defined on the\n-        # # node object. Instead there's some __getattr__() magic going on under\n-        # # the covers to dispatch unrecognised attribute calls to the RPC\n-        # # interface.\n-\n-        # # Logs are nice. Do plenty of them. They can be used in place of comments for\n-        # # breaking the test into sub-sections.\n-        # self.log.info(\"Starting test!\")\n-\n-        # self.log.info(\"Calling a custom function\")\n-        # custom_function()\n-\n-        # self.log.info(\"Calling a custom method\")\n-        # self.custom_method()\n-\n-        # self.log.info(\"Create some blocks\")\n-        # self.tip = int(self.nodes[0].getbestblockhash(), 16)\n-        # self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n-\n-        # height = self.nodes[0].getblockcount()\n-\n-        # for i in range(10):\n-        #     # Use the mininode and blocktools functionality to manually build a block\n-        #     # Calling the generate() rpc is easier, but this allows us to exactly\n-        #     # control the blocks and transactions.\n-        #     block = create_block(self.tip, create_coinbase(height+1), self.block_time)\n-        #     block.solve()\n-        #     block_message = msg_block(block)\n-        #     # Send message is used to send a P2P message to the node over our P2PInterface\n-        #     self.nodes[0].p2p.send_message(block_message)\n-        #     self.tip = block.sha256\n-        #     blocks.append(self.tip)\n-        #     self.block_time += 1\n-        #     height += 1\n-\n-        # self.log.info(\"Wait for node1 to reach current tip (height 11) using RPC\")\n-        # self.nodes[1].waitforblockheight(11)\n-\n-        # self.log.info(\"Connect node2 and node1\")\n-        # connect_nodes(self.nodes[1], 2)\n-\n-        # self.log.info(\"Wait for node2 to receive all the blocks from node1\")\n-        # self.sync_all()\n-\n-        # self.log.info(\"Add P2P connection to node2\")\n-        # self.nodes[0].disconnect_p2ps()\n-\n-        # self.nodes[2].add_p2p_connection(BaseNode())\n-\n-        # self.log.info(\"Test that node2 propagates all the blocks to us\")\n-\n-        # getdata_request = msg_getdata()\n-        # for block in blocks:\n-        #     getdata_request.inv.append(CInv(MSG_BLOCK, block))\n-        # self.nodes[2].p2p.send_message(getdata_request)\n-\n-        # # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n-        # # P2PInterface objects.\n-        # wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n-\n-        # self.log.info(\"Check that each block was received only once\")\n-        # # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving\n-        # # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking\n-        # # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n-        # with mininode_lock:\n-        #     for block in self.nodes[2].p2p.block_receive_map.values():\n-        #         assert_equal(block, 1)\n-\n-if __name__ == '__main__':\n-    ExampleTest().main()"
      }
    ]
  },
  {
    "sha": "805e6329946799640f69822bd61608d738e4b51f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4MDVlNjMyOTk0Njc5OTY0MGY2OTgyMmJkNjE2MDhkNzM4ZTRiNTFm",
    "commit": {
      "author": {
        "name": "Saahil Shangle",
        "email": "saahilshangle@gmail.com",
        "date": "2020-06-08T00:20:11Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:54:56Z"
      },
      "message": "Attempted test where one node sends block to another",
      "tree": {
        "sha": "723a6e51bbae30aee237afbc5725c26189424186",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/723a6e51bbae30aee237afbc5725c26189424186"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/805e6329946799640f69822bd61608d738e4b51f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/805e6329946799640f69822bd61608d738e4b51f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/805e6329946799640f69822bd61608d738e4b51f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/805e6329946799640f69822bd61608d738e4b51f/comments",
    "author": {
      "login": "saahilshangle",
      "id": 10226886,
      "node_id": "MDQ6VXNlcjEwMjI2ODg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10226886?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saahilshangle",
      "html_url": "https://github.com/saahilshangle",
      "followers_url": "https://api.github.com/users/saahilshangle/followers",
      "following_url": "https://api.github.com/users/saahilshangle/following{/other_user}",
      "gists_url": "https://api.github.com/users/saahilshangle/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saahilshangle/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saahilshangle/subscriptions",
      "organizations_url": "https://api.github.com/users/saahilshangle/orgs",
      "repos_url": "https://api.github.com/users/saahilshangle/repos",
      "events_url": "https://api.github.com/users/saahilshangle/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saahilshangle/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9a9afb25ae69b1d0a3d4020b37bf58de9b56749b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9a9afb25ae69b1d0a3d4020b37bf58de9b56749b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9a9afb25ae69b1d0a3d4020b37bf58de9b56749b"
      }
    ],
    "stats": {
      "total": 224,
      "additions": 224,
      "deletions": 0
    },
    "files": [
      {
        "sha": "87d7100d263b50c88ea90451a601e813aebc0939",
        "filename": "test/functional/p2p_saahil.py",
        "status": "added",
        "additions": 224,
        "deletions": 0,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/805e6329946799640f69822bd61608d738e4b51f/test/functional/p2p_saahil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/805e6329946799640f69822bd61608d738e4b51f/test/functional/p2p_saahil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_saahil.py?ref=805e6329946799640f69822bd61608d738e4b51f",
        "patch": "@@ -0,0 +1,224 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"An example functional test\n+\n+The module-level docstring should include a high-level description of\n+what the test is doing. It's the first thing people see when they open\n+the file and should give the reader information about *what* the test\n+is testing and *how* it's being tested\n+\"\"\"\n+# Imports should be in PEP8 ordering (std library first, then third party\n+# libraries then local imports).\n+from collections import defaultdict\n+\n+# Avoid wildcard * imports\n+from test_framework.blocktools import (create_block, create_coinbase)\n+from test_framework.messages import CInv, MSG_BLOCK\n+from test_framework.mininode import (\n+    P2PInterface,\n+    mininode_lock,\n+    msg_block,\n+    msg_getdata,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    connect_nodes,\n+    wait_until,\n+)\n+\n+# P2PInterface is a class containing callbacks to be executed when a P2P\n+# message is received from the node-under-test. Subclass P2PInterface and\n+# override the on_*() methods if you need custom behaviour.\n+class BaseNode(P2PInterface):\n+    def __init__(self):\n+        \"\"\"Initialize the P2PInterface\n+\n+        Used to initialize custom properties for the Node that aren't\n+        included by default in the base class. Be aware that the P2PInterface\n+        base class already stores a counter for each P2P message type and the\n+        last received message of each type, which should be sufficient for the\n+        needs of most tests.\n+\n+        Call super().__init__() first for standard initialization and then\n+        initialize custom properties.\"\"\"\n+        super().__init__()\n+        # Stores a dictionary of all blocks received\n+        self.block_receive_map = defaultdict(int)\n+\n+    def on_block(self, message):\n+        \"\"\"Override the standard on_block callback\n+\n+        Store the hash of a received block in the dictionary.\"\"\"\n+        message.block.calc_sha256()\n+        self.block_receive_map[message.block.sha256] += 1\n+\n+    def on_inv(self, message):\n+        \"\"\"Override the standard on_inv callback\"\"\"\n+        pass\n+\n+def custom_function():\n+    \"\"\"Do some custom behaviour\n+\n+    If this function is more generally useful for other tests, consider\n+    moving it to a module in test_framework.\"\"\"\n+    # self.log.info(\"running custom_function\")  # Oops! Can't run self.log outside the BitcoinTestFramework\n+    pass\n+\n+\n+class ExampleTest(BitcoinTestFramework):\n+    # Each functional test is a subclass of the BitcoinTestFramework class.\n+\n+    # Override the set_test_params(), skip_test_if_missing_module(), add_options(), setup_chain(), setup_network()\n+    # and setup_nodes() methods to customize the test setup as required.\n+\n+    def set_test_params(self):\n+        \"\"\"Override test parameters for your individual test.\n+\n+        This method must be overridden and num_nodes must be explicitly set.\"\"\"\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+        # Use self.extra_args to change command-line arguments for the nodes\n+        self.extra_args = [[], [\"-logips\"], []]\n+\n+        # self.log.info(\"I've finished set_test_params\")  # Oops! Can't run self.log before run_test()\n+\n+    # Use skip_test_if_missing_module() to skip the test if your test requires certain modules to be present.\n+    # This test uses generate which requires wallet to be compiled\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    # Use add_options() to add specific command-line options for your test.\n+    # In practice this is not used very much, since the tests are mostly written\n+    # to be run in automated environments without command-line options.\n+    # def add_options()\n+    #     pass\n+\n+    # Use setup_chain() to customize the node data directories. In practice\n+    # this is not used very much since the default behaviour is almost always\n+    # fine\n+    # def setup_chain():\n+    #     pass\n+\n+    def setup_network(self):\n+        \"\"\"Setup the test network topology\n+\n+        Often you won't need to override this, since the standard network topology\n+        (linear: node0 <-> node1 <-> node2 <-> ...) is fine for most tests.\n+\n+        If you do override this method, remember to start the nodes, assign\n+        them to self.nodes, connect them and then sync.\"\"\"\n+\n+        self.setup_nodes()\n+\n+        # In this test, we're not connecting node2 to node0 or node1. Calls to\n+        # sync_all() should not include node2, since we're not expecting it to\n+        # sync.\n+        #connect_nodes(self.nodes[0], 1)\n+        #self.sync_all(self.nodes[0:2])\n+\n+    # Use setup_nodes() to customize the node start behaviour (for example if\n+    # you don't want to start all nodes at the start of the test).\n+    # def setup_nodes():\n+    #     pass\n+\n+    def custom_method(self):\n+        \"\"\"Do some custom behaviour for this test\n+\n+        Define it in a method here because you're going to use it repeatedly.\n+        If you think it's useful in general, consider moving it to the base\n+        BitcoinTestFramework class so other tests can use it.\"\"\"\n+\n+        self.log.info(\"Running custom_method\")\n+\n+    def run_test(self):\n+        \"\"\"Main test logic\"\"\"\n+\n+        # Create P2P connections will wait for a verack to make sure the connection is fully up\n+        self.nodes[0].add_p2p_connection(BaseNode())\n+\n+        # Generating a block on one of the nodes will get us out of IBD\n+        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n+        self.log.info(\"Number of blocks in node 0: \" + str(self.nodes[0].getblockcount()))\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+        \n+        self.log.info(\"Now sending block from one to the other\")\n+        connect_nodes(self.nodes[0], 1)\n+        self.sync_all(self.nodes[0:2])\n+\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+\n+        # # Notice above how we called an RPC by calling a method with the same\n+        # # name on the node object. Notice also how we used a keyword argument\n+        # # to specify a named RPC argument. Neither of those are defined on the\n+        # # node object. Instead there's some __getattr__() magic going on under\n+        # # the covers to dispatch unrecognised attribute calls to the RPC\n+        # # interface.\n+\n+        # # Logs are nice. Do plenty of them. They can be used in place of comments for\n+        # # breaking the test into sub-sections.\n+        # self.log.info(\"Starting test!\")\n+\n+        # self.log.info(\"Calling a custom function\")\n+        # custom_function()\n+\n+        # self.log.info(\"Calling a custom method\")\n+        # self.custom_method()\n+\n+        # self.log.info(\"Create some blocks\")\n+        # self.tip = int(self.nodes[0].getbestblockhash(), 16)\n+        # self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n+\n+        # height = self.nodes[0].getblockcount()\n+\n+        # for i in range(10):\n+        #     # Use the mininode and blocktools functionality to manually build a block\n+        #     # Calling the generate() rpc is easier, but this allows us to exactly\n+        #     # control the blocks and transactions.\n+        #     block = create_block(self.tip, create_coinbase(height+1), self.block_time)\n+        #     block.solve()\n+        #     block_message = msg_block(block)\n+        #     # Send message is used to send a P2P message to the node over our P2PInterface\n+        #     self.nodes[0].p2p.send_message(block_message)\n+        #     self.tip = block.sha256\n+        #     blocks.append(self.tip)\n+        #     self.block_time += 1\n+        #     height += 1\n+\n+        # self.log.info(\"Wait for node1 to reach current tip (height 11) using RPC\")\n+        # self.nodes[1].waitforblockheight(11)\n+\n+        # self.log.info(\"Connect node2 and node1\")\n+        # connect_nodes(self.nodes[1], 2)\n+\n+        # self.log.info(\"Wait for node2 to receive all the blocks from node1\")\n+        # self.sync_all()\n+\n+        # self.log.info(\"Add P2P connection to node2\")\n+        # self.nodes[0].disconnect_p2ps()\n+\n+        # self.nodes[2].add_p2p_connection(BaseNode())\n+\n+        # self.log.info(\"Test that node2 propagates all the blocks to us\")\n+\n+        # getdata_request = msg_getdata()\n+        # for block in blocks:\n+        #     getdata_request.inv.append(CInv(MSG_BLOCK, block))\n+        # self.nodes[2].p2p.send_message(getdata_request)\n+\n+        # # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n+        # # P2PInterface objects.\n+        # wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n+\n+        # self.log.info(\"Check that each block was received only once\")\n+        # # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving\n+        # # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking\n+        # # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n+        # with mininode_lock:\n+        #     for block in self.nodes[2].p2p.block_receive_map.values():\n+        #         assert_equal(block, 1)\n+\n+if __name__ == '__main__':\n+    ExampleTest().main()"
      }
    ]
  },
  {
    "sha": "28910e713938fdfe1ce694284e7396f07e777dad",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyODkxMGU3MTM5MzhmZGZlMWNlNjk0Mjg0ZTczOTZmMDdlNzc3ZGFk",
    "commit": {
      "author": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-07T06:39:46Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:54:56Z"
      },
      "message": "Revert \"Attempted test where one node sends block to another\"\n\nThis reverts commit 55cf78aae878ac1e2a8ed5712877465a2e4a938c.",
      "tree": {
        "sha": "c1106f8528a1bf448bc3c83e7a8051c62d560ac7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c1106f8528a1bf448bc3c83e7a8051c62d560ac7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/28910e713938fdfe1ce694284e7396f07e777dad",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/28910e713938fdfe1ce694284e7396f07e777dad",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/28910e713938fdfe1ce694284e7396f07e777dad",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/28910e713938fdfe1ce694284e7396f07e777dad/comments",
    "author": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "805e6329946799640f69822bd61608d738e4b51f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/805e6329946799640f69822bd61608d738e4b51f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/805e6329946799640f69822bd61608d738e4b51f"
      }
    ],
    "stats": {
      "total": 224,
      "additions": 0,
      "deletions": 224
    },
    "files": [
      {
        "sha": "87d7100d263b50c88ea90451a601e813aebc0939",
        "filename": "test/functional/p2p_saahil.py",
        "status": "removed",
        "additions": 0,
        "deletions": 224,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/805e6329946799640f69822bd61608d738e4b51f/test/functional/p2p_saahil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/805e6329946799640f69822bd61608d738e4b51f/test/functional/p2p_saahil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_saahil.py?ref=805e6329946799640f69822bd61608d738e4b51f",
        "patch": "@@ -1,224 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2017-2019 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"An example functional test\n-\n-The module-level docstring should include a high-level description of\n-what the test is doing. It's the first thing people see when they open\n-the file and should give the reader information about *what* the test\n-is testing and *how* it's being tested\n-\"\"\"\n-# Imports should be in PEP8 ordering (std library first, then third party\n-# libraries then local imports).\n-from collections import defaultdict\n-\n-# Avoid wildcard * imports\n-from test_framework.blocktools import (create_block, create_coinbase)\n-from test_framework.messages import CInv, MSG_BLOCK\n-from test_framework.mininode import (\n-    P2PInterface,\n-    mininode_lock,\n-    msg_block,\n-    msg_getdata,\n-)\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (\n-    assert_equal,\n-    connect_nodes,\n-    wait_until,\n-)\n-\n-# P2PInterface is a class containing callbacks to be executed when a P2P\n-# message is received from the node-under-test. Subclass P2PInterface and\n-# override the on_*() methods if you need custom behaviour.\n-class BaseNode(P2PInterface):\n-    def __init__(self):\n-        \"\"\"Initialize the P2PInterface\n-\n-        Used to initialize custom properties for the Node that aren't\n-        included by default in the base class. Be aware that the P2PInterface\n-        base class already stores a counter for each P2P message type and the\n-        last received message of each type, which should be sufficient for the\n-        needs of most tests.\n-\n-        Call super().__init__() first for standard initialization and then\n-        initialize custom properties.\"\"\"\n-        super().__init__()\n-        # Stores a dictionary of all blocks received\n-        self.block_receive_map = defaultdict(int)\n-\n-    def on_block(self, message):\n-        \"\"\"Override the standard on_block callback\n-\n-        Store the hash of a received block in the dictionary.\"\"\"\n-        message.block.calc_sha256()\n-        self.block_receive_map[message.block.sha256] += 1\n-\n-    def on_inv(self, message):\n-        \"\"\"Override the standard on_inv callback\"\"\"\n-        pass\n-\n-def custom_function():\n-    \"\"\"Do some custom behaviour\n-\n-    If this function is more generally useful for other tests, consider\n-    moving it to a module in test_framework.\"\"\"\n-    # self.log.info(\"running custom_function\")  # Oops! Can't run self.log outside the BitcoinTestFramework\n-    pass\n-\n-\n-class ExampleTest(BitcoinTestFramework):\n-    # Each functional test is a subclass of the BitcoinTestFramework class.\n-\n-    # Override the set_test_params(), skip_test_if_missing_module(), add_options(), setup_chain(), setup_network()\n-    # and setup_nodes() methods to customize the test setup as required.\n-\n-    def set_test_params(self):\n-        \"\"\"Override test parameters for your individual test.\n-\n-        This method must be overridden and num_nodes must be explicitly set.\"\"\"\n-        self.setup_clean_chain = True\n-        self.num_nodes = 3\n-        # Use self.extra_args to change command-line arguments for the nodes\n-        self.extra_args = [[], [\"-logips\"], []]\n-\n-        # self.log.info(\"I've finished set_test_params\")  # Oops! Can't run self.log before run_test()\n-\n-    # Use skip_test_if_missing_module() to skip the test if your test requires certain modules to be present.\n-    # This test uses generate which requires wallet to be compiled\n-    def skip_test_if_missing_module(self):\n-        self.skip_if_no_wallet()\n-\n-    # Use add_options() to add specific command-line options for your test.\n-    # In practice this is not used very much, since the tests are mostly written\n-    # to be run in automated environments without command-line options.\n-    # def add_options()\n-    #     pass\n-\n-    # Use setup_chain() to customize the node data directories. In practice\n-    # this is not used very much since the default behaviour is almost always\n-    # fine\n-    # def setup_chain():\n-    #     pass\n-\n-    def setup_network(self):\n-        \"\"\"Setup the test network topology\n-\n-        Often you won't need to override this, since the standard network topology\n-        (linear: node0 <-> node1 <-> node2 <-> ...) is fine for most tests.\n-\n-        If you do override this method, remember to start the nodes, assign\n-        them to self.nodes, connect them and then sync.\"\"\"\n-\n-        self.setup_nodes()\n-\n-        # In this test, we're not connecting node2 to node0 or node1. Calls to\n-        # sync_all() should not include node2, since we're not expecting it to\n-        # sync.\n-        #connect_nodes(self.nodes[0], 1)\n-        #self.sync_all(self.nodes[0:2])\n-\n-    # Use setup_nodes() to customize the node start behaviour (for example if\n-    # you don't want to start all nodes at the start of the test).\n-    # def setup_nodes():\n-    #     pass\n-\n-    def custom_method(self):\n-        \"\"\"Do some custom behaviour for this test\n-\n-        Define it in a method here because you're going to use it repeatedly.\n-        If you think it's useful in general, consider moving it to the base\n-        BitcoinTestFramework class so other tests can use it.\"\"\"\n-\n-        self.log.info(\"Running custom_method\")\n-\n-    def run_test(self):\n-        \"\"\"Main test logic\"\"\"\n-\n-        # Create P2P connections will wait for a verack to make sure the connection is fully up\n-        self.nodes[0].add_p2p_connection(BaseNode())\n-\n-        # Generating a block on one of the nodes will get us out of IBD\n-        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n-        self.log.info(\"Number of blocks in node 0: \" + str(self.nodes[0].getblockcount()))\n-        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n-        \n-        self.log.info(\"Now sending block from one to the other\")\n-        connect_nodes(self.nodes[0], 1)\n-        self.sync_all(self.nodes[0:2])\n-\n-        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n-\n-        # # Notice above how we called an RPC by calling a method with the same\n-        # # name on the node object. Notice also how we used a keyword argument\n-        # # to specify a named RPC argument. Neither of those are defined on the\n-        # # node object. Instead there's some __getattr__() magic going on under\n-        # # the covers to dispatch unrecognised attribute calls to the RPC\n-        # # interface.\n-\n-        # # Logs are nice. Do plenty of them. They can be used in place of comments for\n-        # # breaking the test into sub-sections.\n-        # self.log.info(\"Starting test!\")\n-\n-        # self.log.info(\"Calling a custom function\")\n-        # custom_function()\n-\n-        # self.log.info(\"Calling a custom method\")\n-        # self.custom_method()\n-\n-        # self.log.info(\"Create some blocks\")\n-        # self.tip = int(self.nodes[0].getbestblockhash(), 16)\n-        # self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n-\n-        # height = self.nodes[0].getblockcount()\n-\n-        # for i in range(10):\n-        #     # Use the mininode and blocktools functionality to manually build a block\n-        #     # Calling the generate() rpc is easier, but this allows us to exactly\n-        #     # control the blocks and transactions.\n-        #     block = create_block(self.tip, create_coinbase(height+1), self.block_time)\n-        #     block.solve()\n-        #     block_message = msg_block(block)\n-        #     # Send message is used to send a P2P message to the node over our P2PInterface\n-        #     self.nodes[0].p2p.send_message(block_message)\n-        #     self.tip = block.sha256\n-        #     blocks.append(self.tip)\n-        #     self.block_time += 1\n-        #     height += 1\n-\n-        # self.log.info(\"Wait for node1 to reach current tip (height 11) using RPC\")\n-        # self.nodes[1].waitforblockheight(11)\n-\n-        # self.log.info(\"Connect node2 and node1\")\n-        # connect_nodes(self.nodes[1], 2)\n-\n-        # self.log.info(\"Wait for node2 to receive all the blocks from node1\")\n-        # self.sync_all()\n-\n-        # self.log.info(\"Add P2P connection to node2\")\n-        # self.nodes[0].disconnect_p2ps()\n-\n-        # self.nodes[2].add_p2p_connection(BaseNode())\n-\n-        # self.log.info(\"Test that node2 propagates all the blocks to us\")\n-\n-        # getdata_request = msg_getdata()\n-        # for block in blocks:\n-        #     getdata_request.inv.append(CInv(MSG_BLOCK, block))\n-        # self.nodes[2].p2p.send_message(getdata_request)\n-\n-        # # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n-        # # P2PInterface objects.\n-        # wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n-\n-        # self.log.info(\"Check that each block was received only once\")\n-        # # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving\n-        # # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking\n-        # # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n-        # with mininode_lock:\n-        #     for block in self.nodes[2].p2p.block_receive_map.values():\n-        #         assert_equal(block, 1)\n-\n-if __name__ == '__main__':\n-    ExampleTest().main()"
      }
    ]
  },
  {
    "sha": "61a7f86f1712f6fcbcd37d37cd6ef463dd9899de",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MWE3Zjg2ZjE3MTJmNmZjYmNkMzdkMzdjZDZlZjQ2M2RkOTg5OWRl",
    "commit": {
      "author": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-09T07:07:31Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2020-07-10T08:54:56Z"
      },
      "message": "Revert \"[test] test send* wallet rpcs with verbose=True\"\n\nThis reverts commit d8da095378c307052610119ea207a929ba441685.",
      "tree": {
        "sha": "9a42c18959b570a214d6999b98ed30e519fdd6c2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9a42c18959b570a214d6999b98ed30e519fdd6c2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/61a7f86f1712f6fcbcd37d37cd6ef463dd9899de",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61a7f86f1712f6fcbcd37d37cd6ef463dd9899de",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/61a7f86f1712f6fcbcd37d37cd6ef463dd9899de",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61a7f86f1712f6fcbcd37d37cd6ef463dd9899de/comments",
    "author": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "28910e713938fdfe1ce694284e7396f07e777dad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/28910e713938fdfe1ce694284e7396f07e777dad",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/28910e713938fdfe1ce694284e7396f07e777dad"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 0,
      "deletions": 9
    },
    "files": [
      {
        "sha": "896236227688f3a3b1dba5ea64aa7d5f5549961d",
        "filename": "test/functional/wallet_basic.py",
        "status": "modified",
        "additions": 0,
        "deletions": 9,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61a7f86f1712f6fcbcd37d37cd6ef463dd9899de/test/functional/wallet_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61a7f86f1712f6fcbcd37d37cd6ef463dd9899de/test/functional/wallet_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_basic.py?ref=61a7f86f1712f6fcbcd37d37cd6ef463dd9899de",
        "patch": "@@ -650,15 +650,6 @@ def run_test(self):\n         assert_array_result(tx[\"details\"], {\"category\": \"receive\"}, expected_receive_vout)\n         assert_equal(tx[verbose_field], self.nodes[0].decoderawtransaction(tx[\"hex\"]))\n \n-        self.log.info(\"Testing Fee Reason\")\n-        #testing send_rpc_verbose sendtoaddress\n-        address = self.nodes[0].getnewaddress(\"test\") \n-        txid_feeReason_one = self.nodes[2].sendtoaddress(address = address, amount = 10, verbose = True)\n-        assert_equal(str(txid_feeReason_one[\"Fee Reason\"]), \"Fallback fee\")\n-\n-        #testing send_rpc_verbose sendtoaddress\n-        txid_feeReason_two = self.nodes[2].sendmany(dummy = '', amounts = {address: 10}, verbose = True) \n-        assert_equal(str(txid_feeReason_two[\"Fee Reason\"]), \"Fallback fee\")\n \n if __name__ == '__main__':\n     WalletTest().main()"
      }
    ]
  },
  {
    "sha": "a5c1cea195e60a894bf50db7bd33e1ce6adf1779",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNWMxY2VhMTk1ZTYwYTg5NGJmNTBkYjdiZDMzZTFjZTZhZGYxNzc5",
    "commit": {
      "author": {
        "name": "Sishir Giri",
        "email": "sis1001@berkeley.edu",
        "date": "2020-07-11T20:52:04Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2020-07-11T20:52:04Z"
      },
      "message": "Merge pull request #6 from BerkeleyBlockchain/master\n\nsend rpc return fee reason",
      "tree": {
        "sha": "081bde4b71531ad15f785113deb9d9b9bc7ebc91",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/081bde4b71531ad15f785113deb9d9b9bc7ebc91"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a5c1cea195e60a894bf50db7bd33e1ce6adf1779",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfCiZ0CRBK7hj4Ov3rIwAAdHIIAHTRLducodiaDtIlh7UrpcK3\nP598NzyXi9jnKuG+xoyrzBWVbjRyxwx1fqiBqvXfrRq8QiQh5zA3m4p5FCrL48nS\ncJk7I78NWb4CZFJkoUos3eyWXEZKbeYoynrj9ajf+5VT0jN7me2aThnYVVrDc9Fz\nprvQXmUeojOJcH49LgLsIrVP3FBs93vjby6MT27LHX6AGjLTD/FTEieMvkf7jy4L\nAIAPOBtPAdbIPGK99qVz4j3D6JRGBSdiMerT1BuFwwUEUQpONWLqtRhyoUQeelBf\n6LPTBrM2ghRMoqqW2dGk0US6mfoFI2DxIVW4j5d8H1gH3jqYUOucFJQxTotn0Lk=\n=JRn0\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 081bde4b71531ad15f785113deb9d9b9bc7ebc91\nparent 61a7f86f1712f6fcbcd37d37cd6ef463dd9899de\nparent 1341bd0f3107c45461c7193ffcba444accbea70b\nauthor Sishir Giri <sis1001@berkeley.edu> 1594500724 -0700\ncommitter GitHub <noreply@github.com> 1594500724 -0700\n\nMerge pull request #6 from BerkeleyBlockchain/master\n\nsend rpc return fee reason"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a5c1cea195e60a894bf50db7bd33e1ce6adf1779",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a5c1cea195e60a894bf50db7bd33e1ce6adf1779",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a5c1cea195e60a894bf50db7bd33e1ce6adf1779/comments",
    "author": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "61a7f86f1712f6fcbcd37d37cd6ef463dd9899de",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61a7f86f1712f6fcbcd37d37cd6ef463dd9899de",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/61a7f86f1712f6fcbcd37d37cd6ef463dd9899de"
      },
      {
        "sha": "1341bd0f3107c45461c7193ffcba444accbea70b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1341bd0f3107c45461c7193ffcba444accbea70b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1341bd0f3107c45461c7193ffcba444accbea70b"
      }
    ],
    "stats": {
      "total": 224,
      "additions": 224,
      "deletions": 0
    },
    "files": [
      {
        "sha": "87d7100d263b50c88ea90451a601e813aebc0939",
        "filename": "test/functional/p2p_saahil.py",
        "status": "added",
        "additions": 224,
        "deletions": 0,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5c1cea195e60a894bf50db7bd33e1ce6adf1779/test/functional/p2p_saahil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5c1cea195e60a894bf50db7bd33e1ce6adf1779/test/functional/p2p_saahil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_saahil.py?ref=a5c1cea195e60a894bf50db7bd33e1ce6adf1779",
        "patch": "@@ -0,0 +1,224 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"An example functional test\n+\n+The module-level docstring should include a high-level description of\n+what the test is doing. It's the first thing people see when they open\n+the file and should give the reader information about *what* the test\n+is testing and *how* it's being tested\n+\"\"\"\n+# Imports should be in PEP8 ordering (std library first, then third party\n+# libraries then local imports).\n+from collections import defaultdict\n+\n+# Avoid wildcard * imports\n+from test_framework.blocktools import (create_block, create_coinbase)\n+from test_framework.messages import CInv, MSG_BLOCK\n+from test_framework.mininode import (\n+    P2PInterface,\n+    mininode_lock,\n+    msg_block,\n+    msg_getdata,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    connect_nodes,\n+    wait_until,\n+)\n+\n+# P2PInterface is a class containing callbacks to be executed when a P2P\n+# message is received from the node-under-test. Subclass P2PInterface and\n+# override the on_*() methods if you need custom behaviour.\n+class BaseNode(P2PInterface):\n+    def __init__(self):\n+        \"\"\"Initialize the P2PInterface\n+\n+        Used to initialize custom properties for the Node that aren't\n+        included by default in the base class. Be aware that the P2PInterface\n+        base class already stores a counter for each P2P message type and the\n+        last received message of each type, which should be sufficient for the\n+        needs of most tests.\n+\n+        Call super().__init__() first for standard initialization and then\n+        initialize custom properties.\"\"\"\n+        super().__init__()\n+        # Stores a dictionary of all blocks received\n+        self.block_receive_map = defaultdict(int)\n+\n+    def on_block(self, message):\n+        \"\"\"Override the standard on_block callback\n+\n+        Store the hash of a received block in the dictionary.\"\"\"\n+        message.block.calc_sha256()\n+        self.block_receive_map[message.block.sha256] += 1\n+\n+    def on_inv(self, message):\n+        \"\"\"Override the standard on_inv callback\"\"\"\n+        pass\n+\n+def custom_function():\n+    \"\"\"Do some custom behaviour\n+\n+    If this function is more generally useful for other tests, consider\n+    moving it to a module in test_framework.\"\"\"\n+    # self.log.info(\"running custom_function\")  # Oops! Can't run self.log outside the BitcoinTestFramework\n+    pass\n+\n+\n+class ExampleTest(BitcoinTestFramework):\n+    # Each functional test is a subclass of the BitcoinTestFramework class.\n+\n+    # Override the set_test_params(), skip_test_if_missing_module(), add_options(), setup_chain(), setup_network()\n+    # and setup_nodes() methods to customize the test setup as required.\n+\n+    def set_test_params(self):\n+        \"\"\"Override test parameters for your individual test.\n+\n+        This method must be overridden and num_nodes must be explicitly set.\"\"\"\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+        # Use self.extra_args to change command-line arguments for the nodes\n+        self.extra_args = [[], [\"-logips\"], []]\n+\n+        # self.log.info(\"I've finished set_test_params\")  # Oops! Can't run self.log before run_test()\n+\n+    # Use skip_test_if_missing_module() to skip the test if your test requires certain modules to be present.\n+    # This test uses generate which requires wallet to be compiled\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    # Use add_options() to add specific command-line options for your test.\n+    # In practice this is not used very much, since the tests are mostly written\n+    # to be run in automated environments without command-line options.\n+    # def add_options()\n+    #     pass\n+\n+    # Use setup_chain() to customize the node data directories. In practice\n+    # this is not used very much since the default behaviour is almost always\n+    # fine\n+    # def setup_chain():\n+    #     pass\n+\n+    def setup_network(self):\n+        \"\"\"Setup the test network topology\n+\n+        Often you won't need to override this, since the standard network topology\n+        (linear: node0 <-> node1 <-> node2 <-> ...) is fine for most tests.\n+\n+        If you do override this method, remember to start the nodes, assign\n+        them to self.nodes, connect them and then sync.\"\"\"\n+\n+        self.setup_nodes()\n+\n+        # In this test, we're not connecting node2 to node0 or node1. Calls to\n+        # sync_all() should not include node2, since we're not expecting it to\n+        # sync.\n+        #connect_nodes(self.nodes[0], 1)\n+        #self.sync_all(self.nodes[0:2])\n+\n+    # Use setup_nodes() to customize the node start behaviour (for example if\n+    # you don't want to start all nodes at the start of the test).\n+    # def setup_nodes():\n+    #     pass\n+\n+    def custom_method(self):\n+        \"\"\"Do some custom behaviour for this test\n+\n+        Define it in a method here because you're going to use it repeatedly.\n+        If you think it's useful in general, consider moving it to the base\n+        BitcoinTestFramework class so other tests can use it.\"\"\"\n+\n+        self.log.info(\"Running custom_method\")\n+\n+    def run_test(self):\n+        \"\"\"Main test logic\"\"\"\n+\n+        # Create P2P connections will wait for a verack to make sure the connection is fully up\n+        self.nodes[0].add_p2p_connection(BaseNode())\n+\n+        # Generating a block on one of the nodes will get us out of IBD\n+        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n+        self.log.info(\"Number of blocks in node 0: \" + str(self.nodes[0].getblockcount()))\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+        \n+        self.log.info(\"Now sending block from one to the other\")\n+        connect_nodes(self.nodes[0], 1)\n+        self.sync_all(self.nodes[0:2])\n+\n+        self.log.info(\"Number of blocks in node 1: \" + str(self.nodes[1].getblockcount()))\n+\n+        # # Notice above how we called an RPC by calling a method with the same\n+        # # name on the node object. Notice also how we used a keyword argument\n+        # # to specify a named RPC argument. Neither of those are defined on the\n+        # # node object. Instead there's some __getattr__() magic going on under\n+        # # the covers to dispatch unrecognised attribute calls to the RPC\n+        # # interface.\n+\n+        # # Logs are nice. Do plenty of them. They can be used in place of comments for\n+        # # breaking the test into sub-sections.\n+        # self.log.info(\"Starting test!\")\n+\n+        # self.log.info(\"Calling a custom function\")\n+        # custom_function()\n+\n+        # self.log.info(\"Calling a custom method\")\n+        # self.custom_method()\n+\n+        # self.log.info(\"Create some blocks\")\n+        # self.tip = int(self.nodes[0].getbestblockhash(), 16)\n+        # self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n+\n+        # height = self.nodes[0].getblockcount()\n+\n+        # for i in range(10):\n+        #     # Use the mininode and blocktools functionality to manually build a block\n+        #     # Calling the generate() rpc is easier, but this allows us to exactly\n+        #     # control the blocks and transactions.\n+        #     block = create_block(self.tip, create_coinbase(height+1), self.block_time)\n+        #     block.solve()\n+        #     block_message = msg_block(block)\n+        #     # Send message is used to send a P2P message to the node over our P2PInterface\n+        #     self.nodes[0].p2p.send_message(block_message)\n+        #     self.tip = block.sha256\n+        #     blocks.append(self.tip)\n+        #     self.block_time += 1\n+        #     height += 1\n+\n+        # self.log.info(\"Wait for node1 to reach current tip (height 11) using RPC\")\n+        # self.nodes[1].waitforblockheight(11)\n+\n+        # self.log.info(\"Connect node2 and node1\")\n+        # connect_nodes(self.nodes[1], 2)\n+\n+        # self.log.info(\"Wait for node2 to receive all the blocks from node1\")\n+        # self.sync_all()\n+\n+        # self.log.info(\"Add P2P connection to node2\")\n+        # self.nodes[0].disconnect_p2ps()\n+\n+        # self.nodes[2].add_p2p_connection(BaseNode())\n+\n+        # self.log.info(\"Test that node2 propagates all the blocks to us\")\n+\n+        # getdata_request = msg_getdata()\n+        # for block in blocks:\n+        #     getdata_request.inv.append(CInv(MSG_BLOCK, block))\n+        # self.nodes[2].p2p.send_message(getdata_request)\n+\n+        # # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n+        # # P2PInterface objects.\n+        # wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n+\n+        # self.log.info(\"Check that each block was received only once\")\n+        # # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving\n+        # # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking\n+        # # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n+        # with mininode_lock:\n+        #     for block in self.nodes[2].p2p.block_receive_map.values():\n+        #         assert_equal(block, 1)\n+\n+if __name__ == '__main__':\n+    ExampleTest().main()"
      }
    ]
  }
]