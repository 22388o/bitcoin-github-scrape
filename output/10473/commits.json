[
  {
    "sha": "2345a973e9a6a99df3585a7f95fc6d8da55c8d61",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMzQ1YTk3M2U5YTZhOTlkZjM1ODVhN2Y5NWZjNmQ4ZGE1NWM4ZDYx",
    "commit": {
      "author": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@wirelessprv-10-195-127-163.near.illinois.edu",
        "date": "2017-04-13T19:59:51Z"
      },
      "committer": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@wirelessprv-10-195-127-163.near.illinois.edu",
        "date": "2017-04-13T19:59:51Z"
      },
      "message": "added dandelion propagation",
      "tree": {
        "sha": "c56b0ac212c30ec08e8fc101635a0031b2c3bbb5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c56b0ac212c30ec08e8fc101635a0031b2c3bbb5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2345a973e9a6a99df3585a7f95fc6d8da55c8d61",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2345a973e9a6a99df3585a7f95fc6d8da55c8d61",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2345a973e9a6a99df3585a7f95fc6d8da55c8d61",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2345a973e9a6a99df3585a7f95fc6d8da55c8d61/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "67023e9004ba843218bee16bc821e955faf0d394",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/67023e9004ba843218bee16bc821e955faf0d394",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/67023e9004ba843218bee16bc821e955faf0d394"
      }
    ],
    "stats": {
      "total": 110,
      "additions": 104,
      "deletions": 6
    },
    "files": [
      {
        "sha": "7677f67bf7b39c3b15c20e90918878aa619f4de8",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 90,
        "deletions": 5,
        "changes": 95,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2345a973e9a6a99df3585a7f95fc6d8da55c8d61/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2345a973e9a6a99df3585a7f95fc6d8da55c8d61/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=2345a973e9a6a99df3585a7f95fc6d8da55c8d61",
        "patch": "@@ -31,6 +31,8 @@\n #include \"validationinterface.h\"\n \n #include <boost/thread.hpp>\n+#include <stdlib.h> \n+#include <unordered_set>\n \n #if defined(NDEBUG)\n # error \"Bitcoin cannot be compiled without assertions.\"\n@@ -122,6 +124,10 @@ namespace {\n     MapRelay mapRelay;\n     /** Expiration-time ordered list of (expire time, relay map entry) pairs, protected by cs_main). */\n     std::deque<std::pair<int64_t, MapRelay::iterator>> vRelayExpiration;\n+\n+    /** Set of hashes for transactions that are in the Dandelion stem. */\n+    std::set<uint256> stemSet;\n+    \n } // anon namespace\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -925,9 +931,43 @@ bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n static void RelayTransaction(const CTransaction& tx, CConnman& connman)\n {\n     CInv inv(MSG_TX, tx.GetHash());\n-    connman.ForEachNode([&inv](CNode* pnode)\n+    bool stemRelay = false;\n+    CNode* stemNode;\n+    // 1) Check if inv is in the stem\n+    if (stemSet.find(inv.hash) != stemSet.end()) {\n+        /* Pick a dandelion relay at random from outgoing edges\n+           (in principle, this should be the same for all messages\n+           but for our prototype, we will choose relays independently\n+           across transactions)\n+        */ \n+        stemRelay = true;\n+        // Track the outgoing connections with dandelion enabled\n+        std::vector<CNode*> outgoing;\n+        connman.ForEachNode( [&outgoing](CNode* pnode)\n+        {\n+            if (!pnode->fInbound && pnode->GetSendVersion() >= DANDELION_VERSION_NUM) {\n+                outgoing.push_back(pnode);\n+            }\n+        });\n+\n+        // If there are no connected Dandelion nodes, go to fluff phase\n+        if (outgoing.empty()) {\n+            stemSet.erase(inv.hash);\n+        } else {\n+            /* Choose a random element from outgoing (this isn't exactly pseudorandom, \n+            depending on the size of RAND_MAX, but it's close enough) */\n+            std::vector<CNode*>::iterator randIt = outgoing.begin();\n+            std::advance(randIt, std::rand() % outgoing.size());\n+            stemNode = *randIt;\n+        }\n+\n+    }\n+    connman.ForEachNode([&inv,&stemRelay,&stemNode](CNode* pnode)\n     {\n-        pnode->PushInventory(inv);\n+        // Then add inv to the node's queue, if it's supposed to receive the message\n+        if (!stemRelay || stemNode == pnode) {\n+            pnode->PushInventory(inv);\n+        }\n     });\n }\n \n@@ -1513,7 +1553,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n     }\n \n \n-    else if (strCommand == NetMsgType::INV)\n+    else if (strCommand == NetMsgType::INV || strCommand == NetMsgType::D_INV)\n     {\n         std::vector<CInv> vInv;\n         vRecv >> vInv;\n@@ -1548,6 +1588,17 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n             if (inv.type == MSG_TX) {\n                 inv.type |= nFetchFlags;\n+\n+                // If the transaction is in the stem, decide if it should remain in the stem\n+                if (strCommand == NetMsgType::D_INV)\n+                {\n+                    float rand_prob = ((float) rand() / (float) RAND_MAX);\n+                    if (rand_prob < DANDELION_PROB)\n+                    {\n+                        // Add the hash to the set of ongoing stem transactions\n+                        stemSet.insert(inv.hash);\n+                    }\n+                }\n             }\n \n             if (inv.type == MSG_BLOCK) {\n@@ -1956,7 +2007,6 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n     }\n \n-\n     else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n     {\n         CBlockHeaderAndShortTxIDs cmpctblock;\n@@ -3042,17 +3092,52 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n         {\n             LOCK(pto->cs_inventory);\n             vInv.reserve(std::max<size_t>(pto->vInventoryBlockToSend.size(), INVENTORY_BROADCAST_MAX));\n-\n+            \n             // Add blocks\n             BOOST_FOREACH(const uint256& hash, pto->vInventoryBlockToSend) {\n+                \n                 vInv.push_back(CInv(MSG_BLOCK, hash));\n+\n                 if (vInv.size() == MAX_INV_SZ) {\n                     connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                     vInv.clear();\n                 }\n+\n             }\n             pto->vInventoryBlockToSend.clear();\n \n+            /* -------------Process all Dandelion transactions ----------------- \n+            We do this here because the Dandelion inv messages should not be sent\n+            with the usual exponential delay. */\n+\n+            std::vector<CInv> dandVInv;\n+            // Add only the elements that are in the Dandelion stem\n+            dandVInv.reserve(pto->setInventoryTxToSend.size());\n+            for (std::set<uint256>::iterator it = pto->setInventoryTxToSend.begin(); it != pto->setInventoryTxToSend.end(); it++) {\n+                uint256 hash = *it;\n+                // Check if the hash is in the dandelion stem\n+                if (stemSet.find(hash) != stemSet.end()) {\n+                    // remove the hash from the dandelion stem set\n+                    stemSet.erase(hash);\n+                    // remove the iterator from pto's to-send list\n+                    pto->setInventoryTxToSend.erase(it);\n+                    // Add the item to the queue to be sent\n+                    dandVInv.push_back(CInv(MSG_TX, hash));\n+                    if (vInv.size() == MAX_INV_SZ) {\n+                        connman.PushMessage(pto, msgMaker.Make(NetMsgType::D_INV, vInv));\n+                        vInv.clear();\n+                    }\n+                    pto->filterInventoryKnown.insert(hash);\n+                }\n+            }\n+            if (!vInv.empty()) {\n+                connman.PushMessage(pto, msgMaker.Make(NetMsgType::D_INV, vInv));\n+            }\n+\n+            /*-------------------------------------------------------------------------------*/\n+\n+\n+\n             // Check whether periodic sends should happen\n             bool fSendTrickle = pto->fWhitelisted;\n             if (pto->nNextInvSend < nNow) {"
      },
      {
        "sha": "50e7c6fce66656d443afa64978dc1d0fcef61f31",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2345a973e9a6a99df3585a7f95fc6d8da55c8d61/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2345a973e9a6a99df3585a7f95fc6d8da55c8d61/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=2345a973e9a6a99df3585a7f95fc6d8da55c8d61",
        "patch": "@@ -17,6 +17,8 @@ static const int64_t ORPHAN_TX_EXPIRE_TIME = 20 * 60;\n static const int64_t ORPHAN_TX_EXPIRE_INTERVAL = 5 * 60;\n /** Default number of orphan+recently-replaced txn to keep around for block reconstruction */\n static const unsigned int DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN = 100;\n+/** Version number that supports Dandelion */\n+static const int DANDELION_VERSION_NUM = 10;        // TODO: Figure out the version number!\n \n /** Register with a network node to receive its signals */\n void RegisterNodeSignals(CNodeSignals& nodeSignals);"
      },
      {
        "sha": "e654441063216a8ebfef28fc3c7cfafadbc69fa8",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2345a973e9a6a99df3585a7f95fc6d8da55c8d61/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2345a973e9a6a99df3585a7f95fc6d8da55c8d61/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=2345a973e9a6a99df3585a7f95fc6d8da55c8d61",
        "patch": "@@ -39,6 +39,7 @@ const char *SENDCMPCT=\"sendcmpct\";\n const char *CMPCTBLOCK=\"cmpctblock\";\n const char *GETBLOCKTXN=\"getblocktxn\";\n const char *BLOCKTXN=\"blocktxn\";\n+const char *D_INV=\"d_inv\";\n };\n \n /** All known message types. Keep this in the same order as the list of\n@@ -71,6 +72,7 @@ const static std::string allNetMessageTypes[] = {\n     NetMsgType::CMPCTBLOCK,\n     NetMsgType::GETBLOCKTXN,\n     NetMsgType::BLOCKTXN,\n+    NetMsgType::D_INV,\n };\n const static std::vector<std::string> allNetMessageTypesVec(allNetMessageTypes, allNetMessageTypes+ARRAYLEN(allNetMessageTypes));\n "
      },
      {
        "sha": "4e84f06bd7fb314796fcac340ea691bd5fe127e5",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2345a973e9a6a99df3585a7f95fc6d8da55c8d61/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2345a973e9a6a99df3585a7f95fc6d8da55c8d61/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=2345a973e9a6a99df3585a7f95fc6d8da55c8d61",
        "patch": "@@ -240,11 +240,19 @@ extern const char *GETBLOCKTXN;\n  * @since protocol version 70014 as described by BIP 152\n  */\n extern const char *BLOCKTXN;\n+/**\n+ * The Dandelion inv message indicates that the message\n+ * is in the stem phase of Dandelion spreading.\n+ */\n+extern const char *D_INV;\n };\n \n /* Get a vector of all valid message types (see above) */\n const std::vector<std::string> &getAllNetMessageTypes();\n \n+/* Dandelion forwarding probability */\n+const float DANDELION_PROB = 0.2;\n+\n /** nServices flags */\n enum ServiceFlags : uint64_t {\n     // Nothing"
      },
      {
        "sha": "cf6f9c9ccdd4e74df0c0f477879db6309acfe05a",
        "filename": "src/version.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2345a973e9a6a99df3585a7f95fc6d8da55c8d61/src/version.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2345a973e9a6a99df3585a7f95fc6d8da55c8d61/src/version.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/version.h?ref=2345a973e9a6a99df3585a7f95fc6d8da55c8d61",
        "patch": "@@ -9,7 +9,8 @@\n  * network protocol versioning\n  */\n \n-static const int PROTOCOL_VERSION = 70015;\n+// Updated the version number to 70016, to be compatible with Dandelion\n+static const int PROTOCOL_VERSION = 70016;\n \n //! initial proto version, to be increased after version/verack negotiation\n static const int INIT_PROTO_VERSION = 209;"
      }
    ]
  },
  {
    "sha": "85b7acb316d53dc8403efb545cdd73d25cf9e280",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NWI3YWNiMzE2ZDUzZGM4NDAzZWZiNTQ1Y2RkNzNkMjVjZjllMjgw",
    "commit": {
      "author": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@wirelessprv-10-195-127-163.near.illinois.edu",
        "date": "2017-04-13T19:59:55Z"
      },
      "committer": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@wirelessprv-10-195-127-163.near.illinois.edu",
        "date": "2017-04-13T19:59:55Z"
      },
      "message": "Merge branch 'master' of https://github.com/bitcoin/bitcoin",
      "tree": {
        "sha": "ee477526c7883e4561b1a530dc8e407d165b5766",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ee477526c7883e4561b1a530dc8e407d165b5766"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/85b7acb316d53dc8403efb545cdd73d25cf9e280",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/85b7acb316d53dc8403efb545cdd73d25cf9e280",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/85b7acb316d53dc8403efb545cdd73d25cf9e280",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/85b7acb316d53dc8403efb545cdd73d25cf9e280/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "2345a973e9a6a99df3585a7f95fc6d8da55c8d61",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2345a973e9a6a99df3585a7f95fc6d8da55c8d61",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2345a973e9a6a99df3585a7f95fc6d8da55c8d61"
      },
      {
        "sha": "b7365f0545b1a6862e3277b2b2139ee0d5aee1cf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7365f0545b1a6862e3277b2b2139ee0d5aee1cf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b7365f0545b1a6862e3277b2b2139ee0d5aee1cf"
      }
    ],
    "stats": {
      "total": 418,
      "additions": 281,
      "deletions": 137
    },
    "files": [
      {
        "sha": "d08c8bde5b94e4162418d12105d7bdd651c328dd",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "patch": "@@ -97,7 +97,7 @@ endif\n test_test_bitcoin_SOURCES = $(BITCOIN_TESTS) $(JSON_TEST_FILES) $(RAW_TEST_FILES)\n test_test_bitcoin_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -I$(builddir)/test/ $(TESTDEFS) $(EVENT_CFLAGS)\n test_test_bitcoin_LDADD = $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) $(LIBMEMENV) \\\n-  $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB) $(LIBSECP256K1) $(EVENT_LIBS)\n+  $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB) $(LIBSECP256K1) $(EVENT_LIBS) $(EVENT_PTHREADS_LIBS)\n test_test_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n if ENABLE_WALLET\n test_test_bitcoin_LDADD += $(LIBBITCOIN_WALLET)"
      },
      {
        "sha": "42891f345b7c8e7cb57800427891b51e1844c81e",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "patch": "@@ -48,7 +48,7 @@ static void CoinSelection(benchmark::State& state)\n             addCoin(1000 * COIN, wallet, vCoins);\n         addCoin(3 * COIN, wallet, vCoins);\n \n-        std::set<std::pair<const CWalletTx*, unsigned int> > setCoinsRet;\n+        std::set<CInputCoin> setCoinsRet;\n         CAmount nValueRet;\n         bool success = wallet.SelectCoinsMinConf(1003 * COIN, 1, 6, 0, vCoins, setCoinsRet, nValueRet);\n         assert(success);"
      },
      {
        "sha": "e7df23295d1afd63f7e39f7534d269e73da0a41a",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 8,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "patch": "@@ -384,15 +384,13 @@ bool InitHTTPServer()\n \n     // Redirect libevent's logging to our own log\n     event_set_log_callback(&libevent_log_cb);\n-#if LIBEVENT_VERSION_NUMBER >= 0x02010100\n-    // If -debug=libevent, set full libevent debugging.\n-    // Otherwise, disable all libevent debugging.\n-    if (LogAcceptCategory(BCLog::LIBEVENT)) {\n-        event_enable_debug_logging(EVENT_DBG_ALL);\n-    } else {\n-        event_enable_debug_logging(EVENT_DBG_NONE);\n+    // Update libevent's log handling. Returns false if our version of\n+    // libevent doesn't support debug logging, in which case we should\n+    // clear the BCLog::LIBEVENT flag.\n+    if (!UpdateHTTPServerLogging(logCategories & BCLog::LIBEVENT)) {\n+        logCategories &= ~BCLog::LIBEVENT;\n     }\n-#endif\n+\n #ifdef WIN32\n     evthread_use_windows_threads();\n #else\n@@ -435,6 +433,20 @@ bool InitHTTPServer()\n     return true;\n }\n \n+bool UpdateHTTPServerLogging(bool enable) {\n+#if LIBEVENT_VERSION_NUMBER >= 0x02010100\n+    if (enable) {\n+        event_enable_debug_logging(EVENT_DBG_ALL);\n+    } else {\n+        event_enable_debug_logging(EVENT_DBG_NONE);\n+    }\n+    return true;\n+#else\n+    // Can't update libevent logging if version < 02010100\n+    return false;\n+#endif\n+}\n+\n std::thread threadHTTP;\n std::future<bool> threadResult;\n "
      },
      {
        "sha": "6be9950682034d6a4b7fb37be7c3163c1864dedb",
        "filename": "src/httpserver.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/httpserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/httpserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.h?ref=85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "patch": "@@ -32,6 +32,10 @@ void InterruptHTTPServer();\n /** Stop HTTP server */\n void StopHTTPServer();\n \n+/** Change logging level for libevent. Removes BCLog::LIBEVENT from logCategories if\n+ * libevent doesn't support debug logging.*/\n+bool UpdateHTTPServerLogging(bool enable);\n+\n /** Handler for requests to a certain HTTP path */\n typedef std::function<bool(HTTPRequest* req, const std::string &)> HTTPRequestHandler;\n /** Register handler for prefix."
      },
      {
        "sha": "91b2685e4848a79eb87c948e50bc0291f09f64ff",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "patch": "@@ -92,7 +92,7 @@ static const ServiceFlags REQUIRED_SERVICES = NODE_NETWORK;\n // NOTE: When adjusting this, update rpcnet:setban's help (\"24h\")\n static const unsigned int DEFAULT_MISBEHAVING_BANTIME = 60 * 60 * 24;  // Default 24-hour ban\n \n-typedef int NodeId;\n+typedef int64_t NodeId;\n \n struct AddedNodeInfo\n {"
      },
      {
        "sha": "83f89cac0b4819388ecad51552fb8d16842ddcb5",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 18,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "patch": "@@ -780,10 +780,12 @@ void PeerLogicValidation::BlockConnected(const std::shared_ptr<const CBlock>& pb\n     }\n }\n \n+// All of the following cache a recent block, and are protected by cs_most_recent_block\n static CCriticalSection cs_most_recent_block;\n static std::shared_ptr<const CBlock> most_recent_block;\n static std::shared_ptr<const CBlockHeaderAndShortTxIDs> most_recent_compact_block;\n static uint256 most_recent_block_hash;\n+static bool fWitnessesPresentInMostRecentCompactBlock;\n \n void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) {\n     std::shared_ptr<const CBlockHeaderAndShortTxIDs> pcmpctblock = std::make_shared<const CBlockHeaderAndShortTxIDs> (*pblock, true);\n@@ -804,6 +806,7 @@ void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std:\n         most_recent_block_hash = hashBlock;\n         most_recent_block = pblock;\n         most_recent_compact_block = pcmpctblock;\n+        fWitnessesPresentInMostRecentCompactBlock = fWitnessEnabled;\n     }\n \n     connman->ForEachNode([this, &pcmpctblock, pindex, &msgMaker, fWitnessEnabled, &hashBlock](CNode* pnode) {\n@@ -1030,6 +1033,15 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n             {\n                 bool send = false;\n                 BlockMap::iterator mi = mapBlockIndex.find(inv.hash);\n+                std::shared_ptr<const CBlock> a_recent_block;\n+                std::shared_ptr<const CBlockHeaderAndShortTxIDs> a_recent_compact_block;\n+                bool fWitnessesPresentInARecentCompactBlock;\n+                {\n+                    LOCK(cs_most_recent_block);\n+                    a_recent_block = most_recent_block;\n+                    a_recent_compact_block = most_recent_compact_block;\n+                    fWitnessesPresentInARecentCompactBlock = fWitnessesPresentInMostRecentCompactBlock;\n+                }\n                 if (mi != mapBlockIndex.end())\n                 {\n                     if (mi->second->nChainTx && !mi->second->IsValid(BLOCK_VALID_SCRIPTS) &&\n@@ -1039,11 +1051,6 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         // before ActivateBestChain but after AcceptBlock).\n                         // In this case, we need to run ActivateBestChain prior to checking the relay\n                         // conditions below.\n-                        std::shared_ptr<const CBlock> a_recent_block;\n-                        {\n-                            LOCK(cs_most_recent_block);\n-                            a_recent_block = most_recent_block;\n-                        }\n                         CValidationState dummy;\n                         ActivateBestChain(dummy, Params(), a_recent_block);\n                     }\n@@ -1077,14 +1084,20 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                 // it's available before trying to send.\n                 if (send && (mi->second->nStatus & BLOCK_HAVE_DATA))\n                 {\n-                    // Send block from disk\n-                    CBlock block;\n-                    if (!ReadBlockFromDisk(block, (*mi).second, consensusParams))\n-                        assert(!\"cannot load block from disk\");\n+                    std::shared_ptr<const CBlock> pblock;\n+                    if (a_recent_block && a_recent_block->GetHash() == (*mi).second->GetBlockHash()) {\n+                        pblock = a_recent_block;\n+                    } else {\n+                        // Send block from disk\n+                        std::shared_ptr<CBlock> pblockRead = std::make_shared<CBlock>();\n+                        if (!ReadBlockFromDisk(*pblockRead, (*mi).second, consensusParams))\n+                            assert(!\"cannot load block from disk\");\n+                        pblock = pblockRead;\n+                    }\n                     if (inv.type == MSG_BLOCK)\n-                        connman.PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, block));\n+                        connman.PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));\n                     else if (inv.type == MSG_WITNESS_BLOCK)\n-                        connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::BLOCK, block));\n+                        connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n                     else if (inv.type == MSG_FILTERED_BLOCK)\n                     {\n                         bool sendMerkleBlock = false;\n@@ -1093,7 +1106,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                             LOCK(pfrom->cs_filter);\n                             if (pfrom->pfilter) {\n                                 sendMerkleBlock = true;\n-                                merkleBlock = CMerkleBlock(block, *pfrom->pfilter);\n+                                merkleBlock = CMerkleBlock(*pblock, *pfrom->pfilter);\n                             }\n                         }\n                         if (sendMerkleBlock) {\n@@ -1106,7 +1119,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                             // however we MUST always provide at least what the remote peer needs\n                             typedef std::pair<unsigned int, uint256> PairType;\n                             BOOST_FOREACH(PairType& pair, merkleBlock.vMatchedTxn)\n-                                connman.PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *block.vtx[pair.first]));\n+                                connman.PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n                         }\n                         // else\n                             // no response\n@@ -1120,10 +1133,15 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         bool fPeerWantsWitness = State(pfrom->GetId())->fWantsCmpctWitness;\n                         int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n                         if (CanDirectFetch(consensusParams) && mi->second->nHeight >= chainActive.Height() - MAX_CMPCTBLOCK_DEPTH) {\n-                            CBlockHeaderAndShortTxIDs cmpctblock(block, fPeerWantsWitness);\n-                            connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n-                        } else\n-                            connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, block));\n+                            if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == mi->second->GetBlockHash()) {\n+                                connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n+                            } else {\n+                                CBlockHeaderAndShortTxIDs cmpctblock(*pblock, fPeerWantsWitness);\n+                                connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n+                            }\n+                        } else {\n+                            connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n+                        }\n                     }\n \n                     // Trigger the peer node to send a getblocks request for the next batch of inventory\n@@ -3024,7 +3042,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                     {\n                         LOCK(cs_most_recent_block);\n                         if (most_recent_block_hash == pBestIndex->GetBlockHash()) {\n-                            if (state.fWantsCmpctWitness)\n+                            if (state.fWantsCmpctWitness || !fWitnessesPresentInMostRecentCompactBlock)\n                                 connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *most_recent_compact_block));\n                             else {\n                                 CBlockHeaderAndShortTxIDs cmpctblock(*most_recent_block, state.fWantsCmpctWitness);"
      },
      {
        "sha": "52256ca5c4854430501926606da161b5501a93b2",
        "filename": "src/qt/forms/sendcoinsdialog.ui",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/qt/forms/sendcoinsdialog.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/qt/forms/sendcoinsdialog.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/sendcoinsdialog.ui?ref=85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "patch": "@@ -1235,7 +1235,7 @@\n         <bool>false</bool>\n        </property>\n        <property name=\"default\">\n-        <bool>true</bool>\n+        <bool>false</bool>\n        </property>\n       </widget>\n      </item>"
      },
      {
        "sha": "fff072fd4c8cff26b9024cd28d6244d98f0ad719",
        "filename": "src/qt/peertablemodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/qt/peertablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/qt/peertablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/peertablemodel.cpp?ref=85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "patch": "@@ -166,7 +166,7 @@ QVariant PeerTableModel::data(const QModelIndex &index, int role) const\n         switch(index.column())\n         {\n         case NetNodeId:\n-            return rec->nodeStats.nodeid;\n+            return (qint64)rec->nodeStats.nodeid;\n         case Address:\n             return QString::fromStdString(rec->nodeStats.addrName);\n         case Subversion:"
      },
      {
        "sha": "bb8aa23de84200954b6815465584e46f7079b562",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "patch": "@@ -1118,7 +1118,7 @@ void RPCConsole::disconnectSelectedNode()\n     for(int i = 0; i < nodes.count(); i++)\n     {\n         // Get currently selected peer address\n-        NodeId id = nodes.at(i).data().toInt();\n+        NodeId id = nodes.at(i).data().toLongLong();\n         // Find the node, disconnect it and clear the selected node\n         if(g_connman->DisconnectNode(id))\n             clearSelectedNode();\n@@ -1135,7 +1135,7 @@ void RPCConsole::banSelectedNode(int bantime)\n     for(int i = 0; i < nodes.count(); i++)\n     {\n         // Get currently selected peer address\n-        NodeId id = nodes.at(i).data().toInt();\n+        NodeId id = nodes.at(i).data().toLongLong();\n \n \t// Get currently selected peer address\n \tint detailNodeRow = clientModel->getPeerTableModel()->getRowByNodeId(id);"
      },
      {
        "sha": "1f3c4e52adc0cc675c260fec80f45abfffa86aaf",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "patch": "@@ -113,6 +113,8 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"getmempoolancestors\", 1, \"verbose\" },\n     { \"getmempooldescendants\", 1, \"verbose\" },\n     { \"bumpfee\", 1, \"options\" },\n+    { \"logging\", 0, \"include\" },\n+    { \"logging\", 1, \"exclude\" },\n     // Echo with conversion (For testing only)\n     { \"echojson\", 0, \"arg0\" },\n     { \"echojson\", 1, \"arg1\" },"
      },
      {
        "sha": "7b8aa572d713bc78a70778c89ed2c169cb575897",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 70,
        "deletions": 1,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "patch": "@@ -7,6 +7,7 @@\n #include \"clientversion.h\"\n #include \"init.h\"\n #include \"validation.h\"\n+#include \"httpserver.h\"\n #include \"net.h\"\n #include \"netbase.h\"\n #include \"rpc/blockchain.h\"\n@@ -555,6 +556,73 @@ UniValue getmemoryinfo(const JSONRPCRequest& request)\n     }\n }\n \n+uint32_t getCategoryMask(UniValue cats) {\n+    cats = cats.get_array();\n+    uint32_t mask = 0;\n+    for (unsigned int i = 0; i < cats.size(); ++i) {\n+        uint32_t flag = 0;\n+        std::string cat = cats[i].get_str();\n+        if (!GetLogCategory(&flag, &cat)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"unknown logging category \" + cat);\n+        }\n+        mask |= flag;\n+    }\n+    return mask;\n+}\n+\n+UniValue logging(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() > 2) {\n+        throw std::runtime_error(\n+            \"logging [include,...] <exclude>\\n\"\n+            \"Gets and sets the logging configuration.\\n\"\n+            \"When called without an argument, returns the list of categories that are currently being debug logged.\\n\"\n+            \"When called with arguments, adds or removes categories from debug logging.\\n\"\n+            \"The valid logging categories are: \" + ListLogCategories() + \"\\n\"\n+            \"libevent logging is configured on startup and cannot be modified by this RPC during runtime.\"\n+            \"Arguments:\\n\"\n+            \"1. \\\"include\\\" (array of strings) add debug logging for these categories.\\n\"\n+            \"2. \\\"exclude\\\" (array of strings) remove debug logging for these categories.\\n\"\n+            \"\\nResult: <categories>  (string): a list of the logging categories that are active.\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"logging\", \"\\\"[\\\\\\\"all\\\\\\\"]\\\" \\\"[\\\\\\\"http\\\\\\\"]\\\"\")\n+            + HelpExampleRpc(\"logging\", \"[\\\"all\\\"], \\\"[libevent]\\\"\")\n+        );\n+    }\n+\n+    uint32_t originalLogCategories = logCategories;\n+    if (request.params.size() > 0 && request.params[0].isArray()) {\n+        logCategories |= getCategoryMask(request.params[0]);\n+    }\n+\n+    if (request.params.size() > 1 && request.params[1].isArray()) {\n+        logCategories &= ~getCategoryMask(request.params[1]);\n+    }\n+\n+    // Update libevent logging if BCLog::LIBEVENT has changed.\n+    // If the library version doesn't allow it, UpdateHTTPServerLogging() returns false,\n+    // in which case we should clear the BCLog::LIBEVENT flag.\n+    // Throw an error if the user has explicitly asked to change only the libevent\n+    // flag and it failed.\n+    uint32_t changedLogCategories = originalLogCategories ^ logCategories;\n+    if (changedLogCategories & BCLog::LIBEVENT) {\n+        if (!UpdateHTTPServerLogging(logCategories & BCLog::LIBEVENT)) {\n+            logCategories &= ~BCLog::LIBEVENT;\n+            if (changedLogCategories == BCLog::LIBEVENT) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"libevent logging cannot be updated when using libevent before v2.1.1.\");\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    std::vector<CLogCategoryActive> vLogCatActive = ListActiveLogCategories();\n+    for (const auto& logCatActive : vLogCatActive) {\n+        result.pushKV(logCatActive.category, logCatActive.active);\n+    }\n+\n+    return result;\n+}\n+\n UniValue echo(const JSONRPCRequest& request)\n {\n     if (request.fHelp)\n@@ -581,7 +649,8 @@ static const CRPCCommand commands[] =\n     /* Not shown in help */\n     { \"hidden\",             \"setmocktime\",            &setmocktime,            true,  {\"timestamp\"}},\n     { \"hidden\",             \"echo\",                   &echo,                   true,  {\"arg0\",\"arg1\",\"arg2\",\"arg3\",\"arg4\",\"arg5\",\"arg6\",\"arg7\",\"arg8\",\"arg9\"}},\n-    { \"hidden\",             \"echojson\",               &echo,                  true,  {\"arg0\",\"arg1\",\"arg2\",\"arg3\",\"arg4\",\"arg5\",\"arg6\",\"arg7\",\"arg8\",\"arg9\"}},\n+    { \"hidden\",             \"echojson\",               &echo,                   true,  {\"arg0\",\"arg1\",\"arg2\",\"arg3\",\"arg4\",\"arg5\",\"arg6\",\"arg7\",\"arg8\",\"arg9\"}},\n+    { \"hidden\",             \"logging\",                &logging,                true,  {\"include\", \"exclude\"}},\n };\n \n void RegisterMiscRPCCommands(CRPCTable &t)"
      },
      {
        "sha": "7bb8d9941b56dbdba54a57861250639bc1cc7fe3",
        "filename": "src/script/sigcache.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 22,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/script/sigcache.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/script/sigcache.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.cpp?ref=85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "patch": "@@ -15,28 +15,6 @@\n #include <boost/thread.hpp>\n \n namespace {\n-\n-/**\n- * We're hashing a nonce into the entries themselves, so we don't need extra\n- * blinding in the set hash computation.\n- *\n- * This may exhibit platform endian dependent behavior but because these are\n- * nonced hashes (random) and this state is only ever used locally it is safe.\n- * All that matters is local consistency.\n- */\n-class SignatureCacheHasher\n-{\n-public:\n-    template <uint8_t hash_select>\n-    uint32_t operator()(const uint256& key) const\n-    {\n-        static_assert(hash_select <8, \"SignatureCacheHasher only has 8 hashes available.\");\n-        uint32_t u;\n-        std::memcpy(&u, key.begin()+4*hash_select, 4);\n-        return u;\n-    }\n-};\n-\n /**\n  * Valid signature cache, to avoid doing expensive ECDSA signature checking\n  * twice for every transaction (once when accepted into memory pool, and"
      },
      {
        "sha": "55cec4cc8d730edaf87b9a3557e186c78f561cb1",
        "filename": "src/script/sigcache.h",
        "status": "modified",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/script/sigcache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/script/sigcache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.h?ref=85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "patch": "@@ -19,6 +19,27 @@ static const int64_t MAX_MAX_SIG_CACHE_SIZE = 16384;\n \n class CPubKey;\n \n+/**\n+ * We're hashing a nonce into the entries themselves, so we don't need extra\n+ * blinding in the set hash computation.\n+ *\n+ * This may exhibit platform endian dependent behavior but because these are\n+ * nonced hashes (random) and this state is only ever used locally it is safe.\n+ * All that matters is local consistency.\n+ */\n+class SignatureCacheHasher\n+{\n+public:\n+    template <uint8_t hash_select>\n+    uint32_t operator()(const uint256& key) const\n+    {\n+        static_assert(hash_select <8, \"SignatureCacheHasher only has 8 hashes available.\");\n+        uint32_t u;\n+        std::memcpy(&u, key.begin()+4*hash_select, 4);\n+        return u;\n+    }\n+};\n+\n class CachingTransactionSignatureChecker : public TransactionSignatureChecker\n {\n private:"
      },
      {
        "sha": "8cae4e66e8a67b80006118de936f6c807b0bb25d",
        "filename": "src/test/cuckoocache_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 19,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/test/cuckoocache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/test/cuckoocache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/cuckoocache_tests.cpp?ref=85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "patch": "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n #include <boost/test/unit_test.hpp>\n #include \"cuckoocache.h\"\n+#include \"script/sigcache.h\"\n #include \"test/test_bitcoin.h\"\n #include \"random.h\"\n #include <thread>\n@@ -36,20 +37,6 @@ void insecure_GetRandHash(uint256& t)\n         *(ptr++) = insecure_rand.rand32();\n }\n \n-/** Definition copied from /src/script/sigcache.cpp\n- */\n-class uint256Hasher\n-{\n-public:\n-    template <uint8_t hash_select>\n-    uint32_t operator()(const uint256& key) const\n-    {\n-        static_assert(hash_select <8, \"SignatureCacheHasher only has 8 hashes available.\");\n-        uint32_t u;\n-        std::memcpy(&u, key.begin() + 4 * hash_select, 4);\n-        return u;\n-    }\n-};\n \n \n /* Test that no values not inserted into the cache are read out of it.\n@@ -59,7 +46,7 @@ class uint256Hasher\n BOOST_AUTO_TEST_CASE(test_cuckoocache_no_fakes)\n {\n     insecure_rand = FastRandomContext(true);\n-    CuckooCache::cache<uint256, uint256Hasher> cc{};\n+    CuckooCache::cache<uint256, SignatureCacheHasher> cc{};\n     size_t megabytes = 4;\n     cc.setup_bytes(megabytes << 20);\n     uint256 v;\n@@ -138,7 +125,7 @@ BOOST_AUTO_TEST_CASE(cuckoocache_hit_rate_ok)\n     double HitRateThresh = 0.98;\n     size_t megabytes = 4;\n     for (double load = 0.1; load < 2; load *= 2) {\n-        double hits = test_cache<CuckooCache::cache<uint256, uint256Hasher>>(megabytes, load);\n+        double hits = test_cache<CuckooCache::cache<uint256, SignatureCacheHasher>>(megabytes, load);\n         BOOST_CHECK(normalize_hit_rate(hits, load) > HitRateThresh);\n     }\n }\n@@ -206,7 +193,7 @@ void test_cache_erase(size_t megabytes)\n BOOST_AUTO_TEST_CASE(cuckoocache_erase_ok)\n {\n     size_t megabytes = 4;\n-    test_cache_erase<CuckooCache::cache<uint256, uint256Hasher>>(megabytes);\n+    test_cache_erase<CuckooCache::cache<uint256, SignatureCacheHasher>>(megabytes);\n }\n \n template <typename Cache>\n@@ -293,7 +280,7 @@ void test_cache_erase_parallel(size_t megabytes)\n BOOST_AUTO_TEST_CASE(cuckoocache_erase_parallel_ok)\n {\n     size_t megabytes = 4;\n-    test_cache_erase_parallel<CuckooCache::cache<uint256, uint256Hasher>>(megabytes);\n+    test_cache_erase_parallel<CuckooCache::cache<uint256, SignatureCacheHasher>>(megabytes);\n }\n \n \n@@ -389,7 +376,7 @@ void test_cache_generations()\n }\n BOOST_AUTO_TEST_CASE(cuckoocache_generations)\n {\n-    test_cache_generations<CuckooCache::cache<uint256, uint256Hasher>>();\n+    test_cache_generations<CuckooCache::cache<uint256, SignatureCacheHasher>>();\n }\n \n BOOST_AUTO_TEST_SUITE_END();"
      },
      {
        "sha": "0dc203cba5fc7a8839d00f8bca8afd183d17b36a",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 1,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "patch": "@@ -118,7 +118,7 @@ bool fLogIPs = DEFAULT_LOGIPS;\n std::atomic<bool> fReopenDebugLog(false);\n CTranslationInterface translationInterface;\n \n-/** Log categories bitfield. Leveldb/libevent need special handling if their flags are changed at runtime. */\n+/** Log categories bitfield. */\n std::atomic<uint32_t> logCategories(0);\n \n /** Init OpenSSL library multithreading support */\n@@ -295,6 +295,21 @@ std::string ListLogCategories()\n     return ret;\n }\n \n+std::vector<CLogCategoryActive> ListActiveLogCategories()\n+{\n+    std::vector<CLogCategoryActive> ret;\n+    for (unsigned int i = 0; i < ARRAYLEN(LogCategories); i++) {\n+        // Omit the special cases.\n+        if (LogCategories[i].flag != BCLog::NONE && LogCategories[i].flag != BCLog::ALL) {\n+            CLogCategoryActive catActive;\n+            catActive.category = LogCategories[i].category;\n+            catActive.active = LogAcceptCategory(LogCategories[i].flag);\n+            ret.push_back(catActive);\n+        }\n+    }\n+    return ret;\n+}\n+\n /**\n  * fStartedNewLine is a state variable held by the calling context that will\n  * suppress printing of the timestamp when multiple calls are made that don't"
      },
      {
        "sha": "ed28070a3f3d64ef08a556844acc04f12bb390d6",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 10,
        "deletions": 1,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "patch": "@@ -69,6 +69,12 @@ inline std::string _(const char* psz)\n void SetupEnvironment();\n bool SetupNetworking();\n \n+struct CLogCategoryActive\n+{\n+    std::string category;\n+    bool active;\n+};\n+\n namespace BCLog {\n     enum LogFlags : uint32_t {\n         NONE        = 0,\n@@ -102,9 +108,12 @@ static inline bool LogAcceptCategory(uint32_t category)\n     return (logCategories.load(std::memory_order_relaxed) & category) != 0;\n }\n \n-/** Returns a string with the supported log categories */\n+/** Returns a string with the log categories. */\n std::string ListLogCategories();\n \n+/** Returns a vector of the active log categories. */\n+std::vector<CLogCategoryActive> ListActiveLogCategories();\n+\n /** Return true if str parses as a log category and set the flags in f */\n bool GetLogCategory(uint32_t *f, const std::string *str);\n "
      },
      {
        "sha": "6b030935f37b9ad72c203b8bb02ce0a8f728f9f4",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "patch": "@@ -23,14 +23,14 @@\n int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *pWallet)\n {\n     CMutableTransaction txNew(tx);\n-    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    std::vector<CInputCoin> vCoins;\n     // Look up the inputs.  We should have already checked that this transaction\n     // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n     // wallet, with a valid index into the vout array.\n     for (auto& input : tx.vin) {\n         const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n         assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n-        vCoins.emplace_back(&(mi->second), input.prevout.n);\n+        vCoins.emplace_back(CInputCoin(&(mi->second), input.prevout.n));\n     }\n     if (!pWallet->DummySignTx(txNew, vCoins)) {\n         // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)"
      },
      {
        "sha": "03353619213c4eb9e0e7f1fcfeb2094812781dcd",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "patch": "@@ -29,7 +29,7 @@ extern UniValue importmulti(const JSONRPCRequest& request);\n \n std::vector<std::unique_ptr<CWalletTx>> wtxn;\n \n-typedef std::set<std::pair<const CWalletTx*,unsigned int> > CoinSet;\n+typedef std::set<CInputCoin> CoinSet;\n \n BOOST_FIXTURE_TEST_SUITE(wallet_tests, WalletTestingSetup)\n "
      },
      {
        "sha": "c9ca8f653d81a9de6d29bf3601d9b0561aa0d046",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 47,
        "deletions": 50,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "patch": "@@ -65,10 +65,10 @@ const uint256 CMerkleTx::ABANDON_HASH(uint256S(\"00000000000000000000000000000000\n \n struct CompareValueOnly\n {\n-    bool operator()(const std::pair<CAmount, std::pair<const CWalletTx*, unsigned int> >& t1,\n-                    const std::pair<CAmount, std::pair<const CWalletTx*, unsigned int> >& t2) const\n+    bool operator()(const CInputCoin& t1,\n+                    const CInputCoin& t2) const\n     {\n-        return t1.first < t2.first;\n+        return t1.txout.nValue < t2.txout.nValue;\n     }\n };\n \n@@ -957,9 +957,9 @@ bool CWallet::LoadToWallet(const CWalletTx& wtxIn)\n /**\n  * Add a transaction to the wallet, or update it.  pIndex and posInBlock should\n  * be set when the transaction was known to be included in a block.  When\n- * posInBlock = SYNC_TRANSACTION_NOT_IN_BLOCK (-1) , then wallet state is not\n- * updated in AddToWallet, but notifications happen and cached balances are\n- * marked dirty.\n+ * pIndex == NULL, then wallet state is not updated in AddToWallet, but\n+ * notifications happen and cached balances are marked dirty.\n+ *\n  * If fUpdate is true, existing transactions will be updated.\n  * TODO: One exception to this is that the abandoned state is cleared under the\n  * assumption that any further notification of a transaction that was considered\n@@ -973,7 +973,7 @@ bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, const CBlockI\n     {\n         AssertLockHeld(cs_wallet);\n \n-        if (posInBlock != -1) {\n+        if (pIndex != NULL) {\n             BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n                 std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range = mapTxSpends.equal_range(txin.prevout);\n                 while (range.first != range.second) {\n@@ -993,7 +993,7 @@ bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, const CBlockI\n             CWalletTx wtx(this, ptx);\n \n             // Get merkle branch if transaction was found in a block\n-            if (posInBlock != -1)\n+            if (pIndex != NULL)\n                 wtx.SetMerkleBranch(pIndex, posInBlock);\n \n             return AddToWallet(wtx, false);\n@@ -1118,10 +1118,10 @@ void CWallet::MarkConflicted(const uint256& hashBlock, const uint256& hashTx)\n     }\n }\n \n-void CWallet::SyncTransaction(const CTransactionRef& ptx, const CBlockIndex *pindexBlockConnected, int posInBlock) {\n+void CWallet::SyncTransaction(const CTransactionRef& ptx, const CBlockIndex *pindex, int posInBlock) {\n     const CTransaction& tx = *ptx;\n \n-    if (!AddToWalletIfInvolvingMe(ptx, pindexBlockConnected, posInBlock, true))\n+    if (!AddToWalletIfInvolvingMe(ptx, pindex, posInBlock, true))\n         return; // Not one of ours\n \n     // If a transaction changes 'conflicted' state, that changes the balance\n@@ -1136,7 +1136,7 @@ void CWallet::SyncTransaction(const CTransactionRef& ptx, const CBlockIndex *pin\n \n void CWallet::TransactionAddedToMempool(const CTransactionRef& ptx) {\n     LOCK2(cs_main, cs_wallet);\n-    SyncTransaction(ptx, NULL, -1);\n+    SyncTransaction(ptx);\n }\n \n void CWallet::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex *pindex, const std::vector<CTransactionRef>& vtxConflicted) {\n@@ -1150,7 +1150,7 @@ void CWallet::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const\n     // the notification that the conflicted transaction was evicted.\n \n     for (const CTransactionRef& ptx : vtxConflicted) {\n-        SyncTransaction(ptx, NULL, -1);\n+        SyncTransaction(ptx);\n     }\n     for (size_t i = 0; i < pblock->vtx.size(); i++) {\n         SyncTransaction(pblock->vtx[i], pindex, i);\n@@ -1161,7 +1161,7 @@ void CWallet::BlockDisconnected(const std::shared_ptr<const CBlock>& pblock) {\n     LOCK2(cs_main, cs_wallet);\n \n     for (const CTransactionRef& ptx : pblock->vtx) {\n-        SyncTransaction(ptx, NULL, -1);\n+        SyncTransaction(ptx);\n     }\n }\n \n@@ -2061,7 +2061,7 @@ void CWallet::AvailableCoins(std::vector<COutput>& vCoins, bool fOnlySafe, const\n     }\n }\n \n-static void ApproximateBestSubset(const std::vector<std::pair<CAmount, std::pair<const CWalletTx*,unsigned int> > >& vValue, const CAmount& nTotalLower, const CAmount& nTargetValue,\n+static void ApproximateBestSubset(const std::vector<CInputCoin>& vValue, const CAmount& nTotalLower, const CAmount& nTargetValue,\n                                   std::vector<char>& vfBest, CAmount& nBest, int iterations = 1000)\n {\n     std::vector<char> vfIncluded;\n@@ -2088,7 +2088,7 @@ static void ApproximateBestSubset(const std::vector<std::pair<CAmount, std::pair\n                 //the selection random.\n                 if (nPass == 0 ? insecure_rand.rand32()&1 : !vfIncluded[i])\n                 {\n-                    nTotal += vValue[i].first;\n+                    nTotal += vValue[i].txout.nValue;\n                     vfIncluded[i] = true;\n                     if (nTotal >= nTargetValue)\n                     {\n@@ -2098,7 +2098,7 @@ static void ApproximateBestSubset(const std::vector<std::pair<CAmount, std::pair\n                             nBest = nTotal;\n                             vfBest = vfIncluded;\n                         }\n-                        nTotal -= vValue[i].first;\n+                        nTotal -= vValue[i].txout.nValue;\n                         vfIncluded[i] = false;\n                     }\n                 }\n@@ -2108,16 +2108,14 @@ static void ApproximateBestSubset(const std::vector<std::pair<CAmount, std::pair\n }\n \n bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const int nConfMine, const int nConfTheirs, const uint64_t nMaxAncestors, std::vector<COutput> vCoins,\n-                                 std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet) const\n+                                 std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet) const\n {\n     setCoinsRet.clear();\n     nValueRet = 0;\n \n     // List of values less than target\n-    std::pair<CAmount, std::pair<const CWalletTx*,unsigned int> > coinLowestLarger;\n-    coinLowestLarger.first = std::numeric_limits<CAmount>::max();\n-    coinLowestLarger.second.first = NULL;\n-    std::vector<std::pair<CAmount, std::pair<const CWalletTx*,unsigned int> > > vValue;\n+    boost::optional<CInputCoin> coinLowestLarger;\n+    std::vector<CInputCoin> vValue;\n     CAmount nTotalLower = 0;\n \n     random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n@@ -2136,22 +2134,21 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const int nConfMin\n             continue;\n \n         int i = output.i;\n-        CAmount n = pcoin->tx->vout[i].nValue;\n \n-        std::pair<CAmount,std::pair<const CWalletTx*,unsigned int> > coin = std::make_pair(n,std::make_pair(pcoin, i));\n+        CInputCoin coin = CInputCoin(pcoin, i);\n \n-        if (n == nTargetValue)\n+        if (coin.txout.nValue == nTargetValue)\n         {\n-            setCoinsRet.insert(coin.second);\n-            nValueRet += coin.first;\n+            setCoinsRet.insert(coin);\n+            nValueRet += coin.txout.nValue;\n             return true;\n         }\n-        else if (n < nTargetValue + MIN_CHANGE)\n+        else if (coin.txout.nValue < nTargetValue + MIN_CHANGE)\n         {\n             vValue.push_back(coin);\n-            nTotalLower += n;\n+            nTotalLower += coin.txout.nValue;\n         }\n-        else if (n < coinLowestLarger.first)\n+        else if (!coinLowestLarger || coin.txout.nValue < coinLowestLarger->txout.nValue)\n         {\n             coinLowestLarger = coin;\n         }\n@@ -2161,18 +2158,18 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const int nConfMin\n     {\n         for (unsigned int i = 0; i < vValue.size(); ++i)\n         {\n-            setCoinsRet.insert(vValue[i].second);\n-            nValueRet += vValue[i].first;\n+            setCoinsRet.insert(vValue[i]);\n+            nValueRet += vValue[i].txout.nValue;\n         }\n         return true;\n     }\n \n     if (nTotalLower < nTargetValue)\n     {\n-        if (coinLowestLarger.second.first == NULL)\n+        if (!coinLowestLarger)\n             return false;\n-        setCoinsRet.insert(coinLowestLarger.second);\n-        nValueRet += coinLowestLarger.first;\n+        setCoinsRet.insert(coinLowestLarger.get());\n+        nValueRet += coinLowestLarger->txout.nValue;\n         return true;\n     }\n \n@@ -2188,25 +2185,25 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const int nConfMin\n \n     // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n     //                                   or the next bigger coin is closer), return the bigger coin\n-    if (coinLowestLarger.second.first &&\n-        ((nBest != nTargetValue && nBest < nTargetValue + MIN_CHANGE) || coinLowestLarger.first <= nBest))\n+    if (coinLowestLarger &&\n+        ((nBest != nTargetValue && nBest < nTargetValue + MIN_CHANGE) || coinLowestLarger->txout.nValue <= nBest))\n     {\n-        setCoinsRet.insert(coinLowestLarger.second);\n-        nValueRet += coinLowestLarger.first;\n+        setCoinsRet.insert(coinLowestLarger.get());\n+        nValueRet += coinLowestLarger->txout.nValue;\n     }\n     else {\n         for (unsigned int i = 0; i < vValue.size(); i++)\n             if (vfBest[i])\n             {\n-                setCoinsRet.insert(vValue[i].second);\n-                nValueRet += vValue[i].first;\n+                setCoinsRet.insert(vValue[i]);\n+                nValueRet += vValue[i].txout.nValue;\n             }\n \n         if (LogAcceptCategory(BCLog::SELECTCOINS)) {\n             LogPrint(BCLog::SELECTCOINS, \"SelectCoins() best subset: \");\n             for (unsigned int i = 0; i < vValue.size(); i++) {\n                 if (vfBest[i]) {\n-                    LogPrint(BCLog::SELECTCOINS, \"%s \", FormatMoney(vValue[i].first));\n+                    LogPrint(BCLog::SELECTCOINS, \"%s \", FormatMoney(vValue[i].txout.nValue));\n                 }\n             }\n             LogPrint(BCLog::SELECTCOINS, \"total %s\\n\", FormatMoney(nBest));\n@@ -2216,7 +2213,7 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const int nConfMin\n     return true;\n }\n \n-bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet, const CCoinControl* coinControl) const\n+bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl* coinControl) const\n {\n     std::vector<COutput> vCoins(vAvailableCoins);\n \n@@ -2228,13 +2225,13 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n             if (!out.fSpendable)\n                  continue;\n             nValueRet += out.tx->tx->vout[out.i].nValue;\n-            setCoinsRet.insert(std::make_pair(out.tx, out.i));\n+            setCoinsRet.insert(CInputCoin(out.tx, out.i));\n         }\n         return (nValueRet >= nTargetValue);\n     }\n \n     // calculate value from preset inputs and store them\n-    std::set<std::pair<const CWalletTx*, uint32_t> > setPresetCoins;\n+    std::set<CInputCoin> setPresetCoins;\n     CAmount nValueFromPresetInputs = 0;\n \n     std::vector<COutPoint> vPresetInputs;\n@@ -2250,15 +2247,15 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n             if (pcoin->tx->vout.size() <= outpoint.n)\n                 return false;\n             nValueFromPresetInputs += pcoin->tx->vout[outpoint.n].nValue;\n-            setPresetCoins.insert(std::make_pair(pcoin, outpoint.n));\n+            setPresetCoins.insert(CInputCoin(pcoin, outpoint.n));\n         } else\n             return false; // TODO: Allow non-wallet inputs\n     }\n \n     // remove preset inputs from vCoins\n     for (std::vector<COutput>::iterator it = vCoins.begin(); it != vCoins.end() && coinControl && coinControl->HasSelected();)\n     {\n-        if (setPresetCoins.count(std::make_pair(it->tx, it->i)))\n+        if (setPresetCoins.count(CInputCoin(it->tx, it->i)))\n             it = vCoins.erase(it);\n         else\n             ++it;\n@@ -2424,7 +2421,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n     assert(txNew.nLockTime < LOCKTIME_THRESHOLD);\n \n     {\n-        std::set<std::pair<const CWalletTx*,unsigned int> > setCoins;\n+        std::set<CInputCoin> setCoins;\n         LOCK2(cs_main, cs_wallet);\n         {\n             std::vector<COutput> vAvailableCoins;\n@@ -2583,7 +2580,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                 // behavior.\"\n                 bool rbf = coinControl ? coinControl->signalRbf : fWalletRbf;\n                 for (const auto& coin : setCoins)\n-                    txNew.vin.push_back(CTxIn(coin.first->GetHash(),coin.second,CScript(),\n+                    txNew.vin.push_back(CTxIn(coin.outpoint,CScript(),\n                                               std::numeric_limits<unsigned int>::max() - (rbf ? 2 : 1)));\n \n                 // Fill in dummy signatures for fee calculation.\n@@ -2666,10 +2663,10 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n             int nIn = 0;\n             for (const auto& coin : setCoins)\n             {\n-                const CScript& scriptPubKey = coin.first->tx->vout[coin.second].scriptPubKey;\n+                const CScript& scriptPubKey = coin.txout.scriptPubKey;\n                 SignatureData sigdata;\n \n-                if (!ProduceSignature(TransactionSignatureCreator(this, &txNewConst, nIn, coin.first->tx->vout[coin.second].nValue, SIGHASH_ALL), scriptPubKey, sigdata))\n+                if (!ProduceSignature(TransactionSignatureCreator(this, &txNewConst, nIn, coin.txout.nValue, SIGHASH_ALL), scriptPubKey, sigdata))\n                 {\n                     strFailReason = _(\"Signing transaction failed\");\n                     return false;"
      },
      {
        "sha": "cc1a6b7183c0c72eb736131422f5ac37e32e878d",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 33,
        "deletions": 5,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b7acb316d53dc8403efb545cdd73d25cf9e280/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "patch": "@@ -473,7 +473,34 @@ class CWalletTx : public CMerkleTx\n };\n \n \n+class CInputCoin {\n+public:\n+    CInputCoin(const CWalletTx* walletTx, unsigned int i)\n+    {\n+        if (!walletTx)\n+            throw std::invalid_argument(\"walletTx should not be null\");\n+        if (i >= walletTx->tx->vout.size())\n+            throw std::out_of_range(\"The output index is out of range\");\n+\n+        outpoint = COutPoint(walletTx->GetHash(), i);\n+        txout = walletTx->tx->vout[i];\n+    }\n+\n+    COutPoint outpoint;\n+    CTxOut txout;\n \n+    bool operator<(const CInputCoin& rhs) const {\n+        return outpoint < rhs.outpoint;\n+    }\n+\n+    bool operator!=(const CInputCoin& rhs) const {\n+        return outpoint != rhs.outpoint;\n+    }\n+\n+    bool operator==(const CInputCoin& rhs) const {\n+        return outpoint == rhs.outpoint;\n+    }\n+};\n \n class COutput\n {\n@@ -630,7 +657,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n      * all coins from coinControl are selected; Never select unconfirmed coins\n      * if they are not ours\n      */\n-    bool SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet, const CCoinControl *coinControl = NULL) const;\n+    bool SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl *coinControl = NULL) const;\n \n     CWalletDB *pwalletdbEncryption;\n \n@@ -659,8 +686,9 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n \n     void SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator>);\n \n-    /* Used by TransactionAddedToMemorypool/BlockConnected/Disconnected */\n-    void SyncTransaction(const CTransactionRef& tx, const CBlockIndex *pindexBlockConnected, int posInBlock);\n+    /* Used by TransactionAddedToMemorypool/BlockConnected/Disconnected.\n+     * Should be called with pindexBlock and posInBlock if this is for a transaction that is included in a block. */\n+    void SyncTransaction(const CTransactionRef& tx, const CBlockIndex *pindex = NULL, int posInBlock = 0);\n \n     /* the HD chain data model (external chain counters) */\n     CHDChain hdChain;\n@@ -781,7 +809,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n      * completion the coin set and corresponding actual target value is\n      * assembled\n      */\n-    bool SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int nConfTheirs, uint64_t nMaxAncestors, std::vector<COutput> vCoins, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet) const;\n+    bool SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int nConfTheirs, uint64_t nMaxAncestors, std::vector<COutput> vCoins, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet) const;\n \n     bool IsSpent(const uint256& hash, unsigned int n) const;\n \n@@ -1130,7 +1158,7 @@ bool CWallet::DummySignTx(CMutableTransaction &txNew, const ContainerType &coins\n     int nIn = 0;\n     for (const auto& coin : coins)\n     {\n-        const CScript& scriptPubKey = coin.first->tx->vout[coin.second].scriptPubKey;\n+        const CScript& scriptPubKey = coin.txout.scriptPubKey;\n         SignatureData sigdata;\n \n         if (!ProduceSignature(DummySignatureCreator(this), scriptPubKey, sigdata))"
      },
      {
        "sha": "bb12328ec18510a6a00291f4c6e4a384a0e059e7",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b7acb316d53dc8403efb545cdd73d25cf9e280/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b7acb316d53dc8403efb545cdd73d25cf9e280/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "patch": "@@ -293,7 +293,7 @@ def run_tests(test_list, src_dir, build_dir, exeext, jobs=1, enable_coverage=Fal\n         logging.debug(\"Cleaning up coverage data\")\n         coverage.cleanup()\n \n-    all_passed = all(map(lambda test_result: test_result.status == \"Passed\", test_results))\n+    all_passed = all(map(lambda test_result: test_result.was_successful, test_results))\n \n     sys.exit(not all_passed)\n \n@@ -305,7 +305,7 @@ def print_results(test_results, max_len_name, runtime):\n     time_sum = 0\n \n     for test_result in test_results:\n-        all_passed = all_passed and test_result.status != \"Failed\"\n+        all_passed = all_passed and test_result.was_successful\n         time_sum += test_result.time\n         test_result.padding = max_len_name\n         results += str(test_result)\n@@ -393,6 +393,10 @@ def __repr__(self):\n \n         return color[1] + \"%s | %s%s | %s s\\n\" % (self.name.ljust(self.padding), glyph, self.status.ljust(7), self.time) + color[0]\n \n+    @property\n+    def was_successful(self):\n+        return self.status != \"Failed\"\n+\n \n def check_script_list(src_dir):\n     \"\"\"Check scripts directory."
      }
    ]
  },
  {
    "sha": "642024db30c006628c7b5b4320efc56e1573fddb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NDIwMjRkYjMwYzAwNjYyOGM3YjViNDMyMGVmYzU2ZTE1NzNmZGRi",
    "commit": {
      "author": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@wirelessprv-10-195-127-163.near.illinois.edu",
        "date": "2017-04-13T21:29:47Z"
      },
      "committer": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@wirelessprv-10-195-127-163.near.illinois.edu",
        "date": "2017-04-13T21:29:47Z"
      },
      "message": "was calling the wrong variable to send D_INV messages",
      "tree": {
        "sha": "9a58928f1985d349f975e2c962e7428c4ded6cf5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9a58928f1985d349f975e2c962e7428c4ded6cf5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/642024db30c006628c7b5b4320efc56e1573fddb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/642024db30c006628c7b5b4320efc56e1573fddb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/642024db30c006628c7b5b4320efc56e1573fddb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/642024db30c006628c7b5b4320efc56e1573fddb/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/85b7acb316d53dc8403efb545cdd73d25cf9e280",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/85b7acb316d53dc8403efb545cdd73d25cf9e280"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 6,
      "deletions": 5
    },
    "files": [
      {
        "sha": "b78ade24bf64b7eab3353280f3339f433613fc22",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/642024db30c006628c7b5b4320efc56e1573fddb/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/642024db30c006628c7b5b4320efc56e1573fddb/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=642024db30c006628c7b5b4320efc56e1573fddb",
        "patch": "@@ -3141,15 +3141,16 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                     pto->setInventoryTxToSend.erase(it);\n                     // Add the item to the queue to be sent\n                     dandVInv.push_back(CInv(MSG_TX, hash));\n-                    if (vInv.size() == MAX_INV_SZ) {\n-                        connman.PushMessage(pto, msgMaker.Make(NetMsgType::D_INV, vInv));\n-                        vInv.clear();\n+                    if (dandVInv.size() == MAX_INV_SZ) {\n+                        connman.PushMessage(pto, msgMaker.Make(NetMsgType::D_INV, dandVInv));\n+                        dandVInv.clear();\n                     }\n                     pto->filterInventoryKnown.insert(hash);\n                 }\n             }\n-            if (!vInv.empty()) {\n-                connman.PushMessage(pto, msgMaker.Make(NetMsgType::D_INV, vInv));\n+            LogPrintf(\"About to send %d Dandelion messages.\\n\", dandVInv.size());\n+            if (!dandVInv.empty()) {\n+                connman.PushMessage(pto, msgMaker.Make(NetMsgType::D_INV, dandVInv));\n             }\n \n             /*-------------------------------------------------------------------------------*/"
      }
    ]
  },
  {
    "sha": "65da4356985997c9d14c31ff7689945d408de24f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NWRhNDM1Njk4NTk5N2M5ZDE0YzMxZmY3Njg5OTQ1ZDQwOGRlMjRm",
    "commit": {
      "author": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@wirelessprv-10-195-127-163.near.illinois.edu",
        "date": "2017-04-13T21:54:09Z"
      },
      "committer": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@wirelessprv-10-195-127-163.near.illinois.edu",
        "date": "2017-04-13T21:54:09Z"
      },
      "message": "reduced the amount of log output",
      "tree": {
        "sha": "04cd08d6e4b8eb413de9bc9b86ae7b3b7ffdf1f8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/04cd08d6e4b8eb413de9bc9b86ae7b3b7ffdf1f8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/65da4356985997c9d14c31ff7689945d408de24f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/65da4356985997c9d14c31ff7689945d408de24f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/65da4356985997c9d14c31ff7689945d408de24f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/65da4356985997c9d14c31ff7689945d408de24f/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "642024db30c006628c7b5b4320efc56e1573fddb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/642024db30c006628c7b5b4320efc56e1573fddb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/642024db30c006628c7b5b4320efc56e1573fddb"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "6e643351055b23f31cd1c9e9341dd9c0d3636784",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/65da4356985997c9d14c31ff7689945d408de24f/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/65da4356985997c9d14c31ff7689945d408de24f/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=65da4356985997c9d14c31ff7689945d408de24f",
        "patch": "@@ -3148,8 +3148,8 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                     pto->filterInventoryKnown.insert(hash);\n                 }\n             }\n-            LogPrintf(\"About to send %d Dandelion messages.\\n\", dandVInv.size());\n             if (!dandVInv.empty()) {\n+                LogPrintf(\"About to send %d Dandelion messages.\\n\", dandVInv.size());\n                 connman.PushMessage(pto, msgMaker.Make(NetMsgType::D_INV, dandVInv));\n             }\n "
      }
    ]
  },
  {
    "sha": "764be7390a74728c125f4db441ef2504bbb822d1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NjRiZTczOTBhNzQ3MjhjMTI1ZjRkYjQ0MWVmMjUwNGJiYjgyMmQx",
    "commit": {
      "author": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@Giulias.local",
        "date": "2017-04-14T02:10:32Z"
      },
      "committer": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@Giulias.local",
        "date": "2017-04-14T02:10:32Z"
      },
      "message": "fixed the version number",
      "tree": {
        "sha": "088b0bade5927e7ddd906af49956a3361c72dac9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/088b0bade5927e7ddd906af49956a3361c72dac9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/764be7390a74728c125f4db441ef2504bbb822d1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/764be7390a74728c125f4db441ef2504bbb822d1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/764be7390a74728c125f4db441ef2504bbb822d1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/764be7390a74728c125f4db441ef2504bbb822d1/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "65da4356985997c9d14c31ff7689945d408de24f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/65da4356985997c9d14c31ff7689945d408de24f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/65da4356985997c9d14c31ff7689945d408de24f"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 4,
      "deletions": 2
    },
    "files": [
      {
        "sha": "f460595bc1094915d4416a16fdefa72f9ad2cc69",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/764be7390a74728c125f4db441ef2504bbb822d1/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/764be7390a74728c125f4db441ef2504bbb822d1/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=764be7390a74728c125f4db441ef2504bbb822d1",
        "patch": "@@ -17,8 +17,6 @@ static const int64_t ORPHAN_TX_EXPIRE_TIME = 20 * 60;\n static const int64_t ORPHAN_TX_EXPIRE_INTERVAL = 5 * 60;\n /** Default number of orphan+recently-replaced txn to keep around for block reconstruction */\n static const unsigned int DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN = 100;\n-/** Version number that supports Dandelion */\n-static const int DANDELION_VERSION_NUM = 10;        // TODO: Figure out the version number!\n \n /** Register with a network node to receive its signals */\n void RegisterNodeSignals(CNodeSignals& nodeSignals);"
      },
      {
        "sha": "37990507e084d16cc2ff014f8ca114b50670f9fa",
        "filename": "src/version.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/764be7390a74728c125f4db441ef2504bbb822d1/src/version.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/764be7390a74728c125f4db441ef2504bbb822d1/src/version.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/version.h?ref=764be7390a74728c125f4db441ef2504bbb822d1",
        "patch": "@@ -46,4 +46,8 @@ static const int SHORT_IDS_BLOCKS_VERSION = 70014;\n //! not banning for invalid compact blocks starts with this version\n static const int INVALID_CB_NO_BAN_VERSION = 70015;\n \n+// Minimum version number that supports Dandelion\n+static const int DANDELION_VERSION_NUM = 70016; \n+\n+\n #endif // BITCOIN_VERSION_H"
      }
    ]
  },
  {
    "sha": "8551db62924e420013283e5253d2199d0e0e323d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NTUxZGI2MjkyNGU0MjAwMTMyODNlNTI1M2QyMTk5ZDBlMGUzMjNk",
    "commit": {
      "author": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@vpnpool-130-126-152-111.near.illinois.edu",
        "date": "2017-04-18T20:06:57Z"
      },
      "committer": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@vpnpool-130-126-152-111.near.illinois.edu",
        "date": "2017-04-18T20:06:57Z"
      },
      "message": "initializes new transactions in wallet.cpp as being in the Dandelion stem",
      "tree": {
        "sha": "781c5505e8a82cadf27e0c50f9df59e9d4cd9e1d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/781c5505e8a82cadf27e0c50f9df59e9d4cd9e1d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8551db62924e420013283e5253d2199d0e0e323d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8551db62924e420013283e5253d2199d0e0e323d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8551db62924e420013283e5253d2199d0e0e323d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8551db62924e420013283e5253d2199d0e0e323d/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "764be7390a74728c125f4db441ef2504bbb822d1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/764be7390a74728c125f4db441ef2504bbb822d1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/764be7390a74728c125f4db441ef2504bbb822d1"
      }
    ],
    "stats": {
      "total": 53,
      "additions": 43,
      "deletions": 10
    },
    "files": [
      {
        "sha": "7644488bc5fc2ec2d51e0ef92f1b4f8b7d7594de",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 8,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8551db62924e420013283e5253d2199d0e0e323d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8551db62924e420013283e5253d2199d0e0e323d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=8551db62924e420013283e5253d2199d0e0e323d",
        "patch": "@@ -40,6 +40,8 @@\n \n std::atomic<int64_t> nTimeBestReceived(0); // Used only to inform the wallet of when we last received a block\n \n+std::set<uint256> Dandelion::stemSet;\n+\n struct IteratorComparator\n {\n     template<typename I>\n@@ -124,9 +126,6 @@ namespace {\n     MapRelay mapRelay;\n     /** Expiration-time ordered list of (expire time, relay map entry) pairs, protected by cs_main). */\n     std::deque<std::pair<int64_t, MapRelay::iterator>> vRelayExpiration;\n-\n-    /** Set of hashes for transactions that are in the Dandelion stem. */\n-    std::set<uint256> stemSet;\n     \n } // anon namespace\n \n@@ -937,7 +936,7 @@ static void RelayTransaction(const CTransaction& tx, CConnman& connman)\n     bool stemRelay = false;\n     CNode* stemNode;\n     // 1) Check if inv is in the stem\n-    if (stemSet.find(inv.hash) != stemSet.end()) {\n+    if (Dandelion::stemSet.find(inv.hash) != Dandelion::stemSet.end()) {\n         /* Pick a dandelion relay at random from outgoing edges\n            (in principle, this should be the same for all messages\n            but for our prototype, we will choose relays independently\n@@ -955,7 +954,7 @@ static void RelayTransaction(const CTransaction& tx, CConnman& connman)\n \n         // If there are no connected Dandelion nodes, go to fluff phase\n         if (outgoing.empty()) {\n-            stemSet.erase(inv.hash);\n+            Dandelion::stemSet.erase(inv.hash);\n         } else {\n             /* Choose a random element from outgoing (this isn't exactly pseudorandom, \n             depending on the size of RAND_MAX, but it's close enough) */\n@@ -1614,7 +1613,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     if (rand_prob < DANDELION_PROB)\n                     {\n                         // Add the hash to the set of ongoing stem transactions\n-                        stemSet.insert(inv.hash);\n+                        Dandelion::stemSet.insert(inv.hash);\n                     }\n                 }\n             }\n@@ -3134,9 +3133,9 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             for (std::set<uint256>::iterator it = pto->setInventoryTxToSend.begin(); it != pto->setInventoryTxToSend.end(); it++) {\n                 uint256 hash = *it;\n                 // Check if the hash is in the dandelion stem\n-                if (stemSet.find(hash) != stemSet.end()) {\n+                if (Dandelion::stemSet.find(hash) != Dandelion::stemSet.end()) {\n                     // remove the hash from the dandelion stem set\n-                    stemSet.erase(hash);\n+                    Dandelion::stemSet.erase(hash);\n                     // remove the iterator from pto's to-send list\n                     pto->setInventoryTxToSend.erase(it);\n                     // Add the item to the queue to be sent"
      },
      {
        "sha": "dd6be99d332ee718d3d5257c3c4b6cb6bfb47067",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8551db62924e420013283e5253d2199d0e0e323d/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8551db62924e420013283e5253d2199d0e0e323d/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=8551db62924e420013283e5253d2199d0e0e323d",
        "patch": "@@ -18,6 +18,11 @@ static const int64_t ORPHAN_TX_EXPIRE_INTERVAL = 5 * 60;\n /** Default number of orphan+recently-replaced txn to keep around for block reconstruction */\n static const unsigned int DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN = 100;\n \n+namespace Dandelion{\n+    /** Set of hashes for transactions that are in the Dandelion stem. */\n+    extern std::set<uint256> stemSet;\n+}\n+\n /** Register with a network node to receive its signals */\n void RegisterNodeSignals(CNodeSignals& nodeSignals);\n /** Unregister a network node */"
      },
      {
        "sha": "07ab44ff2d426361f4980c22296435995f08092d",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 2,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8551db62924e420013283e5253d2199d0e0e323d/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8551db62924e420013283e5253d2199d0e0e323d/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=8551db62924e420013283e5253d2199d0e0e323d",
        "patch": "@@ -16,6 +16,7 @@\n #include \"keystore.h\"\n #include \"validation.h\"\n #include \"net.h\"\n+#include \"net_processing.h\"\n #include \"policy/policy.h\"\n #include \"policy/rbf.h\"\n #include \"primitives/block.h\"\n@@ -1607,9 +1608,37 @@ bool CWalletTx::RelayWalletTransaction(CConnman* connman)\n             LogPrintf(\"Relaying wtx %s\\n\", GetHash().ToString());\n             if (connman) {\n                 CInv inv(MSG_TX, GetHash());\n-                connman->ForEachNode([&inv](CNode* pnode)\n+                /* Only push to the Dandelion node's queue */\n+                CNode* stemNode;\n+                bool stemRelay = false;\n+                // Find the outgoing connections with dandelion enabled\n+                std::vector<CNode*> outgoing;\n+                connman->ForEachNode( [&outgoing](CNode* pnode)\n                 {\n-                    pnode->PushInventory(inv);\n+                    if (!pnode->fInbound && pnode->GetSendVersion() >= DANDELION_VERSION_NUM) {\n+                        outgoing.push_back(pnode);\n+                    }\n+                });\n+\n+                // If there are no connected Dandelion nodes, go to fluff phase\n+                if (!outgoing.empty()) {\n+                    // Add the transaction to the stemSet\n+                    Dandelion::stemSet.insert(inv.hash);\n+                    stemRelay = true;\n+                    /* Choose a random element from outgoing (this isn't exactly pseudorandom, \n+                    depending on the size of RAND_MAX, but it's close enough) */\n+                    std::vector<CNode*>::iterator randIt = outgoing.begin();\n+                    std::advance(randIt, std::rand() % outgoing.size());\n+                    stemNode = *randIt;\n+                }\n+\n+                // connman->ForEachNode([&inv](CNode* pnode)\n+                connman->ForEachNode([&inv,&stemRelay,&stemNode](CNode* pnode)\n+                {\n+                    // Then add inv to the node's queue, if it's supposed to receive the message\n+                    if (!stemRelay || stemNode == pnode) {\n+                        pnode->PushInventory(inv);\n+                    }\n                 });\n                 return true;\n             }"
      }
    ]
  },
  {
    "sha": "1915325bf7033206c96c91b0030d5086383a50be",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxOTE1MzI1YmY3MDMzMjA2Yzk2YzkxYjAwMzBkNTA4NjM4M2E1MGJl",
    "commit": {
      "author": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@vpnpool-130-126-152-111.near.illinois.edu",
        "date": "2017-04-18T20:07:10Z"
      },
      "committer": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@vpnpool-130-126-152-111.near.illinois.edu",
        "date": "2017-04-18T20:07:10Z"
      },
      "message": "Merge branch 'master' of https://github.com/bitcoin/bitcoin",
      "tree": {
        "sha": "bb42c50ecd51970fd73e265d23e989249aa8be37",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bb42c50ecd51970fd73e265d23e989249aa8be37"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1915325bf7033206c96c91b0030d5086383a50be",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1915325bf7033206c96c91b0030d5086383a50be",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1915325bf7033206c96c91b0030d5086383a50be",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1915325bf7033206c96c91b0030d5086383a50be/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "8551db62924e420013283e5253d2199d0e0e323d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8551db62924e420013283e5253d2199d0e0e323d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8551db62924e420013283e5253d2199d0e0e323d"
      },
      {
        "sha": "9111df9673beb6d6616d491a5478f09b5f14d040",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9111df9673beb6d6616d491a5478f09b5f14d040",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9111df9673beb6d6616d491a5478f09b5f14d040"
      }
    ],
    "stats": {
      "total": 238,
      "additions": 178,
      "deletions": 60
    },
    "files": [
      {
        "sha": "f5d63517b134d0bc206957fb8b4b7a714851c01d",
        "filename": "CONTRIBUTING.md",
        "status": "modified",
        "additions": 33,
        "deletions": 2,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1915325bf7033206c96c91b0030d5086383a50be/CONTRIBUTING.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1915325bf7033206c96c91b0030d5086383a50be/CONTRIBUTING.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/CONTRIBUTING.md?ref=1915325bf7033206c96c91b0030d5086383a50be",
        "patch": "@@ -37,8 +37,8 @@ fixes or code moves with actual code changes.\n \n Commit messages should be verbose by default consisting of a short subject line\n (50 chars max), a blank line and detailed explanatory text as separate\n-paragraph(s); unless the title alone is self-explanatory (like \"Corrected typo\n-in init.cpp\") then a single title line is sufficient. Commit messages should be\n+paragraph(s), unless the title alone is self-explanatory (like \"Corrected typo\n+in init.cpp\") in which case a single title line is sufficient. Commit messages should be\n helpful to people reading your code in the future, so explain the reasoning for\n your decisions. Further explanation [here](http://chris.beams.io/posts/git-commit/).\n \n@@ -225,6 +225,37 @@ discussed extensively on the mailing list and IRC, be accompanied by a widely\n discussed BIP and have a generally widely perceived technical consensus of being\n a worthwhile change based on the judgement of the maintainers.\n \n+### Finding Reviewers\n+\n+As most reviewers are themselves developers with their own projects, the review\n+process can be quite lengthy, and some amount of patience is required. If you find\n+that you've been waiting for a pull request to be given attention for several\n+months, there may be a number of reasons for this, some of which you can do something\n+about:\n+\n+  - It may be because of a feature freeze due to an upcoming release. During this time,\n+    only bug fixes are taken into consideration. If your pull request is a new feature,\n+    it will not be prioritized until the release is over. Wait for release.\n+  - It may be because the changes you are suggesting do not appeal to people. Rather than\n+    nits and critique, which require effort and means they care enough to spend time on your\n+    contribution, thundering silence is a good sign of widespread (mild) dislike of a given change\n+    (because people don't assume *others* won't actually like the proposal). Don't take\n+    that personally, though! Instead, take another critical look at what you are suggesting\n+    and see if it: changes too much, is too broad, doesn't adhere to the\n+    [developer notes](doc/developer-notes.md), is dangerous or insecure, is messily written, etc.\n+    Identify and address any of the issues you find. Then ask e.g. on IRC if someone could give\n+    their opinion on the concept itself.\n+  - It may be because your code is too complex for all but a few people. And those people\n+    may not have realized your pull request even exists. A great way to find people who\n+    are qualified and care about the code you are touching is the\n+    [Git Blame feature](https://help.github.com/articles/tracing-changes-in-a-file/). Simply\n+    find the person touching the code you are touching before you and see if you can find\n+    them and give them a nudge. Don't be incessant about the nudging though.\n+  - Finally, if all else fails, ask on IRC or elsewhere for someone to give your pull request\n+    a look. If you think you've been waiting an unreasonably long amount of time (month+) for\n+    no particular reason (few lines changed, etc), this is totally fine. Try to return the favor\n+    when someone else is asking for feedback on their code, and universe balances out.\n+\n \n Release Policy\n --------------"
      },
      {
        "sha": "27389d6e0c04de839935d7284d6452c7146f6e68",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1915325bf7033206c96c91b0030d5086383a50be/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1915325bf7033206c96c91b0030d5086383a50be/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=1915325bf7033206c96c91b0030d5086383a50be",
        "patch": "@@ -1585,6 +1585,9 @@ void CConnman::ThreadDNSAddressSeed()\n     LogPrintf(\"Loading addresses from DNS seeds (could take a while)\\n\");\n \n     BOOST_FOREACH(const CDNSSeedData &seed, vSeeds) {\n+        if (interruptNet) {\n+            return;\n+        }\n         if (HaveNameProxy()) {\n             AddOneShot(seed.host);\n         } else {\n@@ -1602,6 +1605,9 @@ void CConnman::ThreadDNSAddressSeed()\n                     found++;\n                 }\n             }\n+            if (interruptNet) {\n+                return;\n+            }\n             // TODO: The seed name resolve may fail, yielding an IP of [::], which results in\n             // addrman assigning the same source to results from different seeds.\n             // This should switch to a hard-coded stable dummy IP for each seed name, so that the"
      },
      {
        "sha": "e4a909c1f663f1a0fe173023592aea76e7deaef0",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1915325bf7033206c96c91b0030d5086383a50be/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1915325bf7033206c96c91b0030d5086383a50be/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=1915325bf7033206c96c91b0030d5086383a50be",
        "patch": "@@ -236,10 +236,10 @@ UniValue disconnectnode(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n         throw std::runtime_error(\n-            \"disconnectnode \\\"node\\\" \\n\"\n+            \"disconnectnode \\\"address\\\" \\n\"\n             \"\\nImmediately disconnects from the specified node.\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"node\\\"     (string, required) The node (see getpeerinfo for nodes)\\n\"\n+            \"1. \\\"address\\\"     (string, required) The IP address/port of the node\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"disconnectnode\", \"\\\"192.168.0.6:8333\\\"\")\n             + HelpExampleRpc(\"disconnectnode\", \"\\\"192.168.0.6:8333\\\"\")\n@@ -607,7 +607,7 @@ static const CRPCCommand commands[] =\n     { \"network\",            \"ping\",                   &ping,                   true,  {} },\n     { \"network\",            \"getpeerinfo\",            &getpeerinfo,            true,  {} },\n     { \"network\",            \"addnode\",                &addnode,                true,  {\"node\",\"command\"} },\n-    { \"network\",            \"disconnectnode\",         &disconnectnode,         true,  {\"node\"} },\n+    { \"network\",            \"disconnectnode\",         &disconnectnode,         true,  {\"address\"} },\n     { \"network\",            \"getaddednodeinfo\",       &getaddednodeinfo,       true,  {\"node\"} },\n     { \"network\",            \"getnettotals\",           &getnettotals,           true,  {} },\n     { \"network\",            \"getnetworkinfo\",         &getnetworkinfo,         true,  {} },"
      },
      {
        "sha": "e82ddf2c5a7bbacf018ba8b13b907b58fdff93be",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 9,
        "deletions": 2,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1915325bf7033206c96c91b0030d5086383a50be/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1915325bf7033206c96c91b0030d5086383a50be/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=1915325bf7033206c96c91b0030d5086383a50be",
        "patch": "@@ -336,11 +336,18 @@ I ReadVarInt(Stream& is)\n     I n = 0;\n     while(true) {\n         unsigned char chData = ser_readdata8(is);\n+        if (n > (std::numeric_limits<I>::max() >> 7)) {\n+           throw std::ios_base::failure(\"ReadVarInt(): size too large\");\n+        }\n         n = (n << 7) | (chData & 0x7F);\n-        if (chData & 0x80)\n+        if (chData & 0x80) {\n+            if (n == std::numeric_limits<I>::max()) {\n+                throw std::ios_base::failure(\"ReadVarInt(): size too large\");\n+            }\n             n++;\n-        else\n+        } else {\n             return n;\n+        }\n     }\n }\n "
      },
      {
        "sha": "6ae87c683e15db09ba306da268a7c95206177dac",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 9,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1915325bf7033206c96c91b0030d5086383a50be/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1915325bf7033206c96c91b0030d5086383a50be/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=1915325bf7033206c96c91b0030d5086383a50be",
        "patch": "@@ -1524,7 +1524,11 @@ bool ApplyTxInUndo(const CTxInUndo& undo, CCoinsViewCache& view, const COutPoint\n     return fClean;\n }\n \n-bool DisconnectBlock(const CBlock& block, CValidationState& state, const CBlockIndex* pindex, CCoinsViewCache& view, bool* pfClean)\n+/** Undo the effects of this block (with given index) on the UTXO set represented by coins.\n+ *  In case pfClean is provided, operation will try to be tolerant about errors, and *pfClean\n+ *  will be true if no problems were found. Otherwise, the return value will be false in case\n+ *  of problems. Note that in any case, coins may be modified. */\n+static bool DisconnectBlock(const CBlock& block, CValidationState& state, const CBlockIndex* pindex, CCoinsViewCache& view, bool* pfClean = NULL)\n {\n     assert(pindex->GetBlockHash() == view.GetBestBlock());\n \n@@ -1677,8 +1681,11 @@ static int64_t nTimeIndex = 0;\n static int64_t nTimeCallbacks = 0;\n static int64_t nTimeTotal = 0;\n \n-bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex,\n-                  CCoinsViewCache& view, const CChainParams& chainparams, bool fJustCheck)\n+/** Apply the effects of this block (with given index) on the UTXO set represented by coins.\n+ *  Validity checks that depend on the UTXO set are also done; ConnectBlock()\n+ *  can fail if those validity checks fail (among other reasons). */\n+static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex,\n+                  CCoinsViewCache& view, const CChainParams& chainparams, bool fJustCheck = false)\n {\n     AssertLockHeld(cs_main);\n     assert(pindex);\n@@ -1917,12 +1924,6 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n     int64_t nTime5 = GetTimeMicros(); nTimeIndex += nTime5 - nTime4;\n     LogPrint(BCLog::BENCH, \"    - Index writing: %.2fms [%.2fs]\\n\", 0.001 * (nTime5 - nTime4), nTimeIndex * 0.000001);\n \n-    // Watch for changes to the previous coinbase transaction.\n-    static uint256 hashPrevBestCoinBase;\n-    GetMainSignals().UpdatedTransaction(hashPrevBestCoinBase);\n-    hashPrevBestCoinBase = block.vtx[0]->GetHash();\n-\n-\n     int64_t nTime6 = GetTimeMicros(); nTimeCallbacks += nTime6 - nTime5;\n     LogPrint(BCLog::BENCH, \"    - Callbacks: %.2fms [%.2fs]\\n\", 0.001 * (nTime6 - nTime5), nTimeCallbacks * 0.000001);\n "
      },
      {
        "sha": "51ea18722cf64e21a65a01726e30f3f2b3a9f07c",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 0,
        "deletions": 12,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1915325bf7033206c96c91b0030d5086383a50be/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1915325bf7033206c96c91b0030d5086383a50be/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=1915325bf7033206c96c91b0030d5086383a50be",
        "patch": "@@ -483,18 +483,6 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev, int64_t nAdjustedTime);\n bool ContextualCheckBlock(const CBlock& block, CValidationState& state, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev);\n \n-/** Apply the effects of this block (with given index) on the UTXO set represented by coins.\n- *  Validity checks that depend on the UTXO set are also done; ConnectBlock()\n- *  can fail if those validity checks fail (among other reasons). */\n-bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& coins,\n-                  const CChainParams& chainparams, bool fJustCheck = false);\n-\n-/** Undo the effects of this block (with given index) on the UTXO set represented by coins.\n- *  In case pfClean is provided, operation will try to be tolerant about errors, and *pfClean\n- *  will be true if no problems were found. Otherwise, the return value will be false in case\n- *  of problems. Note that in any case, coins may be modified. */\n-bool DisconnectBlock(const CBlock& block, CValidationState& state, const CBlockIndex* pindex, CCoinsViewCache& coins, bool* pfClean = NULL);\n-\n /** Check a block is completely valid from start to finish (only works on top of our current best block, with cs_main held) */\n bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckPOW = true, bool fCheckMerkleRoot = true);\n "
      },
      {
        "sha": "46d7c9b3295026331a2c595ea3994a8bbf41706b",
        "filename": "src/validationinterface.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1915325bf7033206c96c91b0030d5086383a50be/src/validationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1915325bf7033206c96c91b0030d5086383a50be/src/validationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.cpp?ref=1915325bf7033206c96c91b0030d5086383a50be",
        "patch": "@@ -17,7 +17,6 @@ void RegisterValidationInterface(CValidationInterface* pwalletIn) {\n     g_signals.TransactionAddedToMempool.connect(boost::bind(&CValidationInterface::TransactionAddedToMempool, pwalletIn, _1));\n     g_signals.BlockConnected.connect(boost::bind(&CValidationInterface::BlockConnected, pwalletIn, _1, _2, _3));\n     g_signals.BlockDisconnected.connect(boost::bind(&CValidationInterface::BlockDisconnected, pwalletIn, _1));\n-    g_signals.UpdatedTransaction.connect(boost::bind(&CValidationInterface::UpdatedTransaction, pwalletIn, _1));\n     g_signals.SetBestChain.connect(boost::bind(&CValidationInterface::SetBestChain, pwalletIn, _1));\n     g_signals.Inventory.connect(boost::bind(&CValidationInterface::Inventory, pwalletIn, _1));\n     g_signals.Broadcast.connect(boost::bind(&CValidationInterface::ResendWalletTransactions, pwalletIn, _1, _2));\n@@ -32,7 +31,6 @@ void UnregisterValidationInterface(CValidationInterface* pwalletIn) {\n     g_signals.Broadcast.disconnect(boost::bind(&CValidationInterface::ResendWalletTransactions, pwalletIn, _1, _2));\n     g_signals.Inventory.disconnect(boost::bind(&CValidationInterface::Inventory, pwalletIn, _1));\n     g_signals.SetBestChain.disconnect(boost::bind(&CValidationInterface::SetBestChain, pwalletIn, _1));\n-    g_signals.UpdatedTransaction.disconnect(boost::bind(&CValidationInterface::UpdatedTransaction, pwalletIn, _1));\n     g_signals.TransactionAddedToMempool.disconnect(boost::bind(&CValidationInterface::TransactionAddedToMempool, pwalletIn, _1));\n     g_signals.BlockConnected.disconnect(boost::bind(&CValidationInterface::BlockConnected, pwalletIn, _1, _2, _3));\n     g_signals.BlockDisconnected.disconnect(boost::bind(&CValidationInterface::BlockDisconnected, pwalletIn, _1));\n@@ -46,7 +44,6 @@ void UnregisterAllValidationInterfaces() {\n     g_signals.Broadcast.disconnect_all_slots();\n     g_signals.Inventory.disconnect_all_slots();\n     g_signals.SetBestChain.disconnect_all_slots();\n-    g_signals.UpdatedTransaction.disconnect_all_slots();\n     g_signals.TransactionAddedToMempool.disconnect_all_slots();\n     g_signals.BlockConnected.disconnect_all_slots();\n     g_signals.BlockDisconnected.disconnect_all_slots();"
      },
      {
        "sha": "460aecf243fa25fa7e3f6f6b7d191d6286ff4b2c",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1915325bf7033206c96c91b0030d5086383a50be/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1915325bf7033206c96c91b0030d5086383a50be/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=1915325bf7033206c96c91b0030d5086383a50be",
        "patch": "@@ -37,7 +37,6 @@ class CValidationInterface {\n     virtual void BlockConnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex *pindex, const std::vector<CTransactionRef> &txnConflicted) {}\n     virtual void BlockDisconnected(const std::shared_ptr<const CBlock> &block) {}\n     virtual void SetBestChain(const CBlockLocator &locator) {}\n-    virtual void UpdatedTransaction(const uint256 &hash) {}\n     virtual void Inventory(const uint256 &hash) {}\n     virtual void ResendWalletTransactions(int64_t nBestBlockTime, CConnman* connman) {}\n     virtual void BlockChecked(const CBlock&, const CValidationState&) {}\n@@ -60,8 +59,6 @@ struct CMainSignals {\n     boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex, const std::vector<CTransactionRef> &)> BlockConnected;\n     /** Notifies listeners of a block being disconnected */\n     boost::signals2::signal<void (const std::shared_ptr<const CBlock> &)> BlockDisconnected;\n-    /** Notifies listeners of an updated transaction without new data (for now: a coinbase potentially becoming visible). */\n-    boost::signals2::signal<void (const uint256 &)> UpdatedTransaction;\n     /** Notifies listeners of a new active block chain. */\n     boost::signals2::signal<void (const CBlockLocator &)> SetBestChain;\n     /** Notifies listeners about an inventory item being seen on the network. */"
      },
      {
        "sha": "82708dab26e032da68d804ae7a1d6f7f9d939db3",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1915325bf7033206c96c91b0030d5086383a50be/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1915325bf7033206c96c91b0030d5086383a50be/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=1915325bf7033206c96c91b0030d5086383a50be",
        "patch": "@@ -95,6 +95,8 @@ UniValue importprivkey(const JSONRPCRequest& request)\n             + HelpExampleCli(\"importprivkey\", \"\\\"mykey\\\"\") +\n             \"\\nImport using a label and without rescan\\n\"\n             + HelpExampleCli(\"importprivkey\", \"\\\"mykey\\\" \\\"testing\\\" false\") +\n+            \"\\nImport using default blank label and without rescan\\n\"\n+            + HelpExampleCli(\"importprivkey\", \"\\\"mykey\\\" \\\"\\\" false\") +\n             \"\\nAs a JSON-RPC call\\n\"\n             + HelpExampleRpc(\"importprivkey\", \"\\\"mykey\\\", \\\"testing\\\", false\")\n         );\n@@ -154,6 +156,31 @@ UniValue importprivkey(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+UniValue abortrescan(const JSONRPCRequest& request)\n+{\n+    CWallet* const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() > 0)\n+        throw std::runtime_error(\n+            \"abortrescan\\n\"\n+            \"\\nStops current wallet rescan triggered e.g. by an importprivkey call.\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nImport a private key\\n\"\n+            + HelpExampleCli(\"importprivkey\", \"\\\"mykey\\\"\") +\n+            \"\\nAbort the running wallet rescan\\n\"\n+            + HelpExampleCli(\"abortrescan\", \"\") +\n+            \"\\nAs a JSON-RPC call\\n\"\n+            + HelpExampleRpc(\"abortrescan\", \"\")\n+        );\n+\n+    if (!pwallet->IsScanning() || pwallet->IsAbortingRescan()) return false;\n+    pwallet->AbortRescan();\n+    return true;\n+}\n+\n void ImportAddress(CWallet*, const CBitcoinAddress& address, const std::string& strLabel);\n void ImportScript(CWallet* const pwallet, const CScript& script, const std::string& strLabel, bool isRedeemScript)\n {"
      },
      {
        "sha": "665d856df529cc9bc156cb1f0ea61555aaa69794",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1915325bf7033206c96c91b0030d5086383a50be/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1915325bf7033206c96c91b0030d5086383a50be/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=1915325bf7033206c96c91b0030d5086383a50be",
        "patch": "@@ -2914,6 +2914,7 @@ UniValue bumpfee(const JSONRPCRequest& request)\n     return result;\n }\n \n+extern UniValue abortrescan(const JSONRPCRequest& request); // in rpcdump.cpp\n extern UniValue dumpprivkey(const JSONRPCRequest& request); // in rpcdump.cpp\n extern UniValue importprivkey(const JSONRPCRequest& request);\n extern UniValue importaddress(const JSONRPCRequest& request);\n@@ -2930,6 +2931,7 @@ static const CRPCCommand commands[] =\n     { \"rawtransactions\",    \"fundrawtransaction\",       &fundrawtransaction,       false,  {\"hexstring\",\"options\"} },\n     { \"hidden\",             \"resendwallettransactions\", &resendwallettransactions, true,   {} },\n     { \"wallet\",             \"abandontransaction\",       &abandontransaction,       false,  {\"txid\"} },\n+    { \"wallet\",             \"abortrescan\",              &abortrescan,              false,  {} },\n     { \"wallet\",             \"addmultisigaddress\",       &addmultisigaddress,       true,   {\"nrequired\",\"keys\",\"account\"} },\n     { \"wallet\",             \"addwitnessaddress\",        &addwitnessaddress,        true,   {\"address\"} },\n     { \"wallet\",             \"backupwallet\",             &backupwallet,             true,   {\"destination\"} },"
      },
      {
        "sha": "7dcecce34adbaabc3868b116e50ae7082dcfe2d7",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 12,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1915325bf7033206c96c91b0030d5086383a50be/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1915325bf7033206c96c91b0030d5086383a50be/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=1915325bf7033206c96c91b0030d5086383a50be",
        "patch": "@@ -1156,6 +1156,33 @@ void CWallet::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const\n     for (size_t i = 0; i < pblock->vtx.size(); i++) {\n         SyncTransaction(pblock->vtx[i], pindex, i);\n     }\n+\n+    // The GUI expects a NotifyTransactionChanged when a coinbase tx\n+    // which is in our wallet moves from in-the-best-block to\n+    // 2-confirmations (as it only displays them at that time).\n+    // We do that here.\n+    if (hashPrevBestCoinbase.IsNull()) {\n+        // Immediately after restart we have no idea what the coinbase\n+        // transaction from the previous block is.\n+        // For correctness we scan over the entire wallet, looking for\n+        // the previous block's coinbase, just in case it is ours, so\n+        // that we can notify the UI that it should now be displayed.\n+        if (pindex->pprev) {\n+            for (const std::pair<uint256, CWalletTx>& p : mapWallet) {\n+                if (p.second.IsCoinBase() && p.second.hashBlock == pindex->pprev->GetBlockHash()) {\n+                    NotifyTransactionChanged(this, p.first, CT_UPDATED);\n+                    break;\n+                }\n+            }\n+        }\n+    } else {\n+        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(hashPrevBestCoinbase);\n+        if (mi != mapWallet.end()) {\n+            NotifyTransactionChanged(this, hashPrevBestCoinbase, CT_UPDATED);\n+        }\n+    }\n+\n+    hashPrevBestCoinbase = pblock->vtx[0]->GetHash();\n }\n \n void CWallet::BlockDisconnected(const std::shared_ptr<const CBlock>& pblock) {\n@@ -1528,6 +1555,8 @@ CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool f\n     CBlockIndex* pindex = pindexStart;\n     {\n         LOCK2(cs_main, cs_wallet);\n+        fAbortRescan = false;\n+        fScanningWallet = true;\n \n         // no need to read and scan block, if block was created before\n         // our wallet birthday (as adjusted for block time variability)\n@@ -1537,7 +1566,7 @@ CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool f\n         ShowProgress(_(\"Rescanning...\"), 0); // show rescan progress in GUI as dialog or on splashscreen, if -rescan on startup\n         double dProgressStart = GuessVerificationProgress(chainParams.TxData(), pindex);\n         double dProgressTip = GuessVerificationProgress(chainParams.TxData(), chainActive.Tip());\n-        while (pindex)\n+        while (pindex && !fAbortRescan)\n         {\n             if (pindex->nHeight % 100 == 0 && dProgressTip - dProgressStart > 0.0)\n                 ShowProgress(_(\"Rescanning...\"), std::max(1, std::min(99, (int)((GuessVerificationProgress(chainParams.TxData(), pindex) - dProgressStart) / (dProgressTip - dProgressStart) * 100))));\n@@ -1559,7 +1588,12 @@ CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool f\n                 LogPrintf(\"Still rescanning. At block %d. Progress=%f\\n\", pindex->nHeight, GuessVerificationProgress(chainParams.TxData(), pindex));\n             }\n         }\n+        if (pindex && fAbortRescan) {\n+            LogPrintf(\"Rescan aborted at block %d. Progress=%f\\n\", pindex->nHeight, GuessVerificationProgress(chainParams.TxData(), pindex));\n+        }\n         ShowProgress(_(\"Rescanning...\"), 100); // hide progress dialog in GUI\n+\n+        fScanningWallet = false;\n     }\n     return ret;\n }\n@@ -3412,17 +3446,6 @@ void CWallet::GetAllReserveKeys(std::set<CKeyID>& setAddress) const\n     }\n }\n \n-void CWallet::UpdatedTransaction(const uint256 &hashTx)\n-{\n-    {\n-        LOCK(cs_wallet);\n-        // Only notify UI if this transaction is in this wallet\n-        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(hashTx);\n-        if (mi != mapWallet.end())\n-            NotifyTransactionChanged(this, hashTx, CT_UPDATED);\n-    }\n-}\n-\n void CWallet::GetScriptForMining(std::shared_ptr<CReserveScript> &script)\n {\n     std::shared_ptr<CReserveKey> rKey = std::make_shared<CReserveKey>(this);"
      },
      {
        "sha": "b3483f8308b47e1dba90eb54c4b5f655e66f3578",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 15,
        "deletions": 2,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1915325bf7033206c96c91b0030d5086383a50be/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1915325bf7033206c96c91b0030d5086383a50be/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=1915325bf7033206c96c91b0030d5086383a50be",
        "patch": "@@ -651,6 +651,8 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n {\n private:\n     static std::atomic<bool> fFlushScheduled;\n+    std::atomic<bool> fAbortRescan;\n+    std::atomic<bool> fScanningWallet;\n \n     /**\n      * Select a set of coins such that nValueRet >= nTargetValue and at least\n@@ -713,6 +715,10 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n      */\n     bool AddWatchOnly(const CScript& dest) override;\n \n+    // Used to NotifyTransactionChanged of the previous block's coinbase when\n+    // the next block comes in\n+    uint256 hashPrevBestCoinbase;\n+\n public:\n     /*\n      * Main wallet lock.\n@@ -775,6 +781,8 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n         nTimeFirstKey = 0;\n         fBroadcastTransactions = false;\n         nRelockTime = 0;\n+        fAbortRescan = false;\n+        fScanningWallet = false;\n     }\n \n     std::map<uint256, CWalletTx> mapWallet;\n@@ -819,6 +827,13 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     void UnlockAllCoins();\n     void ListLockedCoins(std::vector<COutPoint>& vOutpts);\n \n+    /*\n+     * Rescan abort properties\n+     */\n+    void AbortRescan() { fAbortRescan = true; }\n+    bool IsAbortingRescan() { return fAbortRescan; }\n+    bool IsScanning() { return fScanningWallet; }\n+\n     /**\n      * keystore implementation\n      * Generate a new key\n@@ -978,8 +993,6 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n \n     bool DelAddressBook(const CTxDestination& address);\n \n-    void UpdatedTransaction(const uint256 &hashTx) override;\n-\n     void Inventory(const uint256 &hash) override\n     {\n         {"
      },
      {
        "sha": "b40052b898a7c6c9cf627e60c607162dc764c592",
        "filename": "test/README.md",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1915325bf7033206c96c91b0030d5086383a50be/test/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1915325bf7033206c96c91b0030d5086383a50be/test/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/README.md?ref=1915325bf7033206c96c91b0030d5086383a50be",
        "patch": "@@ -25,6 +25,8 @@ The ZMQ functional test requires a python ZMQ library. To install it:\n Running tests locally\n =====================\n \n+Build for your system first. Be sure to enable wallet, utils and daemon when you configure. Tests will not run otherwise.\n+\n Functional tests\n ----------------\n "
      },
      {
        "sha": "3a3fa31ec3f875d752f4a16320202db1191f1cbe",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 36,
        "deletions": 12,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1915325bf7033206c96c91b0030d5086383a50be/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1915325bf7033206c96c91b0030d5086383a50be/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=1915325bf7033206c96c91b0030d5086383a50be",
        "patch": "@@ -27,9 +27,17 @@\n \n # Formatting. Default colors to empty strings.\n BOLD, BLUE, RED, GREY = (\"\", \"\"), (\"\", \"\"), (\"\", \"\"), (\"\", \"\")\n-TICK = \"\u2713 \"\n-CROSS = \"\u2716 \"\n-CIRCLE = \"\u25cb \"\n+try:\n+    # Make sure python thinks it can write unicode to its stdout\n+    \"\\u2713\".encode(\"utf_8\").decode(sys.stdout.encoding)\n+    TICK = \"\u2713 \"\n+    CROSS = \"\u2716 \"\n+    CIRCLE = \"\u25cb \"\n+except UnicodeDecodeError:\n+    TICK = \"P \"\n+    CROSS = \"x \"\n+    CIRCLE = \"o \"\n+\n if os.name == 'posix':\n     # primitive formatting on supported\n     # terminal via ANSI escape sequences:\n@@ -140,7 +148,8 @@\n     'replace-by-fee.py',\n ]\n \n-ALL_SCRIPTS = BASE_SCRIPTS + ZMQ_SCRIPTS + EXTENDED_SCRIPTS\n+# Place EXTENDED_SCRIPTS first since it has the 3 longest running tests\n+ALL_SCRIPTS = EXTENDED_SCRIPTS + BASE_SCRIPTS + ZMQ_SCRIPTS\n \n NON_SCRIPTS = [\n     # These are python files that live in the functional tests directory, but are not test scripts.\n@@ -163,6 +172,7 @@ def main():\n     parser.add_argument('--force', '-f', action='store_true', help='run tests even on platforms where they are disabled by default (e.g. windows).')\n     parser.add_argument('--help', '-h', '-?', action='store_true', help='print help text and exit')\n     parser.add_argument('--jobs', '-j', type=int, default=4, help='how many test scripts to run in parallel. Default=4.')\n+    parser.add_argument('--keepcache', '-k', action='store_true', help='the default behavior is to flush the cache directory on startup. --keepcache retains the cache from the previous testrun.')\n     parser.add_argument('--quiet', '-q', action='store_true', help='only print results summary and failure logs')\n     parser.add_argument('--nozmq', action='store_true', help='do not run the zmq tests')\n     args, unknown_args = parser.parse_known_args()\n@@ -217,10 +227,9 @@ def main():\n         if enable_zmq:\n             test_list += ZMQ_SCRIPTS\n         if args.extended:\n-            test_list += EXTENDED_SCRIPTS\n-            # TODO: BASE_SCRIPTS and EXTENDED_SCRIPTS are sorted by runtime\n-            # (for parallel running efficiency). This combined list will is no\n-            # longer sorted.\n+            # place the EXTENDED_SCRIPTS first since the three longest ones\n+            # are there and the list is shorter\n+            test_list = EXTENDED_SCRIPTS + test_list\n \n     # Remove the test cases that the user has explicitly asked to exclude.\n     if args.exclude:\n@@ -241,9 +250,23 @@ def main():\n \n     check_script_list(config[\"environment\"][\"SRCDIR\"])\n \n+    if not args.keepcache:\n+        shutil.rmtree(\"%s/test/cache\" % config[\"environment\"][\"BUILDDIR\"], ignore_errors=True)\n+\n     run_tests(test_list, config[\"environment\"][\"SRCDIR\"], config[\"environment\"][\"BUILDDIR\"], config[\"environment\"][\"EXEEXT\"], args.jobs, args.coverage, passon_args)\n \n def run_tests(test_list, src_dir, build_dir, exeext, jobs=1, enable_coverage=False, args=[]):\n+    # Warn if bitcoind is already running (unix only)\n+    try:\n+        if subprocess.check_output([\"pidof\", \"bitcoind\"]) is not None:\n+            print(\"%sWARNING!%s There is already a bitcoind process running on this system. Tests may fail unexpectedly due to resource contention!\" % (BOLD[1], BOLD[0]))\n+    except (OSError, subprocess.SubprocessError):\n+        pass\n+\n+    # Warn if there is a cache directory\n+    cache_dir = \"%s/test/cache\" % build_dir\n+    if os.path.isdir(cache_dir):\n+        print(\"%sWARNING!%s There is a cache directory here: %s. If tests fail unexpectedly, try deleting the cache directory.\" % (BOLD[1], BOLD[0], cache_dir))\n \n     #Set env vars\n     if \"BITCOIND\" not in os.environ:\n@@ -252,7 +275,7 @@ def run_tests(test_list, src_dir, build_dir, exeext, jobs=1, enable_coverage=Fal\n     tests_dir = src_dir + '/test/functional/'\n \n     flags = [\"--srcdir={}/src\".format(build_dir)] + args\n-    flags.append(\"--cachedir=%s/test/cache\" % build_dir)\n+    flags.append(\"--cachedir=%s\" % cache_dir)\n \n     if enable_coverage:\n         coverage = RPCCoverage()\n@@ -407,9 +430,10 @@ def check_script_list(src_dir):\n     python_files = set([t for t in os.listdir(script_dir) if t[-3:] == \".py\"])\n     missed_tests = list(python_files - set(map(lambda x: x.split()[0], ALL_SCRIPTS + NON_SCRIPTS)))\n     if len(missed_tests) != 0:\n-        print(\"The following scripts are not being run:\" + str(missed_tests))\n-        print(\"Check the test lists in test_runner.py\")\n-        sys.exit(1)\n+        print(\"%sWARNING!%s The following scripts are not being run: %s. Check the test lists in test_runner.py.\" % (BOLD[1], BOLD[0], str(missed_tests)))\n+        if os.getenv('TRAVIS') == 'true':\n+            # On travis this warning is an error to prevent merging incomplete commits into master\n+            sys.exit(1)\n \n class RPCCoverage(object):\n     \"\"\""
      }
    ]
  },
  {
    "sha": "046ca5815e96713f7d4825ff6a750b579be28669",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNDZjYTU4MTVlOTY3MTNmN2Q0ODI1ZmY2YTc1MGI1NzliZTI4NjY5",
    "commit": {
      "author": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@Giulias.local",
        "date": "2017-04-19T03:07:44Z"
      },
      "committer": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@Giulias.local",
        "date": "2017-04-19T03:07:44Z"
      },
      "message": "fixed issue with items staying in stem with too low probability.",
      "tree": {
        "sha": "a95c8e95a40a29715280ef0016b5ea57ea5f5ef8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a95c8e95a40a29715280ef0016b5ea57ea5f5ef8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/046ca5815e96713f7d4825ff6a750b579be28669",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/046ca5815e96713f7d4825ff6a750b579be28669",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/046ca5815e96713f7d4825ff6a750b579be28669",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/046ca5815e96713f7d4825ff6a750b579be28669/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "1915325bf7033206c96c91b0030d5086383a50be",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1915325bf7033206c96c91b0030d5086383a50be",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1915325bf7033206c96c91b0030d5086383a50be"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 3,
      "deletions": 1
    },
    "files": [
      {
        "sha": "2e928f40068cf12101eae2f169f0d3a5faf0d3df",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/046ca5815e96713f7d4825ff6a750b579be28669/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/046ca5815e96713f7d4825ff6a750b579be28669/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=046ca5815e96713f7d4825ff6a750b579be28669",
        "patch": "@@ -1610,7 +1610,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 if (strCommand == NetMsgType::D_INV)\n                 {\n                     float rand_prob = ((float) rand() / (float) RAND_MAX);\n-                    if (rand_prob < DANDELION_PROB)\n+                    if (rand_prob > DANDELION_PROB)\n                     {\n                         // Add the hash to the set of ongoing stem transactions\n                         Dandelion::stemSet.insert(inv.hash);\n@@ -1633,6 +1633,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             else\n             {\n                 pfrom->AddInventoryKnown(inv);\n+                LogPrintf(\"fAlreadyHave is %d. fImporting is %d. fReindex is %d. IsInitialBlockDownload is %d.\\n\",\n+                    fAlreadyHave, fImporting, fReindex, IsInitialBlockDownload());\n                 if (fBlocksOnly) {\n                     LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol peer=%d\\n\", inv.hash.ToString(), pfrom->id);\n                 } else if (!fAlreadyHave && !fImporting && !fReindex && !IsInitialBlockDownload()) {"
      }
    ]
  },
  {
    "sha": "65a13a6dfb38dae58b6131b373ef52c6356f6983",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NWExM2E2ZGZiMzhkYWU1OGI2MTMxYjM3M2VmNTJjNjM1NmY2OTgz",
    "commit": {
      "author": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@Giulias.local",
        "date": "2017-04-20T04:22:47Z"
      },
      "committer": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@Giulias.local",
        "date": "2017-04-20T04:22:47Z"
      },
      "message": "adds dandelion transactions to mapRelay if needed",
      "tree": {
        "sha": "ab42fdd9fcec05c953cbd0c13888b3183e5a7a16",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ab42fdd9fcec05c953cbd0c13888b3183e5a7a16"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/65a13a6dfb38dae58b6131b373ef52c6356f6983",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/65a13a6dfb38dae58b6131b373ef52c6356f6983",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/65a13a6dfb38dae58b6131b373ef52c6356f6983",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/65a13a6dfb38dae58b6131b373ef52c6356f6983/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "046ca5815e96713f7d4825ff6a750b579be28669",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/046ca5815e96713f7d4825ff6a750b579be28669",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/046ca5815e96713f7d4825ff6a750b579be28669"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 11,
      "deletions": 0
    },
    "files": [
      {
        "sha": "bc6d9c78179a94df00618f45f81d3a94b8a4352a",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/65a13a6dfb38dae58b6131b373ef52c6356f6983/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/65a13a6dfb38dae58b6131b373ef52c6356f6983/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=65a13a6dfb38dae58b6131b373ef52c6356f6983",
        "patch": "@@ -3142,6 +3142,17 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                     pto->setInventoryTxToSend.erase(it);\n                     // Add the item to the queue to be sent\n                     dandVInv.push_back(CInv(MSG_TX, hash));\n+                    // Add the hash to the mapRelay if it's in the mempool\n+                    {\n+                        auto txinfo = mempool.info(hash);\n+                        if (!txinfo.tx) {\n+                            continue;\n+                        }\n+                        auto ret = mapRelay.insert(std::make_pair(hash, std::move(txinfo.tx)));\n+                        if (ret.second) {\n+                            vRelayExpiration.push_back(std::make_pair(nNow + 15 * 60 * 1000000, ret.first));\n+                        }\n+                    }\n                     if (dandVInv.size() == MAX_INV_SZ) {\n                         connman.PushMessage(pto, msgMaker.Make(NetMsgType::D_INV, dandVInv));\n                         dandVInv.clear();"
      }
    ]
  },
  {
    "sha": "3305641aab917ed5082c2c46fead2e9c7c9f96cb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMzA1NjQxYWFiOTE3ZWQ1MDgyYzJjNDZmZWFkMmU5YzdjOWY5NmNi",
    "commit": {
      "author": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@Giulias.local",
        "date": "2017-04-20T04:22:59Z"
      },
      "committer": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@Giulias.local",
        "date": "2017-04-20T04:22:59Z"
      },
      "message": "Merge branch 'master' of https://github.com/bitcoin/bitcoin",
      "tree": {
        "sha": "07a3452e18367333af586d63604faa8d31b236c7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/07a3452e18367333af586d63604faa8d31b236c7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3305641aab917ed5082c2c46fead2e9c7c9f96cb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3305641aab917ed5082c2c46fead2e9c7c9f96cb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3305641aab917ed5082c2c46fead2e9c7c9f96cb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3305641aab917ed5082c2c46fead2e9c7c9f96cb/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "65a13a6dfb38dae58b6131b373ef52c6356f6983",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/65a13a6dfb38dae58b6131b373ef52c6356f6983",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/65a13a6dfb38dae58b6131b373ef52c6356f6983"
      },
      {
        "sha": "c91ca0ace9bd62eea8158b92cfc53d6d219e37b7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c91ca0ace9bd62eea8158b92cfc53d6d219e37b7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c91ca0ace9bd62eea8158b92cfc53d6d219e37b7"
      }
    ],
    "stats": {
      "total": 61,
      "additions": 18,
      "deletions": 43
    },
    "files": [
      {
        "sha": "4bb260aa588ae2c5eeb6b5e723de43455f404aef",
        "filename": "src/qt/transactionrecord.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 8,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3305641aab917ed5082c2c46fead2e9c7c9f96cb/src/qt/transactionrecord.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3305641aab917ed5082c2c46fead2e9c7c9f96cb/src/qt/transactionrecord.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.cpp?ref=3305641aab917ed5082c2c46fead2e9c7c9f96cb",
        "patch": "@@ -18,14 +18,8 @@\n  */\n bool TransactionRecord::showTransaction(const CWalletTx &wtx)\n {\n-    if (wtx.IsCoinBase())\n-    {\n-        // Ensures we show generated coins / mined transactions at depth 1\n-        if (!wtx.IsInMainChain())\n-        {\n-            return false;\n-        }\n-    }\n+    // There are currently no cases where we hide transactions, but\n+    // we may want to use this in the future for things like RBF.\n     return true;\n }\n "
      },
      {
        "sha": "8eeba72a064b2f2b6063de09ad8ab5c6ca235f31",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3305641aab917ed5082c2c46fead2e9c7c9f96cb/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3305641aab917ed5082c2c46fead2e9c7c9f96cb/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=3305641aab917ed5082c2c46fead2e9c7c9f96cb",
        "patch": "@@ -424,6 +424,17 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n         BOOST_CHECK_EQUAL(response.write(), strprintf(\"[{\\\"success\\\":false,\\\"error\\\":{\\\"code\\\":-1,\\\"message\\\":\\\"Failed to rescan before time %d, transactions may be missing.\\\"}},{\\\"success\\\":true}]\", newTip->GetBlockTimeMax()));\n         ::pwalletMain = backup;\n     }\n+\n+    // Verify ScanForWalletTransactions does not return null when the scan is\n+    // elided due to the nTimeFirstKey optimization.\n+    {\n+        CWallet wallet;\n+        {\n+            LOCK(wallet.cs_wallet);\n+            wallet.UpdateTimeFirstKey(newTip->GetBlockTime() + 7200 + 1);\n+        }\n+        BOOST_CHECK_EQUAL(newTip, wallet.ScanForWalletTransactions(newTip));\n+    }\n }\n \n // Check that GetImmatureCredit() returns a newly calculated value instead of"
      },
      {
        "sha": "9501f5c0c443d711fde7e0743e8f07fe9e08add9",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 31,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3305641aab917ed5082c2c46fead2e9c7c9f96cb/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3305641aab917ed5082c2c46fead2e9c7c9f96cb/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=3305641aab917ed5082c2c46fead2e9c7c9f96cb",
        "patch": "@@ -1156,33 +1156,6 @@ void CWallet::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const\n     for (size_t i = 0; i < pblock->vtx.size(); i++) {\n         SyncTransaction(pblock->vtx[i], pindex, i);\n     }\n-\n-    // The GUI expects a NotifyTransactionChanged when a coinbase tx\n-    // which is in our wallet moves from in-the-best-block to\n-    // 2-confirmations (as it only displays them at that time).\n-    // We do that here.\n-    if (hashPrevBestCoinbase.IsNull()) {\n-        // Immediately after restart we have no idea what the coinbase\n-        // transaction from the previous block is.\n-        // For correctness we scan over the entire wallet, looking for\n-        // the previous block's coinbase, just in case it is ours, so\n-        // that we can notify the UI that it should now be displayed.\n-        if (pindex->pprev) {\n-            for (const std::pair<uint256, CWalletTx>& p : mapWallet) {\n-                if (p.second.IsCoinBase() && p.second.hashBlock == pindex->pprev->GetBlockHash()) {\n-                    NotifyTransactionChanged(this, p.first, CT_UPDATED);\n-                    break;\n-                }\n-            }\n-        }\n-    } else {\n-        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(hashPrevBestCoinbase);\n-        if (mi != mapWallet.end()) {\n-            NotifyTransactionChanged(this, hashPrevBestCoinbase, CT_UPDATED);\n-        }\n-    }\n-\n-    hashPrevBestCoinbase = pblock->vtx[0]->GetHash();\n }\n \n void CWallet::BlockDisconnected(const std::shared_ptr<const CBlock>& pblock) {\n@@ -1543,16 +1516,17 @@ void CWalletTx::GetAccountAmounts(const std::string& strAccount, CAmount& nRecei\n  * exist in the wallet will be updated.\n  *\n  * Returns pointer to the first block in the last contiguous range that was\n- * successfully scanned.\n- *\n+ * successfully scanned or elided (elided if pIndexStart points at a block\n+ * before CWallet::nTimeFirstKey). Returns null if there is no such range, or\n+ * the range doesn't include chainActive.Tip().\n  */\n CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n {\n-    CBlockIndex* ret = nullptr;\n     int64_t nNow = GetTime();\n     const CChainParams& chainParams = Params();\n \n     CBlockIndex* pindex = pindexStart;\n+    CBlockIndex* ret = pindexStart;\n     {\n         LOCK2(cs_main, cs_wallet);\n         fAbortRescan = false;\n@@ -3916,7 +3890,7 @@ bool CWallet::InitLoadWallet()\n \n     std::string walletFile = GetArg(\"-wallet\", DEFAULT_WALLET_DAT);\n \n-    if (walletFile.find_first_of(\"/\\\\\") != std::string::npos) {\n+    if (boost::filesystem::path(walletFile).filename() != walletFile) {\n         return InitError(_(\"-wallet parameter must only specify a filename (not a path)\"));\n     } else if (SanitizeString(walletFile, SAFE_CHARS_FILENAME) != walletFile) {\n         return InitError(_(\"Invalid characters in -wallet filename\"));"
      },
      {
        "sha": "06e7e14990068e2fd8adc4051ba27e33877d68a1",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3305641aab917ed5082c2c46fead2e9c7c9f96cb/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3305641aab917ed5082c2c46fead2e9c7c9f96cb/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=3305641aab917ed5082c2c46fead2e9c7c9f96cb",
        "patch": "@@ -715,10 +715,6 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n      */\n     bool AddWatchOnly(const CScript& dest) override;\n \n-    // Used to NotifyTransactionChanged of the previous block's coinbase when\n-    // the next block comes in\n-    uint256 hashPrevBestCoinbase;\n-\n public:\n     /*\n      * Main wallet lock."
      }
    ]
  },
  {
    "sha": "20928b7697aa8ffb3dee9c814c3f02b1dbe7d6b1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMDkyOGI3Njk3YWE4ZmZiM2RlZTljODE0YzNmMDJiMWRiZTdkNmIx",
    "commit": {
      "author": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@Giulias.local",
        "date": "2017-04-20T13:23:31Z"
      },
      "committer": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@Giulias.local",
        "date": "2017-04-20T13:23:31Z"
      },
      "message": "only keep message in the stem if there are outgoing neighbors running dandelion",
      "tree": {
        "sha": "5ad74556cf98da6496c0219670ed57ba436e7480",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5ad74556cf98da6496c0219670ed57ba436e7480"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/20928b7697aa8ffb3dee9c814c3f02b1dbe7d6b1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/20928b7697aa8ffb3dee9c814c3f02b1dbe7d6b1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/20928b7697aa8ffb3dee9c814c3f02b1dbe7d6b1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/20928b7697aa8ffb3dee9c814c3f02b1dbe7d6b1/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "3305641aab917ed5082c2c46fead2e9c7c9f96cb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3305641aab917ed5082c2c46fead2e9c7c9f96cb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3305641aab917ed5082c2c46fead2e9c7c9f96cb"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "c1c6da66f30d1b57f68c975dd1402276c6b4fd60",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20928b7697aa8ffb3dee9c814c3f02b1dbe7d6b1/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20928b7697aa8ffb3dee9c814c3f02b1dbe7d6b1/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=20928b7697aa8ffb3dee9c814c3f02b1dbe7d6b1",
        "patch": "@@ -942,7 +942,6 @@ static void RelayTransaction(const CTransaction& tx, CConnman& connman)\n            but for our prototype, we will choose relays independently\n            across transactions)\n         */ \n-        stemRelay = true;\n         // Track the outgoing connections with dandelion enabled\n         std::vector<CNode*> outgoing;\n         connman.ForEachNode( [&outgoing](CNode* pnode)\n@@ -958,6 +957,7 @@ static void RelayTransaction(const CTransaction& tx, CConnman& connman)\n         } else {\n             /* Choose a random element from outgoing (this isn't exactly pseudorandom, \n             depending on the size of RAND_MAX, but it's close enough) */\n+            stemRelay = true;\n             std::vector<CNode*>::iterator randIt = outgoing.begin();\n             std::advance(randIt, std::rand() % outgoing.size());\n             stemNode = *randIt;"
      }
    ]
  },
  {
    "sha": "00bc8d38d1775526f8de7d361cbf4a728f9e461b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMGJjOGQzOGQxNzc1NTI2ZjhkZTdkMzYxY2JmNGE3MjhmOWU0NjFi",
    "commit": {
      "author": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@Giulias.local",
        "date": "2017-04-20T13:23:40Z"
      },
      "committer": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@Giulias.local",
        "date": "2017-04-20T13:23:40Z"
      },
      "message": "Merge branch 'master' of https://github.com/bitcoin/bitcoin",
      "tree": {
        "sha": "20b881c55d28bd61dc7aaddf2f822bab55a19572",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/20b881c55d28bd61dc7aaddf2f822bab55a19572"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/00bc8d38d1775526f8de7d361cbf4a728f9e461b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00bc8d38d1775526f8de7d361cbf4a728f9e461b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/00bc8d38d1775526f8de7d361cbf4a728f9e461b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00bc8d38d1775526f8de7d361cbf4a728f9e461b/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "20928b7697aa8ffb3dee9c814c3f02b1dbe7d6b1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/20928b7697aa8ffb3dee9c814c3f02b1dbe7d6b1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/20928b7697aa8ffb3dee9c814c3f02b1dbe7d6b1"
      },
      {
        "sha": "987a6c09562e1e1e9d6623b999ae9de268490e4b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/987a6c09562e1e1e9d6623b999ae9de268490e4b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/987a6c09562e1e1e9d6623b999ae9de268490e4b"
      }
    ],
    "stats": {
      "total": 268,
      "additions": 170,
      "deletions": 98
    },
    "files": [
      {
        "sha": "5c26baef9e8ae89758bb109dfb4637d4dd38a75c",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00bc8d38d1775526f8de7d361cbf4a728f9e461b/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00bc8d38d1775526f8de7d361cbf4a728f9e461b/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=00bc8d38d1775526f8de7d361cbf4a728f9e461b",
        "patch": "@@ -478,6 +478,7 @@ void BitcoinGUI::setClientModel(ClientModel *_clientModel)\n         connect(_clientModel, SIGNAL(numConnectionsChanged(int)), this, SLOT(setNumConnections(int)));\n         connect(_clientModel, SIGNAL(networkActiveChanged(bool)), this, SLOT(setNetworkActive(bool)));\n \n+        modalOverlay->setKnownBestHeight(_clientModel->getHeaderTipHeight(), QDateTime::fromTime_t(_clientModel->getHeaderTipTime()));\n         setNumBlocks(_clientModel->getNumBlocks(), _clientModel->getLastBlockDate(), _clientModel->getVerificationProgress(NULL), false);\n         connect(_clientModel, SIGNAL(numBlocksChanged(int,QDateTime,double,bool)), this, SLOT(setNumBlocks(int,QDateTime,double,bool)));\n \n@@ -505,8 +506,6 @@ void BitcoinGUI::setClientModel(ClientModel *_clientModel)\n             // initialize the disable state of the tray icon with the current value in the model.\n             setTrayIconVisible(optionsModel->getHideTrayIcon());\n         }\n-\n-        modalOverlay->setKnownBestHeight(clientModel->getHeaderTipHeight(), QDateTime::fromTime_t(clientModel->getHeaderTipTime()));\n     } else {\n         // Disable possibility to show main window via action\n         toggleHideAction->setEnabled(false);"
      },
      {
        "sha": "20d4687971e88f3a8b353173a7343527b6a301e0",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 8,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00bc8d38d1775526f8de7d361cbf4a728f9e461b/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00bc8d38d1775526f8de7d361cbf4a728f9e461b/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=00bc8d38d1775526f8de7d361cbf4a728f9e461b",
        "patch": "@@ -36,6 +36,8 @@ ClientModel::ClientModel(OptionsModel *_optionsModel, QObject *parent) :\n     banTableModel(0),\n     pollTimer(0)\n {\n+    cachedBestHeaderHeight = -1;\n+    cachedBestHeaderTime = -1;\n     peerTableModel = new PeerTableModel(this);\n     banTableModel = new BanTableModel(this);\n     pollTimer = new QTimer(this);\n@@ -74,18 +76,28 @@ int ClientModel::getNumBlocks() const\n \n int ClientModel::getHeaderTipHeight() const\n {\n-    LOCK(cs_main);\n-    if (!pindexBestHeader)\n-        return 0;\n-    return pindexBestHeader->nHeight;\n+    if (cachedBestHeaderHeight == -1) {\n+        // make sure we initially populate the cache via a cs_main lock\n+        // otherwise we need to wait for a tip update\n+        LOCK(cs_main);\n+        if (pindexBestHeader) {\n+            cachedBestHeaderHeight = pindexBestHeader->nHeight;\n+            cachedBestHeaderTime = pindexBestHeader->GetBlockTime();\n+        }\n+    }\n+    return cachedBestHeaderHeight;\n }\n \n int64_t ClientModel::getHeaderTipTime() const\n {\n-    LOCK(cs_main);\n-    if (!pindexBestHeader)\n-        return 0;\n-    return pindexBestHeader->GetBlockTime();\n+    if (cachedBestHeaderTime == -1) {\n+        LOCK(cs_main);\n+        if (pindexBestHeader) {\n+            cachedBestHeaderHeight = pindexBestHeader->nHeight;\n+            cachedBestHeaderTime = pindexBestHeader->GetBlockTime();\n+        }\n+    }\n+    return cachedBestHeaderTime;\n }\n \n quint64 ClientModel::getTotalBytesRecv() const\n@@ -283,6 +295,11 @@ static void BlockTipChanged(ClientModel *clientmodel, bool initialSync, const CB\n \n     int64_t& nLastUpdateNotification = fHeader ? nLastHeaderTipUpdateNotification : nLastBlockTipUpdateNotification;\n \n+    if (fHeader) {\n+        // cache best headers time and height to reduce future cs_main locks\n+        clientmodel->cachedBestHeaderHeight = pIndex->nHeight;\n+        clientmodel->cachedBestHeaderTime = pIndex->GetBlockTime();\n+    }\n     // if we are in-sync, update the UI regardless of last update time\n     if (!initialSync || now - nLastUpdateNotification > MODEL_UPDATE_DELAY) {\n         //pass a async signal to the UI thread"
      },
      {
        "sha": "4c92e2144e32154b7683a4f3e9a29eeedd425a39",
        "filename": "src/qt/clientmodel.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00bc8d38d1775526f8de7d361cbf4a728f9e461b/src/qt/clientmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00bc8d38d1775526f8de7d361cbf4a728f9e461b/src/qt/clientmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.h?ref=00bc8d38d1775526f8de7d361cbf4a728f9e461b",
        "patch": "@@ -8,6 +8,8 @@\n #include <QObject>\n #include <QDateTime>\n \n+#include <atomic>\n+\n class AddressTableModel;\n class BanTableModel;\n class OptionsModel;\n@@ -81,6 +83,10 @@ class ClientModel : public QObject\n     QString formatClientStartupTime() const;\n     QString dataDir() const;\n \n+    // caches for the best header\n+    mutable std::atomic<int> cachedBestHeaderHeight;\n+    mutable std::atomic<int64_t> cachedBestHeaderTime;\n+\n private:\n     OptionsModel *optionsModel;\n     PeerTableModel *peerTableModel;"
      },
      {
        "sha": "941bdd93796252c7fe42055b93a587c8d83c56cc",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00bc8d38d1775526f8de7d361cbf4a728f9e461b/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00bc8d38d1775526f8de7d361cbf4a728f9e461b/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=00bc8d38d1775526f8de7d361cbf4a728f9e461b",
        "patch": "@@ -115,6 +115,7 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"bumpfee\", 1, \"options\" },\n     { \"logging\", 0, \"include\" },\n     { \"logging\", 1, \"exclude\" },\n+    { \"disconnectnode\", 1, \"nodeid\" },\n     // Echo with conversion (For testing only)\n     { \"echojson\", 0, \"arg0\" },\n     { \"echojson\", 1, \"arg1\" },"
      },
      {
        "sha": "cde5ae723bb03d5d843321ecdd79ea8d9e5ac92a",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 7,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00bc8d38d1775526f8de7d361cbf4a728f9e461b/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00bc8d38d1775526f8de7d361cbf4a728f9e461b/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=00bc8d38d1775526f8de7d361cbf4a728f9e461b",
        "patch": "@@ -234,23 +234,43 @@ UniValue addnode(const JSONRPCRequest& request)\n \n UniValue disconnectnode(const JSONRPCRequest& request)\n {\n-    if (request.fHelp || request.params.size() != 1)\n+    if (request.fHelp || request.params.size() == 0 || request.params.size() >= 3)\n         throw std::runtime_error(\n-            \"disconnectnode \\\"address\\\" \\n\"\n-            \"\\nImmediately disconnects from the specified node.\\n\"\n+            \"disconnectnode \\\"[address]\\\" [nodeid]\\n\"\n+            \"\\nImmediately disconnects from the specified peer node.\\n\"\n+            \"\\nStrictly one out of 'address' and 'nodeid' can be provided to identify the node.\\n\"\n+            \"\\nTo disconnect by nodeid, either set 'address' to the empty string, or call using the named 'nodeid' argument only.\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"address\\\"     (string, required) The IP address/port of the node\\n\"\n+            \"1. \\\"address\\\"     (string, optional) The IP address/port of the node\\n\"\n+            \"2. \\\"nodeid\\\"      (number, optional) The node ID (see getpeerinfo for node IDs)\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"disconnectnode\", \"\\\"192.168.0.6:8333\\\"\")\n+            + HelpExampleCli(\"disconnectnode\", \"\\\"\\\" 1\")\n             + HelpExampleRpc(\"disconnectnode\", \"\\\"192.168.0.6:8333\\\"\")\n+            + HelpExampleRpc(\"disconnectnode\", \"\\\"\\\", 1\")\n         );\n \n     if(!g_connman)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n \n-    bool ret = g_connman->DisconnectNode(request.params[0].get_str());\n-    if (!ret)\n+    bool success;\n+    const UniValue &address_arg = request.params[0];\n+    const UniValue &id_arg = request.params.size() < 2 ? NullUniValue : request.params[1];\n+\n+    if (!address_arg.isNull() && id_arg.isNull()) {\n+        /* handle disconnect-by-address */\n+        success = g_connman->DisconnectNode(address_arg.get_str());\n+    } else if (!id_arg.isNull() && (address_arg.isNull() || (address_arg.isStr() && address_arg.get_str().empty()))) {\n+        /* handle disconnect-by-id */\n+        NodeId nodeid = (NodeId) id_arg.get_int64();\n+        success = g_connman->DisconnectNode(nodeid);\n+    } else {\n+        throw JSONRPCError(RPC_INVALID_PARAMS, \"Only one of address and nodeid should be provided.\");\n+    }\n+\n+    if (!success) {\n         throw JSONRPCError(RPC_CLIENT_NODE_NOT_CONNECTED, \"Node not found in connected nodes\");\n+    }\n \n     return NullUniValue;\n }\n@@ -607,7 +627,7 @@ static const CRPCCommand commands[] =\n     { \"network\",            \"ping\",                   &ping,                   true,  {} },\n     { \"network\",            \"getpeerinfo\",            &getpeerinfo,            true,  {} },\n     { \"network\",            \"addnode\",                &addnode,                true,  {\"node\",\"command\"} },\n-    { \"network\",            \"disconnectnode\",         &disconnectnode,         true,  {\"address\"} },\n+    { \"network\",            \"disconnectnode\",         &disconnectnode,         true,  {\"address\", \"nodeid\"} },\n     { \"network\",            \"getaddednodeinfo\",       &getaddednodeinfo,       true,  {\"node\"} },\n     { \"network\",            \"getnettotals\",           &getnettotals,           true,  {} },\n     { \"network\",            \"getnetworkinfo\",         &getnetworkinfo,         true,  {} },"
      },
      {
        "sha": "3f451d49d23e279b4d4fb02f79bfabb6f5c9c31c",
        "filename": "test/functional/disconnect_ban.py",
        "status": "added",
        "additions": 109,
        "deletions": 0,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00bc8d38d1775526f8de7d361cbf4a728f9e461b/test/functional/disconnect_ban.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00bc8d38d1775526f8de7d361cbf4a728f9e461b/test/functional/disconnect_ban.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/disconnect_ban.py?ref=00bc8d38d1775526f8de7d361cbf4a728f9e461b",
        "patch": "@@ -0,0 +1,109 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test node disconnect and ban behavior\"\"\"\n+\n+from test_framework.mininode import wait_until\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (assert_equal,\n+                                 assert_raises_jsonrpc,\n+                                 connect_nodes_bi,\n+                                 start_node,\n+                                 stop_node,\n+                                 )\n+\n+class DisconnectBanTest(BitcoinTestFramework):\n+\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 2\n+        self.setup_clean_chain = False\n+\n+    def setup_network(self):\n+        self.nodes = self.setup_nodes()\n+        connect_nodes_bi(self.nodes, 0, 1)\n+\n+    def run_test(self):\n+        self.log.info(\"Test setban and listbanned RPCs\")\n+\n+        self.log.info(\"setban: successfully ban single IP address\")\n+        assert_equal(len(self.nodes[1].getpeerinfo()), 2)  # node1 should have 2 connections to node0 at this point\n+        self.nodes[1].setban(\"127.0.0.1\", \"add\")\n+        wait_until(lambda: len(self.nodes[1].getpeerinfo()) == 0)\n+        assert_equal(len(self.nodes[1].getpeerinfo()), 0)  # all nodes must be disconnected at this point\n+        assert_equal(len(self.nodes[1].listbanned()), 1)\n+\n+        self.log.info(\"clearbanned: successfully clear ban list\")\n+        self.nodes[1].clearbanned()\n+        assert_equal(len(self.nodes[1].listbanned()), 0)\n+        self.nodes[1].setban(\"127.0.0.0/24\", \"add\")\n+\n+        self.log.info(\"setban: fail to ban an already banned subnet\")\n+        assert_equal(len(self.nodes[1].listbanned()), 1)\n+        assert_raises_jsonrpc(-23, \"IP/Subnet already banned\", self.nodes[1].setban, \"127.0.0.1\", \"add\")\n+\n+        self.log.info(\"setban: fail to ban an invalid subnet\")\n+        assert_raises_jsonrpc(-30, \"Error: Invalid IP/Subnet\", self.nodes[1].setban, \"127.0.0.1/42\", \"add\")\n+        assert_equal(len(self.nodes[1].listbanned()), 1)  # still only one banned ip because 127.0.0.1 is within the range of 127.0.0.0/24\n+\n+        self.log.info(\"setban remove: fail to unban a non-banned subnet\")\n+        assert_raises_jsonrpc(-30, \"Error: Unban failed\", self.nodes[1].setban, \"127.0.0.1\", \"remove\")\n+        assert_equal(len(self.nodes[1].listbanned()), 1)\n+\n+        self.log.info(\"setban remove: successfully unban subnet\")\n+        self.nodes[1].setban(\"127.0.0.0/24\", \"remove\")\n+        assert_equal(len(self.nodes[1].listbanned()), 0)\n+        self.nodes[1].clearbanned()\n+        assert_equal(len(self.nodes[1].listbanned()), 0)\n+\n+        self.log.info(\"setban: test persistence across node restart\")\n+        self.nodes[1].setban(\"127.0.0.0/32\", \"add\")\n+        self.nodes[1].setban(\"127.0.0.0/24\", \"add\")\n+        self.nodes[1].setban(\"192.168.0.1\", \"add\", 1)  # ban for 1 seconds\n+        self.nodes[1].setban(\"2001:4d48:ac57:400:cacf:e9ff:fe1d:9c63/19\", \"add\", 1000)  # ban for 1000 seconds\n+        listBeforeShutdown = self.nodes[1].listbanned()\n+        assert_equal(\"192.168.0.1/32\", listBeforeShutdown[2]['address'])\n+        wait_until(lambda: len(self.nodes[1].listbanned()) == 3)\n+\n+        stop_node(self.nodes[1], 1)\n+\n+        self.nodes[1] = start_node(1, self.options.tmpdir)\n+        listAfterShutdown = self.nodes[1].listbanned()\n+        assert_equal(\"127.0.0.0/24\", listAfterShutdown[0]['address'])\n+        assert_equal(\"127.0.0.0/32\", listAfterShutdown[1]['address'])\n+        assert_equal(\"/19\" in listAfterShutdown[2]['address'], True)\n+\n+        # Clear ban lists\n+        self.nodes[1].clearbanned()\n+        connect_nodes_bi(self.nodes, 0, 1)\n+\n+        self.log.info(\"Test disconnectrnode RPCs\")\n+\n+        self.log.info(\"disconnectnode: fail to disconnect when calling with address and nodeid\")\n+        address1 = self.nodes[0].getpeerinfo()[0]['addr']\n+        node1 = self.nodes[0].getpeerinfo()[0]['addr']\n+        assert_raises_jsonrpc(-32602, \"Only one of address and nodeid should be provided.\", self.nodes[0].disconnectnode, address=address1, nodeid=node1)\n+\n+        self.log.info(\"disconnectnode: fail to disconnect when calling with junk address\")\n+        assert_raises_jsonrpc(-29, \"Node not found in connected nodes\", self.nodes[0].disconnectnode, address=\"221B Baker Street\")\n+\n+        self.log.info(\"disconnectnode: successfully disconnect node by address\")\n+        address1 = self.nodes[0].getpeerinfo()[0]['addr']\n+        self.nodes[0].disconnectnode(address=address1)\n+        wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1)\n+        assert not [node for node in self.nodes[0].getpeerinfo() if node['addr'] == address1]\n+\n+        self.log.info(\"disconnectnode: successfully reconnect node\")\n+        connect_nodes_bi(self.nodes, 0, 1)  # reconnect the node\n+        assert_equal(len(self.nodes[0].getpeerinfo()), 2)\n+        assert [node for node in self.nodes[0].getpeerinfo() if node['addr'] == address1]\n+\n+        self.log.info(\"disconnectnode: successfully disconnect node by node id\")\n+        id1 = self.nodes[0].getpeerinfo()[0]['id']\n+        self.nodes[0].disconnectnode(nodeid=id1)\n+        wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1)\n+        assert not [node for node in self.nodes[0].getpeerinfo() if node['id'] == id1]\n+\n+if __name__ == '__main__':\n+    DisconnectBanTest().main()"
      },
      {
        "sha": "a6b10a0d83d21f152583814cc17e413191fadcd5",
        "filename": "test/functional/nodehandling.py",
        "status": "removed",
        "additions": 0,
        "deletions": 80,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20928b7697aa8ffb3dee9c814c3f02b1dbe7d6b1/test/functional/nodehandling.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20928b7697aa8ffb3dee9c814c3f02b1dbe7d6b1/test/functional/nodehandling.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/nodehandling.py?ref=20928b7697aa8ffb3dee9c814c3f02b1dbe7d6b1",
        "patch": "@@ -1,80 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2014-2016 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Test node handling.\"\"\"\n-\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import *\n-\n-import urllib.parse\n-\n-class NodeHandlingTest (BitcoinTestFramework):\n-\n-    def __init__(self):\n-        super().__init__()\n-        self.num_nodes = 4\n-        self.setup_clean_chain = False\n-\n-    def run_test(self):\n-        ###########################\n-        # setban/listbanned tests #\n-        ###########################\n-        assert_equal(len(self.nodes[2].getpeerinfo()), 4) #we should have 4 nodes at this point\n-        self.nodes[2].setban(\"127.0.0.1\", \"add\")\n-        time.sleep(3) #wait till the nodes are disconected\n-        assert_equal(len(self.nodes[2].getpeerinfo()), 0) #all nodes must be disconnected at this point\n-        assert_equal(len(self.nodes[2].listbanned()), 1)\n-        self.nodes[2].clearbanned()\n-        assert_equal(len(self.nodes[2].listbanned()), 0)\n-        self.nodes[2].setban(\"127.0.0.0/24\", \"add\")\n-        assert_equal(len(self.nodes[2].listbanned()), 1)\n-        # This will throw an exception because 127.0.0.1 is within range 127.0.0.0/24\n-        assert_raises_jsonrpc(-23, \"IP/Subnet already banned\", self.nodes[2].setban, \"127.0.0.1\", \"add\")\n-        # This will throw an exception because 127.0.0.1/42 is not a real subnet\n-        assert_raises_jsonrpc(-30, \"Error: Invalid IP/Subnet\", self.nodes[2].setban, \"127.0.0.1/42\", \"add\")\n-        assert_equal(len(self.nodes[2].listbanned()), 1) #still only one banned ip because 127.0.0.1 is within the range of 127.0.0.0/24\n-        # This will throw an exception because 127.0.0.1 was not added above\n-        assert_raises_jsonrpc(-30, \"Error: Unban failed\", self.nodes[2].setban, \"127.0.0.1\", \"remove\")\n-        assert_equal(len(self.nodes[2].listbanned()), 1)\n-        self.nodes[2].setban(\"127.0.0.0/24\", \"remove\")\n-        assert_equal(len(self.nodes[2].listbanned()), 0)\n-        self.nodes[2].clearbanned()\n-        assert_equal(len(self.nodes[2].listbanned()), 0)\n-\n-        ##test persisted banlist\n-        self.nodes[2].setban(\"127.0.0.0/32\", \"add\")\n-        self.nodes[2].setban(\"127.0.0.0/24\", \"add\")\n-        self.nodes[2].setban(\"192.168.0.1\", \"add\", 1) #ban for 1 seconds\n-        self.nodes[2].setban(\"2001:4d48:ac57:400:cacf:e9ff:fe1d:9c63/19\", \"add\", 1000) #ban for 1000 seconds\n-        listBeforeShutdown = self.nodes[2].listbanned()\n-        assert_equal(\"192.168.0.1/32\", listBeforeShutdown[2]['address']) #must be here\n-        time.sleep(2) #make 100% sure we expired 192.168.0.1 node time\n-\n-        #stop node\n-        stop_node(self.nodes[2], 2)\n-\n-        self.nodes[2] = start_node(2, self.options.tmpdir)\n-        listAfterShutdown = self.nodes[2].listbanned()\n-        assert_equal(\"127.0.0.0/24\", listAfterShutdown[0]['address'])\n-        assert_equal(\"127.0.0.0/32\", listAfterShutdown[1]['address'])\n-        assert_equal(\"/19\" in listAfterShutdown[2]['address'], True)\n-\n-        ###########################\n-        # RPC disconnectnode test #\n-        ###########################\n-        url = urllib.parse.urlparse(self.nodes[1].url)\n-        self.nodes[0].disconnectnode(url.hostname+\":\"+str(p2p_port(1)))\n-        time.sleep(2) #disconnecting a node needs a little bit of time\n-        for node in self.nodes[0].getpeerinfo():\n-            assert(node['addr'] != url.hostname+\":\"+str(p2p_port(1)))\n-\n-        connect_nodes_bi(self.nodes,0,1) #reconnect the node\n-        found = False\n-        for node in self.nodes[0].getpeerinfo():\n-            if node['addr'] == url.hostname+\":\"+str(p2p_port(1)):\n-                found = True\n-        assert(found)\n-\n-if __name__ == '__main__':\n-    NodeHandlingTest ().main ()"
      },
      {
        "sha": "f7a501ab76280cd01725b8a27cb80427e3501f7a",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00bc8d38d1775526f8de7d361cbf4a728f9e461b/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00bc8d38d1775526f8de7d361cbf4a728f9e461b/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=00bc8d38d1775526f8de7d361cbf4a728f9e461b",
        "patch": "@@ -88,7 +88,7 @@\n     'multi_rpc.py',\n     'proxy_test.py',\n     'signrawtransactions.py',\n-    'nodehandling.py',\n+    'disconnect_ban.py',\n     'decodescript.py',\n     'blockchain.py',\n     'disablewallet.py',"
      }
    ]
  },
  {
    "sha": "5263fab0d7462ecca5eb201280a6524a8de920e5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MjYzZmFiMGQ3NDYyZWNjYTVlYjIwMTI4MGE2NTI0YThkZTkyMGU1",
    "commit": {
      "author": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@wirelessprv-10-195-127-163.near.illinois.edu",
        "date": "2017-05-11T20:24:55Z"
      },
      "committer": {
        "name": "Giulia Fanti",
        "email": "giuliafanti@wirelessprv-10-195-127-163.near.illinois.edu",
        "date": "2017-05-11T20:24:55Z"
      },
      "message": "added debugging log messages",
      "tree": {
        "sha": "ec88af297a81275125f1ce857230a94d9dcf5b84",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ec88af297a81275125f1ce857230a94d9dcf5b84"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5263fab0d7462ecca5eb201280a6524a8de920e5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5263fab0d7462ecca5eb201280a6524a8de920e5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5263fab0d7462ecca5eb201280a6524a8de920e5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5263fab0d7462ecca5eb201280a6524a8de920e5/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "00bc8d38d1775526f8de7d361cbf4a728f9e461b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00bc8d38d1775526f8de7d361cbf4a728f9e461b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/00bc8d38d1775526f8de7d361cbf4a728f9e461b"
      }
    ],
    "stats": {
      "total": 15,
      "additions": 12,
      "deletions": 3
    },
    "files": [
      {
        "sha": "8fa3700c09c2c259bfc20202031a07091eb880ae",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 3,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5263fab0d7462ecca5eb201280a6524a8de920e5/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5263fab0d7462ecca5eb201280a6524a8de920e5/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=5263fab0d7462ecca5eb201280a6524a8de920e5",
        "patch": "@@ -1601,7 +1601,11 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 return true;\n \n             bool fAlreadyHave = AlreadyHave(inv);\n-            LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom->id);\n+            if (strCommand == NetMsgType::INV) {\n+                LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom->id);\n+            } else {\n+                LogPrint(BCLog::NET, \"got Dandelion inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom->id);\n+            }\n \n             if (inv.type == MSG_TX) {\n                 inv.type |= nFetchFlags;\n@@ -1610,11 +1614,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 if (strCommand == NetMsgType::D_INV)\n                 {\n                     float rand_prob = ((float) rand() / (float) RAND_MAX);\n-                    if (rand_prob > DANDELION_PROB)\n+                    bool coin_flip = (rand_prob > DANDELION_PROB);\n+                    if (coin_flip)\n                     {\n                         // Add the hash to the set of ongoing stem transactions\n                         Dandelion::stemSet.insert(inv.hash);\n                     }\n+                    LogPrint(BCLog::NET, \"Coin flip was %s for transaction hash=%s\\n\", coin_flip,\n+                            inv.hash.ToString());\n                 }\n             }\n \n@@ -3142,6 +3149,8 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                     pto->setInventoryTxToSend.erase(it);\n                     // Add the item to the queue to be sent\n                     dandVInv.push_back(CInv(MSG_TX, hash));\n+                    LogPrint(BCLog::NET, \"%s: sending Dandelion inv to peer=%d with hash=%s\\n\", __func__,\n+                            pto->id, hash.ToString());\n                     // Add the hash to the mapRelay if it's in the mempool\n                     {\n                         auto txinfo = mempool.info(hash);\n@@ -3161,7 +3170,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                 }\n             }\n             if (!dandVInv.empty()) {\n-                LogPrintf(\"About to send %d Dandelion messages.\\n\", dandVInv.size());\n+                // LogPrintf(\"About to send %d Dandelion messages.\\n\", dandVInv.size());\n                 connman.PushMessage(pto, msgMaker.Make(NetMsgType::D_INV, dandVInv));\n             }\n "
      }
    ]
  },
  {
    "sha": "0119a009021c18efec4c55dba0a1205a8b0995b9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMTE5YTAwOTAyMWMxOGVmZWM0YzU1ZGJhMGExMjA1YThiMDk5NWI5",
    "commit": {
      "author": {
        "name": "Surya Bakshi",
        "email": "sbaks0820@gmail.com",
        "date": "2017-05-29T02:51:59Z"
      },
      "committer": {
        "name": "Surya Bakshi",
        "email": "sbaks0820@gmail.com",
        "date": "2017-05-29T02:51:59Z"
      },
      "message": "sendrawtransaction dandelion",
      "tree": {
        "sha": "3923a6b655985ca61a3c4aa526733e631eb501e0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3923a6b655985ca61a3c4aa526733e631eb501e0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0119a009021c18efec4c55dba0a1205a8b0995b9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0119a009021c18efec4c55dba0a1205a8b0995b9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0119a009021c18efec4c55dba0a1205a8b0995b9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0119a009021c18efec4c55dba0a1205a8b0995b9/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "5263fab0d7462ecca5eb201280a6524a8de920e5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5263fab0d7462ecca5eb201280a6524a8de920e5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5263fab0d7462ecca5eb201280a6524a8de920e5"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 26,
      "deletions": 3
    },
    "files": [
      {
        "sha": "c7816d2a5f327e1dee8d789f7e5e4befb9c1944b",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 3,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0119a009021c18efec4c55dba0a1205a8b0995b9/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0119a009021c18efec4c55dba0a1205a8b0995b9/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=0119a009021c18efec4c55dba0a1205a8b0995b9",
        "patch": "@@ -23,6 +23,7 @@\n #include \"txmempool.h\"\n #include \"uint256.h\"\n #include \"utilstrencodings.h\"\n+#include \"net_processing.h\"\n #ifdef ENABLE_WALLET\n #include \"wallet/rpcwallet.h\"\n #include \"wallet/wallet.h\"\n@@ -923,12 +924,34 @@ UniValue sendrawtransaction(const JSONRPCRequest& request)\n     }\n     if(!g_connman)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n-\n     CInv inv(MSG_TX, hashTx);\n-    g_connman->ForEachNode([&inv](CNode* pnode)\n+    CNode* stemNode;\n+    bool stemRelay = false;\n+    std::vector<CNode*> outgoing;\n+    g_connman->ForEachNode( [&outgoing](CNode* pnode)\n     {\n-        pnode->PushInventory(inv);\n+        if (!pnode->fInbound && pnode->GetSendVersion() >= DANDELION_VERSION_NUM) {\n+            outgoing.push_back(pnode);\n+        }\n+    });\n+\n+    if (!outgoing.empty()) {\n+        Dandelion::stemSet.insert(inv.hash);\n+        stemRelay = true;\n+        std::vector<CNode*>::iterator randIt = outgoing.begin();\n+        std::advance(randIt, std::rand() % outgoing.size());\n+        stemNode = *randIt;\n+    }\n+    g_connman->ForEachNode([&inv, &stemRelay, &stemNode](CNode* pnode)\n+    {\n+        if (!stemRelay || stemNode == pnode) {\n+            pnode->PushInventory(inv);\n+        }\n     });\n+    //g_connman->ForEachNode([&inv](CNode* pnode)\n+    //{\n+    //    pnode->PushInventory(inv);\n+    //});\n     return hashTx.GetHex();\n }\n "
      }
    ]
  },
  {
    "sha": "57c43870128203097599a322c689f4c65c977f11",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1N2M0Mzg3MDEyODIwMzA5NzU5OWEzMjJjNjg5ZjRjNjVjOTc3ZjEx",
    "commit": {
      "author": {
        "name": "Surya Bakshi",
        "email": "sbaks0820@gmail.com",
        "date": "2017-05-29T06:30:29Z"
      },
      "committer": {
        "name": "Surya Bakshi",
        "email": "sbaks0820@gmail.com",
        "date": "2017-05-29T06:30:29Z"
      },
      "message": "fix bug and sendrawtransaction",
      "tree": {
        "sha": "e28880d9762deaaba37f915a9a8c6afd2d4a5068",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e28880d9762deaaba37f915a9a8c6afd2d4a5068"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/57c43870128203097599a322c689f4c65c977f11",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/57c43870128203097599a322c689f4c65c977f11",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/57c43870128203097599a322c689f4c65c977f11",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/57c43870128203097599a322c689f4c65c977f11/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "0119a009021c18efec4c55dba0a1205a8b0995b9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0119a009021c18efec4c55dba0a1205a8b0995b9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0119a009021c18efec4c55dba0a1205a8b0995b9"
      }
    ],
    "stats": {
      "total": 24,
      "additions": 20,
      "deletions": 4
    },
    "files": [
      {
        "sha": "fbb75efae166d61f7cc9b0af9edec2ca369b83c4",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/57c43870128203097599a322c689f4c65c977f11/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/57c43870128203097599a322c689f4c65c977f11/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=57c43870128203097599a322c689f4c65c977f11",
        "patch": "@@ -3139,14 +3139,12 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             std::vector<CInv> dandVInv;\n             // Add only the elements that are in the Dandelion stem\n             dandVInv.reserve(pto->setInventoryTxToSend.size());\n-            for (std::set<uint256>::iterator it = pto->setInventoryTxToSend.begin(); it != pto->setInventoryTxToSend.end(); it++) {\n+            for (std::set<uint256>::iterator it = pto->setInventoryTxToSend.begin(); it != pto->setInventoryTxToSend.end();) {\n                 uint256 hash = *it;\n                 // Check if the hash is in the dandelion stem\n                 if (Dandelion::stemSet.find(hash) != Dandelion::stemSet.end()) {\n                     // remove the hash from the dandelion stem set\n                     Dandelion::stemSet.erase(hash);\n-                    // remove the iterator from pto's to-send list\n-                    pto->setInventoryTxToSend.erase(it);\n                     // Add the item to the queue to be sent\n                     dandVInv.push_back(CInv(MSG_TX, hash));\n                     LogPrint(BCLog::NET, \"%s: sending Dandelion inv to peer=%d with hash=%s\\n\", __func__,\n@@ -3167,6 +3165,10 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                         dandVInv.clear();\n                     }\n                     pto->filterInventoryKnown.insert(hash);\n+                    // remove the iterator from pto's to-send list\n+                    pto->setInventoryTxToSend.erase(it++);\n+                } else {\n+                    it++;\n                 }\n             }\n             if (!dandVInv.empty()) {"
      },
      {
        "sha": "d847f205578b4177c9d169bda1e849b0914a8ef1",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/57c43870128203097599a322c689f4c65c977f11/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/57c43870128203097599a322c689f4c65c977f11/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=57c43870128203097599a322c689f4c65c977f11",
        "patch": "@@ -250,8 +250,11 @@ extern const char *D_INV;\n /* Get a vector of all valid message types (see above) */\n const std::vector<std::string> &getAllNetMessageTypes();\n \n+///* Dandelion forwarding probability */\n+//const float DANDELION_PROB = 0.2;\n+\n /* Dandelion forwarding probability */\n-const float DANDELION_PROB = 0.2;\n+const float DANDELION_PROB = strtof( std::getenv(\"DPROB\"), NULL );\n \n /** nServices flags */\n enum ServiceFlags : uint64_t {"
      },
      {
        "sha": "d039609611bfa36ac47312786abe847ba23b6952",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/57c43870128203097599a322c689f4c65c977f11/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/57c43870128203097599a322c689f4c65c977f11/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=57c43870128203097599a322c689f4c65c977f11",
        "patch": "@@ -4,6 +4,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"base58.h\"\n+//#include \"util.h\"\n #include \"chain.h\"\n #include \"coins.h\"\n #include \"consensus/validation.h\"\n@@ -928,14 +929,17 @@ UniValue sendrawtransaction(const JSONRPCRequest& request)\n     CNode* stemNode;\n     bool stemRelay = false;\n     std::vector<CNode*> outgoing;\n+    LogPrintf(\"DANDELION: Looking for Dandelion Nodes\\n\");\n     g_connman->ForEachNode( [&outgoing](CNode* pnode)\n     {\n         if (!pnode->fInbound && pnode->GetSendVersion() >= DANDELION_VERSION_NUM) {\n+            LogPrintf(\"DANDELION: found one dandelion node\\n\");\n             outgoing.push_back(pnode);\n         }\n     });\n \n     if (!outgoing.empty()) {\n+        LogPrintf(\"DANDELION: adding inv to dandelion peer's push\\n\");\n         Dandelion::stemSet.insert(inv.hash);\n         stemRelay = true;\n         std::vector<CNode*>::iterator randIt = outgoing.begin();\n@@ -945,6 +949,7 @@ UniValue sendrawtransaction(const JSONRPCRequest& request)\n     g_connman->ForEachNode([&inv, &stemRelay, &stemNode](CNode* pnode)\n     {\n         if (!stemRelay || stemNode == pnode) {\n+            LogPrintf(\"DANDELION: pushing transaction\\n\");\n             pnode->PushInventory(inv);\n         }\n     });"
      },
      {
        "sha": "46a4f25d8df05e05471e04820a230e75fb2087b0",
        "filename": "src/timedata.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/57c43870128203097599a322c689f4c65c977f11/src/timedata.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/57c43870128203097599a322c689f4c65c977f11/src/timedata.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.cpp?ref=57c43870128203097599a322c689f4c65c977f11",
        "patch": "@@ -38,6 +38,11 @@ int64_t GetAdjustedTime()\n     return GetTime() + GetTimeOffset();\n }\n \n+int64_t GetAdjustedTimeMillis()\n+{\n+    return GetTimeMillis();\n+}\n+\n static int64_t abs64(int64_t n)\n {\n     return (n >= 0 ? n : -n);"
      },
      {
        "sha": "1987655a96c94defdedd28e5c62a9a5eef70939c",
        "filename": "src/timedata.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/57c43870128203097599a322c689f4c65c977f11/src/timedata.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/57c43870128203097599a322c689f4c65c977f11/src/timedata.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.h?ref=57c43870128203097599a322c689f4c65c977f11",
        "patch": "@@ -73,6 +73,7 @@ class CMedianFilter\n /** Functions to keep track of adjusted P2P time */\n int64_t GetTimeOffset();\n int64_t GetAdjustedTime();\n+int64_t GetAdjustedTimeMillis();\n void AddTimeData(const CNetAddr& ip, int64_t nTime);\n \n #endif // BITCOIN_TIMEDATA_H"
      }
    ]
  },
  {
    "sha": "244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNDRiMTMzYzk3ZGQ3NTk1MGUzZDFlNDBkOWQ3YjZiYWIxZDRmYWRj",
    "commit": {
      "author": {
        "name": "Surya Bakshi",
        "email": "sbaks0820@gmail.com",
        "date": "2017-05-29T06:32:54Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2017-05-29T06:32:54Z"
      },
      "message": "Merge branch 'master' into sendraw",
      "tree": {
        "sha": "3764db70bcba2bebfaa32882c310424d454df2d4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3764db70bcba2bebfaa32882c310424d454df2d4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/comments",
    "author": null,
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "57c43870128203097599a322c689f4c65c977f11",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/57c43870128203097599a322c689f4c65c977f11",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/57c43870128203097599a322c689f4c65c977f11"
      },
      {
        "sha": "b4b057a3e0712dd16b50cbcfe7d613e4413ffa1c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4b057a3e0712dd16b50cbcfe7d613e4413ffa1c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b4b057a3e0712dd16b50cbcfe7d613e4413ffa1c"
      }
    ],
    "stats": {
      "total": 9515,
      "additions": 5939,
      "deletions": 3576
    },
    "files": [
      {
        "sha": "97bb475e4babf692a556b98db8f50caef7104f41",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -43,6 +43,7 @@ install:\n     - if [ -n \"$PACKAGES\" ]; then travis_retry sudo apt-get update; fi\n     - if [ -n \"$PACKAGES\" ]; then travis_retry sudo apt-get install --no-install-recommends --no-upgrade -qq $PACKAGES; fi\n before_script:\n+    - if [ \"$TRAVIS_EVENT_TYPE\" = \"pull_request\" ]; then contrib/devtools/commit-script-check.sh $TRAVIS_COMMIT_RANGE; fi\n     - unset CC; unset CXX\n     - if [ \"$CHECK_DOC\" = 1 ]; then contrib/devtools/check-doc.py; fi\n     - mkdir -p depends/SDKs depends/sdk-sources"
      },
      {
        "sha": "3a56eea0c0516a164968c5bfc531d9d6e72b81c6",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -76,9 +76,6 @@ $(BITCOIN_WIN_INSTALLER): all-recursive\n \t  echo error: could not build $@\n \t@echo built $@\n \n-$(if $(findstring src/,$(MAKECMDGOALS)),$(MAKECMDGOALS), none): FORCE\n-\t$(MAKE) -C src $(patsubst src/%,%,$@)\n-\n $(OSX_APP)/Contents/PkgInfo:\n \t$(MKDIR_P) $(@D)\n \t@echo \"APPL????\" > $@"
      },
      {
        "sha": "36727004887ba1d72bd790429993602ca5ff1fe3",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -549,6 +549,8 @@ AC_CHECK_DECLS([bswap_16, bswap_32, bswap_64],,,\n                  #include <byteswap.h>\n                  #endif])\n \n+AC_CHECK_DECLS([__builtin_clz, __builtin_clzl, __builtin_clzll])\n+\n dnl Check for MSG_NOSIGNAL\n AC_MSG_CHECKING(for MSG_NOSIGNAL)\n AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/socket.h>]],\n@@ -676,6 +678,10 @@ AX_BOOST_PROGRAM_OPTIONS\n AX_BOOST_THREAD\n AX_BOOST_CHRONO\n \n+dnl Boost 1.56 through 1.62 allow using std::atomic instead of its own atomic\n+dnl counter implementations. In 1.63 and later the std::atomic approach is default.\n+m4_pattern_allow(DBOOST_AC_USE_STD_ATOMIC) dnl otherwise it's treated like a macro\n+BOOST_CPPFLAGS=\"-DBOOST_SP_USE_STD_ATOMIC -DBOOST_AC_USE_STD_ATOMIC $BOOST_CPPFLAGS\"\n \n if test x$use_reduce_exports = xyes; then\n   AC_MSG_CHECKING([for working boost reduced exports])"
      },
      {
        "sha": "33dab9b6388890a5ba10e47fcd3b833bb0875dc4",
        "filename": "contrib/debian/changelog",
        "status": "modified",
        "additions": 122,
        "deletions": 3,
        "changes": 125,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/contrib/debian/changelog",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/contrib/debian/changelog",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/changelog?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -1,3 +1,122 @@\n+bitcoin (0.14.1-trusty4) trusty; urgency=medium\n+\n+  * Re-enable UPnP support.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Fri, 05 May 2017 13:28:00 -0400\n+\n+bitcoin (0.14.1-trusty3) trusty; urgency=medium\n+\n+  * Build with qt5 if we are on a non-Ubuntu (ie non-Unity) distro.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Thu, 04 May 2017 17:13:00 -0400\n+\n+bitcoin (0.14.1-trusty2) trusty; urgency=medium\n+\n+  * Bump minimum boost version in deps.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Thu, 04 May 2017 17:12:00 -0400\n+\n+bitcoin (0.14.1-trusty1) trusty; urgency=medium\n+\n+  * New upstream release.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Sat, 22 Apr 2017 17:10:00 -0400\n+\n+bitcoin (0.14.0-trusty1) trusty; urgency=medium\n+\n+  * New upstream release.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Wed, 08 Mar 2017 10:30:00 -0500\n+\n+bitcoin (0.13.2-trusty1) trusty; urgency=medium\n+\n+  * New upstream release.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Thu, 05 Jan 2017 09:59:00 -0500\n+\n+bitcoin (0.13.1-trusty2) trusty; urgency=medium\n+\n+  * Revert to Qt4, due to https://github.com/bitcoin/bitcoin/issues/9038\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Mon, 31 Oct 2016 11:16:00 -0400\n+\n+bitcoin (0.13.1-trusty1) trusty; urgency=medium\n+\n+  * New upstream release.\n+  * Backport updated bitcoin-qt.desktop from upstream master\n+  * Add zmq dependency\n+  * Switch to Qt5 (breaks precise, but that was already broken by C++11)\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Thu, 27 Oct 2016 17:32:00 -0400\n+\n+bitcoin (0.13.0-trusty1) trusty; urgency=medium\n+\n+  * New upstream release.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Sun, 04 Sep 2016 22:09:00 -0400\n+\n+bitcoin (0.12.1-trusty1) trusty; urgency=medium\n+\n+  * New upstream release.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Mon, 18 Apr 2016 14:26:00 -0700\n+\n+bitcoin (0.12.0-trusty6) trusty; urgency=medium\n+\n+  * Fix program-options dep.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Fri, 25 Mar 2016 21:41:00 -0700\n+\n+bitcoin (0.12.0-trusty5) trusty; urgency=medium\n+\n+  * Test explicit --with-gui\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Tue, 23 Feb 2015 23:25:00 -0800\n+\n+bitcoin (0.12.0-trusty4) trusty; urgency=medium\n+\n+  * Fix libevent-dev dep.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Tue, 23 Feb 2015 23:25:00 -0800\n+\n+bitcoin (0.12.0-trusty3) trusty; urgency=medium\n+\n+  * Fix precise boost dep.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Tue, 23 Feb 2015 19:55:00 -0800\n+\n+bitcoin (0.12.0-trusty2) trusty; urgency=medium\n+\n+  * Fix libevent dep.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Tue, 23 Feb 2015 19:53:00 -0800\n+\n+bitcoin (0.12.0-trusty1) trusty; urgency=medium\n+\n+  * New upstream release\n+  * Various updates to contrib/debian were merged, a few were not\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Tue, 23 Feb 2015 19:29:00 -0800\n+\n+bitcoin (0.11.2-trusty1) trusty; urgency=low\n+\n+  * New upstream release.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Fri, 13 Nov 2015 18:39:00 -0800\n+\n+bitcoin (0.11.1-trusty2) trusty; urgency=low\n+\n+  * Remove minupnpc builddep.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Wed, 14 Oct 2015 23:06:00 -1000\n+\n+bitcoin (0.11.1-trusty1) trusty; urgency=high\n+\n+  * New upstream release.\n+  * Disable all UPnP support.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Wed, 14 Oct 2015 13:57:00 -1000\n+\n bitcoin (0.11.0-precise1) precise; urgency=medium\n \n   * New upstream release.\n@@ -179,7 +298,7 @@ bitcoin (0.5.3-natty0) natty; urgency=low\n bitcoin (0.5.2-natty1) natty; urgency=low\n \n   * Remove mentions on anonymity in package descriptions and manpage.\n-    These should never have been there, bitcoin isn't anonymous without\n+    These should never have been there, bitcoin isnt anonymous without\n     a ton of work that virtually no users will ever be willing and\n     capable of doing\n \n@@ -220,7 +339,7 @@ bitcoin (0.5.0~rc1-natty1) natty; urgency=low\n \n   * Add test_bitcoin to build test\n   * Fix clean\n-  * Remove unnecessary build-dependancies\n+  * Remove uneccessary build-dependancies\n \n  -- Matt Corallo <matt@bluematt.me>  Wed, 26 Oct 2011 14:37:18 -0400\n \n@@ -380,7 +499,7 @@ bitcoin (0.3.20.01~dfsg-1) unstable; urgency=low\n \n bitcoin (0.3.19~dfsg-6) unstable; urgency=low\n \n-  * Fix override aggressive optimizations.\n+  * Fix override agressive optimizations.\n   * Fix tighten build-dependencies to really fit backporting to Lenny:\n     + Add fallback build-dependency on libdb4.6++-dev.\n     + Tighten unversioned Boost build-dependencies to recent versions,"
      },
      {
        "sha": "0d6ad25e249fe9b7b89a738aba89c2ca1d495587",
        "filename": "contrib/debian/control",
        "status": "modified",
        "additions": 29,
        "deletions": 26,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/contrib/debian/control",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/contrib/debian/control",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/control?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -1,27 +1,30 @@\n Source: bitcoin\n Section: utils\n Priority: optional\n-Maintainer: Jonas Smedegaard <dr@jones.dk>\n-Uploaders: Micah Anderson <micah@debian.org>\n+Maintainer: Matt Corallo <matt@mattcorallo.com>\n+Uploaders: Matt Corallo <matt@mattcorallo.com>\n Build-Depends: debhelper,\n  devscripts,\n  automake,\n  libtool,\n  bash-completion,\n- libboost-system-dev (>> 1.35) | libboost-system1.35-dev,\n  libdb4.8++-dev,\n  libssl-dev,\n  pkg-config,\n- libminiupnpc8-dev | libminiupnpc-dev (>> 1.6),\n- libboost-filesystem-dev (>> 1.35) | libboost-filesystem1.35-dev,\n- libboost-program-options-dev (>> 1.35) | libboost-program-options1.35-dev,\n- libboost-thread-dev (>> 1.35) | libboost-thread1.35-dev,\n- libboost-test-dev (>> 1.35) | libboost-test1.35-dev,\n- qt4-qmake,\n- libqt4-dev,\n+ libevent-dev,\n+ libboost-system1.48-dev | libboost-system-dev (>> 1.47),\n+ libboost-filesystem1.48-dev | libboost-filesystem-dev (>> 1.47),\n+ libboost-program-options1.48-dev | libboost-program-options-dev (>> 1.47),\n+ libboost-thread1.48-dev | libboost-thread-dev (>> 1.47),\n+ libboost-test1.48-dev | libboost-test-dev (>> 1.47),\n+ libboost-chrono1.48-dev | libboost-chrono-dev (>> 1.47),\n+ libminiupnpc8-dev | libminiupnpc-dev,\n+ qt4-qmake, libqt4-dev,\n+ qttools5-dev-tools, qttools5-dev,\n  libqrencode-dev,\n  libprotobuf-dev, protobuf-compiler,\n- python\n+ python,\n+ libzmq3-dev\n Standards-Version: 3.9.2\n Homepage: https://bitcoincore.org/\n Vcs-Git: git://github.com/bitcoin/bitcoin.git\n@@ -31,11 +34,11 @@ Package: bitcoind\n Architecture: any\n Depends: ${shlibs:Depends}, ${misc:Depends}\n Description: peer-to-peer network based digital currency - daemon\n- Bitcoin is an experimental new digital currency that enables instant\n- payments to anyone, anywhere in the world. Bitcoin uses peer-to-peer\n- technology to operate with no central authority: managing transactions\n- and issuing money are carried out collectively by the network. Bitcoin Core\n- is the name of the open source software which enables the use of this currency.\n+ Bitcoin is a free open source peer-to-peer electronic cash system that\n+ is completely decentralized, without the need for a central server or\n+ trusted parties.  Users hold the crypto keys to their own money and\n+ transact directly with each other, with the help of a P2P network to\n+ check for double-spending.\n  .\n  This package provides the daemon, bitcoind, and the CLI tool\n  bitcoin-cli to interact with the daemon.\n@@ -44,23 +47,23 @@ Package: bitcoin-qt\n Architecture: any\n Depends: ${shlibs:Depends}, ${misc:Depends}\n Description: peer-to-peer network based digital currency - Qt GUI\n- Bitcoin is an experimental new digital currency that enables instant\n- payments to anyone, anywhere in the world. Bitcoin uses peer-to-peer\n- technology to operate with no central authority: managing transactions\n- and issuing money are carried out collectively by the network. Bitcoin Core\n- is the name of the open source software which enables the use of this currency.\n+ Bitcoin is a free open source peer-to-peer electronic cash system that\n+ is completely decentralized, without the need for a central server or\n+ trusted parties.  Users hold the crypto keys to their own money and\n+ transact directly with each other, with the help of a P2P network to\n+ check for double-spending.\n  .\n  This package provides Bitcoin-Qt, a GUI for Bitcoin based on Qt.\n \n Package: bitcoin-tx\n Architecture: any\n Depends: ${shlibs:Depends}, ${misc:Depends}\n Description: peer-to-peer digital currency - standalone transaction tool\n- Bitcoin is an experimental new digital currency that enables instant\n- payments to anyone, anywhere in the world. Bitcoin uses peer-to-peer\n- technology to operate with no central authority: managing transactions\n- and issuing money are carried out collectively by the network. Bitcoin Core\n- is the name of the open source software which enables the use of this currency.\n+ Bitcoin is a free open source peer-to-peer electronic cash system that\n+ is completely decentralized, without the need for a central server or\n+ trusted parties.  Users hold the crypto keys to their own money and\n+ transact directly with each other, with the help of a P2P network to\n+ check for double-spending.\n  .\n  This package provides bitcoin-tx, a command-line transaction creation\n  tool which can be used without a bitcoin daemon.  Some means of"
      },
      {
        "sha": "6885e3852126f17e910cbe4236b4f773a1fd8de6",
        "filename": "contrib/debian/rules",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/contrib/debian/rules",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/contrib/debian/rules",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/rules?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -12,10 +12,12 @@ override_dh_auto_clean:\n \tif [ -f Makefile ]; then $(MAKE) distclean; fi\n \trm -rf Makefile.in aclocal.m4 configure src/Makefile.in src/bitcoin-config.h.in src/build-aux src/qt/Makefile.in src/qt/test/Makefile.in src/test/Makefile.in\n \n+QT=$(shell dpkg-vendor --derives-from Ubuntu && echo qt4 || echo qt5)\n+\n # Yea, autogen should be run on the source archive, but I like doing git archive\n override_dh_auto_configure:\n \t./autogen.sh\n-\t./configure\n+\t./configure --with-gui=$(QT)\n \n override_dh_auto_test:\n \tmake check"
      },
      {
        "sha": "add4bb4883d41b495109672df6d44ebe9691e1d1",
        "filename": "contrib/devtools/commit-script-check.sh",
        "status": "added",
        "additions": 39,
        "deletions": 0,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/contrib/devtools/commit-script-check.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/contrib/devtools/commit-script-check.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/commit-script-check.sh?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -0,0 +1,39 @@\n+#!/bin/sh\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+# This simple script checks for commits beginning with: scripted-diff:\n+# If found, looks for a script between the lines -BEGIN VERIFY SCRIPT- and\n+# -END VERIFY SCRIPT-. If no ending is found, it reads until the end of the\n+# commit message.\n+\n+# The resulting script should exactly transform the previous commit into the current\n+# one. Any remaining diff signals an error.\n+\n+if test \"x$1\" = \"x\"; then\n+    echo \"Usage: $0 <commit>...\"\n+    exit 1\n+fi\n+\n+RET=0\n+PREV_BRANCH=`git name-rev --name-only HEAD`\n+PREV_HEAD=`git rev-parse HEAD`\n+for i in `git rev-list --reverse $1`; do\n+    git rev-list -n 1 --pretty=\"%s\" $i | grep -q \"^scripted-diff:\" || continue\n+    git checkout --quiet $i^ || exit\n+    SCRIPT=\"`git rev-list --format=%b -n1 $i | sed '/^-BEGIN VERIFY SCRIPT-$/,/^-END VERIFY SCRIPT-$/{//!b};d'`\"\n+    if test \"x$SCRIPT\" = \"x\"; then\n+        echo \"Error: missing script for: $i\"\n+        echo \"Failed\"\n+        RET=1\n+    else\n+        echo \"Running script for: $i\"\n+        echo \"$SCRIPT\"\n+        eval \"$SCRIPT\"\n+        git --no-pager diff --exit-code $i && echo \"OK\" || (echo \"Failed\"; false) || RET=1\n+    fi\n+    git reset --quiet --hard HEAD\n+done\n+git checkout --quiet $PREV_BRANCH 2>/dev/null || git checkout --quiet $PREV_HEAD\n+exit $RET"
      },
      {
        "sha": "8fce648fc2a2a84108f1c9e28c20b6aad98d6627",
        "filename": "contrib/devtools/github-merge.py",
        "status": "modified",
        "additions": 25,
        "deletions": 28,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/contrib/devtools/github-merge.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/contrib/devtools/github-merge.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/github-merge.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2016 The Bitcoin Core developers\n+# Copyright (c) 2016-2017 Bitcoin Core Developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -127,6 +127,9 @@ def tree_sha512sum(commit='HEAD'):\n         raise IOError('Non-zero return value executing git cat-file')\n     return overall.hexdigest()\n \n+def print_merge_details(pull, title, branch, base_branch, head_branch):\n+    print('%s#%s%s %s %sinto %s%s' % (ATTR_RESET+ATTR_PR,pull,ATTR_RESET,title,ATTR_RESET+ATTR_PR,branch,ATTR_RESET))\n+    subprocess.check_call([GIT,'log','--graph','--topo-order','--pretty=format:'+COMMIT_FORMAT,base_branch+'..'+head_branch])\n \n def parse_arguments():\n     epilog = '''\n@@ -171,7 +174,7 @@ def main():\n     info = retrieve_pr_info(repo,pull)\n     if info is None:\n         exit(1)\n-    title = info['title']\n+    title = info['title'].strip()\n     # precedence order for destination branch argument:\n     #   - command line argument\n     #   - githubmerge.branch setting\n@@ -256,8 +259,7 @@ def main():\n             printf(\"ERROR: Cannot update message.\",file=stderr)\n             exit(4)\n \n-        print('%s#%s%s %s %sinto %s%s' % (ATTR_RESET+ATTR_PR,pull,ATTR_RESET,title,ATTR_RESET+ATTR_PR,branch,ATTR_RESET))\n-        subprocess.check_call([GIT,'log','--graph','--topo-order','--pretty=format:'+COMMIT_FORMAT,base_branch+'..'+head_branch])\n+        print_merge_details(pull, title, branch, base_branch, head_branch)\n         print()\n \n         # Run test command if configured.\n@@ -276,12 +278,6 @@ def main():\n                     print(\"Difference with github ignored.\",file=stderr)\n                 else:\n                     exit(6)\n-            reply = ask_prompt(\"Press 'd' to accept the diff.\")\n-            if reply.lower() == 'd':\n-                print(\"Diff accepted.\",file=stderr)\n-            else:\n-                print(\"ERROR: Diff rejected.\",file=stderr)\n-                exit(6)\n         else:\n             # Verify the result manually.\n             print(\"Dropping you on a shell so you can try building/testing the merged source.\",file=stderr)\n@@ -290,29 +286,26 @@ def main():\n             if os.path.isfile('/etc/debian_version'): # Show pull number on Debian default prompt\n                 os.putenv('debian_chroot',pull)\n             subprocess.call([BASH,'-i'])\n-            reply = ask_prompt(\"Type 'm' to accept the merge.\")\n-            if reply.lower() == 'm':\n-                print(\"Merge accepted.\",file=stderr)\n-            else:\n-                print(\"ERROR: Merge rejected.\",file=stderr)\n-                exit(7)\n \n         second_sha512 = tree_sha512sum()\n         if first_sha512 != second_sha512:\n             print(\"ERROR: Tree hash changed unexpectedly\",file=stderr)\n             exit(8)\n \n         # Sign the merge commit.\n-        reply = ask_prompt(\"Type 's' to sign off on the merge.\")\n-        if reply == 's':\n-            try:\n-                subprocess.check_call([GIT,'commit','-q','--gpg-sign','--amend','--no-edit'])\n-            except subprocess.CalledProcessError as e:\n-                print(\"Error signing, exiting.\",file=stderr)\n+        print_merge_details(pull, title, branch, base_branch, head_branch)\n+        while True:\n+            reply = ask_prompt(\"Type 's' to sign off on the above merge, or 'x' to reject and exit.\").lower()\n+            if reply == 's':\n+                try:\n+                    subprocess.check_call([GIT,'commit','-q','--gpg-sign','--amend','--no-edit'])\n+                    break\n+                except subprocess.CalledProcessError as e:\n+                    print(\"Error signing, exiting.\",file=stderr)\n+                    exit(1)\n+            elif reply == 'x':\n+                print(\"Not signing off on merge, exiting.\",file=stderr)\n                 exit(1)\n-        else:\n-            print(\"Not signing off on merge, exiting.\",file=stderr)\n-            exit(1)\n \n         # Put the result in branch.\n         subprocess.check_call([GIT,'checkout','-q',branch])\n@@ -326,9 +319,13 @@ def main():\n         subprocess.call([GIT,'branch','-q','-D',local_merge_branch],stderr=devnull)\n \n     # Push the result.\n-    reply = ask_prompt(\"Type 'push' to push the result to %s, branch %s.\" % (host_repo,branch))\n-    if reply.lower() == 'push':\n-        subprocess.check_call([GIT,'push',host_repo,'refs/heads/'+branch])\n+    while True:\n+        reply = ask_prompt(\"Type 'push' to push the result to %s, branch %s, or 'x' to exit without pushing.\" % (host_repo,branch)).lower()\n+        if reply == 'push':\n+            subprocess.check_call([GIT,'push',host_repo,'refs/heads/'+branch])\n+            break\n+        elif reply == 'x':\n+            exit(1)\n \n if __name__ == '__main__':\n     main()"
      },
      {
        "sha": "3da8510cfbd70132954e678ee80f07f9c9e16234",
        "filename": "contrib/gitian-descriptors/gitian-linux.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/contrib/gitian-descriptors/gitian-linux.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/contrib/gitian-descriptors/gitian-linux.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-linux.yml?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -132,6 +132,7 @@ script: |\n   export PATH=${WRAP_DIR}:${PATH}\n \n   # Create the release tarball using (arbitrarily) the first host\n+  export GIT_DIR=\"$PWD/.git\"\n   ./autogen.sh\n   CONFIG_SITE=${BASEPREFIX}/`echo \"${HOSTS}\" | awk '{print $1;}'`/share/config.site ./configure --prefix=/\n   make dist"
      },
      {
        "sha": "206db7c19e751d414d51d4aaeb2e7bf6bff6288b",
        "filename": "contrib/gitian-descriptors/gitian-osx.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/contrib/gitian-descriptors/gitian-osx.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/contrib/gitian-descriptors/gitian-osx.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-osx.yml?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -101,6 +101,7 @@ script: |\n   export PATH=${WRAP_DIR}:${PATH}\n \n   # Create the release tarball using (arbitrarily) the first host\n+  export GIT_DIR=\"$PWD/.git\"\n   ./autogen.sh\n   CONFIG_SITE=${BASEPREFIX}/`echo \"${HOSTS}\" | awk '{print $1;}'`/share/config.site ./configure --prefix=/\n   make dist"
      },
      {
        "sha": "1d4d70494b0cc403649235133c72cbbbc8b2fba0",
        "filename": "contrib/gitian-descriptors/gitian-win.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/contrib/gitian-descriptors/gitian-win.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/contrib/gitian-descriptors/gitian-win.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-win.yml?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -116,6 +116,7 @@ script: |\n   export PATH=${WRAP_DIR}:${PATH}\n \n   # Create the release tarball using (arbitrarily) the first host\n+  export GIT_DIR=\"$PWD/.git\"\n   ./autogen.sh\n   CONFIG_SITE=${BASEPREFIX}/`echo \"${HOSTS}\" | awk '{print $1;}'`/share/config.site ./configure --prefix=/\n   make dist"
      },
      {
        "sha": "23a568ad13aeb91d79e51de4283b0959c4baf027",
        "filename": "contrib/macdeploy/macdeployqtplus",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/contrib/macdeploy/macdeployqtplus",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/contrib/macdeploy/macdeployqtplus",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/macdeployqtplus?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -302,7 +302,6 @@ def copyFramework(framework, path, verbose):\n         if os.path.exists(fromContentsDir):\n             toContentsDir = os.path.join(path, framework.destinationVersionContentsDirectory)\n             shutil.copytree(fromContentsDir, toContentsDir, symlinks=True)\n-            contentslinkfrom = os.path.join(path, framework.destinationContentsDirectory)\n             if verbose >= 3:\n                 print(\"Copied Contents:\", fromContentsDir)\n                 print(\" to:\", toContentsDir)\n@@ -675,9 +674,8 @@ else:\n if verbose >= 2:\n     print(\"+ Installing qt.conf +\")\n \n-f = open(os.path.join(applicationBundle.resourcesPath, \"qt.conf\"), \"wb\")\n-f.write(qt_conf.encode())\n-f.close()\n+with open(os.path.join(applicationBundle.resourcesPath, \"qt.conf\"), \"wb\") as f:\n+    f.write(qt_conf.encode())\n \n # ------------------------------------------------\n "
      },
      {
        "sha": "69ed3e573bb3fa14476b0b539805850159eb23e0",
        "filename": "depends/config.guess",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/depends/config.guess",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/depends/config.guess",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/config.guess?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,7 +2,7 @@\n # Attempt to guess a canonical system name.\n #   Copyright 1992-2017 Free Software Foundation, Inc.\n \n-timestamp='2017-01-01'\n+timestamp='2017-03-05'\n \n # This file is free software; you can redistribute it and/or modify it\n # under the terms of the GNU General Public License as published by\n@@ -837,10 +837,11 @@ EOF\n \tUNAME_PROCESSOR=`/usr/bin/uname -p`\n \tcase ${UNAME_PROCESSOR} in\n \t    amd64)\n-\t\techo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;\n-\t    *)\n-\t\techo ${UNAME_PROCESSOR}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;\n+\t\tUNAME_PROCESSOR=x86_64 ;;\n+\t    i386)\n+\t\tUNAME_PROCESSOR=i586 ;;\n \tesac\n+\techo ${UNAME_PROCESSOR}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`\n \texit ;;\n     i*:CYGWIN*:*)\n \techo ${UNAME_MACHINE}-pc-cygwin\n@@ -1343,6 +1344,9 @@ EOF\n     NSR-?:NONSTOP_KERNEL:*:*)\n \techo nsr-tandem-nsk${UNAME_RELEASE}\n \texit ;;\n+    NSX-?:NONSTOP_KERNEL:*:*)\n+\techo nsx-tandem-nsk${UNAME_RELEASE}\n+\texit ;;\n     *:NonStop-UX:*:*)\n \techo mips-compaq-nonstopux\n \texit ;;"
      },
      {
        "sha": "40ea5dfe1152f0fc5160879bb71bfe1fae2595f6",
        "filename": "depends/config.sub",
        "status": "modified",
        "additions": 11,
        "deletions": 3,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/depends/config.sub",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/depends/config.sub",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/config.sub?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,7 +2,7 @@\n # Configuration validation subroutine script.\n #   Copyright 1992-2017 Free Software Foundation, Inc.\n \n-timestamp='2017-01-01'\n+timestamp='2017-04-02'\n \n # This file is free software; you can redistribute it and/or modify it\n # under the terms of the GNU General Public License as published by\n@@ -263,7 +263,7 @@ case $basic_machine in\n \t| fido | fr30 | frv | ft32 \\\n \t| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \\\n \t| hexagon \\\n-\t| i370 | i860 | i960 | ia64 \\\n+\t| i370 | i860 | i960 | ia16 | ia64 \\\n \t| ip2k | iq2000 \\\n \t| k1om \\\n \t| le32 | le64 \\\n@@ -315,6 +315,7 @@ case $basic_machine in\n \t| ubicom32 \\\n \t| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \\\n \t| visium \\\n+\t| wasm32 \\\n \t| we32k \\\n \t| x86 | xc16x | xstormy16 | xtensa \\\n \t| z8k | z80)\n@@ -388,7 +389,7 @@ case $basic_machine in\n \t| h8300-* | h8500-* \\\n \t| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \\\n \t| hexagon-* \\\n-\t| i*86-* | i860-* | i960-* | ia64-* \\\n+\t| i*86-* | i860-* | i960-* | ia16-* | ia64-* \\\n \t| ip2k-* | iq2000-* \\\n \t| k1om-* \\\n \t| le32-* | le64-* \\\n@@ -446,6 +447,7 @@ case $basic_machine in\n \t| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \\\n \t| vax-* \\\n \t| visium-* \\\n+\t| wasm32-* \\\n \t| we32k-* \\\n \t| x86-* | x86_64-* | xc16x-* | xps100-* \\\n \t| xstormy16-* | xtensa*-* \\\n@@ -948,6 +950,9 @@ case $basic_machine in\n \tnsr-tandem)\n \t\tbasic_machine=nsr-tandem\n \t\t;;\n+\tnsx-tandem)\n+\t\tbasic_machine=nsx-tandem\n+\t\t;;\n \top50n-* | op60c-*)\n \t\tbasic_machine=hppa1.1-oki\n \t\tos=-proelf\n@@ -1243,6 +1248,9 @@ case $basic_machine in\n \t\tbasic_machine=a29k-wrs\n \t\tos=-vxworks\n \t\t;;\n+\twasm32)\n+\t\tbasic_machine=wasm32-unknown\n+\t\t;;\n \tw65*)\n \t\tbasic_machine=w65-wdc\n \t\tos=-none"
      },
      {
        "sha": "bf773ccd147d43228815200029dbddd9920fa09d",
        "filename": "depends/packages/boost.mk",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/depends/packages/boost.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/depends/packages/boost.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/boost.mk?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -1,8 +1,8 @@\n package=boost\n-$(package)_version=1_63_0\n-$(package)_download_path=https://sourceforge.net/projects/boost/files/boost/1.63.0\n+$(package)_version=1_64_0\n+$(package)_download_path=https://dl.bintray.com/boostorg/release/1.64.0/source/\n $(package)_file_name=$(package)_$($(package)_version).tar.bz2\n-$(package)_sha256_hash=beae2529f759f6b3bf3f4969a19c2e9d6f0c503edcb2de4a61d1428519fcb3b0\n+$(package)_sha256_hash=7bcc5caace97baa948931d712ea5f37038dbb1c5d89b43ad4def4ed7cb683332\n \n define $(package)_set_vars\n $(package)_config_opts_release=variant=release"
      },
      {
        "sha": "bbe03754099f53b6fe404876af8cbc68722fc216",
        "filename": "depends/packages/dbus.mk",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/depends/packages/dbus.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/depends/packages/dbus.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/dbus.mk?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -1,8 +1,8 @@\n package=dbus\n-$(package)_version=1.10.14\n-$(package)_download_path=http://dbus.freedesktop.org/releases/dbus\n+$(package)_version=1.10.18\n+$(package)_download_path=https://dbus.freedesktop.org/releases/dbus\n $(package)_file_name=$(package)-$($(package)_version).tar.gz\n-$(package)_sha256_hash=23238f70353e38ce5ca183ebc9525c0d97ac00ef640ad29cf794782af6e6a083\n+$(package)_sha256_hash=6049ddd5f3f3e2618f615f1faeda0a115104423a7996b7aa73e2f36e38cc514a\n $(package)_dependencies=expat\n \n define $(package)_set_vars"
      },
      {
        "sha": "00231d75d5f2f297b798b652c2e85ca865fc2e02",
        "filename": "depends/packages/libevent.mk",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/depends/packages/libevent.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/depends/packages/libevent.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/libevent.mk?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -1,8 +1,8 @@\n package=libevent\n-$(package)_version=2.1.7\n+$(package)_version=2.1.8-stable\n $(package)_download_path=https://github.com/libevent/libevent/archive/\n-$(package)_file_name=release-$($(package)_version)-rc.tar.gz\n-$(package)_sha256_hash=548362d202e22fe24d4c3fad38287b4f6d683e6c21503341373b89785fa6f991\n+$(package)_file_name=release-$($(package)_version).tar.gz\n+$(package)_sha256_hash=316ddb401745ac5d222d7c529ef1eada12f58f6376a66c1118eee803cb70f83d\n \n define $(package)_preprocess_cmds\n   ./autogen.sh"
      },
      {
        "sha": "1bb8cb5d2664746b943756a9efa0db8d8a9d385d",
        "filename": "depends/packages/miniupnpc.mk",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/depends/packages/miniupnpc.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/depends/packages/miniupnpc.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/miniupnpc.mk?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -1,8 +1,8 @@\n package=miniupnpc\n-$(package)_version=2.0\n+$(package)_version=2.0.20170509\n $(package)_download_path=http://miniupnp.free.fr/files\n $(package)_file_name=$(package)-$($(package)_version).tar.gz\n-$(package)_sha256_hash=d434ceb8986efbe199c5ca53f90ed53eab290b1e6d0530b717eb6fa49d61f93b\n+$(package)_sha256_hash=d3c368627f5cdfb66d3ebd64ca39ba54d6ff14a61966dbecb8dd296b7039f16a\n \n define $(package)_set_vars\n $(package)_build_opts=CC=\"$($(package)_cc)\""
      },
      {
        "sha": "966804ce8bbf677fae5446219420532b86fdb800",
        "filename": "depends/packages/native_ccache.mk",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/depends/packages/native_ccache.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/depends/packages/native_ccache.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/native_ccache.mk?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -1,8 +1,8 @@\n package=native_ccache\n-$(package)_version=3.3.3\n+$(package)_version=3.3.4\n $(package)_download_path=https://samba.org/ftp/ccache\n $(package)_file_name=ccache-$($(package)_version).tar.bz2\n-$(package)_sha256_hash=2985bc5e32ebe38d2958d508eb54ddcad39eed909489c0c2988035214597ca54\n+$(package)_sha256_hash=fa9d7f38367431bc86b19ad107d709ca7ecf1574fdacca01698bdf0a47cd8567\n \n define $(package)_set_vars\n $(package)_config_opts="
      },
      {
        "sha": "32d7dbd69e7d694f4b27c151343c815c1708eed9",
        "filename": "doc/build-osx.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/doc/build-osx.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/doc/build-osx.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-osx.md?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -11,14 +11,14 @@ Install the OS X command line tools:\n \n When the popup appears, click `Install`.\n \n-Then install [Homebrew](http://brew.sh).\n+Then install [Homebrew](https://brew.sh).\n \n Dependencies\n ----------------------\n \n-    brew install automake berkeley-db4 libtool boost --c++11 miniupnpc openssl pkg-config protobuf --c++11 qt5 libevent\n+    brew install automake berkeley-db4 libtool boost --c++11 miniupnpc openssl pkg-config protobuf qt libevent\n \n-In case you want to build the disk image with `make deploy` (.dmg / optional), you need RSVG\n+If you want to build the disk image with `make deploy` (.dmg / optional), you need RSVG\n \n     brew install librsvg\n "
      },
      {
        "sha": "b7eae2a630ad1acca937121b4def7e382256f283",
        "filename": "doc/build-unix.md",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/doc/build-unix.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/doc/build-unix.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-unix.md?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -321,8 +321,10 @@ Clang is installed by default as `cc` compiler, this makes it easier to get\n started than on [OpenBSD](build-openbsd.md). Installing dependencies:\n \n     pkg install autoconf automake libtool pkgconf\n-    pkg install boost-libs openssl libevent2\n+    pkg install boost-libs openssl libevent\n+    pkg install gmake\n \n+You need to use GNU make (`gmake`) instead of `make`.\n (`libressl` instead of `openssl` will also work)\n \n For the wallet (optional):\n@@ -338,7 +340,7 @@ Then build using:\n \n     ./autogen.sh\n     ./configure --with-incompatible-bdb BDB_CFLAGS=\"-I/usr/local/include/db5\" BDB_LIBS=\"-L/usr/local/lib -ldb_cxx-5\"\n-    make\n+    gmake\n \n *Note on debugging*: The version of `gdb` installed by default is [ancient and considered harmful](https://wiki.freebsd.org/GdbRetirement).\n It is not suitable for debugging a multi-threaded C++ program, not even for getting backtraces. Please install the package `gdb` and"
      },
      {
        "sha": "cf860a1bf271207f2f62ea53dbd7524916ef5cf8",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 76,
        "deletions": 4,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -343,10 +343,9 @@ Strings and formatting\n Variable names\n --------------\n \n-The shadowing warning (`-Wshadow`) is enabled by default. It prevents issues rising\n-from using a different variable with the same name.\n-\n-Please name variables so that their names do not shadow variables defined in the source code.\n+Although the shadowing warning (`-Wshadow`) is not enabled by default (it prevents issues rising\n+from using a different variable with the same name),\n+please name variables so that their names do not shadow variables defined in the source code.\n \n E.g. in member initializers, prepend `_` to the argument name shadowing the\n member name:\n@@ -495,3 +494,76 @@ Git and GitHub tips\n   This will add an `upstream-pull` remote to your git repository, which can be fetched using `git fetch --all`\n   or `git fetch upstream-pull`. Afterwards, you can use `upstream-pull/NUMBER/head` in arguments to `git show`,\n   `git checkout` and anywhere a commit id would be acceptable to see the changes from pull request NUMBER.\n+\n+RPC interface guidelines\n+--------------------------\n+\n+A few guidelines for introducing and reviewing new RPC interfaces:\n+\n+- Method naming: use consecutive lower-case names such as `getrawtransaction` and `submitblock`\n+\n+  - *Rationale*: Consistency with existing interface.\n+\n+- Argument naming: use snake case `fee_delta` (and not, e.g. camel case `feeDelta`)\n+\n+  - *Rationale*: Consistency with existing interface.\n+\n+- Use the JSON parser for parsing, don't manually parse integers or strings from\n+  arguments unless absolutely necessary.\n+\n+  - *Rationale*: Introduces hand-rolled string manipulation code at both the caller and callee sites,\n+    which is error prone, and it is easy to get things such as escaping wrong.\n+    JSON already supports nested data structures, no need to re-invent the wheel.\n+\n+  - *Exception*: AmountToValue can parse amounts as string. This was introduced because many JSON\n+    parsers and formatters hard-code handling decimal numbers as floating point\n+    values, resulting in potential loss of precision. This is unacceptable for\n+    monetary values. **Always** use `AmountToValue` and `ValueToAmount` when\n+    inputting or outputting monetary values. The only exceptions to this are\n+    `prioritisetransaction` and `getblocktemplate` because their interface\n+    is specified as-is in BIP22.\n+\n+- Missing arguments and 'null' should be treated the same: as default values. If there is no\n+  default value, both cases should fail in the same way.\n+\n+  - *Rationale*: Avoids surprises when switching to name-based arguments. Missing name-based arguments\n+  are passed as 'null'.\n+\n+  - *Exception*: Many legacy exceptions to this exist, one of the worst ones is\n+    `getbalance` which follows a completely different code path based on the\n+    number of arguments. We are still in the process of cleaning these up. Do not introduce\n+    new ones.\n+\n+- Try not to overload methods on argument type. E.g. don't make `getblock(true)` and `getblock(\"hash\")`\n+  do different things.\n+\n+  - *Rationale*: This is impossible to use with `bitcoin-cli`, and can be surprising to users.\n+\n+  - *Exception*: Some RPC calls can take both an `int` and `bool`, most notably when a bool was switched\n+    to a multi-value, or due to other historical reasons. **Always** have false map to 0 and\n+    true to 1 in this case.\n+\n+- Don't forget to fill in the argument names correctly in the RPC command table.\n+\n+  - *Rationale*: If not, the call can not be used with name-based arguments.\n+\n+- Set okSafeMode in the RPC command table to a sensible value: safe mode is when the\n+  blockchain is regarded to be in a confused state, and the client deems it unsafe to\n+  do anything irreversible such as send. Anything that just queries should be permitted.\n+\n+  - *Rationale*: Troubleshooting a node in safe mode is difficult if half the\n+    RPCs don't work.\n+\n+- Add every non-string RPC argument `(method, idx, name)` to the table `vRPCConvertParams` in `rpc/client.cpp`.\n+\n+  - *Rationale*: `bitcoin-cli` and the GUI debug console use this table to determine how to\n+    convert a plaintext command line to JSON. If the types don't match, the method can be unusable\n+    from there.\n+\n+- A RPC method must either be a wallet method or a non-wallet method. Do not\n+  introduce new methods such as `getinfo` and `signrawtransaction` that differ\n+  in behavior based on presence of a wallet.\n+\n+  - *Rationale*: as well as complicating the implementation and interfering\n+    with the introduction of multi-wallet, wallet and non-wallet code should be\n+    separated to avoid introducing circular dependencies between code units."
      },
      {
        "sha": "5dedcb51c895e612c6953b99ca3bb532899cb4aa",
        "filename": "doc/fuzzing.md",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/doc/fuzzing.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/doc/fuzzing.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/fuzzing.md?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -32,6 +32,13 @@ We disable ccache because we don't want to pollute the ccache with instrumented\n objects, and similarly don't want to use non-instrumented cached objects linked\n in.\n \n+The fuzzing can be sped up significantly (~200x) by using `afl-clang-fast` and\n+`afl-clang-fast++` in place of `afl-gcc` and `afl-g++` when compiling. When\n+compiling using `afl-clang-fast`/`afl-clang-fast++` the resulting\n+`test_bitcoin_fuzzy` binary will be instrumented in such a way that the AFL\n+features \"persistent mode\" and \"deferred forkserver\" can be used. See\n+https://github.com/mcarpenter/afl/tree/master/llvm_mode for details.\n+\n Preparing fuzzing\n ------------------\n \n@@ -63,4 +70,3 @@ $AFLPATH/afl-fuzz -i ${AFLIN} -o ${AFLOUT} -m52 -- test/test_bitcoin_fuzzy\n \n You may have to change a few kernel parameters to test optimally - `afl-fuzz`\n will print an error and suggestion if so.\n-"
      },
      {
        "sha": "ef072afd4d7fb94d29007038e587eacb40358a98",
        "filename": "doc/release-notes/release-notes-0.14.1.md",
        "status": "added",
        "additions": 143,
        "deletions": 0,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/doc/release-notes/release-notes-0.14.1.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/doc/release-notes/release-notes-0.14.1.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.14.1.md?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -0,0 +1,143 @@\n+Bitcoin Core version 0.14.1 is now available from:\n+\n+  <https://bitcoin.org/bin/bitcoin-core-0.14.1/>\n+\n+This is a new minor version release, including various bugfixes and\n+performance improvements, as well as updated translations.\n+\n+Please report bugs using the issue tracker at github:\n+\n+  <https://github.com/bitcoin/bitcoin/issues>\n+\n+To receive security and update notifications, please subscribe to:\n+\n+  <https://bitcoincore.org/en/list/announcements/join/>\n+\n+Compatibility\n+==============\n+\n+Bitcoin Core is extensively tested on multiple operating systems using\n+the Linux kernel, macOS 10.8+, and Windows Vista and later.\n+\n+Microsoft ended support for Windows XP on [April 8th, 2014](https://www.microsoft.com/en-us/WindowsForBusiness/end-of-xp-support),\n+No attempt is made to prevent installing or running the software on Windows XP, you\n+can still do so at your own risk but be aware that there are known instabilities and issues.\n+Please do not report issues about Windows XP to the issue tracker.\n+\n+Bitcoin Core should also work on most other Unix-like systems but is not\n+frequently tested on them.\n+\n+Notable changes\n+===============\n+\n+RPC changes\n+-----------\n+\n+- The first positional argument of `createrawtransaction` was renamed from\n+  `transactions` to `inputs`.\n+\n+- The argument of `disconnectnode` was renamed from `node` to `address`.\n+\n+These interface changes break compatibility with 0.14.0, when the named\n+arguments functionality, introduced in 0.14.0, is used. Client software\n+using these calls with named arguments needs to be updated.\n+\n+Mining\n+------\n+\n+In previous versions, getblocktemplate required segwit support from downstream\n+clients/miners once the feature activated on the network. In this version, it\n+now supports non-segwit clients even after activation, by removing all segwit\n+transactions from the returned block template. This allows non-segwit miners to\n+continue functioning correctly even after segwit has activated.\n+\n+Due to the limitations in previous versions, getblocktemplate also recommended\n+non-segwit clients to not signal for the segwit version-bit. Since this is no\n+longer an issue, getblocktemplate now always recommends signalling segwit for\n+all miners. This is safe because ability to enforce the rule is the only\n+required criteria for safe activation, not actually producing segwit-enabled\n+blocks.\n+\n+UTXO memory accounting\n+----------------------\n+\n+Memory usage for the UTXO cache is being calculated more accurately, so that\n+the configured limit (`-dbcache`) will be respected when memory usage peaks\n+during cache flushes.  The memory accounting in prior releases is estimated to\n+only account for half the actual peak utilization.\n+\n+The default `-dbcache` has also been changed in this release to 450MiB.  Users\n+who currently set `-dbcache` to a high value (e.g. to keep the UTXO more fully\n+cached in memory) should consider increasing this setting in order to achieve\n+the same cache performance as prior releases.  Users on low-memory systems\n+(such as systems with 1GB or less) should consider specifying a lower value for\n+this parameter.\n+\n+Additional information relating to running on low-memory systems can be found\n+here:\n+[reducing-bitcoind-memory-usage.md](https://gist.github.com/laanwj/efe29c7661ce9b6620a7).\n+\n+0.14.1 Change log\n+=================\n+\n+Detailed release notes follow. This overview includes changes that affect\n+behavior, not code moves, refactors and string updates. For convenience in locating\n+the code changes and accompanying discussion, both the pull request and\n+git merge commit are mentioned.\n+\n+### RPC and other APIs\n+- #10084 `142fbb2` Rename first named arg of createrawtransaction (MarcoFalke)\n+- #10139 `f15268d` Remove auth cookie on shutdown (practicalswift)\n+- #10146 `2fea10a` Better error handling for submitblock (rawodb, gmaxwell)\n+- #10144 `d947afc` Prioritisetransaction wasn't always updating ancestor fee (sdaftuar)\n+- #10204 `3c79602` Rename disconnectnode argument (jnewbery)\n+\n+### Block and transaction handling\n+- #10126 `0b5e162` Compensate for memory peak at flush time (sipa)\n+- #9912 `fc3d7db` Optimize GetWitnessHash() for non-segwit transactions (sdaftuar)\n+- #10133 `ab864d3` Clean up calculations of pcoinsTip memory usage (morcos)\n+\n+### P2P protocol and network code\n+- #9953/#10013 `d2548a4` Fix shutdown hang with >= 8 -addnodes set (TheBlueMatt)\n+- #10176 `30fa231` net: gracefully handle NodeId wrapping (theuni)\n+\n+### Build system\n+- #9973 `e9611d1` depends: fix zlib build on osx (theuni)\n+\n+### GUI\n+- #10060 `ddc2dd1` Ensure an item exists on the rpcconsole stack before adding (achow101)\n+\n+### Mining\n+- #9955/#10006 `569596c` Don't require segwit in getblocktemplate for segwit signalling or mining (sdaftuar)\n+- #9959/#10127 `b5c3440` Prevent slowdown in CreateNewBlock on large mempools (sdaftuar)\n+\n+### Tests and QA\n+- #10157 `55f641c` Fix the `mempool_packages.py` test (sdaftuar)\n+\n+### Miscellaneous\n+- #10037 `4d8e660` Trivial: Fix typo in help getrawtransaction RPC (keystrike)\n+- #10120 `e4c9a90` util: Work around (virtual) memory exhaustion on 32-bit w/ glibc (laanwj)\n+- #10130 `ecc5232` bitcoin-tx input verification (awemany, jnewbery)\n+\n+Credits\n+=======\n+\n+Thanks to everyone who directly contributed to this release:\n+\n+- Alex Morcos\n+- Andrew Chow\n+- Awemany\n+- Cory Fields\n+- Gregory Maxwell\n+- James Evans\n+- John Newbery\n+- MarcoFalke\n+- Matt Corallo\n+- Pieter Wuille\n+- practicalswift\n+- rawodb\n+- Suhas Daftuar\n+- Wladimir J. van der Laan\n+\n+As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).\n+"
      },
      {
        "sha": "32ef2a5755aa4e93d3da541f78f576a846b53db0",
        "filename": "share/genbuild.sh",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/share/genbuild.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/share/genbuild.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/genbuild.sh?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -17,9 +17,13 @@ else\n     exit 1\n fi\n \n+git_check_in_repo() {\n+    ! { git status --porcelain -uall --ignored \"$@\" 2>/dev/null || echo '??'; } | grep -q '?'\n+}\n+\n DESC=\"\"\n SUFFIX=\"\"\n-if [ -e \"$(which git 2>/dev/null)\" -a \"$(git rev-parse --is-inside-work-tree 2>/dev/null)\" = \"true\" ]; then\n+if [ \"${BITCOIN_GENBUILD_NO_GIT}\" != \"1\" -a -e \"$(which git 2>/dev/null)\" -a \"$(git rev-parse --is-inside-work-tree 2>/dev/null)\" = \"true\" ] && git_check_in_repo share/genbuild.sh; then\n     # clean 'dirty' status of touched files that haven't been modified\n     git diff >/dev/null 2>/dev/null \n "
      },
      {
        "sha": "ae2eb29c943ad447349eaa685d749b02ee16933f",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 15,
        "deletions": 2,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -95,6 +95,7 @@ BITCOIN_CORE_H = \\\n   compat/sanity.h \\\n   compressor.h \\\n   consensus/consensus.h \\\n+  consensus/tx_verify.h \\\n   core_io.h \\\n   core_memusage.h \\\n   cuckoocache.h \\\n@@ -116,6 +117,7 @@ BITCOIN_CORE_H = \\\n   netbase.h \\\n   netmessagemaker.h \\\n   noui.h \\\n+  policy/feerate.h \\\n   policy/fees.h \\\n   policy/policy.h \\\n   policy/rbf.h \\\n@@ -178,12 +180,13 @@ libbitcoin_util_a-clientversion.$(OBJEXT): obj/build.h\n libbitcoin_server_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(MINIUPNPC_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)\n libbitcoin_server_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_server_a_SOURCES = \\\n-  addrman.cpp \\\n   addrdb.cpp \\\n+  addrman.cpp \\\n   bloom.cpp \\\n   blockencodings.cpp \\\n   chain.cpp \\\n   checkpoints.cpp \\\n+  consensus/tx_verify.cpp \\\n   httprpc.cpp \\\n   httpserver.cpp \\\n   init.cpp \\\n@@ -246,6 +249,8 @@ crypto_libbitcoin_crypto_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n crypto_libbitcoin_crypto_a_SOURCES = \\\n   crypto/aes.cpp \\\n   crypto/aes.h \\\n+  crypto/chacha20.h \\\n+  crypto/chacha20.cpp \\\n   crypto/common.h \\\n   crypto/hmac_sha256.cpp \\\n   crypto/hmac_sha256.h \\\n@@ -299,7 +304,6 @@ libbitcoin_consensus_a_SOURCES = \\\n libbitcoin_common_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_common_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_common_a_SOURCES = \\\n-  amount.cpp \\\n   base58.cpp \\\n   chainparams.cpp \\\n   coins.cpp \\\n@@ -310,6 +314,7 @@ libbitcoin_common_a_SOURCES = \\\n   keystore.cpp \\\n   netaddress.cpp \\\n   netbase.cpp \\\n+  policy/feerate.cpp \\\n   protocol.cpp \\\n   scheduler.cpp \\\n   script/sign.cpp \\\n@@ -462,6 +467,14 @@ DISTCLEANFILES = obj/build.h\n \n EXTRA_DIST = $(CTAES_DIST)\n \n+\n+config/bitcoin-config.h: config/stamp-h1\n+\t@$(MAKE) -C $(top_builddir) $(subdir)/$(@)\n+config/stamp-h1: $(top_srcdir)/$(subdir)/config/bitcoin-config.h.in $(top_builddir)/config.status\n+\t$(AM_V_at)$(MAKE) -C $(top_builddir) $(subdir)/$(@)\n+$(top_srcdir)/$(subdir)/config/bitcoin-config.h.in:  $(am__configure_deps)\n+\t$(AM_V_at)$(MAKE) -C $(top_srcdir) $(subdir)/config/bitcoin-config.h.in\n+\n clean-local:\n \t-$(MAKE) -C secp256k1 clean\n \t-$(MAKE) -C univalue clean"
      },
      {
        "sha": "391b9ebdf6947f272f342ad7a83a3e8c99883121",
        "filename": "src/Makefile.qttest.include",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/Makefile.qttest.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/Makefile.qttest.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qttest.include?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -46,7 +46,8 @@ qt_test_test_bitcoin_qt_SOURCES = \\\n if ENABLE_WALLET\n qt_test_test_bitcoin_qt_SOURCES += \\\n   qt/test/paymentservertests.cpp \\\n-  qt/test/wallettests.cpp\n+  qt/test/wallettests.cpp \\\n+  wallet/test/wallet_test_fixture.cpp\n endif\n \n nodist_qt_test_test_bitcoin_qt_SOURCES = $(TEST_QT_MOC_CPP)"
      },
      {
        "sha": "ee1c11ff1f621b68d4c046c27ee8300c98fd936e",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -57,8 +57,8 @@ BITCOIN_TESTS =\\\n   test/policyestimator_tests.cpp \\\n   test/pow_tests.cpp \\\n   test/prevector_tests.cpp \\\n-  test/random_tests.cpp \\\n   test/raii_event_tests.cpp \\\n+  test/random_tests.cpp \\\n   test/reverselock_tests.cpp \\\n   test/rpc_tests.cpp \\\n   test/sanity_tests.cpp \\\n@@ -78,6 +78,7 @@ BITCOIN_TESTS =\\\n   test/testutil.cpp \\\n   test/testutil.h \\\n   test/timedata_tests.cpp \\\n+  test/torcontrol_tests.cpp \\\n   test/transaction_tests.cpp \\\n   test/txvalidationcache_tests.cpp \\\n   test/versionbits_tests.cpp \\"
      },
      {
        "sha": "4a408b9beb1913e06cc9fc570319431838e86533",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -351,8 +351,8 @@ CAddrInfo CAddrMan::Select_(bool newOnly)\n             int nKBucket = RandomInt(ADDRMAN_TRIED_BUCKET_COUNT);\n             int nKBucketPos = RandomInt(ADDRMAN_BUCKET_SIZE);\n             while (vvTried[nKBucket][nKBucketPos] == -1) {\n-                nKBucket = (nKBucket + insecure_rand.rand32()) % ADDRMAN_TRIED_BUCKET_COUNT;\n-                nKBucketPos = (nKBucketPos + insecure_rand.rand32()) % ADDRMAN_BUCKET_SIZE;\n+                nKBucket = (nKBucket + insecure_rand.randbits(ADDRMAN_TRIED_BUCKET_COUNT_LOG2)) % ADDRMAN_TRIED_BUCKET_COUNT;\n+                nKBucketPos = (nKBucketPos + insecure_rand.randbits(ADDRMAN_BUCKET_SIZE_LOG2)) % ADDRMAN_BUCKET_SIZE;\n             }\n             int nId = vvTried[nKBucket][nKBucketPos];\n             assert(mapInfo.count(nId) == 1);\n@@ -368,8 +368,8 @@ CAddrInfo CAddrMan::Select_(bool newOnly)\n             int nUBucket = RandomInt(ADDRMAN_NEW_BUCKET_COUNT);\n             int nUBucketPos = RandomInt(ADDRMAN_BUCKET_SIZE);\n             while (vvNew[nUBucket][nUBucketPos] == -1) {\n-                nUBucket = (nUBucket + insecure_rand.rand32()) % ADDRMAN_NEW_BUCKET_COUNT;\n-                nUBucketPos = (nUBucketPos + insecure_rand.rand32()) % ADDRMAN_BUCKET_SIZE;\n+                nUBucket = (nUBucket + insecure_rand.randbits(ADDRMAN_NEW_BUCKET_COUNT_LOG2)) % ADDRMAN_NEW_BUCKET_COUNT;\n+                nUBucketPos = (nUBucketPos + insecure_rand.randbits(ADDRMAN_BUCKET_SIZE_LOG2)) % ADDRMAN_BUCKET_SIZE;\n             }\n             int nId = vvNew[nUBucket][nUBucketPos];\n             assert(mapInfo.count(nId) == 1);"
      },
      {
        "sha": "70d907488f3d92bdf432d5091aa68e7714887193",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 8,
        "deletions": 3,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -136,13 +136,13 @@ class CAddrInfo : public CAddress\n  */\n \n //! total number of buckets for tried addresses\n-#define ADDRMAN_TRIED_BUCKET_COUNT 256\n+#define ADDRMAN_TRIED_BUCKET_COUNT_LOG2 8\n \n //! total number of buckets for new addresses\n-#define ADDRMAN_NEW_BUCKET_COUNT 1024\n+#define ADDRMAN_NEW_BUCKET_COUNT_LOG2 10\n \n //! maximum allowed number of entries in buckets for new and tried addresses\n-#define ADDRMAN_BUCKET_SIZE 64\n+#define ADDRMAN_BUCKET_SIZE_LOG2 6\n \n //! over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread\n #define ADDRMAN_TRIED_BUCKETS_PER_GROUP 8\n@@ -171,6 +171,11 @@ class CAddrInfo : public CAddress\n //! the maximum number of nodes to return in a getaddr call\n #define ADDRMAN_GETADDR_MAX 2500\n \n+//! Convenience\n+#define ADDRMAN_TRIED_BUCKET_COUNT (1 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2)\n+#define ADDRMAN_NEW_BUCKET_COUNT (1 << ADDRMAN_NEW_BUCKET_COUNT_LOG2)\n+#define ADDRMAN_BUCKET_SIZE (1 << ADDRMAN_BUCKET_SIZE_LOG2)\n+\n /** \n  * Stochastical (IP) address manager \n  */"
      },
      {
        "sha": "2bd367cba29fa5e802635786607272b8c718a553",
        "filename": "src/amount.h",
        "status": "modified",
        "additions": 1,
        "deletions": 44,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/amount.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/amount.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/amount.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -6,19 +6,14 @@\n #ifndef BITCOIN_AMOUNT_H\n #define BITCOIN_AMOUNT_H\n \n-#include \"serialize.h\"\n-\n-#include <stdlib.h>\n-#include <string>\n+#include <stdint.h>\n \n /** Amount in satoshis (Can be negative) */\n typedef int64_t CAmount;\n \n static const CAmount COIN = 100000000;\n static const CAmount CENT = 1000000;\n \n-extern const std::string CURRENCY_UNIT;\n-\n /** No amount larger than this (in satoshi) is valid.\n  *\n  * Note that this constant is *not* the total money supply, which in Bitcoin\n@@ -31,42 +26,4 @@ extern const std::string CURRENCY_UNIT;\n static const CAmount MAX_MONEY = 21000000 * COIN;\n inline bool MoneyRange(const CAmount& nValue) { return (nValue >= 0 && nValue <= MAX_MONEY); }\n \n-/**\n- * Fee rate in satoshis per kilobyte: CAmount / kB\n- */\n-class CFeeRate\n-{\n-private:\n-    CAmount nSatoshisPerK; // unit is satoshis-per-1,000-bytes\n-public:\n-    /** Fee rate of 0 satoshis per kB */\n-    CFeeRate() : nSatoshisPerK(0) { }\n-    explicit CFeeRate(const CAmount& _nSatoshisPerK): nSatoshisPerK(_nSatoshisPerK) { }\n-    /** Constructor for a fee rate in satoshis per kB. The size in bytes must not exceed (2^63 - 1)*/\n-    CFeeRate(const CAmount& nFeePaid, size_t nBytes);\n-    CFeeRate(const CFeeRate& other) { nSatoshisPerK = other.nSatoshisPerK; }\n-    /**\n-     * Return the fee in satoshis for the given size in bytes.\n-     */\n-    CAmount GetFee(size_t nBytes) const;\n-    /**\n-     * Return the fee in satoshis for a size of 1000 bytes\n-     */\n-    CAmount GetFeePerK() const { return GetFee(1000); }\n-    friend bool operator<(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK < b.nSatoshisPerK; }\n-    friend bool operator>(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK > b.nSatoshisPerK; }\n-    friend bool operator==(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK == b.nSatoshisPerK; }\n-    friend bool operator<=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK <= b.nSatoshisPerK; }\n-    friend bool operator>=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK >= b.nSatoshisPerK; }\n-    CFeeRate& operator+=(const CFeeRate& a) { nSatoshisPerK += a.nSatoshisPerK; return *this; }\n-    std::string ToString() const;\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n-        READWRITE(nSatoshisPerK);\n-    }\n-};\n-\n #endif //  BITCOIN_AMOUNT_H"
      },
      {
        "sha": "33631d2d150545196a1a559e5b40a140b8f00c9e",
        "filename": "src/bench/bench.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/bench/bench.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/bench/bench.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -5,6 +5,7 @@\n #include \"bench.h\"\n #include \"perf.h\"\n \n+#include <assert.h>\n #include <iostream>\n #include <iomanip>\n #include <sys/time.h>"
      },
      {
        "sha": "1f36f2a4bca1b07e2577aebb8392463aabe0a2b4",
        "filename": "src/bench/bench.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/bench/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/bench/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -5,10 +5,11 @@\n #ifndef BITCOIN_BENCH_BENCH_H\n #define BITCOIN_BENCH_BENCH_H\n \n+#include <functional>\n+#include <limits>\n #include <map>\n #include <string>\n \n-#include <boost/function.hpp>\n #include <boost/preprocessor/cat.hpp>\n #include <boost/preprocessor/stringize.hpp>\n \n@@ -59,7 +60,7 @@ namespace benchmark {\n         bool KeepRunning();\n     };\n \n-    typedef boost::function<void(State&)> BenchFunction;\n+    typedef std::function<void(State&)> BenchFunction;\n \n     class BenchRunner\n     {"
      },
      {
        "sha": "195388839eaacb5dc1bf91b77eebb0e6d9f19e33",
        "filename": "src/bench/checkblock.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/bench/checkblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/bench/checkblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkblock.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -40,15 +40,15 @@ static void DeserializeAndCheckBlockTest(benchmark::State& state)\n     char a = '\\0';\n     stream.write(&a, 1); // Prevent compaction\n \n-    Consensus::Params params = Params(CBaseChainParams::MAIN).GetConsensus();\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n \n     while (state.KeepRunning()) {\n         CBlock block; // Note that CBlock caches its checked state, so we need to recreate it here\n         stream >> block;\n         assert(stream.Rewind(sizeof(block_bench::block413567)));\n \n         CValidationState validationState;\n-        assert(CheckBlock(block, validationState, params));\n+        assert(CheckBlock(block, validationState, chainParams->GetConsensus()));\n     }\n }\n "
      },
      {
        "sha": "88a2a570f93d2a83aae94700ea7b854426f54c9e",
        "filename": "src/bench/checkqueue.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/bench/checkqueue.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/bench/checkqueue.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkqueue.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -68,7 +68,7 @@ static void CCheckQueueSpeedPrevectorJob(benchmark::State& state)\n         PrevectorJob(){\n         }\n         PrevectorJob(FastRandomContext& insecure_rand){\n-            p.resize(insecure_rand.rand32() % (PREVECTOR_SIZE*2));\n+            p.resize(insecure_rand.randrange(PREVECTOR_SIZE*2));\n         }\n         bool operator()()\n         {"
      },
      {
        "sha": "2914a36c7b92ade59e0fa9c2208647155c762cb5",
        "filename": "src/bench/crypto_hash.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 0,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/bench/crypto_hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/bench/crypto_hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/crypto_hash.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -7,6 +7,7 @@\n #include \"bench.h\"\n #include \"bloom.h\"\n #include \"hash.h\"\n+#include \"random.h\"\n #include \"uint256.h\"\n #include \"utiltime.h\"\n #include \"crypto/ripemd160.h\"\n@@ -69,10 +70,34 @@ static void SipHash_32b(benchmark::State& state)\n     }\n }\n \n+static void FastRandom_32bit(benchmark::State& state)\n+{\n+    FastRandomContext rng(true);\n+    uint32_t x = 0;\n+    while (state.KeepRunning()) {\n+        for (int i = 0; i < 1000000; i++) {\n+            x += rng.rand32();\n+        }\n+    }\n+}\n+\n+static void FastRandom_1bit(benchmark::State& state)\n+{\n+    FastRandomContext rng(true);\n+    uint32_t x = 0;\n+    while (state.KeepRunning()) {\n+        for (int i = 0; i < 1000000; i++) {\n+            x += rng.randbool();\n+        }\n+    }\n+}\n+\n BENCHMARK(RIPEMD160);\n BENCHMARK(SHA1);\n BENCHMARK(SHA256);\n BENCHMARK(SHA512);\n \n BENCHMARK(SHA256_32b);\n BENCHMARK(SipHash_32b);\n+BENCHMARK(FastRandom_32bit);\n+BENCHMARK(FastRandom_1bit);"
      },
      {
        "sha": "885b787b4da09815fd6ba79038608f0b9e8c0281",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -30,6 +30,8 @@ static const int CONTINUE_EXECUTION=-1;\n \n std::string HelpMessageCli()\n {\n+    const auto defaultBaseParams = CreateBaseChainParams(CBaseChainParams::MAIN);\n+    const auto testnetBaseParams = CreateBaseChainParams(CBaseChainParams::TESTNET);\n     std::string strUsage;\n     strUsage += HelpMessageGroup(_(\"Options:\"));\n     strUsage += HelpMessageOpt(\"-?\", _(\"This help message\"));\n@@ -38,7 +40,7 @@ std::string HelpMessageCli()\n     AppendParamsHelpMessages(strUsage);\n     strUsage += HelpMessageOpt(\"-named\", strprintf(_(\"Pass named instead of positional arguments (default: %s)\"), DEFAULT_NAMED));\n     strUsage += HelpMessageOpt(\"-rpcconnect=<ip>\", strprintf(_(\"Send commands to node running on <ip> (default: %s)\"), DEFAULT_RPCCONNECT));\n-    strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\"Connect to JSON-RPC on <port> (default: %u or testnet: %u)\"), BaseParams(CBaseChainParams::MAIN).RPCPort(), BaseParams(CBaseChainParams::TESTNET).RPCPort()));\n+    strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\"Connect to JSON-RPC on <port> (default: %u or testnet: %u)\"), defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()));\n     strUsage += HelpMessageOpt(\"-rpcwait\", _(\"Wait for RPC server to start\"));\n     strUsage += HelpMessageOpt(\"-rpcuser=<user>\", _(\"Username for JSON-RPC connections\"));\n     strUsage += HelpMessageOpt(\"-rpcpassword=<pw>\", _(\"Password for JSON-RPC connections\"));"
      },
      {
        "sha": "45738b5df83f60be4bd7aa5914e349d0f9e11768",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -657,11 +657,13 @@ static void MutateTx(CMutableTransaction& tx, const std::string& command,\n         MutateTxDelOutput(tx, commandVal);\n     else if (command == \"outaddr\")\n         MutateTxAddOutAddr(tx, commandVal);\n-    else if (command == \"outpubkey\")\n+    else if (command == \"outpubkey\") {\n+        if (!ecc) { ecc.reset(new Secp256k1Init()); }\n         MutateTxAddOutPubKey(tx, commandVal);\n-    else if (command == \"outmultisig\")\n+    } else if (command == \"outmultisig\") {\n+        if (!ecc) { ecc.reset(new Secp256k1Init()); }\n         MutateTxAddOutMultiSig(tx, commandVal);\n-    else if (command == \"outscript\")\n+    } else if (command == \"outscript\")\n         MutateTxAddOutScript(tx, commandVal);\n     else if (command == \"outdata\")\n         MutateTxAddOutData(tx, commandVal);"
      },
      {
        "sha": "7ed982c984ce906f53cda4ac39855265dc838080",
        "filename": "src/bloom.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -19,7 +19,7 @@\n #define LN2SQUARED 0.4804530139182014246671025263266649717305529515945455\n #define LN2 0.6931471805599453094172321214581765680755001343602552\n \n-CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweakIn, unsigned char nFlagsIn) :\n+CBloomFilter::CBloomFilter(const unsigned int nElements, const double nFPRate, const unsigned int nTweakIn, unsigned char nFlagsIn) :\n     /**\n      * The ideal size for a bloom filter with a given number of elements and false positive rate is:\n      * - nElements * log(fp rate) / ln(2)^2\n@@ -40,7 +40,7 @@ CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int\n }\n \n // Private constructor used by CRollingBloomFilter\n-CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweakIn) :\n+CBloomFilter::CBloomFilter(const unsigned int nElements, const double nFPRate, const unsigned int nTweakIn) :\n     vData((unsigned int)(-1  / LN2SQUARED * nElements * log(nFPRate)) / 8),\n     isFull(false),\n     isEmpty(true),\n@@ -120,7 +120,7 @@ void CBloomFilter::clear()\n     isEmpty = true;\n }\n \n-void CBloomFilter::reset(unsigned int nNewTweak)\n+void CBloomFilter::reset(const unsigned int nNewTweak)\n {\n     clear();\n     nTweak = nNewTweak;\n@@ -214,7 +214,7 @@ void CBloomFilter::UpdateEmptyFull()\n     isEmpty = empty;\n }\n \n-CRollingBloomFilter::CRollingBloomFilter(unsigned int nElements, double fpRate)\n+CRollingBloomFilter::CRollingBloomFilter(const unsigned int nElements, const double fpRate)\n {\n     double logFpRate = log(fpRate);\n     /* The optimal number of hash functions is log(fpRate) / log(0.5), but"
      },
      {
        "sha": "7ca96822396b909ec076e7f2f562b7d0f1766133",
        "filename": "src/bloom.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/bloom.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/bloom.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -54,7 +54,7 @@ class CBloomFilter\n     unsigned int Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const;\n \n     // Private constructor for CRollingBloomFilter, no restrictions on size\n-    CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweak);\n+    CBloomFilter(const unsigned int nElements, const double nFPRate, const unsigned int nTweak);\n     friend class CRollingBloomFilter;\n \n public:\n@@ -67,7 +67,7 @@ class CBloomFilter\n      * It should generally always be a random value (and is largely only exposed for unit testing)\n      * nFlags should be one of the BLOOM_UPDATE_* enums (not _MASK)\n      */\n-    CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweak, unsigned char nFlagsIn);\n+    CBloomFilter(const unsigned int nElements, const double nFPRate, const unsigned int nTweak, unsigned char nFlagsIn);\n     CBloomFilter() : isFull(true), isEmpty(false), nHashFuncs(0), nTweak(0), nFlags(0) {}\n \n     ADD_SERIALIZE_METHODS;\n@@ -89,7 +89,7 @@ class CBloomFilter\n     bool contains(const uint256& hash) const;\n \n     void clear();\n-    void reset(unsigned int nNewTweak);\n+    void reset(const unsigned int nNewTweak);\n \n     //! True if the size is <= MAX_BLOOM_FILTER_SIZE and the number of hash functions is <= MAX_HASH_FUNCS\n     //! (catch a filter which was just deserialized which was too big)\n@@ -122,7 +122,7 @@ class CRollingBloomFilter\n     // A random bloom filter calls GetRand() at creation time.\n     // Don't create global CRollingBloomFilter objects, as they may be\n     // constructed before the randomizer is properly initialized.\n-    CRollingBloomFilter(unsigned int nElements, double nFPRate);\n+    CRollingBloomFilter(const unsigned int nElements, const double nFPRate);\n \n     void insert(const std::vector<unsigned char>& vKey);\n     void insert(const uint256& hash);"
      },
      {
        "sha": "5055fb3e0a33aabac38d7e48111202cac40b97f2",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 21,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -55,6 +55,12 @@ static CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, uint32_t nBits\n     return CreateGenesisBlock(pszTimestamp, genesisOutputScript, nTime, nNonce, nBits, nVersion, genesisReward);\n }\n \n+void CChainParams::UpdateBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n+{\n+    consensus.vDeployments[d].nStartTime = nStartTime;\n+    consensus.vDeployments[d].nTimeout = nTimeout;\n+}\n+\n /**\n  * Main network\n  */\n@@ -165,7 +171,6 @@ class CMainParams : public CChainParams {\n         };\n     }\n };\n-static CMainParams mainParams;\n \n /**\n  * Testnet (v3)\n@@ -253,7 +258,6 @@ class CTestNetParams : public CChainParams {\n \n     }\n };\n-static CTestNetParams testNetParams;\n \n /**\n  * Regression test\n@@ -326,42 +330,34 @@ class CRegTestParams : public CChainParams {\n         base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x35)(0x87)(0xCF).convert_to_container<std::vector<unsigned char> >();\n         base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x35)(0x83)(0x94).convert_to_container<std::vector<unsigned char> >();\n     }\n-\n-    void UpdateBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n-    {\n-        consensus.vDeployments[d].nStartTime = nStartTime;\n-        consensus.vDeployments[d].nTimeout = nTimeout;\n-    }\n };\n-static CRegTestParams regTestParams;\n \n-static CChainParams *pCurrentParams = 0;\n+static std::unique_ptr<CChainParams> globalChainParams;\n \n const CChainParams &Params() {\n-    assert(pCurrentParams);\n-    return *pCurrentParams;\n+    assert(globalChainParams);\n+    return *globalChainParams;\n }\n \n-CChainParams& Params(const std::string& chain)\n+std::unique_ptr<CChainParams> CreateChainParams(const std::string& chain)\n {\n     if (chain == CBaseChainParams::MAIN)\n-            return mainParams;\n+        return std::unique_ptr<CChainParams>(new CMainParams());\n     else if (chain == CBaseChainParams::TESTNET)\n-            return testNetParams;\n+        return std::unique_ptr<CChainParams>(new CTestNetParams());\n     else if (chain == CBaseChainParams::REGTEST)\n-            return regTestParams;\n-    else\n-        throw std::runtime_error(strprintf(\"%s: Unknown chain %s.\", __func__, chain));\n+        return std::unique_ptr<CChainParams>(new CRegTestParams());\n+    throw std::runtime_error(strprintf(\"%s: Unknown chain %s.\", __func__, chain));\n }\n \n void SelectParams(const std::string& network)\n {\n     SelectBaseParams(network);\n-    pCurrentParams = &Params(network);\n+    globalChainParams = CreateChainParams(network);\n }\n \n-void UpdateRegtestBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n+void UpdateBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n {\n-    regTestParams.UpdateBIP9Parameters(d, nStartTime, nTimeout);\n+    globalChainParams->UpdateBIP9Parameters(d, nStartTime, nTimeout);\n }\n  "
      },
      {
        "sha": "e5312d1080b3ce183a7ad2799a39e206ec5abf72",
        "filename": "src/chainparams.h",
        "status": "modified",
        "additions": 10,
        "deletions": 6,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/chainparams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/chainparams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -11,6 +11,7 @@\n #include \"primitives/block.h\"\n #include \"protocol.h\"\n \n+#include <memory>\n #include <vector>\n \n struct CDNSSeedData {\n@@ -75,6 +76,7 @@ class CChainParams\n     const std::vector<SeedSpec6>& FixedSeeds() const { return vFixedSeeds; }\n     const CCheckpointData& Checkpoints() const { return checkpointData; }\n     const ChainTxData& TxData() const { return chainTxData; }\n+    void UpdateBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);\n protected:\n     CChainParams() {}\n \n@@ -95,15 +97,17 @@ class CChainParams\n };\n \n /**\n- * Return the currently selected parameters. This won't change after app\n- * startup, except for unit tests.\n+ * Creates and returns a std::unique_ptr<CChainParams> of the chosen chain.\n+ * @returns a CChainParams* of the chosen chain.\n+ * @throws a std::runtime_error if the chain is not supported.\n  */\n-const CChainParams &Params();\n+std::unique_ptr<CChainParams> CreateChainParams(const std::string& chain);\n \n /**\n- * @returns CChainParams for the given BIP70 chain name.\n+ * Return the currently selected parameters. This won't change after app\n+ * startup, except for unit tests.\n  */\n-CChainParams& Params(const std::string& chain);\n+const CChainParams &Params();\n \n /**\n  * Sets the params returned by Params() to those for the given BIP70 chain name.\n@@ -114,6 +118,6 @@ void SelectParams(const std::string& chain);\n /**\n  * Allows modifying the BIP9 regtest parameters.\n  */\n-void UpdateRegtestBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);\n+void UpdateBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);\n \n #endif // BITCOIN_CHAINPARAMS_H"
      },
      {
        "sha": "43c9a13c5468b8e01e1f25f5d9b91d6aa8d8a392",
        "filename": "src/chainparamsbase.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 16,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/chainparamsbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/chainparamsbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -35,7 +35,6 @@ class CBaseMainParams : public CBaseChainParams\n         nRPCPort = 8332;\n     }\n };\n-static CBaseMainParams mainParams;\n \n /**\n  * Testnet (v3)\n@@ -49,7 +48,6 @@ class CBaseTestNetParams : public CBaseChainParams\n         strDataDir = \"testnet3\";\n     }\n };\n-static CBaseTestNetParams testNetParams;\n \n /*\n  * Regression test\n@@ -63,31 +61,30 @@ class CBaseRegTestParams : public CBaseChainParams\n         strDataDir = \"regtest\";\n     }\n };\n-static CBaseRegTestParams regTestParams;\n \n-static CBaseChainParams* pCurrentBaseParams = 0;\n+static std::unique_ptr<CBaseChainParams> globalChainBaseParams;\n \n const CBaseChainParams& BaseParams()\n {\n-    assert(pCurrentBaseParams);\n-    return *pCurrentBaseParams;\n+    assert(globalChainBaseParams);\n+    return *globalChainBaseParams;\n }\n \n-CBaseChainParams& BaseParams(const std::string& chain)\n+std::unique_ptr<CBaseChainParams> CreateBaseChainParams(const std::string& chain)\n {\n     if (chain == CBaseChainParams::MAIN)\n-        return mainParams;\n+        return std::unique_ptr<CBaseChainParams>(new CBaseMainParams());\n     else if (chain == CBaseChainParams::TESTNET)\n-        return testNetParams;\n+        return std::unique_ptr<CBaseChainParams>(new CBaseTestNetParams());\n     else if (chain == CBaseChainParams::REGTEST)\n-        return regTestParams;\n+        return std::unique_ptr<CBaseChainParams>(new CBaseRegTestParams());\n     else\n         throw std::runtime_error(strprintf(\"%s: Unknown chain %s.\", __func__, chain));\n }\n \n void SelectBaseParams(const std::string& chain)\n {\n-    pCurrentBaseParams = &BaseParams(chain);\n+    globalChainBaseParams = CreateBaseChainParams(chain);\n }\n \n std::string ChainNameFromCommandLine()\n@@ -103,8 +100,3 @@ std::string ChainNameFromCommandLine()\n         return CBaseChainParams::TESTNET;\n     return CBaseChainParams::MAIN;\n }\n-\n-bool AreBaseParamsConfigured()\n-{\n-    return pCurrentBaseParams != NULL;\n-}"
      },
      {
        "sha": "fc101f5b774c23a483c26dab115ac2675514ec11",
        "filename": "src/chainparamsbase.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/chainparamsbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/chainparamsbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -5,6 +5,7 @@\n #ifndef BITCOIN_CHAINPARAMSBASE_H\n #define BITCOIN_CHAINPARAMSBASE_H\n \n+#include <memory>\n #include <string>\n #include <vector>\n \n@@ -30,6 +31,13 @@ class CBaseChainParams\n     std::string strDataDir;\n };\n \n+/**\n+ * Creates and returns a std::unique_ptr<CBaseChainParams> of the chosen chain.\n+ * @returns a CBaseChainParams* of the chosen chain.\n+ * @throws a std::runtime_error if the chain is not supported.\n+ */\n+std::unique_ptr<CBaseChainParams> CreateBaseChainParams(const std::string& chain);\n+\n /**\n  * Append the help messages for the chainparams options to the\n  * parameter string.\n@@ -42,8 +50,6 @@ void AppendParamsHelpMessages(std::string& strUsage, bool debugHelp=true);\n  */\n const CBaseChainParams& BaseParams();\n \n-CBaseChainParams& BaseParams(const std::string& chain);\n-\n /** Sets the params returned by Params() to those for the given network. */\n void SelectBaseParams(const std::string& chain);\n \n@@ -53,10 +59,4 @@ void SelectBaseParams(const std::string& chain);\n  */\n std::string ChainNameFromCommandLine();\n \n-/**\n- * Return true if SelectBaseParamsFromCommandLine() has been called to select\n- * a network.\n- */\n-bool AreBaseParamsConfigured();\n-\n #endif // BITCOIN_CHAINPARAMSBASE_H"
      },
      {
        "sha": "63c104c02a114a4fa350de9ce6a58675a8b224db",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -5,6 +5,8 @@\n #ifndef BITCOIN_CHECKQUEUE_H\n #define BITCOIN_CHECKQUEUE_H\n \n+#include \"sync.h\"\n+\n #include <algorithm>\n #include <vector>\n "
      },
      {
        "sha": "065bae56e9e47ec1eba7c8911a6b4402610e470e",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -6,6 +6,7 @@\n #ifndef BITCOIN_COINS_H\n #define BITCOIN_COINS_H\n \n+#include \"primitives/transaction.h\"\n #include \"compressor.h\"\n #include \"core_memusage.h\"\n #include \"hash.h\"\n@@ -17,7 +18,7 @@\n #include <stdint.h>\n \n #include <boost/foreach.hpp>\n-#include <boost/unordered_map.hpp>\n+#include <unordered_map>\n \n /** \n  * Pruned version of CTransaction: only retains metadata and unspent transaction outputs\n@@ -279,7 +280,7 @@ struct CCoinsCacheEntry\n     CCoinsCacheEntry() : coins(), flags(0) {}\n };\n \n-typedef boost::unordered_map<uint256, CCoinsCacheEntry, SaltedTxidHasher> CCoinsMap;\n+typedef std::unordered_map<uint256, CCoinsCacheEntry, SaltedTxidHasher> CCoinsMap;\n \n /** Cursor for iterating over CoinsView state */\n class CCoinsViewCursor"
      },
      {
        "sha": "043f4cf95c2619c992519529af4799471eeeda94",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "added",
        "additions": 246,
        "deletions": 0,
        "changes": 246,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -0,0 +1,246 @@\n+// Copyright (c) 2017-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"tx_verify.h\"\n+\n+#include \"consensus.h\"\n+#include \"primitives/transaction.h\"\n+#include \"script/interpreter.h\"\n+#include \"validation.h\"\n+\n+// TODO remove the following dependencies\n+#include \"chain.h\"\n+#include \"coins.h\"\n+#include \"utilmoneystr.h\"\n+ \n+bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime)\n+{\n+    if (tx.nLockTime == 0)\n+        return true;\n+    if ((int64_t)tx.nLockTime < ((int64_t)tx.nLockTime < LOCKTIME_THRESHOLD ? (int64_t)nBlockHeight : nBlockTime))\n+        return true;\n+    for (const auto& txin : tx.vin) {\n+        if (!(txin.nSequence == CTxIn::SEQUENCE_FINAL))\n+            return false;\n+    }\n+    return true;\n+}\n+\n+std::pair<int, int64_t> CalculateSequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block)\n+{\n+    assert(prevHeights->size() == tx.vin.size());\n+\n+    // Will be set to the equivalent height- and time-based nLockTime\n+    // values that would be necessary to satisfy all relative lock-\n+    // time constraints given our view of block chain history.\n+    // The semantics of nLockTime are the last invalid height/time, so\n+    // use -1 to have the effect of any height or time being valid.\n+    int nMinHeight = -1;\n+    int64_t nMinTime = -1;\n+\n+    // tx.nVersion is signed integer so requires cast to unsigned otherwise\n+    // we would be doing a signed comparison and half the range of nVersion\n+    // wouldn't support BIP 68.\n+    bool fEnforceBIP68 = static_cast<uint32_t>(tx.nVersion) >= 2\n+                      && flags & LOCKTIME_VERIFY_SEQUENCE;\n+\n+    // Do not enforce sequence numbers as a relative lock time\n+    // unless we have been instructed to\n+    if (!fEnforceBIP68) {\n+        return std::make_pair(nMinHeight, nMinTime);\n+    }\n+\n+    for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n+        const CTxIn& txin = tx.vin[txinIndex];\n+\n+        // Sequence numbers with the most significant bit set are not\n+        // treated as relative lock-times, nor are they given any\n+        // consensus-enforced meaning at this point.\n+        if (txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n+            // The height of this input is not relevant for sequence locks\n+            (*prevHeights)[txinIndex] = 0;\n+            continue;\n+        }\n+\n+        int nCoinHeight = (*prevHeights)[txinIndex];\n+\n+        if (txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG) {\n+            int64_t nCoinTime = block.GetAncestor(std::max(nCoinHeight-1, 0))->GetMedianTimePast();\n+            // NOTE: Subtract 1 to maintain nLockTime semantics\n+            // BIP 68 relative lock times have the semantics of calculating\n+            // the first block or time at which the transaction would be\n+            // valid. When calculating the effective block time or height\n+            // for the entire transaction, we switch to using the\n+            // semantics of nLockTime which is the last invalid block\n+            // time or height.  Thus we subtract 1 from the calculated\n+            // time or height.\n+\n+            // Time-based relative lock-times are measured from the\n+            // smallest allowed timestamp of the block containing the\n+            // txout being spent, which is the median time past of the\n+            // block prior.\n+            nMinTime = std::max(nMinTime, nCoinTime + (int64_t)((txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_MASK) << CTxIn::SEQUENCE_LOCKTIME_GRANULARITY) - 1);\n+        } else {\n+            nMinHeight = std::max(nMinHeight, nCoinHeight + (int)(txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_MASK) - 1);\n+        }\n+    }\n+\n+    return std::make_pair(nMinHeight, nMinTime);\n+}\n+\n+bool EvaluateSequenceLocks(const CBlockIndex& block, std::pair<int, int64_t> lockPair)\n+{\n+    assert(block.pprev);\n+    int64_t nBlockTime = block.pprev->GetMedianTimePast();\n+    if (lockPair.first >= block.nHeight || lockPair.second >= nBlockTime)\n+        return false;\n+\n+    return true;\n+}\n+\n+bool SequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block)\n+{\n+    return EvaluateSequenceLocks(block, CalculateSequenceLocks(tx, flags, prevHeights, block));\n+}\n+\n+unsigned int GetLegacySigOpCount(const CTransaction& tx)\n+{\n+    unsigned int nSigOps = 0;\n+    for (const auto& txin : tx.vin)\n+    {\n+        nSigOps += txin.scriptSig.GetSigOpCount(false);\n+    }\n+    for (const auto& txout : tx.vout)\n+    {\n+        nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n+    }\n+    return nSigOps;\n+}\n+\n+unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& inputs)\n+{\n+    if (tx.IsCoinBase())\n+        return 0;\n+\n+    unsigned int nSigOps = 0;\n+    for (unsigned int i = 0; i < tx.vin.size(); i++)\n+    {\n+        const CTxOut &prevout = inputs.GetOutputFor(tx.vin[i]);\n+        if (prevout.scriptPubKey.IsPayToScriptHash())\n+            nSigOps += prevout.scriptPubKey.GetSigOpCount(tx.vin[i].scriptSig);\n+    }\n+    return nSigOps;\n+}\n+\n+int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, int flags)\n+{\n+    int64_t nSigOps = GetLegacySigOpCount(tx) * WITNESS_SCALE_FACTOR;\n+\n+    if (tx.IsCoinBase())\n+        return nSigOps;\n+\n+    if (flags & SCRIPT_VERIFY_P2SH) {\n+        nSigOps += GetP2SHSigOpCount(tx, inputs) * WITNESS_SCALE_FACTOR;\n+    }\n+\n+    for (unsigned int i = 0; i < tx.vin.size(); i++)\n+    {\n+        const CTxOut &prevout = inputs.GetOutputFor(tx.vin[i]);\n+        nSigOps += CountWitnessSigOps(tx.vin[i].scriptSig, prevout.scriptPubKey, &tx.vin[i].scriptWitness, flags);\n+    }\n+    return nSigOps;\n+}\n+\n+bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fCheckDuplicateInputs)\n+{\n+    // Basic checks that don't depend on any context\n+    if (tx.vin.empty())\n+        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n+    if (tx.vout.empty())\n+        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n+    // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)\n+    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) > MAX_BLOCK_BASE_SIZE)\n+        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-oversize\");\n+\n+    // Check for negative or overflow output values\n+    CAmount nValueOut = 0;\n+    for (const auto& txout : tx.vout)\n+    {\n+        if (txout.nValue < 0)\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-negative\");\n+        if (txout.nValue > MAX_MONEY)\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n+        nValueOut += txout.nValue;\n+        if (!MoneyRange(nValueOut))\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n+    }\n+\n+    // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n+    if (fCheckDuplicateInputs) {\n+        std::set<COutPoint> vInOutPoints;\n+        for (const auto& txin : tx.vin)\n+        {\n+            if (!vInOutPoints.insert(txin.prevout).second)\n+                return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n+        }\n+    }\n+\n+    if (tx.IsCoinBase())\n+    {\n+        if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-length\");\n+    }\n+    else\n+    {\n+        for (const auto& txin : tx.vin)\n+            if (txin.prevout.IsNull())\n+                return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n+    }\n+\n+    return true;\n+}\n+\n+bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoinsViewCache& inputs, int nSpendHeight)\n+{\n+        // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n+        // for an attacker to attempt to split the network.\n+        if (!inputs.HaveInputs(tx))\n+            return state.Invalid(false, 0, \"\", \"Inputs unavailable\");\n+\n+        CAmount nValueIn = 0;\n+        CAmount nFees = 0;\n+        for (unsigned int i = 0; i < tx.vin.size(); i++)\n+        {\n+            const COutPoint &prevout = tx.vin[i].prevout;\n+            const CCoins *coins = inputs.AccessCoins(prevout.hash);\n+            assert(coins);\n+\n+            // If prev is coinbase, check that it's matured\n+            if (coins->IsCoinBase()) {\n+                if (nSpendHeight - coins->nHeight < COINBASE_MATURITY)\n+                    return state.Invalid(false,\n+                        REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n+                        strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coins->nHeight));\n+            }\n+\n+            // Check for negative or overflow input values\n+            nValueIn += coins->vout[prevout.n].nValue;\n+            if (!MoneyRange(coins->vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n+                return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n+\n+        }\n+\n+        if (nValueIn < tx.GetValueOut())\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-in-belowout\", false,\n+                strprintf(\"value in (%s) < value out (%s)\", FormatMoney(nValueIn), FormatMoney(tx.GetValueOut())));\n+\n+        // Tally transaction fees\n+        CAmount nTxFee = nValueIn - tx.GetValueOut();\n+        if (nTxFee < 0)\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-fee-negative\");\n+        nFees += nTxFee;\n+        if (!MoneyRange(nFees))\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n+    return true;\n+}"
      },
      {
        "sha": "d46d3294ca25039e8ebdaf1d0cd4d73abebb3597",
        "filename": "src/consensus/tx_verify.h",
        "status": "added",
        "additions": 78,
        "deletions": 0,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/consensus/tx_verify.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/consensus/tx_verify.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -0,0 +1,78 @@\n+// Copyright (c) 2017-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CONSENSUS_TX_VERIFY_H\n+#define BITCOIN_CONSENSUS_TX_VERIFY_H\n+\n+#include <stdint.h>\n+#include <vector>\n+\n+class CBlockIndex;\n+class CCoinsViewCache;\n+class CTransaction;\n+class CValidationState;\n+\n+/** Transaction validation functions */\n+\n+/** Context-independent validity checks */\n+bool CheckTransaction(const CTransaction& tx, CValidationState& state, bool fCheckDuplicateInputs=true);\n+\n+namespace Consensus {\n+/**\n+ * Check whether all inputs of this transaction are valid (no double spends and amounts)\n+ * This does not modify the UTXO set. This does not check scripts and sigs.\n+ * Preconditions: tx.IsCoinBase() is false.\n+ */\n+bool CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoinsViewCache& inputs, int nSpendHeight);\n+} // namespace Consensus\n+\n+/** Auxiliary functions for transaction validation (ideally should not be exposed) */\n+\n+/**\n+ * Count ECDSA signature operations the old-fashioned (pre-0.6) way\n+ * @return number of sigops this transaction's outputs will produce when spent\n+ * @see CTransaction::FetchInputs\n+ */\n+unsigned int GetLegacySigOpCount(const CTransaction& tx);\n+\n+/**\n+ * Count ECDSA signature operations in pay-to-script-hash inputs.\n+ * \n+ * @param[in] mapInputs Map of previous transactions that have outputs we're spending\n+ * @return maximum number of sigops required to validate this transaction's inputs\n+ * @see CTransaction::FetchInputs\n+ */\n+unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& mapInputs);\n+\n+/**\n+ * Compute total signature operation cost of a transaction.\n+ * @param[in] tx     Transaction for which we are computing the cost\n+ * @param[in] inputs Map of previous transactions that have outputs we're spending\n+ * @param[out] flags Script verification flags\n+ * @return Total signature operation cost of tx\n+ */\n+int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, int flags);\n+\n+/**\n+ * Check if transaction is final and can be included in a block with the\n+ * specified height and time. Consensus critical.\n+ */\n+bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime);\n+\n+/**\n+ * Calculates the block height and previous block's median time past at\n+ * which the transaction will be considered final in the context of BIP 68.\n+ * Also removes from the vector of input heights any entries which did not\n+ * correspond to sequence locked inputs as they do not affect the calculation.\n+ */\n+std::pair<int, int64_t> CalculateSequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block);\n+\n+bool EvaluateSequenceLocks(const CBlockIndex& block, std::pair<int, int64_t> lockPair);\n+/**\n+ * Check if transaction is final per BIP 68 sequence numbers and can be included in a block.\n+ * Consensus critical. Takes as input a list of heights at which tx's inputs (in order) confirmed.\n+ */\n+bool SequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block);\n+\n+#endif // BITCOIN_CONSENSUS_TX_VERIFY_H"
      },
      {
        "sha": "d116e617eea1833112778fb322c3db8098ebb42f",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -151,6 +151,8 @@ void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry)\n     entry.pushKV(\"txid\", tx.GetHash().GetHex());\n     entry.pushKV(\"hash\", tx.GetWitnessHash().GetHex());\n     entry.pushKV(\"version\", tx.nVersion);\n+    entry.pushKV(\"size\", (int)::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n+    entry.pushKV(\"vsize\", (GetTransactionWeight(tx) + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR);\n     entry.pushKV(\"locktime\", (int64_t)tx.nLockTime);\n \n     UniValue vin(UniValue::VARR);"
      },
      {
        "sha": "816ae870e138aa54621b2cebd62052b36bf55c2f",
        "filename": "src/crypto/chacha20.cpp",
        "status": "added",
        "additions": 180,
        "deletions": 0,
        "changes": 180,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/crypto/chacha20.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/crypto/chacha20.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/chacha20.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -0,0 +1,180 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+// Based on the public domain implementation 'merged' by D. J. Bernstein\n+// See https://cr.yp.to/chacha.html.\n+\n+#include \"crypto/common.h\"\n+#include \"crypto/chacha20.h\"\n+\n+#include <string.h>\n+\n+constexpr static inline uint32_t rotl32(uint32_t v, int c) { return (v << c) | (v >> (32 - c)); }\n+\n+#define QUARTERROUND(a,b,c,d) \\\n+  a += b; d = rotl32(d ^ a, 16); \\\n+  c += d; b = rotl32(b ^ c, 12); \\\n+  a += b; d = rotl32(d ^ a, 8); \\\n+  c += d; b = rotl32(b ^ c, 7);\n+\n+static const unsigned char sigma[] = \"expand 32-byte k\";\n+static const unsigned char tau[] = \"expand 16-byte k\";\n+\n+void ChaCha20::SetKey(const unsigned char* k, size_t keylen)\n+{\n+    const unsigned char *constants;\n+\n+    input[4] = ReadLE32(k + 0);\n+    input[5] = ReadLE32(k + 4);\n+    input[6] = ReadLE32(k + 8);\n+    input[7] = ReadLE32(k + 12);\n+    if (keylen == 32) { /* recommended */\n+        k += 16;\n+        constants = sigma;\n+    } else { /* keylen == 16 */\n+        constants = tau;\n+    }\n+    input[8] = ReadLE32(k + 0);\n+    input[9] = ReadLE32(k + 4);\n+    input[10] = ReadLE32(k + 8);\n+    input[11] = ReadLE32(k + 12);\n+    input[0] = ReadLE32(constants + 0);\n+    input[1] = ReadLE32(constants + 4);\n+    input[2] = ReadLE32(constants + 8);\n+    input[3] = ReadLE32(constants + 12);\n+    input[12] = 0;\n+    input[13] = 0;\n+    input[14] = 0;\n+    input[15] = 0;\n+}\n+\n+ChaCha20::ChaCha20()\n+{\n+    memset(input, 0, sizeof(input));\n+}\n+\n+ChaCha20::ChaCha20(const unsigned char* k, size_t keylen)\n+{\n+    SetKey(k, keylen);\n+}\n+\n+void ChaCha20::SetIV(uint64_t iv)\n+{\n+    input[14] = iv;\n+    input[15] = iv >> 32;\n+}\n+\n+void ChaCha20::Seek(uint64_t pos)\n+{\n+    input[12] = pos;\n+    input[13] = pos >> 32;\n+}\n+\n+void ChaCha20::Output(unsigned char* c, size_t bytes)\n+{\n+    uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    uint32_t j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n+    unsigned char *ctarget = NULL;\n+    unsigned char tmp[64];\n+    unsigned int i;\n+\n+    if (!bytes) return;\n+\n+    j0 = input[0];\n+    j1 = input[1];\n+    j2 = input[2];\n+    j3 = input[3];\n+    j4 = input[4];\n+    j5 = input[5];\n+    j6 = input[6];\n+    j7 = input[7];\n+    j8 = input[8];\n+    j9 = input[9];\n+    j10 = input[10];\n+    j11 = input[11];\n+    j12 = input[12];\n+    j13 = input[13];\n+    j14 = input[14];\n+    j15 = input[15];\n+\n+    for (;;) {\n+        if (bytes < 64) {\n+            ctarget = c;\n+            c = tmp;\n+        }\n+        x0 = j0;\n+        x1 = j1;\n+        x2 = j2;\n+        x3 = j3;\n+        x4 = j4;\n+        x5 = j5;\n+        x6 = j6;\n+        x7 = j7;\n+        x8 = j8;\n+        x9 = j9;\n+        x10 = j10;\n+        x11 = j11;\n+        x12 = j12;\n+        x13 = j13;\n+        x14 = j14;\n+        x15 = j15;\n+        for (i = 20;i > 0;i -= 2) {\n+            QUARTERROUND( x0, x4, x8,x12)\n+            QUARTERROUND( x1, x5, x9,x13)\n+            QUARTERROUND( x2, x6,x10,x14)\n+            QUARTERROUND( x3, x7,x11,x15)\n+            QUARTERROUND( x0, x5,x10,x15)\n+            QUARTERROUND( x1, x6,x11,x12)\n+            QUARTERROUND( x2, x7, x8,x13)\n+            QUARTERROUND( x3, x4, x9,x14)\n+        }\n+        x0 += j0;\n+        x1 += j1;\n+        x2 += j2;\n+        x3 += j3;\n+        x4 += j4;\n+        x5 += j5;\n+        x6 += j6;\n+        x7 += j7;\n+        x8 += j8;\n+        x9 += j9;\n+        x10 += j10;\n+        x11 += j11;\n+        x12 += j12;\n+        x13 += j13;\n+        x14 += j14;\n+        x15 += j15;\n+\n+        ++j12;\n+        if (!j12) ++j13;\n+\n+        WriteLE32(c + 0, x0);\n+        WriteLE32(c + 4, x1);\n+        WriteLE32(c + 8, x2);\n+        WriteLE32(c + 12, x3);\n+        WriteLE32(c + 16, x4);\n+        WriteLE32(c + 20, x5);\n+        WriteLE32(c + 24, x6);\n+        WriteLE32(c + 28, x7);\n+        WriteLE32(c + 32, x8);\n+        WriteLE32(c + 36, x9);\n+        WriteLE32(c + 40, x10);\n+        WriteLE32(c + 44, x11);\n+        WriteLE32(c + 48, x12);\n+        WriteLE32(c + 52, x13);\n+        WriteLE32(c + 56, x14);\n+        WriteLE32(c + 60, x15);\n+\n+        if (bytes <= 64) {\n+            if (bytes < 64) {\n+                for (i = 0;i < bytes;++i) ctarget[i] = c[i];\n+            }\n+            input[12] = j12;\n+            input[13] = j13;\n+            return;\n+        }\n+        bytes -= 64;\n+        c += 64;\n+    }\n+}"
      },
      {
        "sha": "a305977bcd5f4027cbb83b27a16622bab6f0c4c3",
        "filename": "src/crypto/chacha20.h",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/crypto/chacha20.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/crypto/chacha20.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/chacha20.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -0,0 +1,26 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CRYPTO_CHACHA20_H\n+#define BITCOIN_CRYPTO_CHACHA20_H\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+/** A PRNG class for ChaCha20. */\n+class ChaCha20\n+{\n+private:\n+    uint32_t input[16];\n+\n+public:\n+    ChaCha20();\n+    ChaCha20(const unsigned char* key, size_t keylen);\n+    void SetKey(const unsigned char* key, size_t keylen);\n+    void SetIV(uint64_t iv);\n+    void Seek(uint64_t pos);\n+    void Output(unsigned char* output, size_t bytes);\n+};\n+\n+#endif // BITCOIN_CRYPTO_CHACHA20_H"
      },
      {
        "sha": "bcca3d30ea7d686b4244049a3d63f28f50ca8d7c",
        "filename": "src/crypto/common.h",
        "status": "modified",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/crypto/common.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/crypto/common.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/common.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -79,4 +79,25 @@ void static inline WriteBE64(unsigned char* ptr, uint64_t x)\n     memcpy(ptr, (char*)&v, 8);\n }\n \n+/** Return the smallest number n such that (x >> n) == 0 (or 64 if the highest bit in x is set. */\n+uint64_t static inline CountBits(uint64_t x)\n+{\n+#ifdef HAVE_DECL___BUILTIN_CLZL\n+    if (sizeof(unsigned long) >= sizeof(uint64_t)) {\n+        return x ? 8 * sizeof(unsigned long) - __builtin_clzl(x) : 0;\n+    }\n+#endif\n+#ifdef HAVE_DECL___BUILTIN_CLZLL\n+    if (sizeof(unsigned long long) >= sizeof(uint64_t)) {\n+        return x ? 8 * sizeof(unsigned long long) - __builtin_clzll(x) : 0;\n+    }\n+#endif\n+    int ret = 0;\n+    while (x) {\n+        x >>= 1;\n+        ++ret;\n+    }\n+    return ret;\n+}\n+\n #endif // BITCOIN_CRYPTO_COMMON_H"
      },
      {
        "sha": "abb4be254b8fa00f76a43fcaf99b54f310cc3254",
        "filename": "src/fs.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/fs.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/fs.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fs.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -21,4 +21,4 @@ namespace fsbridge {\n     FILE *freopen(const fs::path& p, const char *mode, FILE *stream);\n };\n \n-#endif\n+#endif // BITCOIN_FS_H"
      },
      {
        "sha": "5ab6d8d73268bf79ae2bca44df99e5cffce613e0",
        "filename": "src/httprpc.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/httprpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/httprpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -30,7 +30,7 @@ static const char* WWW_AUTH_HEADER_DATA = \"Basic realm=\\\"jsonrpc\\\"\";\n class HTTPRPCTimer : public RPCTimerBase\n {\n public:\n-    HTTPRPCTimer(struct event_base* eventBase, boost::function<void(void)>& func, int64_t millis) :\n+    HTTPRPCTimer(struct event_base* eventBase, std::function<void(void)>& func, int64_t millis) :\n         ev(eventBase, false, func)\n     {\n         struct timeval tv;\n@@ -52,7 +52,7 @@ class HTTPRPCTimerInterface : public RPCTimerInterface\n     {\n         return \"HTTP\";\n     }\n-    RPCTimerBase* NewTimer(boost::function<void(void)>& func, int64_t millis)\n+    RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis)\n     {\n         return new HTTPRPCTimer(base, func, millis);\n     }\n@@ -93,9 +93,9 @@ static bool multiUserAuthorized(std::string strUserPass)\n     std::string strUser = strUserPass.substr(0, strUserPass.find(\":\"));\n     std::string strPass = strUserPass.substr(strUserPass.find(\":\") + 1);\n \n-    if (mapMultiArgs.count(\"-rpcauth\") > 0) {\n+    if (gArgs.IsArgSet(\"-rpcauth\")) {\n         //Search for multi-user login/pass \"rpcauth\" from config\n-        BOOST_FOREACH(std::string strRPCAuth, mapMultiArgs.at(\"-rpcauth\"))\n+        BOOST_FOREACH(std::string strRPCAuth, gArgs.GetArgs(\"-rpcauth\"))\n         {\n             std::vector<std::string> vFields;\n             boost::split(vFields, strRPCAuth, boost::is_any_of(\":$\"));"
      },
      {
        "sha": "0d1cba3fd2bddb728475cfedc873c09b7a8655f2",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -196,9 +196,8 @@ static bool InitHTTPAllowList()\n     LookupHost(\"::1\", localv6, false);\n     rpc_allow_subnets.push_back(CSubNet(localv4, 8));      // always allow IPv4 local subnet\n     rpc_allow_subnets.push_back(CSubNet(localv6));         // always allow IPv6 localhost\n-    if (mapMultiArgs.count(\"-rpcallowip\")) {\n-        const std::vector<std::string>& vAllow = mapMultiArgs.at(\"-rpcallowip\");\n-        for (std::string strAllow : vAllow) {\n+    if (gArgs.IsArgSet(\"-rpcallowip\")) {\n+        for (const std::string& strAllow : gArgs.GetArgs(\"-rpcallowip\")) {\n             CSubNet subnet;\n             LookupSubNet(strAllow.c_str(), subnet);\n             if (!subnet.IsValid()) {\n@@ -321,12 +320,11 @@ static bool HTTPBindAddresses(struct evhttp* http)\n         if (IsArgSet(\"-rpcbind\")) {\n             LogPrintf(\"WARNING: option -rpcbind was ignored because -rpcallowip was not specified, refusing to allow everyone to connect\\n\");\n         }\n-    } else if (mapMultiArgs.count(\"-rpcbind\")) { // Specific bind address\n-        const std::vector<std::string>& vbind = mapMultiArgs.at(\"-rpcbind\");\n-        for (std::vector<std::string>::const_iterator i = vbind.begin(); i != vbind.end(); ++i) {\n+    } else if (gArgs.IsArgSet(\"-rpcbind\")) { // Specific bind address\n+        for (const std::string& strRPCBind : gArgs.GetArgs(\"-rpcbind\")) {\n             int port = defaultPort;\n             std::string host;\n-            SplitHostPort(*i, port, host);\n+            SplitHostPort(strRPCBind, port, host);\n             endpoints.push_back(std::make_pair(host, port));\n         }\n     } else { // No specific bind address specified, bind to any"
      },
      {
        "sha": "3bbdb16c3bb58eeeb67ad330eacb3941a24a55fb",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 42,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -25,6 +25,8 @@\n #include \"netbase.h\"\n #include \"net.h\"\n #include \"net_processing.h\"\n+#include \"policy/feerate.h\"\n+#include \"policy/fees.h\"\n #include \"policy/policy.h\"\n #include \"rpc/server.h\"\n #include \"rpc/register.h\"\n@@ -57,7 +59,6 @@\n #include <boost/algorithm/string/replace.hpp>\n #include <boost/algorithm/string/split.hpp>\n #include <boost/bind.hpp>\n-#include <boost/function.hpp>\n #include <boost/interprocess/sync/file_lock.hpp>\n #include <boost/thread.hpp>\n #include <openssl/crypto.h>\n@@ -207,15 +208,17 @@ void Shutdown()\n \n     StopTorControl();\n     UnregisterNodeSignals(GetNodeSignals());\n-    if (fDumpMempoolLater)\n+    if (fDumpMempoolLater && GetArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) {\n         DumpMempool();\n+    }\n \n     if (fFeeEstimatesInitialized)\n     {\n+        ::feeEstimator.FlushUnconfirmed(::mempool);\n         fs::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n         CAutoFile est_fileout(fsbridge::fopen(est_path, \"wb\"), SER_DISK, CLIENT_VERSION);\n         if (!est_fileout.IsNull())\n-            mempool.WriteFeeEstimates(est_fileout);\n+            ::feeEstimator.Write(est_fileout);\n         else\n             LogPrintf(\"%s: Failed to write fee estimates to %s\\n\", __func__, est_path.string());\n         fFeeEstimatesInitialized = false;\n@@ -326,6 +329,10 @@ void OnRPCPreCommand(const CRPCCommand& cmd)\n \n std::string HelpMessage(HelpMessageMode mode)\n {\n+    const auto defaultBaseParams = CreateBaseChainParams(CBaseChainParams::MAIN);\n+    const auto testnetBaseParams = CreateBaseChainParams(CBaseChainParams::TESTNET);\n+    const auto defaultChainParams = CreateChainParams(CBaseChainParams::MAIN);\n+    const auto testnetChainParams = CreateChainParams(CBaseChainParams::TESTNET);\n     const bool showDebug = GetBoolArg(\"-help-debug\", false);\n \n     // When adding new options to the categories, please keep and ensure alphabetical ordering.\n@@ -337,7 +344,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-blocknotify=<cmd>\", _(\"Execute command when the best block changes (%s in cmd is replaced by block hash)\"));\n     if (showDebug)\n         strUsage += HelpMessageOpt(\"-blocksonly\", strprintf(_(\"Whether to operate in a blocks only mode (default: %u)\"), DEFAULT_BLOCKSONLY));\n-    strUsage +=HelpMessageOpt(\"-assumevalid=<hex>\", strprintf(_(\"If this block is in the chain assume that it and its ancestors are valid and potentially skip their script verification (0 to verify all, default: %s, testnet: %s)\"), Params(CBaseChainParams::MAIN).GetConsensus().defaultAssumeValid.GetHex(), Params(CBaseChainParams::TESTNET).GetConsensus().defaultAssumeValid.GetHex()));\n+    strUsage +=HelpMessageOpt(\"-assumevalid=<hex>\", strprintf(_(\"If this block is in the chain assume that it and its ancestors are valid and potentially skip their script verification (0 to verify all, default: %s, testnet: %s)\"), defaultChainParams->GetConsensus().defaultAssumeValid.GetHex(), testnetChainParams->GetConsensus().defaultAssumeValid.GetHex()));\n     strUsage += HelpMessageOpt(\"-conf=<file>\", strprintf(_(\"Specify configuration file (default: %s)\"), BITCOIN_CONF_FILENAME));\n     if (mode == HMM_BITCOIND)\n     {\n@@ -353,6 +360,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-maxorphantx=<n>\", strprintf(_(\"Keep at most <n> unconnectable transactions in memory (default: %u)\"), DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n     strUsage += HelpMessageOpt(\"-maxmempool=<n>\", strprintf(_(\"Keep the transaction memory pool below <n> megabytes (default: %u)\"), DEFAULT_MAX_MEMPOOL_SIZE));\n     strUsage += HelpMessageOpt(\"-mempoolexpiry=<n>\", strprintf(_(\"Do not keep transactions in the mempool longer than <n> hours (default: %u)\"), DEFAULT_MEMPOOL_EXPIRY));\n+    strUsage += HelpMessageOpt(\"-persistmempool\", strprintf(_(\"Whether to save the mempool on shutdown and load on restart (default: %u)\"), DEFAULT_PERSIST_MEMPOOL));\n     strUsage += HelpMessageOpt(\"-blockreconstructionextratxn=<n>\", strprintf(_(\"Extra transactions to keep in memory for compact block reconstructions (default: %u)\"), DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN));\n     strUsage += HelpMessageOpt(\"-par=<n>\", strprintf(_(\"Set the number of script verification threads (%u to %d, 0 = auto, <0 = leave that many cores free, default: %d)\"),\n         -GetNumCores(), MAX_SCRIPTCHECK_THREADS, DEFAULT_SCRIPTCHECK_THREADS));\n@@ -390,7 +398,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-onlynet=<net>\", _(\"Only connect to nodes in network <net> (ipv4, ipv6 or onion)\"));\n     strUsage += HelpMessageOpt(\"-permitbaremultisig\", strprintf(_(\"Relay non-P2SH multisig (default: %u)\"), DEFAULT_PERMIT_BAREMULTISIG));\n     strUsage += HelpMessageOpt(\"-peerbloomfilters\", strprintf(_(\"Support filtering of blocks and transaction with bloom filters (default: %u)\"), DEFAULT_PEERBLOOMFILTERS));\n-    strUsage += HelpMessageOpt(\"-port=<port>\", strprintf(_(\"Listen for connections on <port> (default: %u or testnet: %u)\"), Params(CBaseChainParams::MAIN).GetDefaultPort(), Params(CBaseChainParams::TESTNET).GetDefaultPort()));\n+    strUsage += HelpMessageOpt(\"-port=<port>\", strprintf(_(\"Listen for connections on <port> (default: %u or testnet: %u)\"), defaultChainParams->GetDefaultPort(), testnetChainParams->GetDefaultPort()));\n     strUsage += HelpMessageOpt(\"-proxy=<ip:port>\", _(\"Connect through SOCKS5 proxy\"));\n     strUsage += HelpMessageOpt(\"-proxyrandomize\", strprintf(_(\"Randomize credentials for every proxy connection. This enables Tor stream isolation (default: %u)\"), DEFAULT_PROXYRANDOMIZE));\n     strUsage += HelpMessageOpt(\"-seednode=<ip>\", _(\"Connect to a node to retrieve peer addresses, and disconnect\"));\n@@ -427,14 +435,16 @@ std::string HelpMessage(HelpMessageMode mode)\n     {\n         strUsage += HelpMessageOpt(\"-checkblocks=<n>\", strprintf(_(\"How many blocks to check at startup (default: %u, 0 = all)\"), DEFAULT_CHECKBLOCKS));\n         strUsage += HelpMessageOpt(\"-checklevel=<n>\", strprintf(_(\"How thorough the block verification of -checkblocks is (0-4, default: %u)\"), DEFAULT_CHECKLEVEL));\n-        strUsage += HelpMessageOpt(\"-checkblockindex\", strprintf(\"Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive and mapBlocksUnlinked occasionally. Also sets -checkmempool (default: %u)\", Params(CBaseChainParams::MAIN).DefaultConsistencyChecks()));\n-        strUsage += HelpMessageOpt(\"-checkmempool=<n>\", strprintf(\"Run checks every <n> transactions (default: %u)\", Params(CBaseChainParams::MAIN).DefaultConsistencyChecks()));\n+        strUsage += HelpMessageOpt(\"-checkblockindex\", strprintf(\"Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive and mapBlocksUnlinked occasionally. Also sets -checkmempool (default: %u)\", defaultChainParams->DefaultConsistencyChecks()));\n+        strUsage += HelpMessageOpt(\"-checkmempool=<n>\", strprintf(\"Run checks every <n> transactions (default: %u)\", defaultChainParams->DefaultConsistencyChecks()));\n         strUsage += HelpMessageOpt(\"-checkpoints\", strprintf(\"Disable expensive verification for known chain history (default: %u)\", DEFAULT_CHECKPOINTS_ENABLED));\n         strUsage += HelpMessageOpt(\"-disablesafemode\", strprintf(\"Disable safemode, override a real safe mode event (default: %u)\", DEFAULT_DISABLE_SAFEMODE));\n         strUsage += HelpMessageOpt(\"-testsafemode\", strprintf(\"Force safe mode (default: %u)\", DEFAULT_TESTSAFEMODE));\n         strUsage += HelpMessageOpt(\"-dropmessagestest=<n>\", \"Randomly drop 1 of every <n> network messages\");\n         strUsage += HelpMessageOpt(\"-fuzzmessagestest=<n>\", \"Randomly fuzz 1 of every <n> network messages\");\n         strUsage += HelpMessageOpt(\"-stopafterblockimport\", strprintf(\"Stop running after importing blocks from disk (default: %u)\", DEFAULT_STOPAFTERBLOCKIMPORT));\n+        strUsage += HelpMessageOpt(\"-stopatheight\", strprintf(\"Stop running after reaching the given height in the main chain (default: %u)\", DEFAULT_STOPATHEIGHT));\n+\n         strUsage += HelpMessageOpt(\"-limitancestorcount=<n>\", strprintf(\"Do not accept transactions if number of in-mempool ancestors is <n> or more (default: %u)\", DEFAULT_ANCESTOR_LIMIT));\n         strUsage += HelpMessageOpt(\"-limitancestorsize=<n>\", strprintf(\"Do not accept transactions whose size with all in-mempool ancestors exceeds <n> kilobytes (default: %u)\", DEFAULT_ANCESTOR_SIZE_LIMIT));\n         strUsage += HelpMessageOpt(\"-limitdescendantcount=<n>\", strprintf(\"Do not accept transactions if any ancestor would have <n> or more in-mempool descendants (default: %u)\", DEFAULT_DESCENDANT_LIMIT));\n@@ -467,7 +477,7 @@ std::string HelpMessage(HelpMessageMode mode)\n \n     strUsage += HelpMessageGroup(_(\"Node relay options:\"));\n     if (showDebug) {\n-        strUsage += HelpMessageOpt(\"-acceptnonstdtxn\", strprintf(\"Relay and mine \\\"non-standard\\\" transactions (%sdefault: %u)\", \"testnet/regtest only; \", !Params(CBaseChainParams::TESTNET).RequireStandard()));\n+        strUsage += HelpMessageOpt(\"-acceptnonstdtxn\", strprintf(\"Relay and mine \\\"non-standard\\\" transactions (%sdefault: %u)\", \"testnet/regtest only; \", defaultChainParams->RequireStandard()));\n         strUsage += HelpMessageOpt(\"-incrementalrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kB) used to define cost of relay, used for mempool limiting and BIP 125 replacement. (default: %s)\", CURRENCY_UNIT, FormatMoney(DEFAULT_INCREMENTAL_RELAY_FEE)));\n         strUsage += HelpMessageOpt(\"-dustrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kB) used to defined dust, the value of an output such that it will cost about 1/3 of its value in fees at this fee rate to spend it. (default: %s)\", CURRENCY_UNIT, FormatMoney(DUST_RELAY_TX_FEE)));\n     }\n@@ -495,7 +505,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-rpcuser=<user>\", _(\"Username for JSON-RPC connections\"));\n     strUsage += HelpMessageOpt(\"-rpcpassword=<pw>\", _(\"Password for JSON-RPC connections\"));\n     strUsage += HelpMessageOpt(\"-rpcauth=<userpw>\", _(\"Username and hashed password for JSON-RPC connections. The field <userpw> comes in the format: <USERNAME>:<SALT>$<HASH>. A canonical python script is included in share/rpcuser. The client then connects normally using the rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. This option can be specified multiple times\"));\n-    strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\"Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)\"), BaseParams(CBaseChainParams::MAIN).RPCPort(), BaseParams(CBaseChainParams::TESTNET).RPCPort()));\n+    strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\"Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)\"), defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()));\n     strUsage += HelpMessageOpt(\"-rpcallowip=<ip>\", _(\"Allow JSON-RPC connections from specified source. Valid for <ip> are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option can be specified multiple times\"));\n     strUsage += HelpMessageOpt(\"-rpcserialversion\", strprintf(_(\"Sets the serialization of raw transaction or block hex returned in non-verbose mode, non-segwit(0) or segwit(1) (default: %d)\"), DEFAULT_RPC_SERIALIZE_VERSION));\n     strUsage += HelpMessageOpt(\"-rpcthreads=<n>\", strprintf(_(\"Set the number of threads to service RPC calls (default: %d)\"), DEFAULT_HTTP_THREADS));\n@@ -676,8 +686,10 @@ void ThreadImport(std::vector<fs::path> vImportFiles)\n         StartShutdown();\n     }\n     } // End scope of CImportingNow\n-    LoadMempool();\n-    fDumpMempoolLater = !fRequestShutdown;\n+    if (GetArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) {\n+        LoadMempool();\n+        fDumpMempoolLater = !fRequestShutdown;\n+    }\n }\n \n /** Sanity checks\n@@ -734,7 +746,7 @@ void InitParameterInteraction()\n             LogPrintf(\"%s: parameter interaction: -whitebind set -> setting -listen=1\\n\", __func__);\n     }\n \n-    if (mapMultiArgs.count(\"-connect\") && mapMultiArgs.at(\"-connect\").size() > 0) {\n+    if (gArgs.IsArgSet(\"-connect\")) {\n         // when only connecting to trusted nodes, do not seed via DNS, or listen by default\n         if (SoftSetBoolArg(\"-dnsseed\", false))\n             LogPrintf(\"%s: parameter interaction: -connect set -> setting -dnsseed=0\\n\", __func__);\n@@ -888,8 +900,8 @@ bool AppInitParameterInteraction()\n \n     // Make sure enough file descriptors are available\n     int nBind = std::max(\n-                (mapMultiArgs.count(\"-bind\") ? mapMultiArgs.at(\"-bind\").size() : 0) +\n-                (mapMultiArgs.count(\"-whitebind\") ? mapMultiArgs.at(\"-whitebind\").size() : 0), size_t(1));\n+                (gArgs.IsArgSet(\"-bind\") ? gArgs.GetArgs(\"-bind\").size() : 0) +\n+                (gArgs.IsArgSet(\"-whitebind\") ? gArgs.GetArgs(\"-whitebind\").size() : 0), size_t(1));\n     nUserMaxConnections = GetArg(\"-maxconnections\", DEFAULT_MAX_PEER_CONNECTIONS);\n     nMaxConnections = std::max(nUserMaxConnections, 0);\n \n@@ -904,9 +916,9 @@ bool AppInitParameterInteraction()\n         InitWarning(strprintf(_(\"Reducing -maxconnections from %d to %d, because of system limitations.\"), nUserMaxConnections, nMaxConnections));\n \n     // ********************************************************* Step 3: parameter-to-internal-flags\n-    if (mapMultiArgs.count(\"-debug\") > 0) {\n+    if (gArgs.IsArgSet(\"-debug\")) {\n         // Special-case: if -debug=0/-nodebug is set, turn off debugging messages\n-        const std::vector<std::string>& categories = mapMultiArgs.at(\"-debug\");\n+        const std::vector<std::string> categories = gArgs.GetArgs(\"-debug\");\n \n         if (find(categories.begin(), categories.end(), std::string(\"0\")) == categories.end()) {\n             for (const auto& cat : categories) {\n@@ -921,9 +933,8 @@ bool AppInitParameterInteraction()\n     }\n \n     // Now remove the logging categories which were explicitly excluded\n-    if (mapMultiArgs.count(\"-debugexclude\") > 0) {\n-        const std::vector<std::string>& excludedCategories = mapMultiArgs.at(\"-debugexclude\");\n-        for (const auto& cat : excludedCategories) {\n+    if (gArgs.IsArgSet(\"-debugexclude\")) {\n+        for (const std::string& cat : gArgs.GetArgs(\"-debugexclude\")) {\n             uint32_t flag = 0;\n             if (!GetLogCategory(&flag, &cat)) {\n                 InitWarning(strprintf(_(\"Unsupported logging category %s=%s.\"), \"-debugexclude\", cat));\n@@ -1093,15 +1104,14 @@ bool AppInitParameterInteraction()\n         fEnableReplacement = (std::find(vstrReplacementModes.begin(), vstrReplacementModes.end(), \"fee\") != vstrReplacementModes.end());\n     }\n \n-    if (mapMultiArgs.count(\"-bip9params\")) {\n+    if (gArgs.IsArgSet(\"-bip9params\")) {\n         // Allow overriding BIP9 parameters for testing\n         if (!chainparams.MineBlocksOnDemand()) {\n             return InitError(\"BIP9 parameters may only be overridden on regtest.\");\n         }\n-        const std::vector<std::string>& deployments = mapMultiArgs.at(\"-bip9params\");\n-        for (auto i : deployments) {\n+        for (const std::string& strDeployment : gArgs.GetArgs(\"-bip9params\")) {\n             std::vector<std::string> vDeploymentParams;\n-            boost::split(vDeploymentParams, i, boost::is_any_of(\":\"));\n+            boost::split(vDeploymentParams, strDeployment, boost::is_any_of(\":\"));\n             if (vDeploymentParams.size() != 3) {\n                 return InitError(\"BIP9 parameters malformed, expecting deployment:start:end\");\n             }\n@@ -1116,7 +1126,7 @@ bool AppInitParameterInteraction()\n             for (int j=0; j<(int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j)\n             {\n                 if (vDeploymentParams[0].compare(VersionBitsDeploymentInfo[j].name) == 0) {\n-                    UpdateRegtestBIP9Parameters(Consensus::DeploymentPos(j), nStartTime, nTimeout);\n+                    UpdateBIP9Parameters(Consensus::DeploymentPos(j), nStartTime, nTimeout);\n                     found = true;\n                     LogPrintf(\"Setting BIP9 activation parameters for %s to start=%ld, timeout=%ld\\n\", vDeploymentParams[0], nStartTime, nTimeout);\n                     break;\n@@ -1247,8 +1257,8 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n \n     // sanitize comments per BIP-0014, format user agent and check total size\n     std::vector<std::string> uacomments;\n-    if (mapMultiArgs.count(\"-uacomment\")) {\n-        BOOST_FOREACH(std::string cmt, mapMultiArgs.at(\"-uacomment\"))\n+    if (gArgs.IsArgSet(\"-uacomment\")) {\n+        BOOST_FOREACH(std::string cmt, gArgs.GetArgs(\"-uacomment\"))\n         {\n             if (cmt != SanitizeString(cmt, SAFE_CHARS_UA_COMMENT))\n                 return InitError(strprintf(_(\"User Agent comment (%s) contains unsafe characters.\"), cmt));\n@@ -1261,9 +1271,9 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n             strSubVersion.size(), MAX_SUBVERSION_LENGTH));\n     }\n \n-    if (mapMultiArgs.count(\"-onlynet\")) {\n+    if (gArgs.IsArgSet(\"-onlynet\")) {\n         std::set<enum Network> nets;\n-        BOOST_FOREACH(const std::string& snet, mapMultiArgs.at(\"-onlynet\")) {\n+        BOOST_FOREACH(const std::string& snet, gArgs.GetArgs(\"-onlynet\")) {\n             enum Network net = ParseNetwork(snet);\n             if (net == NET_UNROUTABLE)\n                 return InitError(strprintf(_(\"Unknown network specified in -onlynet: '%s'\"), snet));\n@@ -1276,8 +1286,8 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n         }\n     }\n \n-    if (mapMultiArgs.count(\"-whitelist\")) {\n-        BOOST_FOREACH(const std::string& net, mapMultiArgs.at(\"-whitelist\")) {\n+    if (gArgs.IsArgSet(\"-whitelist\")) {\n+        BOOST_FOREACH(const std::string& net, gArgs.GetArgs(\"-whitelist\")) {\n             CSubNet subnet;\n             LookupSubNet(net.c_str(), subnet);\n             if (!subnet.IsValid())\n@@ -1338,16 +1348,16 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n \n     if (fListen) {\n         bool fBound = false;\n-        if (mapMultiArgs.count(\"-bind\")) {\n-            BOOST_FOREACH(const std::string& strBind, mapMultiArgs.at(\"-bind\")) {\n+        if (gArgs.IsArgSet(\"-bind\")) {\n+            BOOST_FOREACH(const std::string& strBind, gArgs.GetArgs(\"-bind\")) {\n                 CService addrBind;\n                 if (!Lookup(strBind.c_str(), addrBind, GetListenPort(), false))\n                     return InitError(ResolveErrMsg(\"bind\", strBind));\n                 fBound |= Bind(connman, addrBind, (BF_EXPLICIT | BF_REPORT_ERROR));\n             }\n         }\n-        if (mapMultiArgs.count(\"-whitebind\")) {\n-            BOOST_FOREACH(const std::string& strBind, mapMultiArgs.at(\"-whitebind\")) {\n+        if (gArgs.IsArgSet(\"-whitebind\")) {\n+            BOOST_FOREACH(const std::string& strBind, gArgs.GetArgs(\"-whitebind\")) {\n                 CService addrBind;\n                 if (!Lookup(strBind.c_str(), addrBind, 0, false))\n                     return InitError(ResolveErrMsg(\"whitebind\", strBind));\n@@ -1356,7 +1366,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                 fBound |= Bind(connman, addrBind, (BF_EXPLICIT | BF_REPORT_ERROR | BF_WHITELIST));\n             }\n         }\n-        if (!mapMultiArgs.count(\"-bind\") && !mapMultiArgs.count(\"-whitebind\")) {\n+        if (!gArgs.IsArgSet(\"-bind\") && !gArgs.IsArgSet(\"-whitebind\")) {\n             struct in_addr inaddr_any;\n             inaddr_any.s_addr = INADDR_ANY;\n             fBound |= Bind(connman, CService(in6addr_any, GetListenPort()), BF_NONE);\n@@ -1366,8 +1376,8 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n             return InitError(_(\"Failed to listen on any port. Use -listen=0 if you want this.\"));\n     }\n \n-    if (mapMultiArgs.count(\"-externalip\")) {\n-        BOOST_FOREACH(const std::string& strAddr, mapMultiArgs.at(\"-externalip\")) {\n+    if (gArgs.IsArgSet(\"-externalip\")) {\n+        BOOST_FOREACH(const std::string& strAddr, gArgs.GetArgs(\"-externalip\")) {\n             CService addrLocal;\n             if (Lookup(strAddr.c_str(), addrLocal, GetListenPort(), fNameLookup) && addrLocal.IsValid())\n                 AddLocal(addrLocal, LOCAL_MANUAL);\n@@ -1376,8 +1386,8 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n         }\n     }\n \n-    if (mapMultiArgs.count(\"-seednode\")) {\n-        BOOST_FOREACH(const std::string& strDest, mapMultiArgs.at(\"-seednode\"))\n+    if (gArgs.IsArgSet(\"-seednode\")) {\n+        BOOST_FOREACH(const std::string& strDest, gArgs.GetArgs(\"-seednode\"))\n             connman.AddOneShot(strDest);\n     }\n \n@@ -1550,7 +1560,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     CAutoFile est_filein(fsbridge::fopen(est_path, \"rb\"), SER_DISK, CLIENT_VERSION);\n     // Allowed to fail as this file IS missing on first startup.\n     if (!est_filein.IsNull())\n-        mempool.ReadFeeEstimates(est_filein);\n+        ::feeEstimator.Read(est_filein);\n     fFeeEstimatesInitialized = true;\n \n     // ********************************************************* Step 8: load wallet\n@@ -1603,9 +1613,9 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n         uiInterface.NotifyBlockTip.connect(BlockNotifyCallback);\n \n     std::vector<fs::path> vImportFiles;\n-    if (mapMultiArgs.count(\"-loadblock\"))\n+    if (gArgs.IsArgSet(\"-loadblock\"))\n     {\n-        BOOST_FOREACH(const std::string& strFile, mapMultiArgs.at(\"-loadblock\"))\n+        BOOST_FOREACH(const std::string& strFile, gArgs.GetArgs(\"-loadblock\"))\n             vImportFiles.push_back(strFile);\n     }\n "
      },
      {
        "sha": "5a75647f1a44163fce0660cad0b444dbbc5e4a64",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -131,14 +131,6 @@ void CKey::MakeNewKey(bool fCompressedIn) {\n     fCompressed = fCompressedIn;\n }\n \n-bool CKey::SetPrivKey(const CPrivKey &privkey, bool fCompressedIn) {\n-    if (!ec_privkey_import_der(secp256k1_context_sign, (unsigned char*)begin(), &privkey[0], privkey.size()))\n-        return false;\n-    fCompressed = fCompressedIn;\n-    fValid = true;\n-    return true;\n-}\n-\n CPrivKey CKey::GetPrivKey() const {\n     assert(fValid);\n     CPrivKey privkey;"
      },
      {
        "sha": "2c6f151727b6447fc1ac7c2816310d434195ab7f",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -94,9 +94,6 @@ class CKey\n     //! Check whether the public key corresponding to this private key is (to be) compressed.\n     bool IsCompressed() const { return fCompressed; }\n \n-    //! Initialize from a CPrivKey (serialized OpenSSL private key data).\n-    bool SetPrivKey(const CPrivKey& vchPrivKey, bool fCompressed);\n-\n     //! Generate a new private key using a cryptographic PRNG.\n     void MakeNewKey(bool fCompressed);\n "
      },
      {
        "sha": "b69acafffd11a37a9263dacabbc29d4fd2924c17",
        "filename": "src/memusage.h",
        "status": "modified",
        "additions": 17,
        "deletions": 3,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/memusage.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -12,6 +12,8 @@\n #include <map>\n #include <set>\n #include <vector>\n+#include <unordered_map>\n+#include <unordered_set>\n \n #include <boost/foreach.hpp>\n #include <boost/unordered_set.hpp>\n@@ -149,7 +151,7 @@ static inline size_t DynamicUsage(const std::shared_ptr<X>& p)\n // Boost data structures\n \n template<typename X>\n-struct boost_unordered_node : private X\n+struct unordered_node : private X\n {\n private:\n     void* ptr;\n@@ -158,13 +160,25 @@ struct boost_unordered_node : private X\n template<typename X, typename Y>\n static inline size_t DynamicUsage(const boost::unordered_set<X, Y>& s)\n {\n-    return MallocUsage(sizeof(boost_unordered_node<X>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n+    return MallocUsage(sizeof(unordered_node<X>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n }\n \n template<typename X, typename Y, typename Z>\n static inline size_t DynamicUsage(const boost::unordered_map<X, Y, Z>& m)\n {\n-    return MallocUsage(sizeof(boost_unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n+    return MallocUsage(sizeof(unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n+}\n+\n+template<typename X, typename Y>\n+static inline size_t DynamicUsage(const std::unordered_set<X, Y>& s)\n+{\n+    return MallocUsage(sizeof(unordered_node<X>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n+}\n+\n+template<typename X, typename Y, typename Z>\n+static inline size_t DynamicUsage(const std::unordered_map<X, Y, Z>& m)\n+{\n+    return MallocUsage(sizeof(unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n }\n \n }"
      },
      {
        "sha": "78d7cd60010529afa6b3310eba69f5bccb0df7ee",
        "filename": "src/merkleblock.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/merkleblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/merkleblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/merkleblock.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -65,7 +65,7 @@ uint256 CPartialMerkleTree::CalcHash(int height, unsigned int pos, const std::ve\n     } else {\n         // calculate left hash\n         uint256 left = CalcHash(height-1, pos*2, vTxid), right;\n-        // calculate right hash if not beyond the end of the array - copy left hash otherwise1\n+        // calculate right hash if not beyond the end of the array - copy left hash otherwise\n         if (pos*2+1 < CalcTreeWidth(height-1))\n             right = CalcHash(height-1, pos*2+1, vTxid);\n         else"
      },
      {
        "sha": "de4c5c8d29e7329b36c64b07f0ee5a768c8c7544",
        "filename": "src/merkleblock.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/merkleblock.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/merkleblock.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/merkleblock.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -23,7 +23,7 @@\n  * storing a bit for each traversed node, signifying whether the node is the\n  * parent of at least one matched leaf txid (or a matched txid itself). In\n  * case we are at the leaf level, or this bit is 0, its merkle node hash is\n- * stored, and its children are not explorer further. Otherwise, no hash is\n+ * stored, and its children are not explored further. Otherwise, no hash is\n  * stored, but we recurse into both (or the only) child branch. During\n  * decoding, the same depth-first traversal is performed, consuming bits and\n  * hashes as they written during encoding."
      },
      {
        "sha": "28b6f23d569665b48e81c627a684487c603e800f",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -10,11 +10,13 @@\n #include \"chainparams.h\"\n #include \"coins.h\"\n #include \"consensus/consensus.h\"\n+#include \"consensus/tx_verify.h\"\n #include \"consensus/merkle.h\"\n #include \"consensus/validation.h\"\n #include \"hash.h\"\n #include \"validation.h\"\n #include \"net.h\"\n+#include \"policy/feerate.h\"\n #include \"policy/policy.h\"\n #include \"pow.h\"\n #include \"primitives/transaction.h\"\n@@ -317,9 +319,7 @@ int BlockAssembler::UpdatePackagesForAdded(const CTxMemPool::setEntries& already\n bool BlockAssembler::SkipMapTxEntry(CTxMemPool::txiter it, indexed_modified_transaction_set &mapModifiedTx, CTxMemPool::setEntries &failedTx)\n {\n     assert (it != mempool.mapTx.end());\n-    if (mapModifiedTx.count(it) || inBlock.count(it) || failedTx.count(it))\n-        return true;\n-    return false;\n+    return mapModifiedTx.count(it) || inBlock.count(it) || failedTx.count(it);\n }\n \n void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, CTxMemPool::txiter entry, std::vector<CTxMemPool::txiter>& sortedEntries)"
      },
      {
        "sha": "198d8f5fff6ebc05eb3c3e9c899044fbaf0cc9d1",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 66,
        "deletions": 73,
        "changes": 139,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -148,7 +148,7 @@ static std::vector<CAddress> convertSeed6(const std::vector<SeedSpec6> &vSeedsIn\n // one by discovery.\n CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices)\n {\n-    CAddress ret(CService(CNetAddr(),GetListenPort()), NODE_NONE);\n+    CAddress ret(CService(CNetAddr(),GetListenPort()), nLocalServices);\n     CService addr;\n     if (GetLocal(addr, paddrPeer))\n     {\n@@ -418,10 +418,10 @@ void CConnman::DumpBanlist()\n \n     CBanDB bandb;\n     banmap_t banmap;\n-    SetBannedSetDirty(false);\n     GetBanned(banmap);\n-    if (!bandb.Write(banmap))\n-        SetBannedSetDirty(true);\n+    if (bandb.Write(banmap)) {\n+        SetBannedSetDirty(false);\n+    }\n \n     LogPrint(BCLog::NET, \"Flushed %d banned node ips/subnets to banlist.dat  %dms\\n\",\n         banmap.size(), GetTimeMillis() - nStart);\n@@ -541,6 +541,8 @@ bool CConnman::Unban(const CSubNet &subNet) {\n void CConnman::GetBanned(banmap_t &banMap)\n {\n     LOCK(cs_setBanned);\n+    // Sweep the banlist so expired bans are not returned\n+    SweepBanned();\n     banMap = setBanned; //create a thread safe copy\n }\n \n@@ -708,7 +710,7 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes, bool& complete\n             handled = msg.readData(pch, nBytes);\n \n         if (handled < 0)\n-                return false;\n+            return false;\n \n         if (msg.in_data && msg.hdr.nMessageSize > MAX_PROTOCOL_MESSAGE_LENGTH) {\n             LogPrint(BCLog::NET, \"Oversized message from peer=%i, disconnecting\\n\", GetId());\n@@ -786,7 +788,7 @@ int CNetMessage::readHeader(const char *pch, unsigned int nBytes)\n \n     // reject messages larger than MAX_SIZE\n     if (hdr.nMessageSize > MAX_SIZE)\n-            return -1;\n+        return -1;\n \n     // switch state to reading message data\n     in_data = true;\n@@ -946,7 +948,7 @@ bool CConnman::AttemptToEvictConnection()\n                 continue;\n             if (node->fDisconnect)\n                 continue;\n-            NodeEvictionCandidate candidate = {node->id, node->nTimeConnected, node->nMinPingUsecTime,\n+            NodeEvictionCandidate candidate = {node->GetId(), node->nTimeConnected, node->nMinPingUsecTime,\n                                                node->nLastBlockTime, node->nLastTXTime,\n                                                (node->nServices & nRelevantServices) == nRelevantServices,\n                                                node->fRelayTxes, node->pfilter != NULL, node->addr, node->nKeyedNetGroup};\n@@ -1069,12 +1071,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n \n     // According to the internet TCP_NODELAY is not carried into accepted sockets\n     // on all platforms.  Set it again here just to be sure.\n-    int set = 1;\n-#ifdef WIN32\n-    setsockopt(hSocket, IPPROTO_TCP, TCP_NODELAY, (const char*)&set, sizeof(int));\n-#else\n-    setsockopt(hSocket, IPPROTO_TCP, TCP_NODELAY, (void*)&set, sizeof(int));\n-#endif\n+    SetSocketNoDelay(hSocket);\n \n     if (IsBanned(addr) && !whitelisted)\n     {\n@@ -1299,59 +1296,55 @@ void CConnman::ThreadSocketHandler()\n             }\n             if (recvSet || errorSet)\n             {\n+                // typical socket buffer is 8K-64K\n+                char pchBuf[0x10000];\n+                int nBytes = 0;\n                 {\n-                    {\n-                        // typical socket buffer is 8K-64K\n-                        char pchBuf[0x10000];\n-                        int nBytes = 0;\n-                        {\n-                            LOCK(pnode->cs_hSocket);\n-                            if (pnode->hSocket == INVALID_SOCKET)\n-                                continue;\n-                            nBytes = recv(pnode->hSocket, pchBuf, sizeof(pchBuf), MSG_DONTWAIT);\n-                        }\n-                        if (nBytes > 0)\n-                        {\n-                            bool notify = false;\n-                            if (!pnode->ReceiveMsgBytes(pchBuf, nBytes, notify))\n-                                pnode->CloseSocketDisconnect();\n-                            RecordBytesRecv(nBytes);\n-                            if (notify) {\n-                                size_t nSizeAdded = 0;\n-                                auto it(pnode->vRecvMsg.begin());\n-                                for (; it != pnode->vRecvMsg.end(); ++it) {\n-                                    if (!it->complete())\n-                                        break;\n-                                    nSizeAdded += it->vRecv.size() + CMessageHeader::HEADER_SIZE;\n-                                }\n-                                {\n-                                    LOCK(pnode->cs_vProcessMsg);\n-                                    pnode->vProcessMsg.splice(pnode->vProcessMsg.end(), pnode->vRecvMsg, pnode->vRecvMsg.begin(), it);\n-                                    pnode->nProcessQueueSize += nSizeAdded;\n-                                    pnode->fPauseRecv = pnode->nProcessQueueSize > nReceiveFloodSize;\n-                                }\n-                                WakeMessageHandler();\n-                            }\n-                        }\n-                        else if (nBytes == 0)\n-                        {\n-                            // socket closed gracefully\n-                            if (!pnode->fDisconnect) {\n-                                LogPrint(BCLog::NET, \"socket closed\\n\");\n-                            }\n-                            pnode->CloseSocketDisconnect();\n+                    LOCK(pnode->cs_hSocket);\n+                    if (pnode->hSocket == INVALID_SOCKET)\n+                        continue;\n+                    nBytes = recv(pnode->hSocket, pchBuf, sizeof(pchBuf), MSG_DONTWAIT);\n+                }\n+                if (nBytes > 0)\n+                {\n+                    bool notify = false;\n+                    if (!pnode->ReceiveMsgBytes(pchBuf, nBytes, notify))\n+                        pnode->CloseSocketDisconnect();\n+                    RecordBytesRecv(nBytes);\n+                    if (notify) {\n+                        size_t nSizeAdded = 0;\n+                        auto it(pnode->vRecvMsg.begin());\n+                        for (; it != pnode->vRecvMsg.end(); ++it) {\n+                            if (!it->complete())\n+                                break;\n+                            nSizeAdded += it->vRecv.size() + CMessageHeader::HEADER_SIZE;\n                         }\n-                        else if (nBytes < 0)\n                         {\n-                            // error\n-                            int nErr = WSAGetLastError();\n-                            if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n-                            {\n-                                if (!pnode->fDisconnect)\n-                                    LogPrintf(\"socket recv error %s\\n\", NetworkErrorString(nErr));\n-                                pnode->CloseSocketDisconnect();\n-                            }\n+                            LOCK(pnode->cs_vProcessMsg);\n+                            pnode->vProcessMsg.splice(pnode->vProcessMsg.end(), pnode->vRecvMsg, pnode->vRecvMsg.begin(), it);\n+                            pnode->nProcessQueueSize += nSizeAdded;\n+                            pnode->fPauseRecv = pnode->nProcessQueueSize > nReceiveFloodSize;\n                         }\n+                        WakeMessageHandler();\n+                    }\n+                }\n+                else if (nBytes == 0)\n+                {\n+                    // socket closed gracefully\n+                    if (!pnode->fDisconnect) {\n+                        LogPrint(BCLog::NET, \"socket closed\\n\");\n+                    }\n+                    pnode->CloseSocketDisconnect();\n+                }\n+                else if (nBytes < 0)\n+                {\n+                    // error\n+                    int nErr = WSAGetLastError();\n+                    if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n+                    {\n+                        if (!pnode->fDisconnect)\n+                            LogPrintf(\"socket recv error %s\\n\", NetworkErrorString(nErr));\n+                        pnode->CloseSocketDisconnect();\n                     }\n                 }\n             }\n@@ -1376,7 +1369,7 @@ void CConnman::ThreadSocketHandler()\n             {\n                 if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n                 {\n-                    LogPrint(BCLog::NET, \"socket no message in first 60 seconds, %d %d from %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0, pnode->id);\n+                    LogPrint(BCLog::NET, \"socket no message in first 60 seconds, %d %d from %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0, pnode->GetId());\n                     pnode->fDisconnect = true;\n                 }\n                 else if (nTime - pnode->nLastSend > TIMEOUT_INTERVAL)\n@@ -1396,7 +1389,7 @@ void CConnman::ThreadSocketHandler()\n                 }\n                 else if (!pnode->fSuccessfullyConnected)\n                 {\n-                    LogPrintf(\"version handshake timeout from %d\\n\", pnode->id);\n+                    LogPrintf(\"version handshake timeout from %d\\n\", pnode->GetId());\n                     pnode->fDisconnect = true;\n                 }\n             }\n@@ -1672,12 +1665,12 @@ void CConnman::ProcessOneShot()\n void CConnman::ThreadOpenConnections()\n {\n     // Connect to specific addresses\n-    if (mapMultiArgs.count(\"-connect\") && mapMultiArgs.at(\"-connect\").size() > 0)\n+    if (gArgs.IsArgSet(\"-connect\") && gArgs.GetArgs(\"-connect\").size() > 0)\n     {\n         for (int64_t nLoop = 0;; nLoop++)\n         {\n             ProcessOneShot();\n-            BOOST_FOREACH(const std::string& strAddr, mapMultiArgs.at(\"-connect\"))\n+            BOOST_FOREACH(const std::string& strAddr, gArgs.GetArgs(\"-connect\"))\n             {\n                 CAddress addr(CService(), NODE_NONE);\n                 OpenNetworkConnection(addr, false, NULL, strAddr.c_str());\n@@ -1879,8 +1872,8 @@ void CConnman::ThreadOpenAddedConnections()\n {\n     {\n         LOCK(cs_vAddedNodes);\n-        if (mapMultiArgs.count(\"-addnode\"))\n-            vAddedNodes = mapMultiArgs.at(\"-addnode\");\n+        if (gArgs.IsArgSet(\"-addnode\"))\n+            vAddedNodes = gArgs.GetArgs(\"-addnode\");\n     }\n \n     while (true)\n@@ -2291,7 +2284,7 @@ bool CConnman::Start(CScheduler& scheduler, std::string& strNodeError, Options c\n     threadOpenAddedConnections = std::thread(&TraceThread<std::function<void()> >, \"addcon\", std::function<void()>(std::bind(&CConnman::ThreadOpenAddedConnections, this)));\n \n     // Initiate outbound connections unless connect=0\n-    if (!mapMultiArgs.count(\"-connect\") || mapMultiArgs.at(\"-connect\").size() != 1 || mapMultiArgs.at(\"-connect\")[0] != \"0\")\n+    if (!gArgs.IsArgSet(\"-connect\") || gArgs.GetArgs(\"-connect\").size() != 1 || gArgs.GetArgs(\"-connect\")[0] != \"0\")\n         threadOpenConnections = std::thread(&TraceThread<std::function<void()> >, \"opencon\", std::function<void()>(std::bind(&CConnman::ThreadOpenConnections, this)));\n \n     // Process messages\n@@ -2489,7 +2482,7 @@ bool CConnman::DisconnectNode(NodeId id)\n {\n     LOCK(cs_vNodes);\n     for(CNode* pnode : vNodes) {\n-        if (id == pnode->id) {\n+        if (id == pnode->GetId()) {\n             pnode->fDisconnect = true;\n             return true;\n         }\n@@ -2627,10 +2620,10 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn\n     nTimeConnected(GetSystemTimeInSeconds()),\n     addr(addrIn),\n     fInbound(fInboundIn),\n-    id(idIn),\n     nKeyedNetGroup(nKeyedNetGroupIn),\n     addrKnown(5000, 0.001),\n     filterInventoryKnown(50000, 0.000001),\n+    id(idIn),\n     nLocalHostNonce(nLocalHostNonceIn),\n     nLocalServices(nLocalServicesIn),\n     nMyStartingHeight(nMyStartingHeightIn),\n@@ -2746,7 +2739,7 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n {\n     size_t nMessageSize = msg.data.size();\n     size_t nTotalSize = nMessageSize + CMessageHeader::HEADER_SIZE;\n-    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(msg.command.c_str()), nMessageSize, pnode->id);\n+    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(msg.command.c_str()), nMessageSize, pnode->GetId());\n \n     std::vector<unsigned char> serializedHeader;\n     serializedHeader.reserve(CMessageHeader::HEADER_SIZE);\n@@ -2784,7 +2777,7 @@ bool CConnman::ForNode(NodeId id, std::function<bool(CNode* pnode)> func)\n     CNode* found = nullptr;\n     LOCK(cs_vNodes);\n     for (auto&& pnode : vNodes) {\n-        if(pnode->id == id) {\n+        if(pnode->GetId() == id) {\n             found = pnode;\n             break;\n         }"
      },
      {
        "sha": "bea04bc5805c3fc4fe75f0f6afc541b80670d935",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -11,10 +11,10 @@\n #include \"amount.h\"\n #include \"bloom.h\"\n #include \"compat.h\"\n-#include \"fs.h\"\n #include \"hash.h\"\n #include \"limitedmap.h\"\n #include \"netaddress.h\"\n+#include \"policy/feerate.h\"\n #include \"protocol.h\"\n #include \"random.h\"\n #include \"streams.h\"\n@@ -36,7 +36,6 @@\n #include <boost/foreach.hpp>\n #include <boost/signals2/signal.hpp>\n \n-class CAddrMan;\n class CScheduler;\n class CNode;\n \n@@ -613,7 +612,6 @@ class CNode\n     CCriticalSection cs_filter;\n     CBloomFilter* pfilter;\n     std::atomic<int> nRefCount;\n-    const NodeId id;\n \n     const uint64_t nKeyedNetGroup;\n     std::atomic_bool fPauseRecv;\n@@ -684,6 +682,7 @@ class CNode\n private:\n     CNode(const CNode&);\n     void operator=(const CNode&);\n+    const NodeId id;\n \n \n     const uint64_t nLocalHostNonce;\n@@ -701,15 +700,15 @@ class CNode\n public:\n \n     NodeId GetId() const {\n-      return id;\n+        return id;\n     }\n \n     uint64_t GetLocalNonce() const {\n-      return nLocalHostNonce;\n+        return nLocalHostNonce;\n     }\n \n     int GetMyStartingHeight() const {\n-      return nMyStartingHeight;\n+        return nMyStartingHeight;\n     }\n \n     int GetRefCount()\n@@ -760,7 +759,7 @@ class CNode\n         // after addresses were pushed.\n         if (_addr.IsValid() && !addrKnown.contains(_addr.GetKey())) {\n             if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n-                vAddrToSend[insecure_rand.rand32() % vAddrToSend.size()] = _addr;\n+                vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\n             } else {\n                 vAddrToSend.push_back(_addr);\n             }"
      },
      {
        "sha": "b4ae009358050f61e7fa2c73b4ae33fc40d56745",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 142,
        "deletions": 147,
        "changes": 289,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -308,6 +308,7 @@ void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n         assert(nPreferredDownload == 0);\n         assert(nPeersWithValidatedDownloads == 0);\n     }\n+    LogPrint(BCLog::NET, \"Cleared nodestate for peer=%d\\n\", nodeid);\n }\n \n // Requires cs_main.\n@@ -338,7 +339,7 @@ bool MarkBlockAsReceived(const uint256& hash) {\n // Requires cs_main.\n // returns false, still setting pit, if the block was already in flight from the same peer\n // pit will only be valid as long as the same cs_main lock is being held\n-bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, const CBlockIndex* pindex = NULL, std::list<QueuedBlock>::iterator** pit = NULL) {\n+bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = NULL, std::list<QueuedBlock>::iterator** pit = NULL) {\n     CNodeState *state = State(nodeid);\n     assert(state != NULL);\n \n@@ -758,8 +759,8 @@ void PeerLogicValidation::BlockConnected(const std::shared_ptr<const CBlock>& pb\n         const CTransaction& tx = *ptx;\n \n         // Which orphan pool entries must we evict?\n-        for (size_t j = 0; j < tx.vin.size(); j++) {\n-            auto itByPrev = mapOrphanTransactionsByPrev.find(tx.vin[j].prevout);\n+        for (const auto& txin : tx.vin) {\n+            auto itByPrev = mapOrphanTransactionsByPrev.find(txin.prevout);\n             if (itByPrev == mapOrphanTransactionsByPrev.end()) continue;\n             for (auto mi = itByPrev->second.begin(); mi != itByPrev->second.end(); ++mi) {\n                 const CTransaction& orphanTx = *(*mi)->second.tx;\n@@ -820,7 +821,7 @@ void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std:\n                 !PeerHasHeader(&state, pindex) && PeerHasHeader(&state, pindex->pprev)) {\n \n             LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", \"PeerLogicValidation::NewPoWValidBlock\",\n-                    hashBlock.ToString(), pnode->id);\n+                    hashBlock.ToString(), pnode->GetId());\n             connman->PushMessage(pnode, msgMaker.Make(NetMsgType::CMPCTBLOCK, *pcmpctblock));\n             state.pindexBestHeaderSent = pindex;\n         }\n@@ -989,7 +990,7 @@ static void RelayAddress(const CAddress& addr, bool fReachable, CConnman& connma\n \n     auto sortfunc = [&best, &hasher, nRelayNodes](CNode* pnode) {\n         if (pnode->nVersion >= CADDR_TIME_VERSION) {\n-            uint64_t hashKey = CSipHasher(hasher).Write(pnode->id).Finalize();\n+            uint64_t hashKey = CSipHasher(hasher).Write(pnode->GetId()).Finalize();\n             for (unsigned int i = 0; i < nRelayNodes; i++) {\n                  if (hashKey > best[i].first) {\n                      std::copy(best.begin() + i, best.begin() + nRelayNodes - 1, best.begin() + i + 1);\n@@ -1201,7 +1202,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n     }\n }\n \n-uint32_t GetFetchFlags(CNode* pfrom, const CBlockIndex* pprev, const Consensus::Params& chainparams) {\n+uint32_t GetFetchFlags(CNode* pfrom) {\n     uint32_t nFetchFlags = 0;\n     if ((pfrom->GetLocalServices() & NODE_WITNESS) && State(pfrom->GetId())->fHaveWitness) {\n         nFetchFlags |= MSG_WITNESS_FLAG;\n@@ -1215,7 +1216,7 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n         if (req.indexes[i] >= block.vtx.size()) {\n             LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 100);\n-            LogPrintf(\"Peer %d sent us a getblocktxn with out-of-bounds tx indices\", pfrom->id);\n+            LogPrintf(\"Peer %d sent us a getblocktxn with out-of-bounds tx indices\", pfrom->GetId());\n             return;\n         }\n         resp.txn[i] = block.vtx[req.indexes[i]];\n@@ -1228,7 +1229,7 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n \n bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n {\n-    LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->id);\n+    LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());\n     if (IsArgSet(\"-dropmessagestest\") && GetRand(GetArg(\"-dropmessagestest\", 0)) == 0)\n     {\n         LogPrintf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n@@ -1307,7 +1308,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n         if (pfrom->nServicesExpected & ~nServices)\n         {\n-            LogPrint(BCLog::NET, \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom->id, nServices, pfrom->nServicesExpected);\n+            LogPrint(BCLog::NET, \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom->GetId(), nServices, pfrom->nServicesExpected);\n             connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,\n                                strprintf(\"Expected to offer services %08x\", pfrom->nServicesExpected)));\n             pfrom->fDisconnect = true;\n@@ -1317,7 +1318,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (nVersion < MIN_PEER_PROTO_VERSION)\n         {\n             // disconnect from peers older than this proto version\n-            LogPrintf(\"peer=%d using obsolete version %i; disconnecting\\n\", pfrom->id, nVersion);\n+            LogPrintf(\"peer=%d using obsolete version %i; disconnecting\\n\", pfrom->GetId(), nVersion);\n             connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,\n                                strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION)));\n             pfrom->fDisconnect = true;\n@@ -1419,7 +1420,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         LogPrintf(\"receive version message: %s: version %d, blocks=%d, us=%s, peer=%d%s\\n\",\n                   cleanSubVer, pfrom->nVersion,\n-                  pfrom->nStartingHeight, addrMe.ToString(), pfrom->id,\n+                  pfrom->nStartingHeight, addrMe.ToString(), pfrom->GetId(),\n                   remoteAddr);\n \n         int64_t nTimeOffset = nTime - GetTime();\n@@ -1589,14 +1590,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         LOCK(cs_main);\n \n-        uint32_t nFetchFlags = GetFetchFlags(pfrom, chainActive.Tip(), chainparams.GetConsensus());\n+        uint32_t nFetchFlags = GetFetchFlags(pfrom);\n \n-        std::vector<CInv> vToFetch;\n-\n-        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n+        for (CInv &inv : vInv)\n         {\n-            CInv &inv = vInv[nInv];\n-\n             if (interruptMsgProc)\n                 return true;\n \n@@ -1607,6 +1604,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 LogPrint(BCLog::NET, \"got Dandelion inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom->id);\n             }\n \n+\n             if (inv.type == MSG_TX) {\n                 inv.type |= nFetchFlags;\n \n@@ -1634,7 +1632,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     // we now only provide a getheaders response here. When we receive the headers, we will\n                     // then ask for the blocks we need.\n                     connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), inv.hash));\n-                    LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, inv.hash.ToString(), pfrom->id);\n+                    LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, inv.hash.ToString(), pfrom->GetId());\n                 }\n             }\n             else\n@@ -1643,7 +1641,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 LogPrintf(\"fAlreadyHave is %d. fImporting is %d. fReindex is %d. IsInitialBlockDownload is %d.\\n\",\n                     fAlreadyHave, fImporting, fReindex, IsInitialBlockDownload());\n                 if (fBlocksOnly) {\n-                    LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol peer=%d\\n\", inv.hash.ToString(), pfrom->id);\n+                    LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol peer=%d\\n\", inv.hash.ToString(), pfrom->GetId());\n                 } else if (!fAlreadyHave && !fImporting && !fReindex && !IsInitialBlockDownload()) {\n                     pfrom->AskFor(inv);\n                 }\n@@ -1652,9 +1650,6 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // Track requests for our stuff\n             GetMainSignals().Inventory(inv.hash);\n         }\n-\n-        if (!vToFetch.empty())\n-            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vToFetch));\n     }\n \n \n@@ -1669,10 +1664,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return error(\"message getdata size() = %u\", vInv.size());\n         }\n \n-        LogPrint(BCLog::NET, \"received getdata (%u invsz) peer=%d\\n\", vInv.size(), pfrom->id);\n+        LogPrint(BCLog::NET, \"received getdata (%u invsz) peer=%d\\n\", vInv.size(), pfrom->GetId());\n \n         if (vInv.size() > 0) {\n-            LogPrint(BCLog::NET, \"received getdata for: %s peer=%d\\n\", vInv[0].ToString(), pfrom->id);\n+            LogPrint(BCLog::NET, \"received getdata for: %s peer=%d\\n\", vInv[0].ToString(), pfrom->GetId());\n         }\n \n         pfrom->vRecvGetData.insert(pfrom->vRecvGetData.end(), vInv.begin(), vInv.end());\n@@ -1712,7 +1707,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (pindex)\n             pindex = chainActive.Next(pindex);\n         int nLimit = 500;\n-        LogPrint(BCLog::NET, \"getblocks %d to %s limit %d from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), nLimit, pfrom->id);\n+        LogPrint(BCLog::NET, \"getblocks %d to %s limit %d from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), nLimit, pfrom->GetId());\n         for (; pindex; pindex = chainActive.Next(pindex))\n         {\n             if (pindex->GetBlockHash() == hashStop)\n@@ -1762,7 +1757,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         BlockMap::iterator it = mapBlockIndex.find(req.blockhash);\n         if (it == mapBlockIndex.end() || !(it->second->nStatus & BLOCK_HAVE_DATA)) {\n-            LogPrintf(\"Peer %d sent us a getblocktxn for a block we don't have\", pfrom->id);\n+            LogPrintf(\"Peer %d sent us a getblocktxn for a block we don't have\", pfrom->GetId());\n             return true;\n         }\n \n@@ -1774,7 +1769,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // might maliciously send lots of getblocktxn requests to trigger\n             // expensive disk reads, because it will require the peer to\n             // actually receive all the data read from disk over the network.\n-            LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block > %i deep\", pfrom->id, MAX_BLOCKTXN_DEPTH);\n+            LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block > %i deep\", pfrom->GetId(), MAX_BLOCKTXN_DEPTH);\n             CInv inv;\n             inv.type = State(pfrom->GetId())->fWantsCmpctWitness ? MSG_WITNESS_BLOCK : MSG_BLOCK;\n             inv.hash = req.blockhash;\n@@ -1799,7 +1794,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         LOCK(cs_main);\n         if (IsInitialBlockDownload() && !pfrom->fWhitelisted) {\n-            LogPrint(BCLog::NET, \"Ignoring getheaders from peer=%d because node is in initial block download\\n\", pfrom->id);\n+            LogPrint(BCLog::NET, \"Ignoring getheaders from peer=%d because node is in initial block download\\n\", pfrom->GetId());\n             return true;\n         }\n \n@@ -1824,7 +1819,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // we must use CBlocks, as CBlockHeaders won't include the 0x00 nTx count at the end\n         std::vector<CBlock> vHeaders;\n         int nLimit = MAX_HEADERS_RESULTS;\n-        LogPrint(BCLog::NET, \"getheaders %d to %s from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), pfrom->id);\n+        LogPrint(BCLog::NET, \"getheaders %d to %s from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), pfrom->GetId());\n         for (; pindex; pindex = chainActive.Next(pindex))\n         {\n             vHeaders.push_back(pindex->GetBlockHeader());\n@@ -1854,7 +1849,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // We are in blocks only mode and peer is either not whitelisted or whitelistrelay is off\n         if (!fRelayTxes && (!pfrom->fWhitelisted || !GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)))\n         {\n-            LogPrint(BCLog::NET, \"transaction sent in violation of protocol peer=%d\\n\", pfrom->id);\n+            LogPrint(BCLog::NET, \"transaction sent in violation of protocol peer=%d\\n\", pfrom->GetId());\n             return true;\n         }\n \n@@ -1887,7 +1882,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             pfrom->nLastTXTime = GetTime();\n \n             LogPrint(BCLog::MEMPOOL, \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",\n-                pfrom->id,\n+                pfrom->GetId(),\n                 tx.GetHash().ToString(),\n                 mempool.size(), mempool.DynamicMemoryUsage() / 1000);\n \n@@ -1962,7 +1957,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 }\n             }\n             if (!fRejectedParents) {\n-                uint32_t nFetchFlags = GetFetchFlags(pfrom, chainActive.Tip(), chainparams.GetConsensus());\n+                uint32_t nFetchFlags = GetFetchFlags(pfrom);\n                 BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n                     CInv _inv(MSG_TX | nFetchFlags, txin.prevout.hash);\n                     pfrom->AddInventoryKnown(_inv);\n@@ -2007,10 +2002,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // case.\n                 int nDoS = 0;\n                 if (!state.IsInvalid(nDoS) || nDoS == 0) {\n-                    LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->id);\n+                    LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->GetId());\n                     RelayTransaction(tx, connman);\n                 } else {\n-                    LogPrintf(\"Not relaying invalid transaction %s from whitelisted peer=%d (%s)\\n\", tx.GetHash().ToString(), pfrom->id, FormatStateMessage(state));\n+                    LogPrintf(\"Not relaying invalid transaction %s from whitelisted peer=%d (%s)\\n\", tx.GetHash().ToString(), pfrom->GetId(), FormatStateMessage(state));\n                 }\n             }\n         }\n@@ -2022,7 +2017,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (state.IsInvalid(nDoS))\n         {\n             LogPrint(BCLog::MEMPOOLREJ, \"%s from peer=%d was not accepted: %s\\n\", tx.GetHash().ToString(),\n-                pfrom->id,\n+                pfrom->GetId(),\n                 FormatStateMessage(state));\n             if (state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) // Never send AcceptToMemoryPool's internal codes over P2P\n                 connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n@@ -2058,7 +2053,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     LOCK(cs_main);\n                     Misbehaving(pfrom->GetId(), nDoS);\n                 }\n-                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\\n\", pfrom->id);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\\n\", pfrom->GetId());\n                 return true;\n             }\n         }\n@@ -2098,7 +2093,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // We requested this block for some reason, but our mempool will probably be useless\n                 // so we just grab the block via normal getdata\n                 std::vector<CInv> vInv(1);\n-                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n+                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n                 connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n             }\n             return true;\n@@ -2122,7 +2117,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n                  (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n                 std::list<QueuedBlock>::iterator* queuedBlockIt = NULL;\n-                if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt)) {\n+                if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), pindex, &queuedBlockIt)) {\n                     if (!(*queuedBlockIt)->partialBlock)\n                         (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&mempool));\n                     else {\n@@ -2137,12 +2132,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 if (status == READ_STATUS_INVALID) {\n                     MarkBlockAsReceived(pindex->GetBlockHash()); // Reset in-flight state in case of whitelist\n                     Misbehaving(pfrom->GetId(), 100);\n-                    LogPrintf(\"Peer %d sent us invalid compact block\\n\", pfrom->id);\n+                    LogPrintf(\"Peer %d sent us invalid compact block\\n\", pfrom->GetId());\n                     return true;\n                 } else if (status == READ_STATUS_FAILED) {\n                     // Duplicate txindexes, the block is now in-flight, so just request it\n                     std::vector<CInv> vInv(1);\n-                    vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n+                    vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n                     connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n                     return true;\n                 }\n@@ -2185,7 +2180,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // We requested this block, but its far into the future, so our\n                 // mempool will probably be useless - request the block normally\n                 std::vector<CInv> vInv(1);\n-                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n+                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n                 connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n                 return true;\n             } else {\n@@ -2242,7 +2237,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n             if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n                     it->second.first != pfrom->GetId()) {\n-                LogPrint(BCLog::NET, \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom->id);\n+                LogPrint(BCLog::NET, \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom->GetId());\n                 return true;\n             }\n \n@@ -2251,12 +2246,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             if (status == READ_STATUS_INVALID) {\n                 MarkBlockAsReceived(resp.blockhash); // Reset in-flight state in case of whitelist\n                 Misbehaving(pfrom->GetId(), 100);\n-                LogPrintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom->id);\n+                LogPrintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom->GetId());\n                 return true;\n             } else if (status == READ_STATUS_FAILED) {\n                 // Might have collided, fall back to getdata now :(\n                 std::vector<CInv> invs;\n-                invs.push_back(CInv(MSG_BLOCK | GetFetchFlags(pfrom, chainActive.Tip(), chainparams.GetConsensus()), resp.blockhash));\n+                invs.push_back(CInv(MSG_BLOCK | GetFetchFlags(pfrom), resp.blockhash));\n                 connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, invs));\n             } else {\n                 // Block is either okay, or possibly we received\n@@ -2339,7 +2334,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     headers[0].GetHash().ToString(),\n                     headers[0].hashPrevBlock.ToString(),\n                     pindexBestHeader->nHeight,\n-                    pfrom->id, nodestate->nUnconnectingHeaders);\n+                    pfrom->GetId(), nodestate->nUnconnectingHeaders);\n             // Set hashLastUnknownBlock for this peer, so that if we\n             // eventually get the headers - even from a different peer -\n             // we can use this peer to download.\n@@ -2377,7 +2372,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         LOCK(cs_main);\n         CNodeState *nodestate = State(pfrom->GetId());\n         if (nodestate->nUnconnectingHeaders > 0) {\n-            LogPrint(BCLog::NET, \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom->id, nodestate->nUnconnectingHeaders);\n+            LogPrint(BCLog::NET, \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom->GetId(), nodestate->nUnconnectingHeaders);\n         }\n         nodestate->nUnconnectingHeaders = 0;\n \n@@ -2388,7 +2383,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // Headers message had its maximum size; the peer may have more headers.\n             // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n             // from there instead.\n-            LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->id, pfrom->nStartingHeight);\n+            LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->GetId(), pfrom->nStartingHeight);\n             connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256()));\n         }\n \n@@ -2424,11 +2419,11 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                         // Can't download any more from this peer\n                         break;\n                     }\n-                    uint32_t nFetchFlags = GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus());\n+                    uint32_t nFetchFlags = GetFetchFlags(pfrom);\n                     vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                    MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex);\n+                    MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), pindex);\n                     LogPrint(BCLog::NET, \"Requesting block %s from  peer=%d\\n\",\n-                            pindex->GetBlockHash().ToString(), pfrom->id);\n+                            pindex->GetBlockHash().ToString(), pfrom->GetId());\n                 }\n                 if (vGetData.size() > 1) {\n                     LogPrint(BCLog::NET, \"Downloading blocks toward %s (%d) via headers direct fetch\\n\",\n@@ -2451,7 +2446,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();\n         vRecv >> *pblock;\n \n-        LogPrint(BCLog::NET, \"received block %s peer=%d\\n\", pblock->GetHash().ToString(), pfrom->id);\n+        LogPrint(BCLog::NET, \"received block %s peer=%d\\n\", pblock->GetHash().ToString(), pfrom->GetId());\n \n         // Process all blocks from whitelisted peers, even if not requested,\n         // unless we're still syncing with the network.\n@@ -2483,14 +2478,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // Making nodes which are behind NAT and can only make outgoing connections ignore\n         // the getaddr message mitigates the attack.\n         if (!pfrom->fInbound) {\n-            LogPrint(BCLog::NET, \"Ignoring \\\"getaddr\\\" from outbound connection. peer=%d\\n\", pfrom->id);\n+            LogPrint(BCLog::NET, \"Ignoring \\\"getaddr\\\" from outbound connection. peer=%d\\n\", pfrom->GetId());\n             return true;\n         }\n \n         // Only send one GetAddr response per connection to reduce resource waste\n         //  and discourage addr stamping of INV announcements.\n         if (pfrom->fSentAddr) {\n-            LogPrint(BCLog::NET, \"Ignoring repeated \\\"getaddr\\\". peer=%d\\n\", pfrom->id);\n+            LogPrint(BCLog::NET, \"Ignoring repeated \\\"getaddr\\\". peer=%d\\n\", pfrom->GetId());\n             return true;\n         }\n         pfrom->fSentAddr = true;\n@@ -2591,7 +2586,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         if (!(sProblem.empty())) {\n             LogPrint(BCLog::NET, \"pong peer=%d: %s, %x expected, %x received, %u bytes\\n\",\n-                pfrom->id,\n+                pfrom->GetId(),\n                 sProblem,\n                 pfrom->nPingNonceSent,\n                 nonce,\n@@ -2668,7 +2663,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 LOCK(pfrom->cs_feeFilter);\n                 pfrom->minFeeFilter = newFeeFilter;\n             }\n-            LogPrint(BCLog::NET, \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom->id);\n+            LogPrint(BCLog::NET, \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom->GetId());\n         }\n     }\n \n@@ -2679,7 +2674,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n     else {\n         // Ignore unknown commands for extensibility\n-        LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(strCommand), pfrom->id);\n+        LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(strCommand), pfrom->GetId());\n     }\n \n \n@@ -2739,100 +2734,100 @@ bool ProcessMessages(CNode* pfrom, CConnman& connman, const std::atomic<bool>& i\n     // this maintains the order of responses\n     if (!pfrom->vRecvGetData.empty()) return true;\n \n-        // Don't bother if send buffer is too full to respond anyway\n-        if (pfrom->fPauseSend)\n-            return false;\n+    // Don't bother if send buffer is too full to respond anyway\n+    if (pfrom->fPauseSend)\n+        return false;\n \n-        std::list<CNetMessage> msgs;\n-        {\n-            LOCK(pfrom->cs_vProcessMsg);\n-            if (pfrom->vProcessMsg.empty())\n-                return false;\n-            // Just take one message\n-            msgs.splice(msgs.begin(), pfrom->vProcessMsg, pfrom->vProcessMsg.begin());\n-            pfrom->nProcessQueueSize -= msgs.front().vRecv.size() + CMessageHeader::HEADER_SIZE;\n-            pfrom->fPauseRecv = pfrom->nProcessQueueSize > connman.GetReceiveFloodSize();\n-            fMoreWork = !pfrom->vProcessMsg.empty();\n-        }\n-        CNetMessage& msg(msgs.front());\n-\n-        msg.SetVersion(pfrom->GetRecvVersion());\n-        // Scan for message start\n-        if (memcmp(msg.hdr.pchMessageStart, chainparams.MessageStart(), CMessageHeader::MESSAGE_START_SIZE) != 0) {\n-            LogPrintf(\"PROCESSMESSAGE: INVALID MESSAGESTART %s peer=%d\\n\", SanitizeString(msg.hdr.GetCommand()), pfrom->id);\n-            pfrom->fDisconnect = true;\n+    std::list<CNetMessage> msgs;\n+    {\n+        LOCK(pfrom->cs_vProcessMsg);\n+        if (pfrom->vProcessMsg.empty())\n             return false;\n-        }\n+        // Just take one message\n+        msgs.splice(msgs.begin(), pfrom->vProcessMsg, pfrom->vProcessMsg.begin());\n+        pfrom->nProcessQueueSize -= msgs.front().vRecv.size() + CMessageHeader::HEADER_SIZE;\n+        pfrom->fPauseRecv = pfrom->nProcessQueueSize > connman.GetReceiveFloodSize();\n+        fMoreWork = !pfrom->vProcessMsg.empty();\n+    }\n+    CNetMessage& msg(msgs.front());\n+\n+    msg.SetVersion(pfrom->GetRecvVersion());\n+    // Scan for message start\n+    if (memcmp(msg.hdr.pchMessageStart, chainparams.MessageStart(), CMessageHeader::MESSAGE_START_SIZE) != 0) {\n+        LogPrintf(\"PROCESSMESSAGE: INVALID MESSAGESTART %s peer=%d\\n\", SanitizeString(msg.hdr.GetCommand()), pfrom->GetId());\n+        pfrom->fDisconnect = true;\n+        return false;\n+    }\n \n-        // Read header\n-        CMessageHeader& hdr = msg.hdr;\n-        if (!hdr.IsValid(chainparams.MessageStart()))\n-        {\n-            LogPrintf(\"PROCESSMESSAGE: ERRORS IN HEADER %s peer=%d\\n\", SanitizeString(hdr.GetCommand()), pfrom->id);\n-            return fMoreWork;\n-        }\n-        std::string strCommand = hdr.GetCommand();\n+    // Read header\n+    CMessageHeader& hdr = msg.hdr;\n+    if (!hdr.IsValid(chainparams.MessageStart()))\n+    {\n+        LogPrintf(\"PROCESSMESSAGE: ERRORS IN HEADER %s peer=%d\\n\", SanitizeString(hdr.GetCommand()), pfrom->GetId());\n+        return fMoreWork;\n+    }\n+    std::string strCommand = hdr.GetCommand();\n \n-        // Message size\n-        unsigned int nMessageSize = hdr.nMessageSize;\n+    // Message size\n+    unsigned int nMessageSize = hdr.nMessageSize;\n \n-        // Checksum\n-        CDataStream& vRecv = msg.vRecv;\n-        const uint256& hash = msg.GetMessageHash();\n-        if (memcmp(hash.begin(), hdr.pchChecksum, CMessageHeader::CHECKSUM_SIZE) != 0)\n+    // Checksum\n+    CDataStream& vRecv = msg.vRecv;\n+    const uint256& hash = msg.GetMessageHash();\n+    if (memcmp(hash.begin(), hdr.pchChecksum, CMessageHeader::CHECKSUM_SIZE) != 0)\n+    {\n+        LogPrintf(\"%s(%s, %u bytes): CHECKSUM ERROR expected %s was %s\\n\", __func__,\n+           SanitizeString(strCommand), nMessageSize,\n+           HexStr(hash.begin(), hash.begin()+CMessageHeader::CHECKSUM_SIZE),\n+           HexStr(hdr.pchChecksum, hdr.pchChecksum+CMessageHeader::CHECKSUM_SIZE));\n+        return fMoreWork;\n+    }\n+\n+    // Process message\n+    bool fRet = false;\n+    try\n+    {\n+        fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams, connman, interruptMsgProc);\n+        if (interruptMsgProc)\n+            return false;\n+        if (!pfrom->vRecvGetData.empty())\n+            fMoreWork = true;\n+    }\n+    catch (const std::ios_base::failure& e)\n+    {\n+        connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_MALFORMED, std::string(\"error parsing message\")));\n+        if (strstr(e.what(), \"end of data\"))\n         {\n-            LogPrintf(\"%s(%s, %u bytes): CHECKSUM ERROR expected %s was %s\\n\", __func__,\n-               SanitizeString(strCommand), nMessageSize,\n-               HexStr(hash.begin(), hash.begin()+CMessageHeader::CHECKSUM_SIZE),\n-               HexStr(hdr.pchChecksum, hdr.pchChecksum+CMessageHeader::CHECKSUM_SIZE));\n-            return fMoreWork;\n+            // Allow exceptions from under-length message on vRecv\n+            LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n         }\n-\n-        // Process message\n-        bool fRet = false;\n-        try\n+        else if (strstr(e.what(), \"size too large\"))\n         {\n-            fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams, connman, interruptMsgProc);\n-            if (interruptMsgProc)\n-                return false;\n-            if (!pfrom->vRecvGetData.empty())\n-                fMoreWork = true;\n+            // Allow exceptions from over-long size\n+            LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n         }\n-        catch (const std::ios_base::failure& e)\n+        else if (strstr(e.what(), \"non-canonical ReadCompactSize()\"))\n         {\n-            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_MALFORMED, std::string(\"error parsing message\")));\n-            if (strstr(e.what(), \"end of data\"))\n-            {\n-                // Allow exceptions from under-length message on vRecv\n-                LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n-            }\n-            else if (strstr(e.what(), \"size too large\"))\n-            {\n-                // Allow exceptions from over-long size\n-                LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n-            }\n-            else if (strstr(e.what(), \"non-canonical ReadCompactSize()\"))\n-            {\n-                // Allow exceptions from non-canonical encoding\n-                LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n-            }\n-            else\n-            {\n-                PrintExceptionContinue(&e, \"ProcessMessages()\");\n-            }\n+            // Allow exceptions from non-canonical encoding\n+            LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n         }\n-        catch (const std::exception& e) {\n+        else\n+        {\n             PrintExceptionContinue(&e, \"ProcessMessages()\");\n-        } catch (...) {\n-            PrintExceptionContinue(NULL, \"ProcessMessages()\");\n         }\n+    }\n+    catch (const std::exception& e) {\n+        PrintExceptionContinue(&e, \"ProcessMessages()\");\n+    } catch (...) {\n+        PrintExceptionContinue(NULL, \"ProcessMessages()\");\n+    }\n \n-        if (!fRet) {\n-            LogPrintf(\"%s(%s, %u bytes) FAILED peer=%d\\n\", __func__, SanitizeString(strCommand), nMessageSize, pfrom->id);\n-        }\n+    if (!fRet) {\n+        LogPrintf(\"%s(%s, %u bytes) FAILED peer=%d\\n\", __func__, SanitizeString(strCommand), nMessageSize, pfrom->GetId());\n+    }\n \n-        LOCK(cs_main);\n-        SendRejectsAndCheckIfBanned(pfrom, connman);\n+    LOCK(cs_main);\n+    SendRejectsAndCheckIfBanned(pfrom, connman);\n \n     return fMoreWork;\n }\n@@ -2957,7 +2952,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                    got back an empty response.  */\n                 if (pindexStart->pprev)\n                     pindexStart = pindexStart->pprev;\n-                LogPrint(BCLog::NET, \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->id, pto->nStartingHeight);\n+                LogPrint(BCLog::NET, \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->GetId(), pto->nStartingHeight);\n                 connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexStart), uint256()));\n             }\n         }\n@@ -2987,7 +2982,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                                  (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||\n                                 pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n             const CBlockIndex *pBestIndex = NULL; // last header queued for delivery\n-            ProcessBlockAvailability(pto->id); // ensure pindexBestKnownBlock is up-to-date\n+            ProcessBlockAvailability(pto->GetId()); // ensure pindexBestKnownBlock is up-to-date\n \n             if (!fRevertToInv) {\n                 bool fFoundStartingHeader = false;\n@@ -3042,7 +3037,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                     // We only send up to 1 block as header-and-ids, as otherwise\n                     // probably means we're doing an initial-ish-sync or they're slow\n                     LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", __func__,\n-                            vHeaders.front().GetHash().ToString(), pto->id);\n+                            vHeaders.front().GetHash().ToString(), pto->GetId());\n \n                     int nSendFlags = state.fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n \n@@ -3072,10 +3067,10 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                         LogPrint(BCLog::NET, \"%s: %u headers, range (%s, %s), to peer=%d\\n\", __func__,\n                                 vHeaders.size(),\n                                 vHeaders.front().GetHash().ToString(),\n-                                vHeaders.back().GetHash().ToString(), pto->id);\n+                                vHeaders.back().GetHash().ToString(), pto->GetId());\n                     } else {\n                         LogPrint(BCLog::NET, \"%s: sending header %s to peer=%d\\n\", __func__,\n-                                vHeaders.front().GetHash().ToString(), pto->id);\n+                                vHeaders.front().GetHash().ToString(), pto->GetId());\n                     }\n                     connman.PushMessage(pto, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n                     state.pindexBestHeaderSent = pBestIndex;\n@@ -3104,7 +3099,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                     if (!PeerHasHeader(&state, pindex)) {\n                         pto->PushInventory(CInv(MSG_BLOCK, hashToAnnounce));\n                         LogPrint(BCLog::NET, \"%s: sending inv peer=%d hash=%s\\n\", __func__,\n-                            pto->id, hashToAnnounce.ToString());\n+                            pto->GetId(), hashToAnnounce.ToString());\n                     }\n                 }\n             }\n@@ -3302,7 +3297,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             // Stalling only triggers when the block download window cannot move. During normal steady state,\n             // the download window should be much larger than the to-be-downloaded set of blocks, so disconnection\n             // should only happen during initial block download.\n-            LogPrintf(\"Peer=%d is stalling block download, disconnecting\\n\", pto->id);\n+            LogPrintf(\"Peer=%d is stalling block download, disconnecting\\n\", pto->GetId());\n             pto->fDisconnect = true;\n             return true;\n         }\n@@ -3315,7 +3310,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             QueuedBlock &queuedBlock = state.vBlocksInFlight.front();\n             int nOtherPeersWithValidatedDownloads = nPeersWithValidatedDownloads - (state.nBlocksInFlightValidHeaders > 0);\n             if (nNow > state.nDownloadingSince + consensusParams.nPowTargetSpacing * (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {\n-                LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), pto->id);\n+                LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), pto->GetId());\n                 pto->fDisconnect = true;\n                 return true;\n             }\n@@ -3330,11 +3325,11 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             NodeId staller = -1;\n             FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n             BOOST_FOREACH(const CBlockIndex *pindex, vToDownload) {\n-                uint32_t nFetchFlags = GetFetchFlags(pto, pindex->pprev, consensusParams);\n+                uint32_t nFetchFlags = GetFetchFlags(pto);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), consensusParams, pindex);\n+                MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);\n                 LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n-                    pindex->nHeight, pto->id);\n+                    pindex->nHeight, pto->GetId());\n             }\n             if (state.nBlocksInFlight == 0 && staller != -1) {\n                 if (State(staller)->nStallingSince == 0) {\n@@ -3352,7 +3347,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             const CInv& inv = (*pto->mapAskFor.begin()).second;\n             if (!AlreadyHave(inv))\n             {\n-                LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->id);\n+                LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n                 vGetData.push_back(inv);\n                 if (vGetData.size() >= 1000)\n                 {"
      },
      {
        "sha": "34a7029862e4d16517bc07a9ff62d29e865887ac",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -179,12 +179,6 @@ bool CNetAddr::IsLocal() const\n    return false;\n }\n \n-bool CNetAddr::IsMulticast() const\n-{\n-    return    (IsIPv4() && (GetByte(3) & 0xF0) == 0xE0)\n-           || (GetByte(15) == 0xFF);\n-}\n-\n bool CNetAddr::IsValid() const\n {\n     // Cleanup 3-byte shifted addresses caused by garbage in size field"
      },
      {
        "sha": "fbc4d1a65f9e7f54eaa2b72e6a22ba13abfe2db4",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -65,7 +65,6 @@ class CNetAddr\n         bool IsLocal() const;\n         bool IsRoutable() const;\n         bool IsValid() const;\n-        bool IsMulticast() const;\n         enum Network GetNetwork() const;\n         std::string ToString() const;\n         std::string ToStringIP() const;"
      },
      {
        "sha": "32557dd179996b9d1f58d780662e3f7cf5ce6635",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 7,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -428,18 +428,14 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n     if (hSocket == INVALID_SOCKET)\n         return false;\n \n-    int set = 1;\n #ifdef SO_NOSIGPIPE\n+    int set = 1;\n     // Different way of disabling SIGPIPE on BSD\n     setsockopt(hSocket, SOL_SOCKET, SO_NOSIGPIPE, (void*)&set, sizeof(int));\n #endif\n \n     //Disable Nagle's algorithm\n-#ifdef WIN32\n-    setsockopt(hSocket, IPPROTO_TCP, TCP_NODELAY, (const char*)&set, sizeof(int));\n-#else\n-    setsockopt(hSocket, IPPROTO_TCP, TCP_NODELAY, (void*)&set, sizeof(int));\n-#endif\n+    SetSocketNoDelay(hSocket);\n \n     // Set to non-blocking\n     if (!SetSocketNonBlocking(hSocket, true))\n@@ -672,13 +668,14 @@ std::string NetworkErrorString(int err)\n std::string NetworkErrorString(int err)\n {\n     char buf[256];\n-    const char *s = buf;\n     buf[0] = 0;\n     /* Too bad there are two incompatible implementations of the\n      * thread-safe strerror. */\n+    const char *s;\n #ifdef STRERROR_R_CHAR_P /* GNU variant can return a pointer outside the passed buffer */\n     s = strerror_r(err, buf, sizeof(buf));\n #else /* POSIX variant always returns message in buffer */\n+    s = buf;\n     if (strerror_r(err, buf, sizeof(buf)))\n         buf[0] = 0;\n #endif\n@@ -728,6 +725,13 @@ bool SetSocketNonBlocking(SOCKET& hSocket, bool fNonBlocking)\n     return true;\n }\n \n+bool SetSocketNoDelay(SOCKET& hSocket)\n+{\n+    int set = 1;\n+    int rc = setsockopt(hSocket, IPPROTO_TCP, TCP_NODELAY, (const char*)&set, sizeof(int));\n+    return rc == 0;\n+}\n+\n void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;"
      },
      {
        "sha": "c9d108aadd1410da675ba0182132d84ce56f96dc",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -59,6 +59,8 @@ std::string NetworkErrorString(int err);\n bool CloseSocket(SOCKET& hSocket);\n /** Disable or enable blocking-mode for a socket */\n bool SetSocketNonBlocking(SOCKET& hSocket, bool fNonBlocking);\n+/** Set the TCP_NODELAY flag on a socket */\n+bool SetSocketNoDelay(SOCKET& hSocket);\n /**\n  * Convert milliseconds to a struct timeval for e.g. select.\n  */"
      },
      {
        "sha": "a089c02284f047ed68c791cddeedb8d978c91736",
        "filename": "src/policy/feerate.cpp",
        "status": "renamed",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/policy/feerate.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/policy/feerate.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/feerate.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -3,7 +3,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"amount.h\"\n+#include \"feerate.h\"\n \n #include \"tinyformat.h\"\n ",
        "previous_filename": "src/amount.cpp"
      },
      {
        "sha": "e82268b095a3196b16007ac58cf3967a40196ed2",
        "filename": "src/policy/feerate.h",
        "status": "added",
        "additions": 54,
        "deletions": 0,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/policy/feerate.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/policy/feerate.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/feerate.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -0,0 +1,54 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_POLICY_FEERATE_H\n+#define BITCOIN_POLICY_FEERATE_H\n+\n+#include \"amount.h\"\n+#include \"serialize.h\"\n+\n+#include <string>\n+\n+extern const std::string CURRENCY_UNIT;\n+\n+/**\n+ * Fee rate in satoshis per kilobyte: CAmount / kB\n+ */\n+class CFeeRate\n+{\n+private:\n+    CAmount nSatoshisPerK; // unit is satoshis-per-1,000-bytes\n+public:\n+    /** Fee rate of 0 satoshis per kB */\n+    CFeeRate() : nSatoshisPerK(0) { }\n+    explicit CFeeRate(const CAmount& _nSatoshisPerK): nSatoshisPerK(_nSatoshisPerK) { }\n+    /** Constructor for a fee rate in satoshis per kB. The size in bytes must not exceed (2^63 - 1)*/\n+    CFeeRate(const CAmount& nFeePaid, size_t nBytes);\n+    CFeeRate(const CFeeRate& other) { nSatoshisPerK = other.nSatoshisPerK; }\n+    /**\n+     * Return the fee in satoshis for the given size in bytes.\n+     */\n+    CAmount GetFee(size_t nBytes) const;\n+    /**\n+     * Return the fee in satoshis for a size of 1000 bytes\n+     */\n+    CAmount GetFeePerK() const { return GetFee(1000); }\n+    friend bool operator<(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK < b.nSatoshisPerK; }\n+    friend bool operator>(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK > b.nSatoshisPerK; }\n+    friend bool operator==(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK == b.nSatoshisPerK; }\n+    friend bool operator<=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK <= b.nSatoshisPerK; }\n+    friend bool operator>=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK >= b.nSatoshisPerK; }\n+    CFeeRate& operator+=(const CFeeRate& a) { nSatoshisPerK += a.nSatoshisPerK; return *this; }\n+    std::string ToString() const;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        READWRITE(nSatoshisPerK);\n+    }\n+};\n+\n+#endif //  BITCOIN_POLICY_FEERATE_H"
      },
      {
        "sha": "66083fe1ee052a5a394320e1168389b50621edae",
        "filename": "src/policy/fees.cpp",
        "status": "modified",
        "additions": 619,
        "deletions": 141,
        "changes": 760,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/policy/fees.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/policy/fees.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -7,46 +7,163 @@\n #include \"policy/policy.h\"\n \n #include \"amount.h\"\n+#include \"clientversion.h\"\n #include \"primitives/transaction.h\"\n #include \"random.h\"\n #include \"streams.h\"\n #include \"txmempool.h\"\n #include \"util.h\"\n \n-void TxConfirmStats::Initialize(std::vector<double>& defaultBuckets,\n-                                unsigned int maxConfirms, double _decay)\n+static constexpr double INF_FEERATE = 1e99;\n+\n+/**\n+ * We will instantiate an instance of this class to track transactions that were\n+ * included in a block. We will lump transactions into a bucket according to their\n+ * approximate feerate and then track how long it took for those txs to be included in a block\n+ *\n+ * The tracking of unconfirmed (mempool) transactions is completely independent of the\n+ * historical tracking of transactions that have been confirmed in a block.\n+ */\n+class TxConfirmStats\n+{\n+private:\n+    //Define the buckets we will group transactions into\n+    const std::vector<double>& buckets;              // The upper-bound of the range for the bucket (inclusive)\n+    const std::map<double, unsigned int>& bucketMap; // Map of bucket upper-bound to index into all vectors by bucket\n+\n+    // For each bucket X:\n+    // Count the total # of txs in each bucket\n+    // Track the historical moving average of this total over blocks\n+    std::vector<double> txCtAvg;\n+\n+    // Count the total # of txs confirmed within Y blocks in each bucket\n+    // Track the historical moving average of theses totals over blocks\n+    std::vector<std::vector<double>> confAvg; // confAvg[Y][X]\n+\n+    // Track moving avg of txs which have been evicted from the mempool\n+    // after failing to be confirmed within Y blocks\n+    std::vector<std::vector<double>> failAvg; // failAvg[Y][X]\n+\n+    // Sum the total feerate of all tx's in each bucket\n+    // Track the historical moving average of this total over blocks\n+    std::vector<double> avg;\n+\n+    // Combine the conf counts with tx counts to calculate the confirmation % for each Y,X\n+    // Combine the total value with the tx counts to calculate the avg feerate per bucket\n+\n+    double decay;\n+\n+    // Resolution (# of blocks) with which confirmations are tracked\n+    unsigned int scale;\n+\n+    // Mempool counts of outstanding transactions\n+    // For each bucket X, track the number of transactions in the mempool\n+    // that are unconfirmed for each possible confirmation value Y\n+    std::vector<std::vector<int> > unconfTxs;  //unconfTxs[Y][X]\n+    // transactions still unconfirmed after GetMaxConfirms for each bucket\n+    std::vector<int> oldUnconfTxs;\n+\n+    void resizeInMemoryCounters(size_t newbuckets);\n+\n+public:\n+    /**\n+     * Create new TxConfirmStats. This is called by BlockPolicyEstimator's\n+     * constructor with default values.\n+     * @param defaultBuckets contains the upper limits for the bucket boundaries\n+     * @param maxConfirms max number of confirms to track\n+     * @param decay how much to decay the historical moving average per block\n+     */\n+    TxConfirmStats(const std::vector<double>& defaultBuckets, const std::map<double, unsigned int>& defaultBucketMap,\n+                   unsigned int maxPeriods, double decay, unsigned int scale);\n+\n+    /** Roll the circular buffer for unconfirmed txs*/\n+    void ClearCurrent(unsigned int nBlockHeight);\n+\n+    /**\n+     * Record a new transaction data point in the current block stats\n+     * @param blocksToConfirm the number of blocks it took this transaction to confirm\n+     * @param val the feerate of the transaction\n+     * @warning blocksToConfirm is 1-based and has to be >= 1\n+     */\n+    void Record(int blocksToConfirm, double val);\n+\n+    /** Record a new transaction entering the mempool*/\n+    unsigned int NewTx(unsigned int nBlockHeight, double val);\n+\n+    /** Remove a transaction from mempool tracking stats*/\n+    void removeTx(unsigned int entryHeight, unsigned int nBestSeenHeight,\n+                  unsigned int bucketIndex, bool inBlock);\n+\n+    /** Update our estimates by decaying our historical moving average and updating\n+        with the data gathered from the current block */\n+    void UpdateMovingAverages();\n+\n+    /**\n+     * Calculate a feerate estimate.  Find the lowest value bucket (or range of buckets\n+     * to make sure we have enough data points) whose transactions still have sufficient likelihood\n+     * of being confirmed within the target number of confirmations\n+     * @param confTarget target number of confirmations\n+     * @param sufficientTxVal required average number of transactions per block in a bucket range\n+     * @param minSuccess the success probability we require\n+     * @param requireGreater return the lowest feerate such that all higher values pass minSuccess OR\n+     *        return the highest feerate such that all lower values fail minSuccess\n+     * @param nBlockHeight the current block height\n+     */\n+    double EstimateMedianVal(int confTarget, double sufficientTxVal,\n+                             double minSuccess, bool requireGreater, unsigned int nBlockHeight,\n+                             EstimationResult *result = nullptr) const;\n+\n+    /** Return the max number of confirms we're tracking */\n+    unsigned int GetMaxConfirms() const { return scale * confAvg.size(); }\n+\n+    /** Write state of estimation data to a file*/\n+    void Write(CAutoFile& fileout) const;\n+\n+    /**\n+     * Read saved state of estimation data from a file and replace all internal data structures and\n+     * variables with this state.\n+     */\n+    void Read(CAutoFile& filein, int nFileVersion, size_t numBuckets);\n+};\n+\n+\n+TxConfirmStats::TxConfirmStats(const std::vector<double>& defaultBuckets,\n+                                const std::map<double, unsigned int>& defaultBucketMap,\n+                               unsigned int maxPeriods, double _decay, unsigned int _scale)\n+    : buckets(defaultBuckets), bucketMap(defaultBucketMap)\n {\n     decay = _decay;\n-    for (unsigned int i = 0; i < defaultBuckets.size(); i++) {\n-        buckets.push_back(defaultBuckets[i]);\n-        bucketMap[defaultBuckets[i]] = i;\n-    }\n-    confAvg.resize(maxConfirms);\n-    curBlockConf.resize(maxConfirms);\n-    unconfTxs.resize(maxConfirms);\n-    for (unsigned int i = 0; i < maxConfirms; i++) {\n+    scale = _scale;\n+    confAvg.resize(maxPeriods);\n+    for (unsigned int i = 0; i < maxPeriods; i++) {\n         confAvg[i].resize(buckets.size());\n-        curBlockConf[i].resize(buckets.size());\n-        unconfTxs[i].resize(buckets.size());\n+    }\n+    failAvg.resize(maxPeriods);\n+    for (unsigned int i = 0; i < maxPeriods; i++) {\n+        failAvg[i].resize(buckets.size());\n     }\n \n-    oldUnconfTxs.resize(buckets.size());\n-    curBlockTxCt.resize(buckets.size());\n     txCtAvg.resize(buckets.size());\n-    curBlockVal.resize(buckets.size());\n     avg.resize(buckets.size());\n+\n+    resizeInMemoryCounters(buckets.size());\n+}\n+\n+void TxConfirmStats::resizeInMemoryCounters(size_t newbuckets) {\n+    // newbuckets must be passed in because the buckets referred to during Read have not been updated yet.\n+    unconfTxs.resize(GetMaxConfirms());\n+    for (unsigned int i = 0; i < unconfTxs.size(); i++) {\n+        unconfTxs[i].resize(newbuckets);\n+    }\n+    oldUnconfTxs.resize(newbuckets);\n }\n \n-// Zero out the data for the current block\n+// Roll the unconfirmed txs circular buffer\n void TxConfirmStats::ClearCurrent(unsigned int nBlockHeight)\n {\n     for (unsigned int j = 0; j < buckets.size(); j++) {\n         oldUnconfTxs[j] += unconfTxs[nBlockHeight%unconfTxs.size()][j];\n         unconfTxs[nBlockHeight%unconfTxs.size()][j] = 0;\n-        for (unsigned int i = 0; i < curBlockConf.size(); i++)\n-            curBlockConf[i][j] = 0;\n-        curBlockTxCt[j] = 0;\n-        curBlockVal[j] = 0;\n     }\n }\n \n@@ -56,33 +173,38 @@ void TxConfirmStats::Record(int blocksToConfirm, double val)\n     // blocksToConfirm is 1-based\n     if (blocksToConfirm < 1)\n         return;\n+    int periodsToConfirm = (blocksToConfirm + scale - 1)/scale;\n     unsigned int bucketindex = bucketMap.lower_bound(val)->second;\n-    for (size_t i = blocksToConfirm; i <= curBlockConf.size(); i++) {\n-        curBlockConf[i - 1][bucketindex]++;\n+    for (size_t i = periodsToConfirm; i <= confAvg.size(); i++) {\n+        confAvg[i - 1][bucketindex]++;\n     }\n-    curBlockTxCt[bucketindex]++;\n-    curBlockVal[bucketindex] += val;\n+    txCtAvg[bucketindex]++;\n+    avg[bucketindex] += val;\n }\n \n void TxConfirmStats::UpdateMovingAverages()\n {\n     for (unsigned int j = 0; j < buckets.size(); j++) {\n         for (unsigned int i = 0; i < confAvg.size(); i++)\n-            confAvg[i][j] = confAvg[i][j] * decay + curBlockConf[i][j];\n-        avg[j] = avg[j] * decay + curBlockVal[j];\n-        txCtAvg[j] = txCtAvg[j] * decay + curBlockTxCt[j];\n+            confAvg[i][j] = confAvg[i][j] * decay;\n+        for (unsigned int i = 0; i < failAvg.size(); i++)\n+            failAvg[i][j] = failAvg[i][j] * decay;\n+        avg[j] = avg[j] * decay;\n+        txCtAvg[j] = txCtAvg[j] * decay;\n     }\n }\n \n // returns -1 on error conditions\n double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n                                          double successBreakPoint, bool requireGreater,\n-                                         unsigned int nBlockHeight)\n+                                         unsigned int nBlockHeight, EstimationResult *result) const\n {\n     // Counters for a bucket (or range of buckets)\n     double nConf = 0; // Number of tx's confirmed within the confTarget\n     double totalNum = 0; // Total number of tx's that were ever confirmed\n     int extraNum = 0;  // Number of tx's still in mempool for confTarget or longer\n+    double failNum = 0; // Number of tx's that were never confirmed but removed from the mempool after confTarget\n+    int periodTarget = (confTarget + scale - 1)/scale;\n \n     int maxbucketindex = buckets.size() - 1;\n \n@@ -105,12 +227,21 @@ double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n \n     bool foundAnswer = false;\n     unsigned int bins = unconfTxs.size();\n+    bool newBucketRange = true;\n+    bool passing = true;\n+    EstimatorBucket passBucket;\n+    EstimatorBucket failBucket;\n \n     // Start counting from highest(default) or lowest feerate transactions\n     for (int bucket = startbucket; bucket >= 0 && bucket <= maxbucketindex; bucket += step) {\n+        if (newBucketRange) {\n+            curNearBucket = bucket;\n+            newBucketRange = false;\n+        }\n         curFarBucket = bucket;\n-        nConf += confAvg[confTarget - 1][bucket];\n+        nConf += confAvg[periodTarget - 1][bucket];\n         totalNum += txCtAvg[bucket];\n+        failNum += failAvg[periodTarget - 1][bucket];\n         for (unsigned int confct = confTarget; confct < GetMaxConfirms(); confct++)\n             extraNum += unconfTxs[(nBlockHeight - confct)%bins][bucket];\n         extraNum += oldUnconfTxs[bucket];\n@@ -119,24 +250,41 @@ double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n         // (Only count the confirmed data points, so that each confirmation count\n         // will be looking at the same amount of data and same bucket breaks)\n         if (totalNum >= sufficientTxVal / (1 - decay)) {\n-            double curPct = nConf / (totalNum + extraNum);\n+            double curPct = nConf / (totalNum + failNum + extraNum);\n \n             // Check to see if we are no longer getting confirmed at the success rate\n-            if (requireGreater && curPct < successBreakPoint)\n-                break;\n-            if (!requireGreater && curPct > successBreakPoint)\n-                break;\n-\n+            if ((requireGreater && curPct < successBreakPoint) || (!requireGreater && curPct > successBreakPoint)) {\n+                if (passing == true) {\n+                    // First time we hit a failure record the failed bucket\n+                    unsigned int failMinBucket = std::min(curNearBucket, curFarBucket);\n+                    unsigned int failMaxBucket = std::max(curNearBucket, curFarBucket);\n+                    failBucket.start = failMinBucket ? buckets[failMinBucket - 1] : 0;\n+                    failBucket.end = buckets[failMaxBucket];\n+                    failBucket.withinTarget = nConf;\n+                    failBucket.totalConfirmed = totalNum;\n+                    failBucket.inMempool = extraNum;\n+                    failBucket.leftMempool = failNum;\n+                    passing = false;\n+                }\n+                continue;\n+            }\n             // Otherwise update the cumulative stats, and the bucket variables\n             // and reset the counters\n             else {\n+                failBucket = EstimatorBucket(); // Reset any failed bucket, currently passing\n                 foundAnswer = true;\n+                passing = true;\n+                passBucket.withinTarget = nConf;\n                 nConf = 0;\n+                passBucket.totalConfirmed = totalNum;\n                 totalNum = 0;\n+                passBucket.inMempool = extraNum;\n+                passBucket.leftMempool = failNum;\n+                failNum = 0;\n                 extraNum = 0;\n                 bestNearBucket = curNearBucket;\n                 bestFarBucket = curFarBucket;\n-                curNearBucket = bucket + step;\n+                newBucketRange = true;\n             }\n         }\n     }\n@@ -148,8 +296,8 @@ double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n     // Find the bucket with the median transaction and then report the average feerate from that bucket\n     // This is a compromise between finding the median which we can't since we don't save all tx's\n     // and reporting the average which is less accurate\n-    unsigned int minBucket = bestNearBucket < bestFarBucket ? bestNearBucket : bestFarBucket;\n-    unsigned int maxBucket = bestNearBucket > bestFarBucket ? bestNearBucket : bestFarBucket;\n+    unsigned int minBucket = std::min(bestNearBucket, bestFarBucket);\n+    unsigned int maxBucket = std::max(bestNearBucket, bestFarBucket);\n     for (unsigned int j = minBucket; j <= maxBucket; j++) {\n         txSum += txCtAvg[j];\n     }\n@@ -163,83 +311,109 @@ double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n                 break;\n             }\n         }\n+\n+        passBucket.start = minBucket ? buckets[minBucket-1] : 0;\n+        passBucket.end = buckets[maxBucket];\n     }\n \n-    LogPrint(BCLog::ESTIMATEFEE, \"%3d: For conf success %s %4.2f need feerate %s: %12.5g from buckets %8g - %8g  Cur Bucket stats %6.2f%%  %8.1f/(%.1f+%d mempool)\\n\",\n-             confTarget, requireGreater ? \">\" : \"<\", successBreakPoint,\n-             requireGreater ? \">\" : \"<\", median, buckets[minBucket], buckets[maxBucket],\n-             100 * nConf / (totalNum + extraNum), nConf, totalNum, extraNum);\n+    // If we were passing until we reached last few buckets with insufficient data, then report those as failed\n+    if (passing && !newBucketRange) {\n+        unsigned int failMinBucket = std::min(curNearBucket, curFarBucket);\n+        unsigned int failMaxBucket = std::max(curNearBucket, curFarBucket);\n+        failBucket.start = failMinBucket ? buckets[failMinBucket - 1] : 0;\n+        failBucket.end = buckets[failMaxBucket];\n+        failBucket.withinTarget = nConf;\n+        failBucket.totalConfirmed = totalNum;\n+        failBucket.inMempool = extraNum;\n+        failBucket.leftMempool = failNum;\n+    }\n \n+    LogPrint(BCLog::ESTIMATEFEE, \"FeeEst: %d %s%.0f%% decay %.5f: feerate: %g from (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\",\n+             confTarget, requireGreater ? \">\" : \"<\", 100.0 * successBreakPoint, decay,\n+             median, passBucket.start, passBucket.end,\n+             100 * passBucket.withinTarget / (passBucket.totalConfirmed + passBucket.inMempool + passBucket.leftMempool),\n+             passBucket.withinTarget, passBucket.totalConfirmed, passBucket.inMempool, passBucket.leftMempool,\n+             failBucket.start, failBucket.end,\n+             100 * failBucket.withinTarget / (failBucket.totalConfirmed + failBucket.inMempool + failBucket.leftMempool),\n+             failBucket.withinTarget, failBucket.totalConfirmed, failBucket.inMempool, failBucket.leftMempool);\n+\n+\n+    if (result) {\n+        result->pass = passBucket;\n+        result->fail = failBucket;\n+        result->decay = decay;\n+        result->scale = scale;\n+    }\n     return median;\n }\n \n-void TxConfirmStats::Write(CAutoFile& fileout)\n+void TxConfirmStats::Write(CAutoFile& fileout) const\n {\n     fileout << decay;\n-    fileout << buckets;\n+    fileout << scale;\n     fileout << avg;\n     fileout << txCtAvg;\n     fileout << confAvg;\n+    fileout << failAvg;\n }\n \n-void TxConfirmStats::Read(CAutoFile& filein)\n+void TxConfirmStats::Read(CAutoFile& filein, int nFileVersion, size_t numBuckets)\n {\n-    // Read data file into temporary variables and do some very basic sanity checking\n-    std::vector<double> fileBuckets;\n-    std::vector<double> fileAvg;\n-    std::vector<std::vector<double> > fileConfAvg;\n-    std::vector<double> fileTxCtAvg;\n-    double fileDecay;\n-    size_t maxConfirms;\n-    size_t numBuckets;\n-\n-    filein >> fileDecay;\n-    if (fileDecay <= 0 || fileDecay >= 1)\n-        throw std::runtime_error(\"Corrupt estimates file. Decay must be between 0 and 1 (non-inclusive)\");\n-    filein >> fileBuckets;\n-    numBuckets = fileBuckets.size();\n-    if (numBuckets <= 1 || numBuckets > 1000)\n-        throw std::runtime_error(\"Corrupt estimates file. Must have between 2 and 1000 feerate buckets\");\n-    filein >> fileAvg;\n-    if (fileAvg.size() != numBuckets)\n+    // Read data file and do some very basic sanity checking\n+    // buckets and bucketMap are not updated yet, so don't access them\n+    // If there is a read failure, we'll just discard this entire object anyway\n+    size_t maxConfirms, maxPeriods;\n+\n+    // The current version will store the decay with each individual TxConfirmStats and also keep a scale factor\n+    if (nFileVersion >= 149900) {\n+        filein >> decay;\n+        if (decay <= 0 || decay >= 1) {\n+            throw std::runtime_error(\"Corrupt estimates file. Decay must be between 0 and 1 (non-inclusive)\");\n+        }\n+        filein >> scale;\n+    }\n+\n+    filein >> avg;\n+    if (avg.size() != numBuckets) {\n         throw std::runtime_error(\"Corrupt estimates file. Mismatch in feerate average bucket count\");\n-    filein >> fileTxCtAvg;\n-    if (fileTxCtAvg.size() != numBuckets)\n+    }\n+    filein >> txCtAvg;\n+    if (txCtAvg.size() != numBuckets) {\n         throw std::runtime_error(\"Corrupt estimates file. Mismatch in tx count bucket count\");\n-    filein >> fileConfAvg;\n-    maxConfirms = fileConfAvg.size();\n-    if (maxConfirms <= 0 || maxConfirms > 6 * 24 * 7) // one week\n-        throw std::runtime_error(\"Corrupt estimates file.  Must maintain estimates for between 1 and 1008 (one week) confirms\");\n-    for (unsigned int i = 0; i < maxConfirms; i++) {\n-        if (fileConfAvg[i].size() != numBuckets)\n-            throw std::runtime_error(\"Corrupt estimates file. Mismatch in feerate conf average bucket count\");\n     }\n-    // Now that we've processed the entire feerate estimate data file and not\n-    // thrown any errors, we can copy it to our data structures\n-    decay = fileDecay;\n-    buckets = fileBuckets;\n-    avg = fileAvg;\n-    confAvg = fileConfAvg;\n-    txCtAvg = fileTxCtAvg;\n-    bucketMap.clear();\n+    filein >> confAvg;\n+    maxPeriods = confAvg.size();\n+    maxConfirms = scale * maxPeriods;\n \n-    // Resize the current block variables which aren't stored in the data file\n-    // to match the number of confirms and buckets\n-    curBlockConf.resize(maxConfirms);\n-    for (unsigned int i = 0; i < maxConfirms; i++) {\n-        curBlockConf[i].resize(buckets.size());\n+    if (maxConfirms <= 0 || maxConfirms > 6 * 24 * 7) { // one week\n+        throw std::runtime_error(\"Corrupt estimates file.  Must maintain estimates for between 1 and 1008 (one week) confirms\");\n+    }\n+    for (unsigned int i = 0; i < maxPeriods; i++) {\n+        if (confAvg[i].size() != numBuckets) {\n+            throw std::runtime_error(\"Corrupt estimates file. Mismatch in feerate conf average bucket count\");\n+        }\n     }\n-    curBlockTxCt.resize(buckets.size());\n-    curBlockVal.resize(buckets.size());\n \n-    unconfTxs.resize(maxConfirms);\n-    for (unsigned int i = 0; i < maxConfirms; i++) {\n-        unconfTxs[i].resize(buckets.size());\n+    if (nFileVersion >= 149900) {\n+        filein >> failAvg;\n+        if (maxPeriods != failAvg.size()) {\n+            throw std::runtime_error(\"Corrupt estimates file. Mismatch in confirms tracked for failures\");\n+        }\n+        for (unsigned int i = 0; i < maxPeriods; i++) {\n+            if (failAvg[i].size() != numBuckets) {\n+                throw std::runtime_error(\"Corrupt estimates file. Mismatch in one of failure average bucket counts\");\n+            }\n+        }\n+    } else {\n+        failAvg.resize(confAvg.size());\n+        for (unsigned int i = 0; i < failAvg.size(); i++) {\n+            failAvg[i].resize(numBuckets);\n+        }\n     }\n-    oldUnconfTxs.resize(buckets.size());\n \n-    for (unsigned int i = 0; i < buckets.size(); i++)\n-        bucketMap[buckets[i]] = i;\n+    // Resize the current block variables which aren't stored in the data file\n+    // to match the number of confirms and buckets\n+    resizeInMemoryCounters(numBuckets);\n \n     LogPrint(BCLog::ESTIMATEFEE, \"Reading estimates: %u buckets counting confirms up to %u blocks\\n\",\n              numBuckets, maxConfirms);\n@@ -253,7 +427,7 @@ unsigned int TxConfirmStats::NewTx(unsigned int nBlockHeight, double val)\n     return bucketindex;\n }\n \n-void TxConfirmStats::removeTx(unsigned int entryHeight, unsigned int nBestSeenHeight, unsigned int bucketindex)\n+void TxConfirmStats::removeTx(unsigned int entryHeight, unsigned int nBestSeenHeight, unsigned int bucketindex, bool inBlock)\n {\n     //nBestSeenHeight is not updated yet for the new block\n     int blocksAgo = nBestSeenHeight - entryHeight;\n@@ -281,18 +455,27 @@ void TxConfirmStats::removeTx(unsigned int entryHeight, unsigned int nBestSeenHe\n                      blockIndex, bucketindex);\n         }\n     }\n+    if (!inBlock && (unsigned int)blocksAgo >= scale) { // Only counts as a failure if not confirmed for entire period\n+        unsigned int periodsAgo = blocksAgo / scale;\n+        for (size_t i = 0; i < periodsAgo && i < failAvg.size(); i++) {\n+            failAvg[i][bucketindex]++;\n+        }\n+    }\n }\n \n // This function is called from CTxMemPool::removeUnchecked to ensure\n // txs removed from the mempool for any reason are no longer\n // tracked. Txs that were part of a block have already been removed in\n // processBlockTx to ensure they are never double tracked, but it is\n // of no harm to try to remove them again.\n-bool CBlockPolicyEstimator::removeTx(uint256 hash)\n+bool CBlockPolicyEstimator::removeTx(uint256 hash, bool inBlock)\n {\n+    LOCK(cs_feeEstimator);\n     std::map<uint256, TxStatsInfo>::iterator pos = mapMemPoolTxs.find(hash);\n     if (pos != mapMemPoolTxs.end()) {\n-        feeStats.removeTx(pos->second.blockHeight, nBestSeenHeight, pos->second.bucketIndex);\n+        feeStats->removeTx(pos->second.blockHeight, nBestSeenHeight, pos->second.bucketIndex, inBlock);\n+        shortStats->removeTx(pos->second.blockHeight, nBestSeenHeight, pos->second.bucketIndex, inBlock);\n+        longStats->removeTx(pos->second.blockHeight, nBestSeenHeight, pos->second.bucketIndex, inBlock);\n         mapMemPoolTxs.erase(hash);\n         return true;\n     } else {\n@@ -301,20 +484,33 @@ bool CBlockPolicyEstimator::removeTx(uint256 hash)\n }\n \n CBlockPolicyEstimator::CBlockPolicyEstimator()\n-    : nBestSeenHeight(0), trackedTxs(0), untrackedTxs(0)\n+    : nBestSeenHeight(0), firstRecordedHeight(0), historicalFirst(0), historicalBest(0), trackedTxs(0), untrackedTxs(0)\n {\n     static_assert(MIN_BUCKET_FEERATE > 0, \"Min feerate must be nonzero\");\n-    minTrackedFee = CFeeRate(MIN_BUCKET_FEERATE);\n-    std::vector<double> vfeelist;\n-    for (double bucketBoundary = minTrackedFee.GetFeePerK(); bucketBoundary <= MAX_BUCKET_FEERATE; bucketBoundary *= FEE_SPACING) {\n-        vfeelist.push_back(bucketBoundary);\n+    size_t bucketIndex = 0;\n+    for (double bucketBoundary = MIN_BUCKET_FEERATE; bucketBoundary <= MAX_BUCKET_FEERATE; bucketBoundary *= FEE_SPACING, bucketIndex++) {\n+        buckets.push_back(bucketBoundary);\n+        bucketMap[bucketBoundary] = bucketIndex;\n     }\n-    vfeelist.push_back(INF_FEERATE);\n-    feeStats.Initialize(vfeelist, MAX_BLOCK_CONFIRMS, DEFAULT_DECAY);\n+    buckets.push_back(INF_FEERATE);\n+    bucketMap[INF_FEERATE] = bucketIndex;\n+    assert(bucketMap.size() == buckets.size());\n+\n+    feeStats = new TxConfirmStats(buckets, bucketMap, MED_BLOCK_PERIODS, MED_DECAY, MED_SCALE);\n+    shortStats = new TxConfirmStats(buckets, bucketMap, SHORT_BLOCK_PERIODS, SHORT_DECAY, SHORT_SCALE);\n+    longStats = new TxConfirmStats(buckets, bucketMap, LONG_BLOCK_PERIODS, LONG_DECAY, LONG_SCALE);\n+}\n+\n+CBlockPolicyEstimator::~CBlockPolicyEstimator()\n+{\n+    delete feeStats;\n+    delete shortStats;\n+    delete longStats;\n }\n \n void CBlockPolicyEstimator::processTransaction(const CTxMemPoolEntry& entry, bool validFeeEstimate)\n {\n+    LOCK(cs_feeEstimator);\n     unsigned int txHeight = entry.GetHeight();\n     uint256 hash = entry.GetTx().GetHash();\n     if (mapMemPoolTxs.count(hash)) {\n@@ -343,12 +539,17 @@ void CBlockPolicyEstimator::processTransaction(const CTxMemPoolEntry& entry, boo\n     CFeeRate feeRate(entry.GetFee(), entry.GetTxSize());\n \n     mapMemPoolTxs[hash].blockHeight = txHeight;\n-    mapMemPoolTxs[hash].bucketIndex = feeStats.NewTx(txHeight, (double)feeRate.GetFeePerK());\n+    unsigned int bucketIndex = feeStats->NewTx(txHeight, (double)feeRate.GetFeePerK());\n+    mapMemPoolTxs[hash].bucketIndex = bucketIndex;\n+    unsigned int bucketIndex2 = shortStats->NewTx(txHeight, (double)feeRate.GetFeePerK());\n+    assert(bucketIndex == bucketIndex2);\n+    unsigned int bucketIndex3 = longStats->NewTx(txHeight, (double)feeRate.GetFeePerK());\n+    assert(bucketIndex == bucketIndex3);\n }\n \n bool CBlockPolicyEstimator::processBlockTx(unsigned int nBlockHeight, const CTxMemPoolEntry* entry)\n {\n-    if (!removeTx(entry->GetTx().GetHash())) {\n+    if (!removeTx(entry->GetTx().GetHash(), true)) {\n         // This transaction wasn't being tracked for fee estimation\n         return false;\n     }\n@@ -367,13 +568,16 @@ bool CBlockPolicyEstimator::processBlockTx(unsigned int nBlockHeight, const CTxM\n     // Feerates are stored and reported as BTC-per-kb:\n     CFeeRate feeRate(entry->GetFee(), entry->GetTxSize());\n \n-    feeStats.Record(blocksToConfirm, (double)feeRate.GetFeePerK());\n+    feeStats->Record(blocksToConfirm, (double)feeRate.GetFeePerK());\n+    shortStats->Record(blocksToConfirm, (double)feeRate.GetFeePerK());\n+    longStats->Record(blocksToConfirm, (double)feeRate.GetFeePerK());\n     return true;\n }\n \n void CBlockPolicyEstimator::processBlock(unsigned int nBlockHeight,\n                                          std::vector<const CTxMemPoolEntry*>& entries)\n {\n+    LOCK(cs_feeEstimator);\n     if (nBlockHeight <= nBestSeenHeight) {\n         // Ignore side chains and re-orgs; assuming they are random\n         // they don't affect the estimate.\n@@ -388,60 +592,226 @@ void CBlockPolicyEstimator::processBlock(unsigned int nBlockHeight,\n     // of unconfirmed txs to remove from tracking.\n     nBestSeenHeight = nBlockHeight;\n \n-    // Clear the current block state and update unconfirmed circular buffer\n-    feeStats.ClearCurrent(nBlockHeight);\n+    // Update unconfirmed circular buffer\n+    feeStats->ClearCurrent(nBlockHeight);\n+    shortStats->ClearCurrent(nBlockHeight);\n+    longStats->ClearCurrent(nBlockHeight);\n+\n+    // Decay all exponential averages\n+    feeStats->UpdateMovingAverages();\n+    shortStats->UpdateMovingAverages();\n+    longStats->UpdateMovingAverages();\n \n     unsigned int countedTxs = 0;\n-    // Repopulate the current block states\n-    for (unsigned int i = 0; i < entries.size(); i++) {\n-        if (processBlockTx(nBlockHeight, entries[i]))\n+    // Update averages with data points from current block\n+    for (const auto& entry : entries) {\n+        if (processBlockTx(nBlockHeight, entry))\n             countedTxs++;\n     }\n \n-    // Update all exponential averages with the current block state\n-    feeStats.UpdateMovingAverages();\n+    if (firstRecordedHeight == 0 && countedTxs > 0) {\n+        firstRecordedHeight = nBestSeenHeight;\n+        LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy first recorded height %u\\n\", firstRecordedHeight);\n+    }\n+\n \n-    LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy after updating estimates for %u of %u txs in block, since last block %u of %u tracked, new mempool map size %u\\n\",\n-             countedTxs, entries.size(), trackedTxs, trackedTxs + untrackedTxs, mapMemPoolTxs.size());\n+    LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy estimates updated by %u of %u block txs, since last block %u of %u tracked, mempool map size %u, max target %u from %s\\n\",\n+             countedTxs, entries.size(), trackedTxs, trackedTxs + untrackedTxs, mapMemPoolTxs.size(),\n+             MaxUsableEstimate(), HistoricalBlockSpan() > BlockSpan() ? \"historical\" : \"current\");\n \n     trackedTxs = 0;\n     untrackedTxs = 0;\n }\n \n-CFeeRate CBlockPolicyEstimator::estimateFee(int confTarget)\n+CFeeRate CBlockPolicyEstimator::estimateFee(int confTarget) const\n {\n-    // Return failure if trying to analyze a target we're not tracking\n     // It's not possible to get reasonable estimates for confTarget of 1\n-    if (confTarget <= 1 || (unsigned int)confTarget > feeStats.GetMaxConfirms())\n+    if (confTarget <= 1)\n+        return CFeeRate(0);\n+\n+    return estimateRawFee(confTarget, DOUBLE_SUCCESS_PCT, FeeEstimateHorizon::MED_HALFLIFE);\n+}\n+\n+CFeeRate CBlockPolicyEstimator::estimateRawFee(int confTarget, double successThreshold, FeeEstimateHorizon horizon, EstimationResult* result) const\n+{\n+    TxConfirmStats* stats;\n+    double sufficientTxs = SUFFICIENT_FEETXS;\n+    switch (horizon) {\n+    case FeeEstimateHorizon::SHORT_HALFLIFE: {\n+        stats = shortStats;\n+        sufficientTxs = SUFFICIENT_TXS_SHORT;\n+        break;\n+    }\n+    case FeeEstimateHorizon::MED_HALFLIFE: {\n+        stats = feeStats;\n+        break;\n+    }\n+    case FeeEstimateHorizon::LONG_HALFLIFE: {\n+        stats = longStats;\n+        break;\n+    }\n+    default: {\n         return CFeeRate(0);\n+    }\n+    }\n \n-    double median = feeStats.EstimateMedianVal(confTarget, SUFFICIENT_FEETXS, MIN_SUCCESS_PCT, true, nBestSeenHeight);\n+    LOCK(cs_feeEstimator);\n+    // Return failure if trying to analyze a target we're not tracking\n+    if (confTarget <= 0 || (unsigned int)confTarget > stats->GetMaxConfirms())\n+        return CFeeRate(0);\n+    if (successThreshold > 1)\n+        return CFeeRate(0);\n+\n+    double median = stats->EstimateMedianVal(confTarget, sufficientTxs, successThreshold, true, nBestSeenHeight, result);\n \n     if (median < 0)\n         return CFeeRate(0);\n \n     return CFeeRate(median);\n }\n \n-CFeeRate CBlockPolicyEstimator::estimateSmartFee(int confTarget, int *answerFoundAtTarget, const CTxMemPool& pool)\n+unsigned int CBlockPolicyEstimator::BlockSpan() const\n+{\n+    if (firstRecordedHeight == 0) return 0;\n+    assert(nBestSeenHeight >= firstRecordedHeight);\n+\n+    return nBestSeenHeight - firstRecordedHeight;\n+}\n+\n+unsigned int CBlockPolicyEstimator::HistoricalBlockSpan() const\n+{\n+    if (historicalFirst == 0) return 0;\n+    assert(historicalBest >= historicalFirst);\n+\n+    if (nBestSeenHeight - historicalBest > OLDEST_ESTIMATE_HISTORY) return 0;\n+\n+    return historicalBest - historicalFirst;\n+}\n+\n+unsigned int CBlockPolicyEstimator::MaxUsableEstimate() const\n+{\n+    // Block spans are divided by 2 to make sure there are enough potential failing data points for the estimate\n+    return std::min(longStats->GetMaxConfirms(), std::max(BlockSpan(), HistoricalBlockSpan()) / 2);\n+}\n+\n+/** Return a fee estimate at the required successThreshold from the shortest\n+ * time horizon which tracks confirmations up to the desired target.  If\n+ * checkShorterHorizon is requested, also allow short time horizon estimates\n+ * for a lower target to reduce the given answer */\n+double CBlockPolicyEstimator::estimateCombinedFee(unsigned int confTarget, double successThreshold, bool checkShorterHorizon) const\n+{\n+    double estimate = -1;\n+    if (confTarget >= 1 && confTarget <= longStats->GetMaxConfirms()) {\n+        // Find estimate from shortest time horizon possible\n+        if (confTarget <= shortStats->GetMaxConfirms()) { // short horizon\n+            estimate = shortStats->EstimateMedianVal(confTarget, SUFFICIENT_TXS_SHORT, successThreshold, true, nBestSeenHeight);\n+        }\n+        else if (confTarget <= feeStats->GetMaxConfirms()) { // medium horizon\n+            estimate = feeStats->EstimateMedianVal(confTarget, SUFFICIENT_FEETXS, successThreshold, true, nBestSeenHeight);\n+        }\n+        else { // long horizon\n+            estimate = longStats->EstimateMedianVal(confTarget, SUFFICIENT_FEETXS, successThreshold, true, nBestSeenHeight);\n+        }\n+        if (checkShorterHorizon) {\n+            // If a lower confTarget from a more recent horizon returns a lower answer use it.\n+            if (confTarget > feeStats->GetMaxConfirms()) {\n+                double medMax = feeStats->EstimateMedianVal(feeStats->GetMaxConfirms(), SUFFICIENT_FEETXS, successThreshold, true, nBestSeenHeight);\n+                if (medMax > 0 && (estimate == -1 || medMax < estimate))\n+                    estimate = medMax;\n+            }\n+            if (confTarget > shortStats->GetMaxConfirms()) {\n+                double shortMax = shortStats->EstimateMedianVal(shortStats->GetMaxConfirms(), SUFFICIENT_TXS_SHORT, successThreshold, true, nBestSeenHeight);\n+                if (shortMax > 0 && (estimate == -1 || shortMax < estimate))\n+                    estimate = shortMax;\n+            }\n+        }\n+    }\n+    return estimate;\n+}\n+\n+/** Ensure that for a conservative estimate, the DOUBLE_SUCCESS_PCT is also met\n+ * at 2 * target for any longer time horizons.\n+ */\n+double CBlockPolicyEstimator::estimateConservativeFee(unsigned int doubleTarget) const\n+{\n+    double estimate = -1;\n+    if (doubleTarget <= shortStats->GetMaxConfirms()) {\n+        estimate = feeStats->EstimateMedianVal(doubleTarget, SUFFICIENT_FEETXS, DOUBLE_SUCCESS_PCT, true, nBestSeenHeight);\n+    }\n+    if (doubleTarget <= feeStats->GetMaxConfirms()) {\n+        double longEstimate = longStats->EstimateMedianVal(doubleTarget, SUFFICIENT_FEETXS, DOUBLE_SUCCESS_PCT, true, nBestSeenHeight);\n+        if (longEstimate > estimate) {\n+            estimate = longEstimate;\n+        }\n+    }\n+    return estimate;\n+}\n+\n+/** estimateSmartFee returns the max of the feerates calculated with a 60%\n+ * threshold required at target / 2, an 85% threshold required at target and a\n+ * 95% threshold required at 2 * target.  Each calculation is performed at the\n+ * shortest time horizon which tracks the required target.  Conservative\n+ * estimates, however, required the 95% threshold at 2 * target be met for any\n+ * longer time horizons also.\n+ */\n+CFeeRate CBlockPolicyEstimator::estimateSmartFee(int confTarget, int *answerFoundAtTarget, const CTxMemPool& pool, bool conservative) const\n {\n     if (answerFoundAtTarget)\n         *answerFoundAtTarget = confTarget;\n-    // Return failure if trying to analyze a target we're not tracking\n-    if (confTarget <= 0 || (unsigned int)confTarget > feeStats.GetMaxConfirms())\n-        return CFeeRate(0);\n-\n-    // It's not possible to get reasonable estimates for confTarget of 1\n-    if (confTarget == 1)\n-        confTarget = 2;\n \n     double median = -1;\n-    while (median < 0 && (unsigned int)confTarget <= feeStats.GetMaxConfirms()) {\n-        median = feeStats.EstimateMedianVal(confTarget++, SUFFICIENT_FEETXS, MIN_SUCCESS_PCT, true, nBestSeenHeight);\n-    }\n+    {\n+        LOCK(cs_feeEstimator);\n+\n+        // Return failure if trying to analyze a target we're not tracking\n+        if (confTarget <= 0 || (unsigned int)confTarget > longStats->GetMaxConfirms())\n+            return CFeeRate(0);\n+\n+        // It's not possible to get reasonable estimates for confTarget of 1\n+        if (confTarget == 1)\n+            confTarget = 2;\n+\n+        unsigned int maxUsableEstimate = MaxUsableEstimate();\n+        if (maxUsableEstimate <= 1)\n+            return CFeeRate(0);\n+\n+        if ((unsigned int)confTarget > maxUsableEstimate) {\n+            confTarget = maxUsableEstimate;\n+        }\n+\n+        assert(confTarget > 0); //estimateCombinedFee and estimateConservativeFee take unsigned ints\n+\n+        /** true is passed to estimateCombined fee for target/2 and target so\n+         * that we check the max confirms for shorter time horizons as well.\n+         * This is necessary to preserve monotonically increasing estimates.\n+         * For non-conservative estimates we do the same thing for 2*target, but\n+         * for conservative estimates we want to skip these shorter horizons\n+         * checks for 2*target because we are taking the max over all time\n+         * horizons so we already have monotonically increasing estimates and\n+         * the purpose of conservative estimates is not to let short term\n+         * fluctuations lower our estimates by too much.\n+         */\n+        double halfEst = estimateCombinedFee(confTarget/2, HALF_SUCCESS_PCT, true);\n+        double actualEst = estimateCombinedFee(confTarget, SUCCESS_PCT, true);\n+        double doubleEst = estimateCombinedFee(2 * confTarget, DOUBLE_SUCCESS_PCT, !conservative);\n+        median = halfEst;\n+        if (actualEst > median) {\n+            median = actualEst;\n+        }\n+        if (doubleEst > median) {\n+            median = doubleEst;\n+        }\n+\n+        if (conservative || median == -1) {\n+            double consEst =  estimateConservativeFee(2 * confTarget);\n+            if (consEst > median) {\n+                median = consEst;\n+            }\n+        }\n+    } // Must unlock cs_feeEstimator before taking mempool locks\n \n     if (answerFoundAtTarget)\n-        *answerFoundAtTarget = confTarget - 1;\n+        *answerFoundAtTarget = confTarget;\n \n     // If mempool is limiting txs , return at least the min feerate from the mempool\n     CAmount minPoolFee = pool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n@@ -454,26 +824,134 @@ CFeeRate CBlockPolicyEstimator::estimateSmartFee(int confTarget, int *answerFoun\n     return CFeeRate(median);\n }\n \n-void CBlockPolicyEstimator::Write(CAutoFile& fileout)\n+\n+bool CBlockPolicyEstimator::Write(CAutoFile& fileout) const\n {\n-    fileout << nBestSeenHeight;\n-    feeStats.Write(fileout);\n+    try {\n+        LOCK(cs_feeEstimator);\n+        fileout << 149900; // version required to read: 0.14.99 or later\n+        fileout << CLIENT_VERSION; // version that wrote the file\n+        fileout << nBestSeenHeight;\n+        if (BlockSpan() > HistoricalBlockSpan()/2) {\n+            fileout << firstRecordedHeight << nBestSeenHeight;\n+        }\n+        else {\n+            fileout << historicalFirst << historicalBest;\n+        }\n+        fileout << buckets;\n+        feeStats->Write(fileout);\n+        shortStats->Write(fileout);\n+        longStats->Write(fileout);\n+    }\n+    catch (const std::exception&) {\n+        LogPrintf(\"CBlockPolicyEstimator::Write(): unable to write policy estimator data (non-fatal)\\n\");\n+        return false;\n+    }\n+    return true;\n }\n \n-void CBlockPolicyEstimator::Read(CAutoFile& filein, int nFileVersion)\n+bool CBlockPolicyEstimator::Read(CAutoFile& filein)\n {\n-    int nFileBestSeenHeight;\n-    filein >> nFileBestSeenHeight;\n-    feeStats.Read(filein);\n-    nBestSeenHeight = nFileBestSeenHeight;\n-    // if nVersionThatWrote < 139900 then another TxConfirmStats (for priority) follows but can be ignored.\n+    try {\n+        LOCK(cs_feeEstimator);\n+        int nVersionRequired, nVersionThatWrote;\n+        unsigned int nFileBestSeenHeight, nFileHistoricalFirst, nFileHistoricalBest;\n+        filein >> nVersionRequired >> nVersionThatWrote;\n+        if (nVersionRequired > CLIENT_VERSION)\n+            return error(\"CBlockPolicyEstimator::Read(): up-version (%d) fee estimate file\", nVersionRequired);\n+\n+        // Read fee estimates file into temporary variables so existing data\n+        // structures aren't corrupted if there is an exception.\n+        filein >> nFileBestSeenHeight;\n+\n+        if (nVersionThatWrote < 149900) {\n+            // Read the old fee estimates file for temporary use, but then discard.  Will start collecting data from scratch.\n+            // decay is stored before buckets in old versions, so pre-read decay and pass into TxConfirmStats constructor\n+            double tempDecay;\n+            filein >> tempDecay;\n+            if (tempDecay <= 0 || tempDecay >= 1)\n+                throw std::runtime_error(\"Corrupt estimates file. Decay must be between 0 and 1 (non-inclusive)\");\n+\n+            std::vector<double> tempBuckets;\n+            filein >> tempBuckets;\n+            size_t tempNum = tempBuckets.size();\n+            if (tempNum <= 1 || tempNum > 1000)\n+                throw std::runtime_error(\"Corrupt estimates file. Must have between 2 and 1000 feerate buckets\");\n+\n+            std::map<double, unsigned int> tempMap;\n+\n+            std::unique_ptr<TxConfirmStats> tempFeeStats(new TxConfirmStats(tempBuckets, tempMap, MED_BLOCK_PERIODS, tempDecay, 1));\n+            tempFeeStats->Read(filein, nVersionThatWrote, tempNum);\n+            // if nVersionThatWrote < 139900 then another TxConfirmStats (for priority) follows but can be ignored.\n+\n+            tempMap.clear();\n+            for (unsigned int i = 0; i < tempBuckets.size(); i++) {\n+                tempMap[tempBuckets[i]] = i;\n+            }\n+        }\n+        else { // nVersionThatWrote >= 149900\n+            filein >> nFileHistoricalFirst >> nFileHistoricalBest;\n+            if (nFileHistoricalFirst > nFileHistoricalBest || nFileHistoricalBest > nFileBestSeenHeight) {\n+                throw std::runtime_error(\"Corrupt estimates file. Historical block range for estimates is invalid\");\n+            }\n+            std::vector<double> fileBuckets;\n+            filein >> fileBuckets;\n+            size_t numBuckets = fileBuckets.size();\n+            if (numBuckets <= 1 || numBuckets > 1000)\n+                throw std::runtime_error(\"Corrupt estimates file. Must have between 2 and 1000 feerate buckets\");\n+\n+            std::unique_ptr<TxConfirmStats> fileFeeStats(new TxConfirmStats(buckets, bucketMap, MED_BLOCK_PERIODS, MED_DECAY, MED_SCALE));\n+            std::unique_ptr<TxConfirmStats> fileShortStats(new TxConfirmStats(buckets, bucketMap, SHORT_BLOCK_PERIODS, SHORT_DECAY, SHORT_SCALE));\n+            std::unique_ptr<TxConfirmStats> fileLongStats(new TxConfirmStats(buckets, bucketMap, LONG_BLOCK_PERIODS, LONG_DECAY, LONG_SCALE));\n+            fileFeeStats->Read(filein, nVersionThatWrote, numBuckets);\n+            fileShortStats->Read(filein, nVersionThatWrote, numBuckets);\n+            fileLongStats->Read(filein, nVersionThatWrote, numBuckets);\n+\n+            // Fee estimates file parsed correctly\n+            // Copy buckets from file and refresh our bucketmap\n+            buckets = fileBuckets;\n+            bucketMap.clear();\n+            for (unsigned int i = 0; i < buckets.size(); i++) {\n+                bucketMap[buckets[i]] = i;\n+            }\n+\n+            // Destroy old TxConfirmStats and point to new ones that already reference buckets and bucketMap\n+            delete feeStats;\n+            delete shortStats;\n+            delete longStats;\n+            feeStats = fileFeeStats.release();\n+            shortStats = fileShortStats.release();\n+            longStats = fileLongStats.release();\n+\n+            nBestSeenHeight = nFileBestSeenHeight;\n+            historicalFirst = nFileHistoricalFirst;\n+            historicalBest = nFileHistoricalBest;\n+        }\n+    }\n+    catch (const std::exception& e) {\n+        LogPrintf(\"CBlockPolicyEstimator::Read(): unable to read policy estimator data (non-fatal): %s\\n\",e.what());\n+        return false;\n+    }\n+    return true;\n+}\n+\n+void CBlockPolicyEstimator::FlushUnconfirmed(CTxMemPool& pool) {\n+    int64_t startclear = GetTimeMicros();\n+    std::vector<uint256> txids;\n+    pool.queryHashes(txids);\n+    LOCK(cs_feeEstimator);\n+    for (auto& txid : txids) {\n+        removeTx(txid, false);\n+    }\n+    int64_t endclear = GetTimeMicros();\n+    LogPrint(BCLog::ESTIMATEFEE, \"Recorded %u unconfirmed txs from mempool in %ld micros\\n\",txids.size(), endclear - startclear);\n }\n \n FeeFilterRounder::FeeFilterRounder(const CFeeRate& minIncrementalFee)\n {\n     CAmount minFeeLimit = std::max(CAmount(1), minIncrementalFee.GetFeePerK() / 2);\n     feeset.insert(0);\n-    for (double bucketBoundary = minFeeLimit; bucketBoundary <= MAX_BUCKET_FEERATE; bucketBoundary *= FEE_SPACING) {\n+    for (double bucketBoundary = minFeeLimit; bucketBoundary <= MAX_FILTER_FEERATE; bucketBoundary *= FEE_FILTER_SPACING) {\n         feeset.insert(bucketBoundary);\n     }\n }"
      },
      {
        "sha": "e99fec2c39398d81b01024e6dd0a10665908e57e",
        "filename": "src/policy/fees.h",
        "status": "modified",
        "additions": 152,
        "deletions": 162,
        "changes": 314,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/policy/fees.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/policy/fees.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -6,8 +6,10 @@\n #define BITCOIN_POLICYESTIMATOR_H\n \n #include \"amount.h\"\n+#include \"feerate.h\"\n #include \"uint256.h\"\n #include \"random.h\"\n+#include \"sync.h\"\n \n #include <map>\n #include <string>\n@@ -17,6 +19,7 @@ class CAutoFile;\n class CFeeRate;\n class CTxMemPoolEntry;\n class CTxMemPool;\n+class TxConfirmStats;\n \n /** \\class CBlockPolicyEstimator\n  * The BlockPolicyEstimator is used for estimating the feerate needed\n@@ -39,203 +42,160 @@ class CTxMemPool;\n  * within your desired 5 blocks.\n  *\n  * Here is a brief description of the implementation:\n- * When a transaction enters the mempool, we\n- * track the height of the block chain at entry.  Whenever a block comes in,\n- * we count the number of transactions in each bucket and the total amount of feerate\n- * paid in each bucket. Then we calculate how many blocks Y it took each\n- * transaction to be mined and we track an array of counters in each bucket\n- * for how long it to took transactions to get confirmed from 1 to a max of 25\n- * and we increment all the counters from Y up to 25. This is because for any\n- * number Z>=Y the transaction was successfully mined within Z blocks.  We\n- * want to save a history of this information, so at any time we have a\n- * counter of the total number of transactions that happened in a given feerate\n- * bucket and the total number that were confirmed in each number 1-25 blocks\n- * or less for any bucket.   We save this history by keeping an exponentially\n- * decaying moving average of each one of these stats.  Furthermore we also\n- * keep track of the number unmined (in mempool) transactions in each bucket\n- * and for how many blocks they have been outstanding and use that to increase\n- * the number of transactions we've seen in that feerate bucket when calculating\n- * an estimate for any number of confirmations below the number of blocks\n- * they've been outstanding.\n+ * When a transaction enters the mempool, we track the height of the block chain\n+ * at entry.  All further calculations are conducted only on this set of \"seen\"\n+ * transactions. Whenever a block comes in, we count the number of transactions\n+ * in each bucket and the total amount of feerate paid in each bucket. Then we\n+ * calculate how many blocks Y it took each transaction to be mined.  We convert\n+ * from a number of blocks to a number of periods Y' each encompassing \"scale\"\n+ * blocks.  This is is tracked in 3 different data sets each up to a maximum\n+ * number of periods. Within each data set we have an array of counters in each\n+ * feerate bucket and we increment all the counters from Y' up to max periods\n+ * representing that a tx was successfully confirmed in less than or equal to\n+ * that many periods. We want to save a history of this information, so at any\n+ * time we have a counter of the total number of transactions that happened in a\n+ * given feerate bucket and the total number that were confirmed in each of the\n+ * periods or less for any bucket.  We save this history by keeping an\n+ * exponentially decaying moving average of each one of these stats.  This is\n+ * done for a different decay in each of the 3 data sets to keep relevant data\n+ * from different time horizons.  Furthermore we also keep track of the number\n+ * unmined (in mempool or left mempool without being included in a block)\n+ * transactions in each bucket and for how many blocks they have been\n+ * outstanding and use both of these numbers to increase the number of transactions\n+ * we've seen in that feerate bucket when calculating an estimate for any number\n+ * of confirmations below the number of blocks they've been outstanding.\n  */\n \n-/**\n- * We will instantiate an instance of this class to track transactions that were\n- * included in a block. We will lump transactions into a bucket according to their\n- * approximate feerate and then track how long it took for those txs to be included in a block\n- *\n- * The tracking of unconfirmed (mempool) transactions is completely independent of the\n- * historical tracking of transactions that have been confirmed in a block.\n- */\n-class TxConfirmStats\n-{\n-private:\n-    //Define the buckets we will group transactions into\n-    std::vector<double> buckets;              // The upper-bound of the range for the bucket (inclusive)\n-    std::map<double, unsigned int> bucketMap; // Map of bucket upper-bound to index into all vectors by bucket\n-\n-    // For each bucket X:\n-    // Count the total # of txs in each bucket\n-    // Track the historical moving average of this total over blocks\n-    std::vector<double> txCtAvg;\n-    // and calculate the total for the current block to update the moving average\n-    std::vector<int> curBlockTxCt;\n-\n-    // Count the total # of txs confirmed within Y blocks in each bucket\n-    // Track the historical moving average of theses totals over blocks\n-    std::vector<std::vector<double> > confAvg; // confAvg[Y][X]\n-    // and calculate the totals for the current block to update the moving averages\n-    std::vector<std::vector<int> > curBlockConf; // curBlockConf[Y][X]\n-\n-    // Sum the total feerate of all tx's in each bucket\n-    // Track the historical moving average of this total over blocks\n-    std::vector<double> avg;\n-    // and calculate the total for the current block to update the moving average\n-    std::vector<double> curBlockVal;\n+/* Identifier for each of the 3 different TxConfirmStats which will track\n+ * history over different time horizons. */\n+enum FeeEstimateHorizon {\n+    SHORT_HALFLIFE = 0,\n+    MED_HALFLIFE = 1,\n+    LONG_HALFLIFE = 2\n+};\n \n-    // Combine the conf counts with tx counts to calculate the confirmation % for each Y,X\n-    // Combine the total value with the tx counts to calculate the avg feerate per bucket\n+/* Used to return detailed information about a feerate bucket */\n+struct EstimatorBucket\n+{\n+    double start = -1;\n+    double end = -1;\n+    double withinTarget = 0;\n+    double totalConfirmed = 0;\n+    double inMempool = 0;\n+    double leftMempool = 0;\n+};\n \n+/* Used to return detailed information about a fee estimate calculation */\n+struct EstimationResult\n+{\n+    EstimatorBucket pass;\n+    EstimatorBucket fail;\n     double decay;\n-\n-    // Mempool counts of outstanding transactions\n-    // For each bucket X, track the number of transactions in the mempool\n-    // that are unconfirmed for each possible confirmation value Y\n-    std::vector<std::vector<int> > unconfTxs;  //unconfTxs[Y][X]\n-    // transactions still unconfirmed after MAX_CONFIRMS for each bucket\n-    std::vector<int> oldUnconfTxs;\n-\n-public:\n-    /**\n-     * Initialize the data structures.  This is called by BlockPolicyEstimator's\n-     * constructor with default values.\n-     * @param defaultBuckets contains the upper limits for the bucket boundaries\n-     * @param maxConfirms max number of confirms to track\n-     * @param decay how much to decay the historical moving average per block\n-     */\n-    void Initialize(std::vector<double>& defaultBuckets, unsigned int maxConfirms, double decay);\n-\n-    /** Clear the state of the curBlock variables to start counting for the new block */\n-    void ClearCurrent(unsigned int nBlockHeight);\n-\n-    /**\n-     * Record a new transaction data point in the current block stats\n-     * @param blocksToConfirm the number of blocks it took this transaction to confirm\n-     * @param val the feerate of the transaction\n-     * @warning blocksToConfirm is 1-based and has to be >= 1\n-     */\n-    void Record(int blocksToConfirm, double val);\n-\n-    /** Record a new transaction entering the mempool*/\n-    unsigned int NewTx(unsigned int nBlockHeight, double val);\n-\n-    /** Remove a transaction from mempool tracking stats*/\n-    void removeTx(unsigned int entryHeight, unsigned int nBestSeenHeight,\n-                  unsigned int bucketIndex);\n-\n-    /** Update our estimates by decaying our historical moving average and updating\n-        with the data gathered from the current block */\n-    void UpdateMovingAverages();\n-\n-    /**\n-     * Calculate a feerate estimate.  Find the lowest value bucket (or range of buckets\n-     * to make sure we have enough data points) whose transactions still have sufficient likelihood\n-     * of being confirmed within the target number of confirmations\n-     * @param confTarget target number of confirmations\n-     * @param sufficientTxVal required average number of transactions per block in a bucket range\n-     * @param minSuccess the success probability we require\n-     * @param requireGreater return the lowest feerate such that all higher values pass minSuccess OR\n-     *        return the highest feerate such that all lower values fail minSuccess\n-     * @param nBlockHeight the current block height\n-     */\n-    double EstimateMedianVal(int confTarget, double sufficientTxVal,\n-                             double minSuccess, bool requireGreater, unsigned int nBlockHeight);\n-\n-    /** Return the max number of confirms we're tracking */\n-    unsigned int GetMaxConfirms() { return confAvg.size(); }\n-\n-    /** Write state of estimation data to a file*/\n-    void Write(CAutoFile& fileout);\n-\n-    /**\n-     * Read saved state of estimation data from a file and replace all internal data structures and\n-     * variables with this state.\n-     */\n-    void Read(CAutoFile& filein);\n+    unsigned int scale;\n };\n \n-\n-\n-/** Track confirm delays up to 25 blocks, can't estimate beyond that */\n-static const unsigned int MAX_BLOCK_CONFIRMS = 25;\n-\n-/** Decay of .998 is a half-life of 346 blocks or about 2.4 days */\n-static const double DEFAULT_DECAY = .998;\n-\n-/** Require greater than 95% of X feerate transactions to be confirmed within Y blocks for X to be big enough */\n-static const double MIN_SUCCESS_PCT = .95;\n-\n-/** Require an avg of 1 tx in the combined feerate bucket per block to have stat significance */\n-static const double SUFFICIENT_FEETXS = 1;\n-\n-// Minimum and Maximum values for tracking feerates\n-// The MIN_BUCKET_FEERATE should just be set to the lowest reasonable feerate we\n-// might ever want to track.  Historically this has been 1000 since it was\n-// inheriting DEFAULT_MIN_RELAY_TX_FEE and changing it is disruptive as it\n-// invalidates old estimates files. So leave it at 1000 unless it becomes\n-// necessary to lower it, and then lower it substantially.\n-static constexpr double MIN_BUCKET_FEERATE = 1000;\n-static const double MAX_BUCKET_FEERATE = 1e7;\n-static const double INF_FEERATE = MAX_MONEY;\n-\n-// We have to lump transactions into buckets based on feerate, but we want to be able\n-// to give accurate estimates over a large range of potential feerates\n-// Therefore it makes sense to exponentially space the buckets\n-/** Spacing of FeeRate buckets */\n-static const double FEE_SPACING = 1.1;\n-\n /**\n  *  We want to be able to estimate feerates that are needed on tx's to be included in\n  * a certain number of blocks.  Every time a block is added to the best chain, this class records\n  * stats on the transactions included in that block\n  */\n class CBlockPolicyEstimator\n {\n+private:\n+    /** Track confirm delays up to 12 blocks for short horizon */\n+    static constexpr unsigned int SHORT_BLOCK_PERIODS = 12;\n+    static constexpr unsigned int SHORT_SCALE = 1;\n+    /** Track confirm delays up to 48 blocks for medium horizon */\n+    static constexpr unsigned int MED_BLOCK_PERIODS = 24;\n+    static constexpr unsigned int MED_SCALE = 2;\n+    /** Track confirm delays up to 1008 blocks for long horizon */\n+    static constexpr unsigned int LONG_BLOCK_PERIODS = 42;\n+    static constexpr unsigned int LONG_SCALE = 24;\n+    /** Historical estimates that are older than this aren't valid */\n+    static const unsigned int OLDEST_ESTIMATE_HISTORY = 6 * 1008;\n+\n+    /** Decay of .962 is a half-life of 18 blocks or about 3 hours */\n+    static constexpr double SHORT_DECAY = .962;\n+    /** Decay of .998 is a half-life of 144 blocks or about 1 day */\n+    static constexpr double MED_DECAY = .9952;\n+    /** Decay of .9995 is a half-life of 1008 blocks or about 1 week */\n+    static constexpr double LONG_DECAY = .99931;\n+\n+    /** Require greater than 60% of X feerate transactions to be confirmed within Y/2 blocks*/\n+    static constexpr double HALF_SUCCESS_PCT = .6;\n+    /** Require greater than 85% of X feerate transactions to be confirmed within Y blocks*/\n+    static constexpr double SUCCESS_PCT = .85;\n+    /** Require greater than 95% of X feerate transactions to be confirmed within 2 * Y blocks*/\n+    static constexpr double DOUBLE_SUCCESS_PCT = .95;\n+\n+    /** Require an avg of 0.1 tx in the combined feerate bucket per block to have stat significance */\n+    static constexpr double SUFFICIENT_FEETXS = 0.1;\n+    /** Require an avg of 0.5 tx when using short decay since there are fewer blocks considered*/\n+    static constexpr double SUFFICIENT_TXS_SHORT = 0.5;\n+\n+    /** Minimum and Maximum values for tracking feerates\n+     * The MIN_BUCKET_FEERATE should just be set to the lowest reasonable feerate we\n+     * might ever want to track.  Historically this has been 1000 since it was\n+     * inheriting DEFAULT_MIN_RELAY_TX_FEE and changing it is disruptive as it\n+     * invalidates old estimates files. So leave it at 1000 unless it becomes\n+     * necessary to lower it, and then lower it substantially.\n+     */\n+    static constexpr double MIN_BUCKET_FEERATE = 1000;\n+    static constexpr double MAX_BUCKET_FEERATE = 1e7;\n+\n+    /** Spacing of FeeRate buckets\n+     * We have to lump transactions into buckets based on feerate, but we want to be able\n+     * to give accurate estimates over a large range of potential feerates\n+     * Therefore it makes sense to exponentially space the buckets\n+     */\n+    static constexpr double FEE_SPACING = 1.05;\n+\n public:\n     /** Create new BlockPolicyEstimator and initialize stats tracking classes with default values */\n     CBlockPolicyEstimator();\n+    ~CBlockPolicyEstimator();\n \n     /** Process all the transactions that have been included in a block */\n     void processBlock(unsigned int nBlockHeight,\n                       std::vector<const CTxMemPoolEntry*>& entries);\n \n-    /** Process a transaction confirmed in a block*/\n-    bool processBlockTx(unsigned int nBlockHeight, const CTxMemPoolEntry* entry);\n-\n     /** Process a transaction accepted to the mempool*/\n     void processTransaction(const CTxMemPoolEntry& entry, bool validFeeEstimate);\n \n     /** Remove a transaction from the mempool tracking stats*/\n-    bool removeTx(uint256 hash);\n+    bool removeTx(uint256 hash, bool inBlock);\n+\n+    /** DEPRECATED. Return a feerate estimate */\n+    CFeeRate estimateFee(int confTarget) const;\n \n-    /** Return a feerate estimate */\n-    CFeeRate estimateFee(int confTarget);\n+    /** Estimate feerate needed to get be included in a block within confTarget\n+     *  blocks. If no answer can be given at confTarget, return an estimate at\n+     *  the closest target where one can be given.  'conservative' estimates are\n+     *  valid over longer time horizons also.\n+     */\n+    CFeeRate estimateSmartFee(int confTarget, int *answerFoundAtTarget, const CTxMemPool& pool, bool conservative = true) const;\n \n-    /** Estimate feerate needed to get be included in a block within\n-     *  confTarget blocks. If no answer can be given at confTarget, return an\n-     *  estimate at the lowest target where one can be given.\n+    /** Return a specific fee estimate calculation with a given success\n+     * threshold and time horizon, and optionally return detailed data about\n+     * calculation\n      */\n-    CFeeRate estimateSmartFee(int confTarget, int *answerFoundAtTarget, const CTxMemPool& pool);\n+    CFeeRate estimateRawFee(int confTarget, double successThreshold, FeeEstimateHorizon horizon, EstimationResult *result = nullptr) const;\n \n     /** Write estimation data to a file */\n-    void Write(CAutoFile& fileout);\n+    bool Write(CAutoFile& fileout) const;\n \n     /** Read estimation data from a file */\n-    void Read(CAutoFile& filein, int nFileVersion);\n+    bool Read(CAutoFile& filein);\n+\n+    /** Empty mempool transactions on shutdown to record failure to confirm for txs still in mempool */\n+    void FlushUnconfirmed(CTxMemPool& pool);\n \n private:\n-    CFeeRate minTrackedFee;    //!< Passed to constructor to avoid dependency on main\n     unsigned int nBestSeenHeight;\n+    unsigned int firstRecordedHeight;\n+    unsigned int historicalFirst;\n+    unsigned int historicalBest;\n+\n     struct TxStatsInfo\n     {\n         unsigned int blockHeight;\n@@ -247,14 +207,43 @@ class CBlockPolicyEstimator\n     std::map<uint256, TxStatsInfo> mapMemPoolTxs;\n \n     /** Classes to track historical data on transaction confirmations */\n-    TxConfirmStats feeStats;\n+    TxConfirmStats* feeStats;\n+    TxConfirmStats* shortStats;\n+    TxConfirmStats* longStats;\n \n     unsigned int trackedTxs;\n     unsigned int untrackedTxs;\n+\n+    std::vector<double> buckets;              // The upper-bound of the range for the bucket (inclusive)\n+    std::map<double, unsigned int> bucketMap; // Map of bucket upper-bound to index into all vectors by bucket\n+\n+    mutable CCriticalSection cs_feeEstimator;\n+\n+    /** Process a transaction confirmed in a block*/\n+    bool processBlockTx(unsigned int nBlockHeight, const CTxMemPoolEntry* entry);\n+\n+    /** Helper for estimateSmartFee */\n+    double estimateCombinedFee(unsigned int confTarget, double successThreshold, bool checkShorterHorizon) const;\n+    /** Helper for estimateSmartFee */\n+    double estimateConservativeFee(unsigned int doubleTarget) const;\n+    /** Number of blocks of data recorded while fee estimates have been running */\n+    unsigned int BlockSpan() const;\n+    /** Number of blocks of recorded fee estimate data represented in saved data file */\n+    unsigned int HistoricalBlockSpan() const;\n+    /** Calculation of highest target that reasonable estimate can be provided for */\n+    unsigned int MaxUsableEstimate() const;\n };\n \n class FeeFilterRounder\n {\n+private:\n+    static constexpr double MAX_FILTER_FEERATE = 1e7;\n+    /** FEE_FILTER_SPACING is just used to provide some quantization of fee\n+     * filter results.  Historically it reused FEE_SPACING, but it is completely\n+     * unrelated, and was made a separate constant so the two concepts are not\n+     * tied together */\n+    static constexpr double FEE_FILTER_SPACING = 1.1;\n+\n public:\n     /** Create new FeeFilterRounder */\n     FeeFilterRounder(const CFeeRate& minIncrementalFee);\n@@ -266,4 +255,5 @@ class FeeFilterRounder\n     std::set<double> feeset;\n     FastRandomContext insecure_rand;\n };\n+\n #endif /*BITCOIN_POLICYESTIMATOR_H */"
      },
      {
        "sha": "f4fffd6578ac57c96ed6cad6057d298d4d438f80",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 1,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -8,12 +8,50 @@\n #include \"policy/policy.h\"\n \n #include \"validation.h\"\n+#include \"coins.h\"\n #include \"tinyformat.h\"\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n \n #include <boost/foreach.hpp>\n \n+CAmount GetDustThreshold(const CTxOut& txout, const CFeeRate& dustRelayFeeIn)\n+{\n+    // \"Dust\" is defined in terms of dustRelayFee,\n+    // which has units satoshis-per-kilobyte.\n+    // If you'd pay more than 1/3 in fees\n+    // to spend something, then we consider it dust.\n+    // A typical spendable non-segwit txout is 34 bytes big, and will\n+    // need a CTxIn of at least 148 bytes to spend:\n+    // so dust is a spendable txout less than\n+    // 546*dustRelayFee/1000 (in satoshis).\n+    // A typical spendable segwit txout is 31 bytes big, and will\n+    // need a CTxIn of at least 67 bytes to spend:\n+    // so dust is a spendable txout less than\n+    // 294*dustRelayFee/1000 (in satoshis).\n+    if (txout.scriptPubKey.IsUnspendable())\n+        return 0;\n+\n+    size_t nSize = GetSerializeSize(txout, SER_DISK, 0);\n+    int witnessversion = 0;\n+    std::vector<unsigned char> witnessprogram;\n+\n+    if (txout.scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) {\n+        // sum the sizes of the parts of a transaction input\n+        // with 75% segwit discount applied to the script size.\n+        nSize += (32 + 4 + 1 + (107 / WITNESS_SCALE_FACTOR) + 4);\n+    } else {\n+        nSize += (32 + 4 + 1 + 107 + 4); // the 148 mentioned above\n+    }\n+\n+    return 3 * dustRelayFeeIn.GetFee(nSize);\n+}\n+\n+bool IsDust(const CTxOut& txout, const CFeeRate& dustRelayFeeIn)\n+{\n+    return (txout.nValue < GetDustThreshold(txout, dustRelayFeeIn));\n+}\n+\n     /**\n      * Check transaction inputs to mitigate two\n      * potential denial-of-service attacks:\n@@ -105,7 +143,7 @@ bool IsStandardTx(const CTransaction& tx, std::string& reason, const bool witnes\n         else if ((whichType == TX_MULTISIG) && (!fIsBareMultisigStd)) {\n             reason = \"bare-multisig\";\n             return false;\n-        } else if (txout.IsDust(dustRelayFee)) {\n+        } else if (IsDust(txout, ::dustRelayFee)) {\n             reason = \"dust\";\n             return false;\n         }"
      },
      {
        "sha": "2c2ea9d5b85a6011523ca2d9275806834cc93b37",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -7,12 +7,14 @@\n #define BITCOIN_POLICY_POLICY_H\n \n #include \"consensus/consensus.h\"\n+#include \"feerate.h\"\n #include \"script/interpreter.h\"\n #include \"script/standard.h\"\n \n #include <string>\n \n class CCoinsViewCache;\n+class CTxOut;\n \n /** Default for -blockmaxsize, which controls the maximum size of block the mining code will create **/\n static const unsigned int DEFAULT_BLOCK_MAX_SIZE = 750000;\n@@ -72,6 +74,10 @@ static const unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCRIPT_\n static const unsigned int STANDARD_LOCKTIME_VERIFY_FLAGS = LOCKTIME_VERIFY_SEQUENCE |\n                                                            LOCKTIME_MEDIAN_TIME_PAST;\n \n+CAmount GetDustThreshold(const CTxOut& txout, const CFeeRate& dustRelayFee);\n+\n+bool IsDust(const CTxOut& txout, const CFeeRate& dustRelayFee);\n+\n bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType, const bool witnessEnabled = false);\n     /**\n      * Check for standard transaction types"
      },
      {
        "sha": "00ac0b92b54da5e9ff41b3e37945f4f00a0a6c2f",
        "filename": "src/primitives/transaction.h",
        "status": "modified",
        "additions": 2,
        "deletions": 39,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/primitives/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/primitives/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -22,8 +22,8 @@ class COutPoint\n     uint256 hash;\n     uint32_t n;\n \n-    COutPoint() { SetNull(); }\n-    COutPoint(uint256 hashIn, uint32_t nIn) { hash = hashIn; n = nIn; }\n+    COutPoint(): n((uint32_t) -1) { }\n+    COutPoint(const uint256& hashIn, uint32_t nIn): hash(hashIn), n(nIn) { }\n \n     ADD_SERIALIZE_METHODS;\n \n@@ -161,43 +161,6 @@ class CTxOut\n         return (nValue == -1);\n     }\n \n-    CAmount GetDustThreshold(const CFeeRate &minRelayTxFee) const\n-    {\n-        // \"Dust\" is defined in terms of CTransaction::minRelayTxFee,\n-        // which has units satoshis-per-kilobyte.\n-        // If you'd pay more than 1/3 in fees\n-        // to spend something, then we consider it dust.\n-        // A typical spendable non-segwit txout is 34 bytes big, and will\n-        // need a CTxIn of at least 148 bytes to spend:\n-        // so dust is a spendable txout less than\n-        // 546*minRelayTxFee/1000 (in satoshis).\n-        // A typical spendable segwit txout is 31 bytes big, and will\n-        // need a CTxIn of at least 67 bytes to spend:\n-        // so dust is a spendable txout less than\n-        // 294*minRelayTxFee/1000 (in satoshis).\n-        if (scriptPubKey.IsUnspendable())\n-            return 0;\n-\n-        size_t nSize = GetSerializeSize(*this, SER_DISK, 0);\n-        int witnessversion = 0;\n-        std::vector<unsigned char> witnessprogram;\n-\n-        if (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) {\n-            // sum the sizes of the parts of a transaction input\n-            // with 75% segwit discount applied to the script size.\n-            nSize += (32 + 4 + 1 + (107 / WITNESS_SCALE_FACTOR) + 4);\n-        } else {\n-            nSize += (32 + 4 + 1 + 107 + 4); // the 148 mentioned above\n-        }\n-\n-        return 3 * minRelayTxFee.GetFee(nSize);\n-    }\n-\n-    bool IsDust(const CFeeRate &minRelayTxFee) const\n-    {\n-        return (nValue < GetDustThreshold(minRelayTxFee));\n-    }\n-\n     friend bool operator==(const CTxOut& a, const CTxOut& b)\n     {\n         return (a.nValue       == b.nValue &&"
      },
      {
        "sha": "f8a99506c131ea35169a73cf7240d4b818599282",
        "filename": "src/qt/bantablemodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/bantablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/bantablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bantablemodel.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -181,7 +181,5 @@ void BanTableModel::sort(int column, Qt::SortOrder order)\n \n bool BanTableModel::shouldShow()\n {\n-    if (priv->size() > 0)\n-        return true;\n-    return false;\n+    return priv->size() > 0;\n }"
      },
      {
        "sha": "de00eacdb98f81917b41889ad8f2c791c8058460",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -9,6 +9,7 @@\n #include \"guiutil.h\"\n #include \"peertablemodel.h\"\n \n+#include \"chain.h\"\n #include \"chainparams.h\"\n #include \"checkpoints.h\"\n #include \"clientversion.h\""
      },
      {
        "sha": "135cf6f701a8dfc0b69b6e0860c51259efc12fcc",
        "filename": "src/qt/coincontroldialog.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 9,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/coincontroldialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/coincontroldialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -15,6 +15,7 @@\n \n #include \"wallet/coincontrol.h\"\n #include \"init.h\"\n+#include \"policy/fees.h\"\n #include \"policy/policy.h\"\n #include \"validation.h\" // For mempool\n #include \"wallet/wallet.h\"\n@@ -433,8 +434,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n         {\n             CTxOut txout(amount, (CScript)std::vector<unsigned char>(24, 0));\n             txDummy.vout.push_back(txout);\n-            if (txout.IsDust(dustRelayFee))\n-               fDust = true;\n+            fDust |= IsDust(txout, ::dustRelayFee);\n         }\n     }\n \n@@ -512,9 +512,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n                 nBytes -= 34;\n \n         // Fee\n-        nPayFee = CWallet::GetMinimumFee(nBytes, nTxConfirmTarget, mempool);\n-        if (nPayFee > 0 && coinControl->nMinimumTotalFee > nPayFee)\n-            nPayFee = coinControl->nMinimumTotalFee;\n+        nPayFee = CWallet::GetMinimumFee(nBytes, nTxConfirmTarget, ::mempool, ::feeEstimator);\n \n         if (nPayAmount > 0)\n         {\n@@ -526,10 +524,10 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n             if (nChange > 0 && nChange < MIN_CHANGE)\n             {\n                 CTxOut txout(nChange, (CScript)std::vector<unsigned char>(24, 0));\n-                if (txout.IsDust(dustRelayFee))\n+                if (IsDust(txout, ::dustRelayFee))\n                 {\n                     if (CoinControlDialog::fSubtractFeeFromAmount) // dust-change will be raised until no dust\n-                        nChange = txout.GetDustThreshold(dustRelayFee);\n+                        nChange = GetDustThreshold(txout, ::dustRelayFee);\n                     else\n                     {\n                         nPayFee += nChange;\n@@ -573,7 +571,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n     l5->setText(((nBytes > 0) ? ASYMP_UTF8 : \"\") + QString::number(nBytes));        // Bytes\n     l7->setText(fDust ? tr(\"yes\") : tr(\"no\"));                               // Dust\n     l8->setText(BitcoinUnits::formatWithUnit(nDisplayUnit, nChange));        // Change\n-    if (nPayFee > 0 && (coinControl->nMinimumTotalFee < nPayFee))\n+    if (nPayFee > 0)\n     {\n         l3->setText(ASYMP_UTF8 + l3->text());\n         l4->setText(ASYMP_UTF8 + l4->text());\n@@ -592,7 +590,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n     if (payTxFee.GetFeePerK() > 0)\n         dFeeVary = (double)std::max(CWallet::GetRequiredFee(1000), payTxFee.GetFeePerK()) / 1000;\n     else {\n-        dFeeVary = (double)std::max(CWallet::GetRequiredFee(1000), mempool.estimateSmartFee(nTxConfirmTarget).GetFeePerK()) / 1000;\n+        dFeeVary = (double)std::max(CWallet::GetRequiredFee(1000), ::feeEstimator.estimateSmartFee(nTxConfirmTarget, NULL, ::mempool).GetFeePerK()) / 1000;\n     }\n     QString toolTip4 = tr(\"Can vary +/- %1 satoshi(s) per input.\").arg(dFeeVary);\n "
      },
      {
        "sha": "89f9c25d143697f8a61317d0307d38eafd745acb",
        "filename": "src/qt/forms/sendcoinsdialog.ui",
        "status": "modified",
        "additions": 0,
        "deletions": 13,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/forms/sendcoinsdialog.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/forms/sendcoinsdialog.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/sendcoinsdialog.ui?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -861,19 +861,6 @@\n                    </attribute>\n                   </widget>\n                  </item>\n-                 <item>\n-                  <widget class=\"QRadioButton\" name=\"radioCustomAtLeast\">\n-                   <property name=\"toolTip\">\n-                    <string>If the custom fee is set to 1000 satoshis and the transaction is only 250 bytes, then &quot;per kilobyte&quot; only pays 250 satoshis in fee, while &quot;total at least&quot; pays 1000 satoshis. For transactions bigger than a kilobyte both pay by kilobyte.</string>\n-                   </property>\n-                   <property name=\"text\">\n-                    <string>total at least</string>\n-                   </property>\n-                   <attribute name=\"buttonGroup\">\n-                    <string notr=\"true\">groupCustomFee</string>\n-                   </attribute>\n-                  </widget>\n-                 </item>\n                  <item>\n                   <widget class=\"BitcoinAmountField\" name=\"customFee\"/>\n                  </item>"
      },
      {
        "sha": "bffa81137b230c5e2fb5292b53d41b776e1494c1",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -251,7 +251,7 @@ bool isDust(const QString& address, const CAmount& amount)\n     CTxDestination dest = CBitcoinAddress(address.toStdString()).Get();\n     CScript script = GetScriptForDestination(dest);\n     CTxOut txOut(amount, script);\n-    return txOut.IsDust(dustRelayFee);\n+    return IsDust(txOut, ::dustRelayFee);\n }\n \n QString HtmlEscape(const QString& str, bool fMultiLine)"
      },
      {
        "sha": "c31a7a478d6538810df6c33ed5983b88e7c26802",
        "filename": "src/qt/paymentserver.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/paymentserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/paymentserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -219,14 +219,16 @@ void PaymentServer::ipcParseCommandLine(int argc, char* argv[])\n             if (GUIUtil::parseBitcoinURI(arg, &r) && !r.address.isEmpty())\n             {\n                 CBitcoinAddress address(r.address.toStdString());\n+                auto tempChainParams = CreateChainParams(CBaseChainParams::MAIN);\n \n-                if (address.IsValid(Params(CBaseChainParams::MAIN)))\n+                if (address.IsValid(*tempChainParams))\n                 {\n                     SelectParams(CBaseChainParams::MAIN);\n                 }\n-                else if (address.IsValid(Params(CBaseChainParams::TESTNET)))\n-                {\n-                    SelectParams(CBaseChainParams::TESTNET);\n+                else {\n+                    tempChainParams = CreateChainParams(CBaseChainParams::TESTNET);\n+                    if (address.IsValid(*tempChainParams))\n+                        SelectParams(CBaseChainParams::TESTNET);\n                 }\n             }\n         }\n@@ -580,7 +582,7 @@ bool PaymentServer::processPaymentRequest(const PaymentRequestPlus& request, Sen\n \n         // Extract and check amounts\n         CTxOut txOut(sendingTo.second, sendingTo.first);\n-        if (txOut.IsDust(dustRelayFee)) {\n+        if (IsDust(txOut, ::dustRelayFee)) {\n             Q_EMIT message(tr(\"Payment request error\"), tr(\"Requested payment amount of %1 is too small (considered dust).\")\n                 .arg(BitcoinUnits::formatWithUnit(optionsModel->getDisplayUnit(), sendingTo.second)),\n                 CClientUIInterface::MSG_ERROR);"
      },
      {
        "sha": "b200cb112717b73a6f8610192412bdffa09f7550",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 5,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -98,7 +98,7 @@ class QtRPCTimerBase: public QObject, public RPCTimerBase\n {\n     Q_OBJECT\n public:\n-    QtRPCTimerBase(boost::function<void(void)>& _func, int64_t millis):\n+    QtRPCTimerBase(std::function<void(void)>& _func, int64_t millis):\n         func(_func)\n     {\n         timer.setSingleShot(true);\n@@ -110,15 +110,15 @@ private Q_SLOTS:\n     void timeout() { func(); }\n private:\n     QTimer timer;\n-    boost::function<void(void)> func;\n+    std::function<void(void)> func;\n };\n \n class QtRPCTimerInterface: public RPCTimerInterface\n {\n public:\n     ~QtRPCTimerInterface() {}\n     const char *Name() { return \"Qt\"; }\n-    RPCTimerBase* NewTimer(boost::function<void(void)>& func, int64_t millis)\n+    RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis)\n     {\n         return new QtRPCTimerBase(func, millis);\n     }\n@@ -730,8 +730,14 @@ void RPCConsole::clear(bool clearHistory)\n             ).arg(fixedFontInfo.family(), QString(\"%1pt\").arg(consoleFontSize))\n         );\n \n+#ifdef Q_OS_MAC\n+    QString clsKey = \"(\u2318)-L\";\n+#else\n+    QString clsKey = \"Ctrl-L\";\n+#endif\n+\t \n     message(CMD_REPLY, (tr(\"Welcome to the %1 RPC console.\").arg(tr(PACKAGE_NAME)) + \"<br>\" +\n-                        tr(\"Use up and down arrows to navigate history, and <b>Ctrl-L</b> to clear screen.\") + \"<br>\" +\n+                        tr(\"Use up and down arrows to navigate history, and %1 to clear screen.\").arg(\"<b>\"+clsKey+\"</b>\") + \"<br>\" +\n                         tr(\"Type <b>help</b> for an overview of available commands.\")) +\n                         \"<br><span class=\\\"secwarning\\\">\" +\n                         tr(\"WARNING: Scammers have been active, telling users to type commands here, stealing their wallet contents. Do not use this console without fully understanding the ramification of a command.\") +\n@@ -829,7 +835,7 @@ void RPCConsole::on_lineEdit_returnPressed()\n \n         cmdBeforeBrowsing = QString();\n \n-        message(CMD_REQUEST, cmd);\n+        message(CMD_REQUEST, QString::fromStdString(strFilteredCmd));\n         Q_EMIT cmdRequest(cmd);\n \n         cmd = QString::fromStdString(strFilteredCmd);"
      },
      {
        "sha": "272ab9486acef2b22c8e92b4d99589459910024e",
        "filename": "src/qt/sendcoinsdialog.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 28,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/sendcoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/sendcoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -21,6 +21,7 @@\n #include \"validation.h\" // mempool and minRelayTxFee\n #include \"ui_interface.h\"\n #include \"txmempool.h\"\n+#include \"policy/fees.h\"\n #include \"wallet/wallet.h\"\n \n #include <QFontMetrics>\n@@ -30,8 +31,6 @@\n #include <QTextDocument>\n #include <QTimer>\n \n-#define SEND_CONFIRM_DELAY   3\n-\n SendCoinsDialog::SendCoinsDialog(const PlatformStyle *_platformStyle, QWidget *parent) :\n     QDialog(parent),\n     ui(new Ui::SendCoinsDialog),\n@@ -110,11 +109,9 @@ SendCoinsDialog::SendCoinsDialog(const PlatformStyle *_platformStyle, QWidget *p\n     ui->groupFee->setId(ui->radioCustomFee, 1);\n     ui->groupFee->button((int)std::max(0, std::min(1, settings.value(\"nFeeRadio\").toInt())))->setChecked(true);\n     ui->groupCustomFee->setId(ui->radioCustomPerKilobyte, 0);\n-    ui->groupCustomFee->setId(ui->radioCustomAtLeast, 1);\n     ui->groupCustomFee->button((int)std::max(0, std::min(1, settings.value(\"nCustomFeeRadio\").toInt())))->setChecked(true);\n     ui->customFee->setValue(settings.value(\"nTransactionFee\").toLongLong());\n     ui->checkBoxMinimumFee->setChecked(settings.value(\"fPayOnlyMinFee\").toBool());\n-    ui->optInRBF->setCheckState(model->getDefaultWalletRbf() ? Qt::Checked : Qt::Unchecked);\n     minimizeFeeSection(settings.value(\"fFeeSectionMinimized\").toBool());\n }\n \n@@ -175,6 +172,9 @@ void SendCoinsDialog::setModel(WalletModel *_model)\n         updateSmartFeeLabel();\n         updateGlobalFeeVariables();\n \n+        // set default rbf checkbox state\n+        ui->optInRBF->setCheckState(model->getDefaultWalletRbf() ? Qt::Checked : Qt::Unchecked);\n+\n         // set the smartfee-sliders default value (wallets default conf.target or last stored value)\n         QSettings settings;\n         if (settings.value(\"nSmartFeeSliderPosition\").toInt() == 0)\n@@ -605,7 +605,6 @@ void SendCoinsDialog::updateFeeSectionControls()\n     ui->checkBoxMinimumFee      ->setEnabled(ui->radioCustomFee->isChecked());\n     ui->labelMinFeeWarning      ->setEnabled(ui->radioCustomFee->isChecked());\n     ui->radioCustomPerKilobyte  ->setEnabled(ui->radioCustomFee->isChecked() && !ui->checkBoxMinimumFee->isChecked());\n-    ui->radioCustomAtLeast      ->setEnabled(ui->radioCustomFee->isChecked() && !ui->checkBoxMinimumFee->isChecked() && CoinControlDialog::coinControl->HasSelected());\n     ui->customFee               ->setEnabled(ui->radioCustomFee->isChecked() && !ui->checkBoxMinimumFee->isChecked());\n }\n \n@@ -616,19 +615,12 @@ void SendCoinsDialog::updateGlobalFeeVariables()\n         int nConfirmTarget = ui->sliderSmartFee->maximum() - ui->sliderSmartFee->value() + 2;\n         payTxFee = CFeeRate(0);\n \n-        // set nMinimumTotalFee to 0 to not accidentally pay a custom fee\n-        CoinControlDialog::coinControl->nMinimumTotalFee = 0;\n-\n         // show the estimated required time for confirmation\n         ui->confirmationTargetLabel->setText(GUIUtil::formatDurationStr(nConfirmTarget * Params().GetConsensus().nPowTargetSpacing) + \" / \" + tr(\"%n block(s)\", \"\", nConfirmTarget));\n     }\n     else\n     {\n         payTxFee = CFeeRate(ui->customFee->value());\n-\n-        // if user has selected to set a minimum absolute fee, pass the value to coincontrol\n-        // set nMinimumTotalFee to 0 in case of user has selected that the fee is per KB\n-        CoinControlDialog::coinControl->nMinimumTotalFee = ui->radioCustomAtLeast->isChecked() ? ui->customFee->value() : 0;\n     }\n }\n \n@@ -660,7 +652,7 @@ void SendCoinsDialog::updateSmartFeeLabel()\n \n     int nBlocksToConfirm = ui->sliderSmartFee->maximum() - ui->sliderSmartFee->value() + 2;\n     int estimateFoundAtBlocks = nBlocksToConfirm;\n-    CFeeRate feeRate = mempool.estimateSmartFee(nBlocksToConfirm, &estimateFoundAtBlocks);\n+    CFeeRate feeRate = ::feeEstimator.estimateSmartFee(nBlocksToConfirm, &estimateFoundAtBlocks, ::mempool);\n     if (feeRate <= CFeeRate(0)) // not enough data => minfee\n     {\n         ui->labelSmartFee->setText(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(),\n@@ -827,21 +819,6 @@ void SendCoinsDialog::coinControlUpdateLabels()\n     if (!model || !model->getOptionsModel())\n         return;\n \n-    if (model->getOptionsModel()->getCoinControlFeatures())\n-    {\n-        // enable minimum absolute fee UI controls\n-        ui->radioCustomAtLeast->setVisible(true);\n-\n-        // only enable the feature if inputs are selected\n-        ui->radioCustomAtLeast->setEnabled(ui->radioCustomFee->isChecked() && !ui->checkBoxMinimumFee->isChecked() &&CoinControlDialog::coinControl->HasSelected());\n-    }\n-    else\n-    {\n-        // in case coin control is disabled (=default), hide minimum absolute fee UI controls\n-        ui->radioCustomAtLeast->setVisible(false);\n-        return;\n-    }\n-\n     // set pay amounts\n     CoinControlDialog::payAmounts.clear();\n     CoinControlDialog::fSubtractFeeFromAmount = false;"
      },
      {
        "sha": "a932f129bed7a78d4ba7d405df89ee752f4d1353",
        "filename": "src/qt/sendcoinsdialog.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/sendcoinsdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/sendcoinsdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -100,13 +100,14 @@ private Q_SLOTS:\n };\n \n \n+#define SEND_CONFIRM_DELAY   3\n \n class SendConfirmationDialog : public QMessageBox\n {\n     Q_OBJECT\n \n public:\n-    SendConfirmationDialog(const QString &title, const QString &text, int secDelay = 0, QWidget *parent = 0);\n+    SendConfirmationDialog(const QString &title, const QString &text, int secDelay = SEND_CONFIRM_DELAY, QWidget *parent = 0);\n     int exec();\n \n private Q_SLOTS:"
      },
      {
        "sha": "32362ccdfc63e6181ff821d7922a0aae0efaa696",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 80,
        "deletions": 13,
        "changes": 93,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -8,26 +8,46 @@\n #include \"qt/sendcoinsdialog.h\"\n #include \"qt/sendcoinsentry.h\"\n #include \"qt/transactiontablemodel.h\"\n+#include \"qt/transactionview.h\"\n #include \"qt/walletmodel.h\"\n #include \"test/test_bitcoin.h\"\n #include \"validation.h\"\n #include \"wallet/wallet.h\"\n \n #include <QAbstractButton>\n+#include <QAction>\n #include <QApplication>\n+#include <QCheckBox>\n+#include <QPushButton>\n #include <QTimer>\n #include <QVBoxLayout>\n \n namespace\n {\n-//! Press \"Yes\" button in modal send confirmation dialog.\n-void ConfirmSend()\n+//! Press \"Ok\" button in message box dialog.\n+void ConfirmMessage(QString* text = nullptr)\n {\n-    QTimer::singleShot(0, makeCallback([](Callback* callback) {\n+    QTimer::singleShot(0, makeCallback([text](Callback* callback) {\n+        for (QWidget* widget : QApplication::topLevelWidgets()) {\n+            if (widget->inherits(\"QMessageBox\")) {\n+                QMessageBox* messageBox = qobject_cast<QMessageBox*>(widget);\n+                if (text) *text = messageBox->text();\n+                messageBox->defaultButton()->click();\n+            }\n+        }\n+        delete callback;\n+    }), SLOT(call()));\n+}\n+\n+//! Press \"Yes\" or \"Cancel\" buttons in modal send confirmation dialog.\n+void ConfirmSend(QString* text = nullptr, bool cancel = false)\n+{\n+    QTimer::singleShot(0, makeCallback([text, cancel](Callback* callback) {\n         for (QWidget* widget : QApplication::topLevelWidgets()) {\n             if (widget->inherits(\"SendConfirmationDialog\")) {\n                 SendConfirmationDialog* dialog = qobject_cast<SendConfirmationDialog*>(widget);\n-                QAbstractButton* button = dialog->button(QMessageBox::Yes);\n+                if (text) *text = dialog->text();\n+                QAbstractButton* button = dialog->button(cancel ? QMessageBox::Cancel : QMessageBox::Yes);\n                 button->setEnabled(true);\n                 button->click();\n             }\n@@ -37,12 +57,16 @@ void ConfirmSend()\n }\n \n //! Send coins to address and return txid.\n-uint256 SendCoins(CWallet& wallet, SendCoinsDialog& sendCoinsDialog, const CBitcoinAddress& address, CAmount amount)\n+uint256 SendCoins(CWallet& wallet, SendCoinsDialog& sendCoinsDialog, const CBitcoinAddress& address, CAmount amount, bool rbf)\n {\n     QVBoxLayout* entries = sendCoinsDialog.findChild<QVBoxLayout*>(\"entries\");\n     SendCoinsEntry* entry = qobject_cast<SendCoinsEntry*>(entries->itemAt(0)->widget());\n     entry->findChild<QValidatedLineEdit*>(\"payTo\")->setText(QString::fromStdString(address.ToString()));\n     entry->findChild<BitcoinAmountField*>(\"payAmount\")->setValue(amount);\n+    sendCoinsDialog.findChild<QFrame*>(\"frameFee\")\n+        ->findChild<QFrame*>(\"frameFeeSelection\")\n+        ->findChild<QCheckBox*>(\"optInRBF\")\n+        ->setCheckState(rbf ? Qt::Checked : Qt::Unchecked);\n     uint256 txid;\n     boost::signals2::scoped_connection c(wallet.NotifyTransactionChanged.connect([&txid](CWallet*, const uint256& hash, ChangeType status) {\n         if (status == CT_NEW) txid = hash;\n@@ -65,6 +89,31 @@ QModelIndex FindTx(const QAbstractItemModel& model, const uint256& txid)\n     }\n     return {};\n }\n+\n+//! Invoke bumpfee on txid and check results.\n+void BumpFee(TransactionView& view, const uint256& txid, bool expectDisabled, std::string expectError, bool cancel)\n+{\n+    QTableView* table = view.findChild<QTableView*>(\"transactionView\");\n+    QModelIndex index = FindTx(*table->selectionModel()->model(), txid);\n+    QVERIFY2(index.isValid(), \"Could not find BumpFee txid\");\n+\n+    // Select row in table, invoke context menu, and make sure bumpfee action is\n+    // enabled or disabled as expected.\n+    QAction* action = view.findChild<QAction*>(\"bumpFeeAction\");\n+    table->selectionModel()->select(index, QItemSelectionModel::ClearAndSelect | QItemSelectionModel::Rows);\n+    action->setEnabled(expectDisabled);\n+    table->customContextMenuRequested({});\n+    QCOMPARE(action->isEnabled(), !expectDisabled);\n+\n+    action->setEnabled(true);\n+    QString text;\n+    if (expectError.empty()) {\n+        ConfirmSend(&text, cancel);\n+    } else {\n+        ConfirmMessage(&text);\n+    }\n+    action->trigger();\n+    QVERIFY(text.indexOf(QString::fromStdString(expectError)) != -1);\n }\n \n //! Simple qt wallet tests.\n@@ -80,13 +129,16 @@ QModelIndex FindTx(const QAbstractItemModel& model, const uint256& txid)\n //     src/qt/test/test_bitcoin-qt -platform xcb      # Linux\n //     src/qt/test/test_bitcoin-qt -platform windows  # Windows\n //     src/qt/test/test_bitcoin-qt -platform cocoa    # macOS\n-void WalletTests::walletTests()\n+void TestSendCoins()\n {\n-    // Set up wallet and chain with 101 blocks (1 mature block for spending).\n+    // Set up wallet and chain with 105 blocks (5 mature blocks for spending).\n     TestChain100Setup test;\n-    test.CreateAndProcessBlock({}, GetScriptForRawPubKey(test.coinbaseKey.GetPubKey()));\n+    for (int i = 0; i < 5; ++i) {\n+        test.CreateAndProcessBlock({}, GetScriptForRawPubKey(test.coinbaseKey.GetPubKey()));\n+    }\n     bitdb.MakeMock();\n-    CWallet wallet(\"wallet_test.dat\");\n+    std::unique_ptr<CWalletDBWrapper> dbw(new CWalletDBWrapper(&bitdb, \"wallet_test.dat\"));\n+    CWallet wallet(std::move(dbw));\n     bool firstRun;\n     wallet.LoadWallet(firstRun);\n     {\n@@ -100,19 +152,34 @@ void WalletTests::walletTests()\n     // Create widgets for sending coins and listing transactions.\n     std::unique_ptr<const PlatformStyle> platformStyle(PlatformStyle::instantiate(\"other\"));\n     SendCoinsDialog sendCoinsDialog(platformStyle.get());\n+    TransactionView transactionView(platformStyle.get());\n     OptionsModel optionsModel;\n     WalletModel walletModel(platformStyle.get(), &wallet, &optionsModel);\n     sendCoinsDialog.setModel(&walletModel);\n+    transactionView.setModel(&walletModel);\n \n     // Send two transactions, and verify they are added to transaction list.\n     TransactionTableModel* transactionTableModel = walletModel.getTransactionTableModel();\n-    QCOMPARE(transactionTableModel->rowCount({}), 101);\n-    uint256 txid1 = SendCoins(wallet, sendCoinsDialog, CBitcoinAddress(CKeyID()), 5 * COIN);\n-    uint256 txid2 = SendCoins(wallet, sendCoinsDialog, CBitcoinAddress(CKeyID()), 10 * COIN);\n-    QCOMPARE(transactionTableModel->rowCount({}), 103);\n+    QCOMPARE(transactionTableModel->rowCount({}), 105);\n+    uint256 txid1 = SendCoins(wallet, sendCoinsDialog, CBitcoinAddress(CKeyID()), 5 * COIN, false /* rbf */);\n+    uint256 txid2 = SendCoins(wallet, sendCoinsDialog, CBitcoinAddress(CKeyID()), 10 * COIN, true /* rbf */);\n+    QCOMPARE(transactionTableModel->rowCount({}), 107);\n     QVERIFY(FindTx(*transactionTableModel, txid1).isValid());\n     QVERIFY(FindTx(*transactionTableModel, txid2).isValid());\n \n+    // Call bumpfee. Test disabled, canceled, enabled, then failing cases.\n+    BumpFee(transactionView, txid1, true /* expect disabled */, \"not BIP 125 replaceable\" /* expected error */, false /* cancel */);\n+    BumpFee(transactionView, txid2, false /* expect disabled */, {} /* expected error */, true /* cancel */);\n+    BumpFee(transactionView, txid2, false /* expect disabled */, {} /* expected error */, false /* cancel */);\n+    BumpFee(transactionView, txid2, false /* expect disabled */, \"already bumped\" /* expected error */, false /* cancel */);\n+\n     bitdb.Flush(true);\n     bitdb.Reset();\n }\n+\n+}\n+\n+void WalletTests::walletTests()\n+{\n+    TestSendCoins();\n+}"
      },
      {
        "sha": "5da10e41b953843e021a083910e2932a08dba4e3",
        "filename": "src/qt/transactionview.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 2,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/transactionview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/transactionview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -11,6 +11,7 @@\n #include \"guiutil.h\"\n #include \"optionsmodel.h\"\n #include \"platformstyle.h\"\n+#include \"sendcoinsdialog.h\"\n #include \"transactiondescdialog.h\"\n #include \"transactionfilterproxy.h\"\n #include \"transactionrecord.h\"\n@@ -37,7 +38,7 @@\n \n TransactionView::TransactionView(const PlatformStyle *platformStyle, QWidget *parent) :\n     QWidget(parent), model(0), transactionProxyModel(0),\n-    transactionView(0), abandonAction(0), columnResizingFixer(0)\n+    transactionView(0), abandonAction(0), bumpFeeAction(0), columnResizingFixer(0)\n {\n     // Build filter row\n     setContentsMargins(0,0,0,0);\n@@ -135,9 +136,12 @@ TransactionView::TransactionView(const PlatformStyle *platformStyle, QWidget *pa\n     view->installEventFilter(this);\n \n     transactionView = view;\n+    transactionView->setObjectName(\"transactionView\");\n \n     // Actions\n     abandonAction = new QAction(tr(\"Abandon transaction\"), this);\n+    bumpFeeAction = new QAction(tr(\"Increase transaction fee\"), this);\n+    bumpFeeAction->setObjectName(\"bumpFeeAction\");\n     QAction *copyAddressAction = new QAction(tr(\"Copy address\"), this);\n     QAction *copyLabelAction = new QAction(tr(\"Copy label\"), this);\n     QAction *copyAmountAction = new QAction(tr(\"Copy amount\"), this);\n@@ -148,6 +152,7 @@ TransactionView::TransactionView(const PlatformStyle *platformStyle, QWidget *pa\n     QAction *showDetailsAction = new QAction(tr(\"Show transaction details\"), this);\n \n     contextMenu = new QMenu(this);\n+    contextMenu->setObjectName(\"contextMenu\");\n     contextMenu->addAction(copyAddressAction);\n     contextMenu->addAction(copyLabelAction);\n     contextMenu->addAction(copyAmountAction);\n@@ -156,6 +161,7 @@ TransactionView::TransactionView(const PlatformStyle *platformStyle, QWidget *pa\n     contextMenu->addAction(copyTxPlainText);\n     contextMenu->addAction(showDetailsAction);\n     contextMenu->addSeparator();\n+    contextMenu->addAction(bumpFeeAction);\n     contextMenu->addAction(abandonAction);\n     contextMenu->addAction(editLabelAction);\n \n@@ -173,6 +179,7 @@ TransactionView::TransactionView(const PlatformStyle *platformStyle, QWidget *pa\n     connect(view, SIGNAL(doubleClicked(QModelIndex)), this, SIGNAL(doubleClicked(QModelIndex)));\n     connect(view, SIGNAL(customContextMenuRequested(QPoint)), this, SLOT(contextualMenu(QPoint)));\n \n+    connect(bumpFeeAction, SIGNAL(triggered()), this, SLOT(bumpFee()));\n     connect(abandonAction, SIGNAL(triggered()), this, SLOT(abandonTx()));\n     connect(copyAddressAction, SIGNAL(triggered()), this, SLOT(copyAddress()));\n     connect(copyLabelAction, SIGNAL(triggered()), this, SLOT(copyLabel()));\n@@ -372,10 +379,11 @@ void TransactionView::contextualMenu(const QPoint &point)\n     uint256 hash;\n     hash.SetHex(selection.at(0).data(TransactionTableModel::TxHashRole).toString().toStdString());\n     abandonAction->setEnabled(model->transactionCanBeAbandoned(hash));\n+    bumpFeeAction->setEnabled(model->transactionSignalsRBF(hash));\n \n     if(index.isValid())\n     {\n-        contextMenu->exec(QCursor::pos());\n+        contextMenu->popup(transactionView->viewport()->mapToGlobal(point));\n     }\n }\n \n@@ -397,6 +405,24 @@ void TransactionView::abandonTx()\n     model->getTransactionTableModel()->updateTransaction(hashQStr, CT_UPDATED, false);\n }\n \n+void TransactionView::bumpFee()\n+{\n+    if(!transactionView || !transactionView->selectionModel())\n+        return;\n+    QModelIndexList selection = transactionView->selectionModel()->selectedRows(0);\n+\n+    // get the hash from the TxHashRole (QVariant / QString)\n+    uint256 hash;\n+    QString hashQStr = selection.at(0).data(TransactionTableModel::TxHashRole).toString();\n+    hash.SetHex(hashQStr.toStdString());\n+\n+    // Bump tx fee over the walletModel\n+    if (model->bumpFee(hash)) {\n+        // Update the table\n+        model->getTransactionTableModel()->updateTransaction(hashQStr, CT_UPDATED, true);\n+    }\n+}\n+\n void TransactionView::copyAddress()\n {\n     GUIUtil::copyEntryData(transactionView, 0, TransactionTableModel::AddressRole);"
      },
      {
        "sha": "52e57cae4cf9486d98b7e55278d5ab44b4d32098",
        "filename": "src/qt/transactionview.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/transactionview.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/transactionview.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -76,6 +76,7 @@ class TransactionView : public QWidget\n     QDateTimeEdit *dateFrom;\n     QDateTimeEdit *dateTo;\n     QAction *abandonAction;\n+    QAction *bumpFeeAction;\n \n     QWidget *createDateRangeWidget();\n \n@@ -99,6 +100,7 @@ private Q_SLOTS:\n     void openThirdPartyTxUrl(QString url);\n     void updateWatchOnlyColumn(bool fHaveWatchOnly);\n     void abandonTx();\n+    void bumpFee();\n \n Q_SIGNALS:\n     void doubleClicked(const QModelIndex&);"
      },
      {
        "sha": "33b407ae5751b9b9d04375baef05a7a22a1a572b",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 91,
        "deletions": 49,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -8,23 +8,29 @@\n #include \"consensus/validation.h\"\n #include \"guiconstants.h\"\n #include \"guiutil.h\"\n+#include \"optionsmodel.h\"\n #include \"paymentserver.h\"\n #include \"recentrequeststablemodel.h\"\n+#include \"sendcoinsdialog.h\"\n #include \"transactiontablemodel.h\"\n \n #include \"base58.h\"\n+#include \"chain.h\"\n #include \"keystore.h\"\n #include \"validation.h\"\n #include \"net.h\" // for g_connman\n+#include \"policy/rbf.h\"\n #include \"sync.h\"\n #include \"ui_interface.h\"\n #include \"util.h\" // for GetBoolArg\n+#include \"wallet/feebumper.h\"\n #include \"wallet/wallet.h\"\n #include \"wallet/walletdb.h\" // for BackupWallet\n \n #include <stdint.h>\n \n #include <QDebug>\n+#include <QMessageBox>\n #include <QSet>\n #include <QTimer>\n \n@@ -62,14 +68,7 @@ CAmount WalletModel::getBalance(const CCoinControl *coinControl) const\n {\n     if (coinControl)\n     {\n-        CAmount nBalance = 0;\n-        std::vector<COutput> vCoins;\n-        wallet->AvailableCoins(vCoins, true, coinControl);\n-        BOOST_FOREACH(const COutput& out, vCoins)\n-            if(out.fSpendable)\n-                nBalance += out.tx->tx->vout[out.i].nValue;\n-\n-        return nBalance;\n+        return wallet->GetAvailableBalance(coinControl);\n     }\n \n     return wallet->GetBalance();\n@@ -594,38 +593,11 @@ bool WalletModel::isSpent(const COutPoint& outpoint) const\n // AvailableCoins + LockedCoins grouped by wallet address (put change in one group with wallet address)\n void WalletModel::listCoins(std::map<QString, std::vector<COutput> >& mapCoins) const\n {\n-    std::vector<COutput> vCoins;\n-    wallet->AvailableCoins(vCoins);\n-\n-    LOCK2(cs_main, wallet->cs_wallet); // ListLockedCoins, mapWallet\n-    std::vector<COutPoint> vLockedCoins;\n-    wallet->ListLockedCoins(vLockedCoins);\n-\n-    // add locked coins\n-    BOOST_FOREACH(const COutPoint& outpoint, vLockedCoins)\n-    {\n-        if (!wallet->mapWallet.count(outpoint.hash)) continue;\n-        int nDepth = wallet->mapWallet[outpoint.hash].GetDepthInMainChain();\n-        if (nDepth < 0) continue;\n-        COutput out(&wallet->mapWallet[outpoint.hash], outpoint.n, nDepth, true /* spendable */, true /* solvable */, true /* safe */);\n-        if (outpoint.n < out.tx->tx->vout.size() && wallet->IsMine(out.tx->tx->vout[outpoint.n]) == ISMINE_SPENDABLE)\n-            vCoins.push_back(out);\n-    }\n-\n-    BOOST_FOREACH(const COutput& out, vCoins)\n-    {\n-        COutput cout = out;\n-\n-        while (wallet->IsChange(cout.tx->tx->vout[cout.i]) && cout.tx->tx->vin.size() > 0 && wallet->IsMine(cout.tx->tx->vin[0]))\n-        {\n-            if (!wallet->mapWallet.count(cout.tx->tx->vin[0].prevout.hash)) break;\n-            cout = COutput(&wallet->mapWallet[cout.tx->tx->vin[0].prevout.hash], cout.tx->tx->vin[0].prevout.n, 0 /* depth */, true /* spendable */, true /* solvable */, true /* safe */);\n+    for (auto& group : wallet->ListCoins()) {\n+        auto& resultGroup = mapCoins[QString::fromStdString(CBitcoinAddress(group.first).ToString())];\n+        for (auto& coin : group.second) {\n+            resultGroup.emplace_back(std::move(coin));\n         }\n-\n-        CTxDestination address;\n-        if(!out.fSpendable || !ExtractDestination(cout.tx->tx->vout[cout.i].scriptPubKey, address))\n-            continue;\n-        mapCoins[QString::fromStdString(CBitcoinAddress(address).ToString())].push_back(out);\n     }\n }\n \n@@ -655,11 +627,7 @@ void WalletModel::listLockedCoins(std::vector<COutPoint>& vOutpts)\n \n void WalletModel::loadReceiveRequests(std::vector<std::string>& vReceiveRequests)\n {\n-    LOCK(wallet->cs_wallet);\n-    BOOST_FOREACH(const PAIRTYPE(CTxDestination, CAddressBookData)& item, wallet->mapAddressBook)\n-        BOOST_FOREACH(const PAIRTYPE(std::string, std::string)& item2, item.second.destdata)\n-            if (item2.first.size() > 2 && item2.first.substr(0,2) == \"rr\") // receive request\n-                vReceiveRequests.push_back(item2.second);\n+    vReceiveRequests = wallet->GetDestValues(\"rr\"); // receive request\n }\n \n bool WalletModel::saveReceiveRequest(const std::string &sAddress, const int64_t nId, const std::string &sRequest)\n@@ -679,11 +647,7 @@ bool WalletModel::saveReceiveRequest(const std::string &sAddress, const int64_t\n \n bool WalletModel::transactionCanBeAbandoned(uint256 hash) const\n {\n-    LOCK2(cs_main, wallet->cs_wallet);\n-    const CWalletTx *wtx = wallet->GetWalletTx(hash);\n-    if (!wtx || wtx->isAbandoned() || wtx->GetDepthInMainChain() > 0 || wtx->InMempool())\n-        return false;\n-    return true;\n+    return wallet->TransactionCanBeAbandoned(hash);\n }\n \n bool WalletModel::abandonTransaction(uint256 hash) const\n@@ -692,6 +656,84 @@ bool WalletModel::abandonTransaction(uint256 hash) const\n     return wallet->AbandonTransaction(hash);\n }\n \n+bool WalletModel::transactionSignalsRBF(uint256 hash) const\n+{\n+    LOCK2(cs_main, wallet->cs_wallet);\n+    const CWalletTx *wtx = wallet->GetWalletTx(hash);\n+    return wtx && SignalsOptInRBF(*wtx);\n+}\n+\n+bool WalletModel::bumpFee(uint256 hash)\n+{\n+    std::unique_ptr<CFeeBumper> feeBump;\n+    {\n+        LOCK2(cs_main, wallet->cs_wallet);\n+        feeBump.reset(new CFeeBumper(wallet, hash, nTxConfirmTarget, false, 0, true));\n+    }\n+    if (feeBump->getResult() != BumpFeeResult::OK)\n+    {\n+        QMessageBox::critical(0, tr(\"Fee bump error\"), tr(\"Increasing transaction fee failed\") + \"<br />(\" +\n+            (feeBump->getErrors().size() ? QString::fromStdString(feeBump->getErrors()[0]) : \"\") +\")\");\n+         return false;\n+    }\n+\n+    // allow a user based fee verification\n+    QString questionString = tr(\"Do you want to increase the fee?\");\n+    questionString.append(\"<br />\");\n+    CAmount oldFee = feeBump->getOldFee();\n+    CAmount newFee = feeBump->getNewFee();\n+    questionString.append(\"<table style=\\\"text-align: left;\\\">\");\n+    questionString.append(\"<tr><td>\");\n+    questionString.append(tr(\"Current fee:\"));\n+    questionString.append(\"</td><td>\");\n+    questionString.append(BitcoinUnits::formatHtmlWithUnit(getOptionsModel()->getDisplayUnit(), oldFee));\n+    questionString.append(\"</td></tr><tr><td>\");\n+    questionString.append(tr(\"Increase:\"));\n+    questionString.append(\"</td><td>\");\n+    questionString.append(BitcoinUnits::formatHtmlWithUnit(getOptionsModel()->getDisplayUnit(), newFee - oldFee));\n+    questionString.append(\"</td></tr><tr><td>\");\n+    questionString.append(tr(\"New fee:\"));\n+    questionString.append(\"</td><td>\");\n+    questionString.append(BitcoinUnits::formatHtmlWithUnit(getOptionsModel()->getDisplayUnit(), newFee));\n+    questionString.append(\"</td></tr></table>\");\n+    SendConfirmationDialog confirmationDialog(tr(\"Confirm fee bump\"), questionString);\n+    confirmationDialog.exec();\n+    QMessageBox::StandardButton retval = (QMessageBox::StandardButton)confirmationDialog.result();\n+\n+    // cancel sign&broadcast if users doesn't want to bump the fee\n+    if (retval != QMessageBox::Yes) {\n+        return false;\n+    }\n+\n+    WalletModel::UnlockContext ctx(requestUnlock());\n+    if(!ctx.isValid())\n+    {\n+        return false;\n+    }\n+\n+    // sign bumped transaction\n+    bool res = false;\n+    {\n+        LOCK2(cs_main, wallet->cs_wallet);\n+        res = feeBump->signTransaction(wallet);\n+    }\n+    if (!res) {\n+        QMessageBox::critical(0, tr(\"Fee bump error\"), tr(\"Can't sign transaction.\"));\n+        return false;\n+    }\n+    // commit the bumped transaction\n+    {\n+        LOCK2(cs_main, wallet->cs_wallet);\n+        res = feeBump->commit(wallet);\n+    }\n+    if(!res) {\n+        QMessageBox::critical(0, tr(\"Fee bump error\"), tr(\"Could not commit transaction\") + \"<br />(\" +\n+            QString::fromStdString(feeBump->getErrors()[0])+\")\");\n+         return false;\n+    }\n+    return true;\n+}\n+\n bool WalletModel::isWalletEnabled()\n {\n    return !GetBoolArg(\"-disablewallet\", DEFAULT_DISABLE_WALLET);"
      },
      {
        "sha": "df5acaf6840e6f6803199aca91996b51412cf6d1",
        "filename": "src/qt/walletmodel.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/walletmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/qt/walletmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -207,6 +207,9 @@ class WalletModel : public QObject\n     bool transactionCanBeAbandoned(uint256 hash) const;\n     bool abandonTransaction(uint256 hash) const;\n \n+    bool transactionSignalsRBF(uint256 hash) const;\n+    bool bumpFee(uint256 hash);\n+\n     static bool isWalletEnabled();\n \n     bool hdEnabled() const;"
      },
      {
        "sha": "de7553c825509cdfe873c0d3529bfdb805269f2b",
        "filename": "src/random.cpp",
        "status": "modified",
        "additions": 97,
        "deletions": 24,
        "changes": 121,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/random.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/random.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -16,6 +16,8 @@\n \n #include <stdlib.h>\n #include <limits>\n+#include <chrono>\n+#include <thread>\n \n #ifndef WIN32\n #include <sys/time.h>\n@@ -32,6 +34,8 @@\n #include <sys/sysctl.h>\n #endif\n \n+#include <mutex>\n+\n #include <openssl/err.h>\n #include <openssl/rand.h>\n \n@@ -43,15 +47,22 @@ static void RandFailure()\n \n static inline int64_t GetPerformanceCounter()\n {\n-    int64_t nCounter = 0;\n-#ifdef WIN32\n-    QueryPerformanceCounter((LARGE_INTEGER*)&nCounter);\n+    // Read the hardware time stamp counter when available.\n+    // See https://en.wikipedia.org/wiki/Time_Stamp_Counter for more information.\n+#if defined(_MSC_VER) && (defined(_M_IX86) || defined(_M_X64))\n+    return __rdtsc();\n+#elif !defined(_MSC_VER) && defined(__i386__)\n+    uint64_t r = 0;\n+    __asm__ volatile (\"rdtsc\" : \"=A\"(r)); // Constrain the r variable to the eax:edx pair.\n+    return r;\n+#elif !defined(_MSC_VER) && (defined(__x86_64__) || defined(__amd64__))\n+    uint64_t r1 = 0, r2 = 0;\n+    __asm__ volatile (\"rdtsc\" : \"=a\"(r1), \"=d\"(r2)); // Constrain r1 to rax and r2 to rdx.\n+    return (r2 << 32) | r1;\n #else\n-    timeval t;\n-    gettimeofday(&t, NULL);\n-    nCounter = (int64_t)(t.tv_sec * 1000000 + t.tv_usec);\n+    // Fall back to using C++11 clock (usually microsecond or nanosecond precision)\n+    return std::chrono::high_resolution_clock::now().time_since_epoch().count();\n #endif\n-    return nCounter;\n }\n \n void RandAddSeed()\n@@ -192,6 +203,43 @@ void GetRandBytes(unsigned char* buf, int num)\n     }\n }\n \n+static void AddDataToRng(void* data, size_t len);\n+\n+void RandAddSeedSleep()\n+{\n+    int64_t nPerfCounter1 = GetPerformanceCounter();\n+    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n+    int64_t nPerfCounter2 = GetPerformanceCounter();\n+\n+    // Combine with and update state\n+    AddDataToRng(&nPerfCounter1, sizeof(nPerfCounter1));\n+    AddDataToRng(&nPerfCounter2, sizeof(nPerfCounter2));\n+\n+    memory_cleanse(&nPerfCounter1, sizeof(nPerfCounter1));\n+    memory_cleanse(&nPerfCounter2, sizeof(nPerfCounter2));\n+}\n+\n+\n+static std::mutex cs_rng_state;\n+static unsigned char rng_state[32] = {0};\n+static uint64_t rng_counter = 0;\n+\n+static void AddDataToRng(void* data, size_t len) {\n+    CSHA512 hasher;\n+    hasher.Write((const unsigned char*)&len, sizeof(len));\n+    hasher.Write((const unsigned char*)data, len);\n+    unsigned char buf[64];\n+    {\n+        std::unique_lock<std::mutex> lock(cs_rng_state);\n+        hasher.Write(rng_state, sizeof(rng_state));\n+        hasher.Write((const unsigned char*)&rng_counter, sizeof(rng_counter));\n+        ++rng_counter;\n+        hasher.Finalize(buf);\n+        memcpy(rng_state, buf + 32, 32);\n+    }\n+    memory_cleanse(buf, 64);\n+}\n+\n void GetStrongRandBytes(unsigned char* out, int num)\n {\n     assert(num <= 32);\n@@ -207,8 +255,17 @@ void GetStrongRandBytes(unsigned char* out, int num)\n     GetOSRand(buf);\n     hasher.Write(buf, 32);\n \n+    // Combine with and update state\n+    {\n+        std::unique_lock<std::mutex> lock(cs_rng_state);\n+        hasher.Write(rng_state, sizeof(rng_state));\n+        hasher.Write((const unsigned char*)&rng_counter, sizeof(rng_counter));\n+        ++rng_counter;\n+        hasher.Finalize(buf);\n+        memcpy(rng_state, buf + 32, 32);\n+    }\n+\n     // Produce output\n-    hasher.Finalize(buf);\n     memcpy(out, buf, num);\n     memory_cleanse(buf, 64);\n }\n@@ -240,26 +297,22 @@ uint256 GetRandHash()\n     return hash;\n }\n \n-FastRandomContext::FastRandomContext(bool fDeterministic)\n+void FastRandomContext::RandomSeed()\n {\n-    // The seed values have some unlikely fixed points which we avoid.\n-    if (fDeterministic) {\n-        Rz = Rw = 11;\n-    } else {\n-        uint32_t tmp;\n-        do {\n-            GetRandBytes((unsigned char*)&tmp, 4);\n-        } while (tmp == 0 || tmp == 0x9068ffffU);\n-        Rz = tmp;\n-        do {\n-            GetRandBytes((unsigned char*)&tmp, 4);\n-        } while (tmp == 0 || tmp == 0x464fffffU);\n-        Rw = tmp;\n-    }\n+    uint256 seed = GetRandHash();\n+    rng.SetKey(seed.begin(), 32);\n+    requires_seed = false;\n+}\n+\n+FastRandomContext::FastRandomContext(const uint256& seed) : requires_seed(false), bytebuf_size(0), bitbuf_size(0)\n+{\n+    rng.SetKey(seed.begin(), 32);\n }\n \n bool Random_SanityCheck()\n {\n+    uint64_t start = GetPerformanceCounter();\n+\n     /* This does not measure the quality of randomness, but it does test that\n      * OSRandom() overwrites all 32 bytes of the output given a maximum\n      * number of tries.\n@@ -286,5 +339,25 @@ bool Random_SanityCheck()\n \n         tries += 1;\n     } while (num_overwritten < NUM_OS_RANDOM_BYTES && tries < MAX_TRIES);\n-    return (num_overwritten == NUM_OS_RANDOM_BYTES); /* If this failed, bailed out after too many tries */\n+    if (num_overwritten != NUM_OS_RANDOM_BYTES) return false; /* If this failed, bailed out after too many tries */\n+\n+    // Check that GetPerformanceCounter increases at least during a GetOSRand() call + 1ms sleep.\n+    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n+    uint64_t stop = GetPerformanceCounter();\n+    if (stop == start) return false;\n+\n+    // We called GetPerformanceCounter. Use it as entropy.\n+    RAND_add((const unsigned char*)&start, sizeof(start), 1);\n+    RAND_add((const unsigned char*)&stop, sizeof(stop), 1);\n+\n+    return true;\n+}\n+\n+FastRandomContext::FastRandomContext(bool fDeterministic) : requires_seed(!fDeterministic), bytebuf_size(0), bitbuf_size(0)\n+{\n+    if (!fDeterministic) {\n+        return;\n+    }\n+    uint256 seed;\n+    rng.SetKey(seed.begin(), 32);\n }"
      },
      {
        "sha": "6a63d5742920954913d29d9954cfe750305557f7",
        "filename": "src/random.h",
        "status": "modified",
        "additions": 78,
        "deletions": 7,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/random.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/random.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -6,6 +6,8 @@\n #ifndef BITCOIN_RANDOM_H\n #define BITCOIN_RANDOM_H\n \n+#include \"crypto/chacha20.h\"\n+#include \"crypto/common.h\"\n #include \"uint256.h\"\n \n #include <stdint.h>\n@@ -21,6 +23,13 @@ uint64_t GetRand(uint64_t nMax);\n int GetRandInt(int nMax);\n uint256 GetRandHash();\n \n+/**\n+ * Add a little bit of randomness to the output of GetStrongRangBytes.\n+ * This sleeps for a millisecond, so should only be called when there is\n+ * no other work to be done.\n+ */\n+void RandAddSeedSleep();\n+\n /**\n  * Function to gather random data from multiple sources, failing whenever any\n  * of those source fail to provide a result.\n@@ -33,17 +42,79 @@ void GetStrongRandBytes(unsigned char* buf, int num);\n  * This class is not thread-safe.\n  */\n class FastRandomContext {\n+private:\n+    bool requires_seed;\n+    ChaCha20 rng;\n+\n+    unsigned char bytebuf[64];\n+    int bytebuf_size;\n+\n+    uint64_t bitbuf;\n+    int bitbuf_size;\n+\n+    void RandomSeed();\n+\n+    void FillByteBuffer()\n+    {\n+        if (requires_seed) {\n+            RandomSeed();\n+        }\n+        rng.Output(bytebuf, sizeof(bytebuf));\n+        bytebuf_size = sizeof(bytebuf);\n+    }\n+\n+    void FillBitBuffer()\n+    {\n+        bitbuf = rand64();\n+        bitbuf_size = 64;\n+    }\n+\n public:\n-    explicit FastRandomContext(bool fDeterministic=false);\n+    explicit FastRandomContext(bool fDeterministic = false);\n+\n+    /** Initialize with explicit seed (only for testing) */\n+    explicit FastRandomContext(const uint256& seed);\n+\n+    /** Generate a random 64-bit integer. */\n+    uint64_t rand64()\n+    {\n+        if (bytebuf_size < 8) FillByteBuffer();\n+        uint64_t ret = ReadLE64(bytebuf + 64 - bytebuf_size);\n+        bytebuf_size -= 8;\n+        return ret;\n+    }\n+\n+    /** Generate a random (bits)-bit integer. */\n+    uint64_t randbits(int bits) {\n+        if (bits == 0) {\n+            return 0;\n+        } else if (bits > 32) {\n+            return rand64() >> (64 - bits);\n+        } else {\n+            if (bitbuf_size < bits) FillBitBuffer();\n+            uint64_t ret = bitbuf & (~(uint64_t)0 >> (64 - bits));\n+            bitbuf >>= bits;\n+            bitbuf_size -= bits;\n+            return ret;\n+        }\n+    }\n \n-    uint32_t rand32() {\n-        Rz = 36969 * (Rz & 65535) + (Rz >> 16);\n-        Rw = 18000 * (Rw & 65535) + (Rw >> 16);\n-        return (Rw << 16) + Rz;\n+    /** Generate a random integer in the range [0..range). */\n+    uint64_t randrange(uint64_t range)\n+    {\n+        --range;\n+        int bits = CountBits(range);\n+        while (true) {\n+            uint64_t ret = randbits(bits);\n+            if (ret <= range) return ret;\n+        }\n     }\n \n-    uint32_t Rz;\n-    uint32_t Rw;\n+    /** Generate a random 32-bit integer. */\n+    uint32_t rand32() { return randbits(32); }\n+\n+    /** Generate a random boolean. */\n+    bool randbool() { return randbits(1); }\n };\n \n /* Number of random bytes returned by GetOSRand."
      },
      {
        "sha": "7537ed45027f510020b2ffdf76f3688ecbec2a78",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -5,6 +5,7 @@\n \n #include \"chain.h\"\n #include \"chainparams.h\"\n+#include \"core_io.h\"\n #include \"primitives/block.h\"\n #include \"primitives/transaction.h\"\n #include \"validation.h\"\n@@ -56,10 +57,6 @@ struct CCoin {\n     }\n };\n \n-/* Defined in rawtransaction.cpp */\n-void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry);\n-void ScriptPubKeyToJSON(const CScript& scriptPubKey, UniValue& out, bool fIncludeHex);\n-\n static bool RESTERR(HTTPRequest* req, enum HTTPStatusCode status, std::string message)\n {\n     req->WriteHeader(\"Content-Type\", \"text/plain\");\n@@ -383,7 +380,7 @@ static bool rest_tx(HTTPRequest* req, const std::string& strURIPart)\n \n     case RF_JSON: {\n         UniValue objTx(UniValue::VOBJ);\n-        TxToJSON(*tx, hashBlock, objTx);\n+        TxToUniv(*tx, hashBlock, objTx);\n         std::string strJSON = objTx.write() + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"application/json\");\n         req->WriteReply(HTTP_OK, strJSON);\n@@ -577,7 +574,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n \n             // include the script in a json output\n             UniValue o(UniValue::VOBJ);\n-            ScriptPubKeyToJSON(coin.out.scriptPubKey, o, true);\n+            ScriptPubKeyToUniv(coin.out.scriptPubKey, o, true);\n             utxo.push_back(Pair(\"scriptPubKey\", o));\n             utxos.push_back(utxo);\n         }"
      },
      {
        "sha": "b4b160aac9f715158c02aa026633821b361f033e",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 117,
        "deletions": 18,
        "changes": 135,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -12,6 +12,8 @@\n #include \"coins.h\"\n #include \"consensus/validation.h\"\n #include \"validation.h\"\n+#include \"core_io.h\"\n+#include \"policy/feerate.h\"\n #include \"policy/policy.h\"\n #include \"primitives/transaction.h\"\n #include \"rpc/server.h\"\n@@ -42,7 +44,6 @@ static std::condition_variable cond_blockchange;\n static CUpdatedBlock latestblock;\n \n extern void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry);\n-void ScriptPubKeyToJSON(const CScript& scriptPubKey, UniValue& out, bool fIncludeHex);\n \n double GetDifficulty(const CBlockIndex* blockindex)\n {\n@@ -123,7 +124,7 @@ UniValue blockToJSON(const CBlock& block, const CBlockIndex* blockindex, bool tx\n         if(txDetails)\n         {\n             UniValue objTx(UniValue::VOBJ);\n-            TxToJSON(*tx, uint256(), objTx);\n+            TxToUniv(*tx, uint256(), objTx);\n             txs.push_back(objTx);\n         }\n         else\n@@ -186,7 +187,7 @@ void RPCNotifyBlockChange(bool ibd, const CBlockIndex * pindex)\n         latestblock.hash = pindex->GetBlockHash();\n         latestblock.height = pindex->nHeight;\n     }\n-\tcond_blockchange.notify_all();\n+    cond_blockchange.notify_all();\n }\n \n UniValue waitfornewblock(const JSONRPCRequest& request)\n@@ -412,6 +413,7 @@ UniValue getrawmempool(const JSONRPCRequest& request)\n         throw std::runtime_error(\n             \"getrawmempool ( verbose )\\n\"\n             \"\\nReturns all transaction ids in memory pool as a json array of string transaction ids.\\n\"\n+            \"\\nHint: use getmempoolentry to fetch a specific transaction from the mempool.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. verbose (boolean, optional, default=false) True for a json object, false for array of transaction ids\\n\"\n             \"\\nResult: (for verbose = false):\\n\"\n@@ -686,13 +688,16 @@ UniValue getblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n-            \"getblock \\\"blockhash\\\" ( verbose )\\n\"\n-            \"\\nIf verbose is false, returns a string that is serialized, hex-encoded data for block 'hash'.\\n\"\n-            \"If verbose is true, returns an Object with information about block <hash>.\\n\"\n+            \"getblock \\\"blockhash\\\" ( verbosity ) \\n\"\n+            \"\\nIf verbosity is 0, returns a string that is serialized, hex-encoded data for block 'hash'.\\n\"\n+            \"If verbosity is 1, returns an Object with information about block <hash>.\\n\"\n+            \"If verbosity is 2, returns an Object with information about block <hash> and information about each transaction. \\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"blockhash\\\"          (string, required) The block hash\\n\"\n-            \"2. verbose                (boolean, optional, default=true) true for a json object, false for the hex encoded data\\n\"\n-            \"\\nResult (for verbose = true):\\n\"\n+            \"2. verbosity              (numeric, optional, default=1) 0 for hex encoded data, 1 for a json object, and 2 for json object with transaction data\\n\"\n+            \"\\nResult (for verbosity = 0):\\n\"\n+            \"\\\"data\\\"             (string) A string that is serialized, hex-encoded data for block 'hash'.\\n\"\n+            \"\\nResult (for verbosity = 1):\\n\"\n             \"{\\n\"\n             \"  \\\"hash\\\" : \\\"hash\\\",     (string) the block hash (same as provided)\\n\"\n             \"  \\\"confirmations\\\" : n,   (numeric) The number of confirmations, or -1 if the block is not on the main chain\\n\"\n@@ -716,8 +721,14 @@ UniValue getblock(const JSONRPCRequest& request)\n             \"  \\\"previousblockhash\\\" : \\\"hash\\\",  (string) The hash of the previous block\\n\"\n             \"  \\\"nextblockhash\\\" : \\\"hash\\\"       (string) The hash of the next block\\n\"\n             \"}\\n\"\n-            \"\\nResult (for verbose=false):\\n\"\n-            \"\\\"data\\\"             (string) A string that is serialized, hex-encoded data for block 'hash'.\\n\"\n+            \"\\nResult (for verbosity = 2):\\n\"\n+            \"{\\n\"\n+            \"  ...,                     Same output as verbosity = 1.\\n\"\n+            \"  \\\"tx\\\" : [               (array of Objects) The transactions in the format of the getrawtransaction RPC. Different from verbosity = 1 \\\"tx\\\" result.\\n\"\n+            \"         ,...\\n\"\n+            \"  ],\\n\"\n+            \"  ,...                     Same output as verbosity = 1.\\n\"\n+            \"}\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"getblock\", \"\\\"00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09\\\"\")\n             + HelpExampleRpc(\"getblock\", \"\\\"00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09\\\"\")\n@@ -728,9 +739,13 @@ UniValue getblock(const JSONRPCRequest& request)\n     std::string strHash = request.params[0].get_str();\n     uint256 hash(uint256S(strHash));\n \n-    bool fVerbose = true;\n-    if (request.params.size() > 1)\n-        fVerbose = request.params[1].get_bool();\n+    int verbosity = 1;\n+    if (request.params.size() > 1) {\n+        if(request.params[1].isNum())\n+            verbosity = request.params[1].get_int();\n+        else\n+            verbosity = request.params[1].get_bool() ? 1 : 0;\n+    }\n \n     if (mapBlockIndex.count(hash) == 0)\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n@@ -749,15 +764,15 @@ UniValue getblock(const JSONRPCRequest& request)\n         // block).\n         throw JSONRPCError(RPC_MISC_ERROR, \"Block not found on disk\");\n \n-    if (!fVerbose)\n+    if (verbosity <= 0)\n     {\n         CDataStream ssBlock(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());\n         ssBlock << block;\n         std::string strHex = HexStr(ssBlock.begin(), ssBlock.end());\n         return strHex;\n     }\n \n-    return blockToJSON(block, pblockindex);\n+    return blockToJSON(block, pblockindex, verbosity >= 2);\n }\n \n struct CCoinsStats\n@@ -975,7 +990,7 @@ UniValue gettxout(const JSONRPCRequest& request)\n         ret.push_back(Pair(\"confirmations\", pindex->nHeight - coins.nHeight + 1));\n     ret.push_back(Pair(\"value\", ValueFromAmount(coins.vout[n].nValue)));\n     UniValue o(UniValue::VOBJ);\n-    ScriptPubKeyToJSON(coins.vout[n].scriptPubKey, o, true);\n+    ScriptPubKeyToUniv(coins.vout[n].scriptPubKey, o, true);\n     ret.push_back(Pair(\"scriptPubKey\", o));\n     ret.push_back(Pair(\"version\", coins.nVersion));\n     ret.push_back(Pair(\"coinbase\", coins.fCoinBase));\n@@ -1059,6 +1074,17 @@ static UniValue BIP9SoftForkDesc(const Consensus::Params& consensusParams, Conse\n     rv.push_back(Pair(\"startTime\", consensusParams.vDeployments[id].nStartTime));\n     rv.push_back(Pair(\"timeout\", consensusParams.vDeployments[id].nTimeout));\n     rv.push_back(Pair(\"since\", VersionBitsTipStateSinceHeight(consensusParams, id)));\n+    if (THRESHOLD_STARTED == thresholdState)\n+    {\n+        UniValue statsUV(UniValue::VOBJ);\n+        BIP9Stats statsStruct = VersionBitsTipStatistics(consensusParams, id);\n+        statsUV.push_back(Pair(\"period\", statsStruct.period));\n+        statsUV.push_back(Pair(\"threshold\", statsStruct.threshold));\n+        statsUV.push_back(Pair(\"elapsed\", statsStruct.elapsed));\n+        statsUV.push_back(Pair(\"count\", statsStruct.count));\n+        statsUV.push_back(Pair(\"possible\", statsStruct.possible));\n+        rv.push_back(Pair(\"statistics\", statsUV));\n+    }\n     return rv;\n }\n \n@@ -1104,7 +1130,14 @@ UniValue getblockchaininfo(const JSONRPCRequest& request)\n             \"        \\\"bit\\\": xx,             (numeric) the bit (0-28) in the block version field used to signal this softfork (only for \\\"started\\\" status)\\n\"\n             \"        \\\"startTime\\\": xx,       (numeric) the minimum median time past of a block at which the bit gains its meaning\\n\"\n             \"        \\\"timeout\\\": xx,         (numeric) the median time past of a block at which the deployment is considered failed if not yet locked in\\n\"\n-            \"        \\\"since\\\": xx            (numeric) height of the first block to which the status applies\\n\"\n+            \"        \\\"since\\\": xx,           (numeric) height of the first block to which the status applies\\n\"\n+            \"        \\\"statistics\\\": {        (object) numeric statistics about BIP9 signalling for a softfork (only for \\\"started\\\" status)\\n\"\n+            \"           \\\"period\\\": xx,       (numeric) the length in blocks of the BIP9 signalling period \\n\"\n+            \"           \\\"threshold\\\": xx,    (numeric) the number of blocks with the version bit set required to activate the feature \\n\"\n+            \"           \\\"elapsed\\\": xx,      (numeric) the number of blocks elapsed since the beginning of the current period \\n\"\n+            \"           \\\"count\\\": xx,        (numeric) the number of blocks with the version bit set in the current period \\n\"\n+            \"           \\\"possible\\\": xx      (boolean) returns false if there are not enough blocks left in this period to pass activation threshold \\n\"\n+            \"        }\\n\"\n             \"     }\\n\"\n             \"  }\\n\"\n             \"}\\n\"\n@@ -1415,13 +1448,79 @@ UniValue reconsiderblock(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+UniValue getchaintxstats(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"getchaintxstats ( nblocks blockhash )\\n\"\n+            \"\\nCompute statistics about the total number and rate of transactions in the chain.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. nblocks      (numeric, optional) Size of the window in number of blocks (default: one month).\\n\"\n+            \"2. \\\"blockhash\\\"  (string, optional) The hash of the block that ends the window.\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"time\\\": xxxxx,        (numeric) The timestamp for the statistics in UNIX format.\\n\"\n+            \"  \\\"txcount\\\": xxxxx,     (numeric) The total number of transactions in the chain up to that point.\\n\"\n+            \"  \\\"txrate\\\": x.xx,       (numeric) The average rate of transactions per second in the window.\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getchaintxstats\", \"\")\n+            + HelpExampleRpc(\"getchaintxstats\", \"2016\")\n+        );\n+\n+    const CBlockIndex* pindex;\n+    int blockcount = 30 * 24 * 60 * 60 / Params().GetConsensus().nPowTargetSpacing; // By default: 1 month\n+\n+    if (request.params.size() > 0 && !request.params[0].isNull()) {\n+        blockcount = request.params[0].get_int();\n+    }\n+\n+    bool havehash = request.params.size() > 1 && !request.params[1].isNull();\n+    uint256 hash;\n+    if (havehash) {\n+        hash = uint256S(request.params[1].get_str());\n+    }\n+\n+    {\n+        LOCK(cs_main);\n+        if (havehash) {\n+            auto it = mapBlockIndex.find(hash);\n+            if (it == mapBlockIndex.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n+            }\n+            pindex = it->second;\n+            if (!chainActive.Contains(pindex)) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Block is not in main chain\");\n+            }\n+        } else {\n+            pindex = chainActive.Tip();\n+        }\n+    }\n+\n+    if (blockcount < 1 || blockcount >= pindex->nHeight) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid block count: should be between 1 and the block's height\");\n+    }\n+\n+    const CBlockIndex* pindexPast = pindex->GetAncestor(pindex->nHeight - blockcount);\n+    int nTimeDiff = pindex->GetMedianTimePast() - pindexPast->GetMedianTimePast();\n+    int nTxDiff = pindex->nChainTx - pindexPast->nChainTx;\n+\n+    UniValue ret(UniValue::VOBJ);\n+    ret.push_back(Pair(\"time\", (int64_t)pindex->nTime));\n+    ret.push_back(Pair(\"txcount\", (int64_t)pindex->nChainTx));\n+    ret.push_back(Pair(\"txrate\", ((double)nTxDiff) / nTimeDiff));\n+\n+    return ret;\n+}\n+\n static const CRPCCommand commands[] =\n { //  category              name                      actor (function)         okSafe argNames\n   //  --------------------- ------------------------  -----------------------  ------ ----------\n     { \"blockchain\",         \"getblockchaininfo\",      &getblockchaininfo,      true,  {} },\n+    { \"blockchain\",         \"getchaintxstats\",        &getchaintxstats,        true,  {\"nblocks\", \"blockhash\"} },\n     { \"blockchain\",         \"getbestblockhash\",       &getbestblockhash,       true,  {} },\n     { \"blockchain\",         \"getblockcount\",          &getblockcount,          true,  {} },\n-    { \"blockchain\",         \"getblock\",               &getblock,               true,  {\"blockhash\",\"verbose\"} },\n+    { \"blockchain\",         \"getblock\",               &getblock,               true,  {\"blockhash\",\"verbosity|verbose\"} },\n     { \"blockchain\",         \"getblockhash\",           &getblockhash,           true,  {\"height\"} },\n     { \"blockchain\",         \"getblockheader\",         &getblockheader,         true,  {\"blockhash\",\"verbose\"} },\n     { \"blockchain\",         \"getchaintips\",           &getchaintips,           true,  {} },"
      },
      {
        "sha": "a3a692c14d527e85a2c906413cf810383423ccde",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -77,8 +77,10 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"listunspent\", 0, \"minconf\" },\n     { \"listunspent\", 1, \"maxconf\" },\n     { \"listunspent\", 2, \"addresses\" },\n-    { \"getblock\", 1, \"verbose\" },\n+    { \"listunspent\", 4, \"query_options\" },\n+    { \"getblock\", 1, \"verbosity\" },\n     { \"getblockheader\", 1, \"verbose\" },\n+    { \"getchaintxstats\", 0, \"nblocks\" },\n     { \"gettransaction\", 1, \"include_watchonly\" },\n     { \"getrawtransaction\", 1, \"verbose\" },\n     { \"createrawtransaction\", 0, \"inputs\" },\n@@ -106,6 +108,10 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"getrawmempool\", 0, \"verbose\" },\n     { \"estimatefee\", 0, \"nblocks\" },\n     { \"estimatesmartfee\", 0, \"nblocks\" },\n+    { \"estimatesmartfee\", 1, \"conservative\" },\n+    { \"estimaterawfee\", 0, \"nblocks\" },\n+    { \"estimaterawfee\", 1, \"threshold\" },\n+    { \"estimaterawfee\", 2, \"horizon\" },\n     { \"prioritisetransaction\", 1, \"fee_delta\" },\n     { \"setban\", 2, \"bantime\" },\n     { \"setban\", 3, \"absolute\" },"
      },
      {
        "sha": "d744269df1c8b033874c35bc219449ff3e45c176",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 101,
        "deletions": 7,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -15,6 +15,7 @@\n #include \"validation.h\"\n #include \"miner.h\"\n #include \"net.h\"\n+#include \"policy/fees.h\"\n #include \"pow.h\"\n #include \"rpc/blockchain.h\"\n #include \"rpc/server.h\"\n@@ -796,6 +797,7 @@ UniValue estimatefee(const JSONRPCRequest& request)\n     if (request.fHelp || request.params.size() != 1)\n         throw std::runtime_error(\n             \"estimatefee nblocks\\n\"\n+            \"\\nDEPRECATED. Please use estimatesmartfee for more intelligent estimates.\"\n             \"\\nEstimates the approximate fee per kilobyte needed for a transaction to begin\\n\"\n             \"confirmation within nblocks blocks. Uses virtual transaction size of transaction\\n\"\n             \"as defined in BIP 141 (witness data is discounted).\\n\"\n@@ -818,7 +820,7 @@ UniValue estimatefee(const JSONRPCRequest& request)\n     if (nBlocks < 1)\n         nBlocks = 1;\n \n-    CFeeRate feeRate = mempool.estimateFee(nBlocks);\n+    CFeeRate feeRate = ::feeEstimator.estimateFee(nBlocks);\n     if (feeRate == CFeeRate(0))\n         return -1.0;\n \n@@ -827,16 +829,19 @@ UniValue estimatefee(const JSONRPCRequest& request)\n \n UniValue estimatesmartfee(const JSONRPCRequest& request)\n {\n-    if (request.fHelp || request.params.size() != 1)\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n-            \"estimatesmartfee nblocks\\n\"\n-            \"\\nWARNING: This interface is unstable and may disappear or change!\\n\"\n+            \"estimatesmartfee nblocks (conservative)\\n\"\n             \"\\nEstimates the approximate fee per kilobyte needed for a transaction to begin\\n\"\n             \"confirmation within nblocks blocks if possible and return the number of blocks\\n\"\n             \"for which the estimate is valid. Uses virtual transaction size as defined\\n\"\n             \"in BIP 141 (witness data is discounted).\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. nblocks     (numeric)\\n\"\n+            \"1. nblocks       (numeric)\\n\"\n+            \"2. conservative  (bool, optional, default=true) Whether to return a more conservative estimate which\\n\"\n+            \"                 also satisfies a longer history. A conservative estimate potentially returns a higher\\n\"\n+            \"                 feerate and is more likely to be sufficient for the desired target, but is not as\\n\"\n+            \"                 responsive to short term drops in the prevailing fee market\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"feerate\\\" : x.x,     (numeric) estimate fee-per-kilobyte (in BTC)\\n\"\n@@ -853,15 +858,102 @@ UniValue estimatesmartfee(const JSONRPCRequest& request)\n     RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VNUM));\n \n     int nBlocks = request.params[0].get_int();\n+    bool conservative = true;\n+    if (request.params.size() > 1 && !request.params[1].isNull()) {\n+        RPCTypeCheckArgument(request.params[1], UniValue::VBOOL);\n+        conservative = request.params[1].get_bool();\n+    }\n \n     UniValue result(UniValue::VOBJ);\n     int answerFound;\n-    CFeeRate feeRate = mempool.estimateSmartFee(nBlocks, &answerFound);\n+    CFeeRate feeRate = ::feeEstimator.estimateSmartFee(nBlocks, &answerFound, ::mempool, conservative);\n     result.push_back(Pair(\"feerate\", feeRate == CFeeRate(0) ? -1.0 : ValueFromAmount(feeRate.GetFeePerK())));\n     result.push_back(Pair(\"blocks\", answerFound));\n     return result;\n }\n \n+UniValue estimaterawfee(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1|| request.params.size() > 3)\n+        throw std::runtime_error(\n+            \"estimaterawfee nblocks (threshold horizon)\\n\"\n+            \"\\nWARNING: This interface is unstable and may disappear or change!\\n\"\n+            \"\\nWARNING: This is an advanced API call that is tightly coupled to the specific\\n\"\n+            \"         implementation of fee estimation. The parameters it can be called with\\n\"\n+            \"         and the results it returns will change if the internal implementation changes.\\n\"\n+            \"\\nEstimates the approximate fee per kilobyte needed for a transaction to begin\\n\"\n+            \"confirmation within nblocks blocks if possible. Uses virtual transaction size as defined\\n\"\n+            \"in BIP 141 (witness data is discounted).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. nblocks     (numeric)\\n\"\n+            \"2. threshold   (numeric, optional) The proportion of transactions in a given feerate range that must have been\\n\"\n+            \"               confirmed within nblocks in order to consider those feerates as high enough and proceed to check\\n\"\n+            \"               lower buckets.  Default: 0.95\\n\"\n+            \"3. horizon     (numeric, optional) How long a history of estimates to consider. 0=short, 1=medium, 2=long.\\n\"\n+            \"               Default: 1\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"feerate\\\" : x.x,        (numeric) estimate fee-per-kilobyte (in BTC)\\n\"\n+            \"  \\\"decay\\\" : x.x,          (numeric) exponential decay (per block) for historical moving average of confirmation data\\n\"\n+            \"  \\\"scale\\\" : x,            (numeric) The resolution of confirmation targets at this time horizon\\n\"\n+            \"  \\\"pass\\\" : {              (json object) information about the lowest range of feerates to succeed in meeting the threshold\\n\"\n+            \"      \\\"startrange\\\" : x.x,     (numeric) start of feerate range\\n\"\n+            \"      \\\"endrange\\\" : x.x,       (numeric) end of feerate range\\n\"\n+            \"      \\\"withintarget\\\" : x.x,   (numeric) number of txs over history horizon in the feerate range that were confirmed within target\\n\"\n+            \"      \\\"totalconfirmed\\\" : x.x, (numeric) number of txs over history horizon in the feerate range that were confirmed at any point\\n\"\n+            \"      \\\"inmempool\\\" : x.x,      (numeric) current number of txs in mempool in the feerate range unconfirmed for at least target blocks\\n\"\n+            \"      \\\"leftmempool\\\" : x.x,    (numeric) number of txs over history horizon in the feerate range that left mempool unconfirmed after target\\n\"\n+            \"  }\\n\"\n+            \"  \\\"fail\\\" : { ... }        (json object) information about the highest range of feerates to fail to meet the threshold\\n\"\n+            \"}\\n\"\n+            \"\\n\"\n+            \"A negative feerate is returned if no answer can be given.\\n\"\n+            \"\\nExample:\\n\"\n+            + HelpExampleCli(\"estimaterawfee\", \"6 0.9 1\")\n+            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VNUM)(UniValue::VNUM)(UniValue::VNUM), true);\n+    RPCTypeCheckArgument(request.params[0], UniValue::VNUM);\n+    int nBlocks = request.params[0].get_int();\n+    double threshold = 0.95;\n+    if (!request.params[1].isNull())\n+        threshold = request.params[1].get_real();\n+    FeeEstimateHorizon horizon = FeeEstimateHorizon::MED_HALFLIFE;\n+    if (!request.params[2].isNull()) {\n+        int horizonInt = request.params[2].get_int();\n+        if (horizonInt < 0 || horizonInt > 2) {\n+            throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid horizon for fee estimates\");\n+        } else {\n+            horizon = (FeeEstimateHorizon)horizonInt;\n+        }\n+    }\n+    UniValue result(UniValue::VOBJ);\n+    CFeeRate feeRate;\n+    EstimationResult buckets;\n+    feeRate = ::feeEstimator.estimateRawFee(nBlocks, threshold, horizon, &buckets);\n+\n+    result.push_back(Pair(\"feerate\", feeRate == CFeeRate(0) ? -1.0 : ValueFromAmount(feeRate.GetFeePerK())));\n+    result.push_back(Pair(\"decay\", buckets.decay));\n+    result.push_back(Pair(\"scale\", (int)buckets.scale));\n+    UniValue passbucket(UniValue::VOBJ);\n+    passbucket.push_back(Pair(\"startrange\", round(buckets.pass.start)));\n+    passbucket.push_back(Pair(\"endrange\", round(buckets.pass.end)));\n+    passbucket.push_back(Pair(\"withintarget\", round(buckets.pass.withinTarget * 100.0) / 100.0));\n+    passbucket.push_back(Pair(\"totalconfirmed\", round(buckets.pass.totalConfirmed * 100.0) / 100.0));\n+    passbucket.push_back(Pair(\"inmempool\", round(buckets.pass.inMempool * 100.0) / 100.0));\n+    passbucket.push_back(Pair(\"leftmempool\", round(buckets.pass.leftMempool * 100.0) / 100.0));\n+    result.push_back(Pair(\"pass\", passbucket));\n+    UniValue failbucket(UniValue::VOBJ);\n+    failbucket.push_back(Pair(\"startrange\", round(buckets.fail.start)));\n+    failbucket.push_back(Pair(\"endrange\", round(buckets.fail.end)));\n+    failbucket.push_back(Pair(\"withintarget\", round(buckets.fail.withinTarget * 100.0) / 100.0));\n+    failbucket.push_back(Pair(\"totalconfirmed\", round(buckets.fail.totalConfirmed * 100.0) / 100.0));\n+    failbucket.push_back(Pair(\"inmempool\", round(buckets.fail.inMempool * 100.0) / 100.0));\n+    failbucket.push_back(Pair(\"leftmempool\", round(buckets.fail.leftMempool * 100.0) / 100.0));\n+    result.push_back(Pair(\"fail\", failbucket));\n+    return result;\n+}\n+\n static const CRPCCommand commands[] =\n { //  category              name                      actor (function)         okSafeMode\n   //  --------------------- ------------------------  -----------------------  ----------\n@@ -875,7 +967,9 @@ static const CRPCCommand commands[] =\n     { \"generating\",         \"generatetoaddress\",      &generatetoaddress,      true,  {\"nblocks\",\"address\",\"maxtries\"} },\n \n     { \"util\",               \"estimatefee\",            &estimatefee,            true,  {\"nblocks\"} },\n-    { \"util\",               \"estimatesmartfee\",       &estimatesmartfee,       true,  {\"nblocks\"} },\n+    { \"util\",               \"estimatesmartfee\",       &estimatesmartfee,       true,  {\"nblocks\", \"conservative\"} },\n+\n+    { \"hidden\",             \"estimaterawfee\",         &estimaterawfee,         true,  {\"nblocks\", \"threshold\", \"horizon\"} },\n };\n \n void RegisterMiningRPCCommands(CRPCTable &t)"
      },
      {
        "sha": "1f973a0c1840cef3b3e0391f2bfd21a1f0a14795",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -4,6 +4,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"base58.h\"\n+#include \"chain.h\"\n #include \"clientversion.h\"\n #include \"init.h\"\n #include \"validation.h\""
      },
      {
        "sha": "2a22a3daf2452ae005917a77a3935da95a986fdb",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 70,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -36,77 +36,15 @@\n \n #include <univalue.h>\n \n-void ScriptPubKeyToJSON(const CScript& scriptPubKey, UniValue& out, bool fIncludeHex)\n-{\n-    txnouttype type;\n-    std::vector<CTxDestination> addresses;\n-    int nRequired;\n-\n-    out.push_back(Pair(\"asm\", ScriptToAsmStr(scriptPubKey)));\n-    if (fIncludeHex)\n-        out.push_back(Pair(\"hex\", HexStr(scriptPubKey.begin(), scriptPubKey.end())));\n-\n-    if (!ExtractDestinations(scriptPubKey, type, addresses, nRequired)) {\n-        out.push_back(Pair(\"type\", GetTxnOutputType(type)));\n-        return;\n-    }\n-\n-    out.push_back(Pair(\"reqSigs\", nRequired));\n-    out.push_back(Pair(\"type\", GetTxnOutputType(type)));\n-\n-    UniValue a(UniValue::VARR);\n-    BOOST_FOREACH(const CTxDestination& addr, addresses)\n-        a.push_back(CBitcoinAddress(addr).ToString());\n-    out.push_back(Pair(\"addresses\", a));\n-}\n \n void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n {\n-    entry.push_back(Pair(\"txid\", tx.GetHash().GetHex()));\n-    entry.push_back(Pair(\"hash\", tx.GetWitnessHash().GetHex()));\n-    entry.push_back(Pair(\"size\", (int)::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION)));\n-    entry.push_back(Pair(\"vsize\", (int)::GetVirtualTransactionSize(tx)));\n-    entry.push_back(Pair(\"version\", tx.nVersion));\n-    entry.push_back(Pair(\"locktime\", (int64_t)tx.nLockTime));\n-\n-    UniValue vin(UniValue::VARR);\n-    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n-        const CTxIn& txin = tx.vin[i];\n-        UniValue in(UniValue::VOBJ);\n-        if (tx.IsCoinBase())\n-            in.push_back(Pair(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n-        else {\n-            in.push_back(Pair(\"txid\", txin.prevout.hash.GetHex()));\n-            in.push_back(Pair(\"vout\", (int64_t)txin.prevout.n));\n-            UniValue o(UniValue::VOBJ);\n-            o.push_back(Pair(\"asm\", ScriptToAsmStr(txin.scriptSig, true)));\n-            o.push_back(Pair(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n-            in.push_back(Pair(\"scriptSig\", o));\n-        }\n-        if (tx.HasWitness()) {\n-                UniValue txinwitness(UniValue::VARR);\n-                for (unsigned int j = 0; j < tx.vin[i].scriptWitness.stack.size(); j++) {\n-                    std::vector<unsigned char> item = tx.vin[i].scriptWitness.stack[j];\n-                    txinwitness.push_back(HexStr(item.begin(), item.end()));\n-                }\n-                in.push_back(Pair(\"txinwitness\", txinwitness));\n-        }\n-        in.push_back(Pair(\"sequence\", (int64_t)txin.nSequence));\n-        vin.push_back(in);\n-    }\n-    entry.push_back(Pair(\"vin\", vin));\n-    UniValue vout(UniValue::VARR);\n-    for (unsigned int i = 0; i < tx.vout.size(); i++) {\n-        const CTxOut& txout = tx.vout[i];\n-        UniValue out(UniValue::VOBJ);\n-        out.push_back(Pair(\"value\", ValueFromAmount(txout.nValue)));\n-        out.push_back(Pair(\"n\", (int64_t)i));\n-        UniValue o(UniValue::VOBJ);\n-        ScriptPubKeyToJSON(txout.scriptPubKey, o, true);\n-        out.push_back(Pair(\"scriptPubKey\", o));\n-        vout.push_back(out);\n-    }\n-    entry.push_back(Pair(\"vout\", vout));\n+    // Call into TxToUniv() in bitcoin-common to decode the transaction hex.\n+    //\n+    // Blockchain contextual information (confirmations and blocktime) is not\n+    // available to code in bitcoin-common, so we query them here and push the\n+    // data into the returned UniValue.\n+    TxToUniv(tx, uint256(), entry);\n \n     if (!hashBlock.IsNull()) {\n         entry.push_back(Pair(\"blockhash\", hashBlock.GetHex()));\n@@ -527,7 +465,7 @@ UniValue decoderawtransaction(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n \n     UniValue result(UniValue::VOBJ);\n-    TxToJSON(CTransaction(std::move(mtx)), uint256(), result);\n+    TxToUniv(CTransaction(std::move(mtx)), uint256(), result);\n \n     return result;\n }\n@@ -567,7 +505,7 @@ UniValue decodescript(const JSONRPCRequest& request)\n     } else {\n         // Empty scripts are valid\n     }\n-    ScriptPubKeyToJSON(script, r, false);\n+    ScriptPubKeyToUniv(script, r, false);\n \n     UniValue type;\n     type = find_value(r, \"type\");\n@@ -587,6 +525,11 @@ static void TxInErrorToJSON(const CTxIn& txin, UniValue& vErrorsRet, const std::\n     UniValue entry(UniValue::VOBJ);\n     entry.push_back(Pair(\"txid\", txin.prevout.hash.ToString()));\n     entry.push_back(Pair(\"vout\", (uint64_t)txin.prevout.n));\n+    UniValue witness(UniValue::VARR);\n+    for (unsigned int i = 0; i < txin.scriptWitness.stack.size(); i++) {\n+        witness.push_back(HexStr(txin.scriptWitness.stack[i].begin(), txin.scriptWitness.stack[i].end()));\n+    }\n+    entry.push_back(Pair(\"witness\", witness));\n     entry.push_back(Pair(\"scriptSig\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n     entry.push_back(Pair(\"sequence\", (uint64_t)txin.nSequence));\n     entry.push_back(Pair(\"error\", strMessage));"
      },
      {
        "sha": "c5fbff00775cdd546e301d702bf776d08f44579c",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 6,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -22,6 +22,8 @@\n #include <boost/signals2/signal.hpp>\n #include <boost/thread.hpp>\n #include <boost/algorithm/string/case_conv.hpp> // for to_upper()\n+#include <boost/algorithm/string/classification.hpp>\n+#include <boost/algorithm/string/split.hpp>\n \n #include <memory> // for unique_ptr\n #include <unordered_map>\n@@ -42,17 +44,17 @@ static struct CRPCSignals\n     boost::signals2::signal<void (const CRPCCommand&)> PreCommand;\n } g_rpcSignals;\n \n-void RPCServer::OnStarted(boost::function<void ()> slot)\n+void RPCServer::OnStarted(std::function<void ()> slot)\n {\n     g_rpcSignals.Started.connect(slot);\n }\n \n-void RPCServer::OnStopped(boost::function<void ()> slot)\n+void RPCServer::OnStopped(std::function<void ()> slot)\n {\n     g_rpcSignals.Stopped.connect(slot);\n }\n \n-void RPCServer::OnPreCommand(boost::function<void (const CRPCCommand&)> slot)\n+void RPCServer::OnPreCommand(std::function<void (const CRPCCommand&)> slot)\n {\n     g_rpcSignals.PreCommand.connect(boost::bind(slot, _1));\n }\n@@ -432,8 +434,16 @@ static inline JSONRPCRequest transformNamedArguments(const JSONRPCRequest& in, c\n     }\n     // Process expected parameters.\n     int hole = 0;\n-    for (const std::string &argName: argNames) {\n-        auto fr = argsIn.find(argName);\n+    for (const std::string &argNamePattern: argNames) {\n+        std::vector<std::string> vargNames;\n+        boost::algorithm::split(vargNames, argNamePattern, boost::algorithm::is_any_of(\"|\"));\n+        auto fr = argsIn.end();\n+        for (const std::string & argName : vargNames) {\n+            fr = argsIn.find(argName);\n+            if (fr != argsIn.end()) {\n+                break;\n+            }\n+        }\n         if (fr != argsIn.end()) {\n             for (int i = 0; i < hole; ++i) {\n                 // Fill hole between specified parameters with JSON nulls,\n@@ -526,7 +536,7 @@ void RPCUnsetTimerInterface(RPCTimerInterface *iface)\n         timerInterface = NULL;\n }\n \n-void RPCRunLater(const std::string& name, boost::function<void(void)> func, int64_t nSeconds)\n+void RPCRunLater(const std::string& name, std::function<void(void)> func, int64_t nSeconds)\n {\n     if (!timerInterface)\n         throw JSONRPCError(RPC_INTERNAL_ERROR, \"No timer handler registered for RPC\");"
      },
      {
        "sha": "1e984cbc0de22ba6fd1128b2f6d81324c333e07c",
        "filename": "src/rpc/server.h",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/rpc/server.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/rpc/server.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -15,8 +15,6 @@\n #include <stdint.h>\n #include <string>\n \n-#include <boost/function.hpp>\n-\n #include <univalue.h>\n \n static const unsigned int DEFAULT_RPC_SERIALIZE_VERSION = 1;\n@@ -25,9 +23,9 @@ class CRPCCommand;\n \n namespace RPCServer\n {\n-    void OnStarted(boost::function<void ()> slot);\n-    void OnStopped(boost::function<void ()> slot);\n-    void OnPreCommand(boost::function<void (const CRPCCommand&)> slot);\n+    void OnStarted(std::function<void ()> slot);\n+    void OnStopped(std::function<void ()> slot);\n+    void OnPreCommand(std::function<void (const CRPCCommand&)> slot);\n }\n \n class CBlockIndex;\n@@ -115,7 +113,7 @@ class RPCTimerInterface\n      * This is needed to cope with the case in which there is no HTTP server, but\n      * only GUI RPC console, and to break the dependency of pcserver on httprpc.\n      */\n-    virtual RPCTimerBase* NewTimer(boost::function<void(void)>& func, int64_t millis) = 0;\n+    virtual RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis) = 0;\n };\n \n /** Set the factory function for timers */\n@@ -129,7 +127,7 @@ void RPCUnsetTimerInterface(RPCTimerInterface *iface);\n  * Run func nSeconds from now.\n  * Overrides previous timer <name> (if any).\n  */\n-void RPCRunLater(const std::string& name, boost::function<void(void)> func, int64_t nSeconds);\n+void RPCRunLater(const std::string& name, std::function<void(void)> func, int64_t nSeconds);\n \n typedef UniValue(*rpcfn_type)(const JSONRPCRequest& jsonRequest);\n "
      },
      {
        "sha": "923ba2c231ede81b503d4923de93571033ab0862",
        "filename": "src/scheduler.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/scheduler.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/scheduler.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scheduler.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -4,6 +4,7 @@\n \n #include \"scheduler.h\"\n \n+#include \"random.h\"\n #include \"reverselock.h\"\n \n #include <assert.h>\n@@ -39,6 +40,11 @@ void CScheduler::serviceQueue()\n     // is called.\n     while (!shouldStop()) {\n         try {\n+            if (!shouldStop() && taskQueue.empty()) {\n+                reverse_lock<boost::unique_lock<boost::mutex> > rlock(lock);\n+                // Use this chance to get a tiny bit more entropy\n+                RandAddSeedSleep();\n+            }\n             while (!shouldStop() && taskQueue.empty()) {\n                 // Wait until there is something to do.\n                 newTaskScheduled.wait(lock);"
      },
      {
        "sha": "27412a15b465b1a98cbc46613fc17b11c45b40cd",
        "filename": "src/scheduler.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/scheduler.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/scheduler.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scheduler.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -7,8 +7,8 @@\n \n //\n // NOTE:\n-// boost::thread / boost::function / boost::chrono should be ported to\n-// std::thread / std::function / std::chrono when we support C++11.\n+// boost::thread / boost::chrono should be ported to std::thread / std::chrono\n+// when we support C++11.\n //\n #include <boost/chrono/chrono.hpp>\n #include <boost/thread.hpp>"
      },
      {
        "sha": "222cff59eab2581fb879dd5c6e1c43fba099f2e5",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -247,10 +247,10 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n {\n     static const CScriptNum bnZero(0);\n     static const CScriptNum bnOne(1);\n-    static const CScriptNum bnFalse(0);\n-    static const CScriptNum bnTrue(1);\n+    // static const CScriptNum bnFalse(0);\n+    // static const CScriptNum bnTrue(1);\n     static const valtype vchFalse(0);\n-    static const valtype vchZero(0);\n+    // static const valtype vchZero(0);\n     static const valtype vchTrue(1, 1);\n \n     CScript::const_iterator pc = script.begin();\n@@ -1028,7 +1028,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n             }\n \n             // Size limits\n-            if (stack.size() + altstack.size() > 1000)\n+            if (stack.size() + altstack.size() > MAX_STACK_SIZE)\n                 return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n         }\n     }\n@@ -1142,24 +1142,24 @@ class CTransactionSignatureSerializer {\n \n uint256 GetPrevoutHash(const CTransaction& txTo) {\n     CHashWriter ss(SER_GETHASH, 0);\n-    for (unsigned int n = 0; n < txTo.vin.size(); n++) {\n-        ss << txTo.vin[n].prevout;\n+    for (const auto& txin : txTo.vin) {\n+        ss << txin.prevout;\n     }\n     return ss.GetHash();\n }\n \n uint256 GetSequenceHash(const CTransaction& txTo) {\n     CHashWriter ss(SER_GETHASH, 0);\n-    for (unsigned int n = 0; n < txTo.vin.size(); n++) {\n-        ss << txTo.vin[n].nSequence;\n+    for (const auto& txin : txTo.vin) {\n+        ss << txin.nSequence;\n     }\n     return ss.GetHash();\n }\n \n uint256 GetOutputsHash(const CTransaction& txTo) {\n     CHashWriter ss(SER_GETHASH, 0);\n-    for (unsigned int n = 0; n < txTo.vout.size(); n++) {\n-        ss << txTo.vout[n];\n+    for (const auto& txout : txTo.vout) {\n+        ss << txout;\n     }\n     return ss.GetHash();\n }"
      },
      {
        "sha": "95a5999a13b538be8d87a984b2c60ec608399a8c",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -30,6 +30,9 @@ static const int MAX_PUBKEYS_PER_MULTISIG = 20;\n // Maximum script length in bytes\n static const int MAX_SCRIPT_SIZE = 10000;\n \n+// Maximum number of values on script interpreter stack\n+static const int MAX_STACK_SIZE = 1000;\n+\n // Threshold for nLockTime: below this value it is interpreted as block number,\n // otherwise as UNIX timestamp.\n static const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov  5 00:53:20 1985 UTC"
      },
      {
        "sha": "8dc5a19ead4b5531566e0210dcdaa6ff2837cd00",
        "filename": "src/streams.h",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/streams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/streams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/streams.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -248,7 +248,8 @@ class CDataStream\n \n     void insert(iterator it, std::vector<char>::const_iterator first, std::vector<char>::const_iterator last)\n     {\n-        assert(last - first >= 0);\n+        if (last == first) return;\n+        assert(last - first > 0);\n         if (it == vch.begin() + nReadPos && (unsigned int)(last - first) <= nReadPos)\n         {\n             // special case for inserting at the front when there's room\n@@ -261,7 +262,8 @@ class CDataStream\n \n     void insert(iterator it, const char* first, const char* last)\n     {\n-        assert(last - first >= 0);\n+        if (last == first) return;\n+        assert(last - first > 0);\n         if (it == vch.begin() + nReadPos && (unsigned int)(last - first) <= nReadPos)\n         {\n             // special case for inserting at the front when there's room\n@@ -339,6 +341,8 @@ class CDataStream\n \n     void read(char* pch, size_t nSize)\n     {\n+        if (nSize == 0) return;\n+\n         // Read from the beginning of the buffer\n         unsigned int nReadPosNext = nReadPos + nSize;\n         if (nReadPosNext >= vch.size())"
      },
      {
        "sha": "f020216c7300a6a7894da8157cc2ffe87b3f62a3",
        "filename": "src/support/cleanse.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/support/cleanse.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/support/cleanse.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/cleanse.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -8,6 +8,7 @@\n \n #include <stdlib.h>\n \n+// Attempt to overwrite data in the specified memory span.\n void memory_cleanse(void *ptr, size_t len);\n \n #endif // BITCOIN_SUPPORT_CLEANSE_H"
      },
      {
        "sha": "dc5372a07043988aeb3b4b611bf7c99fc1551587",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 110,
        "deletions": 100,
        "changes": 210,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -84,36 +84,47 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    // Test 1: Does Addrman respond correctly when empty.\n-    BOOST_CHECK(addrman.size() == 0);\n+    // Test: Does Addrman respond correctly when empty.\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n     CAddrInfo addr_null = addrman.Select();\n-    BOOST_CHECK(addr_null.ToString() == \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addr_null.ToString(), \"[::]:0\");\n \n-    // Test 2: Does Addrman::Add work as expected.\n+    // Test: Does Addrman::Add work as expected.\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n-    addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK(addrman.Add(CAddress(addr1, NODE_NONE), source));\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n     CAddrInfo addr_ret1 = addrman.Select();\n-    BOOST_CHECK(addr_ret1.ToString() == \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addr_ret1.ToString(), \"250.1.1.1:8333\");\n \n-    // Test 3: Does IP address deduplication work correctly.\n+    // Test: Does IP address deduplication work correctly.\n     //  Expected dup IP should not be added.\n     CService addr1_dup = ResolveService(\"250.1.1.1\", 8333);\n-    addrman.Add(CAddress(addr1_dup, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK(!addrman.Add(CAddress(addr1_dup, NODE_NONE), source));\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n+\n \n+    // Test: New table has one addr and we add a diff addr we should\n+    //  have at least one addr.\n+    // Note that addrman's size cannot be tested reliably after insertion, as\n+    // hash collisions may occur. But we can always be sure of at least one\n+    // success.\n \n-    // Test 5: New table has one addr and we add a diff addr we should\n-    //  have two addrs.\n     CService addr2 = ResolveService(\"250.1.1.2\", 8333);\n-    addrman.Add(CAddress(addr2, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 2);\n+    BOOST_CHECK(addrman.Add(CAddress(addr2, NODE_NONE), source));\n+    BOOST_CHECK(addrman.size() >= 1);\n \n-    // Test 6: AddrMan::Clear() should empty the new table.\n+    // Test: AddrMan::Clear() should empty the new table.\n     addrman.Clear();\n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n     CAddrInfo addr_null2 = addrman.Select();\n-    BOOST_CHECK(addr_null2.ToString() == \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addr_null2.ToString(), \"[::]:0\");\n+\n+    // Test: AddrMan::Add multiple addresses works as expected\n+    std::vector<CAddress> vAddr;\n+    vAddr.push_back(CAddress(ResolveService(\"250.1.1.3\", 8333), NODE_NONE));\n+    vAddr.push_back(CAddress(ResolveService(\"250.1.1.4\", 8333), NODE_NONE));\n+    BOOST_CHECK(addrman.Add(vAddr, source));\n+    BOOST_CHECK(addrman.size() >= 1);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_ports)\n@@ -125,26 +136,26 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     // Test 7; Addr with same IP but diff port does not replace existing addr.\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n \n     CService addr1_port = ResolveService(\"250.1.1.1\", 8334);\n     addrman.Add(CAddress(addr1_port, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n     CAddrInfo addr_ret2 = addrman.Select();\n-    BOOST_CHECK(addr_ret2.ToString() == \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addr_ret2.ToString(), \"250.1.1.1:8333\");\n \n-    // Test 8: Add same IP but diff port to tried table, it doesn't get added.\n+    // Test: Add same IP but diff port to tried table, it doesn't get added.\n     //  Perhaps this is not ideal behavior but it is the current behavior.\n     addrman.Good(CAddress(addr1_port, NODE_NONE));\n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n     bool newOnly = true;\n     CAddrInfo addr_ret3 = addrman.Select(newOnly);\n-    BOOST_CHECK(addr_ret3.ToString() == \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addr_ret3.ToString(), \"250.1.1.1:8333\");\n }\n \n \n@@ -157,25 +168,25 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    // Test 9: Select from new with 1 addr in new.\n+    // Test: Select from new with 1 addr in new.\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n \n     bool newOnly = true;\n     CAddrInfo addr_ret1 = addrman.Select(newOnly);\n-    BOOST_CHECK(addr_ret1.ToString() == \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addr_ret1.ToString(), \"250.1.1.1:8333\");\n \n-    // Test 10: move addr to tried, select from new expected nothing returned.\n+    // Test: move addr to tried, select from new expected nothing returned.\n     addrman.Good(CAddress(addr1, NODE_NONE));\n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n     CAddrInfo addr_ret2 = addrman.Select(newOnly);\n-    BOOST_CHECK(addr_ret2.ToString() == \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addr_ret2.ToString(), \"[::]:0\");\n \n     CAddrInfo addr_ret3 = addrman.Select();\n-    BOOST_CHECK(addr_ret3.ToString() == \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addr_ret3.ToString(), \"250.1.1.1:8333\");\n \n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n \n \n     // Add three addresses to new table.\n@@ -199,14 +210,15 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     addrman.Add(CAddress(addr7, NODE_NONE), ResolveService(\"250.1.1.3\", 8333));\n     addrman.Good(CAddress(addr7, NODE_NONE));\n \n-    // Test 11: 6 addrs + 1 addr from last test = 7.\n-    BOOST_CHECK(addrman.size() == 7);\n+    // Test: 6 addrs + 1 addr from last test = 7.\n+    BOOST_CHECK_EQUAL(addrman.size(), 7);\n \n-    // Test 12: Select pulls from new and tried regardless of port number.\n-    BOOST_CHECK(addrman.Select().ToString() == \"250.4.6.6:8333\");\n-    BOOST_CHECK(addrman.Select().ToString() == \"250.3.2.2:9999\");\n-    BOOST_CHECK(addrman.Select().ToString() == \"250.3.3.3:9999\");\n-    BOOST_CHECK(addrman.Select().ToString() == \"250.4.4.4:8333\");\n+    // Test: Select pulls from new and tried regardless of port number.\n+    std::set<uint16_t> ports;\n+    for (int i = 0; i < 20; ++i) {\n+        ports.insert(addrman.Select().GetPort());\n+    }\n+    BOOST_CHECK_EQUAL(ports.size(), 3);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n@@ -218,24 +230,24 @@ BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     for (unsigned int i = 1; i < 18; i++) {\n         CService addr = ResolveService(\"250.1.1.\" + boost::to_string(i));\n         addrman.Add(CAddress(addr, NODE_NONE), source);\n \n-        //Test 13: No collision in new table yet.\n-        BOOST_CHECK(addrman.size() == i);\n+        //Test: No collision in new table yet.\n+        BOOST_CHECK_EQUAL(addrman.size(), i);\n     }\n \n-    //Test 14: new table collision!\n+    //Test: new table collision!\n     CService addr1 = ResolveService(\"250.1.1.18\");\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 17);\n+    BOOST_CHECK_EQUAL(addrman.size(), 17);\n \n     CService addr2 = ResolveService(\"250.1.1.19\");\n     addrman.Add(CAddress(addr2, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 18);\n+    BOOST_CHECK_EQUAL(addrman.size(), 18);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n@@ -247,25 +259,25 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     for (unsigned int i = 1; i < 80; i++) {\n         CService addr = ResolveService(\"250.1.1.\" + boost::to_string(i));\n         addrman.Add(CAddress(addr, NODE_NONE), source);\n         addrman.Good(CAddress(addr, NODE_NONE));\n \n-        //Test 15: No collision in tried table yet.\n+        //Test: No collision in tried table yet.\n         BOOST_CHECK_EQUAL(addrman.size(), i);\n     }\n \n-    //Test 16: tried table collision!\n+    //Test: tried table collision!\n     CService addr1 = ResolveService(\"250.1.1.80\");\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 79);\n+    BOOST_CHECK_EQUAL(addrman.size(), 79);\n \n     CService addr2 = ResolveService(\"250.1.1.81\");\n     addrman.Add(CAddress(addr2, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 80);\n+    BOOST_CHECK_EQUAL(addrman.size(), 80);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_find)\n@@ -275,7 +287,7 @@ BOOST_AUTO_TEST_CASE(addrman_find)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.2.1\", 9999), NODE_NONE);\n@@ -288,23 +300,20 @@ BOOST_AUTO_TEST_CASE(addrman_find)\n     addrman.Add(addr2, source2);\n     addrman.Add(addr3, source1);\n \n-    // Test 17: ensure Find returns an IP matching what we searched on.\n+    // Test: ensure Find returns an IP matching what we searched on.\n     CAddrInfo* info1 = addrman.Find(addr1);\n-    BOOST_CHECK(info1);\n-    if (info1)\n-        BOOST_CHECK(info1->ToString() == \"250.1.2.1:8333\");\n+    BOOST_REQUIRE(info1);\n+    BOOST_CHECK_EQUAL(info1->ToString(), \"250.1.2.1:8333\");\n \n     // Test 18; Find does not discriminate by port number.\n     CAddrInfo* info2 = addrman.Find(addr2);\n-    BOOST_CHECK(info2);\n-    if (info2 && info1)\n-        BOOST_CHECK(info2->ToString() == info1->ToString());\n+    BOOST_REQUIRE(info2);\n+    BOOST_CHECK_EQUAL(info2->ToString(), info1->ToString());\n \n-    // Test 19: Find returns another IP matching what we searched on.\n+    // Test: Find returns another IP matching what we searched on.\n     CAddrInfo* info3 = addrman.Find(addr3);\n-    BOOST_CHECK(info3);\n-    if (info3)\n-        BOOST_CHECK(info3->ToString() == \"251.255.2.1:8333\");\n+    BOOST_REQUIRE(info3);\n+    BOOST_CHECK_EQUAL(info3->ToString(), \"251.255.2.1:8333\");\n }\n \n BOOST_AUTO_TEST_CASE(addrman_create)\n@@ -314,19 +323,19 @@ BOOST_AUTO_TEST_CASE(addrman_create)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n     int nId;\n     CAddrInfo* pinfo = addrman.Create(addr1, source1, &nId);\n \n-    // Test 20: The result should be the same as the input addr.\n-    BOOST_CHECK(pinfo->ToString() == \"250.1.2.1:8333\");\n+    // Test: The result should be the same as the input addr.\n+    BOOST_CHECK_EQUAL(pinfo->ToString(), \"250.1.2.1:8333\");\n \n     CAddrInfo* info2 = addrman.Find(addr1);\n-    BOOST_CHECK(info2->ToString() == \"250.1.2.1:8333\");\n+    BOOST_CHECK_EQUAL(info2->ToString(), \"250.1.2.1:8333\");\n }\n \n \n@@ -337,18 +346,18 @@ BOOST_AUTO_TEST_CASE(addrman_delete)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n     int nId;\n     addrman.Create(addr1, source1, &nId);\n \n-    // Test 21: Delete should actually delete the addr.\n-    BOOST_CHECK(addrman.size() == 1);\n+    // Test: Delete should actually delete the addr.\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n     addrman.Delete(nId);\n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n     CAddrInfo* info2 = addrman.Find(addr1);\n     BOOST_CHECK(info2 == NULL);\n }\n@@ -360,11 +369,11 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    // Test 22: Sanity check, GetAddr should never return anything if addrman\n+    // Test: Sanity check, GetAddr should never return anything if addrman\n     //  is empty.\n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n     std::vector<CAddress> vAddr1 = addrman.GetAddr();\n-    BOOST_CHECK(vAddr1.size() == 0);\n+    BOOST_CHECK_EQUAL(vAddr1.size(), 0);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.250.2.1\", 8333), NODE_NONE);\n     addr1.nTime = GetAdjustedTime(); // Set time so isTerrible = false\n@@ -379,29 +388,28 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n     CNetAddr source2 = ResolveIP(\"250.2.3.3\");\n \n-    // Test 23: Ensure GetAddr works with new addresses.\n+    // Test: Ensure GetAddr works with new addresses.\n     addrman.Add(addr1, source1);\n     addrman.Add(addr2, source2);\n     addrman.Add(addr3, source1);\n     addrman.Add(addr4, source2);\n     addrman.Add(addr5, source1);\n \n     // GetAddr returns 23% of addresses, 23% of 5 is 1 rounded down.\n-    BOOST_CHECK(addrman.GetAddr().size() == 1); \n+    BOOST_CHECK_EQUAL(addrman.GetAddr().size(), 1);\n \n-    // Test 24: Ensure GetAddr works with new and tried addresses.\n+    // Test: Ensure GetAddr works with new and tried addresses.\n     addrman.Good(CAddress(addr1, NODE_NONE));\n     addrman.Good(CAddress(addr2, NODE_NONE));\n-    BOOST_CHECK(addrman.GetAddr().size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.GetAddr().size(), 1);\n \n-    // Test 25: Ensure GetAddr still returns 23% when addrman has many addrs.\n+    // Test: Ensure GetAddr still returns 23% when addrman has many addrs.\n     for (unsigned int i = 1; i < (8 * 256); i++) {\n         int octet1 = i % 256;\n-        int octet2 = (i / 256) % 256;\n-        int octet3 = (i / (256 * 2)) % 256;\n-        std::string strAddr = boost::to_string(octet1) + \".\" + boost::to_string(octet2) + \".\" + boost::to_string(octet3) + \".23\";\n+        int octet2 = i >> 8 % 256;\n+        std::string strAddr = boost::to_string(octet1) + \".\" + boost::to_string(octet2) + \".1.23\";\n         CAddress addr = CAddress(ResolveService(strAddr), NODE_NONE);\n-        \n+\n         // Ensure that for all addrs in addrman, isTerrible == false.\n         addr.nTime = GetAdjustedTime();\n         addrman.Add(addr, ResolveIP(strAddr));\n@@ -411,10 +419,10 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     std::vector<CAddress> vAddr = addrman.GetAddr();\n \n     size_t percent23 = (addrman.size() * 23) / 100;\n-    BOOST_CHECK(vAddr.size() == percent23);\n-    BOOST_CHECK(vAddr.size() == 461);\n+    BOOST_CHECK_EQUAL(vAddr.size(), percent23);\n+    BOOST_CHECK_EQUAL(vAddr.size(), 461);\n     // (Addrman.size() < number of addresses added) due to address collisions.\n-    BOOST_CHECK(addrman.size() == 2007);\n+    BOOST_CHECK_EQUAL(addrman.size(), 2006);\n }\n \n \n@@ -437,13 +445,13 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n \n \n-    BOOST_CHECK(info1.GetTriedBucket(nKey1) == 40);\n+    BOOST_CHECK_EQUAL(info1.GetTriedBucket(nKey1), 40);\n \n-    // Test 26: Make sure key actually randomizes bucket placement. A fail on\n+    // Test: Make sure key actually randomizes bucket placement. A fail on\n     //  this test could be a security issue.\n     BOOST_CHECK(info1.GetTriedBucket(nKey1) != info1.GetTriedBucket(nKey2));\n \n-    // Test 27: Two addresses with same IP but different ports can map to\n+    // Test: Two addresses with same IP but different ports can map to\n     //  different buckets because they have different keys.\n     CAddrInfo info2 = CAddrInfo(addr2, source1);\n \n@@ -458,9 +466,9 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n         int bucket = infoi.GetTriedBucket(nKey1);\n         buckets.insert(bucket);\n     }\n-    // Test 28: IP addresses in the same group (\\16 prefix for IPv4) should\n+    // Test: IP addresses in the same group (\\16 prefix for IPv4) should\n     //  never get more than 8 buckets\n-    BOOST_CHECK(buckets.size() == 8);\n+    BOOST_CHECK_EQUAL(buckets.size(), 8);\n \n     buckets.clear();\n     for (int j = 0; j < 255; j++) {\n@@ -470,9 +478,9 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n         int bucket = infoj.GetTriedBucket(nKey1);\n         buckets.insert(bucket);\n     }\n-    // Test 29: IP addresses in the different groups should map to more than\n+    // Test: IP addresses in the different groups should map to more than\n     //  8 buckets.\n-    BOOST_CHECK(buckets.size() == 160);\n+    BOOST_CHECK_EQUAL(buckets.size(), 160);\n }\n \n BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n@@ -492,16 +500,18 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n \n-    BOOST_CHECK(info1.GetNewBucket(nKey1) == 786);\n+    // Test: Make sure the buckets are what we expect\n+    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1), 786);\n+    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, source1), 786);\n \n-    // Test 30: Make sure key actually randomizes bucket placement. A fail on\n+    // Test: Make sure key actually randomizes bucket placement. A fail on\n     //  this test could be a security issue.\n     BOOST_CHECK(info1.GetNewBucket(nKey1) != info1.GetNewBucket(nKey2));\n \n-    // Test 31: Ports should not effect bucket placement in the addr\n+    // Test: Ports should not effect bucket placement in the addr\n     CAddrInfo info2 = CAddrInfo(addr2, source1);\n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n-    BOOST_CHECK(info1.GetNewBucket(nKey1) == info2.GetNewBucket(nKey1));\n+    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1), info2.GetNewBucket(nKey1));\n \n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n@@ -511,9 +521,9 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n         int bucket = infoi.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n     }\n-    // Test 32: IP addresses in the same group (\\16 prefix for IPv4) should\n+    // Test: IP addresses in the same group (\\16 prefix for IPv4) should\n     //  always map to the same bucket.\n-    BOOST_CHECK(buckets.size() == 1);\n+    BOOST_CHECK_EQUAL(buckets.size(), 1);\n \n     buckets.clear();\n     for (int j = 0; j < 4 * 255; j++) {\n@@ -524,7 +534,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n         int bucket = infoj.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n     }\n-    // Test 33: IP addresses in the same source groups should map to no more\n+    // Test: IP addresses in the same source groups should map to no more\n     //  than 64 buckets.\n     BOOST_CHECK(buckets.size() <= 64);\n \n@@ -536,7 +546,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n         int bucket = infoj.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n     }\n-    // Test 34: IP addresses in the different source groups should map to more\n+    // Test: IP addresses in the different source groups should map to more\n     //  than 64 buckets.\n     BOOST_CHECK(buckets.size() > 64);\n }"
      },
      {
        "sha": "952cf901f02bd3f5c3dfc9e7cf7f9acc7d25f9ba",
        "filename": "src/test/amount_tests.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 1,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/amount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/amount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/amount_tests.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -3,15 +3,23 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"amount.h\"\n+#include \"policy/feerate.h\"\n #include \"test/test_bitcoin.h\"\n \n #include <boost/test/unit_test.hpp>\n \n BOOST_FIXTURE_TEST_SUITE(amount_tests, BasicTestingSetup)\n \n+BOOST_AUTO_TEST_CASE(MoneyRangeTest)\n+{\n+    BOOST_CHECK_EQUAL(MoneyRange(CAmount(-1)), false);\n+    BOOST_CHECK_EQUAL(MoneyRange(MAX_MONEY + CAmount(1)), false);\n+    BOOST_CHECK_EQUAL(MoneyRange(CAmount(1)), true);\n+}\n+\n BOOST_AUTO_TEST_CASE(GetFeeTest)\n {\n-    CFeeRate feeRate;\n+    CFeeRate feeRate, altFeeRate;\n \n     feeRate = CFeeRate(0);\n     // Must always return 0\n@@ -53,6 +61,11 @@ BOOST_AUTO_TEST_CASE(GetFeeTest)\n     BOOST_CHECK_EQUAL(feeRate.GetFee(8), -1); // Special case: returns -1 instead of 0\n     BOOST_CHECK_EQUAL(feeRate.GetFee(9), -1);\n \n+    // check alternate constructor\n+    feeRate = CFeeRate(1000);\n+    altFeeRate = CFeeRate(feeRate);\n+    BOOST_CHECK_EQUAL(feeRate.GetFee(100), altFeeRate.GetFee(100));\n+\n     // Check full constructor\n     // default value\n     BOOST_CHECK(CFeeRate(CAmount(-1), 1000) == CFeeRate(-1));\n@@ -68,4 +81,28 @@ BOOST_AUTO_TEST_CASE(GetFeeTest)\n     CFeeRate(MAX_MONEY, std::numeric_limits<size_t>::max() >> 1).GetFeePerK();\n }\n \n+BOOST_AUTO_TEST_CASE(BinaryOperatorTest)\n+{\n+    CFeeRate a, b;\n+    a = CFeeRate(1);\n+    b = CFeeRate(2);\n+    BOOST_CHECK(a < b);\n+    BOOST_CHECK(b > a);\n+    BOOST_CHECK(a == a);\n+    BOOST_CHECK(a <= b);\n+    BOOST_CHECK(a <= a);\n+    BOOST_CHECK(b >= a);\n+    BOOST_CHECK(b >= b);\n+    // a should be 0.00000002 BTC/kB now\n+    a += a;\n+    BOOST_CHECK(a == b);\n+}\n+\n+BOOST_AUTO_TEST_CASE(ToStringTest)\n+{\n+    CFeeRate feeRate;\n+    feeRate = CFeeRate(1);\n+    BOOST_CHECK_EQUAL(feeRate.ToString(), \"0.00000001 BTC/kB\");\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "72e562808afebd5986686ad4f08b5693736c4bf7",
        "filename": "src/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 68,
        "deletions": 0,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/crypto_tests.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -3,12 +3,14 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"crypto/aes.h\"\n+#include \"crypto/chacha20.h\"\n #include \"crypto/ripemd160.h\"\n #include \"crypto/sha1.h\"\n #include \"crypto/sha256.h\"\n #include \"crypto/sha512.h\"\n #include \"crypto/hmac_sha256.h\"\n #include \"crypto/hmac_sha512.h\"\n+#include \"random.h\"\n #include \"utilstrencodings.h\"\n #include \"test/test_bitcoin.h\"\n #include \"test/test_random.h\"\n@@ -187,6 +189,19 @@ void TestAES256CBC(const std::string &hexkey, const std::string &hexiv, bool pad\n     }\n }\n \n+void TestChaCha20(const std::string &hexkey, uint64_t nonce, uint64_t seek, const std::string& hexout)\n+{\n+    std::vector<unsigned char> key = ParseHex(hexkey);\n+    ChaCha20 rng(key.data(), key.size());\n+    rng.SetIV(nonce);\n+    rng.Seek(seek);\n+    std::vector<unsigned char> out = ParseHex(hexout);\n+    std::vector<unsigned char> outres;\n+    outres.resize(out.size());\n+    rng.Output(outres.data(), outres.size());\n+    BOOST_CHECK(out == outres);\n+}\n+\n std::string LongTestString(void) {\n     std::string ret;\n     for (int i=0; i<200000; i++) {\n@@ -439,4 +454,57 @@ BOOST_AUTO_TEST_CASE(aes_cbc_testvectors) {\n                   \"b2eb05e2c39be9fcda6c19078c6a9d1b3f461796d6b0d6b2e0c2a72b4d80e644\");\n }\n \n+\n+BOOST_AUTO_TEST_CASE(chacha20_testvector)\n+{\n+    // Test vector from RFC 7539\n+    TestChaCha20(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\", 0x4a000000UL, 1,\n+                 \"224f51f3401bd9e12fde276fb8631ded8c131f823d2c06e27e4fcaec9ef3cf788a3b0aa372600a92b57974cded2b9334794cb\"\n+                 \"a40c63e34cdea212c4cf07d41b769a6749f3f630f4122cafe28ec4dc47e26d4346d70b98c73f3e9c53ac40c5945398b6eda1a\"\n+                 \"832c89c167eacd901d7e2bf363\");\n+\n+    // Test vectors from https://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-04#section-7\n+    TestChaCha20(\"0000000000000000000000000000000000000000000000000000000000000000\", 0, 0,\n+                 \"76b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8b770dc7da41597c5157488d7724e03fb8d84a376a43b\"\n+                 \"8f41518a11cc387b669b2ee6586\");\n+    TestChaCha20(\"0000000000000000000000000000000000000000000000000000000000000001\", 0, 0,\n+                 \"4540f05a9f1fb296d7736e7b208e3c96eb4fe1834688d2604f450952ed432d41bbe2a0b6ea7566d2a5d1e7e20d42af2c53d79\"\n+                 \"2b1c43fea817e9ad275ae546963\");\n+    TestChaCha20(\"0000000000000000000000000000000000000000000000000000000000000000\", 0x0100000000000000ULL, 0,\n+                 \"de9cba7bf3d69ef5e786dc63973f653a0b49e015adbff7134fcb7df137821031e85a050278a7084527214f73efc7fa5b52770\"\n+                 \"62eb7a0433e445f41e3\");\n+    TestChaCha20(\"0000000000000000000000000000000000000000000000000000000000000000\", 1, 0,\n+                 \"ef3fdfd6c61578fbf5cf35bd3dd33b8009631634d21e42ac33960bd138e50d32111e4caf237ee53ca8ad6426194a88545ddc4\"\n+                 \"97a0b466e7d6bbdb0041b2f586b\");\n+    TestChaCha20(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\", 0x0706050403020100ULL, 0,\n+                 \"f798a189f195e66982105ffb640bb7757f579da31602fc93ec01ac56f85ac3c134a4547b733b46413042c9440049176905d3b\"\n+                 \"e59ea1c53f15916155c2be8241a38008b9a26bc35941e2444177c8ade6689de95264986d95889fb60e84629c9bd9a5acb1cc1\"\n+                 \"18be563eb9b3a4a472f82e09a7e778492b562ef7130e88dfe031c79db9d4f7c7a899151b9a475032b63fc385245fe054e3dd5\"\n+                 \"a97a5f576fe064025d3ce042c566ab2c507b138db853e3d6959660996546cc9c4a6eafdc777c040d70eaf46f76dad3979e5c5\"\n+                 \"360c3317166a1c894c94a371876a94df7628fe4eaaf2ccb27d5aaae0ad7ad0f9d4b6ad3b54098746d4524d38407a6deb3ab78\"\n+                 \"fab78c9\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(countbits_tests)\n+{\n+    FastRandomContext ctx;\n+    for (int i = 0; i <= 64; ++i) {\n+        if (i == 0) {\n+            // Check handling of zero.\n+            BOOST_CHECK_EQUAL(CountBits(0), 0);\n+        } else if (i < 10) {\n+            for (uint64_t j = 1 << (i - 1); (j >> i) == 0; ++j) {\n+                // Exhaustively test up to 10 bits\n+                BOOST_CHECK_EQUAL(CountBits(j), i);\n+            }\n+        } else {\n+            for (int k = 0; k < 1000; k++) {\n+                // Randomly test 1000 samples of each length above 10 bits.\n+                uint64_t j = ((uint64_t)1) << (i - 1) | ctx.randbits(i - 1);\n+                BOOST_CHECK_EQUAL(CountBits(j), i);\n+            }\n+        }\n+    }\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "e35a7ce569c0e2abd18fd9e653d94562c2471ce2",
        "filename": "src/test/data/script_tests.json",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/data/script_tests.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/data/script_tests.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/script_tests.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -349,7 +349,7 @@\n [\"2147483647\", \"0x04 0xFFFFFF7F EQUAL\", \"P2SH,STRICTENC\", \"OK\"],\n [\"2147483648\", \"0x05 0x0000008000 EQUAL\", \"P2SH,STRICTENC\", \"OK\"],\n [\"549755813887\", \"0x05 0xFFFFFFFF7F EQUAL\", \"P2SH,STRICTENC\", \"OK\"],\n-[\"549755813888\", \"0x06 0xFFFFFFFF7F EQUAL\", \"P2SH,STRICTENC\", \"OK\"],\n+[\"549755813888\", \"0x06 0x000000008000 EQUAL\", \"P2SH,STRICTENC\", \"OK\"],\n [\"9223372036854775807\", \"0x08 0xFFFFFFFFFFFFFF7F EQUAL\", \"P2SH,STRICTENC\", \"OK\"],\n [\"-1\", \"0x01 0x81 EQUAL\", \"P2SH,STRICTENC\", \"OK\", \"Numbers are little-endian with the MSB being a sign bit\"],\n [\"-127\", \"0x01 0xFF EQUAL\", \"P2SH,STRICTENC\", \"OK\"],"
      },
      {
        "sha": "656aec606b6c2cc30a9211418960a3d1f186da85",
        "filename": "src/test/main_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/main_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/main_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/main_tests.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -39,17 +39,18 @@ static void TestBlockSubsidyHalvings(int nSubsidyHalvingInterval)\n \n BOOST_AUTO_TEST_CASE(block_subsidy_test)\n {\n-    TestBlockSubsidyHalvings(Params(CBaseChainParams::MAIN).GetConsensus()); // As in main\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n+    TestBlockSubsidyHalvings(chainParams->GetConsensus()); // As in main\n     TestBlockSubsidyHalvings(150); // As in regtest\n     TestBlockSubsidyHalvings(1000); // Just another interval\n }\n \n BOOST_AUTO_TEST_CASE(subsidy_limit_test)\n {\n-    const Consensus::Params& consensusParams = Params(CBaseChainParams::MAIN).GetConsensus();\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n     CAmount nSum = 0;\n     for (int nHeight = 0; nHeight < 14000000; nHeight += 1000) {\n-        CAmount nSubsidy = GetBlockSubsidy(nHeight, consensusParams);\n+        CAmount nSubsidy = GetBlockSubsidy(nHeight, chainParams->GetConsensus());\n         BOOST_CHECK(nSubsidy <= 50 * COIN);\n         nSum += nSubsidy * 1000;\n         BOOST_CHECK(MoneyRange(nSum));"
      },
      {
        "sha": "a40060e6579adb8d898a4e10bb01846787b981d0",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -6,6 +6,7 @@\n #include \"coins.h\"\n #include \"consensus/consensus.h\"\n #include \"consensus/merkle.h\"\n+#include \"consensus/tx_verify.h\"\n #include \"consensus/validation.h\"\n #include \"validation.h\"\n #include \"miner.h\"\n@@ -194,7 +195,8 @@ void TestPackageSelection(const CChainParams& chainparams, CScript scriptPubKey,\n BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n {\n     // Note that by default, these tests run with size accounting enabled.\n-    const CChainParams& chainparams = Params(CBaseChainParams::MAIN);\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n+    const CChainParams& chainparams = *chainParams;\n     CScript scriptPubKey = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n     std::unique_ptr<CBlockTemplate> pblocktemplate;\n     CMutableTransaction tx,tx2;"
      },
      {
        "sha": "0c7f3e5e2359697c4715cbe661413d249a298d41",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -11,6 +11,7 @@\n #include \"net.h\"\n #include \"netbase.h\"\n #include \"chainparams.h\"\n+#include \"util.h\"\n \n class CAddrManSerializationMock : public CAddrMan\n {\n@@ -72,6 +73,18 @@ CDataStream AddrmanToStream(CAddrManSerializationMock& _addrman)\n \n BOOST_FIXTURE_TEST_SUITE(net_tests, BasicTestingSetup)\n \n+BOOST_AUTO_TEST_CASE(cnode_listen_port)\n+{\n+    // test default\n+    unsigned short port = GetListenPort();\n+    BOOST_CHECK(port == Params().GetDefaultPort());\n+    // test set port\n+    unsigned short altPort = 12345;\n+    SoftSetArg(\"-port\", std::to_string(altPort));\n+    port = GetListenPort();\n+    BOOST_CHECK(port == altPort);\n+}\n+\n BOOST_AUTO_TEST_CASE(caddrdb_read)\n {\n     CAddrManUncorrupted addrmanUncorrupted;"
      },
      {
        "sha": "6bfd31564730233d800b244a2b93bd56bbdb6123",
        "filename": "src/test/policyestimator_tests.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 38,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/policyestimator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/policyestimator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/policyestimator_tests.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -16,7 +16,8 @@ BOOST_FIXTURE_TEST_SUITE(policyestimator_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n {\n-    CTxMemPool mpool;\n+    CBlockPolicyEstimator feeEst;\n+    CTxMemPool mpool(&feeEst);\n     TestMemPoolEntryHelper entry;\n     CAmount basefee(2000);\n     CAmount deltaFee(100);\n@@ -49,8 +50,8 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n     int blocknum = 0;\n \n     // Loop through 200 blocks\n-    // At a decay .998 and 4 fee transactions per block\n-    // This makes the tx count about 1.33 per bucket, above the 1 threshold\n+    // At a decay .9952 and 4 fee transactions per block\n+    // This makes the tx count about 2.5 per bucket, well above the 0.1 threshold\n     while (blocknum < 200) {\n         for (int j = 0; j < 10; j++) { // For each fee\n             for (int k = 0; k < 4; k++) { // add 4 fee txs\n@@ -74,20 +75,14 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n         }\n         mpool.removeForBlock(block, ++blocknum);\n         block.clear();\n-        if (blocknum == 30) {\n-            // At this point we should need to combine 5 buckets to get enough data points\n-            // So estimateFee(1,2,3) should fail and estimateFee(4) should return somewhere around\n-            // 8*baserate.  estimateFee(4) %'s are 100,100,100,100,90 = average 98%\n-            BOOST_CHECK(mpool.estimateFee(1) == CFeeRate(0));\n-            BOOST_CHECK(mpool.estimateFee(2) == CFeeRate(0));\n-            BOOST_CHECK(mpool.estimateFee(3) == CFeeRate(0));\n-            BOOST_CHECK(mpool.estimateFee(4).GetFeePerK() < 8*baseRate.GetFeePerK() + deltaFee);\n-            BOOST_CHECK(mpool.estimateFee(4).GetFeePerK() > 8*baseRate.GetFeePerK() - deltaFee);\n-            int answerFound;\n-            BOOST_CHECK(mpool.estimateSmartFee(1, &answerFound) == mpool.estimateFee(4) && answerFound == 4);\n-            BOOST_CHECK(mpool.estimateSmartFee(3, &answerFound) == mpool.estimateFee(4) && answerFound == 4);\n-            BOOST_CHECK(mpool.estimateSmartFee(4, &answerFound) == mpool.estimateFee(4) && answerFound == 4);\n-            BOOST_CHECK(mpool.estimateSmartFee(8, &answerFound) == mpool.estimateFee(8) && answerFound == 8);\n+        // Check after just a few txs that combining buckets works as expected\n+        if (blocknum == 3) {\n+            // At this point we should need to combine 3 buckets to get enough data points\n+            // So estimateFee(1) should fail and estimateFee(2) should return somewhere around\n+            // 9*baserate.  estimateFee(2) %'s are 100,100,90 = average 97%\n+            BOOST_CHECK(feeEst.estimateFee(1) == CFeeRate(0));\n+            BOOST_CHECK(feeEst.estimateFee(2).GetFeePerK() < 9*baseRate.GetFeePerK() + deltaFee);\n+            BOOST_CHECK(feeEst.estimateFee(2).GetFeePerK() > 9*baseRate.GetFeePerK() - deltaFee);\n         }\n     }\n \n@@ -99,29 +94,30 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n     // Second highest feerate has 100% chance of being included by 2 blocks,\n     // so estimateFee(2) should return 9*baseRate etc...\n     for (int i = 1; i < 10;i++) {\n-        origFeeEst.push_back(mpool.estimateFee(i).GetFeePerK());\n+        origFeeEst.push_back(feeEst.estimateFee(i).GetFeePerK());\n         if (i > 2) { // Fee estimates should be monotonically decreasing\n             BOOST_CHECK(origFeeEst[i-1] <= origFeeEst[i-2]);\n         }\n         int mult = 11-i;\n-        if (i > 1) {\n+        if (i % 2 == 0) { //At scale 2, test logic is only correct for even targets\n             BOOST_CHECK(origFeeEst[i-1] < mult*baseRate.GetFeePerK() + deltaFee);\n             BOOST_CHECK(origFeeEst[i-1] > mult*baseRate.GetFeePerK() - deltaFee);\n         }\n-        else {\n-            BOOST_CHECK(origFeeEst[i-1] == CFeeRate(0).GetFeePerK());\n-        }\n+    }\n+    // Fill out rest of the original estimates\n+    for (int i = 10; i <= 48; i++) {\n+        origFeeEst.push_back(feeEst.estimateFee(i).GetFeePerK());\n     }\n \n     // Mine 50 more blocks with no transactions happening, estimates shouldn't change\n     // We haven't decayed the moving average enough so we still have enough data points in every bucket\n     while (blocknum < 250)\n         mpool.removeForBlock(block, ++blocknum);\n \n-    BOOST_CHECK(mpool.estimateFee(1) == CFeeRate(0));\n+    BOOST_CHECK(feeEst.estimateFee(1) == CFeeRate(0));\n     for (int i = 2; i < 10;i++) {\n-        BOOST_CHECK(mpool.estimateFee(i).GetFeePerK() < origFeeEst[i-1] + deltaFee);\n-        BOOST_CHECK(mpool.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n+        BOOST_CHECK(feeEst.estimateFee(i).GetFeePerK() < origFeeEst[i-1] + deltaFee);\n+        BOOST_CHECK(feeEst.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n     }\n \n \n@@ -139,10 +135,8 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n         mpool.removeForBlock(block, ++blocknum);\n     }\n \n-    int answerFound;\n     for (int i = 1; i < 10;i++) {\n-        BOOST_CHECK(mpool.estimateFee(i) == CFeeRate(0) || mpool.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n-        BOOST_CHECK(mpool.estimateSmartFee(i, &answerFound).GetFeePerK() > origFeeEst[answerFound-1] - deltaFee);\n+        BOOST_CHECK(feeEst.estimateFee(i) == CFeeRate(0) || feeEst.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n     }\n \n     // Mine all those transactions\n@@ -155,16 +149,16 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n             txHashes[j].pop_back();\n         }\n     }\n-    mpool.removeForBlock(block, 265);\n+    mpool.removeForBlock(block, 266);\n     block.clear();\n-    BOOST_CHECK(mpool.estimateFee(1) == CFeeRate(0));\n+    BOOST_CHECK(feeEst.estimateFee(1) == CFeeRate(0));\n     for (int i = 2; i < 10;i++) {\n-        BOOST_CHECK(mpool.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n+        BOOST_CHECK(feeEst.estimateFee(i) == CFeeRate(0) || feeEst.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n     }\n \n-    // Mine 200 more blocks where everything is mined every block\n+    // Mine 400 more blocks where everything is mined every block\n     // Estimates should be below original estimates\n-    while (blocknum < 465) {\n+    while (blocknum < 665) {\n         for (int j = 0; j < 10; j++) { // For each fee multiple\n             for (int k = 0; k < 4; k++) { // add 4 fee txs\n                 tx.vin[0].prevout.n = 10000*blocknum+100*j+k;\n@@ -179,9 +173,9 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n         mpool.removeForBlock(block, ++blocknum);\n         block.clear();\n     }\n-    BOOST_CHECK(mpool.estimateFee(1) == CFeeRate(0));\n-    for (int i = 2; i < 10; i++) {\n-        BOOST_CHECK(mpool.estimateFee(i).GetFeePerK() < origFeeEst[i-1] - deltaFee);\n+    BOOST_CHECK(feeEst.estimateFee(1) == CFeeRate(0));\n+    for (int i = 2; i < 9; i++) { // At 9, the original estimate was already at the bottom (b/c scale = 2)\n+        BOOST_CHECK(feeEst.estimateFee(i).GetFeePerK() < origFeeEst[i-1] - deltaFee);\n     }\n \n     // Test that if the mempool is limited, estimateSmartFee won't return a value below the mempool min fee\n@@ -190,8 +184,8 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n     mpool.TrimToSize(1);\n     BOOST_CHECK(mpool.GetMinFee(1).GetFeePerK() > feeV[5]);\n     for (int i = 1; i < 10; i++) {\n-        BOOST_CHECK(mpool.estimateSmartFee(i).GetFeePerK() >= mpool.estimateFee(i).GetFeePerK());\n-        BOOST_CHECK(mpool.estimateSmartFee(i).GetFeePerK() >= mpool.GetMinFee(1).GetFeePerK());\n+        BOOST_CHECK(feeEst.estimateSmartFee(i, NULL, mpool).GetFeePerK() >= feeEst.estimateRawFee(i, 0.85, FeeEstimateHorizon::MED_HALFLIFE).GetFeePerK());\n+        BOOST_CHECK(feeEst.estimateSmartFee(i, NULL, mpool).GetFeePerK() >= mpool.GetMinFee(1).GetFeePerK());\n     }\n }\n "
      },
      {
        "sha": "3b79f8000d3419c41a6736d6c1cf6b1f5086b37e",
        "filename": "src/test/pow_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 21,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/pow_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/pow_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/pow_tests.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -16,69 +16,59 @@ BOOST_FIXTURE_TEST_SUITE(pow_tests, BasicTestingSetup)\n /* Test calculation of next difficulty target with no constraints applying */\n BOOST_AUTO_TEST_CASE(get_next_work)\n {\n-    SelectParams(CBaseChainParams::MAIN);\n-    const Consensus::Params& params = Params().GetConsensus();\n-\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n     int64_t nLastRetargetTime = 1261130161; // Block #30240\n     CBlockIndex pindexLast;\n     pindexLast.nHeight = 32255;\n     pindexLast.nTime = 1262152739;  // Block #32255\n     pindexLast.nBits = 0x1d00ffff;\n-    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, params), 0x1d00d86a);\n+    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1d00d86a);\n }\n \n /* Test the constraint on the upper bound for next work */\n BOOST_AUTO_TEST_CASE(get_next_work_pow_limit)\n {\n-    SelectParams(CBaseChainParams::MAIN);\n-    const Consensus::Params& params = Params().GetConsensus();\n-\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n     int64_t nLastRetargetTime = 1231006505; // Block #0\n     CBlockIndex pindexLast;\n     pindexLast.nHeight = 2015;\n     pindexLast.nTime = 1233061996;  // Block #2015\n     pindexLast.nBits = 0x1d00ffff;\n-    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, params), 0x1d00ffff);\n+    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1d00ffff);\n }\n \n /* Test the constraint on the lower bound for actual time taken */\n BOOST_AUTO_TEST_CASE(get_next_work_lower_limit_actual)\n {\n-    SelectParams(CBaseChainParams::MAIN);\n-    const Consensus::Params& params = Params().GetConsensus();\n-\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n     int64_t nLastRetargetTime = 1279008237; // Block #66528\n     CBlockIndex pindexLast;\n     pindexLast.nHeight = 68543;\n     pindexLast.nTime = 1279297671;  // Block #68543\n     pindexLast.nBits = 0x1c05a3f4;\n-    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, params), 0x1c0168fd);\n+    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1c0168fd);\n }\n \n /* Test the constraint on the upper bound for actual time taken */\n BOOST_AUTO_TEST_CASE(get_next_work_upper_limit_actual)\n {\n-    SelectParams(CBaseChainParams::MAIN);\n-    const Consensus::Params& params = Params().GetConsensus();\n-\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n     int64_t nLastRetargetTime = 1263163443; // NOTE: Not an actual block time\n     CBlockIndex pindexLast;\n     pindexLast.nHeight = 46367;\n     pindexLast.nTime = 1269211443;  // Block #46367\n     pindexLast.nBits = 0x1c387f6f;\n-    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, params), 0x1d00e1fd);\n+    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1d00e1fd);\n }\n \n BOOST_AUTO_TEST_CASE(GetBlockProofEquivalentTime_test)\n {\n-    SelectParams(CBaseChainParams::MAIN);\n-    const Consensus::Params& params = Params().GetConsensus();\n-\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n     std::vector<CBlockIndex> blocks(10000);\n     for (int i = 0; i < 10000; i++) {\n         blocks[i].pprev = i ? &blocks[i - 1] : NULL;\n         blocks[i].nHeight = i;\n-        blocks[i].nTime = 1269211443 + i * params.nPowTargetSpacing;\n+        blocks[i].nTime = 1269211443 + i * chainParams->GetConsensus().nPowTargetSpacing;\n         blocks[i].nBits = 0x207fffff; /* target 0x7fffff000... */\n         blocks[i].nChainWork = i ? blocks[i - 1].nChainWork + GetBlockProof(blocks[i - 1]) : arith_uint256(0);\n     }\n@@ -88,7 +78,7 @@ BOOST_AUTO_TEST_CASE(GetBlockProofEquivalentTime_test)\n         CBlockIndex *p2 = &blocks[GetRand(10000)];\n         CBlockIndex *p3 = &blocks[GetRand(10000)];\n \n-        int64_t tdiff = GetBlockProofEquivalentTime(*p1, *p2, *p3, params);\n+        int64_t tdiff = GetBlockProofEquivalentTime(*p1, *p2, *p3, chainParams->GetConsensus());\n         BOOST_CHECK_EQUAL(tdiff, p1->GetBlockTime() - p2->GetBlockTime());\n     }\n }"
      },
      {
        "sha": "cfed5e347edfd14baad673835406448c52ca3f06",
        "filename": "src/test/prevector_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/prevector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/prevector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/prevector_tests.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -28,6 +28,7 @@ class prevector_tester {\n     typedef typename pretype::size_type Size;\n     bool passed = true;\n     FastRandomContext rand_cache;\n+    uint256 rand_seed;\n \n \n     template <typename A, typename B>\n@@ -183,13 +184,12 @@ class prevector_tester {\n     }\n \n     ~prevector_tester() {\n-        BOOST_CHECK_MESSAGE(passed, \"insecure_rand_Rz: \"\n-                << rand_cache.Rz\n-                << \", insecure_rand_Rw: \"\n-                << rand_cache.Rw);\n+        BOOST_CHECK_MESSAGE(passed, \"insecure_rand: \" + rand_seed.ToString());\n     }\n+\n     prevector_tester() {\n         seed_insecure_rand();\n+        rand_seed = insecure_rand_seed;\n         rand_cache = insecure_rand_ctx;\n     }\n };"
      },
      {
        "sha": "85967342263a433d6ab411de16ae455840aac7eb",
        "filename": "src/test/random_tests.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 1,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/random_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/random_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/random_tests.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -15,5 +15,39 @@ BOOST_AUTO_TEST_CASE(osrandom_tests)\n     BOOST_CHECK(Random_SanityCheck());\n }\n \n-BOOST_AUTO_TEST_SUITE_END()\n+BOOST_AUTO_TEST_CASE(fastrandom_tests)\n+{\n+    // Check that deterministic FastRandomContexts are deterministic\n+    FastRandomContext ctx1(true);\n+    FastRandomContext ctx2(true);\n+\n+    BOOST_CHECK_EQUAL(ctx1.rand32(), ctx2.rand32());\n+    BOOST_CHECK_EQUAL(ctx1.rand32(), ctx2.rand32());\n+    BOOST_CHECK_EQUAL(ctx1.rand64(), ctx2.rand64());\n+    BOOST_CHECK_EQUAL(ctx1.randbits(3), ctx2.randbits(3));\n+    BOOST_CHECK_EQUAL(ctx1.randbits(7), ctx2.randbits(7));\n+    BOOST_CHECK_EQUAL(ctx1.rand32(), ctx2.rand32());\n+    BOOST_CHECK_EQUAL(ctx1.randbits(3), ctx2.randbits(3));\n+\n+    // Check that a nondeterministic ones are not\n+    FastRandomContext ctx3;\n+    FastRandomContext ctx4;\n+    BOOST_CHECK(ctx3.rand64() != ctx4.rand64()); // extremely unlikely to be equal\n+}\n \n+BOOST_AUTO_TEST_CASE(fastrandom_randbits)\n+{\n+    FastRandomContext ctx1;\n+    FastRandomContext ctx2;\n+    for (int bits = 0; bits < 63; ++bits) {\n+        for (int j = 0; j < 1000; ++j) {\n+            uint64_t rangebits = ctx1.randbits(bits);\n+            BOOST_CHECK_EQUAL(rangebits >> bits, 0);\n+            uint64_t range = ((uint64_t)1) << bits | rangebits;\n+            uint64_t rand = ctx2.randrange(range);\n+            BOOST_CHECK(rand < range);\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "ede68f23d796b0379cc1bc1fdaa2e4cb24eb1ba6",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include \"consensus/tx_verify.h\"\n #include \"core_io.h\"\n #include \"key.h\"\n #include \"keystore.h\""
      },
      {
        "sha": "2f7c22084e03eab5dc499ab9a4db80d8787e1a68",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,10 +2,10 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include \"consensus/tx_verify.h\"\n #include \"consensus/validation.h\"\n #include \"data/sighash.json.h\"\n #include \"hash.h\"\n-#include \"validation.h\" // For CheckTransaction\n #include \"script/interpreter.h\"\n #include \"script/script.h\"\n #include \"serialize.h\""
      },
      {
        "sha": "92781d763dfebe76d65627fd9c08091c8f53a5e9",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,7 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"validation.h\"\n+#include \"consensus/tx_verify.h\"\n #include \"pubkey.h\"\n #include \"key.h\"\n #include \"script/script.h\""
      },
      {
        "sha": "cb625bda11a076d110d1e8db3438d9e36a4885a7",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -27,7 +27,8 @@\n \n #include <boost/thread.hpp>\n \n-FastRandomContext insecure_rand_ctx(true);\n+uint256 insecure_rand_seed = GetRandHash();\n+FastRandomContext insecure_rand_ctx(insecure_rand_seed);\n \n extern bool fPrintToConsole;\n extern void noui_connect();"
      },
      {
        "sha": "e11e46bb022fe92f9b08d4215bedd9ce00cadab9",
        "filename": "src/test/test_bitcoin_fuzzy.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 2,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/test_bitcoin_fuzzy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/test_bitcoin_fuzzy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin_fuzzy.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -59,9 +59,8 @@ bool read_stdin(std::vector<char> &data) {\n     return length==0;\n }\n \n-int main(int argc, char **argv)\n+int do_fuzz()\n {\n-    ECCVerifyHandle globalVerifyHandle;\n     std::vector<char> buffer;\n     if (!read_stdin(buffer)) return 0;\n \n@@ -256,3 +255,23 @@ int main(int argc, char **argv)\n     return 0;\n }\n \n+int main(int argc, char **argv)\n+{\n+    ECCVerifyHandle globalVerifyHandle;\n+#ifdef __AFL_INIT\n+    // Enable AFL deferred forkserver mode. Requires compilation using\n+    // afl-clang-fast++. See fuzzing.md for details.\n+    __AFL_INIT();\n+#endif\n+\n+#ifdef __AFL_LOOP\n+    // Enable AFL persistent mode. Requires compilation using afl-clang-fast++.\n+    // See fuzzing.md for details.\n+    while (__AFL_LOOP(1000)) {\n+        do_fuzz();\n+    }\n+    return 0;\n+#else\n+    return do_fuzz();\n+#endif\n+}"
      },
      {
        "sha": "318c44df4dc8048f5df3a30716a8d109c26c69e0",
        "filename": "src/test/test_random.h",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/test_random.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/test_random.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_random.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -8,11 +8,17 @@\n \n #include \"random.h\"\n \n+extern uint256 insecure_rand_seed;\n extern FastRandomContext insecure_rand_ctx;\n \n static inline void seed_insecure_rand(bool fDeterministic = false)\n {\n-    insecure_rand_ctx = FastRandomContext(fDeterministic);\n+    if (fDeterministic) {\n+        insecure_rand_seed = uint256();\n+    } else {\n+        insecure_rand_seed = GetRandHash();\n+    }\n+    insecure_rand_ctx = FastRandomContext(insecure_rand_seed);\n }\n \n static inline uint32_t insecure_rand(void)"
      },
      {
        "sha": "b7affaacde585dae3c395359ecc30364ea88a40f",
        "filename": "src/test/torcontrol_tests.cpp",
        "status": "added",
        "additions": 199,
        "deletions": 0,
        "changes": 199,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/torcontrol_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/torcontrol_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/torcontrol_tests.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2017 The Zcash developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+//\n+#include \"test/test_bitcoin.h\"\n+#include \"torcontrol.cpp\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+\n+BOOST_FIXTURE_TEST_SUITE(torcontrol_tests, BasicTestingSetup)\n+\n+void CheckSplitTorReplyLine(std::string input, std::string command, std::string args)\n+{\n+    BOOST_TEST_MESSAGE(std::string(\"CheckSplitTorReplyLine(\") + input + \")\");\n+    auto ret = SplitTorReplyLine(input);\n+    BOOST_CHECK_EQUAL(ret.first, command);\n+    BOOST_CHECK_EQUAL(ret.second, args);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_SplitTorReplyLine)\n+{\n+    // Data we should receive during normal usage\n+    CheckSplitTorReplyLine(\n+        \"PROTOCOLINFO PIVERSION\",\n+        \"PROTOCOLINFO\", \"PIVERSION\");\n+    CheckSplitTorReplyLine(\n+        \"AUTH METHODS=COOKIE,SAFECOOKIE COOKIEFILE=\\\"/home/x/.tor/control_auth_cookie\\\"\",\n+        \"AUTH\", \"METHODS=COOKIE,SAFECOOKIE COOKIEFILE=\\\"/home/x/.tor/control_auth_cookie\\\"\");\n+    CheckSplitTorReplyLine(\n+        \"AUTH METHODS=NULL\",\n+        \"AUTH\", \"METHODS=NULL\");\n+    CheckSplitTorReplyLine(\n+        \"AUTH METHODS=HASHEDPASSWORD\",\n+        \"AUTH\", \"METHODS=HASHEDPASSWORD\");\n+    CheckSplitTorReplyLine(\n+        \"VERSION Tor=\\\"0.2.9.8 (git-a0df013ea241b026)\\\"\",\n+        \"VERSION\", \"Tor=\\\"0.2.9.8 (git-a0df013ea241b026)\\\"\");\n+    CheckSplitTorReplyLine(\n+        \"AUTHCHALLENGE SERVERHASH=aaaa SERVERNONCE=bbbb\",\n+        \"AUTHCHALLENGE\", \"SERVERHASH=aaaa SERVERNONCE=bbbb\");\n+\n+    // Other valid inputs\n+    CheckSplitTorReplyLine(\"COMMAND\", \"COMMAND\", \"\");\n+    CheckSplitTorReplyLine(\"COMMAND SOME  ARGS\", \"COMMAND\", \"SOME  ARGS\");\n+\n+    // These inputs are valid because PROTOCOLINFO accepts an OtherLine that is\n+    // just an OptArguments, which enables multiple spaces to be present\n+    // between the command and arguments.\n+    CheckSplitTorReplyLine(\"COMMAND  ARGS\", \"COMMAND\", \" ARGS\");\n+    CheckSplitTorReplyLine(\"COMMAND   EVEN+more  ARGS\", \"COMMAND\", \"  EVEN+more  ARGS\");\n+}\n+\n+void CheckParseTorReplyMapping(std::string input, std::map<std::string,std::string> expected)\n+{\n+    BOOST_TEST_MESSAGE(std::string(\"CheckParseTorReplyMapping(\") + input + \")\");\n+    auto ret = ParseTorReplyMapping(input);\n+    BOOST_CHECK_EQUAL(ret.size(), expected.size());\n+    auto r_it = ret.begin();\n+    auto e_it = expected.begin();\n+    while (r_it != ret.end() && e_it != expected.end()) {\n+        BOOST_CHECK_EQUAL(r_it->first, e_it->first);\n+        BOOST_CHECK_EQUAL(r_it->second, e_it->second);\n+        r_it++;\n+        e_it++;\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_ParseTorReplyMapping)\n+{\n+    // Data we should receive during normal usage\n+    CheckParseTorReplyMapping(\n+        \"METHODS=COOKIE,SAFECOOKIE COOKIEFILE=\\\"/home/x/.tor/control_auth_cookie\\\"\", {\n+            {\"METHODS\", \"COOKIE,SAFECOOKIE\"},\n+            {\"COOKIEFILE\", \"/home/x/.tor/control_auth_cookie\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"METHODS=NULL\", {\n+            {\"METHODS\", \"NULL\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"METHODS=HASHEDPASSWORD\", {\n+            {\"METHODS\", \"HASHEDPASSWORD\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"Tor=\\\"0.2.9.8 (git-a0df013ea241b026)\\\"\", {\n+            {\"Tor\", \"0.2.9.8 (git-a0df013ea241b026)\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"SERVERHASH=aaaa SERVERNONCE=bbbb\", {\n+            {\"SERVERHASH\", \"aaaa\"},\n+            {\"SERVERNONCE\", \"bbbb\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"ServiceID=exampleonion1234\", {\n+            {\"ServiceID\", \"exampleonion1234\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"PrivateKey=RSA1024:BLOB\", {\n+            {\"PrivateKey\", \"RSA1024:BLOB\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"ClientAuth=bob:BLOB\", {\n+            {\"ClientAuth\", \"bob:BLOB\"},\n+        });\n+\n+    // Other valid inputs\n+    CheckParseTorReplyMapping(\n+        \"Foo=Bar=Baz Spam=Eggs\", {\n+            {\"Foo\", \"Bar=Baz\"},\n+            {\"Spam\", \"Eggs\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"Foo=\\\"Bar=Baz\\\"\", {\n+            {\"Foo\", \"Bar=Baz\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"Foo=\\\"Bar Baz\\\"\", {\n+            {\"Foo\", \"Bar Baz\"},\n+        });\n+\n+    // Escapes\n+    CheckParseTorReplyMapping(\n+        \"Foo=\\\"Bar\\\\ Baz\\\"\", {\n+            {\"Foo\", \"Bar Baz\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"Foo=\\\"Bar\\\\Baz\\\"\", {\n+            {\"Foo\", \"BarBaz\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"Foo=\\\"Bar\\\\@Baz\\\"\", {\n+            {\"Foo\", \"Bar@Baz\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"Foo=\\\"Bar\\\\\\\"Baz\\\" Spam=\\\"\\\\\\\"Eggs\\\\\\\"\\\"\", {\n+            {\"Foo\", \"Bar\\\"Baz\"},\n+            {\"Spam\", \"\\\"Eggs\\\"\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"Foo=\\\"Bar\\\\\\\\Baz\\\"\", {\n+            {\"Foo\", \"Bar\\\\Baz\"},\n+        });\n+\n+    // C escapes\n+    CheckParseTorReplyMapping(\n+        \"Foo=\\\"Bar\\\\nBaz\\\\t\\\" Spam=\\\"\\\\rEggs\\\" Octals=\\\"\\\\1a\\\\11\\\\17\\\\18\\\\81\\\\377\\\\378\\\\400\\\\2222\\\" Final=Check\", {\n+            {\"Foo\", \"Bar\\nBaz\\t\"},\n+            {\"Spam\", \"\\rEggs\"},\n+            {\"Octals\", \"\\1a\\11\\17\\1\" \"881\\377\\37\" \"8\\40\" \"0\\222\" \"2\"},\n+            {\"Final\", \"Check\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"Valid=Mapping Escaped=\\\"Escape\\\\\\\\\\\"\", {\n+            {\"Valid\", \"Mapping\"},\n+            {\"Escaped\", \"Escape\\\\\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"Valid=Mapping Bare=\\\"Escape\\\\\\\"\", {});\n+    CheckParseTorReplyMapping(\n+        \"OneOctal=\\\"OneEnd\\\\1\\\" TwoOctal=\\\"TwoEnd\\\\11\\\"\", {\n+            {\"OneOctal\", \"OneEnd\\1\"},\n+            {\"TwoOctal\", \"TwoEnd\\11\"},\n+        });\n+\n+    // Special handling for null case\n+    // (needed because string comparison reads the null as end-of-string)\n+    BOOST_TEST_MESSAGE(std::string(\"CheckParseTorReplyMapping(Null=\\\"\\\\0\\\")\"));\n+    auto ret = ParseTorReplyMapping(\"Null=\\\"\\\\0\\\"\");\n+    BOOST_CHECK_EQUAL(ret.size(), 1);\n+    auto r_it = ret.begin();\n+    BOOST_CHECK_EQUAL(r_it->first, \"Null\");\n+    BOOST_CHECK_EQUAL(r_it->second.size(), 1);\n+    BOOST_CHECK_EQUAL(r_it->second[0], '\\0');\n+\n+    // A more complex valid grammar. PROTOCOLINFO accepts a VersionLine that\n+    // takes a key=value pair followed by an OptArguments, making this valid.\n+    // Because an OptArguments contains no semantic data, there is no point in\n+    // parsing it.\n+    CheckParseTorReplyMapping(\n+        \"SOME=args,here MORE optional=arguments  here\", {\n+            {\"SOME\", \"args,here\"},\n+        });\n+\n+    // Inputs that are effectively invalid under the target grammar.\n+    // PROTOCOLINFO accepts an OtherLine that is just an OptArguments, which\n+    // would make these inputs valid. However,\n+    // - This parser is never used in that situation, because the\n+    //   SplitTorReplyLine parser enables OtherLine to be skipped.\n+    // - Even if these were valid, an OptArguments contains no semantic data,\n+    //   so there is no point in parsing it.\n+    CheckParseTorReplyMapping(\"ARGS\", {});\n+    CheckParseTorReplyMapping(\"MORE ARGS\", {});\n+    CheckParseTorReplyMapping(\"MORE  ARGS\", {});\n+    CheckParseTorReplyMapping(\"EVEN more=ARGS\", {});\n+    CheckParseTorReplyMapping(\"EVEN+more ARGS\", {});\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "67610301d7e5684fa05d9585296c00a7bfe514de",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -8,11 +8,12 @@\n \n #include \"clientversion.h\"\n #include \"checkqueue.h\"\n+#include \"consensus/tx_verify.h\"\n #include \"consensus/validation.h\"\n #include \"core_io.h\"\n #include \"key.h\"\n #include \"keystore.h\"\n-#include \"validation.h\" // For CheckTransaction\n+#include \"validation.h\"\n #include \"policy/policy.h\"\n #include \"script/script.h\"\n #include \"script/sign.h\""
      },
      {
        "sha": "10330c0c23a23139b0ab8c78ce0f98eec6fbdfcc",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 32,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -17,8 +17,6 @@\n \n #include <boost/test/unit_test.hpp>\n \n-extern std::map<std::string, std::string> mapArgs;\n-\n BOOST_FIXTURE_TEST_SUITE(util_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(util_criticalsection)\n@@ -100,52 +98,67 @@ BOOST_AUTO_TEST_CASE(util_DateTimeStrFormat)\n     BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%a, %d %b %Y %H:%M:%S +0000\", 1317425777), \"Fri, 30 Sep 2011 23:36:17 +0000\");\n }\n \n+class TestArgsManager : public ArgsManager\n+{\n+public:\n+    std::map<std::string, std::string>& GetMapArgs()\n+    {\n+        return mapArgs;\n+    };\n+    const std::map<std::string, std::vector<std::string> >& GetMapMultiArgs()\n+    {\n+        return mapMultiArgs;\n+    };\n+};\n+\n BOOST_AUTO_TEST_CASE(util_ParseParameters)\n {\n+    TestArgsManager testArgs;\n     const char *argv_test[] = {\"-ignored\", \"-a\", \"-b\", \"-ccc=argument\", \"-ccc=multiple\", \"f\", \"-d=e\"};\n \n-    ParseParameters(0, (char**)argv_test);\n-    BOOST_CHECK(mapArgs.empty() && mapMultiArgs.empty());\n+    testArgs.ParseParameters(0, (char**)argv_test);\n+    BOOST_CHECK(testArgs.GetMapArgs().empty() && testArgs.GetMapMultiArgs().empty());\n \n-    ParseParameters(1, (char**)argv_test);\n-    BOOST_CHECK(mapArgs.empty() && mapMultiArgs.empty());\n+    testArgs.ParseParameters(1, (char**)argv_test);\n+    BOOST_CHECK(testArgs.GetMapArgs().empty() && testArgs.GetMapMultiArgs().empty());\n \n-    ParseParameters(5, (char**)argv_test);\n+    testArgs.ParseParameters(5, (char**)argv_test);\n     // expectation: -ignored is ignored (program name argument),\n     // -a, -b and -ccc end up in map, -d ignored because it is after\n     // a non-option argument (non-GNU option parsing)\n-    BOOST_CHECK(mapArgs.size() == 3 && mapMultiArgs.size() == 3);\n-    BOOST_CHECK(IsArgSet(\"-a\") && IsArgSet(\"-b\") && IsArgSet(\"-ccc\")\n-                && !IsArgSet(\"f\") && !IsArgSet(\"-d\"));\n-    BOOST_CHECK(mapMultiArgs.count(\"-a\") && mapMultiArgs.count(\"-b\") && mapMultiArgs.count(\"-ccc\")\n-                && !mapMultiArgs.count(\"f\") && !mapMultiArgs.count(\"-d\"));\n-\n-    BOOST_CHECK(mapArgs[\"-a\"] == \"\" && mapArgs[\"-ccc\"] == \"multiple\");\n-    BOOST_CHECK(mapMultiArgs.at(\"-ccc\").size() == 2);\n+    BOOST_CHECK(testArgs.GetMapArgs().size() == 3 && testArgs.GetMapMultiArgs().size() == 3);\n+    BOOST_CHECK(testArgs.IsArgSet(\"-a\") && testArgs.IsArgSet(\"-b\") && testArgs.IsArgSet(\"-ccc\")\n+                && !testArgs.IsArgSet(\"f\") && !testArgs.IsArgSet(\"-d\"));\n+    BOOST_CHECK(testArgs.GetMapMultiArgs().count(\"-a\") && testArgs.GetMapMultiArgs().count(\"-b\") && testArgs.GetMapMultiArgs().count(\"-ccc\")\n+                && !testArgs.GetMapMultiArgs().count(\"f\") && !testArgs.GetMapMultiArgs().count(\"-d\"));\n+\n+    BOOST_CHECK(testArgs.GetMapArgs()[\"-a\"] == \"\" && testArgs.GetMapArgs()[\"-ccc\"] == \"multiple\");\n+    BOOST_CHECK(testArgs.GetArgs(\"-ccc\").size() == 2);\n }\n \n BOOST_AUTO_TEST_CASE(util_GetArg)\n {\n-    mapArgs.clear();\n-    mapArgs[\"strtest1\"] = \"string...\";\n+    TestArgsManager testArgs;\n+    testArgs.GetMapArgs().clear();\n+    testArgs.GetMapArgs()[\"strtest1\"] = \"string...\";\n     // strtest2 undefined on purpose\n-    mapArgs[\"inttest1\"] = \"12345\";\n-    mapArgs[\"inttest2\"] = \"81985529216486895\";\n+    testArgs.GetMapArgs()[\"inttest1\"] = \"12345\";\n+    testArgs.GetMapArgs()[\"inttest2\"] = \"81985529216486895\";\n     // inttest3 undefined on purpose\n-    mapArgs[\"booltest1\"] = \"\";\n+    testArgs.GetMapArgs()[\"booltest1\"] = \"\";\n     // booltest2 undefined on purpose\n-    mapArgs[\"booltest3\"] = \"0\";\n-    mapArgs[\"booltest4\"] = \"1\";\n-\n-    BOOST_CHECK_EQUAL(GetArg(\"strtest1\", \"default\"), \"string...\");\n-    BOOST_CHECK_EQUAL(GetArg(\"strtest2\", \"default\"), \"default\");\n-    BOOST_CHECK_EQUAL(GetArg(\"inttest1\", -1), 12345);\n-    BOOST_CHECK_EQUAL(GetArg(\"inttest2\", -1), 81985529216486895LL);\n-    BOOST_CHECK_EQUAL(GetArg(\"inttest3\", -1), -1);\n-    BOOST_CHECK_EQUAL(GetBoolArg(\"booltest1\", false), true);\n-    BOOST_CHECK_EQUAL(GetBoolArg(\"booltest2\", false), false);\n-    BOOST_CHECK_EQUAL(GetBoolArg(\"booltest3\", false), false);\n-    BOOST_CHECK_EQUAL(GetBoolArg(\"booltest4\", false), true);\n+    testArgs.GetMapArgs()[\"booltest3\"] = \"0\";\n+    testArgs.GetMapArgs()[\"booltest4\"] = \"1\";\n+\n+    BOOST_CHECK_EQUAL(testArgs.GetArg(\"strtest1\", \"default\"), \"string...\");\n+    BOOST_CHECK_EQUAL(testArgs.GetArg(\"strtest2\", \"default\"), \"default\");\n+    BOOST_CHECK_EQUAL(testArgs.GetArg(\"inttest1\", -1), 12345);\n+    BOOST_CHECK_EQUAL(testArgs.GetArg(\"inttest2\", -1), 81985529216486895LL);\n+    BOOST_CHECK_EQUAL(testArgs.GetArg(\"inttest3\", -1), -1);\n+    BOOST_CHECK_EQUAL(testArgs.GetBoolArg(\"booltest1\", false), true);\n+    BOOST_CHECK_EQUAL(testArgs.GetBoolArg(\"booltest2\", false), false);\n+    BOOST_CHECK_EQUAL(testArgs.GetBoolArg(\"booltest3\", false), false);\n+    BOOST_CHECK_EQUAL(testArgs.GetBoolArg(\"booltest4\", false), true);\n }\n \n BOOST_AUTO_TEST_CASE(util_FormatMoney)"
      },
      {
        "sha": "79405ec4d1ed3297cb6266b62a354d83b1f4c92d",
        "filename": "src/test/versionbits_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/versionbits_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/test/versionbits_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/versionbits_tests.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -209,7 +209,8 @@ BOOST_AUTO_TEST_CASE(versionbits_test)\n     }\n \n     // Sanity checks of version bit deployments\n-    const Consensus::Params &mainnetParams = Params(CBaseChainParams::MAIN).GetConsensus();\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n+    const Consensus::Params &mainnetParams = chainParams->GetConsensus();\n     for (int i=0; i<(int) Consensus::MAX_VERSION_BITS_DEPLOYMENTS; i++) {\n         uint32_t bitmask = VersionBitsMask(mainnetParams, (Consensus::DeploymentPos)i);\n         // Make sure that no deployment tries to set an invalid bit.\n@@ -235,7 +236,8 @@ BOOST_AUTO_TEST_CASE(versionbits_computeblockversion)\n {\n     // Check that ComputeBlockVersion will set the appropriate bit correctly\n     // on mainnet.\n-    const Consensus::Params &mainnetParams = Params(CBaseChainParams::MAIN).GetConsensus();\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n+    const Consensus::Params &mainnetParams = chainParams->GetConsensus();\n \n     // Use the TESTDUMMY deployment for testing purposes.\n     int64_t bit = mainnetParams.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit;"
      },
      {
        "sha": "8a37139f1d1ae98b00fb26d711069705f2c63672",
        "filename": "src/torcontrol.cpp",
        "status": "modified",
        "additions": 79,
        "deletions": 12,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/torcontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/torcontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -1,4 +1,5 @@\n // Copyright (c) 2015-2016 The Bitcoin Core developers\n+// Copyright (c) 2017 The Zcash developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -14,7 +15,6 @@\n #include <set>\n #include <stdlib.h>\n \n-#include <boost/function.hpp>\n #include <boost/bind.hpp>\n #include <boost/signals2/signal.hpp>\n #include <boost/foreach.hpp>\n@@ -73,8 +73,8 @@ class TorControlReply\n class TorControlConnection\n {\n public:\n-    typedef boost::function<void(TorControlConnection&)> ConnectionCB;\n-    typedef boost::function<void(TorControlConnection &,const TorControlReply &)> ReplyHandlerCB;\n+    typedef std::function<void(TorControlConnection&)> ConnectionCB;\n+    typedef std::function<void(TorControlConnection &,const TorControlReply &)> ReplyHandlerCB;\n \n     /** Create a new TorControlConnection.\n      */\n@@ -105,9 +105,9 @@ class TorControlConnection\n     boost::signals2::signal<void(TorControlConnection &,const TorControlReply &)> async_handler;\n private:\n     /** Callback when ready for use */\n-    boost::function<void(TorControlConnection&)> connected;\n+    std::function<void(TorControlConnection&)> connected;\n     /** Callback when connection lost */\n-    boost::function<void(TorControlConnection&)> disconnected;\n+    std::function<void(TorControlConnection&)> disconnected;\n     /** Libevent event base */\n     struct event_base *base;\n     /** Connection to control socket */\n@@ -250,6 +250,8 @@ bool TorControlConnection::Command(const std::string &cmd, const ReplyHandlerCB&\n \n /* Split reply line in the form 'AUTH METHODS=...' into a type\n  * 'AUTH' and arguments 'METHODS=...'.\n+ * Grammar is implicitly defined in https://spec.torproject.org/control-spec by\n+ * the server reply formats for PROTOCOLINFO (S3.21) and AUTHCHALLENGE (S3.24).\n  */\n static std::pair<std::string,std::string> SplitTorReplyLine(const std::string &s)\n {\n@@ -265,35 +267,85 @@ static std::pair<std::string,std::string> SplitTorReplyLine(const std::string &s\n }\n \n /** Parse reply arguments in the form 'METHODS=COOKIE,SAFECOOKIE COOKIEFILE=\".../control_auth_cookie\"'.\n+ * Returns a map of keys to values, or an empty map if there was an error.\n+ * Grammar is implicitly defined in https://spec.torproject.org/control-spec by\n+ * the server reply formats for PROTOCOLINFO (S3.21), AUTHCHALLENGE (S3.24),\n+ * and ADD_ONION (S3.27). See also sections 2.1 and 2.3.\n  */\n static std::map<std::string,std::string> ParseTorReplyMapping(const std::string &s)\n {\n     std::map<std::string,std::string> mapping;\n     size_t ptr=0;\n     while (ptr < s.size()) {\n         std::string key, value;\n-        while (ptr < s.size() && s[ptr] != '=') {\n+        while (ptr < s.size() && s[ptr] != '=' && s[ptr] != ' ') {\n             key.push_back(s[ptr]);\n             ++ptr;\n         }\n         if (ptr == s.size()) // unexpected end of line\n             return std::map<std::string,std::string>();\n+        if (s[ptr] == ' ') // The remaining string is an OptArguments\n+            break;\n         ++ptr; // skip '='\n         if (ptr < s.size() && s[ptr] == '\"') { // Quoted string\n-            ++ptr; // skip '='\n+            ++ptr; // skip opening '\"'\n             bool escape_next = false;\n-            while (ptr < s.size() && (!escape_next && s[ptr] != '\"')) {\n-                escape_next = (s[ptr] == '\\\\');\n+            while (ptr < s.size() && (escape_next || s[ptr] != '\"')) {\n+                // Repeated backslashes must be interpreted as pairs\n+                escape_next = (s[ptr] == '\\\\' && !escape_next);\n                 value.push_back(s[ptr]);\n                 ++ptr;\n             }\n             if (ptr == s.size()) // unexpected end of line\n                 return std::map<std::string,std::string>();\n             ++ptr; // skip closing '\"'\n-            /* TODO: unescape value - according to the spec this depends on the\n-             * context, some strings use C-LogPrintf style escape codes, some\n-             * don't. So may be better handled at the call site.\n+            /**\n+             * Unescape value. Per https://spec.torproject.org/control-spec section 2.1.1:\n+             *\n+             *   For future-proofing, controller implementors MAY use the following\n+             *   rules to be compatible with buggy Tor implementations and with\n+             *   future ones that implement the spec as intended:\n+             *\n+             *     Read \\n \\t \\r and \\0 ... \\377 as C escapes.\n+             *     Treat a backslash followed by any other character as that character.\n              */\n+            std::string escaped_value;\n+            for (size_t i = 0; i < value.size(); ++i) {\n+                if (value[i] == '\\\\') {\n+                    // This will always be valid, because if the QuotedString\n+                    // ended in an odd number of backslashes, then the parser\n+                    // would already have returned above, due to a missing\n+                    // terminating double-quote.\n+                    ++i;\n+                    if (value[i] == 'n') {\n+                        escaped_value.push_back('\\n');\n+                    } else if (value[i] == 't') {\n+                        escaped_value.push_back('\\t');\n+                    } else if (value[i] == 'r') {\n+                        escaped_value.push_back('\\r');\n+                    } else if ('0' <= value[i] && value[i] <= '7') {\n+                        size_t j;\n+                        // Octal escape sequences have a limit of three octal digits,\n+                        // but terminate at the first character that is not a valid\n+                        // octal digit if encountered sooner.\n+                        for (j = 1; j < 3 && (i+j) < value.size() && '0' <= value[i+j] && value[i+j] <= '7'; ++j) {}\n+                        // Tor restricts first digit to 0-3 for three-digit octals.\n+                        // A leading digit of 4-7 would therefore be interpreted as\n+                        // a two-digit octal.\n+                        if (j == 3 && value[i] > '3') {\n+                            j--;\n+                        }\n+                        escaped_value.push_back(strtol(value.substr(i, j).c_str(), NULL, 8));\n+                        // Account for automatic incrementing at loop end\n+                        i += j - 1;\n+                    } else {\n+                        escaped_value.push_back(value[i]);\n+                    }\n+                } else {\n+                    escaped_value.push_back(value[i]);\n+                }\n+            }\n+            value = escaped_value;\n         } else { // Unquoted value. Note that values can contain '=' at will, just no spaces\n             while (ptr < s.size() && s[ptr] != ' ') {\n                 value.push_back(s[ptr]);\n@@ -323,6 +375,10 @@ static std::pair<bool,std::string> ReadBinaryFile(const fs::path &filename, size\n     char buffer[128];\n     size_t n;\n     while ((n=fread(buffer, 1, sizeof(buffer), f)) > 0) {\n+        // Check for reading errors so we don't return any data if we couldn't\n+        // read the entire file (or up to maxsize)\n+        if (ferror(f))\n+            return std::make_pair(false,\"\");\n         retval.append(buffer, buffer+n);\n         if (retval.size() > maxsize)\n             break;\n@@ -439,6 +495,13 @@ void TorController::add_onion_cb(TorControlConnection& _conn, const TorControlRe\n             if ((i = m.find(\"PrivateKey\")) != m.end())\n                 private_key = i->second;\n         }\n+        if (service_id.empty()) {\n+            LogPrintf(\"tor: Error parsing ADD_ONION parameters:\\n\");\n+            for (const std::string &s : reply.lines) {\n+                LogPrintf(\"    %s\\n\", SanitizeString(s));\n+            }\n+            return;\n+        }\n         service = LookupNumeric(std::string(service_id+\".onion\").c_str(), GetListenPort());\n         LogPrintf(\"tor: Got service ID %s, advertising service %s\\n\", service_id, service.ToString());\n         if (WriteBinaryFile(GetPrivateKeyFile(), private_key)) {\n@@ -516,6 +579,10 @@ void TorController::authchallenge_cb(TorControlConnection& _conn, const TorContr\n         std::pair<std::string,std::string> l = SplitTorReplyLine(reply.lines[0]);\n         if (l.first == \"AUTHCHALLENGE\") {\n             std::map<std::string,std::string> m = ParseTorReplyMapping(l.second);\n+            if (m.empty()) {\n+                LogPrintf(\"tor: Error parsing AUTHCHALLENGE parameters: %s\\n\", SanitizeString(l.second));\n+                return;\n+            }\n             std::vector<uint8_t> serverHash = ParseHex(m[\"SERVERHASH\"]);\n             std::vector<uint8_t> serverNonce = ParseHex(m[\"SERVERNONCE\"]);\n             LogPrint(BCLog::TOR, \"tor: AUTHCHALLENGE ServerHash %s ServerNonce %s\\n\", HexStr(serverHash), HexStr(serverNonce));"
      },
      {
        "sha": "76aab239830beeba7ae279fb3d1143c99a481adb",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -98,7 +98,11 @@ CCoinsViewCursor *CCoinsViewDB::Cursor() const\n        that restriction.  */\n     i->pcursor->Seek(DB_COINS);\n     // Cache key of first record\n-    i->pcursor->GetKey(i->keyTmp);\n+    if (i->pcursor->Valid()) {\n+        i->pcursor->GetKey(i->keyTmp);\n+    } else {\n+        i->keyTmp.first = 0; // Make sure Valid() and GetKey() return false\n+    }\n     return i;\n }\n \n@@ -169,7 +173,7 @@ bool CBlockTreeDB::ReadFlag(const std::string &name, bool &fValue) {\n     return true;\n }\n \n-bool CBlockTreeDB::LoadBlockIndexGuts(boost::function<CBlockIndex*(const uint256&)> insertBlockIndex)\n+bool CBlockTreeDB::LoadBlockIndexGuts(std::function<CBlockIndex*(const uint256&)> insertBlockIndex)\n {\n     std::unique_ptr<CDBIterator> pcursor(NewIterator());\n "
      },
      {
        "sha": "117e7201fb69ed707d87964c991f257b6957b403",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -15,8 +15,6 @@\n #include <utility>\n #include <vector>\n \n-#include <boost/function.hpp>\n-\n class CBlockIndex;\n class CCoinsViewDBCursor;\n class uint256;\n@@ -122,7 +120,7 @@ class CBlockTreeDB : public CDBWrapper\n     bool WriteTxIndex(const std::vector<std::pair<uint256, CDiskTxPos> > &list);\n     bool WriteFlag(const std::string &name, bool fValue);\n     bool ReadFlag(const std::string &name, bool &fValue);\n-    bool LoadBlockIndexGuts(boost::function<CBlockIndex*(const uint256&)> insertBlockIndex);\n+    bool LoadBlockIndexGuts(std::function<CBlockIndex*(const uint256&)> insertBlockIndex);\n };\n \n #endif // BITCOIN_TXDB_H"
      },
      {
        "sha": "33df0536d0f255021152774d1ae705a45d10d359",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 59,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -5,8 +5,8 @@\n \n #include \"txmempool.h\"\n \n-#include \"clientversion.h\"\n #include \"consensus/consensus.h\"\n+#include \"consensus/tx_verify.h\"\n #include \"consensus/validation.h\"\n #include \"validation.h\"\n #include \"policy/policy.h\"\n@@ -16,7 +16,6 @@\n #include \"util.h\"\n #include \"utilmoneystr.h\"\n #include \"utiltime.h\"\n-#include \"version.h\"\n \n CTxMemPoolEntry::CTxMemPoolEntry(const CTransactionRef& _tx, const CAmount& _nFee,\n                                  int64_t _nTime, unsigned int _entryHeight,\n@@ -333,22 +332,15 @@ void CTxMemPoolEntry::UpdateAncestorState(int64_t modifySize, CAmount modifyFee,\n     assert(int(nSigOpCostWithAncestors) >= 0);\n }\n \n-CTxMemPool::CTxMemPool() :\n-    nTransactionsUpdated(0)\n+CTxMemPool::CTxMemPool(CBlockPolicyEstimator* estimator) :\n+    nTransactionsUpdated(0), minerPolicyEstimator(estimator)\n {\n     _clear(); //lock free clear\n \n     // Sanity checks off by default for performance, because otherwise\n     // accepting transactions becomes O(N^2) where N is the number\n     // of transactions in the pool\n     nCheckFrequency = 0;\n-\n-    minerPolicyEstimator = new CBlockPolicyEstimator();\n-}\n-\n-CTxMemPool::~CTxMemPool()\n-{\n-    delete minerPolicyEstimator;\n }\n \n void CTxMemPool::pruneSpent(const uint256 &hashTx, CCoins &coins)\n@@ -427,7 +419,7 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,\n \n     nTransactionsUpdated++;\n     totalTxSize += entry.GetTxSize();\n-    minerPolicyEstimator->processTransaction(entry, validFeeEstimate);\n+    if (minerPolicyEstimator) {minerPolicyEstimator->processTransaction(entry, validFeeEstimate);}\n \n     vTxHashes.emplace_back(tx.GetWitnessHash(), newit);\n     newit->vTxHashesIdx = vTxHashes.size() - 1;\n@@ -457,7 +449,7 @@ void CTxMemPool::removeUnchecked(txiter it, MemPoolRemovalReason reason)\n     mapLinks.erase(it);\n     mapTx.erase(it);\n     nTransactionsUpdated++;\n-    minerPolicyEstimator->removeTx(hash);\n+    if (minerPolicyEstimator) {minerPolicyEstimator->removeTx(hash, false);}\n }\n \n // Calculates descendants of entry that are not already in setDescendants, and adds to\n@@ -591,7 +583,7 @@ void CTxMemPool::removeForBlock(const std::vector<CTransactionRef>& vtx, unsigne\n             entries.push_back(&*i);\n     }\n     // Before the txs in the new block have been removed from the mempool, update policy estimates\n-    minerPolicyEstimator->processBlock(nBlockHeight, entries);\n+    if (minerPolicyEstimator) {minerPolicyEstimator->processBlock(nBlockHeight, entries);}\n     for (const auto& tx : vtx)\n     {\n         txiter it = mapTx.find(tx->GetHash());\n@@ -850,51 +842,6 @@ TxMempoolInfo CTxMemPool::info(const uint256& hash) const\n     return GetInfo(i);\n }\n \n-CFeeRate CTxMemPool::estimateFee(int nBlocks) const\n-{\n-    LOCK(cs);\n-    return minerPolicyEstimator->estimateFee(nBlocks);\n-}\n-CFeeRate CTxMemPool::estimateSmartFee(int nBlocks, int *answerFoundAtBlocks) const\n-{\n-    LOCK(cs);\n-    return minerPolicyEstimator->estimateSmartFee(nBlocks, answerFoundAtBlocks, *this);\n-}\n-\n-bool\n-CTxMemPool::WriteFeeEstimates(CAutoFile& fileout) const\n-{\n-    try {\n-        LOCK(cs);\n-        fileout << 139900; // version required to read: 0.13.99 or later\n-        fileout << CLIENT_VERSION; // version that wrote the file\n-        minerPolicyEstimator->Write(fileout);\n-    }\n-    catch (const std::exception&) {\n-        LogPrintf(\"CTxMemPool::WriteFeeEstimates(): unable to write policy estimator data (non-fatal)\\n\");\n-        return false;\n-    }\n-    return true;\n-}\n-\n-bool\n-CTxMemPool::ReadFeeEstimates(CAutoFile& filein)\n-{\n-    try {\n-        int nVersionRequired, nVersionThatWrote;\n-        filein >> nVersionRequired >> nVersionThatWrote;\n-        if (nVersionRequired > CLIENT_VERSION)\n-            return error(\"CTxMemPool::ReadFeeEstimates(): up-version (%d) fee estimate file\", nVersionRequired);\n-        LOCK(cs);\n-        minerPolicyEstimator->Read(filein, nVersionThatWrote);\n-    }\n-    catch (const std::exception&) {\n-        LogPrintf(\"CTxMemPool::ReadFeeEstimates(): unable to read policy estimator data (non-fatal)\\n\");\n-        return false;\n-    }\n-    return true;\n-}\n-\n void CTxMemPool::PrioritiseTransaction(const uint256& hash, const CAmount& nFeeDelta)\n {\n     {\n@@ -919,6 +866,7 @@ void CTxMemPool::PrioritiseTransaction(const uint256& hash, const CAmount& nFeeD\n             BOOST_FOREACH(txiter descendantIt, setDescendants) {\n                 mapTx.modify(descendantIt, update_ancestor_state(0, nFeeDelta, 0, 0));\n             }\n+            ++nTransactionsUpdated;\n         }\n     }\n     LogPrintf(\"PrioritiseTransaction: %s feerate += %s\\n\", hash.ToString(), FormatMoney(nFeeDelta));"
      },
      {
        "sha": "a91eb5be54f7d4858cc600f25e1980df264bb647",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 5,
        "deletions": 33,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -16,6 +16,7 @@\n #include \"amount.h\"\n #include \"coins.h\"\n #include \"indirectmap.h\"\n+#include \"policy/feerate.h\"\n #include \"primitives/transaction.h\"\n #include \"sync.h\"\n #include \"random.h\"\n@@ -59,11 +60,6 @@ class CTxMemPool;\n  * (nCountWithDescendants, nSizeWithDescendants, and nModFeesWithDescendants) for\n  * all ancestors of the newly added transaction.\n  *\n- * If updating the descendant state is skipped, we can mark the entry as\n- * \"dirty\", and set nSizeWithDescendants/nModFeesWithDescendants to equal nTxSize/\n- * nFee+feeDelta. (This can potentially happen during a reorg, where we limit the\n- * amount of work we're willing to do to avoid consuming too much CPU.)\n- *\n  */\n \n class CTxMemPoolEntry\n@@ -82,9 +78,7 @@ class CTxMemPoolEntry\n \n     // Information about descendants of this transaction that are in the\n     // mempool; if we remove this transaction we must remove all of these\n-    // descendants as well.  if nCountWithDescendants is 0, treat this entry as\n-    // dirty, and nSizeWithDescendants and nModFeesWithDescendants will not be\n-    // correct.\n+    // descendants as well.\n     uint64_t nCountWithDescendants;  //!< number of descendant transactions\n     uint64_t nSizeWithDescendants;   //!< ... and size\n     CAmount nModFeesWithDescendants; //!< ... and total fees (all including us)\n@@ -115,7 +109,7 @@ class CTxMemPoolEntry\n     size_t DynamicMemoryUsage() const { return nUsageSize; }\n     const LockPoints& GetLockPoints() const { return lockPoints; }\n \n-    // Adjusts the descendant state, if this entry is not dirty.\n+    // Adjusts the descendant state.\n     void UpdateDescendantState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount);\n     // Adjusts the ancestor state\n     void UpdateAncestorState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount, int modifySigOps);\n@@ -398,20 +392,12 @@ enum class MemPoolRemovalReason {\n  * CalculateMemPoolAncestors() takes configurable limits that are designed to\n  * prevent these calculations from being too CPU intensive.\n  *\n- * Adding transactions from a disconnected block can be very time consuming,\n- * because we don't have a way to limit the number of in-mempool descendants.\n- * To bound CPU processing, we limit the amount of work we're willing to do\n- * to properly update the descendant information for a tx being added from\n- * a disconnected block.  If we would exceed the limit, then we instead mark\n- * the entry as \"dirty\", and set the feerate for sorting purposes to be equal\n- * the feerate of the transaction without any descendants.\n- *\n  */\n class CTxMemPool\n {\n private:\n     uint32_t nCheckFrequency; //!< Value n means that n times in 2^32 we check.\n-    unsigned int nTransactionsUpdated;\n+    unsigned int nTransactionsUpdated; //!< Used by getblocktemplate to trigger CreateNewBlock() invocation\n     CBlockPolicyEstimator* minerPolicyEstimator;\n \n     uint64_t totalTxSize;      //!< sum of all mempool tx's virtual sizes. Differs from serialized tx size since witness data is discounted. Defined in BIP 141.\n@@ -496,8 +482,7 @@ class CTxMemPool\n \n     /** Create a new CTxMemPool.\n      */\n-    CTxMemPool();\n-    ~CTxMemPool();\n+    CTxMemPool(CBlockPolicyEstimator* estimator = nullptr);\n \n     /**\n      * If sanity-checking is turned on, check makes sure the pool is\n@@ -618,19 +603,6 @@ class CTxMemPool\n     TxMempoolInfo info(const uint256& hash) const;\n     std::vector<TxMempoolInfo> infoAll() const;\n \n-    /** Estimate fee rate needed to get into the next nBlocks\n-     *  If no answer can be given at nBlocks, return an estimate\n-     *  at the lowest number of blocks where one can be given\n-     */\n-    CFeeRate estimateSmartFee(int nBlocks, int *answerFoundAtBlocks = NULL) const;\n-\n-    /** Estimate fee rate needed to get into the next nBlocks */\n-    CFeeRate estimateFee(int nBlocks) const;\n-\n-    /** Write/Read estimates to disk */\n-    bool WriteFeeEstimates(CAutoFile& fileout) const;\n-    bool ReadFeeEstimates(CAutoFile& filein);\n-\n     size_t DynamicMemoryUsage() const;\n \n     boost::signals2::signal<void (CTransactionRef)> NotifyEntryAdded;"
      },
      {
        "sha": "653a4f072ad60c151e91b62761d8ff17cfa3fcac",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 32,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -13,7 +13,6 @@\n #include \"fs.h\"\n #include \"random.h\"\n #include \"serialize.h\"\n-#include \"sync.h\"\n #include \"utilstrencodings.h\"\n #include \"utiltime.h\"\n \n@@ -88,27 +87,11 @@\n #include <openssl/rand.h>\n #include <openssl/conf.h>\n \n-// Work around clang compilation problem in Boost 1.46:\n-// /usr/include/boost/program_options/detail/config_file.hpp:163:17: error: call to function 'to_internal' that is neither visible in the template definition nor found by argument-dependent lookup\n-// See also: http://stackoverflow.com/questions/10020179/compilation-fail-in-boost-librairies-program-options\n-//           http://clang.debian.net/status.php?version=3.0&key=CANNOT_FIND_FUNCTION\n-namespace boost {\n-\n-    namespace program_options {\n-        std::string to_internal(const std::string&);\n-    }\n-\n-} // namespace boost\n-\n-\n \n const char * const BITCOIN_CONF_FILENAME = \"bitcoin.conf\";\n const char * const BITCOIN_PID_FILENAME = \"bitcoind.pid\";\n \n-CCriticalSection cs_args;\n-std::map<std::string, std::string> mapArgs;\n-static std::map<std::string, std::vector<std::string> > _mapMultiArgs;\n-const std::map<std::string, std::vector<std::string> >& mapMultiArgs = _mapMultiArgs;\n+ArgsManager gArgs;\n bool fPrintToConsole = false;\n bool fPrintToDebugLog = true;\n \n@@ -323,10 +306,14 @@ static std::string LogTimestampStr(const std::string &str, std::atomic_bool *fSt\n         return str;\n \n     if (*fStartedNewLine) {\n-        int64_t nTimeMicros = GetLogTimeMicros();\n+        int64_t nTimeMicros = GetTimeMicros();\n         strStamped = DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", nTimeMicros/1000000);\n         if (fLogTimeMicros)\n             strStamped += strprintf(\".%06d\", nTimeMicros%1000000);\n+        int64_t mocktime = GetMockTime();\n+        if (mocktime) {\n+            strStamped += \" (mocktime: \" + DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", mocktime) + \")\";\n+        }\n         strStamped += ' ' + str;\n     } else\n         strStamped = str;\n@@ -397,11 +384,11 @@ static void InterpretNegativeSetting(std::string& strKey, std::string& strValue)\n     }\n }\n \n-void ParseParameters(int argc, const char* const argv[])\n+void ArgsManager::ParseParameters(int argc, const char* const argv[])\n {\n     LOCK(cs_args);\n     mapArgs.clear();\n-    _mapMultiArgs.clear();\n+    mapMultiArgs.clear();\n \n     for (int i = 1; i < argc; i++)\n     {\n@@ -429,61 +416,68 @@ void ParseParameters(int argc, const char* const argv[])\n         InterpretNegativeSetting(str, strValue);\n \n         mapArgs[str] = strValue;\n-        _mapMultiArgs[str].push_back(strValue);\n+        mapMultiArgs[str].push_back(strValue);\n     }\n }\n \n-bool IsArgSet(const std::string& strArg)\n+std::vector<std::string> ArgsManager::GetArgs(const std::string& strArg)\n+{\n+    LOCK(cs_args);\n+    return mapMultiArgs.at(strArg);\n+}\n+\n+bool ArgsManager::IsArgSet(const std::string& strArg)\n {\n     LOCK(cs_args);\n     return mapArgs.count(strArg);\n }\n \n-std::string GetArg(const std::string& strArg, const std::string& strDefault)\n+std::string ArgsManager::GetArg(const std::string& strArg, const std::string& strDefault)\n {\n     LOCK(cs_args);\n     if (mapArgs.count(strArg))\n         return mapArgs[strArg];\n     return strDefault;\n }\n \n-int64_t GetArg(const std::string& strArg, int64_t nDefault)\n+int64_t ArgsManager::GetArg(const std::string& strArg, int64_t nDefault)\n {\n     LOCK(cs_args);\n     if (mapArgs.count(strArg))\n         return atoi64(mapArgs[strArg]);\n     return nDefault;\n }\n \n-bool GetBoolArg(const std::string& strArg, bool fDefault)\n+bool ArgsManager::GetBoolArg(const std::string& strArg, bool fDefault)\n {\n     LOCK(cs_args);\n     if (mapArgs.count(strArg))\n         return InterpretBool(mapArgs[strArg]);\n     return fDefault;\n }\n \n-bool SoftSetArg(const std::string& strArg, const std::string& strValue)\n+bool ArgsManager::SoftSetArg(const std::string& strArg, const std::string& strValue)\n {\n     LOCK(cs_args);\n     if (mapArgs.count(strArg))\n         return false;\n-    mapArgs[strArg] = strValue;\n+    ForceSetArg(strArg, strValue);\n     return true;\n }\n \n-bool SoftSetBoolArg(const std::string& strArg, bool fValue)\n+bool ArgsManager::SoftSetBoolArg(const std::string& strArg, bool fValue)\n {\n     if (fValue)\n         return SoftSetArg(strArg, std::string(\"1\"));\n     else\n         return SoftSetArg(strArg, std::string(\"0\"));\n }\n \n-void ForceSetArg(const std::string& strArg, const std::string& strValue)\n+void ArgsManager::ForceSetArg(const std::string& strArg, const std::string& strValue)\n {\n     LOCK(cs_args);\n     mapArgs[strArg] = strValue;\n+    mapMultiArgs[strArg].push_back(strValue);\n }\n \n \n@@ -602,7 +596,7 @@ fs::path GetConfigFile(const std::string& confPath)\n     return pathConfigFile;\n }\n \n-void ReadConfigFile(const std::string& confPath)\n+void ArgsManager::ReadConfigFile(const std::string& confPath)\n {\n     fs::ifstream streamConfig(GetConfigFile(confPath));\n     if (!streamConfig.good())\n@@ -621,7 +615,7 @@ void ReadConfigFile(const std::string& confPath)\n             InterpretNegativeSetting(strKey, strValue);\n             if (mapArgs.count(strKey) == 0)\n                 mapArgs[strKey] = strValue;\n-            _mapMultiArgs[strKey].push_back(strValue);\n+            mapMultiArgs[strKey].push_back(strValue);\n         }\n     }\n     // If datadir is changed in .conf file:"
      },
      {
        "sha": "229478d83533b315acf4873364c67f60619dfd17",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 60,
        "deletions": 3,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -16,6 +16,7 @@\n \n #include \"compat.h\"\n #include \"fs.h\"\n+#include \"sync.h\"\n #include \"tinyformat.h\"\n #include \"utiltime.h\"\n \n@@ -41,7 +42,6 @@ class CTranslationInterface\n     boost::signals2::signal<std::string (const char* psz)> Translate;\n };\n \n-extern const std::map<std::string, std::vector<std::string> >& mapMultiArgs;\n extern bool fPrintToConsole;\n extern bool fPrintToDebugLog;\n \n@@ -148,7 +148,6 @@ bool error(const char* fmt, const Args&... args)\n }\n \n void PrintExceptionContinue(const std::exception *pex, const char* pszThread);\n-void ParseParameters(int argc, const char*const argv[]);\n void FileCommit(FILE *file);\n bool TruncateFile(FILE *file, unsigned int length);\n int RaiseFileDescriptorLimit(int nMinFD);\n@@ -163,7 +162,6 @@ fs::path GetConfigFile(const std::string& confPath);\n fs::path GetPidFile();\n void CreatePidFile(const fs::path &path, pid_t pid);\n #endif\n-void ReadConfigFile(const std::string& confPath);\n #ifdef WIN32\n fs::path GetSpecialFolderPath(int nFolder, bool fCreate = true);\n #endif\n@@ -180,6 +178,16 @@ inline bool IsSwitchChar(char c)\n #endif\n }\n \n+class ArgsManager\n+{\n+protected:\n+    CCriticalSection cs_args;\n+    std::map<std::string, std::string> mapArgs;\n+    std::map<std::string, std::vector<std::string> > mapMultiArgs;\n+public:\n+    void ParseParameters(int argc, const char*const argv[]);\n+    void ReadConfigFile(const std::string& confPath);\n+    std::vector<std::string> GetArgs(const std::string& strArg);\n /**\n  * Return true if the given argument has been manually set\n  *\n@@ -235,6 +243,55 @@ bool SoftSetBoolArg(const std::string& strArg, bool fValue);\n \n // Forces a arg setting, used only in testing\n void ForceSetArg(const std::string& strArg, const std::string& strValue);\n+};\n+\n+extern ArgsManager gArgs;\n+\n+// wrappers using the global ArgsManager:\n+static inline void ParseParameters(int argc, const char*const argv[])\n+{\n+    gArgs.ParseParameters(argc, argv);\n+}\n+\n+static inline void ReadConfigFile(const std::string& confPath)\n+{\n+    gArgs.ReadConfigFile(confPath);\n+}\n+\n+static inline bool SoftSetArg(const std::string& strArg, const std::string& strValue)\n+{\n+    return gArgs.SoftSetArg(strArg, strValue);\n+}\n+\n+static inline void ForceSetArg(const std::string& strArg, const std::string& strValue)\n+{\n+    gArgs.ForceSetArg(strArg, strValue);\n+}\n+\n+static inline bool IsArgSet(const std::string& strArg)\n+{\n+    return gArgs.IsArgSet(strArg);\n+}\n+\n+static inline std::string GetArg(const std::string& strArg, const std::string& strDefault)\n+{\n+    return gArgs.GetArg(strArg, strDefault);\n+}\n+\n+static inline int64_t GetArg(const std::string& strArg, int64_t nDefault)\n+{\n+    return gArgs.GetArg(strArg, nDefault);\n+}\n+\n+static inline bool GetBoolArg(const std::string& strArg, bool fDefault)\n+{\n+    return gArgs.GetBoolArg(strArg, fDefault);\n+}\n+\n+static inline bool SoftSetBoolArg(const std::string& strArg, bool fValue)\n+{\n+    return gArgs.SoftSetBoolArg(strArg, fValue);\n+}\n \n /**\n  * Format a string to be used as group of options in help messages"
      },
      {
        "sha": "e07069125d20a37e8eddf2e1f06a8be9df6955ad",
        "filename": "src/utiltime.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/utiltime.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/utiltime.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utiltime.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -9,14 +9,17 @@\n \n #include \"utiltime.h\"\n \n+#include <atomic>\n+\n #include <boost/date_time/posix_time/posix_time.hpp>\n #include <boost/thread.hpp>\n \n-static int64_t nMockTime = 0; //!< For unit testing\n+static std::atomic<int64_t> nMockTime(0); //!< For unit testing\n \n int64_t GetTime()\n {\n-    if (nMockTime) return nMockTime;\n+    int64_t mocktime = nMockTime.load(std::memory_order_relaxed);\n+    if (mocktime) return mocktime;\n \n     time_t now = time(NULL);\n     assert(now > 0);\n@@ -25,7 +28,12 @@ int64_t GetTime()\n \n void SetMockTime(int64_t nMockTimeIn)\n {\n-    nMockTime = nMockTimeIn;\n+    nMockTime.store(nMockTimeIn, std::memory_order_relaxed);\n+}\n+\n+int64_t GetMockTime()\n+{\n+    return nMockTime.load(std::memory_order_relaxed);\n }\n \n int64_t GetTimeMillis()\n@@ -49,14 +57,6 @@ int64_t GetSystemTimeInSeconds()\n     return GetTimeMicros()/1000000;\n }\n \n-/** Return a time useful for the debug log */\n-int64_t GetLogTimeMicros()\n-{\n-    if (nMockTime) return nMockTime*1000000;\n-\n-    return GetTimeMicros();\n-}\n-\n void MilliSleep(int64_t n)\n {\n "
      },
      {
        "sha": "8ae8540b89c7090ccae8b3db516e67530cc765e8",
        "filename": "src/utiltime.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/utiltime.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/utiltime.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utiltime.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -23,8 +23,8 @@ int64_t GetTime();\n int64_t GetTimeMillis();\n int64_t GetTimeMicros();\n int64_t GetSystemTimeInSeconds(); // Like GetTime(), but not mockable\n-int64_t GetLogTimeMicros();\n void SetMockTime(int64_t nMockTimeIn);\n+int64_t GetMockTime();\n void MilliSleep(int64_t n);\n \n std::string DateTimeStrFormat(const char* pszFormat, int64_t nTime);"
      },
      {
        "sha": "ac16af3ee776a0a2070c938d1db6e4c4672235b8",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 281,
        "changes": 335,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -6,11 +6,13 @@\n #include \"validation.h\"\n \n #include \"arith_uint256.h\"\n+#include \"chain.h\"\n #include \"chainparams.h\"\n #include \"checkpoints.h\"\n #include \"checkqueue.h\"\n #include \"consensus/consensus.h\"\n #include \"consensus/merkle.h\"\n+#include \"consensus/tx_verify.h\"\n #include \"consensus/validation.h\"\n #include \"fs.h\"\n #include \"hash.h\"\n@@ -80,7 +82,8 @@ uint256 hashAssumeValid;\n CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE);\n CAmount maxTxFee = DEFAULT_TRANSACTION_MAXFEE;\n \n-CTxMemPool mempool;\n+CBlockPolicyEstimator feeEstimator;\n+CTxMemPool mempool(&feeEstimator);\n \n static void CheckBlockIndex(const Consensus::Params& consensusParams);\n \n@@ -186,19 +189,6 @@ enum FlushStateMode {\n bool static FlushStateToDisk(CValidationState &state, FlushStateMode mode, int nManualPruneHeight=0);\n void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight);\n \n-bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime)\n-{\n-    if (tx.nLockTime == 0)\n-        return true;\n-    if ((int64_t)tx.nLockTime < ((int64_t)tx.nLockTime < LOCKTIME_THRESHOLD ? (int64_t)nBlockHeight : nBlockTime))\n-        return true;\n-    for (const auto& txin : tx.vin) {\n-        if (!(txin.nSequence == CTxIn::SEQUENCE_FINAL))\n-            return false;\n-    }\n-    return true;\n-}\n-\n bool CheckFinalTx(const CTransaction &tx, int flags)\n {\n     AssertLockHeld(cs_main);\n@@ -231,89 +221,6 @@ bool CheckFinalTx(const CTransaction &tx, int flags)\n     return IsFinalTx(tx, nBlockHeight, nBlockTime);\n }\n \n-/**\n- * Calculates the block height and previous block's median time past at\n- * which the transaction will be considered final in the context of BIP 68.\n- * Also removes from the vector of input heights any entries which did not\n- * correspond to sequence locked inputs as they do not affect the calculation.\n- */\n-static std::pair<int, int64_t> CalculateSequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block)\n-{\n-    assert(prevHeights->size() == tx.vin.size());\n-\n-    // Will be set to the equivalent height- and time-based nLockTime\n-    // values that would be necessary to satisfy all relative lock-\n-    // time constraints given our view of block chain history.\n-    // The semantics of nLockTime are the last invalid height/time, so\n-    // use -1 to have the effect of any height or time being valid.\n-    int nMinHeight = -1;\n-    int64_t nMinTime = -1;\n-\n-    // tx.nVersion is signed integer so requires cast to unsigned otherwise\n-    // we would be doing a signed comparison and half the range of nVersion\n-    // wouldn't support BIP 68.\n-    bool fEnforceBIP68 = static_cast<uint32_t>(tx.nVersion) >= 2\n-                      && flags & LOCKTIME_VERIFY_SEQUENCE;\n-\n-    // Do not enforce sequence numbers as a relative lock time\n-    // unless we have been instructed to\n-    if (!fEnforceBIP68) {\n-        return std::make_pair(nMinHeight, nMinTime);\n-    }\n-\n-    for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n-        const CTxIn& txin = tx.vin[txinIndex];\n-\n-        // Sequence numbers with the most significant bit set are not\n-        // treated as relative lock-times, nor are they given any\n-        // consensus-enforced meaning at this point.\n-        if (txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n-            // The height of this input is not relevant for sequence locks\n-            (*prevHeights)[txinIndex] = 0;\n-            continue;\n-        }\n-\n-        int nCoinHeight = (*prevHeights)[txinIndex];\n-\n-        if (txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG) {\n-            int64_t nCoinTime = block.GetAncestor(std::max(nCoinHeight-1, 0))->GetMedianTimePast();\n-            // NOTE: Subtract 1 to maintain nLockTime semantics\n-            // BIP 68 relative lock times have the semantics of calculating\n-            // the first block or time at which the transaction would be\n-            // valid. When calculating the effective block time or height\n-            // for the entire transaction, we switch to using the\n-            // semantics of nLockTime which is the last invalid block\n-            // time or height.  Thus we subtract 1 from the calculated\n-            // time or height.\n-\n-            // Time-based relative lock-times are measured from the\n-            // smallest allowed timestamp of the block containing the\n-            // txout being spent, which is the median time past of the\n-            // block prior.\n-            nMinTime = std::max(nMinTime, nCoinTime + (int64_t)((txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_MASK) << CTxIn::SEQUENCE_LOCKTIME_GRANULARITY) - 1);\n-        } else {\n-            nMinHeight = std::max(nMinHeight, nCoinHeight + (int)(txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_MASK) - 1);\n-        }\n-    }\n-\n-    return std::make_pair(nMinHeight, nMinTime);\n-}\n-\n-static bool EvaluateSequenceLocks(const CBlockIndex& block, std::pair<int, int64_t> lockPair)\n-{\n-    assert(block.pprev);\n-    int64_t nBlockTime = block.pprev->GetMedianTimePast();\n-    if (lockPair.first >= block.nHeight || lockPair.second >= nBlockTime)\n-        return false;\n-\n-    return true;\n-}\n-\n-bool SequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block)\n-{\n-    return EvaluateSequenceLocks(block, CalculateSequenceLocks(tx, flags, prevHeights, block));\n-}\n-\n bool TestLockPointValidity(const LockPoints* lp)\n {\n     AssertLockHeld(cs_main);\n@@ -402,108 +309,6 @@ bool CheckSequenceLocks(const CTransaction &tx, int flags, LockPoints* lp, bool\n     return EvaluateSequenceLocks(index, lockPair);\n }\n \n-\n-unsigned int GetLegacySigOpCount(const CTransaction& tx)\n-{\n-    unsigned int nSigOps = 0;\n-    for (const auto& txin : tx.vin)\n-    {\n-        nSigOps += txin.scriptSig.GetSigOpCount(false);\n-    }\n-    for (const auto& txout : tx.vout)\n-    {\n-        nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n-    }\n-    return nSigOps;\n-}\n-\n-unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& inputs)\n-{\n-    if (tx.IsCoinBase())\n-        return 0;\n-\n-    unsigned int nSigOps = 0;\n-    for (unsigned int i = 0; i < tx.vin.size(); i++)\n-    {\n-        const CTxOut &prevout = inputs.GetOutputFor(tx.vin[i]);\n-        if (prevout.scriptPubKey.IsPayToScriptHash())\n-            nSigOps += prevout.scriptPubKey.GetSigOpCount(tx.vin[i].scriptSig);\n-    }\n-    return nSigOps;\n-}\n-\n-int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, int flags)\n-{\n-    int64_t nSigOps = GetLegacySigOpCount(tx) * WITNESS_SCALE_FACTOR;\n-\n-    if (tx.IsCoinBase())\n-        return nSigOps;\n-\n-    if (flags & SCRIPT_VERIFY_P2SH) {\n-        nSigOps += GetP2SHSigOpCount(tx, inputs) * WITNESS_SCALE_FACTOR;\n-    }\n-\n-    for (unsigned int i = 0; i < tx.vin.size(); i++)\n-    {\n-        const CTxOut &prevout = inputs.GetOutputFor(tx.vin[i]);\n-        nSigOps += CountWitnessSigOps(tx.vin[i].scriptSig, prevout.scriptPubKey, &tx.vin[i].scriptWitness, flags);\n-    }\n-    return nSigOps;\n-}\n-\n-\n-\n-\n-\n-bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fCheckDuplicateInputs)\n-{\n-    // Basic checks that don't depend on any context\n-    if (tx.vin.empty())\n-        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n-    if (tx.vout.empty())\n-        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n-    // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)\n-    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) > MAX_BLOCK_BASE_SIZE)\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-oversize\");\n-\n-    // Check for negative or overflow output values\n-    CAmount nValueOut = 0;\n-    for (const auto& txout : tx.vout)\n-    {\n-        if (txout.nValue < 0)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-negative\");\n-        if (txout.nValue > MAX_MONEY)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n-        nValueOut += txout.nValue;\n-        if (!MoneyRange(nValueOut))\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n-    }\n-\n-    // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n-    if (fCheckDuplicateInputs) {\n-        std::set<COutPoint> vInOutPoints;\n-        for (const auto& txin : tx.vin)\n-        {\n-            if (!vInOutPoints.insert(txin.prevout).second)\n-                return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n-        }\n-    }\n-\n-    if (tx.IsCoinBase())\n-    {\n-        if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-length\");\n-    }\n-    else\n-    {\n-        for (const auto& txin : tx.vin)\n-            if (txin.prevout.IsNull())\n-                return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n-    }\n-\n-    return true;\n-}\n-\n void LimitMempoolSize(CTxMemPool& pool, size_t limit, unsigned long age) {\n     int expired = pool.Expire(GetTime() - age);\n     if (expired != 0) {\n@@ -1139,6 +944,7 @@ bool IsInitialBlockDownload()\n         return true;\n     if (chainActive.Tip()->GetBlockTime() < (GetTime() - nMaxTipAge))\n         return true;\n+    LogPrintf(\"Leaving InitialBlockDownload (latching to false)\\n\");\n     latchToFalse.store(true, std::memory_order_relaxed);\n     return false;\n }\n@@ -1297,10 +1103,7 @@ void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, int nHeight)\n bool CScriptCheck::operator()() {\n     const CScript &scriptSig = ptxTo->vin[nIn].scriptSig;\n     const CScriptWitness *witness = &ptxTo->vin[nIn].scriptWitness;\n-    if (!VerifyScript(scriptSig, scriptPubKey, witness, nFlags, CachingTransactionSignatureChecker(ptxTo, nIn, amount, cacheStore, *txdata), &error)) {\n-        return false;\n-    }\n-    return true;\n+    return VerifyScript(scriptSig, scriptPubKey, witness, nFlags, CachingTransactionSignatureChecker(ptxTo, nIn, amount, cacheStore, *txdata), &error);\n }\n \n int GetSpendHeight(const CCoinsViewCache& inputs)\n@@ -1310,52 +1113,6 @@ int GetSpendHeight(const CCoinsViewCache& inputs)\n     return pindexPrev->nHeight + 1;\n }\n \n-namespace Consensus {\n-bool CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoinsViewCache& inputs, int nSpendHeight)\n-{\n-        // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n-        // for an attacker to attempt to split the network.\n-        if (!inputs.HaveInputs(tx))\n-            return state.Invalid(false, 0, \"\", \"Inputs unavailable\");\n-\n-        CAmount nValueIn = 0;\n-        CAmount nFees = 0;\n-        for (unsigned int i = 0; i < tx.vin.size(); i++)\n-        {\n-            const COutPoint &prevout = tx.vin[i].prevout;\n-            const CCoins *coins = inputs.AccessCoins(prevout.hash);\n-            assert(coins);\n-\n-            // If prev is coinbase, check that it's matured\n-            if (coins->IsCoinBase()) {\n-                if (nSpendHeight - coins->nHeight < COINBASE_MATURITY)\n-                    return state.Invalid(false,\n-                        REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n-                        strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coins->nHeight));\n-            }\n-\n-            // Check for negative or overflow input values\n-            nValueIn += coins->vout[prevout.n].nValue;\n-            if (!MoneyRange(coins->vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n-                return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n-\n-        }\n-\n-        if (nValueIn < tx.GetValueOut())\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-in-belowout\", false,\n-                strprintf(\"value in (%s) < value out (%s)\", FormatMoney(nValueIn), FormatMoney(tx.GetValueOut())));\n-\n-        // Tally transaction fees\n-        CAmount nTxFee = nValueIn - tx.GetValueOut();\n-        if (nTxFee < 0)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-fee-negative\");\n-        nFees += nTxFee;\n-        if (!MoneyRange(nFees))\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n-    return true;\n-}\n-}// namespace Consensus\n-\n bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)\n {\n     if (!tx.IsCoinBase())\n@@ -1524,28 +1281,36 @@ bool ApplyTxInUndo(const CTxInUndo& undo, CCoinsViewCache& view, const COutPoint\n     return fClean;\n }\n \n+enum DisconnectResult\n+{\n+    DISCONNECT_OK,      // All good.\n+    DISCONNECT_UNCLEAN, // Rolled back, but UTXO set was inconsistent with block.\n+    DISCONNECT_FAILED   // Something else went wrong.\n+};\n+\n /** Undo the effects of this block (with given index) on the UTXO set represented by coins.\n- *  In case pfClean is provided, operation will try to be tolerant about errors, and *pfClean\n- *  will be true if no problems were found. Otherwise, the return value will be false in case\n- *  of problems. Note that in any case, coins may be modified. */\n-static bool DisconnectBlock(const CBlock& block, CValidationState& state, const CBlockIndex* pindex, CCoinsViewCache& view, bool* pfClean = NULL)\n+ *  When UNCLEAN or FAILED is returned, view is left in an indeterminate state. */\n+static DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex* pindex, CCoinsViewCache& view)\n {\n     assert(pindex->GetBlockHash() == view.GetBestBlock());\n \n-    if (pfClean)\n-        *pfClean = false;\n-\n     bool fClean = true;\n \n     CBlockUndo blockUndo;\n     CDiskBlockPos pos = pindex->GetUndoPos();\n-    if (pos.IsNull())\n-        return error(\"DisconnectBlock(): no undo data available\");\n-    if (!UndoReadFromDisk(blockUndo, pos, pindex->pprev->GetBlockHash()))\n-        return error(\"DisconnectBlock(): failure reading undo data\");\n+    if (pos.IsNull()) {\n+        error(\"DisconnectBlock(): no undo data available\");\n+        return DISCONNECT_FAILED;\n+    }\n+    if (!UndoReadFromDisk(blockUndo, pos, pindex->pprev->GetBlockHash())) {\n+        error(\"DisconnectBlock(): failure reading undo data\");\n+        return DISCONNECT_FAILED;\n+    }\n \n-    if (blockUndo.vtxundo.size() + 1 != block.vtx.size())\n-        return error(\"DisconnectBlock(): block and undo data inconsistent\");\n+    if (blockUndo.vtxundo.size() + 1 != block.vtx.size()) {\n+        error(\"DisconnectBlock(): block and undo data inconsistent\");\n+        return DISCONNECT_FAILED;\n+    }\n \n     // undo transactions in reverse order\n     for (int i = block.vtx.size() - 1; i >= 0; i--) {\n@@ -1574,8 +1339,10 @@ static bool DisconnectBlock(const CBlock& block, CValidationState& state, const\n         // restore inputs\n         if (i > 0) { // not coinbases\n             const CTxUndo &txundo = blockUndo.vtxundo[i-1];\n-            if (txundo.vprevout.size() != tx.vin.size())\n-                return error(\"DisconnectBlock(): transaction and undo data inconsistent\");\n+            if (txundo.vprevout.size() != tx.vin.size()) {\n+                error(\"DisconnectBlock(): transaction and undo data inconsistent\");\n+                return DISCONNECT_FAILED;\n+            }\n             for (unsigned int j = tx.vin.size(); j-- > 0;) {\n                 const COutPoint &out = tx.vin[j].prevout;\n                 const CTxInUndo &undo = txundo.vprevout[j];\n@@ -1588,12 +1355,7 @@ static bool DisconnectBlock(const CBlock& block, CValidationState& state, const\n     // move best block pointer to prevout block\n     view.SetBestBlock(pindex->pprev->GetBlockHash());\n \n-    if (pfClean) {\n-        *pfClean = fClean;\n-        return true;\n-    }\n-\n-    return fClean;\n+    return fClean ? DISCONNECT_OK : DISCONNECT_UNCLEAN;\n }\n \n void static FlushBlockFile(bool fFinalize = false)\n@@ -2129,7 +1891,7 @@ bool static DisconnectTip(CValidationState& state, const CChainParams& chainpara\n     int64_t nStart = GetTimeMicros();\n     {\n         CCoinsViewCache view(pcoinsTip);\n-        if (!DisconnectBlock(block, state, pindexDelete, view))\n+        if (DisconnectBlock(block, pindexDelete, view) != DISCONNECT_OK)\n             return error(\"DisconnectTip(): DisconnectBlock %s failed\", pindexDelete->GetBlockHash().ToString());\n         bool flushed = view.Flush();\n         assert(flushed);\n@@ -2535,6 +2297,9 @@ bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams,\n         return false;\n     }\n \n+    int nStopAtHeight = GetArg(\"-stopatheight\", DEFAULT_STOPATHEIGHT);\n+    if (nStopAtHeight && pindexNewTip && pindexNewTip->nHeight >= nStopAtHeight) StartShutdown();\n+\n     return true;\n }\n \n@@ -2677,15 +2442,15 @@ CBlockIndex* AddToBlockIndex(const CBlockHeader& block)\n }\n \n /** Mark a block as having its data received and checked (up to BLOCK_VALID_TRANSACTIONS). */\n-bool ReceivedBlockTransactions(const CBlock &block, CValidationState& state, CBlockIndex *pindexNew, const CDiskBlockPos& pos)\n+static bool ReceivedBlockTransactions(const CBlock &block, CValidationState& state, CBlockIndex *pindexNew, const CDiskBlockPos& pos, const Consensus::Params& consensusParams)\n {\n     pindexNew->nTx = block.vtx.size();\n     pindexNew->nChainTx = 0;\n     pindexNew->nFile = pos.nFile;\n     pindexNew->nDataPos = pos.nPos;\n     pindexNew->nUndoPos = 0;\n     pindexNew->nStatus |= BLOCK_HAVE_DATA;\n-    if (IsWitnessEnabled(pindexNew->pprev, Params().GetConsensus())) {\n+    if (IsWitnessEnabled(pindexNew->pprev, consensusParams)) {\n         pindexNew->nStatus |= BLOCK_OPT_WITNESS;\n     }\n     pindexNew->RaiseValidity(BLOCK_VALID_TRANSACTIONS);\n@@ -3051,8 +2816,8 @@ bool ContextualCheckBlock(const CBlock& block, CValidationState& state, const Co\n \n     // No witness data is allowed in blocks that don't commit to witness data, as this would otherwise leave room for spam\n     if (!fHaveWitness) {\n-        for (size_t i = 0; i < block.vtx.size(); i++) {\n-            if (block.vtx[i]->HasWitness()) {\n+      for (const auto& tx : block.vtx) {\n+            if (tx->HasWitness()) {\n                 return state.DoS(100, false, REJECT_INVALID, \"unexpected-witness\", true, strprintf(\"%s : unexpected witness data found\", __func__));\n             }\n         }\n@@ -3207,7 +2972,7 @@ static bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidation\n         if (dbp == NULL)\n             if (!WriteBlockToDisk(block, blockPos, chainparams.MessageStart()))\n                 AbortNode(state, \"Failed to write block\");\n-        if (!ReceivedBlockTransactions(block, state, pindex, blockPos))\n+        if (!ReceivedBlockTransactions(block, state, pindex, blockPos, chainparams.GetConsensus()))\n             return error(\"AcceptBlock(): ReceivedBlockTransactions failed\");\n     } catch (const std::runtime_error& e) {\n         return AbortNode(state, std::string(\"System error: \") + e.what());\n@@ -3654,15 +3419,17 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n         }\n         // check level 3: check for inconsistencies during memory-only disconnect of tip blocks\n         if (nCheckLevel >= 3 && pindex == pindexState && (coins.DynamicMemoryUsage() + pcoinsTip->DynamicMemoryUsage()) <= nCoinCacheUsage) {\n-            bool fClean = true;\n-            if (!DisconnectBlock(block, state, pindex, coins, &fClean))\n+            DisconnectResult res = DisconnectBlock(block, pindex, coins);\n+            if (res == DISCONNECT_FAILED) {\n                 return error(\"VerifyDB(): *** irrecoverable inconsistency in block data at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n+            }\n             pindexState = pindex->pprev;\n-            if (!fClean) {\n+            if (res == DISCONNECT_UNCLEAN) {\n                 nGoodTransactions = 0;\n                 pindexFailure = pindex;\n-            } else\n+            } else {\n                 nGoodTransactions += block.vtx.size();\n+            }\n         }\n         if (ShutdownRequested())\n             return true;\n@@ -3838,7 +3605,7 @@ bool InitBlockIndex(const CChainParams& chainparams)\n             if (!WriteBlockToDisk(block, blockPos, chainparams.MessageStart()))\n                 return error(\"LoadBlockIndex(): writing genesis block to disk failed\");\n             CBlockIndex *pindex = AddToBlockIndex(block);\n-            if (!ReceivedBlockTransactions(block, state, pindex, blockPos))\n+            if (!ReceivedBlockTransactions(block, state, pindex, blockPos, chainparams.GetConsensus()))\n                 return error(\"LoadBlockIndex(): genesis block not accepted\");\n             // Force a chainstate write so that when we VerifyDB in a moment, it doesn't check stale data\n             return FlushStateToDisk(state, FLUSH_STATE_ALWAYS);\n@@ -4167,6 +3934,12 @@ ThresholdState VersionBitsTipState(const Consensus::Params& params, Consensus::D\n     return VersionBitsState(chainActive.Tip(), params, pos, versionbitscache);\n }\n \n+BIP9Stats VersionBitsTipStatistics(const Consensus::Params& params, Consensus::DeploymentPos pos)\n+{\n+    LOCK(cs_main);\n+    return VersionBitsStatistics(chainActive.Tip(), params, pos);\n+}\n+\n int VersionBitsTipStateSinceHeight(const Consensus::Params& params, Consensus::DeploymentPos pos)\n {\n     LOCK(cs_main);"
      },
      {
        "sha": "b19c3ff4f7b34893c8abd429e747c9e4d00282d1",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 11,
        "deletions": 52,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -11,10 +11,10 @@\n #endif\n \n #include \"amount.h\"\n-#include \"chain.h\"\n #include \"coins.h\"\n #include \"fs.h\"\n #include \"protocol.h\" // For CMessageHeader::MessageStartChars\n+#include \"policy/feerate.h\"\n #include \"script/script_error.h\"\n #include \"sync.h\"\n #include \"versionbits.h\"\n@@ -39,6 +39,7 @@ class CChainParams;\n class CInv;\n class CConnman;\n class CScriptCheck;\n+class CBlockPolicyEstimator;\n class CTxMemPool;\n class CValidationInterface;\n class CValidationState;\n@@ -131,7 +132,8 @@ static const bool DEFAULT_PERMIT_BAREMULTISIG = true;\n static const bool DEFAULT_CHECKPOINTS_ENABLED = true;\n static const bool DEFAULT_TXINDEX = false;\n static const unsigned int DEFAULT_BANSCORE_THRESHOLD = 100;\n-\n+/** Default for -persistmempool */\n+static const bool DEFAULT_PERSIST_MEMPOOL = true;\n /** Default for -mempoolreplacement */\n static const bool DEFAULT_ENABLE_REPLACEMENT = true;\n /** Default for using fee filter */\n@@ -145,13 +147,17 @@ static const int MAX_UNCONNECTING_HEADERS = 10;\n \n static const bool DEFAULT_PEERBLOOMFILTERS = true;\n \n+/** Default for -stopatheight */\n+static const int DEFAULT_STOPATHEIGHT = 0;\n+\n struct BlockHasher\n {\n     size_t operator()(const uint256& hash) const { return hash.GetCheapHash(); }\n };\n \n extern CScript COINBASE_FLAGS;\n extern CCriticalSection cs_main;\n+extern CBlockPolicyEstimator feeEstimator;\n extern CTxMemPool mempool;\n typedef boost::unordered_map<uint256, CBlockIndex*, BlockHasher> BlockMap;\n extern BlockMap mapBlockIndex;\n@@ -333,33 +339,12 @@ std::string FormatStateMessage(const CValidationState &state);\n /** Get the BIP9 state for a given deployment at the current tip. */\n ThresholdState VersionBitsTipState(const Consensus::Params& params, Consensus::DeploymentPos pos);\n \n+/** Get the numerical statistics for the BIP9 state for a given deployment at the current tip. */\n+BIP9Stats VersionBitsTipStatistics(const Consensus::Params& params, Consensus::DeploymentPos pos);\n+\n /** Get the block height at which the BIP9 deployment switched into the state for the block building on the current tip. */\n int VersionBitsTipStateSinceHeight(const Consensus::Params& params, Consensus::DeploymentPos pos);\n \n-/** \n- * Count ECDSA signature operations the old-fashioned (pre-0.6) way\n- * @return number of sigops this transaction's outputs will produce when spent\n- * @see CTransaction::FetchInputs\n- */\n-unsigned int GetLegacySigOpCount(const CTransaction& tx);\n-\n-/**\n- * Count ECDSA signature operations in pay-to-script-hash inputs.\n- * \n- * @param[in] mapInputs Map of previous transactions that have outputs we're spending\n- * @return maximum number of sigops required to validate this transaction's inputs\n- * @see CTransaction::FetchInputs\n- */\n-unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& mapInputs);\n-\n-/**\n- * Compute total signature operation cost of a transaction.\n- * @param[in] tx     Transaction for which we are computing the cost\n- * @param[in] inputs Map of previous transactions that have outputs we're spending\n- * @param[out] flags Script verification flags\n- * @return Total signature operation cost of tx\n- */\n-int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, int flags);\n \n /**\n  * Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)\n@@ -374,26 +359,6 @@ void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, int nHeight);\n \n /** Transaction validation functions */\n \n-/** Context-independent validity checks */\n-bool CheckTransaction(const CTransaction& tx, CValidationState& state, bool fCheckDuplicateInputs=true);\n-\n-namespace Consensus {\n-\n-/**\n- * Check whether all inputs of this transaction are valid (no double spends and amounts)\n- * This does not modify the UTXO set. This does not check scripts and sigs.\n- * Preconditions: tx.IsCoinBase() is false.\n- */\n-bool CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoinsViewCache& inputs, int nSpendHeight);\n-\n-} // namespace Consensus\n-\n-/**\n- * Check if transaction is final and can be included in a block with the\n- * specified height and time. Consensus critical.\n- */\n-bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime);\n-\n /**\n  * Check if transaction will be final in the next block to be created.\n  *\n@@ -408,12 +373,6 @@ bool CheckFinalTx(const CTransaction &tx, int flags = -1);\n  */\n bool TestLockPointValidity(const LockPoints* lp);\n \n-/**\n- * Check if transaction is final per BIP 68 sequence numbers and can be included in a block.\n- * Consensus critical. Takes as input a list of heights at which tx's inputs (in order) confirmed.\n- */\n-bool SequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block);\n-\n /**\n  * Check if transaction will be BIP 68 final in the next block to be created.\n  *"
      },
      {
        "sha": "80786233f5acddbf74ef22ef9449384fb94d765e",
        "filename": "src/versionbits.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 1,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/versionbits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/versionbits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -3,7 +3,6 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"versionbits.h\"\n-\n #include \"consensus/params.h\"\n \n const struct BIP9DeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_BITS_DEPLOYMENTS] = {\n@@ -105,6 +104,36 @@ ThresholdState AbstractThresholdConditionChecker::GetStateFor(const CBlockIndex*\n     return state;\n }\n \n+// return the numerical statistics of blocks signalling the specified BIP9 condition in this current period\n+BIP9Stats AbstractThresholdConditionChecker::GetStateStatisticsFor(const CBlockIndex* pindex, const Consensus::Params& params) const\n+{\n+    BIP9Stats stats;\n+\n+    stats.period = Period(params);\n+    stats.threshold = Threshold(params);\n+\n+    if (pindex == NULL)\n+        return stats;\n+\n+    // Find beginning of period\n+    const CBlockIndex* pindexEndOfPrevPeriod = pindex->GetAncestor(pindex->nHeight - ((pindex->nHeight + 1) % stats.period));\n+    stats.elapsed = pindex->nHeight - pindexEndOfPrevPeriod->nHeight;\n+\n+    // Count from current block to beginning of period\n+    int count = 0;\n+    const CBlockIndex* currentIndex = pindex;\n+    while (pindexEndOfPrevPeriod->nHeight != currentIndex->nHeight){\n+        if (Condition(currentIndex, params))\n+            count++;\n+        currentIndex = currentIndex->pprev;\n+    }\n+\n+    stats.count = count;\n+    stats.possible = (stats.period - stats.threshold ) >= (stats.elapsed - count);\n+\n+    return stats;\n+}\n+\n int AbstractThresholdConditionChecker::GetStateSinceHeightFor(const CBlockIndex* pindexPrev, const Consensus::Params& params, ThresholdConditionCache& cache) const\n {\n     const ThresholdState initialState = GetStateFor(pindexPrev, params, cache);\n@@ -167,6 +196,11 @@ ThresholdState VersionBitsState(const CBlockIndex* pindexPrev, const Consensus::\n     return VersionBitsConditionChecker(pos).GetStateFor(pindexPrev, params, cache.caches[pos]);\n }\n \n+BIP9Stats VersionBitsStatistics(const CBlockIndex* pindexPrev, const Consensus::Params& params, Consensus::DeploymentPos pos)\n+{\n+    return VersionBitsConditionChecker(pos).GetStateStatisticsFor(pindexPrev, params);\n+}\n+\n int VersionBitsStateSinceHeight(const CBlockIndex* pindexPrev, const Consensus::Params& params, Consensus::DeploymentPos pos, VersionBitsCache& cache)\n {\n     return VersionBitsConditionChecker(pos).GetStateSinceHeightFor(pindexPrev, params, cache.caches[pos]);"
      },
      {
        "sha": "f1d31ea0af9648299d657cc3898511cf794dc8ae",
        "filename": "src/versionbits.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/versionbits.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/versionbits.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -37,6 +37,14 @@ struct BIP9DeploymentInfo {\n     bool gbt_force;\n };\n \n+struct BIP9Stats {\n+    int period;\n+    int threshold;\n+    int elapsed;\n+    int count;\n+    bool possible;\n+};\n+\n extern const struct BIP9DeploymentInfo VersionBitsDeploymentInfo[];\n \n /**\n@@ -51,6 +59,7 @@ class AbstractThresholdConditionChecker {\n     virtual int Threshold(const Consensus::Params& params) const =0;\n \n public:\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindex, const Consensus::Params& params) const;\n     // Note that the functions below take a pindexPrev as input: they compute information for block B based on its parent.\n     ThresholdState GetStateFor(const CBlockIndex* pindexPrev, const Consensus::Params& params, ThresholdConditionCache& cache) const;\n     int GetStateSinceHeightFor(const CBlockIndex* pindexPrev, const Consensus::Params& params, ThresholdConditionCache& cache) const;\n@@ -64,6 +73,7 @@ struct VersionBitsCache\n };\n \n ThresholdState VersionBitsState(const CBlockIndex* pindexPrev, const Consensus::Params& params, Consensus::DeploymentPos pos, VersionBitsCache& cache);\n+BIP9Stats VersionBitsStatistics(const CBlockIndex* pindexPrev, const Consensus::Params& params, Consensus::DeploymentPos pos);\n int VersionBitsStateSinceHeight(const CBlockIndex* pindexPrev, const Consensus::Params& params, Consensus::DeploymentPos pos, VersionBitsCache& cache);\n uint32_t VersionBitsMask(const Consensus::Params& params, Consensus::DeploymentPos pos);\n "
      },
      {
        "sha": "cb4719ae90c01710f27ee77488680a365d081b84",
        "filename": "src/wallet/coincontrol.h",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/coincontrol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/coincontrol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coincontrol.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -5,6 +5,7 @@\n #ifndef BITCOIN_WALLET_COINCONTROL_H\n #define BITCOIN_WALLET_COINCONTROL_H\n \n+#include \"policy/feerate.h\"\n #include \"primitives/transaction.h\"\n #include \"wallet/wallet.h\"\n \n@@ -17,8 +18,6 @@ class CCoinControl\n     bool fAllowOtherInputs;\n     //! Includes watch only addresses which match the ISMINE_WATCH_SOLVABLE criteria\n     bool fAllowWatchOnly;\n-    //! Minimum absolute fee (not per kilobyte)\n-    CAmount nMinimumTotalFee;\n     //! Override estimated feerate\n     bool fOverrideFeeRate;\n     //! Feerate to use if overrideFeeRate is true\n@@ -39,7 +38,6 @@ class CCoinControl\n         fAllowOtherInputs = false;\n         fAllowWatchOnly = false;\n         setSelected.clear();\n-        nMinimumTotalFee = 0;\n         nFeeRate = CFeeRate(0);\n         fOverrideFeeRate = false;\n         nConfirmTarget = 0;"
      },
      {
        "sha": "25f6bdd9d939a2a0d4673aa867ca9514a579700d",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 94,
        "deletions": 41,
        "changes": 135,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -359,31 +359,34 @@ void CDBEnv::CheckpointLSN(const std::string& strFile)\n }\n \n \n-CDB::CDB(const std::string& strFilename, const char* pszMode, bool fFlushOnCloseIn) : pdb(NULL), activeTxn(NULL)\n+CDB::CDB(CWalletDBWrapper& dbw, const char* pszMode, bool fFlushOnCloseIn) : pdb(NULL), activeTxn(NULL)\n {\n     int ret;\n     fReadOnly = (!strchr(pszMode, '+') && !strchr(pszMode, 'w'));\n     fFlushOnClose = fFlushOnCloseIn;\n-    if (strFilename.empty())\n+    env = dbw.env;\n+    if (dbw.IsDummy()) {\n         return;\n+    }\n+    const std::string &strFilename = dbw.strFile;\n \n     bool fCreate = strchr(pszMode, 'c') != NULL;\n     unsigned int nFlags = DB_THREAD;\n     if (fCreate)\n         nFlags |= DB_CREATE;\n \n     {\n-        LOCK(bitdb.cs_db);\n-        if (!bitdb.Open(GetDataDir()))\n+        LOCK(env->cs_db);\n+        if (!env->Open(GetDataDir()))\n             throw std::runtime_error(\"CDB: Failed to open database environment.\");\n \n         strFile = strFilename;\n-        ++bitdb.mapFileUseCount[strFile];\n-        pdb = bitdb.mapDb[strFile];\n+        ++env->mapFileUseCount[strFile];\n+        pdb = env->mapDb[strFile];\n         if (pdb == NULL) {\n-            pdb = new Db(bitdb.dbenv, 0);\n+            pdb = new Db(env->dbenv, 0);\n \n-            bool fMockDb = bitdb.IsMock();\n+            bool fMockDb = env->IsMock();\n             if (fMockDb) {\n                 DbMpoolFile* mpf = pdb->get_mpf();\n                 ret = mpf->set_flags(DB_MPOOL_NOFILE, 1);\n@@ -401,7 +404,7 @@ CDB::CDB(const std::string& strFilename, const char* pszMode, bool fFlushOnClose\n             if (ret != 0) {\n                 delete pdb;\n                 pdb = NULL;\n-                --bitdb.mapFileUseCount[strFile];\n+                --env->mapFileUseCount[strFile];\n                 strFile = \"\";\n                 throw std::runtime_error(strprintf(\"CDB: Error %d, can't open database %s\", ret, strFilename));\n             }\n@@ -413,7 +416,7 @@ CDB::CDB(const std::string& strFilename, const char* pszMode, bool fFlushOnClose\n                 fReadOnly = fTmp;\n             }\n \n-            bitdb.mapDb[strFile] = pdb;\n+            env->mapDb[strFile] = pdb;\n         }\n     }\n }\n@@ -428,7 +431,7 @@ void CDB::Flush()\n     if (fReadOnly)\n         nMinutes = 1;\n \n-    bitdb.dbenv->txn_checkpoint(nMinutes ? GetArg(\"-dblogsize\", DEFAULT_WALLET_DBLOGSIZE) * 1024 : 0, nMinutes, 0);\n+    env->dbenv->txn_checkpoint(nMinutes ? GetArg(\"-dblogsize\", DEFAULT_WALLET_DBLOGSIZE) * 1024 : 0, nMinutes, 0);\n }\n \n void CDB::Close()\n@@ -444,8 +447,8 @@ void CDB::Close()\n         Flush();\n \n     {\n-        LOCK(bitdb.cs_db);\n-        --bitdb.mapFileUseCount[strFile];\n+        LOCK(env->cs_db);\n+        --env->mapFileUseCount[strFile];\n     }\n }\n \n@@ -463,32 +466,28 @@ void CDBEnv::CloseDb(const std::string& strFile)\n     }\n }\n \n-bool CDBEnv::RemoveDb(const std::string& strFile)\n-{\n-    this->CloseDb(strFile);\n-\n-    LOCK(cs_db);\n-    int rc = dbenv->dbremove(NULL, strFile.c_str(), NULL, DB_AUTO_COMMIT);\n-    return (rc == 0);\n-}\n-\n-bool CDB::Rewrite(const std::string& strFile, const char* pszSkip)\n+bool CDB::Rewrite(CWalletDBWrapper& dbw, const char* pszSkip)\n {\n+    if (dbw.IsDummy()) {\n+        return true;\n+    }\n+    CDBEnv *env = dbw.env;\n+    const std::string& strFile = dbw.strFile;\n     while (true) {\n         {\n-            LOCK(bitdb.cs_db);\n-            if (!bitdb.mapFileUseCount.count(strFile) || bitdb.mapFileUseCount[strFile] == 0) {\n+            LOCK(env->cs_db);\n+            if (!env->mapFileUseCount.count(strFile) || env->mapFileUseCount[strFile] == 0) {\n                 // Flush log data to the dat file\n-                bitdb.CloseDb(strFile);\n-                bitdb.CheckpointLSN(strFile);\n-                bitdb.mapFileUseCount.erase(strFile);\n+                env->CloseDb(strFile);\n+                env->CheckpointLSN(strFile);\n+                env->mapFileUseCount.erase(strFile);\n \n                 bool fSuccess = true;\n                 LogPrintf(\"CDB::Rewrite: Rewriting %s...\\n\", strFile);\n                 std::string strFileRes = strFile + \".rewrite\";\n                 { // surround usage of db with extra {}\n-                    CDB db(strFile.c_str(), \"r\");\n-                    Db* pdbCopy = new Db(bitdb.dbenv, 0);\n+                    CDB db(dbw, \"r\");\n+                    Db* pdbCopy = new Db(env->dbenv, 0);\n \n                     int ret = pdbCopy->open(NULL,               // Txn pointer\n                                             strFileRes.c_str(), // Filename\n@@ -531,17 +530,17 @@ bool CDB::Rewrite(const std::string& strFile, const char* pszSkip)\n                         }\n                     if (fSuccess) {\n                         db.Close();\n-                        bitdb.CloseDb(strFile);\n+                        env->CloseDb(strFile);\n                         if (pdbCopy->close(0))\n                             fSuccess = false;\n                         delete pdbCopy;\n                     }\n                 }\n                 if (fSuccess) {\n-                    Db dbA(bitdb.dbenv, 0);\n+                    Db dbA(env->dbenv, 0);\n                     if (dbA.remove(strFile.c_str(), NULL, 0))\n                         fSuccess = false;\n-                    Db dbB(bitdb.dbenv, 0);\n+                    Db dbB(env->dbenv, 0);\n                     if (dbB.rename(strFileRes.c_str(), NULL, strFile.c_str(), 0))\n                         fSuccess = false;\n                 }\n@@ -596,16 +595,21 @@ void CDBEnv::Flush(bool fShutdown)\n     }\n }\n \n-bool CDB::PeriodicFlush(std::string strFile)\n+bool CDB::PeriodicFlush(CWalletDBWrapper& dbw)\n {\n+    if (dbw.IsDummy()) {\n+        return true;\n+    }\n     bool ret = false;\n+    CDBEnv *env = dbw.env;\n+    const std::string& strFile = dbw.strFile;\n     TRY_LOCK(bitdb.cs_db,lockDb);\n     if (lockDb)\n     {\n         // Don't do this if any databases are in use\n         int nRefCount = 0;\n-        std::map<std::string, int>::iterator mit = bitdb.mapFileUseCount.begin();\n-        while (mit != bitdb.mapFileUseCount.end())\n+        std::map<std::string, int>::iterator mit = env->mapFileUseCount.begin();\n+        while (mit != env->mapFileUseCount.end())\n         {\n             nRefCount += (*mit).second;\n             mit++;\n@@ -614,17 +618,17 @@ bool CDB::PeriodicFlush(std::string strFile)\n         if (nRefCount == 0)\n         {\n             boost::this_thread::interruption_point();\n-            std::map<std::string, int>::iterator mi = bitdb.mapFileUseCount.find(strFile);\n-            if (mi != bitdb.mapFileUseCount.end())\n+            std::map<std::string, int>::iterator mi = env->mapFileUseCount.find(strFile);\n+            if (mi != env->mapFileUseCount.end())\n             {\n                 LogPrint(BCLog::DB, \"Flushing %s\\n\", strFile);\n                 int64_t nStart = GetTimeMillis();\n \n                 // Flush wallet file so it's self contained\n-                bitdb.CloseDb(strFile);\n-                bitdb.CheckpointLSN(strFile);\n+                env->CloseDb(strFile);\n+                env->CheckpointLSN(strFile);\n \n-                bitdb.mapFileUseCount.erase(mi++);\n+                env->mapFileUseCount.erase(mi++);\n                 LogPrint(BCLog::DB, \"Flushed %s %dms\\n\", strFile, GetTimeMillis() - nStart);\n                 ret = true;\n             }\n@@ -633,3 +637,52 @@ bool CDB::PeriodicFlush(std::string strFile)\n \n     return ret;\n }\n+\n+bool CWalletDBWrapper::Rewrite(const char* pszSkip)\n+{\n+    return CDB::Rewrite(*this, pszSkip);\n+}\n+\n+bool CWalletDBWrapper::Backup(const std::string& strDest)\n+{\n+    if (IsDummy()) {\n+        return false;\n+    }\n+    while (true)\n+    {\n+        {\n+            LOCK(env->cs_db);\n+            if (!env->mapFileUseCount.count(strFile) || env->mapFileUseCount[strFile] == 0)\n+            {\n+                // Flush log data to the dat file\n+                env->CloseDb(strFile);\n+                env->CheckpointLSN(strFile);\n+                env->mapFileUseCount.erase(strFile);\n+\n+                // Copy wallet file\n+                fs::path pathSrc = GetDataDir() / strFile;\n+                fs::path pathDest(strDest);\n+                if (fs::is_directory(pathDest))\n+                    pathDest /= strFile;\n+\n+                try {\n+                    fs::copy_file(pathSrc, pathDest, fs::copy_option::overwrite_if_exists);\n+                    LogPrintf(\"copied %s to %s\\n\", strFile, pathDest.string());\n+                    return true;\n+                } catch (const fs::filesystem_error& e) {\n+                    LogPrintf(\"error copying %s to %s - %s\\n\", strFile, pathDest.string(), e.what());\n+                    return false;\n+                }\n+            }\n+        }\n+        MilliSleep(100);\n+    }\n+    return false;\n+}\n+\n+void CWalletDBWrapper::Flush(bool shutdown)\n+{\n+    if (!IsDummy()) {\n+        env->Flush(shutdown);\n+    }\n+}"
      },
      {
        "sha": "3c6870d169d6d3016e3083344053094b840e900c",
        "filename": "src/wallet/db.h",
        "status": "modified",
        "additions": 75,
        "deletions": 28,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -72,7 +72,6 @@ class CDBEnv\n     void CheckpointLSN(const std::string& strFile);\n \n     void CloseDb(const std::string& strFile);\n-    bool RemoveDb(const std::string& strFile);\n \n     DbTxn* TxnBegin(int flags = DB_TXN_WRITE_NOSYNC)\n     {\n@@ -86,6 +85,52 @@ class CDBEnv\n \n extern CDBEnv bitdb;\n \n+/** An instance of this class represents one database.\n+ * For BerkeleyDB this is just a (env, strFile) tuple.\n+ **/\n+class CWalletDBWrapper\n+{\n+    friend class CDB;\n+public:\n+    /** Create dummy DB handle */\n+    CWalletDBWrapper(): env(nullptr)\n+    {\n+    }\n+\n+    /** Create DB handle to real database */\n+    CWalletDBWrapper(CDBEnv *env_in, const std::string &strFile_in):\n+        env(env_in), strFile(strFile_in)\n+    {\n+    }\n+\n+    /** Rewrite the entire database on disk, with the exception of key pszSkip if non-zero\n+     */\n+    bool Rewrite(const char* pszSkip=nullptr);\n+\n+    /** Back up the entire database to a file.\n+     */\n+    bool Backup(const std::string& strDest);\n+\n+    /** Get a name for this database, for debugging etc.\n+     */\n+    std::string GetName() const { return strFile; }\n+\n+    /** Make sure all changes are flushed to disk.\n+     */\n+    void Flush(bool shutdown);\n+\n+private:\n+    /** BerkeleyDB specific */\n+    CDBEnv *env;\n+    std::string strFile;\n+\n+    /** Return whether this database handle is a dummy for testing.\n+     * Only to be used at a low level, application should ideally not care\n+     * about this.\n+     */\n+    bool IsDummy() { return env == nullptr; }\n+};\n+\n \n /** RAII class that provides access to a Berkeley database */\n class CDB\n@@ -96,18 +141,19 @@ class CDB\n     DbTxn* activeTxn;\n     bool fReadOnly;\n     bool fFlushOnClose;\n+    CDBEnv *env;\n \n-    explicit CDB(const std::string& strFilename, const char* pszMode = \"r+\", bool fFlushOnCloseIn=true);\n+public:\n+    explicit CDB(CWalletDBWrapper& dbw, const char* pszMode = \"r+\", bool fFlushOnCloseIn=true);\n     ~CDB() { Close(); }\n \n-public:\n     void Flush();\n     void Close();\n     static bool Recover(const std::string& filename, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue));\n \n     /* flush the wallet passively (TRY_LOCK)\n        ideal to be called periodically */\n-    static bool PeriodicFlush(std::string strFile);\n+    static bool PeriodicFlush(CWalletDBWrapper& dbw);\n     /* verifies the database environment */\n     static bool VerifyEnvironment(const std::string& walletFile, const fs::path& dataDir, std::string& errorStr);\n     /* verifies the database file */\n@@ -117,7 +163,7 @@ class CDB\n     CDB(const CDB&);\n     void operator=(const CDB&);\n \n-protected:\n+public:\n     template <typename K, typename T>\n     bool Read(const K& key, T& value)\n     {\n@@ -134,29 +180,30 @@ class CDB\n         Dbt datValue;\n         datValue.set_flags(DB_DBT_MALLOC);\n         int ret = pdb->get(activeTxn, &datKey, &datValue, 0);\n-        memset(datKey.get_data(), 0, datKey.get_size());\n-        if (datValue.get_data() == NULL)\n-            return false;\n-\n-        // Unserialize value\n-        try {\n-            CDataStream ssValue((char*)datValue.get_data(), (char*)datValue.get_data() + datValue.get_size(), SER_DISK, CLIENT_VERSION);\n-            ssValue >> value;\n-        } catch (const std::exception&) {\n-            return false;\n+        memory_cleanse(datKey.get_data(), datKey.get_size());\n+        bool success = false;\n+        if (datValue.get_data() != NULL) {\n+            // Unserialize value\n+            try {\n+                CDataStream ssValue((char*)datValue.get_data(), (char*)datValue.get_data() + datValue.get_size(), SER_DISK, CLIENT_VERSION);\n+                ssValue >> value;\n+                success = true;\n+            } catch (const std::exception&) {\n+                // In this case success remains 'false'\n+            }\n+\n+            // Clear and free memory\n+            memory_cleanse(datValue.get_data(), datValue.get_size());\n+            free(datValue.get_data());\n         }\n-\n-        // Clear and free memory\n-        memset(datValue.get_data(), 0, datValue.get_size());\n-        free(datValue.get_data());\n-        return (ret == 0);\n+        return ret == 0 && success;\n     }\n \n     template <typename K, typename T>\n     bool Write(const K& key, const T& value, bool fOverwrite = true)\n     {\n         if (!pdb)\n-            return false;\n+            return true;\n         if (fReadOnly)\n             assert(!\"Write called on database in read-only mode\");\n \n@@ -176,8 +223,8 @@ class CDB\n         int ret = pdb->put(activeTxn, &datKey, &datValue, (fOverwrite ? 0 : DB_NOOVERWRITE));\n \n         // Clear memory in case it was a private key\n-        memset(datKey.get_data(), 0, datKey.get_size());\n-        memset(datValue.get_data(), 0, datValue.get_size());\n+        memory_cleanse(datKey.get_data(), datKey.get_size());\n+        memory_cleanse(datValue.get_data(), datValue.get_size());\n         return (ret == 0);\n     }\n \n@@ -199,7 +246,7 @@ class CDB\n         int ret = pdb->del(activeTxn, &datKey, 0);\n \n         // Clear memory\n-        memset(datKey.get_data(), 0, datKey.get_size());\n+        memory_cleanse(datKey.get_data(), datKey.get_size());\n         return (ret == 0 || ret == DB_NOTFOUND);\n     }\n \n@@ -219,7 +266,7 @@ class CDB\n         int ret = pdb->exists(activeTxn, &datKey, 0);\n \n         // Clear memory\n-        memset(datKey.get_data(), 0, datKey.get_size());\n+        memory_cleanse(datKey.get_data(), datKey.get_size());\n         return (ret == 0);\n     }\n \n@@ -262,8 +309,8 @@ class CDB\n         ssValue.write((char*)datValue.get_data(), datValue.get_size());\n \n         // Clear and free memory\n-        memset(datKey.get_data(), 0, datKey.get_size());\n-        memset(datValue.get_data(), 0, datValue.get_size());\n+        memory_cleanse(datKey.get_data(), datKey.get_size());\n+        memory_cleanse(datValue.get_data(), datValue.get_size());\n         free(datKey.get_data());\n         free(datValue.get_data());\n         return 0;\n@@ -310,7 +357,7 @@ class CDB\n         return Write(std::string(\"version\"), nVersion);\n     }\n \n-    bool static Rewrite(const std::string& strFile, const char* pszSkip = NULL);\n+    bool static Rewrite(CWalletDBWrapper& dbw, const char* pszSkip = NULL);\n };\n \n #endif // BITCOIN_WALLET_DB_H"
      },
      {
        "sha": "99120d290cb59f8d3e9f7c3f9e5df39393550ac1",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 22,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -5,6 +5,7 @@\n #include \"consensus/validation.h\"\n #include \"wallet/feebumper.h\"\n #include \"wallet/wallet.h\"\n+#include \"policy/fees.h\"\n #include \"policy/policy.h\"\n #include \"policy/rbf.h\"\n #include \"validation.h\" //for mempool access\n@@ -40,6 +41,31 @@ int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *pWal\n     return GetVirtualTransactionSize(txNew);\n }\n \n+bool CFeeBumper::preconditionChecks(const CWallet *pWallet, const CWalletTx& wtx) {\n+    if (pWallet->HasWalletSpend(wtx.GetHash())) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return false;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(wtx.GetHash());\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return false;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return false;\n+    }\n+    return true;\n+}\n+\n CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n     :\n     txid(std::move(txidIn)),\n@@ -57,25 +83,7 @@ CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConf\n     auto it = pWallet->mapWallet.find(txid);\n     const CWalletTx& wtx = it->second;\n \n-    if (pWallet->HasWalletSpend(txid)) {\n-        vErrors.push_back(\"Transaction has descendants in the wallet\");\n-        currentResult = BumpFeeResult::INVALID_PARAMETER;\n-        return;\n-    }\n-\n-    {\n-        LOCK(mempool.cs);\n-        auto it_mp = mempool.mapTx.find(txid);\n-        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n-            vErrors.push_back(\"Transaction has descendants in the mempool\");\n-            currentResult = BumpFeeResult::INVALID_PARAMETER;\n-            return;\n-        }\n-    }\n-\n-    if (wtx.GetDepthInMainChain() != 0) {\n-        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n-        currentResult = BumpFeeResult::WALLET_ERROR;\n+    if (!preconditionChecks(pWallet, wtx)) {\n         return;\n     }\n \n@@ -159,11 +167,11 @@ CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConf\n     } else {\n         // if user specified a confirm target then don't consider any global payTxFee\n         if (specifiedConfirmTarget) {\n-            nNewFee = CWallet::GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool, CAmount(0));\n+            nNewFee = CWallet::GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool, ::feeEstimator, true);\n         }\n         // otherwise use the regular wallet logic to select payTxFee or default confirm target\n         else {\n-            nNewFee = CWallet::GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool);\n+            nNewFee = CWallet::GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool, ::feeEstimator);\n         }\n \n         nNewFeeRate = CFeeRate(nNewFee, maxNewTxSize);\n@@ -213,7 +221,7 @@ CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConf\n \n     // If the output would become dust, discard it (converting the dust to fee)\n     poutput->nValue -= nDelta;\n-    if (poutput->nValue <= poutput->GetDustThreshold(::dustRelayFee)) {\n+    if (poutput->nValue <= GetDustThreshold(*poutput, ::dustRelayFee)) {\n         LogPrint(BCLog::RPC, \"Bumping fee and discarding dust output\\n\");\n         nNewFee += poutput->nValue;\n         mtx.vout.erase(mtx.vout.begin() + nOutput);\n@@ -247,6 +255,11 @@ bool CFeeBumper::commit(CWallet *pWallet)\n     }\n     CWalletTx& oldWtx = pWallet->mapWallet[txid];\n \n+    // make sure the transaction still has no descendants and hasn't been mined in the meantime\n+    if (!preconditionChecks(pWallet, oldWtx)) {\n+        return false;\n+    }\n+\n     CWalletTx wtxBumped(pWallet, MakeTransactionRef(std::move(mtx)));\n     // commit/broadcast the tx\n     CReserveKey reservekey(pWallet);"
      },
      {
        "sha": "f40d05da28eeb9adfc4e99024f6d0b1f5376f18c",
        "filename": "src/wallet/feebumper.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/feebumper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/feebumper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -8,6 +8,7 @@\n #include <primitives/transaction.h>\n \n class CWallet;\n+class CWalletTx;\n class uint256;\n \n enum class BumpFeeResult\n@@ -44,6 +45,8 @@ class CFeeBumper\n     bool commit(CWallet *pWalletNonConst);\n \n private:\n+    bool preconditionChecks(const CWallet *pWallet, const CWalletTx& wtx);\n+\n     const uint256 txid;\n     uint256 bumpedTxid;\n     CMutableTransaction mtx;"
      },
      {
        "sha": "d46cf69efbfe08fc9fc99b83975e3a5076f80366",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -536,14 +536,11 @@ UniValue importwallet(const JSONRPCRequest& request)\n     }\n     file.close();\n     pwallet->ShowProgress(\"\", 100); // hide progress dialog in GUI\n-\n-    CBlockIndex *pindex = chainActive.Tip();\n-    while (pindex && pindex->pprev && pindex->GetBlockTime() > nTimeBegin - TIMESTAMP_WINDOW)\n-        pindex = pindex->pprev;\n-\n     pwallet->UpdateTimeFirstKey(nTimeBegin);\n \n-    LogPrintf(\"Rescanning last %i blocks\\n\", chainActive.Height() - pindex->nHeight + 1);\n+    CBlockIndex *pindex = chainActive.FindEarliestAtLeast(nTimeBegin - TIMESTAMP_WINDOW);\n+\n+    LogPrintf(\"Rescanning last %i blocks\\n\", pindex ? chainActive.Height() - pindex->nHeight + 1 : 0);\n     pwallet->ScanForWalletTransactions(pindex);\n     pwallet->MarkDirty();\n "
      },
      {
        "sha": "ae4f4f37cbc58deca47e06fc7a39b0f42d3f461e",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 48,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -9,8 +9,11 @@\n #include \"consensus/validation.h\"\n #include \"core_io.h\"\n #include \"init.h\"\n+#include \"wallet/coincontrol.h\"\n #include \"validation.h\"\n #include \"net.h\"\n+#include \"policy/feerate.h\"\n+#include \"policy/fees.h\"\n #include \"policy/policy.h\"\n #include \"policy/rbf.h\"\n #include \"rpc/server.h\"\n@@ -727,6 +730,9 @@ UniValue getbalance(const JSONRPCRequest& request)\n     if (request.params.size() == 0)\n         return  ValueFromAmount(pwallet->GetBalance());\n \n+    const std::string& account_param = request.params[0].get_str();\n+    const std::string* account = account_param != \"*\" ? &account_param : nullptr;\n+\n     int nMinDepth = 1;\n     if (request.params.size() > 1)\n         nMinDepth = request.params[1].get_int();\n@@ -735,41 +741,7 @@ UniValue getbalance(const JSONRPCRequest& request)\n         if(request.params[2].get_bool())\n             filter = filter | ISMINE_WATCH_ONLY;\n \n-    if (request.params[0].get_str() == \"*\") {\n-        // Calculate total balance in a very different way from GetBalance().\n-        // The biggest difference is that GetBalance() sums up all unspent\n-        // TxOuts paying to the wallet, while this sums up both spent and\n-        // unspent TxOuts paying to the wallet, and then subtracts the values of\n-        // TxIns spending from the wallet. This also has fewer restrictions on\n-        // which unconfirmed transactions are considered trusted.\n-        CAmount nBalance = 0;\n-        for (const std::pair<uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n-            const CWalletTx& wtx = pairWtx.second;\n-            if (!CheckFinalTx(wtx) || wtx.GetBlocksToMaturity() > 0 || wtx.GetDepthInMainChain() < 0)\n-                continue;\n-\n-            CAmount allFee;\n-            std::string strSentAccount;\n-            std::list<COutputEntry> listReceived;\n-            std::list<COutputEntry> listSent;\n-            wtx.GetAmounts(listReceived, listSent, allFee, strSentAccount, filter);\n-            if (wtx.GetDepthInMainChain() >= nMinDepth)\n-            {\n-                BOOST_FOREACH(const COutputEntry& r, listReceived)\n-                    nBalance += r.amount;\n-            }\n-            BOOST_FOREACH(const COutputEntry& s, listSent)\n-                nBalance -= s.amount;\n-            nBalance -= allFee;\n-        }\n-        return  ValueFromAmount(nBalance);\n-    }\n-\n-    std::string strAccount = AccountFromValue(request.params[0]);\n-\n-    CAmount nBalance = pwallet->GetAccountBalance(strAccount, nMinDepth, filter);\n-\n-    return ValueFromAmount(nBalance);\n+    return ValueFromAmount(pwallet->GetLegacyBalance(filter, nMinDepth, account));\n }\n \n UniValue getunconfirmedbalance(const JSONRPCRequest &request)\n@@ -899,7 +871,7 @@ UniValue sendfrom(const JSONRPCRequest& request)\n     EnsureWalletIsUnlocked(pwallet);\n \n     // Check funds\n-    CAmount nBalance = pwallet->GetAccountBalance(strAccount, nMinDepth, ISMINE_SPENDABLE);\n+    CAmount nBalance = pwallet->GetLegacyBalance(ISMINE_SPENDABLE, nMinDepth, &strAccount);\n     if (nAmount > nBalance)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Account has insufficient funds\");\n \n@@ -1008,7 +980,7 @@ UniValue sendmany(const JSONRPCRequest& request)\n     EnsureWalletIsUnlocked(pwallet);\n \n     // Check funds\n-    CAmount nBalance = pwallet->GetAccountBalance(strAccount, nMinDepth, ISMINE_SPENDABLE);\n+    CAmount nBalance = pwallet->GetLegacyBalance(ISMINE_SPENDABLE, nMinDepth, &strAccount);\n     if (totalAmount > nBalance)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Account has insufficient funds\");\n \n@@ -2076,7 +2048,7 @@ UniValue walletpassphrase(const JSONRPCRequest& request)\n \n     int64_t nSleepTime = request.params[1].get_int64();\n     pwallet->nRelockTime = GetTime() + nSleepTime;\n-    RPCRunLater(strprintf(\"lockwallet(%s)\", pwallet->strWalletFile), boost::bind(LockWallet, pwallet), nSleepTime);\n+    RPCRunLater(strprintf(\"lockwallet(%s)\", pwallet->GetName()), boost::bind(LockWallet, pwallet), nSleepTime);\n \n     return NullUniValue;\n }\n@@ -2498,22 +2470,29 @@ UniValue listunspent(const JSONRPCRequest& request)\n         return NullUniValue;\n     }\n \n-    if (request.fHelp || request.params.size() > 4)\n+    if (request.fHelp || request.params.size() > 5)\n         throw std::runtime_error(\n-            \"listunspent ( minconf maxconf  [\\\"addresses\\\",...] [include_unsafe] )\\n\"\n+            \"listunspent ( minconf maxconf  [\\\"addresses\\\",...] [include_unsafe] [query_options])\\n\"\n             \"\\nReturns array of unspent transaction outputs\\n\"\n             \"with between minconf and maxconf (inclusive) confirmations.\\n\"\n             \"Optionally filter to only include txouts paid to specified addresses.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. minconf          (numeric, optional, default=1) The minimum confirmations to filter\\n\"\n             \"2. maxconf          (numeric, optional, default=9999999) The maximum confirmations to filter\\n\"\n-            \"3. \\\"addresses\\\"    (string) A json array of bitcoin addresses to filter\\n\"\n+            \"3. \\\"addresses\\\"      (string) A json array of bitcoin addresses to filter\\n\"\n             \"    [\\n\"\n-            \"      \\\"address\\\"   (string) bitcoin address\\n\"\n+            \"      \\\"address\\\"     (string) bitcoin address\\n\"\n             \"      ,...\\n\"\n             \"    ]\\n\"\n             \"4. include_unsafe (bool, optional, default=true) Include outputs that are not safe to spend\\n\"\n             \"                  See description of \\\"safe\\\" attribute below.\\n\"\n+            \"5. query_options    (json, optional) JSON with query options\\n\"\n+            \"    {\\n\"\n+            \"      \\\"minimumAmount\\\"    (numeric or string, default=0) Minimum value of each UTXO in \" + CURRENCY_UNIT + \"\\n\"\n+            \"      \\\"maximumAmount\\\"    (numeric or string, default=unlimited) Maximum value of each UTXO in \" + CURRENCY_UNIT + \"\\n\"\n+            \"      \\\"maximumCount\\\"     (numeric or string, default=unlimited) Maximum number of UTXOs\\n\"\n+            \"      \\\"minimumSumAmount\\\" (numeric or string, default=unlimited) Minimum sum value of all UTXOs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"    }\\n\"\n             \"\\nResult\\n\"\n             \"[                   (array of json object)\\n\"\n             \"  {\\n\"\n@@ -2538,6 +2517,8 @@ UniValue listunspent(const JSONRPCRequest& request)\n             + HelpExampleCli(\"listunspent\", \"\")\n             + HelpExampleCli(\"listunspent\", \"6 9999999 \\\"[\\\\\\\"1PGFqEzfmQch1gKD3ra4k18PNj3tTUUSqg\\\\\\\",\\\\\\\"1LtvqCaApEdUGFkpKMM4MstjcaL4dKg8SP\\\\\\\"]\\\"\")\n             + HelpExampleRpc(\"listunspent\", \"6, 9999999 \\\"[\\\\\\\"1PGFqEzfmQch1gKD3ra4k18PNj3tTUUSqg\\\\\\\",\\\\\\\"1LtvqCaApEdUGFkpKMM4MstjcaL4dKg8SP\\\\\\\"]\\\"\")\n+            + HelpExampleCli(\"listunspent\", \"6 9999999 '[]' true '{ \\\"minimumAmount\\\": 0.005 }'\")\n+            + HelpExampleRpc(\"listunspent\", \"6, 9999999, [] , true, { \\\"minimumAmount\\\": 0.005 } \")\n         );\n \n     int nMinDepth = 1;\n@@ -2573,15 +2554,34 @@ UniValue listunspent(const JSONRPCRequest& request)\n         include_unsafe = request.params[3].get_bool();\n     }\n \n+    CAmount nMinimumAmount = 0;\n+    CAmount nMaximumAmount = MAX_MONEY;\n+    CAmount nMinimumSumAmount = MAX_MONEY;\n+    uint64_t nMaximumCount = 0;\n+\n+    if (request.params.size() > 4) {\n+        const UniValue& options = request.params[4].get_obj();\n+\n+        if (options.exists(\"minimumAmount\"))\n+            nMinimumAmount = AmountFromValue(options[\"minimumAmount\"]);\n+\n+        if (options.exists(\"maximumAmount\"))\n+            nMaximumAmount = AmountFromValue(options[\"maximumAmount\"]);\n+\n+        if (options.exists(\"minimumSumAmount\"))\n+            nMinimumSumAmount = AmountFromValue(options[\"minimumSumAmount\"]);\n+\n+        if (options.exists(\"maximumCount\"))\n+            nMaximumCount = options[\"maximumCount\"].get_int64();\n+    }\n+\n     UniValue results(UniValue::VARR);\n     std::vector<COutput> vecOutputs;\n     assert(pwallet != NULL);\n     LOCK2(cs_main, pwallet->cs_wallet);\n-    pwallet->AvailableCoins(vecOutputs, !include_unsafe, NULL, true);\n-    BOOST_FOREACH(const COutput& out, vecOutputs) {\n-        if (out.nDepth < nMinDepth || out.nDepth > nMaxDepth)\n-            continue;\n \n+    pwallet->AvailableCoins(vecOutputs, !include_unsafe, NULL, nMinimumAmount, nMaximumAmount, nMinimumSumAmount, nMaximumCount, nMinDepth, nMaxDepth);\n+    BOOST_FOREACH(const COutput& out, vecOutputs) {\n         CTxDestination address;\n         const CScript& scriptPubKey = out.tx->tx->vout[out.i].scriptPubKey;\n         bool fValidAddress = ExtractDestination(scriptPubKey, address);\n@@ -2797,7 +2797,7 @@ UniValue bumpfee(const JSONRPCRequest& request)\n             \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n             \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n             \"The user can specify a confirmation target for estimatefee.\\n\"\n-            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC settxfee to set a higher fee rate.\\n\"\n             \"At a minimum, the new fee rate must be high enough to pay an additional new relay fee (incrementalfee\\n\"\n             \"returned by getnetworkinfo) to enter the node's mempool.\\n\"\n             \"\\nArguments:\\n\"\n@@ -2964,7 +2964,7 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             \"listreceivedbyaddress\",    &listreceivedbyaddress,    false,  {\"minconf\",\"include_empty\",\"include_watchonly\"} },\n     { \"wallet\",             \"listsinceblock\",           &listsinceblock,           false,  {\"blockhash\",\"target_confirmations\",\"include_watchonly\"} },\n     { \"wallet\",             \"listtransactions\",         &listtransactions,         false,  {\"account\",\"count\",\"skip\",\"include_watchonly\"} },\n-    { \"wallet\",             \"listunspent\",              &listunspent,              false,  {\"minconf\",\"maxconf\",\"addresses\",\"include_unsafe\"} },\n+    { \"wallet\",             \"listunspent\",              &listunspent,              false,  {\"minconf\",\"maxconf\",\"addresses\",\"include_unsafe\",\"query_options\"} },\n     { \"wallet\",             \"lockunspent\",              &lockunspent,              true,   {\"unlock\",\"transactions\"} },\n     { \"wallet\",             \"move\",                     &movecmd,                  false,  {\"fromaccount\",\"toaccount\",\"amount\",\"minconf\",\"comment\"} },\n     { \"wallet\",             \"sendfrom\",                 &sendfrom,                 false,  {\"fromaccount\",\"toaddress\",\"amount\",\"minconf\",\"comment\",\"comment_to\"} },"
      },
      {
        "sha": "1989bf8d9b96e85e17d3d3759f4da0ab6556f0b0",
        "filename": "src/wallet/test/wallet_test_fixture.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/test/wallet_test_fixture.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/test/wallet_test_fixture.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_test_fixture.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -14,7 +14,8 @@ WalletTestingSetup::WalletTestingSetup(const std::string& chainName):\n     bitdb.MakeMock();\n \n     bool fFirstRun;\n-    pwalletMain = new CWallet(\"wallet_test.dat\");\n+    std::unique_ptr<CWalletDBWrapper> dbw(new CWalletDBWrapper(&bitdb, \"wallet_test.dat\"));\n+    pwalletMain = new CWallet(std::move(dbw));\n     pwalletMain->LoadWallet(fFirstRun);\n     RegisterValidationInterface(pwalletMain);\n "
      },
      {
        "sha": "5c7359fdce4b1cd12cee4964105f65b71369e2d8",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 163,
        "deletions": 0,
        "changes": 163,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -9,6 +9,7 @@\n #include <utility>\n #include <vector>\n \n+#include \"consensus/validation.h\"\n #include \"rpc/server.h\"\n #include \"test/test_bitcoin.h\"\n #include \"validation.h\"\n@@ -19,6 +20,8 @@\n #include <univalue.h>\n \n extern UniValue importmulti(const JSONRPCRequest& request);\n+extern UniValue dumpwallet(const JSONRPCRequest& request);\n+extern UniValue importwallet(const JSONRPCRequest& request);\n \n // how many times to run all the tests to have a chance to catch errors that only show up with particular random shuffles\n #define RUN_TESTS 100\n@@ -437,6 +440,66 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n     }\n }\n \n+// Verify importwallet RPC starts rescan at earliest block with timestamp\n+// greater or equal than key birthday. Previously there was a bug where\n+// importwallet RPC would start the scan at the latest block with timestamp less\n+// than or equal to key birthday.\n+BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n+{\n+    CWallet *pwalletMainBackup = ::pwalletMain;\n+    LOCK(cs_main);\n+\n+    // Create two blocks with same timestamp to verify that importwallet rescan\n+    // will pick up both blocks, not just the first.\n+    const int64_t BLOCK_TIME = chainActive.Tip()->GetBlockTimeMax() + 5;\n+    SetMockTime(BLOCK_TIME);\n+    coinbaseTxns.emplace_back(*CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey())).vtx[0]);\n+    coinbaseTxns.emplace_back(*CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey())).vtx[0]);\n+\n+    // Set key birthday to block time increased by the timestamp window, so\n+    // rescan will start at the block time.\n+    const int64_t KEY_TIME = BLOCK_TIME + TIMESTAMP_WINDOW;\n+    SetMockTime(KEY_TIME);\n+    coinbaseTxns.emplace_back(*CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey())).vtx[0]);\n+\n+    // Import key into wallet and call dumpwallet to create backup file.\n+    {\n+        CWallet wallet;\n+        LOCK(wallet.cs_wallet);\n+        wallet.mapKeyMetadata[coinbaseKey.GetPubKey().GetID()].nCreateTime = KEY_TIME;\n+        wallet.AddKeyPubKey(coinbaseKey, coinbaseKey.GetPubKey());\n+\n+        JSONRPCRequest request;\n+        request.params.setArray();\n+        request.params.push_back(\"wallet.backup\");\n+        ::pwalletMain = &wallet;\n+        ::dumpwallet(request);\n+    }\n+\n+    // Call importwallet RPC and verify all blocks with timestamps >= BLOCK_TIME\n+    // were scanned, and no prior blocks were scanned.\n+    {\n+        CWallet wallet;\n+\n+        JSONRPCRequest request;\n+        request.params.setArray();\n+        request.params.push_back(\"wallet.backup\");\n+        ::pwalletMain = &wallet;\n+        ::importwallet(request);\n+\n+        BOOST_CHECK_EQUAL(wallet.mapWallet.size(), 3);\n+        BOOST_CHECK_EQUAL(coinbaseTxns.size(), 103);\n+        for (size_t i = 0; i < coinbaseTxns.size(); ++i) {\n+            bool found = wallet.GetWalletTx(coinbaseTxns[i].GetHash());\n+            bool expected = i >= 100;\n+            BOOST_CHECK_EQUAL(found, expected);\n+        }\n+    }\n+\n+    SetMockTime(0);\n+    ::pwalletMain = pwalletMainBackup;\n+}\n+\n // Check that GetImmatureCredit() returns a newly calculated value instead of\n // the cached value after a MarkDirty() call.\n //\n@@ -515,4 +578,104 @@ BOOST_AUTO_TEST_CASE(ComputeTimeSmart)\n     SetMockTime(0);\n }\n \n+BOOST_AUTO_TEST_CASE(LoadReceiveRequests)\n+{\n+    CTxDestination dest = CKeyID();\n+    pwalletMain->AddDestData(dest, \"misc\", \"val_misc\");\n+    pwalletMain->AddDestData(dest, \"rr0\", \"val_rr0\");\n+    pwalletMain->AddDestData(dest, \"rr1\", \"val_rr1\");\n+\n+    auto values = pwalletMain->GetDestValues(\"rr\");\n+    BOOST_CHECK_EQUAL(values.size(), 2);\n+    BOOST_CHECK_EQUAL(values[0], \"val_rr0\");\n+    BOOST_CHECK_EQUAL(values[1], \"val_rr1\");\n+}\n+\n+class ListCoinsTestingSetup : public TestChain100Setup\n+{\n+public:\n+    ListCoinsTestingSetup()\n+    {\n+        CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n+        ::bitdb.MakeMock();\n+        wallet.reset(new CWallet(std::unique_ptr<CWalletDBWrapper>(new CWalletDBWrapper(&bitdb, \"wallet_test.dat\"))));\n+        bool firstRun;\n+        wallet->LoadWallet(firstRun);\n+        LOCK(wallet->cs_wallet);\n+        wallet->AddKeyPubKey(coinbaseKey, coinbaseKey.GetPubKey());\n+        wallet->ScanForWalletTransactions(chainActive.Genesis());\n+    }\n+\n+    ~ListCoinsTestingSetup()\n+    {\n+        wallet.reset();\n+        ::bitdb.Flush(true);\n+        ::bitdb.Reset();\n+    }\n+\n+    CWalletTx& AddTx(CRecipient recipient)\n+    {\n+        CWalletTx wtx;\n+        CReserveKey reservekey(wallet.get());\n+        CAmount fee;\n+        int changePos = -1;\n+        std::string error;\n+        BOOST_CHECK(wallet->CreateTransaction({recipient}, wtx, reservekey, fee, changePos, error));\n+        CValidationState state;\n+        BOOST_CHECK(wallet->CommitTransaction(wtx, reservekey, nullptr, state));\n+        auto it = wallet->mapWallet.find(wtx.GetHash());\n+        BOOST_CHECK(it != wallet->mapWallet.end());\n+        CreateAndProcessBlock({CMutableTransaction(*it->second.tx)}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n+        it->second.SetMerkleBranch(chainActive.Tip(), 1);\n+        return it->second;\n+    }\n+\n+    std::unique_ptr<CWallet> wallet;\n+};\n+\n+BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n+{\n+    std::string coinbaseAddress = coinbaseKey.GetPubKey().GetID().ToString();\n+    LOCK(wallet->cs_wallet);\n+\n+    // Confirm ListCoins initially returns 1 coin grouped under coinbaseKey\n+    // address.\n+    auto list = wallet->ListCoins();\n+    BOOST_CHECK_EQUAL(list.size(), 1);\n+    BOOST_CHECK_EQUAL(boost::get<CKeyID>(list.begin()->first).ToString(), coinbaseAddress);\n+    BOOST_CHECK_EQUAL(list.begin()->second.size(), 1);\n+\n+    // Check initial balance from one mature coinbase transaction.\n+    BOOST_CHECK_EQUAL(50 * COIN, wallet->GetAvailableBalance());\n+\n+    // Add a transaction creating a change address, and confirm ListCoins still\n+    // returns the coin associated with the change address underneath the\n+    // coinbaseKey pubkey, even though the change address has a different\n+    // pubkey.\n+    AddTx(CRecipient{GetScriptForRawPubKey({}), 1 * COIN, false /* subtract fee */});\n+    list = wallet->ListCoins();\n+    BOOST_CHECK_EQUAL(list.size(), 1);\n+    BOOST_CHECK_EQUAL(boost::get<CKeyID>(list.begin()->first).ToString(), coinbaseAddress);\n+    BOOST_CHECK_EQUAL(list.begin()->second.size(), 2);\n+\n+    // Lock both coins. Confirm number of available coins drops to 0.\n+    std::vector<COutput> available;\n+    wallet->AvailableCoins(available);\n+    BOOST_CHECK_EQUAL(available.size(), 2);\n+    for (const auto& group : list) {\n+        for (const auto& coin : group.second) {\n+            wallet->LockCoin(COutPoint(coin.tx->GetHash(), coin.i));\n+        }\n+    }\n+    wallet->AvailableCoins(available);\n+    BOOST_CHECK_EQUAL(available.size(), 0);\n+\n+    // Confirm ListCoins still returns same result as before, despite coins\n+    // being locked.\n+    list = wallet->ListCoins();\n+    BOOST_CHECK_EQUAL(list.size(), 1);\n+    BOOST_CHECK_EQUAL(boost::get<CKeyID>(list.begin()->first).ToString(), coinbaseAddress);\n+    BOOST_CHECK_EQUAL(list.begin()->second.size(), 2);\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "0e882cb5c7cb8400704cf4a9b4e80ba9b0560da8",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 308,
        "deletions": 263,
        "changes": 571,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -17,6 +17,7 @@\n #include \"validation.h\"\n #include \"net.h\"\n #include \"net_processing.h\"\n+#include \"policy/fees.h\"\n #include \"policy/policy.h\"\n #include \"policy/rbf.h\"\n #include \"primitives/block.h\"\n@@ -162,7 +163,7 @@ void CWallet::DeriveNewChildKey(CKeyMetadata& metadata, CKey& secret, bool inter\n     secret = childKey.key;\n     metadata.hdMasterKeyID = hdChain.masterKeyID;\n     // update the chain model in the database\n-    if (!CWalletDB(strWalletFile).WriteHDChain(hdChain))\n+    if (!CWalletDB(*dbw).WriteHDChain(hdChain))\n         throw std::runtime_error(std::string(__func__) + \": Writing HD chain model failed\");\n }\n \n@@ -181,10 +182,8 @@ bool CWallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n     if (HaveWatchOnly(script))\n         RemoveWatchOnly(script);\n \n-    if (!fFileBacked)\n-        return true;\n     if (!IsCrypted()) {\n-        return CWalletDB(strWalletFile).WriteKey(pubkey,\n+        return CWalletDB(*dbw).WriteKey(pubkey,\n                                                  secret.GetPrivKey(),\n                                                  mapKeyMetadata[pubkey.GetID()]);\n     }\n@@ -196,16 +195,14 @@ bool CWallet::AddCryptedKey(const CPubKey &vchPubKey,\n {\n     if (!CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret))\n         return false;\n-    if (!fFileBacked)\n-        return true;\n     {\n         LOCK(cs_wallet);\n         if (pwalletdbEncryption)\n             return pwalletdbEncryption->WriteCryptedKey(vchPubKey,\n                                                         vchCryptedSecret,\n                                                         mapKeyMetadata[vchPubKey.GetID()]);\n         else\n-            return CWalletDB(strWalletFile).WriteCryptedKey(vchPubKey,\n+            return CWalletDB(*dbw).WriteCryptedKey(vchPubKey,\n                                                             vchCryptedSecret,\n                                                             mapKeyMetadata[vchPubKey.GetID()]);\n     }\n@@ -241,9 +238,7 @@ bool CWallet::AddCScript(const CScript& redeemScript)\n {\n     if (!CCryptoKeyStore::AddCScript(redeemScript))\n         return false;\n-    if (!fFileBacked)\n-        return true;\n-    return CWalletDB(strWalletFile).WriteCScript(Hash160(redeemScript), redeemScript);\n+    return CWalletDB(*dbw).WriteCScript(Hash160(redeemScript), redeemScript);\n }\n \n bool CWallet::LoadCScript(const CScript& redeemScript)\n@@ -269,9 +264,7 @@ bool CWallet::AddWatchOnly(const CScript& dest)\n     const CKeyMetadata& meta = mapKeyMetadata[CScriptID(dest)];\n     UpdateTimeFirstKey(meta.nCreateTime);\n     NotifyWatchonlyChanged(true);\n-    if (!fFileBacked)\n-        return true;\n-    return CWalletDB(strWalletFile).WriteWatchOnly(dest, meta);\n+    return CWalletDB(*dbw).WriteWatchOnly(dest, meta);\n }\n \n bool CWallet::AddWatchOnly(const CScript& dest, int64_t nCreateTime)\n@@ -287,9 +280,8 @@ bool CWallet::RemoveWatchOnly(const CScript &dest)\n         return false;\n     if (!HaveWatchOnly())\n         NotifyWatchonlyChanged(false);\n-    if (fFileBacked)\n-        if (!CWalletDB(strWalletFile).EraseWatchOnly(dest))\n-            return false;\n+    if (!CWalletDB(*dbw).EraseWatchOnly(dest))\n+        return false;\n \n     return true;\n }\n@@ -354,7 +346,7 @@ bool CWallet::ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase,\n                     return false;\n                 if (!crypter.Encrypt(_vMasterKey, pMasterKey.second.vchCryptedKey))\n                     return false;\n-                CWalletDB(strWalletFile).WriteMasterKey(pMasterKey.first, pMasterKey.second);\n+                CWalletDB(*dbw).WriteMasterKey(pMasterKey.first, pMasterKey.second);\n                 if (fWasLocked)\n                     Lock();\n                 return true;\n@@ -367,7 +359,7 @@ bool CWallet::ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase,\n \n void CWallet::SetBestChain(const CBlockLocator& loc)\n {\n-    CWalletDB walletdb(strWalletFile);\n+    CWalletDB walletdb(*dbw);\n     walletdb.WriteBestBlock(loc);\n }\n \n@@ -386,9 +378,8 @@ bool CWallet::SetMinVersion(enum WalletFeature nVersion, CWalletDB* pwalletdbIn,\n     if (nVersion > nWalletMaxVersion)\n         nWalletMaxVersion = nVersion;\n \n-    if (fFileBacked)\n     {\n-        CWalletDB* pwalletdb = pwalletdbIn ? pwalletdbIn : new CWalletDB(strWalletFile);\n+        CWalletDB* pwalletdb = pwalletdbIn ? pwalletdbIn : new CWalletDB(*dbw);\n         if (nWalletVersion > 40000)\n             pwalletdb->WriteMinVersion(nWalletVersion);\n         if (!pwalletdbIn)\n@@ -442,7 +433,7 @@ bool CWallet::HasWalletSpend(const uint256& txid) const\n \n void CWallet::Flush(bool shutdown)\n {\n-    bitdb.Flush(shutdown);\n+    dbw->Flush(shutdown);\n }\n \n bool CWallet::Verify()\n@@ -595,24 +586,19 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n     {\n         LOCK(cs_wallet);\n         mapMasterKeys[++nMasterKeyMaxID] = kMasterKey;\n-        if (fFileBacked)\n-        {\n-            assert(!pwalletdbEncryption);\n-            pwalletdbEncryption = new CWalletDB(strWalletFile);\n-            if (!pwalletdbEncryption->TxnBegin()) {\n-                delete pwalletdbEncryption;\n-                pwalletdbEncryption = NULL;\n-                return false;\n-            }\n-            pwalletdbEncryption->WriteMasterKey(nMasterKeyMaxID, kMasterKey);\n+        assert(!pwalletdbEncryption);\n+        pwalletdbEncryption = new CWalletDB(*dbw);\n+        if (!pwalletdbEncryption->TxnBegin()) {\n+            delete pwalletdbEncryption;\n+            pwalletdbEncryption = NULL;\n+            return false;\n         }\n+        pwalletdbEncryption->WriteMasterKey(nMasterKeyMaxID, kMasterKey);\n \n         if (!EncryptKeys(_vMasterKey))\n         {\n-            if (fFileBacked) {\n-                pwalletdbEncryption->TxnAbort();\n-                delete pwalletdbEncryption;\n-            }\n+            pwalletdbEncryption->TxnAbort();\n+            delete pwalletdbEncryption;\n             // We now probably have half of our keys encrypted in memory, and half not...\n             // die and let the user reload the unencrypted wallet.\n             assert(false);\n@@ -621,38 +607,32 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n         // Encryption was introduced in version 0.4.0\n         SetMinVersion(FEATURE_WALLETCRYPT, pwalletdbEncryption, true);\n \n-        if (fFileBacked)\n-        {\n-            if (!pwalletdbEncryption->TxnCommit()) {\n-                delete pwalletdbEncryption;\n-                // We now have keys encrypted in memory, but not on disk...\n-                // die to avoid confusion and let the user reload the unencrypted wallet.\n-                assert(false);\n-            }\n-\n+        if (!pwalletdbEncryption->TxnCommit()) {\n             delete pwalletdbEncryption;\n-            pwalletdbEncryption = NULL;\n+            // We now have keys encrypted in memory, but not on disk...\n+            // die to avoid confusion and let the user reload the unencrypted wallet.\n+            assert(false);\n         }\n \n+        delete pwalletdbEncryption;\n+        pwalletdbEncryption = NULL;\n+\n         Lock();\n         Unlock(strWalletPassphrase);\n \n         // if we are using HD, replace the HD master key (seed) with a new one\n         if (IsHDEnabled()) {\n-            CKey key;\n-            CPubKey masterPubKey = GenerateNewHDMasterKey();\n-            // preserve the old chains version to not break backward compatibility\n-            CHDChain oldChain = GetHDChain();\n-            if (!SetHDMasterKey(masterPubKey, &oldChain))\n+            if (!SetHDMasterKey(GenerateNewHDMasterKey())) {\n                 return false;\n+            }\n         }\n \n         NewKeyPool();\n         Lock();\n \n         // Need to completely rewrite the wallet file; if we don't, bdb might keep\n         // bits of the unencrypted private key in slack space in the database file.\n-        CDB::Rewrite(strWalletFile);\n+        dbw->Rewrite();\n \n     }\n     NotifyStatusChanged(this);\n@@ -663,7 +643,7 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n DBErrors CWallet::ReorderTransactions()\n {\n     LOCK(cs_wallet);\n-    CWalletDB walletdb(strWalletFile);\n+    CWalletDB walletdb(*dbw);\n \n     // Old wallets didn't have any defined order for transactions\n     // Probably a bad idea to change the output of this\n@@ -744,14 +724,14 @@ int64_t CWallet::IncOrderPosNext(CWalletDB *pwalletdb)\n     if (pwalletdb) {\n         pwalletdb->WriteOrderPosNext(nOrderPosNext);\n     } else {\n-        CWalletDB(strWalletFile).WriteOrderPosNext(nOrderPosNext);\n+        CWalletDB(*dbw).WriteOrderPosNext(nOrderPosNext);\n     }\n     return nRet;\n }\n \n bool CWallet::AccountMove(std::string strFrom, std::string strTo, CAmount nAmount, std::string strComment)\n {\n-    CWalletDB walletdb(strWalletFile);\n+    CWalletDB walletdb(*dbw);\n     if (!walletdb.TxnBegin())\n         return false;\n \n@@ -785,7 +765,7 @@ bool CWallet::AccountMove(std::string strFrom, std::string strTo, CAmount nAmoun\n \n bool CWallet::GetAccountPubkey(CPubKey &pubKey, std::string strAccount, bool bForceNew)\n {\n-    CWalletDB walletdb(strWalletFile);\n+    CWalletDB walletdb(*dbw);\n \n     CAccount account;\n     walletdb.ReadAccount(strAccount, account);\n@@ -846,7 +826,7 @@ bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n \n     wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();\n \n-    CWalletDB walletdb(strWalletFile, \"r+\");\n+    CWalletDB walletdb(*dbw, \"r+\");\n \n     bool success = true;\n     if (!walletdb.WriteTx(wtx)) {\n@@ -863,7 +843,7 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose)\n {\n     LOCK(cs_wallet);\n \n-    CWalletDB walletdb(strWalletFile, \"r+\", fFlushOnClose);\n+    CWalletDB walletdb(*dbw, \"r+\", fFlushOnClose);\n \n     uint256 hash = wtxIn.GetHash();\n \n@@ -1003,11 +983,18 @@ bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, const CBlockI\n     return false;\n }\n \n+bool CWallet::TransactionCanBeAbandoned(const uint256& hashTx) const\n+{\n+    LOCK2(cs_main, cs_wallet);\n+    const CWalletTx* wtx = GetWalletTx(hashTx);\n+    return wtx && !wtx->isAbandoned() && wtx->GetDepthInMainChain() <= 0 && !wtx->InMempool();\n+}\n+\n bool CWallet::AbandonTransaction(const uint256& hashTx)\n {\n     LOCK2(cs_main, cs_wallet);\n \n-    CWalletDB walletdb(strWalletFile, \"r+\");\n+    CWalletDB walletdb(*dbw, \"r+\");\n \n     std::set<uint256> todo;\n     std::set<uint256> done;\n@@ -1079,7 +1066,7 @@ void CWallet::MarkConflicted(const uint256& hashBlock, const uint256& hashTx)\n         return;\n \n     // Do not flush the wallet here for performance reasons\n-    CWalletDB walletdb(strWalletFile, \"r+\", false);\n+    CWalletDB walletdb(*dbw, \"r+\", false);\n \n     std::set<uint256> todo;\n     std::set<uint256> done;\n@@ -1142,12 +1129,12 @@ void CWallet::TransactionAddedToMempool(const CTransactionRef& ptx) {\n \n void CWallet::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex *pindex, const std::vector<CTransactionRef>& vtxConflicted) {\n     LOCK2(cs_main, cs_wallet);\n-    // TODO: Tempoarily ensure that mempool removals are notified before\n+    // TODO: Temporarily ensure that mempool removals are notified before\n     // connected transactions.  This shouldn't matter, but the abandoned\n     // state of transactions in our wallet is currently cleared when we\n     // receive another notification and there is a race condition where\n     // notification of a connected conflict might cause an outside process\n-    // to abandon a transaction and then have it inadvertantly cleared by\n+    // to abandon a transaction and then have it inadvertently cleared by\n     // the notification that the conflicted transaction was evicted.\n \n     for (const CTransactionRef& ptx : vtxConflicted) {\n@@ -1342,17 +1329,14 @@ CPubKey CWallet::GenerateNewHDMasterKey()\n     return pubkey;\n }\n \n-bool CWallet::SetHDMasterKey(const CPubKey& pubkey, CHDChain *possibleOldChain)\n+bool CWallet::SetHDMasterKey(const CPubKey& pubkey)\n {\n     LOCK(cs_wallet);\n     // store the keyid (hash160) together with\n     // the child index counter in the database\n     // as a hdchain object\n     CHDChain newHdChain;\n-    if (possibleOldChain) {\n-        // preserve the old chains version\n-        newHdChain.nVersion = possibleOldChain->nVersion;\n-    }\n+    newHdChain.nVersion = CanSupportFeature(FEATURE_HD_SPLIT) ? CHDChain::VERSION_HD_CHAIN_SPLIT : CHDChain::VERSION_HD_BASE;\n     newHdChain.masterKeyID = pubkey.GetID();\n     SetHDChain(newHdChain, false);\n \n@@ -1362,7 +1346,7 @@ bool CWallet::SetHDMasterKey(const CPubKey& pubkey, CHDChain *possibleOldChain)\n bool CWallet::SetHDChain(const CHDChain& chain, bool memonly)\n {\n     LOCK(cs_wallet);\n-    if (!memonly && !CWalletDB(strWalletFile).WriteHDChain(chain))\n+    if (!memonly && !CWalletDB(*dbw).WriteHDChain(chain))\n         throw std::runtime_error(std::string(__func__) + \": writing chain failed\");\n \n     hdChain = chain;\n@@ -1475,41 +1459,6 @@ void CWalletTx::GetAmounts(std::list<COutputEntry>& listReceived,\n \n }\n \n-void CWalletTx::GetAccountAmounts(const std::string& strAccount, CAmount& nReceived,\n-                                  CAmount& nSent, CAmount& nFee, const isminefilter& filter) const\n-{\n-    nReceived = nSent = nFee = 0;\n-\n-    CAmount allFee;\n-    std::string strSentAccount;\n-    std::list<COutputEntry> listReceived;\n-    std::list<COutputEntry> listSent;\n-    GetAmounts(listReceived, listSent, allFee, strSentAccount, filter);\n-\n-    if (strAccount == strSentAccount)\n-    {\n-        BOOST_FOREACH(const COutputEntry& s, listSent)\n-            nSent += s.amount;\n-        nFee = allFee;\n-    }\n-    {\n-        LOCK(pwallet->cs_wallet);\n-        BOOST_FOREACH(const COutputEntry& r, listReceived)\n-        {\n-            if (pwallet->mapAddressBook.count(r.destination))\n-            {\n-                std::map<CTxDestination, CAddressBookData>::const_iterator mi = pwallet->mapAddressBook.find(r.destination);\n-                if (mi != pwallet->mapAddressBook.end() && (*mi).second.name == strAccount)\n-                    nReceived += r.amount;\n-            }\n-            else if (strAccount.empty())\n-            {\n-                nReceived += r.amount;\n-            }\n-        }\n-    }\n-}\n-\n /**\n  * Scan the block chain (starting in pindexStart) for transactions\n  * from or to us. If fUpdate is true, found transactions that already\n@@ -1544,6 +1493,10 @@ CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool f\n         {\n             if (pindex->nHeight % 100 == 0 && dProgressTip - dProgressStart > 0.0)\n                 ShowProgress(_(\"Rescanning...\"), std::max(1, std::min(99, (int)((GuessVerificationProgress(chainParams.TxData(), pindex) - dProgressStart) / (dProgressTip - dProgressStart) * 100))));\n+            if (GetTime() >= nNow + 60) {\n+                nNow = GetTime();\n+                LogPrintf(\"Still rescanning. At block %d. Progress=%f\\n\", pindex->nHeight, GuessVerificationProgress(chainParams.TxData(), pindex));\n+            }\n \n             CBlock block;\n             if (ReadBlockFromDisk(block, pindex, Params().GetConsensus())) {\n@@ -1557,10 +1510,6 @@ CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool f\n                 ret = nullptr;\n             }\n             pindex = chainActive.Next(pindex);\n-            if (GetTime() >= nNow + 60) {\n-                nNow = GetTime();\n-                LogPrintf(\"Still rescanning. At block %d. Progress=%f\\n\", pindex->nHeight, GuessVerificationProgress(chainParams.TxData(), pindex));\n-            }\n         }\n         if (pindex && fAbortRescan) {\n             LogPrintf(\"Rescan aborted at block %d. Progress=%f\\n\", pindex->nHeight, GuessVerificationProgress(chainParams.TxData(), pindex));\n@@ -1868,8 +1817,8 @@ bool CWalletTx::IsEquivalentTo(const CWalletTx& _tx) const\n {\n         CMutableTransaction tx1 = *this->tx;\n         CMutableTransaction tx2 = *_tx.tx;\n-        for (unsigned int i = 0; i < tx1.vin.size(); i++) tx1.vin[i].scriptSig = CScript();\n-        for (unsigned int i = 0; i < tx2.vin.size(); i++) tx2.vin[i].scriptSig = CScript();\n+        for (auto& txin : tx1.vin) txin.scriptSig = CScript();\n+        for (auto& txin : tx2.vin) txin.scriptSig = CScript();\n         return CTransaction(tx1) == CTransaction(tx2);\n }\n \n@@ -2021,12 +1970,73 @@ CAmount CWallet::GetImmatureWatchOnlyBalance() const\n     return nTotal;\n }\n \n-void CWallet::AvailableCoins(std::vector<COutput>& vCoins, bool fOnlySafe, const CCoinControl *coinControl, bool fIncludeZeroValue) const\n+// Calculate total balance in a different way from GetBalance. The biggest\n+// difference is that GetBalance sums up all unspent TxOuts paying to the\n+// wallet, while this sums up both spent and unspent TxOuts paying to the\n+// wallet, and then subtracts the values of TxIns spending from the wallet. This\n+// also has fewer restrictions on which unconfirmed transactions are considered\n+// trusted.\n+CAmount CWallet::GetLegacyBalance(const isminefilter& filter, int minDepth, const std::string* account) const\n+{\n+    LOCK2(cs_main, cs_wallet);\n+\n+    CAmount balance = 0;\n+    for (const auto& entry : mapWallet) {\n+        const CWalletTx& wtx = entry.second;\n+        const int depth = wtx.GetDepthInMainChain();\n+        if (depth < 0 || !CheckFinalTx(*wtx.tx) || wtx.GetBlocksToMaturity() > 0) {\n+            continue;\n+        }\n+\n+        // Loop through tx outputs and add incoming payments. For outgoing txs,\n+        // treat change outputs specially, as part of the amount debited.\n+        CAmount debit = wtx.GetDebit(filter);\n+        const bool outgoing = debit > 0;\n+        for (const CTxOut& out : wtx.tx->vout) {\n+            if (outgoing && IsChange(out)) {\n+                debit -= out.nValue;\n+            } else if (IsMine(out) & filter && depth >= minDepth && (!account || *account == GetAccountName(out.scriptPubKey))) {\n+                balance += out.nValue;\n+            }\n+        }\n+\n+        // For outgoing txs, subtract amount debited.\n+        if (outgoing && (!account || *account == wtx.strFromAccount)) {\n+            balance -= debit;\n+        }\n+    }\n+\n+    if (account) {\n+        balance += CWalletDB(*dbw).GetAccountCreditDebit(*account);\n+    }\n+\n+    return balance;\n+}\n+\n+CAmount CWallet::GetAvailableBalance(const CCoinControl* coinControl) const\n+{\n+    LOCK2(cs_main, cs_wallet);\n+\n+    CAmount balance = 0;\n+    std::vector<COutput> vCoins;\n+    AvailableCoins(vCoins, true, coinControl);\n+    for (const COutput& out : vCoins) {\n+        if (out.fSpendable) {\n+            balance += out.tx->tx->vout[out.i].nValue;\n+        }\n+    }\n+    return balance;\n+}\n+\n+void CWallet::AvailableCoins(std::vector<COutput> &vCoins, bool fOnlySafe, const CCoinControl *coinControl, const CAmount &nMinimumAmount, const CAmount &nMaximumAmount, const CAmount &nMinimumSumAmount, const uint64_t &nMaximumCount, const int &nMinDepth, const int &nMaxDepth) const\n {\n     vCoins.clear();\n \n     {\n         LOCK2(cs_main, cs_wallet);\n+\n+        CAmount nTotal = 0;\n+\n         for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const uint256& wtxid = it->first;\n@@ -2084,20 +2094,114 @@ void CWallet::AvailableCoins(std::vector<COutput>& vCoins, bool fOnlySafe, const\n                 continue;\n             }\n \n+            if (nDepth < nMinDepth || nDepth > nMaxDepth)\n+                continue;\n+\n             for (unsigned int i = 0; i < pcoin->tx->vout.size(); i++) {\n+                if (pcoin->tx->vout[i].nValue < nMinimumAmount || pcoin->tx->vout[i].nValue > nMaximumAmount)\n+                    continue;\n+\n+                if (coinControl && coinControl->HasSelected() && !coinControl->fAllowOtherInputs && !coinControl->IsSelected(COutPoint((*it).first, i)))\n+                    continue;\n+\n+                if (IsLockedCoin((*it).first, i))\n+                    continue;\n+\n+                if (IsSpent(wtxid, i))\n+                    continue;\n+\n                 isminetype mine = IsMine(pcoin->tx->vout[i]);\n-                if (!(IsSpent(wtxid, i)) && mine != ISMINE_NO &&\n-                    !IsLockedCoin((*it).first, i) && (pcoin->tx->vout[i].nValue > 0 || fIncludeZeroValue) &&\n-                    (!coinControl || !coinControl->HasSelected() || coinControl->fAllowOtherInputs || coinControl->IsSelected(COutPoint((*it).first, i))))\n-                        vCoins.push_back(COutput(pcoin, i, nDepth,\n-                                                 ((mine & ISMINE_SPENDABLE) != ISMINE_NO) ||\n-                                                  (coinControl && coinControl->fAllowWatchOnly && (mine & ISMINE_WATCH_SOLVABLE) != ISMINE_NO),\n-                                                 (mine & (ISMINE_SPENDABLE | ISMINE_WATCH_SOLVABLE)) != ISMINE_NO, safeTx));\n+\n+                if (mine == ISMINE_NO) {\n+                    continue;\n+                }\n+\n+                bool fSpendableIn = ((mine & ISMINE_SPENDABLE) != ISMINE_NO) || (coinControl && coinControl->fAllowWatchOnly && (mine & ISMINE_WATCH_SOLVABLE) != ISMINE_NO);\n+                bool fSolvableIn = (mine & (ISMINE_SPENDABLE | ISMINE_WATCH_SOLVABLE)) != ISMINE_NO;\n+\n+                vCoins.push_back(COutput(pcoin, i, nDepth, fSpendableIn, fSolvableIn, safeTx));\n+\n+                // Checks the sum amount of all UTXO's.\n+                if (nMinimumSumAmount != MAX_MONEY) {\n+                    nTotal += pcoin->tx->vout[i].nValue;\n+\n+                    if (nTotal >= nMinimumSumAmount) {\n+                        return;\n+                    }\n+                }\n+\n+                // Checks the maximum number of UTXO's.\n+                if (nMaximumCount > 0 && vCoins.size() >= nMaximumCount) {\n+                    return;\n+                }\n             }\n         }\n     }\n }\n \n+std::map<CTxDestination, std::vector<COutput>> CWallet::ListCoins() const\n+{\n+    // TODO: Add AssertLockHeld(cs_wallet) here.\n+    //\n+    // Because the return value from this function contains pointers to\n+    // CWalletTx objects, callers to this function really should acquire the\n+    // cs_wallet lock before calling it. However, the current caller doesn't\n+    // acquire this lock yet. There was an attempt to add the missing lock in\n+    // https://github.com/bitcoin/bitcoin/pull/10340, but that change has been\n+    // postponed until after https://github.com/bitcoin/bitcoin/pull/10244 to\n+    // avoid adding some extra complexity to the Qt code.\n+\n+    std::map<CTxDestination, std::vector<COutput>> result;\n+\n+    std::vector<COutput> availableCoins;\n+    AvailableCoins(availableCoins);\n+\n+    LOCK2(cs_main, cs_wallet);\n+    for (auto& coin : availableCoins) {\n+        CTxDestination address;\n+        if (coin.fSpendable &&\n+            ExtractDestination(FindNonChangeParentOutput(*coin.tx->tx, coin.i).scriptPubKey, address)) {\n+            result[address].emplace_back(std::move(coin));\n+        }\n+    }\n+\n+    std::vector<COutPoint> lockedCoins;\n+    ListLockedCoins(lockedCoins);\n+    for (const auto& output : lockedCoins) {\n+        auto it = mapWallet.find(output.hash);\n+        if (it != mapWallet.end()) {\n+            int depth = it->second.GetDepthInMainChain();\n+            if (depth >= 0 && output.n < it->second.tx->vout.size() &&\n+                IsMine(it->second.tx->vout[output.n]) == ISMINE_SPENDABLE) {\n+                CTxDestination address;\n+                if (ExtractDestination(FindNonChangeParentOutput(*it->second.tx, output.n).scriptPubKey, address)) {\n+                    result[address].emplace_back(\n+                        &it->second, output.n, depth, true /* spendable */, true /* solvable */, false /* safe */);\n+                }\n+            }\n+        }\n+    }\n+\n+    return result;\n+}\n+\n+const CTxOut& CWallet::FindNonChangeParentOutput(const CTransaction& tx, int output) const\n+{\n+    const CTransaction* ptx = &tx;\n+    int n = output;\n+    while (IsChange(ptx->vout[n]) && ptx->vin.size() > 0) {\n+        const COutPoint& prevout = ptx->vin[0].prevout;\n+        auto it = mapWallet.find(prevout.hash);\n+        if (it == mapWallet.end() || it->second.tx->vout.size() <= prevout.n ||\n+            !IsMine(it->second.tx->vout[prevout.n])) {\n+            break;\n+        }\n+        ptx = it->second.tx.get();\n+        n = prevout.n;\n+    }\n+    return ptx->vout[n];\n+}\n+\n static void ApproximateBestSubset(const std::vector<CInputCoin>& vValue, const CAmount& nTotalLower, const CAmount& nTargetValue,\n                                   std::vector<char>& vfBest, CAmount& nBest, int iterations = 1000)\n {\n@@ -2123,7 +2227,7 @@ static void ApproximateBestSubset(const std::vector<CInputCoin>& vValue, const C\n                 //that the rng is fast. We do not use a constant random sequence,\n                 //because there may be some privacy improvement by making\n                 //the selection random.\n-                if (nPass == 0 ? insecure_rand.rand32()&1 : !vfIncluded[i])\n+                if (nPass == 0 ? insecure_rand.randbool() : !vfIncluded[i])\n                 {\n                     nTotal += vValue[i].txout.nValue;\n                     vfIncluded[i] = true;\n@@ -2193,10 +2297,10 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const int nConfMin\n \n     if (nTotalLower == nTargetValue)\n     {\n-        for (unsigned int i = 0; i < vValue.size(); ++i)\n+        for (const auto& input : vValue)\n         {\n-            setCoinsRet.insert(vValue[i]);\n-            nValueRet += vValue[i].txout.nValue;\n+            setCoinsRet.insert(input);\n+            nValueRet += input.txout.nValue;\n         }\n         return true;\n     }\n@@ -2321,10 +2425,12 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n \n bool CWallet::SignTransaction(CMutableTransaction &tx)\n {\n+    AssertLockHeld(cs_wallet); // mapWallet\n+\n     // sign the new tx\n     CTransaction txNewConst(tx);\n     int nIn = 0;\n-    for (auto& input : tx.vin) {\n+    for (const auto& input : tx.vin) {\n         std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(input.prevout.hash);\n         if(mi == mapWallet.end() || input.prevout.n >= mi->second.tx->vout.size()) {\n             return false;\n@@ -2493,7 +2599,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                         }\n                     }\n \n-                    if (txout.IsDust(dustRelayFee))\n+                    if (IsDust(txout, ::dustRelayFee))\n                     {\n                         if (recipient.fSubtractFeeFromAmount && nFeeRet > 0)\n                         {\n@@ -2558,16 +2664,16 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                     // We do not move dust-change to fees, because the sender would end up paying more than requested.\n                     // This would be against the purpose of the all-inclusive feature.\n                     // So instead we raise the change and deduct from the recipient.\n-                    if (nSubtractFeeFromAmount > 0 && newTxOut.IsDust(dustRelayFee))\n+                    if (nSubtractFeeFromAmount > 0 && IsDust(newTxOut, ::dustRelayFee))\n                     {\n-                        CAmount nDust = newTxOut.GetDustThreshold(dustRelayFee) - newTxOut.nValue;\n+                        CAmount nDust = GetDustThreshold(newTxOut, ::dustRelayFee) - newTxOut.nValue;\n                         newTxOut.nValue += nDust; // raise change until no more dust\n                         for (unsigned int i = 0; i < vecSend.size(); i++) // subtract from first recipient\n                         {\n                             if (vecSend[i].fSubtractFeeFromAmount)\n                             {\n                                 txNew.vout[i].nValue -= nDust;\n-                                if (txNew.vout[i].IsDust(dustRelayFee))\n+                                if (IsDust(txNew.vout[i], ::dustRelayFee))\n                                 {\n                                     strFailReason = _(\"The transaction amount is too small to send after the fee has been deducted\");\n                                     return false;\n@@ -2579,7 +2685,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n \n                     // Never create dust outputs; if we would, just\n                     // add the dust to the fee.\n-                    if (newTxOut.IsDust(dustRelayFee))\n+                    if (IsDust(newTxOut, ::dustRelayFee))\n                     {\n                         nChangePosInOut = -1;\n                         nFeeRet += nChange;\n@@ -2601,9 +2707,10 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                         std::vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosInOut;\n                         txNew.vout.insert(position, newTxOut);\n                     }\n-                }\n-                else\n+                } else {\n                     reservekey.ReturnKey();\n+                    nChangePosInOut = -1;\n+                }\n \n                 // Fill vin\n                 //\n@@ -2641,10 +2748,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                 if (coinControl && coinControl->nConfirmTarget > 0)\n                     currentConfirmationTarget = coinControl->nConfirmTarget;\n \n-                CAmount nFeeNeeded = GetMinimumFee(nBytes, currentConfirmationTarget, mempool);\n-                if (coinControl && nFeeNeeded > 0 && coinControl->nMinimumTotalFee > nFeeNeeded) {\n-                    nFeeNeeded = coinControl->nMinimumTotalFee;\n-                }\n+                CAmount nFeeNeeded = GetMinimumFee(nBytes, currentConfirmationTarget, ::mempool, ::feeEstimator);\n                 if (coinControl && coinControl->fOverrideFeeRate)\n                     nFeeNeeded = coinControl->nFeeRate.GetFee(nBytes);\n \n@@ -2787,13 +2891,13 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey, CCon\n }\n \n void CWallet::ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& entries) {\n-    CWalletDB walletdb(strWalletFile);\n+    CWalletDB walletdb(*dbw);\n     return walletdb.ListAccountCreditDebit(strAccount, entries);\n }\n \n bool CWallet::AddAccountingEntry(const CAccountingEntry& acentry)\n {\n-    CWalletDB walletdb(strWalletFile);\n+    CWalletDB walletdb(*dbw);\n \n     return AddAccountingEntry(acentry, &walletdb);\n }\n@@ -2815,19 +2919,14 @@ CAmount CWallet::GetRequiredFee(unsigned int nTxBytes)\n     return std::max(minTxFee.GetFee(nTxBytes), ::minRelayTxFee.GetFee(nTxBytes));\n }\n \n-CAmount CWallet::GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarget, const CTxMemPool& pool)\n+CAmount CWallet::GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarget, const CTxMemPool& pool, const CBlockPolicyEstimator& estimator, bool ignoreUserSetFee)\n {\n     // payTxFee is the user-set global for desired feerate\n-    return GetMinimumFee(nTxBytes, nConfirmTarget, pool, payTxFee.GetFee(nTxBytes));\n-}\n-\n-CAmount CWallet::GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarget, const CTxMemPool& pool, CAmount targetFee)\n-{\n-    CAmount nFeeNeeded = targetFee;\n+    CAmount nFeeNeeded = payTxFee.GetFee(nTxBytes);\n     // User didn't set: use -txconfirmtarget to estimate...\n-    if (nFeeNeeded == 0) {\n+    if (nFeeNeeded == 0 || ignoreUserSetFee) {\n         int estimateFoundTarget = nConfirmTarget;\n-        nFeeNeeded = pool.estimateSmartFee(nConfirmTarget, &estimateFoundTarget).GetFee(nTxBytes);\n+        nFeeNeeded = estimator.estimateSmartFee(nConfirmTarget, &estimateFoundTarget, pool).GetFee(nTxBytes);\n         // ... unless we don't have enough mempool data for estimatefee, then use fallbackFee\n         if (nFeeNeeded == 0)\n             nFeeNeeded = fallbackFee.GetFee(nTxBytes);\n@@ -2845,13 +2944,11 @@ CAmount CWallet::GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarge\n \n DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n {\n-    if (!fFileBacked)\n-        return DB_LOAD_OK;\n     fFirstRunRet = false;\n-    DBErrors nLoadWalletRet = CWalletDB(strWalletFile,\"cr+\").LoadWallet(this);\n+    DBErrors nLoadWalletRet = CWalletDB(*dbw,\"cr+\").LoadWallet(this);\n     if (nLoadWalletRet == DB_NEED_REWRITE)\n     {\n-        if (CDB::Rewrite(strWalletFile, \"\\x04pool\"))\n+        if (dbw->Rewrite(\"\\x04pool\"))\n         {\n             LOCK(cs_wallet);\n             setKeyPool.clear();\n@@ -2872,17 +2969,15 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n \n DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256>& vHashOut)\n {\n-    if (!fFileBacked)\n-        return DB_LOAD_OK;\n     AssertLockHeld(cs_wallet); // mapWallet\n     vchDefaultKey = CPubKey();\n-    DBErrors nZapSelectTxRet = CWalletDB(strWalletFile,\"cr+\").ZapSelectTx(vHashIn, vHashOut);\n+    DBErrors nZapSelectTxRet = CWalletDB(*dbw,\"cr+\").ZapSelectTx(vHashIn, vHashOut);\n     for (uint256 hash : vHashOut)\n         mapWallet.erase(hash);\n \n     if (nZapSelectTxRet == DB_NEED_REWRITE)\n     {\n-        if (CDB::Rewrite(strWalletFile, \"\\x04pool\"))\n+        if (dbw->Rewrite(\"\\x04pool\"))\n         {\n             setKeyPool.clear();\n             // Note: can't top-up keypool here, because wallet is locked.\n@@ -2902,13 +2997,11 @@ DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256\n \n DBErrors CWallet::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n {\n-    if (!fFileBacked)\n-        return DB_LOAD_OK;\n     vchDefaultKey = CPubKey();\n-    DBErrors nZapWalletTxRet = CWalletDB(strWalletFile,\"cr+\").ZapWalletTx(vWtx);\n+    DBErrors nZapWalletTxRet = CWalletDB(*dbw,\"cr+\").ZapWalletTx(vWtx);\n     if (nZapWalletTxRet == DB_NEED_REWRITE)\n     {\n-        if (CDB::Rewrite(strWalletFile, \"\\x04pool\"))\n+        if (dbw->Rewrite(\"\\x04pool\"))\n         {\n             LOCK(cs_wallet);\n             setKeyPool.clear();\n@@ -2938,45 +3031,50 @@ bool CWallet::SetAddressBook(const CTxDestination& address, const std::string& s\n     }\n     NotifyAddressBookChanged(this, address, strName, ::IsMine(*this, address) != ISMINE_NO,\n                              strPurpose, (fUpdated ? CT_UPDATED : CT_NEW) );\n-    if (!fFileBacked)\n+    if (!strPurpose.empty() && !CWalletDB(*dbw).WritePurpose(CBitcoinAddress(address).ToString(), strPurpose))\n         return false;\n-    if (!strPurpose.empty() && !CWalletDB(strWalletFile).WritePurpose(CBitcoinAddress(address).ToString(), strPurpose))\n-        return false;\n-    return CWalletDB(strWalletFile).WriteName(CBitcoinAddress(address).ToString(), strName);\n+    return CWalletDB(*dbw).WriteName(CBitcoinAddress(address).ToString(), strName);\n }\n \n bool CWallet::DelAddressBook(const CTxDestination& address)\n {\n     {\n         LOCK(cs_wallet); // mapAddressBook\n \n-        if(fFileBacked)\n+        // Delete destdata tuples associated with address\n+        std::string strAddress = CBitcoinAddress(address).ToString();\n+        BOOST_FOREACH(const PAIRTYPE(std::string, std::string) &item, mapAddressBook[address].destdata)\n         {\n-            // Delete destdata tuples associated with address\n-            std::string strAddress = CBitcoinAddress(address).ToString();\n-            BOOST_FOREACH(const PAIRTYPE(std::string, std::string) &item, mapAddressBook[address].destdata)\n-            {\n-                CWalletDB(strWalletFile).EraseDestData(strAddress, item.first);\n-            }\n+            CWalletDB(*dbw).EraseDestData(strAddress, item.first);\n         }\n         mapAddressBook.erase(address);\n     }\n \n     NotifyAddressBookChanged(this, address, \"\", ::IsMine(*this, address) != ISMINE_NO, \"\", CT_DELETED);\n \n-    if (!fFileBacked)\n-        return false;\n-    CWalletDB(strWalletFile).ErasePurpose(CBitcoinAddress(address).ToString());\n-    return CWalletDB(strWalletFile).EraseName(CBitcoinAddress(address).ToString());\n+    CWalletDB(*dbw).ErasePurpose(CBitcoinAddress(address).ToString());\n+    return CWalletDB(*dbw).EraseName(CBitcoinAddress(address).ToString());\n }\n \n-bool CWallet::SetDefaultKey(const CPubKey &vchPubKey)\n+const std::string& CWallet::GetAccountName(const CScript& scriptPubKey) const\n {\n-    if (fFileBacked)\n-    {\n-        if (!CWalletDB(strWalletFile).WriteDefaultKey(vchPubKey))\n-            return false;\n+    CTxDestination address;\n+    if (ExtractDestination(scriptPubKey, address) && !scriptPubKey.IsUnspendable()) {\n+        auto mi = mapAddressBook.find(address);\n+        if (mi != mapAddressBook.end()) {\n+            return mi->second.name;\n+        }\n     }\n+    // A scriptPubKey that doesn't have an entry in the address book is\n+    // associated with the default account (\"\").\n+    const static std::string DEFAULT_ACCOUNT_NAME;\n+    return DEFAULT_ACCOUNT_NAME;\n+}\n+\n+bool CWallet::SetDefaultKey(const CPubKey &vchPubKey)\n+{\n+    if (!CWalletDB(*dbw).WriteDefaultKey(vchPubKey))\n+        return false;\n     vchDefaultKey = vchPubKey;\n     return true;\n }\n@@ -2989,7 +3087,7 @@ bool CWallet::NewKeyPool()\n {\n     {\n         LOCK(cs_wallet);\n-        CWalletDB walletdb(strWalletFile);\n+        CWalletDB walletdb(*dbw);\n         BOOST_FOREACH(int64_t nIndex, setKeyPool)\n             walletdb.ErasePool(nIndex);\n         setKeyPool.clear();\n@@ -3010,7 +3108,7 @@ size_t CWallet::KeypoolCountExternalKeys()\n     if (!IsHDEnabled() || !CanSupportFeature(FEATURE_HD_SPLIT))\n         return setKeyPool.size();\n \n-    CWalletDB walletdb(strWalletFile);\n+    CWalletDB walletdb(*dbw);\n \n     // count amount of external keys\n     size_t amountE = 0;\n@@ -3053,7 +3151,7 @@ bool CWallet::TopUpKeyPool(unsigned int kpSize)\n             missingInternal = 0;\n         }\n         bool internal = false;\n-        CWalletDB walletdb(strWalletFile);\n+        CWalletDB walletdb(*dbw);\n         for (int64_t i = missingInternal + missingExternal; i--;)\n         {\n             int64_t nEnd = 1;\n@@ -3084,7 +3182,7 @@ void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool int\n         if(setKeyPool.empty())\n             return;\n \n-        CWalletDB walletdb(strWalletFile);\n+        CWalletDB walletdb(*dbw);\n \n         // try to find a key that matches the internal/external filter\n         for(const int64_t& id : setKeyPool)\n@@ -3110,11 +3208,8 @@ void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool int\n void CWallet::KeepKey(int64_t nIndex)\n {\n     // Remove from key pool\n-    if (fFileBacked)\n-    {\n-        CWalletDB walletdb(strWalletFile);\n-        walletdb.ErasePool(nIndex);\n-    }\n+    CWalletDB walletdb(*dbw);\n+    walletdb.ErasePool(nIndex);\n     LogPrintf(\"keypool keep %d\\n\", nIndex);\n }\n \n@@ -3156,7 +3251,7 @@ int64_t CWallet::GetOldestKeyPoolTime()\n         return GetTime();\n \n     CKeyPool keypool;\n-    CWalletDB walletdb(strWalletFile);\n+    CWalletDB walletdb(*dbw);\n \n     if (IsHDEnabled() && CanSupportFeature(FEATURE_HD_SPLIT))\n     {\n@@ -3274,11 +3369,11 @@ std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings()\n         }\n \n         // group lone addrs by themselves\n-        for (unsigned int i = 0; i < pcoin->tx->vout.size(); i++)\n-            if (IsMine(pcoin->tx->vout[i]))\n+        for (const auto& txout : pcoin->tx->vout)\n+            if (IsMine(txout))\n             {\n                 CTxDestination address;\n-                if(!ExtractDestination(pcoin->tx->vout[i].scriptPubKey, address))\n+                if(!ExtractDestination(txout.scriptPubKey, address))\n                     continue;\n                 grouping.insert(address);\n                 groupings.insert(grouping);\n@@ -3322,37 +3417,6 @@ std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings()\n     return ret;\n }\n \n-CAmount CWallet::GetAccountBalance(const std::string& strAccount, int nMinDepth, const isminefilter& filter)\n-{\n-    CWalletDB walletdb(strWalletFile);\n-    return GetAccountBalance(walletdb, strAccount, nMinDepth, filter);\n-}\n-\n-CAmount CWallet::GetAccountBalance(CWalletDB& walletdb, const std::string& strAccount, int nMinDepth, const isminefilter& filter)\n-{\n-    CAmount nBalance = 0;\n-\n-    // Tally wallet transactions\n-    for (std::map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n-    {\n-        const CWalletTx& wtx = (*it).second;\n-        if (!CheckFinalTx(wtx) || wtx.GetBlocksToMaturity() > 0 || wtx.GetDepthInMainChain() < 0)\n-            continue;\n-\n-        CAmount nReceived, nSent, nFee;\n-        wtx.GetAccountAmounts(strAccount, nReceived, nSent, nFee, filter);\n-\n-        if (nReceived != 0 && wtx.GetDepthInMainChain() >= nMinDepth)\n-            nBalance += nReceived;\n-        nBalance -= nSent + nFee;\n-    }\n-\n-    // Tally internal accounting entries\n-    nBalance += walletdb.GetAccountCreditDebit(strAccount);\n-\n-    return nBalance;\n-}\n-\n std::set<CTxDestination> CWallet::GetAccountAddresses(const std::string& strAccount) const\n {\n     LOCK(cs_wallet);\n@@ -3404,7 +3468,7 @@ void CWallet::GetAllReserveKeys(std::set<CKeyID>& setAddress) const\n {\n     setAddress.clear();\n \n-    CWalletDB walletdb(strWalletFile);\n+    CWalletDB walletdb(*dbw);\n \n     LOCK2(cs_main, cs_wallet);\n     BOOST_FOREACH(const int64_t& id, setKeyPool)\n@@ -3457,7 +3521,7 @@ bool CWallet::IsLockedCoin(uint256 hash, unsigned int n) const\n     return (setLockedCoins.count(outpt) > 0);\n }\n \n-void CWallet::ListLockedCoins(std::vector<COutPoint>& vOutpts)\n+void CWallet::ListLockedCoins(std::vector<COutPoint>& vOutpts) const\n {\n     AssertLockHeld(cs_wallet); // setLockedCoins\n     for (std::set<COutPoint>::iterator it = setLockedCoins.begin();\n@@ -3626,18 +3690,14 @@ bool CWallet::AddDestData(const CTxDestination &dest, const std::string &key, co\n         return false;\n \n     mapAddressBook[dest].destdata.insert(std::make_pair(key, value));\n-    if (!fFileBacked)\n-        return true;\n-    return CWalletDB(strWalletFile).WriteDestData(CBitcoinAddress(dest).ToString(), key, value);\n+    return CWalletDB(*dbw).WriteDestData(CBitcoinAddress(dest).ToString(), key, value);\n }\n \n bool CWallet::EraseDestData(const CTxDestination &dest, const std::string &key)\n {\n     if (!mapAddressBook[dest].destdata.erase(key))\n         return false;\n-    if (!fFileBacked)\n-        return true;\n-    return CWalletDB(strWalletFile).EraseDestData(CBitcoinAddress(dest).ToString(), key);\n+    return CWalletDB(*dbw).EraseDestData(CBitcoinAddress(dest).ToString(), key);\n }\n \n bool CWallet::LoadDestData(const CTxDestination &dest, const std::string &key, const std::string &value)\n@@ -3662,6 +3722,20 @@ bool CWallet::GetDestData(const CTxDestination &dest, const std::string &key, st\n     return false;\n }\n \n+std::vector<std::string> CWallet::GetDestValues(const std::string& prefix) const\n+{\n+    LOCK(cs_wallet);\n+    std::vector<std::string> values;\n+    for (const auto& address : mapAddressBook) {\n+        for (const auto& data : address.second.destdata) {\n+            if (!data.first.compare(0, prefix.size(), prefix)) {\n+                values.emplace_back(data.second);\n+            }\n+        }\n+    }\n+    return values;\n+}\n+\n std::string CWallet::GetWalletHelpString(bool showDebug)\n {\n     std::string strUsage = HelpMessageGroup(_(\"Wallet options:\"));\n@@ -3707,7 +3781,8 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n     if (GetBoolArg(\"-zapwallettxes\", false)) {\n         uiInterface.InitMessage(_(\"Zapping all transactions from wallet...\"));\n \n-        CWallet *tempWallet = new CWallet(walletFile);\n+        std::unique_ptr<CWalletDBWrapper> dbw(new CWalletDBWrapper(&bitdb, walletFile));\n+        CWallet *tempWallet = new CWallet(std::move(dbw));\n         DBErrors nZapWalletRet = tempWallet->ZapWalletTx(vWtx);\n         if (nZapWalletRet != DB_LOAD_OK) {\n             InitError(strprintf(_(\"Error loading %s: Wallet corrupted\"), walletFile));\n@@ -3722,7 +3797,8 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n \n     int64_t nStart = GetTimeMillis();\n     bool fFirstRun = true;\n-    CWallet *walletInstance = new CWallet(walletFile);\n+    std::unique_ptr<CWalletDBWrapper> dbw(new CWalletDBWrapper(&bitdb, walletFile));\n+    CWallet *walletInstance = new CWallet(std::move(dbw));\n     DBErrors nLoadWalletRet = walletInstance->LoadWallet(fFirstRun);\n     if (nLoadWalletRet != DB_LOAD_OK)\n     {\n@@ -3813,7 +3889,7 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n     CBlockIndex *pindexRescan = chainActive.Genesis();\n     if (!GetBoolArg(\"-rescan\", false))\n     {\n-        CWalletDB walletdb(walletFile);\n+        CWalletDB walletdb(*walletInstance->dbw);\n         CBlockLocator locator;\n         if (walletdb.ReadBestBlock(locator))\n             pindexRescan = FindForkInGlobalIndex(chainActive, locator);\n@@ -3846,7 +3922,7 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n         // Restore wallet transaction metadata after -zapwallettxes=1\n         if (GetBoolArg(\"-zapwallettxes\", false) && GetArg(\"-zapwallettxes\", \"1\") != \"2\")\n         {\n-            CWalletDB walletdb(walletFile);\n+            CWalletDB walletdb(*walletInstance->dbw);\n \n             BOOST_FOREACH(const CWalletTx& wtxOld, vWtx)\n             {\n@@ -4006,38 +4082,7 @@ bool CWallet::ParameterInteraction()\n \n bool CWallet::BackupWallet(const std::string& strDest)\n {\n-    if (!fFileBacked)\n-        return false;\n-    while (true)\n-    {\n-        {\n-            LOCK(bitdb.cs_db);\n-            if (!bitdb.mapFileUseCount.count(strWalletFile) || bitdb.mapFileUseCount[strWalletFile] == 0)\n-            {\n-                // Flush log data to the dat file\n-                bitdb.CloseDb(strWalletFile);\n-                bitdb.CheckpointLSN(strWalletFile);\n-                bitdb.mapFileUseCount.erase(strWalletFile);\n-\n-                // Copy wallet file\n-                fs::path pathSrc = GetDataDir() / strWalletFile;\n-                fs::path pathDest(strDest);\n-                if (fs::is_directory(pathDest))\n-                    pathDest /= strWalletFile;\n-\n-                try {\n-                    fs::copy_file(pathSrc, pathDest, fs::copy_option::overwrite_if_exists);\n-                    LogPrintf(\"copied %s to %s\\n\", strWalletFile, pathDest.string());\n-                    return true;\n-                } catch (const fs::filesystem_error& e) {\n-                    LogPrintf(\"error copying %s to %s - %s\\n\", strWalletFile, pathDest.string(), e.what());\n-                    return false;\n-                }\n-            }\n-        }\n-        MilliSleep(100);\n-    }\n-    return false;\n+    return dbw->Backup(strDest);\n }\n \n CKeyPool::CKeyPool()"
      },
      {
        "sha": "11b2f7a66347b4b4500ebb7b8f1e2afc33967c23",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 53,
        "deletions": 27,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -7,6 +7,7 @@\n #define BITCOIN_WALLET_WALLET_H\n \n #include \"amount.h\"\n+#include \"policy/feerate.h\"\n #include \"streams.h\"\n #include \"tinyformat.h\"\n #include \"ui_interface.h\"\n@@ -73,6 +74,7 @@ class CReserveKey;\n class CScript;\n class CScheduler;\n class CTxMemPool;\n+class CBlockPolicyEstimator;\n class CWalletTx;\n \n /** (client) version numbers for particular wallet features */\n@@ -450,9 +452,6 @@ class CWalletTx : public CMerkleTx\n     void GetAmounts(std::list<COutputEntry>& listReceived,\n                     std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const;\n \n-    void GetAccountAmounts(const std::string& strAccount, CAmount& nReceived,\n-                           CAmount& nSent, CAmount& nFee, const isminefilter& filter) const;\n-\n     bool IsFromMe(const isminefilter& filter) const\n     {\n         return (GetDebit(filter) > 0);\n@@ -698,8 +697,6 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     /* HD derive new child key (on internal or external chain) */\n     void DeriveNewChildKey(CKeyMetadata& metadata, CKey& secret, bool internal = false);\n \n-    bool fFileBacked;\n-\n     std::set<int64_t> setKeyPool;\n \n     int64_t nTimeFirstKey;\n@@ -715,17 +712,33 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n      */\n     bool AddWatchOnly(const CScript& dest) override;\n \n+    std::unique_ptr<CWalletDBWrapper> dbw;\n+\n public:\n     /*\n      * Main wallet lock.\n-     * This lock protects all the fields added by CWallet\n-     *   except for:\n-     *      fFileBacked (immutable after instantiation)\n-     *      strWalletFile (immutable after instantiation)\n+     * This lock protects all the fields added by CWallet.\n      */\n     mutable CCriticalSection cs_wallet;\n \n-    const std::string strWalletFile;\n+    /** Get database handle used by this wallet. Ideally this function would\n+     * not be necessary.\n+     */\n+    CWalletDBWrapper& GetDBHandle()\n+    {\n+        return *dbw;\n+    }\n+\n+    /** Get a name for this wallet for logging/debugging purposes.\n+     */\n+    std::string GetName() const\n+    {\n+        if (dbw) {\n+            return dbw->GetName();\n+        } else {\n+            return \"dummy\";\n+        }\n+    }\n \n     void LoadKeyPool(int nIndex, const CKeyPool &keypool)\n     {\n@@ -747,15 +760,16 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     MasterKeyMap mapMasterKeys;\n     unsigned int nMasterKeyMaxID;\n \n-    CWallet()\n+    // Create wallet with dummy database handle\n+    CWallet(): dbw(new CWalletDBWrapper())\n     {\n         SetNull();\n     }\n \n-    CWallet(const std::string& strWalletFileIn) : strWalletFile(strWalletFileIn)\n+    // Create wallet with passed-in database handle\n+    CWallet(std::unique_ptr<CWalletDBWrapper> dbw_in) : dbw(std::move(dbw_in))\n     {\n         SetNull();\n-        fFileBacked = true;\n     }\n \n     ~CWallet()\n@@ -768,7 +782,6 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     {\n         nWalletVersion = FEATURE_BASE;\n         nWalletMaxVersion = FEATURE_BASE;\n-        fFileBacked = false;\n         nMasterKeyMaxID = 0;\n         pwalletdbEncryption = NULL;\n         nOrderPosNext = 0;\n@@ -805,7 +818,17 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     /**\n      * populate vCoins with vector of available COutputs.\n      */\n-    void AvailableCoins(std::vector<COutput>& vCoins, bool fOnlySafe=true, const CCoinControl *coinControl = NULL, bool fIncludeZeroValue=false) const;\n+    void AvailableCoins(std::vector<COutput>& vCoins, bool fOnlySafe=true, const CCoinControl *coinControl = NULL, const CAmount& nMinimumAmount = 1, const CAmount& nMaximumAmount = MAX_MONEY, const CAmount& nMinimumSumAmount = MAX_MONEY, const uint64_t& nMaximumCount = 0, const int& nMinDepth = 0, const int& nMaxDepth = 9999999) const;\n+\n+    /**\n+     * Return list of available coins and locked coins grouped by non-change output address.\n+     */\n+    std::map<CTxDestination, std::vector<COutput>> ListCoins() const;\n+\n+    /**\n+     * Find non-change parent output.\n+     */\n+    const CTxOut& FindNonChangeParentOutput(const CTransaction& tx, int output) const;\n \n     /**\n      * Shuffle and select coins until nTargetValue is reached while avoiding\n@@ -821,7 +844,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     void LockCoin(const COutPoint& output);\n     void UnlockCoin(const COutPoint& output);\n     void UnlockAllCoins();\n-    void ListLockedCoins(std::vector<COutPoint>& vOutpts);\n+    void ListLockedCoins(std::vector<COutPoint>& vOutpts) const;\n \n     /*\n      * Rescan abort properties\n@@ -860,6 +883,8 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     bool LoadDestData(const CTxDestination &dest, const std::string &key, const std::string &value);\n     //! Look up a destination data tuple in the store, return true if found false otherwise\n     bool GetDestData(const CTxDestination &dest, const std::string &key, std::string *value) const;\n+    //! Get all destination values matching a prefix.\n+    std::vector<std::string> GetDestValues(const std::string& prefix) const;\n \n     //! Adds a watch-only address to the store, and saves it to disk.\n     bool AddWatchOnly(const CScript& dest, int64_t nCreateTime);\n@@ -903,6 +928,8 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     CAmount GetWatchOnlyBalance() const;\n     CAmount GetUnconfirmedWatchOnlyBalance() const;\n     CAmount GetImmatureWatchOnlyBalance() const;\n+    CAmount GetLegacyBalance(const isminefilter& filter, int minDepth, const std::string* account) const;\n+    CAmount GetAvailableBalance(const CCoinControl* coinControl = nullptr) const;\n \n     /**\n      * Insert additional inputs into the transaction by\n@@ -932,12 +959,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n      * Estimate the minimum fee considering user set parameters\n      * and the required fee\n      */\n-    static CAmount GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarget, const CTxMemPool& pool);\n-    /**\n-     * Estimate the minimum fee considering required fee and targetFee or if 0\n-     * then fee estimation for nConfirmTarget\n-     */\n-    static CAmount GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarget, const CTxMemPool& pool, CAmount targetFee);\n+    static CAmount GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarget, const CTxMemPool& pool, const CBlockPolicyEstimator& estimator, bool ignoreUserSetFee = false);\n     /**\n      * Return the minimum required fee taking into account the\n      * floating relay fee and user set minimum transaction fee\n@@ -957,8 +979,6 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     std::set< std::set<CTxDestination> > GetAddressGroupings();\n     std::map<CTxDestination, CAmount> GetAddressBalances();\n \n-    CAmount GetAccountBalance(const std::string& strAccount, int nMinDepth, const isminefilter& filter);\n-    CAmount GetAccountBalance(CWalletDB& walletdb, const std::string& strAccount, int nMinDepth, const isminefilter& filter);\n     std::set<CTxDestination> GetAccountAddresses(const std::string& strAccount) const;\n \n     isminetype IsMine(const CTxIn& txin) const;\n@@ -989,6 +1009,8 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n \n     bool DelAddressBook(const CTxDestination& address);\n \n+    const std::string& GetAccountName(const CScript& scriptPubKey) const;\n+\n     void Inventory(const uint256 &hash) override\n     {\n         {\n@@ -1057,6 +1079,9 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     /** Set whether this wallet broadcasts transactions. */\n     void SetBroadcastTransactions(bool broadcast) { fBroadcastTransactions = broadcast; }\n \n+    /** Return whether transaction can be abandoned */\n+    bool TransactionCanBeAbandoned(const uint256& hashTx) const;\n+\n     /* Mark a transaction (and it in-wallet descendants) as abandoned so its inputs may be respent. */\n     bool AbandonTransaction(const uint256& hashTx);\n \n@@ -1092,9 +1117,10 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     CPubKey GenerateNewHDMasterKey();\n     \n     /* Set the current HD master key (will reset the chain child index counters)\n-       If possibleOldChain is provided, the parameters from the old chain (version)\n-       will be preserved. */\n-    bool SetHDMasterKey(const CPubKey& key, CHDChain *possibleOldChain = nullptr);\n+       Sets the master key's version based on the current wallet version (so the\n+       caller must ensure the current wallet version is correct before calling\n+       this function). */\n+    bool SetHDMasterKey(const CPubKey& key);\n };\n \n /** A key allocated from the key pool. */"
      },
      {
        "sha": "342c797dd3ad118f34980da7c5afb2d483d1b9b8",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 70,
        "deletions": 45,
        "changes": 115,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -6,9 +6,9 @@\n #include \"wallet/walletdb.h\"\n \n #include \"base58.h\"\n+#include \"consensus/tx_verify.h\"\n #include \"consensus/validation.h\"\n #include \"fs.h\"\n-#include \"validation.h\" // For CheckTransaction\n #include \"protocol.h\"\n #include \"serialize.h\"\n #include \"sync.h\"\n@@ -33,46 +33,46 @@ static std::atomic<unsigned int> nWalletDBUpdateCounter;\n bool CWalletDB::WriteName(const std::string& strAddress, const std::string& strName)\n {\n     nWalletDBUpdateCounter++;\n-    return Write(make_pair(std::string(\"name\"), strAddress), strName);\n+    return batch.Write(std::make_pair(std::string(\"name\"), strAddress), strName);\n }\n \n bool CWalletDB::EraseName(const std::string& strAddress)\n {\n     // This should only be used for sending addresses, never for receiving addresses,\n     // receiving addresses must always have an address book entry if they're not change return.\n     nWalletDBUpdateCounter++;\n-    return Erase(make_pair(std::string(\"name\"), strAddress));\n+    return batch.Erase(std::make_pair(std::string(\"name\"), strAddress));\n }\n \n bool CWalletDB::WritePurpose(const std::string& strAddress, const std::string& strPurpose)\n {\n     nWalletDBUpdateCounter++;\n-    return Write(make_pair(std::string(\"purpose\"), strAddress), strPurpose);\n+    return batch.Write(std::make_pair(std::string(\"purpose\"), strAddress), strPurpose);\n }\n \n bool CWalletDB::ErasePurpose(const std::string& strPurpose)\n {\n     nWalletDBUpdateCounter++;\n-    return Erase(make_pair(std::string(\"purpose\"), strPurpose));\n+    return batch.Erase(std::make_pair(std::string(\"purpose\"), strPurpose));\n }\n \n bool CWalletDB::WriteTx(const CWalletTx& wtx)\n {\n     nWalletDBUpdateCounter++;\n-    return Write(std::make_pair(std::string(\"tx\"), wtx.GetHash()), wtx);\n+    return batch.Write(std::make_pair(std::string(\"tx\"), wtx.GetHash()), wtx);\n }\n \n bool CWalletDB::EraseTx(uint256 hash)\n {\n     nWalletDBUpdateCounter++;\n-    return Erase(std::make_pair(std::string(\"tx\"), hash));\n+    return batch.Erase(std::make_pair(std::string(\"tx\"), hash));\n }\n \n bool CWalletDB::WriteKey(const CPubKey& vchPubKey, const CPrivKey& vchPrivKey, const CKeyMetadata& keyMeta)\n {\n     nWalletDBUpdateCounter++;\n \n-    if (!Write(std::make_pair(std::string(\"keymeta\"), vchPubKey),\n+    if (!batch.Write(std::make_pair(std::string(\"keymeta\"), vchPubKey),\n                keyMeta, false))\n         return false;\n \n@@ -82,7 +82,7 @@ bool CWalletDB::WriteKey(const CPubKey& vchPubKey, const CPrivKey& vchPrivKey, c\n     vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n     vchKey.insert(vchKey.end(), vchPrivKey.begin(), vchPrivKey.end());\n \n-    return Write(std::make_pair(std::string(\"key\"), vchPubKey), std::make_pair(vchPrivKey, Hash(vchKey.begin(), vchKey.end())), false);\n+    return batch.Write(std::make_pair(std::string(\"key\"), vchPubKey), std::make_pair(vchPrivKey, Hash(vchKey.begin(), vchKey.end())), false);\n }\n \n bool CWalletDB::WriteCryptedKey(const CPubKey& vchPubKey,\n@@ -92,109 +92,109 @@ bool CWalletDB::WriteCryptedKey(const CPubKey& vchPubKey,\n     const bool fEraseUnencryptedKey = true;\n     nWalletDBUpdateCounter++;\n \n-    if (!Write(std::make_pair(std::string(\"keymeta\"), vchPubKey),\n+    if (!batch.Write(std::make_pair(std::string(\"keymeta\"), vchPubKey),\n             keyMeta))\n         return false;\n \n-    if (!Write(std::make_pair(std::string(\"ckey\"), vchPubKey), vchCryptedSecret, false))\n+    if (!batch.Write(std::make_pair(std::string(\"ckey\"), vchPubKey), vchCryptedSecret, false))\n         return false;\n     if (fEraseUnencryptedKey)\n     {\n-        Erase(std::make_pair(std::string(\"key\"), vchPubKey));\n-        Erase(std::make_pair(std::string(\"wkey\"), vchPubKey));\n+        batch.Erase(std::make_pair(std::string(\"key\"), vchPubKey));\n+        batch.Erase(std::make_pair(std::string(\"wkey\"), vchPubKey));\n     }\n     return true;\n }\n \n bool CWalletDB::WriteMasterKey(unsigned int nID, const CMasterKey& kMasterKey)\n {\n     nWalletDBUpdateCounter++;\n-    return Write(std::make_pair(std::string(\"mkey\"), nID), kMasterKey, true);\n+    return batch.Write(std::make_pair(std::string(\"mkey\"), nID), kMasterKey, true);\n }\n \n bool CWalletDB::WriteCScript(const uint160& hash, const CScript& redeemScript)\n {\n     nWalletDBUpdateCounter++;\n-    return Write(std::make_pair(std::string(\"cscript\"), hash), *(const CScriptBase*)(&redeemScript), false);\n+    return batch.Write(std::make_pair(std::string(\"cscript\"), hash), *(const CScriptBase*)(&redeemScript), false);\n }\n \n bool CWalletDB::WriteWatchOnly(const CScript &dest, const CKeyMetadata& keyMeta)\n {\n     nWalletDBUpdateCounter++;\n-    if (!Write(std::make_pair(std::string(\"watchmeta\"), *(const CScriptBase*)(&dest)), keyMeta))\n+    if (!batch.Write(std::make_pair(std::string(\"watchmeta\"), *(const CScriptBase*)(&dest)), keyMeta))\n         return false;\n-    return Write(std::make_pair(std::string(\"watchs\"), *(const CScriptBase*)(&dest)), '1');\n+    return batch.Write(std::make_pair(std::string(\"watchs\"), *(const CScriptBase*)(&dest)), '1');\n }\n \n bool CWalletDB::EraseWatchOnly(const CScript &dest)\n {\n     nWalletDBUpdateCounter++;\n-    if (!Erase(std::make_pair(std::string(\"watchmeta\"), *(const CScriptBase*)(&dest))))\n+    if (!batch.Erase(std::make_pair(std::string(\"watchmeta\"), *(const CScriptBase*)(&dest))))\n         return false;\n-    return Erase(std::make_pair(std::string(\"watchs\"), *(const CScriptBase*)(&dest)));\n+    return batch.Erase(std::make_pair(std::string(\"watchs\"), *(const CScriptBase*)(&dest)));\n }\n \n bool CWalletDB::WriteBestBlock(const CBlockLocator& locator)\n {\n     nWalletDBUpdateCounter++;\n-    Write(std::string(\"bestblock\"), CBlockLocator()); // Write empty block locator so versions that require a merkle branch automatically rescan\n-    return Write(std::string(\"bestblock_nomerkle\"), locator);\n+    batch.Write(std::string(\"bestblock\"), CBlockLocator()); // Write empty block locator so versions that require a merkle branch automatically rescan\n+    return batch.Write(std::string(\"bestblock_nomerkle\"), locator);\n }\n \n bool CWalletDB::ReadBestBlock(CBlockLocator& locator)\n {\n-    if (Read(std::string(\"bestblock\"), locator) && !locator.vHave.empty()) return true;\n-    return Read(std::string(\"bestblock_nomerkle\"), locator);\n+    if (batch.Read(std::string(\"bestblock\"), locator) && !locator.vHave.empty()) return true;\n+    return batch.Read(std::string(\"bestblock_nomerkle\"), locator);\n }\n \n bool CWalletDB::WriteOrderPosNext(int64_t nOrderPosNext)\n {\n     nWalletDBUpdateCounter++;\n-    return Write(std::string(\"orderposnext\"), nOrderPosNext);\n+    return batch.Write(std::string(\"orderposnext\"), nOrderPosNext);\n }\n \n bool CWalletDB::WriteDefaultKey(const CPubKey& vchPubKey)\n {\n     nWalletDBUpdateCounter++;\n-    return Write(std::string(\"defaultkey\"), vchPubKey);\n+    return batch.Write(std::string(\"defaultkey\"), vchPubKey);\n }\n \n bool CWalletDB::ReadPool(int64_t nPool, CKeyPool& keypool)\n {\n-    return Read(std::make_pair(std::string(\"pool\"), nPool), keypool);\n+    return batch.Read(std::make_pair(std::string(\"pool\"), nPool), keypool);\n }\n \n bool CWalletDB::WritePool(int64_t nPool, const CKeyPool& keypool)\n {\n     nWalletDBUpdateCounter++;\n-    return Write(std::make_pair(std::string(\"pool\"), nPool), keypool);\n+    return batch.Write(std::make_pair(std::string(\"pool\"), nPool), keypool);\n }\n \n bool CWalletDB::ErasePool(int64_t nPool)\n {\n     nWalletDBUpdateCounter++;\n-    return Erase(std::make_pair(std::string(\"pool\"), nPool));\n+    return batch.Erase(std::make_pair(std::string(\"pool\"), nPool));\n }\n \n bool CWalletDB::WriteMinVersion(int nVersion)\n {\n-    return Write(std::string(\"minversion\"), nVersion);\n+    return batch.Write(std::string(\"minversion\"), nVersion);\n }\n \n bool CWalletDB::ReadAccount(const std::string& strAccount, CAccount& account)\n {\n     account.SetNull();\n-    return Read(make_pair(std::string(\"acc\"), strAccount), account);\n+    return batch.Read(std::make_pair(std::string(\"acc\"), strAccount), account);\n }\n \n bool CWalletDB::WriteAccount(const std::string& strAccount, const CAccount& account)\n {\n-    return Write(make_pair(std::string(\"acc\"), strAccount), account);\n+    return batch.Write(std::make_pair(std::string(\"acc\"), strAccount), account);\n }\n \n bool CWalletDB::WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry)\n {\n-    return Write(std::make_pair(std::string(\"acentry\"), std::make_pair(acentry.strAccount, nAccEntryNum)), acentry);\n+    return batch.Write(std::make_pair(std::string(\"acentry\"), std::make_pair(acentry.strAccount, nAccEntryNum)), acentry);\n }\n \n bool CWalletDB::WriteAccountingEntry_Backend(const CAccountingEntry& acentry)\n@@ -218,7 +218,7 @@ void CWalletDB::ListAccountCreditDebit(const std::string& strAccount, std::list<\n {\n     bool fAllAccounts = (strAccount == \"*\");\n \n-    Dbc* pcursor = GetCursor();\n+    Dbc* pcursor = batch.GetCursor();\n     if (!pcursor)\n         throw std::runtime_error(std::string(__func__) + \": cannot create DB cursor\");\n     bool setRange = true;\n@@ -229,7 +229,7 @@ void CWalletDB::ListAccountCreditDebit(const std::string& strAccount, std::list<\n         if (setRange)\n             ssKey << std::make_pair(std::string(\"acentry\"), std::make_pair((fAllAccounts ? std::string(\"\") : strAccount), uint64_t(0)));\n         CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n-        int ret = ReadAtCursor(pcursor, ssKey, ssValue, setRange);\n+        int ret = batch.ReadAtCursor(pcursor, ssKey, ssValue, setRange);\n         setRange = false;\n         if (ret == DB_NOTFOUND)\n             break;\n@@ -560,15 +560,15 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n     LOCK(pwallet->cs_wallet);\n     try {\n         int nMinVersion = 0;\n-        if (Read((std::string)\"minversion\", nMinVersion))\n+        if (batch.Read((std::string)\"minversion\", nMinVersion))\n         {\n             if (nMinVersion > CLIENT_VERSION)\n                 return DB_TOO_NEW;\n             pwallet->LoadMinVersion(nMinVersion);\n         }\n \n         // Get cursor\n-        Dbc* pcursor = GetCursor();\n+        Dbc* pcursor = batch.GetCursor();\n         if (!pcursor)\n         {\n             LogPrintf(\"Error getting wallet database cursor\\n\");\n@@ -580,7 +580,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n             // Read next record\n             CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n             CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n-            int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n+            int ret = batch.ReadAtCursor(pcursor, ssKey, ssValue);\n             if (ret == DB_NOTFOUND)\n                 break;\n             else if (ret != 0)\n@@ -664,14 +664,14 @@ DBErrors CWalletDB::FindWalletTx(std::vector<uint256>& vTxHash, std::vector<CWal\n \n     try {\n         int nMinVersion = 0;\n-        if (Read((std::string)\"minversion\", nMinVersion))\n+        if (batch.Read((std::string)\"minversion\", nMinVersion))\n         {\n             if (nMinVersion > CLIENT_VERSION)\n                 return DB_TOO_NEW;\n         }\n \n         // Get cursor\n-        Dbc* pcursor = GetCursor();\n+        Dbc* pcursor = batch.GetCursor();\n         if (!pcursor)\n         {\n             LogPrintf(\"Error getting wallet database cursor\\n\");\n@@ -683,7 +683,7 @@ DBErrors CWalletDB::FindWalletTx(std::vector<uint256>& vTxHash, std::vector<CWal\n             // Read next record\n             CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n             CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n-            int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n+            int ret = batch.ReadAtCursor(pcursor, ssKey, ssValue);\n             if (ret == DB_NOTFOUND)\n                 break;\n             else if (ret != 0)\n@@ -797,9 +797,9 @@ void MaybeCompactWalletDB()\n \n     if (nLastFlushed != CWalletDB::GetUpdateCounter() && GetTime() - nLastWalletUpdate >= 2)\n     {\n-        const std::string& strFile = pwalletMain->strWalletFile;\n-        if (CDB::PeriodicFlush(strFile))\n+        if (CDB::PeriodicFlush(pwalletMain->GetDBHandle())) {\n             nLastFlushed = CWalletDB::GetUpdateCounter();\n+        }\n     }\n     fOneThread = false;\n }\n@@ -855,20 +855,20 @@ bool CWalletDB::VerifyDatabaseFile(const std::string& walletFile, const fs::path\n bool CWalletDB::WriteDestData(const std::string &address, const std::string &key, const std::string &value)\n {\n     nWalletDBUpdateCounter++;\n-    return Write(std::make_pair(std::string(\"destdata\"), std::make_pair(address, key)), value);\n+    return batch.Write(std::make_pair(std::string(\"destdata\"), std::make_pair(address, key)), value);\n }\n \n bool CWalletDB::EraseDestData(const std::string &address, const std::string &key)\n {\n     nWalletDBUpdateCounter++;\n-    return Erase(std::make_pair(std::string(\"destdata\"), std::make_pair(address, key)));\n+    return batch.Erase(std::make_pair(std::string(\"destdata\"), std::make_pair(address, key)));\n }\n \n \n bool CWalletDB::WriteHDChain(const CHDChain& chain)\n {\n     nWalletDBUpdateCounter++;\n-    return Write(std::string(\"hdchain\"), chain);\n+    return batch.Write(std::string(\"hdchain\"), chain);\n }\n \n void CWalletDB::IncrementUpdateCounter()\n@@ -880,3 +880,28 @@ unsigned int CWalletDB::GetUpdateCounter()\n {\n     return nWalletDBUpdateCounter;\n }\n+\n+bool CWalletDB::TxnBegin()\n+{\n+    return batch.TxnBegin();\n+}\n+\n+bool CWalletDB::TxnCommit()\n+{\n+    return batch.TxnCommit();\n+}\n+\n+bool CWalletDB::TxnAbort()\n+{\n+    return batch.TxnAbort();\n+}\n+\n+bool CWalletDB::ReadVersion(int& nVersion)\n+{\n+    return batch.ReadVersion(nVersion);\n+}\n+\n+bool CWalletDB::WriteVersion(int nVersion)\n+{\n+    return batch.WriteVersion(nVersion);\n+}"
      },
      {
        "sha": "cd9fe279c537ec0037156915f3b41706b9174d7a",
        "filename": "src/wallet/walletdb.h",
        "status": "modified",
        "additions": 36,
        "deletions": 3,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/wallet/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.h?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -17,6 +17,21 @@\n #include <utility>\n #include <vector>\n \n+/**\n+ * Overview of wallet database classes:\n+ *\n+ * - CDBEnv is an environment in which the database exists (has no analog in dbwrapper.h)\n+ * - CWalletDBWrapper represents a wallet database (similar to CDBWrapper in dbwrapper.h)\n+ * - CDB is a low-level database transaction (similar to CDBBatch in dbwrapper.h)\n+ * - CWalletDB is a modifier object for the wallet, and encapsulates a database\n+ *   transaction as well as methods to act on the database (no analog in\n+ *   dbwrapper.h)\n+ *\n+ * The latter two are named confusingly, in contrast to what the names CDB\n+ * and CWalletDB suggest they are transient transaction objects and don't\n+ * represent the database itself.\n+ */\n+\n static const bool DEFAULT_FLUSHWALLET = true;\n \n class CAccount;\n@@ -118,11 +133,16 @@ class CKeyMetadata\n     }\n };\n \n-/** Access to the wallet database */\n-class CWalletDB : public CDB\n+/** Access to the wallet database.\n+ * This should really be named CWalletDBBatch, as it represents a single transaction at the\n+ * database. It will be committed when the object goes out of scope.\n+ * Optionally (on by default) it will flush to disk as well.\n+ */\n+class CWalletDB\n {\n public:\n-    CWalletDB(const std::string& strFilename, const char* pszMode = \"r+\", bool _fFlushOnClose = true) : CDB(strFilename, pszMode, _fFlushOnClose)\n+    CWalletDB(CWalletDBWrapper& dbw, const char* pszMode = \"r+\", bool _fFlushOnClose = true) :\n+        batch(dbw, pszMode, _fFlushOnClose)\n     {\n     }\n \n@@ -194,7 +214,20 @@ class CWalletDB : public CDB\n \n     static void IncrementUpdateCounter();\n     static unsigned int GetUpdateCounter();\n+\n+    //! Begin a new transaction\n+    bool TxnBegin();\n+    //! Commit current transaction\n+    bool TxnCommit();\n+    //! Abort current transaction\n+    bool TxnAbort();\n+    //! Read wallet version\n+    bool ReadVersion(int& nVersion);\n+    //! Write wallet version\n+    bool WriteVersion(int nVersion);\n private:\n+    CDB batch;\n+\n     CWalletDB(const CWalletDB&);\n     void operator=(const CWalletDB&);\n };"
      },
      {
        "sha": "700c39f66ea822f60070e3109243ff9fb13860f8",
        "filename": "src/zmq/zmqpublishnotifier.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/zmq/zmqpublishnotifier.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/src/zmq/zmqpublishnotifier.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqpublishnotifier.cpp?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include \"chain.h\"\n #include \"chainparams.h\"\n #include \"streams.h\"\n #include \"zmqpublishnotifier.h\""
      },
      {
        "sha": "4dd512638d973393292e2448cbe097e9dfb875b4",
        "filename": "test/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/README.md?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -34,7 +34,7 @@ You can run any single test by calling\n \n     test/functional/test_runner.py <testname>\n \n-Or you can run any combination of tests by calling\n+Or you can run any combination (incl. duplicates) of tests by calling\n \n     test/functional/test_runner.py <testname1> <testname2> <testname3> ...\n "
      },
      {
        "sha": "e6c4849702c7fe14796d54f1ea53ab8ce9c51ebe",
        "filename": "test/functional/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/README.md?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -59,7 +59,7 @@ thread.)\n * RPC calls are available in p2p tests.\n \n * Can be used to write free-form tests, where specific p2p-protocol behavior\n-is tested.  Examples: ```p2p-accept-block.py```, ```maxblocksinflight.py```.\n+is tested.  Examples: ```p2p-accept-block.py```, ```p2p-compactblocks.py```.\n \n ## Comptool\n "
      },
      {
        "sha": "974875764168726e56aed0e239007ecd00e6926c",
        "filename": "test/functional/abandonconflict.py",
        "status": "modified",
        "additions": 5,
        "deletions": 11,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/abandonconflict.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/abandonconflict.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/abandonconflict.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -10,22 +10,15 @@\n  which are not included in a block and are not currently in the mempool. It has\n  no effect on transactions which are already conflicted or abandoned.\n \"\"\"\n-\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n-import urllib.parse\n \n class AbandonConflictTest(BitcoinTestFramework):\n     def __init__(self):\n         super().__init__()\n         self.num_nodes = 2\n         self.setup_clean_chain = False\n-\n-    def setup_network(self):\n-        self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-minrelaytxfee=0.00001\"]))\n-        self.nodes.append(start_node(1, self.options.tmpdir))\n-        connect_nodes(self.nodes[0], 1)\n+        self.extra_args = [[\"-minrelaytxfee=0.00001\"], []]\n \n     def run_test(self):\n         self.nodes[1].generate(100)\n@@ -42,8 +35,8 @@ def run_test(self):\n         assert(balance - newbalance < Decimal(\"0.001\")) #no more than fees lost\n         balance = newbalance\n \n-        url = urllib.parse.urlparse(self.nodes[1].url)\n-        self.nodes[0].disconnectnode(url.hostname+\":\"+str(p2p_port(1)))\n+        # Disconnect nodes so node0's transactions don't get into node1's mempool\n+        disconnect_nodes(self.nodes[0], 1)\n \n         # Identify the 10btc outputs\n         nA = next(i for i, vout in enumerate(self.nodes[0].getrawtransaction(txA, 1)[\"vout\"]) if vout[\"value\"] == Decimal(\"10\"))\n@@ -83,8 +76,9 @@ def run_test(self):\n         stop_node(self.nodes[0],0)\n         self.nodes[0]=start_node(0, self.options.tmpdir, [\"-minrelaytxfee=0.0001\"])\n \n-        # Verify txs no longer in mempool\n+        # Verify txs no longer in either node's mempool\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        assert_equal(len(self.nodes[1].getrawmempool()), 0)\n \n         # Not in mempool txs from self should only reduce balance\n         # inputs are still spent, but change not received"
      },
      {
        "sha": "bb83042f35002ea1167caaad11e60a2abe385aa9",
        "filename": "test/functional/bip65-cltv-p2p.py",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/bip65-cltv-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/bip65-cltv-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip65-cltv-p2p.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -39,12 +39,7 @@ class BIP65Test(ComparisonTestFramework):\n     def __init__(self):\n         super().__init__()\n         self.num_nodes = 1\n-\n-    def setup_network(self):\n-        # Must set the blockversion for this test\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir,\n-                                 extra_args=[['-whitelist=127.0.0.1', '-blockversion=3']],\n-                                 binary=[self.options.testbinary])\n+        self.extra_args = [['-whitelist=127.0.0.1', '-blockversion=3']]\n \n     def run_test(self):\n         test = TestManager(self, self.options.tmpdir)"
      },
      {
        "sha": "ddf932c74606b4cb1c1f2942d1b41863cd416b58",
        "filename": "test/functional/bip65-cltv.py",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/bip65-cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/bip65-cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip65-cltv.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -12,15 +12,12 @@ def __init__(self):\n         super().__init__()\n         self.num_nodes = 3\n         self.setup_clean_chain = False\n+        self.extra_args = [[], [\"-blockversion=3\"], [\"-blockversion=4\"]]\n \n     def setup_network(self):\n-        self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, []))\n-        self.nodes.append(start_node(1, self.options.tmpdir, [\"-blockversion=3\"]))\n-        self.nodes.append(start_node(2, self.options.tmpdir, [\"-blockversion=4\"]))\n+        self.setup_nodes()\n         connect_nodes(self.nodes[1], 0)\n         connect_nodes(self.nodes[2], 0)\n-        self.is_network_split = False\n         self.sync_all()\n \n     def run_test(self):"
      },
      {
        "sha": "5a322e8c0e43d387cc2f062620846ae8f10c6680",
        "filename": "test/functional/bip68-112-113-p2p.py",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/bip68-112-113-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/bip68-112-113-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip68-112-113-p2p.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -95,12 +95,7 @@ class BIP68_112_113Test(ComparisonTestFramework):\n     def __init__(self):\n         super().__init__()\n         self.num_nodes = 1\n-\n-    def setup_network(self):\n-        # Must set the blockversion for this test\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir,\n-                                 extra_args=[['-whitelist=127.0.0.1', '-blockversion=4']],\n-                                 binary=[self.options.testbinary])\n+        self.extra_args = [['-whitelist=127.0.0.1', '-blockversion=4']]\n \n     def run_test(self):\n         test = TestManager(self, self.options.tmpdir)"
      },
      {
        "sha": "db66b7719cf862fb3294c731a56538bbbf068ba8",
        "filename": "test/functional/bip68-sequence.py",
        "status": "modified",
        "additions": 2,
        "deletions": 7,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/bip68-sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/bip68-sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip68-sequence.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -21,16 +21,11 @@ def __init__(self):\n         super().__init__()\n         self.num_nodes = 2\n         self.setup_clean_chain = False\n+        self.extra_args = [[], [\"-acceptnonstdtxn=0\"]]\n \n-    def setup_network(self):\n-        self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir))\n-        self.nodes.append(start_node(1, self.options.tmpdir, [\"-acceptnonstdtxn=0\"]))\n-        self.is_network_split = False\n+    def run_test(self):\n         self.relayfee = self.nodes[0].getnetworkinfo()[\"relayfee\"]\n-        connect_nodes(self.nodes[0], 1)\n \n-    def run_test(self):\n         # Generate some coins\n         self.nodes[0].generate(110)\n "
      },
      {
        "sha": "fff47fcca99835877b7c3ed87f250ecc75a631c2",
        "filename": "test/functional/bip9-softforks.py",
        "status": "modified",
        "additions": 48,
        "deletions": 10,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/bip9-softforks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/bip9-softforks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip9-softforks.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -16,7 +16,6 @@\n test that enforcement has triggered\n \"\"\"\n \n-from test_framework.blockstore import BlockStore\n from test_framework.test_framework import ComparisonTestFramework\n from test_framework.util import *\n from test_framework.mininode import CTransaction, NetworkThread\n@@ -32,11 +31,7 @@ class BIP9SoftForksTest(ComparisonTestFramework):\n     def __init__(self):\n         super().__init__()\n         self.num_nodes = 1\n-\n-    def setup_network(self):\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir,\n-                                 extra_args=[['-whitelist=127.0.0.1']],\n-                                 binary=[self.options.testbinary])\n+        self.extra_args = [['-whitelist=127.0.0.1']]\n \n     def run_test(self):\n         self.test = TestManager(self, self.options.tmpdir)\n@@ -104,12 +99,43 @@ def test_BIP(self, bipName, activated_version, invalidate, invalidatePostSignatu\n \n         assert_equal(self.get_bip9_status(bipName)['status'], 'started')\n         assert_equal(self.get_bip9_status(bipName)['since'], 144)\n+        assert_equal(self.get_bip9_status(bipName)['statistics']['elapsed'], 0)\n+        assert_equal(self.get_bip9_status(bipName)['statistics']['count'], 0)\n         tmpl = self.nodes[0].getblocktemplate({})\n         assert(bipName not in tmpl['rules'])\n         assert_equal(tmpl['vbavailable'][bipName], bitno)\n         assert_equal(tmpl['vbrequired'], 0)\n         assert(tmpl['version'] & activated_version)\n \n+        # Test 1-A\n+        # check stats after max number of \"signalling not\" blocks such that LOCKED_IN still possible this period\n+        test_blocks = self.generate_blocks(36, 4, test_blocks) # 0x00000004 (signalling not)\n+        test_blocks = self.generate_blocks(10, activated_version) # 0x20000001 (signalling ready)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+\n+        assert_equal(self.get_bip9_status(bipName)['statistics']['elapsed'], 46)\n+        assert_equal(self.get_bip9_status(bipName)['statistics']['count'], 10)\n+        assert_equal(self.get_bip9_status(bipName)['statistics']['possible'], True)\n+\n+        # Test 1-B\n+        # check stats after one additional \"signalling not\" block --  LOCKED_IN no longer possible this period\n+        test_blocks = self.generate_blocks(1, 4, test_blocks) # 0x00000004 (signalling not)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+\n+        assert_equal(self.get_bip9_status(bipName)['statistics']['elapsed'], 47)\n+        assert_equal(self.get_bip9_status(bipName)['statistics']['count'], 10)\n+        assert_equal(self.get_bip9_status(bipName)['statistics']['possible'], False)\n+\n+        # Test 1-C\n+        # finish period with \"ready\" blocks, but soft fork will still fail to advance to LOCKED_IN\n+        test_blocks = self.generate_blocks(97, activated_version) # 0x20000001 (signalling ready)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+\n+        assert_equal(self.get_bip9_status(bipName)['statistics']['elapsed'], 0)\n+        assert_equal(self.get_bip9_status(bipName)['statistics']['count'], 0)\n+        assert_equal(self.get_bip9_status(bipName)['statistics']['possible'], True)\n+        assert_equal(self.get_bip9_status(bipName)['status'], 'started')\n+\n         # Test 2\n         # Fail to achieve LOCKED_IN 100 out of 144 signal bit 1\n         # using a variety of bits to simulate multiple parallel softforks\n@@ -121,6 +147,8 @@ def test_BIP(self, bipName, activated_version, invalidate, invalidatePostSignatu\n \n         assert_equal(self.get_bip9_status(bipName)['status'], 'started')\n         assert_equal(self.get_bip9_status(bipName)['since'], 144)\n+        assert_equal(self.get_bip9_status(bipName)['statistics']['elapsed'], 0)\n+        assert_equal(self.get_bip9_status(bipName)['statistics']['count'], 0)\n         tmpl = self.nodes[0].getblocktemplate({})\n         assert(bipName not in tmpl['rules'])\n         assert_equal(tmpl['vbavailable'][bipName], bitno)\n@@ -130,14 +158,24 @@ def test_BIP(self, bipName, activated_version, invalidate, invalidatePostSignatu\n         # Test 3\n         # 108 out of 144 signal bit 1 to achieve LOCKED_IN\n         # using a variety of bits to simulate multiple parallel softforks\n-        test_blocks = self.generate_blocks(58, activated_version) # 0x20000001 (signalling ready)\n+        test_blocks = self.generate_blocks(57, activated_version) # 0x20000001 (signalling ready)\n         test_blocks = self.generate_blocks(26, 4, test_blocks) # 0x00000004 (signalling not)\n         test_blocks = self.generate_blocks(50, activated_version, test_blocks) # 0x20000101 (signalling ready)\n         test_blocks = self.generate_blocks(10, 4, test_blocks) # 0x20010000 (signalling not)\n         yield TestInstance(test_blocks, sync_every_block=False)\n \n+        # check counting stats and \"possible\" flag before last block of this period achieves LOCKED_IN...\n+        assert_equal(self.get_bip9_status(bipName)['statistics']['elapsed'], 143)\n+        assert_equal(self.get_bip9_status(bipName)['statistics']['count'], 107)\n+        assert_equal(self.get_bip9_status(bipName)['statistics']['possible'], True)\n+        assert_equal(self.get_bip9_status(bipName)['status'], 'started')\n+\n+        # ...continue with Test 3\n+        test_blocks = self.generate_blocks(1, activated_version) # 0x20000001 (signalling ready)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+\n         assert_equal(self.get_bip9_status(bipName)['status'], 'locked_in')\n-        assert_equal(self.get_bip9_status(bipName)['since'], 432)\n+        assert_equal(self.get_bip9_status(bipName)['since'], 576)\n         tmpl = self.nodes[0].getblocktemplate({})\n         assert(bipName not in tmpl['rules'])\n \n@@ -147,7 +185,7 @@ def test_BIP(self, bipName, activated_version, invalidate, invalidatePostSignatu\n         yield TestInstance(test_blocks, sync_every_block=False)\n \n         assert_equal(self.get_bip9_status(bipName)['status'], 'locked_in')\n-        assert_equal(self.get_bip9_status(bipName)['since'], 432)\n+        assert_equal(self.get_bip9_status(bipName)['since'], 576)\n         tmpl = self.nodes[0].getblocktemplate({})\n         assert(bipName not in tmpl['rules'])\n \n@@ -173,7 +211,7 @@ def test_BIP(self, bipName, activated_version, invalidate, invalidatePostSignatu\n         yield TestInstance([[block, True]])\n \n         assert_equal(self.get_bip9_status(bipName)['status'], 'active')\n-        assert_equal(self.get_bip9_status(bipName)['since'], 576)\n+        assert_equal(self.get_bip9_status(bipName)['since'], 720)\n         tmpl = self.nodes[0].getblocktemplate({})\n         assert(bipName in tmpl['rules'])\n         assert(bipName not in tmpl['vbavailable'])"
      },
      {
        "sha": "31c7ebba90c820b6dd910c9bac9b1a986774d40a",
        "filename": "test/functional/bipdersig-p2p.py",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/bipdersig-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/bipdersig-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bipdersig-p2p.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -47,12 +47,6 @@ def __init__(self):\n         super().__init__()\n         self.num_nodes = 1\n \n-    def setup_network(self):\n-        # Must set the blockversion for this test\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir,\n-                                 extra_args=[['-whitelist=127.0.0.1', '-blockversion=2']],\n-                                 binary=[self.options.testbinary])\n-\n     def run_test(self):\n         test = TestManager(self, self.options.tmpdir)\n         test.add_all_connections(self.nodes)"
      },
      {
        "sha": "41f88fb664b2318f447be09c4063a7e694f8c6a5",
        "filename": "test/functional/bipdersig.py",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/bipdersig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/bipdersig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bipdersig.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -12,15 +12,12 @@ def __init__(self):\n         super().__init__()\n         self.num_nodes = 3\n         self.setup_clean_chain = False\n+        self.extra_args = [[], [\"-blockversion=2\"], [\"-blockversion=3\"]]\n \n     def setup_network(self):\n-        self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, []))\n-        self.nodes.append(start_node(1, self.options.tmpdir, [\"-blockversion=2\"]))\n-        self.nodes.append(start_node(2, self.options.tmpdir, [\"-blockversion=3\"]))\n+        self.setup_nodes()\n         connect_nodes(self.nodes[1], 0)\n         connect_nodes(self.nodes[2], 0)\n-        self.is_network_split = False\n         self.sync_all()\n \n     def run_test(self):"
      },
      {
        "sha": "b6112c728083a1a79b32fb096470c51c1e163cee",
        "filename": "test/functional/blockchain.py",
        "status": "modified",
        "additions": 45,
        "deletions": 10,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/blockchain.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -6,6 +6,11 @@\n \n Test the following RPCs:\n     - gettxoutsetinfo\n+    - getdifficulty\n+    - getbestblockhash\n+    - getblockhash\n+    - getblockheader\n+    - getnetworkhashps\n     - verifychain\n \n Tests correspond to code in rpc/blockchain.cpp.\n@@ -19,8 +24,6 @@\n     assert_raises_jsonrpc,\n     assert_is_hex_string,\n     assert_is_hash_string,\n-    start_nodes,\n-    connect_nodes_bi,\n )\n \n \n@@ -29,17 +32,13 @@ class BlockchainTest(BitcoinTestFramework):\n     def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = False\n-        self.num_nodes = 2\n-\n-    def setup_network(self, split=False):\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir)\n-        connect_nodes_bi(self.nodes, 0, 1)\n-        self.is_network_split = False\n-        self.sync_all()\n+        self.num_nodes = 1\n \n     def run_test(self):\n         self._test_gettxoutsetinfo()\n         self._test_getblockheader()\n+        self._test_getdifficulty()\n+        self._test_getnetworkhashps()\n         self.nodes[0].verifychain(4, 0)\n \n     def _test_gettxoutsetinfo(self):\n@@ -51,13 +50,38 @@ def _test_gettxoutsetinfo(self):\n         assert_equal(res['height'], 200)\n         assert_equal(res['txouts'], 200)\n         assert_equal(res['bytes_serialized'], 13924),\n+        assert_equal(res['bestblock'], node.getblockhash(200))\n         assert_equal(len(res['bestblock']), 64)\n         assert_equal(len(res['hash_serialized']), 64)\n \n+        self.log.info(\"Test that gettxoutsetinfo() works for blockchain with just the genesis block\")\n+        b1hash = node.getblockhash(1)\n+        node.invalidateblock(b1hash)\n+\n+        res2 = node.gettxoutsetinfo()\n+        assert_equal(res2['transactions'], 0)\n+        assert_equal(res2['total_amount'], Decimal('0'))\n+        assert_equal(res2['height'], 0)\n+        assert_equal(res2['txouts'], 0)\n+        assert_equal(res2['bestblock'], node.getblockhash(0))\n+        assert_equal(len(res2['hash_serialized']), 64)\n+\n+        self.log.info(\"Test that gettxoutsetinfo() returns the same result after invalidate/reconsider block\")\n+        node.reconsiderblock(b1hash)\n+\n+        res3 = node.gettxoutsetinfo()\n+        assert_equal(res['total_amount'], res3['total_amount'])\n+        assert_equal(res['transactions'], res3['transactions'])\n+        assert_equal(res['height'], res3['height'])\n+        assert_equal(res['txouts'], res3['txouts'])\n+        assert_equal(res['bestblock'], res3['bestblock'])\n+        assert_equal(res['hash_serialized'], res3['hash_serialized'])\n+\n     def _test_getblockheader(self):\n         node = self.nodes[0]\n \n-        assert_raises_jsonrpc(-5, \"Block not found\", node.getblockheader, \"nonsense\")\n+        assert_raises_jsonrpc(-5, \"Block not found\",\n+                              node.getblockheader, \"nonsense\")\n \n         besthash = node.getbestblockhash()\n         secondbesthash = node.getblockhash(199)\n@@ -79,5 +103,16 @@ def _test_getblockheader(self):\n         assert isinstance(int(header['versionHex'], 16), int)\n         assert isinstance(header['difficulty'], Decimal)\n \n+    def _test_getdifficulty(self):\n+        difficulty = self.nodes[0].getdifficulty()\n+        # 1 hash in 2 should be valid, so difficulty should be 1/2**31\n+        # binary => decimal => binary math is why we do this check\n+        assert abs(difficulty * 2**31 - 1) < 0.0001\n+\n+    def _test_getnetworkhashps(self):\n+        hashes_per_second = self.nodes[0].getnetworkhashps()\n+        # This should be 2 hashes every 10 minutes or 1/300\n+        assert abs(hashes_per_second * 300 - 1) < 0.0001\n+\n if __name__ == '__main__':\n     BlockchainTest().main()"
      },
      {
        "sha": "54fd7740c1f442baf8ec959562778b8592cfd38b",
        "filename": "test/functional/bumpfee.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bumpfee.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -47,7 +47,6 @@ def setup_network(self, split=False):\n         self.nodes[1].walletpassphrase(WALLET_PASSPHRASE, WALLET_PASSPHRASE_TIMEOUT)\n \n         connect_nodes_bi(self.nodes, 0, 1)\n-        self.is_network_split = False\n         self.sync_all()\n \n     def run_test(self):"
      },
      {
        "sha": "21a9f1223fd37abee2209c698b4eaa50ec1637b1",
        "filename": "test/functional/decodescript.py",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/decodescript.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/decodescript.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/decodescript.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -16,10 +16,6 @@ def __init__(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 1\n \n-    def setup_network(self, split=False):\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir)\n-        self.is_network_split = False\n-\n     def decodescript_script_sig(self):\n         signature = '304502207fa7a6d1e0ee81132a269ad84e68d695483745cde8b541e3bf630749894e342a022100c1f7ab20e13e22fb95281a870f3dcf38d782e53023ee313d741ad0cfbc0c509001'\n         push_signature = '48' + signature"
      },
      {
        "sha": "d3445134142622825ef0dae53a4c48c9399c77cb",
        "filename": "test/functional/disablewallet.py",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/disablewallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/disablewallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/disablewallet.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -18,13 +18,11 @@ def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n         self.num_nodes = 1\n-\n-    def setup_network(self, split=False):\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, [['-disablewallet']])\n-        self.is_network_split = False\n-        self.sync_all()\n+        self.extra_args = [[\"-disablewallet\"]]\n \n     def run_test (self):\n+        # Make sure wallet is really disabled\n+        assert_raises_jsonrpc(-32601, 'Method not found', self.nodes[0].getwalletinfo)\n         x = self.nodes[0].validateaddress('3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy')\n         assert(x['isvalid'] == False)\n         x = self.nodes[0].validateaddress('mneYUmWYsuk7kySiURxCi3AGxrAqZxLgPZ')"
      },
      {
        "sha": "f453fc0261e192357045d317a774d5d47046b2e9",
        "filename": "test/functional/disconnect_ban.py",
        "status": "modified",
        "additions": 11,
        "deletions": 9,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/disconnect_ban.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/disconnect_ban.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/disconnect_ban.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -3,6 +3,7 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test node disconnect and ban behavior\"\"\"\n+import time\n \n from test_framework.mininode import wait_until\n from test_framework.test_framework import BitcoinTestFramework\n@@ -20,17 +21,13 @@ def __init__(self):\n         self.num_nodes = 2\n         self.setup_clean_chain = False\n \n-    def setup_network(self):\n-        self.nodes = self.setup_nodes()\n-        connect_nodes_bi(self.nodes, 0, 1)\n-\n     def run_test(self):\n         self.log.info(\"Test setban and listbanned RPCs\")\n \n         self.log.info(\"setban: successfully ban single IP address\")\n         assert_equal(len(self.nodes[1].getpeerinfo()), 2)  # node1 should have 2 connections to node0 at this point\n         self.nodes[1].setban(\"127.0.0.1\", \"add\")\n-        wait_until(lambda: len(self.nodes[1].getpeerinfo()) == 0)\n+        assert wait_until(lambda: len(self.nodes[1].getpeerinfo()) == 0, timeout=10)\n         assert_equal(len(self.nodes[1].getpeerinfo()), 0)  # all nodes must be disconnected at this point\n         assert_equal(len(self.nodes[1].listbanned()), 1)\n \n@@ -60,11 +57,16 @@ def run_test(self):\n         self.log.info(\"setban: test persistence across node restart\")\n         self.nodes[1].setban(\"127.0.0.0/32\", \"add\")\n         self.nodes[1].setban(\"127.0.0.0/24\", \"add\")\n+        # Set the mocktime so we can control when bans expire\n+        old_time = int(time.time())\n+        self.nodes[1].setmocktime(old_time)\n         self.nodes[1].setban(\"192.168.0.1\", \"add\", 1)  # ban for 1 seconds\n         self.nodes[1].setban(\"2001:4d48:ac57:400:cacf:e9ff:fe1d:9c63/19\", \"add\", 1000)  # ban for 1000 seconds\n         listBeforeShutdown = self.nodes[1].listbanned()\n         assert_equal(\"192.168.0.1/32\", listBeforeShutdown[2]['address'])\n-        wait_until(lambda: len(self.nodes[1].listbanned()) == 3)\n+        # Move time forward by 3 seconds so the third ban has expired\n+        self.nodes[1].setmocktime(old_time + 3)\n+        assert_equal(len(self.nodes[1].listbanned()), 3)\n \n         stop_node(self.nodes[1], 1)\n \n@@ -78,7 +80,7 @@ def run_test(self):\n         self.nodes[1].clearbanned()\n         connect_nodes_bi(self.nodes, 0, 1)\n \n-        self.log.info(\"Test disconnectrnode RPCs\")\n+        self.log.info(\"Test disconnectnode RPCs\")\n \n         self.log.info(\"disconnectnode: fail to disconnect when calling with address and nodeid\")\n         address1 = self.nodes[0].getpeerinfo()[0]['addr']\n@@ -91,7 +93,7 @@ def run_test(self):\n         self.log.info(\"disconnectnode: successfully disconnect node by address\")\n         address1 = self.nodes[0].getpeerinfo()[0]['addr']\n         self.nodes[0].disconnectnode(address=address1)\n-        wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1)\n+        assert wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1, timeout=10)\n         assert not [node for node in self.nodes[0].getpeerinfo() if node['addr'] == address1]\n \n         self.log.info(\"disconnectnode: successfully reconnect node\")\n@@ -102,7 +104,7 @@ def run_test(self):\n         self.log.info(\"disconnectnode: successfully disconnect node by node id\")\n         id1 = self.nodes[0].getpeerinfo()[0]['id']\n         self.nodes[0].disconnectnode(nodeid=id1)\n-        wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1)\n+        assert wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1, timeout=10)\n         assert not [node for node in self.nodes[0].getpeerinfo() if node['id'] == id1]\n \n if __name__ == '__main__':"
      },
      {
        "sha": "9db61c8350f948d681832ab035af2a7ac0182a9b",
        "filename": "test/functional/forknotify.py",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/forknotify.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/forknotify.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/forknotify.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -16,8 +16,6 @@ def __init__(self):\n         self.num_nodes = 2\n         self.setup_clean_chain = False\n \n-    alert_filename = None  # Set by setup_network\n-\n     def setup_network(self):\n         self.nodes = []\n         self.alert_filename = os.path.join(self.options.tmpdir, \"alert.txt\")\n@@ -30,7 +28,6 @@ def setup_network(self):\n                                 [\"-blockversion=211\"]))\n         connect_nodes(self.nodes[1], 0)\n \n-        self.is_network_split = False\n         self.sync_all()\n \n     def run_test(self):"
      },
      {
        "sha": "9ddafeb611cc45683d11c3536c99c1756ea318d8",
        "filename": "test/functional/fundrawtransaction.py",
        "status": "modified",
        "additions": 10,
        "deletions": 9,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/fundrawtransaction.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -23,15 +23,12 @@ def __init__(self):\n         self.num_nodes = 4\n \n     def setup_network(self, split=False):\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir)\n-\n-        connect_nodes_bi(self.nodes,0,1)\n-        connect_nodes_bi(self.nodes,1,2)\n-        connect_nodes_bi(self.nodes,0,2)\n-        connect_nodes_bi(self.nodes,0,3)\n+        self.setup_nodes()\n \n-        self.is_network_split=False\n-        self.sync_all()\n+        connect_nodes_bi(self.nodes, 0, 1)\n+        connect_nodes_bi(self.nodes, 1, 2)\n+        connect_nodes_bi(self.nodes, 0, 2)\n+        connect_nodes_bi(self.nodes, 0, 3)\n \n     def run_test(self):\n         min_relay_tx_fee = self.nodes[0].getnetworkinfo()['relayfee']\n@@ -53,6 +50,11 @@ def run_test(self):\n         self.nodes[0].generate(121)\n         self.sync_all()\n \n+        # ensure that setting changePosition in fundraw with an exact match is handled properly\n+        rawmatch = self.nodes[2].createrawtransaction([], {self.nodes[2].getnewaddress():50})\n+        rawmatch = self.nodes[2].fundrawtransaction(rawmatch, {\"changePosition\":1, \"subtractFeeFromOutputs\":[0]})\n+        assert_equal(rawmatch[\"changepos\"], -1)\n+\n         watchonly_address = self.nodes[0].getnewaddress()\n         watchonly_pubkey = self.nodes[0].validateaddress(watchonly_address)[\"pubkey\"]\n         watchonly_amount = Decimal(200)\n@@ -462,7 +464,6 @@ def run_test(self):\n         connect_nodes_bi(self.nodes,1,2)\n         connect_nodes_bi(self.nodes,0,2)\n         connect_nodes_bi(self.nodes,0,3)\n-        self.is_network_split=False\n         self.sync_all()\n \n         # drain the keypool"
      },
      {
        "sha": "fca99c7df5715a767e30a31e7946d8ba993b79f5",
        "filename": "test/functional/getblocktemplate_proposals.py",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/getblocktemplate_proposals.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/getblocktemplate_proposals.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/getblocktemplate_proposals.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -73,10 +73,6 @@ def __init__(self):\n         self.num_nodes = 2\n         self.setup_clean_chain = False\n \n-    def setup_network(self):\n-        self.nodes = self.setup_nodes()\n-        connect_nodes_bi(self.nodes, 0, 1)\n-\n     def run_test(self):\n         node = self.nodes[0]\n         node.generate(1) # Mine a block to leave initial block download"
      },
      {
        "sha": "15f96c565fe60353c4a20ff105953f5b21e8a922",
        "filename": "test/functional/getchaintips.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/getchaintips.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/getchaintips.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/getchaintips.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -31,7 +31,7 @@ def run_test (self):\n         self.split_network ()\n         self.nodes[0].generate(10)\n         self.nodes[2].generate(20)\n-        self.sync_all ()\n+        self.sync_all([self.nodes[:2], self.nodes[2:]])\n \n         tips = self.nodes[1].getchaintips ()\n         assert_equal (len (tips), 1)"
      },
      {
        "sha": "4b32e8d9ca338373d3fbf7e332fa06c082afcb5d",
        "filename": "test/functional/httpbasics.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/httpbasics.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/httpbasics.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/httpbasics.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -17,7 +17,7 @@ def __init__(self):\n         self.setup_clean_chain = False\n \n     def setup_network(self):\n-        self.nodes = self.setup_nodes()\n+        self.setup_nodes()\n \n     def run_test(self):\n "
      },
      {
        "sha": "9e3491c428f55fffe14e17c5d36144097114cf03",
        "filename": "test/functional/importmulti.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/importmulti.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -12,9 +12,8 @@ def __init__(self):\n         self.num_nodes = 2\n         self.setup_clean_chain = True\n \n-    def setup_network(self, split=False):\n-        self.nodes = start_nodes(2, self.options.tmpdir)\n-        self.is_network_split=False\n+    def setup_network(self):\n+        self.setup_nodes()\n \n     def run_test (self):\n         self.log.info(\"Mining blocks...\")"
      },
      {
        "sha": "94753fe43114c31eb75092249b17c8a05d20b233",
        "filename": "test/functional/importprunedfunds.py",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/importprunedfunds.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/importprunedfunds.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/importprunedfunds.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -14,12 +14,6 @@ def __init__(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 2\n \n-    def setup_network(self, split=False):\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir)\n-        connect_nodes_bi(self.nodes,0,1)\n-        self.is_network_split=False\n-        self.sync_all()\n-\n     def run_test(self):\n         self.log.info(\"Mining blocks...\")\n         self.nodes[0].generate(101)"
      },
      {
        "sha": "c499d57b90379746f66ee1def2cc3544de0b9d87",
        "filename": "test/functional/invalidateblock.py",
        "status": "modified",
        "additions": 3,
        "deletions": 8,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/invalidateblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/invalidateblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/invalidateblock.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -8,20 +8,15 @@\n from test_framework.util import *\n \n class InvalidateTest(BitcoinTestFramework):\n-    \n-        \n+\n     def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n         self.num_nodes = 3\n \n     def setup_network(self):\n-        self.nodes = []\n-        self.is_network_split = False \n-        self.nodes.append(start_node(0, self.options.tmpdir))\n-        self.nodes.append(start_node(1, self.options.tmpdir))\n-        self.nodes.append(start_node(2, self.options.tmpdir))\n-        \n+        self.setup_nodes()\n+\n     def run_test(self):\n         self.log.info(\"Make sure we repopulate setBlockIndexCandidates after InvalidateBlock:\")\n         self.log.info(\"Mine 4 blocks on Node 0\")"
      },
      {
        "sha": "c276e64c7c710dda5f238e7a8e2102e0cfb9af8c",
        "filename": "test/functional/keypool.py",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/keypool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/keypool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/keypool.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -84,8 +84,5 @@ def __init__(self):\n         self.setup_clean_chain = False\n         self.num_nodes = 1\n \n-    def setup_network(self):\n-        self.nodes = self.setup_nodes()\n-\n if __name__ == '__main__':\n     KeyPoolTest().main()"
      },
      {
        "sha": "f3d41e573eda75ebc24b5fe9b815b1a06c404fbb",
        "filename": "test/functional/listsinceblock.py",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/listsinceblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/listsinceblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/listsinceblock.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -43,7 +43,6 @@ def run_test (self):\n         This test only checks that [tx0] is present.\n         '''\n \n-        assert_equal(self.is_network_split, False)\n         self.nodes[2].generate(101)\n         self.sync_all()\n \n@@ -54,7 +53,6 @@ def run_test (self):\n \n         # Split network into two\n         self.split_network()\n-        assert_equal(self.is_network_split, True)\n \n         # send to nodes[0] from nodes[2]\n         senttx = self.nodes[2].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n@@ -64,7 +62,7 @@ def run_test (self):\n         self.nodes[2].generate(7)\n         self.log.info('lastblockhash=%s' % (lastblockhash))\n \n-        self.sync_all()\n+        self.sync_all([self.nodes[:2], self.nodes[2:]])\n \n         self.join_network()\n "
      },
      {
        "sha": "cba370d8b06b8cd952e2acddc8320bbe27939829",
        "filename": "test/functional/listtransactions.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/listtransactions.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -24,7 +24,7 @@ def __init__(self):\n     def setup_nodes(self):\n         #This test requires mocktime\n         enable_mocktime()\n-        return start_nodes(self.num_nodes, self.options.tmpdir)\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir)\n \n     def run_test(self):\n         # Simple send, 0 to 1:"
      },
      {
        "sha": "4ef2a35a44522cb0fff2871ec7f0ceef6222458c",
        "filename": "test/functional/maxblocksinflight.py",
        "status": "removed",
        "additions": 0,
        "deletions": 93,
        "changes": 93,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/57c43870128203097599a322c689f4c65c977f11/test/functional/maxblocksinflight.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/57c43870128203097599a322c689f4c65c977f11/test/functional/maxblocksinflight.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/maxblocksinflight.py?ref=57c43870128203097599a322c689f4c65c977f11",
        "patch": "@@ -1,93 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2015-2016 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Test nodes responses to having many blocks in flight.\n-\n-In this test we connect to one node over p2p, send it numerous inv's, and\n-compare the resulting number of getdata requests to a max allowed value.  We\n-test for exceeding 128 blocks in flight, which was the limit an 0.9 client will\n-reach. [0.10 clients shouldn't request more than 16 from a single peer.]\n-\"\"\"\n-\n-from test_framework.mininode import *\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import *\n-\n-MAX_REQUESTS = 128\n-\n-class TestManager(NodeConnCB):\n-    def on_getdata(self, conn, message):\n-        self.log.debug(\"got getdata %s\" % repr(message))\n-        # Log the requests\n-        for inv in message.inv:\n-            if inv.hash not in self.blockReqCounts:\n-                self.blockReqCounts[inv.hash] = 0\n-            self.blockReqCounts[inv.hash] += 1\n-\n-    def on_close(self, conn):\n-        if not self.disconnectOkay:\n-            raise EarlyDisconnectError(0)\n-\n-    def add_new_connection(self, connection):\n-        super().add_connection(connection)\n-        self.blockReqCounts = {}\n-        self.disconnectOkay = False\n-\n-    def run(self):\n-        self.connection.rpc.generate(1)  # Leave IBD\n-\n-        numBlocksToGenerate = [8, 16, 128, 1024]\n-        for count in range(len(numBlocksToGenerate)):\n-            current_invs = []\n-            for i in range(numBlocksToGenerate[count]):\n-                current_invs.append(CInv(2, random.randrange(0, 1 << 256)))\n-                if len(current_invs) >= 50000:\n-                    self.connection.send_message(msg_inv(current_invs))\n-                    current_invs = []\n-            if len(current_invs) > 0:\n-                self.connection.send_message(msg_inv(current_invs))\n-\n-            # Wait and see how many blocks were requested\n-            time.sleep(2)\n-\n-            total_requests = 0\n-            with mininode_lock:\n-                for key in self.blockReqCounts:\n-                    total_requests += self.blockReqCounts[key]\n-                    if self.blockReqCounts[key] > 1:\n-                        raise AssertionError(\"Error, test failed: block %064x requested more than once\" % key)\n-            if total_requests > MAX_REQUESTS:\n-                raise AssertionError(\"Error, too many blocks (%d) requested\" % total_requests)\n-            self.log.info(\"Round %d: success (total requests: %d)\" % (count, total_requests))\n-\n-        self.disconnectOkay = True\n-        self.connection.disconnect_node()\n-\n-\n-class MaxBlocksInFlightTest(BitcoinTestFramework):\n-    def add_options(self, parser):\n-        parser.add_option(\"--testbinary\", dest=\"testbinary\",\n-                          default=os.getenv(\"BITCOIND\", \"bitcoind\"),\n-                          help=\"Binary to test max block requests behavior\")\n-\n-    def __init__(self):\n-        super().__init__()\n-        self.setup_clean_chain = True\n-        self.num_nodes = 1\n-\n-    def setup_network(self):\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir,\n-                                 extra_args=[['-whitelist=127.0.0.1']],\n-                                 binary=[self.options.testbinary])\n-\n-    def run_test(self):\n-        test = TestManager()\n-        # pass log handler through to the test manager object\n-        test.log = self.log\n-        test.add_new_connection(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test))\n-        NetworkThread().start()  # Start up network handling in another thread\n-        test.run()\n-\n-if __name__ == '__main__':\n-    MaxBlocksInFlightTest().main()"
      },
      {
        "sha": "bff1b532347f98a41fb6164248d439b843177a60",
        "filename": "test/functional/maxuploadtarget.py",
        "status": "modified",
        "additions": 16,
        "deletions": 66,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/maxuploadtarget.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -10,79 +10,36 @@\n if uploadtarget has been reached.\n * Verify that the upload counters are reset after 24 hours.\n \"\"\"\n+from collections import defaultdict\n+import time\n \n from test_framework.mininode import *\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n-import time\n \n-# TestNode: bare-bones \"peer\".  Used mostly as a conduit for a test to sending\n-# p2p messages to a node, generating the messages in the main testing logic.\n class TestNode(NodeConnCB):\n     def __init__(self):\n         super().__init__()\n-        self.connection = None\n-        self.ping_counter = 1\n-        self.last_pong = msg_pong()\n-        self.block_receive_map = {}\n-\n-    def add_connection(self, conn):\n-        self.connection = conn\n-        self.peer_disconnected = False\n+        self.block_receive_map = defaultdict(int)\n \n     def on_inv(self, conn, message):\n         pass\n \n-    # Track the last getdata message we receive (used in the test)\n-    def on_getdata(self, conn, message):\n-        self.last_getdata = message\n-\n     def on_block(self, conn, message):\n         message.block.calc_sha256()\n-        try:\n-            self.block_receive_map[message.block.sha256] += 1\n-        except KeyError as e:\n-            self.block_receive_map[message.block.sha256] = 1\n-\n-    # Spin until verack message is received from the node.\n-    # We use this to signal that our test can begin. This\n-    # is called from the testing thread, so it needs to acquire\n-    # the global lock.\n-    def wait_for_verack(self):\n-        def veracked():\n-            return self.verack_received\n-        return wait_until(veracked, timeout=10)\n-\n-    def wait_for_disconnect(self):\n-        def disconnected():\n-            return self.peer_disconnected\n-        return wait_until(disconnected, timeout=10)\n-\n-    # Wrapper for the NodeConn's send_message function\n-    def send_message(self, message):\n-        self.connection.send_message(message)\n-\n-    def on_pong(self, conn, message):\n-        self.last_pong = message\n-\n-    def on_close(self, conn):\n-        self.peer_disconnected = True\n+        self.block_receive_map[message.block.sha256] += 1\n \n class MaxUploadTest(BitcoinTestFramework):\n  \n     def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n         self.num_nodes = 1\n+        self.extra_args = [[\"-maxuploadtarget=800\", \"-blockmaxsize=999000\"]]\n \n         # Cache for utxos, as the listunspent may take a long time later in the test\n         self.utxo_cache = []\n \n-    def setup_network(self):\n-        # Start a node with maxuploadtarget of 200 MB (/24h)\n-        self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-maxuploadtarget=800\", \"-blockmaxsize=999000\"]))\n-\n     def run_test(self):\n         # Before we connect anything, we first set the time on the node\n         # to be in the past, otherwise things break because the CNode\n@@ -192,33 +149,26 @@ def run_test(self):\n         stop_node(self.nodes[0], 0)\n         self.nodes[0] = start_node(0, self.options.tmpdir, [\"-whitelist=127.0.0.1\", \"-maxuploadtarget=1\", \"-blockmaxsize=999000\"])\n \n-        #recreate/reconnect 3 test nodes\n-        test_nodes = []\n-        connections = []\n-\n-        for i in range(3):\n-            test_nodes.append(TestNode())\n-            connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_nodes[i]))\n-            test_nodes[i].add_connection(connections[i])\n+        #recreate/reconnect a test node\n+        test_nodes = [TestNode()]\n+        connections = [NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_nodes[0])]\n+        test_nodes[0].add_connection(connections[0])\n \n         NetworkThread().start() # Start up network handling in another thread\n-        [x.wait_for_verack() for x in test_nodes]\n+        test_nodes[0].wait_for_verack()\n \n         #retrieve 20 blocks which should be enough to break the 1MB limit\n         getdata_request.inv = [CInv(2, big_new_block)]\n         for i in range(20):\n-            test_nodes[1].send_message(getdata_request)\n-            test_nodes[1].sync_with_ping()\n-            assert_equal(test_nodes[1].block_receive_map[big_new_block], i+1)\n+            test_nodes[0].send_message(getdata_request)\n+            test_nodes[0].sync_with_ping()\n+            assert_equal(test_nodes[0].block_receive_map[big_new_block], i+1)\n \n         getdata_request.inv = [CInv(2, big_old_block)]\n-        test_nodes[1].send_message(getdata_request)\n-        test_nodes[1].wait_for_disconnect()\n-        assert_equal(len(self.nodes[0].getpeerinfo()), 3) #node is still connected because of the whitelist\n+        test_nodes[0].send_and_ping(getdata_request)\n+        assert_equal(len(self.nodes[0].getpeerinfo()), 1) #node is still connected because of the whitelist\n \n-        self.log.info(\"Peer 1 still connected after trying to download old block (whitelisted)\")\n-\n-        [c.disconnect_node() for c in connections]\n+        self.log.info(\"Peer still connected after trying to download old block (whitelisted)\")\n \n if __name__ == '__main__':\n     MaxUploadTest().main()"
      },
      {
        "sha": "2777291dd0effec0044c37e642c62ee2bb8a7913",
        "filename": "test/functional/mempool_limit.py",
        "status": "modified",
        "additions": 7,
        "deletions": 12,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/mempool_limit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/mempool_limit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_limit.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -9,30 +9,25 @@\n \n class MempoolLimitTest(BitcoinTestFramework):\n \n-    def setup_network(self):\n-        self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-maxmempool=5\", \"-spendzeroconfchange=0\"]))\n-        self.is_network_split = False\n-        self.sync_all()\n-        self.relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n-\n     def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n         self.num_nodes = 1\n-\n-        self.txouts = gen_return_txouts()\n+        self.extra_args = [[\"-maxmempool=5\", \"-spendzeroconfchange=0\"]]\n \n     def run_test(self):\n+        txouts = gen_return_txouts()\n+        relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n+\n         txids = []\n-        utxos = create_confirmed_utxos(self.relayfee, self.nodes[0], 91)\n+        utxos = create_confirmed_utxos(relayfee, self.nodes[0], 91)\n \n         #create a mempool tx that will be evicted\n         us0 = utxos.pop()\n         inputs = [{ \"txid\" : us0[\"txid\"], \"vout\" : us0[\"vout\"]}]\n         outputs = {self.nodes[0].getnewaddress() : 0.0001}\n         tx = self.nodes[0].createrawtransaction(inputs, outputs)\n-        self.nodes[0].settxfee(self.relayfee) # specifically fund this tx with low fee\n+        self.nodes[0].settxfee(relayfee) # specifically fund this tx with low fee\n         txF = self.nodes[0].fundrawtransaction(tx)\n         self.nodes[0].settxfee(0) # return to automatic fee selection\n         txFS = self.nodes[0].signrawtransaction(txF['hex'])\n@@ -42,7 +37,7 @@ def run_test(self):\n         base_fee = relayfee*100\n         for i in range (3):\n             txids.append([])\n-            txids[i] = create_lots_of_big_transactions(self.nodes[0], self.txouts, utxos[30*i:30*i+30], 30, (i+1)*base_fee)\n+            txids[i] = create_lots_of_big_transactions(self.nodes[0], txouts, utxos[30*i:30*i+30], 30, (i+1)*base_fee)\n \n         # by now, the tx should be evicted, check confirmation state\n         assert(txid not in self.nodes[0].getrawmempool())"
      },
      {
        "sha": "72f04095f47d10d9f88de596e2a4d257b61edac3",
        "filename": "test/functional/mempool_packages.py",
        "status": "modified",
        "additions": 1,
        "deletions": 8,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/mempool_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/mempool_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_packages.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -16,14 +16,7 @@ def __init__(self):\n         super().__init__()\n         self.num_nodes = 2\n         self.setup_clean_chain = False\n-\n-    def setup_network(self):\n-        self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-maxorphantx=1000\"]))\n-        self.nodes.append(start_node(1, self.options.tmpdir, [\"-maxorphantx=1000\", \"-limitancestorcount=5\"]))\n-        connect_nodes(self.nodes[0], 1)\n-        self.is_network_split = False\n-        self.sync_all()\n+        self.extra_args = [[\"-maxorphantx=1000\"], [\"-maxorphantx=1000\", \"-limitancestorcount=5\"]]\n \n     # Build a transaction that spends parent_txid:vout\n     # Return amount sent"
      },
      {
        "sha": "7b15476ea2714a4b2b6cdc8b49e361f71f1e8385",
        "filename": "test/functional/mempool_persist.py",
        "status": "added",
        "additions": 90,
        "deletions": 0,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/mempool_persist.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/mempool_persist.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_persist.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -0,0 +1,90 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test mempool persistence.\n+\n+By default, bitcoind will dump mempool on shutdown and\n+then reload it on startup. This can be overridden with\n+the -persistmempool=0 command line option.\n+\n+Test is as follows:\n+\n+  - start node0, node1 and node2. node1 has -persistmempool=0\n+  - create 5 transactions on node2 to its own address. Note that these\n+    are not sent to node0 or node1 addresses because we don't want\n+    them to be saved in the wallet.\n+  - check that node0 and node1 have 5 transactions in their mempools\n+  - shutdown all nodes.\n+  - startup node0. Verify that it still has 5 transactions\n+    in its mempool. Shutdown node0. This tests that by default the\n+    mempool is persistent.\n+  - startup node1. Verify that its mempool is empty. Shutdown node1.\n+    This tests that with -persistmempool=0, the mempool is not\n+    dumped to disk when the node is shut down.\n+  - Restart node0 with -persistmempool=0. Verify that its mempool is\n+    empty. Shutdown node0. This tests that with -persistmempool=0,\n+    the mempool is not loaded from disk on start up.\n+  - Restart node0 with -persistmempool. Verify that it has 5\n+    transactions in its mempool. This tests that -persistmempool=0\n+    does not overwrite a previously valid mempool stored on disk.\n+\n+\"\"\"\n+import time\n+\n+from test_framework.mininode import wait_until\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class MempoolPersistTest(BitcoinTestFramework):\n+\n+    def __init__(self):\n+        super().__init__()\n+        # We need 3 nodes for this test. Node1 does not have a persistent mempool.\n+        self.num_nodes = 3\n+        self.setup_clean_chain = False\n+        self.extra_args = [[], [\"-persistmempool=0\"], []]\n+\n+    def run_test(self):\n+        chain_height = self.nodes[0].getblockcount()\n+        assert_equal(chain_height, 200)\n+\n+        self.log.debug(\"Mine a single block to get out of IBD\")\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        self.log.debug(\"Send 5 transactions from node2 (to its own address)\")\n+        for i in range(5):\n+            self.nodes[2].sendtoaddress(self.nodes[2].getnewaddress(), Decimal(\"10\"))\n+        self.sync_all()\n+\n+        self.log.debug(\"Verify that node0 and node1 have 5 transactions in their mempools\")\n+        assert_equal(len(self.nodes[0].getrawmempool()), 5)\n+        assert_equal(len(self.nodes[1].getrawmempool()), 5)\n+\n+        self.log.debug(\"Stop-start node0 and node1. Verify that node0 has the transactions in its mempool and node1 does not.\")\n+        stop_nodes(self.nodes)\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir))\n+        self.nodes.append(start_node(1, self.options.tmpdir))\n+        # Give bitcoind a second to reload the mempool\n+        time.sleep(1)\n+        assert wait_until(lambda: len(self.nodes[0].getrawmempool()) == 5)\n+        assert_equal(len(self.nodes[1].getrawmempool()), 0)\n+\n+        self.log.debug(\"Stop-start node0 with -persistmempool=0. Verify that it doesn't load its mempool.dat file.\")\n+        stop_nodes(self.nodes)\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-persistmempool=0\"]))\n+        # Give bitcoind a second to reload the mempool\n+        time.sleep(1)\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+\n+        self.log.debug(\"Stop-start node0. Verify that it has the transactions in its mempool.\")\n+        stop_nodes(self.nodes)\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir))\n+        assert wait_until(lambda: len(self.nodes[0].getrawmempool()) == 5)\n+\n+if __name__ == '__main__':\n+    MempoolPersistTest().main()"
      },
      {
        "sha": "937bf4bab5781624eaca85936723a9882ffba0b5",
        "filename": "test/functional/mempool_reorg.py",
        "status": "modified",
        "additions": 1,
        "deletions": 9,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/mempool_reorg.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/mempool_reorg.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_reorg.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -17,18 +17,10 @@ def __init__(self):\n         super().__init__()\n         self.num_nodes = 2\n         self.setup_clean_chain = False\n+        self.extra_args = [[\"-checkmempool\"]] * 2\n \n     alert_filename = None  # Set by setup_network\n \n-    def setup_network(self):\n-        args = [\"-checkmempool\"]\n-        self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, args))\n-        self.nodes.append(start_node(1, self.options.tmpdir, args))\n-        connect_nodes(self.nodes[1], 0)\n-        self.is_network_split = False\n-        self.sync_all()\n-\n     def run_test(self):\n         # Start with a 200 block chain\n         assert_equal(self.nodes[0].getblockcount(), 200)"
      },
      {
        "sha": "a2f6228df91c26238f57f79b7b9ac5e6afd44b54",
        "filename": "test/functional/mempool_resurrect_test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/mempool_resurrect_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/mempool_resurrect_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_resurrect_test.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -14,13 +14,8 @@ def __init__(self):\n         super().__init__()\n         self.num_nodes = 1\n         self.setup_clean_chain = False\n-\n-    def setup_network(self):\n         # Just need one node for this test\n-        args = [\"-checkmempool\"]\n-        self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, args))\n-        self.is_network_split = False\n+        self.extra_args = [[\"-checkmempool\"]]\n \n     def run_test(self):\n         node0_address = self.nodes[0].getnewaddress()"
      },
      {
        "sha": "277ea45ad5bee4c1baa57a9bba8aa82509702586",
        "filename": "test/functional/mempool_spendcoinbase.py",
        "status": "modified",
        "additions": 1,
        "deletions": 7,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/mempool_spendcoinbase.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/mempool_spendcoinbase.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_spendcoinbase.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -22,13 +22,7 @@ def __init__(self):\n         super().__init__()\n         self.num_nodes = 1\n         self.setup_clean_chain = False\n-\n-    def setup_network(self):\n-        # Just need one node for this test\n-        args = [\"-checkmempool\"]\n-        self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, args))\n-        self.is_network_split = False\n+        self.extra_args = [[\"-checkmempool\"]]\n \n     def run_test(self):\n         chain_height = self.nodes[0].getblockcount()"
      },
      {
        "sha": "06af72ef1013c9d9386286e94279e56d78a1e64c",
        "filename": "test/functional/merkle_blocks.py",
        "status": "modified",
        "additions": 3,
        "deletions": 8,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/merkle_blocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/merkle_blocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/merkle_blocks.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -13,20 +13,15 @@ def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n         self.num_nodes = 4\n+        # Nodes 0/1 are \"wallet\" nodes, Nodes 2/3 are used for testing\n+        self.extra_args = [[], [], [], [\"-txindex\"]]\n \n     def setup_network(self):\n-        self.nodes = []\n-        # Nodes 0/1 are \"wallet\" nodes\n-        self.nodes.append(start_node(0, self.options.tmpdir))\n-        self.nodes.append(start_node(1, self.options.tmpdir))\n-        # Nodes 2/3 are used for testing\n-        self.nodes.append(start_node(2, self.options.tmpdir))\n-        self.nodes.append(start_node(3, self.options.tmpdir, [\"-txindex\"]))\n+        self.setup_nodes()\n         connect_nodes(self.nodes[0], 1)\n         connect_nodes(self.nodes[0], 2)\n         connect_nodes(self.nodes[0], 3)\n \n-        self.is_network_split = False\n         self.sync_all()\n \n     def run_test(self):"
      },
      {
        "sha": "6ff91a960b627c90377a98669fc592ec8071b74f",
        "filename": "test/functional/multi_rpc.py",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/multi_rpc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/multi_rpc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/multi_rpc.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -27,9 +27,6 @@ def setup_chain(self):\n             f.write(rpcauth+\"\\n\")\n             f.write(rpcauth2+\"\\n\")\n \n-    def setup_network(self):\n-        self.nodes = self.setup_nodes()\n-\n     def run_test(self):\n \n         ##################################################"
      },
      {
        "sha": "fb460644413ac9157f784aba39a1258b95780af9",
        "filename": "test/functional/net.py",
        "status": "modified",
        "additions": 49,
        "deletions": 10,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/net.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/net.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/net.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -7,15 +7,14 @@\n Tests correspond to code in rpc/net.cpp.\n \"\"\"\n \n-from decimal import Decimal\n import time\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.authproxy import JSONRPCException\n from test_framework.util import (\n     assert_equal,\n-    start_nodes,\n+    assert_raises_jsonrpc,\n     connect_nodes_bi,\n+    p2p_port,\n )\n \n \n@@ -25,15 +24,42 @@ def __init__(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 2\n \n-    def setup_network(self):\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir)\n-        connect_nodes_bi(self.nodes, 0, 1)\n-        self.is_network_split = False\n-        self.sync_all()\n-\n     def run_test(self):\n+        self._test_connection_count()\n+        self._test_getnettotals()\n+        self._test_getnetworkinginfo()\n+        self._test_getaddednodeinfo()\n+\n+    def _test_connection_count(self):\n+        # connect_nodes_bi connects each node to the other\n+        assert_equal(self.nodes[0].getconnectioncount(), 2)\n+\n+    def _test_getnettotals(self):\n+        # check that getnettotals totalbytesrecv and totalbytessent\n+        # are consistent with getpeerinfo\n+        peer_info = self.nodes[0].getpeerinfo()\n+        assert_equal(len(peer_info), 2)\n+        net_totals = self.nodes[0].getnettotals()\n+        assert_equal(sum([peer['bytesrecv'] for peer in peer_info]),\n+                     net_totals['totalbytesrecv'])\n+        assert_equal(sum([peer['bytessent'] for peer in peer_info]),\n+                     net_totals['totalbytessent'])\n+        # test getnettotals and getpeerinfo by doing a ping\n+        # the bytes sent/received should change\n+        # note ping and pong are 32 bytes each\n+        self.nodes[0].ping()\n+        time.sleep(0.1)\n+        peer_info_after_ping = self.nodes[0].getpeerinfo()\n+        net_totals_after_ping = self.nodes[0].getnettotals()\n+        for before, after in zip(peer_info, peer_info_after_ping):\n+            assert_equal(before['bytesrecv_per_msg']['pong'] + 32, after['bytesrecv_per_msg']['pong'])\n+            assert_equal(before['bytessent_per_msg']['ping'] + 32, after['bytessent_per_msg']['ping'])\n+        assert_equal(net_totals['totalbytesrecv'] + 32*2, net_totals_after_ping['totalbytesrecv'])\n+        assert_equal(net_totals['totalbytessent'] + 32*2, net_totals_after_ping['totalbytessent'])\n+\n+    def _test_getnetworkinginfo(self):\n         assert_equal(self.nodes[0].getnetworkinfo()['networkactive'], True)\n-        assert_equal(self.nodes[0].getnetworkinfo()['connections'], 2) # bilateral connection\n+        assert_equal(self.nodes[0].getnetworkinfo()['connections'], 2)\n \n         self.nodes[0].setnetworkactive(False)\n         assert_equal(self.nodes[0].getnetworkinfo()['networkactive'], False)\n@@ -49,6 +75,19 @@ def run_test(self):\n         assert_equal(self.nodes[0].getnetworkinfo()['networkactive'], True)\n         assert_equal(self.nodes[0].getnetworkinfo()['connections'], 2)\n \n+    def _test_getaddednodeinfo(self):\n+        assert_equal(self.nodes[0].getaddednodeinfo(), [])\n+        # add a node (node2) to node0\n+        ip_port = \"127.0.0.1:{}\".format(p2p_port(2))\n+        self.nodes[0].addnode(ip_port, 'add')\n+        # check that the node has indeed been added\n+        added_nodes = self.nodes[0].getaddednodeinfo(ip_port)\n+        assert_equal(len(added_nodes), 1)\n+        assert_equal(added_nodes[0]['addednode'], ip_port)\n+        # check that a non-existant node returns an error\n+        assert_raises_jsonrpc(-24, \"Node has not been added\",\n+                              self.nodes[0].getaddednodeinfo, '1.1.1.1')\n+\n \n if __name__ == '__main__':\n     NetTest().main()"
      },
      {
        "sha": "9717add272e999f006118f2695915c0c2529d400",
        "filename": "test/functional/nulldummy.py",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/nulldummy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/nulldummy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/nulldummy.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -41,11 +41,7 @@ def __init__(self):\n         super().__init__()\n         self.num_nodes = 1\n         self.setup_clean_chain = True\n-\n-    def setup_network(self):\n-        # Must set the blockversion for this test\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir,\n-                                 extra_args=[['-whitelist=127.0.0.1', '-walletprematurewitness']])\n+        self.extra_args = [['-whitelist=127.0.0.1', '-walletprematurewitness']]\n \n     def run_test(self):\n         self.address = self.nodes[0].getnewaddress()"
      },
      {
        "sha": "322cb767db3137fc1c757711f5b1543943d9a906",
        "filename": "test/functional/p2p-acceptblock.py",
        "status": "modified",
        "additions": 6,
        "deletions": 44,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-acceptblock.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -54,40 +54,6 @@\n import time\n from test_framework.blocktools import create_block, create_coinbase\n \n-# TestNode: bare-bones \"peer\".  Used mostly as a conduit for a test to sending\n-# p2p messages to a node, generating the messages in the main testing logic.\n-class TestNode(NodeConnCB):\n-    def __init__(self):\n-        super().__init__()\n-        self.connection = None\n-        self.ping_counter = 1\n-        self.last_pong = msg_pong()\n-\n-    def add_connection(self, conn):\n-        self.connection = conn\n-\n-    # Track the last getdata message we receive (used in the test)\n-    def on_getdata(self, conn, message):\n-        self.last_getdata = message\n-\n-    # Spin until verack message is received from the node.\n-    # We use this to signal that our test can begin. This\n-    # is called from the testing thread, so it needs to acquire\n-    # the global lock.\n-    def wait_for_verack(self):\n-        while True:\n-            with mininode_lock:\n-                if self.verack_received:\n-                    return\n-            time.sleep(0.05)\n-\n-    # Wrapper for the NodeConn's send_message function\n-    def send_message(self, message):\n-        self.connection.send_message(message)\n-\n-    def on_pong(self, conn, message):\n-        self.last_pong = message\n-\n class AcceptBlockTest(BitcoinTestFramework):\n     def add_options(self, parser):\n         parser.add_option(\"--testbinary\", dest=\"testbinary\",\n@@ -98,22 +64,18 @@ def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n         self.num_nodes = 2\n+        self.extra_args = [[], [\"-whitelist=127.0.0.1\"]]\n \n     def setup_network(self):\n         # Node0 will be used to test behavior of processing unrequested blocks\n         # from peers which are not whitelisted, while Node1 will be used for\n         # the whitelisted case.\n-        self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir,\n-                                     binary=self.options.testbinary))\n-        self.nodes.append(start_node(1, self.options.tmpdir,\n-                                     [\"-whitelist=127.0.0.1\"],\n-                                     binary=self.options.testbinary))\n+        self.setup_nodes()\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n-        test_node = TestNode()   # connects to node0 (not whitelisted)\n-        white_node = TestNode()  # connects to node1 (whitelisted)\n+        test_node = NodeConnCB()   # connects to node0 (not whitelisted)\n+        white_node = NodeConnCB()  # connects to node1 (whitelisted)\n \n         connections = []\n         connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node))\n@@ -238,12 +200,12 @@ def run_test(self):\n         # triggers a getdata on block 2 (it should if block 2 is missing).\n         with mininode_lock:\n             # Clear state so we can check the getdata request\n-            test_node.last_getdata = None\n+            test_node.last_message.pop(\"getdata\", None)\n             test_node.send_message(msg_inv([CInv(2, blocks_h3[0].sha256)]))\n \n         test_node.sync_with_ping()\n         with mininode_lock:\n-            getdata = test_node.last_getdata\n+            getdata = test_node.last_message[\"getdata\"]\n \n         # Check that the getdata includes the right block\n         assert_equal(getdata.inv[0].hash, blocks_h2f[0].sha256)"
      },
      {
        "sha": "9b302120ac68fabf503779a4c1214f812893b92d",
        "filename": "test/functional/p2p-compactblocks.py",
        "status": "modified",
        "additions": 66,
        "deletions": 108,
        "changes": 174,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-compactblocks.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -19,64 +19,31 @@ class TestNode(NodeConnCB):\n     def __init__(self):\n         super().__init__()\n         self.last_sendcmpct = []\n-        self.last_headers = None\n-        self.last_inv = None\n-        self.last_cmpctblock = None\n         self.block_announced = False\n-        self.last_getdata = None\n-        self.last_getheaders = None\n-        self.last_getblocktxn = None\n-        self.last_block = None\n-        self.last_blocktxn = None\n         # Store the hashes of blocks we've seen announced.\n         # This is for synchronizing the p2p message traffic,\n         # so we can eg wait until a particular block is announced.\n-        self.set_announced_blockhashes = set()\n-        self.connected = False\n-\n-    def on_open(self, conn):\n-        self.connected = True\n-\n-    def on_close(self, conn):\n-        self.connected = False\n+        self.announced_blockhashes = set()\n \n     def on_sendcmpct(self, conn, message):\n         self.last_sendcmpct.append(message)\n \n-    def on_block(self, conn, message):\n-        self.last_block = message\n-\n     def on_cmpctblock(self, conn, message):\n-        self.last_cmpctblock = message\n         self.block_announced = True\n-        self.last_cmpctblock.header_and_shortids.header.calc_sha256()\n-        self.set_announced_blockhashes.add(self.last_cmpctblock.header_and_shortids.header.sha256)\n+        self.last_message[\"cmpctblock\"].header_and_shortids.header.calc_sha256()\n+        self.announced_blockhashes.add(self.last_message[\"cmpctblock\"].header_and_shortids.header.sha256)\n \n     def on_headers(self, conn, message):\n-        self.last_headers = message\n         self.block_announced = True\n-        for x in self.last_headers.headers:\n+        for x in self.last_message[\"headers\"].headers:\n             x.calc_sha256()\n-            self.set_announced_blockhashes.add(x.sha256)\n+            self.announced_blockhashes.add(x.sha256)\n \n     def on_inv(self, conn, message):\n-        self.last_inv = message\n-        for x in self.last_inv.inv:\n+        for x in self.last_message[\"inv\"].inv:\n             if x.type == 2:\n                 self.block_announced = True\n-                self.set_announced_blockhashes.add(x.hash)\n-\n-    def on_getdata(self, conn, message):\n-        self.last_getdata = message\n-\n-    def on_getheaders(self, conn, message):\n-        self.last_getheaders = message\n-\n-    def on_getblocktxn(self, conn, message):\n-        self.last_getblocktxn = message\n-\n-    def on_blocktxn(self, conn, message):\n-        self.last_blocktxn = message\n+                self.announced_blockhashes.add(x.hash)\n \n     # Requires caller to hold mininode_lock\n     def received_block_announcement(self):\n@@ -85,9 +52,9 @@ def received_block_announcement(self):\n     def clear_block_announcement(self):\n         with mininode_lock:\n             self.block_announced = False\n-            self.last_inv = None\n-            self.last_headers = None\n-            self.last_cmpctblock = None\n+            self.last_message.pop(\"inv\", None)\n+            self.last_message.pop(\"headers\", None)\n+            self.last_message.pop(\"cmpctblock\", None)\n \n     def get_headers(self, locator, hashstop):\n         msg = msg_getheaders()\n@@ -103,15 +70,14 @@ def send_header_for_blocks(self, new_blocks):\n     def request_headers_and_sync(self, locator, hashstop=0):\n         self.clear_block_announcement()\n         self.get_headers(locator, hashstop)\n-        assert(wait_until(self.received_block_announcement, timeout=30))\n-        assert(self.received_block_announcement())\n+        assert wait_until(self.received_block_announcement, timeout=30)\n         self.clear_block_announcement()\n \n     # Block until a block announcement for a particular block hash is\n     # received.\n     def wait_for_block_announcement(self, block_hash, timeout=30):\n         def received_hash():\n-            return (block_hash in self.set_announced_blockhashes)\n+            return (block_hash in self.announced_blockhashes)\n         return wait_until(received_hash, timeout=timeout)\n \n     def send_await_disconnect(self, message, timeout=30):\n@@ -132,17 +98,9 @@ def __init__(self):\n         self.setup_clean_chain = True\n         # Node0 = pre-segwit, node1 = segwit-aware\n         self.num_nodes = 2\n+        self.extra_args = [[\"-bip9params=segwit:0:0\"], [\"-txindex\"]]\n         self.utxos = []\n \n-    def setup_network(self):\n-        self.nodes = []\n-\n-        # Start up node0 to be a version 1, pre-segwit node.\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, \n-                [[\"-bip9params=segwit:0:0\"], \n-                 [\"-txindex\"]])\n-        connect_nodes(self.nodes[0], 1)\n-\n     def build_block_on_tip(self, node, segwit=False):\n         height = node.getblockcount()\n         tip = node.getbestblockhash()\n@@ -214,14 +172,14 @@ def check_announcement_of_new_block(node, peer, predicate):\n             with mininode_lock:\n                 assert predicate(peer), (\n                     \"block_hash={!r}, cmpctblock={!r}, inv={!r}\".format(\n-                        block_hash, peer.last_cmpctblock, peer.last_inv))\n+                        block_hash, peer.last_message.get(\"cmpctblock\", None), peer.last_message.get(\"inv\", None)))\n \n         # We shouldn't get any block announcements via cmpctblock yet.\n-        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is None)\n+        check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" not in p.last_message)\n \n         # Try one more time, this time after requesting headers.\n         test_node.request_headers_and_sync(locator=[tip])\n-        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is None and p.last_inv is not None)\n+        check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" not in p.last_message and \"inv\" in p.last_message)\n \n         # Test a few ways of using sendcmpct that should NOT\n         # result in compact block announcements.\n@@ -233,7 +191,7 @@ def check_announcement_of_new_block(node, peer, predicate):\n         sendcmpct.version = preferred_version+1\n         sendcmpct.announce = True\n         test_node.send_and_ping(sendcmpct)\n-        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is None)\n+        check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" not in p.last_message)\n \n         # Headers sync before next test.\n         test_node.request_headers_and_sync(locator=[tip])\n@@ -242,7 +200,7 @@ def check_announcement_of_new_block(node, peer, predicate):\n         sendcmpct.version = preferred_version\n         sendcmpct.announce = False\n         test_node.send_and_ping(sendcmpct)\n-        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is None)\n+        check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" not in p.last_message)\n \n         # Headers sync before next test.\n         test_node.request_headers_and_sync(locator=[tip])\n@@ -251,26 +209,26 @@ def check_announcement_of_new_block(node, peer, predicate):\n         sendcmpct.version = preferred_version\n         sendcmpct.announce = True\n         test_node.send_and_ping(sendcmpct)\n-        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is not None)\n+        check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" in p.last_message)\n \n         # Try one more time (no headers sync should be needed!)\n-        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is not None)\n+        check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" in p.last_message)\n \n         # Try one more time, after turning on sendheaders\n         test_node.send_and_ping(msg_sendheaders())\n-        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is not None)\n+        check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" in p.last_message)\n \n         # Try one more time, after sending a version-1, announce=false message.\n         sendcmpct.version = preferred_version-1\n         sendcmpct.announce = False\n         test_node.send_and_ping(sendcmpct)\n-        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is not None)\n+        check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" in p.last_message)\n \n         # Now turn off announcements\n         sendcmpct.version = preferred_version\n         sendcmpct.announce = False\n         test_node.send_and_ping(sendcmpct)\n-        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is None and p.last_headers is not None)\n+        check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" not in p.last_message and \"headers\" in p.last_message)\n \n         if old_node is not None:\n             # Verify that a peer using an older protocol version can receive\n@@ -280,7 +238,7 @@ def check_announcement_of_new_block(node, peer, predicate):\n             old_node.send_and_ping(sendcmpct)\n             # Header sync\n             old_node.request_headers_and_sync(locator=[tip])\n-            check_announcement_of_new_block(node, old_node, lambda p: p.last_cmpctblock is not None)\n+            check_announcement_of_new_block(node, old_node, lambda p: \"cmpctblock\" in p.last_message)\n \n     # This test actually causes bitcoind to (reasonably!) disconnect us, so do this last.\n     def test_invalid_cmpctblock_message(self):\n@@ -345,9 +303,9 @@ def test_compactblock_construction(self, node, test_node, version, use_witness_a\n         # Now fetch and check the compact block\n         header_and_shortids = None\n         with mininode_lock:\n-            assert(test_node.last_cmpctblock is not None)\n+            assert(\"cmpctblock\" in test_node.last_message)\n             # Convert the on-the-wire representation to absolute indexes\n-            header_and_shortids = HeaderAndShortIDs(test_node.last_cmpctblock.header_and_shortids)\n+            header_and_shortids = HeaderAndShortIDs(test_node.last_message[\"cmpctblock\"].header_and_shortids)\n         self.check_compactblock_construction_from_block(version, header_and_shortids, block_hash, block)\n \n         # Now fetch the compact block using a normal non-announce getdata\n@@ -362,9 +320,9 @@ def test_compactblock_construction(self, node, test_node, version, use_witness_a\n         # Now fetch and check the compact block\n         header_and_shortids = None\n         with mininode_lock:\n-            assert(test_node.last_cmpctblock is not None)\n+            assert(\"cmpctblock\" in test_node.last_message)\n             # Convert the on-the-wire representation to absolute indexes\n-            header_and_shortids = HeaderAndShortIDs(test_node.last_cmpctblock.header_and_shortids)\n+            header_and_shortids = HeaderAndShortIDs(test_node.last_message[\"cmpctblock\"].header_and_shortids)\n         self.check_compactblock_construction_from_block(version, header_and_shortids, block_hash, block)\n \n     def check_compactblock_construction_from_block(self, version, header_and_shortids, block_hash, block):\n@@ -424,20 +382,20 @@ def test_compactblock_requests(self, node, test_node, version, segwit):\n         for announce in [\"inv\", \"header\"]:\n             block = self.build_block_on_tip(node, segwit=segwit)\n             with mininode_lock:\n-                test_node.last_getdata = None\n+                test_node.last_message.pop(\"getdata\", None)\n \n             if announce == \"inv\":\n                 test_node.send_message(msg_inv([CInv(2, block.sha256)]))\n-                success = wait_until(lambda: test_node.last_getheaders is not None, timeout=30)\n+                success = wait_until(lambda: \"getheaders\" in test_node.last_message, timeout=30)\n                 assert(success)\n                 test_node.send_header_for_blocks([block])\n             else:\n                 test_node.send_header_for_blocks([block])\n-            success = wait_until(lambda: test_node.last_getdata is not None, timeout=30)\n+            success = wait_until(lambda: \"getdata\" in test_node.last_message, timeout=30)\n             assert(success)\n-            assert_equal(len(test_node.last_getdata.inv), 1)\n-            assert_equal(test_node.last_getdata.inv[0].type, 4)\n-            assert_equal(test_node.last_getdata.inv[0].hash, block.sha256)\n+            assert_equal(len(test_node.last_message[\"getdata\"].inv), 1)\n+            assert_equal(test_node.last_message[\"getdata\"].inv[0].type, 4)\n+            assert_equal(test_node.last_message[\"getdata\"].inv[0].hash, block.sha256)\n \n             # Send back a compactblock message that omits the coinbase\n             comp_block = HeaderAndShortIDs()\n@@ -453,8 +411,8 @@ def test_compactblock_requests(self, node, test_node, version, segwit):\n             assert_equal(int(node.getbestblockhash(), 16), block.hashPrevBlock)\n             # Expect a getblocktxn message.\n             with mininode_lock:\n-                assert(test_node.last_getblocktxn is not None)\n-                absolute_indexes = test_node.last_getblocktxn.block_txn_request.to_absolute()\n+                assert(\"getblocktxn\" in test_node.last_message)\n+                absolute_indexes = test_node.last_message[\"getblocktxn\"].block_txn_request.to_absolute()\n             assert_equal(absolute_indexes, [0])  # should be a coinbase request\n \n             # Send the coinbase, and verify that the tip advances.\n@@ -493,8 +451,8 @@ def test_getblocktxn_response(compact_block, peer, expected_result):\n             msg = msg_cmpctblock(compact_block.to_p2p())\n             peer.send_and_ping(msg)\n             with mininode_lock:\n-                assert(peer.last_getblocktxn is not None)\n-                absolute_indexes = peer.last_getblocktxn.block_txn_request.to_absolute()\n+                assert(\"getblocktxn\" in peer.last_message)\n+                absolute_indexes = peer.last_message[\"getblocktxn\"].block_txn_request.to_absolute()\n             assert_equal(absolute_indexes, expected_result)\n \n         def test_tip_after_message(node, peer, msg, tip):\n@@ -558,14 +516,14 @@ def test_tip_after_message(node, peer, msg, tip):\n \n         # Clear out last request.\n         with mininode_lock:\n-            test_node.last_getblocktxn = None\n+            test_node.last_message.pop(\"getblocktxn\", None)\n \n         # Send compact block\n         comp_block.initialize_from_block(block, prefill_list=[0], use_witness=with_witness)\n         test_tip_after_message(node, test_node, msg_cmpctblock(comp_block.to_p2p()), block.sha256)\n         with mininode_lock:\n             # Shouldn't have gotten a request for any transaction\n-            assert(test_node.last_getblocktxn is None)\n+            assert(\"getblocktxn\" not in test_node.last_message)\n \n     # Incorrectly responding to a getblocktxn shouldn't cause the block to be\n     # permanently failed.\n@@ -591,8 +549,8 @@ def test_incorrect_blocktxn_response(self, node, test_node, version):\n         test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n         absolute_indexes = []\n         with mininode_lock:\n-            assert(test_node.last_getblocktxn is not None)\n-            absolute_indexes = test_node.last_getblocktxn.block_txn_request.to_absolute()\n+            assert(\"getblocktxn\" in test_node.last_message)\n+            absolute_indexes = test_node.last_message[\"getblocktxn\"].block_txn_request.to_absolute()\n         assert_equal(absolute_indexes, [6, 7, 8, 9, 10])\n \n         # Now give an incorrect response.\n@@ -613,11 +571,11 @@ def test_incorrect_blocktxn_response(self, node, test_node, version):\n         assert_equal(int(node.getbestblockhash(), 16), block.hashPrevBlock)\n \n         # We should receive a getdata request\n-        success = wait_until(lambda: test_node.last_getdata is not None, timeout=10)\n+        success = wait_until(lambda: \"getdata\" in test_node.last_message, timeout=10)\n         assert(success)\n-        assert_equal(len(test_node.last_getdata.inv), 1)\n-        assert(test_node.last_getdata.inv[0].type == 2 or test_node.last_getdata.inv[0].type == 2|MSG_WITNESS_FLAG)\n-        assert_equal(test_node.last_getdata.inv[0].hash, block.sha256)\n+        assert_equal(len(test_node.last_message[\"getdata\"].inv), 1)\n+        assert(test_node.last_message[\"getdata\"].inv[0].type == 2 or test_node.last_message[\"getdata\"].inv[0].type == 2|MSG_WITNESS_FLAG)\n+        assert_equal(test_node.last_message[\"getdata\"].inv[0].hash, block.sha256)\n \n         # Deliver the block\n         if version==2:\n@@ -641,15 +599,15 @@ def test_getblocktxn_handler(self, node, test_node, version):\n             num_to_request = random.randint(1, len(block.vtx))\n             msg.block_txn_request.from_absolute(sorted(random.sample(range(len(block.vtx)), num_to_request)))\n             test_node.send_message(msg)\n-            success = wait_until(lambda: test_node.last_blocktxn is not None, timeout=10)\n+            success = wait_until(lambda: \"blocktxn\" in test_node.last_message, timeout=10)\n             assert(success)\n \n             [tx.calc_sha256() for tx in block.vtx]\n             with mininode_lock:\n-                assert_equal(test_node.last_blocktxn.block_transactions.blockhash, int(block_hash, 16))\n+                assert_equal(test_node.last_message[\"blocktxn\"].block_transactions.blockhash, int(block_hash, 16))\n                 all_indices = msg.block_txn_request.to_absolute()\n                 for index in all_indices:\n-                    tx = test_node.last_blocktxn.block_transactions.transactions.pop(0)\n+                    tx = test_node.last_message[\"blocktxn\"].block_transactions.transactions.pop(0)\n                     tx.calc_sha256()\n                     assert_equal(tx.sha256, block.vtx[index].sha256)\n                     if version == 1:\n@@ -658,21 +616,21 @@ def test_getblocktxn_handler(self, node, test_node, version):\n                     else:\n                         # Check that the witness matches\n                         assert_equal(tx.calc_sha256(True), block.vtx[index].calc_sha256(True))\n-                test_node.last_blocktxn = None\n+                test_node.last_message.pop(\"blocktxn\", None)\n             current_height -= 1\n \n         # Next request should send a full block response, as we're past the\n         # allowed depth for a blocktxn response.\n         block_hash = node.getblockhash(current_height)\n         msg.block_txn_request = BlockTransactionsRequest(int(block_hash, 16), [0])\n         with mininode_lock:\n-            test_node.last_block = None\n-            test_node.last_blocktxn = None\n+            test_node.last_message.pop(\"block\", None)\n+            test_node.last_message.pop(\"blocktxn\", None)\n         test_node.send_and_ping(msg)\n         with mininode_lock:\n-            test_node.last_block.block.calc_sha256()\n-            assert_equal(test_node.last_block.block.sha256, int(block_hash, 16))\n-            assert_equal(test_node.last_blocktxn, None)\n+            test_node.last_message[\"block\"].block.calc_sha256()\n+            assert_equal(test_node.last_message[\"block\"].block.sha256, int(block_hash, 16))\n+            assert \"blocktxn\" not in test_node.last_message\n \n     def test_compactblocks_not_at_tip(self, node, test_node):\n         # Test that requesting old compactblocks doesn't work.\n@@ -685,21 +643,21 @@ def test_compactblocks_not_at_tip(self, node, test_node):\n \n         test_node.clear_block_announcement()\n         test_node.send_message(msg_getdata([CInv(4, int(new_blocks[0], 16))]))\n-        success = wait_until(lambda: test_node.last_cmpctblock is not None, timeout=30)\n+        success = wait_until(lambda: \"cmpctblock\" in test_node.last_message, timeout=30)\n         assert(success)\n \n         test_node.clear_block_announcement()\n         node.generate(1)\n         wait_until(test_node.received_block_announcement, timeout=30)\n         test_node.clear_block_announcement()\n         with mininode_lock:\n-            test_node.last_block = None\n+            test_node.last_message.pop(\"block\", None)\n         test_node.send_message(msg_getdata([CInv(4, int(new_blocks[0], 16))]))\n-        success = wait_until(lambda: test_node.last_block is not None, timeout=30)\n+        success = wait_until(lambda: \"block\" in test_node.last_message, timeout=30)\n         assert(success)\n         with mininode_lock:\n-            test_node.last_block.block.calc_sha256()\n-            assert_equal(test_node.last_block.block.sha256, int(new_blocks[0], 16))\n+            test_node.last_message[\"block\"].block.calc_sha256()\n+            assert_equal(test_node.last_message[\"block\"].block.sha256, int(new_blocks[0], 16))\n \n         # Generate an old compactblock, and verify that it's not accepted.\n         cur_height = node.getblockcount()\n@@ -726,10 +684,10 @@ def test_compactblocks_not_at_tip(self, node, test_node):\n         msg = msg_getblocktxn()\n         msg.block_txn_request = BlockTransactionsRequest(block.sha256, [0])\n         with mininode_lock:\n-            test_node.last_blocktxn = None\n+            test_node.last_message.pop(\"blocktxn\", None)\n         test_node.send_and_ping(msg)\n         with mininode_lock:\n-            assert(test_node.last_blocktxn is None)\n+            assert \"blocktxn\" not in test_node.last_message\n \n     def activate_segwit(self, node):\n         node.generate(144*3)\n@@ -750,9 +708,9 @@ def test_end_to_end_block_relay(self, node, listeners):\n             wait_until(lambda: l.received_block_announcement(), timeout=30)\n         with mininode_lock:\n             for l in listeners:\n-                assert(l.last_cmpctblock is not None)\n-                l.last_cmpctblock.header_and_shortids.header.calc_sha256()\n-                assert_equal(l.last_cmpctblock.header_and_shortids.header.sha256, block.sha256)\n+                assert \"cmpctblock\" in l.last_message\n+                l.last_message[\"cmpctblock\"].header_and_shortids.header.calc_sha256()\n+                assert_equal(l.last_message[\"cmpctblock\"].header_and_shortids.header.sha256, block.sha256)\n \n     # Test that we don't get disconnected if we relay a compact block with valid header,\n     # but invalid transactions.\n@@ -804,7 +762,7 @@ def announce_cmpct_block(node, peer):\n             msg = msg_cmpctblock(cmpct_block.to_p2p())\n             peer.send_and_ping(msg)\n             with mininode_lock:\n-                assert(peer.last_getblocktxn is not None)\n+                assert \"getblocktxn\" in peer.last_message\n             return block, cmpct_block\n \n         block, cmpct_block = announce_cmpct_block(node, stalling_peer)"
      },
      {
        "sha": "dbccb633a5b88abe7196a50a17ceb5aa350ebcaf",
        "filename": "test/functional/p2p-feefilter.py",
        "status": "modified",
        "additions": 2,
        "deletions": 16,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/p2p-feefilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/p2p-feefilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-feefilter.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -22,8 +22,6 @@ def allInvsMatch(invsExpected, testnode):\n         time.sleep(1)\n     return False\n \n-# TestNode: bare-bones \"peer\".  Used to track which invs are received from a node\n-# and to send the node feefilter messages.\n class TestNode(NodeConnCB):\n     def __init__(self):\n         super().__init__()\n@@ -38,25 +36,13 @@ def clear_invs(self):\n         with mininode_lock:\n             self.txinvs = []\n \n-    def send_filter(self, feerate):\n-        self.send_message(msg_feefilter(feerate))\n-        self.sync_with_ping()\n-\n class FeeFilterTest(BitcoinTestFramework):\n \n     def __init__(self):\n         super().__init__()\n         self.num_nodes = 2\n         self.setup_clean_chain = False\n \n-    def setup_network(self):\n-        # Node1 will be used to generate txs which should be relayed from Node0\n-        # to our test node\n-        self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir))\n-        self.nodes.append(start_node(1, self.options.tmpdir))\n-        connect_nodes(self.nodes[0], 1)\n-\n     def run_test(self):\n         node1 = self.nodes[1]\n         node0 = self.nodes[0]\n@@ -78,7 +64,7 @@ def run_test(self):\n         test_node.clear_invs()\n \n         # Set a filter of 15 sat/byte\n-        test_node.send_filter(15000)\n+        test_node.send_and_ping(msg_feefilter(15000))\n \n         # Test that txs are still being received (paying 20 sat/byte)\n         txids = [node1.sendtoaddress(node1.getnewaddress(), 1) for x in range(3)]\n@@ -103,7 +89,7 @@ def run_test(self):\n         test_node.clear_invs()\n \n         # Remove fee filter and check that txs are received again\n-        test_node.send_filter(0)\n+        test_node.send_and_ping(msg_feefilter(0))\n         txids = [node1.sendtoaddress(node1.getnewaddress(), 1) for x in range(3)]\n         assert(allInvsMatch(txids, test_node))\n         test_node.clear_invs()"
      },
      {
        "sha": "33b57ef33d8d021b9ebb9b99af214fb76d1484d2",
        "filename": "test/functional/p2p-leaktests.py",
        "status": "modified",
        "additions": 7,
        "deletions": 17,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/p2p-leaktests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/p2p-leaktests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-leaktests.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -20,22 +20,16 @@\n class CLazyNode(NodeConnCB):\n     def __init__(self):\n         super().__init__()\n-        self.connection = None\n         self.unexpected_msg = False\n-        self.connected = False\n-\n-    def add_connection(self, conn):\n-        self.connection = conn\n-\n-    def send_message(self, message):\n-        self.connection.send_message(message)\n+        self.ever_connected = False\n \n     def bad_message(self, message):\n         self.unexpected_msg = True\n         self.log.info(\"should not have received message: %s\" % message.command)\n \n     def on_open(self, conn):\n         self.connected = True\n+        self.ever_connected = True\n \n     def on_version(self, conn, message): self.bad_message(message)\n     def on_verack(self, conn, message): self.bad_message(message)\n@@ -63,9 +57,6 @@ def on_blocktxn(self, conn, message): self.bad_message(message)\n # Node that never sends a version. We'll use this to send a bunch of messages\n # anyway, and eventually get disconnected.\n class CNodeNoVersionBan(CLazyNode):\n-    def __init__(self):\n-        super().__init__()\n-\n     # send a bunch of veracks without sending a message. This should get us disconnected.\n     # NOTE: implementation-specific check here. Remove if bitcoind ban behavior changes\n     def on_open(self, conn):\n@@ -101,10 +92,7 @@ class P2PLeakTest(BitcoinTestFramework):\n     def __init__(self):\n         super().__init__()\n         self.num_nodes = 1\n-    def setup_network(self):\n-        extra_args = [['-banscore='+str(banscore)]\n-                      for i in range(self.num_nodes)]\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n+        self.extra_args = [['-banscore='+str(banscore)]]\n \n     def run_test(self):\n         no_version_bannode = CNodeNoVersionBan()\n@@ -121,7 +109,9 @@ def run_test(self):\n \n         NetworkThread().start()  # Start up network handling in another thread\n \n-        assert(wait_until(lambda: no_version_bannode.connected and no_version_idlenode.connected and no_verack_idlenode.version_received, timeout=10))\n+        assert wait_until(lambda: no_version_bannode.ever_connected, timeout=10)\n+        assert wait_until(lambda: no_version_idlenode.ever_connected, timeout=10)\n+        assert wait_until(lambda: no_verack_idlenode.version_received, timeout=10)\n \n         # Mine a block and make sure that it's not sent to the connected nodes\n         self.nodes[0].generate(1)\n@@ -130,7 +120,7 @@ def run_test(self):\n         time.sleep(5)\n \n         #This node should have been banned\n-        assert(no_version_bannode.connection.state == \"closed\")\n+        assert not no_version_bannode.connected\n \n         [conn.disconnect_node() for conn in connections]\n "
      },
      {
        "sha": "34ef249eeaa08857a980ffdb075701ff496df846",
        "filename": "test/functional/p2p-mempool.py",
        "status": "modified",
        "additions": 4,
        "deletions": 62,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/p2p-mempool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/p2p-mempool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-mempool.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -12,82 +12,24 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n \n-class TestNode(NodeConnCB):\n-    def __init__(self):\n-        super().__init__()\n-        self.connection = None\n-        self.ping_counter = 1\n-        self.last_pong = msg_pong()\n-        self.block_receive_map = {}\n-\n-    def add_connection(self, conn):\n-        self.connection = conn\n-        self.peer_disconnected = False\n-\n-    def on_inv(self, conn, message):\n-        pass\n-\n-    # Track the last getdata message we receive (used in the test)\n-    def on_getdata(self, conn, message):\n-        self.last_getdata = message\n-\n-    def on_block(self, conn, message):\n-        message.block.calc_sha256()\n-        try:\n-            self.block_receive_map[message.block.sha256] += 1\n-        except KeyError as e:\n-            self.block_receive_map[message.block.sha256] = 1\n-\n-    # Spin until verack message is received from the node.\n-    # We use this to signal that our test can begin. This\n-    # is called from the testing thread, so it needs to acquire\n-    # the global lock.\n-    def wait_for_verack(self):\n-        def veracked():\n-            return self.verack_received\n-        return wait_until(veracked, timeout=10)\n-\n-    def wait_for_disconnect(self):\n-        def disconnected():\n-            return self.peer_disconnected\n-        return wait_until(disconnected, timeout=10)\n-\n-    # Wrapper for the NodeConn's send_message function\n-    def send_message(self, message):\n-        self.connection.send_message(message)\n-\n-    def on_pong(self, conn, message):\n-        self.last_pong = message\n-\n-    def on_close(self, conn):\n-        self.peer_disconnected = True\n-\n-    def send_mempool(self):\n-        self.lastInv = []\n-        self.send_message(msg_mempool())\n-\n class P2PMempoolTests(BitcoinTestFramework):\n \n     def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n-        self.num_nodes = 2\n-\n-    def setup_network(self):\n-        # Start a node with maxuploadtarget of 200 MB (/24h)\n-        self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-peerbloomfilters=0\"]))\n+        self.num_nodes = 1\n+        self.extra_args = [[\"-peerbloomfilters=0\"]]\n \n     def run_test(self):\n         #connect a mininode\n-        aTestNode = TestNode()\n+        aTestNode = NodeConnCB()\n         node = NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], aTestNode)\n         aTestNode.add_connection(node)\n         NetworkThread().start()\n         aTestNode.wait_for_verack()\n \n         #request mempool\n-        aTestNode.send_mempool()\n+        aTestNode.send_message(msg_mempool())\n         aTestNode.wait_for_disconnect()\n \n         #mininode must be disconnected at this point"
      },
      {
        "sha": "24d4d37c426c50afd4c4995d8383a857804a8263",
        "filename": "test/functional/p2p-segwit.py",
        "status": "modified",
        "additions": 34,
        "deletions": 107,
        "changes": 141,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-segwit.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -8,7 +8,7 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n from test_framework.script import *\n-from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment, WITNESS_COMMITMENT_HEADER\n+from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment, get_witness_script, WITNESS_COMMITMENT_HEADER\n from test_framework.key import CECKey, CPubKey\n import time\n import random\n@@ -35,79 +35,22 @@ def get_virtual_size(witness_block):\n class TestNode(NodeConnCB):\n     def __init__(self):\n         super().__init__()\n-        self.connection = None\n-        self.ping_counter = 1\n-        self.last_pong = msg_pong(0)\n-        self.sleep_time = 0.05\n         self.getdataset = set()\n-        self.last_reject = None\n-\n-    def add_connection(self, conn):\n-        self.connection = conn\n-\n-    # Wrapper for the NodeConn's send_message function\n-    def send_message(self, message):\n-        self.connection.send_message(message)\n-\n-    def on_inv(self, conn, message):\n-        self.last_inv = message\n-\n-    def on_block(self, conn, message):\n-        self.last_block = message.block\n-        self.last_block.calc_sha256()\n \n     def on_getdata(self, conn, message):\n         for inv in message.inv:\n             self.getdataset.add(inv.hash)\n-        self.last_getdata = message\n-\n-    def on_getheaders(self, conn, message):\n-        self.last_getheaders = message\n-\n-    def on_pong(self, conn, message):\n-        self.last_pong = message\n-\n-    def on_reject(self, conn, message):\n-        self.last_reject = message\n-\n-    # Syncing helpers\n-    def sync(self, test_function, timeout=60):\n-        while timeout > 0:\n-            with mininode_lock:\n-                if test_function():\n-                    return\n-            time.sleep(self.sleep_time)\n-            timeout -= self.sleep_time\n-        raise AssertionError(\"Sync failed to complete\")\n-        \n-    def wait_for_block(self, blockhash, timeout=60):\n-        test_function = lambda: self.last_block != None and self.last_block.sha256 == blockhash\n-        self.sync(test_function, timeout)\n-        return\n-\n-    def wait_for_getdata(self, timeout=60):\n-        test_function = lambda: self.last_getdata != None\n-        self.sync(test_function, timeout)\n-\n-    def wait_for_getheaders(self, timeout=60):\n-        test_function = lambda: self.last_getheaders != None\n-        self.sync(test_function, timeout)\n-\n-    def wait_for_inv(self, expected_inv, timeout=60):\n-        test_function = lambda: self.last_inv != expected_inv\n-        self.sync(test_function, timeout)\n \n     def announce_tx_and_wait_for_getdata(self, tx, timeout=60):\n         with mininode_lock:\n-            self.last_getdata = None\n+            self.last_message.pop(\"getdata\", None)\n         self.send_message(msg_inv(inv=[CInv(1, tx.sha256)]))\n         self.wait_for_getdata(timeout)\n-        return\n \n     def announce_block_and_wait_for_getdata(self, block, use_header, timeout=60):\n         with mininode_lock:\n-            self.last_getdata = None\n-            self.last_getheaders = None\n+            self.last_message.pop(\"getdata\", None)\n+            self.last_message.pop(\"getheaders\", None)\n         msg = msg_headers()\n         msg.headers = [ CBlockHeader(block) ]\n         if use_header:\n@@ -117,47 +60,35 @@ def announce_block_and_wait_for_getdata(self, block, use_header, timeout=60):\n             self.wait_for_getheaders()\n             self.send_message(msg)\n         self.wait_for_getdata()\n-        return\n-\n-    def announce_block(self, block, use_header):\n-        with mininode_lock:\n-            self.last_getdata = None\n-        if use_header:\n-            msg = msg_headers()\n-            msg.headers = [ CBlockHeader(block) ]\n-            self.send_message(msg)\n-        else:\n-            self.send_message(msg_inv(inv=[CInv(2, block.sha256)]))\n \n     def request_block(self, blockhash, inv_type, timeout=60):\n         with mininode_lock:\n-            self.last_block = None\n+            self.last_message.pop(\"block\", None)\n         self.send_message(msg_getdata(inv=[CInv(inv_type, blockhash)]))\n         self.wait_for_block(blockhash, timeout)\n-        return self.last_block\n+        return self.last_message[\"block\"].block\n \n     def test_transaction_acceptance(self, tx, with_witness, accepted, reason=None):\n         tx_message = msg_tx(tx)\n         if with_witness:\n             tx_message = msg_witness_tx(tx)\n         self.send_message(tx_message)\n-        self.sync_with_ping(60)\n+        self.sync_with_ping()\n         assert_equal(tx.hash in self.connection.rpc.getrawmempool(), accepted)\n         if (reason != None and not accepted):\n             # Check the rejection reason as well.\n             with mininode_lock:\n-                assert_equal(self.last_reject.reason, reason)\n+                assert_equal(self.last_message[\"reject\"].reason, reason)\n \n     # Test whether a witness block had the correct effect on the tip\n     def test_witness_block(self, block, accepted, with_witness=True):\n         if with_witness:\n             self.send_message(msg_witness_block(block))\n         else:\n             self.send_message(msg_block(block))\n-        self.sync_with_ping(60)\n+        self.sync_with_ping()\n         assert_equal(self.connection.rpc.getbestblockhash() == block.hash, accepted)\n \n-\n # Used to keep track of anyone-can-spend outputs that we can use in the tests\n class UTXO(object):\n     def __init__(self, sha256, n, nValue):\n@@ -183,17 +114,13 @@ def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n         self.num_nodes = 3\n+        self.extra_args = [[\"-whitelist=127.0.0.1\"], [\"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=0\"], [\"-whitelist=127.0.0.1\", \"-bip9params=segwit:0:0\"]]\n \n     def setup_network(self):\n-        self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-whitelist=127.0.0.1\"]))\n-        # Start a node for testing IsStandard rules.\n-        self.nodes.append(start_node(1, self.options.tmpdir, [\"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=0\"]))\n+        self.setup_nodes()\n         connect_nodes(self.nodes[0], 1)\n-\n-        # Disable segwit's bip9 parameter to simulate upgrading after activation.\n-        self.nodes.append(start_node(2, self.options.tmpdir, [\"-whitelist=127.0.0.1\", \"-bip9params=segwit:0:0\"]))\n         connect_nodes(self.nodes[0], 2)\n+        self.sync_all()\n \n     ''' Helpers '''\n     # Build a block on top of node0's tip.\n@@ -228,7 +155,7 @@ def test_non_witness_transaction(self):\n         block = self.build_next_block(nVersion=1)\n         block.solve()\n         self.test_node.send_message(msg_block(block))\n-        self.test_node.sync_with_ping(60) # make sure the block was processed\n+        self.test_node.sync_with_ping() # make sure the block was processed\n         txid = block.vtx[0].sha256\n \n         self.nodes[0].generate(99) # let the block mature\n@@ -244,7 +171,7 @@ def test_non_witness_transaction(self):\n         assert_equal(msg_tx(tx).serialize(), msg_witness_tx(tx).serialize())\n \n         self.test_node.send_message(msg_witness_tx(tx))\n-        self.test_node.sync_with_ping(60) # make sure the tx was processed\n+        self.test_node.sync_with_ping() # make sure the tx was processed\n         assert(tx.hash in self.nodes[0].getrawmempool())\n         # Save this transaction for later\n         self.utxo.append(UTXO(tx.sha256, 0, 49*100000000))\n@@ -279,12 +206,12 @@ def test_unnecessary_witness_before_segwit_activation(self):\n         # TODO: fix synchronization so we can test reject reason\n         # Right now, bitcoind delays sending reject messages for blocks\n         # until the future, making synchronization here difficult.\n-        #assert_equal(self.test_node.last_reject.reason, \"unexpected-witness\")\n+        #assert_equal(self.test_node.last_message[\"reject\"].reason, \"unexpected-witness\")\n \n         # But it should not be permanently marked bad...\n         # Resend without witness information.\n         self.test_node.send_message(msg_block(block))\n-        self.test_node.sync_with_ping(60)\n+        self.test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n \n         sync_blocks(self.nodes)\n@@ -893,7 +820,7 @@ def test_witness_tx_relay_before_segwit_activation(self):\n         # Verify that if a peer doesn't set nServices to include NODE_WITNESS,\n         # the getdata is just for the non-witness portion.\n         self.old_node.announce_tx_and_wait_for_getdata(tx)\n-        assert(self.old_node.last_getdata.inv[0].type == 1)\n+        assert(self.old_node.last_message[\"getdata\"].inv[0].type == 1)\n \n         # Since we haven't delivered the tx yet, inv'ing the same tx from\n         # a witness transaction ought not result in a getdata.\n@@ -989,9 +916,9 @@ def test_tx_relay_after_segwit_activation(self):\n         tx3.wit.vtxinwit[0].scriptWitness.stack = [ witness_program ]\n         # Also check that old_node gets a tx announcement, even though this is\n         # a witness transaction.\n-        self.old_node.wait_for_inv(CInv(1, tx2.sha256)) # wait until tx2 was inv'ed\n+        self.old_node.wait_for_inv([CInv(1, tx2.sha256)]) # wait until tx2 was inv'ed\n         self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=True)\n-        self.old_node.wait_for_inv(CInv(1, tx3.sha256))\n+        self.old_node.wait_for_inv([CInv(1, tx3.sha256)])\n \n         # Test that getrawtransaction returns correct witness information\n         # hash, size, vsize\n@@ -1028,20 +955,20 @@ def test_block_relay(self, segwit_activated):\n         block1.solve()\n \n         self.test_node.announce_block_and_wait_for_getdata(block1, use_header=False)\n-        assert(self.test_node.last_getdata.inv[0].type == blocktype)\n+        assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n         self.test_node.test_witness_block(block1, True)\n \n         block2 = self.build_next_block(nVersion=4)\n         block2.solve()\n \n         self.test_node.announce_block_and_wait_for_getdata(block2, use_header=True)\n-        assert(self.test_node.last_getdata.inv[0].type == blocktype)\n+        assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n         self.test_node.test_witness_block(block2, True)\n \n         block3 = self.build_next_block(nVersion=(VB_TOP_BITS | (1<<15)))\n         block3.solve()\n         self.test_node.announce_block_and_wait_for_getdata(block3, use_header=True)\n-        assert(self.test_node.last_getdata.inv[0].type == blocktype)\n+        assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n         self.test_node.test_witness_block(block3, True)\n \n         # Check that we can getdata for witness blocks or regular blocks,\n@@ -1092,13 +1019,18 @@ def test_block_relay(self, segwit_activated):\n             block4 = self.build_next_block(nVersion=4)\n             block4.solve()\n             self.old_node.getdataset = set()\n+\n             # Blocks can be requested via direct-fetch (immediately upon processing the announcement)\n             # or via parallel download (with an indeterminate delay from processing the announcement)\n             # so to test that a block is NOT requested, we could guess a time period to sleep for,\n             # and then check. We can avoid the sleep() by taking advantage of transaction getdata's\n             # being processed after block getdata's, and announce a transaction as well,\n             # and then check to see if that particular getdata has been received.\n-            self.old_node.announce_block(block4, use_header=False)\n+            # Since 0.14, inv's will only be responded to with a getheaders, so send a header\n+            # to announce this block.\n+            msg = msg_headers()\n+            msg.headers = [ CBlockHeader(block4) ]\n+            self.old_node.send_message(msg)\n             self.old_node.announce_tx_and_wait_for_getdata(block4.vtx[0])\n             assert(block4.sha256 not in self.old_node.getdataset)\n \n@@ -1250,9 +1182,9 @@ def test_segwit_versions(self):\n         # Spending a higher version witness output is not allowed by policy,\n         # even with fRequireStandard=false.\n         self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=False)\n-        self.test_node.sync_with_ping(60)\n+        self.test_node.sync_with_ping()\n         with mininode_lock:\n-            assert(b\"reserved for soft-fork upgrades\" in self.test_node.last_reject.reason)\n+            assert(b\"reserved for soft-fork upgrades\" in self.test_node.last_message[\"reject\"].reason)\n \n         # Building a block with the transaction must be valid, however.\n         block = self.build_next_block()\n@@ -1380,7 +1312,7 @@ def test_signature_version_1(self):\n         for i in range(NUM_TESTS):\n             # Ping regularly to keep the connection alive\n             if (not i % 100):\n-                self.test_node.sync_with_ping(60)\n+                self.test_node.sync_with_ping()\n             # Choose random number of inputs to use.\n             num_inputs = random.randint(1, 10)\n             # Create a slight bias for producing more utxos\n@@ -1721,15 +1653,10 @@ def test_getblocktemplate_before_lockin(self):\n                 assert('default_witness_commitment' in gbt_results)\n                 witness_commitment = gbt_results['default_witness_commitment']\n \n-                # TODO: this duplicates some code from blocktools.py, would be nice\n-                # to refactor.\n                 # Check that default_witness_commitment is present.\n-                block = CBlock()\n-                witness_root = block.get_merkle_root([ser_uint256(0), ser_uint256(txid)])\n-                check_commitment = uint256_from_str(hash256(ser_uint256(witness_root)+ser_uint256(0)))\n-                from test_framework.blocktools import WITNESS_COMMITMENT_HEADER\n-                output_data = WITNESS_COMMITMENT_HEADER + ser_uint256(check_commitment)\n-                script = CScript([OP_RETURN, output_data])\n+                witness_root = CBlock.get_merkle_root([ser_uint256(0),\n+                                                       ser_uint256(txid)])\n+                script = get_witness_script(witness_root, 0)\n                 assert_equal(witness_commitment, bytes_to_hex_str(script))\n \n         # undo mocktime"
      },
      {
        "sha": "c3b29c215b7d37b46c5546c482b24c7748800820",
        "filename": "test/functional/p2p-timeouts.py",
        "status": "modified",
        "additions": 2,
        "deletions": 19,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/p2p-timeouts.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/p2p-timeouts.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-timeouts.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -28,33 +28,16 @@\n from test_framework.util import *\n \n class TestNode(NodeConnCB):\n-    def __init__(self):\n-        super().__init__()\n-        self.connected = False\n-        self.received_version = False\n-\n-    def on_open(self, conn):\n-        self.connected = True\n-\n-    def on_close(self, conn):\n-        self.connected = False\n-\n     def on_version(self, conn, message):\n         # Don't send a verack in response\n-        self.received_version = True\n+        pass\n \n class TimeoutsTest(BitcoinTestFramework):\n     def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n         self.num_nodes = 1\n \n-    def setup_network(self):\n-        self.nodes = []\n-\n-        # Start up node0 to be a version 1, pre-segwit node.\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir)\n-\n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n         self.no_verack_node = TestNode() # never send verack\n@@ -83,7 +66,7 @@ def run_test(self):\n \n         sleep(30)\n \n-        assert(self.no_verack_node.received_version)\n+        assert \"version\" in self.no_verack_node.last_message\n \n         assert(self.no_verack_node.connected)\n         assert(self.no_version_node.connected)"
      },
      {
        "sha": "41921fe14e3c789875865fae240275028cb38e05",
        "filename": "test/functional/p2p-versionbits-warning.py",
        "status": "modified",
        "additions": 1,
        "deletions": 20,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/p2p-versionbits-warning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/p2p-versionbits-warning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-versionbits-warning.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -12,7 +12,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n import re\n-import time\n from test_framework.blocktools import create_block, create_coinbase\n \n VB_PERIOD = 144 # versionbits period length for regtest\n@@ -24,28 +23,10 @@\n WARN_UNKNOWN_RULES_ACTIVE = \"unknown new rules activated (versionbit {})\".format(VB_UNKNOWN_BIT)\n VB_PATTERN = re.compile(\"^Warning.*versionbit\")\n \n-# TestNode: bare-bones \"peer\".  Used mostly as a conduit for a test to sending\n-# p2p messages to a node, generating the messages in the main testing logic.\n class TestNode(NodeConnCB):\n-    def __init__(self):\n-        super().__init__()\n-        self.connection = None\n-        self.ping_counter = 1\n-        self.last_pong = msg_pong()\n-\n-    def add_connection(self, conn):\n-        self.connection = conn\n-\n     def on_inv(self, conn, message):\n         pass\n \n-    # Wrapper for the NodeConn's send_message function\n-    def send_message(self, message):\n-        self.connection.send_message(message)\n-\n-    def on_pong(self, conn, message):\n-        self.last_pong = message\n-\n class VersionBitsWarningTest(BitcoinTestFramework):\n     def __init__(self):\n         super().__init__()\n@@ -58,7 +39,7 @@ def setup_network(self):\n         with open(self.alert_filename, 'w', encoding='utf8') as _:\n             pass\n         self.extra_args = [[\"-alertnotify=echo %s >> \\\"\" + self.alert_filename + \"\\\"\"]]\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, self.extra_args)\n+        self.setup_nodes()\n \n     # Send numblocks blocks via peer with nVersionToUse set.\n     def send_blocks_with_version(self, peer, numblocks, nVersionToUse):"
      },
      {
        "sha": "04b41e76baefeaf2dca2bd9f4808406009de708d",
        "filename": "test/functional/preciousblock.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/preciousblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/preciousblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/preciousblock.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -41,7 +41,7 @@ def __init__(self):\n         self.num_nodes = 3\n \n     def setup_network(self):\n-        self.nodes = self.setup_nodes()\n+        self.setup_nodes()\n \n     def run_test(self):\n         self.log.info(\"Ensure submitblock can in principle reorg to a competing chain\")"
      },
      {
        "sha": "9c3b3fd5d9b4eb51cd5b783269ea27fb5025574b",
        "filename": "test/functional/prioritise_transaction.py",
        "status": "modified",
        "additions": 14,
        "deletions": 8,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/prioritise_transaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/prioritise_transaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/prioritise_transaction.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -13,18 +13,13 @@ class PrioritiseTransactionTest(BitcoinTestFramework):\n     def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n-        self.num_nodes = 1\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-printpriority=1\"], [\"-printpriority=1\"]]\n \n+    def run_test(self):\n         self.txouts = gen_return_txouts()\n-\n-    def setup_network(self):\n-        self.nodes = []\n-        self.is_network_split = False\n-\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-printpriority=1\"]))\n         self.relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n \n-    def run_test(self):\n         utxo_count = 90\n         utxos = create_confirmed_utxos(self.relayfee, self.nodes[0], utxo_count)\n         base_fee = self.relayfee*100 # our transactions are smaller than 100kb\n@@ -120,5 +115,16 @@ def run_test(self):\n         assert_equal(self.nodes[0].sendrawtransaction(tx_hex), tx_id)\n         assert(tx_id in self.nodes[0].getrawmempool())\n \n+        # Test that calling prioritisetransaction is sufficient to trigger\n+        # getblocktemplate to (eventually) return a new block.\n+        mock_time = int(time.time())\n+        self.nodes[0].setmocktime(mock_time)\n+        template = self.nodes[0].getblocktemplate()\n+        self.nodes[0].prioritisetransaction(tx_id, -int(self.relayfee*COIN))\n+        self.nodes[0].setmocktime(mock_time+10)\n+        new_template = self.nodes[0].getblocktemplate()\n+\n+        assert(template != new_template)\n+\n if __name__ == '__main__':\n     PrioritiseTransactionTest().main()"
      },
      {
        "sha": "69384d9d85af71872e9eb3bf4375876161e118f0",
        "filename": "test/functional/proxy_test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/proxy_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/proxy_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/proxy_test.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -90,7 +90,7 @@ def setup_nodes(self):\n             ]\n         if self.have_ipv6:\n             args[3] = ['-listen', '-proxy=[%s]:%i' % (self.conf3.addr),'-proxyrandomize=0', '-noonion']\n-        return start_nodes(self.num_nodes, self.options.tmpdir, extra_args=args)\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args=args)\n \n     def node_test(self, node, proxies, auth, test_onion=True):\n         rv = []"
      },
      {
        "sha": "17019c658bfd9e91fac30522348cfbd56c77a927",
        "filename": "test/functional/pruning.py",
        "status": "modified",
        "additions": 20,
        "deletions": 22,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/pruning.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -32,31 +32,21 @@ def __init__(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 6\n \n-        # Cache for utxos, as the listunspent may take a long time later in the test\n-        self.utxo_cache_0 = []\n-        self.utxo_cache_1 = []\n-\n-    def setup_network(self):\n-        self.nodes = []\n-        self.is_network_split = False\n-\n-        # Create nodes 0 and 1 to mine\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\"], timewait=900))\n-        self.nodes.append(start_node(1, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\"], timewait=900))\n-\n-        # Create node 2 to test pruning\n-        self.nodes.append(start_node(2, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-prune=550\"], timewait=900))\n-        self.prunedir = self.options.tmpdir+\"/node2/regtest/blocks/\"\n-\n+        # Create nodes 0 and 1 to mine.\n+        # Create node 2 to test pruning.\n         # Create nodes 3 and 4 to test manual pruning (they will be re-started with manual pruning later)\n-        self.nodes.append(start_node(3, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\"], timewait=900))\n-        self.nodes.append(start_node(4, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\"], timewait=900))\n-\n         # Create nodes 5 to test wallet in prune mode, but do not connect\n-        self.nodes.append(start_node(5, self.options.tmpdir, [\"-prune=550\"]))\n+        self.extra_args = [[\"-maxreceivebuffer=20000\", \"-blockmaxsize=999000\", \"-checkblocks=5\"],\n+                           [\"-maxreceivebuffer=20000\", \"-blockmaxsize=999000\", \"-checkblocks=5\"],\n+                           [\"-maxreceivebuffer=20000\", \"-prune=550\"],\n+                           [\"-maxreceivebuffer=20000\", \"-blockmaxsize=999000\"],\n+                           [\"-maxreceivebuffer=20000\", \"-blockmaxsize=999000\"],\n+                           [\"-prune=550\"]]\n \n-        # Determine default relay fee\n-        self.relayfee = self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+        self.prunedir = self.options.tmpdir + \"/node2/regtest/blocks/\"\n \n         connect_nodes(self.nodes[0], 1)\n         connect_nodes(self.nodes[1], 2)\n@@ -332,6 +322,14 @@ def wallet_test(self):\n     def run_test(self):\n         self.log.info(\"Warning! This test requires 4GB of disk space and takes over 30 mins (up to 2 hours)\")\n         self.log.info(\"Mining a big blockchain of 995 blocks\")\n+\n+        # Determine default relay fee\n+        self.relayfee = self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+\n+        # Cache for utxos, as the listunspent may take a long time later in the test\n+        self.utxo_cache_0 = []\n+        self.utxo_cache_1 = []\n+\n         self.create_big_chain()\n         # Chain diagram key:\n         # *   blocks on main chain"
      },
      {
        "sha": "35debf9cab52a74375bed5d86074fa7a13453313",
        "filename": "test/functional/rawtransactions.py",
        "status": "modified",
        "additions": 1,
        "deletions": 13,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/rawtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/rawtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rawtransactions.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -24,21 +24,9 @@ def __init__(self):\n         self.num_nodes = 3\n \n     def setup_network(self, split=False):\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir)\n-\n-        #connect to a local machine for debugging\n-        #url = \"http://bitcoinrpc:DP6DvqZtqXarpeNWyN3LZTFchCCyCUuHwNF7E8pX99x1@%s:%d\" % ('127.0.0.1', 18332)\n-        #proxy = AuthServiceProxy(url)\n-        #proxy.url = url # store URL on proxy for info\n-        #self.nodes.append(proxy)\n-\n-        connect_nodes_bi(self.nodes,0,1)\n-        connect_nodes_bi(self.nodes,1,2)\n+        super().setup_network()\n         connect_nodes_bi(self.nodes,0,2)\n \n-        self.is_network_split=False\n-        self.sync_all()\n-\n     def run_test(self):\n \n         #prepare some coins for multiple *rawtransaction commands"
      },
      {
        "sha": "a1cae301c598ae7fec888f81b220fb42fade15f3",
        "filename": "test/functional/receivedby.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/receivedby.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/receivedby.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/receivedby.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -32,7 +32,7 @@ def __init__(self):\n     def setup_nodes(self):\n         #This test requires mocktime\n         enable_mocktime()\n-        return start_nodes(self.num_nodes, self.options.tmpdir)\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir)\n \n     def run_test(self):\n         '''"
      },
      {
        "sha": "8b8c5f3e710a314c8684d53b6cd6f09178246466",
        "filename": "test/functional/reindex.py",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/reindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/reindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/reindex.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -24,9 +24,6 @@ def __init__(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 1\n \n-    def setup_network(self):\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir)\n-\n     def reindex(self, justchainstate=False):\n         self.nodes[0].generate(3)\n         blockcount = self.nodes[0].getblockcount()"
      },
      {
        "sha": "e940ce535c2b1f74112604a10f8a29afed6943cb",
        "filename": "test/functional/replace-by-fee.py",
        "status": "modified",
        "additions": 6,
        "deletions": 11,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/replace-by-fee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/replace-by-fee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/replace-by-fee.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -65,17 +65,12 @@ def __init__(self):\n         super().__init__()\n         self.num_nodes = 1\n         self.setup_clean_chain = False\n-\n-    def setup_network(self):\n-        self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-maxorphantx=1000\",\n-                                                              \"-whitelist=127.0.0.1\",\n-                                                              \"-limitancestorcount=50\",\n-                                                              \"-limitancestorsize=101\",\n-                                                              \"-limitdescendantcount=200\",\n-                                                              \"-limitdescendantsize=101\"\n-                                                              ]))\n-        self.is_network_split = False\n+        self.extra_args= [[\"-maxorphantx=1000\",\n+                           \"-whitelist=127.0.0.1\",\n+                           \"-limitancestorcount=50\",\n+                           \"-limitancestorsize=101\",\n+                           \"-limitdescendantcount=200\",\n+                           \"-limitdescendantsize=101\"]]\n \n     def run_test(self):\n         make_utxo(self.nodes[0], 1*COIN)"
      },
      {
        "sha": "fbcceba0fafb626115333b921df169d3164c29ee",
        "filename": "test/functional/rest.py",
        "status": "modified",
        "additions": 2,
        "deletions": 6,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/rest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/rest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rest.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -49,12 +49,8 @@ def __init__(self):\n         self.num_nodes = 3\n \n     def setup_network(self, split=False):\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir)\n-        connect_nodes_bi(self.nodes,0,1)\n-        connect_nodes_bi(self.nodes,1,2)\n-        connect_nodes_bi(self.nodes,0,2)\n-        self.is_network_split=False\n-        self.sync_all()\n+        super().setup_network()\n+        connect_nodes_bi(self.nodes, 0, 2)\n \n     def run_test(self):\n         url = urllib.parse.urlparse(self.nodes[0].url)"
      },
      {
        "sha": "3b286000a167482da8ac4326a75710c9d6729846",
        "filename": "test/functional/rpcnamedargs.py",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/rpcnamedargs.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/rpcnamedargs.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpcnamedargs.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -8,7 +8,6 @@\n from test_framework.util import (\n     assert_equal,\n     assert_raises_jsonrpc,\n-    start_nodes,\n )\n \n \n@@ -22,11 +21,6 @@ def __init__(self):\n         self.setup_clean_chain = False\n         self.num_nodes = 1\n \n-    def setup_network(self, split=False):\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir)\n-        self.is_network_split = False\n-        self.sync_all()\n-\n     def run_test(self):\n         node = self.nodes[0]\n         h = node.help(command='getinfo')"
      },
      {
        "sha": "ac95d664665400a1b45aabd840b6d252f4f01e1a",
        "filename": "test/functional/segwit.py",
        "status": "modified",
        "additions": 4,
        "deletions": 7,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/segwit.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -80,16 +80,13 @@ def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n         self.num_nodes = 3\n+        self.extra_args = [[\"-walletprematurewitness\", \"-rpcserialversion=0\"],\n+                           [\"-blockversion=4\", \"-promiscuousmempoolflags=517\", \"-prematurewitness\", \"-walletprematurewitness\", \"-rpcserialversion=1\"],\n+                           [\"-blockversion=536870915\", \"-promiscuousmempoolflags=517\", \"-prematurewitness\", \"-walletprematurewitness\"]]\n \n     def setup_network(self):\n-        self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-walletprematurewitness\", \"-rpcserialversion=0\"]))\n-        self.nodes.append(start_node(1, self.options.tmpdir, [\"-blockversion=4\", \"-promiscuousmempoolflags=517\", \"-prematurewitness\", \"-walletprematurewitness\", \"-rpcserialversion=1\"]))\n-        self.nodes.append(start_node(2, self.options.tmpdir, [\"-blockversion=536870915\", \"-promiscuousmempoolflags=517\", \"-prematurewitness\", \"-walletprematurewitness\"]))\n-        connect_nodes(self.nodes[1], 0)\n-        connect_nodes(self.nodes[2], 1)\n+        super().setup_network()\n         connect_nodes(self.nodes[0], 2)\n-        self.is_network_split = False\n         self.sync_all()\n \n     def success_mine(self, node, txid, sign, redeem_script=\"\"):"
      },
      {
        "sha": "44c357c6dbd93074db60bf505be3f031c507c0ae",
        "filename": "test/functional/sendheaders.py",
        "status": "modified",
        "additions": 33,
        "deletions": 87,
        "changes": 120,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/sendheaders.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -81,23 +81,17 @@\n \n direct_fetch_response_time = 0.05\n \n-class BaseNode(NodeConnCB):\n+class TestNode(NodeConnCB):\n     def __init__(self):\n         super().__init__()\n-        self.last_inv = None\n-        self.last_headers = None\n-        self.last_block = None\n-        self.last_getdata = None\n         self.block_announced = False\n-        self.last_getheaders = None\n-        self.disconnected = False\n         self.last_blockhash_announced = None\n \n     def clear_last_announcement(self):\n         with mininode_lock:\n             self.block_announced = False\n-            self.last_inv = None\n-            self.last_headers = None\n+            self.last_message.pop(\"inv\", None)\n+            self.last_message.pop(\"headers\", None)\n \n     # Request data for a list of block hashes\n     def get_data(self, block_hashes):\n@@ -118,29 +112,17 @@ def send_block_inv(self, blockhash):\n         self.connection.send_message(msg)\n \n     def on_inv(self, conn, message):\n-        self.last_inv = message\n         self.block_announced = True\n         self.last_blockhash_announced = message.inv[-1].hash\n \n     def on_headers(self, conn, message):\n-        self.last_headers = message\n         if len(message.headers):\n             self.block_announced = True\n             message.headers[-1].calc_sha256()\n             self.last_blockhash_announced = message.headers[-1].sha256\n \n     def on_block(self, conn, message):\n-        self.last_block = message.block\n-        self.last_block.calc_sha256()\n-\n-    def on_getdata(self, conn, message):\n-        self.last_getdata = message\n-\n-    def on_getheaders(self, conn, message):\n-        self.last_getheaders = message\n-\n-    def on_close(self, conn):\n-        self.disconnected = True\n+        self.last_message[\"block\"].calc_sha256()\n \n     # Test whether the last announcement we received had the\n     # right header or the right inv\n@@ -155,43 +137,27 @@ def check_last_announcement(self, headers=None, inv=None):\n \n             success = True\n             compare_inv = []\n-            if self.last_inv != None:\n-                compare_inv = [x.hash for x in self.last_inv.inv]\n+            if \"inv\" in self.last_message:\n+                compare_inv = [x.hash for x in self.last_message[\"inv\"].inv]\n             if compare_inv != expect_inv:\n                 success = False\n \n             hash_headers = []\n-            if self.last_headers != None:\n+            if \"headers\" in self.last_message:\n                 # treat headers as a list of block hashes\n-                hash_headers = [ x.sha256 for x in self.last_headers.headers ]\n+                hash_headers = [ x.sha256 for x in self.last_message[\"headers\"].headers ]\n             if hash_headers != expect_headers:\n                 success = False\n \n-            self.last_inv = None\n-            self.last_headers = None\n+            self.last_message.pop(\"inv\", None)\n+            self.last_message.pop(\"headers\", None)\n         return success\n \n-    # Syncing helpers\n-    def wait_for_block(self, blockhash, timeout=60):\n-        test_function = lambda: self.last_block != None and self.last_block.sha256 == blockhash\n-        assert(wait_until(test_function, timeout=timeout))\n-        return\n-\n-    def wait_for_getheaders(self, timeout=60):\n-        test_function = lambda: self.last_getheaders != None\n-        assert(wait_until(test_function, timeout=timeout))\n-        return\n-\n     def wait_for_getdata(self, hash_list, timeout=60):\n         if hash_list == []:\n             return\n \n-        test_function = lambda: self.last_getdata != None and [x.hash for x in self.last_getdata.inv] == hash_list\n-        assert(wait_until(test_function, timeout=timeout))\n-        return\n-\n-    def wait_for_disconnect(self, timeout=60):\n-        test_function = lambda: self.disconnected\n+        test_function = lambda: \"getdata\" in self.last_message and [x.hash for x in self.last_message[\"getdata\"].inv] == hash_list\n         assert(wait_until(test_function, timeout=timeout))\n         return\n \n@@ -210,28 +176,12 @@ def send_getblocks(self, locator):\n         getblocks_message.locator.vHave = locator\n         self.send_message(getblocks_message)\n \n-# InvNode: This peer should only ever receive inv's, because it doesn't ever send a\n-# \"sendheaders\" message.\n-class InvNode(BaseNode):\n-    def __init__(self):\n-        BaseNode.__init__(self)\n-\n-# TestNode: This peer is the one we use for most of the testing.\n-class TestNode(BaseNode):\n-    def __init__(self):\n-        BaseNode.__init__(self)\n-\n class SendHeadersTest(BitcoinTestFramework):\n     def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n         self.num_nodes = 2\n \n-    def setup_network(self):\n-        self.nodes = []\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir)\n-        connect_nodes(self.nodes[0], 1)\n-\n     # mine count blocks and return the new tip\n     def mine_blocks(self, count):\n         # Clear out last block announcement from each p2p listener\n@@ -260,7 +210,7 @@ def mine_reorg(self, length):\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n-        inv_node = InvNode()\n+        inv_node = TestNode()\n         test_node = TestNode()\n \n         self.p2p_connections = [inv_node, test_node]\n@@ -293,7 +243,7 @@ def run_test(self):\n             if i == 0:\n                 # first request the block\n                 test_node.get_data([tip])\n-                test_node.wait_for_block(tip, timeout=5)\n+                test_node.wait_for_block(tip)\n             elif i == 1:\n                 # next try requesting header and block\n                 test_node.get_headers(locator=[old_tip], hashstop=tip)\n@@ -308,7 +258,7 @@ def run_test(self):\n                 new_block = create_block(tip, create_coinbase(height+1), block_time)\n                 new_block.solve()\n                 test_node.send_header_for_blocks([new_block])\n-                test_node.wait_for_getdata([new_block.sha256], timeout=5)\n+                test_node.wait_for_getdata([new_block.sha256])\n                 test_node.send_message(msg_block(new_block))\n                 test_node.sync_with_ping() # make sure this block is processed\n                 inv_node.clear_last_announcement()\n@@ -347,18 +297,18 @@ def run_test(self):\n                 if j == 0:\n                     # Announce via inv\n                     test_node.send_block_inv(tip)\n-                    test_node.wait_for_getheaders(timeout=5)\n+                    test_node.wait_for_getheaders()\n                     # Should have received a getheaders now\n                     test_node.send_header_for_blocks(blocks)\n                     # Test that duplicate inv's won't result in duplicate\n                     # getdata requests, or duplicate headers announcements\n                     [ inv_node.send_block_inv(x.sha256) for x in blocks ]\n-                    test_node.wait_for_getdata([x.sha256 for x in blocks], timeout=5)\n+                    test_node.wait_for_getdata([x.sha256 for x in blocks])\n                     inv_node.sync_with_ping()\n                 else:\n                     # Announce via headers\n                     test_node.send_header_for_blocks(blocks)\n-                    test_node.wait_for_getdata([x.sha256 for x in blocks], timeout=5)\n+                    test_node.wait_for_getdata([x.sha256 for x in blocks])\n                     # Test that duplicate headers won't result in duplicate\n                     # getdata requests (the check is further down)\n                     inv_node.send_header_for_blocks(blocks)\n@@ -368,8 +318,8 @@ def run_test(self):\n                 inv_node.sync_with_ping()\n                 # This block should not be announced to the inv node (since it also\n                 # broadcast it)\n-                assert_equal(inv_node.last_inv, None)\n-                assert_equal(inv_node.last_headers, None)\n+                assert \"inv\" not in inv_node.last_message\n+                assert \"headers\" not in inv_node.last_message\n                 tip = self.mine_blocks(1)\n                 assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n                 assert_equal(test_node.check_last_announcement(headers=[tip]), True)\n@@ -459,12 +409,12 @@ def run_test(self):\n             inv_node.send_message(msg_block(blocks[-1]))\n \n         inv_node.sync_with_ping() # Make sure blocks are processed\n-        test_node.last_getdata = None\n+        test_node.last_message.pop(\"getdata\", None)\n         test_node.send_header_for_blocks(blocks)\n         test_node.sync_with_ping()\n         # should not have received any getdata messages\n         with mininode_lock:\n-            assert_equal(test_node.last_getdata, None)\n+            assert \"getdata\" not in test_node.last_message\n \n         # This time, direct fetch should work\n         blocks = []\n@@ -498,11 +448,11 @@ def run_test(self):\n \n         # Announcing one block on fork should not trigger direct fetch\n         # (less work than tip)\n-        test_node.last_getdata = None\n+        test_node.last_message.pop(\"getdata\", None)\n         test_node.send_header_for_blocks(blocks[0:1])\n         test_node.sync_with_ping()\n         with mininode_lock:\n-            assert_equal(test_node.last_getdata, None)\n+            assert \"getdata\" not in test_node.last_message\n \n         # Announcing one more block on fork should trigger direct fetch for\n         # both blocks (same work as tip)\n@@ -517,11 +467,11 @@ def run_test(self):\n         test_node.wait_for_getdata([x.sha256 for x in blocks[2:16]], timeout=direct_fetch_response_time)\n \n         # Announcing 1 more header should not trigger any response\n-        test_node.last_getdata = None\n+        test_node.last_message.pop(\"getdata\", None)\n         test_node.send_header_for_blocks(blocks[18:19])\n         test_node.sync_with_ping()\n         with mininode_lock:\n-            assert_equal(test_node.last_getdata, None)\n+            assert \"getdata\" not in test_node.last_message\n \n         self.log.info(\"Part 4: success!\")\n \n@@ -532,7 +482,7 @@ def run_test(self):\n         # First we test that receipt of an unconnecting header doesn't prevent\n         # chain sync.\n         for i in range(10):\n-            test_node.last_getdata = None\n+            test_node.last_message.pop(\"getdata\", None)\n             blocks = []\n             # Create two more blocks.\n             for j in range(2):\n@@ -543,9 +493,9 @@ def run_test(self):\n                 height += 1\n             # Send the header of the second block -> this won't connect.\n             with mininode_lock:\n-                test_node.last_getheaders = None\n+                test_node.last_message.pop(\"getheaders\", None)\n             test_node.send_header_for_blocks([blocks[1]])\n-            test_node.wait_for_getheaders(timeout=1)\n+            test_node.wait_for_getheaders()\n             test_node.send_header_for_blocks(blocks)\n             test_node.wait_for_getdata([x.sha256 for x in blocks])\n             [ test_node.send_message(msg_block(x)) for x in blocks ]\n@@ -566,9 +516,9 @@ def run_test(self):\n         for i in range(1, MAX_UNCONNECTING_HEADERS):\n             # Send a header that doesn't connect, check that we get a getheaders.\n             with mininode_lock:\n-                test_node.last_getheaders = None\n+                test_node.last_message.pop(\"getheaders\", None)\n             test_node.send_header_for_blocks([blocks[i]])\n-            test_node.wait_for_getheaders(timeout=1)\n+            test_node.wait_for_getheaders()\n \n         # Next header will connect, should re-set our count:\n         test_node.send_header_for_blocks([blocks[0]])\n@@ -581,25 +531,21 @@ def run_test(self):\n         for i in range(5*MAX_UNCONNECTING_HEADERS - 1):\n             # Send a header that doesn't connect, check that we get a getheaders.\n             with mininode_lock:\n-                test_node.last_getheaders = None\n+                test_node.last_message.pop(\"getheaders\", None)\n             test_node.send_header_for_blocks([blocks[i%len(blocks)]])\n-            test_node.wait_for_getheaders(timeout=1)\n+            test_node.wait_for_getheaders()\n \n         # Eventually this stops working.\n-        with mininode_lock:\n-            self.last_getheaders = None\n         test_node.send_header_for_blocks([blocks[-1]])\n \n         # Should get disconnected\n         test_node.wait_for_disconnect()\n-        with mininode_lock:\n-            self.last_getheaders = True\n \n         self.log.info(\"Part 5: success!\")\n \n         # Finally, check that the inv node never received a getdata request,\n         # throughout the test\n-        assert_equal(inv_node.last_getdata, None)\n+        assert \"getdata\" not in inv_node.last_message\n \n if __name__ == '__main__':\n     SendHeadersTest().main()"
      },
      {
        "sha": "42f6a9daaf1fd7c7bc9f22c6e38592072f050798",
        "filename": "test/functional/signmessages.py",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/signmessages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/signmessages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/signmessages.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -5,7 +5,6 @@\n \"\"\"Test RPC commands for signing and verifying messages.\"\"\"\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import *\n \n class SignMessagesTest(BitcoinTestFramework):\n \n@@ -14,10 +13,6 @@ def __init__(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 1\n \n-    def setup_network(self, split=False):\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir)\n-        self.is_network_split = False\n-\n     def run_test(self):\n         message = 'This is just a test message'\n "
      },
      {
        "sha": "437905e764fbf236f6472d2d2d65730880ac1704",
        "filename": "test/functional/signrawtransactions.py",
        "status": "modified",
        "additions": 27,
        "deletions": 4,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/signrawtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/signrawtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/signrawtransactions.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -14,10 +14,6 @@ def __init__(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 1\n \n-    def setup_network(self, split=False):\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir)\n-        self.is_network_split = False\n-\n     def successful_signing_test(self):\n         \"\"\"Create and sign a valid raw transaction with one input.\n \n@@ -118,6 +114,7 @@ def script_verification_error_test(self):\n         # 5) Script verification errors have certain properties\n         assert 'txid' in rawTxSigned['errors'][0]\n         assert 'vout' in rawTxSigned['errors'][0]\n+        assert 'witness' in rawTxSigned['errors'][0]\n         assert 'scriptSig' in rawTxSigned['errors'][0]\n         assert 'sequence' in rawTxSigned['errors'][0]\n         assert 'error' in rawTxSigned['errors'][0]\n@@ -127,6 +124,32 @@ def script_verification_error_test(self):\n         assert_equal(rawTxSigned['errors'][0]['vout'], inputs[1]['vout'])\n         assert_equal(rawTxSigned['errors'][1]['txid'], inputs[2]['txid'])\n         assert_equal(rawTxSigned['errors'][1]['vout'], inputs[2]['vout'])\n+        assert not rawTxSigned['errors'][0]['witness']\n+\n+        # Now test signing failure for transaction with input witnesses\n+        p2wpkh_raw_tx = \"01000000000102fff7f7881a8099afa6940d42d1e7f6362bec38171ea3edf433541db4e4ad969f00000000494830450221008b9d1dc26ba6a9cb62127b02742fa9d754cd3bebf337f7a55d114c8e5cdd30be022040529b194ba3f9281a99f2b1c0a19c0489bc22ede944ccf4ecbab4cc618ef3ed01eeffffffef51e1b804cc89d182d279655c3aa89e815b1b309fe287d9b2b55d57b90ec68a0100000000ffffffff02202cb206000000001976a9148280b37df378db99f66f85c95a783a76ac7a6d5988ac9093510d000000001976a9143bde42dbee7e4dbe6a21b2d50ce2f0167faa815988ac000247304402203609e17b84f6a7d30c80bfa610b5b4542f32a8a0d5447a12fb1366d7f01cc44a0220573a954c4518331561406f90300e8f3358f51928d43c212a8caed02de67eebee0121025476c2e83188368da1ff3e292e7acafcdb3566bb0ad253f62fc70f07aeee635711000000\"\n+\n+        rawTxSigned = self.nodes[0].signrawtransaction(p2wpkh_raw_tx)\n+\n+        # 7) The transaction has no complete set of signatures\n+        assert 'complete' in rawTxSigned\n+        assert_equal(rawTxSigned['complete'], False)\n+\n+        # 8) Two script verification errors occurred\n+        assert 'errors' in rawTxSigned\n+        assert_equal(len(rawTxSigned['errors']), 2)\n+\n+        # 9) Script verification errors have certain properties\n+        assert 'txid' in rawTxSigned['errors'][0]\n+        assert 'vout' in rawTxSigned['errors'][0]\n+        assert 'witness' in rawTxSigned['errors'][0]\n+        assert 'scriptSig' in rawTxSigned['errors'][0]\n+        assert 'sequence' in rawTxSigned['errors'][0]\n+        assert 'error' in rawTxSigned['errors'][0]\n+\n+        # Non-empty witness checked here\n+        assert_equal(rawTxSigned['errors'][1]['witness'], [\"304402203609e17b84f6a7d30c80bfa610b5b4542f32a8a0d5447a12fb1366d7f01cc44a0220573a954c4518331561406f90300e8f3358f51928d43c212a8caed02de67eebee01\", \"025476c2e83188368da1ff3e292e7acafcdb3566bb0ad253f62fc70f07aeee6357\"])\n+        assert not rawTxSigned['errors'][0]['witness']\n \n     def run_test(self):\n         self.successful_signing_test()"
      },
      {
        "sha": "4124f8025e309430aabf193a1a130ae357bf5d07",
        "filename": "test/functional/smartfees.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/smartfees.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/smartfees.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/smartfees.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -116,8 +116,8 @@ def check_estimates(node, fees_seen, max_invalid, print_estimates = True):\n     for i,e in enumerate(all_estimates): # estimate is for i+1\n         if e >= 0:\n             valid_estimate = True\n-            # estimatesmartfee should return the same result\n-            assert_equal(node.estimatesmartfee(i+1)[\"feerate\"], e)\n+            if i >= 13:  # for n>=14 estimatesmartfee(n/2) should be at least as high as estimatefee(n)\n+                assert(node.estimatesmartfee((i+1)//2)[\"feerate\"] > float(e) - delta)\n \n         else:\n             invalid_estimates += 1\n@@ -203,7 +203,6 @@ def setup_network(self):\n         connect_nodes(self.nodes[0], 2)\n         connect_nodes(self.nodes[2], 1)\n \n-        self.is_network_split = False\n         self.sync_all()\n \n     def transact_and_mine(self, numblocks, mining_node):"
      },
      {
        "sha": "dfcc524313a6d89fcfb58c69ce5e11bf9ad2fe5d",
        "filename": "test/functional/test_framework/authproxy.py",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/test_framework/authproxy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/test_framework/authproxy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/authproxy.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -42,6 +42,7 @@\n import json\n import logging\n import socket\n+import time\n try:\n     import urllib.parse as urlparse\n except ImportError:\n@@ -163,6 +164,7 @@ def _batch(self, rpc_call_list):\n         return self._request('POST', self.__url.path, postdata.encode('utf-8'))\n \n     def _get_response(self):\n+        req_start_time = time.time()\n         try:\n             http_response = self.__conn.getresponse()\n         except socket.timeout as e:\n@@ -183,8 +185,9 @@ def _get_response(self):\n \n         responsedata = http_response.read().decode('utf8')\n         response = json.loads(responsedata, parse_float=decimal.Decimal)\n+        elapsed = time.time() - req_start_time\n         if \"error\" in response and response[\"error\"] is None:\n-            log.debug(\"<-%s- %s\"%(response[\"id\"], json.dumps(response[\"result\"], default=EncodeDecimal, ensure_ascii=self.ensure_ascii)))\n+            log.debug(\"<-%s- [%.6f] %s\"%(response[\"id\"], elapsed, json.dumps(response[\"result\"], default=EncodeDecimal, ensure_ascii=self.ensure_ascii)))\n         else:\n-            log.debug(\"<-- \"+responsedata)\n+            log.debug(\"<-- [%.6f] %s\"%(elapsed,responsedata))\n         return response"
      },
      {
        "sha": "5dcf516dc6e983f0f7992fc56fd1c0d5eadc57fd",
        "filename": "test/functional/test_framework/blocktools.py",
        "status": "modified",
        "additions": 8,
        "deletions": 3,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/test_framework/blocktools.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/test_framework/blocktools.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/blocktools.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -25,21 +25,26 @@ def create_block(hashprev, coinbase, nTime=None):\n # From BIP141\n WITNESS_COMMITMENT_HEADER = b\"\\xaa\\x21\\xa9\\xed\"\n \n+\n+def get_witness_script(witness_root, witness_nonce):\n+    witness_commitment = uint256_from_str(hash256(ser_uint256(witness_root)+ser_uint256(witness_nonce)))\n+    output_data = WITNESS_COMMITMENT_HEADER + ser_uint256(witness_commitment)\n+    return CScript([OP_RETURN, output_data])\n+\n+\n # According to BIP141, blocks with witness rules active must commit to the\n # hash of all in-block transactions including witness.\n def add_witness_commitment(block, nonce=0):\n     # First calculate the merkle root of the block's\n     # transactions, with witnesses.\n     witness_nonce = nonce\n     witness_root = block.calc_witness_merkle_root()\n-    witness_commitment = uint256_from_str(hash256(ser_uint256(witness_root)+ser_uint256(witness_nonce)))\n     # witness_nonce should go to coinbase witness.\n     block.vtx[0].wit.vtxinwit = [CTxInWitness()]\n     block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ser_uint256(witness_nonce)]\n \n     # witness commitment is the last OP_RETURN output in coinbase\n-    output_data = WITNESS_COMMITMENT_HEADER + ser_uint256(witness_commitment)\n-    block.vtx[0].vout.append(CTxOut(0, CScript([OP_RETURN, output_data])))\n+    block.vtx[0].vout.append(CTxOut(0, get_witness_script(witness_root, witness_nonce)))\n     block.vtx[0].rehash()\n     block.hashMerkleRoot = block.calc_merkle_root()\n     block.rehash()"
      },
      {
        "sha": "9f062865a3e23c08128dd74fd6193af9cd3cb025",
        "filename": "test/functional/test_framework/comptool.py",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/test_framework/comptool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/test_framework/comptool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/comptool.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -192,9 +192,7 @@ def disconnected():\n         return wait_until(disconnected, timeout=10)\n \n     def wait_for_verack(self):\n-        def veracked():\n-            return all(node.verack_received for node in self.test_nodes)\n-        return wait_until(veracked, timeout=10)\n+        return all(node.wait_for_verack() for node in self.test_nodes)\n \n     def wait_for_pings(self, counter):\n         def received_pongs():"
      },
      {
        "sha": "fb3ed1473a941404d0e7e0dc5a4905e97177997c",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 101,
        "deletions": 49,
        "changes": 150,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -20,21 +20,22 @@\n ser_*, deser_*: functions that handle serialization/deserialization\n \"\"\"\n \n-import struct\n-import socket\n import asyncore\n-import time\n-import sys\n-import random\n-from .util import hex_str_to_bytes, bytes_to_hex_str\n-from io import BytesIO\n from codecs import encode\n+from collections import defaultdict\n+import copy\n import hashlib\n-from threading import RLock\n-from threading import Thread\n+from io import BytesIO\n import logging\n-import copy\n+import random\n+import socket\n+import struct\n+import sys\n+import time\n+from threading import RLock, Thread\n+\n from test_framework.siphash import siphash256\n+from test_framework.util import hex_str_to_bytes, bytes_to_hex_str\n \n BIP0031_VERSION = 60000\n MY_VERSION = 70014  # past bip-31 for ping/pong\n@@ -610,7 +611,8 @@ def serialize(self, with_witness=False):\n         return r\n \n     # Calculate the merkle root given a vector of transaction hashes\n-    def get_merkle_root(self, hashes):\n+    @classmethod\n+    def get_merkle_root(cls, hashes):\n         while len(hashes) > 1:\n             newhashes = []\n             for i in range(0, len(hashes), 2):\n@@ -1356,6 +1358,8 @@ def __repr__(self):\n \n # Helper function\n def wait_until(predicate, *, attempts=float('inf'), timeout=float('inf')):\n+    if attempts == float('inf') and timeout == float('inf'):\n+        timeout = 60\n     attempt = 0\n     elapsed = 0\n \n@@ -1465,30 +1469,57 @@ def serialize(self):\n         r += self.block_transactions.serialize(with_witness=True)\n         return r\n \n-# This is what a callback should look like for NodeConn\n-# Reimplement the on_* functions to provide handling for events\n class NodeConnCB(object):\n+    \"\"\"Callback and helper functions for P2P connection to a bitcoind node.\n+\n+    Individual testcases should subclass this and override the on_* methods\n+    if they want to alter message handling behaviour.\n+    \"\"\"\n+\n     def __init__(self):\n-        self.verack_received = False\n+        # Track whether we have a P2P connection open to the node\n+        self.connected = False\n+        self.connection = None\n+\n+        # Track number of messages of each type received and the most recent\n+        # message of each type\n+        self.message_count = defaultdict(int)\n+        self.last_message = {}\n+\n+        # A count of the number of ping messages we've sent to the node\n+        self.ping_counter = 1\n+\n         # deliver_sleep_time is helpful for debugging race conditions in p2p\n         # tests; it causes message delivery to sleep for the specified time\n         # before acquiring the global lock and delivering the next message.\n         self.deliver_sleep_time = None\n+\n         # Remember the services our peer has advertised\n         self.peer_services = None\n-        self.connection = None\n-        self.ping_counter = 1\n-        self.last_pong = msg_pong()\n+\n+    # Message receiving methods\n \n     def deliver(self, conn, message):\n+        \"\"\"Receive message and dispatch message to appropriate callback.\n+\n+        We keep a count of how many of each message type has been received\n+        and the most recent message of each type.\n+\n+        Optionally waits for deliver_sleep_time before dispatching message.\n+        \"\"\"\n+\n         deliver_sleep = self.get_deliver_sleep_time()\n         if deliver_sleep is not None:\n             time.sleep(deliver_sleep)\n         with mininode_lock:\n             try:\n-                getattr(self, 'on_' + message.command.decode('ascii'))(conn, message)\n+                command = message.command.decode('ascii')\n+                self.message_count[command] += 1\n+                self.last_message[command] = message\n+                getattr(self, 'on_' + command)(conn, message)\n             except:\n-                logger.exception(\"ERROR delivering %s\" % repr(message))\n+                print(\"ERROR delivering %s (%s)\" % (repr(message),\n+                                                    sys.exc_info()[0]))\n \n     def set_deliver_sleep_time(self, value):\n         with mininode_lock:\n@@ -1498,14 +1529,20 @@ def get_deliver_sleep_time(self):\n         with mininode_lock:\n             return self.deliver_sleep_time\n \n-    # Callbacks which can be overridden by subclasses\n-    #################################################\n+    # Callback methods. Can be overridden by subclasses in individual test\n+    # cases to provide custom message handling behaviour.\n+\n+    def on_open(self, conn):\n+        self.connected = True\n+\n+    def on_close(self, conn):\n+        self.connected = False\n+        self.connection = None\n \n     def on_addr(self, conn, message): pass\n     def on_alert(self, conn, message): pass\n     def on_block(self, conn, message): pass\n     def on_blocktxn(self, conn, message): pass\n-    def on_close(self, conn): pass\n     def on_cmpctblock(self, conn, message): pass\n     def on_feefilter(self, conn, message): pass\n     def on_getaddr(self, conn, message): pass\n@@ -1515,7 +1552,7 @@ def on_getdata(self, conn, message): pass\n     def on_getheaders(self, conn, message): pass\n     def on_headers(self, conn, message): pass\n     def on_mempool(self, conn): pass\n-    def on_open(self, conn): pass\n+    def on_pong(self, conn, message): pass\n     def on_reject(self, conn, message): pass\n     def on_sendcmpct(self, conn, message): pass\n     def on_sendheaders(self, conn, message): pass\n@@ -1533,9 +1570,6 @@ def on_ping(self, conn, message):\n         if conn.ver_send > BIP0031_VERSION:\n             conn.send_message(msg_pong(message.nonce))\n \n-    def on_pong(self, conn, message):\n-        self.last_pong = message\n-\n     def on_verack(self, conn, message):\n         conn.ver_recv = conn.ver_send\n         self.verack_received = True\n@@ -1548,43 +1582,61 @@ def on_version(self, conn, message):\n             conn.ver_recv = conn.ver_send\n         conn.nServices = message.nServices\n \n-    # Helper functions\n-    ##################\n+    # Connection helper methods\n \n     def add_connection(self, conn):\n         self.connection = conn\n \n-    # Wrapper for the NodeConn's send_message function\n+    def wait_for_disconnect(self, timeout=60):\n+        test_function = lambda: not self.connected\n+        assert wait_until(test_function, timeout=timeout)\n+\n+    # Message receiving helper methods\n+\n+    def wait_for_block(self, blockhash, timeout=60):\n+        test_function = lambda: self.last_message.get(\"block\") and self.last_message[\"block\"].block.rehash() == blockhash\n+        assert wait_until(test_function, timeout=timeout)\n+\n+    def wait_for_getdata(self, timeout=60):\n+        test_function = lambda: self.last_message.get(\"getdata\")\n+        assert wait_until(test_function, timeout=timeout)\n+\n+    def wait_for_getheaders(self, timeout=60):\n+        test_function = lambda: self.last_message.get(\"getheaders\")\n+        assert wait_until(test_function, timeout=timeout)\n+\n+    def wait_for_inv(self, expected_inv, timeout=60):\n+        \"\"\"Waits for an INV message and checks that the first inv object in the message was as expected.\"\"\"\n+        if len(expected_inv) > 1:\n+            raise NotImplementedError(\"wait_for_inv() will only verify the first inv object\")\n+        test_function = lambda: self.last_message.get(\"inv\") and \\\n+                                self.last_message[\"inv\"].inv[0].type == expected_inv[0].type and \\\n+                                self.last_message[\"inv\"].inv[0].hash == expected_inv[0].hash\n+        assert wait_until(test_function, timeout=timeout)\n+\n+    def wait_for_verack(self, timeout=60):\n+        test_function = lambda: self.message_count[\"verack\"]\n+        assert wait_until(test_function, timeout=timeout)\n+\n+    # Message sending helper functions\n+\n     def send_message(self, message):\n-        self.connection.send_message(message)\n+        if self.connection:\n+            self.connection.send_message(message)\n+        else:\n+            logger.error(\"Cannot send message. No connection to node!\")\n \n     def send_and_ping(self, message):\n         self.send_message(message)\n         self.sync_with_ping()\n \n     # Sync up with the node\n     def sync_with_ping(self, timeout=60):\n-        def received_pong():\n-            return (self.last_pong.nonce == self.ping_counter)\n         self.send_message(msg_ping(nonce=self.ping_counter))\n-        success = wait_until(received_pong, timeout=timeout)\n-        if not success:\n-            logger.error(\"sync_with_ping failed!\")\n-            raise AssertionError(\"sync_with_ping failed!\")\n+        test_function = lambda: self.last_message.get(\"pong\") and self.last_message[\"pong\"].nonce == self.ping_counter\n+        assert wait_until(test_function, timeout=timeout)\n         self.ping_counter += 1\n-\n-        return success\n-\n-    # Spin until verack message is received from the node.\n-    # Tests may want to use this as a signal that the test can begin.\n-    # This can be called from the testing thread, so it needs to acquire the\n-    # global lock.\n-    def wait_for_verack(self):\n-        while True:\n-            with mininode_lock:\n-                if self.verack_received:\n-                    return\n-            time.sleep(0.05)\n+        return True\n \n # The actual NodeConn class\n # This class provides an interface for a p2p connection to a specified node"
      },
      {
        "sha": "4b5b311385a3b9b196d505bd26c2ac6cad8709ca",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 182,
        "deletions": 67,
        "changes": 249,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -8,27 +8,55 @@\n import logging\n import optparse\n import os\n-import sys\n import shutil\n+import subprocess\n+import sys\n import tempfile\n import time\n \n from .util import (\n-    initialize_chain,\n-    start_nodes,\n+    PortSeed,\n+    MAX_NODES,\n+    bitcoind_processes,\n+    check_json_precision,\n     connect_nodes_bi,\n+    disable_mocktime,\n+    disconnect_nodes,\n+    enable_coverage,\n+    enable_mocktime,\n+    get_mocktime,\n+    get_rpc_proxy,\n+    initialize_datadir,\n+    log_filename,\n+    p2p_port,\n+    rpc_url,\n+    set_node_times,\n+    start_node,\n+    start_nodes,\n+    stop_node,\n+    stop_nodes,\n     sync_blocks,\n     sync_mempools,\n-    stop_nodes,\n-    stop_node,\n-    enable_coverage,\n-    check_json_precision,\n-    initialize_chain_clean,\n-    PortSeed,\n+    wait_for_bitcoind_start,\n )\n from .authproxy import JSONRPCException\n \n class BitcoinTestFramework(object):\n+    \"\"\"Base class for a bitcoin test script.\n+\n+    Individual bitcoin test scripts should subclass this class and override the following methods:\n+\n+    - __init__()\n+    - add_options()\n+    - setup_chain()\n+    - setup_network()\n+    - run_test()\n+\n+    The main() method should not be overridden.\n+\n+    This class also contains various public and private helper methods.\"\"\"\n+\n+    # Methods to override in subclass test scripts.\n \n     TEST_EXIT_PASSED = 0\n     TEST_EXIT_FAILED = 1\n@@ -39,69 +67,36 @@ def __init__(self):\n         self.setup_clean_chain = False\n         self.nodes = None\n \n-    def run_test(self):\n-        raise NotImplementedError\n-\n     def add_options(self, parser):\n         pass\n \n     def setup_chain(self):\n         self.log.info(\"Initializing test directory \"+self.options.tmpdir)\n         if self.setup_clean_chain:\n-            initialize_chain_clean(self.options.tmpdir, self.num_nodes)\n+            self._initialize_chain_clean(self.options.tmpdir, self.num_nodes)\n         else:\n-            initialize_chain(self.options.tmpdir, self.num_nodes, self.options.cachedir)\n-\n-    def stop_node(self, num_node):\n-        stop_node(self.nodes[num_node], num_node)\n-\n-    def setup_nodes(self):\n-        return start_nodes(self.num_nodes, self.options.tmpdir)\n+            self._initialize_chain(self.options.tmpdir, self.num_nodes, self.options.cachedir)\n \n-    def setup_network(self, split = False):\n-        self.nodes = self.setup_nodes()\n+    def setup_network(self):\n+        self.setup_nodes()\n \n         # Connect the nodes as a \"chain\".  This allows us\n         # to split the network between nodes 1 and 2 to get\n         # two halves that can work on competing chains.\n-\n-        # If we joined network halves, connect the nodes from the joint\n-        # on outward.  This ensures that chains are properly reorganised.\n-        if not split:\n-            connect_nodes_bi(self.nodes, 1, 2)\n-            sync_blocks(self.nodes[1:3])\n-            sync_mempools(self.nodes[1:3])\n-\n-        connect_nodes_bi(self.nodes, 0, 1)\n-        connect_nodes_bi(self.nodes, 2, 3)\n-        self.is_network_split = split\n+        for i in range(self.num_nodes - 1):\n+            connect_nodes_bi(self.nodes, i, i + 1)\n         self.sync_all()\n \n-    def split_network(self):\n-        \"\"\"\n-        Split the network of four nodes into nodes 0/1 and 2/3.\n-        \"\"\"\n-        assert not self.is_network_split\n-        stop_nodes(self.nodes)\n-        self.setup_network(True)\n-\n-    def sync_all(self):\n-        if self.is_network_split:\n-            sync_blocks(self.nodes[:2])\n-            sync_blocks(self.nodes[2:])\n-            sync_mempools(self.nodes[:2])\n-            sync_mempools(self.nodes[2:])\n-        else:\n-            sync_blocks(self.nodes)\n-            sync_mempools(self.nodes)\n+    def setup_nodes(self):\n+        extra_args = None\n+        if hasattr(self, \"extra_args\"):\n+            extra_args = self.extra_args\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n \n-    def join_network(self):\n-        \"\"\"\n-        Join the (previously split) network halves together.\n-        \"\"\"\n-        assert self.is_network_split\n-        stop_nodes(self.nodes)\n-        self.setup_network(False)\n+    def run_test(self):\n+        raise NotImplementedError\n+\n+    # Main function. This should not be overridden by the subclass test scripts.\n \n     def main(self):\n \n@@ -114,8 +109,7 @@ def main(self):\n                           help=\"Source directory containing bitcoind/bitcoin-cli (default: %default)\")\n         parser.add_option(\"--cachedir\", dest=\"cachedir\", default=os.path.normpath(os.path.dirname(os.path.realpath(__file__))+\"/../../cache\"),\n                           help=\"Directory for caching pregenerated datadirs\")\n-        parser.add_option(\"--tmpdir\", dest=\"tmpdir\", default=tempfile.mkdtemp(prefix=\"test\"),\n-                          help=\"Root directory for datadirs\")\n+        parser.add_option(\"--tmpdir\", dest=\"tmpdir\", help=\"Root directory for datadirs\")\n         parser.add_option(\"-l\", \"--loglevel\", dest=\"loglevel\", default=\"INFO\",\n                           help=\"log events at this level and higher to the console. Can be set to DEBUG, INFO, WARNING, ERROR or CRITICAL. Passing --loglevel DEBUG will output all logs to console. Note that logs at all levels are always written to the test_framework.log file in the temporary test directory.\")\n         parser.add_option(\"--tracerpc\", dest=\"trace_rpc\", default=False, action=\"store_true\",\n@@ -124,12 +118,11 @@ def main(self):\n                           help=\"The seed to use for assigning port numbers (default: current process id)\")\n         parser.add_option(\"--coveragedir\", dest=\"coveragedir\",\n                           help=\"Write tested RPC commands into this directory\")\n+        parser.add_option(\"--configfile\", dest=\"configfile\",\n+                          help=\"Location of the test framework config file\")\n         self.add_options(parser)\n         (self.options, self.args) = parser.parse_args()\n \n-        # backup dir variable for removal at cleanup\n-        self.options.root, self.options.tmpdir = self.options.tmpdir, self.options.tmpdir + '/' + str(self.options.port_seed)\n-\n         if self.options.coveragedir:\n             enable_coverage(self.options.coveragedir)\n \n@@ -140,7 +133,10 @@ def main(self):\n         check_json_precision()\n \n         # Set up temp directory and start logging\n-        os.makedirs(self.options.tmpdir, exist_ok=False)\n+        if self.options.tmpdir:\n+            os.makedirs(self.options.tmpdir, exist_ok=False)\n+        else:\n+            self.options.tmpdir = tempfile.mkdtemp(prefix=\"test\")\n         self._start_logging()\n \n         success = False\n@@ -163,15 +159,13 @@ def main(self):\n \n         if not self.options.noshutdown:\n             self.log.info(\"Stopping nodes\")\n-            stop_nodes(self.nodes)\n+            self.stop_nodes()\n         else:\n             self.log.info(\"Note: bitcoinds were not stopped and may still be running\")\n \n         if not self.options.nocleanup and not self.options.noshutdown and success:\n             self.log.info(\"Cleaning up\")\n             shutil.rmtree(self.options.tmpdir)\n-            if not os.listdir(self.options.root):\n-                os.rmdir(self.options.root)\n         else:\n             self.log.warning(\"Not cleaning up dir %s\" % self.options.tmpdir)\n             if os.getenv(\"PYTHON_DEBUG\", \"\"):\n@@ -197,6 +191,45 @@ def main(self):\n             logging.shutdown()\n             sys.exit(self.TEST_EXIT_FAILED)\n \n+    # Public helper methods. These can be accessed by the subclass test scripts.\n+\n+    def start_node(self, i, dirname, extra_args=None, rpchost=None, timewait=None, binary=None, stderr=None):\n+        return start_node(i, dirname, extra_args, rpchost, timewait, binary, stderr)\n+\n+    def start_nodes(self, num_nodes, dirname, extra_args=None, rpchost=None, timewait=None, binary=None):\n+        return start_nodes(num_nodes, dirname, extra_args, rpchost, timewait, binary)\n+\n+    def stop_node(self, num_node):\n+        stop_node(self.nodes[num_node], num_node)\n+\n+    def stop_nodes(self):\n+        stop_nodes(self.nodes)\n+\n+    def split_network(self):\n+        \"\"\"\n+        Split the network of four nodes into nodes 0/1 and 2/3.\n+        \"\"\"\n+        disconnect_nodes(self.nodes[1], 2)\n+        disconnect_nodes(self.nodes[2], 1)\n+        self.sync_all([self.nodes[:2], self.nodes[2:]])\n+\n+    def join_network(self):\n+        \"\"\"\n+        Join the (previously split) network halves together.\n+        \"\"\"\n+        connect_nodes_bi(self.nodes, 1, 2)\n+        self.sync_all()\n+\n+    def sync_all(self, node_groups=None):\n+        if not node_groups:\n+            node_groups = [self.nodes]\n+\n+        for group in node_groups:\n+            sync_blocks(group)\n+            sync_mempools(group)\n+\n+    # Private helper methods. These should not be accessed by the subclass test scripts.\n+\n     def _start_logging(self):\n         # Add logger and logging handlers\n         self.log = logging.getLogger('TestFramework')\n@@ -225,6 +258,88 @@ def _start_logging(self):\n             rpc_handler.setLevel(logging.DEBUG)\n             rpc_logger.addHandler(rpc_handler)\n \n+    def _initialize_chain(self, test_dir, num_nodes, cachedir):\n+        \"\"\"Initialize a pre-mined blockchain for use by the test.\n+\n+        Create a cache of a 200-block-long chain (with wallet) for MAX_NODES\n+        Afterward, create num_nodes copies from the cache.\"\"\"\n+\n+        assert num_nodes <= MAX_NODES\n+        create_cache = False\n+        for i in range(MAX_NODES):\n+            if not os.path.isdir(os.path.join(cachedir, 'node' + str(i))):\n+                create_cache = True\n+                break\n+\n+        if create_cache:\n+            self.log.debug(\"Creating data directories from cached datadir\")\n+\n+            # find and delete old cache directories if any exist\n+            for i in range(MAX_NODES):\n+                if os.path.isdir(os.path.join(cachedir, \"node\" + str(i))):\n+                    shutil.rmtree(os.path.join(cachedir, \"node\" + str(i)))\n+\n+            # Create cache directories, run bitcoinds:\n+            for i in range(MAX_NODES):\n+                datadir = initialize_datadir(cachedir, i)\n+                args = [os.getenv(\"BITCOIND\", \"bitcoind\"), \"-server\", \"-keypool=1\", \"-datadir=\" + datadir, \"-discover=0\"]\n+                if i > 0:\n+                    args.append(\"-connect=127.0.0.1:\" + str(p2p_port(0)))\n+                bitcoind_processes[i] = subprocess.Popen(args)\n+                self.log.debug(\"initialize_chain: bitcoind started, waiting for RPC to come up\")\n+                wait_for_bitcoind_start(bitcoind_processes[i], rpc_url(i), i)\n+                self.log.debug(\"initialize_chain: RPC successfully started\")\n+\n+            self.nodes = []\n+            for i in range(MAX_NODES):\n+                try:\n+                    self.nodes.append(get_rpc_proxy(rpc_url(i), i))\n+                except:\n+                    self.log.exception(\"Error connecting to node %d\" % i)\n+                    sys.exit(1)\n+\n+            # Create a 200-block-long chain; each of the 4 first nodes\n+            # gets 25 mature blocks and 25 immature.\n+            # Note: To preserve compatibility with older versions of\n+            # initialize_chain, only 4 nodes will generate coins.\n+            #\n+            # blocks are created with timestamps 10 minutes apart\n+            # starting from 2010 minutes in the past\n+            enable_mocktime()\n+            block_time = get_mocktime() - (201 * 10 * 60)\n+            for i in range(2):\n+                for peer in range(4):\n+                    for j in range(25):\n+                        set_node_times(self.nodes, block_time)\n+                        self.nodes[peer].generate(1)\n+                        block_time += 10 * 60\n+                    # Must sync before next peer starts generating blocks\n+                    sync_blocks(self.nodes)\n+\n+            # Shut them down, and clean up cache directories:\n+            self.stop_nodes()\n+            self.nodes = []\n+            disable_mocktime()\n+            for i in range(MAX_NODES):\n+                os.remove(log_filename(cachedir, i, \"debug.log\"))\n+                os.remove(log_filename(cachedir, i, \"db.log\"))\n+                os.remove(log_filename(cachedir, i, \"peers.dat\"))\n+                os.remove(log_filename(cachedir, i, \"fee_estimates.dat\"))\n+\n+        for i in range(num_nodes):\n+            from_dir = os.path.join(cachedir, \"node\" + str(i))\n+            to_dir = os.path.join(test_dir, \"node\" + str(i))\n+            shutil.copytree(from_dir, to_dir)\n+            initialize_datadir(test_dir, i)  # Overwrite port/rpcport in bitcoin.conf\n+\n+    def _initialize_chain_clean(self, test_dir, num_nodes):\n+        \"\"\"Initialize empty blockchain for use by the test.\n+\n+        Create an empty blockchain and num_nodes wallets.\n+        Useful if a test case wants complete control over initialization.\"\"\"\n+        for i in range(num_nodes):\n+            initialize_datadir(test_dir, i)\n+\n # Test framework for doing p2p comparison testing, which sets up some bitcoind\n # binaries:\n # 1 binary: test binary\n@@ -247,7 +362,7 @@ def add_options(self, parser):\n                           help=\"bitcoind binary to use for reference nodes (if any)\")\n \n     def setup_network(self):\n-        self.nodes = start_nodes(\n+        self.nodes = self.start_nodes(\n             self.num_nodes, self.options.tmpdir,\n             extra_args=[['-whitelist=127.0.0.1']] * self.num_nodes,\n             binary=[self.options.testbinary] +"
      },
      {
        "sha": "2b56fe8d62996562167df9dddee4329d8281a46a",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 14,
        "deletions": 82,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -226,87 +226,6 @@ def wait_for_bitcoind_start(process, url, i):\n                 raise # unknown JSON RPC exception\n         time.sleep(0.25)\n \n-def initialize_chain(test_dir, num_nodes, cachedir):\n-    \"\"\"\n-    Create a cache of a 200-block-long chain (with wallet) for MAX_NODES\n-    Afterward, create num_nodes copies from the cache\n-    \"\"\"\n-\n-    assert num_nodes <= MAX_NODES\n-    create_cache = False\n-    for i in range(MAX_NODES):\n-        if not os.path.isdir(os.path.join(cachedir, 'node'+str(i))):\n-            create_cache = True\n-            break\n-\n-    if create_cache:\n-        logger.debug(\"Creating data directories from cached datadir\")\n-\n-        #find and delete old cache directories if any exist\n-        for i in range(MAX_NODES):\n-            if os.path.isdir(os.path.join(cachedir,\"node\"+str(i))):\n-                shutil.rmtree(os.path.join(cachedir,\"node\"+str(i)))\n-\n-        # Create cache directories, run bitcoinds:\n-        for i in range(MAX_NODES):\n-            datadir=initialize_datadir(cachedir, i)\n-            args = [ os.getenv(\"BITCOIND\", \"bitcoind\"), \"-server\", \"-keypool=1\", \"-datadir=\"+datadir, \"-discover=0\" ]\n-            if i > 0:\n-                args.append(\"-connect=127.0.0.1:\"+str(p2p_port(0)))\n-            bitcoind_processes[i] = subprocess.Popen(args)\n-            logger.debug(\"initialize_chain: bitcoind started, waiting for RPC to come up\")\n-            wait_for_bitcoind_start(bitcoind_processes[i], rpc_url(i), i)\n-            logger.debug(\"initialize_chain: RPC successfully started\")\n-\n-        rpcs = []\n-        for i in range(MAX_NODES):\n-            try:\n-                rpcs.append(get_rpc_proxy(rpc_url(i), i))\n-            except:\n-                sys.stderr.write(\"Error connecting to \"+url+\"\\n\")\n-                sys.exit(1)\n-\n-        # Create a 200-block-long chain; each of the 4 first nodes\n-        # gets 25 mature blocks and 25 immature.\n-        # Note: To preserve compatibility with older versions of\n-        # initialize_chain, only 4 nodes will generate coins.\n-        #\n-        # blocks are created with timestamps 10 minutes apart\n-        # starting from 2010 minutes in the past\n-        enable_mocktime()\n-        block_time = get_mocktime() - (201 * 10 * 60)\n-        for i in range(2):\n-            for peer in range(4):\n-                for j in range(25):\n-                    set_node_times(rpcs, block_time)\n-                    rpcs[peer].generate(1)\n-                    block_time += 10*60\n-                # Must sync before next peer starts generating blocks\n-                sync_blocks(rpcs)\n-\n-        # Shut them down, and clean up cache directories:\n-        stop_nodes(rpcs)\n-        disable_mocktime()\n-        for i in range(MAX_NODES):\n-            os.remove(log_filename(cachedir, i, \"debug.log\"))\n-            os.remove(log_filename(cachedir, i, \"db.log\"))\n-            os.remove(log_filename(cachedir, i, \"peers.dat\"))\n-            os.remove(log_filename(cachedir, i, \"fee_estimates.dat\"))\n-\n-    for i in range(num_nodes):\n-        from_dir = os.path.join(cachedir, \"node\"+str(i))\n-        to_dir = os.path.join(test_dir,  \"node\"+str(i))\n-        shutil.copytree(from_dir, to_dir)\n-        initialize_datadir(test_dir, i) # Overwrite port/rpcport in bitcoin.conf\n-\n-def initialize_chain_clean(test_dir, num_nodes):\n-    \"\"\"\n-    Create an empty blockchain and num_nodes wallets.\n-    Useful if a test case wants complete control over initialization.\n-    \"\"\"\n-    for i in range(num_nodes):\n-        datadir=initialize_datadir(test_dir, i)\n-\n \n def start_node(i, dirname, extra_args=None, rpchost=None, timewait=None, binary=None, stderr=None):\n     \"\"\"\n@@ -315,7 +234,7 @@ def start_node(i, dirname, extra_args=None, rpchost=None, timewait=None, binary=\n     datadir = os.path.join(dirname, \"node\"+str(i))\n     if binary is None:\n         binary = os.getenv(\"BITCOIND\", \"bitcoind\")\n-    args = [binary, \"-datadir=\" + datadir, \"-server\", \"-keypool=1\", \"-discover=0\", \"-rest\", \"-logtimemicros\", \"-debug\", \"-debugexclude=libevent\", \"-debugexclude=leveldb\", \"-mocktime=\" + str(get_mocktime())]\n+    args = [binary, \"-datadir=\" + datadir, \"-server\", \"-keypool=1\", \"-discover=0\", \"-rest\", \"-logtimemicros\", \"-debug\", \"-debugexclude=libevent\", \"-debugexclude=leveldb\", \"-mocktime=\" + str(get_mocktime()), \"-uacomment=testnode%d\" % i]\n     if extra_args is not None: args.extend(extra_args)\n     bitcoind_processes[i] = subprocess.Popen(args, stderr=stderr)\n     logger.debug(\"initialize_chain: bitcoind started, waiting for RPC to come up\")\n@@ -354,6 +273,8 @@ def start_nodes(num_nodes, dirname, extra_args=None, rpchost=None, timewait=None\n     \"\"\"\n     if extra_args is None: extra_args = [ None for _ in range(num_nodes) ]\n     if binary is None: binary = [ None for _ in range(num_nodes) ]\n+    assert_equal(len(extra_args), num_nodes)\n+    assert_equal(len(binary), num_nodes)\n     rpcs = []\n     try:\n         for i in range(num_nodes):\n@@ -385,6 +306,17 @@ def set_node_times(nodes, t):\n     for node in nodes:\n         node.setmocktime(t)\n \n+def disconnect_nodes(from_connection, node_num):\n+    for peer_id in [peer['id'] for peer in from_connection.getpeerinfo() if \"testnode%d\" % node_num in peer['subver']]:\n+        from_connection.disconnectnode(nodeid=peer_id)\n+\n+    for _ in range(50):\n+        if [peer['id'] for peer in from_connection.getpeerinfo() if \"testnode%d\" % node_num in peer['subver']] == []:\n+            break\n+        time.sleep(0.1)\n+    else:\n+        raise AssertionError(\"timed out waiting for disconnect\")\n+\n def connect_nodes(from_connection, node_num):\n     ip_port = \"127.0.0.1:\"+str(p2p_port(node_num))\n     from_connection.addnode(ip_port, \"onetry\")"
      },
      {
        "sha": "b2aee7c739a55fc1781861848683416140da4bf9",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 47,
        "deletions": 38,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -16,6 +16,7 @@\n \n import argparse\n import configparser\n+import datetime\n import os\n import time\n import shutil\n@@ -77,13 +78,15 @@\n     'rawtransactions.py',\n     'reindex.py',\n     # vv Tests less than 30s vv\n+    \"zmq_test.py\",\n     'mempool_resurrect_test.py',\n     'txn_doublespend.py --mineblock',\n     'txn_clone.py',\n     'getchaintips.py',\n     'rest.py',\n     'mempool_spendcoinbase.py',\n     'mempool_reorg.py',\n+    'mempool_persist.py',\n     'httpbasics.py',\n     'multi_rpc.py',\n     'proxy_test.py',\n@@ -110,11 +113,6 @@\n     'p2p-leaktests.py',\n ]\n \n-ZMQ_SCRIPTS = [\n-    # ZMQ test can only be run if bitcoin was built with zmq-enabled.\n-    # call test_runner.py with -nozmq to explicitly exclude these tests.\n-    'zmq_test.py']\n-\n EXTENDED_SCRIPTS = [\n     # These tests are not run by the travis build process.\n     # Longest test should go first, to favor running tests in parallel\n@@ -143,13 +141,12 @@\n     'txn_clone.py --mineblock',\n     'forknotify.py',\n     'invalidateblock.py',\n-    'maxblocksinflight.py',\n     'p2p-acceptblock.py',\n     'replace-by-fee.py',\n ]\n \n # Place EXTENDED_SCRIPTS first since it has the 3 longest running tests\n-ALL_SCRIPTS = EXTENDED_SCRIPTS + BASE_SCRIPTS + ZMQ_SCRIPTS\n+ALL_SCRIPTS = EXTENDED_SCRIPTS + BASE_SCRIPTS\n \n NON_SCRIPTS = [\n     # These are python files that live in the functional tests directory, but are not test scripts.\n@@ -167,32 +164,40 @@ def main():\n     Help text and arguments for individual test script:''',\n                                      formatter_class=argparse.RawTextHelpFormatter)\n     parser.add_argument('--coverage', action='store_true', help='generate a basic coverage report for the RPC interface')\n-    parser.add_argument('--exclude', '-x', help='specify a comma-seperated-list of scripts to exclude. Do not include the .py extension in the name.')\n+    parser.add_argument('--exclude', '-x', help='specify a comma-seperated-list of scripts to exclude.')\n     parser.add_argument('--extended', action='store_true', help='run the extended test suite in addition to the basic tests')\n     parser.add_argument('--force', '-f', action='store_true', help='run tests even on platforms where they are disabled by default (e.g. windows).')\n     parser.add_argument('--help', '-h', '-?', action='store_true', help='print help text and exit')\n     parser.add_argument('--jobs', '-j', type=int, default=4, help='how many test scripts to run in parallel. Default=4.')\n     parser.add_argument('--keepcache', '-k', action='store_true', help='the default behavior is to flush the cache directory on startup. --keepcache retains the cache from the previous testrun.')\n     parser.add_argument('--quiet', '-q', action='store_true', help='only print results summary and failure logs')\n-    parser.add_argument('--nozmq', action='store_true', help='do not run the zmq tests')\n+    parser.add_argument('--tmpdirprefix', '-t', default=tempfile.gettempdir(), help=\"Root directory for datadirs\")\n     args, unknown_args = parser.parse_known_args()\n \n-    # Create a set to store arguments and create the passon string\n-    tests = set(arg for arg in unknown_args if arg[:2] != \"--\")\n+    # args to be passed on always start with two dashes; tests are the remaining unknown args\n+    tests = [arg for arg in unknown_args if arg[:2] != \"--\"]\n     passon_args = [arg for arg in unknown_args if arg[:2] == \"--\"]\n \n     # Read config generated by configure.\n     config = configparser.ConfigParser()\n-    config.read_file(open(os.path.dirname(__file__) + \"/config.ini\"))\n+    configfile = os.path.abspath(os.path.dirname(__file__)) + \"/config.ini\"\n+    config.read_file(open(configfile))\n+\n+    passon_args.append(\"--configfile=%s\" % configfile)\n \n     # Set up logging\n     logging_level = logging.INFO if args.quiet else logging.DEBUG\n     logging.basicConfig(format='%(message)s', level=logging_level)\n \n+    # Create base test directory\n+    tmpdir = \"%s/bitcoin_test_runner_%s\" % (args.tmpdirprefix, datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\"))\n+    os.makedirs(tmpdir)\n+\n+    logging.debug(\"Temporary test directory at %s\" % tmpdir)\n+\n     enable_wallet = config[\"components\"].getboolean(\"ENABLE_WALLET\")\n     enable_utils = config[\"components\"].getboolean(\"ENABLE_UTILS\")\n     enable_bitcoind = config[\"components\"].getboolean(\"ENABLE_BITCOIND\")\n-    enable_zmq = config[\"components\"].getboolean(\"ENABLE_ZMQ\") and not args.nozmq\n \n     if config[\"environment\"][\"EXEEXT\"] == \".exe\" and not args.force:\n         # https://github.com/bitcoin/bitcoin/commit/d52802551752140cf41f0d9a225a43e84404d3e9\n@@ -205,37 +210,34 @@ def main():\n         print(\"Rerun `configure` with -enable-wallet, -with-utils and -with-daemon and rerun make\")\n         sys.exit(0)\n \n-    # python3-zmq may not be installed. Handle this gracefully and with some helpful info\n-    if enable_zmq:\n-        try:\n-            import zmq\n-        except ImportError:\n-            print(\"ERROR: \\\"import zmq\\\" failed. Use -nozmq to run without the ZMQ tests.\"\n-                  \"To run zmq tests, see dependency info in /test/README.md.\")\n-            raise\n-\n     # Build list of tests\n     if tests:\n         # Individual tests have been specified. Run specified tests that exist\n         # in the ALL_SCRIPTS list. Accept the name with or without .py extension.\n-        test_list = [t for t in ALL_SCRIPTS if\n-                (t in tests or re.sub(\".py$\", \"\", t) in tests)]\n+        tests = [re.sub(\"\\.py$\", \"\", t) + \".py\" for t in tests]\n+        test_list = []\n+        for t in tests:\n+            if t in ALL_SCRIPTS:\n+                test_list.append(t)\n+            else:\n+                print(\"{}WARNING!{} Test '{}' not found in full test list.\".format(BOLD[1], BOLD[0], t))\n     else:\n-        # No individual tests have been specified. Run base tests, and\n-        # optionally ZMQ tests and extended tests.\n+        # No individual tests have been specified.\n+        # Run all base tests, and optionally run extended tests.\n         test_list = BASE_SCRIPTS\n-        if enable_zmq:\n-            test_list += ZMQ_SCRIPTS\n         if args.extended:\n             # place the EXTENDED_SCRIPTS first since the three longest ones\n             # are there and the list is shorter\n             test_list = EXTENDED_SCRIPTS + test_list\n \n     # Remove the test cases that the user has explicitly asked to exclude.\n     if args.exclude:\n-        for exclude_test in args.exclude.split(','):\n-            if exclude_test + \".py\" in test_list:\n-                test_list.remove(exclude_test + \".py\")\n+        tests_excl = [re.sub(\"\\.py$\", \"\", t) + \".py\" for t in args.exclude.split(',')]\n+        for exclude_test in tests_excl:\n+            if exclude_test in test_list:\n+                test_list.remove(exclude_test)\n+            else:\n+                print(\"{}WARNING!{} Test '{}' not found in current test list.\".format(BOLD[1], BOLD[0], exclude_test))\n \n     if not test_list:\n         print(\"No valid test scripts specified. Check that your test is in one \"\n@@ -253,9 +255,9 @@ def main():\n     if not args.keepcache:\n         shutil.rmtree(\"%s/test/cache\" % config[\"environment\"][\"BUILDDIR\"], ignore_errors=True)\n \n-    run_tests(test_list, config[\"environment\"][\"SRCDIR\"], config[\"environment\"][\"BUILDDIR\"], config[\"environment\"][\"EXEEXT\"], args.jobs, args.coverage, passon_args)\n+    run_tests(test_list, config[\"environment\"][\"SRCDIR\"], config[\"environment\"][\"BUILDDIR\"], config[\"environment\"][\"EXEEXT\"], tmpdir, args.jobs, args.coverage, passon_args)\n \n-def run_tests(test_list, src_dir, build_dir, exeext, jobs=1, enable_coverage=False, args=[]):\n+def run_tests(test_list, src_dir, build_dir, exeext, tmpdir, jobs=1, enable_coverage=False, args=[]):\n     # Warn if bitcoind is already running (unix only)\n     try:\n         if subprocess.check_output([\"pidof\", \"bitcoind\"]) is not None:\n@@ -286,10 +288,10 @@ def run_tests(test_list, src_dir, build_dir, exeext, jobs=1, enable_coverage=Fal\n \n     if len(test_list) > 1 and jobs > 1:\n         # Populate cache\n-        subprocess.check_output([tests_dir + 'create_cache.py'] + flags)\n+        subprocess.check_output([tests_dir + 'create_cache.py'] + flags + [\"--tmpdir=%s/cache\" % tmpdir])\n \n     #Run Tests\n-    job_queue = TestHandler(jobs, tests_dir, test_list, flags)\n+    job_queue = TestHandler(jobs, tests_dir, tmpdir, test_list, flags)\n     time0 = time.time()\n     test_results = []\n \n@@ -316,6 +318,10 @@ def run_tests(test_list, src_dir, build_dir, exeext, jobs=1, enable_coverage=Fal\n         logging.debug(\"Cleaning up coverage data\")\n         coverage.cleanup()\n \n+    # Clear up the temp directory if all subdirectories are gone\n+    if not os.listdir(tmpdir):\n+        os.rmdir(tmpdir)\n+\n     all_passed = all(map(lambda test_result: test_result.was_successful, test_results))\n \n     sys.exit(not all_passed)\n@@ -343,10 +349,11 @@ class TestHandler:\n     Trigger the testscrips passed in via the list.\n     \"\"\"\n \n-    def __init__(self, num_tests_parallel, tests_dir, test_list=None, flags=None):\n+    def __init__(self, num_tests_parallel, tests_dir, tmpdir, test_list=None, flags=None):\n         assert(num_tests_parallel >= 1)\n         self.num_jobs = num_tests_parallel\n         self.tests_dir = tests_dir\n+        self.tmpdir = tmpdir\n         self.test_list = test_list\n         self.flags = flags\n         self.num_running = 0\n@@ -361,13 +368,15 @@ def get_next(self):\n             # Add tests\n             self.num_running += 1\n             t = self.test_list.pop(0)\n-            port_seed = [\"--portseed={}\".format(len(self.test_list) + self.portseed_offset)]\n+            portseed = len(self.test_list) + self.portseed_offset\n+            portseed_arg = [\"--portseed={}\".format(portseed)]\n             log_stdout = tempfile.SpooledTemporaryFile(max_size=2**16)\n             log_stderr = tempfile.SpooledTemporaryFile(max_size=2**16)\n             test_argv = t.split()\n+            tmpdir = [\"--tmpdir=%s/%s_%s\" % (self.tmpdir, re.sub(\".py$\", \"\", test_argv[0]), portseed)]\n             self.jobs.append((t,\n                               time.time(),\n-                              subprocess.Popen([self.tests_dir + test_argv[0]] + test_argv[1:] + self.flags + port_seed,\n+                              subprocess.Popen([self.tests_dir + test_argv[0]] + test_argv[1:] + self.flags + portseed_arg + tmpdir,\n                                                universal_newlines=True,\n                                                stdout=log_stdout,\n                                                stderr=log_stderr),"
      },
      {
        "sha": "9b81af96cf0b6c41b17630627ff23391c73f9de7",
        "filename": "test/functional/txn_clone.py",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/txn_clone.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/txn_clone.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/txn_clone.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -20,7 +20,9 @@ def add_options(self, parser):\n \n     def setup_network(self):\n         # Start with split network:\n-        return super(TxnMallTest, self).setup_network(True)\n+        super(TxnMallTest, self).setup_network()\n+        disconnect_nodes(self.nodes[1], 2)\n+        disconnect_nodes(self.nodes[2], 1)\n \n     def run_test(self):\n         # All nodes should start with 1,250 BTC:"
      },
      {
        "sha": "1bd3b3271c5198ecb7494bad27bf900df0b140cc",
        "filename": "test/functional/txn_doublespend.py",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/txn_doublespend.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/txn_doublespend.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/txn_doublespend.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -20,7 +20,9 @@ def add_options(self, parser):\n \n     def setup_network(self):\n         # Start with split network:\n-        return super(TxnMallTest, self).setup_network(True)\n+        super().setup_network()\n+        disconnect_nodes(self.nodes[1], 2)\n+        disconnect_nodes(self.nodes[2], 1)\n \n     def run_test(self):\n         # All nodes should start with 1,250 BTC:"
      },
      {
        "sha": "e6635bea1c671268cbfffa9e39bc1aaa2ecf5cc0",
        "filename": "test/functional/wallet-accounts.py",
        "status": "modified",
        "additions": 52,
        "deletions": 15,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/wallet-accounts.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/wallet-accounts.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet-accounts.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -7,14 +7,14 @@\n RPCs tested are:\n     - getaccountaddress\n     - getaddressesbyaccount\n+    - listaddressgroupings\n     - setaccount\n     - sendfrom (with account arguments)\n     - move (with account arguments)\n \"\"\"\n \n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n-    start_nodes,\n     assert_equal,\n )\n \n@@ -24,22 +24,59 @@ def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n         self.num_nodes = 1\n-        self.node_args = [[]]\n+        self.extra_args = [[]]\n \n-    def setup_network(self):\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, self.node_args)\n-        self.is_network_split = False\n-\n-    def run_test (self):\n+    def run_test(self):\n         node = self.nodes[0]\n         # Check that there's no UTXO on any of the nodes\n         assert_equal(len(node.listunspent()), 0)\n-        \n+\n+        # Note each time we call generate, all generated coins go into\n+        # the same address, so we call twice to get two addresses w/50 each\n+        node.generate(1)\n         node.generate(101)\n-        \n-        assert_equal(node.getbalance(), 50)\n-        \n-        accounts = [\"a\",\"b\",\"c\",\"d\",\"e\"]\n+        assert_equal(node.getbalance(), 100)\n+\n+        # there should be 2 address groups\n+        # each with 1 address with a balance of 50 Bitcoins\n+        address_groups = node.listaddressgroupings()\n+        assert_equal(len(address_groups), 2)\n+        # the addresses aren't linked now, but will be after we send to the\n+        # common address\n+        linked_addresses = set()\n+        for address_group in address_groups:\n+            assert_equal(len(address_group), 1)\n+            assert_equal(len(address_group[0]), 2)\n+            assert_equal(address_group[0][1], 50)\n+            linked_addresses.add(address_group[0][0])\n+\n+        # send 50 from each address to a third address not in this wallet\n+        # There's some fee that will come back to us when the miner reward\n+        # matures.\n+        common_address = \"msf4WtN1YQKXvNtvdFYt9JBnUD2FB41kjr\"\n+        txid = node.sendmany(\n+            fromaccount=\"\",\n+            amounts={common_address: 100},\n+            subtractfeefrom=[common_address],\n+            minconf=1,\n+        )\n+        tx_details = node.gettransaction(txid)\n+        fee = -tx_details['details'][0]['fee']\n+        # there should be 1 address group, with the previously\n+        # unlinked addresses now linked (they both have 0 balance)\n+        address_groups = node.listaddressgroupings()\n+        assert_equal(len(address_groups), 1)\n+        assert_equal(len(address_groups[0]), 2)\n+        assert_equal(set([a[0] for a in address_groups[0]]), linked_addresses)\n+        assert_equal([a[1] for a in address_groups[0]], [0, 0])\n+\n+        node.generate(1)\n+\n+        # we want to reset so that the \"\" account has what's expected.\n+        # otherwise we're off by exactly the fee amount as that's mined\n+        # and matures in the next 100 blocks\n+        node.sendfrom(\"\", common_address, fee)\n+        accounts = [\"a\", \"b\", \"c\", \"d\", \"e\"]\n         amount_to_send = 1.0\n         account_addresses = dict()\n         for account in accounts:\n@@ -56,7 +93,7 @@ def run_test (self):\n         \n         for i in range(len(accounts)):\n             from_account = accounts[i]\n-            to_account = accounts[(i+1)%len(accounts)]\n+            to_account = accounts[(i+1) % len(accounts)]\n             to_address = account_addresses[to_account]\n             node.sendfrom(from_account, to_address, amount_to_send)\n         \n@@ -67,7 +104,7 @@ def run_test (self):\n             assert(address != account_addresses[account])\n             assert_equal(node.getreceivedbyaccount(account), 2)\n             node.move(account, \"\", node.getbalance(account))\n-        \n+\n         node.generate(101)\n         \n         expected_account_balances = {\"\": 5200}\n@@ -97,4 +134,4 @@ def run_test (self):\n             assert_equal(node.getbalance(account), 50)\n \n if __name__ == '__main__':\n-    WalletAccountsTest().main ()\n+    WalletAccountsTest().main()"
      },
      {
        "sha": "aab3b4bc2de53a560112a63dec8b2c3d6ab46353",
        "filename": "test/functional/wallet-hd.py",
        "status": "modified",
        "additions": 7,
        "deletions": 13,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/wallet-hd.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/wallet-hd.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet-hd.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -6,7 +6,6 @@\n \n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n-    start_nodes,\n     start_node,\n     assert_equal,\n     connect_nodes_bi,\n@@ -22,20 +21,15 @@ def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n         self.num_nodes = 2\n-        self.node_args = [['-usehd=0'], ['-usehd=1', '-keypool=0']]\n-\n-    def setup_network(self):\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, self.node_args)\n-        self.is_network_split = False\n-        connect_nodes_bi(self.nodes, 0, 1)\n+        self.extra_args = [['-usehd=0'], ['-usehd=1', '-keypool=0']]\n \n     def run_test (self):\n         tmpdir = self.options.tmpdir\n \n         # Make sure can't switch off usehd after wallet creation\n         self.stop_node(1)\n         assert_start_raises_init_error(1, self.options.tmpdir, ['-usehd=0'], 'already existing HD wallet')\n-        self.nodes[1] = start_node(1, self.options.tmpdir, self.node_args[1])\n+        self.nodes[1] = start_node(1, self.options.tmpdir, self.extra_args[1])\n         connect_nodes_bi(self.nodes, 0, 1)\n \n         # Make sure we use hd, keep masterkeyid\n@@ -44,7 +38,7 @@ def run_test (self):\n \n         # create an internal key\n         change_addr = self.nodes[1].getrawchangeaddress()\n-        change_addrV= self.nodes[1].validateaddress(change_addr);\n+        change_addrV= self.nodes[1].validateaddress(change_addr)\n         assert_equal(change_addrV[\"hdkeypath\"], \"m/0'/1'/0'\") #first internal child key\n \n         # Import a non-HD private key in the HD wallet\n@@ -72,7 +66,7 @@ def run_test (self):\n \n         # create an internal key (again)\n         change_addr = self.nodes[1].getrawchangeaddress()\n-        change_addrV= self.nodes[1].validateaddress(change_addr);\n+        change_addrV= self.nodes[1].validateaddress(change_addr)\n         assert_equal(change_addrV[\"hdkeypath\"], \"m/0'/1'/1'\") #second internal child key\n \n         self.sync_all()\n@@ -82,7 +76,7 @@ def run_test (self):\n         self.stop_node(1)\n         os.remove(self.options.tmpdir + \"/node1/regtest/wallet.dat\")\n         shutil.copyfile(tmpdir + \"/hd.bak\", tmpdir + \"/node1/regtest/wallet.dat\")\n-        self.nodes[1] = start_node(1, self.options.tmpdir, self.node_args[1])\n+        self.nodes[1] = start_node(1, self.options.tmpdir, self.extra_args[1])\n         #connect_nodes_bi(self.nodes, 0, 1)\n \n         # Assert that derivation is deterministic\n@@ -96,13 +90,13 @@ def run_test (self):\n \n         # Needs rescan\n         self.stop_node(1)\n-        self.nodes[1] = start_node(1, self.options.tmpdir, self.node_args[1] + ['-rescan'])\n+        self.nodes[1] = start_node(1, self.options.tmpdir, self.extra_args[1] + ['-rescan'])\n         #connect_nodes_bi(self.nodes, 0, 1)\n         assert_equal(self.nodes[1].getbalance(), num_hd_adds + 1)\n \n         # send a tx and make sure its using the internal chain for the changeoutput\n         txid = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n-        outs = self.nodes[1].decoderawtransaction(self.nodes[1].gettransaction(txid)['hex'])['vout'];\n+        outs = self.nodes[1].decoderawtransaction(self.nodes[1].gettransaction(txid)['hex'])['vout']\n         keypath = \"\"\n         for out in outs:\n             if out['value'] != 1:"
      },
      {
        "sha": "efde2e005e39e4b8321264af224ed249847799df",
        "filename": "test/functional/wallet.py",
        "status": "modified",
        "additions": 30,
        "deletions": 7,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/wallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/wallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -6,7 +6,7 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n \n-class WalletTest (BitcoinTestFramework):\n+class WalletTest(BitcoinTestFramework):\n \n     def check_fee_amount(self, curr_balance, balance_with_fee, fee_per_byte, tx_size):\n         \"\"\"Return curr_balance after asserting the fee was in range\"\"\"\n@@ -20,15 +20,14 @@ def __init__(self):\n         self.num_nodes = 4\n         self.extra_args = [['-usehd={:d}'.format(i%2==0)] for i in range(4)]\n \n-    def setup_network(self, split=False):\n+    def setup_network(self):\n         self.nodes = start_nodes(3, self.options.tmpdir, self.extra_args[:3])\n         connect_nodes_bi(self.nodes,0,1)\n         connect_nodes_bi(self.nodes,1,2)\n         connect_nodes_bi(self.nodes,0,2)\n-        self.is_network_split=False\n         self.sync_all()\n \n-    def run_test (self):\n+    def run_test(self):\n \n         # Check that there's no UTXO on none of the nodes\n         assert_equal(len(self.nodes[0].listunspent()), 0)\n@@ -52,14 +51,38 @@ def run_test (self):\n         assert_equal(self.nodes[2].getbalance(), 0)\n \n         # Check that only first and second nodes have UTXOs\n-        assert_equal(len(self.nodes[0].listunspent()), 1)\n+        utxos = self.nodes[0].listunspent()\n+        assert_equal(len(utxos), 1)\n         assert_equal(len(self.nodes[1].listunspent()), 1)\n         assert_equal(len(self.nodes[2].listunspent()), 0)\n \n         # Send 21 BTC from 0 to 2 using sendtoaddress call.\n+        # Locked memory should use at least 32 bytes to sign each transaction\n+        self.log.info(\"test getmemoryinfo\")\n+        memory_before = self.nodes[0].getmemoryinfo()\n         self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 11)\n-        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 10)\n-\n+        mempool_txid = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 10)\n+        memory_after = self.nodes[0].getmemoryinfo()\n+        assert(memory_before['locked']['used'] + 64 <= memory_after['locked']['used'])\n+\n+        self.log.info(\"test gettxout\")\n+        # utxo spent in mempool should be visible if you exclude mempool\n+        # but invisible if you include mempool\n+        confirmed_txid, confirmed_index = utxos[0][\"txid\"], utxos[0][\"vout\"]\n+        txout = self.nodes[0].gettxout(confirmed_txid, confirmed_index, False)\n+        assert_equal(txout['value'], 50)\n+        txout = self.nodes[0].gettxout(confirmed_txid, confirmed_index, True)\n+        assert txout is None\n+        # new utxo from mempool should be invisible if you exclude mempool\n+        # but visible if you include mempool\n+        txout = self.nodes[0].gettxout(mempool_txid, 0, False)\n+        assert txout is None\n+        txout1 = self.nodes[0].gettxout(mempool_txid, 0, True)\n+        txout2 = self.nodes[0].gettxout(mempool_txid, 1, True)\n+        # note the mempool tx will have randomly assigned indices\n+        # but 10 will go to node2 and the rest will go to node0\n+        balance = self.nodes[0].getbalance()\n+        assert_equal(set([txout1['value'], txout2['value']]), set([10, balance]))\n         walletinfo = self.nodes[0].getwalletinfo()\n         assert_equal(walletinfo['immature_balance'], 0)\n "
      },
      {
        "sha": "0492132af6898e4d753b5e37ba28e627af9f746e",
        "filename": "test/functional/walletbackup.py",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/walletbackup.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/walletbackup.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/walletbackup.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -44,14 +44,12 @@ def __init__(self):\n         # nodes 1, 2,3 are spenders, let's give them a keypool=100\n         self.extra_args = [[\"-keypool=100\"], [\"-keypool=100\"], [\"-keypool=100\"], []]\n \n-    # This mirrors how the network was setup in the bash test\n     def setup_network(self, split=False):\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, self.extra_args)\n+        self.setup_nodes()\n         connect_nodes(self.nodes[0], 3)\n         connect_nodes(self.nodes[1], 3)\n         connect_nodes(self.nodes[2], 3)\n         connect_nodes(self.nodes[2], 0)\n-        self.is_network_split=False\n         self.sync_all()\n \n     def one_send(self, from_node, to_address):"
      },
      {
        "sha": "7987edeb544091ec93e498522a19114693b86591",
        "filename": "test/functional/zapwallettxes.py",
        "status": "modified",
        "additions": 2,
        "deletions": 6,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/zapwallettxes.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/zapwallettxes.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/zapwallettxes.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -23,13 +23,9 @@ def __init__(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 3\n \n-    def setup_network(self, split=False):\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir)\n-        connect_nodes_bi(self.nodes,0,1)\n-        connect_nodes_bi(self.nodes,1,2)\n+    def setup_network(self):\n+        super().setup_network()\n         connect_nodes_bi(self.nodes,0,2)\n-        self.is_network_split=False\n-        self.sync_all()\n \n     def run_test (self):\n         self.log.info(\"Mining blocks...\")"
      },
      {
        "sha": "918e13bcd486f31b2815ec0ed7129e6c9289c618",
        "filename": "test/functional/zmq_test.py",
        "status": "modified",
        "additions": 22,
        "deletions": 3,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/zmq_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/functional/zmq_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/zmq_test.py?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -3,11 +3,13 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the ZMQ API.\"\"\"\n+import configparser\n+import os\n+import struct\n+import sys\n \n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n-import zmq\n-import struct\n \n class ZMQTest (BitcoinTestFramework):\n \n@@ -18,12 +20,29 @@ def __init__(self):\n     port = 28332\n \n     def setup_nodes(self):\n+        # Try to import python3-zmq. Skip this test if the import fails.\n+        try:\n+            import zmq\n+        except ImportError:\n+            self.log.warning(\"python3-zmq module not available. Skipping zmq tests!\")\n+            sys.exit(self.TEST_EXIT_SKIPPED)\n+\n+        # Check that bitcoin has been built with ZMQ enabled\n+        config = configparser.ConfigParser()\n+        if not self.options.configfile:\n+            self.options.configfile = os.path.dirname(__file__) + \"/config.ini\"\n+        config.read_file(open(self.options.configfile))\n+\n+        if not config[\"components\"].getboolean(\"ENABLE_ZMQ\"):\n+            self.log.warning(\"bitcoind has not been built with zmq enabled. Skipping zmq tests!\")\n+            sys.exit(self.TEST_EXIT_SKIPPED)\n+\n         self.zmqContext = zmq.Context()\n         self.zmqSubSocket = self.zmqContext.socket(zmq.SUB)\n         self.zmqSubSocket.setsockopt(zmq.SUBSCRIBE, b\"hashblock\")\n         self.zmqSubSocket.setsockopt(zmq.SUBSCRIBE, b\"hashtx\")\n         self.zmqSubSocket.connect(\"tcp://127.0.0.1:%i\" % self.port)\n-        return start_nodes(self.num_nodes, self.options.tmpdir, extra_args=[\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args=[\n             ['-zmqpubhashtx=tcp://127.0.0.1:'+str(self.port), '-zmqpubhashblock=tcp://127.0.0.1:'+str(self.port)],\n             [],\n             [],"
      },
      {
        "sha": "9fe2de649bed505d537bf8174b477f35f8556c8d",
        "filename": "test/util/data/blanktxv1.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/blanktxv1.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/blanktxv1.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/blanktxv1.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"d21633ba23f70118185227be58a63527675641ad37967e2aa461559f577aec43\",\n     \"hash\": \"d21633ba23f70118185227be58a63527675641ad37967e2aa461559f577aec43\",\n     \"version\": 1,\n+    \"size\": 10,\n+    \"vsize\": 10,\n     \"locktime\": 0,\n     \"vin\": [\n     ],"
      },
      {
        "sha": "e97626e421d13747a3da2b81b72a8dd3ea3b7148",
        "filename": "test/util/data/blanktxv2.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/blanktxv2.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/blanktxv2.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/blanktxv2.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"4ebd325a4b394cff8c57e8317ccf5a8d0e2bdf1b8526f8aad6c8e43d8240621a\",\n     \"hash\": \"4ebd325a4b394cff8c57e8317ccf5a8d0e2bdf1b8526f8aad6c8e43d8240621a\",\n     \"version\": 2,\n+    \"size\": 10,\n+    \"vsize\": 10,\n     \"locktime\": 0,\n     \"vin\": [\n     ],"
      },
      {
        "sha": "f6dfbb51cc35d9dc56118dd83aa5171da19a5df0",
        "filename": "test/util/data/tt-delin1-out.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/tt-delin1-out.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/tt-delin1-out.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/tt-delin1-out.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"81b2035be1da1abe745c6141174a73d151009ec17b3d5ebffa2e177408c50dfd\",\n     \"hash\": \"81b2035be1da1abe745c6141174a73d151009ec17b3d5ebffa2e177408c50dfd\",\n     \"version\": 1,\n+    \"size\": 3040,\n+    \"vsize\": 3040,\n     \"locktime\": 0,\n     \"vin\": [\n         {"
      },
      {
        "sha": "6769ed79fff8b95d5554387fd38fdc4e6078f0b8",
        "filename": "test/util/data/tt-delout1-out.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/tt-delout1-out.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/tt-delout1-out.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/tt-delout1-out.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"c46ccd75b5050e942b2e86a3648f843f525fe6fc000bf0534ba5973063354493\",\n     \"hash\": \"c46ccd75b5050e942b2e86a3648f843f525fe6fc000bf0534ba5973063354493\",\n     \"version\": 1,\n+    \"size\": 3155,\n+    \"vsize\": 3155,\n     \"locktime\": 0,\n     \"vin\": [\n         {"
      },
      {
        "sha": "82b64df075d545a97d8ac767ee2ec866694bdd62",
        "filename": "test/util/data/tt-locktime317000-out.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/tt-locktime317000-out.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/tt-locktime317000-out.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/tt-locktime317000-out.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"aded538f642c17e15f4d3306b8be7e1a4d1ae0c4616d641ab51ea09ba65e5cb5\",\n     \"hash\": \"aded538f642c17e15f4d3306b8be7e1a4d1ae0c4616d641ab51ea09ba65e5cb5\",\n     \"version\": 1,\n+    \"size\": 3189,\n+    \"vsize\": 3189,\n     \"locktime\": 317000,\n     \"vin\": [\n         {"
      },
      {
        "sha": "36741044c914a096f665076964497881a5345ecf",
        "filename": "test/util/data/txcreate1.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreate1.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreate1.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreate1.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"fe7d174f42dce0cffa7a527e9bc8368956057619ec817648f6138b98f2533e8f\",\n     \"hash\": \"fe7d174f42dce0cffa7a527e9bc8368956057619ec817648f6138b98f2533e8f\",\n     \"version\": 2,\n+    \"size\": 201,\n+    \"vsize\": 201,\n     \"locktime\": 0,\n     \"vin\": [\n         {"
      },
      {
        "sha": "23fe7ace679cd60bca6cc47a180c206e0cf9db2a",
        "filename": "test/util/data/txcreate2.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreate2.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreate2.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreate2.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"0481afb29931341d0d7861d8a2f6f26456fa042abf54a23e96440ed7946e0715\",\n     \"hash\": \"0481afb29931341d0d7861d8a2f6f26456fa042abf54a23e96440ed7946e0715\",\n     \"version\": 2,\n+    \"size\": 19,\n+    \"vsize\": 19,\n     \"locktime\": 0,\n     \"vin\": [\n     ],"
      },
      {
        "sha": "e65a1859eb38443cb3bacf9bb1738a2139099871",
        "filename": "test/util/data/txcreatedata1.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatedata1.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatedata1.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatedata1.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"07894b4d12fe7853dd911402db1620920d261b9627c447f931417d330c25f06e\",\n     \"hash\": \"07894b4d12fe7853dd911402db1620920d261b9627c447f931417d330c25f06e\",\n     \"version\": 1,\n+    \"size\": 176,\n+    \"vsize\": 176,\n     \"locktime\": 0,\n     \"vin\": [\n         {"
      },
      {
        "sha": "8f1544e1c023890ac60e6b0330e2089ed665fe7b",
        "filename": "test/util/data/txcreatedata2.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatedata2.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatedata2.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatedata2.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"c14b007fa3a6c1e7765919c1d14c1cfc2b8642c3a5d3be4b1fa8c4ccfec98bb0\",\n     \"hash\": \"c14b007fa3a6c1e7765919c1d14c1cfc2b8642c3a5d3be4b1fa8c4ccfec98bb0\",\n     \"version\": 2,\n+    \"size\": 176,\n+    \"vsize\": 176,\n     \"locktime\": 0,\n     \"vin\": [\n         {"
      },
      {
        "sha": "e52401f4184cf6c8ddf963a369af8ba1a494af65",
        "filename": "test/util/data/txcreatedata_seq0.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatedata_seq0.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatedata_seq0.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatedata_seq0.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"8df6ed527472542dd5e137c242a7c5a9f337ac34f7b257ae4af886aeaebb51b0\",\n     \"hash\": \"8df6ed527472542dd5e137c242a7c5a9f337ac34f7b257ae4af886aeaebb51b0\",\n     \"version\": 2,\n+    \"size\": 85,\n+    \"vsize\": 85,\n     \"locktime\": 0,\n     \"vin\": [\n         {"
      },
      {
        "sha": "093ff4a56bb4c2fa9d29469b2b2ea3368ddf1039",
        "filename": "test/util/data/txcreatedata_seq1.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatedata_seq1.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatedata_seq1.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatedata_seq1.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"c4dea671b0d7b48f8ab10bc46650e8329d3c5766931f548f513847a19f5ba75b\",\n     \"hash\": \"c4dea671b0d7b48f8ab10bc46650e8329d3c5766931f548f513847a19f5ba75b\",\n     \"version\": 1,\n+    \"size\": 126,\n+    \"vsize\": 126,\n     \"locktime\": 0,\n     \"vin\": [\n         {"
      },
      {
        "sha": "0cc530836afa32b50ac807f236a280ef57b944bf",
        "filename": "test/util/data/txcreatemultisig1.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatemultisig1.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatemultisig1.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatemultisig1.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"0d1d4edfc217d9db3ab6a9298f26a52eae3c52f55a6cb8ccbc14f7c727572894\",\n     \"hash\": \"0d1d4edfc217d9db3ab6a9298f26a52eae3c52f55a6cb8ccbc14f7c727572894\",\n     \"version\": 1,\n+    \"size\": 124,\n+    \"vsize\": 124,\n     \"locktime\": 0,\n     \"vin\": [\n     ],"
      },
      {
        "sha": "8ad2ffdc6575229bd3b60436ef0828a4ac516120",
        "filename": "test/util/data/txcreatemultisig2.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatemultisig2.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatemultisig2.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatemultisig2.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"0d861f278a3b7bce7cb5a88d71e6e6a903336f95ad5a2c29b295b63835b6eee3\",\n     \"hash\": \"0d861f278a3b7bce7cb5a88d71e6e6a903336f95ad5a2c29b295b63835b6eee3\",\n     \"version\": 1,\n+    \"size\": 42,\n+    \"vsize\": 42,\n     \"locktime\": 0,\n     \"vin\": [\n     ],"
      },
      {
        "sha": "086bf44b8a9e58f490aa90b579503d95af45f1f7",
        "filename": "test/util/data/txcreatemultisig3.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatemultisig3.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatemultisig3.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatemultisig3.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"ccc552220b46a3b5140048b03395987ce4f0fa1ddf8c635bba1fa44e0f8c1d7f\",\n     \"hash\": \"ccc552220b46a3b5140048b03395987ce4f0fa1ddf8c635bba1fa44e0f8c1d7f\",\n     \"version\": 1,\n+    \"size\": 53,\n+    \"vsize\": 53,\n     \"locktime\": 0,\n     \"vin\": [\n     ],"
      },
      {
        "sha": "d23ccc045e8f311a6c2544b749693aa9202be13a",
        "filename": "test/util/data/txcreatemultisig4.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatemultisig4.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatemultisig4.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatemultisig4.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"5e8b1cc73234e208d4b7ca9075f136b908c34101be7a048df4ba9ac758b61567\",\n     \"hash\": \"5e8b1cc73234e208d4b7ca9075f136b908c34101be7a048df4ba9ac758b61567\",\n     \"version\": 1,\n+    \"size\": 42,\n+    \"vsize\": 42,\n     \"locktime\": 0,\n     \"vin\": [\n     ],"
      },
      {
        "sha": "f10aaecf7aae98af5114747028e1778188d97dc3",
        "filename": "test/util/data/txcreateoutpubkey1.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreateoutpubkey1.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreateoutpubkey1.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreateoutpubkey1.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"f42b38ac12e3fafc96ba1a9ba70cbfe326744aef75df5fb9db5d6e2855ca415f\",\n     \"hash\": \"f42b38ac12e3fafc96ba1a9ba70cbfe326744aef75df5fb9db5d6e2855ca415f\",\n     \"version\": 1,\n+    \"size\": 54,\n+    \"vsize\": 54,\n     \"locktime\": 0,\n     \"vin\": [\n     ],"
      },
      {
        "sha": "5a473b76c3ee54511edec9fb1dd9c6a0cbcab52a",
        "filename": "test/util/data/txcreateoutpubkey2.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreateoutpubkey2.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreateoutpubkey2.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreateoutpubkey2.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"70f2a088cde460e677415fa1fb71895e90c231e6ed38ed203a35b6f848e9cc73\",\n     \"hash\": \"70f2a088cde460e677415fa1fb71895e90c231e6ed38ed203a35b6f848e9cc73\",\n     \"version\": 1,\n+    \"size\": 41,\n+    \"vsize\": 41,\n     \"locktime\": 0,\n     \"vin\": [\n     ],"
      },
      {
        "sha": "b8389b8f7e6501a80bddecd3cb45d778baac4af3",
        "filename": "test/util/data/txcreateoutpubkey3.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreateoutpubkey3.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreateoutpubkey3.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreateoutpubkey3.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"bfc7e898ee9f6a9652d7b8cca147e2da134502e2ada0f279ed634fc8cf833f8c\",\n     \"hash\": \"bfc7e898ee9f6a9652d7b8cca147e2da134502e2ada0f279ed634fc8cf833f8c\",\n     \"version\": 1,\n+    \"size\": 42,\n+    \"vsize\": 42,\n     \"locktime\": 0,\n     \"vin\": [\n     ],"
      },
      {
        "sha": "823168e9fb573b2d1ba33c3a489d37fb8c34e463",
        "filename": "test/util/data/txcreatescript1.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatescript1.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatescript1.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatescript1.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"f0851b68202f736b792649cfc960259c2374badcb644ab20cac726b5f72f61c9\",\n     \"hash\": \"f0851b68202f736b792649cfc960259c2374badcb644ab20cac726b5f72f61c9\",\n     \"version\": 1,\n+    \"size\": 20,\n+    \"vsize\": 20,\n     \"locktime\": 0,\n     \"vin\": [\n     ],"
      },
      {
        "sha": "d4c7e10c78f0db6a01ee375ececdae00a669ea32",
        "filename": "test/util/data/txcreatescript2.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatescript2.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatescript2.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatescript2.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"6e07a7cc075e0703f32ee8c4e5373fe654bfbc315148fda364e1be286ff290d0\",\n     \"hash\": \"6e07a7cc075e0703f32ee8c4e5373fe654bfbc315148fda364e1be286ff290d0\",\n     \"version\": 1,\n+    \"size\": 42,\n+    \"vsize\": 42,\n     \"locktime\": 0,\n     \"vin\": [\n     ],"
      },
      {
        "sha": "001e69511fa1d66c7d1162c177338059e6acd78c",
        "filename": "test/util/data/txcreatescript3.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatescript3.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatescript3.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatescript3.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"8a234037b088e987c877030efc83374a07441c321bf9dc6dd2f206bc26507df8\",\n     \"hash\": \"8a234037b088e987c877030efc83374a07441c321bf9dc6dd2f206bc26507df8\",\n     \"version\": 1,\n+    \"size\": 53,\n+    \"vsize\": 53,\n     \"locktime\": 0,\n     \"vin\": [\n     ],"
      },
      {
        "sha": "20094bcd44eaa89cc1c2fce1b37657ad5b50d053",
        "filename": "test/util/data/txcreatescript4.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatescript4.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatescript4.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatescript4.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"24225cf5e9391100d6b218134b9f03383ca4c880a1f634ac12990cf28b66adbc\",\n     \"hash\": \"24225cf5e9391100d6b218134b9f03383ca4c880a1f634ac12990cf28b66adbc\",\n     \"version\": 1,\n+    \"size\": 42,\n+    \"vsize\": 42,\n     \"locktime\": 0,\n     \"vin\": [\n     ],"
      },
      {
        "sha": "519d3ab0669ac204352111760464acab366f725c",
        "filename": "test/util/data/txcreatesignv1.json",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatesignv1.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b133c97dd75950e3d1e40d9d7b6bab1d4fadc/test/util/data/txcreatesignv1.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/txcreatesignv1.json?ref=244b133c97dd75950e3d1e40d9d7b6bab1d4fadc",
        "patch": "@@ -2,6 +2,8 @@\n     \"txid\": \"977e7cd286cb72cd470d539ba6cb48400f8f387d97451d45cdb8819437a303af\",\n     \"hash\": \"977e7cd286cb72cd470d539ba6cb48400f8f387d97451d45cdb8819437a303af\",\n     \"version\": 1,\n+    \"size\": 224,\n+    \"vsize\": 224,\n     \"locktime\": 0,\n     \"vin\": [\n         {"
      }
    ]
  }
]