[
  {
    "sha": "c772f4cb04aa2edc04d849039b07c5a454d3f666",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNzcyZjRjYjA0YWEyZWRjMDRkODQ5MDM5YjA3YzVhNDU0ZDNmNjY2",
    "commit": {
      "author": {
        "name": "Michael Ford",
        "email": "fanquake@gmail.com",
        "date": "2014-10-24T03:23:14Z"
      },
      "committer": {
        "name": "Michael Ford",
        "email": "fanquake@gmail.com",
        "date": "2014-10-24T03:23:14Z"
      },
      "message": "Add doc/doxygen to .gitignore",
      "tree": {
        "sha": "f5b6b26572cf73e4ebc59b35b48efb8aa689d06f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f5b6b26572cf73e4ebc59b35b48efb8aa689d06f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c772f4cb04aa2edc04d849039b07c5a454d3f666",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c772f4cb04aa2edc04d849039b07c5a454d3f666",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c772f4cb04aa2edc04d849039b07c5a454d3f666",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c772f4cb04aa2edc04d849039b07c5a454d3f666/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3552d4b859d56726cd25baa6f1e5988050bdad33",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3552d4b859d56726cd25baa6f1e5988050bdad33",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3552d4b859d56726cd25baa6f1e5988050bdad33"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 2,
      "deletions": 0
    },
    "files": [
      {
        "sha": "bafc5919c1f0f40e4fe46616241244cafd956e89",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c772f4cb04aa2edc04d849039b07c5a454d3f666/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c772f4cb04aa2edc04d849039b07c5a454d3f666/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=c772f4cb04aa2edc04d849039b07c5a454d3f666",
        "patch": "@@ -102,3 +102,5 @@ qa/pull-tester/run-bitcoind-for-test.sh\n qa/pull-tester/build-tests.sh\n \n !src/leveldb*/Makefile\n+\n+/doc/doxygen/"
      }
    ]
  },
  {
    "sha": "24f5c94015cd15adbf9a7018e11667ee36799cec",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNGY1Yzk0MDE1Y2QxNWFkYmY5YTcwMThlMTE2NjdlZTM2Nzk5Y2Vj",
    "commit": {
      "author": {
        "name": "Michael Ford",
        "email": "fanquake@gmail.com",
        "date": "2014-10-24T04:04:27Z"
      },
      "committer": {
        "name": "Michael Ford",
        "email": "fanquake@gmail.com",
        "date": "2014-10-24T07:45:27Z"
      },
      "message": "Update comments in addrman to be doxygen compatible\n\nAlso correct the file license",
      "tree": {
        "sha": "8048ce36df5a53a37b13a804a1ec60bd379e3867",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8048ce36df5a53a37b13a804a1ec60bd379e3867"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/24f5c94015cd15adbf9a7018e11667ee36799cec",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/24f5c94015cd15adbf9a7018e11667ee36799cec",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/24f5c94015cd15adbf9a7018e11667ee36799cec",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/24f5c94015cd15adbf9a7018e11667ee36799cec/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c772f4cb04aa2edc04d849039b07c5a454d3f666",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c772f4cb04aa2edc04d849039b07c5a454d3f666",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c772f4cb04aa2edc04d849039b07c5a454d3f666"
      }
    ],
    "stats": {
      "total": 247,
      "additions": 128,
      "deletions": 119
    },
    "files": [
      {
        "sha": "7ff21b00ec5c0fee5202db74f4ae6ae07e316207",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/24f5c94015cd15adbf9a7018e11667ee36799cec/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/24f5c94015cd15adbf9a7018e11667ee36799cec/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=24f5c94015cd15adbf9a7018e11667ee36799cec",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2012 Pieter Wuille\n-// Distributed under the MIT/X11 software license, see the accompanying\n+// Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"addrman.h\"\n@@ -39,7 +39,7 @@ int CAddrInfo::GetNewBucket(const std::vector<unsigned char>& nKey, const CNetAd\n \n bool CAddrInfo::IsTerrible(int64_t nNow) const\n {\n-    if (nLastTry && nLastTry >= nNow - 60) // never remove things tried the last minute\n+    if (nLastTry && nLastTry >= nNow - 60) // never remove things tried in the last minute\n         return false;\n \n     if (nTime > nNow + 10 * 60) // came in a flying DeLorean\n@@ -131,7 +131,7 @@ int CAddrMan::SelectTried(int nKBucket)\n {\n     std::vector<int>& vTried = vvTried[nKBucket];\n \n-    // random shuffle the first few elements (using the entire list)\n+    // randomly shuffle the first few elements (using the entire list)\n     // find the least recently tried among them\n     int64_t nOldest = -1;\n     int nOldestPos = -1;\n@@ -211,7 +211,7 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId, int nOrigin)\n \n     assert(info.nRefCount == 0);\n \n-    // what tried bucket to move the entry to\n+    // which tried bucket to move the entry to\n     int nKBucket = info.GetTriedBucket(nKey);\n     std::vector<int>& vTried = vvTried[nKBucket];\n "
      },
      {
        "sha": "914086fc7614effc524b0f19bef68aff41b207cb",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 124,
        "deletions": 115,
        "changes": 239,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/24f5c94015cd15adbf9a7018e11667ee36799cec/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/24f5c94015cd15adbf9a7018e11667ee36799cec/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=24f5c94015cd15adbf9a7018e11667ee36799cec",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2012 Pieter Wuille\n-// Distributed under the MIT/X11 software license, see the accompanying\n+// Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #ifndef _BITCOIN_ADDRMAN\n@@ -17,29 +17,31 @@\n #include <stdint.h>\n #include <vector>\n \n-/** Extended statistics about a CAddress */\n+/** \n+ * Extended statistics about a CAddress \n+ */\n class CAddrInfo : public CAddress\n {\n private:\n-    // where knowledge about this address first came from\n+    //! where knowledge about this address first came from\n     CNetAddr source;\n \n-    // last successful connection by us\n+    //! last successful connection by us\n     int64_t nLastSuccess;\n \n-    // last try whatsoever by us:\n+    //! last try whatsoever by us:\n     // int64_t CAddress::nLastTry\n \n-    // connection attempts since last successful attempt\n+    //! connection attempts since last successful attempt\n     int nAttempts;\n \n-    // reference count in new sets (memory only)\n+    //! reference count in new sets (memory only)\n     int nRefCount;\n \n-    // in tried set? (memory only)\n+    //! in tried set? (memory only)\n     bool fInTried;\n \n-    // position in vRandom\n+    //! position in vRandom\n     int nRandomPos;\n \n     friend class CAddrMan;\n@@ -76,200 +78,205 @@ class CAddrInfo : public CAddress\n         Init();\n     }\n \n-    // Calculate in which \"tried\" bucket this entry belongs\n+    //! Calculate in which \"tried\" bucket this entry belongs\n     int GetTriedBucket(const std::vector<unsigned char> &nKey) const;\n \n-    // Calculate in which \"new\" bucket this entry belongs, given a certain source\n+    //! Calculate in which \"new\" bucket this entry belongs, given a certain source\n     int GetNewBucket(const std::vector<unsigned char> &nKey, const CNetAddr& src) const;\n \n-    // Calculate in which \"new\" bucket this entry belongs, using its default source\n+    //! Calculate in which \"new\" bucket this entry belongs, using its default source\n     int GetNewBucket(const std::vector<unsigned char> &nKey) const\n     {\n         return GetNewBucket(nKey, source);\n     }\n \n-    // Determine whether the statistics about this entry are bad enough so that it can just be deleted\n+    //! Determine whether the statistics about this entry are bad enough so that it can just be deleted\n     bool IsTerrible(int64_t nNow = GetAdjustedTime()) const;\n \n-    // Calculate the relative chance this entry should be given when selecting nodes to connect to\n+    //! Calculate the relative chance this entry should be given when selecting nodes to connect to\n     double GetChance(int64_t nNow = GetAdjustedTime()) const;\n \n };\n \n-// Stochastic address manager\n-//\n-// Design goals:\n-//  * Only keep a limited number of addresses around, so that addr.dat and memory requirements do not grow without bound.\n-//  * Keep the address tables in-memory, and asynchronously dump the entire to able in addr.dat.\n-//  * Make sure no (localized) attacker can fill the entire table with his nodes/addresses.\n-//\n-// To that end:\n-//  * Addresses are organized into buckets.\n-//    * Address that have not yet been tried go into 256 \"new\" buckets.\n-//      * Based on the address range (/16 for IPv4) of source of the information, 32 buckets are selected at random\n-//      * The actual bucket is chosen from one of these, based on the range the address itself is located.\n-//      * One single address can occur in up to 4 different buckets, to increase selection chances for addresses that\n-//        are seen frequently. The chance for increasing this multiplicity decreases exponentially.\n-//      * When adding a new address to a full bucket, a randomly chosen entry (with a bias favoring less recently seen\n-//        ones) is removed from it first.\n-//    * Addresses of nodes that are known to be accessible go into 64 \"tried\" buckets.\n-//      * Each address range selects at random 4 of these buckets.\n-//      * The actual bucket is chosen from one of these, based on the full address.\n-//      * When adding a new good address to a full bucket, a randomly chosen entry (with a bias favoring less recently\n-//        tried ones) is evicted from it, back to the \"new\" buckets.\n-//    * Bucket selection is based on cryptographic hashing, using a randomly-generated 256-bit key, which should not\n-//      be observable by adversaries.\n-//    * Several indexes are kept for high performance. Defining DEBUG_ADDRMAN will introduce frequent (and expensive)\n-//      consistency checks for the entire data structure.\n-\n-// total number of buckets for tried addresses\n+/** Stochastic address manager\n+ *\n+ * Design goals:\n+ *  * Keep the address tables in-memory, and asynchronously dump the entire to able in peers.dat.\n+ *  * Make sure no (localized) attacker can fill the entire table with his nodes/addresses.\n+ *\n+ * To that end:\n+ *  * Addresses are organized into buckets.\n+ *    * Address that have not yet been tried go into 256 \"new\" buckets.\n+ *      * Based on the address range (/16 for IPv4) of source of the information, 32 buckets are selected at random\n+ *      * The actual bucket is chosen from one of these, based on the range the address itself is located.\n+ *      * One single address can occur in up to 4 different buckets, to increase selection chances for addresses that\n+ *        are seen frequently. The chance for increasing this multiplicity decreases exponentially.\n+ *      * When adding a new address to a full bucket, a randomly chosen entry (with a bias favoring less recently seen\n+ *        ones) is removed from it first.\n+ *    * Addresses of nodes that are known to be accessible go into 64 \"tried\" buckets.\n+ *      * Each address range selects at random 4 of these buckets.\n+ *      * The actual bucket is chosen from one of these, based on the full address.\n+ *      * When adding a new good address to a full bucket, a randomly chosen entry (with a bias favoring less recently\n+ *        tried ones) is evicted from it, back to the \"new\" buckets.\n+ *    * Bucket selection is based on cryptographic hashing, using a randomly-generated 256-bit key, which should not\n+ *      be observable by adversaries.\n+ *    * Several indexes are kept for high performance. Defining DEBUG_ADDRMAN will introduce frequent (and expensive)\n+ *      consistency checks for the entire data structure.\n+ */\n+\n+//! total number of buckets for tried addresses\n #define ADDRMAN_TRIED_BUCKET_COUNT 64\n \n-// maximum allowed number of entries in buckets for tried addresses\n+//! maximum allowed number of entries in buckets for tried addresses\n #define ADDRMAN_TRIED_BUCKET_SIZE 64\n \n-// total number of buckets for new addresses\n+//! total number of buckets for new addresses\n #define ADDRMAN_NEW_BUCKET_COUNT 256\n \n-// maximum allowed number of entries in buckets for new addresses\n+//! maximum allowed number of entries in buckets for new addresses\n #define ADDRMAN_NEW_BUCKET_SIZE 64\n \n-// over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread\n+//! over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread\n #define ADDRMAN_TRIED_BUCKETS_PER_GROUP 4\n \n-// over how many buckets entries with new addresses originating from a single group are spread\n+//! over how many buckets entries with new addresses originating from a single group are spread\n #define ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP 32\n \n-// in how many buckets for entries with new addresses a single address may occur\n+//! in how many buckets for entries with new addresses a single address may occur\n #define ADDRMAN_NEW_BUCKETS_PER_ADDRESS 4\n \n-// how many entries in a bucket with tried addresses are inspected, when selecting one to replace\n+//! how many entries in a bucket with tried addresses are inspected, when selecting one to replace\n #define ADDRMAN_TRIED_ENTRIES_INSPECT_ON_EVICT 4\n \n-// how old addresses can maximally be\n+//! how old addresses can maximally be\n #define ADDRMAN_HORIZON_DAYS 30\n \n-// after how many failed attempts we give up on a new node\n+//! after how many failed attempts we give up on a new node\n #define ADDRMAN_RETRIES 3\n \n-// how many successive failures are allowed ...\n+//! how many successive failures are allowed ...\n #define ADDRMAN_MAX_FAILURES 10\n \n-// ... in at least this many days\n+//! ... in at least this many days\n #define ADDRMAN_MIN_FAIL_DAYS 7\n \n-// the maximum percentage of nodes to return in a getaddr call\n+//! the maximum percentage of nodes to return in a getaddr call\n #define ADDRMAN_GETADDR_MAX_PCT 23\n \n-// the maximum number of nodes to return in a getaddr call\n+//! the maximum number of nodes to return in a getaddr call\n #define ADDRMAN_GETADDR_MAX 2500\n \n-/** Stochastical (IP) address manager */\n+/** \n+ * Stochastical (IP) address manager \n+ */\n class CAddrMan\n {\n private:\n-    // critical section to protect the inner data structures\n+    //! critical section to protect the inner data structures\n     mutable CCriticalSection cs;\n \n-    // secret key to randomize bucket select with\n+    //! secret key to randomize bucket select with\n     std::vector<unsigned char> nKey;\n \n-    // last used nId\n+    //! last used nId\n     int nIdCount;\n \n-    // table with information about all nIds\n+    //! table with information about all nIds\n     std::map<int, CAddrInfo> mapInfo;\n \n-    // find an nId based on its network address\n+    //! find an nId based on its network address\n     std::map<CNetAddr, int> mapAddr;\n \n-    // randomly-ordered vector of all nIds\n+    //! randomly-ordered vector of all nIds\n     std::vector<int> vRandom;\n \n     // number of \"tried\" entries\n     int nTried;\n \n-    // list of \"tried\" buckets\n+    //! list of \"tried\" buckets\n     std::vector<std::vector<int> > vvTried;\n \n-    // number of (unique) \"new\" entries\n+    //! number of (unique) \"new\" entries\n     int nNew;\n \n-    // list of \"new\" buckets\n+    //! list of \"new\" buckets\n     std::vector<std::set<int> > vvNew;\n \n protected:\n \n-    // Find an entry.\n+    //! Find an entry.\n     CAddrInfo* Find(const CNetAddr& addr, int *pnId = NULL);\n \n-    // find an entry, creating it if necessary.\n-    // nTime and nServices of found node is updated, if necessary.\n+    //! find an entry, creating it if necessary.\n+    //! nTime and nServices of the found node are updated, if necessary.\n     CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = NULL);\n \n-    // Swap two elements in vRandom.\n+    //! Swap two elements in vRandom.\n     void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2);\n \n-    // Return position in given bucket to replace.\n+    //! Return position in given bucket to replace.\n     int SelectTried(int nKBucket);\n \n-    // Remove an element from a \"new\" bucket.\n-    // This is the only place where actual deletes occur.\n-    // They are never deleted while in the \"tried\" table, only possibly evicted back to the \"new\" table.\n+    //! Remove an element from a \"new\" bucket.\n+    //! This is the only place where actual deletions occur.\n+    //! Elements are never deleted while in the \"tried\" table, only possibly evicted back to the \"new\" table.\n     int ShrinkNew(int nUBucket);\n \n-    // Move an entry from the \"new\" table(s) to the \"tried\" table\n-    // @pre vvUnkown[nOrigin].count(nId) != 0\n+    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n+    //! @pre vvUnkown[nOrigin].count(nId) != 0\n     void MakeTried(CAddrInfo& info, int nId, int nOrigin);\n \n-    // Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n+    //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n     void Good_(const CService &addr, int64_t nTime);\n \n-    // Add an entry to the \"new\" table.\n+    //! Add an entry to the \"new\" table.\n     bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty);\n \n-    // Mark an entry as attempted to connect.\n+    //! Mark an entry as attempted to connect.\n     void Attempt_(const CService &addr, int64_t nTime);\n \n-    // Select an address to connect to.\n-    // nUnkBias determines how much to favor new addresses over tried ones (min=0, max=100)\n+    //! Select an address to connect to.\n+    //! nUnkBias determines how much to favor new addresses over tried ones (min=0, max=100)\n     CAddress Select_(int nUnkBias);\n \n #ifdef DEBUG_ADDRMAN\n-    // Perform consistency check. Returns an error code or zero.\n+    //! Perform consistency check. Returns an error code or zero.\n     int Check_();\n #endif\n \n-    // Select several addresses at once.\n+    //! Select several addresses at once.\n     void GetAddr_(std::vector<CAddress> &vAddr);\n \n-    // Mark an entry as currently-connected-to.\n+    //! Mark an entry as currently-connected-to.\n     void Connected_(const CService &addr, int64_t nTime);\n \n public:\n-    // serialized format:\n-    // * version byte (currently 0)\n-    // * nKey\n-    // * nNew\n-    // * nTried\n-    // * number of \"new\" buckets\n-    // * all nNew addrinfos in vvNew\n-    // * all nTried addrinfos in vvTried\n-    // * for each bucket:\n-    //   * number of elements\n-    //   * for each element: index\n-    //\n-    // Notice that vvTried, mapAddr and vVector are never encoded explicitly;\n-    // they are instead reconstructed from the other information.\n-    //\n-    // vvNew is serialized, but only used if ADDRMAN_UNKOWN_BUCKET_COUNT didn't change,\n-    // otherwise it is reconstructed as well.\n-    //\n-    // This format is more complex, but significantly smaller (at most 1.5 MiB), and supports\n-    // changes to the ADDRMAN_ parameters without breaking the on-disk structure.\n-    //\n-    // We don't use ADD_SERIALIZE_METHODS since the serialization and deserialization code has\n-    // very little in common.\n+    /**\n+     * serialized format:\n+     * * version byte (currently 0)\n+     * * nKey\n+     * * nNew\n+     * * nTried\n+     * * number of \"new\" buckets\n+     * * all nNew addrinfos in vvNew\n+     * * all nTried addrinfos in vvTried\n+     * * for each bucket:\n+     *   * number of elements\n+     *   * for each element: index\n+     *\n+     * Notice that vvTried, mapAddr and vVector are never encoded explicitly;\n+     * they are instead reconstructed from the other information.\n+     *\n+     * vvNew is serialized, but only used if ADDRMAN_UNKOWN_BUCKET_COUNT didn't change,\n+     * otherwise it is reconstructed as well.\n+     *\n+     * This format is more complex, but significantly smaller (at most 1.5 MiB), and supports\n+     * changes to the ADDRMAN_ parameters without breaking the on-disk structure.\n+     *\n+     * We don't use ADD_SERIALIZE_METHODS since the serialization and deserialization code has\n+     * very little in common.\n+     *\n+     */\n     template<typename Stream>\n     void Serialize(Stream &s, int nType, int nVersionDummy) const\n     {\n@@ -394,13 +401,13 @@ class CAddrMan\n          nNew = 0;\n     }\n \n-    // Return the number of (unique) addresses in all tables.\n+    //! Return the number of (unique) addresses in all tables.\n     int size()\n     {\n         return vRandom.size();\n     }\n \n-    // Consistency check\n+    //! Consistency check\n     void Check()\n     {\n #ifdef DEBUG_ADDRMAN\n@@ -413,7 +420,7 @@ class CAddrMan\n #endif\n     }\n \n-    // Add a single address.\n+    //! Add a single address.\n     bool Add(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty = 0)\n     {\n         bool fRet = false;\n@@ -428,7 +435,7 @@ class CAddrMan\n         return fRet;\n     }\n \n-    // Add multiple addresses.\n+    //! Add multiple addresses.\n     bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0)\n     {\n         int nAdd = 0;\n@@ -444,7 +451,7 @@ class CAddrMan\n         return nAdd > 0;\n     }\n \n-    // Mark an entry as accessible.\n+    //! Mark an entry as accessible.\n     void Good(const CService &addr, int64_t nTime = GetAdjustedTime())\n     {\n         {\n@@ -455,7 +462,7 @@ class CAddrMan\n         }\n     }\n \n-    // Mark an entry as connection attempted to.\n+    //! Mark an entry as connection attempted to.\n     void Attempt(const CService &addr, int64_t nTime = GetAdjustedTime())\n     {\n         {\n@@ -466,8 +473,10 @@ class CAddrMan\n         }\n     }\n \n-    // Choose an address to connect to.\n-    // nUnkBias determines how much \"new\" entries are favored over \"tried\" ones (0-100).\n+    /**\n+     * Choose an address to connect to.\n+     * nUnkBias determines how much \"new\" entries are favored over \"tried\" ones (0-100).\n+     */\n     CAddress Select(int nUnkBias = 50)\n     {\n         CAddress addrRet;\n@@ -480,7 +489,7 @@ class CAddrMan\n         return addrRet;\n     }\n \n-    // Return a bunch of addresses, selected at random.\n+    //! Return a bunch of addresses, selected at random.\n     std::vector<CAddress> GetAddr()\n     {\n         Check();\n@@ -493,7 +502,7 @@ class CAddrMan\n         return vAddr;\n     }\n \n-    // Mark an entry as currently-connected-to.\n+    //! Mark an entry as currently-connected-to.\n     void Connected(const CService &addr, int64_t nTime = GetAdjustedTime())\n     {\n         {"
      }
    ]
  }
]