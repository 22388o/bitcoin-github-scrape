[
  {
    "sha": "52e15aa4d067fc4ace12c80be5c82e85c04fcfec",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MmUxNWFhNGQwNjdmYzRhY2UxMmM4MGJlNWM4MmU4NWMwNGZjZmVj",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-03-29T18:07:39Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-04-18T19:25:01Z"
      },
      "message": "Adds helper functions to NodeConnCB\n\nThis commit adds some helper functions to NodeConnCB which are useful\nfor many tests:\n\n- NodeConnCB now keeps track of the number of each message type that\nit's received and the most recent message of each type. Many tests\nassert on the most recent block, tx or reject message.\n- NodeConnCB now keeps track of its connection state by setting a\nconnected boolean in on_open() and on_close()\n- NodeConnCB now has wait_for_block, wait_for_getdata,\nwait_for_getheaders, wait_for_inv and wait_for_verack methods\n\nI have updated the individual test cases to make sure that there are no\nnamespace problems that cause them to fail with these new definitions.\nFuture commits will remove the duplicate code.",
      "tree": {
        "sha": "a8cc190981446a60e8c0189890cd986e8287cbc8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a8cc190981446a60e8c0189890cd986e8287cbc8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/52e15aa4d067fc4ace12c80be5c82e85c04fcfec",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/52e15aa4d067fc4ace12c80be5c82e85c04fcfec",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/52e15aa4d067fc4ace12c80be5c82e85c04fcfec",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/52e15aa4d067fc4ace12c80be5c82e85c04fcfec/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2584925077f9658b3953ad931b74779006e59807",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2584925077f9658b3953ad931b74779006e59807",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2584925077f9658b3953ad931b74779006e59807"
      }
    ],
    "stats": {
      "total": 185,
      "additions": 107,
      "deletions": 78
    },
    "files": [
      {
        "sha": "696933512e890486c5cf7ddbdbbd13eabc4af751",
        "filename": "test/functional/maxuploadtarget.py",
        "status": "modified",
        "additions": 0,
        "deletions": 9,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52e15aa4d067fc4ace12c80be5c82e85c04fcfec/test/functional/maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52e15aa4d067fc4ace12c80be5c82e85c04fcfec/test/functional/maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/maxuploadtarget.py?ref=52e15aa4d067fc4ace12c80be5c82e85c04fcfec",
        "patch": "@@ -44,15 +44,6 @@ def on_block(self, conn, message):\n         except KeyError as e:\n             self.block_receive_map[message.block.sha256] = 1\n \n-    # Spin until verack message is received from the node.\n-    # We use this to signal that our test can begin. This\n-    # is called from the testing thread, so it needs to acquire\n-    # the global lock.\n-    def wait_for_verack(self):\n-        def veracked():\n-            return self.verack_received\n-        return wait_until(veracked, timeout=10)\n-\n     def wait_for_disconnect(self):\n         def disconnected():\n             return self.peer_disconnected"
      },
      {
        "sha": "e2aad3f1d1ce21ab5786bb1e0d13b469326618c7",
        "filename": "test/functional/p2p-acceptblock.py",
        "status": "modified",
        "additions": 0,
        "deletions": 11,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52e15aa4d067fc4ace12c80be5c82e85c04fcfec/test/functional/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52e15aa4d067fc4ace12c80be5c82e85c04fcfec/test/functional/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-acceptblock.py?ref=52e15aa4d067fc4ace12c80be5c82e85c04fcfec",
        "patch": "@@ -70,17 +70,6 @@ def add_connection(self, conn):\n     def on_getdata(self, conn, message):\n         self.last_getdata = message\n \n-    # Spin until verack message is received from the node.\n-    # We use this to signal that our test can begin. This\n-    # is called from the testing thread, so it needs to acquire\n-    # the global lock.\n-    def wait_for_verack(self):\n-        while True:\n-            with mininode_lock:\n-                if self.verack_received:\n-                    return\n-            time.sleep(0.05)\n-\n     # Wrapper for the NodeConn's send_message function\n     def send_message(self, message):\n         self.connection.send_message(message)"
      },
      {
        "sha": "2423d4a9692bbb35007a5175fea62b7007530fbb",
        "filename": "test/functional/p2p-leaktests.py",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52e15aa4d067fc4ace12c80be5c82e85c04fcfec/test/functional/p2p-leaktests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52e15aa4d067fc4ace12c80be5c82e85c04fcfec/test/functional/p2p-leaktests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-leaktests.py?ref=52e15aa4d067fc4ace12c80be5c82e85c04fcfec",
        "patch": "@@ -23,6 +23,7 @@ def __init__(self):\n         self.connection = None\n         self.unexpected_msg = False\n         self.connected = False\n+        self.ever_connected = False\n \n     def add_connection(self, conn):\n         self.connection = conn\n@@ -36,6 +37,7 @@ def bad_message(self, message):\n \n     def on_open(self, conn):\n         self.connected = True\n+        self.ever_connected = True\n \n     def on_version(self, conn, message): self.bad_message(message)\n     def on_verack(self, conn, message): self.bad_message(message)\n@@ -121,7 +123,9 @@ def run_test(self):\n \n         NetworkThread().start()  # Start up network handling in another thread\n \n-        assert(wait_until(lambda: no_version_bannode.connected and no_version_idlenode.connected and no_verack_idlenode.version_received, timeout=10))\n+        assert wait_until(lambda: no_version_bannode.ever_connected, timeout=10)\n+        assert wait_until(lambda: no_version_idlenode.ever_connected, timeout=10)\n+        assert wait_until(lambda: no_verack_idlenode.version_received, timeout=10)\n \n         # Mine a block and make sure that it's not sent to the connected nodes\n         self.nodes[0].generate(1)\n@@ -130,7 +134,7 @@ def run_test(self):\n         time.sleep(5)\n \n         #This node should have been banned\n-        assert(no_version_bannode.connection.state == \"closed\")\n+        assert not no_version_bannode.connected\n \n         [conn.disconnect_node() for conn in connections]\n "
      },
      {
        "sha": "c17af173c7dbbd67479dba444c6c774d9413c168",
        "filename": "test/functional/p2p-mempool.py",
        "status": "modified",
        "additions": 0,
        "deletions": 9,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52e15aa4d067fc4ace12c80be5c82e85c04fcfec/test/functional/p2p-mempool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52e15aa4d067fc4ace12c80be5c82e85c04fcfec/test/functional/p2p-mempool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-mempool.py?ref=52e15aa4d067fc4ace12c80be5c82e85c04fcfec",
        "patch": "@@ -38,15 +38,6 @@ def on_block(self, conn, message):\n         except KeyError as e:\n             self.block_receive_map[message.block.sha256] = 1\n \n-    # Spin until verack message is received from the node.\n-    # We use this to signal that our test can begin. This\n-    # is called from the testing thread, so it needs to acquire\n-    # the global lock.\n-    def wait_for_verack(self):\n-        def veracked():\n-            return self.verack_received\n-        return wait_until(veracked, timeout=10)\n-\n     def wait_for_disconnect(self):\n         def disconnected():\n             return self.peer_disconnected"
      },
      {
        "sha": "cb9a938f940072b421e489279f1e296439b40038",
        "filename": "test/functional/test_framework/comptool.py",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52e15aa4d067fc4ace12c80be5c82e85c04fcfec/test/functional/test_framework/comptool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52e15aa4d067fc4ace12c80be5c82e85c04fcfec/test/functional/test_framework/comptool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/comptool.py?ref=52e15aa4d067fc4ace12c80be5c82e85c04fcfec",
        "patch": "@@ -192,9 +192,7 @@ def disconnected():\n         return wait_until(disconnected, timeout=10)\n \n     def wait_for_verack(self):\n-        def veracked():\n-            return all(node.verack_received for node in self.test_nodes)\n-        return wait_until(veracked, timeout=10)\n+        [node.wait_for_verack() for node in self.test_nodes]\n \n     def wait_for_pings(self, counter):\n         def received_pongs():"
      },
      {
        "sha": "3b4d05df6c75bd97c01d87f68e22576aba5c9e1f",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 100,
        "deletions": 44,
        "changes": 144,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52e15aa4d067fc4ace12c80be5c82e85c04fcfec/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52e15aa4d067fc4ace12c80be5c82e85c04fcfec/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=52e15aa4d067fc4ace12c80be5c82e85c04fcfec",
        "patch": "@@ -20,21 +20,22 @@\n ser_*, deser_*: functions that handle serialization/deserialization\n \"\"\"\n \n-import struct\n-import socket\n import asyncore\n-import time\n-import sys\n-import random\n-from .util import hex_str_to_bytes, bytes_to_hex_str\n-from io import BytesIO\n from codecs import encode\n+from collections import defaultdict\n+import copy\n import hashlib\n-from threading import RLock\n-from threading import Thread\n+from io import BytesIO\n import logging\n-import copy\n+import random\n+import socket\n+import struct\n+import sys\n+import time\n+from threading import RLock, Thread\n+\n from test_framework.siphash import siphash256\n+from test_framework.util import hex_str_to_bytes, bytes_to_hex_str\n \n BIP0031_VERSION = 60000\n MY_VERSION = 70014  # past bip-31 for ping/pong\n@@ -1465,30 +1466,57 @@ def serialize(self):\n         r += self.block_transactions.serialize(with_witness=True)\n         return r\n \n-# This is what a callback should look like for NodeConn\n-# Reimplement the on_* functions to provide handling for events\n class NodeConnCB(object):\n+    \"\"\"Callback and helper functions for P2P connection to a bitcoind node.\n+\n+    Individual testcases should subclass this and override the on_* methods\n+    if they want to alter message handling behaviour.\n+    \"\"\"\n+\n     def __init__(self):\n-        self.verack_received = False\n+        # Track whether we have a P2P connection open to the node\n+        self.connected = False\n+        self.connection = None\n+\n+        # Track number of messages of each type received and the most recent\n+        # message of each type\n+        self.message_count = defaultdict(int)\n+        self.last_message = {}\n+\n+        # A count of the number of ping messages we've sent to the node\n+        self.ping_counter = 1\n+\n         # deliver_sleep_time is helpful for debugging race conditions in p2p\n         # tests; it causes message delivery to sleep for the specified time\n         # before acquiring the global lock and delivering the next message.\n         self.deliver_sleep_time = None\n+\n         # Remember the services our peer has advertised\n         self.peer_services = None\n-        self.connection = None\n-        self.ping_counter = 1\n-        self.last_pong = msg_pong()\n+\n+    # Message receiving methods\n \n     def deliver(self, conn, message):\n+        \"\"\"Receive message and dispatch message to appropriate callback.\n+\n+        We keep a count of how many of each message type has been received\n+        and the most recent message of each type.\n+\n+        Optionally waits for deliver_sleep_time before dispatching message.\n+        \"\"\"\n+\n         deliver_sleep = self.get_deliver_sleep_time()\n         if deliver_sleep is not None:\n             time.sleep(deliver_sleep)\n         with mininode_lock:\n             try:\n-                getattr(self, 'on_' + message.command.decode('ascii'))(conn, message)\n+                command = message.command.decode('ascii')\n+                self.message_count[command] += 1\n+                self.last_message[command] = message\n+                getattr(self, 'on_' + command)(conn, message)\n             except:\n-                logger.exception(\"ERROR delivering %s\" % repr(message))\n+                print(\"ERROR delivering %s (%s)\" % (repr(message),\n+                                                    sys.exc_info()[0]))\n \n     def set_deliver_sleep_time(self, value):\n         with mininode_lock:\n@@ -1498,14 +1526,20 @@ def get_deliver_sleep_time(self):\n         with mininode_lock:\n             return self.deliver_sleep_time\n \n-    # Callbacks which can be overridden by subclasses\n-    #################################################\n+    # Callback methods. Can be overridden by subclasses in individual test\n+    # cases to provide custom message handling behaviour.\n+\n+    def on_open(self, conn):\n+        self.connected = True\n+\n+    def on_close(self, conn):\n+        self.connected = False\n+        self.connection = None\n \n     def on_addr(self, conn, message): pass\n     def on_alert(self, conn, message): pass\n     def on_block(self, conn, message): pass\n     def on_blocktxn(self, conn, message): pass\n-    def on_close(self, conn): pass\n     def on_cmpctblock(self, conn, message): pass\n     def on_feefilter(self, conn, message): pass\n     def on_getaddr(self, conn, message): pass\n@@ -1515,7 +1549,7 @@ def on_getdata(self, conn, message): pass\n     def on_getheaders(self, conn, message): pass\n     def on_headers(self, conn, message): pass\n     def on_mempool(self, conn): pass\n-    def on_open(self, conn): pass\n+    def on_pong(self, conn, message): pass\n     def on_reject(self, conn, message): pass\n     def on_sendcmpct(self, conn, message): pass\n     def on_sendheaders(self, conn, message): pass\n@@ -1533,9 +1567,6 @@ def on_ping(self, conn, message):\n         if conn.ver_send > BIP0031_VERSION:\n             conn.send_message(msg_pong(message.nonce))\n \n-    def on_pong(self, conn, message):\n-        self.last_pong = message\n-\n     def on_verack(self, conn, message):\n         conn.ver_recv = conn.ver_send\n         self.verack_received = True\n@@ -1548,44 +1579,69 @@ def on_version(self, conn, message):\n             conn.ver_recv = conn.ver_send\n         conn.nServices = message.nServices\n \n-    # Helper functions\n-    ##################\n+    # Connection helper methods\n \n     def add_connection(self, conn):\n         self.connection = conn\n \n-    # Wrapper for the NodeConn's send_message function\n+    def wait_for_disconnect(self, timeout=60):\n+        test_function = lambda: not self.connected\n+        assert wait_until(test_function, timeout=timeout)\n+\n+    # Message receiving helper methods\n+\n+    def sync(self, test_function, timeout=60):\n+        while timeout > 0:\n+            with mininode_lock:\n+                if test_function():\n+                    return\n+            time.sleep(0.05)\n+            timeout -= 0.05\n+        raise AssertionError(\"Sync failed to complete\")\n+\n+    def wait_for_block(self, blockhash, timeout=60):\n+        test_function = lambda: self.last_message.get(\"block\") and self.last_message[\"block\"].block.rehash() == blockhash\n+        self.sync(test_function, timeout)\n+\n+    def wait_for_getdata(self, timeout=60):\n+        test_function = lambda: self.last_message.get(\"getdata\")\n+        self.sync(test_function, timeout)\n+\n+    def wait_for_getheaders(self, timeout=60):\n+        test_function = lambda: self.last_message.get(\"getheaders\")\n+        self.sync(test_function, timeout)\n+\n+    def wait_for_inv(self, expected_inv, timeout=60):\n+        test_function = lambda: self.last_message.get(\"inv\") and self.last_message[\"inv\"] != expected_inv\n+        self.sync(test_function, timeout)\n+\n+    def wait_for_verack(self, timeout=60):\n+        test_function = lambda: self.message_count[\"verack\"]\n+        self.sync(test_function, timeout)\n+\n+    # Message sending helper functions\n+\n     def send_message(self, message):\n-        self.connection.send_message(message)\n+        if self.connection:\n+            self.connection.send_message(message)\n+        else:\n+            logger.error(\"Cannot send message. No connection to node!\")\n \n     def send_and_ping(self, message):\n         self.send_message(message)\n         self.sync_with_ping()\n \n     # Sync up with the node\n     def sync_with_ping(self, timeout=60):\n-        def received_pong():\n-            return (self.last_pong.nonce == self.ping_counter)\n         self.send_message(msg_ping(nonce=self.ping_counter))\n-        success = wait_until(received_pong, timeout=timeout)\n+        test_function = lambda: self.last_message.get(\"pong\") and self.last_message[\"pong\"].nonce == self.ping_counter\n+        success = wait_until(test_function, timeout = timeout)\n         if not success:\n             logger.error(\"sync_with_ping failed!\")\n             raise AssertionError(\"sync_with_ping failed!\")\n         self.ping_counter += 1\n-\n         return success\n \n-    # Spin until verack message is received from the node.\n-    # Tests may want to use this as a signal that the test can begin.\n-    # This can be called from the testing thread, so it needs to acquire the\n-    # global lock.\n-    def wait_for_verack(self):\n-        while True:\n-            with mininode_lock:\n-                if self.verack_received:\n-                    return\n-            time.sleep(0.05)\n-\n # The actual NodeConn class\n # This class provides an interface for a p2p connection to a specified node\n class NodeConn(asyncore.dispatcher):"
      }
    ]
  },
  {
    "sha": "2a52ae63bfdde948250df1c876dcdd5af99f03b5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYTUyYWU2M2JmZGRlOTQ4MjUwZGYxYzg3NmRjZGQ1YWY5OWYwM2I1",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-03-30T12:38:46Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-04-18T21:20:09Z"
      },
      "message": "Remove duplicate method definitions in NodeConnCB subclasses\n\nAll Node classes in individual test cases subclass from NodeConnCB. Many\nhave duplicate definitions for methods that are defined in the base\nclass. This commit removes those duplicate definitions.\n\nThis commit removes ~290 lines of duplicate code.",
      "tree": {
        "sha": "d53a338b3c6c9eba1474330412dd0e5953822399",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d53a338b3c6c9eba1474330412dd0e5953822399"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2a52ae63bfdde948250df1c876dcdd5af99f03b5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a52ae63bfdde948250df1c876dcdd5af99f03b5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2a52ae63bfdde948250df1c876dcdd5af99f03b5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a52ae63bfdde948250df1c876dcdd5af99f03b5/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "52e15aa4d067fc4ace12c80be5c82e85c04fcfec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/52e15aa4d067fc4ace12c80be5c82e85c04fcfec",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/52e15aa4d067fc4ace12c80be5c82e85c04fcfec"
      }
    ],
    "stats": {
      "total": 595,
      "additions": 144,
      "deletions": 451
    },
    "files": [
      {
        "sha": "b38fdc0f889a3c580236aaa06b7f42356347ec79",
        "filename": "test/functional/maxuploadtarget.py",
        "status": "modified",
        "additions": 15,
        "deletions": 52,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/maxuploadtarget.py?ref=2a52ae63bfdde948250df1c876dcdd5af99f03b5",
        "patch": "@@ -10,54 +10,24 @@\n if uploadtarget has been reached.\n * Verify that the upload counters are reset after 24 hours.\n \"\"\"\n+from collections import defaultdict\n+import time\n \n from test_framework.mininode import *\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n-import time\n \n-# TestNode: bare-bones \"peer\".  Used mostly as a conduit for a test to sending\n-# p2p messages to a node, generating the messages in the main testing logic.\n class TestNode(NodeConnCB):\n     def __init__(self):\n         super().__init__()\n-        self.connection = None\n-        self.ping_counter = 1\n-        self.last_pong = msg_pong()\n-        self.block_receive_map = {}\n-\n-    def add_connection(self, conn):\n-        self.connection = conn\n-        self.peer_disconnected = False\n+        self.block_receive_map = defaultdict(int)\n \n     def on_inv(self, conn, message):\n         pass\n \n-    # Track the last getdata message we receive (used in the test)\n-    def on_getdata(self, conn, message):\n-        self.last_getdata = message\n-\n     def on_block(self, conn, message):\n         message.block.calc_sha256()\n-        try:\n-            self.block_receive_map[message.block.sha256] += 1\n-        except KeyError as e:\n-            self.block_receive_map[message.block.sha256] = 1\n-\n-    def wait_for_disconnect(self):\n-        def disconnected():\n-            return self.peer_disconnected\n-        return wait_until(disconnected, timeout=10)\n-\n-    # Wrapper for the NodeConn's send_message function\n-    def send_message(self, message):\n-        self.connection.send_message(message)\n-\n-    def on_pong(self, conn, message):\n-        self.last_pong = message\n-\n-    def on_close(self, conn):\n-        self.peer_disconnected = True\n+        self.block_receive_map[message.block.sha256] += 1\n \n class MaxUploadTest(BitcoinTestFramework):\n  \n@@ -183,33 +153,26 @@ def run_test(self):\n         stop_node(self.nodes[0], 0)\n         self.nodes[0] = start_node(0, self.options.tmpdir, [\"-whitelist=127.0.0.1\", \"-maxuploadtarget=1\", \"-blockmaxsize=999000\"])\n \n-        #recreate/reconnect 3 test nodes\n-        test_nodes = []\n-        connections = []\n-\n-        for i in range(3):\n-            test_nodes.append(TestNode())\n-            connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_nodes[i]))\n-            test_nodes[i].add_connection(connections[i])\n+        #recreate/reconnect a test node\n+        test_nodes = [TestNode()]\n+        connections = [NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_nodes[0])]\n+        test_nodes[0].add_connection(connections[0])\n \n         NetworkThread().start() # Start up network handling in another thread\n-        [x.wait_for_verack() for x in test_nodes]\n+        test_nodes[0].wait_for_verack()\n \n         #retrieve 20 blocks which should be enough to break the 1MB limit\n         getdata_request.inv = [CInv(2, big_new_block)]\n         for i in range(20):\n-            test_nodes[1].send_message(getdata_request)\n-            test_nodes[1].sync_with_ping()\n-            assert_equal(test_nodes[1].block_receive_map[big_new_block], i+1)\n+            test_nodes[0].send_message(getdata_request)\n+            test_nodes[0].sync_with_ping()\n+            assert_equal(test_nodes[0].block_receive_map[big_new_block], i+1)\n \n         getdata_request.inv = [CInv(2, big_old_block)]\n-        test_nodes[1].send_message(getdata_request)\n-        test_nodes[1].wait_for_disconnect()\n-        assert_equal(len(self.nodes[0].getpeerinfo()), 3) #node is still connected because of the whitelist\n-\n-        self.log.info(\"Peer 1 still connected after trying to download old block (whitelisted)\")\n+        test_nodes[0].send_and_ping(getdata_request)\n+        assert_equal(len(self.nodes[0].getpeerinfo()), 1) #node is still connected because of the whitelist\n \n-        [c.disconnect_node() for c in connections]\n+        self.log.info(\"Peer still connected after trying to download old block (whitelisted)\")\n \n if __name__ == '__main__':\n     MaxUploadTest().main()"
      },
      {
        "sha": "01d621a53ad9b627273f85eae9f1242e7d800706",
        "filename": "test/functional/p2p-acceptblock.py",
        "status": "modified",
        "additions": 4,
        "deletions": 27,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-acceptblock.py?ref=2a52ae63bfdde948250df1c876dcdd5af99f03b5",
        "patch": "@@ -54,29 +54,6 @@\n import time\n from test_framework.blocktools import create_block, create_coinbase\n \n-# TestNode: bare-bones \"peer\".  Used mostly as a conduit for a test to sending\n-# p2p messages to a node, generating the messages in the main testing logic.\n-class TestNode(NodeConnCB):\n-    def __init__(self):\n-        super().__init__()\n-        self.connection = None\n-        self.ping_counter = 1\n-        self.last_pong = msg_pong()\n-\n-    def add_connection(self, conn):\n-        self.connection = conn\n-\n-    # Track the last getdata message we receive (used in the test)\n-    def on_getdata(self, conn, message):\n-        self.last_getdata = message\n-\n-    # Wrapper for the NodeConn's send_message function\n-    def send_message(self, message):\n-        self.connection.send_message(message)\n-\n-    def on_pong(self, conn, message):\n-        self.last_pong = message\n-\n class AcceptBlockTest(BitcoinTestFramework):\n     def add_options(self, parser):\n         parser.add_option(\"--testbinary\", dest=\"testbinary\",\n@@ -101,8 +78,8 @@ def setup_network(self):\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n-        test_node = TestNode()   # connects to node0 (not whitelisted)\n-        white_node = TestNode()  # connects to node1 (whitelisted)\n+        test_node = NodeConnCB()   # connects to node0 (not whitelisted)\n+        white_node = NodeConnCB()  # connects to node1 (whitelisted)\n \n         connections = []\n         connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node))\n@@ -227,12 +204,12 @@ def run_test(self):\n         # triggers a getdata on block 2 (it should if block 2 is missing).\n         with mininode_lock:\n             # Clear state so we can check the getdata request\n-            test_node.last_getdata = None\n+            test_node.last_message.pop(\"getdata\", None)\n             test_node.send_message(msg_inv([CInv(2, blocks_h3[0].sha256)]))\n \n         test_node.sync_with_ping()\n         with mininode_lock:\n-            getdata = test_node.last_getdata\n+            getdata = test_node.last_message[\"getdata\"]\n \n         # Check that the getdata includes the right block\n         assert_equal(getdata.inv[0].hash, blocks_h2f[0].sha256)"
      },
      {
        "sha": "cf9608a6570a827740a9d9f279944e327d0790e7",
        "filename": "test/functional/p2p-compactblocks.py",
        "status": "modified",
        "additions": 65,
        "deletions": 99,
        "changes": 164,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-compactblocks.py?ref=2a52ae63bfdde948250df1c876dcdd5af99f03b5",
        "patch": "@@ -19,64 +19,31 @@ class TestNode(NodeConnCB):\n     def __init__(self):\n         super().__init__()\n         self.last_sendcmpct = []\n-        self.last_headers = None\n-        self.last_inv = None\n-        self.last_cmpctblock = None\n         self.block_announced = False\n-        self.last_getdata = None\n-        self.last_getheaders = None\n-        self.last_getblocktxn = None\n-        self.last_block = None\n-        self.last_blocktxn = None\n         # Store the hashes of blocks we've seen announced.\n         # This is for synchronizing the p2p message traffic,\n         # so we can eg wait until a particular block is announced.\n-        self.set_announced_blockhashes = set()\n-        self.connected = False\n-\n-    def on_open(self, conn):\n-        self.connected = True\n-\n-    def on_close(self, conn):\n-        self.connected = False\n+        self.announced_blockhashes = set()\n \n     def on_sendcmpct(self, conn, message):\n         self.last_sendcmpct.append(message)\n \n-    def on_block(self, conn, message):\n-        self.last_block = message\n-\n     def on_cmpctblock(self, conn, message):\n-        self.last_cmpctblock = message\n         self.block_announced = True\n-        self.last_cmpctblock.header_and_shortids.header.calc_sha256()\n-        self.set_announced_blockhashes.add(self.last_cmpctblock.header_and_shortids.header.sha256)\n+        self.last_message[\"cmpctblock\"].header_and_shortids.header.calc_sha256()\n+        self.announced_blockhashes.add(self.last_message[\"cmpctblock\"].header_and_shortids.header.sha256)\n \n     def on_headers(self, conn, message):\n-        self.last_headers = message\n         self.block_announced = True\n-        for x in self.last_headers.headers:\n+        for x in self.last_message[\"headers\"].headers:\n             x.calc_sha256()\n-            self.set_announced_blockhashes.add(x.sha256)\n+            self.announced_blockhashes.add(x.sha256)\n \n     def on_inv(self, conn, message):\n-        self.last_inv = message\n-        for x in self.last_inv.inv:\n+        for x in self.last_message[\"inv\"].inv:\n             if x.type == 2:\n                 self.block_announced = True\n-                self.set_announced_blockhashes.add(x.hash)\n-\n-    def on_getdata(self, conn, message):\n-        self.last_getdata = message\n-\n-    def on_getheaders(self, conn, message):\n-        self.last_getheaders = message\n-\n-    def on_getblocktxn(self, conn, message):\n-        self.last_getblocktxn = message\n-\n-    def on_blocktxn(self, conn, message):\n-        self.last_blocktxn = message\n+                self.announced_blockhashes.add(x.hash)\n \n     # Requires caller to hold mininode_lock\n     def received_block_announcement(self):\n@@ -85,9 +52,9 @@ def received_block_announcement(self):\n     def clear_block_announcement(self):\n         with mininode_lock:\n             self.block_announced = False\n-            self.last_inv = None\n-            self.last_headers = None\n-            self.last_cmpctblock = None\n+            self.last_message.pop(\"inv\", None)\n+            self.last_message.pop(\"headers\", None)\n+            self.last_message.pop(\"cmpctblock\", None)\n \n     def get_headers(self, locator, hashstop):\n         msg = msg_getheaders()\n@@ -103,15 +70,14 @@ def send_header_for_blocks(self, new_blocks):\n     def request_headers_and_sync(self, locator, hashstop=0):\n         self.clear_block_announcement()\n         self.get_headers(locator, hashstop)\n-        assert(wait_until(self.received_block_announcement, timeout=30))\n-        assert(self.received_block_announcement())\n+        assert wait_until(self.received_block_announcement, timeout=30)\n         self.clear_block_announcement()\n \n     # Block until a block announcement for a particular block hash is\n     # received.\n     def wait_for_block_announcement(self, block_hash, timeout=30):\n         def received_hash():\n-            return (block_hash in self.set_announced_blockhashes)\n+            return (block_hash in self.announced_blockhashes)\n         return wait_until(received_hash, timeout=timeout)\n \n     def send_await_disconnect(self, message, timeout=30):\n@@ -214,14 +180,14 @@ def check_announcement_of_new_block(node, peer, predicate):\n             with mininode_lock:\n                 assert predicate(peer), (\n                     \"block_hash={!r}, cmpctblock={!r}, inv={!r}\".format(\n-                        block_hash, peer.last_cmpctblock, peer.last_inv))\n+                        block_hash, peer.last_message.get(\"cmpctblock\", None), peer.last_message.get(\"inv\", None)))\n \n         # We shouldn't get any block announcements via cmpctblock yet.\n-        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is None)\n+        check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" not in p.last_message)\n \n         # Try one more time, this time after requesting headers.\n         test_node.request_headers_and_sync(locator=[tip])\n-        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is None and p.last_inv is not None)\n+        check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" not in p.last_message and \"inv\" in p.last_message)\n \n         # Test a few ways of using sendcmpct that should NOT\n         # result in compact block announcements.\n@@ -233,7 +199,7 @@ def check_announcement_of_new_block(node, peer, predicate):\n         sendcmpct.version = preferred_version+1\n         sendcmpct.announce = True\n         test_node.send_and_ping(sendcmpct)\n-        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is None)\n+        check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" not in p.last_message)\n \n         # Headers sync before next test.\n         test_node.request_headers_and_sync(locator=[tip])\n@@ -242,7 +208,7 @@ def check_announcement_of_new_block(node, peer, predicate):\n         sendcmpct.version = preferred_version\n         sendcmpct.announce = False\n         test_node.send_and_ping(sendcmpct)\n-        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is None)\n+        check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" not in p.last_message)\n \n         # Headers sync before next test.\n         test_node.request_headers_and_sync(locator=[tip])\n@@ -251,26 +217,26 @@ def check_announcement_of_new_block(node, peer, predicate):\n         sendcmpct.version = preferred_version\n         sendcmpct.announce = True\n         test_node.send_and_ping(sendcmpct)\n-        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is not None)\n+        check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" in p.last_message)\n \n         # Try one more time (no headers sync should be needed!)\n-        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is not None)\n+        check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" in p.last_message)\n \n         # Try one more time, after turning on sendheaders\n         test_node.send_and_ping(msg_sendheaders())\n-        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is not None)\n+        check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" in p.last_message)\n \n         # Try one more time, after sending a version-1, announce=false message.\n         sendcmpct.version = preferred_version-1\n         sendcmpct.announce = False\n         test_node.send_and_ping(sendcmpct)\n-        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is not None)\n+        check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" in p.last_message)\n \n         # Now turn off announcements\n         sendcmpct.version = preferred_version\n         sendcmpct.announce = False\n         test_node.send_and_ping(sendcmpct)\n-        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is None and p.last_headers is not None)\n+        check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" not in p.last_message and \"headers\" in p.last_message)\n \n         if old_node is not None:\n             # Verify that a peer using an older protocol version can receive\n@@ -280,7 +246,7 @@ def check_announcement_of_new_block(node, peer, predicate):\n             old_node.send_and_ping(sendcmpct)\n             # Header sync\n             old_node.request_headers_and_sync(locator=[tip])\n-            check_announcement_of_new_block(node, old_node, lambda p: p.last_cmpctblock is not None)\n+            check_announcement_of_new_block(node, old_node, lambda p: \"cmpctblock\" in p.last_message)\n \n     # This test actually causes bitcoind to (reasonably!) disconnect us, so do this last.\n     def test_invalid_cmpctblock_message(self):\n@@ -345,9 +311,9 @@ def test_compactblock_construction(self, node, test_node, version, use_witness_a\n         # Now fetch and check the compact block\n         header_and_shortids = None\n         with mininode_lock:\n-            assert(test_node.last_cmpctblock is not None)\n+            assert(\"cmpctblock\" in test_node.last_message)\n             # Convert the on-the-wire representation to absolute indexes\n-            header_and_shortids = HeaderAndShortIDs(test_node.last_cmpctblock.header_and_shortids)\n+            header_and_shortids = HeaderAndShortIDs(test_node.last_message[\"cmpctblock\"].header_and_shortids)\n         self.check_compactblock_construction_from_block(version, header_and_shortids, block_hash, block)\n \n         # Now fetch the compact block using a normal non-announce getdata\n@@ -362,9 +328,9 @@ def test_compactblock_construction(self, node, test_node, version, use_witness_a\n         # Now fetch and check the compact block\n         header_and_shortids = None\n         with mininode_lock:\n-            assert(test_node.last_cmpctblock is not None)\n+            assert(\"cmpctblock\" in test_node.last_message)\n             # Convert the on-the-wire representation to absolute indexes\n-            header_and_shortids = HeaderAndShortIDs(test_node.last_cmpctblock.header_and_shortids)\n+            header_and_shortids = HeaderAndShortIDs(test_node.last_message[\"cmpctblock\"].header_and_shortids)\n         self.check_compactblock_construction_from_block(version, header_and_shortids, block_hash, block)\n \n     def check_compactblock_construction_from_block(self, version, header_and_shortids, block_hash, block):\n@@ -424,20 +390,20 @@ def test_compactblock_requests(self, node, test_node, version, segwit):\n         for announce in [\"inv\", \"header\"]:\n             block = self.build_block_on_tip(node, segwit=segwit)\n             with mininode_lock:\n-                test_node.last_getdata = None\n+                test_node.last_message.pop(\"getdata\", None)\n \n             if announce == \"inv\":\n                 test_node.send_message(msg_inv([CInv(2, block.sha256)]))\n-                success = wait_until(lambda: test_node.last_getheaders is not None, timeout=30)\n+                success = wait_until(lambda: \"getheaders\" in test_node.last_message, timeout=30)\n                 assert(success)\n                 test_node.send_header_for_blocks([block])\n             else:\n                 test_node.send_header_for_blocks([block])\n-            success = wait_until(lambda: test_node.last_getdata is not None, timeout=30)\n+            success = wait_until(lambda: \"getdata\" in test_node.last_message, timeout=30)\n             assert(success)\n-            assert_equal(len(test_node.last_getdata.inv), 1)\n-            assert_equal(test_node.last_getdata.inv[0].type, 4)\n-            assert_equal(test_node.last_getdata.inv[0].hash, block.sha256)\n+            assert_equal(len(test_node.last_message[\"getdata\"].inv), 1)\n+            assert_equal(test_node.last_message[\"getdata\"].inv[0].type, 4)\n+            assert_equal(test_node.last_message[\"getdata\"].inv[0].hash, block.sha256)\n \n             # Send back a compactblock message that omits the coinbase\n             comp_block = HeaderAndShortIDs()\n@@ -453,8 +419,8 @@ def test_compactblock_requests(self, node, test_node, version, segwit):\n             assert_equal(int(node.getbestblockhash(), 16), block.hashPrevBlock)\n             # Expect a getblocktxn message.\n             with mininode_lock:\n-                assert(test_node.last_getblocktxn is not None)\n-                absolute_indexes = test_node.last_getblocktxn.block_txn_request.to_absolute()\n+                assert(\"getblocktxn\" in test_node.last_message)\n+                absolute_indexes = test_node.last_message[\"getblocktxn\"].block_txn_request.to_absolute()\n             assert_equal(absolute_indexes, [0])  # should be a coinbase request\n \n             # Send the coinbase, and verify that the tip advances.\n@@ -493,8 +459,8 @@ def test_getblocktxn_response(compact_block, peer, expected_result):\n             msg = msg_cmpctblock(compact_block.to_p2p())\n             peer.send_and_ping(msg)\n             with mininode_lock:\n-                assert(peer.last_getblocktxn is not None)\n-                absolute_indexes = peer.last_getblocktxn.block_txn_request.to_absolute()\n+                assert(\"getblocktxn\" in peer.last_message)\n+                absolute_indexes = peer.last_message[\"getblocktxn\"].block_txn_request.to_absolute()\n             assert_equal(absolute_indexes, expected_result)\n \n         def test_tip_after_message(node, peer, msg, tip):\n@@ -558,14 +524,14 @@ def test_tip_after_message(node, peer, msg, tip):\n \n         # Clear out last request.\n         with mininode_lock:\n-            test_node.last_getblocktxn = None\n+            test_node.last_message.pop(\"getblocktxn\", None)\n \n         # Send compact block\n         comp_block.initialize_from_block(block, prefill_list=[0], use_witness=with_witness)\n         test_tip_after_message(node, test_node, msg_cmpctblock(comp_block.to_p2p()), block.sha256)\n         with mininode_lock:\n             # Shouldn't have gotten a request for any transaction\n-            assert(test_node.last_getblocktxn is None)\n+            assert(\"getblocktxn\" not in test_node.last_message)\n \n     # Incorrectly responding to a getblocktxn shouldn't cause the block to be\n     # permanently failed.\n@@ -591,8 +557,8 @@ def test_incorrect_blocktxn_response(self, node, test_node, version):\n         test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n         absolute_indexes = []\n         with mininode_lock:\n-            assert(test_node.last_getblocktxn is not None)\n-            absolute_indexes = test_node.last_getblocktxn.block_txn_request.to_absolute()\n+            assert(\"getblocktxn\" in test_node.last_message)\n+            absolute_indexes = test_node.last_message[\"getblocktxn\"].block_txn_request.to_absolute()\n         assert_equal(absolute_indexes, [6, 7, 8, 9, 10])\n \n         # Now give an incorrect response.\n@@ -613,11 +579,11 @@ def test_incorrect_blocktxn_response(self, node, test_node, version):\n         assert_equal(int(node.getbestblockhash(), 16), block.hashPrevBlock)\n \n         # We should receive a getdata request\n-        success = wait_until(lambda: test_node.last_getdata is not None, timeout=10)\n+        success = wait_until(lambda: \"getdata\" in test_node.last_message, timeout=10)\n         assert(success)\n-        assert_equal(len(test_node.last_getdata.inv), 1)\n-        assert(test_node.last_getdata.inv[0].type == 2 or test_node.last_getdata.inv[0].type == 2|MSG_WITNESS_FLAG)\n-        assert_equal(test_node.last_getdata.inv[0].hash, block.sha256)\n+        assert_equal(len(test_node.last_message[\"getdata\"].inv), 1)\n+        assert(test_node.last_message[\"getdata\"].inv[0].type == 2 or test_node.last_message[\"getdata\"].inv[0].type == 2|MSG_WITNESS_FLAG)\n+        assert_equal(test_node.last_message[\"getdata\"].inv[0].hash, block.sha256)\n \n         # Deliver the block\n         if version==2:\n@@ -641,15 +607,15 @@ def test_getblocktxn_handler(self, node, test_node, version):\n             num_to_request = random.randint(1, len(block.vtx))\n             msg.block_txn_request.from_absolute(sorted(random.sample(range(len(block.vtx)), num_to_request)))\n             test_node.send_message(msg)\n-            success = wait_until(lambda: test_node.last_blocktxn is not None, timeout=10)\n+            success = wait_until(lambda: \"blocktxn\" in test_node.last_message, timeout=10)\n             assert(success)\n \n             [tx.calc_sha256() for tx in block.vtx]\n             with mininode_lock:\n-                assert_equal(test_node.last_blocktxn.block_transactions.blockhash, int(block_hash, 16))\n+                assert_equal(test_node.last_message[\"blocktxn\"].block_transactions.blockhash, int(block_hash, 16))\n                 all_indices = msg.block_txn_request.to_absolute()\n                 for index in all_indices:\n-                    tx = test_node.last_blocktxn.block_transactions.transactions.pop(0)\n+                    tx = test_node.last_message[\"blocktxn\"].block_transactions.transactions.pop(0)\n                     tx.calc_sha256()\n                     assert_equal(tx.sha256, block.vtx[index].sha256)\n                     if version == 1:\n@@ -658,21 +624,21 @@ def test_getblocktxn_handler(self, node, test_node, version):\n                     else:\n                         # Check that the witness matches\n                         assert_equal(tx.calc_sha256(True), block.vtx[index].calc_sha256(True))\n-                test_node.last_blocktxn = None\n+                test_node.last_message.pop(\"blocktxn\", None)\n             current_height -= 1\n \n         # Next request should send a full block response, as we're past the\n         # allowed depth for a blocktxn response.\n         block_hash = node.getblockhash(current_height)\n         msg.block_txn_request = BlockTransactionsRequest(int(block_hash, 16), [0])\n         with mininode_lock:\n-            test_node.last_block = None\n-            test_node.last_blocktxn = None\n+            test_node.last_message.pop(\"block\", None)\n+            test_node.last_message.pop(\"blocktxn\", None)\n         test_node.send_and_ping(msg)\n         with mininode_lock:\n-            test_node.last_block.block.calc_sha256()\n-            assert_equal(test_node.last_block.block.sha256, int(block_hash, 16))\n-            assert_equal(test_node.last_blocktxn, None)\n+            test_node.last_message[\"block\"].block.calc_sha256()\n+            assert_equal(test_node.last_message[\"block\"].block.sha256, int(block_hash, 16))\n+            assert \"blocktxn\" not in test_node.last_message\n \n     def test_compactblocks_not_at_tip(self, node, test_node):\n         # Test that requesting old compactblocks doesn't work.\n@@ -685,21 +651,21 @@ def test_compactblocks_not_at_tip(self, node, test_node):\n \n         test_node.clear_block_announcement()\n         test_node.send_message(msg_getdata([CInv(4, int(new_blocks[0], 16))]))\n-        success = wait_until(lambda: test_node.last_cmpctblock is not None, timeout=30)\n+        success = wait_until(lambda: \"cmpctblock\" in test_node.last_message, timeout=30)\n         assert(success)\n \n         test_node.clear_block_announcement()\n         node.generate(1)\n         wait_until(test_node.received_block_announcement, timeout=30)\n         test_node.clear_block_announcement()\n         with mininode_lock:\n-            test_node.last_block = None\n+            test_node.last_message.pop(\"block\", None)\n         test_node.send_message(msg_getdata([CInv(4, int(new_blocks[0], 16))]))\n-        success = wait_until(lambda: test_node.last_block is not None, timeout=30)\n+        success = wait_until(lambda: \"block\" in test_node.last_message, timeout=30)\n         assert(success)\n         with mininode_lock:\n-            test_node.last_block.block.calc_sha256()\n-            assert_equal(test_node.last_block.block.sha256, int(new_blocks[0], 16))\n+            test_node.last_message[\"block\"].block.calc_sha256()\n+            assert_equal(test_node.last_message[\"block\"].block.sha256, int(new_blocks[0], 16))\n \n         # Generate an old compactblock, and verify that it's not accepted.\n         cur_height = node.getblockcount()\n@@ -726,10 +692,10 @@ def test_compactblocks_not_at_tip(self, node, test_node):\n         msg = msg_getblocktxn()\n         msg.block_txn_request = BlockTransactionsRequest(block.sha256, [0])\n         with mininode_lock:\n-            test_node.last_blocktxn = None\n+            test_node.last_message.pop(\"blocktxn\", None)\n         test_node.send_and_ping(msg)\n         with mininode_lock:\n-            assert(test_node.last_blocktxn is None)\n+            assert \"blocktxn\" not in test_node.last_message\n \n     def activate_segwit(self, node):\n         node.generate(144*3)\n@@ -750,9 +716,9 @@ def test_end_to_end_block_relay(self, node, listeners):\n             wait_until(lambda: l.received_block_announcement(), timeout=30)\n         with mininode_lock:\n             for l in listeners:\n-                assert(l.last_cmpctblock is not None)\n-                l.last_cmpctblock.header_and_shortids.header.calc_sha256()\n-                assert_equal(l.last_cmpctblock.header_and_shortids.header.sha256, block.sha256)\n+                assert \"cmpctblock\" in l.last_message\n+                l.last_message[\"cmpctblock\"].header_and_shortids.header.calc_sha256()\n+                assert_equal(l.last_message[\"cmpctblock\"].header_and_shortids.header.sha256, block.sha256)\n \n     # Test that we don't get disconnected if we relay a compact block with valid header,\n     # but invalid transactions.\n@@ -804,7 +770,7 @@ def announce_cmpct_block(node, peer):\n             msg = msg_cmpctblock(cmpct_block.to_p2p())\n             peer.send_and_ping(msg)\n             with mininode_lock:\n-                assert(peer.last_getblocktxn is not None)\n+                assert \"getblocktxn\" in peer.last_message\n             return block, cmpct_block\n \n         block, cmpct_block = announce_cmpct_block(node, stalling_peer)"
      },
      {
        "sha": "fe1a43ac54ca4c63df8ad963316d816943c25bff",
        "filename": "test/functional/p2p-feefilter.py",
        "status": "modified",
        "additions": 2,
        "deletions": 8,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/p2p-feefilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/p2p-feefilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-feefilter.py?ref=2a52ae63bfdde948250df1c876dcdd5af99f03b5",
        "patch": "@@ -22,8 +22,6 @@ def allInvsMatch(invsExpected, testnode):\n         time.sleep(1)\n     return False\n \n-# TestNode: bare-bones \"peer\".  Used to track which invs are received from a node\n-# and to send the node feefilter messages.\n class TestNode(NodeConnCB):\n     def __init__(self):\n         super().__init__()\n@@ -38,10 +36,6 @@ def clear_invs(self):\n         with mininode_lock:\n             self.txinvs = []\n \n-    def send_filter(self, feerate):\n-        self.send_message(msg_feefilter(feerate))\n-        self.sync_with_ping()\n-\n class FeeFilterTest(BitcoinTestFramework):\n \n     def __init__(self):\n@@ -78,7 +72,7 @@ def run_test(self):\n         test_node.clear_invs()\n \n         # Set a filter of 15 sat/byte\n-        test_node.send_filter(15000)\n+        test_node.send_and_ping(msg_feefilter(15000))\n \n         # Test that txs are still being received (paying 20 sat/byte)\n         txids = [node1.sendtoaddress(node1.getnewaddress(), 1) for x in range(3)]\n@@ -103,7 +97,7 @@ def run_test(self):\n         test_node.clear_invs()\n \n         # Remove fee filter and check that txs are received again\n-        test_node.send_filter(0)\n+        test_node.send_and_ping(msg_feefilter(0))\n         txids = [node1.sendtoaddress(node1.getnewaddress(), 1) for x in range(3)]\n         assert(allInvsMatch(txids, test_node))\n         test_node.clear_invs()"
      },
      {
        "sha": "4cc3107cf87d632b43ab9952a5d4314b56dec027",
        "filename": "test/functional/p2p-leaktests.py",
        "status": "modified",
        "additions": 0,
        "deletions": 11,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/p2p-leaktests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/p2p-leaktests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-leaktests.py?ref=2a52ae63bfdde948250df1c876dcdd5af99f03b5",
        "patch": "@@ -20,17 +20,9 @@\n class CLazyNode(NodeConnCB):\n     def __init__(self):\n         super().__init__()\n-        self.connection = None\n         self.unexpected_msg = False\n-        self.connected = False\n         self.ever_connected = False\n \n-    def add_connection(self, conn):\n-        self.connection = conn\n-\n-    def send_message(self, message):\n-        self.connection.send_message(message)\n-\n     def bad_message(self, message):\n         self.unexpected_msg = True\n         self.log.info(\"should not have received message: %s\" % message.command)\n@@ -65,9 +57,6 @@ def on_blocktxn(self, conn, message): self.bad_message(message)\n # Node that never sends a version. We'll use this to send a bunch of messages\n # anyway, and eventually get disconnected.\n class CNodeNoVersionBan(CLazyNode):\n-    def __init__(self):\n-        super().__init__()\n-\n     # send a bunch of veracks without sending a message. This should get us disconnected.\n     # NOTE: implementation-specific check here. Remove if bitcoind ban behavior changes\n     def on_open(self, conn):"
      },
      {
        "sha": "188016e7184c49d53dbcf8fe2085a4186f42dc78",
        "filename": "test/functional/p2p-mempool.py",
        "status": "modified",
        "additions": 3,
        "deletions": 50,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/p2p-mempool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/p2p-mempool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-mempool.py?ref=2a52ae63bfdde948250df1c876dcdd5af99f03b5",
        "patch": "@@ -12,51 +12,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n \n-class TestNode(NodeConnCB):\n-    def __init__(self):\n-        super().__init__()\n-        self.connection = None\n-        self.ping_counter = 1\n-        self.last_pong = msg_pong()\n-        self.block_receive_map = {}\n-\n-    def add_connection(self, conn):\n-        self.connection = conn\n-        self.peer_disconnected = False\n-\n-    def on_inv(self, conn, message):\n-        pass\n-\n-    # Track the last getdata message we receive (used in the test)\n-    def on_getdata(self, conn, message):\n-        self.last_getdata = message\n-\n-    def on_block(self, conn, message):\n-        message.block.calc_sha256()\n-        try:\n-            self.block_receive_map[message.block.sha256] += 1\n-        except KeyError as e:\n-            self.block_receive_map[message.block.sha256] = 1\n-\n-    def wait_for_disconnect(self):\n-        def disconnected():\n-            return self.peer_disconnected\n-        return wait_until(disconnected, timeout=10)\n-\n-    # Wrapper for the NodeConn's send_message function\n-    def send_message(self, message):\n-        self.connection.send_message(message)\n-\n-    def on_pong(self, conn, message):\n-        self.last_pong = message\n-\n-    def on_close(self, conn):\n-        self.peer_disconnected = True\n-\n-    def send_mempool(self):\n-        self.lastInv = []\n-        self.send_message(msg_mempool())\n-\n class P2PMempoolTests(BitcoinTestFramework):\n \n     def __init__(self):\n@@ -65,20 +20,18 @@ def __init__(self):\n         self.num_nodes = 2\n \n     def setup_network(self):\n-        # Start a node with maxuploadtarget of 200 MB (/24h)\n-        self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-peerbloomfilters=0\"]))\n+        self.nodes = [start_node(0, self.options.tmpdir, [\"-peerbloomfilters=0\"])]\n \n     def run_test(self):\n         #connect a mininode\n-        aTestNode = TestNode()\n+        aTestNode = NodeConnCB()\n         node = NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], aTestNode)\n         aTestNode.add_connection(node)\n         NetworkThread().start()\n         aTestNode.wait_for_verack()\n \n         #request mempool\n-        aTestNode.send_mempool()\n+        aTestNode.send_message(msg_mempool())\n         aTestNode.wait_for_disconnect()\n \n         #mininode must be disconnected at this point"
      },
      {
        "sha": "0ed5fd3eaf41219261c765d1bd96fb8d772ddd12",
        "filename": "test/functional/p2p-segwit.py",
        "status": "modified",
        "additions": 20,
        "deletions": 79,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-segwit.py?ref=2a52ae63bfdde948250df1c876dcdd5af99f03b5",
        "patch": "@@ -35,79 +35,22 @@ def get_virtual_size(witness_block):\n class TestNode(NodeConnCB):\n     def __init__(self):\n         super().__init__()\n-        self.connection = None\n-        self.ping_counter = 1\n-        self.last_pong = msg_pong(0)\n-        self.sleep_time = 0.05\n         self.getdataset = set()\n-        self.last_reject = None\n-\n-    def add_connection(self, conn):\n-        self.connection = conn\n-\n-    # Wrapper for the NodeConn's send_message function\n-    def send_message(self, message):\n-        self.connection.send_message(message)\n-\n-    def on_inv(self, conn, message):\n-        self.last_inv = message\n-\n-    def on_block(self, conn, message):\n-        self.last_block = message.block\n-        self.last_block.calc_sha256()\n \n     def on_getdata(self, conn, message):\n         for inv in message.inv:\n             self.getdataset.add(inv.hash)\n-        self.last_getdata = message\n-\n-    def on_getheaders(self, conn, message):\n-        self.last_getheaders = message\n-\n-    def on_pong(self, conn, message):\n-        self.last_pong = message\n-\n-    def on_reject(self, conn, message):\n-        self.last_reject = message\n-\n-    # Syncing helpers\n-    def sync(self, test_function, timeout=60):\n-        while timeout > 0:\n-            with mininode_lock:\n-                if test_function():\n-                    return\n-            time.sleep(self.sleep_time)\n-            timeout -= self.sleep_time\n-        raise AssertionError(\"Sync failed to complete\")\n-        \n-    def wait_for_block(self, blockhash, timeout=60):\n-        test_function = lambda: self.last_block != None and self.last_block.sha256 == blockhash\n-        self.sync(test_function, timeout)\n-        return\n-\n-    def wait_for_getdata(self, timeout=60):\n-        test_function = lambda: self.last_getdata != None\n-        self.sync(test_function, timeout)\n-\n-    def wait_for_getheaders(self, timeout=60):\n-        test_function = lambda: self.last_getheaders != None\n-        self.sync(test_function, timeout)\n-\n-    def wait_for_inv(self, expected_inv, timeout=60):\n-        test_function = lambda: self.last_inv != expected_inv\n-        self.sync(test_function, timeout)\n \n     def announce_tx_and_wait_for_getdata(self, tx, timeout=60):\n         with mininode_lock:\n-            self.last_getdata = None\n+            self.last_message.pop(\"getdata\", None)\n         self.send_message(msg_inv(inv=[CInv(1, tx.sha256)]))\n         self.wait_for_getdata(timeout)\n-        return\n \n     def announce_block_and_wait_for_getdata(self, block, use_header, timeout=60):\n         with mininode_lock:\n-            self.last_getdata = None\n-            self.last_getheaders = None\n+            self.last_message.pop(\"getdata\", None)\n+            self.last_message.pop(\"getheaders\", None)\n         msg = msg_headers()\n         msg.headers = [ CBlockHeader(block) ]\n         if use_header:\n@@ -117,11 +60,10 @@ def announce_block_and_wait_for_getdata(self, block, use_header, timeout=60):\n             self.wait_for_getheaders()\n             self.send_message(msg)\n         self.wait_for_getdata()\n-        return\n \n     def announce_block(self, block, use_header):\n         with mininode_lock:\n-            self.last_getdata = None\n+            self.last_message.pop(\"getdata\", None)\n         if use_header:\n             msg = msg_headers()\n             msg.headers = [ CBlockHeader(block) ]\n@@ -131,33 +73,32 @@ def announce_block(self, block, use_header):\n \n     def request_block(self, blockhash, inv_type, timeout=60):\n         with mininode_lock:\n-            self.last_block = None\n+            self.last_message.pop(\"block\", None)\n         self.send_message(msg_getdata(inv=[CInv(inv_type, blockhash)]))\n         self.wait_for_block(blockhash, timeout)\n-        return self.last_block\n+        return self.last_message[\"block\"].block\n \n     def test_transaction_acceptance(self, tx, with_witness, accepted, reason=None):\n         tx_message = msg_tx(tx)\n         if with_witness:\n             tx_message = msg_witness_tx(tx)\n         self.send_message(tx_message)\n-        self.sync_with_ping(60)\n+        self.sync_with_ping()\n         assert_equal(tx.hash in self.connection.rpc.getrawmempool(), accepted)\n         if (reason != None and not accepted):\n             # Check the rejection reason as well.\n             with mininode_lock:\n-                assert_equal(self.last_reject.reason, reason)\n+                assert_equal(self.last_message[\"reject\"].reason, reason)\n \n     # Test whether a witness block had the correct effect on the tip\n     def test_witness_block(self, block, accepted, with_witness=True):\n         if with_witness:\n             self.send_message(msg_witness_block(block))\n         else:\n             self.send_message(msg_block(block))\n-        self.sync_with_ping(60)\n+        self.sync_with_ping()\n         assert_equal(self.connection.rpc.getbestblockhash() == block.hash, accepted)\n \n-\n # Used to keep track of anyone-can-spend outputs that we can use in the tests\n class UTXO(object):\n     def __init__(self, sha256, n, nValue):\n@@ -228,7 +169,7 @@ def test_non_witness_transaction(self):\n         block = self.build_next_block(nVersion=1)\n         block.solve()\n         self.test_node.send_message(msg_block(block))\n-        self.test_node.sync_with_ping(60) # make sure the block was processed\n+        self.test_node.sync_with_ping() # make sure the block was processed\n         txid = block.vtx[0].sha256\n \n         self.nodes[0].generate(99) # let the block mature\n@@ -244,7 +185,7 @@ def test_non_witness_transaction(self):\n         assert_equal(msg_tx(tx).serialize(), msg_witness_tx(tx).serialize())\n \n         self.test_node.send_message(msg_witness_tx(tx))\n-        self.test_node.sync_with_ping(60) # make sure the tx was processed\n+        self.test_node.sync_with_ping() # make sure the tx was processed\n         assert(tx.hash in self.nodes[0].getrawmempool())\n         # Save this transaction for later\n         self.utxo.append(UTXO(tx.sha256, 0, 49*100000000))\n@@ -279,12 +220,12 @@ def test_unnecessary_witness_before_segwit_activation(self):\n         # TODO: fix synchronization so we can test reject reason\n         # Right now, bitcoind delays sending reject messages for blocks\n         # until the future, making synchronization here difficult.\n-        #assert_equal(self.test_node.last_reject.reason, \"unexpected-witness\")\n+        #assert_equal(self.test_node.last_message[\"reject\"].reason, \"unexpected-witness\")\n \n         # But it should not be permanently marked bad...\n         # Resend without witness information.\n         self.test_node.send_message(msg_block(block))\n-        self.test_node.sync_with_ping(60)\n+        self.test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n \n         sync_blocks(self.nodes)\n@@ -893,7 +834,7 @@ def test_witness_tx_relay_before_segwit_activation(self):\n         # Verify that if a peer doesn't set nServices to include NODE_WITNESS,\n         # the getdata is just for the non-witness portion.\n         self.old_node.announce_tx_and_wait_for_getdata(tx)\n-        assert(self.old_node.last_getdata.inv[0].type == 1)\n+        assert(self.old_node.last_message[\"getdata\"].inv[0].type == 1)\n \n         # Since we haven't delivered the tx yet, inv'ing the same tx from\n         # a witness transaction ought not result in a getdata.\n@@ -1028,20 +969,20 @@ def test_block_relay(self, segwit_activated):\n         block1.solve()\n \n         self.test_node.announce_block_and_wait_for_getdata(block1, use_header=False)\n-        assert(self.test_node.last_getdata.inv[0].type == blocktype)\n+        assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n         self.test_node.test_witness_block(block1, True)\n \n         block2 = self.build_next_block(nVersion=4)\n         block2.solve()\n \n         self.test_node.announce_block_and_wait_for_getdata(block2, use_header=True)\n-        assert(self.test_node.last_getdata.inv[0].type == blocktype)\n+        assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n         self.test_node.test_witness_block(block2, True)\n \n         block3 = self.build_next_block(nVersion=(VB_TOP_BITS | (1<<15)))\n         block3.solve()\n         self.test_node.announce_block_and_wait_for_getdata(block3, use_header=True)\n-        assert(self.test_node.last_getdata.inv[0].type == blocktype)\n+        assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n         self.test_node.test_witness_block(block3, True)\n \n         # Check that we can getdata for witness blocks or regular blocks,\n@@ -1250,9 +1191,9 @@ def test_segwit_versions(self):\n         # Spending a higher version witness output is not allowed by policy,\n         # even with fRequireStandard=false.\n         self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=False)\n-        self.test_node.sync_with_ping(60)\n+        self.test_node.sync_with_ping()\n         with mininode_lock:\n-            assert(b\"reserved for soft-fork upgrades\" in self.test_node.last_reject.reason)\n+            assert(b\"reserved for soft-fork upgrades\" in self.test_node.last_message[\"reject\"].reason)\n \n         # Building a block with the transaction must be valid, however.\n         block = self.build_next_block()\n@@ -1380,7 +1321,7 @@ def test_signature_version_1(self):\n         for i in range(NUM_TESTS):\n             # Ping regularly to keep the connection alive\n             if (not i % 100):\n-                self.test_node.sync_with_ping(60)\n+                self.test_node.sync_with_ping()\n             # Choose random number of inputs to use.\n             num_inputs = random.randint(1, 10)\n             # Create a slight bias for producing more utxos"
      },
      {
        "sha": "210e561e7436ce16ef057e11ffe7e905e4c789ad",
        "filename": "test/functional/p2p-timeouts.py",
        "status": "modified",
        "additions": 2,
        "deletions": 13,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/p2p-timeouts.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/p2p-timeouts.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-timeouts.py?ref=2a52ae63bfdde948250df1c876dcdd5af99f03b5",
        "patch": "@@ -28,20 +28,9 @@\n from test_framework.util import *\n \n class TestNode(NodeConnCB):\n-    def __init__(self):\n-        super().__init__()\n-        self.connected = False\n-        self.received_version = False\n-\n-    def on_open(self, conn):\n-        self.connected = True\n-\n-    def on_close(self, conn):\n-        self.connected = False\n-\n     def on_version(self, conn, message):\n         # Don't send a verack in response\n-        self.received_version = True\n+        pass\n \n class TimeoutsTest(BitcoinTestFramework):\n     def __init__(self):\n@@ -83,7 +72,7 @@ def run_test(self):\n \n         sleep(30)\n \n-        assert(self.no_verack_node.received_version)\n+        assert \"version\" in self.no_verack_node.last_message\n \n         assert(self.no_verack_node.connected)\n         assert(self.no_version_node.connected)"
      },
      {
        "sha": "06cdd5f91d110c6608b2904242f1bfefbfb99fc0",
        "filename": "test/functional/p2p-versionbits-warning.py",
        "status": "modified",
        "additions": 0,
        "deletions": 18,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/p2p-versionbits-warning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/p2p-versionbits-warning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-versionbits-warning.py?ref=2a52ae63bfdde948250df1c876dcdd5af99f03b5",
        "patch": "@@ -24,28 +24,10 @@\n WARN_UNKNOWN_RULES_ACTIVE = \"unknown new rules activated (versionbit {})\".format(VB_UNKNOWN_BIT)\n VB_PATTERN = re.compile(\"^Warning.*versionbit\")\n \n-# TestNode: bare-bones \"peer\".  Used mostly as a conduit for a test to sending\n-# p2p messages to a node, generating the messages in the main testing logic.\n class TestNode(NodeConnCB):\n-    def __init__(self):\n-        super().__init__()\n-        self.connection = None\n-        self.ping_counter = 1\n-        self.last_pong = msg_pong()\n-\n-    def add_connection(self, conn):\n-        self.connection = conn\n-\n     def on_inv(self, conn, message):\n         pass\n \n-    # Wrapper for the NodeConn's send_message function\n-    def send_message(self, message):\n-        self.connection.send_message(message)\n-\n-    def on_pong(self, conn, message):\n-        self.last_pong = message\n-\n class VersionBitsWarningTest(BitcoinTestFramework):\n     def __init__(self):\n         super().__init__()"
      },
      {
        "sha": "ef20d42238151af3536abda53873aa28d9560d12",
        "filename": "test/functional/sendheaders.py",
        "status": "modified",
        "additions": 25,
        "deletions": 74,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/sendheaders.py?ref=2a52ae63bfdde948250df1c876dcdd5af99f03b5",
        "patch": "@@ -81,23 +81,17 @@\n \n direct_fetch_response_time = 0.05\n \n-class BaseNode(NodeConnCB):\n+class TestNode(NodeConnCB):\n     def __init__(self):\n         super().__init__()\n-        self.last_inv = None\n-        self.last_headers = None\n-        self.last_block = None\n-        self.last_getdata = None\n         self.block_announced = False\n-        self.last_getheaders = None\n-        self.disconnected = False\n         self.last_blockhash_announced = None\n \n     def clear_last_announcement(self):\n         with mininode_lock:\n             self.block_announced = False\n-            self.last_inv = None\n-            self.last_headers = None\n+            self.last_message.pop(\"inv\", None)\n+            self.last_message.pop(\"headers\", None)\n \n     # Request data for a list of block hashes\n     def get_data(self, block_hashes):\n@@ -118,29 +112,17 @@ def send_block_inv(self, blockhash):\n         self.connection.send_message(msg)\n \n     def on_inv(self, conn, message):\n-        self.last_inv = message\n         self.block_announced = True\n         self.last_blockhash_announced = message.inv[-1].hash\n \n     def on_headers(self, conn, message):\n-        self.last_headers = message\n         if len(message.headers):\n             self.block_announced = True\n             message.headers[-1].calc_sha256()\n             self.last_blockhash_announced = message.headers[-1].sha256\n \n     def on_block(self, conn, message):\n-        self.last_block = message.block\n-        self.last_block.calc_sha256()\n-\n-    def on_getdata(self, conn, message):\n-        self.last_getdata = message\n-\n-    def on_getheaders(self, conn, message):\n-        self.last_getheaders = message\n-\n-    def on_close(self, conn):\n-        self.disconnected = True\n+        self.last_message[\"block\"].calc_sha256()\n \n     # Test whether the last announcement we received had the\n     # right header or the right inv\n@@ -155,43 +137,27 @@ def check_last_announcement(self, headers=None, inv=None):\n \n             success = True\n             compare_inv = []\n-            if self.last_inv != None:\n-                compare_inv = [x.hash for x in self.last_inv.inv]\n+            if \"inv\" in self.last_message:\n+                compare_inv = [x.hash for x in self.last_message[\"inv\"].inv]\n             if compare_inv != expect_inv:\n                 success = False\n \n             hash_headers = []\n-            if self.last_headers != None:\n+            if \"headers\" in self.last_message:\n                 # treat headers as a list of block hashes\n-                hash_headers = [ x.sha256 for x in self.last_headers.headers ]\n+                hash_headers = [ x.sha256 for x in self.last_message[\"headers\"].headers ]\n             if hash_headers != expect_headers:\n                 success = False\n \n-            self.last_inv = None\n-            self.last_headers = None\n+            self.last_message.pop(\"inv\", None)\n+            self.last_message.pop(\"headers\", None)\n         return success\n \n-    # Syncing helpers\n-    def wait_for_block(self, blockhash, timeout=60):\n-        test_function = lambda: self.last_block != None and self.last_block.sha256 == blockhash\n-        assert(wait_until(test_function, timeout=timeout))\n-        return\n-\n-    def wait_for_getheaders(self, timeout=60):\n-        test_function = lambda: self.last_getheaders != None\n-        assert(wait_until(test_function, timeout=timeout))\n-        return\n-\n     def wait_for_getdata(self, hash_list, timeout=60):\n         if hash_list == []:\n             return\n \n-        test_function = lambda: self.last_getdata != None and [x.hash for x in self.last_getdata.inv] == hash_list\n-        assert(wait_until(test_function, timeout=timeout))\n-        return\n-\n-    def wait_for_disconnect(self, timeout=60):\n-        test_function = lambda: self.disconnected\n+        test_function = lambda: \"getdata\" in self.last_message and [x.hash for x in self.last_message[\"getdata\"].inv] == hash_list\n         assert(wait_until(test_function, timeout=timeout))\n         return\n \n@@ -210,17 +176,6 @@ def send_getblocks(self, locator):\n         getblocks_message.locator.vHave = locator\n         self.send_message(getblocks_message)\n \n-# InvNode: This peer should only ever receive inv's, because it doesn't ever send a\n-# \"sendheaders\" message.\n-class InvNode(BaseNode):\n-    def __init__(self):\n-        BaseNode.__init__(self)\n-\n-# TestNode: This peer is the one we use for most of the testing.\n-class TestNode(BaseNode):\n-    def __init__(self):\n-        BaseNode.__init__(self)\n-\n class SendHeadersTest(BitcoinTestFramework):\n     def __init__(self):\n         super().__init__()\n@@ -260,7 +215,7 @@ def mine_reorg(self, length):\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n-        inv_node = InvNode()\n+        inv_node = TestNode()\n         test_node = TestNode()\n \n         self.p2p_connections = [inv_node, test_node]\n@@ -368,8 +323,8 @@ def run_test(self):\n                 inv_node.sync_with_ping()\n                 # This block should not be announced to the inv node (since it also\n                 # broadcast it)\n-                assert_equal(inv_node.last_inv, None)\n-                assert_equal(inv_node.last_headers, None)\n+                assert \"inv\" not in inv_node.last_message\n+                assert \"headers\" not in inv_node.last_message\n                 tip = self.mine_blocks(1)\n                 assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n                 assert_equal(test_node.check_last_announcement(headers=[tip]), True)\n@@ -459,12 +414,12 @@ def run_test(self):\n             inv_node.send_message(msg_block(blocks[-1]))\n \n         inv_node.sync_with_ping() # Make sure blocks are processed\n-        test_node.last_getdata = None\n+        test_node.last_message.pop(\"getdata\", None)\n         test_node.send_header_for_blocks(blocks)\n         test_node.sync_with_ping()\n         # should not have received any getdata messages\n         with mininode_lock:\n-            assert_equal(test_node.last_getdata, None)\n+            assert \"getdata\" not in test_node.last_message\n \n         # This time, direct fetch should work\n         blocks = []\n@@ -498,11 +453,11 @@ def run_test(self):\n \n         # Announcing one block on fork should not trigger direct fetch\n         # (less work than tip)\n-        test_node.last_getdata = None\n+        test_node.last_message.pop(\"getdata\", None)\n         test_node.send_header_for_blocks(blocks[0:1])\n         test_node.sync_with_ping()\n         with mininode_lock:\n-            assert_equal(test_node.last_getdata, None)\n+            assert \"getdata\" not in test_node.last_message\n \n         # Announcing one more block on fork should trigger direct fetch for\n         # both blocks (same work as tip)\n@@ -517,11 +472,11 @@ def run_test(self):\n         test_node.wait_for_getdata([x.sha256 for x in blocks[2:16]], timeout=direct_fetch_response_time)\n \n         # Announcing 1 more header should not trigger any response\n-        test_node.last_getdata = None\n+        test_node.last_message.pop(\"getdata\", None)\n         test_node.send_header_for_blocks(blocks[18:19])\n         test_node.sync_with_ping()\n         with mininode_lock:\n-            assert_equal(test_node.last_getdata, None)\n+            assert \"getdata\" not in test_node.last_message\n \n         self.log.info(\"Part 4: success!\")\n \n@@ -532,7 +487,7 @@ def run_test(self):\n         # First we test that receipt of an unconnecting header doesn't prevent\n         # chain sync.\n         for i in range(10):\n-            test_node.last_getdata = None\n+            test_node.last_message.pop(\"getdata\", None)\n             blocks = []\n             # Create two more blocks.\n             for j in range(2):\n@@ -543,7 +498,7 @@ def run_test(self):\n                 height += 1\n             # Send the header of the second block -> this won't connect.\n             with mininode_lock:\n-                test_node.last_getheaders = None\n+                test_node.last_message.pop(\"getheaders\", None)\n             test_node.send_header_for_blocks([blocks[1]])\n             test_node.wait_for_getheaders(timeout=1)\n             test_node.send_header_for_blocks(blocks)\n@@ -566,7 +521,7 @@ def run_test(self):\n         for i in range(1, MAX_UNCONNECTING_HEADERS):\n             # Send a header that doesn't connect, check that we get a getheaders.\n             with mininode_lock:\n-                test_node.last_getheaders = None\n+                test_node.last_message.pop(\"getheaders\", None)\n             test_node.send_header_for_blocks([blocks[i]])\n             test_node.wait_for_getheaders(timeout=1)\n \n@@ -581,25 +536,21 @@ def run_test(self):\n         for i in range(5*MAX_UNCONNECTING_HEADERS - 1):\n             # Send a header that doesn't connect, check that we get a getheaders.\n             with mininode_lock:\n-                test_node.last_getheaders = None\n+                test_node.last_message.pop(\"getheaders\", None)\n             test_node.send_header_for_blocks([blocks[i%len(blocks)]])\n             test_node.wait_for_getheaders(timeout=1)\n \n         # Eventually this stops working.\n-        with mininode_lock:\n-            self.last_getheaders = None\n         test_node.send_header_for_blocks([blocks[-1]])\n \n         # Should get disconnected\n         test_node.wait_for_disconnect()\n-        with mininode_lock:\n-            self.last_getheaders = True\n \n         self.log.info(\"Part 5: success!\")\n \n         # Finally, check that the inv node never received a getdata request,\n         # throughout the test\n-        assert_equal(inv_node.last_getdata, None)\n+        assert \"getdata\" not in inv_node.last_message\n \n if __name__ == '__main__':\n     SendHeadersTest().main()"
      },
      {
        "sha": "9f062865a3e23c08128dd74fd6193af9cd3cb025",
        "filename": "test/functional/test_framework/comptool.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/test_framework/comptool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/test_framework/comptool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/comptool.py?ref=2a52ae63bfdde948250df1c876dcdd5af99f03b5",
        "patch": "@@ -192,7 +192,7 @@ def disconnected():\n         return wait_until(disconnected, timeout=10)\n \n     def wait_for_verack(self):\n-        [node.wait_for_verack() for node in self.test_nodes]\n+        return all(node.wait_for_verack() for node in self.test_nodes)\n \n     def wait_for_pings(self, counter):\n         def received_pongs():"
      },
      {
        "sha": "b2531a6c9e14afadb0d092044b02244fdf5d0adc",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 7,
        "deletions": 19,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a52ae63bfdde948250df1c876dcdd5af99f03b5/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=2a52ae63bfdde948250df1c876dcdd5af99f03b5",
        "patch": "@@ -1590,34 +1590,25 @@ def wait_for_disconnect(self, timeout=60):\n \n     # Message receiving helper methods\n \n-    def sync(self, test_function, timeout=60):\n-        while timeout > 0:\n-            with mininode_lock:\n-                if test_function():\n-                    return\n-            time.sleep(0.05)\n-            timeout -= 0.05\n-        raise AssertionError(\"Sync failed to complete\")\n-\n     def wait_for_block(self, blockhash, timeout=60):\n         test_function = lambda: self.last_message.get(\"block\") and self.last_message[\"block\"].block.rehash() == blockhash\n-        self.sync(test_function, timeout)\n+        assert wait_until(test_function, timeout=timeout)\n \n     def wait_for_getdata(self, timeout=60):\n         test_function = lambda: self.last_message.get(\"getdata\")\n-        self.sync(test_function, timeout)\n+        assert wait_until(test_function, timeout=timeout)\n \n     def wait_for_getheaders(self, timeout=60):\n         test_function = lambda: self.last_message.get(\"getheaders\")\n-        self.sync(test_function, timeout)\n+        assert wait_until(test_function, timeout=timeout)\n \n     def wait_for_inv(self, expected_inv, timeout=60):\n         test_function = lambda: self.last_message.get(\"inv\") and self.last_message[\"inv\"] != expected_inv\n-        self.sync(test_function, timeout)\n+        assert wait_until(test_function, timeout=timeout)\n \n     def wait_for_verack(self, timeout=60):\n         test_function = lambda: self.message_count[\"verack\"]\n-        self.sync(test_function, timeout)\n+        assert wait_until(test_function, timeout=timeout)\n \n     # Message sending helper functions\n \n@@ -1635,12 +1626,9 @@ def send_and_ping(self, message):\n     def sync_with_ping(self, timeout=60):\n         self.send_message(msg_ping(nonce=self.ping_counter))\n         test_function = lambda: self.last_message.get(\"pong\") and self.last_message[\"pong\"].nonce == self.ping_counter\n-        success = wait_until(test_function, timeout = timeout)\n-        if not success:\n-            logger.error(\"sync_with_ping failed!\")\n-            raise AssertionError(\"sync_with_ping failed!\")\n+        assert wait_until(test_function, timeout=timeout)\n         self.ping_counter += 1\n-        return success\n+        return True\n \n # The actual NodeConn class\n # This class provides an interface for a p2p connection to a specified node"
      }
    ]
  }
]