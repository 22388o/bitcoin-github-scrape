[
  {
    "sha": "9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NjIzZjdmNmZjOGE1MjYwYWQwZTQ5MGUwZmUzNTZjY2UzZWNmZGFk",
    "commit": {
      "author": {
        "name": "Santy Raghavan",
        "email": "santy.raghavan@gmail.com",
        "date": "2017-08-08T16:29:23Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2017-08-08T16:29:23Z"
      },
      "message": "Merge pull request #1 from bitcoin/master\n\nmerge",
      "tree": {
        "sha": "269b79142de26735a7f7101b8b5ad3fe17d5aad5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/269b79142de26735a7f7101b8b5ad3fe17d5aad5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/comments",
    "author": {
      "login": "santyraghavan",
      "id": 20128884,
      "node_id": "MDQ6VXNlcjIwMTI4ODg0",
      "avatar_url": "https://avatars.githubusercontent.com/u/20128884?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/santyraghavan",
      "html_url": "https://github.com/santyraghavan",
      "followers_url": "https://api.github.com/users/santyraghavan/followers",
      "following_url": "https://api.github.com/users/santyraghavan/following{/other_user}",
      "gists_url": "https://api.github.com/users/santyraghavan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/santyraghavan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/santyraghavan/subscriptions",
      "organizations_url": "https://api.github.com/users/santyraghavan/orgs",
      "repos_url": "https://api.github.com/users/santyraghavan/repos",
      "events_url": "https://api.github.com/users/santyraghavan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/santyraghavan/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c91ca0ace9bd62eea8158b92cfc53d6d219e37b7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c91ca0ace9bd62eea8158b92cfc53d6d219e37b7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c91ca0ace9bd62eea8158b92cfc53d6d219e37b7"
      },
      {
        "sha": "2507fd55568b361080e9127f40584af2df64f76e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2507fd55568b361080e9127f40584af2df64f76e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2507fd55568b361080e9127f40584af2df64f76e"
      }
    ],
    "stats": {
      "total": 45110,
      "additions": 32433,
      "deletions": 12677
    },
    "files": [
      {
        "sha": "60c26dae8b89349b88d704dd7be7320ef8684b16",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -80,7 +80,6 @@ Bitcoin-Qt.app\n # Unit-tests\n Makefile.test\n bitcoin-qt_test\n-src/test/buildenv.py\n \n # Resources cpp\n qrc_*.cpp\n@@ -101,8 +100,7 @@ coverage_percent.txt\n linux-coverage-build\n linux-build\n win32-build\n-test/functional/config.ini\n-test/util/buildenv.py\n+test/config.ini\n test/cache/*\n \n !src/leveldb*/Makefile"
      },
      {
        "sha": "12f91096cc951664562903e5890b64bcb23ffacb",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 7,
        "deletions": 8,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -29,10 +29,10 @@ env:\n     - HOST=i686-pc-linux-gnu PACKAGES=\"g++-multilib bc python3-zmq\" DEP_OPTS=\"NO_QT=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports LDFLAGS=-static-libstdc++\" USE_SHELL=\"/bin/dash\"\n # Win64\n     - HOST=x86_64-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-x86-64 wine1.6 bc\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n-# bitcoind\n-    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"bc python3-zmq\" DEP_OPTS=\"NO_QT=1 NO_UPNP=1 DEBUG=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports CPPFLAGS=-DDEBUG_LOCKORDER\"\n-# No wallet\n-    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3 xvfb\" DEP_OPTS=\"NO_WALLET=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n+# x86_64 Linux (uses qt5 dev package instead of depends Qt to speed up build and avoid timeout)\n+    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3-zmq qtbase5-dev qttools5-dev-tools protobuf-compiler libdbus-1-dev libharfbuzz-dev\" DEP_OPTS=\"NO_QT=1 NO_UPNP=1 DEBUG=1 ALLOW_HOST_PACKAGES=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --with-gui=qt5 --enable-glibc-back-compat --enable-reduce-exports CPPFLAGS=-DDEBUG_LOCKORDER\"\n+# x86_64 Linux, No wallet\n+    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3\" DEP_OPTS=\"NO_WALLET=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n # Cross-Mac\n     - HOST=x86_64-apple-darwin11 PACKAGES=\"cmake imagemagick libcap-dev librsvg2-bin libz-dev libbz2-dev libtiff-tools python-dev\" BITCOIN_CONFIG=\"--enable-gui --enable-reduce-exports\" OSX_SDK=10.11 GOAL=\"deploy\"\n \n@@ -43,14 +43,13 @@ install:\n     - if [ -n \"$PACKAGES\" ]; then travis_retry sudo apt-get update; fi\n     - if [ -n \"$PACKAGES\" ]; then travis_retry sudo apt-get install --no-install-recommends --no-upgrade -qq $PACKAGES; fi\n before_script:\n+    - if [ \"$TRAVIS_EVENT_TYPE\" = \"pull_request\" ]; then contrib/devtools/commit-script-check.sh $TRAVIS_COMMIT_RANGE; fi\n     - unset CC; unset CXX\n     - if [ \"$CHECK_DOC\" = 1 ]; then contrib/devtools/check-doc.py; fi\n     - mkdir -p depends/SDKs depends/sdk-sources\n     - if [ -n \"$OSX_SDK\" -a ! -f depends/sdk-sources/MacOSX${OSX_SDK}.sdk.tar.gz ]; then curl --location --fail $SDK_URL/MacOSX${OSX_SDK}.sdk.tar.gz -o depends/sdk-sources/MacOSX${OSX_SDK}.sdk.tar.gz; fi\n     - if [ -n \"$OSX_SDK\" -a -f depends/sdk-sources/MacOSX${OSX_SDK}.sdk.tar.gz ]; then tar -C depends/SDKs -xf depends/sdk-sources/MacOSX${OSX_SDK}.sdk.tar.gz; fi\n     - make $MAKEJOBS -C depends HOST=$HOST $DEP_OPTS\n-    # Start xvfb if needed, as documented at https://docs.travis-ci.com/user/gui-and-headless-browsers/#Using-xvfb-to-Run-Tests-That-Require-a-GUI\n-    - if [ \"$RUN_TESTS\" = \"true\" -a \"${DEP_OPTS#*NO_QT=1}\" = \"$DEP_OPTS\" ]; then export DISPLAY=:99.0; /sbin/start-stop-daemon --start --pidfile /tmp/custom_xvfb_99.pid --make-pidfile --background --exec /usr/bin/Xvfb -- :99 -ac; fi\n script:\n     - if [ \"$CHECK_DOC\" = 1 -a \"$TRAVIS_REPO_SLUG\" = \"bitcoin/bitcoin\" -a \"$TRAVIS_PULL_REQUEST\" = \"false\" ]; then while read LINE; do travis_retry gpg --keyserver hkp://subset.pool.sks-keyservers.net --recv-keys $LINE; done < contrib/verify-commits/trusted-keys; fi\n     - if [ \"$CHECK_DOC\" = 1 -a \"$TRAVIS_REPO_SLUG\" = \"bitcoin/bitcoin\" -a \"$TRAVIS_PULL_REQUEST\" = \"false\" ]; then git fetch --unshallow; fi\n@@ -68,8 +67,8 @@ script:\n     - ./configure --cache-file=../config.cache $BITCOIN_CONFIG_ALL $BITCOIN_CONFIG || ( cat config.log && false)\n     - make $MAKEJOBS $GOAL || ( echo \"Build failure. Verbose build follows.\" && make $GOAL V=1 ; false )\n     - export LD_LIBRARY_PATH=$TRAVIS_BUILD_DIR/depends/$HOST/lib\n-    - if [ \"$RUN_TESTS\" = \"true\" ]; then make $MAKEJOBS check VERBOSE=1; fi\n-    - if [ \"$TRAVIS_EVENT_TYPE\" = \"cron\" ]; then extended=\"--extended --exclude pruning\"; fi\n+    - if [ \"$RUN_TESTS\" = \"true\" ]; then travis_wait 30 make $MAKEJOBS check VERBOSE=1; fi\n+    - if [ \"$TRAVIS_EVENT_TYPE\" = \"cron\" ]; then extended=\"--extended --exclude pruning,dbcrash\"; fi\n     - if [ \"$RUN_TESTS\" = \"true\" ]; then test/functional/test_runner.py --coverage --quiet ${extended}; fi\n after_script:\n     - echo $TRAVIS_COMMIT_RANGE"
      },
      {
        "sha": "8216b7d60811bc01573622eaa5f12a856d6e53e8",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 22,
        "deletions": 36,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -59,10 +59,10 @@ OSX_PACKAGING = $(OSX_DEPLOY_SCRIPT) $(OSX_FANCY_PLIST) $(OSX_INSTALLER_ICONS) \\\n   $(top_srcdir)/contrib/macdeploy/detached-sig-apply.sh \\\n   $(top_srcdir)/contrib/macdeploy/detached-sig-create.sh\n \n-COVERAGE_INFO = baseline_filtered_combined.info baseline.info \\\n-  leveldb_baseline.info test_bitcoin_filtered.info total_coverage.info \\\n+COVERAGE_INFO = baseline.info \\\n+  test_bitcoin_filtered.info total_coverage.info \\\n   baseline_filtered.info functional_test.info functional_test_filtered.info \\\n-  leveldb_baseline_filtered.info test_bitcoin_coverage.info test_bitcoin.info\n+  test_bitcoin_coverage.info test_bitcoin.info\n \n dist-hook:\n \t-$(GIT) archive --format=tar HEAD -- src/clientversion.cpp | $(AMTAR) -C $(top_distdir) -xf -\n@@ -76,9 +76,6 @@ $(BITCOIN_WIN_INSTALLER): all-recursive\n \t  echo error: could not build $@\n \t@echo built $@\n \n-$(if $(findstring src/,$(MAKECMDGOALS)),$(MAKECMDGOALS), none): FORCE\n-\t$(MAKE) -C src $(patsubst src/%,%,$@)\n-\n $(OSX_APP)/Contents/PkgInfo:\n \t$(MKDIR_P) $(@D)\n \t@echo \"APPL????\" > $@\n@@ -169,52 +166,45 @@ $(BITCOIN_CLI_BIN): FORCE\n \t$(MAKE) -C src $(@F)\n \n if USE_LCOV\n+LCOV_FILTER_PATTERN=-p \"/usr/include/\" -p \"src/leveldb/\" -p \"src/bench/\" -p \"src/univalue\" -p \"src/crypto/ctaes\" -p \"src/secp256k1\"\n \n baseline.info:\n \t$(LCOV) -c -i -d $(abs_builddir)/src -o $@\n \n baseline_filtered.info: baseline.info\n-\t$(LCOV) -r $< \"/usr/include/*\" -o $@\n-\n-leveldb_baseline.info: baseline_filtered.info\n-\t$(LCOV) -c -i -d $(abs_builddir)/src/leveldb -b $(abs_builddir)/src/leveldb -o $@\n-\n-leveldb_baseline_filtered.info: leveldb_baseline.info\n-\t$(LCOV) -r $< \"/usr/include/*\" -o $@\n+\t$(abs_builddir)/contrib/filter-lcov.py $(LCOV_FILTER_PATTERN) $< $@\n+\t$(LCOV) -a $@ $(LCOV_OPTS) -o $@\n \n-baseline_filtered_combined.info: leveldb_baseline_filtered.info baseline_filtered.info\n-\t$(LCOV) -a leveldb_baseline_filtered.info -a baseline_filtered.info -o $@\n-\n-test_bitcoin.info: baseline_filtered_combined.info\n+test_bitcoin.info: baseline_filtered.info\n \t$(MAKE) -C src/ check\n-\t$(LCOV) -c -d $(abs_builddir)/src -t test_bitcoin -o $@\n-\t$(LCOV) -z -d $(abs_builddir)/src\n-\t$(LCOV) -z -d $(abs_builddir)/src/leveldb\n+\t$(LCOV) -c $(LCOV_OPTS) -d $(abs_builddir)/src -t test_bitcoin -o $@\n+\t$(LCOV) -z $(LCOV_OPTS) -d $(abs_builddir)/src\n \n test_bitcoin_filtered.info: test_bitcoin.info\n-\t$(LCOV) -r $< \"/usr/include/*\" -o $@\n+\t$(abs_builddir)/contrib/filter-lcov.py $(LCOV_FILTER_PATTERN) $< $@\n+\t$(LCOV) -a $@ $(LCOV_OPTS) -o $@\n \n functional_test.info: test_bitcoin_filtered.info\n-\t-@TIMEOUT=15 python test/functional/test_runner.py $(EXTENDED_FUNCTIONAL_TESTS)\n-\t$(LCOV) -c -d $(abs_builddir)/src --t functional-tests -o $@\n-\t$(LCOV) -z -d $(abs_builddir)/src\n-\t$(LCOV) -z -d $(abs_builddir)/src/leveldb\n+\t-@TIMEOUT=15 test/functional/test_runner.py $(EXTENDED_FUNCTIONAL_TESTS)\n+\t$(LCOV) -c $(LCOV_OPTS) -d $(abs_builddir)/src --t functional-tests -o $@\n+\t$(LCOV) -z $(LCOV_OPTS) -d $(abs_builddir)/src\n \n functional_test_filtered.info: functional_test.info\n-\t$(LCOV) -r $< \"/usr/include/*\" -o $@\n+\t$(abs_builddir)/contrib/filter-lcov.py $(LCOV_FILTER_PATTERN) $< $@\n+\t$(LCOV) -a $@ $(LCOV_OPTS) -o $@\n \n-test_bitcoin_coverage.info: baseline_filtered_combined.info test_bitcoin_filtered.info\n-\t$(LCOV) -a baseline_filtered.info -a leveldb_baseline_filtered.info -a test_bitcoin_filtered.info -o $@\n+test_bitcoin_coverage.info: baseline_filtered.info test_bitcoin_filtered.info\n+\t$(LCOV) -a $(LCOV_OPTS) baseline_filtered.info -a test_bitcoin_filtered.info -o $@\n \n-total_coverage.info: baseline_filtered_combined.info test_bitcoin_filtered.info functional_test_filtered.info\n-\t$(LCOV) -a baseline_filtered.info -a leveldb_baseline_filtered.info -a test_bitcoin_filtered.info -a functional_test_filtered.info -o $@ | $(GREP) \"\\%\" | $(AWK) '{ print substr($$3,2,50) \"/\" $$5 }' > coverage_percent.txt\n+total_coverage.info: test_bitcoin_filtered.info functional_test_filtered.info\n+\t$(LCOV) -a $(LCOV_OPTS) baseline_filtered.info -a test_bitcoin_filtered.info -a functional_test_filtered.info -o $@ | $(GREP) \"\\%\" | $(AWK) '{ print substr($$3,2,50) \"/\" $$5 }' > coverage_percent.txt\n \n test_bitcoin.coverage/.dirstamp:  test_bitcoin_coverage.info\n-\t$(GENHTML) -s $< -o $(@D)\n+\t$(GENHTML) -s $(LCOV_OPTS) $< -o $(@D)\n \t@touch $@\n \n total.coverage/.dirstamp: total_coverage.info\n-\t$(GENHTML) -s $< -o $(@D)\n+\t$(GENHTML) -s $(LCOV_OPTS) $< -o $(@D)\n \t@touch $@\n \n cov: test_bitcoin.coverage/.dirstamp total.coverage/.dirstamp\n@@ -226,7 +216,6 @@ dist_noinst_SCRIPTS = autogen.sh\n EXTRA_DIST = $(top_srcdir)/share/genbuild.sh test/functional/test_runner.py test/functional $(DIST_CONTRIB) $(DIST_DOCS) $(WINDOWS_PACKAGING) $(OSX_PACKAGING) $(BIN_CHECKS)\n \n EXTRA_DIST += \\\n-    test/util/bctest.py \\\n     test/util/bitcoin-util-test.py \\\n     test/util/data/bitcoin-util-test.json \\\n     test/util/data/blanktxv1.hex \\\n@@ -280,9 +269,6 @@ EXTRA_DIST += \\\n \n CLEANFILES = $(OSX_DMG) $(BITCOIN_WIN_INSTALLER)\n \n-# This file is problematic for out-of-tree builds if it exists.\n-DISTCLEANFILES = test/util/buildenv.pyc\n-\n .INTERMEDIATE: $(COVERAGE_INFO)\n \n DISTCHECK_CONFIGURE_FLAGS = --enable-man"
      },
      {
        "sha": "b9bf7bf46e54971d3f0f3b9353a707fce3ddb4a3",
        "filename": "build-aux/m4/bitcoin_find_bdb48.m4",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/build-aux/m4/bitcoin_find_bdb48.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/build-aux/m4/bitcoin_find_bdb48.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_find_bdb48.m4?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -12,7 +12,7 @@ AC_DEFUN([BITCOIN_FIND_BDB48],[\n     bdbpath=X\n     bdb48path=X\n     bdbdirlist=\n-    for _vn in 4.8 48 4 5 ''; do\n+    for _vn in 4.8 48 4 5 5.3 ''; do\n       for _pfx in b lib ''; do\n         bdbdirlist=\"$bdbdirlist ${_pfx}db${_vn}\"\n       done"
      },
      {
        "sha": "f83dba076fd132df578edfb1ec9f94715cb42317",
        "filename": "build-aux/m4/bitcoin_qt.m4",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/build-aux/m4/bitcoin_qt.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/build-aux/m4/bitcoin_qt.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_qt.m4?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -399,17 +399,17 @@ AC_DEFUN([_BITCOIN_QT_FIND_LIBS_WITH_PKGCONFIG],[\n     qt4_modules=\"QtCore QtGui QtNetwork\"\n     BITCOIN_QT_CHECK([\n       if test x$bitcoin_qt_want_version = xqt5 || ( test x$bitcoin_qt_want_version = xauto && test x$auto_priority_version = xqt5 ); then\n-        PKG_CHECK_MODULES([QT], [$qt5_modules], [QT_INCLUDES=\"$QT_CFLAGS\"; have_qt=yes],[have_qt=no])\n+        PKG_CHECK_MODULES([QT5], [$qt5_modules], [QT_INCLUDES=\"$QT5_CFLAGS\"; QT_LIBS=\"$QT5_LIBS\" have_qt=yes],[have_qt=no])\n       elif test x$bitcoin_qt_want_version = xqt4 || ( test x$bitcoin_qt_want_version = xauto && test x$auto_priority_version = xqt4 ); then\n-        PKG_CHECK_MODULES([QT], [$qt4_modules], [QT_INCLUDES=\"$QT_CFLAGS\"; have_qt=yes], [have_qt=no])\n+        PKG_CHECK_MODULES([QT4], [$qt4_modules], [QT_INCLUDES=\"$QT4_CFLAGS\"; QT_LIBS=\"$QT4_LIBS\" ; have_qt=yes], [have_qt=no])\n       fi\n \n       dnl qt version is set to 'auto' and the preferred version wasn't found. Now try the other.\n       if test x$have_qt = xno && test x$bitcoin_qt_want_version = xauto; then\n         if test x$auto_priority_version = xqt5; then\n-          PKG_CHECK_MODULES([QT], [$qt4_modules], [QT_INCLUDES=\"$QT_CFLAGS\"; have_qt=yes; QT_LIB_PREFIX=Qt; bitcoin_qt_got_major_vers=4], [have_qt=no])\n+          PKG_CHECK_MODULES([QT4], [$qt4_modules], [QT_INCLUDES=\"$QT4_CFLAGS\"; QT_LIBS=\"$QT4_LIBS\" ; have_qt=yes; QT_LIB_PREFIX=Qt; bitcoin_qt_got_major_vers=4], [have_qt=no])\n         else\n-          PKG_CHECK_MODULES([QT], [$qt5_modules], [QT_INCLUDES=\"$QT_CFLAGS\"; have_qt=yes; QT_LIB_PREFIX=Qt5; bitcoin_qt_got_major_vers=5], [have_qt=no])\n+          PKG_CHECK_MODULES([QT5], [$qt5_modules], [QT_INCLUDES=\"$QT5_CFLAGS\"; QT_LIBS=\"$QT5_LIBS\" ; have_qt=yes; QT_LIB_PREFIX=Qt5; bitcoin_qt_got_major_vers=5], [have_qt=no])\n         fi\n       fi\n       if test x$have_qt != xyes; then"
      },
      {
        "sha": "fd1396fc9ee6a4a16d0fa799bd0298518f5cdbf7",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 78,
        "deletions": 5,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -19,6 +19,12 @@ BITCOIN_GUI_NAME=bitcoin-qt\n BITCOIN_CLI_NAME=bitcoin-cli\n BITCOIN_TX_NAME=bitcoin-tx\n \n+dnl Unless the user specified ARFLAGS, force it to be cr\n+AC_ARG_VAR(ARFLAGS, [Flags for the archiver, defaults to <cr> if not set])\n+if test \"x${ARFLAGS+set}\" != \"xset\"; then\n+  ARFLAGS=\"cr\"\n+fi\n+\n AC_CANONICAL_HOST\n \n AH_TOP([#ifndef BITCOIN_CONFIG_H])\n@@ -158,13 +164,29 @@ AC_ARG_ENABLE([lcov],\n   [enable lcov testing (default is no)])],\n   [use_lcov=yes],\n   [use_lcov=no])\n+  \n+AC_ARG_ENABLE([lcov-branch-coverage],\n+  [AS_HELP_STRING([--enable-lcov-branch-coverage],\n+  [enable lcov testing branch coverage (default is no)])],\n+  [use_lcov_branch=yes],\n+  [use_lcov_branch=no])\n \n AC_ARG_ENABLE([glibc-back-compat],\n   [AS_HELP_STRING([--enable-glibc-back-compat],\n   [enable backwards compatibility with glibc])],\n   [use_glibc_compat=$enableval],\n   [use_glibc_compat=no])\n \n+AC_ARG_ENABLE([experimental-asm],\n+  [AS_HELP_STRING([--enable-experimental-asm],\n+  [Enable experimental assembly routines (default is no)])],\n+  [experimental_asm=$enableval],\n+  [experimental_asm=no])\n+\n+if test \"x$experimental_asm\" = xyes; then\n+  AC_DEFINE(EXPERIMENTAL_ASM, 1, [Define this symbol to build in experimental assembly routines])\n+fi\n+\n AC_ARG_WITH([system-univalue],\n   [AS_HELP_STRING([--with-system-univalue],\n   [Build with system UniValue (default is no)])],\n@@ -235,7 +257,36 @@ if test \"x$CXXFLAGS_overridden\" = \"xno\"; then\n   AX_CHECK_COMPILE_FLAG([-Wself-assign],[CXXFLAGS=\"$CXXFLAGS -Wno-self-assign\"],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_COMPILE_FLAG([-Wunused-local-typedef],[CXXFLAGS=\"$CXXFLAGS -Wno-unused-local-typedef\"],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_COMPILE_FLAG([-Wdeprecated-register],[CXXFLAGS=\"$CXXFLAGS -Wno-deprecated-register\"],,[[$CXXFLAG_WERROR]])\n+  AX_CHECK_COMPILE_FLAG([-Wimplicit-fallthrough],[CXXFLAGS=\"$CXXFLAGS -Wno-implicit-fallthrough\"],,[[$CXXFLAG_WERROR]])\n fi\n+\n+# Check for optional instruction set support. Enabling these does _not_ imply that all code will\n+# be compiled with them, rather that specific objects/libs may use them after checking for runtime\n+# compatibility.\n+AX_CHECK_COMPILE_FLAG([-msse4.2],[[SSE42_CXXFLAGS=\"-msse4.2\"]],,[[$CXXFLAG_WERROR]])\n+\n+TEMP_CXXFLAGS=\"$CXXFLAGS\"\n+CXXFLAGS=\"$CXXFLAGS $SSE42_CXXFLAGS\"\n+AC_MSG_CHECKING(for assembler crc32 support)\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+    #include <stdint.h>\n+    #if defined(_MSC_VER)\n+    #include <intrin.h>\n+    #elif defined(__GNUC__) && defined(__SSE4_2__)\n+    #include <nmmintrin.h>\n+    #endif\n+  ]],[[\n+    uint64_t l = 0;\n+    l = _mm_crc32_u8(l, 0);\n+    l = _mm_crc32_u32(l, 0);\n+    l = _mm_crc32_u64(l, 0);\n+    return l;\n+  ]])],\n+ [ AC_MSG_RESULT(yes); enable_hwcrc32=yes],\n+ [ AC_MSG_RESULT(no)]\n+)\n+CXXFLAGS=\"$TEMP_CXXFLAGS\"\n+\n CPPFLAGS=\"$CPPFLAGS -DHAVE_BUILD_INFO -D__STDC_FORMAT_MACROS\"\n \n AC_ARG_WITH([utils],\n@@ -435,6 +486,12 @@ if test x$use_lcov = xyes; then\n     [AC_MSG_ERROR(\"lcov testing requested but --coverage linker flag does not work\")])\n   AX_CHECK_COMPILE_FLAG([--coverage],[CXXFLAGS=\"$CXXFLAGS --coverage\"],\n     [AC_MSG_ERROR(\"lcov testing requested but --coverage flag does not work\")])\n+  AC_DEFINE(USE_COVERAGE, 1, [Define this symbol if coverage is enabled])\n+  CXXFLAGS=\"$CXXFLAGS -Og\"\n+fi\n+\n+if test x$use_lcov_branch != xno; then\n+  AC_SUBST(LCOV_OPTS, \"$LCOV_OPTS --rc lcov_branch_coverage=1\")\n fi\n \n dnl Check for endianness\n@@ -549,6 +606,8 @@ AC_CHECK_DECLS([bswap_16, bswap_32, bswap_64],,,\n                  #include <byteswap.h>\n                  #endif])\n \n+AC_CHECK_DECLS([__builtin_clz, __builtin_clzl, __builtin_clzll])\n+\n dnl Check for MSG_NOSIGNAL\n AC_MSG_CHECKING(for MSG_NOSIGNAL)\n AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/socket.h>]],\n@@ -615,6 +674,14 @@ AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <unistd.h>]],\n  [ AC_MSG_RESULT(no)]\n )\n \n+AC_MSG_CHECKING(for getentropy via random.h)\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <unistd.h>\n+ #include <sys/random.h>]],\n+ [[ getentropy(nullptr, 32) ]])],\n+ [ AC_MSG_RESULT(yes); AC_DEFINE(HAVE_GETENTROPY_RAND, 1,[Define this symbol if the BSD getentropy system call is available with sys/random.h]) ],\n+ [ AC_MSG_RESULT(no)]\n+)\n+\n AC_MSG_CHECKING(for sysctl KERN_ARND)\n AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/types.h>\n   #include <sys/sysctl.h>]],\n@@ -676,6 +743,10 @@ AX_BOOST_PROGRAM_OPTIONS\n AX_BOOST_THREAD\n AX_BOOST_CHRONO\n \n+dnl Boost 1.56 through 1.62 allow using std::atomic instead of its own atomic\n+dnl counter implementations. In 1.63 and later the std::atomic approach is default.\n+m4_pattern_allow(DBOOST_AC_USE_STD_ATOMIC) dnl otherwise it's treated like a macro\n+BOOST_CPPFLAGS=\"-DBOOST_SP_USE_STD_ATOMIC -DBOOST_AC_USE_STD_ATOMIC $BOOST_CPPFLAGS\"\n \n if test x$use_reduce_exports = xyes; then\n   AC_MSG_CHECKING([for working boost reduced exports])\n@@ -1107,6 +1178,8 @@ AM_CONDITIONAL([USE_QRCODE], [test x$use_qr = xyes])\n AM_CONDITIONAL([USE_LCOV],[test x$use_lcov = xyes])\n AM_CONDITIONAL([GLIBC_BACK_COMPAT],[test x$use_glibc_compat = xyes])\n AM_CONDITIONAL([HARDEN],[test x$use_hardening = xyes])\n+AM_CONDITIONAL([ENABLE_HWCRC32],[test x$enable_hwcrc32 = xyes])\n+AM_CONDITIONAL([EXPERIMENTAL_ASM],[test x$experimental_asm = xyes])\n \n AC_DEFINE(CLIENT_VERSION_MAJOR, _CLIENT_VERSION_MAJOR, [Major version])\n AC_DEFINE(CLIENT_VERSION_MINOR, _CLIENT_VERSION_MINOR, [Minor version])\n@@ -1139,6 +1212,7 @@ AC_SUBST(HARDENED_CPPFLAGS)\n AC_SUBST(HARDENED_LDFLAGS)\n AC_SUBST(PIC_FLAGS)\n AC_SUBST(PIE_FLAGS)\n+AC_SUBST(SSE42_CXXFLAGS)\n AC_SUBST(LIBTOOL_APP_LDFLAGS)\n AC_SUBST(USE_UPNP)\n AC_SUBST(USE_QRCODE)\n@@ -1154,13 +1228,11 @@ AC_SUBST(EVENT_PTHREADS_LIBS)\n AC_SUBST(ZMQ_LIBS)\n AC_SUBST(PROTOBUF_LIBS)\n AC_SUBST(QR_LIBS)\n-AC_CONFIG_FILES([Makefile src/Makefile doc/man/Makefile share/setup.nsi share/qt/Info.plist test/functional/config.ini])\n-AC_CONFIG_FILES([test/util/buildenv.py],[chmod +x test/util/buildenv.py])\n+AC_CONFIG_FILES([Makefile src/Makefile doc/man/Makefile share/setup.nsi share/qt/Info.plist test/config.ini])\n AC_CONFIG_FILES([contrib/devtools/split-debug.sh],[chmod +x contrib/devtools/split-debug.sh])\n AC_CONFIG_FILES([doc/Doxyfile])\n AC_CONFIG_LINKS([test/functional/test_runner.py:test/functional/test_runner.py])\n AC_CONFIG_LINKS([test/util/bitcoin-util-test.py:test/util/bitcoin-util-test.py])\n-AC_CONFIG_LINKS([test/util/bctest.py:test/util/bctest.py])\n \n dnl boost's m4 checks do something really nasty: they export these vars. As a\n dnl result, they leak into secp256k1's configure and crazy things happen.\n@@ -1208,8 +1280,8 @@ esac\n dnl Replace the BUILDDIR path with the correct Windows path if compiling on Native Windows\n case ${OS} in\n    *Windows*)\n-     sed  's/BUILDDIR=\"\\/\\([[a-z]]\\)/BUILDDIR=\"\\1:/'  test/functional/config.ini > test/functional/config-2.ini\n-     mv test/functional/config-2.ini test/functional/config.ini\n+     sed  's/BUILDDIR=\"\\/\\([[a-z]]\\)/BUILDDIR=\"\\1:/'  test/config.ini > test/config-2.ini\n+     mv test/config-2.ini test/config.ini\n    ;;\n esac\n \n@@ -1237,4 +1309,5 @@ echo \"  CPPFLAGS      = $CPPFLAGS\"\n echo \"  CXX           = $CXX\"\n echo \"  CXXFLAGS      = $CXXFLAGS\"\n echo \"  LDFLAGS       = $LDFLAGS\"\n+echo \"  ARFLAGS       = $ARFLAGS\"\n echo "
      },
      {
        "sha": "33dab9b6388890a5ba10e47fcd3b833bb0875dc4",
        "filename": "contrib/debian/changelog",
        "status": "modified",
        "additions": 122,
        "deletions": 3,
        "changes": 125,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/debian/changelog",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/debian/changelog",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/changelog?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -1,3 +1,122 @@\n+bitcoin (0.14.1-trusty4) trusty; urgency=medium\n+\n+  * Re-enable UPnP support.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Fri, 05 May 2017 13:28:00 -0400\n+\n+bitcoin (0.14.1-trusty3) trusty; urgency=medium\n+\n+  * Build with qt5 if we are on a non-Ubuntu (ie non-Unity) distro.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Thu, 04 May 2017 17:13:00 -0400\n+\n+bitcoin (0.14.1-trusty2) trusty; urgency=medium\n+\n+  * Bump minimum boost version in deps.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Thu, 04 May 2017 17:12:00 -0400\n+\n+bitcoin (0.14.1-trusty1) trusty; urgency=medium\n+\n+  * New upstream release.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Sat, 22 Apr 2017 17:10:00 -0400\n+\n+bitcoin (0.14.0-trusty1) trusty; urgency=medium\n+\n+  * New upstream release.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Wed, 08 Mar 2017 10:30:00 -0500\n+\n+bitcoin (0.13.2-trusty1) trusty; urgency=medium\n+\n+  * New upstream release.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Thu, 05 Jan 2017 09:59:00 -0500\n+\n+bitcoin (0.13.1-trusty2) trusty; urgency=medium\n+\n+  * Revert to Qt4, due to https://github.com/bitcoin/bitcoin/issues/9038\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Mon, 31 Oct 2016 11:16:00 -0400\n+\n+bitcoin (0.13.1-trusty1) trusty; urgency=medium\n+\n+  * New upstream release.\n+  * Backport updated bitcoin-qt.desktop from upstream master\n+  * Add zmq dependency\n+  * Switch to Qt5 (breaks precise, but that was already broken by C++11)\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Thu, 27 Oct 2016 17:32:00 -0400\n+\n+bitcoin (0.13.0-trusty1) trusty; urgency=medium\n+\n+  * New upstream release.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Sun, 04 Sep 2016 22:09:00 -0400\n+\n+bitcoin (0.12.1-trusty1) trusty; urgency=medium\n+\n+  * New upstream release.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Mon, 18 Apr 2016 14:26:00 -0700\n+\n+bitcoin (0.12.0-trusty6) trusty; urgency=medium\n+\n+  * Fix program-options dep.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Fri, 25 Mar 2016 21:41:00 -0700\n+\n+bitcoin (0.12.0-trusty5) trusty; urgency=medium\n+\n+  * Test explicit --with-gui\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Tue, 23 Feb 2015 23:25:00 -0800\n+\n+bitcoin (0.12.0-trusty4) trusty; urgency=medium\n+\n+  * Fix libevent-dev dep.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Tue, 23 Feb 2015 23:25:00 -0800\n+\n+bitcoin (0.12.0-trusty3) trusty; urgency=medium\n+\n+  * Fix precise boost dep.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Tue, 23 Feb 2015 19:55:00 -0800\n+\n+bitcoin (0.12.0-trusty2) trusty; urgency=medium\n+\n+  * Fix libevent dep.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Tue, 23 Feb 2015 19:53:00 -0800\n+\n+bitcoin (0.12.0-trusty1) trusty; urgency=medium\n+\n+  * New upstream release\n+  * Various updates to contrib/debian were merged, a few were not\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Tue, 23 Feb 2015 19:29:00 -0800\n+\n+bitcoin (0.11.2-trusty1) trusty; urgency=low\n+\n+  * New upstream release.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Fri, 13 Nov 2015 18:39:00 -0800\n+\n+bitcoin (0.11.1-trusty2) trusty; urgency=low\n+\n+  * Remove minupnpc builddep.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Wed, 14 Oct 2015 23:06:00 -1000\n+\n+bitcoin (0.11.1-trusty1) trusty; urgency=high\n+\n+  * New upstream release.\n+  * Disable all UPnP support.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Wed, 14 Oct 2015 13:57:00 -1000\n+\n bitcoin (0.11.0-precise1) precise; urgency=medium\n \n   * New upstream release.\n@@ -179,7 +298,7 @@ bitcoin (0.5.3-natty0) natty; urgency=low\n bitcoin (0.5.2-natty1) natty; urgency=low\n \n   * Remove mentions on anonymity in package descriptions and manpage.\n-    These should never have been there, bitcoin isn't anonymous without\n+    These should never have been there, bitcoin isnt anonymous without\n     a ton of work that virtually no users will ever be willing and\n     capable of doing\n \n@@ -220,7 +339,7 @@ bitcoin (0.5.0~rc1-natty1) natty; urgency=low\n \n   * Add test_bitcoin to build test\n   * Fix clean\n-  * Remove unnecessary build-dependancies\n+  * Remove uneccessary build-dependancies\n \n  -- Matt Corallo <matt@bluematt.me>  Wed, 26 Oct 2011 14:37:18 -0400\n \n@@ -380,7 +499,7 @@ bitcoin (0.3.20.01~dfsg-1) unstable; urgency=low\n \n bitcoin (0.3.19~dfsg-6) unstable; urgency=low\n \n-  * Fix override aggressive optimizations.\n+  * Fix override agressive optimizations.\n   * Fix tighten build-dependencies to really fit backporting to Lenny:\n     + Add fallback build-dependency on libdb4.6++-dev.\n     + Tighten unversioned Boost build-dependencies to recent versions,"
      },
      {
        "sha": "0d6ad25e249fe9b7b89a738aba89c2ca1d495587",
        "filename": "contrib/debian/control",
        "status": "modified",
        "additions": 29,
        "deletions": 26,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/debian/control",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/debian/control",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/control?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -1,27 +1,30 @@\n Source: bitcoin\n Section: utils\n Priority: optional\n-Maintainer: Jonas Smedegaard <dr@jones.dk>\n-Uploaders: Micah Anderson <micah@debian.org>\n+Maintainer: Matt Corallo <matt@mattcorallo.com>\n+Uploaders: Matt Corallo <matt@mattcorallo.com>\n Build-Depends: debhelper,\n  devscripts,\n  automake,\n  libtool,\n  bash-completion,\n- libboost-system-dev (>> 1.35) | libboost-system1.35-dev,\n  libdb4.8++-dev,\n  libssl-dev,\n  pkg-config,\n- libminiupnpc8-dev | libminiupnpc-dev (>> 1.6),\n- libboost-filesystem-dev (>> 1.35) | libboost-filesystem1.35-dev,\n- libboost-program-options-dev (>> 1.35) | libboost-program-options1.35-dev,\n- libboost-thread-dev (>> 1.35) | libboost-thread1.35-dev,\n- libboost-test-dev (>> 1.35) | libboost-test1.35-dev,\n- qt4-qmake,\n- libqt4-dev,\n+ libevent-dev,\n+ libboost-system1.48-dev | libboost-system-dev (>> 1.47),\n+ libboost-filesystem1.48-dev | libboost-filesystem-dev (>> 1.47),\n+ libboost-program-options1.48-dev | libboost-program-options-dev (>> 1.47),\n+ libboost-thread1.48-dev | libboost-thread-dev (>> 1.47),\n+ libboost-test1.48-dev | libboost-test-dev (>> 1.47),\n+ libboost-chrono1.48-dev | libboost-chrono-dev (>> 1.47),\n+ libminiupnpc8-dev | libminiupnpc-dev,\n+ qt4-qmake, libqt4-dev,\n+ qttools5-dev-tools, qttools5-dev,\n  libqrencode-dev,\n  libprotobuf-dev, protobuf-compiler,\n- python\n+ python,\n+ libzmq3-dev\n Standards-Version: 3.9.2\n Homepage: https://bitcoincore.org/\n Vcs-Git: git://github.com/bitcoin/bitcoin.git\n@@ -31,11 +34,11 @@ Package: bitcoind\n Architecture: any\n Depends: ${shlibs:Depends}, ${misc:Depends}\n Description: peer-to-peer network based digital currency - daemon\n- Bitcoin is an experimental new digital currency that enables instant\n- payments to anyone, anywhere in the world. Bitcoin uses peer-to-peer\n- technology to operate with no central authority: managing transactions\n- and issuing money are carried out collectively by the network. Bitcoin Core\n- is the name of the open source software which enables the use of this currency.\n+ Bitcoin is a free open source peer-to-peer electronic cash system that\n+ is completely decentralized, without the need for a central server or\n+ trusted parties.  Users hold the crypto keys to their own money and\n+ transact directly with each other, with the help of a P2P network to\n+ check for double-spending.\n  .\n  This package provides the daemon, bitcoind, and the CLI tool\n  bitcoin-cli to interact with the daemon.\n@@ -44,23 +47,23 @@ Package: bitcoin-qt\n Architecture: any\n Depends: ${shlibs:Depends}, ${misc:Depends}\n Description: peer-to-peer network based digital currency - Qt GUI\n- Bitcoin is an experimental new digital currency that enables instant\n- payments to anyone, anywhere in the world. Bitcoin uses peer-to-peer\n- technology to operate with no central authority: managing transactions\n- and issuing money are carried out collectively by the network. Bitcoin Core\n- is the name of the open source software which enables the use of this currency.\n+ Bitcoin is a free open source peer-to-peer electronic cash system that\n+ is completely decentralized, without the need for a central server or\n+ trusted parties.  Users hold the crypto keys to their own money and\n+ transact directly with each other, with the help of a P2P network to\n+ check for double-spending.\n  .\n  This package provides Bitcoin-Qt, a GUI for Bitcoin based on Qt.\n \n Package: bitcoin-tx\n Architecture: any\n Depends: ${shlibs:Depends}, ${misc:Depends}\n Description: peer-to-peer digital currency - standalone transaction tool\n- Bitcoin is an experimental new digital currency that enables instant\n- payments to anyone, anywhere in the world. Bitcoin uses peer-to-peer\n- technology to operate with no central authority: managing transactions\n- and issuing money are carried out collectively by the network. Bitcoin Core\n- is the name of the open source software which enables the use of this currency.\n+ Bitcoin is a free open source peer-to-peer electronic cash system that\n+ is completely decentralized, without the need for a central server or\n+ trusted parties.  Users hold the crypto keys to their own money and\n+ transact directly with each other, with the help of a P2P network to\n+ check for double-spending.\n  .\n  This package provides bitcoin-tx, a command-line transaction creation\n  tool which can be used without a bitcoin daemon.  Some means of"
      },
      {
        "sha": "6885e3852126f17e910cbe4236b4f773a1fd8de6",
        "filename": "contrib/debian/rules",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/debian/rules",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/debian/rules",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/rules?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -12,10 +12,12 @@ override_dh_auto_clean:\n \tif [ -f Makefile ]; then $(MAKE) distclean; fi\n \trm -rf Makefile.in aclocal.m4 configure src/Makefile.in src/bitcoin-config.h.in src/build-aux src/qt/Makefile.in src/qt/test/Makefile.in src/test/Makefile.in\n \n+QT=$(shell dpkg-vendor --derives-from Ubuntu && echo qt4 || echo qt5)\n+\n # Yea, autogen should be run on the source archive, but I like doing git archive\n override_dh_auto_configure:\n \t./autogen.sh\n-\t./configure\n+\t./configure --with-gui=$(QT)\n \n override_dh_auto_test:\n \tmake check"
      },
      {
        "sha": "3b7a8f9a61e62b53eb239b9969af7ade1740a8e4",
        "filename": "contrib/devtools/check-doc.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/devtools/check-doc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/devtools/check-doc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/check-doc.py?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -21,7 +21,7 @@\n REGEX_ARG = re.compile(r'(?:map(?:Multi)?Args(?:\\.count\\(|\\[)|Get(?:Bool)?Arg\\()\\\"(\\-[^\\\"]+?)\\\"')\n REGEX_DOC = re.compile(r'HelpMessageOpt\\(\\\"(\\-[^\\\"=]+?)(?:=|\\\")')\n # list unsupported, deprecated and duplicate args as they need no documentation\n-SET_DOC_OPTIONAL = set(['-rpcssl', '-benchmark', '-h', '-help', '-socks', '-tor', '-debugnet', '-whitelistalwaysrelay', '-prematurewitness', '-walletprematurewitness', '-promiscuousmempoolflags', '-blockminsize', '-sendfreetransactions'])\n+SET_DOC_OPTIONAL = set(['-rpcssl', '-benchmark', '-h', '-help', '-socks', '-tor', '-debugnet', '-whitelistalwaysrelay', '-prematurewitness', '-walletprematurewitness', '-promiscuousmempoolflags', '-blockminsize', '-dbcrashratio', '-forcecompactdb'])\n \n def main():\n   used = check_output(CMD_GREP_ARGS, shell=True)"
      },
      {
        "sha": "1c9dbc7f68ff5355fa02848dd6c85d659cf8d409",
        "filename": "contrib/devtools/commit-script-check.sh",
        "status": "added",
        "additions": 46,
        "deletions": 0,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/devtools/commit-script-check.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/devtools/commit-script-check.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/commit-script-check.sh?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -0,0 +1,46 @@\n+#!/bin/sh\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+# This simple script checks for commits beginning with: scripted-diff:\n+# If found, looks for a script between the lines -BEGIN VERIFY SCRIPT- and\n+# -END VERIFY SCRIPT-. If no ending is found, it reads until the end of the\n+# commit message.\n+\n+# The resulting script should exactly transform the previous commit into the current\n+# one. Any remaining diff signals an error.\n+\n+if test \"x$1\" = \"x\"; then\n+    echo \"Usage: $0 <commit>...\"\n+    exit 1\n+fi\n+\n+RET=0\n+PREV_BRANCH=`git name-rev --name-only HEAD`\n+PREV_HEAD=`git rev-parse HEAD`\n+for i in `git rev-list --reverse $1`; do\n+    if git rev-list -n 1 --pretty=\"%s\" $i | grep -q \"^scripted-diff:\"; then\n+        git checkout --quiet $i^ || exit\n+        SCRIPT=\"`git rev-list --format=%b -n1 $i | sed '/^-BEGIN VERIFY SCRIPT-$/,/^-END VERIFY SCRIPT-$/{//!b};d'`\"\n+        if test \"x$SCRIPT\" = \"x\"; then\n+            echo \"Error: missing script for: $i\"\n+            echo \"Failed\"\n+            RET=1\n+        else\n+            echo \"Running script for: $i\"\n+            echo \"$SCRIPT\"\n+            eval \"$SCRIPT\"\n+            git --no-pager diff --exit-code $i && echo \"OK\" || (echo \"Failed\"; false) || RET=1\n+        fi\n+        git reset --quiet --hard HEAD\n+     else\n+        if git rev-list \"--format=%b\" -n1 $i | grep -q '^-\\(BEGIN\\|END\\)[ a-zA-Z]*-$'; then\n+            echo \"Error: script block marker but no scripted-diff in title\"\n+            echo \"Failed\"\n+            RET=1\n+        fi\n+    fi\n+done\n+git checkout --quiet $PREV_BRANCH 2>/dev/null || git checkout --quiet $PREV_HEAD\n+exit $RET"
      },
      {
        "sha": "c664cf81fa9f63ac3fb4a32a19840442927b7450",
        "filename": "contrib/devtools/github-merge.py",
        "status": "modified",
        "additions": 26,
        "deletions": 28,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/devtools/github-merge.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/devtools/github-merge.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/github-merge.py?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2016 The Bitcoin Core developers\n+# Copyright (c) 2016-2017 Bitcoin Core Developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -127,6 +127,9 @@ def tree_sha512sum(commit='HEAD'):\n         raise IOError('Non-zero return value executing git cat-file')\n     return overall.hexdigest()\n \n+def print_merge_details(pull, title, branch, base_branch, head_branch):\n+    print('%s#%s%s %s %sinto %s%s' % (ATTR_RESET+ATTR_PR,pull,ATTR_RESET,title,ATTR_RESET+ATTR_PR,branch,ATTR_RESET))\n+    subprocess.check_call([GIT,'log','--graph','--topo-order','--pretty=format:'+COMMIT_FORMAT,base_branch+'..'+head_branch])\n \n def parse_arguments():\n     epilog = '''\n@@ -171,7 +174,8 @@ def main():\n     info = retrieve_pr_info(repo,pull)\n     if info is None:\n         exit(1)\n-    title = info['title']\n+    title = info['title'].strip()\n+    body = info['body'].strip()\n     # precedence order for destination branch argument:\n     #   - command line argument\n     #   - githubmerge.branch setting\n@@ -226,6 +230,7 @@ def main():\n             firstline = 'Merge #%s' % (pull,)\n         message = firstline + '\\n\\n'\n         message += subprocess.check_output([GIT,'log','--no-merges','--topo-order','--pretty=format:%h %s (%an)',base_branch+'..'+head_branch]).decode('utf-8')\n+        message += '\\n\\nPull request description:\\n\\n  ' + body.replace('\\n', '\\n  ') + '\\n'\n         try:\n             subprocess.check_call([GIT,'merge','-q','--commit','--no-edit','--no-ff','-m',message.encode('utf-8'),head_branch])\n         except subprocess.CalledProcessError as e:\n@@ -256,8 +261,7 @@ def main():\n             printf(\"ERROR: Cannot update message.\",file=stderr)\n             exit(4)\n \n-        print('%s#%s%s %s %sinto %s%s' % (ATTR_RESET+ATTR_PR,pull,ATTR_RESET,title,ATTR_RESET+ATTR_PR,branch,ATTR_RESET))\n-        subprocess.check_call([GIT,'log','--graph','--topo-order','--pretty=format:'+COMMIT_FORMAT,base_branch+'..'+head_branch])\n+        print_merge_details(pull, title, branch, base_branch, head_branch)\n         print()\n \n         # Run test command if configured.\n@@ -276,12 +280,6 @@ def main():\n                     print(\"Difference with github ignored.\",file=stderr)\n                 else:\n                     exit(6)\n-            reply = ask_prompt(\"Press 'd' to accept the diff.\")\n-            if reply.lower() == 'd':\n-                print(\"Diff accepted.\",file=stderr)\n-            else:\n-                print(\"ERROR: Diff rejected.\",file=stderr)\n-                exit(6)\n         else:\n             # Verify the result manually.\n             print(\"Dropping you on a shell so you can try building/testing the merged source.\",file=stderr)\n@@ -290,29 +288,25 @@ def main():\n             if os.path.isfile('/etc/debian_version'): # Show pull number on Debian default prompt\n                 os.putenv('debian_chroot',pull)\n             subprocess.call([BASH,'-i'])\n-            reply = ask_prompt(\"Type 'm' to accept the merge.\")\n-            if reply.lower() == 'm':\n-                print(\"Merge accepted.\",file=stderr)\n-            else:\n-                print(\"ERROR: Merge rejected.\",file=stderr)\n-                exit(7)\n \n         second_sha512 = tree_sha512sum()\n         if first_sha512 != second_sha512:\n             print(\"ERROR: Tree hash changed unexpectedly\",file=stderr)\n             exit(8)\n \n         # Sign the merge commit.\n-        reply = ask_prompt(\"Type 's' to sign off on the merge.\")\n-        if reply == 's':\n-            try:\n-                subprocess.check_call([GIT,'commit','-q','--gpg-sign','--amend','--no-edit'])\n-            except subprocess.CalledProcessError as e:\n-                print(\"Error signing, exiting.\",file=stderr)\n+        print_merge_details(pull, title, branch, base_branch, head_branch)\n+        while True:\n+            reply = ask_prompt(\"Type 's' to sign off on the above merge, or 'x' to reject and exit.\").lower()\n+            if reply == 's':\n+                try:\n+                    subprocess.check_call([GIT,'commit','-q','--gpg-sign','--amend','--no-edit'])\n+                    break\n+                except subprocess.CalledProcessError as e:\n+                    print(\"Error while signing, asking again.\",file=stderr)\n+            elif reply == 'x':\n+                print(\"Not signing off on merge, exiting.\",file=stderr)\n                 exit(1)\n-        else:\n-            print(\"Not signing off on merge, exiting.\",file=stderr)\n-            exit(1)\n \n         # Put the result in branch.\n         subprocess.check_call([GIT,'checkout','-q',branch])\n@@ -326,9 +320,13 @@ def main():\n         subprocess.call([GIT,'branch','-q','-D',local_merge_branch],stderr=devnull)\n \n     # Push the result.\n-    reply = ask_prompt(\"Type 'push' to push the result to %s, branch %s.\" % (host_repo,branch))\n-    if reply.lower() == 'push':\n-        subprocess.check_call([GIT,'push',host_repo,'refs/heads/'+branch])\n+    while True:\n+        reply = ask_prompt(\"Type 'push' to push the result to %s, branch %s, or 'x' to exit without pushing.\" % (host_repo,branch)).lower()\n+        if reply == 'push':\n+            subprocess.check_call([GIT,'push',host_repo,'refs/heads/'+branch])\n+            break\n+        elif reply == 'x':\n+            exit(1)\n \n if __name__ == '__main__':\n     main()"
      },
      {
        "sha": "299377d691155308875fb95fe5b7f49f9e8d50dc",
        "filename": "contrib/filter-lcov.py",
        "status": "added",
        "additions": 25,
        "deletions": 0,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/filter-lcov.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/filter-lcov.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/filter-lcov.py?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -0,0 +1,25 @@\n+#!/usr/bin/env python3\n+\n+import argparse\n+\n+parser = argparse.ArgumentParser(description='Remove the coverage data from a tracefile for all files matching the pattern.')\n+parser.add_argument('--pattern', '-p', action='append', help='the pattern of files to remove', required=True)\n+parser.add_argument('tracefile', help='the tracefile to remove the coverage data from')\n+parser.add_argument('outfile', help='filename for the output to be written to')\n+\n+args = parser.parse_args()\n+tracefile = args.tracefile\n+pattern = args.pattern\n+outfile = args.outfile\n+\n+in_remove = False\n+with open(tracefile, 'r') as f:\n+    with open(outfile, 'w') as wf:\n+        for line in f:\n+            for p in pattern:\n+                if line.startswith(\"SF:\") and p in line:\n+                    in_remove = True\n+            if not in_remove:\n+                wf.write(line)\n+            if line == 'end_of_record\\n':\n+                in_remove = False"
      },
      {
        "sha": "3da8510cfbd70132954e678ee80f07f9c9e16234",
        "filename": "contrib/gitian-descriptors/gitian-linux.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/gitian-descriptors/gitian-linux.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/gitian-descriptors/gitian-linux.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-linux.yml?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -132,6 +132,7 @@ script: |\n   export PATH=${WRAP_DIR}:${PATH}\n \n   # Create the release tarball using (arbitrarily) the first host\n+  export GIT_DIR=\"$PWD/.git\"\n   ./autogen.sh\n   CONFIG_SITE=${BASEPREFIX}/`echo \"${HOSTS}\" | awk '{print $1;}'`/share/config.site ./configure --prefix=/\n   make dist"
      },
      {
        "sha": "206db7c19e751d414d51d4aaeb2e7bf6bff6288b",
        "filename": "contrib/gitian-descriptors/gitian-osx.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/gitian-descriptors/gitian-osx.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/gitian-descriptors/gitian-osx.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-osx.yml?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -101,6 +101,7 @@ script: |\n   export PATH=${WRAP_DIR}:${PATH}\n \n   # Create the release tarball using (arbitrarily) the first host\n+  export GIT_DIR=\"$PWD/.git\"\n   ./autogen.sh\n   CONFIG_SITE=${BASEPREFIX}/`echo \"${HOSTS}\" | awk '{print $1;}'`/share/config.site ./configure --prefix=/\n   make dist"
      },
      {
        "sha": "1d4d70494b0cc403649235133c72cbbbc8b2fba0",
        "filename": "contrib/gitian-descriptors/gitian-win.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/gitian-descriptors/gitian-win.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/gitian-descriptors/gitian-win.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-win.yml?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -116,6 +116,7 @@ script: |\n   export PATH=${WRAP_DIR}:${PATH}\n \n   # Create the release tarball using (arbitrarily) the first host\n+  export GIT_DIR=\"$PWD/.git\"\n   ./autogen.sh\n   CONFIG_SITE=${BASEPREFIX}/`echo \"${HOSTS}\" | awk '{print $1;}'`/share/config.site ./configure --prefix=/\n   make dist"
      },
      {
        "sha": "eed232a8722de569dc75dc97fc926e18b060898a",
        "filename": "contrib/gitian-keys/laanwj-key.pgp",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/gitian-keys/laanwj-key.pgp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/gitian-keys/laanwj-key.pgp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-keys/laanwj-key.pgp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "f70e25cb5fdd29e49de2c89b81bd92633e5b93df",
        "filename": "contrib/init/bitcoind.openrcconf",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/init/bitcoind.openrcconf",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/init/bitcoind.openrcconf",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/init/bitcoind.openrcconf?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -23,7 +23,7 @@\n #BITCOIND_NICE=0\n \n # Additional options (avoid -conf and -datadir, use flags above)\n-BITCOIND_OPTS=\"-disablewallet\"\n+#BITCOIND_OPTS=\"\"\n \n # The timeout in seconds OpenRC will wait for bitcoind to terminate\n # after a SIGTERM has been raised."
      },
      {
        "sha": "23a568ad13aeb91d79e51de4283b0959c4baf027",
        "filename": "contrib/macdeploy/macdeployqtplus",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/macdeploy/macdeployqtplus",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/macdeploy/macdeployqtplus",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/macdeployqtplus?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -302,7 +302,6 @@ def copyFramework(framework, path, verbose):\n         if os.path.exists(fromContentsDir):\n             toContentsDir = os.path.join(path, framework.destinationVersionContentsDirectory)\n             shutil.copytree(fromContentsDir, toContentsDir, symlinks=True)\n-            contentslinkfrom = os.path.join(path, framework.destinationContentsDirectory)\n             if verbose >= 3:\n                 print(\"Copied Contents:\", fromContentsDir)\n                 print(\" to:\", toContentsDir)\n@@ -675,9 +674,8 @@ else:\n if verbose >= 2:\n     print(\"+ Installing qt.conf +\")\n \n-f = open(os.path.join(applicationBundle.resourcesPath, \"qt.conf\"), \"wb\")\n-f.write(qt_conf.encode())\n-f.close()\n+with open(os.path.join(applicationBundle.resourcesPath, \"qt.conf\"), \"wb\") as f:\n+    f.write(qt_conf.encode())\n \n # ------------------------------------------------\n "
      },
      {
        "sha": "4ab2f356803a8933edd1fe7b573533281ef7c1f2",
        "filename": "contrib/rpm/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/rpm/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/rpm/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/rpm/README.md?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -181,5 +181,5 @@ knows what they are getting when installing the GUI package.\n \n As far as minor differences, I generally prefer to assign the file permissions\n in the `%files` portion of an RPM spec file rather than specifying the\n-permissions of a file during `%install` and other minor things like that that\n+permissions of a file during `%install` and other minor things like that\n are largely just cosmetic."
      },
      {
        "sha": "b206866cc5eb4abc3075f8692637a7096d7f0b0e",
        "filename": "contrib/rpm/bitcoin.if",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/rpm/bitcoin.if",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/rpm/bitcoin.if",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/rpm/bitcoin.if?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -121,7 +121,7 @@ interface(`bitcoin_manage_lib_dirs',`\n ########################################\n ## <summary>\n ##\tAll of the rules required to administrate\n-##\tan bitcoin environment\n+##\ta bitcoin environment\n ## </summary>\n ## <param name=\"domain\">\n ##\t<summary>"
      },
      {
        "sha": "139c03181fc806a9854a3ad307146883df0e47cf",
        "filename": "contrib/seeds/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/seeds/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/seeds/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/seeds/README.md?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -8,7 +8,7 @@ and remove old versions as necessary.\n \n The seeds compiled into the release are created from sipa's DNS seed data, like this:\n \n-    curl -s http://bitcoin.sipa.be/seeds.txt > seeds_main.txt\n+    curl -s http://bitcoin.sipa.be/seeds.txt.gz | gzip -dc > seeds_main.txt\n     python3 makeseeds.py < seeds_main.txt > nodes_main.txt\n     python3 generate-seeds.py . > ../../src/chainparamsseeds.h\n "
      },
      {
        "sha": "877a7836ef74a8a382cc76d7407179b108329af5",
        "filename": "contrib/seeds/makeseeds.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/seeds/makeseeds.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/seeds/makeseeds.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/seeds/makeseeds.py?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -30,7 +30,7 @@\n PATTERN_IPV4 = re.compile(r\"^((\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})):(\\d+)$\")\n PATTERN_IPV6 = re.compile(r\"^\\[([0-9a-z:]+)\\]:(\\d+)$\")\n PATTERN_ONION = re.compile(r\"^([abcdefghijklmnopqrstuvwxyz234567]{16}\\.onion):(\\d+)$\")\n-PATTERN_AGENT = re.compile(r\"^(/Satoshi:0.12.(0|1|99)/|/Satoshi:0.13.(0|1|2|99)/)$\")\n+PATTERN_AGENT = re.compile(r\"^(/Satoshi:0.13.(1|2|99)/|/Satoshi:0.14.(0|1|2|99)/)$\")\n \n def parseline(line):\n     sline = line.split()"
      },
      {
        "sha": "60b34216cd634388e2bd697077616c1075aad204",
        "filename": "contrib/seeds/nodes_main.txt",
        "status": "modified",
        "additions": 1168,
        "deletions": 886,
        "changes": 2054,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/seeds/nodes_main.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/seeds/nodes_main.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/seeds/nodes_main.txt?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -1,1168 +1,1450 @@\n-2.7.8.12:8333\n 2.228.70.198:8333\n-5.39.64.7:8333\n-5.45.80.34:38333\n-5.51.160.38:8333\n-5.61.33.33:8333\n-5.61.37.12:8333\n-5.95.80.47:8333\n-5.102.164.173:8333\n-5.175.71.130:8333\n-5.189.165.22:8333\n-5.199.130.228:8333\n-5.228.100.222:8333\n+4.15.180.29:8333\n+4.15.180.30:8333\n+5.2.67.110:8333\n+5.39.224.103:8333\n+5.43.124.154:8333\n+5.189.165.102:8333\n+5.226.149.145:8333\n+5.228.7.146:8333\n+5.228.64.71:8333\n+5.249.152.101:8333\n+5.254.124.55:8333\n 5.255.64.231:8333\n-13.93.6.133:8333\n-18.85.34.10:8333\n-18.241.0.63:8333\n+5.255.90.234:8333\n+14.192.8.27:21301\n+18.62.3.86:8333\n+18.85.35.80:8333\n 23.28.128.65:8333\n-23.248.113.52:8333\n-23.253.151.73:8333\n-24.4.96.121:8333\n-24.69.65.191:8333\n-24.87.8.43:8333\n-24.150.224.110:8333\n+23.108.83.12:8333\n+23.233.2.238:8333\n+24.27.65.168:8333\n+24.56.241.219:8333\n+24.64.75.132:8333\n+24.73.70.26:8333\n+24.121.154.140:8333\n+24.203.96.72:8333\n+24.225.34.62:8333\n 24.227.69.146:8333\n-27.0.235.33:8333\n-31.170.106.203:8333\n-31.184.197.96:8333\n-31.214.240.56:8333\n-37.1.202.134:8333\n-37.18.74.232:8333\n-37.34.48.17:8333\n+24.232.136.119:8333\n+31.16.123.235:8333\n+31.19.205.53:8333\n+31.132.136.35:8333\n+31.184.234.85:8333\n+31.211.102.161:8333\n 37.48.64.140:8333\n 37.97.141.116:8333\n+37.120.160.12:8333\n 37.120.164.16:8333\n-37.120.169.123:8333\n-37.143.9.128:8333\n-37.153.172.227:8333\n-37.193.227.16:8333\n-37.205.8.78:8333\n-37.220.0.114:8333\n-37.232.218.199:8333\n-38.140.161.53:8333\n-40.87.70.120:8333\n-41.162.163.93:8333\n-42.2.198.48:8333\n-45.20.67.1:8333\n-45.55.197.77:8333\n+37.134.226.181:8333\n+37.147.110.43:8333\n+37.194.10.30:8333\n+37.247.22.53:8333\n+38.27.65.158:8333\n+38.133.141.34:8333\n+43.248.160.151:8333\n+45.32.130.19:8333\n+45.32.193.157:8333\n+45.46.161.121:8333\n 45.56.97.63:8333\n-45.58.38.162:8333\n-45.63.1.33:8333\n-45.79.2.70:8333\n+45.116.178.79:8188\n 46.16.240.98:8333\n-46.19.137.74:8333\n-46.28.206.146:8333\n-46.32.252.197:8333\n+46.20.246.100:8333\n+46.21.97.135:8333\n+46.59.10.237:8333\n 46.59.13.59:8333\n-46.59.39.195:8333\n 46.148.16.210:8333\n-46.160.195.121:8333\n-46.166.142.21:8333\n-46.166.160.29:8330\n+46.166.160.96:8333\n 46.188.44.20:8333\n 46.229.238.187:8333\n 46.231.16.149:8333\n+47.88.35.181:8333\n 47.88.100.130:8333\n-47.89.192.134:8333\n-47.185.194.160:8333\n-47.189.129.218:8333\n-49.65.2.140:8333\n-50.3.72.129:8333\n-50.31.99.225:8333\n-51.175.33.95:8333\n-52.1.165.219:8333\n-52.10.170.186:8333\n-52.51.128.216:8333\n-54.197.130.244:8333\n-58.59.2.22:8333\n-58.84.6.81:8333\n-59.125.8.143:8333\n-59.167.130.139:8333\n+47.184.129.94:8333\n+47.199.68.204:8333\n+50.30.38.203:8333\n+50.63.162.242:8333\n+50.97.133.208:8333\n+50.114.227.224:8333\n+51.15.0.17:8333\n+51.174.69.239:8333\n+52.7.135.69:8333\n+52.14.64.82:8333\n+52.204.105.25:8333\n+54.255.160.87:8333\n 61.47.2.20:8333\n+61.125.131.55:8333\n 62.43.130.178:8333\n-62.76.96.6:8333\n+62.106.16.111:8333\n 62.107.200.30:8333\n-62.133.15.58:8333\n+62.109.20.99:8333\n 62.133.194.2:8333\n 62.133.194.156:8333\n-62.138.1.95:8333\n-62.216.238.3:8333\n-62.238.34.125:8333\n-63.137.40.207:8333\n-63.231.96.109:8333\n-64.78.240.150:8333\n-64.83.225.146:8333\n-64.137.236.68:8833\n-64.156.193.120:8333\n-66.79.160.82:8333\n-66.91.230.231:8333\n-66.135.128.121:8333\n-66.172.10.4:8333\n+62.176.6.94:8333\n+62.182.169.222:8333\n+62.205.132.245:8333\n+62.216.238.133:8333\n+63.231.239.212:8333\n+64.34.231.140:8333\n+64.203.102.86:8333\n+64.233.245.39:8333\n+65.183.76.73:8333\n+66.96.199.166:8333\n 66.194.38.250:8333\n 66.194.38.253:8333\n-66.215.34.26:8333\n-66.240.237.155:8333\n-67.205.96.108:8333\n-67.205.128.5:8333\n-67.219.233.140:8333\n+66.196.12.63:8333\n+67.215.6.34:8333\n 67.221.193.55:8333\n-68.100.196.118:8333\n+68.66.193.192:8333\n+68.69.235.230:8333\n+68.111.10.219:8333\n+68.119.138.175:8333\n 68.132.193.222:8333\n-68.168.118.234:8333\n+68.194.42.76:8333\n+68.235.41.204:8333\n 69.11.97.43:8333\n-69.30.229.10:8333\n-69.50.171.205:8333\n-69.125.193.145:8333\n-69.162.139.125:8333\n-70.35.98.39:8333\n+69.41.3.212:8333\n+69.41.171.35:8333\n+69.41.171.36:8333\n+69.55.64.216:8333\n+69.84.42.56:8333\n+70.48.48.250:8333\n 70.112.32.29:8333\n-71.126.181.146:8333\n-72.180.32.105:8333\n-73.226.64.145:8333\n-74.83.140.242:8333\n-74.84.128.158:9333\n+70.250.74.20:8333\n+71.93.161.162:8333\n+71.198.0.126:8333\n+72.5.167.41:8333\n+72.224.11.103:8333\n+73.72.160.213:8333\n 74.122.237.124:8333\n-74.215.133.145:8333\n-75.76.101.169:8333\n-75.85.13.8:8333\n-75.86.168.13:8333\n-75.170.97.25:8333\n-75.177.137.134:8333\n+75.86.137.34:8333\n+75.165.99.144:8333\n+76.64.74.193:8333\n 76.76.227.136:8333\n-77.53.136.6:8333\n-77.110.11.52:8333\n-78.25.32.206:8333\n-78.34.8.120:8333\n-78.46.32.99:8333\n-78.56.9.214:8333\n-78.56.229.177:8333\n-78.129.237.245:8333\n+76.173.161.44:8333\n+76.178.22.44:8333\n+77.47.137.27:8333\n+77.77.46.250:8333\n+77.91.193.152:8333\n+77.95.226.194:8333\n+77.120.246.254:8333\n+77.163.136.136:8333\n+77.203.13.57:8333\n+77.236.37.214:8333\n+77.239.37.12:8333\n+77.247.179.44:8333\n+78.34.14.52:8333\n+78.109.163.153:8333\n 78.196.172.45:8333\n 79.132.230.144:8333\n-79.169.35.235:8333\n-79.172.194.219:8333\n-80.64.65.87:8333\n-80.89.137.115:8333\n-80.93.36.173:8333\n-80.101.167.100:8333\n-80.114.34.158:8333\n-80.127.136.50:8333\n-80.188.139.82:8333\n-80.222.39.77:8333\n-80.223.105.69:8333\n-80.229.151.187:8333\n-80.240.129.221:8333\n+79.160.2.105:8333\n+80.82.77.138:8333\n+80.100.203.151:8333\n+80.147.68.237:8333\n+80.237.240.102:8333\n+81.2.246.127:8333\n+81.7.7.86:8333\n 81.7.10.238:8333\n-81.7.13.84:8333\n-81.27.96.92:8333\n-81.35.143.98:8333\n-81.82.201.5:8333\n+81.27.96.37:8333\n 81.83.96.5:8333\n-81.169.227.36:8333\n-81.171.2.119:8333\n-81.171.38.130:8333\n-81.175.255.118:8333\n-81.207.8.49:8333\n 81.228.194.187:8333\n-82.9.1.77:8333\n-82.11.33.229:8333\n-82.102.13.117:8333\n-82.116.203.240:8333\n-82.130.103.16:8333\n-82.136.65.227:8333\n-82.158.227.238:8333\n-82.197.212.25:8333\n+82.45.69.216:8333\n+82.69.44.183:8333\n+82.72.198.68:8333\n+82.95.204.10:8333\n+82.118.236.127:8333\n+82.118.242.4:8333\n+82.134.66.146:8333\n+82.193.109.199:8333\n+82.197.210.65:8333\n 82.199.102.10:8333\n-82.200.204.41:8333\n-82.200.204.119:8333\n-82.221.105.223:8333\n+82.200.205.30:8333\n 82.221.108.27:8333\n-82.221.111.136:8333\n+82.221.128.81:8333\n 82.221.139.97:8333\n+82.232.202.246:8333\n+83.60.64.252:8333\n+83.61.8.228:8333\n+83.128.41.48:8333\n+83.128.111.69:8333\n 83.137.41.10:8333\n-83.143.130.19:8333\n-83.150.9.196:8333\n+83.150.43.17:8333\n 83.169.2.43:8333\n-83.217.203.130:8333\n-83.249.88.52:8333\n-84.26.162.92:8333\n+83.174.209.87:8333\n+83.255.43.163:8333\n 84.42.193.6:8333\n-84.134.194.115:8333\n-84.201.32.115:8333\n-84.212.232.71:8333\n-84.238.140.176:8333\n-85.10.104.34:8333\n+84.52.145.231:8333\n+84.52.234.70:8333\n+84.85.102.113:8333\n+84.92.92.247:8333\n+84.146.35.123:8333\n+84.212.198.222:8333\n+84.217.163.135:8333\n+84.245.27.185:8333\n+84.251.203.5:8333\n 85.21.144.226:8333\n 85.25.194.12:8333\n-85.144.79.190:8333\n-85.145.228.192:8333\n-85.194.238.130:8333\n-85.228.201.80:8333\n-85.229.228.174:8333\n-85.236.233.87:8333\n-86.80.204.185:8333\n-86.105.227.190:8333\n-86.135.39.40:8333\n-87.106.139.127:8333\n+85.25.194.28:8333\n+85.144.119.222:8333\n+85.183.140.62:8333\n+85.214.228.203:8333\n+85.214.234.254:8333\n+85.218.150.1:8333\n+85.228.196.10:8333\n+86.15.2.235:8333\n+86.61.6.210:8333\n+87.92.115.194:8333\n 87.120.8.5:8333\n 87.120.37.230:8333\n+87.233.181.146:8333\n 87.239.101.102:8333\n-87.243.197.82:8333\n-88.112.112.173:8333\n+88.87.78.126:8333\n+88.98.198.130:8333\n+88.98.225.214:8333\n+88.99.58.194:8333\n 88.150.192.17:8333\n-88.185.155.134:8333\n-88.202.202.221:8333\n-88.202.230.87:8333\n-88.208.39.182:8333\n+88.196.136.31:17556\n+88.208.58.193:8333\n+88.208.58.194:8333\n+89.22.96.132:8333\n+89.22.104.48:8333\n+89.25.80.98:8333\n 89.34.99.41:8333\n+89.142.195.112:8333\n 89.163.224.187:8333\n-89.169.233.150:8333\n-89.184.65.85:8333\n-89.212.91.219:8333\n-89.249.178.36:8333\n+89.163.224.195:8333\n+89.238.79.235:8333\n+90.46.240.214:8333\n+90.65.232.129:8333\n+90.71.117.90:8333\n 90.149.38.172:8333\n-91.65.97.157:8333\n-91.107.64.143:8333\n-91.114.35.107:8333\n+90.156.97.145:8333\n+90.177.48.104:8333\n+91.106.194.97:8333\n 91.135.0.187:8333\n-91.145.110.95:8333\n-91.157.38.151:8333\n+91.150.189.155:8333\n+91.185.198.216:8333\n+91.196.11.45:8333\n 91.197.44.133:8333\n-91.205.176.54:8333\n-91.206.203.10:8333\n-91.206.203.18:8333\n-91.215.35.130:8333\n-91.219.239.159:8333\n-91.223.133.2:8333\n-91.223.133.40:8333\n+91.224.0.227:8333\n 91.226.10.90:8333\n+91.228.45.130:8333\n+91.229.77.239:8333\n+91.238.100.249:8333\n 91.240.141.169:8333\n 92.27.7.209:8333\n-92.89.67.207:8333\n-92.221.201.138:8333\n-93.95.187.122:8333\n-93.103.73.187:8333\n+92.54.16.135:8333\n+93.89.84.93:8333\n+93.100.51.48:8333\n+93.100.76.151:8333\n+93.104.214.235:8333\n+93.115.86.246:8333\n 93.123.80.47:8333\n+93.174.88.211:8333\n 93.188.224.253:8333\n 93.190.69.242:8333\n-94.19.12.244:8333\n-94.156.128.116:8333\n-94.177.171.73:8333\n+94.74.81.93:8333\n+94.156.35.8:8333\n+94.176.237.241:8333\n 94.181.44.104:8333\n-94.237.26.173:8333\n-94.242.229.158:8333\n-94.255.128.98:8333\n-95.79.35.50:8333\n-95.91.41.39:8333\n-95.110.234.93:8333\n-95.128.48.209:8333\n+94.227.43.171:8333\n+95.79.102.208:8333\n+95.79.102.209:8333\n+95.154.237.24:8333\n+95.183.48.62:8333\n 95.183.48.71:8333\n-96.23.67.85:8333\n-97.64.177.10:8333\n-97.104.201.95:8333\n-98.29.197.149:8333\n-98.169.2.107:8333\n-99.232.48.72:8333\n-101.100.141.55:8333\n-103.7.32.40:8333\n-103.53.225.69:8333\n-103.249.106.74:8333\n-104.128.224.13:8333\n-104.128.228.252:8333\n-104.155.1.158:8333\n-104.168.128.50:8333\n-104.199.160.228:8333\n-104.204.109.11:8333\n-104.219.251.118:8333\n-104.223.3.129:8333\n-104.223.3.219:8333\n-104.238.130.182:8333\n-104.245.99.227:8333\n-106.38.234.89:8333\n-106.104.134.218:8333\n-107.136.6.71:8333\n+95.213.161.2:8333\n+95.213.201.94:8333\n+96.20.227.39:8333\n+96.28.41.91:8333\n+98.127.130.17:8333\n+100.36.48.101:8333\n+101.0.81.42:8333\n+101.0.81.43:8333\n+103.11.64.46:8333\n+103.24.244.69:8333\n+103.47.210.50:8333\n+103.76.41.169:8333\n+103.80.168.57:8333\n+103.203.51.186:8333\n+103.224.118.79:8333\n+103.250.4.74:8333\n+104.192.170.202:8333\n+104.196.0.99:8333\n+104.199.192.85:8333\n+104.219.251.46:8333\n+104.223.108.33:8333\n+104.237.2.189:8333\n+104.247.230.28:8333\n 107.150.45.210:8333\n-107.151.144.103:8333\n-107.170.44.99:8333\n-107.181.137.133:8333\n-107.191.102.13:8333\n-108.58.252.82:8333\n-108.59.9.167:8333\n+107.174.34.77:8333\n+107.174.34.78:8333\n+107.180.71.47:8333\n 108.59.12.163:8333\n-108.162.106.215:8333\n-108.168.133.164:8333\n-108.173.202.101:8333\n-108.180.110.190:8333\n-109.29.75.40:8333\n-109.120.194.136:8333\n-109.230.230.88:8333\n-109.235.67.115:8333\n-109.235.69.120:8333\n-109.236.90.199:8333\n+108.168.37.13:8333\n+108.175.3.18:8333\n+108.234.193.106:8333\n+109.9.173.13:8333\n+109.101.220.151:8333\n+109.172.104.119:8333\n+109.195.193.138:8333\n+109.206.177.21:8333\n+109.226.35.28:8333\n 109.255.0.107:8333\n-110.10.130.12:8333\n-110.10.176.94:8333\n-110.132.172.251:8333\n-111.90.158.17:8333\n+113.29.183.143:8333\n+114.145.97.73:8333\n 115.66.205.171:8333\n-116.31.123.139:8333\n-118.192.48.46:8333\n-118.193.164.98:8333\n-119.29.156.231:8333\n-119.63.44.133:19980\n-119.81.99.27:8333\n-119.106.12.169:8333\n-119.147.137.155:19980\n-119.185.1.182:8333\n-120.55.193.136:8333\n-121.254.173.23:8333\n+118.67.201.40:8333\n+118.194.226.168:8333\n+119.28.70.144:8333\n+120.24.166.73:9998\n+120.76.244.201:10022\n+121.82.4.232:8333\n 121.254.173.40:8333\n-123.56.129.45:8333\n 123.203.163.128:8333\n-123.206.32.198:8333\n-124.189.160.221:8333\n-124.189.192.232:8333\n-128.140.224.162:8333\n-128.199.68.205:8333\n-130.234.207.115:8333\n-131.113.41.123:8333\n-131.114.72.104:8333\n-132.204.108.155:8333\n-134.119.13.230:8333\n-134.213.133.206:8333\n-134.213.133.207:8333\n-135.23.5.3:8333\n-137.74.0.66:8333\n-138.68.1.45:8333\n-138.68.2.194:8333\n+124.171.70.45:8333\n+125.63.57.7:8333\n+125.128.35.41:8333\n+128.208.244.124:8333\n+128.230.208.73:8333\n+131.114.10.233:8333\n+131.114.10.235:8333\n+132.239.36.105:8333\n+134.213.214.233:8333\n+136.61.238.121:8333\n+136.62.86.140:8333\n+136.144.128.49:8333\n+137.48.144.52:8333\n+137.116.160.176:8333\n+137.117.193.113:8333\n+138.19.79.208:8333\n 138.68.64.19:8333\n-138.68.64.28:8333\n-139.59.42.248:8333\n-139.220.240.153:8333\n-140.112.107.118:8333\n-140.186.224.112:8333\n-141.52.64.141:8333\n-142.68.237.107:8333\n-142.217.12.106:8333\n-146.60.204.92:8333\n-146.185.161.209:8333\n+139.59.96.16:8333\n+139.162.160.232:8333\n+141.136.115.230:8333\n+142.59.232.111:8333\n+142.111.2.74:8333\n+142.162.128.23:8333\n+143.107.116.5:8333\n+143.229.22.74:8333\n+143.229.36.71:8333\n+144.2.105.60:8333\n+144.76.224.214:8333\n+146.185.19.30:8333\n+147.32.30.25:8333\n+147.229.13.210:8333\n 148.103.7.119:8333\n-149.210.133.244:8333\n+150.101.114.194:8333\n 150.229.0.143:8333\n-151.231.238.25:8333\n-151.248.160.227:8333\n-153.230.228.15:8333\n-155.133.43.249:8333\n-158.58.238.145:8333\n-158.109.79.13:34821\n-159.203.70.208:8333\n+154.66.207.126:8333\n+158.129.212.236:8333\n+158.129.212.251:8333\n 160.16.206.31:8333\n 162.209.1.233:8333\n 162.209.4.125:8333\n-162.216.192.231:8333\n-162.243.100.111:8333\n-162.246.11.194:8333\n-162.248.102.117:8333\n-162.252.46.83:8333\n-163.172.33.78:8333\n-163.172.194.30:8333\n-169.229.198.106:8333\n+162.220.246.225:8333\n+163.172.218.186:8333\n+166.230.70.145:8333\n+168.235.74.45:8333\n+169.44.34.88:8333\n 170.75.195.168:8333\n-172.103.205.197:8333\n-172.245.225.126:8333\n-173.179.37.8:8333\n-173.208.203.74:8333\n-173.252.46.16:8333\n-174.117.141.124:8333\n-175.126.38.158:8333\n-175.126.38.177:8333\n-175.139.106.119:8333\n-175.140.232.66:8333\n-176.9.117.100:8333\n-176.36.33.121:8333\n+172.112.2.67:8333\n+173.94.164.38:8333\n+173.183.232.109:8333\n+173.208.176.122:8333\n+173.212.194.114:8333\n+173.232.228.146:8333\n+175.126.124.92:8333\n+175.145.109.51:8333\n+176.24.198.205:8333\n+176.36.37.62:8333\n 176.36.99.222:8333\n-176.56.227.36:8333\n-176.100.100.206:8333\n 176.106.144.183:8333\n-176.123.7.148:8333\n-176.126.167.10:8333\n-176.223.201.198:8333\n-178.62.68.62:8333\n-178.62.102.56:8333\n-178.62.203.185:8333\n-178.124.197.101:8333\n+177.33.1.40:8333\n+178.162.214.225:8333\n+178.164.109.83:8333\n 178.170.138.202:8333\n-178.175.129.18:8333\n-178.188.47.62:8333\n-178.199.240.22:8333\n+178.175.136.122:8333\n 178.218.209.162:8333\n-178.237.35.34:8333\n-178.238.224.242:8333\n+178.254.2.64:8333\n 178.254.34.144:8333\n-178.254.34.161:8333\n-179.43.183.2:8333\n+178.255.41.21:8333\n+178.255.144.163:8333\n+180.181.208.42:8333\n 180.200.128.58:8333\n-182.93.34.130:8333\n-185.8.238.197:8333\n-185.11.139.172:8333\n+180.235.50.14:8333\n+181.215.148.154:8333\n+184.64.13.43:8333\n+184.94.164.170:8333\n+184.152.107.251:8333\n+184.182.233.206:8333\n+185.4.24.199:8333\n+185.20.99.49:8333\n 185.24.97.11:8333\n-185.24.233.100:8333\n+185.25.48.27:8333\n 185.25.48.71:8333\n-185.25.48.114:8333\n+185.26.196.249:8333\n 185.28.76.179:8333\n-185.70.105.152:8339\n-185.77.128.69:8333\n-185.77.128.241:8333\n-185.86.79.87:8333\n-185.89.102.2:3333\n-185.89.102.53:3333\n-185.109.144.155:8333\n-185.117.75.50:8333\n+185.35.139.250:8333\n+185.41.113.69:8333\n+185.50.213.123:8333\n+185.50.213.124:8333\n+185.50.232.114:8333\n+185.51.192.40:8333\n+185.53.129.244:8333\n+185.71.177.100:8333\n+185.77.129.176:8333\n+185.82.201.51:8333\n 185.121.173.223:8333\n-185.128.41.157:8333\n-185.130.226.106:8333\n-185.145.130.76:8333\n-188.63.192.104:8333\n+185.140.252.253:8333\n+185.145.129.184:8333\n+185.145.130.163:8333\n+185.154.156.50:8333\n+185.162.124.69:8333\n+185.170.42.2:8333\n+186.149.197.96:8333\n+188.65.212.138:8333\n+188.65.213.48:8333\n+188.93.209.192:8333\n+188.113.79.45:8333\n+188.113.84.116:8333\n 188.113.164.231:8333\n-188.166.229.112:8333\n-188.214.128.77:8333\n-190.10.8.211:8333\n-190.81.160.184:8333\n-190.111.231.19:8333\n-192.131.44.93:8333\n+188.122.16.153:8333\n+188.165.224.28:8333\n+188.175.239.227:8333\n+188.214.128.18:8333\n+188.227.64.19:8333\n+188.253.2.125:8333\n+189.45.203.166:8333\n+190.184.198.34:8333\n+192.151.145.250:8333\n 192.206.202.6:8333\n-192.227.245.133:8333\n-192.241.74.123:8333\n-192.241.74.126:8333\n-192.254.71.222:8333\n-193.10.64.85:8333\n-193.46.80.101:8333\n+192.228.101.157:8333\n+193.2.76.41:8333\n+193.27.209.100:8333\n+193.33.237.187:8333\n+193.46.83.17:8333\n 193.49.43.219:8333\n-193.93.79.215:8333\n-193.183.99.46:8333\n-193.234.224.195:8333\n-193.239.80.155:8333\n-194.63.140.208:8333\n-194.87.1.232:8333\n-194.187.227.18:8333\n-194.247.12.136:8333\n-195.91.176.86:8333\n-196.28.98.20:8333\n-198.44.249.35:8333\n-198.84.172.252:8333\n-198.204.224.106:8333\n-198.211.97.46:8333\n-199.66.64.198:8333\n-199.101.100.58:8333\n-199.101.100.59:8333\n+194.24.182.27:8333\n+194.28.206.201:8333\n+194.63.143.197:8333\n+194.71.109.91:8333\n+194.79.8.36:8333\n+194.135.93.38:8333\n+194.186.160.253:8333\n+195.9.140.134:8333\n+195.39.206.29:8333\n+195.67.36.89:8333\n+195.169.99.82:8333\n+195.214.214.253:8333\n+195.223.71.147:8333\n+198.37.118.11:8333\n+198.54.113.125:8333\n+198.101.12.139:8333\n+198.143.12.105:8333\n+198.251.83.19:8333\n 199.127.224.50:8333\n-200.46.241.71:8333\n+200.12.138.146:8333\n 200.116.98.185:8333\n-203.9.225.13:8333\n-203.177.142.37:8333\n-205.200.247.149:8333\n-205.209.131.150:13838\n-206.53.64.74:8333\n-206.72.192.69:8333\n-206.123.112.180:8333\n-208.66.208.153:8333\n-208.68.174.76:8333\n+200.122.128.130:8333\n+202.29.6.48:8333\n+202.133.115.115:8333\n+203.59.17.160:8333\n+204.15.11.4:8333\n+204.111.241.195:8333\n+205.251.85.151:8333\n+207.244.70.40:8333\n+207.254.50.72:8333\n+208.76.93.83:8333\n 208.107.97.242:8333\n-208.111.48.132:8333\n+208.110.73.107:8333\n 208.118.235.190:8333\n-209.6.205.126:8333\n-209.40.96.121:8333\n-209.58.130.137:8333\n 209.73.142.226:8333\n-209.90.224.4:8333\n-209.126.69.243:8333\n-209.126.108.91:8333\n-209.195.4.18:8333\n+209.81.9.223:8333\n+209.126.107.166:8333\n+209.177.86.19:8333\n 209.250.6.190:8333\n-210.54.37.225:8333\n+210.1.219.155:8333\n+210.211.109.165:8333\n 210.223.3.44:8333\n-211.149.234.109:8333\n+211.21.129.69:8333\n+212.50.98.161:8333\n 212.51.140.183:8333\n+212.56.108.81:8333\n+212.83.35.173:8333\n 212.90.179.206:8333\n 212.93.226.90:8333\n 212.110.171.118:8333\n-212.202.132.17:8333\n+213.5.36.58:8333\n+213.5.181.205:8333\n+213.17.16.251:8333\n 213.91.205.134:8333\n-213.165.68.218:8333\n-213.196.200.213:8333\n+213.91.211.17:8333\n+213.155.3.216:8333\n+213.168.13.151:8333\n+213.186.170.109:8334\n+213.222.208.150:8333\n+216.32.213.112:8333\n 216.59.4.212:8333\n-216.74.32.109:8333\n-216.158.225.70:8333\n-216.164.138.13:8333\n-216.167.236.247:8333\n+216.126.193.163:8333\n 216.197.79.74:8333\n-217.11.225.189:8333\n+216.218.147.140:8333\n+216.227.39.84:8333\n+216.245.206.181:8333\n+216.249.92.230:8333\n 217.12.199.207:8333\n-217.20.130.72:8333\n-217.23.6.148:8333\n-217.23.140.103:8333\n-217.28.96.180:8333\n+217.23.2.177:8333\n+217.23.5.68:8333\n+217.28.194.2:8333\n 217.35.130.42:8333\n-217.111.66.79:8333\n-217.158.9.102:8333\n+217.64.47.138:8333\n+217.101.72.242:8333\n+217.145.81.229:8333\n 217.168.143.169:8333\n-217.209.32.219:8333\n-218.161.33.165:8333\n-221.121.144.138:8333\n-[2001:0:4137:9e76:2048:3a84:bb91:e846]:8333\n-[2001:0:4137:9e76:2066:e9e:b489:f8b8]:8333\n-[2001:0:4137:9e76:3854:1211:b5ac:a96b]:8333\n-[2001:0:4137:9e76:4e3:1f66:cd4c:829f]:8333\n-[2001:0:4137:9e76:ad:1f4:9ea9:fa2e]:8333\n-[2001:0:4137:9e76:e5:baa:b66f:f418]:8333\n-[2001:0:53aa:64c:20a2:59c4:ad22:93ea]:8333\n+217.169.7.111:8333\n+217.182.192.7:8333\n+219.88.232.229:8333\n+219.113.244.52:8333\n+220.130.128.58:8333\n+220.244.225.239:8333\n+221.141.3.12:8333\n+222.166.176.99:8333\n+223.252.173.147:8333\n+[2001:0:4137:9e76:1025:4e5:acb0:22cd]:8333\n+[2001:0:4137:9e76:1078:18a6:5d2c:2461]:8333\n+[2001:0:4137:9e76:10ec:236a:bd3b:f3c0]:8333\n+[2001:0:4137:9e76:186d:3f17:b7ad:95cf]:8333\n+[2001:0:4137:9e76:1870:242:ac03:aaf9]:8333\n+[2001:0:4137:9e76:18a6:1102:2abf:eb70]:8333\n+[2001:0:4137:9e76:1ce5:248c:4ff5:2b1d]:8333\n+[2001:0:4137:9e76:200f:156a:bc77:3acd]:8333\n+[2001:0:4137:9e76:2418:19d1:cddc:b1af]:8333\n+[2001:0:4137:9e76:2857:3d78:aaf8:eb28]:8333\n+[2001:0:4137:9e76:28b2:1b84:64fb:2d6a]:8333\n+[2001:0:4137:9e76:2c70:d51:d046:1209]:8333\n+[2001:0:4137:9e76:2cac:2fcf:46bb:be0d]:8333\n+[2001:0:4137:9e76:305e:20ee:a94f:6f69]:8333\n+[2001:0:4137:9e76:30cd:849:adfe:6e67]:8333\n+[2001:0:4137:9e76:345b:f12:ae1e:2948]:8333\n+[2001:0:4137:9e76:3c40:146e:9741:5a3a]:8333\n+[2001:0:4137:9e76:3c9e:3c3e:9d6e:7340]:8333\n+[2001:0:4137:9e76:499:29a8:d047:7ea1]:8333\n+[2001:0:4137:9e76:51:24:81b2:59e3]:8333\n+[2001:0:4137:9e76:889:2d7c:b61b:bf0d]:8333\n+[2001:0:4137:9e76:c9f:379c:add2:c938]:8333\n+[2001:0:4137:9e76:cd6:2eb4:b82b:addb]:8333\n+[2001:0:4137:9e76:cf0:2e3a:b29d:6207]:8333\n+[2001:0:53aa:64c:1485:fbf9:a798:1ffe]:8333\n [2001:0:53aa:64c:59:617f:a10d:e0]:8333\n-[2001:0:5ef5:79fb:200f:3ae5:3cbc:74c9]:8333\n-[2001:0:5ef5:79fb:38f2:13b4:b208:5604]:8333\n-[2001:0:5ef5:79fd:200b:22a7:cc50:f52d]:8333\n-[2001:0:5ef5:79fd:24ef:1aef:a994:303d]:8333\n-[2001:0:5ef5:79fd:24fc:b5d:ad4f:4db2]:8333\n-[2001:0:5ef5:79fd:28bf:2d23:e02e:c3ef]:8333\n-[2001:0:5ef5:79fd:3cd0:3c2e:da44:a759]:8333\n-[2001:0:5ef5:79fd:87e:fd7:b1c2:1b4]:8333\n-[2001:0:9d38:6ab8:18db:3bda:ab90:e81e]:8333\n-[2001:0:9d38:6ab8:4e7:1660:862f:a6d7]:8333\n-[2001:0:9d38:6ab8:6:2b:5074:9588]:8333\n-[2001:0:9d38:6abd:10f8:a7d7:bb90:f524]:8333\n-[2001:13d8:1c01:1000::11]:8333\n-[2001:15c0:65ff:610::2]:8333\n-[2001:1608:10:156:ae::4adb]:8333\n-[2001:1620:b1b:8888:20d:b9ff:fe41:6710]:8333\n-[2001:1620:b1b:face:20d:b9ff:fe41:6710]:8333\n-[2001:1620:f00:282::2]:8333\n-[2001:1620:f00:8282::1]:8333\n-[2001:1680:101:1ae::1]:8333\n-[2001:16d8:ff00:85de:20c:29ff:fe52:9594]:8333\n-[2001:19f0:4400:434d:5400:ff:fe42:2678]:8333\n+[2001:0:5ef5:79fb:1020:2cd0:4750:eb12]:8333\n+[2001:0:5ef5:79fb:1036:1d50:3881:6930]:8333\n+[2001:0:5ef5:79fb:10a4:27d8:9c0a:cfa9]:8333\n+[2001:0:5ef5:79fb:10ae:5a8:524b:dcc4]:8333\n+[2001:0:5ef5:79fb:1892:3e3a:3f74:affa]:8333\n+[2001:0:5ef5:79fb:1c95:1a60:d1f5:215b]:8333\n+[2001:0:5ef5:79fb:200b:16ef:b9cf:9860]:8333\n+[2001:0:5ef5:79fb:28e4:fbff:3237:992]:8333\n+[2001:0:5ef5:79fb:2ce8:1d9e:b3bf:b53e]:8333\n+[2001:0:5ef5:79fb:300a:2e20:4750:eb12]:8333\n+[2001:0:5ef5:79fb:30a2:1ad9:5324:836a]:8333\n+[2001:0:5ef5:79fb:3409:1996:bcac:241f]:8333\n+[2001:0:5ef5:79fb:344b:2bd4:bb3e:e26]:8333\n+[2001:0:5ef5:79fb:34b3:11db:e7da:d461]:8333\n+[2001:0:5ef5:79fb:3839:2e0c:ba30:288e]:8333\n+[2001:0:5ef5:79fb:3880:ef4:b5f0:ee4d]:8333\n+[2001:0:5ef5:79fb:389f:52:9c0c:1f41]:8333\n+[2001:0:5ef5:79fb:3c73:304a:9d8b:99d5]:8333\n+[2001:0:5ef5:79fb:3cac:33e4:39ca:38c]:8333\n+[2001:0:5ef5:79fb:6f:3667:5398:538f]:8333\n+[2001:0:5ef5:79fb:88c:3e6:9454:3331]:8333\n+[2001:0:5ef5:79fb:89:3b55:9fcc:8e66]:8333\n+[2001:0:5ef5:79fb:c9b:3d65:bdf4:5d58]:8333\n+[2001:0:5ef5:79fb:cb7:8cc:b8ee:6806]:8333\n+[2001:0:5ef5:79fd:24f6:37b5:b9d2:2aa7]:8333\n+[2001:0:5ef5:79fd:3c63:82e:aabc:bd39]:8333\n+[2001:0:5ef5:79fd:3cf5:2eb7:c966:561d]:8333\n+[2001:0:5ef5:79fd:cf4:28e2:aabd:b766]:8333\n+[2001:0:9d38:6ab8:10f6:453:3ca4:1a8e]:8333\n+[2001:0:9d38:6ab8:14dd:298b:431c:bfec]:8333\n+[2001:0:9d38:6ab8:3051:1561:b62d:73a5]:8333\n+[2001:0:9d38:6ab8:3467:ffa:b612:e9c6]:8333\n+[2001:0:9d38:6ab8:8e8:1e26:e8e3:eed7]:8333\n+[2001:0:9d38:6ab8:c82:37b3:47ee:3ae2]:8333\n+[2001:0:9d38:6abd:1052:3cd8:a89b:e67]:8333\n+[2001:0:9d38:6abd:144d:23f3:abcb:8bcb]:8333\n+[2001:0:9d38:6abd:1c2e:31df:adf1:e616]:8333\n+[2001:0:9d38:6abd:1c41:213b:facc:9c6b]:8333\n+[2001:0:9d38:6abd:2093:12b5:8cbf:4f57]:8333\n+[2001:0:9d38:6abd:243a:2394:fd91:712c]:8333\n+[2001:0:9d38:6abd:2833:9f8:c94c:6881]:8333\n+[2001:0:9d38:6abd:2c84:29d3:ae5a:f6f0]:8333\n+[2001:0:9d38:6abd:2ce4:d50:cb22:3672]:8333\n+[2001:0:9d38:6abd:3824:816:c30d:e9d4]:8333\n+[2001:0:9d38:6abd:389a:24e9:cb5c:a1cd]:8333\n+[2001:0:9d38:6abd:38bd:88f:2193:4932]:8333\n+[2001:0:9d38:6abd:3c4f:cb1:d65b:d775]:8333\n+[2001:0:9d38:6abd:3c51:280b:b1e9:ffd]:8333\n+[2001:0:9d38:6abd:3c5a:2e2:2193:4932]:8333\n+[2001:0:9d38:6abd:3c5e:3ebf:3dc0:703a]:8333\n+[2001:0:9d38:6abd:4c9:12fc:d1d9:dc21]:8333\n+[2001:0:9d38:6abd:6e:34e7:d0a7:6772]:8333\n+[2001:0:9d38:6abd:8de:1f29:2aea:f96f]:8333\n+[2001:0:9d38:6abd:c5f:2674:a467:787c]:8333\n+[2001:0:9d38:6abd:cc0:23a4:ad7c:c998]:8333\n+[2001:0:9d38:78cf:20c0:2097:d188:9c3b]:8333\n+[2001:0:9d38:78cf:2420:dda:4ff6:8794]:8333\n+[2001:0:9d38:78cf:2892:fcb:26b2:22ac]:8333\n+[2001:0:9d38:78cf:3020:1ad7:26b2:22ac]:8333\n+[2001:0:9d38:78cf:30ae:211b:e717:7788]:8333\n+[2001:0:9d38:78cf:30d0:6edd:a418:a9e9]:8333\n+[2001:0:9d38:78cf:30d9:3278:b004:65a7]:8333\n+[2001:0:9d38:78cf:387a:17d5:dacb:bdf1]:8333\n+[2001:0:9d38:78cf:3c38:c41:433c:7b87]:8333\n+[2001:0:9d38:78cf:467:193:a8b0:a122]:8333\n+[2001:0:9d38:78cf:c65:fb96:97d2:a9b0]:8333\n+[2001:0:9d38:78cf:c9f:2633:d169:9999]:8333\n+[2001:0:9d38:78cf:ce2:aba:d120:90db]:8333\n+[2001:0:9d38:90d7:105d:26f2:a241:7339]:8333\n+[2001:0:9d38:90d7:1062:3f95:e065:fc21]:8333\n+[2001:0:9d38:90d7:10a6:19f6:ab95:ebcb]:8333\n+[2001:0:9d38:90d7:14e2:22cb:738f:9489]:8333\n+[2001:0:9d38:90d7:18fb:3da9:893d:1d57]:8333\n+[2001:0:9d38:90d7:1cc3:2534:e020:53fa]:8333\n+[2001:0:9d38:90d7:206d:2b34:d0cb:9de8]:8333\n+[2001:0:9d38:90d7:20cb:2cb:b9a7:ca5e]:8333\n+[2001:0:9d38:90d7:245c:2753:4382:704b]:8333\n+[2001:0:9d38:90d7:24d6:225f:793b:bf5]:8333\n+[2001:0:9d38:90d7:24da:8f0:bbf9:9c93]:8333\n+[2001:0:9d38:90d7:28a2:107b:438e:b08d]:8333\n+[2001:0:9d38:90d7:2c16:d58:b381:b61]:8333\n+[2001:0:9d38:90d7:2c68:3068:cb59:3be7]:8333\n+[2001:0:9d38:90d7:2c90:3855:b94f:c926]:8333\n+[2001:0:9d38:90d7:2ca2:3592:c111:dd82]:8333\n+[2001:0:9d38:90d7:2cce:1f6e:b381:8605]:8333\n+[2001:0:9d38:90d7:3435:3915:2bcc:6cc7]:8333\n+[2001:0:9d38:90d7:3438:2b9f:ad57:a721]:8333\n+[2001:0:9d38:90d7:3474:1df1:e732:e5e3]:8333\n+[2001:0:9d38:90d7:38c4:37af:ab0a:f5ef]:8333\n+[2001:0:9d38:90d7:3a:39fd:a43b:5591]:8333\n+[2001:0:9d38:90d7:3c9d:2a45:d537:3bd6]:8333\n+[2001:0:9d38:90d7:3cfb:2cf5:5254:4d1e]:8333\n+[2001:0:9d38:90d7:43f:337:adb4:6310]:8333\n+[2001:0:9d38:90d7:493:995:d2e9:39be]:8333\n+[2001:0:9d38:90d7:5b:ce3:b275:92ab]:8333\n+[2001:0:9d38:90d7:8a8:59d:d0cb:d585]:8333\n+[2001:0:9d38:90d7:c8e:1ba0:c5a9:dace]:8333\n+[2001:0:9d38:90d7:cdb:365f:2302:f729]:8333\n+[2001:0:9d38:90d7:cf5:222e:893e:716c]:8333\n+[2001:0:9d38:90d7:d6:1085:b8dd:41c2]:8333\n+[2001:0:9d38:953c:101a:23b3:6b98:f888]:8333\n+[2001:0:9d38:953c:1805:f38:3eb2:2121]:8333\n+[2001:0:9d38:953c:1858:16f9:3833:da19]:8333\n+[2001:0:9d38:953c:18ea:2735:e73d:adc5]:8333\n+[2001:0:9d38:953c:1c44:2b70:9de7:a7cc]:8333\n+[2001:0:9d38:953c:200a:3f95:bb7c:c09f]:8333\n+[2001:0:9d38:953c:200c:3473:b85d:ddd]:8333\n+[2001:0:9d38:953c:200f:5a0:47c6:5507]:8333\n+[2001:0:9d38:953c:2097:204a:47c5:5881]:8333\n+[2001:0:9d38:953c:248f:24cd:aaf5:dee3]:8333\n+[2001:0:9d38:953c:287d:168e:3caf:47af]:8333\n+[2001:0:9d38:953c:28c1:58d:b721:94c1]:8333\n+[2001:0:9d38:953c:2c31:30a3:39d3:528]:8188\n+[2001:0:9d38:953c:2c3d:309b:d2db:8288]:8333\n+[2001:0:9d38:953c:2c47:1b36:52c1:3c73]:8333\n+[2001:0:9d38:953c:304a:10e1:b739:822a]:8333\n+[2001:0:9d38:953c:30a3:29fd:33f6:eaab]:8333\n+[2001:0:9d38:953c:3427:859b:b525:1069]:8333\n+[2001:0:9d38:953c:3459:2541:3651:d675]:8333\n+[2001:0:9d38:953c:4f5:9c88:af91:d3d3]:8333\n+[2001:0:9d38:953c:cd1:1d54:b80a:42f4]:8333\n+[2001:0:9d38:953c:cfa:37e6:9d8e:7474]:8333\n+[2001:13d8:1c01:2000:2470::1]:8333\n+[2001:1470:fffd:202c:225:90ff:fe8f:5f62]:8333\n+[2001:14ba:200:0:543c:42ce:a48b:b0d0]:8333\n+[2001:14ba:2fc:700:41b2:df51:efd8:f581]:8333\n [2001:19f0:5000:8c8b:5400:ff:fe1f:c023]:8333\n-[2001:19f0:5000:8ce6:5400:ff:fe1b:24a9]:8333\n-[2001:19f0:5:314:5400:ff:fe2c:42e8]:8333\n-[2001:19f0:5:51b:5400:ff:fe49:fe5b]:8333\n+[2001:19f0:5:749:5400:ff:fe71:c3fc]:8333\n [2001:19f0:5:bc:5400:ff:fe3b:9339]:8333\n-[2001:1af8:4020:a020:5::]:8333\n+[2001:19f0:7402:42c:5400:ff:fe6c:b9b8]:8333\n+[2001:1af8:4010:a08f:f811:e5f0:3f63:e753]:8333\n+[2001:1af8:4010:a094:3333::8c38]:8333\n+[2001:1af8:4070:a016:3333::5afb]:8333\n+[2001:1af8:4700:a071:4444::e26e]:8333\n [2001:1bc8:1a0:590e:2e0:f4ff:fe16:3a39]:8333\n-[2001:1c04:1401:8f00:f4fe:4fff:fe0c:df40]:8333\n+[2001:2040:77::89]:8333\n+[2001:288:1001:107:294e:5581:74bd:42f9]:8333\n+[2001:3c8:c103:a001::48]:8333\n [2001:4128:6135:10:20c:29ff:fe69:9e81]:8333\n [2001:4128:6135:2010:21e:bff:fee8:a3c0]:8333\n [2001:4128:6135:e001:5054:ff:fe37:e9eb]:8333\n-[2001:41d0:1000:1024::]:8333\n-[2001:41d0:1000:1433::]:8333\n-[2001:41d0:1004:22ae::]:8333\n-[2001:41d0:1004:2996::]:8333\n-[2001:41d0:1008:11e0::1a5c:6d9d]:8333\n-[2001:41d0:1008:11e0::b74:baf7]:8333\n-[2001:41d0:1008:237a::]:8333\n+[2001:4178:6:1427:62:116:188:85]:8333\n+[2001:41d0:1004:20f0::]:8333\n [2001:41d0:1008:2752::]:8333\n-[2001:41d0:1008:494::]:8333\n-[2001:41d0:1:45d8::1]:8333\n-[2001:41d0:1:5630::1]:8333\n+[2001:41d0:1:4722::1]:8333\n [2001:41d0:1:6f57::1]:8333\n-[2001:41d0:1:801e::1]:8333\n-[2001:41d0:1:8852::1]:8333\n+[2001:41d0:1:7353::1]:8333\n+[2001:41d0:1:7469::1]:8333\n+[2001:41d0:1:7d09::1]:8333\n [2001:41d0:1:8b26::1]:8333\n-[2001:41d0:1:a5b8::1]:8333\n-[2001:41d0:1:b26b::1]:8333\n-[2001:41d0:1:c139::1]:8333\n-[2001:41d0:1:c8d7::1]:8333\n+[2001:41d0:1:c129::1]:8333\n [2001:41d0:1:d227::]:8333\n-[2001:41d0:1:dbc4::1]:8333\n-[2001:41d0:1:dc5d::1]:8333\n [2001:41d0:1:e13b::1]:8333\n-[2001:41d0:1:ef5b::1]:8333\n+[2001:41d0:1:e623::1]:8333\n [2001:41d0:2:16be::1]:8333\n [2001:41d0:2:203c::1]:8333\n-[2001:41d0:2:38c5::1]:8333\n-[2001:41d0:2:519::]:8333\n+[2001:41d0:2:3242::]:8333\n+[2001:41d0:2:8a0f::]:8333\n+[2001:41d0:2:8c65::]:8333\n+[2001:41d0:2:8d13::]:8333\n+[2001:41d0:2:9459::]:8333\n+[2001:41d0:2:950a:ffff:ffff:0:3]:8333\n [2001:41d0:2:9c94::1]:8333\n-[2001:41d0:2:b792::]:8333\n+[2001:41d0:2:a212::]:8333\n+[2001:41d0:2:a232::]:8333\n+[2001:41d0:2:ab1c::]:8333\n [2001:41d0:2:bf2a::]:8333\n [2001:41d0:2:c793::]:8333\n-[2001:41d0:2:c9bf::]:8333\n-[2001:41d0:303:4f0::]:8333\n-[2001:41d0:8:1a8a::1]:8333\n-[2001:41d0:8:3fa9::1]:8333\n-[2001:41d0:8:4670::1]:8333\n-[2001:41d0:8:4f48::1]:8333\n-[2001:41d0:8:6728::]:8333\n-[2001:41d0:8:72c2:d:242:ac11:2]:8333\n-[2001:41d0:8:8007::]:8333\n-[2001:41d0:8:a71c::]:8333\n-[2001:41d0:8:bccc::1]:8333\n+[2001:41d0:302:1000::fa25]:8333\n+[2001:41d0:303:1907::]:8333\n+[2001:41d0:52:d00::6e2]:8333\n+[2001:41d0:52:d00::6e3]:8333\n+[2001:41d0:8:1b29::]:8333\n+[2001:41d0:8:3d4b::1]:8333\n+[2001:41d0:8:4d4d::1]:8333\n+[2001:41d0:8:7a38::1]:8333\n+[2001:41d0:8:8f46::1]:8333\n+[2001:41d0:8:ba87::1]:8333\n [2001:41d0:8:bd45::1]:8333\n+[2001:41d0:8:bed3::]:8333\n [2001:41d0:8:c67c::]:8333\n+[2001:41d0:8:d844:1337::1017]:8333\n+[2001:41d0:8:ddb::1]:8333\n+[2001:41d0:8:ddf::1]:8333\n [2001:41d0:8:de3d::1]:8333\n-[2001:41d0:8:e257::1]:8333\n [2001:41d0:8:e3e4::1]:8333\n-[2001:41d0:a:14cc::1]:8333\n-[2001:41d0:a:15b2::1]:8333\n-[2001:41d0:a:1ac9::1]:8333\n-[2001:41d0:a:2496::1]:8333\n-[2001:41d0:a:308c::]:8333\n-[2001:41d0:a:5879::]:8333\n+[2001:41d0:a:4e3f::1c7d:6b01]:8333\n+[2001:41d0:a:635b::1]:8333\n [2001:41d0:a:6810::1]:8333\n-[2001:41d0:a:682d::1]:8333\n [2001:41d0:a:6c29::1]:8333\n-[2001:41d0:a:f52a::1]:8333\n+[2001:41d0:a:6fd0::]:8333\n+[2001:41d0:a:fac7::1]:8333\n [2001:41d0:d:111c::]:8333\n+[2001:41d0:d:2ac8::]:8333\n [2001:41d0:e:1388::1]:8333\n-[2001:41d0:e:26b::1]:8333\n-[2001:41d0:e:f73::1]:8333\n-[2001:41d0:fc8c:a200:7a24:afff:fe9d:c69b]:8333\n [2001:41f0:61:0:72f3:95ff:fe09:7521]:8333\n [2001:41f0:61::7]:8333\n-[2001:4428:200:8171:db6:2ff4:9c0e:a2da]:8333\n [2001:470:1f07:151c:baac:6fff:feb7:3ba9]:8333\n-[2001:470:1f0b:ad6:a60:6eff:fec6:2323]:8333\n-[2001:470:1f11:617::10f]:8333\n-[2001:470:1f14:73e::2]:8333\n-[2001:470:1f14:7d::2]:8333\n+[2001:470:1f0b:8c4::5]:8333\n+[2001:470:1f0b:967::11]:8333\n [2001:470:1f15:11f8::10]:8333\n [2001:470:1f15:1b95:2c3e:8a9a:24e1:7084]:8333\n-[2001:470:1f15:e9b::3ef]:8333\n+[2001:470:1f15:f28::3]:8333\n+[2001:470:1f1a:172::2]:8333\n+[2001:470:1f1c:b07::2]:8333\n [2001:470:1f1d:3a9::10]:8333\n [2001:470:25:482::2]:8333\n-[2001:470:27:19f::2]:8333\n-[2001:470:27:665::2]:8333\n [2001:470:28:365::4]:8333\n-[2001:470:41:6::2]:8333\n-[2001:470:727b::11:14]:8333\n-[2001:470:7:2f0::2]:8333\n-[2001:470:7:65::2]:8333\n-[2001:470:7f85::2]:8333\n-[2001:470:8:2e1:5825:39df:3e4c:54a8]:8333\n-[2001:470:8:2e1::43]:8333\n-[2001:470:8:2e1:ae2a:e257:4470:6350]:8333\n+[2001:470:754f:42::17a]:8333\n+[2001:470:7:b74::2]:8333\n+[2001:470:7dda:1::1]:8333\n+[2001:470:8:c70:20c:29ff:fe6a:8fdc]:8333\n+[2001:470:8:c70::54]:8333\n [2001:470:a:c13::2]:8333\n+[2001:470:d00d:0:3664:a9ff:fe9a:5150]:8333\n+[2001:470:dbf2:aaaa::b17:c01c]:8333\n+[2001:470:f457:8000::a6]:8333\n [2001:4801:7819:74:b745:b9d5:ff10:a61a]:8333\n [2001:4801:7819:74:b745:b9d5:ff10:aaec]:8333\n [2001:4801:7828:104:be76:4eff:fe10:1325]:8333\n-[2001:4802:7800:2:30d7:1775:ff20:1858]:8333\n-[2001:4ba0:babe:832::]:8333\n-[2001:4ba0:cafe:379::1]:8333\n-[2001:4ba0:ffee:33::10]:8333\n-[2001:4dd0:ff00:9a67::9]:8333\n-[2001:610:1b19::3]:8333\n-[2001:610:600:a41::2]:8333\n-[2001:678:174:4021::2:8333]:8333\n-[2001:67c:16dc:1201:5054:ff:fe17:4dac]:8333\n+[2001:4ba0:cafe:13c0::1]:8333\n+[2001:4ba0:cafe:418::1]:8333\n+[2001:558:6045:23:1830:896c:d901:190d]:8333\n+[2001:67c:1220:80c::93e5:dd2]:8333\n [2001:67c:2128:ffff:6062:36ff:fe30:6532]:8333\n-[2001:67c:2564:331:3547:6e28:85a4:fb27]:8333\n-[2001:6a0:200:368::2]:8333\n-[2001:718:801:311:5054:ff:fe19:c483]:8333\n-[2001:7b8:2ff:8f::2]:8333\n-[2001:8d8:8a6:4400::3f:86c]:8333\n [2001:8d8:923:8400::87:ebd]:8333\n-[2001:960:66d::2]:8333\n+[2001:981:4452:1::100]:8333\n [2001:981:46:1:ba27:ebff:fe5b:edee]:8333\n-[2001:ba8:1f1:f069::2]:8333\n+[2001:981:bdbd:1:c506:7d38:4b47:da15]:8333\n+[2001:985:79af:20::35]:8333\n [2001:bc8:225f:10e:505:6573:7573:d0a]:8333\n-[2001:bc8:2706::1]:8333\n [2001:bc8:323c:100::53]:8333\n [2001:bc8:323c:100::80:4]:8333\n [2001:bc8:323c:100::cafe]:8333\n [2001:bc8:3680:4242::1]:8333\n [2001:bc8:399f:f000::1]:8333\n-[2001:bc8:3cbf::5]:8333\n-[2001:bc8:4700:2300::19:807]:8333\n-[2001:e42:102:1805:160:16:206:31]:8333\n-[2002:12f1:3f::12f1:3f]:8333\n-[2002:1e2:5349::1e2:5349]:8333\n+[2002:1e2:5587::1e2:5587]:8333\n [2002:1e2:5588::1e2:5588]:8333\n-[2002:2501:cf62::2501:cf62]:8333\n-[2002:268c:a135::268c:a135]:8333\n-[2002:2a33:99db::2a33:99db]:8332\n-[2002:2ebc:2c14::7]:8333\n-[2002:2f59:2c9c::2f59:2c9c]:11885\n-[2002:2f5a:3619::2f5a:3619]:8333\n-[2002:2f5a:36a4::2f5a:36a4]:8333\n-[2002:2f5a:429::2f5a:429]:8333\n+[2002:2a33:21c4::2a33:21c4]:8333\n+[2002:2e04:784b::2e04:784b]:8333\n+[2002:2ebc:2c14::16]:8333\n+[2002:2f5a:3c1c::2f5a:3c1c]:10011\n [2002:2f5a:562a::2f5a:562a]:8333\n-[2002:3a3b:216::3a3b:216]:8333\n-[2002:3dfa:5d23::3dfa:5d23]:8333\n-[2002:424f:a052::424f:a052]:8333\n-[2002:451e:e922::451e:e922]:8333\n+[2002:2f5b:a5f9::2f5b:a5f9]:8333\n+[2002:3141:28c::3141:28c]:8333\n+[2002:323f:a2f2::323f:a2f2]:8333\n+[2002:323f:fbd::323f:fbd]:8333\n+[2002:33ff:69a0::1]:8333\n+[2002:3e6a:106f::3e6a:106f]:8333\n+[2002:3e70:bbc::3e70:bbc]:8333\n+[2002:3e7a:6727::3e7a:6727]:8333\n+[2002:3f62:e6bb::3f62:e6bb]:8333\n [2002:4540:4b30::4540:4b30]:8333\n-[2002:51ab:7cc::51ab:7cc]:8333\n-[2002:527:de11::527:de11]:8333\n-[2002:5395:7d01::5395:7d01]:8333\n-[2002:5395:7d2a::5395:7d2a]:8333\n-[2002:5669:e3be::5669:e3be]:8333\n-[2002:566a:5d6d::566a:5d6d]:8333\n-[2002:59b9:f820::59b9:f820]:8333\n-[2002:59f8:ac69::59f8:ac69]:8333\n-[2002:5bd4:b65a::5bd4:b65a]:8333\n-[2002:5c3f:39db::5c3f:39db]:8333\n-[2002:5d33:8d03::5d33:8d03]:8333\n-[2002:5d67:49bb::5d67:49bb]:8333\n-[2002:5dae:5d5f::5dae:5d5f]:8333\n+[2002:4e6b:c745::1]:8333\n+[2002:5052:4d8a::5052:4d8a]:8333\n+[2002:51a9:9cc9::51a9:9cc9]:8333\n+[2002:54fb:cb05::1]:8333\n+[2002:5bc2:5428::5bc2:5428]:8333\n+[2002:5bce:1253::5bce:1253]:8333\n+[2002:5bdb:19e8::5bdb:19e8]:8333\n+[2002:5c3f:3912::5c3f:3912]:8333\n+[2002:5dbd:91a9::5dbd:91a9]:8333\n [2002:5dbe:8cc6::5dbe:8cc6]:8333\n-[2002:5dbe:9503::5dbe:9503]:8333\n [2002:5fd3:8944::5fd3:8944]:8333\n-[2002:5fd3:9467::5fd3:9467]:8333\n-[2002:67f9:6a48::67f9:6a48]:8333\n-[2002:67f9:6a4a::67f9:6a4a]:8333\n-[2002:67f9:6a95::67f9:6a95]:8333\n+[2002:65c8:a018::65c8:a018]:8333\n+[2002:6750:a839::6750:a839]:8333\n+[2002:67fa:44b::67fa:44b]:8333\n [2002:6a0e:3ea8::6a0e:3ea8]:10011\n-[2002:6b96:375a::6b96:375a]:8333\n-[2002:6ca8:cffb::6ca8:cffb]:8333\n-[2002:6caf:234::6caf:234]:8333\n-[2002:6dec:58f5::6dec:58f5]:8333\n+[2002:6a0f:2497::6a0f:2497]:8333\n [2002:6dec:5ac7::6dec:5ac7]:8333\n-[2002:7237:4a02::7237:4a02]:20033\n-[2002:7237:94fd::7237:94fd]:10011\n-[2002:7237:e428::7237:e428]:8333\n+[2002:704a:d6d4::704a:d6d4]:9997\n [2002:7237:fcf6::7237:fcf6]:20188\n-[2002:76c0:96e6::76c0:96e6]:8333\n+[2002:76b2:7f40::76b2:7f40]:8333\n [2002:7819:7e80::7819:7e80]:7743\n-[2002:781a:ea86::781a:ea86]:8333\n-[2002:781a:f3c2::781a:f3c2]:14475\n-[2002:784c:c2c0::784c:c2c0]:8333\n-[2002:784c:ec97::784c:ec97]:8333\n-[2002:792b:261a::792b:261a]:8333\n-[2002:88f3:8cca::88f3:8cca]:8333\n-[2002:88f3:a83c::88f3:a83c]:8333\n-[2002:8ac9:516f::8ac9:516f]:8333\n-[2002:8b81:6d78::8b81:6d78]:50344\n-[2002:8b81:6e5c::8b81:6e5c]:38176\n-[2002:8bc4:90a6::8bc4:90a6]:8333\n+[2002:781b:8db8::781b:8db8]:8333\n+[2002:7b38:cd00::7b38:cd00]:8333\n [2002:ac52:b854::ac52:b854]:8333\n-[2002:add0:c14a::add0:c14a]:8333\n-[2002:b07e:a70a::b07e:a70a]:8333\n-[2002:b27c:c565:1::250]:8333\n-[2002:b27c:c565::1]:8333\n-[2002:b94d:80f1::b94d:80f1]:8333\n-[2002:b982:e26a::b982:e26a]:8333\n-[2002:bcd5:3145::bcd5:3145]:8333\n-[2002:c08a:d22b::c08a:d22b]:8333\n-[2002:c0c7:f8e3::c0c7:f8e3]:32771\n-[2002:c1a9:fc5a::c1a9:fc5a]:8333\n+[2002:b610:1ca3::b610:1ca3]:8333\n+[2002:b946:694a::b946:694a]:8339\n+[2002:b994:9167::b994:9167]:8333\n+[2002:bc28:6b92::bc28:6b92]:8333\n [2002:c23f:8fc5::c23f:8fc5]:8333\n-[2002:d395:ea6d::d395:ea6d]:8333\n-[2002:d917:ca5::d917:ca5]:8333\n-[2002:d917:e91::d917:e91]:8333\n+[2002:c338:3f0a::c338:3f0a]:8333\n+[2002:d1b1:5615::d1b1:5615]:8333\n+[2002:d2d3:6da5::d2d3:6da5]:8333\n+[2002:d917:2b1::d917:2b1]:8333\n [2002:db71:f434::db71:f434]:8333\n-[2400:2651:161:1000:6847:d40f:aaa3:4848]:8333\n-[2400:8901::f03c:91ff:fec8:4280]:8333\n-[2401:1800:7800:102:be76:4eff:fe1c:a7d]:8333\n+[2003:a:36f:4f01::1]:8333\n+[2003:a:37f:ef4f:dead:babe:b00b:beef]:8333\n+[2400:8901::f03c:91ff:fe2c:63d8]:8333\n+[2400:8902::f03c:91ff:fed5:9d8d]:8333\n [2401:2500:203:10:153:120:156:83]:8333\n [2401:a400:3200:5600:14ee:f361:4bdc:1f7c]:8333\n+[2402:1f00:8100:36::]:8333\n [2403:4200:403:2::ff]:8333\n+[2405:9800:b440:947f:59a5:f379:1876:858c]:8333\n [2405:aa00:2::40]:8333\n+[2406:da14:445:5201::4]:8333\n+[2406:da18:f7c:4351:1a58:81fe:6ed0:1103]:8333\n+[2406:da18:f7c:4351:22aa:2585:fe88:7d58]:8333\n+[2406:da18:f7c:4351:2674:33bb:25d6:cbba]:8333\n+[2406:da18:f7c:4351:2e19:a8c7:a36a:bde0]:8333\n+[2406:da18:f7c:4351:3cc8:43d:fbcc:5067]:8333\n+[2406:da18:f7c:4351:5228:2b53:bb9a:edf5]:8333\n+[2406:da18:f7c:4351:5729:102:998c:d41a]:8333\n+[2406:da18:f7c:4351:591b:4881:3986:3703]:8333\n+[2406:da18:f7c:4351:59b9:b50:f47f:b560]:8333\n+[2406:da18:f7c:4351:61f2:cfb0:8c45:5fdd]:8333\n+[2406:da18:f7c:4351:6356:68e0:73fc:ac0b]:8333\n+[2406:da18:f7c:4351:660e:f6bc:3563:ba8e]:8333\n+[2406:da18:f7c:4351:691:9e:f2df:227d]:8333\n+[2406:da18:f7c:4351:721c:83d2:6765:4300]:8333\n+[2406:da18:f7c:4351:7237:9be:4601:bc15]:8333\n+[2406:da18:f7c:4351:7a3b:c203:fd11:6c7d]:8333\n+[2406:da18:f7c:4351:7a74:a80e:889a:ba42]:8333\n+[2406:da18:f7c:4351:7ee3:a181:f25c:fa79]:8333\n+[2406:da18:f7c:4351:8a25:9084:140:4549]:8333\n+[2406:da18:f7c:4351:8bc0:c6fd:ecfb:f074]:8333\n+[2406:da18:f7c:4351:91ce:d0ba:1b9e:c27b]:8333\n+[2406:da18:f7c:4351:9336:44e7:84b4:85b9]:8333\n+[2406:da18:f7c:4351:936c:c3b9:a1d0:848]:8333\n+[2406:da18:f7c:4351:93ef:1eef:65c8:766d]:8333\n+[2406:da18:f7c:4351:94e0:5b27:78c2:5111]:8333\n+[2406:da18:f7c:4351:9815:a202:18a3:2a36]:8333\n+[2406:da18:f7c:4351:9e1b:135c:7472:9d9]:8333\n+[2406:da18:f7c:4351:9f84:278:68f5:b8ea]:8333\n+[2406:da18:f7c:4351:a062:493f:a6f8:ca75]:8333\n+[2406:da18:f7c:4351:a192:b98:3066:8f11]:8333\n+[2406:da18:f7c:4351:a1cb:2f19:4a54:38c9]:8333\n+[2406:da18:f7c:4351:a4a2:4c9:c43a:98ae]:8333\n+[2406:da18:f7c:4351:a7e9:cd48:fa90:46d3]:8333\n+[2406:da18:f7c:4351:a88:99:6671:fce4]:8333\n+[2406:da18:f7c:4351:abe1:2e48:eb97:2ab5]:8333\n+[2406:da18:f7c:4351:acf5:2b21:5d2a:6b31]:8333\n+[2406:da18:f7c:4351:b51f:8966:74a5:6c53]:8333\n+[2406:da18:f7c:4351:b8e3:f3ca:e412:daa5]:8333\n+[2406:da18:f7c:4351:ba7c:6da8:da59:b1b6]:8333\n+[2406:da18:f7c:4351:be04:6f8e:8f93:c555]:8333\n+[2406:da18:f7c:4351:c82d:2a0b:31a5:e28d]:8333\n+[2406:da18:f7c:4351:c993:eb06:bd2c:1e65]:8333\n+[2406:da18:f7c:4351:d4b9:bff8:c4d4:1e05]:8333\n+[2406:da18:f7c:4351:d70d:a73d:1ddd:439e]:8333\n+[2406:da18:f7c:4351:e103:f456:b296:9f29]:8333\n+[2406:da18:f7c:4351:ea3b:27ec:7c2:aebc]:8333\n+[2406:da18:f7c:4351:f62c:5013:379b:363e]:8333\n [240b:10:ca20:f0:224:e8ff:fe1f:60d9]:8333\n [240b:250:1e0:2400:b9ef:8fe3:a69a:7378]:8333\n-[240d:1a:302:8600:8876:a36d:12ee:f285]:8333\n+[2600:1f14:34a:fe00:13f4:ceb6:a9db:4f47]:8333\n+[2600:1f14:34a:fe00:2550:9366:a5d9:78a5]:8333\n+[2600:1f14:34a:fe00:27d:6ed:7c8d:7bee]:8333\n+[2600:1f14:34a:fe00:2ed6:8a19:4eb:36c1]:8333\n+[2600:1f14:34a:fe00:34c7:2e9e:e60e:f823]:8333\n+[2600:1f14:34a:fe00:38de:442:72df:6346]:8333\n+[2600:1f14:34a:fe00:3a1e:878f:991a:9582]:8333\n+[2600:1f14:34a:fe00:3d88:1805:54e3:f4c8]:8333\n+[2600:1f14:34a:fe00:3f3e:58bd:ec82:5dac]:8333\n+[2600:1f14:34a:fe00:449a:9515:8436:f407]:8333\n+[2600:1f14:34a:fe00:4f84:277f:e64d:1f06]:8333\n+[2600:1f14:34a:fe00:5229:de84:8226:7257]:8333\n+[2600:1f14:34a:fe00:5743:42c3:951b:e97a]:8333\n+[2600:1f14:34a:fe00:5a29:85b:86b5:fa0e]:8333\n+[2600:1f14:34a:fe00:5de8:81e:6d79:330b]:8333\n+[2600:1f14:34a:fe00:5fca:ad1e:5b9c:5265]:8333\n+[2600:1f14:34a:fe00:68c4:ca1b:813e:1bce]:8333\n+[2600:1f14:34a:fe00:6:de9e:7b5e:a558]:8333\n+[2600:1f14:34a:fe00:6c72:1fcd:433:dc97]:8333\n+[2600:1f14:34a:fe00:77ee:629f:bc13:fb4f]:8333\n+[2600:1f14:34a:fe00:79d0:85d6:516f:3293]:8333\n+[2600:1f14:34a:fe00:81:422f:9ef3:4579]:8333\n+[2600:1f14:34a:fe00:822b:5f05:ec8d:48c6]:8333\n+[2600:1f14:34a:fe00:82a:76a2:fdc9:845e]:8333\n+[2600:1f14:34a:fe00:83ca:cef6:e04c:50c0]:8333\n+[2600:1f14:34a:fe00:8ba2:a36c:8687:d5aa]:8333\n+[2600:1f14:34a:fe00:8c80:5c67:3b47:90b3]:8333\n+[2600:1f14:34a:fe00:8eb8:f47f:6d53:e3ae]:8333\n+[2600:1f14:34a:fe00:989c:f8f8:a922:1b9a]:8333\n+[2600:1f14:34a:fe00:98c9:1eb3:ea12:a8f0]:8333\n+[2600:1f14:34a:fe00:9ee5:a8f6:6b2a:866e]:8333\n+[2600:1f14:34a:fe00:a46b:7bd5:629f:f75c]:8333\n+[2600:1f14:34a:fe00:a627:8299:8784:d439]:8333\n+[2600:1f14:34a:fe00:ad0b:955e:b4e5:d97d]:8333\n+[2600:1f14:34a:fe00:ae82:7117:9d69:7c86]:8333\n+[2600:1f14:34a:fe00:ccee:365a:43f8:b871]:8333\n+[2600:1f14:34a:fe00:d5ee:a3e2:2f85:e593]:8333\n+[2600:1f14:34a:fe00:d5f0:1fe0:6bd5:18a8]:8333\n+[2600:1f14:34a:fe00:e4a7:5aba:af87:4cdb]:8333\n+[2600:1f14:34a:fe00:e8e5:2d0:fb6f:2f5]:8333\n+[2600:1f14:34a:fe00:e9ef:4690:a5ac:92be]:8333\n+[2600:1f14:34a:fe00:efba:2260:6997:fcf7]:8333\n+[2600:1f14:34a:fe00:f107:2d08:c67:e5dd]:8333\n+[2600:1f14:34a:fe00:f1b9:88fb:f3db:a86e]:8333\n+[2600:1f14:34a:fe00:f79c:17b7:6f75:95b7]:8333\n+[2600:1f14:6ae:d900:6550:3fc5:e074:a72c]:8333\n+[2600:1f16:625:e00:1243:38b3:caa:d62e]:8333\n+[2600:1f16:625:e00:166d:a956:1041:f97d]:8333\n+[2600:1f16:625:e00:35f2:2428:fc57:d638]:8333\n+[2600:1f16:625:e00:3c75:333e:b7f:8cc0]:8333\n+[2600:1f16:625:e00:3fbf:31f:1b57:8b18]:8333\n+[2600:1f16:625:e00:5617:7575:379:a8cc]:8333\n+[2600:1f16:625:e00:58fa:fce6:30:a5dc]:8333\n+[2600:1f16:625:e00:5e74:70dc:af78:6b77]:8333\n+[2600:1f16:625:e00:7036:f651:2ee:39cd]:8333\n+[2600:1f16:625:e00:7fc:9004:e7be:ffe2]:8333\n+[2600:1f16:625:e00:814a:23f6:e996:5e64]:8333\n+[2600:1f16:625:e00:822c:a88b:f9c:57e3]:8333\n+[2600:1f16:625:e00:8314:b91e:a7ba:702]:8333\n+[2600:1f16:625:e00:88bb:ee9a:10de:12]:8333\n+[2600:1f16:625:e00:8c30:56f5:a29a:91de]:8333\n+[2600:1f16:625:e00:8fdf:6517:7718:8c42]:8333\n+[2600:1f16:625:e00:91fd:78b1:62a3:193]:8333\n+[2600:1f16:625:e00:930d:93ed:76a6:3285]:8333\n+[2600:1f16:625:e00:93c2:615f:a79a:c11f]:8333\n+[2600:1f16:625:e00:a780:8bc8:a1f6:d417]:8333\n+[2600:1f16:625:e00:a951:e663:4046:8c3a]:8333\n+[2600:1f16:625:e00:ab19:5fe3:f155:1371]:8333\n+[2600:1f16:625:e00:aefd:9cc7:d3:6e86]:8333\n+[2600:1f16:625:e00:b031:e86e:8604:324a]:8333\n+[2600:1f16:625:e00:b6e:4399:9dc2:6b45]:8333\n+[2600:1f16:625:e00:b7c7:58c6:21a1:fd41]:8333\n+[2600:1f16:625:e00:c169:6282:178c:27d6]:8333\n+[2600:1f16:625:e00:c94e:58b:bd35:d815]:8333\n+[2600:1f16:625:e00:caa5:7369:73a4:5711]:8333\n+[2600:1f16:625:e00:cd15:b9f2:6e3e:6fd1]:8333\n+[2600:1f16:625:e00:d6f3:775:66b7:3e92]:8333\n+[2600:1f16:625:e00:dbec:f7d9:e15:f8e0]:8333\n+[2600:1f16:625:e00:dbf4:4d41:594e:bc20]:8333\n+[2600:1f16:625:e00:e11b:4589:a0c3:9cc7]:8333\n+[2600:1f16:625:e00:ed68:15b0:3a97:be0c]:8333\n+[2600:1f16:625:e00:eef3:bce0:84ee:a98b]:8333\n+[2600:1f16:625:e00:ef3a:f66e:f059:d03f]:8333\n+[2600:1f16:625:e00:f67c:d398:5b6:d34f]:8333\n+[2600:1f16:625:e00:fe35:5099:3a8e:d123]:8333\n+[2600:1f18:64d9:1603:6f6f:eef9:b595:1958]:8333\n+[2600:3c00::f03c:91ff:fe84:d650]:8333\n+[2600:3c00::f03c:91ff:fe89:7438]:8333\n [2600:3c00::f03c:91ff:fe91:3e49]:8333\n [2600:3c00::f03c:91ff:febb:981e]:8333\n-[2600:3c01::f03c:91ff:fe18:6adf]:8333\n [2600:3c01::f03c:91ff:fe69:89e9]:8333\n [2600:3c01::f03c:91ff:fe91:6a29]:8333\n-[2600:3c01::f03c:91ff:fef1:1eaa]:8333\n-[2600:3c03::f03c:91ff:fe18:da80]:8333\n [2600:3c03::f03c:91ff:fe28:1445]:8333\n-[2600:3c03::f03c:91ff:fe67:d2e]:8333\n-[2600:3c03::f03c:91ff:fe89:116f]:8333\n-[2600:3c03::f03c:91ff:feb0:5fc4]:8333\n [2600:3c03::f03c:91ff:fee0:233e]:8333\n-[2600:3c03::f03c:91ff:fee0:51]:8333\n+[2600:6c55:7200:24d:cf4:811c:7cb3:f7a7]:8333\n [2600:8805:2400:14e:226:4aff:fe02:2ba4]:8333\n-[2600:8807:5080:3301:1487:83b7:33d7:eb97]:8333\n-[2601:186:c100:6bcd:16bd:cea1:235d:1c19]:8333\n-[2601:18c:4200:28d0:e4d:e9ff:fec5:76d0]:8333\n-[2601:247:8201:6251:30e6:7b95:69bf:9248]:8333\n+[2601:18d:4600:3cc2:20e7:b3ff:fecf:a99]:8333\n+[2601:1c2:1702:5241:47d:4016:ec42:6705]:8333\n+[2601:441:4101:70cd:4e3:8e81:3250:1f0b]:8333\n [2601:602:9980:f78:211:11ff:fec5:1ae]:8333\n-[2602:ae:1993:de00:2c50:9a44:8f11:77a5]:8333\n-[2602:ff68:0:1:21e:bff:feca:db72]:8333\n-[2602:ff68:0:1:2bd:27ff:feb0:adf8]:8333\n-[2602:ff68:0:1::5]:8333\n-[2602:ff68:0:5:2bd:27ff:feb0:adf8]:8333\n-[2602:ffc5:1f::1f:2d61]:8333\n-[2602:ffc5:1f::1f:9211]:8333\n-[2602:ffc5::9e63:27a2]:8333\n+[2601:646:4103:179f:5809:1bff:fe55:6678]:8333\n+[2602:4c:323:b101:35a3:9de8:6984:ef56]:8333\n+[2602:ff62:104:ac1:8000::]:8333\n+[2602:ffc5:40::1:711e]:8333\n [2602:ffc5::c30:1c75]:8333\n-[2602:ffc5::ffc5:b844]:8333\n-[2602:ffe8:100:2::457:936b]:8333\n-[2604:180:2:eee::ca46]:8333\n-[2604:880:d:85::be37]:8333\n-[2604:9a00:2100:a009:2::]:8333\n-[2604:a880:2:d0::301:8001]:8333\n-[2604:a880:2:d0::4a9:1001]:8333\n-[2604:a880:2:d0::53a:c001]:8333\n+[2604:a880:2:d0::17e9:2001]:8333\n+[2604:a880:2:d0::22f8:f001]:8333\n+[2604:a880:2:d0::22f9:1]:8333\n+[2604:a880:2:d0::22f9:c001]:8333\n+[2604:a880:2:d0::22f9:d001]:8333\n+[2604:a880:2:d0::22f9:e001]:8333\n+[2604:a880:2:d0::22fa:2001]:8333\n+[2604:a880:2:d0::22fa:3001]:8333\n+[2604:a880:400:d0::1684:5001]:8333\n+[2604:a880:400:d0::1ac4:b001]:8333\n+[2604:a880:400:d0::2004:4001]:8333\n+[2604:a880:400:d0::2004:5001]:8333\n+[2604:a880:400:d0::2004:6001]:8333\n+[2604:a880:400:d0::2004:c001]:8333\n+[2604:a880:400:d0::2004:d001]:8333\n+[2604:a880:400:d0::2004:e001]:8333\n+[2604:a880:400:d0::2004:f001]:8333\n+[2604:a880:400:d0::2005:1]:8333\n+[2604:a880:400:d0::2005:3001]:8333\n+[2604:a880:400:d0::261f:6001]:8333\n+[2604:a880:400:d0::28b8:5001]:8333\n [2604:a880:400:d0::ad7:e001]:8333\n-[2604:a880:400:d0::dcf:f001]:8333\n [2605:4d00::50]:8333\n-[2605:6000:edc8:300::ddfe]:8333\n-[2605:6000:ffc0:70:74d5:225c:f553:5bb8]:8333\n-[2606:6000:c148:7003:5054:ff:fe78:66ff]:8333\n-[2606:6000:e6d6:d701:d428:5e44:a2c9:3ff6]:8333\n-[2606:c680:1:4a:2016:d1ff:fe93:52a7]:8333\n+[2605:5d80:2002::245]:8333\n+[2605:9880:0:953:225:90ff:fed2:c0b4]:8333\n+[2606:c380::215:17ff:feb3:3ec]:8333\n+[2607:1c00:a:6:3c1c:1b0d:ba4:8ea9]:8333\n+[2607:1c00:a:6::1000]:8333\n+[2607:4480:2:2000:250:56ff:fe86:6449]:8333\n+[2607:5300:120:671::]:8333\n+[2607:5300:120:962::]:8333\n+[2607:5300:201:2000::1:556]:8333\n [2607:5300:203:118:3733::1414]:8333\n-[2607:5300:60:13bb::1]:8333\n-[2607:5300:60:1966::1]:8333\n-[2607:5300:60:2218::]:8333\n-[2607:5300:60:3775::]:8333\n+[2607:5300:60:10aa::1]:8333\n+[2607:5300:60:1e83::]:8333\n+[2607:5300:60:1e83::1000]:8333\n+[2607:5300:60:1e83::2000]:8333\n+[2607:5300:60:2d0::1]:8333\n [2607:5300:60:3ddf::]:8333\n-[2607:5300:60:a654::]:8333\n-[2607:5300:60:a7a3::]:8333\n+[2607:5300:60:3f3c::]:8333\n+[2607:5300:60:5428::]:8333\n [2607:5300:60:ac0::1]:8333\n-[2607:5300:60:cf97::]:8333\n-[2607:f0d0:1901:19::6]:8333\n-[2607:f128:40:1202:69:162:139:125]:8333\n-[2607:f128:40:1703::2]:8333\n-[2607:f178:0:8::106]:8333\n-[2607:f1c0:84d:8900::7e:cad]:8333\n+[2607:5300:61:f4b::1]:8333\n+[2607:9000:0:1:5054:ff:fe5d:264e]:8333\n+[2607:f1c0:846:9a00::87:d00e]:8333\n+[2607:f2d8:4005:d:a8a2:eeff:fee0:a859]:8333\n [2607:f948:0:1::1:40]:8333\n-[2607:fcd0:100:2302::6094:635a]:8333\n-[2607:fcd0:100:6a00::3a96:1]:8333\n-[2607:fcd0:100:6a02::7ff0:1]:8333\n-[2607:fcd0:100:8203::8c58:dbc]:8333\n-[2607:fea8:1360:9c2:221a:6ff:fe47:776d]:8333\n-[2607:fea8:4da0:9ce:5114:a8ec:20f5:a50b]:8333\n-[2607:fea8:5df:fda0:feaa:14ff:feda:c79a]:8333\n-[2607:fea8:84c0:163:f42c:baff:fecc:6bbf]:8333\n+[2607:fa18:3a01::50]:8333\n+[2607:fea8:3ca0:926::2]:8333\n+[2607:fea8:4da0:3b0::2]:8333\n [2607:ff10:c5:502:225:90ff:fe32:d446]:8333\n-[2607:ff48:aa81:800::96cf:1]:8333\n-[2620:11c:5001:1118:d267:e5ff:fee9:e673]:8333\n+[2607:ff28:9005:1::2567:57e0]:8333\n+[2620:71:4000:0:192:30:120:110]:8333\n [2620:b8:4000:1000::93:1]:8333\n [2800:1a0::9]:8333\n-[2a00:1178:2:43:19fd:d43e:b77:edeb]:8333\n-[2a00:1178:2:43:b4e3:e562:f811:d761]:8333\n-[2a00:14f0:e000:80d2:cd1a::1]:8333\n-[2a00:1630:14::101]:8333\n-[2a00:1630:2:1802:188:122:91:11]:8333\n-[2a00:1630:2:500::4]:8333\n+[2801:84:0:1034:76d4:35ff:fe7f:5033]:8333\n+[2a00:16d8:c::5b6a:c261]:8333\n [2a00:1768:2001:24::148:218]:8333\n-[2a00:1768:2001:27::142:21]:8333\n+[2a00:19e0:1:1:225:90ff:fea5:fc0]:8333\n [2a00:1a48:7810:101:be76:4eff:fe08:c774]:8333\n-[2a00:1ca8:37::a5fc:40d1]:8333\n-[2a00:1ca8:37::ab6d:ce2c]:8333\n-[2a00:1dc0:2255:10::2]:8333\n+[2a00:6340:2004:0:5054:ff:fe54:38c]:8333\n+[2a00:7b80:477:21::1c8c:83a6]:8333\n [2a00:7c80:0:71::8]:8333\n [2a00:7c80:0:97::7]:8333\n-[2a00:bbe0:0:42:222:64ff:fe9a:e206]:8333\n-[2a00:c98:2050:a020:3::110]:8333\n-[2a00:dcc0:eda:98:183:193:1d24:b53a]:8333\n-[2a00:dcc0:eda:98:183:193:c382:6bdb]:8333\n-[2a00:dcc0:eda:98:183:193:f72e:d943]:8333\n-[2a00:f90:ff0:c100:53c4:97a7:8b59:796a]:8333\n-[2a01:238:435c:de00:b110:38cf:192d:b2c]:28333\n-[2a01:348:6:7cf::2]:8333\n-[2a01:368:e012:8888:216:3eff:fe24:1162]:8333\n+[2a01:238:4363:4900:d85e:c1d9:2b32:61d0]:8333\n [2a01:488:66:1000:53a9:22b:0:1]:8333\n-[2a01:488:67:1000:523:ffa7:0:1]:8333\n+[2a01:488:67:1000:5bfa:5526:0:1]:8333\n [2a01:488:67:1000:b01c:3379:0:1]:8333\n-[2a01:4f8:100:34ce::2]:8333\n-[2a01:4f8:100:44e7::2]:8333\n-[2a01:4f8:10a:2e4::2]:8333\n-[2a01:4f8:10a:34e::2]:8333\n-[2a01:4f8:10a:51d::2]:8333\n-[2a01:4f8:10a:622::2]:8333\n-[2a01:4f8:10a:85f::2]:8333\n-[2a01:4f8:10a:864::2]:8333\n-[2a01:4f8:10a:d04::2]:8333\n-[2a01:4f8:110:334c::2]:8333\n+[2a01:4d60:3:1:5::1]:8333\n+[2a01:4f8:10a:1d8f::2]:8333\n+[2a01:4f8:10a:1e81::2]:8333\n+[2a01:4f8:10a:2261::2]:8833\n+[2a01:4f8:10a:239c::2]:9002\n+[2a01:4f8:10a:294a::2]:8333\n+[2a01:4f8:10a:31d3::2]:8333\n+[2a01:4f8:10a:3fe6::2]:8333\n+[2a01:4f8:10a:b2e::2]:8333\n+[2a01:4f8:10b:12d7::2]:8333\n+[2a01:4f8:10b:d50::2]:8333\n+[2a01:4f8:10b:e2d::2]:8333\n+[2a01:4f8:10b:ee1::2]:8333\n+[2a01:4f8:110:5107::2]:8333\n+[2a01:4f8:110:5292::2]:8333\n [2a01:4f8:110:536e::2]:8333\n [2a01:4f8:120:43e4::2]:8333\n-[2a01:4f8:120:702e::2]:8333\n-[2a01:4f8:121:4346::2]:8333\n [2a01:4f8:130:3332::2]:8333\n+[2a01:4f8:130:430b::2]:8333\n+[2a01:4f8:130:618e::2]:8333\n+[2a01:4f8:130:71d2::2]:8333\n+[2a01:4f8:130:7422::2]:8333\n [2a01:4f8:131:33ad::2]:8333\n [2a01:4f8:131:33ad:fea1::666]:8333\n-[2a01:4f8:140:31b0::2]:8333\n-[2a01:4f8:140:4088::2]:8333\n+[2a01:4f8:131:3428::2]:8333\n+[2a01:4f8:140:1326::2]:8333\n+[2a01:4f8:140:524a::2]:8333\n+[2a01:4f8:140:6055::2]:8333\n+[2a01:4f8:140:7410::2]:8333\n [2a01:4f8:140:931a::2]:8333\n-[2a01:4f8:140:93b0::2]:8333\n-[2a01:4f8:141:13ad::c451]:8333\n-[2a01:4f8:141:186::2]:8333\n+[2a01:4f8:141:2254::2]:8333\n [2a01:4f8:141:22ae::2]:8333\n-[2a01:4f8:141:322c::2]:8333\n [2a01:4f8:150:11d4::2]:8333\n-[2a01:4f8:150:440f::2]:8333\n-[2a01:4f8:150:61ee::2]:8333\n+[2a01:4f8:150:70a4::2]:8333\n [2a01:4f8:150:726b::2]:8333\n-[2a01:4f8:151:30c9::2]:15000\n-[2a01:4f8:151:41a2::2]:8333\n-[2a01:4f8:151:41cc::2]:8333\n-[2a01:4f8:151:52c6::154]:8333\n-[2a01:4f8:151:600b::1:1]:8333\n+[2a01:4f8:150:72ee::4202]:8333\n+[2a01:4f8:150:90ca::2]:8333\n+[2a01:4f8:151:30c9::2]:8333\n+[2a01:4f8:151:334d::3]:8333\n [2a01:4f8:151:7175::2]:8333\n [2a01:4f8:160:41f0::1:33]:8333\n-[2a01:4f8:160:5328::27f0:187a]:8333\n-[2a01:4f8:160:814f::2]:8333\n-[2a01:4f8:161:21ad::333:30]:8333\n+[2a01:4f8:160:636e::2]:8333\n [2a01:4f8:161:7026::2]:8333\n-[2a01:4f8:162:4110::2]:8333\n-[2a01:4f8:162:4348::2]:8333\n+[2a01:4f8:162:2108::2]:8333\n+[2a01:4f8:162:3121::50]:8333\n+[2a01:4f8:162:424c::2]:8333\n [2a01:4f8:171:1c1b::2]:8333\n [2a01:4f8:171:1c3::2]:8333\n [2a01:4f8:171:2258::2]:8333\n-[2a01:4f8:171:2a70::2]:8333\n-[2a01:4f8:171:2e1b::2]:8333\n+[2a01:4f8:171:27d6::2]:8333\n [2a01:4f8:171:2f28::2]:8333\n-[2a01:4f8:171:3248::2]:8333\n-[2a01:4f8:171:380c::2]:8333\n-[2a01:4f8:171:b93::2]:8333\n-[2a01:4f8:171:d0a::2]:8333\n-[2a01:4f8:172:116c::2]:8333\n-[2a01:4f8:172:1287::2]:8333\n-[2a01:4f8:172:17a9::2]:8333\n-[2a01:4f8:172:1ca7::2]:8333\n-[2a01:4f8:172:2159::2]:8333\n-[2a01:4f8:172:3a41::2]:8333\n-[2a01:4f8:172:3b42::2]:8333\n-[2a01:4f8:172:3ec1::2]:8333\n-[2a01:4f8:172:3ec2::2]:8333\n-[2a01:4f8:172:aeb::2]:8333\n-[2a01:4f8:172:aec::2]:8333\n-[2a01:4f8:173:10ab::2]:8333\n-[2a01:4f8:173:1551::2]:8333\n-[2a01:4f8:173:1bca::2]:8333\n-[2a01:4f8:173:1e2e::2]:8333\n-[2a01:4f8:173:2162::2]:8333\n-[2a01:4f8:173:21e6::2]:8333\n+[2a01:4f8:171:d23::2]:8333\n+[2a01:4f8:172:10da::2]:8333\n+[2a01:4f8:172:504::2]:8333\n+[2a01:4f8:173:1622::2]:8333\n [2a01:4f8:173:42::2]:8333\n-[2a01:4f8:173:cc1::2]:8333\n-[2a01:4f8:190:1253::2]:8333\n [2a01:4f8:190:24eb::2]:8333\n-[2a01:4f8:190:34f0::2]:8333\n [2a01:4f8:190:528d::2]:8333\n-[2a01:4f8:190:91ce::2]:8333\n-[2a01:4f8:191:2194::83]:8333\n-[2a01:4f8:191:40e8::2]:8333\n-[2a01:4f8:191:8165::2]:22556\n+[2a01:4f8:190:61f3::2]:8333\n+[2a01:4f8:191:418f::2]:3333\n+[2a01:4f8:191:63b4:5000::1]:8333\n [2a01:4f8:191:81b7::2]:8333\n [2a01:4f8:191:8328::3]:8333\n-[2a01:4f8:192:11b2::2]:8343\n-[2a01:4f8:192:216c::2]:8333\n-[2a01:4f8:192:22af::2]:8333\n-[2a01:4f8:192:2422::2]:8333\n-[2a01:4f8:192:34d0::2]:8333\n-[2a01:4f8:192:440b::2]:8333\n+[2a01:4f8:192:4a5::2]:8333\n [2a01:4f8:192:5230::2]:8333\n-[2a01:4f8:192:db::2]:8333\n [2a01:4f8:200:1012::2]:8333\n+[2a01:4f8:200:32a6::2]:8333\n [2a01:4f8:200:414e::2]:8333\n [2a01:4f8:200:416a::2]:8333\n-[2a01:4f8:201:21a7::2]:8333\n-[2a01:4f8:201:4017::11]:8333\n+[2a01:4f8:200:90c3::2]:8333\n+[2a01:4f8:201:148d::2]:8333\n+[2a01:4f8:201:2cc::2]:8333\n+[2a01:4f8:201:3e3::2]:8333\n+[2a01:4f8:201:53cc::2]:8333\n [2a01:4f8:201:6011::4]:8333\n-[2a01:4f8:201:60d5::2]:8333\n-[2a01:4f8:202:12d6::2]:8333\n+[2a01:4f8:202:3030::2]:8333\n [2a01:4f8:202:31e3::2]:8333\n [2a01:4f8:202:32c6::2]:8333\n-[2a01:4f8:202:53c3::2]:8333\n-[2a01:4f8:211:14cf::2]:8333\n+[2a01:4f8:202:6035::2]:8333\n+[2a01:4f8:210:5488::2]:8333\n+[2a01:4f8:211:1e17::2]:8333\n [2a01:4f8:211:1ec5::2]:8333\n-[2a01:4f8:211:483::2]:8333\n-[2a01:4f8:211:d99::8]:8333\n [2a01:4f8:212:1826::2]:8333\n-[2a01:4f8:212:27a8::2]:8333\n-[2a01:4f8:221:801::2]:8333\n-[2a01:4f8:a0:12cc::2]:8333\n-[2a01:4f8:a0:746a:101:1:1:2]:8333\n-[2a01:4f8:a0:828a::2]:8333\n-[2a01:4f8:c17:2eef::2]:8333\n-[2a01:4f8:c17:2f3c::2]:3333\n+[2a01:4f8:221:f59::2]:8333\n+[2a01:4f8:c0c:1026::2]:8333\n+[2a01:4f8:c0c:1028::2]:8333\n+[2a01:4f8:c0c:1029::2]:8333\n+[2a01:4f8:c0c:105f::2]:8333\n+[2a01:4f8:c0c:1064::2]:8333\n+[2a01:4f8:c0c:106b::2]:8333\n+[2a01:4f8:c0c:106d::2]:8333\n+[2a01:4f8:c0c:1070::2]:8333\n+[2a01:4f8:c0c:1105::2]:8333\n+[2a01:4f8:c0c:1106::2]:8333\n+[2a01:4f8:c0c:1134::2]:8333\n+[2a01:4f8:c0c:1135::2]:8333\n+[2a01:4f8:c0c:113c::2]:8333\n+[2a01:4f8:c0c:115c::2]:8333\n+[2a01:4f8:c0c:115e::2]:8333\n+[2a01:4f8:c0c:1170::2]:8333\n+[2a01:4f8:c0c:1172::2]:8333\n+[2a01:4f8:c0c:117b::2]:8333\n+[2a01:4f8:c0c:117c::2]:8333\n+[2a01:4f8:c0c:1180::2]:8333\n+[2a01:4f8:c0c:1181::2]:8333\n+[2a01:4f8:c0c:1185::2]:8333\n+[2a01:4f8:c0c:1186::2]:8333\n+[2a01:4f8:c0c:1187::2]:8333\n+[2a01:4f8:c0c:1188::2]:8333\n+[2a01:4f8:c0c:1189::2]:8333\n+[2a01:4f8:c0c:121::2]:8333\n+[2a01:4f8:c0c:122::2]:8333\n+[2a01:4f8:c0c:15a8::2]:8333\n+[2a01:4f8:c0c:1da4::2]:8333\n+[2a01:4f8:c0c:1ff7::2]:8333\n+[2a01:4f8:c0c:2262::2]:8333\n+[2a01:4f8:c0c:73d::2]:8333\n+[2a01:4f8:c0c:790::2]:8333\n+[2a01:4f8:c0c:7a8::2]:8333\n+[2a01:4f8:c0c:7a9::2]:8333\n+[2a01:4f8:c0c:7e9::2]:8333\n+[2a01:4f8:c0c:816::2]:8333\n+[2a01:4f8:c0c:817::2]:8333\n+[2a01:4f8:c0c:818::2]:8333\n+[2a01:4f8:c0c:820::2]:8333\n+[2a01:4f8:c0c:821::2]:8333\n+[2a01:4f8:c0c:822::2]:8333\n+[2a01:4f8:c0c:896::2]:8333\n+[2a01:4f8:c0c:8c6::2]:8333\n+[2a01:4f8:c0c:8c9::2]:8333\n+[2a01:4f8:c0c:8d1::2]:8333\n+[2a01:4f8:c0c:8d2::2]:8333\n+[2a01:4f8:c0c:8d9::2]:8333\n+[2a01:4f8:c0c:8da::2]:8333\n+[2a01:4f8:c0c:8dc::2]:8333\n+[2a01:4f8:c0c:8f1::2]:8333\n+[2a01:4f8:c0c:91e::2]:8333\n+[2a01:4f8:c0c:927::2]:8333\n+[2a01:4f8:c0c:939::2]:8333\n+[2a01:4f8:c0c:944::2]:8333\n+[2a01:4f8:c0c:951::2]:8333\n+[2a01:4f8:c0c:967::2]:8333\n+[2a01:4f8:c0c:96f::2]:8333\n+[2a01:4f8:c0c:97d::2]:8333\n+[2a01:4f8:c0c:982::2]:8333\n+[2a01:4f8:c0c:9fc::2]:8333\n+[2a01:4f8:c0c:b35::2]:8333\n+[2a01:4f8:c0c:b4c::2]:8333\n+[2a01:4f8:c0c:bfe::2]:8333\n+[2a01:4f8:c0c:c08::2]:8333\n+[2a01:4f8:c0c:c13::2]:8333\n+[2a01:4f8:c0c:c14::2]:8333\n+[2a01:4f8:c0c:c16::2]:8333\n+[2a01:4f8:c0c:c19::2]:8333\n+[2a01:4f8:c0c:c32::2]:8333\n+[2a01:4f8:c0c:c36::2]:8333\n+[2a01:4f8:c0c:c39::2]:8333\n+[2a01:4f8:c0c:c58::2]:8333\n+[2a01:4f8:c0c:c5e::2]:8333\n+[2a01:4f8:c0c:c70::2]:8333\n+[2a01:4f8:c0c:c72::2]:8333\n+[2a01:4f8:c0c:c79::2]:8333\n+[2a01:4f8:c0c:cb1::2]:8333\n+[2a01:4f8:c0c:cf5::2]:8333\n+[2a01:4f8:c0c:cff::2]:8333\n+[2a01:4f8:c0c:d0e::2]:8333\n+[2a01:4f8:c0c:d1b::2]:8333\n+[2a01:4f8:c0c:d67::2]:8333\n+[2a01:4f8:c0c:d68::2]:8333\n+[2a01:4f8:c0c:d81::2]:8333\n+[2a01:4f8:c0c:e2d::2]:8333\n+[2a01:4f8:c0c:e30::2]:8333\n+[2a01:4f8:c0c:e4f::2]:8333\n+[2a01:4f8:c0c:e5b::2]:8333\n+[2a01:4f8:c0c:e88::2]:8333\n+[2a01:4f8:c0c:f69::2]:8333\n+[2a01:4f8:c0c:f76::2]:8333\n+[2a01:4f8:c0c:f77::2]:8333\n+[2a01:4f8:c0c:f78::2]:8333\n+[2a01:4f8:c0c:f89::2]:8333\n+[2a01:4f8:c0c:f8a::2]:8333\n+[2a01:4f8:c0c:fd6::2]:8333\n+[2a01:4f8:c0c:fea::2]:8333\n+[2a01:4f8:c17:24ee::2]:8333\n+[2a01:4f8:c17:2c16::2]:8333\n+[2a01:4f8:c17:330f::2]:8333\n+[2a01:4f8:c17:34f0::2]:8333\n+[2a01:4f8:c17:3986::2]:8333\n [2a01:4f8:c17:3b02::2]:8333\n-[2a01:4f8:c17:4245::2]:8333\n-[2a01:4f8:c17:464f::2]:8333\n-[2a01:4f8:c17:4a1c::2]:8333\n-[2a01:4f8:c17:4c5d::2]:8333\n+[2a01:4f8:c17:3d85::2]:8333\n+[2a01:4f8:c17:4271::2]:8333\n+[2a01:4f8:c17:5dc0::2]:8333\n+[2a01:4f8:c17:63a0::2]:8333\n [2a01:4f8:c17:67f8::2]:8333\n-[2a01:4f8:c17:6dd0::2]:8333\n [2a01:4f8:c17:710b::2]:8333\n-[2a01:4f8:c17:714::2]:8333\n-[2a01:4f8:c17:72c6::2]:8333\n-[2a01:608:ffff:a009:8bf5:879d:e51a:f837]:8333\n+[2a01:4f8:c17:e00::2]:8333\n [2a01:680:10:10::1]:8333\n [2a01:6f0:ffff:120::8dcb]:8333\n-[2a01:79c:cebc:857c:98c1:88ff:fef5:90de]:8333\n-[2a01:79d:7377:2629:7e57:7e57:1:1]:8333\n-[2a01:7c8:aaac:43d:5054:ff:fe4e:3dd4]:8333\n+[2a01:79d:b7dd:ffb4:5d86:70b8:fc7f:f253]:8333\n+[2a01:7a0:2:1374::4]:8333\n+[2a01:7a0:2:1374::5]:8333\n+[2a01:7a0:2:137c::3]:8333\n+[2a01:7c8:aaaa:373:5054:ff:feb3:2947]:8333\n+[2a01:7c8:aaaa:3a0:5054:ff:fe8c:974c]:8333\n+[2a01:7c8:aab0:4b7:910d:625e:a13e:c342]:8333\n [2a01:7c8:aab5:3e6:5054:ff:fed7:4e54]:8333\n+[2a01:7c8:aab5:41e:5054:ff:fe38:f4fb]:8333\n+[2a01:7c8:aaba:343::8333]:8333\n+[2a01:7c8:aabc:18c:5054:ff:fefd:3b49]:8333\n [2a01:7c8:aabd:3d5:5054:ff:fe95:f586]:8333\n-[2a01:7c8:aac1:453:d0d2:af96:fa88:5d0e]:8333\n-[2a01:7c8:aac3:663:5054:ff:fe25:8c69]:8333\n-[2a01:7c8:aac3:97:5054:ff:fea7:3780]:8333\n-[2a01:7c8:aac4:567:5054:ff:fedc:518a]:8333\n-[2a01:7e00::f03c:91ff:fe26:8c87]:8333\n [2a01:7e00::f03c:91ff:fe50:94b8]:8333\n-[2a01:7e00::f03c:91ff:fe55:2c]:8333\n-[2a01:7e00::f03c:91ff:fe89:1143]:8333\n-[2a01:7e00::f03c:91ff:fe89:53fd]:8333\n-[2a01:7e00::f03c:91ff:fedf:b70f]:8333\n-[2a01:b000::4166:515b:ef9e:b3]:8333\n+[2a01:8e01:b943:3a63:d250:99ff:fe1f:4fb2]:8333\n [2a01:b2e0:2::40]:8333\n-[2a01:e34:ec29:24c0:f3:ddaf:9f59:586f]:8333\n+[2a01:d0:0:1c::245]:8333\n+[2a01:d0:8fc3::2]:8333\n+[2a01:e34:ec29:e8d0:25c7:c1ce:b7a3:d238]:8333\n+[2a01:e34:ec4a:c2d0:1cf3:40d2:a79f:3901]:8333\n [2a01:e34:eed7:6670:ec1b:bf7c:b012:6069]:8333\n+[2a01:e35:2433:e320:9c8e:6ff0:990f:f06e]:8333\n [2a01:e35:2ee5:610:21f:d0ff:fe4e:7460]:8333\n-[2a01:e35:8a3f:47c0:c617:feff:fe3c:9fbd]:8333\n-[2a01:e35:8bff:70b0:1e1b:dff:fe0b:236d]:8333\n-[2a02:1205:34c3:a4e0:d63d:7eff:fe98:10c8]:8333\n-[2a02:1205:34da:aa00:5882:249d:ddbf:bc43]:8333\n [2a02:1205:5051:a640:d6ae:52ff:fea3:ac]:8333\n-[2a02:1205:c689:d980:baae:edff:feea:9445]:8333\n [2a02:120b:2c2a:5ec0:10dd:31ff:fe42:5079]:8333\n-[2a02:120b:2c35:69d0:219:99ff:fe6b:4ec3]:8333\n-[2a02:120b:c3c2:ff60:21f:5bff:fec3:a7ad]:24312\n-[2a02:13b8:4000:1000:216:e6ff:fe92:8619]:8333\n-[2a02:13b8:4000:1000::27]:8333\n-[2a02:17d0:2a:4400:40f:3dd4:b053:47ad]:8333\n-[2a02:180:1:1::517:afb]:8333\n+[2a02:168:6273::614]:8333\n [2a02:180:6:1::18]:8333\n-[2a02:1810:1d11:f900:6872:f28e:8126:f635]:8333\n-[2a02:27a8:0:1:52e5:49ff:fee3:3b49]:8333\n-[2a02:348:86:3011::1]:8333\n+[2a02:180:6:1::ed]:8333\n+[2a02:1811:b707:116:8c1f:c5be:bf3a:54df]:8333\n+[2a02:20c8:1422:1::a3]:8333\n+[2a02:2168:d05:2c00:216:3eff:fef7:a099]:8333\n+[2a02:27f8:2012:0:e9f7:268f:c441:6129]:8333\n+[2a02:2808:5401:0:225:90ff:fe4e:ee42]:8333\n [2a02:390:9000:0:218:7dff:fe10:be33]:8333\n-[2a02:582:78c1:7600:2d49:6212:29d3:abb]:8333\n-[2a02:6080::1:190b:69e3]:8333\n-[2a02:750:7:3305::575]:8333\n-[2a02:752:100:3::53]:8333\n-[2a02:7aa0:1201::7501:d950]:8333\n-[2a02:7aa0:1201::deb3:81a2]:8333\n-[2a02:7aa0:1619::a037:69a6]:8333\n-[2a02:810d:14c0:8694:d250:99ff:fe81:23d9]:8333\n-[2a02:a50::dacb:8aff:fe36:8d2d]:8333\n-[2a02:c200:0:10:3:0:2591:1]:8333\n-[2a02:c200:1:10:2:5:9982:1]:8333\n-[2a02:c200:1:10:3:0:9290:1]:8333\n-[2a02:c205:3000:7158::1]:8333\n-[2a02:c205:3001:4522::1]:8333\n-[2a02:c205:3001:6549::1]:8333\n-[2a02:c207:2008:3772::1]:8333\n-[2a02:c207:2008:6519::1]:8333\n+[2a02:7aa0:1201::bd4e:1219]:8333\n+[2a02:7aa0:1619::590:eba2]:8333\n+[2a02:7aa0:1619::a7a2:7e86]:8333\n+[2a02:c200:1:10:2:5:800:1]:8333\n+[2a02:c205:2002:2550::17]:8333\n+[2a02:c205:2008:272::1]:8333\n+[2a02:c205:2010:5484::1]:8333\n+[2a02:c205:3001:6710::1]:8333\n+[2a02:c205:3001:7714::2]:8333\n+[2a02:c205:3002:888::1]:8333\n+[2a02:c207:2002:9013::1]:8333\n+[2a02:c207:2008:3392::1]:8333\n+[2a02:c207:2008:8337::1]:8333\n [2a02:c207:2009:213::1]:8333\n-[2a02:c207:2009:7858::1]:8333\n-[2a02:c207:2010:302::1]:8333\n+[2a02:c207:2010:7751::1]:8333\n+[2a02:c207:2010:7986::1]:8333\n+[2a02:c207:2011:7829::1]:8333\n+[2a02:c207:2011:8299::1]:8333\n+[2a02:c207:2012:2133::1]:8333\n+[2a02:c207:2012:263::1]:8333\n+[2a02:c207:2012:2682::1]:8333\n+[2a02:c207:2012:3635::1]:8333\n+[2a02:c207:2012:4826::1]:8333\n+[2a02:c207:2012:5668::1]:8333\n [2a02:c207:3001:5824::1]:8333\n+[2a02:c207:3001:7776::1]:8333\n+[2a02:c207:3002:621::1]:8333\n [2a02:ce80:0:20::1]:8333\n+[2a03:2260:11e:301::8]:8333\n+[2a03:2260:11e:302::3]:8333\n [2a03:4000:2:496::8]:8333\n+[2a03:4000:6:12e7::1]:8333\n [2a03:4000:6:416c::53]:8333\n-[2a03:4000:6:8009::1]:8333\n-[2a03:4000:9:8e::1]:8333\n-[2a03:7380:2140:17:51fe:3519:b571:4a13]:8333\n-[2a03:b0c0:0:1010::7a3:1001]:8333\n-[2a03:b0c0:0:1010::7aa:4001]:8333\n+[2a03:b0c0:3:d0::1219:6001]:8333\n [2a03:b0c0:3:d0::1b99:c001]:8333\n [2a03:b0c0:3:d0::1b99:e001]:8333\n [2a03:b0c0:3:d0::1b9a:3001]:8333\n-[2a03:b0c0:3:d0::2208:6001]:8333\n [2a03:b0c0:3:d0::23f7:1001]:8333\n+[2a03:b0c0:3:d0::23f7:2001]:8333\n+[2a03:b0c0:3:d0::23f7:4001]:8333\n+[2a03:b0c0:3:d0::23f7:5001]:8333\n+[2a03:b0c0:3:d0::23f7:7001]:8333\n [2a03:b0c0:3:d0::23f7:9001]:8333\n+[2a03:b0c0:3:d0::23fb:1001]:8333\n [2a03:b0c0:3:d0::23fb:2001]:8333\n [2a03:b0c0:3:d0::23fb:3001]:8333\n [2a03:b0c0:3:d0::23fb:5001]:8333\n-[2a03:b0c0:3:d0::23fb:7001]:8333\n+[2a03:b0c0:3:d0::23fb:6001]:8333\n+[2a03:b0c0:3:d0::23fb:8001]:8333\n+[2a03:b0c0:3:d0::23ff:b001]:8333\n [2a03:b0c0:3:d0::2400:1]:8333\n [2a03:b0c0:3:d0::2400:3001]:8333\n+[2a03:b0c0:3:d0::2400:4001]:8333\n [2a03:b0c0:3:d0::2400:e001]:8333\n+[2a03:b0c0:3:d0::2400:f001]:8333\n [2a03:b0c0:3:d0::2401:e001]:8333\n+[2a03:b0c0:3:d0::2402:1]:8333\n [2a03:b0c0:3:d0::2402:2001]:8333\n [2a03:b0c0:3:d0::2402:8001]:8333\n [2a03:b0c0:3:d0::2402:9001]:8333\n [2a03:b0c0:3:d0::2402:b001]:8333\n [2a03:b0c0:3:d0::2402:d001]:8333\n+[2a03:b0c0:3:d0::2402:e001]:8333\n [2a03:b0c0:3:d0::2403:1001]:8333\n [2a03:b0c0:3:d0::2403:2001]:8333\n+[2a03:b0c0:3:d0::2403:3001]:8333\n [2a03:b0c0:3:d0::2403:4001]:8333\n [2a03:b0c0:3:d0::2403:6001]:8333\n [2a03:b0c0:3:d0::2403:a001]:8333\n [2a03:b0c0:3:d0::2403:b001]:8333\n+[2a03:b0c0:3:d0::2403:e001]:8333\n [2a03:b0c0:3:d0::2403:f001]:8333\n+[2a03:b0c0:3:d0::2404:1]:8333\n+[2a03:b0c0:3:d0::2404:3001]:8333\n+[2a03:b0c0:3:d0::2404:4001]:8333\n [2a03:b0c0:3:d0::2404:6001]:8333\n+[2a03:b0c0:3:d0::2404:8001]:8333\n+[2a03:b0c0:3:d0::2404:9001]:8333\n [2a03:b0c0:3:d0::2404:b001]:8333\n-[2a03:f80:ed15:149:154:155:235:1]:8333\n-[2a04:1980:3100:1aac:e61d:2dff:fe29:f241]:8333\n-[2a04:1980:3100:1aac:e61d:2dff:fe29:f251]:8333\n-[2a04:2180:0:1::5a49:3c06]:8333\n-[2a04:2180:1:7::3]:8333\n-[2a04:2e00:5:2e:9a4b:e1ff:fe62:6dc0]:8333\n+[2a03:b0c0:3:d0::2405:2001]:8333\n+[2a03:b0c0:3:d0::2405:3001]:8333\n+[2a03:b0c0:3:d0::2405:8001]:8333\n+[2a03:b0c0:3:d0::2405:9001]:8333\n+[2a03:b0c0:3:d0::2405:a001]:8333\n+[2a03:b0c0:3:d0::44b8:9001]:8333\n+[2a03:b0c0:3:d0::44b8:e001]:8333\n+[2a03:b0c0:3:d0::44b8:f001]:8333\n+[2a03:b0c0:3:d0::44b9:1]:8333\n+[2a03:b0c0:3:d0::44b9:1001]:8333\n+[2a03:b0c0:3:d0::44b9:2001]:8333\n+[2a03:b0c0:3:d0::44b9:4001]:8333\n+[2a04:2180:0:2::94]:8333\n [2a04:3542:1000:910:8492:b8ff:fe91:711d]:8333\n-[2a04:dbc3:fffe:0:e61f:13ff:fe95:8401]:8333\n+[2a04:52c0:101:122::ba8e]:8333\n+[2a05:3580:d400:140d:da6e:826e:e771:4100]:8333\n [2a06:9fc0:2a06:9fc0:2a06:9fc1:67c:e706]:8333\n-[2c0f:f738:2004:82::]:8333\n-2hryb3uh3tzwgnya.onion:8333\n-3nmbbakinewlgdln.onion:8333\n-3qeri3tmhzmpegyv.onion:8333\n-4wdknmecghcmclq5.onion:8333\n-53tsjt6zq3iasv5q.onion:8333\n-5cg7qeywvwo6vxpt.onion:8333\n-5gbcrgqxcbxj253s.onion:8333\n-6cn4ilbwkrkh7gwo.onion:8333\n-6e4jrnn7igeqxmlf.onion:8333\n-6ymgbvnn6d5nfmv4.onion:8333\n-6zsh3bfduhpo7ldl.onion:8333\n-72fq6phv4fg4rhvh.onion:8333\n-7gdqp6npusk4lfwk.onion:8333\n-a7emxol55e623lqc.onion:8333\n-assbiydziq77zaki.onion:8333\n+226eupdnaouu4h2v.onion:8333\n+2frgxpe5mheghyom.onion:8333\n+3ihjnsvwc3x6dp2o.onion:8333\n+3w77hrilg6q64opl.onion:8333\n+4ls4o6iszcd7mkfw.onion:8333\n+4p3abjxqppzxi7qi.onion:8333\n+546esc6botbjfbxb.onion:8333\n+5msftytzlsskr4ut.onion:8333\n+5ty6rxpgrkmdnk4a.onion:8333\n+akmqyuidrf56ip26.onion:8333\n+alhlegtjkdmbqsvt.onion:8333\n bafk5ioatlgt7dgl.onion:8333\n-bk7yp6epnmcllq72.onion:8333\n-brwqezn6le54w2bb.onion:8333\n-bs4bq6s6qkvt5hpi.onion:8333\n bup5n5e3kurvjzf3.onion:8333\n-c2tpqkaz4ihjzwgb.onion:8333\n-cernrmrk5zomzozn.onion:8333\n-cfyegj64ht3jpodr.onion:8333\n-cg5vg54cazzpvoug.onion:8333\n-cgk4u2lxrvml4jvb.onion:8333\n cjygd7pu5lqkky5j.onion:8333\n-d6wubsdtr46dd5ki.onion:8333\n-dfq6yjc3aelplwr4.onion:8333\n+cyvpgt25274i5b7c.onion:8333\n+dekj4wacywpqsad3.onion:8333\n dqpxwlpnv3z3hznl.onion:8333\n-eamfospuveabaimd.onion:8333\n-ep2mjzox3kvb6ax4.onion:8333\n-fpbxb4wjudiw2w5a.onion:8333\n-fu5hfsbbf5jwsvhv.onion:8333\n-g4freoibsczujle3.onion:8333\n+drarzpycbtxwbcld.onion:8333\n+drp4pvejybx2ejdr.onion:8333\n+dxkmtmwiq7ddtgul.onion:8333\n+e6j57zkyibu2smad.onion:8333\n+ejcqevujcqltqn7d.onion:8333\n+eqgbt2ghfvsshbvo.onion:8333\n+fgizgkdnndilo6ka.onion:8333\n+fqxup4oev33eeidg.onion:8333\n gb5ypqt63du3wfhn.onion:8333\n ggdy2pb2avlbtjwq.onion:8333\n-gh2aiddzxmvyrnue.onion:8333\n-gnxgylbgzvaazkq7.onion:8333\n-hnizdxnejel64ubk.onion:8333\n-htvdcmlc3abji2ab.onion:8443\n-hwuboois4gslupgx.onion:8333\n-hxz6gowludlj6d5a.onion:8333\n-j6umo4bnsztpsonc.onion:8333\n-jdunmaocwbbnw565.onion:8333\n-ktv3qlxl7xvmdlf4.onion:8333\n+hahhloezyfqh3hci.onion:8333\n+ihdv6bzz2gx72fs7.onion:8333\n+in7r5ieo7ogkxbne.onion:8333\n kvd44sw7skb5folw.onion:8333\n-kwimnzm6vd4zakvl.onion:8333\n-la5xhk3lprxzxmz2.onion:8333\n-lc7cx67end26uutp.onion:8352\n-mwu5og2agcspmgkx.onion:8333\n-mzxkipiyekaoh7my.onion:8333\n-n6rwlrtwpqc7qwo7.onion:8333\n-nj36424yccqph62z.onion:8333\n-o256w7t3vcgktmxk.onion:8333\n+mn744hbioayn3ojs.onion:8333\n+ms4ntrrisfxzpvmy.onion:8333\n+n5lqwpjabqg62ihx.onion:8333\n o4sl5na6jeqgi3l6.onion:8333\n-okdzjarwekbshnof.onion:8333\n-oyebydl2pacx6v26.onion:8333\n-p5mx2imj75dpmime.onion:8333\n+omjv24nbck4k5ud6.onion:8333\n+po3j2hfkmf7sh36o.onion:8333\n psco6bxjewljrczx.onion:8333\n-pxtgswet6tlgrbwj.onion:8333\n-rb4v3fhgx2zr4rre.onion:8333\n+qi5yr6lvlckzffor.onion:8333\n+qlv6py6hdtzipntn.onion:8333\n+qynmpgdbp23xyfnj.onion:8333\n+rhtawcs7xak4gi3t.onion:8333\n+rjacws757ai66lre.onion:8333\n rjlnp3hwvrsmap6e.onion:8333\n+rkdvqcrtfv6yt4oy.onion:8333\n rlafimkctvz63llg.onion:8333\n-rxjvy5eyttep5tts.onion:8333\n+rlj4ppok4dnsdu5n.onion:8333\n seoskudzk6vn6mqz.onion:8333\n-tpgdufxxsw3jkrdf.onion:8333\n-tuiyvqgi3o675pjb.onion:8333\n+tayqi57tfiy7x3vk.onion:8333\n+tchop676j6yppwwm.onion:8333\n+trrtyp3sirmwttyu.onion:8333\n tx4zd7d5exonnblh.onion:8333\n-uokg6avfgbhofls3.onion:8333\n-v3gjphgqy5hygcml.onion:8333\n-vhdoxqq63xr53ol7.onion:8333\n+u4ecb7txxi6l3gix.onion:8333\n+umcxcmfycvejw264.onion:8333\n+v7xqd42ocemalurd.onion:8333\n+vb267mt3lnwfdmdb.onion:8333\n+vev3n5fxfrtqj6e5.onion:8333\n visevrizz3quyagj.onion:8333\n-vqpye2k5rcqvj5mq.onion:8333\n-wfsx2gi7djhy22hk.onion:8333\n-wg6vwmbrzyyzapun.onion:8333\n-xub4w3w4wwk56xiq.onion:8333\n+vpg6p5e5ln33dqtp.onion:8333\n+vr2ruasinafoy3fl.onion:8333\n+x6pthvd5x6abyfo7.onion:8333\n+xbwbzrspvav7u5ie.onion:8333\n+xfcevnql2chnawko.onion:8333\n ycivnom44dmxx4ob.onion:8333\n-ywskufc62bf2fum4.onion:8333\n-z4fax2vxg23t2ddf.onion:8333\n-zo5dklwelmdrpo5n.onion:8333\n+yzdvlv5daitafekn.onion:8333"
      },
      {
        "sha": "3ffe0a2f289556d40fab4f5ed82ddefaab645ea9",
        "filename": "contrib/verifybinaries/README.md",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/verifybinaries/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/verifybinaries/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verifybinaries/README.md?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -26,6 +26,14 @@ The script returns 0 if everything passes the checks. It returns 1 if either the\n ./verify.sh bitcoin-core-0.13.0-rc3\n ```\n \n+If you only want to download the binaries of certain platform, add the corresponding suffix, e.g.:\n+\n+```sh\n+./verify.sh bitcoin-core-0.11.2-osx\n+./verify.sh 0.12.0-linux\n+./verify.sh bitcoin-core-0.13.0-rc3-win64\n+```\n+\n If you do not want to keep the downloaded binaries, specify anything as the second parameter.\n \n ```sh"
      },
      {
        "sha": "409f517c9fb2691549a8ff280461d14d1b2e9dd7",
        "filename": "contrib/verifybinaries/verify.sh",
        "status": "modified",
        "additions": 63,
        "deletions": 11,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/verifybinaries/verify.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/contrib/verifybinaries/verify.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verifybinaries/verify.sh?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -3,7 +3,8 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-###   This script attempts to download the signature file SHA256SUMS.asc from bitcoin.org\n+###   This script attempts to download the signature file SHA256SUMS.asc from\n+###   bitcoincore.org and bitcoin.org and compares them.\n ###   It first checks if the signature passes, and then downloads the files specified in\n ###   the file, and checks if the hashes of these files match those that are specified\n ###   in the signature file.\n@@ -22,7 +23,9 @@ TMPFILE=\"hashes.tmp\"\n \n SIGNATUREFILENAME=\"SHA256SUMS.asc\"\n RCSUBDIR=\"test\"\n-BASEDIR=\"https://bitcoin.org/bin/\"\n+HOST1=\"https://bitcoincore.org\"\n+HOST2=\"https://bitcoin.org\"\n+BASEDIR=\"/bin/\"\n VERSIONPREFIX=\"bitcoin-core-\"\n RCVERSIONSTRING=\"rc\"\n \n@@ -42,13 +45,36 @@ if [ -n \"$1\" ]; then\n       VERSION=\"$VERSIONPREFIX$1\"\n    fi\n \n-   #now let's see if the version string contains \"rc\", and strip it off if it does\n-   #  and simultaneously add RCSUBDIR to BASEDIR, where we will look for SIGNATUREFILENAME\n-   if [[ $VERSION == *\"$RCVERSIONSTRING\"* ]]; then\n-      BASEDIR=\"$BASEDIR${VERSION/%-$RCVERSIONSTRING*}/\"\n-      BASEDIR=\"$BASEDIR$RCSUBDIR.$RCVERSIONSTRING${VERSION: -1}/\"\n+   STRIPPEDLAST=\"${VERSION%-*}\"\n+\n+   #now let's see if the version string contains \"rc\" or a platform name (e.g. \"osx\")\n+   if [[ \"$STRIPPEDLAST-\" == \"$VERSIONPREFIX\" ]]; then\n+      BASEDIR=\"$BASEDIR$VERSION/\"\n    else\n+      # let's examine the last part to see if it's rc and/or platform name\n+      STRIPPEDNEXTTOLAST=\"${STRIPPEDLAST%-*}\"\n+      if [[ \"$STRIPPEDNEXTTOLAST-\" == \"$VERSIONPREFIX\" ]]; then\n+\n+         LASTSUFFIX=\"${VERSION##*-}\"\n+         VERSION=\"$STRIPPEDLAST\"\n+\n+         if [[ $LASTSUFFIX == *\"$RCVERSIONSTRING\"* ]]; then\n+            RCVERSION=\"$LASTSUFFIX\"\n+         else\n+            PLATFORM=\"$LASTSUFFIX\"\n+         fi\n+\n+      else\n+         RCVERSION=\"${STRIPPEDLAST##*-}\"\n+         PLATFORM=\"${VERSION##*-}\"\n+\n+         VERSION=\"$STRIPPEDNEXTTOLAST\"\n+      fi\n+\n       BASEDIR=\"$BASEDIR$VERSION/\"\n+      if [[ $RCVERSION == *\"$RCVERSIONSTRING\"* ]]; then\n+         BASEDIR=\"$BASEDIR$RCSUBDIR.$RCVERSION/\"\n+      fi\n    fi\n \n    SIGNATUREFILE=\"$BASEDIR$SIGNATUREFILENAME\"\n@@ -58,7 +84,7 @@ else\n fi\n \n #first we fetch the file containing the signature\n-WGETOUT=$(wget -N \"$BASEDIR$SIGNATUREFILENAME\" 2>&1)\n+WGETOUT=$(wget -N \"$HOST1$BASEDIR$SIGNATUREFILENAME\" 2>&1)\n \n #and then see if wget completed successfully\n if [ $? -ne 0 ]; then\n@@ -69,6 +95,22 @@ if [ $? -ne 0 ]; then\n    exit 2\n fi\n \n+WGETOUT=$(wget -N -O \"$SIGNATUREFILENAME.2\" \"$HOST2$BASEDIR$SIGNATUREFILENAME\" 2>&1)\n+if [ $? -ne 0 ]; then\n+   echo \"bitcoin.org failed to provide signature file, but bitcoincore.org did?\"\n+   echo \"wget output:\"\n+   echo \"$WGETOUT\"|sed 's/^/\\t/g'\n+   clean_up $SIGNATUREFILENAME\n+   exit 3\n+fi\n+\n+SIGFILEDIFFS=\"$(diff $SIGNATUREFILENAME $SIGNATUREFILENAME.2)\"\n+if [ \"$SIGFILEDIFFS\" != \"\" ]; then\n+   echo \"bitcoin.org and bitcoincore.org signature files were not equal?\"\n+   clean_up $SIGNATUREFILENAME $SIGNATUREFILENAME.2\n+   exit 4\n+fi\n+\n #then we check it\n GPGOUT=$(gpg --yes --decrypt --output \"$TMPFILE\" \"$SIGNATUREFILENAME\" 2>&1)\n \n@@ -88,17 +130,27 @@ if [ $RET -ne 0 ]; then\n \n    echo \"gpg output:\"\n    echo \"$GPGOUT\"|sed 's/^/\\t/g'\n-   clean_up $SIGNATUREFILENAME $TMPFILE\n+   clean_up $SIGNATUREFILENAME $SIGNATUREFILENAME.2 $TMPFILE\n    exit \"$RET\"\n fi\n \n+if [ -n \"$PLATFORM\" ]; then\n+   grep $PLATFORM $TMPFILE > \"$TMPFILE-plat\"\n+   TMPFILESIZE=$(stat -c%s \"$TMPFILE-plat\")\n+   if [ $TMPFILESIZE -eq 0 ]; then\n+      echo \"error: no files matched the platform specified\" && exit 3\n+   fi\n+   mv \"$TMPFILE-plat\" $TMPFILE\n+fi\n+\n #here we extract the filenames from the signature file\n FILES=$(awk '{print $2}' \"$TMPFILE\")\n \n #and download these one by one\n for file in $FILES\n do\n-   wget --quiet -N \"$BASEDIR$file\"\n+   echo \"Downloading $file\"\n+   wget --quiet -N \"$HOST1$BASEDIR$file\"\n done\n \n #check hashes\n@@ -116,7 +168,7 @@ fi\n \n if [ -n \"$2\" ]; then\n    echo \"Clean up the binaries\"\n-   clean_up $FILES $SIGNATUREFILENAME $TMPFILE\n+   clean_up $FILES $SIGNATUREFILENAME $SIGNATUREFILENAME.2 $TMPFILE\n else\n    echo \"Keep the binaries in $WORKINGDIR\"\n    clean_up $TMPFILE"
      },
      {
        "sha": "0ddd348e53edabc9069317ab52d5f99ac429781a",
        "filename": "depends/Makefile",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/Makefile?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -134,6 +134,7 @@ $(host_prefix)/share/config.site : config.site.in $(host_prefix)/.stamp_$(final_\n             -e 's|@CXXFLAGS@|$(strip $(host_CXXFLAGS) $(host_$(release_type)_CXXFLAGS))|' \\\n             -e 's|@CPPFLAGS@|$(strip $(host_CPPFLAGS) $(host_$(release_type)_CPPFLAGS))|' \\\n             -e 's|@LDFLAGS@|$(strip $(host_LDFLAGS) $(host_$(release_type)_LDFLAGS))|' \\\n+            -e 's|@allow_host_packages@|$(ALLOW_HOST_PACKAGES)|' \\\n             -e 's|@no_qt@|$(NO_QT)|' \\\n             -e 's|@no_wallet@|$(NO_WALLET)|' \\\n             -e 's|@no_upnp@|$(NO_UPNP)|' \\"
      },
      {
        "sha": "69ed3e573bb3fa14476b0b539805850159eb23e0",
        "filename": "depends/config.guess",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/config.guess",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/config.guess",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/config.guess?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -2,7 +2,7 @@\n # Attempt to guess a canonical system name.\n #   Copyright 1992-2017 Free Software Foundation, Inc.\n \n-timestamp='2017-01-01'\n+timestamp='2017-03-05'\n \n # This file is free software; you can redistribute it and/or modify it\n # under the terms of the GNU General Public License as published by\n@@ -837,10 +837,11 @@ EOF\n \tUNAME_PROCESSOR=`/usr/bin/uname -p`\n \tcase ${UNAME_PROCESSOR} in\n \t    amd64)\n-\t\techo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;\n-\t    *)\n-\t\techo ${UNAME_PROCESSOR}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;\n+\t\tUNAME_PROCESSOR=x86_64 ;;\n+\t    i386)\n+\t\tUNAME_PROCESSOR=i586 ;;\n \tesac\n+\techo ${UNAME_PROCESSOR}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`\n \texit ;;\n     i*:CYGWIN*:*)\n \techo ${UNAME_MACHINE}-pc-cygwin\n@@ -1343,6 +1344,9 @@ EOF\n     NSR-?:NONSTOP_KERNEL:*:*)\n \techo nsr-tandem-nsk${UNAME_RELEASE}\n \texit ;;\n+    NSX-?:NONSTOP_KERNEL:*:*)\n+\techo nsx-tandem-nsk${UNAME_RELEASE}\n+\texit ;;\n     *:NonStop-UX:*:*)\n \techo mips-compaq-nonstopux\n \texit ;;"
      },
      {
        "sha": "0a4a9c327e2e73e55d226c4cdc8a543bcf0da1f5",
        "filename": "depends/config.site.in",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/config.site.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/config.site.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/config.site.in?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -13,10 +13,10 @@ fi\n if test -z $with_qt_translationdir; then\n   with_qt_translationdir=$depends_prefix/translations\n fi\n-if test -z $with_qt_bindir; then\n+if test -z $with_qt_bindir && test -z \"@no_qt@\"; then\n   with_qt_bindir=$depends_prefix/native/bin\n fi\n-if test -z $with_protoc_bindir; then\n+if test -z $with_protoc_bindir && test -z \"@no_qt@\"; then\n   with_protoc_bindir=$depends_prefix/native/bin\n fi\n \n@@ -53,9 +53,10 @@ PKG_CONFIG=\"`which pkg-config` --static\"\n # These two need to remain exported because pkg-config does not see them\n # otherwise. That means they must be unexported at the end of configure.ac to\n # avoid ruining the cache. Sigh.\n-\n-export PKG_CONFIG_LIBDIR=$depends_prefix/lib/pkgconfig\n-export PKG_CONFIG_PATH=$depends_prefix/share/pkgconfig\n+export PKG_CONFIG_PATH=$depends_prefix/share/pkgconfig:$depends_prefix/lib/pkgconfig\n+if test -z \"@allow_host_packages@\"; then\n+  export PKGCONFIG_LIBDIR=\n+fi\n \n CPPFLAGS=\"-I$depends_prefix/include/ $CPPFLAGS\"\n LDFLAGS=\"-L$depends_prefix/lib $LDFLAGS\""
      },
      {
        "sha": "40ea5dfe1152f0fc5160879bb71bfe1fae2595f6",
        "filename": "depends/config.sub",
        "status": "modified",
        "additions": 11,
        "deletions": 3,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/config.sub",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/config.sub",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/config.sub?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -2,7 +2,7 @@\n # Configuration validation subroutine script.\n #   Copyright 1992-2017 Free Software Foundation, Inc.\n \n-timestamp='2017-01-01'\n+timestamp='2017-04-02'\n \n # This file is free software; you can redistribute it and/or modify it\n # under the terms of the GNU General Public License as published by\n@@ -263,7 +263,7 @@ case $basic_machine in\n \t| fido | fr30 | frv | ft32 \\\n \t| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \\\n \t| hexagon \\\n-\t| i370 | i860 | i960 | ia64 \\\n+\t| i370 | i860 | i960 | ia16 | ia64 \\\n \t| ip2k | iq2000 \\\n \t| k1om \\\n \t| le32 | le64 \\\n@@ -315,6 +315,7 @@ case $basic_machine in\n \t| ubicom32 \\\n \t| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \\\n \t| visium \\\n+\t| wasm32 \\\n \t| we32k \\\n \t| x86 | xc16x | xstormy16 | xtensa \\\n \t| z8k | z80)\n@@ -388,7 +389,7 @@ case $basic_machine in\n \t| h8300-* | h8500-* \\\n \t| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \\\n \t| hexagon-* \\\n-\t| i*86-* | i860-* | i960-* | ia64-* \\\n+\t| i*86-* | i860-* | i960-* | ia16-* | ia64-* \\\n \t| ip2k-* | iq2000-* \\\n \t| k1om-* \\\n \t| le32-* | le64-* \\\n@@ -446,6 +447,7 @@ case $basic_machine in\n \t| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \\\n \t| vax-* \\\n \t| visium-* \\\n+\t| wasm32-* \\\n \t| we32k-* \\\n \t| x86-* | x86_64-* | xc16x-* | xps100-* \\\n \t| xstormy16-* | xtensa*-* \\\n@@ -948,6 +950,9 @@ case $basic_machine in\n \tnsr-tandem)\n \t\tbasic_machine=nsr-tandem\n \t\t;;\n+\tnsx-tandem)\n+\t\tbasic_machine=nsx-tandem\n+\t\t;;\n \top50n-* | op60c-*)\n \t\tbasic_machine=hppa1.1-oki\n \t\tos=-proelf\n@@ -1243,6 +1248,9 @@ case $basic_machine in\n \t\tbasic_machine=a29k-wrs\n \t\tos=-vxworks\n \t\t;;\n+\twasm32)\n+\t\tbasic_machine=wasm32-unknown\n+\t\t;;\n \tw65*)\n \t\tbasic_machine=w65-wdc\n \t\tos=-none"
      },
      {
        "sha": "bf773ccd147d43228815200029dbddd9920fa09d",
        "filename": "depends/packages/boost.mk",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/packages/boost.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/packages/boost.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/boost.mk?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -1,8 +1,8 @@\n package=boost\n-$(package)_version=1_63_0\n-$(package)_download_path=https://sourceforge.net/projects/boost/files/boost/1.63.0\n+$(package)_version=1_64_0\n+$(package)_download_path=https://dl.bintray.com/boostorg/release/1.64.0/source/\n $(package)_file_name=$(package)_$($(package)_version).tar.bz2\n-$(package)_sha256_hash=beae2529f759f6b3bf3f4969a19c2e9d6f0c503edcb2de4a61d1428519fcb3b0\n+$(package)_sha256_hash=7bcc5caace97baa948931d712ea5f37038dbb1c5d89b43ad4def4ed7cb683332\n \n define $(package)_set_vars\n $(package)_config_opts_release=variant=release"
      },
      {
        "sha": "bbe03754099f53b6fe404876af8cbc68722fc216",
        "filename": "depends/packages/dbus.mk",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/packages/dbus.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/packages/dbus.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/dbus.mk?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -1,8 +1,8 @@\n package=dbus\n-$(package)_version=1.10.14\n-$(package)_download_path=http://dbus.freedesktop.org/releases/dbus\n+$(package)_version=1.10.18\n+$(package)_download_path=https://dbus.freedesktop.org/releases/dbus\n $(package)_file_name=$(package)-$($(package)_version).tar.gz\n-$(package)_sha256_hash=23238f70353e38ce5ca183ebc9525c0d97ac00ef640ad29cf794782af6e6a083\n+$(package)_sha256_hash=6049ddd5f3f3e2618f615f1faeda0a115104423a7996b7aa73e2f36e38cc514a\n $(package)_dependencies=expat\n \n define $(package)_set_vars"
      },
      {
        "sha": "7f484724a49097b4ed403f16141ad1f2f2ec7b92",
        "filename": "depends/packages/expat.mk",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/packages/expat.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/packages/expat.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/expat.mk?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -1,8 +1,8 @@\n package=expat\n-$(package)_version=2.2.0\n+$(package)_version=2.2.1\n $(package)_download_path=https://downloads.sourceforge.net/project/expat/expat/$($(package)_version)\n $(package)_file_name=$(package)-$($(package)_version).tar.bz2\n-$(package)_sha256_hash=d9e50ff2d19b3538bd2127902a89987474e1a4db8e43a66a4d1a712ab9a504ff\n+$(package)_sha256_hash=1868cadae4c82a018e361e2b2091de103cd820aaacb0d6cfa49bd2cd83978885\n \n define $(package)_set_vars\n $(package)_config_opts=--disable-static"
      },
      {
        "sha": "12695db4b9f781c9ce8aa9a62dab0ae36a0a1ce4",
        "filename": "depends/packages/fontconfig.mk",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/packages/fontconfig.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/packages/fontconfig.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/fontconfig.mk?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -13,7 +13,13 @@ define $(package)_config_cmds\n   $($(package)_autoconf)\n endef\n \n+# 2.12.1 uses CHAR_WIDTH which is reserved and clashes with some glibc versions, but newer versions of fontconfig\n+# have broken makefiles which needlessly attempt to re-generate headers with gperf.\n+# Instead, change all uses of CHAR_WIDTH, and disable the rule that forces header re-generation.\n+# This can be removed once the upstream build is fixed.\n define $(package)_build_cmds\n+  sed -i 's/CHAR_WIDTH/CHARWIDTH/g' fontconfig/fontconfig.h src/fcobjshash.gperf src/fcobjs.h src/fcobjshash.h && \\\n+  sed -i 's/fcobjshash.h: fcobjshash.gperf/fcobjshash.h:/' src/Makefile && \\\n   $(MAKE)\n endef\n "
      },
      {
        "sha": "00231d75d5f2f297b798b652c2e85ca865fc2e02",
        "filename": "depends/packages/libevent.mk",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/packages/libevent.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/packages/libevent.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/libevent.mk?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -1,8 +1,8 @@\n package=libevent\n-$(package)_version=2.1.7\n+$(package)_version=2.1.8-stable\n $(package)_download_path=https://github.com/libevent/libevent/archive/\n-$(package)_file_name=release-$($(package)_version)-rc.tar.gz\n-$(package)_sha256_hash=548362d202e22fe24d4c3fad38287b4f6d683e6c21503341373b89785fa6f991\n+$(package)_file_name=release-$($(package)_version).tar.gz\n+$(package)_sha256_hash=316ddb401745ac5d222d7c529ef1eada12f58f6376a66c1118eee803cb70f83d\n \n define $(package)_preprocess_cmds\n   ./autogen.sh"
      },
      {
        "sha": "1bb8cb5d2664746b943756a9efa0db8d8a9d385d",
        "filename": "depends/packages/miniupnpc.mk",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/packages/miniupnpc.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/packages/miniupnpc.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/miniupnpc.mk?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -1,8 +1,8 @@\n package=miniupnpc\n-$(package)_version=2.0\n+$(package)_version=2.0.20170509\n $(package)_download_path=http://miniupnp.free.fr/files\n $(package)_file_name=$(package)-$($(package)_version).tar.gz\n-$(package)_sha256_hash=d434ceb8986efbe199c5ca53f90ed53eab290b1e6d0530b717eb6fa49d61f93b\n+$(package)_sha256_hash=d3c368627f5cdfb66d3ebd64ca39ba54d6ff14a61966dbecb8dd296b7039f16a\n \n define $(package)_set_vars\n $(package)_build_opts=CC=\"$($(package)_cc)\""
      },
      {
        "sha": "966804ce8bbf677fae5446219420532b86fdb800",
        "filename": "depends/packages/native_ccache.mk",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/packages/native_ccache.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/depends/packages/native_ccache.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/native_ccache.mk?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -1,8 +1,8 @@\n package=native_ccache\n-$(package)_version=3.3.3\n+$(package)_version=3.3.4\n $(package)_download_path=https://samba.org/ftp/ccache\n $(package)_file_name=ccache-$($(package)_version).tar.bz2\n-$(package)_sha256_hash=2985bc5e32ebe38d2958d508eb54ddcad39eed909489c0c2988035214597ca54\n+$(package)_sha256_hash=fa9d7f38367431bc86b19ad107d709ca7ecf1574fdacca01698bdf0a47cd8567\n \n define $(package)_set_vars\n $(package)_config_opts="
      },
      {
        "sha": "caf6782886520aa050869489f237a8323b250475",
        "filename": "doc/REST-interface.md",
        "status": "modified",
        "additions": 16,
        "deletions": 12,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/doc/REST-interface.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/doc/REST-interface.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/REST-interface.md?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -40,11 +40,13 @@ Only supports JSON as output format.\n * headers : (numeric) the current number of headers we have validated\n * bestblockhash : (string) the hash of the currently best block\n * difficulty : (numeric) the current difficulty\n+* mediantime : (numeric) the median time of the 11 blocks before the most recent block on the blockchain\n * verificationprogress : (numeric) estimate of verification progress [0..1]\n * chainwork : (string) total amount of work in active chain, in hexadecimal\n * pruned : (boolean) if the blocks are subject to pruning\n * pruneheight : (numeric) heighest block available\n * softforks : (array) status of softforks in progress\n+* bip9_softforks : (object) status of BIP9 softforks in progress\n \n ####Query UTXO set\n `GET /rest/getutxos/<checkmempool>/<txid>-<n>/<txid>-<n>/.../<txid>-<n>.<bin|hex|json>`\n@@ -57,25 +59,25 @@ Example:\n ```\n $ curl localhost:18332/rest/getutxos/checkmempool/b2cdfd7b89def827ff8af7cd9bff7627ff72e5e8b0f71210f92ea7a4000c5d75-0.json 2>/dev/null | json_pp\n {\n-   \"chaintipHash\" : \"00000000fb01a7f3745a717f8caebee056c484e6e0bfe4a9591c235bb70506fb\",\n    \"chainHeight\" : 325347,\n+   \"chaintipHash\" : \"00000000fb01a7f3745a717f8caebee056c484e6e0bfe4a9591c235bb70506fb\",\n+   \"bitmap\": \"1\",\n    \"utxos\" : [\n       {\n+         \"txvers\" : 1\n+         \"height\" : 2147483647,\n+         \"value\" : 8.8687,\t\t \n          \"scriptPubKey\" : {\n-            \"addresses\" : [\n-               \"mi7as51dvLJsizWnTMurtRmrP8hG2m1XvD\"\n-            ],\n-            \"type\" : \"pubkeyhash\",\n+            \"asm\" : \"OP_DUP OP_HASH160 1c7cebb529b86a04c683dfa87be49de35bcf589e OP_EQUALVERIFY OP_CHECKSIG\",\n             \"hex\" : \"76a9141c7cebb529b86a04c683dfa87be49de35bcf589e88ac\",\n             \"reqSigs\" : 1,\n-            \"asm\" : \"OP_DUP OP_HASH160 1c7cebb529b86a04c683dfa87be49de35bcf589e OP_EQUALVERIFY OP_CHECKSIG\"\n-         },\n-         \"value\" : 8.8687,\n-         \"height\" : 2147483647,\n-         \"txvers\" : 1\n+            \"type\" : \"pubkeyhash\",\n+            \"addresses\" : [\n+               \"mi7as51dvLJsizWnTMurtRmrP8hG2m1XvD\"\n+            ]\n+         }\n       }\n-   ],\n-   \"bitmap\" : \"1\"\n+   ]\n }\n ```\n \n@@ -87,6 +89,8 @@ Only supports JSON as output format.\n * size : (numeric) the number of transactions in the TX mempool\n * bytes : (numeric) size of the TX mempool in bytes\n * usage : (numeric) total TX mempool memory usage\n+* maxmempool : (numeric) maximum memory usage for the mempool in bytes\n+* mempoolminfee : (numeric) minimum feerate (BTC per KB) for tx to be accepted\n \n `GET /rest/mempool/contents.json`\n "
      },
      {
        "sha": "32d7dbd69e7d694f4b27c151343c815c1708eed9",
        "filename": "doc/build-osx.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/doc/build-osx.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/doc/build-osx.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-osx.md?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -11,14 +11,14 @@ Install the OS X command line tools:\n \n When the popup appears, click `Install`.\n \n-Then install [Homebrew](http://brew.sh).\n+Then install [Homebrew](https://brew.sh).\n \n Dependencies\n ----------------------\n \n-    brew install automake berkeley-db4 libtool boost --c++11 miniupnpc openssl pkg-config protobuf --c++11 qt5 libevent\n+    brew install automake berkeley-db4 libtool boost --c++11 miniupnpc openssl pkg-config protobuf qt libevent\n \n-In case you want to build the disk image with `make deploy` (.dmg / optional), you need RSVG\n+If you want to build the disk image with `make deploy` (.dmg / optional), you need RSVG\n \n     brew install librsvg\n "
      },
      {
        "sha": "b7eae2a630ad1acca937121b4def7e382256f283",
        "filename": "doc/build-unix.md",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/doc/build-unix.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/doc/build-unix.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-unix.md?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -321,8 +321,10 @@ Clang is installed by default as `cc` compiler, this makes it easier to get\n started than on [OpenBSD](build-openbsd.md). Installing dependencies:\n \n     pkg install autoconf automake libtool pkgconf\n-    pkg install boost-libs openssl libevent2\n+    pkg install boost-libs openssl libevent\n+    pkg install gmake\n \n+You need to use GNU make (`gmake`) instead of `make`.\n (`libressl` instead of `openssl` will also work)\n \n For the wallet (optional):\n@@ -338,7 +340,7 @@ Then build using:\n \n     ./autogen.sh\n     ./configure --with-incompatible-bdb BDB_CFLAGS=\"-I/usr/local/include/db5\" BDB_LIBS=\"-L/usr/local/lib -ldb_cxx-5\"\n-    make\n+    gmake\n \n *Note on debugging*: The version of `gdb` installed by default is [ancient and considered harmful](https://wiki.freebsd.org/GdbRetirement).\n It is not suitable for debugging a multi-threaded C++ program, not even for getting backtraces. Please install the package `gdb` and"
      },
      {
        "sha": "d783a7a8ae3297b4b4e0af8e13b73b7c2c6682e0",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 135,
        "deletions": 17,
        "changes": 152,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -3,49 +3,72 @@ Developer Notes\n \n Various coding styles have been used during the history of the codebase,\n and the result is not very consistent. However, we're now trying to converge to\n-a single style, so please use it in new code. Old code will be converted\n-gradually and you are encouraged to use the provided\n-[clang-format-diff script](/contrib/devtools/README.md#clang-format-diffpy)\n-to clean up the patch automatically before submitting a pull request.\n+a single style, which is specified below. When writing patches, favor the new\n+style over attempting to mimick the surrounding style, except for move-only\n+commits.\n+\n+Do not submit patches solely to modify the style of existing code.\n \n-- Basic rules specified in [src/.clang-format](/src/.clang-format).\n+- **Indentation and whitespace rules** as specified in\n+[src/.clang-format](/src/.clang-format). You can use the provided\n+[clang-format-diff script](/contrib/devtools/README.md#clang-format-diffpy)\n+tool to clean up patches automatically before submission.\n   - Braces on new lines for namespaces, classes, functions, methods.\n   - Braces on the same line for everything else.\n   - 4 space indentation (no tabs) for every block except namespaces.\n   - No indentation for `public`/`protected`/`private` or for `namespace`.\n   - No extra spaces inside parenthesis; don't do ( this )\n   - No space after function names; one space after `if`, `for` and `while`.\n-  - If an `if` only has a single-statement then-clause, it can appear\n-    on the same line as the if, without braces. In every other case,\n-    braces are required, and the then and else clauses must appear\n+  - If an `if` only has a single-statement `then`-clause, it can appear\n+    on the same line as the `if`, without braces. In every other case,\n+    braces are required, and the `then` and `else` clauses must appear\n     correctly indented on a new line.\n+\n+- **Symbol naming conventions**. These are preferred in new code, but are not\n+required when doing so would need changes to significant pieces of existing\n+code.\n+  - Variable and namespace names are all lowercase, and may use `_` to\n+    separate words (snake_case).\n+    - Class member variables have a `m_` prefix.\n+    - Global variables have a `g_` prefix.\n+  - Constant names are all uppercase, and use `_` to separate words.\n+  - Class names, function names and method names are UpperCamelCase\n+    (PascalCase). Do not prefix class names with `C`.\n+\n+- **Miscellaneous**\n   - `++i` is preferred over `i++`.\n \n Block style example:\n ```c++\n+int g_count = 0;\n+\n namespace foo\n {\n class Class\n {\n+    std::string m_name;\n+\n+public:\n     bool Function(const std::string& s, int n)\n     {\n         // Comment summarising what this section of code does\n         for (int i = 0; i < n; ++i) {\n+            int total_sum = 0;\n             // When something fails, return early\n             if (!Something()) return false;\n             ...\n-            if (SomethingElse()) {\n-                DoMore();\n+            if (SomethingElse(i)) {\n+                total_sum += ComputeSomething(g_count);\n             } else {\n-                DoLess();\n+                DoSomething(m_name, total_sum);\n             }\n         }\n \n         // Success return is usually at the end\n         return true;\n     }\n }\n-}\n+} // namespace foo\n ```\n \n Doxygen comments\n@@ -264,7 +287,7 @@ General C++\n \n - Assertions should not have side-effects\n \n-  - *Rationale*: Even though the source code is set to to refuse to compile\n+  - *Rationale*: Even though the source code is set to refuse to compile\n     with assertions disabled, having side-effects in assertions is unexpected and\n     makes the code harder to understand\n \n@@ -343,10 +366,9 @@ Strings and formatting\n Variable names\n --------------\n \n-The shadowing warning (`-Wshadow`) is enabled by default. It prevents issues rising\n-from using a different variable with the same name.\n-\n-Please name variables so that their names do not shadow variables defined in the source code.\n+Although the shadowing warning (`-Wshadow`) is not enabled by default (it prevents issues rising\n+from using a different variable with the same name),\n+please name variables so that their names do not shadow variables defined in the source code.\n \n E.g. in member initializers, prepend `_` to the argument name shadowing the\n member name:\n@@ -403,11 +425,34 @@ Source code organization\n \n   - *Rationale*: Shorter and simpler header files are easier to read, and reduce compile time\n \n+- Every `.cpp` and `.h` file should `#include` every header file it directly uses classes, functions or other\n+  definitions from, even if those headers are already included indirectly through other headers. One exception\n+  is that a `.cpp` file does not need to re-include the includes already included in its corresponding `.h` file.\n+\n+  - *Rationale*: Excluding headers because they are already indirectly included results in compilation\n+    failures when those indirect dependencies change. Furthermore, it obscures what the real code\n+    dependencies are.\n+\n - Don't import anything into the global namespace (`using namespace ...`). Use\n   fully specified types such as `std::string`.\n \n   - *Rationale*: Avoids symbol conflicts\n \n+- Terminate namespaces with a comment (`// namespace mynamespace`). The comment\n+  should be placed on the same line as the brace closing the namespace, e.g.\n+\n+```c++\n+namespace mynamespace {\n+    ...\n+} // namespace mynamespace\n+\n+namespace {\n+    ...\n+} // namespace\n+```\n+\n+  - *Rationale*: Avoids confusion about the namespace context\n+\n GUI\n -----\n \n@@ -495,3 +540,76 @@ Git and GitHub tips\n   This will add an `upstream-pull` remote to your git repository, which can be fetched using `git fetch --all`\n   or `git fetch upstream-pull`. Afterwards, you can use `upstream-pull/NUMBER/head` in arguments to `git show`,\n   `git checkout` and anywhere a commit id would be acceptable to see the changes from pull request NUMBER.\n+\n+RPC interface guidelines\n+--------------------------\n+\n+A few guidelines for introducing and reviewing new RPC interfaces:\n+\n+- Method naming: use consecutive lower-case names such as `getrawtransaction` and `submitblock`\n+\n+  - *Rationale*: Consistency with existing interface.\n+\n+- Argument naming: use snake case `fee_delta` (and not, e.g. camel case `feeDelta`)\n+\n+  - *Rationale*: Consistency with existing interface.\n+\n+- Use the JSON parser for parsing, don't manually parse integers or strings from\n+  arguments unless absolutely necessary.\n+\n+  - *Rationale*: Introduces hand-rolled string manipulation code at both the caller and callee sites,\n+    which is error prone, and it is easy to get things such as escaping wrong.\n+    JSON already supports nested data structures, no need to re-invent the wheel.\n+\n+  - *Exception*: AmountFromValue can parse amounts as string. This was introduced because many JSON\n+    parsers and formatters hard-code handling decimal numbers as floating point\n+    values, resulting in potential loss of precision. This is unacceptable for\n+    monetary values. **Always** use `AmountFromValue` and `ValueFromAmount` when\n+    inputting or outputting monetary values. The only exceptions to this are\n+    `prioritisetransaction` and `getblocktemplate` because their interface\n+    is specified as-is in BIP22.\n+\n+- Missing arguments and 'null' should be treated the same: as default values. If there is no\n+  default value, both cases should fail in the same way.\n+\n+  - *Rationale*: Avoids surprises when switching to name-based arguments. Missing name-based arguments\n+  are passed as 'null'.\n+\n+  - *Exception*: Many legacy exceptions to this exist, one of the worst ones is\n+    `getbalance` which follows a completely different code path based on the\n+    number of arguments. We are still in the process of cleaning these up. Do not introduce\n+    new ones.\n+\n+- Try not to overload methods on argument type. E.g. don't make `getblock(true)` and `getblock(\"hash\")`\n+  do different things.\n+\n+  - *Rationale*: This is impossible to use with `bitcoin-cli`, and can be surprising to users.\n+\n+  - *Exception*: Some RPC calls can take both an `int` and `bool`, most notably when a bool was switched\n+    to a multi-value, or due to other historical reasons. **Always** have false map to 0 and\n+    true to 1 in this case.\n+\n+- Don't forget to fill in the argument names correctly in the RPC command table.\n+\n+  - *Rationale*: If not, the call can not be used with name-based arguments.\n+\n+- Set okSafeMode in the RPC command table to a sensible value: safe mode is when the\n+  blockchain is regarded to be in a confused state, and the client deems it unsafe to\n+  do anything irreversible such as send. Anything that just queries should be permitted.\n+\n+  - *Rationale*: Troubleshooting a node in safe mode is difficult if half the\n+    RPCs don't work.\n+\n+- Add every non-string RPC argument `(method, idx, name)` to the table `vRPCConvertParams` in `rpc/client.cpp`.\n+\n+  - *Rationale*: `bitcoin-cli` and the GUI debug console use this table to determine how to\n+    convert a plaintext command line to JSON. If the types don't match, the method can be unusable\n+    from there.\n+\n+- A RPC method must either be a wallet method or a non-wallet method. Do not\n+  introduce new methods such as `getinfo` and `signrawtransaction` that differ\n+  in behavior based on presence of a wallet.\n+\n+  - *Rationale*: as well as complicating the implementation and interfering\n+    with the introduction of multi-wallet, wallet and non-wallet code should be\n+    separated to avoid introducing circular dependencies between code units."
      },
      {
        "sha": "5dedcb51c895e612c6953b99ca3bb532899cb4aa",
        "filename": "doc/fuzzing.md",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/doc/fuzzing.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/doc/fuzzing.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/fuzzing.md?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -32,6 +32,13 @@ We disable ccache because we don't want to pollute the ccache with instrumented\n objects, and similarly don't want to use non-instrumented cached objects linked\n in.\n \n+The fuzzing can be sped up significantly (~200x) by using `afl-clang-fast` and\n+`afl-clang-fast++` in place of `afl-gcc` and `afl-g++` when compiling. When\n+compiling using `afl-clang-fast`/`afl-clang-fast++` the resulting\n+`test_bitcoin_fuzzy` binary will be instrumented in such a way that the AFL\n+features \"persistent mode\" and \"deferred forkserver\" can be used. See\n+https://github.com/mcarpenter/afl/tree/master/llvm_mode for details.\n+\n Preparing fuzzing\n ------------------\n \n@@ -63,4 +70,3 @@ $AFLPATH/afl-fuzz -i ${AFLIN} -o ${AFLOUT} -m52 -- test/test_bitcoin_fuzzy\n \n You may have to change a few kernel parameters to test optimally - `afl-fuzz`\n will print an error and suggestion if so.\n-"
      },
      {
        "sha": "9f9afaf04f444dd1e7a31eec280b13e91fcae3b2",
        "filename": "doc/gitian-building.md",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/doc/gitian-building.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/doc/gitian-building.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/gitian-building.md?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -131,6 +131,7 @@ To select a different button, press `Tab`.\n   - Leave domain name empty.\n \n ![](gitian-building/debian_install_5_configure_the_network.png)\n+![](gitian-building/debian_install_6_domain_name.png)\n \n - Choose a root password and enter it twice (remember it for later)\n "
      },
      {
        "sha": "a13ede2dd584c7950287b50186844db9a269d6ab",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -36,6 +36,21 @@ Notable changes\n Low-level RPC changes\n ---------------------\n \n+- The new database model no longer stores information about transaction\n+  versions of unspent outputs. This means that:\n+  - The `gettxout` RPC no longer has a `version` field in the response.\n+  - The `gettxoutsetinfo` RPC reports `hash_serialized_2` instead of `hash_serialized`,\n+    which does not commit to the transaction versions of unspent outputs, but does\n+    commit to the height and coinbase information.\n+  - The `gettxoutsetinfo` response now contains `disk_size` and `bogosize` instead of\n+    `bytes_serialized`. The first is a more accurate estimate of actual disk usage, but\n+    is not deterministic. The second is unrelated to disk usage, but is a\n+    database-independent metric of UTXO set size: it counts every UTXO entry as 50 + the\n+    length of its scriptPubKey.\n+  - The `getutxos` REST path no longer reports the `txvers` field in JSON format,\n+    and always reports 0 for transaction versions in the binary format\n+\n+\n - Error codes have been updated to be more accurate for the following error cases:\n   - `getblock` now returns RPC_MISC_ERROR if the block can't be found on disk (for\n   example if the block has been pruned). Previously returned RPC_INTERNAL_ERROR."
      },
      {
        "sha": "ef072afd4d7fb94d29007038e587eacb40358a98",
        "filename": "doc/release-notes/release-notes-0.14.1.md",
        "status": "added",
        "additions": 143,
        "deletions": 0,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/doc/release-notes/release-notes-0.14.1.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/doc/release-notes/release-notes-0.14.1.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.14.1.md?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -0,0 +1,143 @@\n+Bitcoin Core version 0.14.1 is now available from:\n+\n+  <https://bitcoin.org/bin/bitcoin-core-0.14.1/>\n+\n+This is a new minor version release, including various bugfixes and\n+performance improvements, as well as updated translations.\n+\n+Please report bugs using the issue tracker at github:\n+\n+  <https://github.com/bitcoin/bitcoin/issues>\n+\n+To receive security and update notifications, please subscribe to:\n+\n+  <https://bitcoincore.org/en/list/announcements/join/>\n+\n+Compatibility\n+==============\n+\n+Bitcoin Core is extensively tested on multiple operating systems using\n+the Linux kernel, macOS 10.8+, and Windows Vista and later.\n+\n+Microsoft ended support for Windows XP on [April 8th, 2014](https://www.microsoft.com/en-us/WindowsForBusiness/end-of-xp-support),\n+No attempt is made to prevent installing or running the software on Windows XP, you\n+can still do so at your own risk but be aware that there are known instabilities and issues.\n+Please do not report issues about Windows XP to the issue tracker.\n+\n+Bitcoin Core should also work on most other Unix-like systems but is not\n+frequently tested on them.\n+\n+Notable changes\n+===============\n+\n+RPC changes\n+-----------\n+\n+- The first positional argument of `createrawtransaction` was renamed from\n+  `transactions` to `inputs`.\n+\n+- The argument of `disconnectnode` was renamed from `node` to `address`.\n+\n+These interface changes break compatibility with 0.14.0, when the named\n+arguments functionality, introduced in 0.14.0, is used. Client software\n+using these calls with named arguments needs to be updated.\n+\n+Mining\n+------\n+\n+In previous versions, getblocktemplate required segwit support from downstream\n+clients/miners once the feature activated on the network. In this version, it\n+now supports non-segwit clients even after activation, by removing all segwit\n+transactions from the returned block template. This allows non-segwit miners to\n+continue functioning correctly even after segwit has activated.\n+\n+Due to the limitations in previous versions, getblocktemplate also recommended\n+non-segwit clients to not signal for the segwit version-bit. Since this is no\n+longer an issue, getblocktemplate now always recommends signalling segwit for\n+all miners. This is safe because ability to enforce the rule is the only\n+required criteria for safe activation, not actually producing segwit-enabled\n+blocks.\n+\n+UTXO memory accounting\n+----------------------\n+\n+Memory usage for the UTXO cache is being calculated more accurately, so that\n+the configured limit (`-dbcache`) will be respected when memory usage peaks\n+during cache flushes.  The memory accounting in prior releases is estimated to\n+only account for half the actual peak utilization.\n+\n+The default `-dbcache` has also been changed in this release to 450MiB.  Users\n+who currently set `-dbcache` to a high value (e.g. to keep the UTXO more fully\n+cached in memory) should consider increasing this setting in order to achieve\n+the same cache performance as prior releases.  Users on low-memory systems\n+(such as systems with 1GB or less) should consider specifying a lower value for\n+this parameter.\n+\n+Additional information relating to running on low-memory systems can be found\n+here:\n+[reducing-bitcoind-memory-usage.md](https://gist.github.com/laanwj/efe29c7661ce9b6620a7).\n+\n+0.14.1 Change log\n+=================\n+\n+Detailed release notes follow. This overview includes changes that affect\n+behavior, not code moves, refactors and string updates. For convenience in locating\n+the code changes and accompanying discussion, both the pull request and\n+git merge commit are mentioned.\n+\n+### RPC and other APIs\n+- #10084 `142fbb2` Rename first named arg of createrawtransaction (MarcoFalke)\n+- #10139 `f15268d` Remove auth cookie on shutdown (practicalswift)\n+- #10146 `2fea10a` Better error handling for submitblock (rawodb, gmaxwell)\n+- #10144 `d947afc` Prioritisetransaction wasn't always updating ancestor fee (sdaftuar)\n+- #10204 `3c79602` Rename disconnectnode argument (jnewbery)\n+\n+### Block and transaction handling\n+- #10126 `0b5e162` Compensate for memory peak at flush time (sipa)\n+- #9912 `fc3d7db` Optimize GetWitnessHash() for non-segwit transactions (sdaftuar)\n+- #10133 `ab864d3` Clean up calculations of pcoinsTip memory usage (morcos)\n+\n+### P2P protocol and network code\n+- #9953/#10013 `d2548a4` Fix shutdown hang with >= 8 -addnodes set (TheBlueMatt)\n+- #10176 `30fa231` net: gracefully handle NodeId wrapping (theuni)\n+\n+### Build system\n+- #9973 `e9611d1` depends: fix zlib build on osx (theuni)\n+\n+### GUI\n+- #10060 `ddc2dd1` Ensure an item exists on the rpcconsole stack before adding (achow101)\n+\n+### Mining\n+- #9955/#10006 `569596c` Don't require segwit in getblocktemplate for segwit signalling or mining (sdaftuar)\n+- #9959/#10127 `b5c3440` Prevent slowdown in CreateNewBlock on large mempools (sdaftuar)\n+\n+### Tests and QA\n+- #10157 `55f641c` Fix the `mempool_packages.py` test (sdaftuar)\n+\n+### Miscellaneous\n+- #10037 `4d8e660` Trivial: Fix typo in help getrawtransaction RPC (keystrike)\n+- #10120 `e4c9a90` util: Work around (virtual) memory exhaustion on 32-bit w/ glibc (laanwj)\n+- #10130 `ecc5232` bitcoin-tx input verification (awemany, jnewbery)\n+\n+Credits\n+=======\n+\n+Thanks to everyone who directly contributed to this release:\n+\n+- Alex Morcos\n+- Andrew Chow\n+- Awemany\n+- Cory Fields\n+- Gregory Maxwell\n+- James Evans\n+- John Newbery\n+- MarcoFalke\n+- Matt Corallo\n+- Pieter Wuille\n+- practicalswift\n+- rawodb\n+- Suhas Daftuar\n+- Wladimir J. van der Laan\n+\n+As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).\n+"
      },
      {
        "sha": "0ad554b7738c17a4017b57234fce1132f9a9ed45",
        "filename": "doc/release-notes/release-notes-0.14.2.md",
        "status": "added",
        "additions": 102,
        "deletions": 0,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/doc/release-notes/release-notes-0.14.2.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/doc/release-notes/release-notes-0.14.2.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.14.2.md?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -0,0 +1,102 @@\n+Bitcoin Core version 0.14.2 is now available from:\n+\n+  <https://bitcoin.org/bin/bitcoin-core-0.14.2/>\n+\n+This is a new minor version release, including various bugfixes and\n+performance improvements, as well as updated translations.\n+\n+Please report bugs using the issue tracker at github:\n+\n+  <https://github.com/bitcoin/bitcoin/issues>\n+\n+To receive security and update notifications, please subscribe to:\n+\n+  <https://bitcoincore.org/en/list/announcements/join/>\n+\n+Compatibility\n+==============\n+\n+Bitcoin Core is extensively tested on multiple operating systems using\n+the Linux kernel, macOS 10.8+, and Windows Vista and later.\n+\n+Microsoft ended support for Windows XP on [April 8th, 2014](https://www.microsoft.com/en-us/WindowsForBusiness/end-of-xp-support),\n+No attempt is made to prevent installing or running the software on Windows XP, you\n+can still do so at your own risk but be aware that there are known instabilities and issues.\n+Please do not report issues about Windows XP to the issue tracker.\n+\n+Bitcoin Core should also work on most other Unix-like systems but is not\n+frequently tested on them.\n+\n+Notable changes\n+===============\n+\n+miniupnp CVE-2017-8798\n+----------------------------\n+\n+Bundled miniupnpc was updated to 2.0.20170509. This fixes an integer signedness error\n+(present in MiniUPnPc v1.4.20101221 through v2.0) that allows remote attackers\n+(within the LAN) to cause a denial of service or possibly have unspecified\n+other impact.\n+\n+This only affects users that have explicitly enabled UPnP through the GUI\n+setting or through the `-upnp` option, as since the last UPnP vulnerability\n+(in Bitcoin Core 0.10.3) it has been disabled by default.\n+\n+If you use this option, it is recommended to upgrade to this version as soon as\n+possible.\n+\n+Known Bugs\n+==========\n+\n+Since 0.14.0 the approximate transaction fee shown in Bitcoin-Qt when using coin\n+control and smart fee estimation does not reflect any change in target from the\n+smart fee slider. It will only present an approximate fee calculated using the\n+default target. The fee calculated using the correct target is still applied to\n+the transaction and shown in the final send confirmation dialog.\n+\n+0.14.2 Change log\n+=================\n+\n+Detailed release notes follow. This overview includes changes that affect\n+behavior, not code moves, refactors and string updates. For convenience in locating\n+the code changes and accompanying discussion, both the pull request and\n+git merge commit are mentioned.\n+\n+### RPC and other APIs\n+- #10410 `321419b` Fix importwallet edge case rescan bug (ryanofsky)\n+\n+### P2P protocol and network code\n+- #10424 `37a8fc5` Populate services in GetLocalAddress (morcos)\n+- #10441 `9e3ad50` Only enforce expected services for half of outgoing connections (theuni)\n+\n+### Build system\n+- #10414 `ffb0c4b` miniupnpc 2.0.20170509 (fanquake)\n+- #10228 `ae479bc` Regenerate bitcoin-config.h as necessary (theuni)\n+\n+### Miscellaneous\n+- #10245 `44a17f2` Minor fix in build documentation for FreeBSD 11 (shigeya)\n+- #10215 `0aee4a1` Check interruptNet during dnsseed lookups (TheBlueMatt)\n+\n+### GUI\n+- #10231 `1e936d7` Reduce a significant cs_main lock freeze (jonasschnelli)\n+\n+### Wallet\n+- #10294 `1847642` Unset change position when there is no change (instagibbs)\n+\n+Credits\n+=======\n+\n+Thanks to everyone who directly contributed to this release:\n+\n+- Alex Morcos\n+- Cory Fields\n+- fanquake\n+- Gregory Sanders\n+- Jonas Schnelli\n+- Matt Corallo\n+- Russell Yanofsky\n+- Shigeya Suzuki\n+- Wladimir J. van der Laan\n+\n+As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).\n+"
      },
      {
        "sha": "32ef2a5755aa4e93d3da541f78f576a846b53db0",
        "filename": "share/genbuild.sh",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/share/genbuild.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/share/genbuild.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/genbuild.sh?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -17,9 +17,13 @@ else\n     exit 1\n fi\n \n+git_check_in_repo() {\n+    ! { git status --porcelain -uall --ignored \"$@\" 2>/dev/null || echo '??'; } | grep -q '?'\n+}\n+\n DESC=\"\"\n SUFFIX=\"\"\n-if [ -e \"$(which git 2>/dev/null)\" -a \"$(git rev-parse --is-inside-work-tree 2>/dev/null)\" = \"true\" ]; then\n+if [ \"${BITCOIN_GENBUILD_NO_GIT}\" != \"1\" -a -e \"$(which git 2>/dev/null)\" -a \"$(git rev-parse --is-inside-work-tree 2>/dev/null)\" = \"true\" ] && git_check_in_repo share/genbuild.sh; then\n     # clean 'dirty' status of touched files that haven't been modified\n     git diff >/dev/null 2>/dev/null \n "
      },
      {
        "sha": "f54e249a0c1e77003e93d9f9a0f1325caa859e42",
        "filename": "share/pixmaps/nsis-header.bmp",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/share/pixmaps/nsis-header.bmp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/share/pixmaps/nsis-header.bmp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/pixmaps/nsis-header.bmp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "14349528853f1198bfdbf7f9f180a5618820ef76",
        "filename": "share/pixmaps/nsis-wizard.bmp",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/share/pixmaps/nsis-wizard.bmp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/share/pixmaps/nsis-wizard.bmp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/pixmaps/nsis-wizard.bmp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "2d2ee67035991568ce34df826feadb88e0e10f74",
        "filename": "src/.clang-format",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/.clang-format",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/.clang-format",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/.clang-format?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -23,7 +23,6 @@ ContinuationIndentWidth: 4\n Cpp11BracedListStyle: true\n DerivePointerAlignment: false\n DisableFormat:   false\n-ForEachMacros:   [ foreach, Q_FOREACH, BOOST_FOREACH, BOOST_REVERSE_FOREACH ]\n IndentCaseLabels: false\n IndentFunctionDeclarationAfterType: false\n IndentWidth:     4\n@@ -47,6 +46,6 @@ SpacesInAngles:  false\n SpacesInContainerLiterals: true\n SpacesInCStyleCastParentheses: false\n SpacesInParentheses: false\n-Standard:        Cpp03\n+Standard:        Cpp11\n TabWidth:        8\n UseTab:          Never"
      },
      {
        "sha": "f7abab482e9e6ef338bee3bc710de3fe5e65a588",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 23,
        "deletions": 3,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -95,6 +95,7 @@ BITCOIN_CORE_H = \\\n   compat/sanity.h \\\n   compressor.h \\\n   consensus/consensus.h \\\n+  consensus/tx_verify.h \\\n   core_io.h \\\n   core_memusage.h \\\n   cuckoocache.h \\\n@@ -116,15 +117,18 @@ BITCOIN_CORE_H = \\\n   netbase.h \\\n   netmessagemaker.h \\\n   noui.h \\\n+  policy/feerate.h \\\n   policy/fees.h \\\n   policy/policy.h \\\n   policy/rbf.h \\\n   pow.h \\\n   protocol.h \\\n   random.h \\\n+  reverse_iterator.h \\\n   reverselock.h \\\n   rpc/blockchain.h \\\n   rpc/client.h \\\n+  rpc/mining.h \\\n   rpc/protocol.h \\\n   rpc/server.h \\\n   rpc/register.h \\\n@@ -178,12 +182,13 @@ libbitcoin_util_a-clientversion.$(OBJEXT): obj/build.h\n libbitcoin_server_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(MINIUPNPC_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)\n libbitcoin_server_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_server_a_SOURCES = \\\n-  addrman.cpp \\\n   addrdb.cpp \\\n+  addrman.cpp \\\n   bloom.cpp \\\n   blockencodings.cpp \\\n   chain.cpp \\\n   checkpoints.cpp \\\n+  consensus/tx_verify.cpp \\\n   httprpc.cpp \\\n   httpserver.cpp \\\n   init.cpp \\\n@@ -195,6 +200,7 @@ libbitcoin_server_a_SOURCES = \\\n   noui.cpp \\\n   policy/fees.cpp \\\n   policy/policy.cpp \\\n+  policy/rbf.cpp \\\n   pow.cpp \\\n   rest.cpp \\\n   rpc/blockchain.cpp \\\n@@ -237,7 +243,6 @@ libbitcoin_wallet_a_SOURCES = \\\n   wallet/rpcwallet.cpp \\\n   wallet/wallet.cpp \\\n   wallet/walletdb.cpp \\\n-  policy/rbf.cpp \\\n   $(BITCOIN_CORE_H)\n \n # crypto primitives library\n@@ -246,6 +251,8 @@ crypto_libbitcoin_crypto_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n crypto_libbitcoin_crypto_a_SOURCES = \\\n   crypto/aes.cpp \\\n   crypto/aes.h \\\n+  crypto/chacha20.h \\\n+  crypto/chacha20.cpp \\\n   crypto/common.h \\\n   crypto/hmac_sha256.cpp \\\n   crypto/hmac_sha256.h \\\n@@ -260,6 +267,10 @@ crypto_libbitcoin_crypto_a_SOURCES = \\\n   crypto/sha512.cpp \\\n   crypto/sha512.h\n \n+if EXPERIMENTAL_ASM\n+crypto_libbitcoin_crypto_a_SOURCES += crypto/sha256_sse4.cpp\n+endif\n+\n # consensus: shared between all executables that validate any consensus rules.\n libbitcoin_consensus_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_consensus_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n@@ -299,7 +310,6 @@ libbitcoin_consensus_a_SOURCES = \\\n libbitcoin_common_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_common_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_common_a_SOURCES = \\\n-  amount.cpp \\\n   base58.cpp \\\n   chainparams.cpp \\\n   coins.cpp \\\n@@ -310,6 +320,7 @@ libbitcoin_common_a_SOURCES = \\\n   keystore.cpp \\\n   netaddress.cpp \\\n   netbase.cpp \\\n+  policy/feerate.cpp \\\n   protocol.cpp \\\n   scheduler.cpp \\\n   script/sign.cpp \\\n@@ -375,6 +386,7 @@ bitcoind_LDADD = \\\n   $(LIBBITCOIN_CONSENSUS) \\\n   $(LIBBITCOIN_CRYPTO) \\\n   $(LIBLEVELDB) \\\n+  $(LIBLEVELDB_SSE42) \\\n   $(LIBMEMENV) \\\n   $(LIBSECP256K1)\n \n@@ -462,6 +474,14 @@ DISTCLEANFILES = obj/build.h\n \n EXTRA_DIST = $(CTAES_DIST)\n \n+\n+config/bitcoin-config.h: config/stamp-h1\n+\t@$(MAKE) -C $(top_builddir) $(subdir)/$(@)\n+config/stamp-h1: $(top_srcdir)/$(subdir)/config/bitcoin-config.h.in $(top_builddir)/config.status\n+\t$(AM_V_at)$(MAKE) -C $(top_builddir) $(subdir)/$(@)\n+$(top_srcdir)/$(subdir)/config/bitcoin-config.h.in:  $(am__configure_deps)\n+\t$(AM_V_at)$(MAKE) -C $(top_srcdir) $(subdir)/config/bitcoin-config.h.in\n+\n clean-local:\n \t-$(MAKE) -C secp256k1 clean\n \t-$(MAKE) -C univalue clean"
      },
      {
        "sha": "2b1f70b25bc4588d26470216dc9c07d0b4b5c676",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -39,6 +39,7 @@ bench_bench_bitcoin_LDADD = \\\n   $(LIBBITCOIN_CONSENSUS) \\\n   $(LIBBITCOIN_CRYPTO) \\\n   $(LIBLEVELDB) \\\n+  $(LIBLEVELDB_SSE42) \\\n   $(LIBMEMENV) \\\n   $(LIBSECP256K1) \\\n   $(LIBUNIVALUE)"
      },
      {
        "sha": "833f3d2a10cac9465c72045bc244e3efc76156c8",
        "filename": "src/Makefile.leveldb.include",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/Makefile.leveldb.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/Makefile.leveldb.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.leveldb.include?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -4,12 +4,15 @@\n \n LIBLEVELDB_INT = leveldb/libleveldb.a\n LIBMEMENV_INT  = leveldb/libmemenv.a\n+LIBLEVELDB_SSE42_INT  = leveldb/libleveldb_sse42.a\n \n EXTRA_LIBRARIES += $(LIBLEVELDB_INT)\n EXTRA_LIBRARIES += $(LIBMEMENV_INT)\n+EXTRA_LIBRARIES += $(LIBLEVELDB_SSE42_INT)\n \n LIBLEVELDB += $(LIBLEVELDB_INT)\n LIBMEMENV += $(LIBMEMENV_INT)\n+LIBLEVELDB_SSE42 = $(LIBLEVELDB_SSE42_INT)\n \n LEVELDB_CPPFLAGS += -I$(srcdir)/leveldb/include\n LEVELDB_CPPFLAGS += -I$(srcdir)/leveldb/helpers/memenv\n@@ -74,6 +77,7 @@ leveldb_libleveldb_a_SOURCES += leveldb/table/merger.h\n leveldb_libleveldb_a_SOURCES += leveldb/table/format.h\n leveldb_libleveldb_a_SOURCES += leveldb/table/iterator_wrapper.h\n leveldb_libleveldb_a_SOURCES += leveldb/util/crc32c.h\n+leveldb_libleveldb_a_SOURCES += leveldb/util/env_posix_test_helper.h\n leveldb_libleveldb_a_SOURCES += leveldb/util/arena.h\n leveldb_libleveldb_a_SOURCES += leveldb/util/random.h\n leveldb_libleveldb_a_SOURCES += leveldb/util/posix_logger.h\n@@ -135,3 +139,11 @@ leveldb_libmemenv_a_CPPFLAGS = $(leveldb_libleveldb_a_CPPFLAGS)\n leveldb_libmemenv_a_CXXFLAGS = $(leveldb_libleveldb_a_CXXFLAGS)\n leveldb_libmemenv_a_SOURCES =  leveldb/helpers/memenv/memenv.cc\n leveldb_libmemenv_a_SOURCES += leveldb/helpers/memenv/memenv.h\n+\n+leveldb_libleveldb_sse42_a_CPPFLAGS = $(leveldb_libleveldb_a_CPPFLAGS)\n+leveldb_libleveldb_sse42_a_CXXFLAGS = $(leveldb_libleveldb_a_CXXFLAGS)\n+if ENABLE_HWCRC32\n+leveldb_libleveldb_sse42_a_CPPFLAGS += -DLEVELDB_PLATFORM_POSIX_SSE\n+leveldb_libleveldb_sse42_a_CXXFLAGS += $(SSE42_CXXFLAGS)\n+endif\n+leveldb_libleveldb_sse42_a_SOURCES =  leveldb/port/port_posix_sse.cc"
      },
      {
        "sha": "e4b64c1ca79c3e6ab98e9c5d3662b9c3f9a315bb",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -407,7 +407,7 @@ endif\n if ENABLE_ZMQ\n qt_bitcoin_qt_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n endif\n-qt_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) $(LIBMEMENV) \\\n+qt_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) \\\n   $(BOOST_LIBS) $(QT_LIBS) $(QT_DBUS_LIBS) $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(LIBSECP256K1) \\\n   $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)\n qt_bitcoin_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)"
      },
      {
        "sha": "02f30bc9527b10ade4e91c36a1da2141539908a6",
        "filename": "src/Makefile.qttest.include",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/Makefile.qttest.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/Makefile.qttest.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qttest.include?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -46,7 +46,8 @@ qt_test_test_bitcoin_qt_SOURCES = \\\n if ENABLE_WALLET\n qt_test_test_bitcoin_qt_SOURCES += \\\n   qt/test/paymentservertests.cpp \\\n-  qt/test/wallettests.cpp\n+  qt/test/wallettests.cpp \\\n+  wallet/test/wallet_test_fixture.cpp\n endif\n \n nodist_qt_test_test_bitcoin_qt_SOURCES = $(TEST_QT_MOC_CPP)\n@@ -59,7 +60,7 @@ if ENABLE_ZMQ\n qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n endif\n qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) \\\n-  $(LIBMEMENV) $(BOOST_LIBS) $(QT_DBUS_LIBS) $(QT_TEST_LIBS) $(QT_LIBS) \\\n+  $(LIBLEVELDB_SSE42) $(LIBMEMENV) $(BOOST_LIBS) $(QT_DBUS_LIBS) $(QT_TEST_LIBS) $(QT_LIBS) \\\n   $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(LIBSECP256K1) \\\n   $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)\n qt_test_test_bitcoin_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)"
      },
      {
        "sha": "6415b3d2e3399fa9971e017e979bd9a84bf8f96c",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -57,8 +57,8 @@ BITCOIN_TESTS =\\\n   test/policyestimator_tests.cpp \\\n   test/pow_tests.cpp \\\n   test/prevector_tests.cpp \\\n-  test/random_tests.cpp \\\n   test/raii_event_tests.cpp \\\n+  test/random_tests.cpp \\\n   test/reverselock_tests.cpp \\\n   test/rpc_tests.cpp \\\n   test/sanity_tests.cpp \\\n@@ -74,10 +74,10 @@ BITCOIN_TESTS =\\\n   test/test_bitcoin.cpp \\\n   test/test_bitcoin.h \\\n   test/test_bitcoin_main.cpp \\\n-  test/test_random.h \\\n   test/testutil.cpp \\\n   test/testutil.h \\\n   test/timedata_tests.cpp \\\n+  test/torcontrol_tests.cpp \\\n   test/transaction_tests.cpp \\\n   test/txvalidationcache_tests.cpp \\\n   test/versionbits_tests.cpp \\\n@@ -96,12 +96,13 @@ endif\n \n test_test_bitcoin_SOURCES = $(BITCOIN_TESTS) $(JSON_TEST_FILES) $(RAW_TEST_FILES)\n test_test_bitcoin_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -I$(builddir)/test/ $(TESTDEFS) $(EVENT_CFLAGS)\n-test_test_bitcoin_LDADD = $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) $(LIBMEMENV) \\\n-  $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB) $(LIBSECP256K1) $(EVENT_LIBS) $(EVENT_PTHREADS_LIBS)\n-test_test_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+test_test_bitcoin_LDADD =\n if ENABLE_WALLET\n test_test_bitcoin_LDADD += $(LIBBITCOIN_WALLET)\n endif\n+test_test_bitcoin_LDADD += $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) \\\n+  $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB) $(LIBSECP256K1) $(EVENT_LIBS) $(EVENT_PTHREADS_LIBS)\n+test_test_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n \n test_test_bitcoin_LDADD += $(LIBBITCOIN_CONSENSUS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS)\n test_test_bitcoin_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) -static\n@@ -147,7 +148,7 @@ bitcoin_test_clean : FORCE\n \n check-local:\n \t@echo \"Running test/util/bitcoin-util-test.py...\"\n-\t$(PYTHON) $(top_builddir)/test/util/bitcoin-util-test.py\n+\t$(top_builddir)/test/util/bitcoin-util-test.py\n \t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C secp256k1 check\n if EMBEDDED_UNIVALUE\n \t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C univalue check"
      },
      {
        "sha": "7f85c16585aa28b471d16c15b689ba23da6391a8",
        "filename": "src/addrdb.cpp",
        "status": "modified",
        "additions": 71,
        "deletions": 143,
        "changes": 214,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/addrdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/addrdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -15,25 +15,31 @@\n #include \"tinyformat.h\"\n #include \"util.h\"\n \n+namespace {\n \n-CBanDB::CBanDB()\n+template <typename Stream, typename Data>\n+bool SerializeDB(Stream& stream, const Data& data)\n {\n-    pathBanlist = GetDataDir() / \"banlist.dat\";\n+    // Write and commit header, data\n+    try {\n+        CHashWriter hasher(SER_DISK, CLIENT_VERSION);\n+        stream << FLATDATA(Params().MessageStart()) << data;\n+        hasher << FLATDATA(Params().MessageStart()) << data;\n+        stream << hasher.GetHash();\n+    } catch (const std::exception& e) {\n+        return error(\"%s: Serialize or I/O error - %s\", __func__, e.what());\n+    }\n+\n+    return true;\n }\n \n-bool CBanDB::Write(const banmap_t& banSet)\n+template <typename Data>\n+bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)\n {\n     // Generate random temporary filename\n     unsigned short randv = 0;\n     GetRandBytes((unsigned char*)&randv, sizeof(randv));\n-    std::string tmpfn = strprintf(\"banlist.dat.%04x\", randv);\n-\n-    // serialize banlist, checksum data up to that point, then append csum\n-    CDataStream ssBanlist(SER_DISK, CLIENT_VERSION);\n-    ssBanlist << FLATDATA(Params().MessageStart());\n-    ssBanlist << banSet;\n-    uint256 hash = Hash(ssBanlist.begin(), ssBanlist.end());\n-    ssBanlist << hash;\n+    std::string tmpfn = strprintf(\"%s.%04x\", prefix, randv);\n \n     // open temp output file, and associate with CAutoFile\n     fs::path pathTmp = GetDataDir() / tmpfn;\n@@ -42,69 +48,41 @@ bool CBanDB::Write(const banmap_t& banSet)\n     if (fileout.IsNull())\n         return error(\"%s: Failed to open file %s\", __func__, pathTmp.string());\n \n-    // Write and commit header, data\n-    try {\n-        fileout << ssBanlist;\n-    }\n-    catch (const std::exception& e) {\n-        return error(\"%s: Serialize or I/O error - %s\", __func__, e.what());\n-    }\n+    // Serialize\n+    if (!SerializeDB(fileout, data)) return false;\n     FileCommit(fileout.Get());\n     fileout.fclose();\n \n-    // replace existing banlist.dat, if any, with new banlist.dat.XXXX\n-    if (!RenameOver(pathTmp, pathBanlist))\n+    // replace existing file, if any, with new file\n+    if (!RenameOver(pathTmp, path))\n         return error(\"%s: Rename-into-place failed\", __func__);\n \n     return true;\n }\n \n-bool CBanDB::Read(banmap_t& banSet)\n+template <typename Stream, typename Data>\n+bool DeserializeDB(Stream& stream, Data& data, bool fCheckSum = true)\n {\n-    // open input file, and associate with CAutoFile\n-    FILE *file = fsbridge::fopen(pathBanlist, \"rb\");\n-    CAutoFile filein(file, SER_DISK, CLIENT_VERSION);\n-    if (filein.IsNull())\n-        return error(\"%s: Failed to open file %s\", __func__, pathBanlist.string());\n-\n-    // use file size to size memory buffer\n-    uint64_t fileSize = fs::file_size(pathBanlist);\n-    uint64_t dataSize = 0;\n-    // Don't try to resize to a negative number if file is small\n-    if (fileSize >= sizeof(uint256))\n-        dataSize = fileSize - sizeof(uint256);\n-    std::vector<unsigned char> vchData;\n-    vchData.resize(dataSize);\n-    uint256 hashIn;\n-\n-    // read data and checksum from file\n-    try {\n-        filein.read((char *)&vchData[0], dataSize);\n-        filein >> hashIn;\n-    }\n-    catch (const std::exception& e) {\n-        return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n-    }\n-    filein.fclose();\n-\n-    CDataStream ssBanlist(vchData, SER_DISK, CLIENT_VERSION);\n-\n-    // verify stored checksum matches input data\n-    uint256 hashTmp = Hash(ssBanlist.begin(), ssBanlist.end());\n-    if (hashIn != hashTmp)\n-        return error(\"%s: Checksum mismatch, data corrupted\", __func__);\n-\n-    unsigned char pchMsgTmp[4];\n     try {\n+        CHashVerifier<Stream> verifier(&stream);\n         // de-serialize file header (network specific magic number) and ..\n-        ssBanlist >> FLATDATA(pchMsgTmp);\n-\n+        unsigned char pchMsgTmp[4];\n+        verifier >> FLATDATA(pchMsgTmp);\n         // ... verify the network matches ours\n         if (memcmp(pchMsgTmp, Params().MessageStart(), sizeof(pchMsgTmp)))\n             return error(\"%s: Invalid network magic number\", __func__);\n \n-        // de-serialize ban data\n-        ssBanlist >> banSet;\n+        // de-serialize data\n+        verifier >> data;\n+\n+        // verify checksum\n+        if (fCheckSum) {\n+            uint256 hashTmp;\n+            stream >> hashTmp;\n+            if (hashTmp != verifier.GetHash()) {\n+                return error(\"%s: Checksum mismatch, data corrupted\", __func__);\n+            }\n+        }\n     }\n     catch (const std::exception& e) {\n         return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n@@ -113,106 +91,56 @@ bool CBanDB::Read(banmap_t& banSet)\n     return true;\n }\n \n-CAddrDB::CAddrDB()\n+template <typename Data>\n+bool DeserializeFileDB(const fs::path& path, Data& data)\n {\n-    pathAddr = GetDataDir() / \"peers.dat\";\n+    // open input file, and associate with CAutoFile\n+    FILE *file = fsbridge::fopen(path, \"rb\");\n+    CAutoFile filein(file, SER_DISK, CLIENT_VERSION);\n+    if (filein.IsNull())\n+        return error(\"%s: Failed to open file %s\", __func__, path.string());\n+\n+    return DeserializeDB(filein, data);\n }\n \n-bool CAddrDB::Write(const CAddrMan& addr)\n-{\n-    // Generate random temporary filename\n-    unsigned short randv = 0;\n-    GetRandBytes((unsigned char*)&randv, sizeof(randv));\n-    std::string tmpfn = strprintf(\"peers.dat.%04x\", randv);\n+}\n \n-    // serialize addresses, checksum data up to that point, then append csum\n-    CDataStream ssPeers(SER_DISK, CLIENT_VERSION);\n-    ssPeers << FLATDATA(Params().MessageStart());\n-    ssPeers << addr;\n-    uint256 hash = Hash(ssPeers.begin(), ssPeers.end());\n-    ssPeers << hash;\n+CBanDB::CBanDB()\n+{\n+    pathBanlist = GetDataDir() / \"banlist.dat\";\n+}\n \n-    // open temp output file, and associate with CAutoFile\n-    fs::path pathTmp = GetDataDir() / tmpfn;\n-    FILE *file = fsbridge::fopen(pathTmp, \"wb\");\n-    CAutoFile fileout(file, SER_DISK, CLIENT_VERSION);\n-    if (fileout.IsNull())\n-        return error(\"%s: Failed to open file %s\", __func__, pathTmp.string());\n+bool CBanDB::Write(const banmap_t& banSet)\n+{\n+    return SerializeFileDB(\"banlist\", pathBanlist, banSet);\n+}\n \n-    // Write and commit header, data\n-    try {\n-        fileout << ssPeers;\n-    }\n-    catch (const std::exception& e) {\n-        return error(\"%s: Serialize or I/O error - %s\", __func__, e.what());\n-    }\n-    FileCommit(fileout.Get());\n-    fileout.fclose();\n+bool CBanDB::Read(banmap_t& banSet)\n+{\n+    return DeserializeFileDB(pathBanlist, banSet);\n+}\n \n-    // replace existing peers.dat, if any, with new peers.dat.XXXX\n-    if (!RenameOver(pathTmp, pathAddr))\n-        return error(\"%s: Rename-into-place failed\", __func__);\n+CAddrDB::CAddrDB()\n+{\n+    pathAddr = GetDataDir() / \"peers.dat\";\n+}\n \n-    return true;\n+bool CAddrDB::Write(const CAddrMan& addr)\n+{\n+    return SerializeFileDB(\"peers\", pathAddr, addr);\n }\n \n bool CAddrDB::Read(CAddrMan& addr)\n {\n-    // open input file, and associate with CAutoFile\n-    FILE *file = fsbridge::fopen(pathAddr, \"rb\");\n-    CAutoFile filein(file, SER_DISK, CLIENT_VERSION);\n-    if (filein.IsNull())\n-        return error(\"%s: Failed to open file %s\", __func__, pathAddr.string());\n-\n-    // use file size to size memory buffer\n-    uint64_t fileSize = fs::file_size(pathAddr);\n-    uint64_t dataSize = 0;\n-    // Don't try to resize to a negative number if file is small\n-    if (fileSize >= sizeof(uint256))\n-        dataSize = fileSize - sizeof(uint256);\n-    std::vector<unsigned char> vchData;\n-    vchData.resize(dataSize);\n-    uint256 hashIn;\n-\n-    // read data and checksum from file\n-    try {\n-        filein.read((char *)&vchData[0], dataSize);\n-        filein >> hashIn;\n-    }\n-    catch (const std::exception& e) {\n-        return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n-    }\n-    filein.fclose();\n-\n-    CDataStream ssPeers(vchData, SER_DISK, CLIENT_VERSION);\n-\n-    // verify stored checksum matches input data\n-    uint256 hashTmp = Hash(ssPeers.begin(), ssPeers.end());\n-    if (hashIn != hashTmp)\n-        return error(\"%s: Checksum mismatch, data corrupted\", __func__);\n-\n-    return Read(addr, ssPeers);\n+    return DeserializeFileDB(pathAddr, addr);\n }\n \n bool CAddrDB::Read(CAddrMan& addr, CDataStream& ssPeers)\n {\n-    unsigned char pchMsgTmp[4];\n-    try {\n-        // de-serialize file header (network specific magic number) and ..\n-        ssPeers >> FLATDATA(pchMsgTmp);\n-\n-        // ... verify the network matches ours\n-        if (memcmp(pchMsgTmp, Params().MessageStart(), sizeof(pchMsgTmp)))\n-            return error(\"%s: Invalid network magic number\", __func__);\n-\n-        // de-serialize address data into one CAddrMan object\n-        ssPeers >> addr;\n-    }\n-    catch (const std::exception& e) {\n-        // de-serialization has failed, ensure addrman is left in a clean state\n+    bool ret = DeserializeDB(ssPeers, addr, false);\n+    if (!ret) {\n+        // Ensure addrman is left in a clean state\n         addr.Clear();\n-        return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n     }\n-\n-    return true;\n+    return ret;\n }"
      },
      {
        "sha": "6cb36dfac4e60ee8512f8dfdac28101aa6ecc48c",
        "filename": "src/addrdb.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/addrdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/addrdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -85,7 +85,7 @@ class CAddrDB\n     CAddrDB();\n     bool Write(const CAddrMan& addr);\n     bool Read(CAddrMan& addr);\n-    bool Read(CAddrMan& addr, CDataStream& ssPeers);\n+    static bool Read(CAddrMan& addr, CDataStream& ssPeers);\n };\n \n /** Access to the banlist database (banlist.dat) */"
      },
      {
        "sha": "4a408b9beb1913e06cc9fc570319431838e86533",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -351,8 +351,8 @@ CAddrInfo CAddrMan::Select_(bool newOnly)\n             int nKBucket = RandomInt(ADDRMAN_TRIED_BUCKET_COUNT);\n             int nKBucketPos = RandomInt(ADDRMAN_BUCKET_SIZE);\n             while (vvTried[nKBucket][nKBucketPos] == -1) {\n-                nKBucket = (nKBucket + insecure_rand.rand32()) % ADDRMAN_TRIED_BUCKET_COUNT;\n-                nKBucketPos = (nKBucketPos + insecure_rand.rand32()) % ADDRMAN_BUCKET_SIZE;\n+                nKBucket = (nKBucket + insecure_rand.randbits(ADDRMAN_TRIED_BUCKET_COUNT_LOG2)) % ADDRMAN_TRIED_BUCKET_COUNT;\n+                nKBucketPos = (nKBucketPos + insecure_rand.randbits(ADDRMAN_BUCKET_SIZE_LOG2)) % ADDRMAN_BUCKET_SIZE;\n             }\n             int nId = vvTried[nKBucket][nKBucketPos];\n             assert(mapInfo.count(nId) == 1);\n@@ -368,8 +368,8 @@ CAddrInfo CAddrMan::Select_(bool newOnly)\n             int nUBucket = RandomInt(ADDRMAN_NEW_BUCKET_COUNT);\n             int nUBucketPos = RandomInt(ADDRMAN_BUCKET_SIZE);\n             while (vvNew[nUBucket][nUBucketPos] == -1) {\n-                nUBucket = (nUBucket + insecure_rand.rand32()) % ADDRMAN_NEW_BUCKET_COUNT;\n-                nUBucketPos = (nUBucketPos + insecure_rand.rand32()) % ADDRMAN_BUCKET_SIZE;\n+                nUBucket = (nUBucket + insecure_rand.randbits(ADDRMAN_NEW_BUCKET_COUNT_LOG2)) % ADDRMAN_NEW_BUCKET_COUNT;\n+                nUBucketPos = (nUBucketPos + insecure_rand.randbits(ADDRMAN_BUCKET_SIZE_LOG2)) % ADDRMAN_BUCKET_SIZE;\n             }\n             int nId = vvNew[nUBucket][nUBucketPos];\n             assert(mapInfo.count(nId) == 1);"
      },
      {
        "sha": "70d907488f3d92bdf432d5091aa68e7714887193",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 8,
        "deletions": 3,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -136,13 +136,13 @@ class CAddrInfo : public CAddress\n  */\n \n //! total number of buckets for tried addresses\n-#define ADDRMAN_TRIED_BUCKET_COUNT 256\n+#define ADDRMAN_TRIED_BUCKET_COUNT_LOG2 8\n \n //! total number of buckets for new addresses\n-#define ADDRMAN_NEW_BUCKET_COUNT 1024\n+#define ADDRMAN_NEW_BUCKET_COUNT_LOG2 10\n \n //! maximum allowed number of entries in buckets for new and tried addresses\n-#define ADDRMAN_BUCKET_SIZE 64\n+#define ADDRMAN_BUCKET_SIZE_LOG2 6\n \n //! over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread\n #define ADDRMAN_TRIED_BUCKETS_PER_GROUP 8\n@@ -171,6 +171,11 @@ class CAddrInfo : public CAddress\n //! the maximum number of nodes to return in a getaddr call\n #define ADDRMAN_GETADDR_MAX 2500\n \n+//! Convenience\n+#define ADDRMAN_TRIED_BUCKET_COUNT (1 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2)\n+#define ADDRMAN_NEW_BUCKET_COUNT (1 << ADDRMAN_NEW_BUCKET_COUNT_LOG2)\n+#define ADDRMAN_BUCKET_SIZE (1 << ADDRMAN_BUCKET_SIZE_LOG2)\n+\n /** \n  * Stochastical (IP) address manager \n  */"
      },
      {
        "sha": "2bd367cba29fa5e802635786607272b8c718a553",
        "filename": "src/amount.h",
        "status": "modified",
        "additions": 1,
        "deletions": 44,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/amount.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/amount.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/amount.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -6,19 +6,14 @@\n #ifndef BITCOIN_AMOUNT_H\n #define BITCOIN_AMOUNT_H\n \n-#include \"serialize.h\"\n-\n-#include <stdlib.h>\n-#include <string>\n+#include <stdint.h>\n \n /** Amount in satoshis (Can be negative) */\n typedef int64_t CAmount;\n \n static const CAmount COIN = 100000000;\n static const CAmount CENT = 1000000;\n \n-extern const std::string CURRENCY_UNIT;\n-\n /** No amount larger than this (in satoshi) is valid.\n  *\n  * Note that this constant is *not* the total money supply, which in Bitcoin\n@@ -31,42 +26,4 @@ extern const std::string CURRENCY_UNIT;\n static const CAmount MAX_MONEY = 21000000 * COIN;\n inline bool MoneyRange(const CAmount& nValue) { return (nValue >= 0 && nValue <= MAX_MONEY); }\n \n-/**\n- * Fee rate in satoshis per kilobyte: CAmount / kB\n- */\n-class CFeeRate\n-{\n-private:\n-    CAmount nSatoshisPerK; // unit is satoshis-per-1,000-bytes\n-public:\n-    /** Fee rate of 0 satoshis per kB */\n-    CFeeRate() : nSatoshisPerK(0) { }\n-    explicit CFeeRate(const CAmount& _nSatoshisPerK): nSatoshisPerK(_nSatoshisPerK) { }\n-    /** Constructor for a fee rate in satoshis per kB. The size in bytes must not exceed (2^63 - 1)*/\n-    CFeeRate(const CAmount& nFeePaid, size_t nBytes);\n-    CFeeRate(const CFeeRate& other) { nSatoshisPerK = other.nSatoshisPerK; }\n-    /**\n-     * Return the fee in satoshis for the given size in bytes.\n-     */\n-    CAmount GetFee(size_t nBytes) const;\n-    /**\n-     * Return the fee in satoshis for a size of 1000 bytes\n-     */\n-    CAmount GetFeePerK() const { return GetFee(1000); }\n-    friend bool operator<(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK < b.nSatoshisPerK; }\n-    friend bool operator>(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK > b.nSatoshisPerK; }\n-    friend bool operator==(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK == b.nSatoshisPerK; }\n-    friend bool operator<=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK <= b.nSatoshisPerK; }\n-    friend bool operator>=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK >= b.nSatoshisPerK; }\n-    CFeeRate& operator+=(const CFeeRate& a) { nSatoshisPerK += a.nSatoshisPerK; return *this; }\n-    std::string ToString() const;\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n-        READWRITE(nSatoshisPerK);\n-    }\n-};\n-\n #endif //  BITCOIN_AMOUNT_H"
      },
      {
        "sha": "b4952af6f48906a29db02ce9a86766e01d7d92ca",
        "filename": "src/arith_uint256.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/arith_uint256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/arith_uint256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/arith_uint256.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -15,6 +15,8 @@\n template <unsigned int BITS>\n base_uint<BITS>::base_uint(const std::string& str)\n {\n+    static_assert(BITS/32 > 0 && BITS%32 == 0, \"Template parameter BITS must be a positive multiple of 32.\");\n+\n     SetHex(str);\n }\n "
      },
      {
        "sha": "c7734035df2e0bdf133598bd4581c0146ce18425",
        "filename": "src/arith_uint256.h",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/arith_uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/arith_uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/arith_uint256.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -31,12 +31,16 @@ class base_uint\n \n     base_uint()\n     {\n+        static_assert(BITS/32 > 0 && BITS%32 == 0, \"Template parameter BITS must be a positive multiple of 32.\");\n+\n         for (int i = 0; i < WIDTH; i++)\n             pn[i] = 0;\n     }\n \n     base_uint(const base_uint& b)\n     {\n+        static_assert(BITS/32 > 0 && BITS%32 == 0, \"Template parameter BITS must be a positive multiple of 32.\");\n+\n         for (int i = 0; i < WIDTH; i++)\n             pn[i] = b.pn[i];\n     }\n@@ -50,6 +54,8 @@ class base_uint\n \n     base_uint(uint64_t b)\n     {\n+        static_assert(BITS/32 > 0 && BITS%32 == 0, \"Template parameter BITS must be a positive multiple of 32.\");\n+\n         pn[0] = (unsigned int)b;\n         pn[1] = (unsigned int)(b >> 32);\n         for (int i = 2; i < WIDTH; i++)\n@@ -174,7 +180,7 @@ class base_uint\n     {\n         // prefix operator\n         int i = 0;\n-        while (++pn[i] == 0 && i < WIDTH-1)\n+        while (i < WIDTH && ++pn[i] == 0)\n             i++;\n         return *this;\n     }\n@@ -191,7 +197,7 @@ class base_uint\n     {\n         // prefix operator\n         int i = 0;\n-        while (--pn[i] == (uint32_t)-1 && i < WIDTH-1)\n+        while (i < WIDTH && --pn[i] == (uint32_t)-1)\n             i++;\n         return *this;\n     }"
      },
      {
        "sha": "17022a6bc161f084e4672882ce4f6e1060fe3d61",
        "filename": "src/base58.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -110,7 +110,7 @@ std::string EncodeBase58(const unsigned char* pbegin, const unsigned char* pend)\n \n std::string EncodeBase58(const std::vector<unsigned char>& vch)\n {\n-    return EncodeBase58(&vch[0], &vch[0] + vch.size());\n+    return EncodeBase58(vch.data(), vch.data() + vch.size());\n }\n \n bool DecodeBase58(const std::string& str, std::vector<unsigned char>& vchRet)\n@@ -160,7 +160,7 @@ void CBase58Data::SetData(const std::vector<unsigned char>& vchVersionIn, const\n     vchVersion = vchVersionIn;\n     vchData.resize(nSize);\n     if (!vchData.empty())\n-        memcpy(&vchData[0], pdata, nSize);\n+        memcpy(vchData.data(), pdata, nSize);\n }\n \n void CBase58Data::SetData(const std::vector<unsigned char>& vchVersionIn, const unsigned char* pbegin, const unsigned char* pend)\n@@ -180,8 +180,8 @@ bool CBase58Data::SetString(const char* psz, unsigned int nVersionBytes)\n     vchVersion.assign(vchTemp.begin(), vchTemp.begin() + nVersionBytes);\n     vchData.resize(vchTemp.size() - nVersionBytes);\n     if (!vchData.empty())\n-        memcpy(&vchData[0], &vchTemp[nVersionBytes], vchData.size());\n-    memory_cleanse(&vchTemp[0], vchTemp.size());\n+        memcpy(vchData.data(), vchTemp.data() + nVersionBytes, vchData.size());\n+    memory_cleanse(vchTemp.data(), vchTemp.size());\n     return true;\n }\n \n@@ -225,7 +225,7 @@ class CBitcoinAddressVisitor : public boost::static_visitor<bool>\n     bool operator()(const CNoDestination& no) const { return false; }\n };\n \n-} // anon namespace\n+} // namespace\n \n bool CBitcoinAddress::Set(const CKeyID& id)\n {\n@@ -262,7 +262,7 @@ CTxDestination CBitcoinAddress::Get() const\n     if (!IsValid())\n         return CNoDestination();\n     uint160 id;\n-    memcpy(&id, &vchData[0], 20);\n+    memcpy(&id, vchData.data(), 20);\n     if (vchVersion == Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS))\n         return CKeyID(id);\n     else if (vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS))\n@@ -276,7 +276,7 @@ bool CBitcoinAddress::GetKeyID(CKeyID& keyID) const\n     if (!IsValid() || vchVersion != Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS))\n         return false;\n     uint160 id;\n-    memcpy(&id, &vchData[0], 20);\n+    memcpy(&id, vchData.data(), 20);\n     keyID = CKeyID(id);\n     return true;\n }"
      },
      {
        "sha": "4de5cc6ce5f9f3e4b8738bfa399743f5a8284b9d",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -148,7 +148,7 @@ template<typename K, int Size, CChainParams::Base58Type Type> class CBitcoinExtK\n         K ret;\n         if (vchData.size() == Size) {\n             // If base58 encoded data does not hold an ext key, return a !IsValid() key\n-            ret.Decode(&vchData[0]);\n+            ret.Decode(vchData.data());\n         }\n         return ret;\n     }"
      },
      {
        "sha": "65e27a615d9344c765068a95676691a19314504a",
        "filename": "src/bench/base58.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 12,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bench/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bench/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/base58.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -7,34 +7,37 @@\n #include \"validation.h\"\n #include \"base58.h\"\n \n+#include <array>\n #include <vector>\n #include <string>\n \n \n static void Base58Encode(benchmark::State& state)\n {\n-    unsigned char buff[32] = {\n-        17, 79, 8, 99, 150, 189, 208, 162, 22, 23, 203, 163, 36, 58, 147,\n-        227, 139, 2, 215, 100, 91, 38, 11, 141, 253, 40, 117, 21, 16, 90,\n-        200, 24\n+    static const std::array<unsigned char, 32> buff = {\n+        {\n+            17, 79, 8, 99, 150, 189, 208, 162, 22, 23, 203, 163, 36, 58, 147,\n+            227, 139, 2, 215, 100, 91, 38, 11, 141, 253, 40, 117, 21, 16, 90,\n+            200, 24\n+        }\n     };\n-    unsigned char* b = buff;\n     while (state.KeepRunning()) {\n-        EncodeBase58(b, b + 32);\n+        EncodeBase58(buff.begin(), buff.end());\n     }\n }\n \n \n static void Base58CheckEncode(benchmark::State& state)\n {\n-    unsigned char buff[32] = {\n-        17, 79, 8, 99, 150, 189, 208, 162, 22, 23, 203, 163, 36, 58, 147,\n-        227, 139, 2, 215, 100, 91, 38, 11, 141, 253, 40, 117, 21, 16, 90,\n-        200, 24\n+    static const std::array<unsigned char, 32> buff = {\n+        {\n+            17, 79, 8, 99, 150, 189, 208, 162, 22, 23, 203, 163, 36, 58, 147,\n+            227, 139, 2, 215, 100, 91, 38, 11, 141, 253, 40, 117, 21, 16, 90,\n+            200, 24\n+        }\n     };\n-    unsigned char* b = buff;\n     std::vector<unsigned char> vch;\n-    vch.assign(b, b + 32);\n+    vch.assign(buff.begin(), buff.end());\n     while (state.KeepRunning()) {\n         EncodeBase58Check(vch);\n     }"
      },
      {
        "sha": "33631d2d150545196a1a559e5b40a140b8f00c9e",
        "filename": "src/bench/bench.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bench/bench.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bench/bench.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -5,6 +5,7 @@\n #include \"bench.h\"\n #include \"perf.h\"\n \n+#include <assert.h>\n #include <iostream>\n #include <iomanip>\n #include <sys/time.h>"
      },
      {
        "sha": "1f36f2a4bca1b07e2577aebb8392463aabe0a2b4",
        "filename": "src/bench/bench.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bench/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bench/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -5,10 +5,11 @@\n #ifndef BITCOIN_BENCH_BENCH_H\n #define BITCOIN_BENCH_BENCH_H\n \n+#include <functional>\n+#include <limits>\n #include <map>\n #include <string>\n \n-#include <boost/function.hpp>\n #include <boost/preprocessor/cat.hpp>\n #include <boost/preprocessor/stringize.hpp>\n \n@@ -59,7 +60,7 @@ namespace benchmark {\n         bool KeepRunning();\n     };\n \n-    typedef boost::function<void(State&)> BenchFunction;\n+    typedef std::function<void(State&)> BenchFunction;\n \n     class BenchRunner\n     {"
      },
      {
        "sha": "37fd772435ed70ce760fc1ad8f3b36f1f37776e1",
        "filename": "src/bench/bench_bitcoin.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bench/bench_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bench/bench_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench_bitcoin.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -4,13 +4,17 @@\n \n #include \"bench.h\"\n \n+#include \"crypto/sha256.h\"\n #include \"key.h\"\n #include \"validation.h\"\n #include \"util.h\"\n+#include \"random.h\"\n \n int\n main(int argc, char** argv)\n {\n+    SHA256AutoDetect();\n+    RandomInit();\n     ECC_Start();\n     SetupEnvironment();\n     fPrintToDebugLog = false; // don't want to write to debug.log file"
      },
      {
        "sha": "5aab3381fd21dd64684306b01b1dfce9861212fd",
        "filename": "src/bench/ccoins_caching.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bench/ccoins_caching.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bench/ccoins_caching.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/ccoins_caching.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -35,14 +35,14 @@ SetupDummyInputs(CBasicKeyStore& keystoreRet, CCoinsViewCache& coinsRet)\n     dummyTransactions[0].vout[0].scriptPubKey << ToByteVector(key[0].GetPubKey()) << OP_CHECKSIG;\n     dummyTransactions[0].vout[1].nValue = 50 * CENT;\n     dummyTransactions[0].vout[1].scriptPubKey << ToByteVector(key[1].GetPubKey()) << OP_CHECKSIG;\n-    coinsRet.ModifyCoins(dummyTransactions[0].GetHash())->FromTx(dummyTransactions[0], 0);\n+    AddCoins(coinsRet, dummyTransactions[0], 0);\n \n     dummyTransactions[1].vout.resize(2);\n     dummyTransactions[1].vout[0].nValue = 21 * CENT;\n     dummyTransactions[1].vout[0].scriptPubKey = GetScriptForDestination(key[2].GetPubKey().GetID());\n     dummyTransactions[1].vout[1].nValue = 22 * CENT;\n     dummyTransactions[1].vout[1].scriptPubKey = GetScriptForDestination(key[3].GetPubKey().GetID());\n-    coinsRet.ModifyCoins(dummyTransactions[1].GetHash())->FromTx(dummyTransactions[1], 0);\n+    AddCoins(coinsRet, dummyTransactions[1], 0);\n \n     return dummyTransactions;\n }"
      },
      {
        "sha": "7bb1b93668cf7472dd8781cf750596d204d5314a",
        "filename": "src/bench/checkblock.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bench/checkblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bench/checkblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkblock.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -11,7 +11,7 @@\n \n namespace block_bench {\n #include \"bench/data/block413567.raw.h\"\n-}\n+} // namespace block_bench\n \n // These are the two major time-sinks which happen after we have fully received\n // a block off the wire, but before we can relay the block on to peers using\n@@ -40,15 +40,15 @@ static void DeserializeAndCheckBlockTest(benchmark::State& state)\n     char a = '\\0';\n     stream.write(&a, 1); // Prevent compaction\n \n-    Consensus::Params params = Params(CBaseChainParams::MAIN).GetConsensus();\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n \n     while (state.KeepRunning()) {\n         CBlock block; // Note that CBlock caches its checked state, so we need to recreate it here\n         stream >> block;\n         assert(stream.Rewind(sizeof(block_bench::block413567)));\n \n         CValidationState validationState;\n-        assert(CheckBlock(block, validationState, params));\n+        assert(CheckBlock(block, validationState, chainParams->GetConsensus()));\n     }\n }\n "
      },
      {
        "sha": "88a2a570f93d2a83aae94700ea7b854426f54c9e",
        "filename": "src/bench/checkqueue.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bench/checkqueue.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bench/checkqueue.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkqueue.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -68,7 +68,7 @@ static void CCheckQueueSpeedPrevectorJob(benchmark::State& state)\n         PrevectorJob(){\n         }\n         PrevectorJob(FastRandomContext& insecure_rand){\n-            p.resize(insecure_rand.rand32() % (PREVECTOR_SIZE*2));\n+            p.resize(insecure_rand.randrange(PREVECTOR_SIZE*2));\n         }\n         bool operator()()\n         {"
      },
      {
        "sha": "f8956508f68216fba8b4534419ffafbac62002ff",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -5,7 +5,6 @@\n #include \"bench.h\"\n #include \"wallet/wallet.h\"\n \n-#include <boost/foreach.hpp>\n #include <set>\n \n static void addCoin(const CAmount& nValue, const CWallet& wallet, std::vector<COutput>& vCoins)\n@@ -39,7 +38,7 @@ static void CoinSelection(benchmark::State& state)\n \n     while (state.KeepRunning()) {\n         // Empty wallet.\n-        BOOST_FOREACH (COutput output, vCoins)\n+        for (COutput output : vCoins)\n             delete output.tx;\n         vCoins.clear();\n "
      },
      {
        "sha": "2914a36c7b92ade59e0fa9c2208647155c762cb5",
        "filename": "src/bench/crypto_hash.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 0,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bench/crypto_hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bench/crypto_hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/crypto_hash.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -7,6 +7,7 @@\n #include \"bench.h\"\n #include \"bloom.h\"\n #include \"hash.h\"\n+#include \"random.h\"\n #include \"uint256.h\"\n #include \"utiltime.h\"\n #include \"crypto/ripemd160.h\"\n@@ -69,10 +70,34 @@ static void SipHash_32b(benchmark::State& state)\n     }\n }\n \n+static void FastRandom_32bit(benchmark::State& state)\n+{\n+    FastRandomContext rng(true);\n+    uint32_t x = 0;\n+    while (state.KeepRunning()) {\n+        for (int i = 0; i < 1000000; i++) {\n+            x += rng.rand32();\n+        }\n+    }\n+}\n+\n+static void FastRandom_1bit(benchmark::State& state)\n+{\n+    FastRandomContext rng(true);\n+    uint32_t x = 0;\n+    while (state.KeepRunning()) {\n+        for (int i = 0; i < 1000000; i++) {\n+            x += rng.randbool();\n+        }\n+    }\n+}\n+\n BENCHMARK(RIPEMD160);\n BENCHMARK(SHA1);\n BENCHMARK(SHA256);\n BENCHMARK(SHA512);\n \n BENCHMARK(SHA256_32b);\n BENCHMARK(SipHash_32b);\n+BENCHMARK(FastRandom_32bit);\n+BENCHMARK(FastRandom_1bit);"
      },
      {
        "sha": "ef7381c1201db0d37438c7de10ca1d17e221333b",
        "filename": "src/bench/verify_script.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bench/verify_script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bench/verify_script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/verify_script.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -11,6 +11,8 @@\n #include \"script/sign.h\"\n #include \"streams.h\"\n \n+#include <array>\n+\n // FIXME: Dedup with BuildCreditingTransaction in test/script_tests.cpp.\n static CMutableTransaction BuildCreditingTransaction(const CScript& scriptPubKey)\n {\n@@ -55,8 +57,12 @@ static void VerifyScriptBench(benchmark::State& state)\n \n     // Keypair.\n     CKey key;\n-    const unsigned char vchKey[32] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};\n-    key.Set(vchKey, vchKey + 32, false);\n+    static const std::array<unsigned char, 32> vchKey = {\n+        {\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\n+        }\n+    };\n+    key.Set(vchKey.begin(), vchKey.end(), false);\n     CPubKey pubkey = key.GetPubKey();\n     uint160 pubkeyHash;\n     CHash160().Write(pubkey.begin(), pubkey.size()).Finalize(pubkeyHash.begin());"
      },
      {
        "sha": "c1a7c927e306287265d57d3db4d1b68d82f4317c",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 4,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -30,6 +30,8 @@ static const int CONTINUE_EXECUTION=-1;\n \n std::string HelpMessageCli()\n {\n+    const auto defaultBaseParams = CreateBaseChainParams(CBaseChainParams::MAIN);\n+    const auto testnetBaseParams = CreateBaseChainParams(CBaseChainParams::TESTNET);\n     std::string strUsage;\n     strUsage += HelpMessageGroup(_(\"Options:\"));\n     strUsage += HelpMessageOpt(\"-?\", _(\"This help message\"));\n@@ -38,12 +40,13 @@ std::string HelpMessageCli()\n     AppendParamsHelpMessages(strUsage);\n     strUsage += HelpMessageOpt(\"-named\", strprintf(_(\"Pass named instead of positional arguments (default: %s)\"), DEFAULT_NAMED));\n     strUsage += HelpMessageOpt(\"-rpcconnect=<ip>\", strprintf(_(\"Send commands to node running on <ip> (default: %s)\"), DEFAULT_RPCCONNECT));\n-    strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\"Connect to JSON-RPC on <port> (default: %u or testnet: %u)\"), BaseParams(CBaseChainParams::MAIN).RPCPort(), BaseParams(CBaseChainParams::TESTNET).RPCPort()));\n+    strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\"Connect to JSON-RPC on <port> (default: %u or testnet: %u)\"), defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()));\n     strUsage += HelpMessageOpt(\"-rpcwait\", _(\"Wait for RPC server to start\"));\n     strUsage += HelpMessageOpt(\"-rpcuser=<user>\", _(\"Username for JSON-RPC connections\"));\n     strUsage += HelpMessageOpt(\"-rpcpassword=<pw>\", _(\"Password for JSON-RPC connections\"));\n     strUsage += HelpMessageOpt(\"-rpcclienttimeout=<n>\", strprintf(_(\"Timeout in seconds during HTTP requests, or 0 for no timeout. (default: %d)\"), DEFAULT_HTTP_CLIENT_TIMEOUT));\n     strUsage += HelpMessageOpt(\"-stdin\", _(\"Read extra arguments from standard input, one per line until EOF/Ctrl-D (recommended for sensitive information such as passphrases)\"));\n+    strUsage += HelpMessageOpt(\"-rpcwallet=<walletname>\", _(\"Send RPC for non-default wallet on RPC server (argument is wallet filename in bitcoind directory, required if bitcoind/-Qt runs with multiple wallets)\"));\n \n     return strUsage;\n }\n@@ -189,8 +192,14 @@ static void http_error_cb(enum evhttp_request_error err, void *ctx)\n \n UniValue CallRPC(const std::string& strMethod, const UniValue& params)\n {\n-    std::string host = GetArg(\"-rpcconnect\", DEFAULT_RPCCONNECT);\n-    int port = GetArg(\"-rpcport\", BaseParams().RPCPort());\n+    std::string host;\n+    // In preference order, we choose the following for the port:\n+    //     1. -rpcport\n+    //     2. port in -rpcconnect (ie following : in ipv4 or ]: in ipv6)\n+    //     3. default port for chain\n+    int port = BaseParams().RPCPort();\n+    SplitHostPort(GetArg(\"-rpcconnect\", DEFAULT_RPCCONNECT), port, host);\n+    port = GetArg(\"-rpcport\", port);\n \n     // Obtain event base\n     raii_event_base base = obtain_event_base();\n@@ -233,7 +242,20 @@ UniValue CallRPC(const std::string& strMethod, const UniValue& params)\n     assert(output_buffer);\n     evbuffer_add(output_buffer, strRequest.data(), strRequest.size());\n \n-    int r = evhttp_make_request(evcon.get(), req.get(), EVHTTP_REQ_POST, \"/\");\n+    // check if we should use a special wallet endpoint\n+    std::string endpoint = \"/\";\n+    std::string walletName = GetArg(\"-rpcwallet\", \"\");\n+    if (!walletName.empty()) {\n+        char *encodedURI = evhttp_uriencode(walletName.c_str(), walletName.size(), false);\n+        if (encodedURI) {\n+            endpoint = \"/wallet/\"+ std::string(encodedURI);\n+            free(encodedURI);\n+        }\n+        else {\n+            throw CConnectionFailed(\"uri-encode failed\");\n+        }\n+    }\n+    int r = evhttp_make_request(evcon.get(), req.get(), EVHTTP_REQ_POST, endpoint.c_str());\n     req.release(); // ownership moved to evcon in above call\n     if (r != 0) {\n         throw CConnectionFailed(\"send http request failed\");\n@@ -315,6 +337,10 @@ int CommandLineRPC(int argc, char *argv[])\n \n                         if (errMsg.isStr())\n                             strPrint += \"error message:\\n\"+errMsg.get_str();\n+\n+                        if (errCode.isNum() && errCode.get_int() == RPC_WALLET_NOT_SPECIFIED) {\n+                            strPrint += \"\\nTry adding \\\"-rpcwallet=<filename>\\\" option to bitcoin-cli command line.\";\n+                        }\n                     }\n                 } else {\n                     // Result"
      },
      {
        "sha": "9acb3fd30e9668e18f6cbbf2921646e7f2799d6f",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 51,
        "deletions": 20,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -13,6 +13,7 @@\n #include \"core_io.h\"\n #include \"keystore.h\"\n #include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n #include \"primitives/transaction.h\"\n #include \"script/script.h\"\n #include \"script/sign.h\"\n@@ -24,7 +25,6 @@\n #include <stdio.h>\n \n #include <boost/algorithm/string.hpp>\n-#include <boost/assign/list_of.hpp>\n \n static bool fCreateBlank;\n static std::map<std::string,UniValue> registers;\n@@ -77,6 +77,7 @@ static int AppInitRawTx(int argc, char* argv[])\n         strUsage += HelpMessageOpt(\"in=TXID:VOUT(:SEQUENCE_NUMBER)\", _(\"Add input to TX\"));\n         strUsage += HelpMessageOpt(\"locktime=N\", _(\"Set TX lock time to N\"));\n         strUsage += HelpMessageOpt(\"nversion=N\", _(\"Set TX version to N\"));\n+        strUsage += HelpMessageOpt(\"replaceable(=N)\", _(\"Set RBF opt-in sequence number for input N (if not provided, opt-in all available inputs)\"));\n         strUsage += HelpMessageOpt(\"outaddr=VALUE:ADDRESS\", _(\"Add address-based output to TX\"));\n         strUsage += HelpMessageOpt(\"outpubkey=VALUE:PUBKEY[:FLAGS]\", _(\"Add pay-to-pubkey output to TX\") + \". \" +\n             _(\"Optionally add the \\\"W\\\" flag to produce a pay-to-witness-pubkey-hash output\") + \". \" +\n@@ -202,6 +203,26 @@ static void MutateTxLocktime(CMutableTransaction& tx, const std::string& cmdVal)\n     tx.nLockTime = (unsigned int) newLocktime;\n }\n \n+static void MutateTxRBFOptIn(CMutableTransaction& tx, const std::string& strInIdx)\n+{\n+    // parse requested index\n+    int inIdx = atoi(strInIdx);\n+    if (inIdx < 0 || inIdx >= (int)tx.vin.size()) {\n+        throw std::runtime_error(\"Invalid TX input index '\" + strInIdx + \"'\");\n+    }\n+\n+    // set the nSequence to MAX_INT - 2 (= RBF opt in flag)\n+    int cnt = 0;\n+    for (CTxIn& txin : tx.vin) {\n+        if (strInIdx == \"\" || cnt == inIdx) {\n+            if (txin.nSequence > MAX_BIP125_RBF_SEQUENCE) {\n+                txin.nSequence = MAX_BIP125_RBF_SEQUENCE;\n+            }\n+        }\n+        ++cnt;\n+    }\n+}\n+\n static void MutateTxAddInput(CMutableTransaction& tx, const std::string& strInput)\n {\n     std::vector<std::string> vStrInputParts;\n@@ -218,7 +239,7 @@ static void MutateTxAddInput(CMutableTransaction& tx, const std::string& strInpu\n     uint256 txid(uint256S(strTxid));\n \n     static const unsigned int minTxOutSz = 9;\n-    static const unsigned int maxVout = MAX_BLOCK_BASE_SIZE / minTxOutSz;\n+    static const unsigned int maxVout = MAX_BLOCK_WEIGHT / (WITNESS_SCALE_FACTOR * minTxOutSz);\n \n     // extract and validate vout\n     std::string strVout = vStrInputParts[1];\n@@ -278,7 +299,6 @@ static void MutateTxAddOutPubKey(CMutableTransaction& tx, const std::string& str\n     if (!pubkey.IsFullyValid())\n         throw std::runtime_error(\"invalid TX output pubkey\");\n     CScript scriptPubKey = GetScriptForRawPubKey(pubkey);\n-    CBitcoinAddress addr(scriptPubKey);\n \n     // Extract and validate FLAGS\n     bool bSegWit = false;\n@@ -546,7 +566,11 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n             if (!prevOut.isObject())\n                 throw std::runtime_error(\"expected prevtxs internal object\");\n \n-            std::map<std::string,UniValue::VType> types = boost::assign::map_list_of(\"txid\", UniValue::VSTR)(\"vout\",UniValue::VNUM)(\"scriptPubKey\",UniValue::VSTR);\n+            std::map<std::string, UniValue::VType> types = {\n+                {\"txid\", UniValue::VSTR},\n+                {\"vout\", UniValue::VNUM},\n+                {\"scriptPubKey\", UniValue::VSTR},\n+            };\n             if (!prevOut.checkObject(types))\n                 throw std::runtime_error(\"prevtxs internal object typecheck fail\");\n \n@@ -556,24 +580,26 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n             if (nOut < 0)\n                 throw std::runtime_error(\"vout must be positive\");\n \n+            COutPoint out(txid, nOut);\n             std::vector<unsigned char> pkData(ParseHexUV(prevOut[\"scriptPubKey\"], \"scriptPubKey\"));\n             CScript scriptPubKey(pkData.begin(), pkData.end());\n \n             {\n-                CCoinsModifier coins = view.ModifyCoins(txid);\n-                if (coins->IsAvailable(nOut) && coins->vout[nOut].scriptPubKey != scriptPubKey) {\n+                const Coin& coin = view.AccessCoin(out);\n+                if (!coin.IsSpent() && coin.out.scriptPubKey != scriptPubKey) {\n                     std::string err(\"Previous output scriptPubKey mismatch:\\n\");\n-                    err = err + ScriptToAsmStr(coins->vout[nOut].scriptPubKey) + \"\\nvs:\\n\"+\n+                    err = err + ScriptToAsmStr(coin.out.scriptPubKey) + \"\\nvs:\\n\"+\n                         ScriptToAsmStr(scriptPubKey);\n                     throw std::runtime_error(err);\n                 }\n-                if ((unsigned int)nOut >= coins->vout.size())\n-                    coins->vout.resize(nOut+1);\n-                coins->vout[nOut].scriptPubKey = scriptPubKey;\n-                coins->vout[nOut].nValue = 0;\n+                Coin newcoin;\n+                newcoin.out.scriptPubKey = scriptPubKey;\n+                newcoin.out.nValue = 0;\n                 if (prevOut.exists(\"amount\")) {\n-                    coins->vout[nOut].nValue = AmountFromValue(prevOut[\"amount\"]);\n+                    newcoin.out.nValue = AmountFromValue(prevOut[\"amount\"]);\n                 }\n+                newcoin.nHeight = 1;\n+                view.AddCoin(out, std::move(newcoin), true);\n             }\n \n             // if redeemScript given and private keys given,\n@@ -595,21 +621,21 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n     // Sign what we can:\n     for (unsigned int i = 0; i < mergedTx.vin.size(); i++) {\n         CTxIn& txin = mergedTx.vin[i];\n-        const CCoins* coins = view.AccessCoins(txin.prevout.hash);\n-        if (!coins || !coins->IsAvailable(txin.prevout.n)) {\n+        const Coin& coin = view.AccessCoin(txin.prevout);\n+        if (coin.IsSpent()) {\n             fComplete = false;\n             continue;\n         }\n-        const CScript& prevPubKey = coins->vout[txin.prevout.n].scriptPubKey;\n-        const CAmount& amount = coins->vout[txin.prevout.n].nValue;\n+        const CScript& prevPubKey = coin.out.scriptPubKey;\n+        const CAmount& amount = coin.out.nValue;\n \n         SignatureData sigdata;\n         // Only sign SIGHASH_SINGLE if there's a corresponding output:\n         if (!fHashSingle || (i < mergedTx.vout.size()))\n             ProduceSignature(MutableTransactionSignatureCreator(&keystore, &mergedTx, i, amount, nHashType), prevPubKey, sigdata);\n \n         // ... and merge in other signatures:\n-        BOOST_FOREACH(const CTransaction& txv, txVariants)\n+        for (const CTransaction& txv : txVariants)\n             sigdata = CombineSignatures(prevPubKey, MutableTransactionSignatureChecker(&mergedTx, i, amount), sigdata, DataFromTransaction(txv, i));\n         UpdateTransaction(mergedTx, i, sigdata);\n \n@@ -647,6 +673,9 @@ static void MutateTx(CMutableTransaction& tx, const std::string& command,\n         MutateTxVersion(tx, commandVal);\n     else if (command == \"locktime\")\n         MutateTxLocktime(tx, commandVal);\n+    else if (command == \"replaceable\") {\n+        MutateTxRBFOptIn(tx, commandVal);\n+    }\n \n     else if (command == \"delin\")\n         MutateTxDelInput(tx, commandVal);\n@@ -657,11 +686,13 @@ static void MutateTx(CMutableTransaction& tx, const std::string& command,\n         MutateTxDelOutput(tx, commandVal);\n     else if (command == \"outaddr\")\n         MutateTxAddOutAddr(tx, commandVal);\n-    else if (command == \"outpubkey\")\n+    else if (command == \"outpubkey\") {\n+        if (!ecc) { ecc.reset(new Secp256k1Init()); }\n         MutateTxAddOutPubKey(tx, commandVal);\n-    else if (command == \"outmultisig\")\n+    } else if (command == \"outmultisig\") {\n+        if (!ecc) { ecc.reset(new Secp256k1Init()); }\n         MutateTxAddOutMultiSig(tx, commandVal);\n-    else if (command == \"outscript\")\n+    } else if (command == \"outscript\")\n         MutateTxAddOutScript(tx, commandVal);\n     else if (command == \"outdata\")\n         MutateTxAddOutData(tx, commandVal);"
      },
      {
        "sha": "ff61b9065be2f971288a54b104a94af7327c821e",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 15,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -20,7 +20,6 @@\n #include \"httprpc.h\"\n #include \"utilstrencodings.h\"\n \n-#include <boost/algorithm/string/predicate.hpp>\n #include <boost/thread.hpp>\n \n #include <stdio.h>\n@@ -117,17 +116,14 @@ bool AppInit(int argc, char* argv[])\n             return false;\n         }\n \n-        // Command-line RPC\n-        bool fCommandLine = false;\n-        for (int i = 1; i < argc; i++)\n-            if (!IsSwitchChar(argv[i][0]) && !boost::algorithm::istarts_with(argv[i], \"bitcoin:\"))\n-                fCommandLine = true;\n-\n-        if (fCommandLine)\n-        {\n-            fprintf(stderr, \"Error: There is no RPC client functionality in bitcoind anymore. Use the bitcoin-cli utility instead.\\n\");\n-            exit(EXIT_FAILURE);\n+        // Error out when loose non-argument tokens are encountered on command line\n+        for (int i = 1; i < argc; i++) {\n+            if (!IsSwitchChar(argv[i][0])) {\n+                fprintf(stderr, \"Error: Command line contains unexpected token '%s', see bitcoind -h for a list of options.\\n\", argv[i]);\n+                exit(EXIT_FAILURE);\n+            }\n         }\n+\n         // -server defaults to true for bitcoind but not for the GUI so do this here\n         SoftSetBoolArg(\"-server\", true);\n         // Set this early so that parameter interactions go to console\n@@ -163,7 +159,12 @@ bool AppInit(int argc, char* argv[])\n             return false;\n #endif // HAVE_DECL_DAEMON\n         }\n-\n+        // Lock data directory after daemonization\n+        if (!AppInitLockDataDirectory())\n+        {\n+            // If locking the data directory failed, exit immediately\n+            exit(EXIT_FAILURE);\n+        }\n         fRet = AppInitMain(threadGroup, scheduler);\n     }\n     catch (const std::exception& e) {\n@@ -175,9 +176,7 @@ bool AppInit(int argc, char* argv[])\n     if (!fRet)\n     {\n         Interrupt(threadGroup);\n-        // threadGroup.join_all(); was left out intentionally here, because we didn't re-test all of\n-        // the startup-failure cases to make sure they don't result in a hang due to some\n-        // thread-blocking-waiting-for-another-thread-during-startup case\n+        threadGroup.join_all();\n     } else {\n         WaitForShutdown(&threadGroup);\n     }"
      },
      {
        "sha": "6f27b7b9dc5dff082ab3c773a99786789ae315de",
        "filename": "src/blockencodings.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/blockencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/blockencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -15,8 +15,6 @@\n \n #include <unordered_map>\n \n-#define MIN_TRANSACTION_BASE_SIZE (::GetSerializeSize(CTransaction(), SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS))\n-\n CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block, bool fUseWTXID) :\n         nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n         shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n@@ -50,7 +48,7 @@ uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, const std::vector<std::pair<uint256, CTransactionRef>>& extra_txn) {\n     if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n         return READ_STATUS_INVALID;\n-    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_BASE_SIZE / MIN_TRANSACTION_BASE_SIZE)\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_WEIGHT / MIN_SERIALIZABLE_TRANSACTION_WEIGHT)\n         return READ_STATUS_INVALID;\n \n     assert(header.IsNull() && txn_available.empty());\n@@ -172,7 +170,7 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n bool PartiallyDownloadedBlock::IsTxAvailable(size_t index) const {\n     assert(!header.IsNull());\n     assert(index < txn_available.size());\n-    return txn_available[index] ? true : false;\n+    return txn_available[index] != nullptr;\n }\n \n ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<CTransactionRef>& vtx_missing) {"
      },
      {
        "sha": "fa884f0bf32ef5d34a85f5712b6a44aa28d007aa",
        "filename": "src/bloom.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -14,12 +14,11 @@\n #include <math.h>\n #include <stdlib.h>\n \n-#include <boost/foreach.hpp>\n \n #define LN2SQUARED 0.4804530139182014246671025263266649717305529515945455\n #define LN2 0.6931471805599453094172321214581765680755001343602552\n \n-CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweakIn, unsigned char nFlagsIn) :\n+CBloomFilter::CBloomFilter(const unsigned int nElements, const double nFPRate, const unsigned int nTweakIn, unsigned char nFlagsIn) :\n     /**\n      * The ideal size for a bloom filter with a given number of elements and false positive rate is:\n      * - nElements * log(fp rate) / ln(2)^2\n@@ -40,7 +39,7 @@ CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int\n }\n \n // Private constructor used by CRollingBloomFilter\n-CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweakIn) :\n+CBloomFilter::CBloomFilter(const unsigned int nElements, const double nFPRate, const unsigned int nTweakIn) :\n     vData((unsigned int)(-1  / LN2SQUARED * nElements * log(nFPRate)) / 8),\n     isFull(false),\n     isEmpty(true),\n@@ -120,7 +119,7 @@ void CBloomFilter::clear()\n     isEmpty = true;\n }\n \n-void CBloomFilter::reset(unsigned int nNewTweak)\n+void CBloomFilter::reset(const unsigned int nNewTweak)\n {\n     clear();\n     nTweak = nNewTweak;\n@@ -179,7 +178,7 @@ bool CBloomFilter::IsRelevantAndUpdate(const CTransaction& tx)\n     if (fFound)\n         return true;\n \n-    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+    for (const CTxIn& txin : tx.vin)\n     {\n         // Match if the filter contains an outpoint tx spends\n         if (contains(txin.prevout))\n@@ -214,7 +213,7 @@ void CBloomFilter::UpdateEmptyFull()\n     isEmpty = empty;\n }\n \n-CRollingBloomFilter::CRollingBloomFilter(unsigned int nElements, double fpRate)\n+CRollingBloomFilter::CRollingBloomFilter(const unsigned int nElements, const double fpRate)\n {\n     double logFpRate = log(fpRate);\n     /* The optimal number of hash functions is log(fpRate) / log(0.5), but"
      },
      {
        "sha": "7ca96822396b909ec076e7f2f562b7d0f1766133",
        "filename": "src/bloom.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bloom.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/bloom.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -54,7 +54,7 @@ class CBloomFilter\n     unsigned int Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const;\n \n     // Private constructor for CRollingBloomFilter, no restrictions on size\n-    CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweak);\n+    CBloomFilter(const unsigned int nElements, const double nFPRate, const unsigned int nTweak);\n     friend class CRollingBloomFilter;\n \n public:\n@@ -67,7 +67,7 @@ class CBloomFilter\n      * It should generally always be a random value (and is largely only exposed for unit testing)\n      * nFlags should be one of the BLOOM_UPDATE_* enums (not _MASK)\n      */\n-    CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweak, unsigned char nFlagsIn);\n+    CBloomFilter(const unsigned int nElements, const double nFPRate, const unsigned int nTweak, unsigned char nFlagsIn);\n     CBloomFilter() : isFull(true), isEmpty(false), nHashFuncs(0), nTweak(0), nFlags(0) {}\n \n     ADD_SERIALIZE_METHODS;\n@@ -89,7 +89,7 @@ class CBloomFilter\n     bool contains(const uint256& hash) const;\n \n     void clear();\n-    void reset(unsigned int nNewTweak);\n+    void reset(const unsigned int nNewTweak);\n \n     //! True if the size is <= MAX_BLOOM_FILTER_SIZE and the number of hash functions is <= MAX_HASH_FUNCS\n     //! (catch a filter which was just deserialized which was too big)\n@@ -122,7 +122,7 @@ class CRollingBloomFilter\n     // A random bloom filter calls GetRand() at creation time.\n     // Don't create global CRollingBloomFilter objects, as they may be\n     // constructed before the randomizer is properly initialized.\n-    CRollingBloomFilter(unsigned int nElements, double nFPRate);\n+    CRollingBloomFilter(const unsigned int nElements, const double nFPRate);\n \n     void insert(const std::vector<unsigned char>& vKey);\n     void insert(const uint256& hash);"
      },
      {
        "sha": "ffd58d471d34b5f9926194446137f4e703742a82",
        "filename": "src/chain.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 1,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -126,7 +126,7 @@ arith_uint256 GetBlockProof(const CBlockIndex& block)\n     if (fNegative || fOverflow || bnTarget == 0)\n         return 0;\n     // We need to compute 2**256 / (bnTarget+1), but we can't represent 2**256\n-    // as it's too large for a arith_uint256. However, as 2**256 is at least as large\n+    // as it's too large for an arith_uint256. However, as 2**256 is at least as large\n     // as bnTarget+1, it is equal to ((2**256 - bnTarget - 1) / (bnTarget+1)) + 1,\n     // or ~bnTarget / (nTarget+1) + 1.\n     return (~bnTarget / (bnTarget + 1)) + 1;\n@@ -148,3 +148,22 @@ int64_t GetBlockProofEquivalentTime(const CBlockIndex& to, const CBlockIndex& fr\n     }\n     return sign * r.GetLow64();\n }\n+\n+/** Find the last common ancestor two blocks have.\n+ *  Both pa and pb must be non-NULL. */\n+const CBlockIndex* LastCommonAncestor(const CBlockIndex* pa, const CBlockIndex* pb) {\n+    if (pa->nHeight > pb->nHeight) {\n+        pa = pa->GetAncestor(pb->nHeight);\n+    } else if (pb->nHeight > pa->nHeight) {\n+        pb = pb->GetAncestor(pa->nHeight);\n+    }\n+\n+    while (pa != pb && pa && pb) {\n+        pa = pa->pprev;\n+        pb = pb->pprev;\n+    }\n+\n+    // Eventually all chain branches meet at the genesis block.\n+    assert(pa == pb);\n+    return pa;\n+}"
      },
      {
        "sha": "c5304b7d6f3e10bb32a1313d88d308ed14813d11",
        "filename": "src/chain.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -362,6 +362,9 @@ class CBlockIndex\n arith_uint256 GetBlockProof(const CBlockIndex& block);\n /** Return the time it would take to redo the work difference between from and to, assuming the current hashrate corresponds to the difficulty at tip, in seconds. */\n int64_t GetBlockProofEquivalentTime(const CBlockIndex& to, const CBlockIndex& from, const CBlockIndex& tip, const Consensus::Params&);\n+/** Find the forking point between two chain tips. */\n+const CBlockIndex* LastCommonAncestor(const CBlockIndex* pa, const CBlockIndex* pb);\n+\n \n /** Used to marshal pointers into hashes for db storage. */\n class CDiskBlockIndex : public CBlockIndex"
      },
      {
        "sha": "2021ec51dbc858d9ce0f21587faebc5d0cb3782d",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 66,
        "deletions": 70,
        "changes": 136,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -12,8 +12,6 @@\n \n #include <assert.h>\n \n-#include <boost/assign/list_of.hpp>\n-\n #include \"chainparamsseeds.h\"\n \n static CBlock CreateGenesisBlock(const char* pszTimestamp, const CScript& genesisOutputScript, uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)\n@@ -55,6 +53,12 @@ static CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, uint32_t nBits\n     return CreateGenesisBlock(pszTimestamp, genesisOutputScript, nTime, nNonce, nBits, nVersion, genesisReward);\n }\n \n+void CChainParams::UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n+{\n+    consensus.vDeployments[d].nStartTime = nStartTime;\n+    consensus.vDeployments[d].nTimeout = nTimeout;\n+}\n+\n /**\n  * Main network\n  */\n@@ -97,10 +101,10 @@ class CMainParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1510704000; // November 15th, 2017.\n \n         // The best chain should have at least this much work.\n-        consensus.nMinimumChainWork = uint256S(\"0x0000000000000000000000000000000000000000003f94d1ad391682fe038bf5\");\n+        consensus.nMinimumChainWork = uint256S(\"0x000000000000000000000000000000000000000000723d3581fe1bd55373540a\");\n \n         // By default assume that the signatures in ancestors of this block are valid.\n-        consensus.defaultAssumeValid = uint256S(\"0x00000000000000000013176bf8d7dfeab4e1db31dc93bc311b436e82ab226b90\"); //453354\n+        consensus.defaultAssumeValid = uint256S(\"0x0000000000000000003b9ce759c2a087d52abc4266f8f4ebd6d768b89defa50a\"); //477890\n \n         /**\n          * The message start string is designed to be unlikely to occur in normal data.\n@@ -120,18 +124,18 @@ class CMainParams : public CChainParams {\n         assert(genesis.hashMerkleRoot == uint256S(\"0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\"));\n \n         // Note that of those with the service bits flag, most only support a subset of possible options\n-        vSeeds.push_back(CDNSSeedData(\"bitcoin.sipa.be\", \"seed.bitcoin.sipa.be\", true)); // Pieter Wuille, only supports x1, x5, x9, and xd\n-        vSeeds.push_back(CDNSSeedData(\"bluematt.me\", \"dnsseed.bluematt.me\", true)); // Matt Corallo, only supports x9\n-        vSeeds.push_back(CDNSSeedData(\"dashjr.org\", \"dnsseed.bitcoin.dashjr.org\")); // Luke Dashjr\n-        vSeeds.push_back(CDNSSeedData(\"bitcoinstats.com\", \"seed.bitcoinstats.com\", true)); // Christian Decker, supports x1 - xf\n-        vSeeds.push_back(CDNSSeedData(\"bitcoin.jonasschnelli.ch\", \"seed.bitcoin.jonasschnelli.ch\", true)); // Jonas Schnelli, only supports x1, x5, x9, and xd\n-        vSeeds.push_back(CDNSSeedData(\"petertodd.org\", \"seed.btc.petertodd.org\", true)); // Peter Todd, only supports x1, x5, x9, and xd\n+        vSeeds.emplace_back(\"seed.bitcoin.sipa.be\", true); // Pieter Wuille, only supports x1, x5, x9, and xd\n+        vSeeds.emplace_back(\"dnsseed.bluematt.me\", true); // Matt Corallo, only supports x9\n+        vSeeds.emplace_back(\"dnsseed.bitcoin.dashjr.org\", false); // Luke Dashjr\n+        vSeeds.emplace_back(\"seed.bitcoinstats.com\", true); // Christian Decker, supports x1 - xf\n+        vSeeds.emplace_back(\"seed.bitcoin.jonasschnelli.ch\", true); // Jonas Schnelli, only supports x1, x5, x9, and xd\n+        vSeeds.emplace_back(\"seed.btc.petertodd.org\", true); // Peter Todd, only supports x1, x5, x9, and xd\n \n         base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,0);\n         base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,5);\n         base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,128);\n-        base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x88)(0xB2)(0x1E).convert_to_container<std::vector<unsigned char> >();\n-        base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x88)(0xAD)(0xE4).convert_to_container<std::vector<unsigned char> >();\n+        base58Prefixes[EXT_PUBLIC_KEY] = {0x04, 0x88, 0xB2, 0x1E};\n+        base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x88, 0xAD, 0xE4};\n \n         vFixedSeeds = std::vector<SeedSpec6>(pnSeed6_main, pnSeed6_main + ARRAYLEN(pnSeed6_main));\n \n@@ -140,32 +144,32 @@ class CMainParams : public CChainParams {\n         fMineBlocksOnDemand = false;\n \n         checkpointData = (CCheckpointData) {\n-            boost::assign::map_list_of\n-            ( 11111, uint256S(\"0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d\"))\n-            ( 33333, uint256S(\"0x000000002dd5588a74784eaa7ab0507a18ad16a236e7b1ce69f00d7ddfb5d0a6\"))\n-            ( 74000, uint256S(\"0x0000000000573993a3c9e41ce34471c079dcf5f52a0e824a81e7f953b8661a20\"))\n-            (105000, uint256S(\"0x00000000000291ce28027faea320c8d2b054b2e0fe44a773f3eefb151d6bdc97\"))\n-            (134444, uint256S(\"0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe\"))\n-            (168000, uint256S(\"0x000000000000099e61ea72015e79632f216fe6cb33d7899acb35b75c8303b763\"))\n-            (193000, uint256S(\"0x000000000000059f452a5f7340de6682a977387c17010ff6e6c3bd83ca8b1317\"))\n-            (210000, uint256S(\"0x000000000000048b95347e83192f69cf0366076336c639f9b7228e9ba171342e\"))\n-            (216116, uint256S(\"0x00000000000001b4f4b433e81ee46494af945cf96014816a4e2370f11b23df4e\"))\n-            (225430, uint256S(\"0x00000000000001c108384350f74090433e7fcf79a606b8e797f065b130575932\"))\n-            (250000, uint256S(\"0x000000000000003887df1f29024b06fc2200b55f8af8f35453d7be294df2d214\"))\n-            (279000, uint256S(\"0x0000000000000001ae8c72a0b0c301f67e3afca10e819efa9041e458e9bd7e40\"))\n-            (295000, uint256S(\"0x00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983\"))\n+            {\n+                { 11111, uint256S(\"0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d\")},\n+                { 33333, uint256S(\"0x000000002dd5588a74784eaa7ab0507a18ad16a236e7b1ce69f00d7ddfb5d0a6\")},\n+                { 74000, uint256S(\"0x0000000000573993a3c9e41ce34471c079dcf5f52a0e824a81e7f953b8661a20\")},\n+                {105000, uint256S(\"0x00000000000291ce28027faea320c8d2b054b2e0fe44a773f3eefb151d6bdc97\")},\n+                {134444, uint256S(\"0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe\")},\n+                {168000, uint256S(\"0x000000000000099e61ea72015e79632f216fe6cb33d7899acb35b75c8303b763\")},\n+                {193000, uint256S(\"0x000000000000059f452a5f7340de6682a977387c17010ff6e6c3bd83ca8b1317\")},\n+                {210000, uint256S(\"0x000000000000048b95347e83192f69cf0366076336c639f9b7228e9ba171342e\")},\n+                {216116, uint256S(\"0x00000000000001b4f4b433e81ee46494af945cf96014816a4e2370f11b23df4e\")},\n+                {225430, uint256S(\"0x00000000000001c108384350f74090433e7fcf79a606b8e797f065b130575932\")},\n+                {250000, uint256S(\"0x000000000000003887df1f29024b06fc2200b55f8af8f35453d7be294df2d214\")},\n+                {279000, uint256S(\"0x0000000000000001ae8c72a0b0c301f67e3afca10e819efa9041e458e9bd7e40\")},\n+                {295000, uint256S(\"0x00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983\")},\n+            }\n         };\n \n         chainTxData = ChainTxData{\n-            // Data as of block 00000000000000000166d612d5595e2b1cd88d71d695fc580af64d8da8658c23 (height 446482).\n-            1483472411, // * UNIX timestamp of last known number of transactions\n-            184495391,  // * total number of transactions between genesis and that timestamp\n+            // Data as of block 000000000000000000d97e53664d17967bd4ee50b23abb92e54a34eb222d15ae (height 478913).\n+            1501801925, // * UNIX timestamp of last known number of transactions\n+            243756039,  // * total number of transactions between genesis and that timestamp\n                         //   (the tx=... number in the SetBestChain debug.log lines)\n-            3.2         // * estimated number of transactions per second after that timestamp\n+            3.1         // * estimated number of transactions per second after that timestamp\n         };\n     }\n };\n-static CMainParams mainParams;\n \n /**\n  * Testnet (v3)\n@@ -201,10 +205,10 @@ class CTestNetParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1493596800; // May 1st 2017\n \n         // The best chain should have at least this much work.\n-        consensus.nMinimumChainWork = uint256S(\"0x00000000000000000000000000000000000000000000001f057509eba81aed91\");\n+        consensus.nMinimumChainWork = uint256S(\"0x00000000000000000000000000000000000000000000002830dab7f76dbb7d63\");\n \n         // By default assume that the signatures in ancestors of this block are valid.\n-        consensus.defaultAssumeValid = uint256S(\"0x00000000000128796ee387cf110ccb9d2f36cffaf7f73079c995377c65ac0dcc\"); //1079274\n+        consensus.defaultAssumeValid = uint256S(\"0x0000000002e9e7b00e1f6dc5123a04aad68dd0f0968d8c7aa45f6640795c37b1\"); //1135275\n \n         pchMessageStart[0] = 0x0b;\n         pchMessageStart[1] = 0x11;\n@@ -221,16 +225,16 @@ class CTestNetParams : public CChainParams {\n         vFixedSeeds.clear();\n         vSeeds.clear();\n         // nodes with support for servicebits filtering should be at the top\n-        vSeeds.push_back(CDNSSeedData(\"testnetbitcoin.jonasschnelli.ch\", \"testnet-seed.bitcoin.jonasschnelli.ch\", true));\n-        vSeeds.push_back(CDNSSeedData(\"petertodd.org\", \"seed.tbtc.petertodd.org\", true));\n-        vSeeds.push_back(CDNSSeedData(\"bluematt.me\", \"testnet-seed.bluematt.me\"));\n-        vSeeds.push_back(CDNSSeedData(\"bitcoin.schildbach.de\", \"testnet-seed.bitcoin.schildbach.de\"));\n+        vSeeds.emplace_back(\"testnet-seed.bitcoin.jonasschnelli.ch\", true);\n+        vSeeds.emplace_back(\"seed.tbtc.petertodd.org\", true);\n+        vSeeds.emplace_back(\"testnet-seed.bluematt.me\", false);\n+        vSeeds.emplace_back(\"testnet-seed.bitcoin.schildbach.de\", false);\n \n         base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);\n         base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);\n         base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,239);\n-        base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x35)(0x87)(0xCF).convert_to_container<std::vector<unsigned char> >();\n-        base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x35)(0x83)(0x94).convert_to_container<std::vector<unsigned char> >();\n+        base58Prefixes[EXT_PUBLIC_KEY] = {0x04, 0x35, 0x87, 0xCF};\n+        base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x35, 0x83, 0x94};\n \n         vFixedSeeds = std::vector<SeedSpec6>(pnSeed6_test, pnSeed6_test + ARRAYLEN(pnSeed6_test));\n \n@@ -240,20 +244,20 @@ class CTestNetParams : public CChainParams {\n \n \n         checkpointData = (CCheckpointData) {\n-            boost::assign::map_list_of\n-            ( 546, uint256S(\"000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70\")),\n+            {\n+                {546, uint256S(\"000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70\")},\n+            }\n         };\n \n         chainTxData = ChainTxData{\n-            // Data as of block 00000000c2872f8f8a8935c8e3c5862be9038c97d4de2cf37ed496991166928a (height 1063660)\n-            1483546230,\n-            12834668,\n+            // Data as of block 00000000000001c200b9790dc637d3bb141fe77d155b966ed775b17e109f7c6c (height 1156179)\n+            1501802953,\n+            14706531,\n             0.15\n         };\n \n     }\n };\n-static CTestNetParams testNetParams;\n \n /**\n  * Regression test\n@@ -309,9 +313,10 @@ class CRegTestParams : public CChainParams {\n         fRequireStandard = false;\n         fMineBlocksOnDemand = true;\n \n-        checkpointData = (CCheckpointData){\n-            boost::assign::map_list_of\n-            ( 0, uint256S(\"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\"))\n+        checkpointData = (CCheckpointData) {\n+            {\n+                {0, uint256S(\"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\")},\n+            }\n         };\n \n         chainTxData = ChainTxData{\n@@ -323,45 +328,36 @@ class CRegTestParams : public CChainParams {\n         base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);\n         base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);\n         base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,239);\n-        base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x35)(0x87)(0xCF).convert_to_container<std::vector<unsigned char> >();\n-        base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x35)(0x83)(0x94).convert_to_container<std::vector<unsigned char> >();\n-    }\n-\n-    void UpdateBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n-    {\n-        consensus.vDeployments[d].nStartTime = nStartTime;\n-        consensus.vDeployments[d].nTimeout = nTimeout;\n+        base58Prefixes[EXT_PUBLIC_KEY] = {0x04, 0x35, 0x87, 0xCF};\n+        base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x35, 0x83, 0x94};\n     }\n };\n-static CRegTestParams regTestParams;\n \n-static CChainParams *pCurrentParams = 0;\n+static std::unique_ptr<CChainParams> globalChainParams;\n \n const CChainParams &Params() {\n-    assert(pCurrentParams);\n-    return *pCurrentParams;\n+    assert(globalChainParams);\n+    return *globalChainParams;\n }\n \n-CChainParams& Params(const std::string& chain)\n+std::unique_ptr<CChainParams> CreateChainParams(const std::string& chain)\n {\n     if (chain == CBaseChainParams::MAIN)\n-            return mainParams;\n+        return std::unique_ptr<CChainParams>(new CMainParams());\n     else if (chain == CBaseChainParams::TESTNET)\n-            return testNetParams;\n+        return std::unique_ptr<CChainParams>(new CTestNetParams());\n     else if (chain == CBaseChainParams::REGTEST)\n-            return regTestParams;\n-    else\n-        throw std::runtime_error(strprintf(\"%s: Unknown chain %s.\", __func__, chain));\n+        return std::unique_ptr<CChainParams>(new CRegTestParams());\n+    throw std::runtime_error(strprintf(\"%s: Unknown chain %s.\", __func__, chain));\n }\n \n void SelectParams(const std::string& network)\n {\n     SelectBaseParams(network);\n-    pCurrentParams = &Params(network);\n+    globalChainParams = CreateChainParams(network);\n }\n \n-void UpdateRegtestBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n+void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n {\n-    regTestParams.UpdateBIP9Parameters(d, nStartTime, nTimeout);\n+    globalChainParams->UpdateVersionBitsParameters(d, nStartTime, nTimeout);\n }\n- "
      },
      {
        "sha": "f55ae4cf7f068f8884f976c7a6c431bb7a778bcb",
        "filename": "src/chainparams.h",
        "status": "modified",
        "additions": 13,
        "deletions": 9,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/chainparams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/chainparams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -11,12 +11,13 @@\n #include \"primitives/block.h\"\n #include \"protocol.h\"\n \n+#include <memory>\n #include <vector>\n \n struct CDNSSeedData {\n-    std::string name, host;\n+    std::string host;\n     bool supportsServiceBitsFiltering;\n-    CDNSSeedData(const std::string &strName, const std::string &strHost, bool supportsServiceBitsFilteringIn = false) : name(strName), host(strHost), supportsServiceBitsFiltering(supportsServiceBitsFilteringIn) {}\n+    CDNSSeedData(const std::string &strHost, bool supportsServiceBitsFilteringIn) : host(strHost), supportsServiceBitsFiltering(supportsServiceBitsFilteringIn) {}\n };\n \n struct SeedSpec6 {\n@@ -75,6 +76,7 @@ class CChainParams\n     const std::vector<SeedSpec6>& FixedSeeds() const { return vFixedSeeds; }\n     const CCheckpointData& Checkpoints() const { return checkpointData; }\n     const ChainTxData& TxData() const { return chainTxData; }\n+    void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);\n protected:\n     CChainParams() {}\n \n@@ -95,15 +97,17 @@ class CChainParams\n };\n \n /**\n- * Return the currently selected parameters. This won't change after app\n- * startup, except for unit tests.\n+ * Creates and returns a std::unique_ptr<CChainParams> of the chosen chain.\n+ * @returns a CChainParams* of the chosen chain.\n+ * @throws a std::runtime_error if the chain is not supported.\n  */\n-const CChainParams &Params();\n+std::unique_ptr<CChainParams> CreateChainParams(const std::string& chain);\n \n /**\n- * @returns CChainParams for the given BIP70 chain name.\n+ * Return the currently selected parameters. This won't change after app\n+ * startup, except for unit tests.\n  */\n-CChainParams& Params(const std::string& chain);\n+const CChainParams &Params();\n \n /**\n  * Sets the params returned by Params() to those for the given BIP70 chain name.\n@@ -112,8 +116,8 @@ CChainParams& Params(const std::string& chain);\n void SelectParams(const std::string& chain);\n \n /**\n- * Allows modifying the BIP9 regtest parameters.\n+ * Allows modifying the Version Bits regtest parameters.\n  */\n-void UpdateRegtestBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);\n+void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);\n \n #endif // BITCOIN_CHAINPARAMS_H"
      },
      {
        "sha": "43c9a13c5468b8e01e1f25f5d9b91d6aa8d8a392",
        "filename": "src/chainparamsbase.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 16,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/chainparamsbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/chainparamsbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -35,7 +35,6 @@ class CBaseMainParams : public CBaseChainParams\n         nRPCPort = 8332;\n     }\n };\n-static CBaseMainParams mainParams;\n \n /**\n  * Testnet (v3)\n@@ -49,7 +48,6 @@ class CBaseTestNetParams : public CBaseChainParams\n         strDataDir = \"testnet3\";\n     }\n };\n-static CBaseTestNetParams testNetParams;\n \n /*\n  * Regression test\n@@ -63,31 +61,30 @@ class CBaseRegTestParams : public CBaseChainParams\n         strDataDir = \"regtest\";\n     }\n };\n-static CBaseRegTestParams regTestParams;\n \n-static CBaseChainParams* pCurrentBaseParams = 0;\n+static std::unique_ptr<CBaseChainParams> globalChainBaseParams;\n \n const CBaseChainParams& BaseParams()\n {\n-    assert(pCurrentBaseParams);\n-    return *pCurrentBaseParams;\n+    assert(globalChainBaseParams);\n+    return *globalChainBaseParams;\n }\n \n-CBaseChainParams& BaseParams(const std::string& chain)\n+std::unique_ptr<CBaseChainParams> CreateBaseChainParams(const std::string& chain)\n {\n     if (chain == CBaseChainParams::MAIN)\n-        return mainParams;\n+        return std::unique_ptr<CBaseChainParams>(new CBaseMainParams());\n     else if (chain == CBaseChainParams::TESTNET)\n-        return testNetParams;\n+        return std::unique_ptr<CBaseChainParams>(new CBaseTestNetParams());\n     else if (chain == CBaseChainParams::REGTEST)\n-        return regTestParams;\n+        return std::unique_ptr<CBaseChainParams>(new CBaseRegTestParams());\n     else\n         throw std::runtime_error(strprintf(\"%s: Unknown chain %s.\", __func__, chain));\n }\n \n void SelectBaseParams(const std::string& chain)\n {\n-    pCurrentBaseParams = &BaseParams(chain);\n+    globalChainBaseParams = CreateBaseChainParams(chain);\n }\n \n std::string ChainNameFromCommandLine()\n@@ -103,8 +100,3 @@ std::string ChainNameFromCommandLine()\n         return CBaseChainParams::TESTNET;\n     return CBaseChainParams::MAIN;\n }\n-\n-bool AreBaseParamsConfigured()\n-{\n-    return pCurrentBaseParams != NULL;\n-}"
      },
      {
        "sha": "fc101f5b774c23a483c26dab115ac2675514ec11",
        "filename": "src/chainparamsbase.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/chainparamsbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/chainparamsbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -5,6 +5,7 @@\n #ifndef BITCOIN_CHAINPARAMSBASE_H\n #define BITCOIN_CHAINPARAMSBASE_H\n \n+#include <memory>\n #include <string>\n #include <vector>\n \n@@ -30,6 +31,13 @@ class CBaseChainParams\n     std::string strDataDir;\n };\n \n+/**\n+ * Creates and returns a std::unique_ptr<CBaseChainParams> of the chosen chain.\n+ * @returns a CBaseChainParams* of the chosen chain.\n+ * @throws a std::runtime_error if the chain is not supported.\n+ */\n+std::unique_ptr<CBaseChainParams> CreateBaseChainParams(const std::string& chain);\n+\n /**\n  * Append the help messages for the chainparams options to the\n  * parameter string.\n@@ -42,8 +50,6 @@ void AppendParamsHelpMessages(std::string& strUsage, bool debugHelp=true);\n  */\n const CBaseChainParams& BaseParams();\n \n-CBaseChainParams& BaseParams(const std::string& chain);\n-\n /** Sets the params returned by Params() to those for the given network. */\n void SelectBaseParams(const std::string& chain);\n \n@@ -53,10 +59,4 @@ void SelectBaseParams(const std::string& chain);\n  */\n std::string ChainNameFromCommandLine();\n \n-/**\n- * Return true if SelectBaseParamsFromCommandLine() has been called to select\n- * a network.\n- */\n-bool AreBaseParamsConfigured();\n-\n #endif // BITCOIN_CHAINPARAMSBASE_H"
      },
      {
        "sha": "2c99ca8ab09cbf81a388eabbcddb9ebc8735a52e",
        "filename": "src/chainparamsseeds.h",
        "status": "modified",
        "additions": 1168,
        "deletions": 886,
        "changes": 2054,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/chainparamsseeds.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/chainparamsseeds.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsseeds.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "e6b5fb72a77ca3328ad9a41b1f8da887e3bcd8f4",
        "filename": "src/checkpoints.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/checkpoints.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/checkpoints.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkpoints.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -6,20 +6,20 @@\n \n #include \"chain.h\"\n #include \"chainparams.h\"\n+#include \"reverse_iterator.h\"\n #include \"validation.h\"\n #include \"uint256.h\"\n \n #include <stdint.h>\n \n-#include <boost/foreach.hpp>\n \n namespace Checkpoints {\n \n     CBlockIndex* GetLastCheckpoint(const CCheckpointData& data)\n     {\n         const MapCheckpoints& checkpoints = data.mapCheckpoints;\n \n-        BOOST_REVERSE_FOREACH(const MapCheckpoints::value_type& i, checkpoints)\n+        for (const MapCheckpoints::value_type& i : reverse_iterate(checkpoints))\n         {\n             const uint256& hash = i.second;\n             BlockMap::const_iterator t = mapBlockIndex.find(hash);"
      },
      {
        "sha": "408e278d216271daa09dc22ede258e53b45276ac",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -5,12 +5,12 @@\n #ifndef BITCOIN_CHECKQUEUE_H\n #define BITCOIN_CHECKQUEUE_H\n \n+#include \"sync.h\"\n+\n #include <algorithm>\n #include <vector>\n \n-#include <boost/foreach.hpp>\n #include <boost/thread/condition_variable.hpp>\n-#include <boost/thread/locks.hpp>\n #include <boost/thread/mutex.hpp>\n \n template <typename T>\n@@ -119,7 +119,7 @@ class CCheckQueue\n                 fOk = fAllOk;\n             }\n             // execute work\n-            BOOST_FOREACH (T& check, vChecks)\n+            for (T& check : vChecks)\n                 if (fOk)\n                     fOk = check();\n             vChecks.clear();\n@@ -149,7 +149,7 @@ class CCheckQueue\n     void Add(std::vector<T>& vChecks)\n     {\n         boost::unique_lock<boost::mutex> lock(mutex);\n-        BOOST_FOREACH (T& check, vChecks) {\n+        for (T& check : vChecks) {\n             queue.push_back(T());\n             check.swap(queue.back());\n         }"
      },
      {
        "sha": "e30bda930ae6c9e24ea2d121b36ac3157e341745",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 100,
        "deletions": 159,
        "changes": 259,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -4,175 +4,135 @@\n \n #include \"coins.h\"\n \n+#include \"consensus/consensus.h\"\n #include \"memusage.h\"\n #include \"random.h\"\n \n #include <assert.h>\n \n-/**\n- * calculate number of bytes for the bitmask, and its number of non-zero bytes\n- * each bit in the bitmask represents the availability of one output, but the\n- * availabilities of the first two outputs are encoded separately\n- */\n-void CCoins::CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) const {\n-    unsigned int nLastUsedByte = 0;\n-    for (unsigned int b = 0; 2+b*8 < vout.size(); b++) {\n-        bool fZero = true;\n-        for (unsigned int i = 0; i < 8 && 2+b*8+i < vout.size(); i++) {\n-            if (!vout[2+b*8+i].IsNull()) {\n-                fZero = false;\n-                continue;\n-            }\n-        }\n-        if (!fZero) {\n-            nLastUsedByte = b + 1;\n-            nNonzeroBytes++;\n-        }\n-    }\n-    nBytes += nLastUsedByte;\n-}\n-\n-bool CCoins::Spend(uint32_t nPos) \n-{\n-    if (nPos >= vout.size() || vout[nPos].IsNull())\n-        return false;\n-    vout[nPos].SetNull();\n-    Cleanup();\n-    return true;\n-}\n-\n-bool CCoinsView::GetCoins(const uint256 &txid, CCoins &coins) const { return false; }\n-bool CCoinsView::HaveCoins(const uint256 &txid) const { return false; }\n+bool CCoinsView::GetCoin(const COutPoint &outpoint, Coin &coin) const { return false; }\n uint256 CCoinsView::GetBestBlock() const { return uint256(); }\n+std::vector<uint256> CCoinsView::GetHeadBlocks() const { return std::vector<uint256>(); }\n bool CCoinsView::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return false; }\n CCoinsViewCursor *CCoinsView::Cursor() const { return 0; }\n \n+bool CCoinsView::HaveCoin(const COutPoint &outpoint) const\n+{\n+    Coin coin;\n+    return GetCoin(outpoint, coin);\n+}\n \n CCoinsViewBacked::CCoinsViewBacked(CCoinsView *viewIn) : base(viewIn) { }\n-bool CCoinsViewBacked::GetCoins(const uint256 &txid, CCoins &coins) const { return base->GetCoins(txid, coins); }\n-bool CCoinsViewBacked::HaveCoins(const uint256 &txid) const { return base->HaveCoins(txid); }\n+bool CCoinsViewBacked::GetCoin(const COutPoint &outpoint, Coin &coin) const { return base->GetCoin(outpoint, coin); }\n+bool CCoinsViewBacked::HaveCoin(const COutPoint &outpoint) const { return base->HaveCoin(outpoint); }\n uint256 CCoinsViewBacked::GetBestBlock() const { return base->GetBestBlock(); }\n+std::vector<uint256> CCoinsViewBacked::GetHeadBlocks() const { return base->GetHeadBlocks(); }\n void CCoinsViewBacked::SetBackend(CCoinsView &viewIn) { base = &viewIn; }\n bool CCoinsViewBacked::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return base->BatchWrite(mapCoins, hashBlock); }\n CCoinsViewCursor *CCoinsViewBacked::Cursor() const { return base->Cursor(); }\n+size_t CCoinsViewBacked::EstimateSize() const { return base->EstimateSize(); }\n \n-SaltedTxidHasher::SaltedTxidHasher() : k0(GetRand(std::numeric_limits<uint64_t>::max())), k1(GetRand(std::numeric_limits<uint64_t>::max())) {}\n-\n-CCoinsViewCache::CCoinsViewCache(CCoinsView *baseIn) : CCoinsViewBacked(baseIn), hasModifier(false), cachedCoinsUsage(0) { }\n+SaltedOutpointHasher::SaltedOutpointHasher() : k0(GetRand(std::numeric_limits<uint64_t>::max())), k1(GetRand(std::numeric_limits<uint64_t>::max())) {}\n \n-CCoinsViewCache::~CCoinsViewCache()\n-{\n-    assert(!hasModifier);\n-}\n+CCoinsViewCache::CCoinsViewCache(CCoinsView *baseIn) : CCoinsViewBacked(baseIn), cachedCoinsUsage(0) {}\n \n size_t CCoinsViewCache::DynamicMemoryUsage() const {\n     return memusage::DynamicUsage(cacheCoins) + cachedCoinsUsage;\n }\n \n-CCoinsMap::const_iterator CCoinsViewCache::FetchCoins(const uint256 &txid) const {\n-    CCoinsMap::iterator it = cacheCoins.find(txid);\n+CCoinsMap::iterator CCoinsViewCache::FetchCoin(const COutPoint &outpoint) const {\n+    CCoinsMap::iterator it = cacheCoins.find(outpoint);\n     if (it != cacheCoins.end())\n         return it;\n-    CCoins tmp;\n-    if (!base->GetCoins(txid, tmp))\n+    Coin tmp;\n+    if (!base->GetCoin(outpoint, tmp))\n         return cacheCoins.end();\n-    CCoinsMap::iterator ret = cacheCoins.insert(std::make_pair(txid, CCoinsCacheEntry())).first;\n-    tmp.swap(ret->second.coins);\n-    if (ret->second.coins.IsPruned()) {\n-        // The parent only has an empty entry for this txid; we can consider our\n+    CCoinsMap::iterator ret = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::forward_as_tuple(std::move(tmp))).first;\n+    if (ret->second.coin.IsSpent()) {\n+        // The parent only has an empty entry for this outpoint; we can consider our\n         // version as fresh.\n         ret->second.flags = CCoinsCacheEntry::FRESH;\n     }\n-    cachedCoinsUsage += ret->second.coins.DynamicMemoryUsage();\n+    cachedCoinsUsage += ret->second.coin.DynamicMemoryUsage();\n     return ret;\n }\n \n-bool CCoinsViewCache::GetCoins(const uint256 &txid, CCoins &coins) const {\n-    CCoinsMap::const_iterator it = FetchCoins(txid);\n+bool CCoinsViewCache::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n+    CCoinsMap::const_iterator it = FetchCoin(outpoint);\n     if (it != cacheCoins.end()) {\n-        coins = it->second.coins;\n-        return true;\n+        coin = it->second.coin;\n+        return !coin.IsSpent();\n     }\n     return false;\n }\n \n-CCoinsModifier CCoinsViewCache::ModifyCoins(const uint256 &txid) {\n-    assert(!hasModifier);\n-    std::pair<CCoinsMap::iterator, bool> ret = cacheCoins.insert(std::make_pair(txid, CCoinsCacheEntry()));\n-    size_t cachedCoinUsage = 0;\n-    if (ret.second) {\n-        if (!base->GetCoins(txid, ret.first->second.coins)) {\n-            // The parent view does not have this entry; mark it as fresh.\n-            ret.first->second.coins.Clear();\n-            ret.first->second.flags = CCoinsCacheEntry::FRESH;\n-        } else if (ret.first->second.coins.IsPruned()) {\n-            // The parent view only has a pruned entry for this; mark it as fresh.\n-            ret.first->second.flags = CCoinsCacheEntry::FRESH;\n+void CCoinsViewCache::AddCoin(const COutPoint &outpoint, Coin&& coin, bool possible_overwrite) {\n+    assert(!coin.IsSpent());\n+    if (coin.out.scriptPubKey.IsUnspendable()) return;\n+    CCoinsMap::iterator it;\n+    bool inserted;\n+    std::tie(it, inserted) = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::tuple<>());\n+    bool fresh = false;\n+    if (!inserted) {\n+        cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n+    }\n+    if (!possible_overwrite) {\n+        if (!it->second.coin.IsSpent()) {\n+            throw std::logic_error(\"Adding new coin that replaces non-pruned entry\");\n         }\n-    } else {\n-        cachedCoinUsage = ret.first->second.coins.DynamicMemoryUsage();\n+        fresh = !(it->second.flags & CCoinsCacheEntry::DIRTY);\n     }\n-    // Assume that whenever ModifyCoins is called, the entry will be modified.\n-    ret.first->second.flags |= CCoinsCacheEntry::DIRTY;\n-    return CCoinsModifier(*this, ret.first, cachedCoinUsage);\n+    it->second.coin = std::move(coin);\n+    it->second.flags |= CCoinsCacheEntry::DIRTY | (fresh ? CCoinsCacheEntry::FRESH : 0);\n+    cachedCoinsUsage += it->second.coin.DynamicMemoryUsage();\n }\n \n-/* ModifyNewCoins allows for faster coin modification when creating the new\n- * outputs from a transaction.  It assumes that BIP 30 (no duplicate txids)\n- * applies and has already been tested for (or the test is not required due to\n- * BIP 34, height in coinbase).  If we can assume BIP 30 then we know that any\n- * non-coinbase transaction we are adding to the UTXO must not already exist in\n- * the utxo unless it is fully spent.  Thus we can check only if it exists DIRTY\n- * at the current level of the cache, in which case it is not safe to mark it\n- * FRESH (b/c then its spentness still needs to flushed).  If it's not dirty and\n- * doesn't exist or is pruned in the current cache, we know it either doesn't\n- * exist or is pruned in parent caches, which is the definition of FRESH.  The\n- * exception to this is the two historical violations of BIP 30 in the chain,\n- * both of which were coinbases.  We do not mark these fresh so we we can ensure\n- * that they will still be properly overwritten when spent.\n- */\n-CCoinsModifier CCoinsViewCache::ModifyNewCoins(const uint256 &txid, bool coinbase) {\n-    assert(!hasModifier);\n-    std::pair<CCoinsMap::iterator, bool> ret = cacheCoins.insert(std::make_pair(txid, CCoinsCacheEntry()));\n-    if (!coinbase) {\n-        // New coins must not already exist.\n-        if (!ret.first->second.coins.IsPruned())\n-            throw std::logic_error(\"ModifyNewCoins should not find pre-existing coins on a non-coinbase unless they are pruned!\");\n+void AddCoins(CCoinsViewCache& cache, const CTransaction &tx, int nHeight, bool check) {\n+    bool fCoinbase = tx.IsCoinBase();\n+    const uint256& txid = tx.GetHash();\n+    for (size_t i = 0; i < tx.vout.size(); ++i) {\n+        bool overwrite = check ? cache.HaveCoin(COutPoint(txid, i)) : fCoinbase;\n+        // Always set the possible_overwrite flag to AddCoin for coinbase txn, in order to correctly\n+        // deal with the pre-BIP30 occurrences of duplicate coinbase transactions.\n+        cache.AddCoin(COutPoint(txid, i), Coin(tx.vout[i], nHeight, fCoinbase), overwrite);\n+    }\n+}\n \n-        if (!(ret.first->second.flags & CCoinsCacheEntry::DIRTY)) {\n-            // If the coin is known to be pruned (have no unspent outputs) in\n-            // the current view and the cache entry is not dirty, we know the\n-            // coin also must be pruned in the parent view as well, so it is safe\n-            // to mark this fresh.\n-            ret.first->second.flags |= CCoinsCacheEntry::FRESH;\n-        }\n+bool CCoinsViewCache::SpendCoin(const COutPoint &outpoint, Coin* moveout) {\n+    CCoinsMap::iterator it = FetchCoin(outpoint);\n+    if (it == cacheCoins.end()) return false;\n+    cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n+    if (moveout) {\n+        *moveout = std::move(it->second.coin);\n+    }\n+    if (it->second.flags & CCoinsCacheEntry::FRESH) {\n+        cacheCoins.erase(it);\n+    } else {\n+        it->second.flags |= CCoinsCacheEntry::DIRTY;\n+        it->second.coin.Clear();\n     }\n-    ret.first->second.coins.Clear();\n-    ret.first->second.flags |= CCoinsCacheEntry::DIRTY;\n-    return CCoinsModifier(*this, ret.first, 0);\n+    return true;\n }\n \n-const CCoins* CCoinsViewCache::AccessCoins(const uint256 &txid) const {\n-    CCoinsMap::const_iterator it = FetchCoins(txid);\n+static const Coin coinEmpty;\n+\n+const Coin& CCoinsViewCache::AccessCoin(const COutPoint &outpoint) const {\n+    CCoinsMap::const_iterator it = FetchCoin(outpoint);\n     if (it == cacheCoins.end()) {\n-        return NULL;\n+        return coinEmpty;\n     } else {\n-        return &it->second.coins;\n+        return it->second.coin;\n     }\n }\n \n-bool CCoinsViewCache::HaveCoins(const uint256 &txid) const {\n-    CCoinsMap::const_iterator it = FetchCoins(txid);\n-    // We're using vtx.empty() instead of IsPruned here for performance reasons,\n-    // as we only care about the case where a transaction was replaced entirely\n-    // in a reorganization (which wipes vout entirely, as opposed to spending\n-    // which just cleans individual outputs).\n-    return (it != cacheCoins.end() && !it->second.coins.vout.empty());\n+bool CCoinsViewCache::HaveCoin(const COutPoint &outpoint) const {\n+    CCoinsMap::const_iterator it = FetchCoin(outpoint);\n+    return (it != cacheCoins.end() && !it->second.coin.IsSpent());\n }\n \n-bool CCoinsViewCache::HaveCoinsInCache(const uint256 &txid) const {\n-    CCoinsMap::const_iterator it = cacheCoins.find(txid);\n-    return it != cacheCoins.end();\n+bool CCoinsViewCache::HaveCoinInCache(const COutPoint &outpoint) const {\n+    CCoinsMap::const_iterator it = cacheCoins.find(outpoint);\n+    return (it != cacheCoins.end() && !it->second.coin.IsSpent());\n }\n \n uint256 CCoinsViewCache::GetBestBlock() const {\n@@ -186,19 +146,18 @@ void CCoinsViewCache::SetBestBlock(const uint256 &hashBlockIn) {\n }\n \n bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn) {\n-    assert(!hasModifier);\n     for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {\n         if (it->second.flags & CCoinsCacheEntry::DIRTY) { // Ignore non-dirty entries (optimization).\n             CCoinsMap::iterator itUs = cacheCoins.find(it->first);\n             if (itUs == cacheCoins.end()) {\n                 // The parent cache does not have an entry, while the child does\n                 // We can ignore it if it's both FRESH and pruned in the child\n-                if (!(it->second.flags & CCoinsCacheEntry::FRESH && it->second.coins.IsPruned())) {\n+                if (!(it->second.flags & CCoinsCacheEntry::FRESH && it->second.coin.IsSpent())) {\n                     // Otherwise we will need to create it in the parent\n                     // and move the data up and mark it as dirty\n                     CCoinsCacheEntry& entry = cacheCoins[it->first];\n-                    entry.coins.swap(it->second.coins);\n-                    cachedCoinsUsage += entry.coins.DynamicMemoryUsage();\n+                    entry.coin = std::move(it->second.coin);\n+                    cachedCoinsUsage += entry.coin.DynamicMemoryUsage();\n                     entry.flags = CCoinsCacheEntry::DIRTY;\n                     // We can mark it FRESH in the parent if it was FRESH in the child\n                     // Otherwise it might have just been flushed from the parent's cache\n@@ -211,21 +170,21 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n                 // parent cache entry has unspent outputs. If this ever happens,\n                 // it means the FRESH flag was misapplied and there is a logic\n                 // error in the calling code.\n-                if ((it->second.flags & CCoinsCacheEntry::FRESH) && !itUs->second.coins.IsPruned())\n+                if ((it->second.flags & CCoinsCacheEntry::FRESH) && !itUs->second.coin.IsSpent())\n                     throw std::logic_error(\"FRESH flag misapplied to cache entry for base transaction with spendable outputs\");\n \n                 // Found the entry in the parent cache\n-                if ((itUs->second.flags & CCoinsCacheEntry::FRESH) && it->second.coins.IsPruned()) {\n+                if ((itUs->second.flags & CCoinsCacheEntry::FRESH) && it->second.coin.IsSpent()) {\n                     // The grandparent does not have an entry, and the child is\n                     // modified and being pruned. This means we can just delete\n                     // it from the parent.\n-                    cachedCoinsUsage -= itUs->second.coins.DynamicMemoryUsage();\n+                    cachedCoinsUsage -= itUs->second.coin.DynamicMemoryUsage();\n                     cacheCoins.erase(itUs);\n                 } else {\n                     // A normal modification.\n-                    cachedCoinsUsage -= itUs->second.coins.DynamicMemoryUsage();\n-                    itUs->second.coins.swap(it->second.coins);\n-                    cachedCoinsUsage += itUs->second.coins.DynamicMemoryUsage();\n+                    cachedCoinsUsage -= itUs->second.coin.DynamicMemoryUsage();\n+                    itUs->second.coin = std::move(it->second.coin);\n+                    cachedCoinsUsage += itUs->second.coin.DynamicMemoryUsage();\n                     itUs->second.flags |= CCoinsCacheEntry::DIRTY;\n                     // NOTE: It is possible the child has a FRESH flag here in\n                     // the event the entry we found in the parent is pruned. But\n@@ -249,11 +208,11 @@ bool CCoinsViewCache::Flush() {\n     return fOk;\n }\n \n-void CCoinsViewCache::Uncache(const uint256& hash)\n+void CCoinsViewCache::Uncache(const COutPoint& hash)\n {\n     CCoinsMap::iterator it = cacheCoins.find(hash);\n     if (it != cacheCoins.end() && it->second.flags == 0) {\n-        cachedCoinsUsage -= it->second.coins.DynamicMemoryUsage();\n+        cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n         cacheCoins.erase(it);\n     }\n }\n@@ -262,21 +221,14 @@ unsigned int CCoinsViewCache::GetCacheSize() const {\n     return cacheCoins.size();\n }\n \n-const CTxOut &CCoinsViewCache::GetOutputFor(const CTxIn& input) const\n-{\n-    const CCoins* coins = AccessCoins(input.prevout.hash);\n-    assert(coins && coins->IsAvailable(input.prevout.n));\n-    return coins->vout[input.prevout.n];\n-}\n-\n CAmount CCoinsViewCache::GetValueIn(const CTransaction& tx) const\n {\n     if (tx.IsCoinBase())\n         return 0;\n \n     CAmount nResult = 0;\n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n-        nResult += GetOutputFor(tx.vin[i]).nValue;\n+        nResult += AccessCoin(tx.vin[i].prevout).out.nValue;\n \n     return nResult;\n }\n@@ -285,35 +237,24 @@ bool CCoinsViewCache::HaveInputs(const CTransaction& tx) const\n {\n     if (!tx.IsCoinBase()) {\n         for (unsigned int i = 0; i < tx.vin.size(); i++) {\n-            const COutPoint &prevout = tx.vin[i].prevout;\n-            const CCoins* coins = AccessCoins(prevout.hash);\n-            if (!coins || !coins->IsAvailable(prevout.n)) {\n+            if (!HaveCoin(tx.vin[i].prevout)) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n \n-CCoinsModifier::CCoinsModifier(CCoinsViewCache& cache_, CCoinsMap::iterator it_, size_t usage) : cache(cache_), it(it_), cachedCoinUsage(usage) {\n-    assert(!cache.hasModifier);\n-    cache.hasModifier = true;\n-}\n+static const size_t MIN_TRANSACTION_OUTPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxOut(), SER_NETWORK, PROTOCOL_VERSION);\n+static const size_t MAX_OUTPUTS_PER_BLOCK = MAX_BLOCK_WEIGHT / MIN_TRANSACTION_OUTPUT_WEIGHT;\n \n-CCoinsModifier::~CCoinsModifier()\n+const Coin& AccessByTxid(const CCoinsViewCache& view, const uint256& txid)\n {\n-    assert(cache.hasModifier);\n-    cache.hasModifier = false;\n-    it->second.coins.Cleanup();\n-    cache.cachedCoinsUsage -= cachedCoinUsage; // Subtract the old usage\n-    if ((it->second.flags & CCoinsCacheEntry::FRESH) && it->second.coins.IsPruned()) {\n-        cache.cacheCoins.erase(it);\n-    } else {\n-        // If the coin still exists after the modification, add the new usage\n-        cache.cachedCoinsUsage += it->second.coins.DynamicMemoryUsage();\n+    COutPoint iter(txid, 0);\n+    while (iter.n < MAX_OUTPUTS_PER_BLOCK) {\n+        const Coin& alternate = view.AccessCoin(iter);\n+        if (!alternate.IsSpent()) return alternate;\n+        ++iter.n;\n     }\n-}\n-\n-CCoinsViewCursor::~CCoinsViewCursor()\n-{\n+    return coinEmpty;\n }"
      },
      {
        "sha": "efb5ce869c3fc13365cc07e436b75c2a7364d3dd",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 110,
        "deletions": 271,
        "changes": 381,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -6,6 +6,7 @@\n #ifndef BITCOIN_COINS_H\n #define BITCOIN_COINS_H\n \n+#include \"primitives/transaction.h\"\n #include \"compressor.h\"\n #include \"core_memusage.h\"\n #include \"hash.h\"\n@@ -16,254 +17,92 @@\n #include <assert.h>\n #include <stdint.h>\n \n-#include <boost/foreach.hpp>\n-#include <boost/unordered_map.hpp>\n+#include <unordered_map>\n \n-/** \n- * Pruned version of CTransaction: only retains metadata and unspent transaction outputs\n+/**\n+ * A UTXO entry.\n  *\n  * Serialized format:\n- * - VARINT(nVersion)\n- * - VARINT(nCode)\n- * - unspentness bitvector, for vout[2] and further; least significant byte first\n- * - the non-spent CTxOuts (via CTxOutCompressor)\n- * - VARINT(nHeight)\n- *\n- * The nCode value consists of:\n- * - bit 0: IsCoinBase()\n- * - bit 1: vout[0] is not spent\n- * - bit 2: vout[1] is not spent\n- * - The higher bits encode N, the number of non-zero bytes in the following bitvector.\n- *   - In case both bit 1 and bit 2 are unset, they encode N-1, as there must be at\n- *     least one non-spent output).\n- *\n- * Example: 0104835800816115944e077fe7c803cfa57f29b36bf87c1d358bb85e\n- *          <><><--------------------------------------------><---->\n- *          |  \\                  |                             /\n- *    version   code             vout[1]                  height\n- *\n- *    - version = 1\n- *    - code = 4 (vout[1] is not spent, and 0 non-zero bytes of bitvector follow)\n- *    - unspentness bitvector: as 0 non-zero bytes follow, it has length 0\n- *    - vout[1]: 835800816115944e077fe7c803cfa57f29b36bf87c1d35\n- *               * 8358: compact amount representation for 60000000000 (600 BTC)\n- *               * 00: special txout type pay-to-pubkey-hash\n- *               * 816115944e077fe7c803cfa57f29b36bf87c1d35: address uint160\n- *    - height = 203998\n- *\n- *\n- * Example: 0109044086ef97d5790061b01caab50f1b8e9c50a5057eb43c2d9563a4eebbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa486af3b\n- *          <><><--><--------------------------------------------------><----------------------------------------------><---->\n- *         /  \\   \\                     |                                                           |                     /\n- *  version  code  unspentness       vout[4]                                                     vout[16]           height\n- *\n- *  - version = 1\n- *  - code = 9 (coinbase, neither vout[0] or vout[1] are unspent,\n- *                2 (1, +1 because both bit 1 and bit 2 are unset) non-zero bitvector bytes follow)\n- *  - unspentness bitvector: bits 2 (0x04) and 14 (0x4000) are set, so vout[2+2] and vout[14+2] are unspent\n- *  - vout[4]: 86ef97d5790061b01caab50f1b8e9c50a5057eb43c2d9563a4ee\n- *             * 86ef97d579: compact amount representation for 234925952 (2.35 BTC)\n- *             * 00: special txout type pay-to-pubkey-hash\n- *             * 61b01caab50f1b8e9c50a5057eb43c2d9563a4ee: address uint160\n- *  - vout[16]: bbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa4\n- *              * bbd123: compact amount representation for 110397 (0.001 BTC)\n- *              * 00: special txout type pay-to-pubkey-hash\n- *              * 8c988f1a4a4de2161e0f50aac7f17e7f9555caa4: address uint160\n- *  - height = 120891\n+ * - VARINT((coinbase ? 1 : 0) | (height << 1))\n+ * - the non-spent CTxOut (via CTxOutCompressor)\n  */\n-class CCoins\n+class Coin\n {\n public:\n-    //! whether transaction is a coinbase\n-    bool fCoinBase;\n-\n-    //! unspent transaction outputs; spent outputs are .IsNull(); spent outputs at the end of the array are dropped\n-    std::vector<CTxOut> vout;\n+    //! unspent transaction output\n+    CTxOut out;\n \n-    //! at which height this transaction was included in the active block chain\n-    int nHeight;\n+    //! whether containing transaction was a coinbase\n+    unsigned int fCoinBase : 1;\n \n-    //! version of the CTransaction; accesses to this value should probably check for nHeight as well,\n-    //! as new tx version will probably only be introduced at certain heights\n-    int nVersion;\n+    //! at which height this containing transaction was included in the active block chain\n+    uint32_t nHeight : 31;\n \n-    void FromTx(const CTransaction &tx, int nHeightIn) {\n-        fCoinBase = tx.IsCoinBase();\n-        vout = tx.vout;\n-        nHeight = nHeightIn;\n-        nVersion = tx.nVersion;\n-        ClearUnspendable();\n-    }\n-\n-    //! construct a CCoins from a CTransaction, at a given height\n-    CCoins(const CTransaction &tx, int nHeightIn) {\n-        FromTx(tx, nHeightIn);\n-    }\n+    //! construct a Coin from a CTxOut and height/coinbase information.\n+    Coin(CTxOut&& outIn, int nHeightIn, bool fCoinBaseIn) : out(std::move(outIn)), fCoinBase(fCoinBaseIn), nHeight(nHeightIn) {}\n+    Coin(const CTxOut& outIn, int nHeightIn, bool fCoinBaseIn) : out(outIn), fCoinBase(fCoinBaseIn),nHeight(nHeightIn) {}\n \n     void Clear() {\n+        out.SetNull();\n         fCoinBase = false;\n-        std::vector<CTxOut>().swap(vout);\n         nHeight = 0;\n-        nVersion = 0;\n     }\n \n     //! empty constructor\n-    CCoins() : fCoinBase(false), vout(0), nHeight(0), nVersion(0) { }\n-\n-    //!remove spent outputs at the end of vout\n-    void Cleanup() {\n-        while (vout.size() > 0 && vout.back().IsNull())\n-            vout.pop_back();\n-        if (vout.empty())\n-            std::vector<CTxOut>().swap(vout);\n-    }\n-\n-    void ClearUnspendable() {\n-        BOOST_FOREACH(CTxOut &txout, vout) {\n-            if (txout.scriptPubKey.IsUnspendable())\n-                txout.SetNull();\n-        }\n-        Cleanup();\n-    }\n-\n-    void swap(CCoins &to) {\n-        std::swap(to.fCoinBase, fCoinBase);\n-        to.vout.swap(vout);\n-        std::swap(to.nHeight, nHeight);\n-        std::swap(to.nVersion, nVersion);\n-    }\n-\n-    //! equality test\n-    friend bool operator==(const CCoins &a, const CCoins &b) {\n-         // Empty CCoins objects are always equal.\n-         if (a.IsPruned() && b.IsPruned())\n-             return true;\n-         return a.fCoinBase == b.fCoinBase &&\n-                a.nHeight == b.nHeight &&\n-                a.nVersion == b.nVersion &&\n-                a.vout == b.vout;\n-    }\n-    friend bool operator!=(const CCoins &a, const CCoins &b) {\n-        return !(a == b);\n-    }\n-\n-    void CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) const;\n+    Coin() : fCoinBase(false), nHeight(0) { }\n \n     bool IsCoinBase() const {\n         return fCoinBase;\n     }\n \n     template<typename Stream>\n     void Serialize(Stream &s) const {\n-        unsigned int nMaskSize = 0, nMaskCode = 0;\n-        CalcMaskSize(nMaskSize, nMaskCode);\n-        bool fFirst = vout.size() > 0 && !vout[0].IsNull();\n-        bool fSecond = vout.size() > 1 && !vout[1].IsNull();\n-        assert(fFirst || fSecond || nMaskCode);\n-        unsigned int nCode = 8*(nMaskCode - (fFirst || fSecond ? 0 : 1)) + (fCoinBase ? 1 : 0) + (fFirst ? 2 : 0) + (fSecond ? 4 : 0);\n-        // version\n-        ::Serialize(s, VARINT(this->nVersion));\n-        // header code\n-        ::Serialize(s, VARINT(nCode));\n-        // spentness bitmask\n-        for (unsigned int b = 0; b<nMaskSize; b++) {\n-            unsigned char chAvail = 0;\n-            for (unsigned int i = 0; i < 8 && 2+b*8+i < vout.size(); i++)\n-                if (!vout[2+b*8+i].IsNull())\n-                    chAvail |= (1 << i);\n-            ::Serialize(s, chAvail);\n-        }\n-        // txouts themself\n-        for (unsigned int i = 0; i < vout.size(); i++) {\n-            if (!vout[i].IsNull())\n-                ::Serialize(s, CTxOutCompressor(REF(vout[i])));\n-        }\n-        // coinbase height\n-        ::Serialize(s, VARINT(nHeight));\n+        assert(!IsSpent());\n+        uint32_t code = nHeight * 2 + fCoinBase;\n+        ::Serialize(s, VARINT(code));\n+        ::Serialize(s, CTxOutCompressor(REF(out)));\n     }\n \n     template<typename Stream>\n     void Unserialize(Stream &s) {\n-        unsigned int nCode = 0;\n-        // version\n-        ::Unserialize(s, VARINT(this->nVersion));\n-        // header code\n-        ::Unserialize(s, VARINT(nCode));\n-        fCoinBase = nCode & 1;\n-        std::vector<bool> vAvail(2, false);\n-        vAvail[0] = (nCode & 2) != 0;\n-        vAvail[1] = (nCode & 4) != 0;\n-        unsigned int nMaskCode = (nCode / 8) + ((nCode & 6) != 0 ? 0 : 1);\n-        // spentness bitmask\n-        while (nMaskCode > 0) {\n-            unsigned char chAvail = 0;\n-            ::Unserialize(s, chAvail);\n-            for (unsigned int p = 0; p < 8; p++) {\n-                bool f = (chAvail & (1 << p)) != 0;\n-                vAvail.push_back(f);\n-            }\n-            if (chAvail != 0)\n-                nMaskCode--;\n-        }\n-        // txouts themself\n-        vout.assign(vAvail.size(), CTxOut());\n-        for (unsigned int i = 0; i < vAvail.size(); i++) {\n-            if (vAvail[i])\n-                ::Unserialize(s, REF(CTxOutCompressor(vout[i])));\n-        }\n-        // coinbase height\n-        ::Unserialize(s, VARINT(nHeight));\n-        Cleanup();\n-    }\n-\n-    //! mark a vout spent\n-    bool Spend(uint32_t nPos);\n-\n-    //! check whether a particular output is still available\n-    bool IsAvailable(unsigned int nPos) const {\n-        return (nPos < vout.size() && !vout[nPos].IsNull());\n+        uint32_t code = 0;\n+        ::Unserialize(s, VARINT(code));\n+        nHeight = code >> 1;\n+        fCoinBase = code & 1;\n+        ::Unserialize(s, REF(CTxOutCompressor(out)));\n     }\n \n-    //! check whether the entire CCoins is spent\n-    //! note that only !IsPruned() CCoins can be serialized\n-    bool IsPruned() const {\n-        BOOST_FOREACH(const CTxOut &out, vout)\n-            if (!out.IsNull())\n-                return false;\n-        return true;\n+    bool IsSpent() const {\n+        return out.IsNull();\n     }\n \n     size_t DynamicMemoryUsage() const {\n-        size_t ret = memusage::DynamicUsage(vout);\n-        BOOST_FOREACH(const CTxOut &out, vout) {\n-            ret += RecursiveDynamicUsage(out.scriptPubKey);\n-        }\n-        return ret;\n+        return memusage::DynamicUsage(out.scriptPubKey);\n     }\n };\n \n-class SaltedTxidHasher\n+class SaltedOutpointHasher\n {\n private:\n     /** Salt */\n     const uint64_t k0, k1;\n \n public:\n-    SaltedTxidHasher();\n+    SaltedOutpointHasher();\n \n     /**\n      * This *must* return size_t. With Boost 1.46 on 32-bit systems the\n      * unordered_map will behave unpredictably if the custom hasher returns a\n      * uint64_t, resulting in failures when syncing the chain (#4634).\n      */\n-    size_t operator()(const uint256& txid) const {\n-        return SipHashUint256(k0, k1, txid);\n+    size_t operator()(const COutPoint& id) const {\n+        return SipHashUint256Extra(k0, k1, id.hash, id.n);\n     }\n };\n \n struct CCoinsCacheEntry\n {\n-    CCoins coins; // The actual cached data.\n+    Coin coin; // The actual cached data.\n     unsigned char flags;\n \n     enum Flags {\n@@ -276,20 +115,21 @@ struct CCoinsCacheEntry\n          */\n     };\n \n-    CCoinsCacheEntry() : coins(), flags(0) {}\n+    CCoinsCacheEntry() : flags(0) {}\n+    explicit CCoinsCacheEntry(Coin&& coin_) : coin(std::move(coin_)), flags(0) {}\n };\n \n-typedef boost::unordered_map<uint256, CCoinsCacheEntry, SaltedTxidHasher> CCoinsMap;\n+typedef std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher> CCoinsMap;\n \n /** Cursor for iterating over CoinsView state */\n class CCoinsViewCursor\n {\n public:\n     CCoinsViewCursor(const uint256 &hashBlockIn): hashBlock(hashBlockIn) {}\n-    virtual ~CCoinsViewCursor();\n+    virtual ~CCoinsViewCursor() {}\n \n-    virtual bool GetKey(uint256 &key) const = 0;\n-    virtual bool GetValue(CCoins &coins) const = 0;\n+    virtual bool GetKey(COutPoint &key) const = 0;\n+    virtual bool GetValue(Coin &coin) const = 0;\n     virtual unsigned int GetValueSize() const = 0;\n \n     virtual bool Valid() const = 0;\n@@ -305,17 +145,25 @@ class CCoinsViewCursor\n class CCoinsView\n {\n public:\n-    //! Retrieve the CCoins (unspent transaction outputs) for a given txid\n-    virtual bool GetCoins(const uint256 &txid, CCoins &coins) const;\n+    /** Retrieve the Coin (unspent transaction output) for a given outpoint.\n+     *  Returns true only when an unspent coin was found, which is returned in coin.\n+     *  When false is returned, coin's value is unspecified.\n+     */\n+    virtual bool GetCoin(const COutPoint &outpoint, Coin &coin) const;\n \n-    //! Just check whether we have data for a given txid.\n-    //! This may (but cannot always) return true for fully spent transactions\n-    virtual bool HaveCoins(const uint256 &txid) const;\n+    //! Just check whether a given outpoint is unspent.\n+    virtual bool HaveCoin(const COutPoint &outpoint) const;\n \n     //! Retrieve the block hash whose state this CCoinsView currently represents\n     virtual uint256 GetBestBlock() const;\n \n-    //! Do a bulk modification (multiple CCoins changes + BestBlock change).\n+    //! Retrieve the range of blocks that may have been only partially written.\n+    //! If the database is in a consistent state, the result is the empty vector.\n+    //! Otherwise, a two-element vector is returned consisting of the new and\n+    //! the old block hash, in that order.\n+    virtual std::vector<uint256> GetHeadBlocks() const;\n+\n+    //! Do a bulk modification (multiple Coin changes + BestBlock change).\n     //! The passed mapCoins can be modified.\n     virtual bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n \n@@ -324,6 +172,9 @@ class CCoinsView\n \n     //! As we use CCoinsViews polymorphically, have a virtual destructor\n     virtual ~CCoinsView() {}\n+\n+    //! Estimate database size (0 if not implemented)\n+    virtual size_t EstimateSize() const { return 0; }\n };\n \n \n@@ -335,97 +186,75 @@ class CCoinsViewBacked : public CCoinsView\n \n public:\n     CCoinsViewBacked(CCoinsView *viewIn);\n-    bool GetCoins(const uint256 &txid, CCoins &coins) const;\n-    bool HaveCoins(const uint256 &txid) const;\n-    uint256 GetBestBlock() const;\n+    bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n+    bool HaveCoin(const COutPoint &outpoint) const override;\n+    uint256 GetBestBlock() const override;\n+    std::vector<uint256> GetHeadBlocks() const override;\n     void SetBackend(CCoinsView &viewIn);\n-    bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n-    CCoinsViewCursor *Cursor() const;\n+    bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n+    CCoinsViewCursor *Cursor() const override;\n+    size_t EstimateSize() const override;\n };\n \n \n-class CCoinsViewCache;\n-\n-/** \n- * A reference to a mutable cache entry. Encapsulating it allows us to run\n- *  cleanup code after the modification is finished, and keeping track of\n- *  concurrent modifications. \n- */\n-class CCoinsModifier\n-{\n-private:\n-    CCoinsViewCache& cache;\n-    CCoinsMap::iterator it;\n-    size_t cachedCoinUsage; // Cached memory usage of the CCoins object before modification\n-    CCoinsModifier(CCoinsViewCache& cache_, CCoinsMap::iterator it_, size_t usage);\n-\n-public:\n-    CCoins* operator->() { return &it->second.coins; }\n-    CCoins& operator*() { return it->second.coins; }\n-    ~CCoinsModifier();\n-    friend class CCoinsViewCache;\n-};\n-\n /** CCoinsView that adds a memory cache for transactions to another CCoinsView */\n class CCoinsViewCache : public CCoinsViewBacked\n {\n protected:\n-    /* Whether this cache has an active modifier. */\n-    bool hasModifier;\n-\n-\n     /**\n      * Make mutable so that we can \"fill the cache\" even from Get-methods\n      * declared as \"const\".  \n      */\n     mutable uint256 hashBlock;\n     mutable CCoinsMap cacheCoins;\n \n-    /* Cached dynamic memory usage for the inner CCoins objects. */\n+    /* Cached dynamic memory usage for the inner Coin objects. */\n     mutable size_t cachedCoinsUsage;\n \n public:\n     CCoinsViewCache(CCoinsView *baseIn);\n-    ~CCoinsViewCache();\n \n     // Standard CCoinsView methods\n-    bool GetCoins(const uint256 &txid, CCoins &coins) const;\n-    bool HaveCoins(const uint256 &txid) const;\n-    uint256 GetBestBlock() const;\n+    bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n+    bool HaveCoin(const COutPoint &outpoint) const override;\n+    uint256 GetBestBlock() const override;\n     void SetBestBlock(const uint256 &hashBlock);\n-    bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n+    bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n+    CCoinsViewCursor* Cursor() const override {\n+        throw std::logic_error(\"CCoinsViewCache cursor iteration not supported.\");\n+    }\n \n     /**\n-     * Check if we have the given tx already loaded in this cache.\n-     * The semantics are the same as HaveCoins(), but no calls to\n+     * Check if we have the given utxo already loaded in this cache.\n+     * The semantics are the same as HaveCoin(), but no calls to\n      * the backing CCoinsView are made.\n      */\n-    bool HaveCoinsInCache(const uint256 &txid) const;\n+    bool HaveCoinInCache(const COutPoint &outpoint) const;\n \n     /**\n-     * Return a pointer to CCoins in the cache, or NULL if not found. This is\n-     * more efficient than GetCoins. Modifications to other cache entries are\n-     * allowed while accessing the returned pointer.\n+     * Return a reference to Coin in the cache, or a pruned one if not found. This is\n+     * more efficient than GetCoin.\n+     *\n+     * Generally, do not hold the reference returned for more than a short scope.\n+     * While the current implementation allows for modifications to the contents\n+     * of the cache while holding the reference, this behavior should not be relied\n+     * on! To be safe, best to not hold the returned reference through any other\n+     * calls to this cache.\n      */\n-    const CCoins* AccessCoins(const uint256 &txid) const;\n+    const Coin& AccessCoin(const COutPoint &output) const;\n \n     /**\n-     * Return a modifiable reference to a CCoins. If no entry with the given\n-     * txid exists, a new one is created. Simultaneous modifications are not\n-     * allowed.\n+     * Add a coin. Set potential_overwrite to true if a non-pruned version may\n+     * already exist.\n      */\n-    CCoinsModifier ModifyCoins(const uint256 &txid);\n+    void AddCoin(const COutPoint& outpoint, Coin&& coin, bool potential_overwrite);\n \n     /**\n-     * Return a modifiable reference to a CCoins. Assumes that no entry with the given\n-     * txid exists and creates a new one. This saves a database access in the case where\n-     * the coins were to be wiped out by FromTx anyway.  This should not be called with\n-     * the 2 historical coinbase duplicate pairs because the new coins are marked fresh, and\n-     * in the event the duplicate coinbase was spent before a flush, the now pruned coins\n-     * would not properly overwrite the first coinbase of the pair. Simultaneous modifications\n-     * are not allowed.\n+     * Spend a coin. Pass moveto in order to get the deleted data.\n+     * If no unspent output exists for the passed outpoint, this call\n+     * has no effect.\n      */\n-    CCoinsModifier ModifyNewCoins(const uint256 &txid, bool coinbase);\n+    bool SpendCoin(const COutPoint &outpoint, Coin* moveto = nullptr);\n \n     /**\n      * Push the modifications applied to this cache to its base.\n@@ -435,12 +264,12 @@ class CCoinsViewCache : public CCoinsViewBacked\n     bool Flush();\n \n     /**\n-     * Removes the transaction with the given hash from the cache, if it is\n+     * Removes the UTXO with the given outpoint from the cache, if it is\n      * not modified.\n      */\n-    void Uncache(const uint256 &txid);\n+    void Uncache(const COutPoint &outpoint);\n \n-    //! Calculate the size of the cache (in number of transactions)\n+    //! Calculate the size of the cache (in number of transaction outputs)\n     unsigned int GetCacheSize() const;\n \n     //! Calculate the size of the cache (in bytes)\n@@ -459,17 +288,27 @@ class CCoinsViewCache : public CCoinsViewBacked\n     //! Check whether all prevouts of the transaction are present in the UTXO set represented by this view\n     bool HaveInputs(const CTransaction& tx) const;\n \n-    const CTxOut &GetOutputFor(const CTxIn& input) const;\n-\n-    friend class CCoinsModifier;\n-\n private:\n-    CCoinsMap::const_iterator FetchCoins(const uint256 &txid) const;\n+    CCoinsMap::iterator FetchCoin(const COutPoint &outpoint) const;\n \n     /**\n      * By making the copy constructor private, we prevent accidentally using it when one intends to create a cache on top of a base cache.\n      */\n     CCoinsViewCache(const CCoinsViewCache &);\n };\n \n+//! Utility function to add all of a transaction's outputs to a cache.\n+// When check is false, this assumes that overwrites are only possible for coinbase transactions.\n+// When check is true, the underlying view may be queried to determine whether an addition is\n+// an overwrite.\n+// TODO: pass in a boolean to limit these possible overwrites to known\n+// (pre-BIP34) cases.\n+void AddCoins(CCoinsViewCache& cache, const CTransaction& tx, int nHeight, bool check = false);\n+\n+//! Utility function to find any unspent output with a given txid.\n+// This function can be quite expensive because in the event of a transaction\n+// which is not found in the cache, it can cause up to MAX_OUTPUTS_PER_BLOCK\n+// lookups to database, so it should be used with care.\n+const Coin& AccessByTxid(const CCoinsViewCache& cache, const uint256& txid);\n+\n #endif // BITCOIN_COINS_H"
      },
      {
        "sha": "e022659c018ac32c65d18dc605be8826a6dbde6e",
        "filename": "src/compat.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/compat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/compat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -76,7 +76,7 @@ typedef unsigned int SOCKET;\n size_t strnlen( const char *start, size_t max_len);\n #endif // HAVE_DECL_STRNLEN\n \n-bool static inline IsSelectableSocket(SOCKET s) {\n+bool static inline IsSelectableSocket(const SOCKET& s) {\n #ifdef WIN32\n     return true;\n #else"
      },
      {
        "sha": "b4d1c90992b767f2f3676936f0478f2ef44a1b98",
        "filename": "src/compat/glibc_sanity.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/compat/glibc_sanity.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/compat/glibc_sanity.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibc_sanity.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -56,7 +56,7 @@ bool sanity_test_fdelt()\n }\n #endif\n \n-} // anon namespace\n+} // namespace\n \n bool glibc_sanity_test()\n {"
      },
      {
        "sha": "569fb1bbe886c5f561e5273a5f2fa3f086a32333",
        "filename": "src/compat/glibcxx_sanity.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/compat/glibcxx_sanity.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/compat/glibcxx_sanity.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibcxx_sanity.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -38,7 +38,7 @@ bool sanity_test_list(unsigned int size)\n     return true;\n }\n \n-} // anon namespace\n+} // namespace\n \n // trigger: string::at(x) on an empty string to trigger __throw_out_of_range_fmt.\n // test: force std::string to throw an out_of_range exception. Verify that"
      },
      {
        "sha": "f4c12f38d2d1fc7494669adbc3c3191978743db0",
        "filename": "src/compressor.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/compressor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/compressor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compressor.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -93,30 +93,30 @@ bool CScriptCompressor::Decompress(unsigned int nSize, const std::vector<unsigne\n         script[0] = OP_DUP;\n         script[1] = OP_HASH160;\n         script[2] = 20;\n-        memcpy(&script[3], &in[0], 20);\n+        memcpy(&script[3], in.data(), 20);\n         script[23] = OP_EQUALVERIFY;\n         script[24] = OP_CHECKSIG;\n         return true;\n     case 0x01:\n         script.resize(23);\n         script[0] = OP_HASH160;\n         script[1] = 20;\n-        memcpy(&script[2], &in[0], 20);\n+        memcpy(&script[2], in.data(), 20);\n         script[22] = OP_EQUAL;\n         return true;\n     case 0x02:\n     case 0x03:\n         script.resize(35);\n         script[0] = 33;\n         script[1] = nSize;\n-        memcpy(&script[2], &in[0], 32);\n+        memcpy(&script[2], in.data(), 32);\n         script[34] = OP_CHECKSIG;\n         return true;\n     case 0x04:\n     case 0x05:\n         unsigned char vch[33] = {};\n         vch[0] = nSize - 2;\n-        memcpy(&vch[1], &in[0], 32);\n+        memcpy(&vch[1], in.data(), 32);\n         CPubKey pubkey(&vch[0], &vch[33]);\n         if (!pubkey.Decompress())\n             return false;"
      },
      {
        "sha": "ddd4ee9fab489977a5d5f36a89f37ebdec767f9d",
        "filename": "src/consensus/consensus.h",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/consensus/consensus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/consensus/consensus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/consensus.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -6,19 +6,23 @@\n #ifndef BITCOIN_CONSENSUS_CONSENSUS_H\n #define BITCOIN_CONSENSUS_CONSENSUS_H\n \n+#include <stdlib.h>\n #include <stdint.h>\n \n /** The maximum allowed size for a serialized block, in bytes (only for buffer size limits) */\n static const unsigned int MAX_BLOCK_SERIALIZED_SIZE = 4000000;\n /** The maximum allowed weight for a block, see BIP 141 (network rule) */\n static const unsigned int MAX_BLOCK_WEIGHT = 4000000;\n-/** The maximum allowed size for a block excluding witness data, in bytes (network rule) */\n-static const unsigned int MAX_BLOCK_BASE_SIZE = 1000000;\n /** The maximum allowed number of signature check operations in a block (network rule) */\n static const int64_t MAX_BLOCK_SIGOPS_COST = 80000;\n /** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */\n static const int COINBASE_MATURITY = 100;\n \n+static const int WITNESS_SCALE_FACTOR = 4;\n+\n+static const size_t MIN_TRANSACTION_WEIGHT = WITNESS_SCALE_FACTOR * 60; // 60 is the lower bound for the size of a valid serialized CTransaction\n+static const size_t MIN_SERIALIZABLE_TRANSACTION_WEIGHT = WITNESS_SCALE_FACTOR * 10; // 10 is the lower bound for the size of a serialized CTransaction\n+\n /** Flags for nSequence and nLockTime locks */\n enum {\n     /* Interpret sequence numbers as relative lock-time constraints. */"
      },
      {
        "sha": "0a71915d1df129362300fdefe6e5b9b1b51e7ca9",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "added",
        "additions": 250,
        "deletions": 0,
        "changes": 250,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -0,0 +1,250 @@\n+// Copyright (c) 2017-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"tx_verify.h\"\n+\n+#include \"consensus.h\"\n+#include \"primitives/transaction.h\"\n+#include \"script/interpreter.h\"\n+#include \"validation.h\"\n+\n+// TODO remove the following dependencies\n+#include \"chain.h\"\n+#include \"coins.h\"\n+#include \"utilmoneystr.h\"\n+ \n+bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime)\n+{\n+    if (tx.nLockTime == 0)\n+        return true;\n+    if ((int64_t)tx.nLockTime < ((int64_t)tx.nLockTime < LOCKTIME_THRESHOLD ? (int64_t)nBlockHeight : nBlockTime))\n+        return true;\n+    for (const auto& txin : tx.vin) {\n+        if (!(txin.nSequence == CTxIn::SEQUENCE_FINAL))\n+            return false;\n+    }\n+    return true;\n+}\n+\n+std::pair<int, int64_t> CalculateSequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block)\n+{\n+    assert(prevHeights->size() == tx.vin.size());\n+\n+    // Will be set to the equivalent height- and time-based nLockTime\n+    // values that would be necessary to satisfy all relative lock-\n+    // time constraints given our view of block chain history.\n+    // The semantics of nLockTime are the last invalid height/time, so\n+    // use -1 to have the effect of any height or time being valid.\n+    int nMinHeight = -1;\n+    int64_t nMinTime = -1;\n+\n+    // tx.nVersion is signed integer so requires cast to unsigned otherwise\n+    // we would be doing a signed comparison and half the range of nVersion\n+    // wouldn't support BIP 68.\n+    bool fEnforceBIP68 = static_cast<uint32_t>(tx.nVersion) >= 2\n+                      && flags & LOCKTIME_VERIFY_SEQUENCE;\n+\n+    // Do not enforce sequence numbers as a relative lock time\n+    // unless we have been instructed to\n+    if (!fEnforceBIP68) {\n+        return std::make_pair(nMinHeight, nMinTime);\n+    }\n+\n+    for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n+        const CTxIn& txin = tx.vin[txinIndex];\n+\n+        // Sequence numbers with the most significant bit set are not\n+        // treated as relative lock-times, nor are they given any\n+        // consensus-enforced meaning at this point.\n+        if (txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n+            // The height of this input is not relevant for sequence locks\n+            (*prevHeights)[txinIndex] = 0;\n+            continue;\n+        }\n+\n+        int nCoinHeight = (*prevHeights)[txinIndex];\n+\n+        if (txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG) {\n+            int64_t nCoinTime = block.GetAncestor(std::max(nCoinHeight-1, 0))->GetMedianTimePast();\n+            // NOTE: Subtract 1 to maintain nLockTime semantics\n+            // BIP 68 relative lock times have the semantics of calculating\n+            // the first block or time at which the transaction would be\n+            // valid. When calculating the effective block time or height\n+            // for the entire transaction, we switch to using the\n+            // semantics of nLockTime which is the last invalid block\n+            // time or height.  Thus we subtract 1 from the calculated\n+            // time or height.\n+\n+            // Time-based relative lock-times are measured from the\n+            // smallest allowed timestamp of the block containing the\n+            // txout being spent, which is the median time past of the\n+            // block prior.\n+            nMinTime = std::max(nMinTime, nCoinTime + (int64_t)((txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_MASK) << CTxIn::SEQUENCE_LOCKTIME_GRANULARITY) - 1);\n+        } else {\n+            nMinHeight = std::max(nMinHeight, nCoinHeight + (int)(txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_MASK) - 1);\n+        }\n+    }\n+\n+    return std::make_pair(nMinHeight, nMinTime);\n+}\n+\n+bool EvaluateSequenceLocks(const CBlockIndex& block, std::pair<int, int64_t> lockPair)\n+{\n+    assert(block.pprev);\n+    int64_t nBlockTime = block.pprev->GetMedianTimePast();\n+    if (lockPair.first >= block.nHeight || lockPair.second >= nBlockTime)\n+        return false;\n+\n+    return true;\n+}\n+\n+bool SequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block)\n+{\n+    return EvaluateSequenceLocks(block, CalculateSequenceLocks(tx, flags, prevHeights, block));\n+}\n+\n+unsigned int GetLegacySigOpCount(const CTransaction& tx)\n+{\n+    unsigned int nSigOps = 0;\n+    for (const auto& txin : tx.vin)\n+    {\n+        nSigOps += txin.scriptSig.GetSigOpCount(false);\n+    }\n+    for (const auto& txout : tx.vout)\n+    {\n+        nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n+    }\n+    return nSigOps;\n+}\n+\n+unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& inputs)\n+{\n+    if (tx.IsCoinBase())\n+        return 0;\n+\n+    unsigned int nSigOps = 0;\n+    for (unsigned int i = 0; i < tx.vin.size(); i++)\n+    {\n+        const Coin& coin = inputs.AccessCoin(tx.vin[i].prevout);\n+        assert(!coin.IsSpent());\n+        const CTxOut &prevout = coin.out;\n+        if (prevout.scriptPubKey.IsPayToScriptHash())\n+            nSigOps += prevout.scriptPubKey.GetSigOpCount(tx.vin[i].scriptSig);\n+    }\n+    return nSigOps;\n+}\n+\n+int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, int flags)\n+{\n+    int64_t nSigOps = GetLegacySigOpCount(tx) * WITNESS_SCALE_FACTOR;\n+\n+    if (tx.IsCoinBase())\n+        return nSigOps;\n+\n+    if (flags & SCRIPT_VERIFY_P2SH) {\n+        nSigOps += GetP2SHSigOpCount(tx, inputs) * WITNESS_SCALE_FACTOR;\n+    }\n+\n+    for (unsigned int i = 0; i < tx.vin.size(); i++)\n+    {\n+        const Coin& coin = inputs.AccessCoin(tx.vin[i].prevout);\n+        assert(!coin.IsSpent());\n+        const CTxOut &prevout = coin.out;\n+        nSigOps += CountWitnessSigOps(tx.vin[i].scriptSig, prevout.scriptPubKey, &tx.vin[i].scriptWitness, flags);\n+    }\n+    return nSigOps;\n+}\n+\n+bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fCheckDuplicateInputs)\n+{\n+    // Basic checks that don't depend on any context\n+    if (tx.vin.empty())\n+        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n+    if (tx.vout.empty())\n+        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n+    // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)\n+    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n+        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-oversize\");\n+\n+    // Check for negative or overflow output values\n+    CAmount nValueOut = 0;\n+    for (const auto& txout : tx.vout)\n+    {\n+        if (txout.nValue < 0)\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-negative\");\n+        if (txout.nValue > MAX_MONEY)\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n+        nValueOut += txout.nValue;\n+        if (!MoneyRange(nValueOut))\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n+    }\n+\n+    // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n+    if (fCheckDuplicateInputs) {\n+        std::set<COutPoint> vInOutPoints;\n+        for (const auto& txin : tx.vin)\n+        {\n+            if (!vInOutPoints.insert(txin.prevout).second)\n+                return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n+        }\n+    }\n+\n+    if (tx.IsCoinBase())\n+    {\n+        if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-length\");\n+    }\n+    else\n+    {\n+        for (const auto& txin : tx.vin)\n+            if (txin.prevout.IsNull())\n+                return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n+    }\n+\n+    return true;\n+}\n+\n+bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoinsViewCache& inputs, int nSpendHeight)\n+{\n+        // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n+        // for an attacker to attempt to split the network.\n+        if (!inputs.HaveInputs(tx))\n+            return state.Invalid(false, 0, \"\", \"Inputs unavailable\");\n+\n+        CAmount nValueIn = 0;\n+        CAmount nFees = 0;\n+        for (unsigned int i = 0; i < tx.vin.size(); i++)\n+        {\n+            const COutPoint &prevout = tx.vin[i].prevout;\n+            const Coin& coin = inputs.AccessCoin(prevout);\n+            assert(!coin.IsSpent());\n+\n+            // If prev is coinbase, check that it's matured\n+            if (coin.IsCoinBase()) {\n+                if (nSpendHeight - coin.nHeight < COINBASE_MATURITY)\n+                    return state.Invalid(false,\n+                        REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n+                        strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coin.nHeight));\n+            }\n+\n+            // Check for negative or overflow input values\n+            nValueIn += coin.out.nValue;\n+            if (!MoneyRange(coin.out.nValue) || !MoneyRange(nValueIn))\n+                return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n+\n+        }\n+\n+        if (nValueIn < tx.GetValueOut())\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-in-belowout\", false,\n+                strprintf(\"value in (%s) < value out (%s)\", FormatMoney(nValueIn), FormatMoney(tx.GetValueOut())));\n+\n+        // Tally transaction fees\n+        CAmount nTxFee = nValueIn - tx.GetValueOut();\n+        if (nTxFee < 0)\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-fee-negative\");\n+        nFees += nTxFee;\n+        if (!MoneyRange(nFees))\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n+    return true;\n+}"
      },
      {
        "sha": "d46d3294ca25039e8ebdaf1d0cd4d73abebb3597",
        "filename": "src/consensus/tx_verify.h",
        "status": "added",
        "additions": 78,
        "deletions": 0,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/consensus/tx_verify.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/consensus/tx_verify.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -0,0 +1,78 @@\n+// Copyright (c) 2017-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CONSENSUS_TX_VERIFY_H\n+#define BITCOIN_CONSENSUS_TX_VERIFY_H\n+\n+#include <stdint.h>\n+#include <vector>\n+\n+class CBlockIndex;\n+class CCoinsViewCache;\n+class CTransaction;\n+class CValidationState;\n+\n+/** Transaction validation functions */\n+\n+/** Context-independent validity checks */\n+bool CheckTransaction(const CTransaction& tx, CValidationState& state, bool fCheckDuplicateInputs=true);\n+\n+namespace Consensus {\n+/**\n+ * Check whether all inputs of this transaction are valid (no double spends and amounts)\n+ * This does not modify the UTXO set. This does not check scripts and sigs.\n+ * Preconditions: tx.IsCoinBase() is false.\n+ */\n+bool CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoinsViewCache& inputs, int nSpendHeight);\n+} // namespace Consensus\n+\n+/** Auxiliary functions for transaction validation (ideally should not be exposed) */\n+\n+/**\n+ * Count ECDSA signature operations the old-fashioned (pre-0.6) way\n+ * @return number of sigops this transaction's outputs will produce when spent\n+ * @see CTransaction::FetchInputs\n+ */\n+unsigned int GetLegacySigOpCount(const CTransaction& tx);\n+\n+/**\n+ * Count ECDSA signature operations in pay-to-script-hash inputs.\n+ * \n+ * @param[in] mapInputs Map of previous transactions that have outputs we're spending\n+ * @return maximum number of sigops required to validate this transaction's inputs\n+ * @see CTransaction::FetchInputs\n+ */\n+unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& mapInputs);\n+\n+/**\n+ * Compute total signature operation cost of a transaction.\n+ * @param[in] tx     Transaction for which we are computing the cost\n+ * @param[in] inputs Map of previous transactions that have outputs we're spending\n+ * @param[out] flags Script verification flags\n+ * @return Total signature operation cost of tx\n+ */\n+int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, int flags);\n+\n+/**\n+ * Check if transaction is final and can be included in a block with the\n+ * specified height and time. Consensus critical.\n+ */\n+bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime);\n+\n+/**\n+ * Calculates the block height and previous block's median time past at\n+ * which the transaction will be considered final in the context of BIP 68.\n+ * Also removes from the vector of input heights any entries which did not\n+ * correspond to sequence locked inputs as they do not affect the calculation.\n+ */\n+std::pair<int, int64_t> CalculateSequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block);\n+\n+bool EvaluateSequenceLocks(const CBlockIndex& block, std::pair<int, int64_t> lockPair);\n+/**\n+ * Check if transaction is final per BIP 68 sequence numbers and can be included in a block.\n+ * Consensus critical. Takes as input a list of heights at which tx's inputs (in order) confirmed.\n+ */\n+bool SequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block);\n+\n+#endif // BITCOIN_CONSENSUS_TX_VERIFY_H"
      },
      {
        "sha": "5494ce40eac4204e06026d589958ff42e8f1fc0a",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 19,
        "deletions": 1,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -7,14 +7,18 @@\n #define BITCOIN_CONSENSUS_VALIDATION_H\n \n #include <string>\n+#include \"version.h\"\n+#include \"consensus/consensus.h\"\n+#include \"primitives/transaction.h\"\n+#include \"primitives/block.h\"\n \n /** \"reject\" message codes */\n static const unsigned char REJECT_MALFORMED = 0x01;\n static const unsigned char REJECT_INVALID = 0x10;\n static const unsigned char REJECT_OBSOLETE = 0x11;\n static const unsigned char REJECT_DUPLICATE = 0x12;\n static const unsigned char REJECT_NONSTANDARD = 0x40;\n-static const unsigned char REJECT_DUST = 0x41;\n+// static const unsigned char REJECT_DUST = 0x41; // part of BIP 61\n static const unsigned char REJECT_INSUFFICIENTFEE = 0x42;\n static const unsigned char REJECT_CHECKPOINT = 0x43;\n \n@@ -85,4 +89,18 @@ class CValidationState {\n     std::string GetDebugMessage() const { return strDebugMessage; }\n };\n \n+static inline int64_t GetTransactionWeight(const CTransaction& tx)\n+{\n+    return ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR -1) + ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n+}\n+\n+static inline int64_t GetBlockWeight(const CBlock& block)\n+{\n+    // This implements the weight = (stripped_size * 4) + witness_size formula,\n+    // using only serialization with and without witness data. As witness_size\n+    // is equal to total_size - stripped_size, this formula is identical to:\n+    // weight = (stripped_size * 3) + total_size.\n+    return ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION);\n+}\n+\n #endif // BITCOIN_CONSENSUS_VALIDATION_H"
      },
      {
        "sha": "3f25faf0ec2cce561144a27088ab8866dc699507",
        "filename": "src/core_io.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/core_io.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/core_io.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_io.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -5,6 +5,8 @@\n #ifndef BITCOIN_CORE_IO_H\n #define BITCOIN_CORE_IO_H\n \n+#include \"amount.h\"\n+\n #include <string>\n #include <vector>\n \n@@ -25,6 +27,7 @@ uint256 ParseHashStr(const std::string&, const std::string& strName);\n std::vector<unsigned char> ParseHexUV(const UniValue& v, const std::string& strName);\n \n // core_write.cpp\n+UniValue ValueFromAmount(const CAmount& amount);\n std::string FormatScript(const CScript& script);\n std::string EncodeHexTx(const CTransaction& tx, const int serializeFlags = 0);\n void ScriptPubKeyToUniv(const CScript& scriptPubKey, UniValue& out, bool fIncludeHex);"
      },
      {
        "sha": "f038e7b15487471566295dce78d24a6f903c83ab",
        "filename": "src/core_memusage.h",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/core_memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/core_memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_memusage.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -10,7 +10,7 @@\n #include \"memusage.h\"\n \n static inline size_t RecursiveDynamicUsage(const CScript& script) {\n-    return memusage::DynamicUsage(*static_cast<const CScriptBase*>(&script));\n+    return memusage::DynamicUsage(script);\n }\n \n static inline size_t RecursiveDynamicUsage(const COutPoint& out) {\n@@ -63,4 +63,9 @@ static inline size_t RecursiveDynamicUsage(const CBlockLocator& locator) {\n     return memusage::DynamicUsage(locator.vHave);\n }\n \n+template<typename X>\n+static inline size_t RecursiveDynamicUsage(const std::shared_ptr<X>& p) {\n+    return p ? memusage::DynamicUsage(p) + RecursiveDynamicUsage(*p) : 0;\n+}\n+\n #endif // BITCOIN_CORE_MEMUSAGE_H"
      },
      {
        "sha": "7018131a134ad08042c41ae1441594211448325c",
        "filename": "src/core_read.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 5,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/core_read.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/core_read.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_read.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -18,7 +18,6 @@\n #include <boost/algorithm/string/predicate.hpp>\n #include <boost/algorithm/string/replace.hpp>\n #include <boost/algorithm/string/split.hpp>\n-#include <boost/assign/list_of.hpp>\n \n CScript ParseScript(const std::string& s)\n {\n@@ -28,7 +27,7 @@ CScript ParseScript(const std::string& s)\n \n     if (mapOpNames.empty())\n     {\n-        for (int op = 0; op <= OP_NOP10; op++)\n+        for (unsigned int op = 0; op <= MAX_OPCODE; op++)\n         {\n             // Allow OP_RESERVED to get into mapOpNames\n             if (op < OP_NOP && op != OP_RESERVED)\n@@ -88,18 +87,40 @@ CScript ParseScript(const std::string& s)\n     return result;\n }\n \n+// Check that all of the input and output scripts of a transaction contains valid opcodes\n+bool CheckTxScriptsSanity(const CMutableTransaction& tx)\n+{\n+    // Check input scripts for non-coinbase txs\n+    if (!CTransaction(tx).IsCoinBase()) {\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            if (!tx.vin[i].scriptSig.HasValidOps() || tx.vin[i].scriptSig.size() > MAX_SCRIPT_SIZE) {\n+                return false;\n+            }\n+        }\n+    }\n+    // Check output scripts\n+    for (unsigned int i = 0; i < tx.vout.size(); i++) {\n+        if (!tx.vout[i].scriptPubKey.HasValidOps() || tx.vout[i].scriptPubKey.size() > MAX_SCRIPT_SIZE) {\n+            return false;\n+        }\n+    }\n+    \n+    return true;\n+}\n+\n bool DecodeHexTx(CMutableTransaction& tx, const std::string& strHexTx, bool fTryNoWitness)\n {\n-    if (!IsHex(strHexTx))\n+    if (!IsHex(strHexTx)) {\n         return false;\n+    }\n \n     std::vector<unsigned char> txData(ParseHex(strHexTx));\n \n     if (fTryNoWitness) {\n         CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS);\n         try {\n             ssData >> tx;\n-            if (ssData.eof()) {\n+            if (ssData.eof() && CheckTxScriptsSanity(tx)) {\n                 return true;\n             }\n         }\n@@ -111,8 +132,9 @@ bool DecodeHexTx(CMutableTransaction& tx, const std::string& strHexTx, bool fTry\n     CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n     try {\n         ssData >> tx;\n-        if (!ssData.empty())\n+        if (!ssData.empty()) {\n             return false;\n+        }\n     }\n     catch (const std::exception&) {\n         return false;"
      },
      {
        "sha": "217b491a0dc815eb654868a16185a3ab0b3b3034",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 15,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -5,7 +5,8 @@\n #include \"core_io.h\"\n \n #include \"base58.h\"\n-#include \"primitives/transaction.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n #include \"script/script.h\"\n #include \"script/standard.h\"\n #include \"serialize.h\"\n@@ -15,8 +16,15 @@\n #include \"utilmoneystr.h\"\n #include \"utilstrencodings.h\"\n \n-#include <boost/assign/list_of.hpp>\n-#include <boost/foreach.hpp>\n+UniValue ValueFromAmount(const CAmount& amount)\n+{\n+    bool sign = amount < 0;\n+    int64_t n_abs = (sign ? -amount : amount);\n+    int64_t quotient = n_abs / COIN;\n+    int64_t remainder = n_abs % COIN;\n+    return UniValue(UniValue::VNUM,\n+            strprintf(\"%s%d.%08d\", sign ? \"-\" : \"\", quotient, remainder));\n+}\n \n std::string FormatScript(const CScript& script)\n {\n@@ -53,15 +61,14 @@ std::string FormatScript(const CScript& script)\n     return ret.substr(0, ret.size() - 1);\n }\n \n-const std::map<unsigned char, std::string> mapSigHashTypes =\n-    boost::assign::map_list_of\n-    (static_cast<unsigned char>(SIGHASH_ALL), std::string(\"ALL\"))\n-    (static_cast<unsigned char>(SIGHASH_ALL|SIGHASH_ANYONECANPAY), std::string(\"ALL|ANYONECANPAY\"))\n-    (static_cast<unsigned char>(SIGHASH_NONE), std::string(\"NONE\"))\n-    (static_cast<unsigned char>(SIGHASH_NONE|SIGHASH_ANYONECANPAY), std::string(\"NONE|ANYONECANPAY\"))\n-    (static_cast<unsigned char>(SIGHASH_SINGLE), std::string(\"SINGLE\"))\n-    (static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\"))\n-    ;\n+const std::map<unsigned char, std::string> mapSigHashTypes = {\n+    {static_cast<unsigned char>(SIGHASH_ALL), std::string(\"ALL\")},\n+    {static_cast<unsigned char>(SIGHASH_ALL|SIGHASH_ANYONECANPAY), std::string(\"ALL|ANYONECANPAY\")},\n+    {static_cast<unsigned char>(SIGHASH_NONE), std::string(\"NONE\")},\n+    {static_cast<unsigned char>(SIGHASH_NONE|SIGHASH_ANYONECANPAY), std::string(\"NONE|ANYONECANPAY\")},\n+    {static_cast<unsigned char>(SIGHASH_SINGLE), std::string(\"SINGLE\")},\n+    {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\")},\n+};\n \n /**\n  * Create the assembly string representation of a CScript object.\n@@ -141,7 +148,7 @@ void ScriptPubKeyToUniv(const CScript& scriptPubKey,\n     out.pushKV(\"type\", GetTxnOutputType(type));\n \n     UniValue a(UniValue::VARR);\n-    BOOST_FOREACH(const CTxDestination& addr, addresses)\n+    for (const CTxDestination& addr : addresses)\n         a.push_back(CBitcoinAddress(addr).ToString());\n     out.pushKV(\"addresses\", a);\n }\n@@ -151,6 +158,8 @@ void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry)\n     entry.pushKV(\"txid\", tx.GetHash().GetHex());\n     entry.pushKV(\"hash\", tx.GetWitnessHash().GetHex());\n     entry.pushKV(\"version\", tx.nVersion);\n+    entry.pushKV(\"size\", (int)::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n+    entry.pushKV(\"vsize\", (GetTransactionWeight(tx) + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR);\n     entry.pushKV(\"locktime\", (int64_t)tx.nLockTime);\n \n     UniValue vin(UniValue::VARR);\n@@ -185,8 +194,7 @@ void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry)\n \n         UniValue out(UniValue::VOBJ);\n \n-        UniValue outValue(UniValue::VNUM, FormatMoney(txout.nValue));\n-        out.pushKV(\"value\", outValue);\n+        out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n         out.pushKV(\"n\", (int64_t)i);\n \n         UniValue o(UniValue::VOBJ);"
      },
      {
        "sha": "5e70d25eeeef4862bccaf2b64647411ba3f0673c",
        "filename": "src/crypto/aes.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/crypto/aes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/crypto/aes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/aes.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -112,7 +112,6 @@ static int CBCEncrypt(const T& enc, const unsigned char iv[AES_BLOCKSIZE], const\n template <typename T>\n static int CBCDecrypt(const T& dec, const unsigned char iv[AES_BLOCKSIZE], const unsigned char* data, int size, bool pad, unsigned char* out)\n {\n-    unsigned char padsize = 0;\n     int written = 0;\n     bool fail = false;\n     const unsigned char* prev = iv;\n@@ -136,7 +135,7 @@ static int CBCDecrypt(const T& dec, const unsigned char iv[AES_BLOCKSIZE], const\n     if (pad) {\n         // If used, padding size is the value of the last decrypted byte. For\n         // it to be valid, It must be between 1 and AES_BLOCKSIZE.\n-        padsize = *--out;\n+        unsigned char padsize = *--out;\n         fail = !padsize | (padsize > AES_BLOCKSIZE);\n \n         // If not well-formed, treat it as though there's no padding."
      },
      {
        "sha": "816ae870e138aa54621b2cebd62052b36bf55c2f",
        "filename": "src/crypto/chacha20.cpp",
        "status": "added",
        "additions": 180,
        "deletions": 0,
        "changes": 180,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/crypto/chacha20.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/crypto/chacha20.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/chacha20.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -0,0 +1,180 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+// Based on the public domain implementation 'merged' by D. J. Bernstein\n+// See https://cr.yp.to/chacha.html.\n+\n+#include \"crypto/common.h\"\n+#include \"crypto/chacha20.h\"\n+\n+#include <string.h>\n+\n+constexpr static inline uint32_t rotl32(uint32_t v, int c) { return (v << c) | (v >> (32 - c)); }\n+\n+#define QUARTERROUND(a,b,c,d) \\\n+  a += b; d = rotl32(d ^ a, 16); \\\n+  c += d; b = rotl32(b ^ c, 12); \\\n+  a += b; d = rotl32(d ^ a, 8); \\\n+  c += d; b = rotl32(b ^ c, 7);\n+\n+static const unsigned char sigma[] = \"expand 32-byte k\";\n+static const unsigned char tau[] = \"expand 16-byte k\";\n+\n+void ChaCha20::SetKey(const unsigned char* k, size_t keylen)\n+{\n+    const unsigned char *constants;\n+\n+    input[4] = ReadLE32(k + 0);\n+    input[5] = ReadLE32(k + 4);\n+    input[6] = ReadLE32(k + 8);\n+    input[7] = ReadLE32(k + 12);\n+    if (keylen == 32) { /* recommended */\n+        k += 16;\n+        constants = sigma;\n+    } else { /* keylen == 16 */\n+        constants = tau;\n+    }\n+    input[8] = ReadLE32(k + 0);\n+    input[9] = ReadLE32(k + 4);\n+    input[10] = ReadLE32(k + 8);\n+    input[11] = ReadLE32(k + 12);\n+    input[0] = ReadLE32(constants + 0);\n+    input[1] = ReadLE32(constants + 4);\n+    input[2] = ReadLE32(constants + 8);\n+    input[3] = ReadLE32(constants + 12);\n+    input[12] = 0;\n+    input[13] = 0;\n+    input[14] = 0;\n+    input[15] = 0;\n+}\n+\n+ChaCha20::ChaCha20()\n+{\n+    memset(input, 0, sizeof(input));\n+}\n+\n+ChaCha20::ChaCha20(const unsigned char* k, size_t keylen)\n+{\n+    SetKey(k, keylen);\n+}\n+\n+void ChaCha20::SetIV(uint64_t iv)\n+{\n+    input[14] = iv;\n+    input[15] = iv >> 32;\n+}\n+\n+void ChaCha20::Seek(uint64_t pos)\n+{\n+    input[12] = pos;\n+    input[13] = pos >> 32;\n+}\n+\n+void ChaCha20::Output(unsigned char* c, size_t bytes)\n+{\n+    uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    uint32_t j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n+    unsigned char *ctarget = NULL;\n+    unsigned char tmp[64];\n+    unsigned int i;\n+\n+    if (!bytes) return;\n+\n+    j0 = input[0];\n+    j1 = input[1];\n+    j2 = input[2];\n+    j3 = input[3];\n+    j4 = input[4];\n+    j5 = input[5];\n+    j6 = input[6];\n+    j7 = input[7];\n+    j8 = input[8];\n+    j9 = input[9];\n+    j10 = input[10];\n+    j11 = input[11];\n+    j12 = input[12];\n+    j13 = input[13];\n+    j14 = input[14];\n+    j15 = input[15];\n+\n+    for (;;) {\n+        if (bytes < 64) {\n+            ctarget = c;\n+            c = tmp;\n+        }\n+        x0 = j0;\n+        x1 = j1;\n+        x2 = j2;\n+        x3 = j3;\n+        x4 = j4;\n+        x5 = j5;\n+        x6 = j6;\n+        x7 = j7;\n+        x8 = j8;\n+        x9 = j9;\n+        x10 = j10;\n+        x11 = j11;\n+        x12 = j12;\n+        x13 = j13;\n+        x14 = j14;\n+        x15 = j15;\n+        for (i = 20;i > 0;i -= 2) {\n+            QUARTERROUND( x0, x4, x8,x12)\n+            QUARTERROUND( x1, x5, x9,x13)\n+            QUARTERROUND( x2, x6,x10,x14)\n+            QUARTERROUND( x3, x7,x11,x15)\n+            QUARTERROUND( x0, x5,x10,x15)\n+            QUARTERROUND( x1, x6,x11,x12)\n+            QUARTERROUND( x2, x7, x8,x13)\n+            QUARTERROUND( x3, x4, x9,x14)\n+        }\n+        x0 += j0;\n+        x1 += j1;\n+        x2 += j2;\n+        x3 += j3;\n+        x4 += j4;\n+        x5 += j5;\n+        x6 += j6;\n+        x7 += j7;\n+        x8 += j8;\n+        x9 += j9;\n+        x10 += j10;\n+        x11 += j11;\n+        x12 += j12;\n+        x13 += j13;\n+        x14 += j14;\n+        x15 += j15;\n+\n+        ++j12;\n+        if (!j12) ++j13;\n+\n+        WriteLE32(c + 0, x0);\n+        WriteLE32(c + 4, x1);\n+        WriteLE32(c + 8, x2);\n+        WriteLE32(c + 12, x3);\n+        WriteLE32(c + 16, x4);\n+        WriteLE32(c + 20, x5);\n+        WriteLE32(c + 24, x6);\n+        WriteLE32(c + 28, x7);\n+        WriteLE32(c + 32, x8);\n+        WriteLE32(c + 36, x9);\n+        WriteLE32(c + 40, x10);\n+        WriteLE32(c + 44, x11);\n+        WriteLE32(c + 48, x12);\n+        WriteLE32(c + 52, x13);\n+        WriteLE32(c + 56, x14);\n+        WriteLE32(c + 60, x15);\n+\n+        if (bytes <= 64) {\n+            if (bytes < 64) {\n+                for (i = 0;i < bytes;++i) ctarget[i] = c[i];\n+            }\n+            input[12] = j12;\n+            input[13] = j13;\n+            return;\n+        }\n+        bytes -= 64;\n+        c += 64;\n+    }\n+}"
      },
      {
        "sha": "a305977bcd5f4027cbb83b27a16622bab6f0c4c3",
        "filename": "src/crypto/chacha20.h",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/crypto/chacha20.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/crypto/chacha20.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/chacha20.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -0,0 +1,26 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CRYPTO_CHACHA20_H\n+#define BITCOIN_CRYPTO_CHACHA20_H\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+/** A PRNG class for ChaCha20. */\n+class ChaCha20\n+{\n+private:\n+    uint32_t input[16];\n+\n+public:\n+    ChaCha20();\n+    ChaCha20(const unsigned char* key, size_t keylen);\n+    void SetKey(const unsigned char* key, size_t keylen);\n+    void SetIV(uint64_t iv);\n+    void Seek(uint64_t pos);\n+    void Output(unsigned char* output, size_t bytes);\n+};\n+\n+#endif // BITCOIN_CRYPTO_CHACHA20_H"
      },
      {
        "sha": "bcca3d30ea7d686b4244049a3d63f28f50ca8d7c",
        "filename": "src/crypto/common.h",
        "status": "modified",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/crypto/common.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/crypto/common.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/common.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -79,4 +79,25 @@ void static inline WriteBE64(unsigned char* ptr, uint64_t x)\n     memcpy(ptr, (char*)&v, 8);\n }\n \n+/** Return the smallest number n such that (x >> n) == 0 (or 64 if the highest bit in x is set. */\n+uint64_t static inline CountBits(uint64_t x)\n+{\n+#ifdef HAVE_DECL___BUILTIN_CLZL\n+    if (sizeof(unsigned long) >= sizeof(uint64_t)) {\n+        return x ? 8 * sizeof(unsigned long) - __builtin_clzl(x) : 0;\n+    }\n+#endif\n+#ifdef HAVE_DECL___BUILTIN_CLZLL\n+    if (sizeof(unsigned long long) >= sizeof(uint64_t)) {\n+        return x ? 8 * sizeof(unsigned long long) - __builtin_clzll(x) : 0;\n+    }\n+#endif\n+    int ret = 0;\n+    while (x) {\n+        x >>= 1;\n+        ++ret;\n+    }\n+    return ret;\n+}\n+\n #endif // BITCOIN_CRYPTO_COMMON_H"
      },
      {
        "sha": "15d6db90c2469fdee46fda454a471ce6d506b258",
        "filename": "src/crypto/sha256.cpp",
        "status": "modified",
        "additions": 148,
        "deletions": 88,
        "changes": 236,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/crypto/sha256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/crypto/sha256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha256.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -3,10 +3,21 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"crypto/sha256.h\"\n-\n #include \"crypto/common.h\"\n \n+#include <assert.h>\n #include <string.h>\n+#include <atomic>\n+\n+#if defined(__x86_64__) || defined(__amd64__)\n+#if defined(EXPERIMENTAL_ASM)\n+#include <cpuid.h>\n+namespace sha256_sse4\n+{\n+void Transform(uint32_t* s, const unsigned char* chunk, size_t blocks);\n+}\n+#endif\n+#endif\n \n // Internal implementation code.\n namespace\n@@ -43,93 +54,142 @@ void inline Initialize(uint32_t* s)\n     s[7] = 0x5be0cd19ul;\n }\n \n-/** Perform one SHA-256 transformation, processing a 64-byte chunk. */\n-void Transform(uint32_t* s, const unsigned char* chunk)\n+/** Perform a number of SHA-256 transformations, processing 64-byte chunks. */\n+void Transform(uint32_t* s, const unsigned char* chunk, size_t blocks)\n {\n-    uint32_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4], f = s[5], g = s[6], h = s[7];\n-    uint32_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;\n-\n-    Round(a, b, c, d, e, f, g, h, 0x428a2f98, w0 = ReadBE32(chunk + 0));\n-    Round(h, a, b, c, d, e, f, g, 0x71374491, w1 = ReadBE32(chunk + 4));\n-    Round(g, h, a, b, c, d, e, f, 0xb5c0fbcf, w2 = ReadBE32(chunk + 8));\n-    Round(f, g, h, a, b, c, d, e, 0xe9b5dba5, w3 = ReadBE32(chunk + 12));\n-    Round(e, f, g, h, a, b, c, d, 0x3956c25b, w4 = ReadBE32(chunk + 16));\n-    Round(d, e, f, g, h, a, b, c, 0x59f111f1, w5 = ReadBE32(chunk + 20));\n-    Round(c, d, e, f, g, h, a, b, 0x923f82a4, w6 = ReadBE32(chunk + 24));\n-    Round(b, c, d, e, f, g, h, a, 0xab1c5ed5, w7 = ReadBE32(chunk + 28));\n-    Round(a, b, c, d, e, f, g, h, 0xd807aa98, w8 = ReadBE32(chunk + 32));\n-    Round(h, a, b, c, d, e, f, g, 0x12835b01, w9 = ReadBE32(chunk + 36));\n-    Round(g, h, a, b, c, d, e, f, 0x243185be, w10 = ReadBE32(chunk + 40));\n-    Round(f, g, h, a, b, c, d, e, 0x550c7dc3, w11 = ReadBE32(chunk + 44));\n-    Round(e, f, g, h, a, b, c, d, 0x72be5d74, w12 = ReadBE32(chunk + 48));\n-    Round(d, e, f, g, h, a, b, c, 0x80deb1fe, w13 = ReadBE32(chunk + 52));\n-    Round(c, d, e, f, g, h, a, b, 0x9bdc06a7, w14 = ReadBE32(chunk + 56));\n-    Round(b, c, d, e, f, g, h, a, 0xc19bf174, w15 = ReadBE32(chunk + 60));\n-\n-    Round(a, b, c, d, e, f, g, h, 0xe49b69c1, w0 += sigma1(w14) + w9 + sigma0(w1));\n-    Round(h, a, b, c, d, e, f, g, 0xefbe4786, w1 += sigma1(w15) + w10 + sigma0(w2));\n-    Round(g, h, a, b, c, d, e, f, 0x0fc19dc6, w2 += sigma1(w0) + w11 + sigma0(w3));\n-    Round(f, g, h, a, b, c, d, e, 0x240ca1cc, w3 += sigma1(w1) + w12 + sigma0(w4));\n-    Round(e, f, g, h, a, b, c, d, 0x2de92c6f, w4 += sigma1(w2) + w13 + sigma0(w5));\n-    Round(d, e, f, g, h, a, b, c, 0x4a7484aa, w5 += sigma1(w3) + w14 + sigma0(w6));\n-    Round(c, d, e, f, g, h, a, b, 0x5cb0a9dc, w6 += sigma1(w4) + w15 + sigma0(w7));\n-    Round(b, c, d, e, f, g, h, a, 0x76f988da, w7 += sigma1(w5) + w0 + sigma0(w8));\n-    Round(a, b, c, d, e, f, g, h, 0x983e5152, w8 += sigma1(w6) + w1 + sigma0(w9));\n-    Round(h, a, b, c, d, e, f, g, 0xa831c66d, w9 += sigma1(w7) + w2 + sigma0(w10));\n-    Round(g, h, a, b, c, d, e, f, 0xb00327c8, w10 += sigma1(w8) + w3 + sigma0(w11));\n-    Round(f, g, h, a, b, c, d, e, 0xbf597fc7, w11 += sigma1(w9) + w4 + sigma0(w12));\n-    Round(e, f, g, h, a, b, c, d, 0xc6e00bf3, w12 += sigma1(w10) + w5 + sigma0(w13));\n-    Round(d, e, f, g, h, a, b, c, 0xd5a79147, w13 += sigma1(w11) + w6 + sigma0(w14));\n-    Round(c, d, e, f, g, h, a, b, 0x06ca6351, w14 += sigma1(w12) + w7 + sigma0(w15));\n-    Round(b, c, d, e, f, g, h, a, 0x14292967, w15 += sigma1(w13) + w8 + sigma0(w0));\n-\n-    Round(a, b, c, d, e, f, g, h, 0x27b70a85, w0 += sigma1(w14) + w9 + sigma0(w1));\n-    Round(h, a, b, c, d, e, f, g, 0x2e1b2138, w1 += sigma1(w15) + w10 + sigma0(w2));\n-    Round(g, h, a, b, c, d, e, f, 0x4d2c6dfc, w2 += sigma1(w0) + w11 + sigma0(w3));\n-    Round(f, g, h, a, b, c, d, e, 0x53380d13, w3 += sigma1(w1) + w12 + sigma0(w4));\n-    Round(e, f, g, h, a, b, c, d, 0x650a7354, w4 += sigma1(w2) + w13 + sigma0(w5));\n-    Round(d, e, f, g, h, a, b, c, 0x766a0abb, w5 += sigma1(w3) + w14 + sigma0(w6));\n-    Round(c, d, e, f, g, h, a, b, 0x81c2c92e, w6 += sigma1(w4) + w15 + sigma0(w7));\n-    Round(b, c, d, e, f, g, h, a, 0x92722c85, w7 += sigma1(w5) + w0 + sigma0(w8));\n-    Round(a, b, c, d, e, f, g, h, 0xa2bfe8a1, w8 += sigma1(w6) + w1 + sigma0(w9));\n-    Round(h, a, b, c, d, e, f, g, 0xa81a664b, w9 += sigma1(w7) + w2 + sigma0(w10));\n-    Round(g, h, a, b, c, d, e, f, 0xc24b8b70, w10 += sigma1(w8) + w3 + sigma0(w11));\n-    Round(f, g, h, a, b, c, d, e, 0xc76c51a3, w11 += sigma1(w9) + w4 + sigma0(w12));\n-    Round(e, f, g, h, a, b, c, d, 0xd192e819, w12 += sigma1(w10) + w5 + sigma0(w13));\n-    Round(d, e, f, g, h, a, b, c, 0xd6990624, w13 += sigma1(w11) + w6 + sigma0(w14));\n-    Round(c, d, e, f, g, h, a, b, 0xf40e3585, w14 += sigma1(w12) + w7 + sigma0(w15));\n-    Round(b, c, d, e, f, g, h, a, 0x106aa070, w15 += sigma1(w13) + w8 + sigma0(w0));\n-\n-    Round(a, b, c, d, e, f, g, h, 0x19a4c116, w0 += sigma1(w14) + w9 + sigma0(w1));\n-    Round(h, a, b, c, d, e, f, g, 0x1e376c08, w1 += sigma1(w15) + w10 + sigma0(w2));\n-    Round(g, h, a, b, c, d, e, f, 0x2748774c, w2 += sigma1(w0) + w11 + sigma0(w3));\n-    Round(f, g, h, a, b, c, d, e, 0x34b0bcb5, w3 += sigma1(w1) + w12 + sigma0(w4));\n-    Round(e, f, g, h, a, b, c, d, 0x391c0cb3, w4 += sigma1(w2) + w13 + sigma0(w5));\n-    Round(d, e, f, g, h, a, b, c, 0x4ed8aa4a, w5 += sigma1(w3) + w14 + sigma0(w6));\n-    Round(c, d, e, f, g, h, a, b, 0x5b9cca4f, w6 += sigma1(w4) + w15 + sigma0(w7));\n-    Round(b, c, d, e, f, g, h, a, 0x682e6ff3, w7 += sigma1(w5) + w0 + sigma0(w8));\n-    Round(a, b, c, d, e, f, g, h, 0x748f82ee, w8 += sigma1(w6) + w1 + sigma0(w9));\n-    Round(h, a, b, c, d, e, f, g, 0x78a5636f, w9 += sigma1(w7) + w2 + sigma0(w10));\n-    Round(g, h, a, b, c, d, e, f, 0x84c87814, w10 += sigma1(w8) + w3 + sigma0(w11));\n-    Round(f, g, h, a, b, c, d, e, 0x8cc70208, w11 += sigma1(w9) + w4 + sigma0(w12));\n-    Round(e, f, g, h, a, b, c, d, 0x90befffa, w12 += sigma1(w10) + w5 + sigma0(w13));\n-    Round(d, e, f, g, h, a, b, c, 0xa4506ceb, w13 += sigma1(w11) + w6 + sigma0(w14));\n-    Round(c, d, e, f, g, h, a, b, 0xbef9a3f7, w14 + sigma1(w12) + w7 + sigma0(w15));\n-    Round(b, c, d, e, f, g, h, a, 0xc67178f2, w15 + sigma1(w13) + w8 + sigma0(w0));\n-\n-    s[0] += a;\n-    s[1] += b;\n-    s[2] += c;\n-    s[3] += d;\n-    s[4] += e;\n-    s[5] += f;\n-    s[6] += g;\n-    s[7] += h;\n+    while (blocks--) {\n+        uint32_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4], f = s[5], g = s[6], h = s[7];\n+        uint32_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;\n+\n+        Round(a, b, c, d, e, f, g, h, 0x428a2f98, w0 = ReadBE32(chunk + 0));\n+        Round(h, a, b, c, d, e, f, g, 0x71374491, w1 = ReadBE32(chunk + 4));\n+        Round(g, h, a, b, c, d, e, f, 0xb5c0fbcf, w2 = ReadBE32(chunk + 8));\n+        Round(f, g, h, a, b, c, d, e, 0xe9b5dba5, w3 = ReadBE32(chunk + 12));\n+        Round(e, f, g, h, a, b, c, d, 0x3956c25b, w4 = ReadBE32(chunk + 16));\n+        Round(d, e, f, g, h, a, b, c, 0x59f111f1, w5 = ReadBE32(chunk + 20));\n+        Round(c, d, e, f, g, h, a, b, 0x923f82a4, w6 = ReadBE32(chunk + 24));\n+        Round(b, c, d, e, f, g, h, a, 0xab1c5ed5, w7 = ReadBE32(chunk + 28));\n+        Round(a, b, c, d, e, f, g, h, 0xd807aa98, w8 = ReadBE32(chunk + 32));\n+        Round(h, a, b, c, d, e, f, g, 0x12835b01, w9 = ReadBE32(chunk + 36));\n+        Round(g, h, a, b, c, d, e, f, 0x243185be, w10 = ReadBE32(chunk + 40));\n+        Round(f, g, h, a, b, c, d, e, 0x550c7dc3, w11 = ReadBE32(chunk + 44));\n+        Round(e, f, g, h, a, b, c, d, 0x72be5d74, w12 = ReadBE32(chunk + 48));\n+        Round(d, e, f, g, h, a, b, c, 0x80deb1fe, w13 = ReadBE32(chunk + 52));\n+        Round(c, d, e, f, g, h, a, b, 0x9bdc06a7, w14 = ReadBE32(chunk + 56));\n+        Round(b, c, d, e, f, g, h, a, 0xc19bf174, w15 = ReadBE32(chunk + 60));\n+\n+        Round(a, b, c, d, e, f, g, h, 0xe49b69c1, w0 += sigma1(w14) + w9 + sigma0(w1));\n+        Round(h, a, b, c, d, e, f, g, 0xefbe4786, w1 += sigma1(w15) + w10 + sigma0(w2));\n+        Round(g, h, a, b, c, d, e, f, 0x0fc19dc6, w2 += sigma1(w0) + w11 + sigma0(w3));\n+        Round(f, g, h, a, b, c, d, e, 0x240ca1cc, w3 += sigma1(w1) + w12 + sigma0(w4));\n+        Round(e, f, g, h, a, b, c, d, 0x2de92c6f, w4 += sigma1(w2) + w13 + sigma0(w5));\n+        Round(d, e, f, g, h, a, b, c, 0x4a7484aa, w5 += sigma1(w3) + w14 + sigma0(w6));\n+        Round(c, d, e, f, g, h, a, b, 0x5cb0a9dc, w6 += sigma1(w4) + w15 + sigma0(w7));\n+        Round(b, c, d, e, f, g, h, a, 0x76f988da, w7 += sigma1(w5) + w0 + sigma0(w8));\n+        Round(a, b, c, d, e, f, g, h, 0x983e5152, w8 += sigma1(w6) + w1 + sigma0(w9));\n+        Round(h, a, b, c, d, e, f, g, 0xa831c66d, w9 += sigma1(w7) + w2 + sigma0(w10));\n+        Round(g, h, a, b, c, d, e, f, 0xb00327c8, w10 += sigma1(w8) + w3 + sigma0(w11));\n+        Round(f, g, h, a, b, c, d, e, 0xbf597fc7, w11 += sigma1(w9) + w4 + sigma0(w12));\n+        Round(e, f, g, h, a, b, c, d, 0xc6e00bf3, w12 += sigma1(w10) + w5 + sigma0(w13));\n+        Round(d, e, f, g, h, a, b, c, 0xd5a79147, w13 += sigma1(w11) + w6 + sigma0(w14));\n+        Round(c, d, e, f, g, h, a, b, 0x06ca6351, w14 += sigma1(w12) + w7 + sigma0(w15));\n+        Round(b, c, d, e, f, g, h, a, 0x14292967, w15 += sigma1(w13) + w8 + sigma0(w0));\n+\n+        Round(a, b, c, d, e, f, g, h, 0x27b70a85, w0 += sigma1(w14) + w9 + sigma0(w1));\n+        Round(h, a, b, c, d, e, f, g, 0x2e1b2138, w1 += sigma1(w15) + w10 + sigma0(w2));\n+        Round(g, h, a, b, c, d, e, f, 0x4d2c6dfc, w2 += sigma1(w0) + w11 + sigma0(w3));\n+        Round(f, g, h, a, b, c, d, e, 0x53380d13, w3 += sigma1(w1) + w12 + sigma0(w4));\n+        Round(e, f, g, h, a, b, c, d, 0x650a7354, w4 += sigma1(w2) + w13 + sigma0(w5));\n+        Round(d, e, f, g, h, a, b, c, 0x766a0abb, w5 += sigma1(w3) + w14 + sigma0(w6));\n+        Round(c, d, e, f, g, h, a, b, 0x81c2c92e, w6 += sigma1(w4) + w15 + sigma0(w7));\n+        Round(b, c, d, e, f, g, h, a, 0x92722c85, w7 += sigma1(w5) + w0 + sigma0(w8));\n+        Round(a, b, c, d, e, f, g, h, 0xa2bfe8a1, w8 += sigma1(w6) + w1 + sigma0(w9));\n+        Round(h, a, b, c, d, e, f, g, 0xa81a664b, w9 += sigma1(w7) + w2 + sigma0(w10));\n+        Round(g, h, a, b, c, d, e, f, 0xc24b8b70, w10 += sigma1(w8) + w3 + sigma0(w11));\n+        Round(f, g, h, a, b, c, d, e, 0xc76c51a3, w11 += sigma1(w9) + w4 + sigma0(w12));\n+        Round(e, f, g, h, a, b, c, d, 0xd192e819, w12 += sigma1(w10) + w5 + sigma0(w13));\n+        Round(d, e, f, g, h, a, b, c, 0xd6990624, w13 += sigma1(w11) + w6 + sigma0(w14));\n+        Round(c, d, e, f, g, h, a, b, 0xf40e3585, w14 += sigma1(w12) + w7 + sigma0(w15));\n+        Round(b, c, d, e, f, g, h, a, 0x106aa070, w15 += sigma1(w13) + w8 + sigma0(w0));\n+\n+        Round(a, b, c, d, e, f, g, h, 0x19a4c116, w0 += sigma1(w14) + w9 + sigma0(w1));\n+        Round(h, a, b, c, d, e, f, g, 0x1e376c08, w1 += sigma1(w15) + w10 + sigma0(w2));\n+        Round(g, h, a, b, c, d, e, f, 0x2748774c, w2 += sigma1(w0) + w11 + sigma0(w3));\n+        Round(f, g, h, a, b, c, d, e, 0x34b0bcb5, w3 += sigma1(w1) + w12 + sigma0(w4));\n+        Round(e, f, g, h, a, b, c, d, 0x391c0cb3, w4 += sigma1(w2) + w13 + sigma0(w5));\n+        Round(d, e, f, g, h, a, b, c, 0x4ed8aa4a, w5 += sigma1(w3) + w14 + sigma0(w6));\n+        Round(c, d, e, f, g, h, a, b, 0x5b9cca4f, w6 += sigma1(w4) + w15 + sigma0(w7));\n+        Round(b, c, d, e, f, g, h, a, 0x682e6ff3, w7 += sigma1(w5) + w0 + sigma0(w8));\n+        Round(a, b, c, d, e, f, g, h, 0x748f82ee, w8 += sigma1(w6) + w1 + sigma0(w9));\n+        Round(h, a, b, c, d, e, f, g, 0x78a5636f, w9 += sigma1(w7) + w2 + sigma0(w10));\n+        Round(g, h, a, b, c, d, e, f, 0x84c87814, w10 += sigma1(w8) + w3 + sigma0(w11));\n+        Round(f, g, h, a, b, c, d, e, 0x8cc70208, w11 += sigma1(w9) + w4 + sigma0(w12));\n+        Round(e, f, g, h, a, b, c, d, 0x90befffa, w12 += sigma1(w10) + w5 + sigma0(w13));\n+        Round(d, e, f, g, h, a, b, c, 0xa4506ceb, w13 += sigma1(w11) + w6 + sigma0(w14));\n+        Round(c, d, e, f, g, h, a, b, 0xbef9a3f7, w14 + sigma1(w12) + w7 + sigma0(w15));\n+        Round(b, c, d, e, f, g, h, a, 0xc67178f2, w15 + sigma1(w13) + w8 + sigma0(w0));\n+\n+        s[0] += a;\n+        s[1] += b;\n+        s[2] += c;\n+        s[3] += d;\n+        s[4] += e;\n+        s[5] += f;\n+        s[6] += g;\n+        s[7] += h;\n+        chunk += 64;\n+    }\n }\n \n } // namespace sha256\n+\n+typedef void (*TransformType)(uint32_t*, const unsigned char*, size_t);\n+\n+bool SelfTest(TransformType tr) {\n+    static const unsigned char in1[65] = {0, 0x80};\n+    static const unsigned char in2[129] = {\n+        0,\n+        32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, \n+        32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, \n+        0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0\n+    };\n+    static const uint32_t init[8] = {0x6a09e667ul, 0xbb67ae85ul, 0x3c6ef372ul, 0xa54ff53aul, 0x510e527ful, 0x9b05688cul, 0x1f83d9abul, 0x5be0cd19ul};\n+    static const uint32_t out1[8] = {0xe3b0c442ul, 0x98fc1c14ul, 0x9afbf4c8ul, 0x996fb924ul, 0x27ae41e4ul, 0x649b934cul, 0xa495991bul, 0x7852b855ul};\n+    static const uint32_t out2[8] = {0xce4153b0ul, 0x147c2a86ul, 0x3ed4298eul, 0xe0676bc8ul, 0x79fc77a1ul, 0x2abe1f49ul, 0xb2b055dful, 0x1069523eul};\n+    uint32_t buf[8];\n+    memcpy(buf, init, sizeof(buf));\n+    // Process nothing, and check we remain in the initial state.\n+    tr(buf, nullptr, 0);\n+    if (memcmp(buf, init, sizeof(buf))) return false;\n+    // Process the padded empty string (unaligned)\n+    tr(buf, in1 + 1, 1);\n+    if (memcmp(buf, out1, sizeof(buf))) return false;\n+    // Process 64 spaces (unaligned)\n+    memcpy(buf, init, sizeof(buf));\n+    tr(buf, in2 + 1, 2);\n+    if (memcmp(buf, out2, sizeof(buf))) return false;\n+    return true;\n+}\n+\n+TransformType Transform = sha256::Transform;\n+\n } // namespace\n \n+std::string SHA256AutoDetect()\n+{\n+#if defined(EXPERIMENTAL_ASM) && (defined(__x86_64__) || defined(__amd64__))\n+    uint32_t eax, ebx, ecx, edx;\n+    if (__get_cpuid(1, &eax, &ebx, &ecx, &edx) && (ecx >> 19) & 1) {\n+        Transform = sha256_sse4::Transform;\n+        assert(SelfTest(Transform));\n+        return \"sse4\";\n+    }\n+#endif\n+\n+    assert(SelfTest(Transform));\n+    return \"standard\";\n+}\n \n ////// SHA-256\n \n@@ -147,14 +207,14 @@ CSHA256& CSHA256::Write(const unsigned char* data, size_t len)\n         memcpy(buf + bufsize, data, 64 - bufsize);\n         bytes += 64 - bufsize;\n         data += 64 - bufsize;\n-        sha256::Transform(s, buf);\n+        Transform(s, buf, 1);\n         bufsize = 0;\n     }\n-    while (end >= data + 64) {\n-        // Process full chunks directly from the source.\n-        sha256::Transform(s, data);\n-        bytes += 64;\n-        data += 64;\n+    if (end - data >= 64) {\n+        size_t blocks = (end - data) / 64;\n+        Transform(s, data, blocks);\n+        data += 64 * blocks;\n+        bytes += 64 * blocks;\n     }\n     if (end > data) {\n         // Fill the buffer with what remains."
      },
      {
        "sha": "aa4f3972cc71c358fffabe31423b9f7c787c3488",
        "filename": "src/crypto/sha256.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/crypto/sha256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/crypto/sha256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha256.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -7,6 +7,7 @@\n \n #include <stdint.h>\n #include <stdlib.h>\n+#include <string>\n \n /** A hasher class for SHA-256. */\n class CSHA256\n@@ -25,4 +26,9 @@ class CSHA256\n     CSHA256& Reset();\n };\n \n+/** Autodetect the best available SHA256 implementation.\n+ *  Returns the name of the implementation.\n+ */\n+std::string SHA256AutoDetect();\n+\n #endif // BITCOIN_CRYPTO_SHA256_H"
      },
      {
        "sha": "89f529a3abcff52044b0db662aa857518c523e80",
        "filename": "src/crypto/sha256_sse4.cpp",
        "status": "added",
        "additions": 1506,
        "deletions": 0,
        "changes": 1506,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/crypto/sha256_sse4.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/crypto/sha256_sse4.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha256_sse4.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -0,0 +1,1506 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+//\n+// This is a translation to GCC extended asm syntax from YASM code by Intel\n+// (available at the bottom of this file).\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+#if defined(__x86_64__) || defined(__amd64__)\n+\n+namespace sha256_sse4\n+{\n+void Transform(uint32_t* s, const unsigned char* chunk, size_t blocks)\n+{\n+    static const uint32_t K256 alignas(16) [] = {\n+        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n+        0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n+        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n+        0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n+        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n+        0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n+        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n+        0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n+        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n+        0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n+        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n+        0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n+        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n+        0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n+        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n+        0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\n+    };\n+    static const uint32_t FLIP_MASK alignas(16) [] = {0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f};\n+    static const uint32_t SHUF_00BA alignas(16) [] = {0x03020100, 0x0b0a0908, 0xffffffff, 0xffffffff};\n+    static const uint32_t SHUF_DC00 alignas(16) [] = {0xffffffff, 0xffffffff, 0x03020100, 0x0b0a0908};\n+    uint32_t a, b, c, d, f, g, h, y0, y1, y2;\n+    uint64_t tbl;\n+    uint64_t inp_end, inp;\n+    uint32_t xfer alignas(16) [4];\n+\n+    __asm__ __volatile__(\n+        \"shl    $0x6,%2;\"\n+        \"je     Ldone_hash_%=;\"\n+        \"add    %1,%2;\"\n+        \"mov    %2,%14;\"\n+        \"mov    (%0),%3;\"\n+        \"mov    0x4(%0),%4;\"\n+        \"mov    0x8(%0),%5;\"\n+        \"mov    0xc(%0),%6;\"\n+        \"mov    0x10(%0),%k2;\"\n+        \"mov    0x14(%0),%7;\"\n+        \"mov    0x18(%0),%8;\"\n+        \"mov    0x1c(%0),%9;\"\n+        \"movdqa %18,%%xmm12;\"\n+        \"movdqa %19,%%xmm10;\"\n+        \"movdqa %20,%%xmm11;\"\n+\n+        \"Lloop0_%=:\"\n+        \"lea    %17,%13;\"\n+        \"movdqu (%1),%%xmm4;\"\n+        \"pshufb %%xmm12,%%xmm4;\"\n+        \"movdqu 0x10(%1),%%xmm5;\"\n+        \"pshufb %%xmm12,%%xmm5;\"\n+        \"movdqu 0x20(%1),%%xmm6;\"\n+        \"pshufb %%xmm12,%%xmm6;\"\n+        \"movdqu 0x30(%1),%%xmm7;\"\n+        \"pshufb %%xmm12,%%xmm7;\"\n+        \"mov    %1,%15;\"\n+        \"mov    $3,%1;\"\n+\n+        \"Lloop1_%=:\"\n+        \"movdqa 0x0(%13),%%xmm9;\"\n+        \"paddd  %%xmm4,%%xmm9;\"\n+        \"movdqa %%xmm9,%16;\"\n+        \"movdqa %%xmm7,%%xmm0;\"\n+        \"mov    %k2,%10;\"\n+        \"ror    $0xe,%10;\"\n+        \"mov    %3,%11;\"\n+        \"palignr $0x4,%%xmm6,%%xmm0;\"\n+        \"ror    $0x9,%11;\"\n+        \"xor    %k2,%10;\"\n+        \"mov    %7,%12;\"\n+        \"ror    $0x5,%10;\"\n+        \"movdqa %%xmm5,%%xmm1;\"\n+        \"xor    %3,%11;\"\n+        \"xor    %8,%12;\"\n+        \"paddd  %%xmm4,%%xmm0;\"\n+        \"xor    %k2,%10;\"\n+        \"and    %k2,%12;\"\n+        \"ror    $0xb,%11;\"\n+        \"palignr $0x4,%%xmm4,%%xmm1;\"\n+        \"xor    %3,%11;\"\n+        \"ror    $0x6,%10;\"\n+        \"xor    %8,%12;\"\n+        \"movdqa %%xmm1,%%xmm2;\"\n+        \"ror    $0x2,%11;\"\n+        \"add    %10,%12;\"\n+        \"add    %16,%12;\"\n+        \"movdqa %%xmm1,%%xmm3;\"\n+        \"mov    %3,%10;\"\n+        \"add    %12,%9;\"\n+        \"mov    %3,%12;\"\n+        \"pslld  $0x19,%%xmm1;\"\n+        \"or     %5,%10;\"\n+        \"add    %9,%6;\"\n+        \"and    %5,%12;\"\n+        \"psrld  $0x7,%%xmm2;\"\n+        \"and    %4,%10;\"\n+        \"add    %11,%9;\"\n+        \"por    %%xmm2,%%xmm1;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%9;\"\n+        \"movdqa %%xmm3,%%xmm2;\"\n+        \"mov    %6,%10;\"\n+        \"mov    %9,%11;\"\n+        \"movdqa %%xmm3,%%xmm8;\"\n+        \"ror    $0xe,%10;\"\n+        \"xor    %6,%10;\"\n+        \"mov    %k2,%12;\"\n+        \"ror    $0x9,%11;\"\n+        \"pslld  $0xe,%%xmm3;\"\n+        \"xor    %9,%11;\"\n+        \"ror    $0x5,%10;\"\n+        \"xor    %7,%12;\"\n+        \"psrld  $0x12,%%xmm2;\"\n+        \"ror    $0xb,%11;\"\n+        \"xor    %6,%10;\"\n+        \"and    %6,%12;\"\n+        \"ror    $0x6,%10;\"\n+        \"pxor   %%xmm3,%%xmm1;\"\n+        \"xor    %9,%11;\"\n+        \"xor    %7,%12;\"\n+        \"psrld  $0x3,%%xmm8;\"\n+        \"add    %10,%12;\"\n+        \"add    4+%16,%12;\"\n+        \"ror    $0x2,%11;\"\n+        \"pxor   %%xmm2,%%xmm1;\"\n+        \"mov    %9,%10;\"\n+        \"add    %12,%8;\"\n+        \"mov    %9,%12;\"\n+        \"pxor   %%xmm8,%%xmm1;\"\n+        \"or     %4,%10;\"\n+        \"add    %8,%5;\"\n+        \"and    %4,%12;\"\n+        \"pshufd $0xfa,%%xmm7,%%xmm2;\"\n+        \"and    %3,%10;\"\n+        \"add    %11,%8;\"\n+        \"paddd  %%xmm1,%%xmm0;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%8;\"\n+        \"movdqa %%xmm2,%%xmm3;\"\n+        \"mov    %5,%10;\"\n+        \"mov    %8,%11;\"\n+        \"ror    $0xe,%10;\"\n+        \"movdqa %%xmm2,%%xmm8;\"\n+        \"xor    %5,%10;\"\n+        \"ror    $0x9,%11;\"\n+        \"mov    %6,%12;\"\n+        \"xor    %8,%11;\"\n+        \"ror    $0x5,%10;\"\n+        \"psrlq  $0x11,%%xmm2;\"\n+        \"xor    %k2,%12;\"\n+        \"psrlq  $0x13,%%xmm3;\"\n+        \"xor    %5,%10;\"\n+        \"and    %5,%12;\"\n+        \"psrld  $0xa,%%xmm8;\"\n+        \"ror    $0xb,%11;\"\n+        \"xor    %8,%11;\"\n+        \"xor    %k2,%12;\"\n+        \"ror    $0x6,%10;\"\n+        \"pxor   %%xmm3,%%xmm2;\"\n+        \"add    %10,%12;\"\n+        \"ror    $0x2,%11;\"\n+        \"add    8+%16,%12;\"\n+        \"pxor   %%xmm2,%%xmm8;\"\n+        \"mov    %8,%10;\"\n+        \"add    %12,%7;\"\n+        \"mov    %8,%12;\"\n+        \"pshufb %%xmm10,%%xmm8;\"\n+        \"or     %3,%10;\"\n+        \"add    %7,%4;\"\n+        \"and    %3,%12;\"\n+        \"paddd  %%xmm8,%%xmm0;\"\n+        \"and    %9,%10;\"\n+        \"add    %11,%7;\"\n+        \"pshufd $0x50,%%xmm0,%%xmm2;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%7;\"\n+        \"movdqa %%xmm2,%%xmm3;\"\n+        \"mov    %4,%10;\"\n+        \"ror    $0xe,%10;\"\n+        \"mov    %7,%11;\"\n+        \"movdqa %%xmm2,%%xmm4;\"\n+        \"ror    $0x9,%11;\"\n+        \"xor    %4,%10;\"\n+        \"mov    %5,%12;\"\n+        \"ror    $0x5,%10;\"\n+        \"psrlq  $0x11,%%xmm2;\"\n+        \"xor    %7,%11;\"\n+        \"xor    %6,%12;\"\n+        \"psrlq  $0x13,%%xmm3;\"\n+        \"xor    %4,%10;\"\n+        \"and    %4,%12;\"\n+        \"ror    $0xb,%11;\"\n+        \"psrld  $0xa,%%xmm4;\"\n+        \"xor    %7,%11;\"\n+        \"ror    $0x6,%10;\"\n+        \"xor    %6,%12;\"\n+        \"pxor   %%xmm3,%%xmm2;\"\n+        \"ror    $0x2,%11;\"\n+        \"add    %10,%12;\"\n+        \"add    12+%16,%12;\"\n+        \"pxor   %%xmm2,%%xmm4;\"\n+        \"mov    %7,%10;\"\n+        \"add    %12,%k2;\"\n+        \"mov    %7,%12;\"\n+        \"pshufb %%xmm11,%%xmm4;\"\n+        \"or     %9,%10;\"\n+        \"add    %k2,%3;\"\n+        \"and    %9,%12;\"\n+        \"paddd  %%xmm0,%%xmm4;\"\n+        \"and    %8,%10;\"\n+        \"add    %11,%k2;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%k2;\"\n+        \"movdqa 0x10(%13),%%xmm9;\"\n+        \"paddd  %%xmm5,%%xmm9;\"\n+        \"movdqa %%xmm9,%16;\"\n+        \"movdqa %%xmm4,%%xmm0;\"\n+        \"mov    %3,%10;\"\n+        \"ror    $0xe,%10;\"\n+        \"mov    %k2,%11;\"\n+        \"palignr $0x4,%%xmm7,%%xmm0;\"\n+        \"ror    $0x9,%11;\"\n+        \"xor    %3,%10;\"\n+        \"mov    %4,%12;\"\n+        \"ror    $0x5,%10;\"\n+        \"movdqa %%xmm6,%%xmm1;\"\n+        \"xor    %k2,%11;\"\n+        \"xor    %5,%12;\"\n+        \"paddd  %%xmm5,%%xmm0;\"\n+        \"xor    %3,%10;\"\n+        \"and    %3,%12;\"\n+        \"ror    $0xb,%11;\"\n+        \"palignr $0x4,%%xmm5,%%xmm1;\"\n+        \"xor    %k2,%11;\"\n+        \"ror    $0x6,%10;\"\n+        \"xor    %5,%12;\"\n+        \"movdqa %%xmm1,%%xmm2;\"\n+        \"ror    $0x2,%11;\"\n+        \"add    %10,%12;\"\n+        \"add    %16,%12;\"\n+        \"movdqa %%xmm1,%%xmm3;\"\n+        \"mov    %k2,%10;\"\n+        \"add    %12,%6;\"\n+        \"mov    %k2,%12;\"\n+        \"pslld  $0x19,%%xmm1;\"\n+        \"or     %8,%10;\"\n+        \"add    %6,%9;\"\n+        \"and    %8,%12;\"\n+        \"psrld  $0x7,%%xmm2;\"\n+        \"and    %7,%10;\"\n+        \"add    %11,%6;\"\n+        \"por    %%xmm2,%%xmm1;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%6;\"\n+        \"movdqa %%xmm3,%%xmm2;\"\n+        \"mov    %9,%10;\"\n+        \"mov    %6,%11;\"\n+        \"movdqa %%xmm3,%%xmm8;\"\n+        \"ror    $0xe,%10;\"\n+        \"xor    %9,%10;\"\n+        \"mov    %3,%12;\"\n+        \"ror    $0x9,%11;\"\n+        \"pslld  $0xe,%%xmm3;\"\n+        \"xor    %6,%11;\"\n+        \"ror    $0x5,%10;\"\n+        \"xor    %4,%12;\"\n+        \"psrld  $0x12,%%xmm2;\"\n+        \"ror    $0xb,%11;\"\n+        \"xor    %9,%10;\"\n+        \"and    %9,%12;\"\n+        \"ror    $0x6,%10;\"\n+        \"pxor   %%xmm3,%%xmm1;\"\n+        \"xor    %6,%11;\"\n+        \"xor    %4,%12;\"\n+        \"psrld  $0x3,%%xmm8;\"\n+        \"add    %10,%12;\"\n+        \"add    4+%16,%12;\"\n+        \"ror    $0x2,%11;\"\n+        \"pxor   %%xmm2,%%xmm1;\"\n+        \"mov    %6,%10;\"\n+        \"add    %12,%5;\"\n+        \"mov    %6,%12;\"\n+        \"pxor   %%xmm8,%%xmm1;\"\n+        \"or     %7,%10;\"\n+        \"add    %5,%8;\"\n+        \"and    %7,%12;\"\n+        \"pshufd $0xfa,%%xmm4,%%xmm2;\"\n+        \"and    %k2,%10;\"\n+        \"add    %11,%5;\"\n+        \"paddd  %%xmm1,%%xmm0;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%5;\"\n+        \"movdqa %%xmm2,%%xmm3;\"\n+        \"mov    %8,%10;\"\n+        \"mov    %5,%11;\"\n+        \"ror    $0xe,%10;\"\n+        \"movdqa %%xmm2,%%xmm8;\"\n+        \"xor    %8,%10;\"\n+        \"ror    $0x9,%11;\"\n+        \"mov    %9,%12;\"\n+        \"xor    %5,%11;\"\n+        \"ror    $0x5,%10;\"\n+        \"psrlq  $0x11,%%xmm2;\"\n+        \"xor    %3,%12;\"\n+        \"psrlq  $0x13,%%xmm3;\"\n+        \"xor    %8,%10;\"\n+        \"and    %8,%12;\"\n+        \"psrld  $0xa,%%xmm8;\"\n+        \"ror    $0xb,%11;\"\n+        \"xor    %5,%11;\"\n+        \"xor    %3,%12;\"\n+        \"ror    $0x6,%10;\"\n+        \"pxor   %%xmm3,%%xmm2;\"\n+        \"add    %10,%12;\"\n+        \"ror    $0x2,%11;\"\n+        \"add    8+%16,%12;\"\n+        \"pxor   %%xmm2,%%xmm8;\"\n+        \"mov    %5,%10;\"\n+        \"add    %12,%4;\"\n+        \"mov    %5,%12;\"\n+        \"pshufb %%xmm10,%%xmm8;\"\n+        \"or     %k2,%10;\"\n+        \"add    %4,%7;\"\n+        \"and    %k2,%12;\"\n+        \"paddd  %%xmm8,%%xmm0;\"\n+        \"and    %6,%10;\"\n+        \"add    %11,%4;\"\n+        \"pshufd $0x50,%%xmm0,%%xmm2;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%4;\"\n+        \"movdqa %%xmm2,%%xmm3;\"\n+        \"mov    %7,%10;\"\n+        \"ror    $0xe,%10;\"\n+        \"mov    %4,%11;\"\n+        \"movdqa %%xmm2,%%xmm5;\"\n+        \"ror    $0x9,%11;\"\n+        \"xor    %7,%10;\"\n+        \"mov    %8,%12;\"\n+        \"ror    $0x5,%10;\"\n+        \"psrlq  $0x11,%%xmm2;\"\n+        \"xor    %4,%11;\"\n+        \"xor    %9,%12;\"\n+        \"psrlq  $0x13,%%xmm3;\"\n+        \"xor    %7,%10;\"\n+        \"and    %7,%12;\"\n+        \"ror    $0xb,%11;\"\n+        \"psrld  $0xa,%%xmm5;\"\n+        \"xor    %4,%11;\"\n+        \"ror    $0x6,%10;\"\n+        \"xor    %9,%12;\"\n+        \"pxor   %%xmm3,%%xmm2;\"\n+        \"ror    $0x2,%11;\"\n+        \"add    %10,%12;\"\n+        \"add    12+%16,%12;\"\n+        \"pxor   %%xmm2,%%xmm5;\"\n+        \"mov    %4,%10;\"\n+        \"add    %12,%3;\"\n+        \"mov    %4,%12;\"\n+        \"pshufb %%xmm11,%%xmm5;\"\n+        \"or     %6,%10;\"\n+        \"add    %3,%k2;\"\n+        \"and    %6,%12;\"\n+        \"paddd  %%xmm0,%%xmm5;\"\n+        \"and    %5,%10;\"\n+        \"add    %11,%3;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%3;\"\n+        \"movdqa 0x20(%13),%%xmm9;\"\n+        \"paddd  %%xmm6,%%xmm9;\"\n+        \"movdqa %%xmm9,%16;\"\n+        \"movdqa %%xmm5,%%xmm0;\"\n+        \"mov    %k2,%10;\"\n+        \"ror    $0xe,%10;\"\n+        \"mov    %3,%11;\"\n+        \"palignr $0x4,%%xmm4,%%xmm0;\"\n+        \"ror    $0x9,%11;\"\n+        \"xor    %k2,%10;\"\n+        \"mov    %7,%12;\"\n+        \"ror    $0x5,%10;\"\n+        \"movdqa %%xmm7,%%xmm1;\"\n+        \"xor    %3,%11;\"\n+        \"xor    %8,%12;\"\n+        \"paddd  %%xmm6,%%xmm0;\"\n+        \"xor    %k2,%10;\"\n+        \"and    %k2,%12;\"\n+        \"ror    $0xb,%11;\"\n+        \"palignr $0x4,%%xmm6,%%xmm1;\"\n+        \"xor    %3,%11;\"\n+        \"ror    $0x6,%10;\"\n+        \"xor    %8,%12;\"\n+        \"movdqa %%xmm1,%%xmm2;\"\n+        \"ror    $0x2,%11;\"\n+        \"add    %10,%12;\"\n+        \"add    %16,%12;\"\n+        \"movdqa %%xmm1,%%xmm3;\"\n+        \"mov    %3,%10;\"\n+        \"add    %12,%9;\"\n+        \"mov    %3,%12;\"\n+        \"pslld  $0x19,%%xmm1;\"\n+        \"or     %5,%10;\"\n+        \"add    %9,%6;\"\n+        \"and    %5,%12;\"\n+        \"psrld  $0x7,%%xmm2;\"\n+        \"and    %4,%10;\"\n+        \"add    %11,%9;\"\n+        \"por    %%xmm2,%%xmm1;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%9;\"\n+        \"movdqa %%xmm3,%%xmm2;\"\n+        \"mov    %6,%10;\"\n+        \"mov    %9,%11;\"\n+        \"movdqa %%xmm3,%%xmm8;\"\n+        \"ror    $0xe,%10;\"\n+        \"xor    %6,%10;\"\n+        \"mov    %k2,%12;\"\n+        \"ror    $0x9,%11;\"\n+        \"pslld  $0xe,%%xmm3;\"\n+        \"xor    %9,%11;\"\n+        \"ror    $0x5,%10;\"\n+        \"xor    %7,%12;\"\n+        \"psrld  $0x12,%%xmm2;\"\n+        \"ror    $0xb,%11;\"\n+        \"xor    %6,%10;\"\n+        \"and    %6,%12;\"\n+        \"ror    $0x6,%10;\"\n+        \"pxor   %%xmm3,%%xmm1;\"\n+        \"xor    %9,%11;\"\n+        \"xor    %7,%12;\"\n+        \"psrld  $0x3,%%xmm8;\"\n+        \"add    %10,%12;\"\n+        \"add    4+%16,%12;\"\n+        \"ror    $0x2,%11;\"\n+        \"pxor   %%xmm2,%%xmm1;\"\n+        \"mov    %9,%10;\"\n+        \"add    %12,%8;\"\n+        \"mov    %9,%12;\"\n+        \"pxor   %%xmm8,%%xmm1;\"\n+        \"or     %4,%10;\"\n+        \"add    %8,%5;\"\n+        \"and    %4,%12;\"\n+        \"pshufd $0xfa,%%xmm5,%%xmm2;\"\n+        \"and    %3,%10;\"\n+        \"add    %11,%8;\"\n+        \"paddd  %%xmm1,%%xmm0;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%8;\"\n+        \"movdqa %%xmm2,%%xmm3;\"\n+        \"mov    %5,%10;\"\n+        \"mov    %8,%11;\"\n+        \"ror    $0xe,%10;\"\n+        \"movdqa %%xmm2,%%xmm8;\"\n+        \"xor    %5,%10;\"\n+        \"ror    $0x9,%11;\"\n+        \"mov    %6,%12;\"\n+        \"xor    %8,%11;\"\n+        \"ror    $0x5,%10;\"\n+        \"psrlq  $0x11,%%xmm2;\"\n+        \"xor    %k2,%12;\"\n+        \"psrlq  $0x13,%%xmm3;\"\n+        \"xor    %5,%10;\"\n+        \"and    %5,%12;\"\n+        \"psrld  $0xa,%%xmm8;\"\n+        \"ror    $0xb,%11;\"\n+        \"xor    %8,%11;\"\n+        \"xor    %k2,%12;\"\n+        \"ror    $0x6,%10;\"\n+        \"pxor   %%xmm3,%%xmm2;\"\n+        \"add    %10,%12;\"\n+        \"ror    $0x2,%11;\"\n+        \"add    8+%16,%12;\"\n+        \"pxor   %%xmm2,%%xmm8;\"\n+        \"mov    %8,%10;\"\n+        \"add    %12,%7;\"\n+        \"mov    %8,%12;\"\n+        \"pshufb %%xmm10,%%xmm8;\"\n+        \"or     %3,%10;\"\n+        \"add    %7,%4;\"\n+        \"and    %3,%12;\"\n+        \"paddd  %%xmm8,%%xmm0;\"\n+        \"and    %9,%10;\"\n+        \"add    %11,%7;\"\n+        \"pshufd $0x50,%%xmm0,%%xmm2;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%7;\"\n+        \"movdqa %%xmm2,%%xmm3;\"\n+        \"mov    %4,%10;\"\n+        \"ror    $0xe,%10;\"\n+        \"mov    %7,%11;\"\n+        \"movdqa %%xmm2,%%xmm6;\"\n+        \"ror    $0x9,%11;\"\n+        \"xor    %4,%10;\"\n+        \"mov    %5,%12;\"\n+        \"ror    $0x5,%10;\"\n+        \"psrlq  $0x11,%%xmm2;\"\n+        \"xor    %7,%11;\"\n+        \"xor    %6,%12;\"\n+        \"psrlq  $0x13,%%xmm3;\"\n+        \"xor    %4,%10;\"\n+        \"and    %4,%12;\"\n+        \"ror    $0xb,%11;\"\n+        \"psrld  $0xa,%%xmm6;\"\n+        \"xor    %7,%11;\"\n+        \"ror    $0x6,%10;\"\n+        \"xor    %6,%12;\"\n+        \"pxor   %%xmm3,%%xmm2;\"\n+        \"ror    $0x2,%11;\"\n+        \"add    %10,%12;\"\n+        \"add    12+%16,%12;\"\n+        \"pxor   %%xmm2,%%xmm6;\"\n+        \"mov    %7,%10;\"\n+        \"add    %12,%k2;\"\n+        \"mov    %7,%12;\"\n+        \"pshufb %%xmm11,%%xmm6;\"\n+        \"or     %9,%10;\"\n+        \"add    %k2,%3;\"\n+        \"and    %9,%12;\"\n+        \"paddd  %%xmm0,%%xmm6;\"\n+        \"and    %8,%10;\"\n+        \"add    %11,%k2;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%k2;\"\n+        \"movdqa 0x30(%13),%%xmm9;\"\n+        \"paddd  %%xmm7,%%xmm9;\"\n+        \"movdqa %%xmm9,%16;\"\n+        \"add    $0x40,%13;\"\n+        \"movdqa %%xmm6,%%xmm0;\"\n+        \"mov    %3,%10;\"\n+        \"ror    $0xe,%10;\"\n+        \"mov    %k2,%11;\"\n+        \"palignr $0x4,%%xmm5,%%xmm0;\"\n+        \"ror    $0x9,%11;\"\n+        \"xor    %3,%10;\"\n+        \"mov    %4,%12;\"\n+        \"ror    $0x5,%10;\"\n+        \"movdqa %%xmm4,%%xmm1;\"\n+        \"xor    %k2,%11;\"\n+        \"xor    %5,%12;\"\n+        \"paddd  %%xmm7,%%xmm0;\"\n+        \"xor    %3,%10;\"\n+        \"and    %3,%12;\"\n+        \"ror    $0xb,%11;\"\n+        \"palignr $0x4,%%xmm7,%%xmm1;\"\n+        \"xor    %k2,%11;\"\n+        \"ror    $0x6,%10;\"\n+        \"xor    %5,%12;\"\n+        \"movdqa %%xmm1,%%xmm2;\"\n+        \"ror    $0x2,%11;\"\n+        \"add    %10,%12;\"\n+        \"add    %16,%12;\"\n+        \"movdqa %%xmm1,%%xmm3;\"\n+        \"mov    %k2,%10;\"\n+        \"add    %12,%6;\"\n+        \"mov    %k2,%12;\"\n+        \"pslld  $0x19,%%xmm1;\"\n+        \"or     %8,%10;\"\n+        \"add    %6,%9;\"\n+        \"and    %8,%12;\"\n+        \"psrld  $0x7,%%xmm2;\"\n+        \"and    %7,%10;\"\n+        \"add    %11,%6;\"\n+        \"por    %%xmm2,%%xmm1;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%6;\"\n+        \"movdqa %%xmm3,%%xmm2;\"\n+        \"mov    %9,%10;\"\n+        \"mov    %6,%11;\"\n+        \"movdqa %%xmm3,%%xmm8;\"\n+        \"ror    $0xe,%10;\"\n+        \"xor    %9,%10;\"\n+        \"mov    %3,%12;\"\n+        \"ror    $0x9,%11;\"\n+        \"pslld  $0xe,%%xmm3;\"\n+        \"xor    %6,%11;\"\n+        \"ror    $0x5,%10;\"\n+        \"xor    %4,%12;\"\n+        \"psrld  $0x12,%%xmm2;\"\n+        \"ror    $0xb,%11;\"\n+        \"xor    %9,%10;\"\n+        \"and    %9,%12;\"\n+        \"ror    $0x6,%10;\"\n+        \"pxor   %%xmm3,%%xmm1;\"\n+        \"xor    %6,%11;\"\n+        \"xor    %4,%12;\"\n+        \"psrld  $0x3,%%xmm8;\"\n+        \"add    %10,%12;\"\n+        \"add    4+%16,%12;\"\n+        \"ror    $0x2,%11;\"\n+        \"pxor   %%xmm2,%%xmm1;\"\n+        \"mov    %6,%10;\"\n+        \"add    %12,%5;\"\n+        \"mov    %6,%12;\"\n+        \"pxor   %%xmm8,%%xmm1;\"\n+        \"or     %7,%10;\"\n+        \"add    %5,%8;\"\n+        \"and    %7,%12;\"\n+        \"pshufd $0xfa,%%xmm6,%%xmm2;\"\n+        \"and    %k2,%10;\"\n+        \"add    %11,%5;\"\n+        \"paddd  %%xmm1,%%xmm0;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%5;\"\n+        \"movdqa %%xmm2,%%xmm3;\"\n+        \"mov    %8,%10;\"\n+        \"mov    %5,%11;\"\n+        \"ror    $0xe,%10;\"\n+        \"movdqa %%xmm2,%%xmm8;\"\n+        \"xor    %8,%10;\"\n+        \"ror    $0x9,%11;\"\n+        \"mov    %9,%12;\"\n+        \"xor    %5,%11;\"\n+        \"ror    $0x5,%10;\"\n+        \"psrlq  $0x11,%%xmm2;\"\n+        \"xor    %3,%12;\"\n+        \"psrlq  $0x13,%%xmm3;\"\n+        \"xor    %8,%10;\"\n+        \"and    %8,%12;\"\n+        \"psrld  $0xa,%%xmm8;\"\n+        \"ror    $0xb,%11;\"\n+        \"xor    %5,%11;\"\n+        \"xor    %3,%12;\"\n+        \"ror    $0x6,%10;\"\n+        \"pxor   %%xmm3,%%xmm2;\"\n+        \"add    %10,%12;\"\n+        \"ror    $0x2,%11;\"\n+        \"add    8+%16,%12;\"\n+        \"pxor   %%xmm2,%%xmm8;\"\n+        \"mov    %5,%10;\"\n+        \"add    %12,%4;\"\n+        \"mov    %5,%12;\"\n+        \"pshufb %%xmm10,%%xmm8;\"\n+        \"or     %k2,%10;\"\n+        \"add    %4,%7;\"\n+        \"and    %k2,%12;\"\n+        \"paddd  %%xmm8,%%xmm0;\"\n+        \"and    %6,%10;\"\n+        \"add    %11,%4;\"\n+        \"pshufd $0x50,%%xmm0,%%xmm2;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%4;\"\n+        \"movdqa %%xmm2,%%xmm3;\"\n+        \"mov    %7,%10;\"\n+        \"ror    $0xe,%10;\"\n+        \"mov    %4,%11;\"\n+        \"movdqa %%xmm2,%%xmm7;\"\n+        \"ror    $0x9,%11;\"\n+        \"xor    %7,%10;\"\n+        \"mov    %8,%12;\"\n+        \"ror    $0x5,%10;\"\n+        \"psrlq  $0x11,%%xmm2;\"\n+        \"xor    %4,%11;\"\n+        \"xor    %9,%12;\"\n+        \"psrlq  $0x13,%%xmm3;\"\n+        \"xor    %7,%10;\"\n+        \"and    %7,%12;\"\n+        \"ror    $0xb,%11;\"\n+        \"psrld  $0xa,%%xmm7;\"\n+        \"xor    %4,%11;\"\n+        \"ror    $0x6,%10;\"\n+        \"xor    %9,%12;\"\n+        \"pxor   %%xmm3,%%xmm2;\"\n+        \"ror    $0x2,%11;\"\n+        \"add    %10,%12;\"\n+        \"add    12+%16,%12;\"\n+        \"pxor   %%xmm2,%%xmm7;\"\n+        \"mov    %4,%10;\"\n+        \"add    %12,%3;\"\n+        \"mov    %4,%12;\"\n+        \"pshufb %%xmm11,%%xmm7;\"\n+        \"or     %6,%10;\"\n+        \"add    %3,%k2;\"\n+        \"and    %6,%12;\"\n+        \"paddd  %%xmm0,%%xmm7;\"\n+        \"and    %5,%10;\"\n+        \"add    %11,%3;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%3;\"\n+        \"sub    $0x1,%1;\"\n+        \"jne    Lloop1_%=;\"\n+        \"mov    $0x2,%1;\"\n+\n+        \"Lloop2_%=:\"\n+        \"paddd  0x0(%13),%%xmm4;\"\n+        \"movdqa %%xmm4,%16;\"\n+        \"mov    %k2,%10;\"\n+        \"ror    $0xe,%10;\"\n+        \"mov    %3,%11;\"\n+        \"xor    %k2,%10;\"\n+        \"ror    $0x9,%11;\"\n+        \"mov    %7,%12;\"\n+        \"xor    %3,%11;\"\n+        \"ror    $0x5,%10;\"\n+        \"xor    %8,%12;\"\n+        \"xor    %k2,%10;\"\n+        \"ror    $0xb,%11;\"\n+        \"and    %k2,%12;\"\n+        \"xor    %3,%11;\"\n+        \"ror    $0x6,%10;\"\n+        \"xor    %8,%12;\"\n+        \"add    %10,%12;\"\n+        \"ror    $0x2,%11;\"\n+        \"add    %16,%12;\"\n+        \"mov    %3,%10;\"\n+        \"add    %12,%9;\"\n+        \"mov    %3,%12;\"\n+        \"or     %5,%10;\"\n+        \"add    %9,%6;\"\n+        \"and    %5,%12;\"\n+        \"and    %4,%10;\"\n+        \"add    %11,%9;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%9;\"\n+        \"mov    %6,%10;\"\n+        \"ror    $0xe,%10;\"\n+        \"mov    %9,%11;\"\n+        \"xor    %6,%10;\"\n+        \"ror    $0x9,%11;\"\n+        \"mov    %k2,%12;\"\n+        \"xor    %9,%11;\"\n+        \"ror    $0x5,%10;\"\n+        \"xor    %7,%12;\"\n+        \"xor    %6,%10;\"\n+        \"ror    $0xb,%11;\"\n+        \"and    %6,%12;\"\n+        \"xor    %9,%11;\"\n+        \"ror    $0x6,%10;\"\n+        \"xor    %7,%12;\"\n+        \"add    %10,%12;\"\n+        \"ror    $0x2,%11;\"\n+        \"add    4+%16,%12;\"\n+        \"mov    %9,%10;\"\n+        \"add    %12,%8;\"\n+        \"mov    %9,%12;\"\n+        \"or     %4,%10;\"\n+        \"add    %8,%5;\"\n+        \"and    %4,%12;\"\n+        \"and    %3,%10;\"\n+        \"add    %11,%8;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%8;\"\n+        \"mov    %5,%10;\"\n+        \"ror    $0xe,%10;\"\n+        \"mov    %8,%11;\"\n+        \"xor    %5,%10;\"\n+        \"ror    $0x9,%11;\"\n+        \"mov    %6,%12;\"\n+        \"xor    %8,%11;\"\n+        \"ror    $0x5,%10;\"\n+        \"xor    %k2,%12;\"\n+        \"xor    %5,%10;\"\n+        \"ror    $0xb,%11;\"\n+        \"and    %5,%12;\"\n+        \"xor    %8,%11;\"\n+        \"ror    $0x6,%10;\"\n+        \"xor    %k2,%12;\"\n+        \"add    %10,%12;\"\n+        \"ror    $0x2,%11;\"\n+        \"add    8+%16,%12;\"\n+        \"mov    %8,%10;\"\n+        \"add    %12,%7;\"\n+        \"mov    %8,%12;\"\n+        \"or     %3,%10;\"\n+        \"add    %7,%4;\"\n+        \"and    %3,%12;\"\n+        \"and    %9,%10;\"\n+        \"add    %11,%7;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%7;\"\n+        \"mov    %4,%10;\"\n+        \"ror    $0xe,%10;\"\n+        \"mov    %7,%11;\"\n+        \"xor    %4,%10;\"\n+        \"ror    $0x9,%11;\"\n+        \"mov    %5,%12;\"\n+        \"xor    %7,%11;\"\n+        \"ror    $0x5,%10;\"\n+        \"xor    %6,%12;\"\n+        \"xor    %4,%10;\"\n+        \"ror    $0xb,%11;\"\n+        \"and    %4,%12;\"\n+        \"xor    %7,%11;\"\n+        \"ror    $0x6,%10;\"\n+        \"xor    %6,%12;\"\n+        \"add    %10,%12;\"\n+        \"ror    $0x2,%11;\"\n+        \"add    12+%16,%12;\"\n+        \"mov    %7,%10;\"\n+        \"add    %12,%k2;\"\n+        \"mov    %7,%12;\"\n+        \"or     %9,%10;\"\n+        \"add    %k2,%3;\"\n+        \"and    %9,%12;\"\n+        \"and    %8,%10;\"\n+        \"add    %11,%k2;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%k2;\"\n+        \"paddd  0x10(%13),%%xmm5;\"\n+        \"movdqa %%xmm5,%16;\"\n+        \"add    $0x20,%13;\"\n+        \"mov    %3,%10;\"\n+        \"ror    $0xe,%10;\"\n+        \"mov    %k2,%11;\"\n+        \"xor    %3,%10;\"\n+        \"ror    $0x9,%11;\"\n+        \"mov    %4,%12;\"\n+        \"xor    %k2,%11;\"\n+        \"ror    $0x5,%10;\"\n+        \"xor    %5,%12;\"\n+        \"xor    %3,%10;\"\n+        \"ror    $0xb,%11;\"\n+        \"and    %3,%12;\"\n+        \"xor    %k2,%11;\"\n+        \"ror    $0x6,%10;\"\n+        \"xor    %5,%12;\"\n+        \"add    %10,%12;\"\n+        \"ror    $0x2,%11;\"\n+        \"add    %16,%12;\"\n+        \"mov    %k2,%10;\"\n+        \"add    %12,%6;\"\n+        \"mov    %k2,%12;\"\n+        \"or     %8,%10;\"\n+        \"add    %6,%9;\"\n+        \"and    %8,%12;\"\n+        \"and    %7,%10;\"\n+        \"add    %11,%6;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%6;\"\n+        \"mov    %9,%10;\"\n+        \"ror    $0xe,%10;\"\n+        \"mov    %6,%11;\"\n+        \"xor    %9,%10;\"\n+        \"ror    $0x9,%11;\"\n+        \"mov    %3,%12;\"\n+        \"xor    %6,%11;\"\n+        \"ror    $0x5,%10;\"\n+        \"xor    %4,%12;\"\n+        \"xor    %9,%10;\"\n+        \"ror    $0xb,%11;\"\n+        \"and    %9,%12;\"\n+        \"xor    %6,%11;\"\n+        \"ror    $0x6,%10;\"\n+        \"xor    %4,%12;\"\n+        \"add    %10,%12;\"\n+        \"ror    $0x2,%11;\"\n+        \"add    4+%16,%12;\"\n+        \"mov    %6,%10;\"\n+        \"add    %12,%5;\"\n+        \"mov    %6,%12;\"\n+        \"or     %7,%10;\"\n+        \"add    %5,%8;\"\n+        \"and    %7,%12;\"\n+        \"and    %k2,%10;\"\n+        \"add    %11,%5;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%5;\"\n+        \"mov    %8,%10;\"\n+        \"ror    $0xe,%10;\"\n+        \"mov    %5,%11;\"\n+        \"xor    %8,%10;\"\n+        \"ror    $0x9,%11;\"\n+        \"mov    %9,%12;\"\n+        \"xor    %5,%11;\"\n+        \"ror    $0x5,%10;\"\n+        \"xor    %3,%12;\"\n+        \"xor    %8,%10;\"\n+        \"ror    $0xb,%11;\"\n+        \"and    %8,%12;\"\n+        \"xor    %5,%11;\"\n+        \"ror    $0x6,%10;\"\n+        \"xor    %3,%12;\"\n+        \"add    %10,%12;\"\n+        \"ror    $0x2,%11;\"\n+        \"add    8+%16,%12;\"\n+        \"mov    %5,%10;\"\n+        \"add    %12,%4;\"\n+        \"mov    %5,%12;\"\n+        \"or     %k2,%10;\"\n+        \"add    %4,%7;\"\n+        \"and    %k2,%12;\"\n+        \"and    %6,%10;\"\n+        \"add    %11,%4;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%4;\"\n+        \"mov    %7,%10;\"\n+        \"ror    $0xe,%10;\"\n+        \"mov    %4,%11;\"\n+        \"xor    %7,%10;\"\n+        \"ror    $0x9,%11;\"\n+        \"mov    %8,%12;\"\n+        \"xor    %4,%11;\"\n+        \"ror    $0x5,%10;\"\n+        \"xor    %9,%12;\"\n+        \"xor    %7,%10;\"\n+        \"ror    $0xb,%11;\"\n+        \"and    %7,%12;\"\n+        \"xor    %4,%11;\"\n+        \"ror    $0x6,%10;\"\n+        \"xor    %9,%12;\"\n+        \"add    %10,%12;\"\n+        \"ror    $0x2,%11;\"\n+        \"add    12+%16,%12;\"\n+        \"mov    %4,%10;\"\n+        \"add    %12,%3;\"\n+        \"mov    %4,%12;\"\n+        \"or     %6,%10;\"\n+        \"add    %3,%k2;\"\n+        \"and    %6,%12;\"\n+        \"and    %5,%10;\"\n+        \"add    %11,%3;\"\n+        \"or     %12,%10;\"\n+        \"add    %10,%3;\"\n+        \"movdqa %%xmm6,%%xmm4;\"\n+        \"movdqa %%xmm7,%%xmm5;\"\n+        \"sub    $0x1,%1;\"\n+        \"jne    Lloop2_%=;\"\n+        \"add    (%0),%3;\"\n+        \"mov    %3,(%0);\"\n+        \"add    0x4(%0),%4;\"\n+        \"mov    %4,0x4(%0);\"\n+        \"add    0x8(%0),%5;\"\n+        \"mov    %5,0x8(%0);\"\n+        \"add    0xc(%0),%6;\"\n+        \"mov    %6,0xc(%0);\"\n+        \"add    0x10(%0),%k2;\"\n+        \"mov    %k2,0x10(%0);\"\n+        \"add    0x14(%0),%7;\"\n+        \"mov    %7,0x14(%0);\"\n+        \"add    0x18(%0),%8;\"\n+        \"mov    %8,0x18(%0);\"\n+        \"add    0x1c(%0),%9;\"\n+        \"mov    %9,0x1c(%0);\"\n+        \"mov    %15,%1;\"\n+        \"add    $0x40,%1;\"\n+        \"cmp    %14,%1;\"\n+        \"jne    Lloop0_%=;\"\n+\n+        \"Ldone_hash_%=:\"\n+\n+        : \"+r\"(s), \"+r\"(chunk), \"+r\"(blocks), \"=r\"(a), \"=r\"(b), \"=r\"(c), \"=r\"(d), /* e = chunk */ \"=r\"(f), \"=r\"(g), \"=r\"(h), \"=r\"(y0), \"=r\"(y1), \"=r\"(y2), \"=r\"(tbl), \"+m\"(inp_end), \"+m\"(inp), \"+m\"(xfer)\n+        : \"m\"(K256), \"m\"(FLIP_MASK), \"m\"(SHUF_00BA), \"m\"(SHUF_DC00)\n+        : \"cc\", \"memory\", \"xmm0\", \"xmm1\", \"xmm2\", \"xmm3\", \"xmm4\", \"xmm5\", \"xmm6\", \"xmm7\", \"xmm8\", \"xmm9\", \"xmm10\", \"xmm11\", \"xmm12\"\n+   );\n+}\n+}\n+\n+/*\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+; Copyright (c) 2012, Intel Corporation \n+; \n+; All rights reserved. \n+; \n+; Redistribution and use in source and binary forms, with or without\n+; modification, are permitted provided that the following conditions are\n+; met: \n+; \n+; * Redistributions of source code must retain the above copyright\n+;   notice, this list of conditions and the following disclaimer.  \n+; \n+; * Redistributions in binary form must reproduce the above copyright\n+;   notice, this list of conditions and the following disclaimer in the\n+;   documentation and/or other materials provided with the\n+;   distribution. \n+; \n+; * Neither the name of the Intel Corporation nor the names of its\n+;   contributors may be used to endorse or promote products derived from\n+;   this software without specific prior written permission. \n+; \n+; \n+; THIS SOFTWARE IS PROVIDED BY INTEL CORPORATION \"AS IS\" AND ANY\n+; EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+; PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL CORPORATION OR\n+; CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+; EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+; PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+; PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+; LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+; NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;\n+; Example YASM command lines:\n+; Windows:  yasm -Xvc -f x64 -rnasm -pnasm -o sha256_sse4.obj -g cv8 sha256_sse4.asm\n+; Linux:    yasm -f x64 -f elf64 -X gnu -g dwarf2 -D LINUX -o sha256_sse4.o sha256_sse4.asm\n+;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;\n+; This code is described in an Intel White-Paper:\n+; \"Fast SHA-256 Implementations on Intel Architecture Processors\"\n+;\n+; To find it, surf to http://www.intel.com/p/en_US/embedded \n+; and search for that title.\n+; The paper is expected to be released roughly at the end of April, 2012\n+;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+; This code schedules 1 blocks at a time, with 4 lanes per block\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+%define\tMOVDQ movdqu ;; assume buffers not aligned \n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Define Macros\n+\n+; addm [mem], reg\n+; Add reg to mem using reg-mem add and store\n+%macro addm 2\n+    add\t%2, %1\n+    mov\t%1, %2\n+%endm\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+; COPY_XMM_AND_BSWAP xmm, [mem], byte_flip_mask\n+; Load xmm with mem and byte swap each dword\n+%macro COPY_XMM_AND_BSWAP 3\n+    MOVDQ %1, %2\n+    pshufb %1, %3\n+%endmacro\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+%define X0 xmm4\n+%define X1 xmm5\n+%define X2 xmm6\n+%define X3 xmm7\n+\n+%define XTMP0 xmm0\n+%define XTMP1 xmm1\n+%define XTMP2 xmm2\n+%define XTMP3 xmm3\n+%define XTMP4 xmm8\n+%define XFER  xmm9\n+\n+%define SHUF_00BA\txmm10 ; shuffle xBxA -> 00BA\n+%define SHUF_DC00\txmm11 ; shuffle xDxC -> DC00\n+%define BYTE_FLIP_MASK\txmm12\n+    \n+%ifdef LINUX\n+%define NUM_BLKS rdx\t; 3rd arg\n+%define CTX\trsi\t; 2nd arg\n+%define INP\trdi\t; 1st arg\n+\n+%define SRND\trdi\t; clobbers INP\n+%define c\tecx\n+%define d \tr8d\n+%define e \tedx\n+%else\n+%define NUM_BLKS r8\t; 3rd arg\n+%define CTX\trdx \t; 2nd arg\n+%define INP\trcx \t; 1st arg\n+\n+%define SRND\trcx\t; clobbers INP\n+%define c \tedi \n+%define d\tesi \n+%define e \tr8d\n+    \n+%endif\n+%define TBL\trbp\n+%define a eax\n+%define b ebx\n+\n+%define f r9d\n+%define g r10d\n+%define h r11d\n+\n+%define y0 r13d\n+%define y1 r14d\n+%define y2 r15d\n+\n+\n+\n+_INP_END_SIZE\tequ 8\n+_INP_SIZE\tequ 8\n+_XFER_SIZE\tequ 8\n+%ifdef LINUX\n+_XMM_SAVE_SIZE\tequ 0\n+%else\n+_XMM_SAVE_SIZE\tequ 7*16\n+%endif\n+; STACK_SIZE plus pushes must be an odd multiple of 8\n+_ALIGN_SIZE\tequ 8\n+\n+_INP_END\tequ 0\n+_INP\t\tequ _INP_END  + _INP_END_SIZE\n+_XFER\t\tequ _INP      + _INP_SIZE\n+_XMM_SAVE\tequ _XFER     + _XFER_SIZE + _ALIGN_SIZE\n+STACK_SIZE\tequ _XMM_SAVE + _XMM_SAVE_SIZE\n+\n+; rotate_Xs\n+; Rotate values of symbols X0...X3\n+%macro rotate_Xs 0\n+%xdefine X_ X0\n+%xdefine X0 X1\n+%xdefine X1 X2\n+%xdefine X2 X3\n+%xdefine X3 X_\n+%endm\n+\n+; ROTATE_ARGS\n+; Rotate values of symbols a...h\n+%macro ROTATE_ARGS 0\n+%xdefine TMP_ h\n+%xdefine h g\n+%xdefine g f\n+%xdefine f e\n+%xdefine e d\n+%xdefine d c\n+%xdefine c b\n+%xdefine b a\n+%xdefine a TMP_\n+%endm\n+\n+%macro FOUR_ROUNDS_AND_SCHED 0\n+\t;; compute s0 four at a time and s1 two at a time\n+\t;; compute W[-16] + W[-7] 4 at a time\n+\tmovdqa\tXTMP0, X3\n+    mov\ty0, e\t\t; y0 = e\n+    ror\ty0, (25-11)\t; y0 = e >> (25-11)\n+    mov\ty1, a\t\t; y1 = a\n+\tpalignr\tXTMP0, X2, 4\t; XTMP0 = W[-7]\n+    ror\ty1, (22-13)\t; y1 = a >> (22-13)\n+    xor\ty0, e\t\t; y0 = e ^ (e >> (25-11))\n+    mov\ty2, f\t\t; y2 = f\n+    ror\ty0, (11-6)\t; y0 = (e >> (11-6)) ^ (e >> (25-6))\n+\tmovdqa\tXTMP1, X1\n+    xor\ty1, a\t\t; y1 = a ^ (a >> (22-13)\n+    xor\ty2, g\t\t; y2 = f^g\n+\tpaddd\tXTMP0, X0\t; XTMP0 = W[-7] + W[-16]\n+    xor\ty0, e\t\t; y0 = e ^ (e >> (11-6)) ^ (e >> (25-6))\n+    and\ty2, e\t\t; y2 = (f^g)&e\n+    ror\ty1, (13-2)\t; y1 = (a >> (13-2)) ^ (a >> (22-2))\n+\t;; compute s0\n+\tpalignr\tXTMP1, X0, 4\t; XTMP1 = W[-15]\n+    xor\ty1, a\t\t; y1 = a ^ (a >> (13-2)) ^ (a >> (22-2))\n+    ror\ty0, 6\t\t; y0 = S1 = (e>>6) & (e>>11) ^ (e>>25)\n+    xor\ty2, g\t\t; y2 = CH = ((f^g)&e)^g\n+\tmovdqa\tXTMP2, XTMP1\t; XTMP2 = W[-15]\n+    ror\ty1, 2\t\t; y1 = S0 = (a>>2) ^ (a>>13) ^ (a>>22)\n+    add\ty2, y0\t\t; y2 = S1 + CH\n+    add\ty2, [rsp + _XFER + 0*4]\t; y2 = k + w + S1 + CH\n+\tmovdqa\tXTMP3, XTMP1\t; XTMP3 = W[-15]\n+    mov\ty0, a\t\t; y0 = a\n+    add\th, y2\t\t; h = h + S1 + CH + k + w\n+    mov\ty2, a\t\t; y2 = a\n+\tpslld\tXTMP1, (32-7)\n+    or\ty0, c\t\t; y0 = a|c\n+    add\td, h\t\t; d = d + h + S1 + CH + k + w\n+    and\ty2, c\t\t; y2 = a&c\n+\tpsrld\tXTMP2, 7\n+    and\ty0, b\t\t; y0 = (a|c)&b\n+    add\th, y1\t\t; h = h + S1 + CH + k + w + S0\n+\tpor\tXTMP1, XTMP2\t; XTMP1 = W[-15] ror 7\n+    or\ty0, y2\t\t; y0 = MAJ = (a|c)&b)|(a&c)\n+    add\th, y0\t\t; h = h + S1 + CH + k + w + S0 + MAJ\n+\n+ROTATE_ARGS\n+\tmovdqa\tXTMP2, XTMP3\t; XTMP2 = W[-15]\n+    mov\ty0, e\t\t; y0 = e\n+    mov\ty1, a\t\t; y1 = a\n+\tmovdqa\tXTMP4, XTMP3\t; XTMP4 = W[-15]\n+    ror\ty0, (25-11)\t; y0 = e >> (25-11)\n+    xor\ty0, e\t\t; y0 = e ^ (e >> (25-11))\n+    mov\ty2, f\t\t; y2 = f\n+    ror\ty1, (22-13)\t; y1 = a >> (22-13)\n+\tpslld\tXTMP3, (32-18)\n+    xor\ty1, a\t\t; y1 = a ^ (a >> (22-13)\n+    ror\ty0, (11-6)\t; y0 = (e >> (11-6)) ^ (e >> (25-6))\n+    xor\ty2, g\t\t; y2 = f^g\n+\tpsrld\tXTMP2, 18\n+    ror\ty1, (13-2)\t; y1 = (a >> (13-2)) ^ (a >> (22-2))\n+    xor\ty0, e\t\t; y0 = e ^ (e >> (11-6)) ^ (e >> (25-6))\n+    and\ty2, e\t\t; y2 = (f^g)&e\n+    ror\ty0, 6\t\t; y0 = S1 = (e>>6) & (e>>11) ^ (e>>25)\n+\tpxor\tXTMP1, XTMP3\n+    xor\ty1, a\t\t; y1 = a ^ (a >> (13-2)) ^ (a >> (22-2))\n+    xor\ty2, g\t\t; y2 = CH = ((f^g)&e)^g\n+\tpsrld\tXTMP4, 3\t; XTMP4 = W[-15] >> 3\n+    add\ty2, y0\t\t; y2 = S1 + CH\n+    add\ty2, [rsp + _XFER + 1*4]\t; y2 = k + w + S1 + CH\n+    ror\ty1, 2\t\t; y1 = S0 = (a>>2) ^ (a>>13) ^ (a>>22)\n+\tpxor\tXTMP1, XTMP2\t; XTMP1 = W[-15] ror 7 ^ W[-15] ror 18\n+    mov\ty0, a\t\t; y0 = a\n+    add\th, y2\t\t; h = h + S1 + CH + k + w\n+    mov\ty2, a\t\t; y2 = a\n+\tpxor\tXTMP1, XTMP4\t; XTMP1 = s0\n+    or\ty0, c\t\t; y0 = a|c\n+    add\td, h\t\t; d = d + h + S1 + CH + k + w\n+    and\ty2, c\t\t; y2 = a&c\n+\t;; compute low s1\n+\tpshufd\tXTMP2, X3, 11111010b\t; XTMP2 = W[-2] {BBAA}\n+    and\ty0, b\t\t; y0 = (a|c)&b\n+    add\th, y1\t\t; h = h + S1 + CH + k + w + S0\n+\tpaddd\tXTMP0, XTMP1\t; XTMP0 = W[-16] + W[-7] + s0\n+    or\ty0, y2\t\t; y0 = MAJ = (a|c)&b)|(a&c)\n+    add\th, y0\t\t; h = h + S1 + CH + k + w + S0 + MAJ\n+\n+ROTATE_ARGS\n+\tmovdqa\tXTMP3, XTMP2\t; XTMP3 = W[-2] {BBAA}\n+    mov\ty0, e\t\t; y0 = e\n+    mov\ty1, a\t\t; y1 = a\n+    ror\ty0, (25-11)\t; y0 = e >> (25-11)\n+\tmovdqa\tXTMP4, XTMP2\t; XTMP4 = W[-2] {BBAA}\n+    xor\ty0, e\t\t; y0 = e ^ (e >> (25-11))\n+    ror\ty1, (22-13)\t; y1 = a >> (22-13)\n+    mov\ty2, f\t\t; y2 = f\n+    xor\ty1, a\t\t; y1 = a ^ (a >> (22-13)\n+    ror\ty0, (11-6)\t; y0 = (e >> (11-6)) ^ (e >> (25-6))\n+\tpsrlq\tXTMP2, 17\t; XTMP2 = W[-2] ror 17 {xBxA}\n+    xor\ty2, g\t\t; y2 = f^g\n+\tpsrlq\tXTMP3, 19\t; XTMP3 = W[-2] ror 19 {xBxA}\n+    xor\ty0, e\t\t; y0 = e ^ (e >> (11-6)) ^ (e >> (25-6))\n+    and\ty2, e\t\t; y2 = (f^g)&e\n+\tpsrld\tXTMP4, 10\t; XTMP4 = W[-2] >> 10 {BBAA}\n+    ror\ty1, (13-2)\t; y1 = (a >> (13-2)) ^ (a >> (22-2))\n+    xor\ty1, a\t\t; y1 = a ^ (a >> (13-2)) ^ (a >> (22-2))\n+    xor\ty2, g\t\t; y2 = CH = ((f^g)&e)^g\n+    ror\ty0, 6\t\t; y0 = S1 = (e>>6) & (e>>11) ^ (e>>25)\n+\tpxor\tXTMP2, XTMP3\n+    add\ty2, y0\t\t; y2 = S1 + CH\n+    ror\ty1, 2\t\t; y1 = S0 = (a>>2) ^ (a>>13) ^ (a>>22)\n+    add\ty2, [rsp + _XFER + 2*4]\t; y2 = k + w + S1 + CH\n+\tpxor\tXTMP4, XTMP2\t; XTMP4 = s1 {xBxA}\n+    mov\ty0, a\t\t; y0 = a\n+    add\th, y2\t\t; h = h + S1 + CH + k + w\n+    mov\ty2, a\t\t; y2 = a\n+\tpshufb\tXTMP4, SHUF_00BA\t; XTMP4 = s1 {00BA}\n+    or\ty0, c\t\t; y0 = a|c\n+    add\td, h\t\t; d = d + h + S1 + CH + k + w\n+    and\ty2, c\t\t; y2 = a&c\n+\tpaddd\tXTMP0, XTMP4\t; XTMP0 = {..., ..., W[1], W[0]}\n+    and\ty0, b\t\t; y0 = (a|c)&b\n+    add\th, y1\t\t; h = h + S1 + CH + k + w + S0\n+\t;; compute high s1\n+\tpshufd\tXTMP2, XTMP0, 01010000b\t; XTMP2 = W[-2] {DDCC}\n+    or\ty0, y2\t\t; y0 = MAJ = (a|c)&b)|(a&c)\n+    add\th, y0\t\t; h = h + S1 + CH + k + w + S0 + MAJ\n+\n+ROTATE_ARGS\n+\tmovdqa\tXTMP3, XTMP2\t; XTMP3 = W[-2] {DDCC}\n+    mov\ty0, e\t\t; y0 = e\n+    ror\ty0, (25-11)\t; y0 = e >> (25-11)\n+    mov\ty1, a\t\t; y1 = a\n+\tmovdqa\tX0,    XTMP2\t; X0    = W[-2] {DDCC}\n+    ror\ty1, (22-13)\t; y1 = a >> (22-13)\n+    xor\ty0, e\t\t; y0 = e ^ (e >> (25-11))\n+    mov\ty2, f\t\t; y2 = f\n+    ror\ty0, (11-6)\t; y0 = (e >> (11-6)) ^ (e >> (25-6))\n+\tpsrlq\tXTMP2, 17\t; XTMP2 = W[-2] ror 17 {xDxC}\n+    xor\ty1, a\t\t; y1 = a ^ (a >> (22-13)\n+    xor\ty2, g\t\t; y2 = f^g\n+\tpsrlq\tXTMP3, 19\t; XTMP3 = W[-2] ror 19 {xDxC}\n+    xor\ty0, e\t\t; y0 = e ^ (e >> (11-6)) ^ (e >> (25-6))\n+    and\ty2, e\t\t; y2 = (f^g)&e\n+    ror\ty1, (13-2)\t; y1 = (a >> (13-2)) ^ (a >> (22-2))\n+\tpsrld\tX0,    10\t; X0 = W[-2] >> 10 {DDCC}\n+    xor\ty1, a\t\t; y1 = a ^ (a >> (13-2)) ^ (a >> (22-2))\n+    ror\ty0, 6\t\t; y0 = S1 = (e>>6) & (e>>11) ^ (e>>25)\n+    xor\ty2, g\t\t; y2 = CH = ((f^g)&e)^g\n+\tpxor\tXTMP2, XTMP3\n+    ror\ty1, 2\t\t; y1 = S0 = (a>>2) ^ (a>>13) ^ (a>>22)\n+    add\ty2, y0\t\t; y2 = S1 + CH\n+    add\ty2, [rsp + _XFER + 3*4]\t; y2 = k + w + S1 + CH\n+\tpxor\tX0, XTMP2\t; X0 = s1 {xDxC}\n+    mov\ty0, a\t\t; y0 = a\n+    add\th, y2\t\t; h = h + S1 + CH + k + w\n+    mov\ty2, a\t\t; y2 = a\n+\tpshufb\tX0, SHUF_DC00\t; X0 = s1 {DC00}\n+    or\ty0, c\t\t; y0 = a|c\n+    add\td, h\t\t; d = d + h + S1 + CH + k + w\n+    and\ty2, c\t\t; y2 = a&c\n+\tpaddd\tX0, XTMP0\t; X0 = {W[3], W[2], W[1], W[0]}\n+    and\ty0, b\t\t; y0 = (a|c)&b\n+    add\th, y1\t\t; h = h + S1 + CH + k + w + S0\n+    or\ty0, y2\t\t; y0 = MAJ = (a|c)&b)|(a&c)\n+    add\th, y0\t\t; h = h + S1 + CH + k + w + S0 + MAJ\n+\n+ROTATE_ARGS\n+rotate_Xs\n+%endm\n+\n+;; input is [rsp + _XFER + %1 * 4]\n+%macro DO_ROUND 1\n+    mov\ty0, e\t\t; y0 = e\n+    ror\ty0, (25-11)\t; y0 = e >> (25-11)\n+    mov\ty1, a\t\t; y1 = a\n+    xor\ty0, e\t\t; y0 = e ^ (e >> (25-11))\n+    ror\ty1, (22-13)\t; y1 = a >> (22-13)\n+    mov\ty2, f\t\t; y2 = f\n+    xor\ty1, a\t\t; y1 = a ^ (a >> (22-13)\n+    ror\ty0, (11-6)\t; y0 = (e >> (11-6)) ^ (e >> (25-6))\n+    xor\ty2, g\t\t; y2 = f^g\n+    xor\ty0, e\t\t; y0 = e ^ (e >> (11-6)) ^ (e >> (25-6))\n+    ror\ty1, (13-2)\t; y1 = (a >> (13-2)) ^ (a >> (22-2))\n+    and\ty2, e\t\t; y2 = (f^g)&e\n+    xor\ty1, a\t\t; y1 = a ^ (a >> (13-2)) ^ (a >> (22-2))\n+    ror\ty0, 6\t\t; y0 = S1 = (e>>6) & (e>>11) ^ (e>>25)\n+    xor\ty2, g\t\t; y2 = CH = ((f^g)&e)^g\n+    add\ty2, y0\t\t; y2 = S1 + CH\n+    ror\ty1, 2\t\t; y1 = S0 = (a>>2) ^ (a>>13) ^ (a>>22)\n+    add\ty2, [rsp + _XFER + %1 * 4]\t; y2 = k + w + S1 + CH\n+    mov\ty0, a\t\t; y0 = a\n+    add\th, y2\t\t; h = h + S1 + CH + k + w\n+    mov\ty2, a\t\t; y2 = a\n+    or\ty0, c\t\t; y0 = a|c\n+    add\td, h\t\t; d = d + h + S1 + CH + k + w\n+    and\ty2, c\t\t; y2 = a&c\n+    and\ty0, b\t\t; y0 = (a|c)&b\n+    add\th, y1\t\t; h = h + S1 + CH + k + w + S0\n+    or\ty0, y2\t\t; y0 = MAJ = (a|c)&b)|(a&c)\n+    add\th, y0\t\t; h = h + S1 + CH + k + w + S0 + MAJ\n+    ROTATE_ARGS\n+%endm\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; void sha256_sse4(void *input_data, UINT32 digest[8], UINT64 num_blks)\n+;; arg 1 : pointer to input data\n+;; arg 2 : pointer to digest\n+;; arg 3 : Num blocks\n+section .text\n+global sha256_sse4\n+align 32\n+sha256_sse4:\n+    push\trbx\n+%ifndef LINUX\n+    push\trsi\n+    push\trdi\n+%endif\n+    push\trbp\n+    push\tr13\n+    push\tr14\n+    push\tr15\n+\n+    sub\trsp,STACK_SIZE\n+%ifndef LINUX\n+    movdqa\t[rsp + _XMM_SAVE + 0*16],xmm6\t\n+    movdqa\t[rsp + _XMM_SAVE + 1*16],xmm7\n+    movdqa\t[rsp + _XMM_SAVE + 2*16],xmm8\t\n+    movdqa\t[rsp + _XMM_SAVE + 3*16],xmm9\t\n+    movdqa\t[rsp + _XMM_SAVE + 4*16],xmm10\n+    movdqa\t[rsp + _XMM_SAVE + 5*16],xmm11\n+    movdqa\t[rsp + _XMM_SAVE + 6*16],xmm12\n+%endif\n+\n+    shl\tNUM_BLKS, 6\t; convert to bytes\n+    jz\tdone_hash\n+    add\tNUM_BLKS, INP\t; pointer to end of data\n+    mov\t[rsp + _INP_END], NUM_BLKS\n+\n+    ;; load initial digest\n+    mov\ta,[4*0 + CTX]\n+    mov\tb,[4*1 + CTX]\n+    mov\tc,[4*2 + CTX]\n+    mov\td,[4*3 + CTX]\n+    mov\te,[4*4 + CTX]\n+    mov\tf,[4*5 + CTX]\n+    mov\tg,[4*6 + CTX]\n+    mov\th,[4*7 + CTX]\n+\n+    movdqa\tBYTE_FLIP_MASK, [PSHUFFLE_BYTE_FLIP_MASK wrt rip]\n+    movdqa\tSHUF_00BA, [_SHUF_00BA wrt rip]\n+    movdqa\tSHUF_DC00, [_SHUF_DC00 wrt rip]\n+\n+loop0:\n+    lea\tTBL,[K256 wrt rip]\n+\n+    ;; byte swap first 16 dwords\n+    COPY_XMM_AND_BSWAP\tX0, [INP + 0*16], BYTE_FLIP_MASK\n+    COPY_XMM_AND_BSWAP\tX1, [INP + 1*16], BYTE_FLIP_MASK\n+    COPY_XMM_AND_BSWAP\tX2, [INP + 2*16], BYTE_FLIP_MASK\n+    COPY_XMM_AND_BSWAP\tX3, [INP + 3*16], BYTE_FLIP_MASK\n+    \n+    mov\t[rsp + _INP], INP\n+\n+    ;; schedule 48 input dwords, by doing 3 rounds of 16 each\n+    mov\tSRND, 3\n+align 16\n+loop1:\n+    movdqa\tXFER, [TBL + 0*16]\n+    paddd\tXFER, X0\n+    movdqa\t[rsp + _XFER], XFER\n+    FOUR_ROUNDS_AND_SCHED\n+\n+    movdqa\tXFER, [TBL + 1*16]\n+    paddd\tXFER, X0\n+    movdqa\t[rsp + _XFER], XFER\n+    FOUR_ROUNDS_AND_SCHED\n+\n+    movdqa\tXFER, [TBL + 2*16]\n+    paddd\tXFER, X0\n+    movdqa\t[rsp + _XFER], XFER\n+    FOUR_ROUNDS_AND_SCHED\n+\n+    movdqa\tXFER, [TBL + 3*16]\n+    paddd\tXFER, X0\n+    movdqa\t[rsp + _XFER], XFER\n+    add\tTBL, 4*16\n+    FOUR_ROUNDS_AND_SCHED\n+\n+    sub\tSRND, 1\n+    jne\tloop1\n+\n+    mov\tSRND, 2\n+loop2:\n+    paddd\tX0, [TBL + 0*16]\n+    movdqa\t[rsp + _XFER], X0\n+    DO_ROUND\t0\n+    DO_ROUND\t1\n+    DO_ROUND\t2\n+    DO_ROUND\t3\n+    paddd\tX1, [TBL + 1*16]\n+    movdqa\t[rsp + _XFER], X1\n+    add\tTBL, 2*16\n+    DO_ROUND\t0\n+    DO_ROUND\t1\n+    DO_ROUND\t2\n+    DO_ROUND\t3\n+\n+    movdqa\tX0, X2\n+    movdqa\tX1, X3\n+\n+    sub\tSRND, 1\n+    jne\tloop2\n+\n+    addm\t[4*0 + CTX],a\n+    addm\t[4*1 + CTX],b\n+    addm\t[4*2 + CTX],c\n+    addm\t[4*3 + CTX],d\n+    addm\t[4*4 + CTX],e\n+    addm\t[4*5 + CTX],f\n+    addm\t[4*6 + CTX],g\n+    addm\t[4*7 + CTX],h\n+\n+    mov\tINP, [rsp + _INP]\n+    add\tINP, 64\n+    cmp\tINP, [rsp + _INP_END]\n+    jne\tloop0\n+\n+done_hash:\n+%ifndef LINUX\n+    movdqa\txmm6,[rsp + _XMM_SAVE + 0*16]\n+    movdqa\txmm7,[rsp + _XMM_SAVE + 1*16]\n+    movdqa\txmm8,[rsp + _XMM_SAVE + 2*16]\n+    movdqa\txmm9,[rsp + _XMM_SAVE + 3*16]\n+    movdqa\txmm10,[rsp + _XMM_SAVE + 4*16]\n+    movdqa\txmm11,[rsp + _XMM_SAVE + 5*16]\n+    movdqa\txmm12,[rsp + _XMM_SAVE + 6*16]\n+%endif\n+\n+    add\trsp, STACK_SIZE\n+\n+    pop\tr15\n+    pop\tr14\n+    pop\tr13\n+    pop\trbp\n+%ifndef LINUX\n+    pop\trdi\n+    pop\trsi\n+%endif\n+    pop\trbx\n+\n+    ret\t\n+    \n+\n+section .data\n+align 64\n+K256:\n+    dd\t0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5\n+    dd\t0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5\n+    dd\t0xd807aa98,0x12835b01,0x243185be,0x550c7dc3\n+    dd\t0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174\n+    dd\t0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc\n+    dd\t0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da\n+    dd\t0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7\n+    dd\t0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967\n+    dd\t0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13\n+    dd\t0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85\n+    dd\t0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3\n+    dd\t0xd192e819,0xd6990624,0xf40e3585,0x106aa070\n+    dd\t0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5\n+    dd\t0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3\n+    dd\t0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208\n+    dd\t0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2\n+\n+PSHUFFLE_BYTE_FLIP_MASK: ddq 0x0c0d0e0f08090a0b0405060700010203\n+\n+; shuffle xBxA -> 00BA\n+_SHUF_00BA:              ddq 0xFFFFFFFFFFFFFFFF0b0a090803020100\n+\n+; shuffle xDxC -> DC00\n+_SHUF_DC00:              ddq 0x0b0a090803020100FFFFFFFFFFFFFFFF\n+*/\n+\n+#endif"
      },
      {
        "sha": "fd24d05ee7b998eab6bc7a4510e4d13fd1841f22",
        "filename": "src/cuckoocache.h",
        "status": "modified",
        "additions": 33,
        "deletions": 2,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/cuckoocache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/cuckoocache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cuckoocache.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -176,15 +176,15 @@ class cache\n      */\n     mutable std::vector<bool> epoch_flags;\n \n-    /** epoch_heuristic_counter is used to determine when a epoch might be aged\n+    /** epoch_heuristic_counter is used to determine when an epoch might be aged\n      * & an expensive scan should be done.  epoch_heuristic_counter is\n      * decremented on insert and reset to the new number of inserts which would\n      * cause the epoch to reach epoch_size when it reaches zero.\n      */\n     uint32_t epoch_heuristic_counter;\n \n     /** epoch_size is set to be the number of elements supposed to be in a\n-     * epoch. When the number of non-erased elements in a epoch\n+     * epoch. When the number of non-erased elements in an epoch\n      * exceeds epoch_size, a new epoch should be started and all\n      * current entries demoted. epoch_size is set to be 45% of size because\n      * we want to keep load around 90%, and we support 3 epochs at once --\n@@ -206,6 +206,37 @@ class cache\n     /** compute_hashes is convenience for not having to write out this\n      * expression everywhere we use the hash values of an Element.\n      *\n+     * We need to map the 32-bit input hash onto a hash bucket in a range [0, size) in a\n+     *  manner which preserves as much of the hash's uniformity as possible.  Ideally\n+     *  this would be done by bitmasking but the size is usually not a power of two.\n+     *\n+     * The naive approach would be to use a mod -- which isn't perfectly uniform but so\n+     *  long as the hash is much larger than size it is not that bad.  Unfortunately,\n+     *  mod/division is fairly slow on ordinary microprocessors (e.g. 90-ish cycles on\n+     *  haswell, ARM doesn't even have an instruction for it.); when the divisor is a\n+     *  constant the compiler will do clever tricks to turn it into a multiply+add+shift,\n+     *  but size is a run-time value so the compiler can't do that here.\n+     *\n+     * One option would be to implement the same trick the compiler uses and compute the\n+     *  constants for exact division based on the size, as described in \"{N}-bit Unsigned\n+     *  Division via {N}-bit Multiply-Add\" by Arch D. Robison in 2005. But that code is\n+     *  somewhat complicated and the result is still slower than other options:\n+     *\n+     * Instead we treat the 32-bit random number as a Q32 fixed-point number in the range\n+     *  [0,1) and simply multiply it by the size.  Then we just shift the result down by\n+     *  32-bits to get our bucket number.  The results has non-uniformity the same as a\n+     *  mod, but it is much faster to compute. More about this technique can be found at\n+     *  http://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/\n+     *\n+     * The resulting non-uniformity is also more equally distributed which would be\n+     *  advantageous for something like linear probing, though it shouldn't matter\n+     *  one way or the other for a cuckoo table.\n+     *\n+     * The primary disadvantage of this approach is increased intermediate precision is\n+     *  required but for a 32-bit random number we only need the high 32 bits of a\n+     *  32*32->64 multiply, which means the operation is reasonably fast even on a\n+     *  typical 32-bit processor.\n+     *\n      * @param e the element whose hashes will be returned\n      * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n      */"
      },
      {
        "sha": "3626e0177f75bb0f089f71a740fefbaefedfa865",
        "filename": "src/dbwrapper.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/dbwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/dbwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -108,13 +108,19 @@ CDBWrapper::CDBWrapper(const fs::path& path, size_t nCacheSize, bool fMemory, bo\n             leveldb::Status result = leveldb::DestroyDB(path.string(), options);\n             dbwrapper_private::HandleError(result);\n         }\n-        TryCreateDirectory(path);\n+        TryCreateDirectories(path);\n         LogPrintf(\"Opening LevelDB in %s\\n\", path.string());\n     }\n     leveldb::Status status = leveldb::DB::Open(options, path.string(), &pdb);\n     dbwrapper_private::HandleError(status);\n     LogPrintf(\"Opened LevelDB successfully\\n\");\n \n+    if (GetBoolArg(\"-forcecompactdb\", false)) {\n+        LogPrintf(\"Starting database compaction of %s\\n\", path.string());\n+        pdb->CompactRange(nullptr, nullptr);\n+        LogPrintf(\"Finished database compaction of %s\\n\", path.string());\n+    }\n+\n     // The base-case obfuscation key, which is a noop.\n     obfuscate_key = std::vector<unsigned char>(OBFUSCATE_KEY_NUM_BYTES, '\\000');\n \n@@ -209,4 +215,4 @@ const std::vector<unsigned char>& GetObfuscateKey(const CDBWrapper &w)\n     return w.obfuscate_key;\n }\n \n-};\n+} // namespace dbwrapper_private"
      },
      {
        "sha": "d36188652a785e95060492ddaf7076323d0e3c6a",
        "filename": "src/dbwrapper.h",
        "status": "modified",
        "additions": 58,
        "deletions": 2,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/dbwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/dbwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -55,11 +55,19 @@ class CDBBatch\n     CDataStream ssKey;\n     CDataStream ssValue;\n \n+    size_t size_estimate;\n+\n public:\n     /**\n      * @param[in] _parent   CDBWrapper that this batch is to be submitted to\n      */\n-    CDBBatch(const CDBWrapper &_parent) : parent(_parent), ssKey(SER_DISK, CLIENT_VERSION), ssValue(SER_DISK, CLIENT_VERSION) { };\n+    CDBBatch(const CDBWrapper &_parent) : parent(_parent), ssKey(SER_DISK, CLIENT_VERSION), ssValue(SER_DISK, CLIENT_VERSION), size_estimate(0) { };\n+\n+    void Clear()\n+    {\n+        batch.Clear();\n+        size_estimate = 0;\n+    }\n \n     template <typename K, typename V>\n     void Write(const K& key, const V& value)\n@@ -74,6 +82,14 @@ class CDBBatch\n         leveldb::Slice slValue(ssValue.data(), ssValue.size());\n \n         batch.Put(slKey, slValue);\n+        // LevelDB serializes writes as:\n+        // - byte: header\n+        // - varint: key length (1 byte up to 127B, 2 bytes up to 16383B, ...)\n+        // - byte[]: key\n+        // - varint: value length\n+        // - byte[]: value\n+        // The formula below assumes the key and value are both less than 16k.\n+        size_estimate += 3 + (slKey.size() > 127) + slKey.size() + (slValue.size() > 127) + slValue.size();\n         ssKey.clear();\n         ssValue.clear();\n     }\n@@ -86,8 +102,16 @@ class CDBBatch\n         leveldb::Slice slKey(ssKey.data(), ssKey.size());\n \n         batch.Delete(slKey);\n+        // LevelDB serializes erases as:\n+        // - byte: header\n+        // - varint: key length\n+        // - byte[]: key\n+        // The formula below assumes the key is less than 16kB.\n+        size_estimate += 2 + (slKey.size() > 127) + slKey.size();\n         ssKey.clear();\n     }\n+\n+    size_t SizeEstimate() const { return size_estimate; }\n };\n \n class CDBIterator\n@@ -281,7 +305,39 @@ class CDBWrapper\n      * Return true if the database managed by this class contains no entries.\n      */\n     bool IsEmpty();\n+\n+    template<typename K>\n+    size_t EstimateSize(const K& key_begin, const K& key_end) const\n+    {\n+        CDataStream ssKey1(SER_DISK, CLIENT_VERSION), ssKey2(SER_DISK, CLIENT_VERSION);\n+        ssKey1.reserve(DBWRAPPER_PREALLOC_KEY_SIZE);\n+        ssKey2.reserve(DBWRAPPER_PREALLOC_KEY_SIZE);\n+        ssKey1 << key_begin;\n+        ssKey2 << key_end;\n+        leveldb::Slice slKey1(ssKey1.data(), ssKey1.size());\n+        leveldb::Slice slKey2(ssKey2.data(), ssKey2.size());\n+        uint64_t size = 0;\n+        leveldb::Range range(slKey1, slKey2);\n+        pdb->GetApproximateSizes(&range, 1, &size);\n+        return size;\n+    }\n+\n+    /**\n+     * Compact a certain range of keys in the database.\n+     */\n+    template<typename K>\n+    void CompactRange(const K& key_begin, const K& key_end) const\n+    {\n+        CDataStream ssKey1(SER_DISK, CLIENT_VERSION), ssKey2(SER_DISK, CLIENT_VERSION);\n+        ssKey1.reserve(DBWRAPPER_PREALLOC_KEY_SIZE);\n+        ssKey2.reserve(DBWRAPPER_PREALLOC_KEY_SIZE);\n+        ssKey1 << key_begin;\n+        ssKey2 << key_end;\n+        leveldb::Slice slKey1(ssKey1.data(), ssKey1.size());\n+        leveldb::Slice slKey2(ssKey2.data(), ssKey2.size());\n+        pdb->CompactRange(&slKey1, &slKey2);\n+    }\n+\n };\n \n #endif // BITCOIN_DBWRAPPER_H\n-"
      },
      {
        "sha": "a5e12f1cfcb70e0c2fcc628d8f53bf6fa3adee1c",
        "filename": "src/fs.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/fs.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/fs.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fs.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -1,7 +1,5 @@\n #include \"fs.h\"\n \n-#include <boost/filesystem.hpp>\n-\n namespace fsbridge {\n \n FILE *fopen(const fs::path& p, const char *mode)"
      },
      {
        "sha": "abb4be254b8fa00f76a43fcaf99b54f310cc3254",
        "filename": "src/fs.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/fs.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/fs.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fs.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -21,4 +21,4 @@ namespace fsbridge {\n     FILE *freopen(const fs::path& p, const char *mode, FILE *stream);\n };\n \n-#endif\n+#endif // BITCOIN_FS_H"
      },
      {
        "sha": "5a15600be55e82dc595f3fee61e398431a4c219e",
        "filename": "src/hash.cpp",
        "status": "modified",
        "additions": 61,
        "deletions": 23,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -17,36 +17,34 @@ unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char\n {\n     // The following is MurmurHash3 (x86_32), see http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp\n     uint32_t h1 = nHashSeed;\n-    if (vDataToHash.size() > 0)\n-    {\n-        const uint32_t c1 = 0xcc9e2d51;\n-        const uint32_t c2 = 0x1b873593;\n+    const uint32_t c1 = 0xcc9e2d51;\n+    const uint32_t c2 = 0x1b873593;\n \n-        const int nblocks = vDataToHash.size() / 4;\n+    const int nblocks = vDataToHash.size() / 4;\n \n-        //----------\n-        // body\n-        const uint8_t* blocks = &vDataToHash[0] + nblocks * 4;\n+    //----------\n+    // body\n+    const uint8_t* blocks = vDataToHash.data();\n \n-        for (int i = -nblocks; i; i++) {\n-            uint32_t k1 = ReadLE32(blocks + i*4);\n+    for (int i = 0; i < nblocks; ++i) {\n+        uint32_t k1 = ReadLE32(blocks + i*4);\n \n-            k1 *= c1;\n-            k1 = ROTL32(k1, 15);\n-            k1 *= c2;\n+        k1 *= c1;\n+        k1 = ROTL32(k1, 15);\n+        k1 *= c2;\n \n-            h1 ^= k1;\n-            h1 = ROTL32(h1, 13);\n-            h1 = h1 * 5 + 0xe6546b64;\n-        }\n+        h1 ^= k1;\n+        h1 = ROTL32(h1, 13);\n+        h1 = h1 * 5 + 0xe6546b64;\n+    }\n \n-        //----------\n-        // tail\n-        const uint8_t* tail = (const uint8_t*)(&vDataToHash[0] + nblocks * 4);\n+    //----------\n+    // tail\n+    const uint8_t* tail = vDataToHash.data() + nblocks * 4;\n \n-        uint32_t k1 = 0;\n+    uint32_t k1 = 0;\n \n-        switch (vDataToHash.size() & 3) {\n+    switch (vDataToHash.size() & 3) {\n         case 3:\n             k1 ^= tail[2] << 16;\n         case 2:\n@@ -57,7 +55,6 @@ unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char\n             k1 = ROTL32(k1, 15);\n             k1 *= c2;\n             h1 ^= k1;\n-        }\n     }\n \n     //----------\n@@ -208,3 +205,44 @@ uint64_t SipHashUint256(uint64_t k0, uint64_t k1, const uint256& val)\n     SIPROUND;\n     return v0 ^ v1 ^ v2 ^ v3;\n }\n+\n+uint64_t SipHashUint256Extra(uint64_t k0, uint64_t k1, const uint256& val, uint32_t extra)\n+{\n+    /* Specialized implementation for efficiency */\n+    uint64_t d = val.GetUint64(0);\n+\n+    uint64_t v0 = 0x736f6d6570736575ULL ^ k0;\n+    uint64_t v1 = 0x646f72616e646f6dULL ^ k1;\n+    uint64_t v2 = 0x6c7967656e657261ULL ^ k0;\n+    uint64_t v3 = 0x7465646279746573ULL ^ k1 ^ d;\n+\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = val.GetUint64(1);\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = val.GetUint64(2);\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = val.GetUint64(3);\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = (((uint64_t)36) << 56) | extra;\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    v2 ^= 0xFF;\n+    SIPROUND;\n+    SIPROUND;\n+    SIPROUND;\n+    SIPROUND;\n+    return v0 ^ v1 ^ v2 ^ v3;\n+}"
      },
      {
        "sha": "b9952d39fc97dc1472a1c11b6e9e312f1b7a5e01",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -160,6 +160,41 @@ class CHashWriter\n     }\n };\n \n+/** Reads data from an underlying stream, while hashing the read data. */\n+template<typename Source>\n+class CHashVerifier : public CHashWriter\n+{\n+private:\n+    Source* source;\n+\n+public:\n+    CHashVerifier(Source* source_) : CHashWriter(source_->GetType(), source_->GetVersion()), source(source_) {}\n+\n+    void read(char* pch, size_t nSize)\n+    {\n+        source->read(pch, nSize);\n+        this->write(pch, nSize);\n+    }\n+\n+    void ignore(size_t nSize)\n+    {\n+        char data[1024];\n+        while (nSize > 0) {\n+            size_t now = std::min<size_t>(nSize, 1024);\n+            read(data, now);\n+            nSize -= now;\n+        }\n+    }\n+\n+    template<typename T>\n+    CHashVerifier<Source>& operator>>(T& obj)\n+    {\n+        // Unserialize from this stream\n+        ::Unserialize(*this, obj);\n+        return (*this);\n+    }\n+};\n+\n /** Compute the 256-bit hash of an object's serialization. */\n template<typename T>\n uint256 SerializeHash(const T& obj, int nType=SER_GETHASH, int nVersion=PROTOCOL_VERSION)\n@@ -206,5 +241,6 @@ class CSipHasher\n  *      .Finalize()\n  */\n uint64_t SipHashUint256(uint64_t k0, uint64_t k1, const uint256& val);\n+uint64_t SipHashUint256Extra(uint64_t k0, uint64_t k1, const uint256& val, uint32_t extra);\n \n #endif // BITCOIN_HASH_H"
      },
      {
        "sha": "69c3e3f49f606ee808c11bd79f6e9d9e8072a8dc",
        "filename": "src/httprpc.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 34,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/httprpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/httprpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -16,10 +16,8 @@\n #include \"ui_interface.h\"\n #include \"crypto/hmac_sha256.h\"\n #include <stdio.h>\n-#include \"utilstrencodings.h\"\n \n #include <boost/algorithm/string.hpp> // boost::trim\n-#include <boost/foreach.hpp> //BOOST_FOREACH\n \n /** WWW-Authenticate to present with 401 Unauthorized response */\n static const char* WWW_AUTH_HEADER_DATA = \"Basic realm=\\\"jsonrpc\\\"\";\n@@ -30,7 +28,7 @@ static const char* WWW_AUTH_HEADER_DATA = \"Basic realm=\\\"jsonrpc\\\"\";\n class HTTPRPCTimer : public RPCTimerBase\n {\n public:\n-    HTTPRPCTimer(struct event_base* eventBase, boost::function<void(void)>& func, int64_t millis) :\n+    HTTPRPCTimer(struct event_base* eventBase, std::function<void(void)>& func, int64_t millis) :\n         ev(eventBase, false, func)\n     {\n         struct timeval tv;\n@@ -48,11 +46,11 @@ class HTTPRPCTimerInterface : public RPCTimerInterface\n     HTTPRPCTimerInterface(struct event_base* _base) : base(_base)\n     {\n     }\n-    const char* Name()\n+    const char* Name() override\n     {\n         return \"HTTP\";\n     }\n-    RPCTimerBase* NewTimer(boost::function<void(void)>& func, int64_t millis)\n+    RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis) override\n     {\n         return new HTTPRPCTimer(base, func, millis);\n     }\n@@ -93,35 +91,32 @@ static bool multiUserAuthorized(std::string strUserPass)\n     std::string strUser = strUserPass.substr(0, strUserPass.find(\":\"));\n     std::string strPass = strUserPass.substr(strUserPass.find(\":\") + 1);\n \n-    if (mapMultiArgs.count(\"-rpcauth\") > 0) {\n+    for (const std::string& strRPCAuth : gArgs.GetArgs(\"-rpcauth\")) {\n         //Search for multi-user login/pass \"rpcauth\" from config\n-        BOOST_FOREACH(std::string strRPCAuth, mapMultiArgs.at(\"-rpcauth\"))\n-        {\n-            std::vector<std::string> vFields;\n-            boost::split(vFields, strRPCAuth, boost::is_any_of(\":$\"));\n-            if (vFields.size() != 3) {\n-                //Incorrect formatting in config file\n-                continue;\n-            }\n-\n-            std::string strName = vFields[0];\n-            if (!TimingResistantEqual(strName, strUser)) {\n-                continue;\n-            }\n-\n-            std::string strSalt = vFields[1];\n-            std::string strHash = vFields[2];\n-\n-            static const unsigned int KEY_SIZE = 32;\n-            unsigned char out[KEY_SIZE];\n-\n-            CHMAC_SHA256(reinterpret_cast<const unsigned char*>(strSalt.c_str()), strSalt.size()).Write(reinterpret_cast<const unsigned char*>(strPass.c_str()), strPass.size()).Finalize(out);\n-            std::vector<unsigned char> hexvec(out, out+KEY_SIZE);\n-            std::string strHashFromPass = HexStr(hexvec);\n-\n-            if (TimingResistantEqual(strHashFromPass, strHash)) {\n-                return true;\n-            }\n+        std::vector<std::string> vFields;\n+        boost::split(vFields, strRPCAuth, boost::is_any_of(\":$\"));\n+        if (vFields.size() != 3) {\n+            //Incorrect formatting in config file\n+            continue;\n+        }\n+\n+        std::string strName = vFields[0];\n+        if (!TimingResistantEqual(strName, strUser)) {\n+            continue;\n+        }\n+\n+        std::string strSalt = vFields[1];\n+        std::string strHash = vFields[2];\n+\n+        static const unsigned int KEY_SIZE = 32;\n+        unsigned char out[KEY_SIZE];\n+\n+        CHMAC_SHA256(reinterpret_cast<const unsigned char*>(strSalt.c_str()), strSalt.size()).Write(reinterpret_cast<const unsigned char*>(strPass.c_str()), strPass.size()).Finalize(out);\n+        std::vector<unsigned char> hexvec(out, out+KEY_SIZE);\n+        std::string strHashFromPass = HexStr(hexvec);\n+\n+        if (TimingResistantEqual(strHashFromPass, strHash)) {\n+            return true;\n         }\n     }\n     return false;\n@@ -238,7 +233,10 @@ bool StartHTTPRPC()\n         return false;\n \n     RegisterHTTPHandler(\"/\", true, HTTPReq_JSONRPC);\n-\n+#ifdef ENABLE_WALLET\n+    // ifdef can be removed once we switch to better endpoint support and API versioning\n+    RegisterHTTPHandler(\"/wallet/\", false, HTTPReq_JSONRPC);\n+#endif\n     assert(EventBase());\n     httpRPCTimerInterface = new HTTPRPCTimerInterface(EventBase());\n     RPCSetTimerInterface(httpRPCTimerInterface);"
      },
      {
        "sha": "a89a8f0fbfe0980bb935d33ceafb78b03270de00",
        "filename": "src/httprpc.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/httprpc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/httprpc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -8,8 +8,6 @@\n #include <string>\n #include <map>\n \n-class HTTPRequest;\n-\n /** Start HTTP RPC subsystem.\n  * Precondition; HTTP and RPC has been started.\n  */"
      },
      {
        "sha": "ba012554006a461dd75f450cf0dd0f013d759c29",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 33,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -7,6 +7,7 @@\n #include \"chainparamsbase.h\"\n #include \"compat.h\"\n #include \"util.h\"\n+#include \"utilstrencodings.h\"\n #include \"netbase.h\"\n #include \"rpc/protocol.h\" // For HTTP status codes\n #include \"sync.h\"\n@@ -21,13 +22,13 @@\n #include <signal.h>\n #include <future>\n \n-#include <event2/event.h>\n-#include <event2/http.h>\n #include <event2/thread.h>\n #include <event2/buffer.h>\n #include <event2/util.h>\n #include <event2/keyvalq_struct.h>\n \n+#include \"support/events.h\"\n+\n #ifdef EVENT__HAVE_NETINET_IN_H\n #include <netinet/in.h>\n #ifdef _XOPEN_SOURCE_EXTENDED\n@@ -46,7 +47,7 @@ class HTTPWorkItem : public HTTPClosure\n         req(std::move(_req)), path(_path), func(_func)\n     {\n     }\n-    void operator()()\n+    void operator()() override\n     {\n         func(req.get(), path);\n     }\n@@ -196,19 +197,16 @@ static bool InitHTTPAllowList()\n     LookupHost(\"::1\", localv6, false);\n     rpc_allow_subnets.push_back(CSubNet(localv4, 8));      // always allow IPv4 local subnet\n     rpc_allow_subnets.push_back(CSubNet(localv6));         // always allow IPv6 localhost\n-    if (mapMultiArgs.count(\"-rpcallowip\")) {\n-        const std::vector<std::string>& vAllow = mapMultiArgs.at(\"-rpcallowip\");\n-        for (std::string strAllow : vAllow) {\n-            CSubNet subnet;\n-            LookupSubNet(strAllow.c_str(), subnet);\n-            if (!subnet.IsValid()) {\n-                uiInterface.ThreadSafeMessageBox(\n-                    strprintf(\"Invalid -rpcallowip subnet specification: %s. Valid are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24).\", strAllow),\n-                    \"\", CClientUIInterface::MSG_ERROR);\n-                return false;\n-            }\n-            rpc_allow_subnets.push_back(subnet);\n+    for (const std::string& strAllow : gArgs.GetArgs(\"-rpcallowip\")) {\n+        CSubNet subnet;\n+        LookupSubNet(strAllow.c_str(), subnet);\n+        if (!subnet.IsValid()) {\n+            uiInterface.ThreadSafeMessageBox(\n+                strprintf(\"Invalid -rpcallowip subnet specification: %s. Valid are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24).\", strAllow),\n+                \"\", CClientUIInterface::MSG_ERROR);\n+            return false;\n         }\n+        rpc_allow_subnets.push_back(subnet);\n     }\n     std::string strAllowed;\n     for (const CSubNet& subnet : rpc_allow_subnets)\n@@ -321,12 +319,11 @@ static bool HTTPBindAddresses(struct evhttp* http)\n         if (IsArgSet(\"-rpcbind\")) {\n             LogPrintf(\"WARNING: option -rpcbind was ignored because -rpcallowip was not specified, refusing to allow everyone to connect\\n\");\n         }\n-    } else if (mapMultiArgs.count(\"-rpcbind\")) { // Specific bind address\n-        const std::vector<std::string>& vbind = mapMultiArgs.at(\"-rpcbind\");\n-        for (std::vector<std::string>::const_iterator i = vbind.begin(); i != vbind.end(); ++i) {\n+    } else if (gArgs.IsArgSet(\"-rpcbind\")) { // Specific bind address\n+        for (const std::string& strRPCBind : gArgs.GetArgs(\"-rpcbind\")) {\n             int port = defaultPort;\n             std::string host;\n-            SplitHostPort(*i, port, host);\n+            SplitHostPort(strRPCBind, port, host);\n             endpoints.push_back(std::make_pair(host, port));\n         }\n     } else { // No specific bind address specified, bind to any\n@@ -369,9 +366,6 @@ static void libevent_log_cb(int severity, const char *msg)\n \n bool InitHTTPServer()\n {\n-    struct evhttp* http = 0;\n-    struct event_base* base = 0;\n-\n     if (!InitHTTPAllowList())\n         return false;\n \n@@ -397,17 +391,13 @@ bool InitHTTPServer()\n     evthread_use_pthreads();\n #endif\n \n-    base = event_base_new(); // XXX RAII\n-    if (!base) {\n-        LogPrintf(\"Couldn't create an event_base: exiting\\n\");\n-        return false;\n-    }\n+    raii_event_base base_ctr = obtain_event_base();\n \n     /* Create a new evhttp object to handle requests. */\n-    http = evhttp_new(base); // XXX RAII\n+    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());\n+    struct evhttp* http = http_ctr.get();\n     if (!http) {\n         LogPrintf(\"couldn't create evhttp. Exiting.\\n\");\n-        event_base_free(base);\n         return false;\n     }\n \n@@ -418,8 +408,6 @@ bool InitHTTPServer()\n \n     if (!HTTPBindAddresses(http)) {\n         LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n-        evhttp_free(http);\n-        event_base_free(base);\n         return false;\n     }\n \n@@ -428,8 +416,9 @@ bool InitHTTPServer()\n     LogPrintf(\"HTTP: creating work queue of depth %d\\n\", workQueueDepth);\n \n     workQueue = new WorkQueue<HTTPClosure>(workQueueDepth);\n-    eventBase = base;\n-    eventHTTP = http;\n+    // tranfer ownership to eventBase/HTTP via .release()\n+    eventBase = base_ctr.release();\n+    eventHTTP = http_ctr.release();\n     return true;\n }\n \n@@ -677,3 +666,14 @@ void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n     }\n }\n \n+std::string urlDecode(const std::string &urlEncoded) {\n+    std::string res;\n+    if (!urlEncoded.empty()) {\n+        char *decoded = evhttp_uridecode(urlEncoded.c_str(), false, NULL);\n+        if (decoded) {\n+            res = std::string(decoded);\n+            free(decoded);\n+        }\n+    }\n+    return res;\n+}"
      },
      {
        "sha": "3e434bf0a0b263ae1a26924710f29f2c5a33bf79",
        "filename": "src/httpserver.h",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/httpserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/httpserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -86,7 +86,7 @@ class HTTPRequest\n \n     /**\n      * Get the request header specified by hdr, or an empty string.\n-     * Return an pair (isPresent,string).\n+     * Return a pair (isPresent,string).\n      */\n     std::pair<bool, std::string> GetHeader(const std::string& hdr);\n \n@@ -125,7 +125,7 @@ class HTTPClosure\n     virtual ~HTTPClosure() {}\n };\n \n-/** Event class. This can be used either as an cross-thread trigger or as a timer.\n+/** Event class. This can be used either as a cross-thread trigger or as a timer.\n  */\n class HTTPEvent\n {\n@@ -148,4 +148,6 @@ class HTTPEvent\n     struct event* ev;\n };\n \n+std::string urlDecode(const std::string &urlEncoded);\n+\n #endif // BITCOIN_HTTPSERVER_H"
      },
      {
        "sha": "ca62d3e7cc3395c3a9c20689686d24d9601dd834",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 232,
        "deletions": 192,
        "changes": 424,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -25,6 +25,8 @@\n #include \"netbase.h\"\n #include \"net.h\"\n #include \"net_processing.h\"\n+#include \"policy/feerate.h\"\n+#include \"policy/fees.h\"\n #include \"policy/policy.h\"\n #include \"rpc/server.h\"\n #include \"rpc/register.h\"\n@@ -53,11 +55,9 @@\n #endif\n \n #include <boost/algorithm/string/classification.hpp>\n-#include <boost/algorithm/string/predicate.hpp>\n #include <boost/algorithm/string/replace.hpp>\n #include <boost/algorithm/string/split.hpp>\n #include <boost/bind.hpp>\n-#include <boost/function.hpp>\n #include <boost/interprocess/sync/file_lock.hpp>\n #include <boost/thread.hpp>\n #include <openssl/crypto.h>\n@@ -88,14 +88,6 @@ static CZMQNotificationInterface* pzmqNotificationInterface = NULL;\n #define MIN_CORE_FILEDESCRIPTORS 150\n #endif\n \n-/** Used to pass flags to the Bind() function */\n-enum BindFlags {\n-    BF_NONE         = 0,\n-    BF_EXPLICIT     = (1U << 0),\n-    BF_REPORT_ERROR = (1U << 1),\n-    BF_WHITELIST    = (1U << 2),\n-};\n-\n static const char* FEE_ESTIMATES_FILENAME=\"fee_estimates.dat\";\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -145,9 +137,9 @@ class CCoinsViewErrorCatcher : public CCoinsViewBacked\n {\n public:\n     CCoinsViewErrorCatcher(CCoinsView* view) : CCoinsViewBacked(view) {}\n-    bool GetCoins(const uint256 &txid, CCoins &coins) const {\n+    bool GetCoin(const COutPoint &outpoint, Coin &coin) const override {\n         try {\n-            return CCoinsViewBacked::GetCoins(txid, coins);\n+            return CCoinsViewBacked::GetCoin(outpoint, coin);\n         } catch(const std::runtime_error& e) {\n             uiInterface.ThreadSafeMessageBox(_(\"Error reading from database, shutting down.\"), \"\", CClientUIInterface::MSG_ERROR);\n             LogPrintf(\"Error reading from database: %s\\n\", e.what());\n@@ -161,7 +153,6 @@ class CCoinsViewErrorCatcher : public CCoinsViewBacked\n     // Writes do not need similar protection, as failure to write is handled by the caller.\n };\n \n-static CCoinsViewDB *pcoinsdbview = NULL;\n static CCoinsViewErrorCatcher *pcoinscatcher = NULL;\n static std::unique_ptr<ECCVerifyHandle> globalVerifyHandle;\n \n@@ -197,8 +188,9 @@ void Shutdown()\n     StopRPC();\n     StopHTTPServer();\n #ifdef ENABLE_WALLET\n-    if (pwalletMain)\n-        pwalletMain->Flush(false);\n+    for (CWalletRef pwallet : vpwallets) {\n+        pwallet->Flush(false);\n+    }\n #endif\n     MapPort(false);\n     UnregisterValidationInterface(peerLogic.get());\n@@ -207,20 +199,37 @@ void Shutdown()\n \n     StopTorControl();\n     UnregisterNodeSignals(GetNodeSignals());\n-    if (fDumpMempoolLater)\n+    if (fDumpMempoolLater && GetArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) {\n         DumpMempool();\n+    }\n \n     if (fFeeEstimatesInitialized)\n     {\n+        ::feeEstimator.FlushUnconfirmed(::mempool);\n         fs::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n         CAutoFile est_fileout(fsbridge::fopen(est_path, \"wb\"), SER_DISK, CLIENT_VERSION);\n         if (!est_fileout.IsNull())\n-            mempool.WriteFeeEstimates(est_fileout);\n+            ::feeEstimator.Write(est_fileout);\n         else\n             LogPrintf(\"%s: Failed to write fee estimates to %s\\n\", __func__, est_path.string());\n         fFeeEstimatesInitialized = false;\n     }\n \n+    // FlushStateToDisk generates a SetBestChain callback, which we should avoid missing\n+    if (pcoinsTip != nullptr) {\n+        FlushStateToDisk();\n+    }\n+\n+    // After there are no more peers/RPC left to give us new data which may generate\n+    // CValidationInterface callbacks, flush them...\n+    GetMainSignals().FlushBackgroundCallbacks();\n+\n+    // Any future callbacks will be dropped. This should absolutely be safe - if\n+    // missing a callback results in an unrecoverable situation, unclean shutdown\n+    // would too. The only reason to do the above flushes is to let the wallet catch\n+    // up with our current chain to avoid any strange pruning edge cases and make\n+    // next startup faster by avoiding rescan.\n+\n     {\n         LOCK(cs_main);\n         if (pcoinsTip != NULL) {\n@@ -236,8 +245,9 @@ void Shutdown()\n         pblocktree = NULL;\n     }\n #ifdef ENABLE_WALLET\n-    if (pwalletMain)\n-        pwalletMain->Flush(true);\n+    for (CWalletRef pwallet : vpwallets) {\n+        pwallet->Flush(true);\n+    }\n #endif\n \n #if ENABLE_ZMQ\n@@ -256,9 +266,12 @@ void Shutdown()\n     }\n #endif\n     UnregisterAllValidationInterfaces();\n+    GetMainSignals().UnregisterBackgroundSignalScheduler();\n #ifdef ENABLE_WALLET\n-    delete pwalletMain;\n-    pwalletMain = NULL;\n+    for (CWalletRef pwallet : vpwallets) {\n+        delete pwallet;\n+    }\n+    vpwallets.clear();\n #endif\n     globalVerifyHandle.reset();\n     ECC_Stop();\n@@ -291,17 +304,6 @@ static void registerSignalHandler(int signal, void(*handler)(int))\n }\n #endif\n \n-bool static Bind(CConnman& connman, const CService &addr, unsigned int flags) {\n-    if (!(flags & BF_EXPLICIT) && IsLimited(addr))\n-        return false;\n-    std::string strError;\n-    if (!connman.BindListenPort(addr, strError, (flags & BF_WHITELIST) != 0)) {\n-        if (flags & BF_REPORT_ERROR)\n-            return InitError(strError);\n-        return false;\n-    }\n-    return true;\n-}\n void OnRPCStarted()\n {\n     uiInterface.NotifyBlockTip.connect(&RPCNotifyBlockChange);\n@@ -326,6 +328,10 @@ void OnRPCPreCommand(const CRPCCommand& cmd)\n \n std::string HelpMessage(HelpMessageMode mode)\n {\n+    const auto defaultBaseParams = CreateBaseChainParams(CBaseChainParams::MAIN);\n+    const auto testnetBaseParams = CreateBaseChainParams(CBaseChainParams::TESTNET);\n+    const auto defaultChainParams = CreateChainParams(CBaseChainParams::MAIN);\n+    const auto testnetChainParams = CreateChainParams(CBaseChainParams::TESTNET);\n     const bool showDebug = GetBoolArg(\"-help-debug\", false);\n \n     // When adding new options to the categories, please keep and ensure alphabetical ordering.\n@@ -337,7 +343,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-blocknotify=<cmd>\", _(\"Execute command when the best block changes (%s in cmd is replaced by block hash)\"));\n     if (showDebug)\n         strUsage += HelpMessageOpt(\"-blocksonly\", strprintf(_(\"Whether to operate in a blocks only mode (default: %u)\"), DEFAULT_BLOCKSONLY));\n-    strUsage +=HelpMessageOpt(\"-assumevalid=<hex>\", strprintf(_(\"If this block is in the chain assume that it and its ancestors are valid and potentially skip their script verification (0 to verify all, default: %s, testnet: %s)\"), Params(CBaseChainParams::MAIN).GetConsensus().defaultAssumeValid.GetHex(), Params(CBaseChainParams::TESTNET).GetConsensus().defaultAssumeValid.GetHex()));\n+    strUsage +=HelpMessageOpt(\"-assumevalid=<hex>\", strprintf(_(\"If this block is in the chain assume that it and its ancestors are valid and potentially skip their script verification (0 to verify all, default: %s, testnet: %s)\"), defaultChainParams->GetConsensus().defaultAssumeValid.GetHex(), testnetChainParams->GetConsensus().defaultAssumeValid.GetHex()));\n     strUsage += HelpMessageOpt(\"-conf=<file>\", strprintf(_(\"Specify configuration file (default: %s)\"), BITCOIN_CONF_FILENAME));\n     if (mode == HMM_BITCOIND)\n     {\n@@ -346,13 +352,17 @@ std::string HelpMessage(HelpMessageMode mode)\n #endif\n     }\n     strUsage += HelpMessageOpt(\"-datadir=<dir>\", _(\"Specify data directory\"));\n+    if (showDebug) {\n+        strUsage += HelpMessageOpt(\"-dbbatchsize\", strprintf(\"Maximum database write batch size in bytes (default: %u)\", nDefaultDbBatchSize));\n+    }\n     strUsage += HelpMessageOpt(\"-dbcache=<n>\", strprintf(_(\"Set database cache size in megabytes (%d to %d, default: %d)\"), nMinDbCache, nMaxDbCache, nDefaultDbCache));\n     if (showDebug)\n         strUsage += HelpMessageOpt(\"-feefilter\", strprintf(\"Tell other nodes to filter invs to us by our mempool min fee (default: %u)\", DEFAULT_FEEFILTER));\n     strUsage += HelpMessageOpt(\"-loadblock=<file>\", _(\"Imports blocks from external blk000??.dat file on startup\"));\n     strUsage += HelpMessageOpt(\"-maxorphantx=<n>\", strprintf(_(\"Keep at most <n> unconnectable transactions in memory (default: %u)\"), DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n     strUsage += HelpMessageOpt(\"-maxmempool=<n>\", strprintf(_(\"Keep the transaction memory pool below <n> megabytes (default: %u)\"), DEFAULT_MAX_MEMPOOL_SIZE));\n     strUsage += HelpMessageOpt(\"-mempoolexpiry=<n>\", strprintf(_(\"Do not keep transactions in the mempool longer than <n> hours (default: %u)\"), DEFAULT_MEMPOOL_EXPIRY));\n+    strUsage += HelpMessageOpt(\"-persistmempool\", strprintf(_(\"Whether to save the mempool on shutdown and load on restart (default: %u)\"), DEFAULT_PERSIST_MEMPOOL));\n     strUsage += HelpMessageOpt(\"-blockreconstructionextratxn=<n>\", strprintf(_(\"Extra transactions to keep in memory for compact block reconstructions (default: %u)\"), DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN));\n     strUsage += HelpMessageOpt(\"-par=<n>\", strprintf(_(\"Set the number of script verification threads (%u to %d, 0 = auto, <0 = leave that many cores free, default: %d)\"),\n         -GetNumCores(), MAX_SCRIPTCHECK_THREADS, DEFAULT_SCRIPTCHECK_THREADS));\n@@ -390,7 +400,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-onlynet=<net>\", _(\"Only connect to nodes in network <net> (ipv4, ipv6 or onion)\"));\n     strUsage += HelpMessageOpt(\"-permitbaremultisig\", strprintf(_(\"Relay non-P2SH multisig (default: %u)\"), DEFAULT_PERMIT_BAREMULTISIG));\n     strUsage += HelpMessageOpt(\"-peerbloomfilters\", strprintf(_(\"Support filtering of blocks and transaction with bloom filters (default: %u)\"), DEFAULT_PEERBLOOMFILTERS));\n-    strUsage += HelpMessageOpt(\"-port=<port>\", strprintf(_(\"Listen for connections on <port> (default: %u or testnet: %u)\"), Params(CBaseChainParams::MAIN).GetDefaultPort(), Params(CBaseChainParams::TESTNET).GetDefaultPort()));\n+    strUsage += HelpMessageOpt(\"-port=<port>\", strprintf(_(\"Listen for connections on <port> (default: %u or testnet: %u)\"), defaultChainParams->GetDefaultPort(), testnetChainParams->GetDefaultPort()));\n     strUsage += HelpMessageOpt(\"-proxy=<ip:port>\", _(\"Connect through SOCKS5 proxy\"));\n     strUsage += HelpMessageOpt(\"-proxyrandomize\", strprintf(_(\"Randomize credentials for every proxy connection. This enables Tor stream isolation (default: %u)\"), DEFAULT_PROXYRANDOMIZE));\n     strUsage += HelpMessageOpt(\"-seednode=<ip>\", _(\"Connect to a node to retrieve peer addresses, and disconnect\"));\n@@ -427,19 +437,21 @@ std::string HelpMessage(HelpMessageMode mode)\n     {\n         strUsage += HelpMessageOpt(\"-checkblocks=<n>\", strprintf(_(\"How many blocks to check at startup (default: %u, 0 = all)\"), DEFAULT_CHECKBLOCKS));\n         strUsage += HelpMessageOpt(\"-checklevel=<n>\", strprintf(_(\"How thorough the block verification of -checkblocks is (0-4, default: %u)\"), DEFAULT_CHECKLEVEL));\n-        strUsage += HelpMessageOpt(\"-checkblockindex\", strprintf(\"Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive and mapBlocksUnlinked occasionally. Also sets -checkmempool (default: %u)\", Params(CBaseChainParams::MAIN).DefaultConsistencyChecks()));\n-        strUsage += HelpMessageOpt(\"-checkmempool=<n>\", strprintf(\"Run checks every <n> transactions (default: %u)\", Params(CBaseChainParams::MAIN).DefaultConsistencyChecks()));\n+        strUsage += HelpMessageOpt(\"-checkblockindex\", strprintf(\"Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive and mapBlocksUnlinked occasionally. Also sets -checkmempool (default: %u)\", defaultChainParams->DefaultConsistencyChecks()));\n+        strUsage += HelpMessageOpt(\"-checkmempool=<n>\", strprintf(\"Run checks every <n> transactions (default: %u)\", defaultChainParams->DefaultConsistencyChecks()));\n         strUsage += HelpMessageOpt(\"-checkpoints\", strprintf(\"Disable expensive verification for known chain history (default: %u)\", DEFAULT_CHECKPOINTS_ENABLED));\n         strUsage += HelpMessageOpt(\"-disablesafemode\", strprintf(\"Disable safemode, override a real safe mode event (default: %u)\", DEFAULT_DISABLE_SAFEMODE));\n         strUsage += HelpMessageOpt(\"-testsafemode\", strprintf(\"Force safe mode (default: %u)\", DEFAULT_TESTSAFEMODE));\n         strUsage += HelpMessageOpt(\"-dropmessagestest=<n>\", \"Randomly drop 1 of every <n> network messages\");\n         strUsage += HelpMessageOpt(\"-fuzzmessagestest=<n>\", \"Randomly fuzz 1 of every <n> network messages\");\n         strUsage += HelpMessageOpt(\"-stopafterblockimport\", strprintf(\"Stop running after importing blocks from disk (default: %u)\", DEFAULT_STOPAFTERBLOCKIMPORT));\n+        strUsage += HelpMessageOpt(\"-stopatheight\", strprintf(\"Stop running after reaching the given height in the main chain (default: %u)\", DEFAULT_STOPATHEIGHT));\n+\n         strUsage += HelpMessageOpt(\"-limitancestorcount=<n>\", strprintf(\"Do not accept transactions if number of in-mempool ancestors is <n> or more (default: %u)\", DEFAULT_ANCESTOR_LIMIT));\n         strUsage += HelpMessageOpt(\"-limitancestorsize=<n>\", strprintf(\"Do not accept transactions whose size with all in-mempool ancestors exceeds <n> kilobytes (default: %u)\", DEFAULT_ANCESTOR_SIZE_LIMIT));\n         strUsage += HelpMessageOpt(\"-limitdescendantcount=<n>\", strprintf(\"Do not accept transactions if any ancestor would have <n> or more in-mempool descendants (default: %u)\", DEFAULT_DESCENDANT_LIMIT));\n         strUsage += HelpMessageOpt(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT));\n-        strUsage += HelpMessageOpt(\"-bip9params=deployment:start:end\", \"Use given start/end times for specified BIP9 deployment (regtest-only)\");\n+        strUsage += HelpMessageOpt(\"-vbparams=deployment:start:end\", \"Use given start/end times for specified version bits deployment (regtest-only)\");\n     }\n     strUsage += HelpMessageOpt(\"-debug=<category>\", strprintf(_(\"Output debugging information (default: %u, supplying <category> is optional)\"), 0) + \". \" +\n         _(\"If <category> is not supplied or if <category> = 1, output all debugging information.\") + \" \" + _(\"<category> can be:\") + \" \" + ListLogCategories() + \".\");\n@@ -451,7 +463,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     {\n         strUsage += HelpMessageOpt(\"-logtimemicros\", strprintf(\"Add microsecond precision to debug timestamps (default: %u)\", DEFAULT_LOGTIMEMICROS));\n         strUsage += HelpMessageOpt(\"-mocktime=<n>\", \"Replace actual time with <n> seconds since epoch (default: 0)\");\n-        strUsage += HelpMessageOpt(\"-maxsigcachesize=<n>\", strprintf(\"Limit size of signature cache to <n> MiB (default: %u)\", DEFAULT_MAX_SIG_CACHE_SIZE));\n+        strUsage += HelpMessageOpt(\"-maxsigcachesize=<n>\", strprintf(\"Limit sum of signature cache and script execution cache sizes to <n> MiB (default: %u)\", DEFAULT_MAX_SIG_CACHE_SIZE));\n         strUsage += HelpMessageOpt(\"-maxtipage=<n>\", strprintf(\"Maximum tip age in seconds to consider node in initial block download (default: %u)\", DEFAULT_MAX_TIP_AGE));\n     }\n     strUsage += HelpMessageOpt(\"-maxtxfee=<amt>\", strprintf(_(\"Maximum total fees (in %s) to use in a single wallet transaction or raw transaction; setting this too low may abort large transactions (default: %s)\"),\n@@ -467,9 +479,9 @@ std::string HelpMessage(HelpMessageMode mode)\n \n     strUsage += HelpMessageGroup(_(\"Node relay options:\"));\n     if (showDebug) {\n-        strUsage += HelpMessageOpt(\"-acceptnonstdtxn\", strprintf(\"Relay and mine \\\"non-standard\\\" transactions (%sdefault: %u)\", \"testnet/regtest only; \", !Params(CBaseChainParams::TESTNET).RequireStandard()));\n+        strUsage += HelpMessageOpt(\"-acceptnonstdtxn\", strprintf(\"Relay and mine \\\"non-standard\\\" transactions (%sdefault: %u)\", \"testnet/regtest only; \", defaultChainParams->RequireStandard()));\n         strUsage += HelpMessageOpt(\"-incrementalrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kB) used to define cost of relay, used for mempool limiting and BIP 125 replacement. (default: %s)\", CURRENCY_UNIT, FormatMoney(DEFAULT_INCREMENTAL_RELAY_FEE)));\n-        strUsage += HelpMessageOpt(\"-dustrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kB) used to defined dust, the value of an output such that it will cost about 1/3 of its value in fees at this fee rate to spend it. (default: %s)\", CURRENCY_UNIT, FormatMoney(DUST_RELAY_TX_FEE)));\n+        strUsage += HelpMessageOpt(\"-dustrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kB) used to defined dust, the value of an output such that it will cost more than its value in fees at this fee rate to spend it. (default: %s)\", CURRENCY_UNIT, FormatMoney(DUST_RELAY_TX_FEE)));\n     }\n     strUsage += HelpMessageOpt(\"-bytespersigop\", strprintf(_(\"Equivalent bytes per sigop in transactions for relay and mining (default: %u)\"), DEFAULT_BYTES_PER_SIGOP));\n     strUsage += HelpMessageOpt(\"-datacarrier\", strprintf(_(\"Relay and mine data carrier transactions (default: %u)\"), DEFAULT_ACCEPT_DATACARRIER));\n@@ -495,7 +507,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-rpcuser=<user>\", _(\"Username for JSON-RPC connections\"));\n     strUsage += HelpMessageOpt(\"-rpcpassword=<pw>\", _(\"Password for JSON-RPC connections\"));\n     strUsage += HelpMessageOpt(\"-rpcauth=<userpw>\", _(\"Username and hashed password for JSON-RPC connections. The field <userpw> comes in the format: <USERNAME>:<SALT>$<HASH>. A canonical python script is included in share/rpcuser. The client then connects normally using the rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. This option can be specified multiple times\"));\n-    strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\"Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)\"), BaseParams(CBaseChainParams::MAIN).RPCPort(), BaseParams(CBaseChainParams::TESTNET).RPCPort()));\n+    strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\"Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)\"), defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()));\n     strUsage += HelpMessageOpt(\"-rpcallowip=<ip>\", _(\"Allow JSON-RPC connections from specified source. Valid for <ip> are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option can be specified multiple times\"));\n     strUsage += HelpMessageOpt(\"-rpcserialversion\", strprintf(_(\"Sets the serialization of raw transaction or block hex returned in non-verbose mode, non-segwit(0) or segwit(1) (default: %d)\"), DEFAULT_RPC_SERIALIZE_VERSION));\n     strUsage += HelpMessageOpt(\"-rpcthreads=<n>\", strprintf(_(\"Set the number of threads to service RPC calls (default: %d)\"), DEFAULT_HTTP_THREADS));\n@@ -601,7 +613,7 @@ void CleanupBlockRevFiles()\n     // keeping a separate counter.  Once we hit a gap (or if 0 doesn't exist)\n     // start removing block files.\n     int nContigCounter = 0;\n-    BOOST_FOREACH(const PAIRTYPE(std::string, fs::path)& item, mapBlockFiles) {\n+    for (const std::pair<std::string, fs::path>& item : mapBlockFiles) {\n         if (atoi(item.first) == nContigCounter) {\n             nContigCounter++;\n             continue;\n@@ -636,7 +648,7 @@ void ThreadImport(std::vector<fs::path> vImportFiles)\n         fReindex = false;\n         LogPrintf(\"Reindexing finished\\n\");\n         // To avoid ending up in a situation without genesis block, re-try initializing (no-op if reindexing worked):\n-        InitBlockIndex(chainparams);\n+        LoadGenesisBlock(chainparams);\n     }\n \n     // hardcoded $DATADIR/bootstrap.dat\n@@ -654,7 +666,7 @@ void ThreadImport(std::vector<fs::path> vImportFiles)\n     }\n \n     // -loadblock=\n-    BOOST_FOREACH(const fs::path& path, vImportFiles) {\n+    for (const fs::path& path : vImportFiles) {\n         FILE *file = fsbridge::fopen(path, \"rb\");\n         if (file) {\n             LogPrintf(\"Importing blocks file %s...\\n\", path.string());\n@@ -676,8 +688,10 @@ void ThreadImport(std::vector<fs::path> vImportFiles)\n         StartShutdown();\n     }\n     } // End scope of CImportingNow\n-    LoadMempool();\n-    fDumpMempoolLater = !fRequestShutdown;\n+    if (GetArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) {\n+        LoadMempool();\n+        fDumpMempoolLater = !fRequestShutdown;\n+    }\n }\n \n /** Sanity checks\n@@ -734,7 +748,7 @@ void InitParameterInteraction()\n             LogPrintf(\"%s: parameter interaction: -whitebind set -> setting -listen=1\\n\", __func__);\n     }\n \n-    if (mapMultiArgs.count(\"-connect\") && mapMultiArgs.at(\"-connect\").size() > 0) {\n+    if (gArgs.IsArgSet(\"-connect\")) {\n         // when only connecting to trusted nodes, do not seed via DNS, or listen by default\n         if (SoftSetBoolArg(\"-dnsseed\", false))\n             LogPrintf(\"%s: parameter interaction: -connect set -> setting -dnsseed=0\\n\", __func__);\n@@ -808,7 +822,7 @@ int nUserMaxConnections;\n int nFD;\n ServiceFlags nLocalServices = NODE_NETWORK;\n \n-}\n+} // namespace\n \n [[noreturn]] static void new_handler_terminate()\n {\n@@ -830,8 +844,6 @@ bool AppInitBasicSetup()\n     // Turn off Microsoft heap dump noise\n     _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);\n     _CrtSetReportFile(_CRT_WARN, CreateFileA(\"NUL\", GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0));\n-#endif\n-#if _MSC_VER >= 1400\n     // Disable confusing \"helpful\" text message on abort, Ctrl-C\n     _set_abort_behavior(0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);\n #endif\n@@ -886,10 +898,14 @@ bool AppInitParameterInteraction()\n             return InitError(_(\"Prune mode is incompatible with -txindex.\"));\n     }\n \n+    // -bind and -whitebind can't be set when not listening\n+    size_t nUserBind = gArgs.GetArgs(\"-bind\").size() + gArgs.GetArgs(\"-whitebind\").size();\n+    if (nUserBind != 0 && !gArgs.GetBoolArg(\"-listen\", DEFAULT_LISTEN)) {\n+        return InitError(\"Cannot set -bind or -whitebind together with -listen=0\");\n+    }\n+\n     // Make sure enough file descriptors are available\n-    int nBind = std::max(\n-                (mapMultiArgs.count(\"-bind\") ? mapMultiArgs.at(\"-bind\").size() : 0) +\n-                (mapMultiArgs.count(\"-whitebind\") ? mapMultiArgs.at(\"-whitebind\").size() : 0), size_t(1));\n+    int nBind = std::max(nUserBind, size_t(1));\n     nUserMaxConnections = GetArg(\"-maxconnections\", DEFAULT_MAX_PEER_CONNECTIONS);\n     nMaxConnections = std::max(nUserMaxConnections, 0);\n \n@@ -904,9 +920,9 @@ bool AppInitParameterInteraction()\n         InitWarning(strprintf(_(\"Reducing -maxconnections from %d to %d, because of system limitations.\"), nUserMaxConnections, nMaxConnections));\n \n     // ********************************************************* Step 3: parameter-to-internal-flags\n-    if (mapMultiArgs.count(\"-debug\") > 0) {\n+    if (gArgs.IsArgSet(\"-debug\")) {\n         // Special-case: if -debug=0/-nodebug is set, turn off debugging messages\n-        const std::vector<std::string>& categories = mapMultiArgs.at(\"-debug\");\n+        const std::vector<std::string> categories = gArgs.GetArgs(\"-debug\");\n \n         if (find(categories.begin(), categories.end(), std::string(\"0\")) == categories.end()) {\n             for (const auto& cat : categories) {\n@@ -921,16 +937,13 @@ bool AppInitParameterInteraction()\n     }\n \n     // Now remove the logging categories which were explicitly excluded\n-    if (mapMultiArgs.count(\"-debugexclude\") > 0) {\n-        const std::vector<std::string>& excludedCategories = mapMultiArgs.at(\"-debugexclude\");\n-        for (const auto& cat : excludedCategories) {\n-            uint32_t flag = 0;\n-            if (!GetLogCategory(&flag, &cat)) {\n-                InitWarning(strprintf(_(\"Unsupported logging category %s=%s.\"), \"-debugexclude\", cat));\n-                continue;\n-            }\n-            logCategories &= ~flag;\n+    for (const std::string& cat : gArgs.GetArgs(\"-debugexclude\")) {\n+        uint32_t flag = 0;\n+        if (!GetLogCategory(&flag, &cat)) {\n+            InitWarning(strprintf(_(\"Unsupported logging category %s=%s.\"), \"-debugexclude\", cat));\n+            continue;\n         }\n+        logCategories &= ~flag;\n     }\n \n     // Check for -debugnet\n@@ -1017,14 +1030,7 @@ bool AppInitParameterInteraction()\n     if (nConnectTimeout <= 0)\n         nConnectTimeout = DEFAULT_CONNECT_TIMEOUT;\n \n-    // Fee-per-kilobyte amount required for mempool acceptance and relay\n-    // If you are mining, be careful setting this:\n-    // if you set it to zero then\n-    // a transaction spammer can cheaply fill blocks using\n-    // 0-fee transactions. It should be set above the real\n-    // cost to you of processing a transaction.\n-    if (IsArgSet(\"-minrelaytxfee\"))\n-    {\n+    if (IsArgSet(\"-minrelaytxfee\")) {\n         CAmount n = 0;\n         if (!ParseMoney(GetArg(\"-minrelaytxfee\", \"\"), n)) {\n             return InitError(AmountErrMsg(\"minrelaytxfee\", GetArg(\"-minrelaytxfee\", \"\")));\n@@ -1093,17 +1099,16 @@ bool AppInitParameterInteraction()\n         fEnableReplacement = (std::find(vstrReplacementModes.begin(), vstrReplacementModes.end(), \"fee\") != vstrReplacementModes.end());\n     }\n \n-    if (mapMultiArgs.count(\"-bip9params\")) {\n-        // Allow overriding BIP9 parameters for testing\n+    if (gArgs.IsArgSet(\"-vbparams\")) {\n+        // Allow overriding version bits parameters for testing\n         if (!chainparams.MineBlocksOnDemand()) {\n-            return InitError(\"BIP9 parameters may only be overridden on regtest.\");\n+            return InitError(\"Version bits parameters may only be overridden on regtest.\");\n         }\n-        const std::vector<std::string>& deployments = mapMultiArgs.at(\"-bip9params\");\n-        for (auto i : deployments) {\n+        for (const std::string& strDeployment : gArgs.GetArgs(\"-vbparams\")) {\n             std::vector<std::string> vDeploymentParams;\n-            boost::split(vDeploymentParams, i, boost::is_any_of(\":\"));\n+            boost::split(vDeploymentParams, strDeployment, boost::is_any_of(\":\"));\n             if (vDeploymentParams.size() != 3) {\n-                return InitError(\"BIP9 parameters malformed, expecting deployment:start:end\");\n+                return InitError(\"Version bits parameters malformed, expecting deployment:start:end\");\n             }\n             int64_t nStartTime, nTimeout;\n             if (!ParseInt64(vDeploymentParams[1], &nStartTime)) {\n@@ -1116,9 +1121,9 @@ bool AppInitParameterInteraction()\n             for (int j=0; j<(int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j)\n             {\n                 if (vDeploymentParams[0].compare(VersionBitsDeploymentInfo[j].name) == 0) {\n-                    UpdateRegtestBIP9Parameters(Consensus::DeploymentPos(j), nStartTime, nTimeout);\n+                    UpdateVersionBitsParameters(Consensus::DeploymentPos(j), nStartTime, nTimeout);\n                     found = true;\n-                    LogPrintf(\"Setting BIP9 activation parameters for %s to start=%ld, timeout=%ld\\n\", vDeploymentParams[0], nStartTime, nTimeout);\n+                    LogPrintf(\"Setting version bits activation parameters for %s to start=%ld, timeout=%ld\\n\", vDeploymentParams[0], nStartTime, nTimeout);\n                     break;\n                 }\n             }\n@@ -1158,6 +1163,9 @@ bool AppInitSanityChecks()\n     // ********************************************************* Step 4: sanity checks\n \n     // Initialize elliptic curve code\n+    std::string sha256_algo = SHA256AutoDetect();\n+    LogPrintf(\"Using the '%s' SHA256 implementation\\n\", sha256_algo);\n+    RandomInit();\n     ECC_Start();\n     globalVerifyHandle.reset(new ECCVerifyHandle());\n \n@@ -1166,21 +1174,27 @@ bool AppInitSanityChecks()\n         return InitError(strprintf(_(\"Initialization sanity check failed. %s is shutting down.\"), _(PACKAGE_NAME)));\n \n     // Probe the data directory lock to give an early error message, if possible\n+    // We cannot hold the data directory lock here, as the forking for daemon() hasn't yet happened,\n+    // and a fork will cause weird behavior to it.\n     return LockDataDirectory(true);\n }\n \n-bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n+bool AppInitLockDataDirectory()\n {\n-    const CChainParams& chainparams = Params();\n-    // ********************************************************* Step 4a: application initialization\n     // After daemonization get the data directory lock again and hold on to it until exit\n     // This creates a slight window for a race condition to happen, however this condition is harmless: it\n     // will at most make us exit without printing a message to console.\n     if (!LockDataDirectory(false)) {\n         // Detailed error printed inside LockDataDirectory\n         return false;\n     }\n+    return true;\n+}\n \n+bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n+{\n+    const CChainParams& chainparams = Params();\n+    // ********************************************************* Step 4a: application initialization\n #ifndef WIN32\n     CreatePidFile(GetPidFile(), getpid());\n #endif\n@@ -1201,6 +1215,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     LogPrintf(\"Using at most %i automatic connections (%i file descriptors available)\\n\", nMaxConnections, nFD);\n \n     InitSignatureCache();\n+    InitScriptExecutionCache();\n \n     LogPrintf(\"Using %u threads for script verification\\n\", nScriptCheckThreads);\n     if (nScriptCheckThreads) {\n@@ -1212,6 +1227,8 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     CScheduler::Function serviceLoop = boost::bind(&CScheduler::serviceQueue, &scheduler);\n     threadGroup.create_thread(boost::bind(&TraceThread<CScheduler::Function>, \"scheduler\", serviceLoop));\n \n+    GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n+\n     /* Start the RPC server already.  It will be started in \"warmup\" mode\n      * and not really process calls already (but it will signify connections\n      * that the server is there and will be ready later).  Warmup mode will\n@@ -1247,23 +1264,20 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n \n     // sanitize comments per BIP-0014, format user agent and check total size\n     std::vector<std::string> uacomments;\n-    if (mapMultiArgs.count(\"-uacomment\")) {\n-        BOOST_FOREACH(std::string cmt, mapMultiArgs.at(\"-uacomment\"))\n-        {\n-            if (cmt != SanitizeString(cmt, SAFE_CHARS_UA_COMMENT))\n-                return InitError(strprintf(_(\"User Agent comment (%s) contains unsafe characters.\"), cmt));\n-            uacomments.push_back(cmt);\n-        }\n+    for (const std::string& cmt : gArgs.GetArgs(\"-uacomment\")) {\n+        if (cmt != SanitizeString(cmt, SAFE_CHARS_UA_COMMENT))\n+            return InitError(strprintf(_(\"User Agent comment (%s) contains unsafe characters.\"), cmt));\n+        uacomments.push_back(cmt);\n     }\n     strSubVersion = FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, uacomments);\n     if (strSubVersion.size() > MAX_SUBVERSION_LENGTH) {\n         return InitError(strprintf(_(\"Total length of network version string (%i) exceeds maximum length (%i). Reduce the number or size of uacomments.\"),\n             strSubVersion.size(), MAX_SUBVERSION_LENGTH));\n     }\n \n-    if (mapMultiArgs.count(\"-onlynet\")) {\n+    if (gArgs.IsArgSet(\"-onlynet\")) {\n         std::set<enum Network> nets;\n-        BOOST_FOREACH(const std::string& snet, mapMultiArgs.at(\"-onlynet\")) {\n+        for (const std::string& snet : gArgs.GetArgs(\"-onlynet\")) {\n             enum Network net = ParseNetwork(snet);\n             if (net == NET_UNROUTABLE)\n                 return InitError(strprintf(_(\"Unknown network specified in -onlynet: '%s'\"), snet));\n@@ -1276,16 +1290,6 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n         }\n     }\n \n-    if (mapMultiArgs.count(\"-whitelist\")) {\n-        BOOST_FOREACH(const std::string& net, mapMultiArgs.at(\"-whitelist\")) {\n-            CSubNet subnet;\n-            LookupSubNet(net.c_str(), subnet);\n-            if (!subnet.IsValid())\n-                return InitError(strprintf(_(\"Invalid netmask specified in -whitelist: '%s'\"), net));\n-            connman.AddWhitelistedRange(subnet);\n-        }\n-    }\n-\n     // Check for host lookup allowed before parsing any network related parameters\n     fNameLookup = GetBoolArg(\"-dns\", DEFAULT_NAME_LOOKUP);\n \n@@ -1336,49 +1340,12 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     fDiscover = GetBoolArg(\"-discover\", true);\n     fRelayTxes = !GetBoolArg(\"-blocksonly\", DEFAULT_BLOCKSONLY);\n \n-    if (fListen) {\n-        bool fBound = false;\n-        if (mapMultiArgs.count(\"-bind\")) {\n-            BOOST_FOREACH(const std::string& strBind, mapMultiArgs.at(\"-bind\")) {\n-                CService addrBind;\n-                if (!Lookup(strBind.c_str(), addrBind, GetListenPort(), false))\n-                    return InitError(ResolveErrMsg(\"bind\", strBind));\n-                fBound |= Bind(connman, addrBind, (BF_EXPLICIT | BF_REPORT_ERROR));\n-            }\n-        }\n-        if (mapMultiArgs.count(\"-whitebind\")) {\n-            BOOST_FOREACH(const std::string& strBind, mapMultiArgs.at(\"-whitebind\")) {\n-                CService addrBind;\n-                if (!Lookup(strBind.c_str(), addrBind, 0, false))\n-                    return InitError(ResolveErrMsg(\"whitebind\", strBind));\n-                if (addrBind.GetPort() == 0)\n-                    return InitError(strprintf(_(\"Need to specify a port with -whitebind: '%s'\"), strBind));\n-                fBound |= Bind(connman, addrBind, (BF_EXPLICIT | BF_REPORT_ERROR | BF_WHITELIST));\n-            }\n-        }\n-        if (!mapMultiArgs.count(\"-bind\") && !mapMultiArgs.count(\"-whitebind\")) {\n-            struct in_addr inaddr_any;\n-            inaddr_any.s_addr = INADDR_ANY;\n-            fBound |= Bind(connman, CService(in6addr_any, GetListenPort()), BF_NONE);\n-            fBound |= Bind(connman, CService(inaddr_any, GetListenPort()), !fBound ? BF_REPORT_ERROR : BF_NONE);\n-        }\n-        if (!fBound)\n-            return InitError(_(\"Failed to listen on any port. Use -listen=0 if you want this.\"));\n-    }\n-\n-    if (mapMultiArgs.count(\"-externalip\")) {\n-        BOOST_FOREACH(const std::string& strAddr, mapMultiArgs.at(\"-externalip\")) {\n-            CService addrLocal;\n-            if (Lookup(strAddr.c_str(), addrLocal, GetListenPort(), fNameLookup) && addrLocal.IsValid())\n-                AddLocal(addrLocal, LOCAL_MANUAL);\n-            else\n-                return InitError(ResolveErrMsg(\"externalip\", strAddr));\n-        }\n-    }\n-\n-    if (mapMultiArgs.count(\"-seednode\")) {\n-        BOOST_FOREACH(const std::string& strDest, mapMultiArgs.at(\"-seednode\"))\n-            connman.AddOneShot(strDest);\n+    for (const std::string& strAddr : gArgs.GetArgs(\"-externalip\")) {\n+        CService addrLocal;\n+        if (Lookup(strAddr.c_str(), addrLocal, GetListenPort(), fNameLookup) && addrLocal.IsValid())\n+            AddLocal(addrLocal, LOCAL_MANUAL);\n+        else\n+            return InitError(ResolveErrMsg(\"externalip\", strAddr));\n     }\n \n #if ENABLE_ZMQ\n@@ -1400,8 +1367,6 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     fReindex = GetBoolArg(\"-reindex\", false);\n     bool fReindexChainState = GetBoolArg(\"-reindex-chainstate\", false);\n \n-    fs::create_directories(GetDataDir() / \"blocks\");\n-\n     // cache size calculations\n     int64_t nTotalCache = (GetArg(\"-dbcache\", nDefaultDbCache) << 20);\n     nTotalCache = std::max(nTotalCache, nMinDbCache << 20); // total cache cannot be less than nMinDbCache\n@@ -1420,7 +1385,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     LogPrintf(\"* Using %.1fMiB for in-memory UTXO set (plus up to %.1fMiB of unused mempool space)\\n\", nCoinCacheUsage * (1.0 / 1024 / 1024), nMempoolSizeMax * (1.0 / 1024 / 1024));\n \n     bool fLoaded = false;\n-    while (!fLoaded) {\n+    while (!fLoaded && !fRequestShutdown) {\n         bool fReset = fReindex;\n         std::string strLoadError;\n \n@@ -1435,18 +1400,22 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                 delete pcoinscatcher;\n                 delete pblocktree;\n \n-                pblocktree = new CBlockTreeDB(nBlockTreeDBCache, false, fReindex);\n-                pcoinsdbview = new CCoinsViewDB(nCoinDBCache, false, fReindex || fReindexChainState);\n-                pcoinscatcher = new CCoinsViewErrorCatcher(pcoinsdbview);\n-                pcoinsTip = new CCoinsViewCache(pcoinscatcher);\n+                pblocktree = new CBlockTreeDB(nBlockTreeDBCache, false, fReset);\n \n-                if (fReindex) {\n+                if (fReset) {\n                     pblocktree->WriteReindexing(true);\n                     //If we're reindexing in prune mode, wipe away unusable block files and all undo data files\n                     if (fPruneMode)\n                         CleanupBlockRevFiles();\n                 }\n \n+                if (fRequestShutdown) break;\n+\n+                // LoadBlockIndex will load fTxIndex from the db, or set it if\n+                // we're reindexing. It will also load fHavePruned if we've\n+                // ever removed a block file from disk.\n+                // Note that it also sets fReindex based on the disk flag!\n+                // From here on out fReindex and fReset mean something different!\n                 if (!LoadBlockIndex(chainparams)) {\n                     strLoadError = _(\"Error loading block database\");\n                     break;\n@@ -1457,12 +1426,6 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                 if (!mapBlockIndex.empty() && mapBlockIndex.count(chainparams.GetConsensus().hashGenesisBlock) == 0)\n                     return InitError(_(\"Incorrect or no genesis block found. Wrong datadir for network?\"));\n \n-                // Initialize the block index (no-op if non-empty database was already loaded)\n-                if (!InitBlockIndex(chainparams)) {\n-                    strLoadError = _(\"Error initializing block database\");\n-                    break;\n-                }\n-\n                 // Check for changed -txindex state\n                 if (fTxIndex != GetBoolArg(\"-txindex\", DEFAULT_TXINDEX)) {\n                     strLoadError = _(\"You need to rebuild the database using -reindex-chainstate to change -txindex\");\n@@ -1476,36 +1439,82 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                     break;\n                 }\n \n-                if (!fReindex && chainActive.Tip() != NULL) {\n+                // At this point blocktree args are consistent with what's on disk.\n+                // If we're not mid-reindex (based on disk + args), add a genesis block on disk\n+                // (otherwise we use the one already on disk).\n+                // This is called again in ThreadImport after the reindex completes.\n+                if (!fReindex && !LoadGenesisBlock(chainparams)) {\n+                    strLoadError = _(\"Error initializing block database\");\n+                    break;\n+                }\n+\n+                // At this point we're either in reindex or we've loaded a useful\n+                // block tree into mapBlockIndex!\n+\n+                pcoinsdbview = new CCoinsViewDB(nCoinDBCache, false, fReset || fReindexChainState);\n+                pcoinscatcher = new CCoinsViewErrorCatcher(pcoinsdbview);\n+\n+                // If necessary, upgrade from older database format.\n+                // This is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate\n+                if (!pcoinsdbview->Upgrade()) {\n+                    strLoadError = _(\"Error upgrading chainstate database\");\n+                    break;\n+                }\n+\n+                // ReplayBlocks is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate\n+                if (!ReplayBlocks(chainparams, pcoinsdbview)) {\n+                    strLoadError = _(\"Unable to replay blocks. You will need to rebuild the database using -reindex-chainstate.\");\n+                    break;\n+                }\n+\n+                // The on-disk coinsdb is now in a good state, create the cache\n+                pcoinsTip = new CCoinsViewCache(pcoinscatcher);\n+\n+                bool is_coinsview_empty = fReset || fReindexChainState || pcoinsTip->GetBestBlock().IsNull();\n+                if (!is_coinsview_empty) {\n+                    // LoadChainTip sets chainActive based on pcoinsTip's best block\n+                    if (!LoadChainTip(chainparams)) {\n+                        strLoadError = _(\"Error initializing block database\");\n+                        break;\n+                    }\n+                    assert(chainActive.Tip() != NULL);\n+                }\n+\n+                if (!fReset) {\n+                    // Note that RewindBlockIndex MUST run even if we're about to -reindex-chainstate.\n+                    // It both disconnects blocks based on chainActive, and drops block data in\n+                    // mapBlockIndex based on lack of available witness data.\n                     uiInterface.InitMessage(_(\"Rewinding blocks...\"));\n                     if (!RewindBlockIndex(chainparams)) {\n                         strLoadError = _(\"Unable to rewind the database to a pre-fork state. You will need to redownload the blockchain\");\n                         break;\n                     }\n                 }\n \n-                uiInterface.InitMessage(_(\"Verifying blocks...\"));\n-                if (fHavePruned && GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS) > MIN_BLOCKS_TO_KEEP) {\n-                    LogPrintf(\"Prune: pruned datadir may not have more than %d blocks; only checking available blocks\",\n-                        MIN_BLOCKS_TO_KEEP);\n-                }\n+                if (!is_coinsview_empty) {\n+                    uiInterface.InitMessage(_(\"Verifying blocks...\"));\n+                    if (fHavePruned && GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS) > MIN_BLOCKS_TO_KEEP) {\n+                        LogPrintf(\"Prune: pruned datadir may not have more than %d blocks; only checking available blocks\",\n+                            MIN_BLOCKS_TO_KEEP);\n+                    }\n \n-                {\n-                    LOCK(cs_main);\n-                    CBlockIndex* tip = chainActive.Tip();\n-                    RPCNotifyBlockChange(true, tip);\n-                    if (tip && tip->nTime > GetAdjustedTime() + 2 * 60 * 60) {\n-                        strLoadError = _(\"The block database contains a block which appears to be from the future. \"\n-                                \"This may be due to your computer's date and time being set incorrectly. \"\n-                                \"Only rebuild the block database if you are sure that your computer's date and time are correct\");\n-                        break;\n+                    {\n+                        LOCK(cs_main);\n+                        CBlockIndex* tip = chainActive.Tip();\n+                        RPCNotifyBlockChange(true, tip);\n+                        if (tip && tip->nTime > GetAdjustedTime() + 2 * 60 * 60) {\n+                            strLoadError = _(\"The block database contains a block which appears to be from the future. \"\n+                                    \"This may be due to your computer's date and time being set incorrectly. \"\n+                                    \"Only rebuild the block database if you are sure that your computer's date and time are correct\");\n+                            break;\n+                        }\n                     }\n-                }\n \n-                if (!CVerifyDB().VerifyDB(chainparams, pcoinsdbview, GetArg(\"-checklevel\", DEFAULT_CHECKLEVEL),\n-                              GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS))) {\n-                    strLoadError = _(\"Corrupted block database detected\");\n-                    break;\n+                    if (!CVerifyDB().VerifyDB(chainparams, pcoinsdbview, GetArg(\"-checklevel\", DEFAULT_CHECKLEVEL),\n+                                  GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS))) {\n+                        strLoadError = _(\"Corrupted block database detected\");\n+                        break;\n+                    }\n                 }\n             } catch (const std::exception& e) {\n                 LogPrintf(\"%s\\n\", e.what());\n@@ -1516,7 +1525,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n             fLoaded = true;\n         } while(false);\n \n-        if (!fLoaded) {\n+        if (!fLoaded && !fRequestShutdown) {\n             // first suggest a reindex\n             if (!fReset) {\n                 bool fRet = uiInterface.ThreadSafeQuestion(\n@@ -1544,13 +1553,15 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n         LogPrintf(\"Shutdown requested. Exiting.\\n\");\n         return false;\n     }\n-    LogPrintf(\" block index %15dms\\n\", GetTimeMillis() - nStart);\n+    if (fLoaded) {\n+        LogPrintf(\" block index %15dms\\n\", GetTimeMillis() - nStart);\n+    }\n \n     fs::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n     CAutoFile est_filein(fsbridge::fopen(est_path, \"rb\"), SER_DISK, CLIENT_VERSION);\n     // Allowed to fail as this file IS missing on first startup.\n     if (!est_filein.IsNull())\n-        mempool.ReadFeeEstimates(est_filein);\n+        ::feeEstimator.Read(est_filein);\n     fFeeEstimatesInitialized = true;\n \n     // ********************************************************* Step 8: load wallet\n@@ -1603,10 +1614,8 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n         uiInterface.NotifyBlockTip.connect(BlockNotifyCallback);\n \n     std::vector<fs::path> vImportFiles;\n-    if (mapMultiArgs.count(\"-loadblock\"))\n-    {\n-        BOOST_FOREACH(const std::string& strFile, mapMultiArgs.at(\"-loadblock\"))\n-            vImportFiles.push_back(strFile);\n+    for (const std::string& strFile : gArgs.GetArgs(\"-loadblock\")) {\n+        vImportFiles.push_back(strFile);\n     }\n \n     threadGroup.create_thread(boost::bind(&ThreadImport, vImportFiles));\n@@ -1633,7 +1642,6 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     // Map ports with UPnP\n     MapPort(GetBoolArg(\"-upnp\", DEFAULT_UPNP));\n \n-    std::string strNodeError;\n     CConnman::Options connOptions;\n     connOptions.nLocalServices = nLocalServices;\n     connOptions.nRelevantServices = nRelevantServices;\n@@ -1649,17 +1657,49 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     connOptions.nMaxOutboundTimeframe = nMaxOutboundTimeframe;\n     connOptions.nMaxOutboundLimit = nMaxOutboundLimit;\n \n-    if (!connman.Start(scheduler, strNodeError, connOptions))\n-        return InitError(strNodeError);\n+    for (const std::string& strBind : gArgs.GetArgs(\"-bind\")) {\n+        CService addrBind;\n+        if (!Lookup(strBind.c_str(), addrBind, GetListenPort(), false)) {\n+            return InitError(ResolveErrMsg(\"bind\", strBind));\n+        }\n+        connOptions.vBinds.push_back(addrBind);\n+    }\n+    for (const std::string& strBind : gArgs.GetArgs(\"-whitebind\")) {\n+        CService addrBind;\n+        if (!Lookup(strBind.c_str(), addrBind, 0, false)) {\n+            return InitError(ResolveErrMsg(\"whitebind\", strBind));\n+        }\n+        if (addrBind.GetPort() == 0) {\n+            return InitError(strprintf(_(\"Need to specify a port with -whitebind: '%s'\"), strBind));\n+        }\n+        connOptions.vWhiteBinds.push_back(addrBind);\n+    }\n+\n+    for (const auto& net : gArgs.GetArgs(\"-whitelist\")) {\n+        CSubNet subnet;\n+        LookupSubNet(net.c_str(), subnet);\n+        if (!subnet.IsValid())\n+            return InitError(strprintf(_(\"Invalid netmask specified in -whitelist: '%s'\"), net));\n+        connOptions.vWhitelistedRange.push_back(subnet);\n+    }\n+\n+    if (gArgs.IsArgSet(\"-seednode\")) {\n+        connOptions.vSeedNodes = gArgs.GetArgs(\"-seednode\");\n+    }\n+\n+    if (!connman.Start(scheduler, connOptions)) {\n+        return false;\n+    }\n \n     // ********************************************************* Step 12: finished\n \n     SetRPCWarmupFinished();\n     uiInterface.InitMessage(_(\"Done loading\"));\n \n #ifdef ENABLE_WALLET\n-    if (pwalletMain)\n-        pwalletMain->postInitProcess(scheduler);\n+    for (CWalletRef pwallet : vpwallets) {\n+        pwallet->postInitProcess(scheduler);\n+    }\n #endif\n \n     return !fRequestShutdown;"
      },
      {
        "sha": "a0a824738cfe723ce68bbf0d1f01e3f508e1f85c",
        "filename": "src/init.h",
        "status": "modified",
        "additions": 11,
        "deletions": 5,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -27,27 +27,33 @@ void InitLogging();\n void InitParameterInteraction();\n \n /** Initialize bitcoin core: Basic context setup.\n- *  @note This can be done before daemonization.\n+ *  @note This can be done before daemonization. Do not call Shutdown() if this function fails.\n  *  @pre Parameters should be parsed and config file should be read.\n  */\n bool AppInitBasicSetup();\n /**\n  * Initialization: parameter interaction.\n- * @note This can be done before daemonization.\n+ * @note This can be done before daemonization. Do not call Shutdown() if this function fails.\n  * @pre Parameters should be parsed and config file should be read, AppInitBasicSetup should have been called.\n  */\n bool AppInitParameterInteraction();\n /**\n  * Initialization sanity checks: ecc init, sanity checks, dir lock.\n- * @note This can be done before daemonization.\n+ * @note This can be done before daemonization. Do not call Shutdown() if this function fails.\n  * @pre Parameters should be parsed and config file should be read, AppInitParameterInteraction should have been called.\n  */\n bool AppInitSanityChecks();\n /**\n- * Bitcoin core main initialization.\n- * @note This should only be done after daemonization.\n+ * Lock bitcoin core data directory.\n+ * @note This should only be done after daemonization. Do not call Shutdown() if this function fails.\n  * @pre Parameters should be parsed and config file should be read, AppInitSanityChecks should have been called.\n  */\n+bool AppInitLockDataDirectory();\n+/**\n+ * Bitcoin core main initialization.\n+ * @note This should only be done after daemonization. Call Shutdown() if this function fails.\n+ * @pre Parameters should be parsed and config file should be read, AppInitLockDataDirectory should have been called.\n+ */\n bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler);\n \n /** The help message mode determines what help message to show */"
      },
      {
        "sha": "5a991fc1d2911cdf27309fe7ccb2aca65fdf1368",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 13,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -131,22 +131,14 @@ void CKey::MakeNewKey(bool fCompressedIn) {\n     fCompressed = fCompressedIn;\n }\n \n-bool CKey::SetPrivKey(const CPrivKey &privkey, bool fCompressedIn) {\n-    if (!ec_privkey_import_der(secp256k1_context_sign, (unsigned char*)begin(), &privkey[0], privkey.size()))\n-        return false;\n-    fCompressed = fCompressedIn;\n-    fValid = true;\n-    return true;\n-}\n-\n CPrivKey CKey::GetPrivKey() const {\n     assert(fValid);\n     CPrivKey privkey;\n     int ret;\n     size_t privkeylen;\n     privkey.resize(279);\n     privkeylen = 279;\n-    ret = ec_privkey_export_der(secp256k1_context_sign, (unsigned char*)&privkey[0], &privkeylen, begin(), fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED);\n+    ret = ec_privkey_export_der(secp256k1_context_sign, (unsigned char*) privkey.data(), &privkeylen, begin(), fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED);\n     assert(ret);\n     privkey.resize(privkeylen);\n     return privkey;\n@@ -175,7 +167,7 @@ bool CKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig, uint32_\n     secp256k1_ecdsa_signature sig;\n     int ret = secp256k1_ecdsa_sign(secp256k1_context_sign, &sig, hash.begin(), begin(), secp256k1_nonce_function_rfc6979, test_case ? extra_entropy : NULL);\n     assert(ret);\n-    secp256k1_ecdsa_signature_serialize_der(secp256k1_context_sign, (unsigned char*)&vchSig[0], &nSigLen, &sig);\n+    secp256k1_ecdsa_signature_serialize_der(secp256k1_context_sign, (unsigned char*)vchSig.data(), &nSigLen, &sig);\n     vchSig.resize(nSigLen);\n     return true;\n }\n@@ -210,7 +202,7 @@ bool CKey::SignCompact(const uint256 &hash, std::vector<unsigned char>& vchSig)\n }\n \n bool CKey::Load(CPrivKey &privkey, CPubKey &vchPubKey, bool fSkipCheck=false) {\n-    if (!ec_privkey_import_der(secp256k1_context_sign, (unsigned char*)begin(), &privkey[0], privkey.size()))\n+    if (!ec_privkey_import_der(secp256k1_context_sign, (unsigned char*)begin(), privkey.data(), privkey.size()))\n         return false;\n     fCompressed = vchPubKey.IsCompressed();\n     fValid = true;\n@@ -253,8 +245,8 @@ void CExtKey::SetMaster(const unsigned char *seed, unsigned int nSeedLen) {\n     static const unsigned char hashkey[] = {'B','i','t','c','o','i','n',' ','s','e','e','d'};\n     std::vector<unsigned char, secure_allocator<unsigned char>> vout(64);\n     CHMAC_SHA512(hashkey, sizeof(hashkey)).Write(seed, nSeedLen).Finalize(vout.data());\n-    key.Set(&vout[0], &vout[32], true);\n-    memcpy(chaincode.begin(), &vout[32], 32);\n+    key.Set(vout.data(), vout.data() + 32, true);\n+    memcpy(chaincode.begin(), vout.data() + 32, 32);\n     nDepth = 0;\n     nChild = 0;\n     memset(vchFingerprint, 0, sizeof(vchFingerprint));"
      },
      {
        "sha": "2c6f151727b6447fc1ac7c2816310d434195ab7f",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -94,9 +94,6 @@ class CKey\n     //! Check whether the public key corresponding to this private key is (to be) compressed.\n     bool IsCompressed() const { return fCompressed; }\n \n-    //! Initialize from a CPrivKey (serialized OpenSSL private key data).\n-    bool SetPrivKey(const CPrivKey& vchPrivKey, bool fCompressed);\n-\n     //! Generate a new private key using a cryptographic PRNG.\n     void MakeNewKey(bool fCompressed);\n "
      },
      {
        "sha": "8454175ca81a0e5538a8b1ce054e46b65b3d67ea",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -9,8 +9,6 @@\n #include \"pubkey.h\"\n #include \"util.h\"\n \n-#include <boost/foreach.hpp>\n-\n bool CKeyStore::AddKey(const CKey &key) {\n     return AddKeyPubKey(key, key.GetPubKey());\n }"
      },
      {
        "sha": "965ae0c79ad865193afe0fb7041ca2c0ffe5f751",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 12,
        "deletions": 13,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -13,7 +13,6 @@\n #include \"sync.h\"\n \n #include <boost/signals2/signal.hpp>\n-#include <boost/variant.hpp>\n \n /** A virtual base class for key stores */\n class CKeyStore\n@@ -61,9 +60,9 @@ class CBasicKeyStore : public CKeyStore\n     WatchOnlySet setWatchOnly;\n \n public:\n-    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey);\n-    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const;\n-    bool HaveKey(const CKeyID &address) const\n+    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey) override;\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override;\n+    bool HaveKey(const CKeyID &address) const override\n     {\n         bool result;\n         {\n@@ -72,7 +71,7 @@ class CBasicKeyStore : public CKeyStore\n         }\n         return result;\n     }\n-    void GetKeys(std::set<CKeyID> &setAddress) const\n+    void GetKeys(std::set<CKeyID> &setAddress) const override\n     {\n         setAddress.clear();\n         {\n@@ -85,7 +84,7 @@ class CBasicKeyStore : public CKeyStore\n             }\n         }\n     }\n-    bool GetKey(const CKeyID &address, CKey &keyOut) const\n+    bool GetKey(const CKeyID &address, CKey &keyOut) const override\n     {\n         {\n             LOCK(cs_KeyStore);\n@@ -98,14 +97,14 @@ class CBasicKeyStore : public CKeyStore\n         }\n         return false;\n     }\n-    virtual bool AddCScript(const CScript& redeemScript);\n-    virtual bool HaveCScript(const CScriptID &hash) const;\n-    virtual bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const;\n+    virtual bool AddCScript(const CScript& redeemScript) override;\n+    virtual bool HaveCScript(const CScriptID &hash) const override;\n+    virtual bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const override;\n \n-    virtual bool AddWatchOnly(const CScript &dest);\n-    virtual bool RemoveWatchOnly(const CScript &dest);\n-    virtual bool HaveWatchOnly(const CScript &dest) const;\n-    virtual bool HaveWatchOnly() const;\n+    virtual bool AddWatchOnly(const CScript &dest) override;\n+    virtual bool RemoveWatchOnly(const CScript &dest) override;\n+    virtual bool HaveWatchOnly(const CScript &dest) const override;\n+    virtual bool HaveWatchOnly() const override;\n };\n \n typedef std::vector<unsigned char, secure_allocator<unsigned char> > CKeyingMaterial;"
      },
      {
        "sha": "f7cc7d736c4f20d6cab6e760d43b76e880b80e95",
        "filename": "src/leveldb/Makefile",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/Makefile?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -44,6 +44,7 @@ TESTS = \\\n \tutil/cache_test \\\n \tutil/coding_test \\\n \tutil/crc32c_test \\\n+\tutil/env_posix_test \\\n \tutil/env_test \\\n \tutil/hash_test\n \n@@ -121,7 +122,7 @@ SHARED_MEMENVLIB = $(SHARED_OUTDIR)/libmemenv.a\n else\n # Update db.h if you change these.\n SHARED_VERSION_MAJOR = 1\n-SHARED_VERSION_MINOR = 19\n+SHARED_VERSION_MINOR = 20\n SHARED_LIB1 = libleveldb.$(PLATFORM_SHARED_EXT)\n SHARED_LIB2 = $(SHARED_LIB1).$(SHARED_VERSION_MAJOR)\n SHARED_LIB3 = $(SHARED_LIB1).$(SHARED_VERSION_MAJOR).$(SHARED_VERSION_MINOR)\n@@ -337,6 +338,9 @@ $(STATIC_OUTDIR)/db_test:db/db_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS)\n $(STATIC_OUTDIR)/dbformat_test:db/dbformat_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS)\n \t$(CXX) $(LDFLAGS) $(CXXFLAGS) db/dbformat_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n+$(STATIC_OUTDIR)/env_posix_test:util/env_posix_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) $(LDFLAGS) $(CXXFLAGS) util/env_posix_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n+\n $(STATIC_OUTDIR)/env_test:util/env_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS)\n \t$(CXX) $(LDFLAGS) $(CXXFLAGS) util/env_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n@@ -412,3 +416,9 @@ $(SHARED_OUTDIR)/%.o: %.cc\n \n $(SHARED_OUTDIR)/%.o: %.c\n \t$(CC) $(CFLAGS) $(PLATFORM_SHARED_CFLAGS) -c $< -o $@\n+\n+$(STATIC_OUTDIR)/port/port_posix_sse.o: port/port_posix_sse.cc\n+\t$(CXX) $(CXXFLAGS) $(PLATFORM_SSEFLAGS) -c $< -o $@\n+\n+$(SHARED_OUTDIR)/port/port_posix_sse.o: port/port_posix_sse.cc\n+\t$(CXX) $(CXXFLAGS) $(PLATFORM_SHARED_CFLAGS) $(PLATFORM_SSEFLAGS) -c $< -o $@"
      },
      {
        "sha": "a010c508585e89ad3aacf50dd3630feb05ac24db",
        "filename": "src/leveldb/README.md",
        "status": "modified",
        "additions": 13,
        "deletions": 12,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/README.md?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -16,7 +16,7 @@ Authors: Sanjay Ghemawat (sanjay@google.com) and Jeff Dean (jeff@google.com)\n   * External activity (file system operations etc.) is relayed through a virtual interface so users can customize the operating system interactions.\n \n # Documentation\n-  [LevelDB library documentation](https://rawgit.com/google/leveldb/master/doc/index.html) is online and bundled with the source code.\n+  [LevelDB library documentation](https://github.com/google/leveldb/blob/master/doc/index.md) is online and bundled with the source code.\n \n \n # Limitations\n@@ -113,29 +113,30 @@ by the one or two disk seeks needed to fetch the data from disk.\n Write performance will be mostly unaffected by whether or not the\n working set fits in memory.\n \n-    readrandom   :      16.677 micros/op;  (approximately 60,000 reads per second)\n-    readseq      :       0.476 micros/op;  232.3 MB/s\n-    readreverse  :       0.724 micros/op;  152.9 MB/s\n+    readrandom  : 16.677 micros/op;  (approximately 60,000 reads per second)\n+    readseq     :  0.476 micros/op;  232.3 MB/s\n+    readreverse :  0.724 micros/op;  152.9 MB/s\n \n LevelDB compacts its underlying storage data in the background to\n improve read performance.  The results listed above were done\n immediately after a lot of random writes.  The results after\n compactions (which are usually triggered automatically) are better.\n \n-    readrandom   :      11.602 micros/op;  (approximately 85,000 reads per second)\n-    readseq      :       0.423 micros/op;  261.8 MB/s\n-    readreverse  :       0.663 micros/op;  166.9 MB/s\n+    readrandom  : 11.602 micros/op;  (approximately 85,000 reads per second)\n+    readseq     :  0.423 micros/op;  261.8 MB/s\n+    readreverse :  0.663 micros/op;  166.9 MB/s\n \n Some of the high cost of reads comes from repeated decompression of blocks\n read from disk.  If we supply enough cache to the leveldb so it can hold the\n uncompressed blocks in memory, the read performance improves again:\n \n-    readrandom   :       9.775 micros/op;  (approximately 100,000 reads per second before compaction)\n-    readrandom   :       5.215 micros/op;  (approximately 190,000 reads per second after compaction)\n+    readrandom  : 9.775 micros/op;  (approximately 100,000 reads per second before compaction)\n+    readrandom  : 5.215 micros/op;  (approximately 190,000 reads per second after compaction)\n \n ## Repository contents\n \n-See doc/index.html for more explanation. See doc/impl.html for a brief overview of the implementation.\n+See [doc/index.md](doc/index.md) for more explanation. See\n+[doc/impl.md](doc/impl.md) for a brief overview of the implementation.\n \n The public interface is in include/*.h.  Callers should not include or\n rely on the details of any other header files in this package.  Those\n@@ -148,7 +149,7 @@ Guide to header files:\n * **include/options.h**: Control over the behavior of an entire database,\n and also control over the behavior of individual reads and writes.\n \n-* **include/comparator.h**: Abstraction for user-specified comparison function. \n+* **include/comparator.h**: Abstraction for user-specified comparison function.\n If you want just bytewise comparison of keys, you can use the default\n comparator, but clients can write their own comparator implementations if they\n want custom ordering (e.g. to handle different character encodings, etc.)\n@@ -165,7 +166,7 @@ length into some other byte array.\n * **include/status.h**: Status is returned from many of the public interfaces\n and is used to report success and various kinds of errors.\n \n-* **include/env.h**: \n+* **include/env.h**:\n Abstraction of the OS environment.  A posix implementation of this interface is\n in util/env_posix.cc\n "
      },
      {
        "sha": "4a94715900969161b9f29d41e27f0659c648df10",
        "filename": "src/leveldb/build_detect_platform",
        "status": "modified",
        "additions": 29,
        "deletions": 1,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/build_detect_platform",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/build_detect_platform",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/build_detect_platform?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -63,6 +63,7 @@ PLATFORM_SHARED_EXT=\"so\"\n PLATFORM_SHARED_LDFLAGS=\"-shared -Wl,-soname -Wl,\"\n PLATFORM_SHARED_CFLAGS=\"-fPIC\"\n PLATFORM_SHARED_VERSIONED=true\n+PLATFORM_SSEFLAGS=\n \n MEMCMP_FLAG=\n if [ \"$CXX\" = \"g++\" ]; then\n@@ -77,6 +78,7 @@ case \"$TARGET_OS\" in\n         COMMON_FLAGS=\"$MEMCMP_FLAG -lpthread -DOS_LINUX -DCYGWIN\"\n         PLATFORM_LDFLAGS=\"-lpthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     Darwin)\n         PLATFORM=OS_MACOSX\n@@ -85,24 +87,28 @@ case \"$TARGET_OS\" in\n         [ -z \"$INSTALL_PATH\" ] && INSTALL_PATH=`pwd`\n         PLATFORM_SHARED_LDFLAGS=\"-dynamiclib -install_name $INSTALL_PATH/\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     Linux)\n         PLATFORM=OS_LINUX\n         COMMON_FLAGS=\"$MEMCMP_FLAG -pthread -DOS_LINUX\"\n         PLATFORM_LDFLAGS=\"-pthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     SunOS)\n         PLATFORM=OS_SOLARIS\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_SOLARIS\"\n         PLATFORM_LIBS=\"-lpthread -lrt\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     FreeBSD)\n         PLATFORM=OS_FREEBSD\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_FREEBSD\"\n         PLATFORM_LIBS=\"-lpthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     GNU/kFreeBSD)\n         PLATFORM=OS_KFREEBSD\n@@ -115,31 +121,36 @@ case \"$TARGET_OS\" in\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_NETBSD\"\n         PLATFORM_LIBS=\"-lpthread -lgcc_s\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     OpenBSD)\n         PLATFORM=OS_OPENBSD\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_OPENBSD\"\n         PLATFORM_LDFLAGS=\"-pthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     DragonFly)\n         PLATFORM=OS_DRAGONFLYBSD\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_DRAGONFLYBSD\"\n         PLATFORM_LIBS=\"-lpthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     OS_ANDROID_CROSSCOMPILE)\n         PLATFORM=OS_ANDROID\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_ANDROID -DLEVELDB_PLATFORM_POSIX\"\n         PLATFORM_LDFLAGS=\"\"  # All pthread features are in the Android C library\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         CROSS_COMPILE=true\n         ;;\n     HP-UX)\n         PLATFORM=OS_HPUX\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_HPUX\"\n         PLATFORM_LDFLAGS=\"-pthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         # man ld: +h internal_name\n         PLATFORM_SHARED_LDFLAGS=\"-shared -Wl,+h -Wl,\"\n         ;;\n@@ -148,6 +159,7 @@ case \"$TARGET_OS\" in\n         COMMON_FLAGS=\"$MEMCMP_FLAG -DOS_MACOSX\"\n         [ -z \"$INSTALL_PATH\" ] && INSTALL_PATH=`pwd`\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         PLATFORM_SHARED_EXT=\n         PLATFORM_SHARED_LDFLAGS=\n         PLATFORM_SHARED_CFLAGS=\n@@ -182,7 +194,7 @@ set +f # re-enable globbing\n \n # The sources consist of the portable files, plus the platform-specific port\n # file.\n-echo \"SOURCES=$PORTABLE_FILES $PORT_FILE\" >> $OUTPUT\n+echo \"SOURCES=$PORTABLE_FILES $PORT_FILE $PORT_SSE_FILE\" >> $OUTPUT\n echo \"MEMENV_SOURCES=helpers/memenv/memenv.cc\" >> $OUTPUT\n \n if [ \"$CROSS_COMPILE\" = \"true\" ]; then\n@@ -213,6 +225,21 @@ EOF\n     fi\n \n     rm -f $CXXOUTPUT 2>/dev/null\n+\n+    # Test if gcc SSE 4.2 is supported\n+    $CXX $CXXFLAGS -x c++ - -o $CXXOUTPUT -msse4.2 2>/dev/null  <<EOF\n+      int main() {}\n+EOF\n+    if [ \"$?\" = 0 ]; then\n+        PLATFORM_SSEFLAGS=\"-msse4.2\"\n+    fi\n+\n+    rm -f $CXXOUTPUT 2>/dev/null\n+fi\n+\n+# Use the SSE 4.2 CRC32C intrinsics iff runtime checks indicate compiler supports them.\n+if [ -n \"$PLATFORM_SSEFLAGS\" ]; then\n+    PLATFORM_SSEFLAGS=\"$PLATFORM_SSEFLAGS -DLEVELDB_PLATFORM_POSIX_SSE\"\n fi\n \n PLATFORM_CCFLAGS=\"$PLATFORM_CCFLAGS $COMMON_FLAGS\"\n@@ -225,6 +252,7 @@ echo \"PLATFORM_LDFLAGS=$PLATFORM_LDFLAGS\" >> $OUTPUT\n echo \"PLATFORM_LIBS=$PLATFORM_LIBS\" >> $OUTPUT\n echo \"PLATFORM_CCFLAGS=$PLATFORM_CCFLAGS\" >> $OUTPUT\n echo \"PLATFORM_CXXFLAGS=$PLATFORM_CXXFLAGS\" >> $OUTPUT\n+echo \"PLATFORM_SSEFLAGS=$PLATFORM_SSEFLAGS\" >> $OUTPUT\n echo \"PLATFORM_SHARED_CFLAGS=$PLATFORM_SHARED_CFLAGS\" >> $OUTPUT\n echo \"PLATFORM_SHARED_EXT=$PLATFORM_SHARED_EXT\" >> $OUTPUT\n echo \"PLATFORM_SHARED_LDFLAGS=$PLATFORM_SHARED_LDFLAGS\" >> $OUTPUT"
      },
      {
        "sha": "3ad19a512b56c92ba4d4ba26d1a8638d12611d57",
        "filename": "src/leveldb/db/db_bench.cc",
        "status": "modified",
        "additions": 29,
        "deletions": 9,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/db/db_bench.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/db/db_bench.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/db_bench.cc?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -84,6 +84,14 @@ static bool FLAGS_histogram = false;\n // (initialized to default value by \"main\")\n static int FLAGS_write_buffer_size = 0;\n \n+// Number of bytes written to each file.\n+// (initialized to default value by \"main\")\n+static int FLAGS_max_file_size = 0;\n+\n+// Approximate size of user data packed per block (before compression.\n+// (initialized to default value by \"main\")\n+static int FLAGS_block_size = 0;\n+\n // Number of bytes to use as a cache of uncompressed data.\n // Negative means use default settings.\n static int FLAGS_cache_size = -1;\n@@ -109,6 +117,7 @@ static const char* FLAGS_db = NULL;\n namespace leveldb {\n \n namespace {\n+leveldb::Env* g_env = NULL;\n \n // Helper for quickly generating random data.\n class RandomGenerator {\n@@ -186,7 +195,7 @@ class Stats {\n     done_ = 0;\n     bytes_ = 0;\n     seconds_ = 0;\n-    start_ = Env::Default()->NowMicros();\n+    start_ = g_env->NowMicros();\n     finish_ = start_;\n     message_.clear();\n   }\n@@ -204,7 +213,7 @@ class Stats {\n   }\n \n   void Stop() {\n-    finish_ = Env::Default()->NowMicros();\n+    finish_ = g_env->NowMicros();\n     seconds_ = (finish_ - start_) * 1e-6;\n   }\n \n@@ -214,7 +223,7 @@ class Stats {\n \n   void FinishedSingleOp() {\n     if (FLAGS_histogram) {\n-      double now = Env::Default()->NowMicros();\n+      double now = g_env->NowMicros();\n       double micros = now - last_op_finish_;\n       hist_.Add(micros);\n       if (micros > 20000) {\n@@ -404,10 +413,10 @@ class Benchmark {\n     reads_(FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads),\n     heap_counter_(0) {\n     std::vector<std::string> files;\n-    Env::Default()->GetChildren(FLAGS_db, &files);\n+    g_env->GetChildren(FLAGS_db, &files);\n     for (size_t i = 0; i < files.size(); i++) {\n       if (Slice(files[i]).starts_with(\"heap-\")) {\n-        Env::Default()->DeleteFile(std::string(FLAGS_db) + \"/\" + files[i]);\n+        g_env->DeleteFile(std::string(FLAGS_db) + \"/\" + files[i]);\n       }\n     }\n     if (!FLAGS_use_existing_db) {\n@@ -589,7 +598,7 @@ class Benchmark {\n       arg[i].shared = &shared;\n       arg[i].thread = new ThreadState(i);\n       arg[i].thread->shared = &shared;\n-      Env::Default()->StartThread(ThreadBody, &arg[i]);\n+      g_env->StartThread(ThreadBody, &arg[i]);\n     }\n \n     shared.mu.Lock();\n@@ -700,9 +709,12 @@ class Benchmark {\n   void Open() {\n     assert(db_ == NULL);\n     Options options;\n+    options.env = g_env;\n     options.create_if_missing = !FLAGS_use_existing_db;\n     options.block_cache = cache_;\n     options.write_buffer_size = FLAGS_write_buffer_size;\n+    options.max_file_size = FLAGS_max_file_size;\n+    options.block_size = FLAGS_block_size;\n     options.max_open_files = FLAGS_open_files;\n     options.filter_policy = filter_policy_;\n     options.reuse_logs = FLAGS_reuse_logs;\n@@ -925,7 +937,7 @@ class Benchmark {\n     char fname[100];\n     snprintf(fname, sizeof(fname), \"%s/heap-%04d\", FLAGS_db, ++heap_counter_);\n     WritableFile* file;\n-    Status s = Env::Default()->NewWritableFile(fname, &file);\n+    Status s = g_env->NewWritableFile(fname, &file);\n     if (!s.ok()) {\n       fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n       return;\n@@ -934,7 +946,7 @@ class Benchmark {\n     delete file;\n     if (!ok) {\n       fprintf(stderr, \"heap profiling not supported\\n\");\n-      Env::Default()->DeleteFile(fname);\n+      g_env->DeleteFile(fname);\n     }\n   }\n };\n@@ -943,6 +955,8 @@ class Benchmark {\n \n int main(int argc, char** argv) {\n   FLAGS_write_buffer_size = leveldb::Options().write_buffer_size;\n+  FLAGS_max_file_size = leveldb::Options().max_file_size;\n+  FLAGS_block_size = leveldb::Options().block_size;\n   FLAGS_open_files = leveldb::Options().max_open_files;\n   std::string default_db_path;\n \n@@ -973,6 +987,10 @@ int main(int argc, char** argv) {\n       FLAGS_value_size = n;\n     } else if (sscanf(argv[i], \"--write_buffer_size=%d%c\", &n, &junk) == 1) {\n       FLAGS_write_buffer_size = n;\n+    } else if (sscanf(argv[i], \"--max_file_size=%d%c\", &n, &junk) == 1) {\n+      FLAGS_max_file_size = n;\n+    } else if (sscanf(argv[i], \"--block_size=%d%c\", &n, &junk) == 1) {\n+      FLAGS_block_size = n;\n     } else if (sscanf(argv[i], \"--cache_size=%d%c\", &n, &junk) == 1) {\n       FLAGS_cache_size = n;\n     } else if (sscanf(argv[i], \"--bloom_bits=%d%c\", &n, &junk) == 1) {\n@@ -987,9 +1005,11 @@ int main(int argc, char** argv) {\n     }\n   }\n \n+  leveldb::g_env = leveldb::Env::Default();\n+\n   // Choose a location for the test database if none given with --db=<path>\n   if (FLAGS_db == NULL) {\n-      leveldb::Env::Default()->GetTestDirectory(&default_db_path);\n+      leveldb::g_env->GetTestDirectory(&default_db_path);\n       default_db_path += \"/dbbench\";\n       FLAGS_db = default_db_path.c_str();\n   }"
      },
      {
        "sha": "f43ad7679436b312959e5e0487c9313694d83ecc",
        "filename": "src/leveldb/db/db_impl.cc",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/db/db_impl.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/db/db_impl.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/db_impl.cc?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -96,6 +96,7 @@ Options SanitizeOptions(const std::string& dbname,\n   result.filter_policy = (src.filter_policy != NULL) ? ipolicy : NULL;\n   ClipToRange(&result.max_open_files,    64 + kNumNonTableCacheFiles, 50000);\n   ClipToRange(&result.write_buffer_size, 64<<10,                      1<<30);\n+  ClipToRange(&result.max_file_size,     1<<20,                       1<<30);\n   ClipToRange(&result.block_size,        1<<10,                       4<<20);\n   if (result.info_log == NULL) {\n     // Open a log file in the same directory as the db"
      },
      {
        "sha": "356e69fca231def5f74b95eaff53f12f42169317",
        "filename": "src/leveldb/db/log_format.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/db/log_format.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/db/log_format.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/log_format.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -3,7 +3,7 @@\n // found in the LICENSE file. See the AUTHORS file for names of contributors.\n //\n // Log format information shared by reader and writer.\n-// See ../doc/log_format.txt for more detail.\n+// See ../doc/log_format.md for more detail.\n \n #ifndef STORAGE_LEVELDB_DB_LOG_FORMAT_H_\n #define STORAGE_LEVELDB_DB_LOG_FORMAT_H_"
      },
      {
        "sha": "287afdbdcb90c7f8ba1dacd3a842660b22bdab0b",
        "filename": "src/leveldb/db/memtable.cc",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/db/memtable.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/db/memtable.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/memtable.cc?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -101,7 +101,7 @@ void MemTable::Add(SequenceNumber s, ValueType type,\n   p += 8;\n   p = EncodeVarint32(p, val_size);\n   memcpy(p, value.data(), val_size);\n-  assert((p + val_size) - buf == encoded_len);\n+  assert(p + val_size == buf + encoded_len);\n   table_.Insert(buf);\n }\n "
      },
      {
        "sha": "2cb6d80ed3cf9a14f48dcbd80fc430efaaca3cc0",
        "filename": "src/leveldb/db/version_set.cc",
        "status": "modified",
        "additions": 35,
        "deletions": 22,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/db/version_set.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/db/version_set.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/version_set.cc?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -20,30 +20,39 @@\n \n namespace leveldb {\n \n-static const int kTargetFileSize = 2 * 1048576;\n+static size_t TargetFileSize(const Options* options) {\n+  return options->max_file_size;\n+}\n \n // Maximum bytes of overlaps in grandparent (i.e., level+2) before we\n // stop building a single file in a level->level+1 compaction.\n-static const int64_t kMaxGrandParentOverlapBytes = 10 * kTargetFileSize;\n+static int64_t MaxGrandParentOverlapBytes(const Options* options) {\n+  return 10 * TargetFileSize(options);\n+}\n \n // Maximum number of bytes in all compacted files.  We avoid expanding\n // the lower level file set of a compaction if it would make the\n // total compaction cover more than this many bytes.\n-static const int64_t kExpandedCompactionByteSizeLimit = 25 * kTargetFileSize;\n+static int64_t ExpandedCompactionByteSizeLimit(const Options* options) {\n+  return 25 * TargetFileSize(options);\n+}\n \n-static double MaxBytesForLevel(int level) {\n+static double MaxBytesForLevel(const Options* options, int level) {\n   // Note: the result for level zero is not really used since we set\n   // the level-0 compaction threshold based on number of files.\n-  double result = 10 * 1048576.0;  // Result for both level-0 and level-1\n+\n+  // Result for both level-0 and level-1\n+  double result = 10. * 1048576.0;\n   while (level > 1) {\n     result *= 10;\n     level--;\n   }\n   return result;\n }\n \n-static uint64_t MaxFileSizeForLevel(int level) {\n-  return kTargetFileSize;  // We could vary per level to reduce number of files?\n+static uint64_t MaxFileSizeForLevel(const Options* options, int level) {\n+  // We could vary per level to reduce number of files?\n+  return TargetFileSize(options);\n }\n \n static int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {\n@@ -508,7 +517,7 @@ int Version::PickLevelForMemTableOutput(\n         // Check that file does not overlap too many grandparent bytes.\n         GetOverlappingInputs(level + 2, &start, &limit, &overlaps);\n         const int64_t sum = TotalFileSize(overlaps);\n-        if (sum > kMaxGrandParentOverlapBytes) {\n+        if (sum > MaxGrandParentOverlapBytes(vset_->options_)) {\n           break;\n         }\n       }\n@@ -1027,7 +1036,7 @@ bool VersionSet::ReuseManifest(const std::string& dscname,\n       manifest_type != kDescriptorFile ||\n       !env_->GetFileSize(dscname, &manifest_size).ok() ||\n       // Make new compacted MANIFEST if old one is too big\n-      manifest_size >= kTargetFileSize) {\n+      manifest_size >= TargetFileSize(options_)) {\n     return false;\n   }\n \n@@ -1076,7 +1085,8 @@ void VersionSet::Finalize(Version* v) {\n     } else {\n       // Compute the ratio of current size to size limit.\n       const uint64_t level_bytes = TotalFileSize(v->files_[level]);\n-      score = static_cast<double>(level_bytes) / MaxBytesForLevel(level);\n+      score =\n+          static_cast<double>(level_bytes) / MaxBytesForLevel(options_, level);\n     }\n \n     if (score > best_score) {\n@@ -1290,7 +1300,7 @@ Compaction* VersionSet::PickCompaction() {\n     level = current_->compaction_level_;\n     assert(level >= 0);\n     assert(level+1 < config::kNumLevels);\n-    c = new Compaction(level);\n+    c = new Compaction(options_, level);\n \n     // Pick the first file that comes after compact_pointer_[level]\n     for (size_t i = 0; i < current_->files_[level].size(); i++) {\n@@ -1307,7 +1317,7 @@ Compaction* VersionSet::PickCompaction() {\n     }\n   } else if (seek_compaction) {\n     level = current_->file_to_compact_level_;\n-    c = new Compaction(level);\n+    c = new Compaction(options_, level);\n     c->inputs_[0].push_back(current_->file_to_compact_);\n   } else {\n     return NULL;\n@@ -1352,7 +1362,8 @@ void VersionSet::SetupOtherInputs(Compaction* c) {\n     const int64_t inputs1_size = TotalFileSize(c->inputs_[1]);\n     const int64_t expanded0_size = TotalFileSize(expanded0);\n     if (expanded0.size() > c->inputs_[0].size() &&\n-        inputs1_size + expanded0_size < kExpandedCompactionByteSizeLimit) {\n+        inputs1_size + expanded0_size <\n+            ExpandedCompactionByteSizeLimit(options_)) {\n       InternalKey new_start, new_limit;\n       GetRange(expanded0, &new_start, &new_limit);\n       std::vector<FileMetaData*> expanded1;\n@@ -1414,7 +1425,7 @@ Compaction* VersionSet::CompactRange(\n   // and we must not pick one file and drop another older file if the\n   // two files overlap.\n   if (level > 0) {\n-    const uint64_t limit = MaxFileSizeForLevel(level);\n+    const uint64_t limit = MaxFileSizeForLevel(options_, level);\n     uint64_t total = 0;\n     for (size_t i = 0; i < inputs.size(); i++) {\n       uint64_t s = inputs[i]->file_size;\n@@ -1426,17 +1437,17 @@ Compaction* VersionSet::CompactRange(\n     }\n   }\n \n-  Compaction* c = new Compaction(level);\n+  Compaction* c = new Compaction(options_, level);\n   c->input_version_ = current_;\n   c->input_version_->Ref();\n   c->inputs_[0] = inputs;\n   SetupOtherInputs(c);\n   return c;\n }\n \n-Compaction::Compaction(int level)\n+Compaction::Compaction(const Options* options, int level)\n     : level_(level),\n-      max_output_file_size_(MaxFileSizeForLevel(level)),\n+      max_output_file_size_(MaxFileSizeForLevel(options, level)),\n       input_version_(NULL),\n       grandparent_index_(0),\n       seen_key_(false),\n@@ -1453,12 +1464,13 @@ Compaction::~Compaction() {\n }\n \n bool Compaction::IsTrivialMove() const {\n+  const VersionSet* vset = input_version_->vset_;\n   // Avoid a move if there is lots of overlapping grandparent data.\n   // Otherwise, the move could create a parent file that will require\n   // a very expensive merge later on.\n-  return (num_input_files(0) == 1 &&\n-          num_input_files(1) == 0 &&\n-          TotalFileSize(grandparents_) <= kMaxGrandParentOverlapBytes);\n+  return (num_input_files(0) == 1 && num_input_files(1) == 0 &&\n+          TotalFileSize(grandparents_) <=\n+              MaxGrandParentOverlapBytes(vset->options_));\n }\n \n void Compaction::AddInputDeletions(VersionEdit* edit) {\n@@ -1491,8 +1503,9 @@ bool Compaction::IsBaseLevelForKey(const Slice& user_key) {\n }\n \n bool Compaction::ShouldStopBefore(const Slice& internal_key) {\n+  const VersionSet* vset = input_version_->vset_;\n   // Scan to find earliest grandparent file that contains key.\n-  const InternalKeyComparator* icmp = &input_version_->vset_->icmp_;\n+  const InternalKeyComparator* icmp = &vset->icmp_;\n   while (grandparent_index_ < grandparents_.size() &&\n       icmp->Compare(internal_key,\n                     grandparents_[grandparent_index_]->largest.Encode()) > 0) {\n@@ -1503,7 +1516,7 @@ bool Compaction::ShouldStopBefore(const Slice& internal_key) {\n   }\n   seen_key_ = true;\n \n-  if (overlapped_bytes_ > kMaxGrandParentOverlapBytes) {\n+  if (overlapped_bytes_ > MaxGrandParentOverlapBytes(vset->options_)) {\n     // Too much overlap for current output; start new output\n     overlapped_bytes_ = 0;\n     return true;"
      },
      {
        "sha": "7935a965a7c9fdd62533a8c13c9b6033675066df",
        "filename": "src/leveldb/db/version_set.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/db/version_set.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/db/version_set.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/version_set.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -366,7 +366,7 @@ class Compaction {\n   friend class Version;\n   friend class VersionSet;\n \n-  explicit Compaction(int level);\n+  Compaction(const Options* options, int level);\n \n   int level_;\n   uint64_t max_output_file_size_;\n@@ -376,7 +376,7 @@ class Compaction {\n   // Each compaction reads inputs from \"level_\" and \"level_+1\"\n   std::vector<FileMetaData*> inputs_[2];      // The two sets of inputs\n \n-  // State used to check for number of of overlapping grandparent files\n+  // State used to check for number of overlapping grandparent files\n   // (parent == level_ + 1, grandparent == level_ + 2)\n   std::vector<FileMetaData*> grandparents_;\n   size_t grandparent_index_;  // Index in grandparent_starts_"
      },
      {
        "sha": "700c564e433827c311cd8a26896ceaa7c8260818",
        "filename": "src/leveldb/doc/doc.css",
        "status": "removed",
        "additions": 0,
        "deletions": 89,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c91ca0ace9bd62eea8158b92cfc53d6d219e37b7/src/leveldb/doc/doc.css",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c91ca0ace9bd62eea8158b92cfc53d6d219e37b7/src/leveldb/doc/doc.css",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/doc.css?ref=c91ca0ace9bd62eea8158b92cfc53d6d219e37b7",
        "patch": "@@ -1,89 +0,0 @@\n-body {\n-  margin-left: 0.5in;\n-  margin-right: 0.5in;\n-  background: white;\n-  color: black;\n-}\n-\n-h1 {\n-  margin-left: -0.2in;\n-  font-size: 14pt;\n-}\n-h2 {\n-  margin-left: -0in;\n-  font-size: 12pt;\n-}\n-h3 {\n-  margin-left: -0in;\n-}\n-h4 {\n-  margin-left: -0in;\n-}\n-hr {\n-  margin-left: -0in;\n-}\n-\n-/* Definition lists: definition term bold */\n-dt {\n-  font-weight: bold;\n-}\n-\n-address {\n-  text-align: center;\n-}\n-code,samp,var {\n-  color: blue;\n-}\n-kbd {\n-  color: #600000;\n-}\n-div.note p {\n-  float: right;\n-  width: 3in;\n-  margin-right: 0%;\n-  padding: 1px;\n-  border: 2px solid #6060a0;\n-  background-color: #fffff0;\n-}\n-\n-ul {\n-  margin-top: -0em;\n-  margin-bottom: -0em;\n-}\n-\n-ol {\n-  margin-top: -0em;\n-  margin-bottom: -0em;\n-}\n-\n-UL.nobullets {\n-  list-style-type: none;\n-  list-style-image: none;\n-  margin-left: -1em;\n-}\n-\n-p {\n-  margin: 1em 0 1em 0;\n-  padding: 0 0 0 0;\n-}\n-\n-pre {\n-  line-height: 1.3em;\n-  padding: 0.4em 0 0.8em 0;\n-  margin:  0 0 0 0;\n-  border:  0 0 0 0;\n-  color: blue;\n-}\n-\n-.datatable {\n-  margin-left: auto;\n-  margin-right: auto;\n-  margin-top: 2em;\n-  margin-bottom: 2em;\n-  border: 1px solid;\n-}\n-\n-.datatable td,th {\n-  padding: 0 0.5em 0 0.5em;\n-  text-align: right;\n-}"
      },
      {
        "sha": "6a468be0955d921a3e7bad2d55a71989209d06ae",
        "filename": "src/leveldb/doc/impl.html",
        "status": "removed",
        "additions": 0,
        "deletions": 213,
        "changes": 213,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c91ca0ace9bd62eea8158b92cfc53d6d219e37b7/src/leveldb/doc/impl.html",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c91ca0ace9bd62eea8158b92cfc53d6d219e37b7/src/leveldb/doc/impl.html",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/impl.html?ref=c91ca0ace9bd62eea8158b92cfc53d6d219e37b7",
        "patch": "@@ -1,213 +0,0 @@\n-<!DOCTYPE html>\n-<html>\n-<head>\n-<link rel=\"stylesheet\" type=\"text/css\" href=\"doc.css\" />\n-<title>Leveldb file layout and compactions</title>\n-</head>\n-\n-<body>\n-\n-<h1>Files</h1>\n-\n-The implementation of leveldb is similar in spirit to the\n-representation of a single\n-<a href=\"http://research.google.com/archive/bigtable.html\">\n-Bigtable tablet (section 5.3)</a>.\n-However the organization of the files that make up the representation\n-is somewhat different and is explained below.\n-\n-<p>\n-Each database is represented by a set of files stored in a directory.\n-There are several different types of files as documented below:\n-<p>\n-<h2>Log files</h2>\n-<p>\n-A log file (*.log) stores a sequence of recent updates.  Each update\n-is appended to the current log file.  When the log file reaches a\n-pre-determined size (approximately 4MB by default), it is converted\n-to a sorted table (see below) and a new log file is created for future\n-updates.\n-<p>\n-A copy of the current log file is kept in an in-memory structure (the\n-<code>memtable</code>).  This copy is consulted on every read so that read\n-operations reflect all logged updates.\n-<p>\n-<h2>Sorted tables</h2>\n-<p>\n-A sorted table (*.sst) stores a sequence of entries sorted by key.\n-Each entry is either a value for the key, or a deletion marker for the\n-key.  (Deletion markers are kept around to hide obsolete values\n-present in older sorted tables).\n-<p>\n-The set of sorted tables are organized into a sequence of levels.  The\n-sorted table generated from a log file is placed in a special <code>young</code>\n-level (also called level-0).  When the number of young files exceeds a\n-certain threshold (currently four), all of the young files are merged\n-together with all of the overlapping level-1 files to produce a\n-sequence of new level-1 files (we create a new level-1 file for every\n-2MB of data.)\n-<p>\n-Files in the young level may contain overlapping keys.  However files\n-in other levels have distinct non-overlapping key ranges.  Consider\n-level number L where L >= 1.  When the combined size of files in\n-level-L exceeds (10^L) MB (i.e., 10MB for level-1, 100MB for level-2,\n-...), one file in level-L, and all of the overlapping files in\n-level-(L+1) are merged to form a set of new files for level-(L+1).\n-These merges have the effect of gradually migrating new updates from\n-the young level to the largest level using only bulk reads and writes\n-(i.e., minimizing expensive seeks).\n-\n-<h2>Manifest</h2>\n-<p>\n-A MANIFEST file lists the set of sorted tables that make up each\n-level, the corresponding key ranges, and other important metadata.\n-A new MANIFEST file (with a new number embedded in the file name)\n-is created whenever the database is reopened.  The MANIFEST file is\n-formatted as a log, and changes made to the serving state (as files\n-are added or removed) are appended to this log.\n-<p>\n-<h2>Current</h2>\n-<p>\n-CURRENT is a simple text file that contains the name of the latest\n-MANIFEST file.\n-<p>\n-<h2>Info logs</h2>\n-<p>\n-Informational messages are printed to files named LOG and LOG.old.\n-<p>\n-<h2>Others</h2>\n-<p>\n-Other files used for miscellaneous purposes may also be present\n-(LOCK, *.dbtmp).\n-\n-<h1>Level 0</h1>\n-When the log file grows above a certain size (1MB by default):\n-<ul>\n-<li>Create a brand new memtable and log file and direct future updates here\n-<li>In the background:\n-<ul>\n-<li>Write the contents of the previous memtable to an sstable\n-<li>Discard the memtable\n-<li>Delete the old log file and the old memtable\n-<li>Add the new sstable to the young (level-0) level.\n-</ul>\n-</ul>\n-\n-<h1>Compactions</h1>\n-\n-<p>\n-When the size of level L exceeds its limit, we compact it in a\n-background thread.  The compaction picks a file from level L and all\n-overlapping files from the next level L+1.  Note that if a level-L\n-file overlaps only part of a level-(L+1) file, the entire file at\n-level-(L+1) is used as an input to the compaction and will be\n-discarded after the compaction.  Aside: because level-0 is special\n-(files in it may overlap each other), we treat compactions from\n-level-0 to level-1 specially: a level-0 compaction may pick more than\n-one level-0 file in case some of these files overlap each other.\n-\n-<p>\n-A compaction merges the contents of the picked files to produce a\n-sequence of level-(L+1) files.  We switch to producing a new\n-level-(L+1) file after the current output file has reached the target\n-file size (2MB).  We also switch to a new output file when the key\n-range of the current output file has grown enough to overlap more than\n-ten level-(L+2) files.  This last rule ensures that a later compaction\n-of a level-(L+1) file will not pick up too much data from level-(L+2).\n-\n-<p>\n-The old files are discarded and the new files are added to the serving\n-state.\n-\n-<p>\n-Compactions for a particular level rotate through the key space.  In\n-more detail, for each level L, we remember the ending key of the last\n-compaction at level L.  The next compaction for level L will pick the\n-first file that starts after this key (wrapping around to the\n-beginning of the key space if there is no such file).\n-\n-<p>\n-Compactions drop overwritten values.  They also drop deletion markers\n-if there are no higher numbered levels that contain a file whose range\n-overlaps the current key.\n-\n-<h2>Timing</h2>\n-\n-Level-0 compactions will read up to four 1MB files from level-0, and\n-at worst all the level-1 files (10MB).  I.e., we will read 14MB and\n-write 14MB.\n-\n-<p>\n-Other than the special level-0 compactions, we will pick one 2MB file\n-from level L.  In the worst case, this will overlap ~ 12 files from\n-level L+1 (10 because level-(L+1) is ten times the size of level-L,\n-and another two at the boundaries since the file ranges at level-L\n-will usually not be aligned with the file ranges at level-L+1).  The\n-compaction will therefore read 26MB and write 26MB.  Assuming a disk\n-IO rate of 100MB/s (ballpark range for modern drives), the worst\n-compaction cost will be approximately 0.5 second.\n-\n-<p>\n-If we throttle the background writing to something small, say 10% of\n-the full 100MB/s speed, a compaction may take up to 5 seconds.  If the\n-user is writing at 10MB/s, we might build up lots of level-0 files\n-(~50 to hold the 5*10MB).  This may significantly increase the cost of\n-reads due to the overhead of merging more files together on every\n-read.\n-\n-<p>\n-Solution 1: To reduce this problem, we might want to increase the log\n-switching threshold when the number of level-0 files is large.  Though\n-the downside is that the larger this threshold, the more memory we will\n-need to hold the corresponding memtable.\n-\n-<p>\n-Solution 2: We might want to decrease write rate artificially when the\n-number of level-0 files goes up.\n-\n-<p>\n-Solution 3: We work on reducing the cost of very wide merges.\n-Perhaps most of the level-0 files will have their blocks sitting\n-uncompressed in the cache and we will only need to worry about the\n-O(N) complexity in the merging iterator.\n-\n-<h2>Number of files</h2>\n-\n-Instead of always making 2MB files, we could make larger files for\n-larger levels to reduce the total file count, though at the expense of\n-more bursty compactions.  Alternatively, we could shard the set of\n-files into multiple directories.\n-\n-<p>\n-An experiment on an <code>ext3</code> filesystem on Feb 04, 2011 shows\n-the following timings to do 100K file opens in directories with\n-varying number of files:\n-<table class=\"datatable\">\n-<tr><th>Files in directory</th><th>Microseconds to open a file</th></tr>\n-<tr><td>1000</td><td>9</td>\n-<tr><td>10000</td><td>10</td>\n-<tr><td>100000</td><td>16</td>\n-</table>\n-So maybe even the sharding is not necessary on modern filesystems?\n-\n-<h1>Recovery</h1>\n-\n-<ul>\n-<li> Read CURRENT to find name of the latest committed MANIFEST\n-<li> Read the named MANIFEST file\n-<li> Clean up stale files\n-<li> We could open all sstables here, but it is probably better to be lazy...\n-<li> Convert log chunk to a new level-0 sstable\n-<li> Start directing new writes to a new log file with recovered sequence#\n-</ul>\n-\n-<h1>Garbage collection of files</h1>\n-\n-<code>DeleteObsoleteFiles()</code> is called at the end of every\n-compaction and at the end of recovery.  It finds the names of all\n-files in the database.  It deletes all log files that are not the\n-current log file.  It deletes all table files that are not referenced\n-from some level and are not the output of an active compaction.\n-\n-</body>\n-</html>"
      },
      {
        "sha": "4b13f2a6ba73bd46667eec0e63e6af6e10bad6d4",
        "filename": "src/leveldb/doc/impl.md",
        "status": "added",
        "additions": 170,
        "deletions": 0,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/doc/impl.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/doc/impl.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/impl.md?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -0,0 +1,170 @@\n+## Files\n+\n+The implementation of leveldb is similar in spirit to the representation of a\n+single [Bigtable tablet (section 5.3)](http://research.google.com/archive/bigtable.html).\n+However the organization of the files that make up the representation is\n+somewhat different and is explained below.\n+\n+Each database is represented by a set of files stored in a directory. There are\n+several different types of files as documented below:\n+\n+### Log files\n+\n+A log file (*.log) stores a sequence of recent updates. Each update is appended\n+to the current log file. When the log file reaches a pre-determined size\n+(approximately 4MB by default), it is converted to a sorted table (see below)\n+and a new log file is created for future updates.\n+\n+A copy of the current log file is kept in an in-memory structure (the\n+`memtable`). This copy is consulted on every read so that read operations\n+reflect all logged updates.\n+\n+## Sorted tables\n+\n+A sorted table (*.ldb) stores a sequence of entries sorted by key. Each entry is\n+either a value for the key, or a deletion marker for the key. (Deletion markers\n+are kept around to hide obsolete values present in older sorted tables).\n+\n+The set of sorted tables are organized into a sequence of levels. The sorted\n+table generated from a log file is placed in a special **young** level (also\n+called level-0). When the number of young files exceeds a certain threshold\n+(currently four), all of the young files are merged together with all of the\n+overlapping level-1 files to produce a sequence of new level-1 files (we create\n+a new level-1 file for every 2MB of data.)\n+\n+Files in the young level may contain overlapping keys. However files in other\n+levels have distinct non-overlapping key ranges. Consider level number L where\n+L >= 1. When the combined size of files in level-L exceeds (10^L) MB (i.e., 10MB\n+for level-1, 100MB for level-2, ...), one file in level-L, and all of the\n+overlapping files in level-(L+1) are merged to form a set of new files for\n+level-(L+1). These merges have the effect of gradually migrating new updates\n+from the young level to the largest level using only bulk reads and writes\n+(i.e., minimizing expensive seeks).\n+\n+### Manifest\n+\n+A MANIFEST file lists the set of sorted tables that make up each level, the\n+corresponding key ranges, and other important metadata. A new MANIFEST file\n+(with a new number embedded in the file name) is created whenever the database\n+is reopened. The MANIFEST file is formatted as a log, and changes made to the\n+serving state (as files are added or removed) are appended to this log.\n+\n+### Current\n+\n+CURRENT is a simple text file that contains the name of the latest MANIFEST\n+file.\n+\n+### Info logs\n+\n+Informational messages are printed to files named LOG and LOG.old.\n+\n+### Others\n+\n+Other files used for miscellaneous purposes may also be present (LOCK, *.dbtmp).\n+\n+## Level 0\n+\n+When the log file grows above a certain size (1MB by default):\n+Create a brand new memtable and log file and direct future updates here\n+In the background:\n+Write the contents of the previous memtable to an sstable\n+Discard the memtable\n+Delete the old log file and the old memtable\n+Add the new sstable to the young (level-0) level.\n+\n+## Compactions\n+\n+When the size of level L exceeds its limit, we compact it in a background\n+thread. The compaction picks a file from level L and all overlapping files from\n+the next level L+1. Note that if a level-L file overlaps only part of a\n+level-(L+1) file, the entire file at level-(L+1) is used as an input to the\n+compaction and will be discarded after the compaction.  Aside: because level-0\n+is special (files in it may overlap each other), we treat compactions from\n+level-0 to level-1 specially: a level-0 compaction may pick more than one\n+level-0 file in case some of these files overlap each other.\n+\n+A compaction merges the contents of the picked files to produce a sequence of\n+level-(L+1) files. We switch to producing a new level-(L+1) file after the\n+current output file has reached the target file size (2MB). We also switch to a\n+new output file when the key range of the current output file has grown enough\n+to overlap more than ten level-(L+2) files.  This last rule ensures that a later\n+compaction of a level-(L+1) file will not pick up too much data from\n+level-(L+2).\n+\n+The old files are discarded and the new files are added to the serving state.\n+\n+Compactions for a particular level rotate through the key space. In more detail,\n+for each level L, we remember the ending key of the last compaction at level L.\n+The next compaction for level L will pick the first file that starts after this\n+key (wrapping around to the beginning of the key space if there is no such\n+file).\n+\n+Compactions drop overwritten values. They also drop deletion markers if there\n+are no higher numbered levels that contain a file whose range overlaps the\n+current key.\n+\n+### Timing\n+\n+Level-0 compactions will read up to four 1MB files from level-0, and at worst\n+all the level-1 files (10MB). I.e., we will read 14MB and write 14MB.\n+\n+Other than the special level-0 compactions, we will pick one 2MB file from level\n+L. In the worst case, this will overlap ~ 12 files from level L+1 (10 because\n+level-(L+1) is ten times the size of level-L, and another two at the boundaries\n+since the file ranges at level-L will usually not be aligned with the file\n+ranges at level-L+1). The compaction will therefore read 26MB and write 26MB.\n+Assuming a disk IO rate of 100MB/s (ballpark range for modern drives), the worst\n+compaction cost will be approximately 0.5 second.\n+\n+If we throttle the background writing to something small, say 10% of the full\n+100MB/s speed, a compaction may take up to 5 seconds. If the user is writing at\n+10MB/s, we might build up lots of level-0 files (~50 to hold the 5*10MB). This\n+may significantly increase the cost of reads due to the overhead of merging more\n+files together on every read.\n+\n+Solution 1: To reduce this problem, we might want to increase the log switching\n+threshold when the number of level-0 files is large. Though the downside is that\n+the larger this threshold, the more memory we will need to hold the\n+corresponding memtable.\n+\n+Solution 2: We might want to decrease write rate artificially when the number of\n+level-0 files goes up.\n+\n+Solution 3: We work on reducing the cost of very wide merges. Perhaps most of\n+the level-0 files will have their blocks sitting uncompressed in the cache and\n+we will only need to worry about the O(N) complexity in the merging iterator.\n+\n+### Number of files\n+\n+Instead of always making 2MB files, we could make larger files for larger levels\n+to reduce the total file count, though at the expense of more bursty\n+compactions.  Alternatively, we could shard the set of files into multiple\n+directories.\n+\n+An experiment on an ext3 filesystem on Feb 04, 2011 shows the following timings\n+to do 100K file opens in directories with varying number of files:\n+\n+\n+| Files in directory | Microseconds to open a file |\n+|-------------------:|----------------------------:|\n+|               1000 |                           9 |\n+|              10000 |                          10 |\n+|             100000 |                          16 |\n+\n+So maybe even the sharding is not necessary on modern filesystems?\n+\n+## Recovery\n+\n+* Read CURRENT to find name of the latest committed MANIFEST\n+* Read the named MANIFEST file\n+* Clean up stale files\n+* We could open all sstables here, but it is probably better to be lazy...\n+* Convert log chunk to a new level-0 sstable\n+* Start directing new writes to a new log file with recovered sequence#\n+\n+## Garbage collection of files\n+\n+`DeleteObsoleteFiles()` is called at the end of every compaction and at the end\n+of recovery. It finds the names of all files in the database. It deletes all log\n+files that are not the current log file. It deletes all table files that are not\n+referenced from some level and are not the output of an active compaction."
      },
      {
        "sha": "2155192581e7b79784564f190a47138ae29461f0",
        "filename": "src/leveldb/doc/index.html",
        "status": "removed",
        "additions": 0,
        "deletions": 549,
        "changes": 549,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c91ca0ace9bd62eea8158b92cfc53d6d219e37b7/src/leveldb/doc/index.html",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c91ca0ace9bd62eea8158b92cfc53d6d219e37b7/src/leveldb/doc/index.html",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/index.html?ref=c91ca0ace9bd62eea8158b92cfc53d6d219e37b7",
        "patch": "@@ -1,549 +0,0 @@\n-<!DOCTYPE html>\n-<html>\n-<head>\n-<link rel=\"stylesheet\" type=\"text/css\" href=\"doc.css\" />\n-<title>Leveldb</title>\n-</head>\n-\n-<body>\n-<h1>Leveldb</h1>\n-<address>Jeff Dean, Sanjay Ghemawat</address>\n-<p>\n-The <code>leveldb</code> library provides a persistent key value store.  Keys and\n-values are arbitrary byte arrays.  The keys are ordered within the key\n-value store according to a user-specified comparator function.\n-\n-<p>\n-<h1>Opening A Database</h1>\n-<p>\n-A <code>leveldb</code> database has a name which corresponds to a file system\n-directory.  All of the contents of database are stored in this\n-directory.  The following example shows how to open a database,\n-creating it if necessary:\n-<p>\n-<pre>\n-  #include &lt;cassert&gt;\n-  #include \"leveldb/db.h\"\n-\n-  leveldb::DB* db;\n-  leveldb::Options options;\n-  options.create_if_missing = true;\n-  leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", &amp;db);\n-  assert(status.ok());\n-  ...\n-</pre>\n-If you want to raise an error if the database already exists, add\n-the following line before the <code>leveldb::DB::Open</code> call:\n-<pre>\n-  options.error_if_exists = true;\n-</pre>\n-<h1>Status</h1>\n-<p>\n-You may have noticed the <code>leveldb::Status</code> type above.  Values of this\n-type are returned by most functions in <code>leveldb</code> that may encounter an\n-error.  You can check if such a result is ok, and also print an\n-associated error message:\n-<p>\n-<pre>\n-   leveldb::Status s = ...;\n-   if (!s.ok()) cerr &lt;&lt; s.ToString() &lt;&lt; endl;\n-</pre>\n-<h1>Closing A Database</h1>\n-<p>\n-When you are done with a database, just delete the database object.\n-Example:\n-<p>\n-<pre>\n-  ... open the db as described above ...\n-  ... do something with db ...\n-  delete db;\n-</pre>\n-<h1>Reads And Writes</h1>\n-<p>\n-The database provides <code>Put</code>, <code>Delete</code>, and <code>Get</code> methods to\n-modify/query the database.  For example, the following code\n-moves the value stored under key1 to key2.\n-<pre>\n-  std::string value;\n-  leveldb::Status s = db-&gt;Get(leveldb::ReadOptions(), key1, &amp;value);\n-  if (s.ok()) s = db-&gt;Put(leveldb::WriteOptions(), key2, value);\n-  if (s.ok()) s = db-&gt;Delete(leveldb::WriteOptions(), key1);\n-</pre>\n-\n-<h1>Atomic Updates</h1>\n-<p>\n-Note that if the process dies after the Put of key2 but before the\n-delete of key1, the same value may be left stored under multiple keys.\n-Such problems can be avoided by using the <code>WriteBatch</code> class to\n-atomically apply a set of updates:\n-<p>\n-<pre>\n-  #include \"leveldb/write_batch.h\"\n-  ...\n-  std::string value;\n-  leveldb::Status s = db-&gt;Get(leveldb::ReadOptions(), key1, &amp;value);\n-  if (s.ok()) {\n-    leveldb::WriteBatch batch;\n-    batch.Delete(key1);\n-    batch.Put(key2, value);\n-    s = db-&gt;Write(leveldb::WriteOptions(), &amp;batch);\n-  }\n-</pre>\n-The <code>WriteBatch</code> holds a sequence of edits to be made to the database,\n-and these edits within the batch are applied in order.  Note that we\n-called <code>Delete</code> before <code>Put</code> so that if <code>key1</code> is identical to <code>key2</code>,\n-we do not end up erroneously dropping the value entirely.\n-<p>\n-Apart from its atomicity benefits, <code>WriteBatch</code> may also be used to\n-speed up bulk updates by placing lots of individual mutations into the\n-same batch.\n-\n-<h1>Synchronous Writes</h1>\n-By default, each write to <code>leveldb</code> is asynchronous: it\n-returns after pushing the write from the process into the operating\n-system.  The transfer from operating system memory to the underlying\n-persistent storage happens asynchronously.  The <code>sync</code> flag\n-can be turned on for a particular write to make the write operation\n-not return until the data being written has been pushed all the way to\n-persistent storage.  (On Posix systems, this is implemented by calling\n-either <code>fsync(...)</code> or <code>fdatasync(...)</code> or\n-<code>msync(..., MS_SYNC)</code> before the write operation returns.)\n-<pre>\n-  leveldb::WriteOptions write_options;\n-  write_options.sync = true;\n-  db-&gt;Put(write_options, ...);\n-</pre>\n-Asynchronous writes are often more than a thousand times as fast as\n-synchronous writes.  The downside of asynchronous writes is that a\n-crash of the machine may cause the last few updates to be lost.  Note\n-that a crash of just the writing process (i.e., not a reboot) will not\n-cause any loss since even when <code>sync</code> is false, an update\n-is pushed from the process memory into the operating system before it\n-is considered done.\n-\n-<p>\n-Asynchronous writes can often be used safely.  For example, when\n-loading a large amount of data into the database you can handle lost\n-updates by restarting the bulk load after a crash.  A hybrid scheme is\n-also possible where every Nth write is synchronous, and in the event\n-of a crash, the bulk load is restarted just after the last synchronous\n-write finished by the previous run.  (The synchronous write can update\n-a marker that describes where to restart on a crash.)\n-\n-<p>\n-<code>WriteBatch</code> provides an alternative to asynchronous writes.\n-Multiple updates may be placed in the same <code>WriteBatch</code> and\n-applied together using a synchronous write (i.e.,\n-<code>write_options.sync</code> is set to true).  The extra cost of\n-the synchronous write will be amortized across all of the writes in\n-the batch.\n-\n-<p>\n-<h1>Concurrency</h1>\n-<p>\n-A database may only be opened by one process at a time.\n-The <code>leveldb</code> implementation acquires a lock from the\n-operating system to prevent misuse.  Within a single process, the\n-same <code>leveldb::DB</code> object may be safely shared by multiple\n-concurrent threads.  I.e., different threads may write into or fetch\n-iterators or call <code>Get</code> on the same database without any\n-external synchronization (the leveldb implementation will\n-automatically do the required synchronization).  However other objects\n-(like Iterator and WriteBatch) may require external synchronization.\n-If two threads share such an object, they must protect access to it\n-using their own locking protocol.  More details are available in\n-the public header files.\n-<p>\n-<h1>Iteration</h1>\n-<p>\n-The following example demonstrates how to print all key,value pairs\n-in a database.\n-<p>\n-<pre>\n-  leveldb::Iterator* it = db-&gt;NewIterator(leveldb::ReadOptions());\n-  for (it-&gt;SeekToFirst(); it-&gt;Valid(); it-&gt;Next()) {\n-    cout &lt;&lt; it-&gt;key().ToString() &lt;&lt; \": \"  &lt;&lt; it-&gt;value().ToString() &lt;&lt; endl;\n-  }\n-  assert(it-&gt;status().ok());  // Check for any errors found during the scan\n-  delete it;\n-</pre>\n-The following variation shows how to process just the keys in the\n-range <code>[start,limit)</code>:\n-<p>\n-<pre>\n-  for (it-&gt;Seek(start);\n-       it-&gt;Valid() &amp;&amp; it-&gt;key().ToString() &lt; limit;\n-       it-&gt;Next()) {\n-    ...\n-  }\n-</pre>\n-You can also process entries in reverse order.  (Caveat: reverse\n-iteration may be somewhat slower than forward iteration.)\n-<p>\n-<pre>\n-  for (it-&gt;SeekToLast(); it-&gt;Valid(); it-&gt;Prev()) {\n-    ...\n-  }\n-</pre>\n-<h1>Snapshots</h1>\n-<p>\n-Snapshots provide consistent read-only views over the entire state of\n-the key-value store.  <code>ReadOptions::snapshot</code> may be non-NULL to indicate\n-that a read should operate on a particular version of the DB state.\n-If <code>ReadOptions::snapshot</code> is NULL, the read will operate on an\n-implicit snapshot of the current state.\n-<p>\n-Snapshots are created by the DB::GetSnapshot() method:\n-<p>\n-<pre>\n-  leveldb::ReadOptions options;\n-  options.snapshot = db-&gt;GetSnapshot();\n-  ... apply some updates to db ...\n-  leveldb::Iterator* iter = db-&gt;NewIterator(options);\n-  ... read using iter to view the state when the snapshot was created ...\n-  delete iter;\n-  db-&gt;ReleaseSnapshot(options.snapshot);\n-</pre>\n-Note that when a snapshot is no longer needed, it should be released\n-using the DB::ReleaseSnapshot interface.  This allows the\n-implementation to get rid of state that was being maintained just to\n-support reading as of that snapshot.\n-<h1>Slice</h1>\n-<p>\n-The return value of the <code>it->key()</code> and <code>it->value()</code> calls above\n-are instances of the <code>leveldb::Slice</code> type.  <code>Slice</code> is a simple\n-structure that contains a length and a pointer to an external byte\n-array.  Returning a <code>Slice</code> is a cheaper alternative to returning a\n-<code>std::string</code> since we do not need to copy potentially large keys and\n-values.  In addition, <code>leveldb</code> methods do not return null-terminated\n-C-style strings since <code>leveldb</code> keys and values are allowed to\n-contain '\\0' bytes.\n-<p>\n-C++ strings and null-terminated C-style strings can be easily converted\n-to a Slice:\n-<p>\n-<pre>\n-   leveldb::Slice s1 = \"hello\";\n-\n-   std::string str(\"world\");\n-   leveldb::Slice s2 = str;\n-</pre>\n-A Slice can be easily converted back to a C++ string:\n-<pre>\n-   std::string str = s1.ToString();\n-   assert(str == std::string(\"hello\"));\n-</pre>\n-Be careful when using Slices since it is up to the caller to ensure that\n-the external byte array into which the Slice points remains live while\n-the Slice is in use.  For example, the following is buggy:\n-<p>\n-<pre>\n-   leveldb::Slice slice;\n-   if (...) {\n-     std::string str = ...;\n-     slice = str;\n-   }\n-   Use(slice);\n-</pre>\n-When the <code>if</code> statement goes out of scope, <code>str</code> will be destroyed and the\n-backing storage for <code>slice</code> will disappear.\n-<p>\n-<h1>Comparators</h1>\n-<p>\n-The preceding examples used the default ordering function for key,\n-which orders bytes lexicographically.  You can however supply a custom\n-comparator when opening a database.  For example, suppose each\n-database key consists of two numbers and we should sort by the first\n-number, breaking ties by the second number.  First, define a proper\n-subclass of <code>leveldb::Comparator</code> that expresses these rules:\n-<p>\n-<pre>\n-  class TwoPartComparator : public leveldb::Comparator {\n-   public:\n-    // Three-way comparison function:\n-    //   if a &lt; b: negative result\n-    //   if a &gt; b: positive result\n-    //   else: zero result\n-    int Compare(const leveldb::Slice&amp; a, const leveldb::Slice&amp; b) const {\n-      int a1, a2, b1, b2;\n-      ParseKey(a, &amp;a1, &amp;a2);\n-      ParseKey(b, &amp;b1, &amp;b2);\n-      if (a1 &lt; b1) return -1;\n-      if (a1 &gt; b1) return +1;\n-      if (a2 &lt; b2) return -1;\n-      if (a2 &gt; b2) return +1;\n-      return 0;\n-    }\n-\n-    // Ignore the following methods for now:\n-    const char* Name() const { return \"TwoPartComparator\"; }\n-    void FindShortestSeparator(std::string*, const leveldb::Slice&amp;) const { }\n-    void FindShortSuccessor(std::string*) const { }\n-  };\n-</pre>\n-Now create a database using this custom comparator:\n-<p>\n-<pre>\n-  TwoPartComparator cmp;\n-  leveldb::DB* db;\n-  leveldb::Options options;\n-  options.create_if_missing = true;\n-  options.comparator = &amp;cmp;\n-  leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", &amp;db);\n-  ...\n-</pre>\n-<h2>Backwards compatibility</h2>\n-<p>\n-The result of the comparator's <code>Name</code> method is attached to the\n-database when it is created, and is checked on every subsequent\n-database open.  If the name changes, the <code>leveldb::DB::Open</code> call will\n-fail.  Therefore, change the name if and only if the new key format\n-and comparison function are incompatible with existing databases, and\n-it is ok to discard the contents of all existing databases.\n-<p>\n-You can however still gradually evolve your key format over time with\n-a little bit of pre-planning.  For example, you could store a version\n-number at the end of each key (one byte should suffice for most uses).\n-When you wish to switch to a new key format (e.g., adding an optional\n-third part to the keys processed by <code>TwoPartComparator</code>),\n-(a) keep the same comparator name (b) increment the version number\n-for new keys (c) change the comparator function so it uses the\n-version numbers found in the keys to decide how to interpret them.\n-<p>\n-<h1>Performance</h1>\n-<p>\n-Performance can be tuned by changing the default values of the\n-types defined in <code>include/leveldb/options.h</code>.\n-\n-<p>\n-<h2>Block size</h2>\n-<p>\n-<code>leveldb</code> groups adjacent keys together into the same block and such a\n-block is the unit of transfer to and from persistent storage.  The\n-default block size is approximately 4096 uncompressed bytes.\n-Applications that mostly do bulk scans over the contents of the\n-database may wish to increase this size.  Applications that do a lot\n-of point reads of small values may wish to switch to a smaller block\n-size if performance measurements indicate an improvement.  There isn't\n-much benefit in using blocks smaller than one kilobyte, or larger than\n-a few megabytes.  Also note that compression will be more effective\n-with larger block sizes.\n-<p>\n-<h2>Compression</h2>\n-<p>\n-Each block is individually compressed before being written to\n-persistent storage.  Compression is on by default since the default\n-compression method is very fast, and is automatically disabled for\n-uncompressible data.  In rare cases, applications may want to disable\n-compression entirely, but should only do so if benchmarks show a\n-performance improvement:\n-<p>\n-<pre>\n-  leveldb::Options options;\n-  options.compression = leveldb::kNoCompression;\n-  ... leveldb::DB::Open(options, name, ...) ....\n-</pre>\n-<h2>Cache</h2>\n-<p>\n-The contents of the database are stored in a set of files in the\n-filesystem and each file stores a sequence of compressed blocks.  If\n-<code>options.cache</code> is non-NULL, it is used to cache frequently used\n-uncompressed block contents.\n-<p>\n-<pre>\n-  #include \"leveldb/cache.h\"\n-\n-  leveldb::Options options;\n-  options.cache = leveldb::NewLRUCache(100 * 1048576);  // 100MB cache\n-  leveldb::DB* db;\n-  leveldb::DB::Open(options, name, &db);\n-  ... use the db ...\n-  delete db\n-  delete options.cache;\n-</pre>\n-Note that the cache holds uncompressed data, and therefore it should\n-be sized according to application level data sizes, without any\n-reduction from compression.  (Caching of compressed blocks is left to\n-the operating system buffer cache, or any custom <code>Env</code>\n-implementation provided by the client.)\n-<p>\n-When performing a bulk read, the application may wish to disable\n-caching so that the data processed by the bulk read does not end up\n-displacing most of the cached contents.  A per-iterator option can be\n-used to achieve this:\n-<p>\n-<pre>\n-  leveldb::ReadOptions options;\n-  options.fill_cache = false;\n-  leveldb::Iterator* it = db-&gt;NewIterator(options);\n-  for (it-&gt;SeekToFirst(); it-&gt;Valid(); it-&gt;Next()) {\n-    ...\n-  }\n-</pre>\n-<h2>Key Layout</h2>\n-<p>\n-Note that the unit of disk transfer and caching is a block.  Adjacent\n-keys (according to the database sort order) will usually be placed in\n-the same block.  Therefore the application can improve its performance\n-by placing keys that are accessed together near each other and placing\n-infrequently used keys in a separate region of the key space.\n-<p>\n-For example, suppose we are implementing a simple file system on top\n-of <code>leveldb</code>.  The types of entries we might wish to store are:\n-<p>\n-<pre>\n-   filename -&gt; permission-bits, length, list of file_block_ids\n-   file_block_id -&gt; data\n-</pre>\n-We might want to prefix <code>filename</code> keys with one letter (say '/') and the\n-<code>file_block_id</code> keys with a different letter (say '0') so that scans\n-over just the metadata do not force us to fetch and cache bulky file\n-contents.\n-<p>\n-<h2>Filters</h2>\n-<p>\n-Because of the way <code>leveldb</code> data is organized on disk,\n-a single <code>Get()</code> call may involve multiple reads from disk.\n-The optional <code>FilterPolicy</code> mechanism can be used to reduce\n-the number of disk reads substantially.\n-<pre>\n-   leveldb::Options options;\n-   options.filter_policy = NewBloomFilterPolicy(10);\n-   leveldb::DB* db;\n-   leveldb::DB::Open(options, \"/tmp/testdb\", &amp;db);\n-   ... use the database ...\n-   delete db;\n-   delete options.filter_policy;\n-</pre>\n-The preceding code associates a\n-<a href=\"http://en.wikipedia.org/wiki/Bloom_filter\">Bloom filter</a>\n-based filtering policy with the database.  Bloom filter based\n-filtering relies on keeping some number of bits of data in memory per\n-key (in this case 10 bits per key since that is the argument we passed\n-to NewBloomFilterPolicy).  This filter will reduce the number of unnecessary\n-disk reads needed for <code>Get()</code> calls by a factor of\n-approximately a 100.  Increasing the bits per key will lead to a\n-larger reduction at the cost of more memory usage.  We recommend that\n-applications whose working set does not fit in memory and that do a\n-lot of random reads set a filter policy.\n-<p>\n-If you are using a custom comparator, you should ensure that the filter\n-policy you are using is compatible with your comparator.  For example,\n-consider a comparator that ignores trailing spaces when comparing keys.\n-<code>NewBloomFilterPolicy</code> must not be used with such a comparator.\n-Instead, the application should provide a custom filter policy that\n-also ignores trailing spaces.  For example:\n-<pre>\n-  class CustomFilterPolicy : public leveldb::FilterPolicy {\n-   private:\n-    FilterPolicy* builtin_policy_;\n-   public:\n-    CustomFilterPolicy() : builtin_policy_(NewBloomFilterPolicy(10)) { }\n-    ~CustomFilterPolicy() { delete builtin_policy_; }\n-\n-    const char* Name() const { return \"IgnoreTrailingSpacesFilter\"; }\n-\n-    void CreateFilter(const Slice* keys, int n, std::string* dst) const {\n-      // Use builtin bloom filter code after removing trailing spaces\n-      std::vector&lt;Slice&gt; trimmed(n);\n-      for (int i = 0; i &lt; n; i++) {\n-        trimmed[i] = RemoveTrailingSpaces(keys[i]);\n-      }\n-      return builtin_policy_-&gt;CreateFilter(&amp;trimmed[i], n, dst);\n-    }\n-\n-    bool KeyMayMatch(const Slice& key, const Slice& filter) const {\n-      // Use builtin bloom filter code after removing trailing spaces\n-      return builtin_policy_-&gt;KeyMayMatch(RemoveTrailingSpaces(key), filter);\n-    }\n-  };\n-</pre>\n-<p>\n-Advanced applications may provide a filter policy that does not use\n-a bloom filter but uses some other mechanism for summarizing a set\n-of keys.  See <code>leveldb/filter_policy.h</code> for detail.\n-<p>\n-<h1>Checksums</h1>\n-<p>\n-<code>leveldb</code> associates checksums with all data it stores in the file system.\n-There are two separate controls provided over how aggressively these\n-checksums are verified:\n-<p>\n-<ul>\n-<li> <code>ReadOptions::verify_checksums</code> may be set to true to force\n-  checksum verification of all data that is read from the file system on\n-  behalf of a particular read.  By default, no such verification is\n-  done.\n-<p>\n-<li> <code>Options::paranoid_checks</code> may be set to true before opening a\n-  database to make the database implementation raise an error as soon as\n-  it detects an internal corruption.  Depending on which portion of the\n-  database has been corrupted, the error may be raised when the database\n-  is opened, or later by another database operation.  By default,\n-  paranoid checking is off so that the database can be used even if\n-  parts of its persistent storage have been corrupted.\n-<p>\n-  If a database is corrupted (perhaps it cannot be opened when\n-  paranoid checking is turned on), the <code>leveldb::RepairDB</code> function\n-  may be used to recover as much of the data as possible\n-<p>\n-</ul>\n-<h1>Approximate Sizes</h1>\n-<p>\n-The <code>GetApproximateSizes</code> method can used to get the approximate\n-number of bytes of file system space used by one or more key ranges.\n-<p>\n-<pre>\n-   leveldb::Range ranges[2];\n-   ranges[0] = leveldb::Range(\"a\", \"c\");\n-   ranges[1] = leveldb::Range(\"x\", \"z\");\n-   uint64_t sizes[2];\n-   leveldb::Status s = db-&gt;GetApproximateSizes(ranges, 2, sizes);\n-</pre>\n-The preceding call will set <code>sizes[0]</code> to the approximate number of\n-bytes of file system space used by the key range <code>[a..c)</code> and\n-<code>sizes[1]</code> to the approximate number of bytes used by the key range\n-<code>[x..z)</code>.\n-<p>\n-<h1>Environment</h1>\n-<p>\n-All file operations (and other operating system calls) issued by the\n-<code>leveldb</code> implementation are routed through a <code>leveldb::Env</code> object.\n-Sophisticated clients may wish to provide their own <code>Env</code>\n-implementation to get better control.  For example, an application may\n-introduce artificial delays in the file IO paths to limit the impact\n-of <code>leveldb</code> on other activities in the system.\n-<p>\n-<pre>\n-  class SlowEnv : public leveldb::Env {\n-    .. implementation of the Env interface ...\n-  };\n-\n-  SlowEnv env;\n-  leveldb::Options options;\n-  options.env = &amp;env;\n-  Status s = leveldb::DB::Open(options, ...);\n-</pre>\n-<h1>Porting</h1>\n-<p>\n-<code>leveldb</code> may be ported to a new platform by providing platform\n-specific implementations of the types/methods/functions exported by\n-<code>leveldb/port/port.h</code>.  See <code>leveldb/port/port_example.h</code> for more\n-details.\n-<p>\n-In addition, the new platform may need a new default <code>leveldb::Env</code>\n-implementation.  See <code>leveldb/util/env_posix.h</code> for an example.\n-\n-<h1>Other Information</h1>\n-\n-<p>\n-Details about the <code>leveldb</code> implementation may be found in\n-the following documents:\n-<ul>\n-<li> <a href=\"impl.html\">Implementation notes</a>\n-<li> <a href=\"table_format.txt\">Format of an immutable Table file</a>\n-<li> <a href=\"log_format.txt\">Format of a log file</a>\n-</ul>\n-\n-</body>\n-</html>"
      },
      {
        "sha": "be8569692bb054676bf451e06a8dd4980c32edca",
        "filename": "src/leveldb/doc/index.md",
        "status": "added",
        "additions": 523,
        "deletions": 0,
        "changes": 523,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/doc/index.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/doc/index.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/index.md?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -0,0 +1,523 @@\n+leveldb\n+=======\n+\n+_Jeff Dean, Sanjay Ghemawat_\n+\n+The leveldb library provides a persistent key value store. Keys and values are\n+arbitrary byte arrays.  The keys are ordered within the key value store\n+according to a user-specified comparator function.\n+\n+## Opening A Database\n+\n+A leveldb database has a name which corresponds to a file system directory. All\n+of the contents of database are stored in this directory. The following example\n+shows how to open a database, creating it if necessary:\n+\n+```c++\n+#include <cassert>\n+#include \"leveldb/db.h\"\n+\n+leveldb::DB* db;\n+leveldb::Options options;\n+options.create_if_missing = true;\n+leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", &db);\n+assert(status.ok());\n+...\n+```\n+\n+If you want to raise an error if the database already exists, add the following\n+line before the `leveldb::DB::Open` call:\n+\n+```c++\n+options.error_if_exists = true;\n+```\n+\n+## Status\n+\n+You may have noticed the `leveldb::Status` type above. Values of this type are\n+returned by most functions in leveldb that may encounter an error. You can check\n+if such a result is ok, and also print an associated error message:\n+\n+```c++\n+leveldb::Status s = ...;\n+if (!s.ok()) cerr << s.ToString() << endl;\n+```\n+\n+## Closing A Database\n+\n+When you are done with a database, just delete the database object. Example:\n+\n+```c++\n+... open the db as described above ...\n+... do something with db ...\n+delete db;\n+```\n+\n+## Reads And Writes\n+\n+The database provides Put, Delete, and Get methods to modify/query the database.\n+For example, the following code moves the value stored under key1 to key2.\n+\n+```c++\n+std::string value;\n+leveldb::Status s = db->Get(leveldb::ReadOptions(), key1, &value);\n+if (s.ok()) s = db->Put(leveldb::WriteOptions(), key2, value);\n+if (s.ok()) s = db->Delete(leveldb::WriteOptions(), key1);\n+```\n+\n+## Atomic Updates\n+\n+Note that if the process dies after the Put of key2 but before the delete of\n+key1, the same value may be left stored under multiple keys. Such problems can\n+be avoided by using the `WriteBatch` class to atomically apply a set of updates:\n+\n+```c++\n+#include \"leveldb/write_batch.h\"\n+...\n+std::string value;\n+leveldb::Status s = db->Get(leveldb::ReadOptions(), key1, &value);\n+if (s.ok()) {\n+  leveldb::WriteBatch batch;\n+  batch.Delete(key1);\n+  batch.Put(key2, value);\n+  s = db->Write(leveldb::WriteOptions(), &batch);\n+}\n+```\n+\n+The `WriteBatch` holds a sequence of edits to be made to the database, and these\n+edits within the batch are applied in order. Note that we called Delete before\n+Put so that if key1 is identical to key2, we do not end up erroneously dropping\n+the value entirely.\n+\n+Apart from its atomicity benefits, `WriteBatch` may also be used to speed up\n+bulk updates by placing lots of individual mutations into the same batch.\n+\n+## Synchronous Writes\n+\n+By default, each write to leveldb is asynchronous: it returns after pushing the\n+write from the process into the operating system. The transfer from operating\n+system memory to the underlying persistent storage happens asynchronously. The\n+sync flag can be turned on for a particular write to make the write operation\n+not return until the data being written has been pushed all the way to\n+persistent storage. (On Posix systems, this is implemented by calling either\n+`fsync(...)` or `fdatasync(...)` or `msync(..., MS_SYNC)` before the write\n+operation returns.)\n+\n+```c++\n+leveldb::WriteOptions write_options;\n+write_options.sync = true;\n+db->Put(write_options, ...);\n+```\n+\n+Asynchronous writes are often more than a thousand times as fast as synchronous\n+writes. The downside of asynchronous writes is that a crash of the machine may\n+cause the last few updates to be lost. Note that a crash of just the writing\n+process (i.e., not a reboot) will not cause any loss since even when sync is\n+false, an update is pushed from the process memory into the operating system\n+before it is considered done.\n+\n+Asynchronous writes can often be used safely. For example, when loading a large\n+amount of data into the database you can handle lost updates by restarting the\n+bulk load after a crash. A hybrid scheme is also possible where every Nth write\n+is synchronous, and in the event of a crash, the bulk load is restarted just\n+after the last synchronous write finished by the previous run. (The synchronous\n+write can update a marker that describes where to restart on a crash.)\n+\n+`WriteBatch` provides an alternative to asynchronous writes. Multiple updates\n+may be placed in the same WriteBatch and applied together using a synchronous\n+write (i.e., `write_options.sync` is set to true). The extra cost of the\n+synchronous write will be amortized across all of the writes in the batch.\n+\n+## Concurrency\n+\n+A database may only be opened by one process at a time. The leveldb\n+implementation acquires a lock from the operating system to prevent misuse.\n+Within a single process, the same `leveldb::DB` object may be safely shared by\n+multiple concurrent threads. I.e., different threads may write into or fetch\n+iterators or call Get on the same database without any external synchronization\n+(the leveldb implementation will automatically do the required synchronization).\n+However other objects (like Iterator and `WriteBatch`) may require external\n+synchronization. If two threads share such an object, they must protect access\n+to it using their own locking protocol. More details are available in the public\n+header files.\n+\n+## Iteration\n+\n+The following example demonstrates how to print all key,value pairs in a\n+database.\n+\n+```c++\n+leveldb::Iterator* it = db->NewIterator(leveldb::ReadOptions());\n+for (it->SeekToFirst(); it->Valid(); it->Next()) {\n+  cout << it->key().ToString() << \": \"  << it->value().ToString() << endl;\n+}\n+assert(it->status().ok());  // Check for any errors found during the scan\n+delete it;\n+```\n+\n+The following variation shows how to process just the keys in the range\n+[start,limit):\n+\n+```c++\n+for (it->Seek(start);\n+   it->Valid() && it->key().ToString() < limit;\n+   it->Next()) {\n+  ...\n+}\n+```\n+\n+You can also process entries in reverse order. (Caveat: reverse iteration may be\n+somewhat slower than forward iteration.)\n+\n+```c++\n+for (it->SeekToLast(); it->Valid(); it->Prev()) {\n+  ...\n+}\n+```\n+\n+## Snapshots\n+\n+Snapshots provide consistent read-only views over the entire state of the\n+key-value store.  `ReadOptions::snapshot` may be non-NULL to indicate that a\n+read should operate on a particular version of the DB state. If\n+`ReadOptions::snapshot` is NULL, the read will operate on an implicit snapshot\n+of the current state.\n+\n+Snapshots are created by the `DB::GetSnapshot()` method:\n+\n+```c++\n+leveldb::ReadOptions options;\n+options.snapshot = db->GetSnapshot();\n+... apply some updates to db ...\n+leveldb::Iterator* iter = db->NewIterator(options);\n+... read using iter to view the state when the snapshot was created ...\n+delete iter;\n+db->ReleaseSnapshot(options.snapshot);\n+```\n+\n+Note that when a snapshot is no longer needed, it should be released using the\n+`DB::ReleaseSnapshot` interface. This allows the implementation to get rid of\n+state that was being maintained just to support reading as of that snapshot.\n+\n+## Slice\n+\n+The return value of the `it->key()` and `it->value()` calls above are instances\n+of the `leveldb::Slice` type. Slice is a simple structure that contains a length\n+and a pointer to an external byte array. Returning a Slice is a cheaper\n+alternative to returning a `std::string` since we do not need to copy\n+potentially large keys and values. In addition, leveldb methods do not return\n+null-terminated C-style strings since leveldb keys and values are allowed to\n+contain `'\\0'` bytes.\n+\n+C++ strings and null-terminated C-style strings can be easily converted to a\n+Slice:\n+\n+```c++\n+leveldb::Slice s1 = \"hello\";\n+\n+std::string str(\"world\");\n+leveldb::Slice s2 = str;\n+```\n+\n+A Slice can be easily converted back to a C++ string:\n+\n+```c++\n+std::string str = s1.ToString();\n+assert(str == std::string(\"hello\"));\n+```\n+\n+Be careful when using Slices since it is up to the caller to ensure that the\n+external byte array into which the Slice points remains live while the Slice is\n+in use. For example, the following is buggy:\n+\n+```c++\n+leveldb::Slice slice;\n+if (...) {\n+  std::string str = ...;\n+  slice = str;\n+}\n+Use(slice);\n+```\n+\n+When the if statement goes out of scope, str will be destroyed and the backing\n+storage for slice will disappear.\n+\n+## Comparators\n+\n+The preceding examples used the default ordering function for key, which orders\n+bytes lexicographically. You can however supply a custom comparator when opening\n+a database.  For example, suppose each database key consists of two numbers and\n+we should sort by the first number, breaking ties by the second number. First,\n+define a proper subclass of `leveldb::Comparator` that expresses these rules:\n+\n+```c++\n+class TwoPartComparator : public leveldb::Comparator {\n+ public:\n+  // Three-way comparison function:\n+  //   if a < b: negative result\n+  //   if a > b: positive result\n+  //   else: zero result\n+  int Compare(const leveldb::Slice& a, const leveldb::Slice& b) const {\n+    int a1, a2, b1, b2;\n+    ParseKey(a, &a1, &a2);\n+    ParseKey(b, &b1, &b2);\n+    if (a1 < b1) return -1;\n+    if (a1 > b1) return +1;\n+    if (a2 < b2) return -1;\n+    if (a2 > b2) return +1;\n+    return 0;\n+  }\n+\n+  // Ignore the following methods for now:\n+  const char* Name() const { return \"TwoPartComparator\"; }\n+  void FindShortestSeparator(std::string*, const leveldb::Slice&) const {}\n+  void FindShortSuccessor(std::string*) const {}\n+};\n+```\n+\n+Now create a database using this custom comparator:\n+\n+```c++\n+TwoPartComparator cmp;\n+leveldb::DB* db;\n+leveldb::Options options;\n+options.create_if_missing = true;\n+options.comparator = &cmp;\n+leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", &db);\n+...\n+```\n+\n+### Backwards compatibility\n+\n+The result of the comparator's Name method is attached to the database when it\n+is created, and is checked on every subsequent database open. If the name\n+changes, the `leveldb::DB::Open` call will fail. Therefore, change the name if\n+and only if the new key format and comparison function are incompatible with\n+existing databases, and it is ok to discard the contents of all existing\n+databases.\n+\n+You can however still gradually evolve your key format over time with a little\n+bit of pre-planning. For example, you could store a version number at the end of\n+each key (one byte should suffice for most uses). When you wish to switch to a\n+new key format (e.g., adding an optional third part to the keys processed by\n+`TwoPartComparator`), (a) keep the same comparator name (b) increment the\n+version number for new keys (c) change the comparator function so it uses the\n+version numbers found in the keys to decide how to interpret them.\n+\n+## Performance\n+\n+Performance can be tuned by changing the default values of the types defined in\n+`include/leveldb/options.h`.\n+\n+### Block size\n+\n+leveldb groups adjacent keys together into the same block and such a block is\n+the unit of transfer to and from persistent storage. The default block size is\n+approximately 4096 uncompressed bytes.  Applications that mostly do bulk scans\n+over the contents of the database may wish to increase this size. Applications\n+that do a lot of point reads of small values may wish to switch to a smaller\n+block size if performance measurements indicate an improvement. There isn't much\n+benefit in using blocks smaller than one kilobyte, or larger than a few\n+megabytes. Also note that compression will be more effective with larger block\n+sizes.\n+\n+### Compression\n+\n+Each block is individually compressed before being written to persistent\n+storage. Compression is on by default since the default compression method is\n+very fast, and is automatically disabled for uncompressible data. In rare cases,\n+applications may want to disable compression entirely, but should only do so if\n+benchmarks show a performance improvement:\n+\n+```c++\n+leveldb::Options options;\n+options.compression = leveldb::kNoCompression;\n+... leveldb::DB::Open(options, name, ...) ....\n+```\n+\n+### Cache\n+\n+The contents of the database are stored in a set of files in the filesystem and\n+each file stores a sequence of compressed blocks. If options.cache is non-NULL,\n+it is used to cache frequently used uncompressed block contents.\n+\n+```c++\n+#include \"leveldb/cache.h\"\n+\n+leveldb::Options options;\n+options.cache = leveldb::NewLRUCache(100 * 1048576);  // 100MB cache\n+leveldb::DB* db;\n+leveldb::DB::Open(options, name, &db);\n+... use the db ...\n+delete db\n+delete options.cache;\n+```\n+\n+Note that the cache holds uncompressed data, and therefore it should be sized\n+according to application level data sizes, without any reduction from\n+compression. (Caching of compressed blocks is left to the operating system\n+buffer cache, or any custom Env implementation provided by the client.)\n+\n+When performing a bulk read, the application may wish to disable caching so that\n+the data processed by the bulk read does not end up displacing most of the\n+cached contents. A per-iterator option can be used to achieve this:\n+\n+```c++\n+leveldb::ReadOptions options;\n+options.fill_cache = false;\n+leveldb::Iterator* it = db->NewIterator(options);\n+for (it->SeekToFirst(); it->Valid(); it->Next()) {\n+  ...\n+}\n+```\n+\n+### Key Layout\n+\n+Note that the unit of disk transfer and caching is a block. Adjacent keys\n+(according to the database sort order) will usually be placed in the same block.\n+Therefore the application can improve its performance by placing keys that are\n+accessed together near each other and placing infrequently used keys in a\n+separate region of the key space.\n+\n+For example, suppose we are implementing a simple file system on top of leveldb.\n+The types of entries we might wish to store are:\n+\n+    filename -> permission-bits, length, list of file_block_ids\n+    file_block_id -> data\n+\n+We might want to prefix filename keys with one letter (say '/') and the\n+`file_block_id` keys with a different letter (say '0') so that scans over just\n+the metadata do not force us to fetch and cache bulky file contents.\n+\n+### Filters\n+\n+Because of the way leveldb data is organized on disk, a single `Get()` call may\n+involve multiple reads from disk. The optional FilterPolicy mechanism can be\n+used to reduce the number of disk reads substantially.\n+\n+```c++\n+leveldb::Options options;\n+options.filter_policy = NewBloomFilterPolicy(10);\n+leveldb::DB* db;\n+leveldb::DB::Open(options, \"/tmp/testdb\", &db);\n+... use the database ...\n+delete db;\n+delete options.filter_policy;\n+```\n+\n+The preceding code associates a Bloom filter based filtering policy with the\n+database.  Bloom filter based filtering relies on keeping some number of bits of\n+data in memory per key (in this case 10 bits per key since that is the argument\n+we passed to `NewBloomFilterPolicy`). This filter will reduce the number of\n+unnecessary disk reads needed for Get() calls by a factor of approximately\n+a 100. Increasing the bits per key will lead to a larger reduction at the cost\n+of more memory usage. We recommend that applications whose working set does not\n+fit in memory and that do a lot of random reads set a filter policy.\n+\n+If you are using a custom comparator, you should ensure that the filter policy\n+you are using is compatible with your comparator. For example, consider a\n+comparator that ignores trailing spaces when comparing keys.\n+`NewBloomFilterPolicy` must not be used with such a comparator. Instead, the\n+application should provide a custom filter policy that also ignores trailing\n+spaces. For example:\n+\n+```c++\n+class CustomFilterPolicy : public leveldb::FilterPolicy {\n+ private:\n+  FilterPolicy* builtin_policy_;\n+\n+ public:\n+  CustomFilterPolicy() : builtin_policy_(NewBloomFilterPolicy(10)) {}\n+  ~CustomFilterPolicy() { delete builtin_policy_; }\n+\n+  const char* Name() const { return \"IgnoreTrailingSpacesFilter\"; }\n+\n+  void CreateFilter(const Slice* keys, int n, std::string* dst) const {\n+    // Use builtin bloom filter code after removing trailing spaces\n+    std::vector<Slice> trimmed(n);\n+    for (int i = 0; i < n; i++) {\n+      trimmed[i] = RemoveTrailingSpaces(keys[i]);\n+    }\n+    return builtin_policy_->CreateFilter(&trimmed[i], n, dst);\n+  }\n+};\n+```\n+\n+Advanced applications may provide a filter policy that does not use a bloom\n+filter but uses some other mechanism for summarizing a set of keys. See\n+`leveldb/filter_policy.h` for detail.\n+\n+## Checksums\n+\n+leveldb associates checksums with all data it stores in the file system. There\n+are two separate controls provided over how aggressively these checksums are\n+verified:\n+\n+`ReadOptions::verify_checksums` may be set to true to force checksum\n+verification of all data that is read from the file system on behalf of a\n+particular read.  By default, no such verification is done.\n+\n+`Options::paranoid_checks` may be set to true before opening a database to make\n+the database implementation raise an error as soon as it detects an internal\n+corruption. Depending on which portion of the database has been corrupted, the\n+error may be raised when the database is opened, or later by another database\n+operation. By default, paranoid checking is off so that the database can be used\n+even if parts of its persistent storage have been corrupted.\n+\n+If a database is corrupted (perhaps it cannot be opened when paranoid checking\n+is turned on), the `leveldb::RepairDB` function may be used to recover as much\n+of the data as possible\n+\n+## Approximate Sizes\n+\n+The `GetApproximateSizes` method can used to get the approximate number of bytes\n+of file system space used by one or more key ranges.\n+\n+```c++\n+leveldb::Range ranges[2];\n+ranges[0] = leveldb::Range(\"a\", \"c\");\n+ranges[1] = leveldb::Range(\"x\", \"z\");\n+uint64_t sizes[2];\n+leveldb::Status s = db->GetApproximateSizes(ranges, 2, sizes);\n+```\n+\n+The preceding call will set `sizes[0]` to the approximate number of bytes of\n+file system space used by the key range `[a..c)` and `sizes[1]` to the\n+approximate number of bytes used by the key range `[x..z)`.\n+\n+## Environment\n+\n+All file operations (and other operating system calls) issued by the leveldb\n+implementation are routed through a `leveldb::Env` object. Sophisticated clients\n+may wish to provide their own Env implementation to get better control.\n+For example, an application may introduce artificial delays in the file IO\n+paths to limit the impact of leveldb on other activities in the system.\n+\n+```c++\n+class SlowEnv : public leveldb::Env {\n+  ... implementation of the Env interface ...\n+};\n+\n+SlowEnv env;\n+leveldb::Options options;\n+options.env = &env;\n+Status s = leveldb::DB::Open(options, ...);\n+```\n+\n+## Porting\n+\n+leveldb may be ported to a new platform by providing platform specific\n+implementations of the types/methods/functions exported by\n+`leveldb/port/port.h`.  See `leveldb/port/port_example.h` for more details.\n+\n+In addition, the new platform may need a new default `leveldb::Env`\n+implementation.  See `leveldb/util/env_posix.h` for an example.\n+\n+## Other Information\n+\n+Details about the leveldb implementation may be found in the following\n+documents:\n+\n+1. [Implementation notes](impl.md)\n+2. [Format of an immutable Table file](table_format.md)\n+3. [Format of a log file](log_format.md)"
      },
      {
        "sha": "f32cb5d7dac482e71a103f85b1a2667b92e6120e",
        "filename": "src/leveldb/doc/log_format.md",
        "status": "added",
        "additions": 75,
        "deletions": 0,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/doc/log_format.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/doc/log_format.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/log_format.md?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -0,0 +1,75 @@\n+leveldb Log format\n+==================\n+The log file contents are a sequence of 32KB blocks.  The only exception is that\n+the tail of the file may contain a partial block.\n+\n+Each block consists of a sequence of records:\n+\n+    block := record* trailer?\n+    record :=\n+      checksum: uint32     // crc32c of type and data[] ; little-endian\n+      length: uint16       // little-endian\n+      type: uint8          // One of FULL, FIRST, MIDDLE, LAST\n+      data: uint8[length]\n+\n+A record never starts within the last six bytes of a block (since it won't fit).\n+Any leftover bytes here form the trailer, which must consist entirely of zero\n+bytes and must be skipped by readers.\n+\n+Aside: if exactly seven bytes are left in the current block, and a new non-zero\n+length record is added, the writer must emit a FIRST record (which contains zero\n+bytes of user data) to fill up the trailing seven bytes of the block and then\n+emit all of the user data in subsequent blocks.\n+\n+More types may be added in the future.  Some Readers may skip record types they\n+do not understand, others may report that some data was skipped.\n+\n+    FULL == 1\n+    FIRST == 2\n+    MIDDLE == 3\n+    LAST == 4\n+\n+The FULL record contains the contents of an entire user record.\n+\n+FIRST, MIDDLE, LAST are types used for user records that have been split into\n+multiple fragments (typically because of block boundaries).  FIRST is the type\n+of the first fragment of a user record, LAST is the type of the last fragment of\n+a user record, and MIDDLE is the type of all interior fragments of a user\n+record.\n+\n+Example: consider a sequence of user records:\n+\n+    A: length 1000\n+    B: length 97270\n+    C: length 8000\n+\n+**A** will be stored as a FULL record in the first block.\n+\n+**B** will be split into three fragments: first fragment occupies the rest of\n+the first block, second fragment occupies the entirety of the second block, and\n+the third fragment occupies a prefix of the third block.  This will leave six\n+bytes free in the third block, which will be left empty as the trailer.\n+\n+**C** will be stored as a FULL record in the fourth block.\n+\n+----\n+\n+## Some benefits over the recordio format:\n+\n+1. We do not need any heuristics for resyncing - just go to next block boundary\n+   and scan.  If there is a corruption, skip to the next block.  As a\n+   side-benefit, we do not get confused when part of the contents of one log\n+   file are embedded as a record inside another log file.\n+\n+2. Splitting at approximate boundaries (e.g., for mapreduce) is simple: find the\n+   next block boundary and skip records until we hit a FULL or FIRST record.\n+\n+3. We do not need extra buffering for large records.\n+\n+## Some downsides compared to recordio format:\n+\n+1. No packing of tiny records.  This could be fixed by adding a new record type,\n+   so it is a shortcoming of the current implementation, not necessarily the\n+   format.\n+\n+2. No compression.  Again, this could be fixed by adding new record types."
      },
      {
        "sha": "4cca5ef6ead327bc4c55d8941528f656fa68166c",
        "filename": "src/leveldb/doc/log_format.txt",
        "status": "removed",
        "additions": 0,
        "deletions": 75,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c91ca0ace9bd62eea8158b92cfc53d6d219e37b7/src/leveldb/doc/log_format.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c91ca0ace9bd62eea8158b92cfc53d6d219e37b7/src/leveldb/doc/log_format.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/log_format.txt?ref=c91ca0ace9bd62eea8158b92cfc53d6d219e37b7",
        "patch": "@@ -1,75 +0,0 @@\n-The log file contents are a sequence of 32KB blocks.  The only\n-exception is that the tail of the file may contain a partial block.\n-\n-Each block consists of a sequence of records:\n-   block := record* trailer?\n-   record :=\n-\tchecksum: uint32\t// crc32c of type and data[] ; little-endian\n-\tlength: uint16\t\t// little-endian\n-\ttype: uint8\t\t// One of FULL, FIRST, MIDDLE, LAST\n-\tdata: uint8[length]\n-\n-A record never starts within the last six bytes of a block (since it\n-won't fit).  Any leftover bytes here form the trailer, which must\n-consist entirely of zero bytes and must be skipped by readers.\n-\n-Aside: if exactly seven bytes are left in the current block, and a new\n-non-zero length record is added, the writer must emit a FIRST record\n-(which contains zero bytes of user data) to fill up the trailing seven\n-bytes of the block and then emit all of the user data in subsequent\n-blocks.\n-\n-More types may be added in the future.  Some Readers may skip record\n-types they do not understand, others may report that some data was\n-skipped.\n-\n-FULL == 1\n-FIRST == 2\n-MIDDLE == 3\n-LAST == 4\n-\n-The FULL record contains the contents of an entire user record.\n-\n-FIRST, MIDDLE, LAST are types used for user records that have been\n-split into multiple fragments (typically because of block boundaries).\n-FIRST is the type of the first fragment of a user record, LAST is the\n-type of the last fragment of a user record, and MIDDLE is the type of\n-all interior fragments of a user record.\n-\n-Example: consider a sequence of user records:\n-   A: length 1000\n-   B: length 97270\n-   C: length 8000\n-A will be stored as a FULL record in the first block.\n-\n-B will be split into three fragments: first fragment occupies the rest\n-of the first block, second fragment occupies the entirety of the\n-second block, and the third fragment occupies a prefix of the third\n-block.  This will leave six bytes free in the third block, which will\n-be left empty as the trailer.\n-\n-C will be stored as a FULL record in the fourth block.\n-\n-===================\n-\n-Some benefits over the recordio format:\n-\n-(1) We do not need any heuristics for resyncing - just go to next\n-block boundary and scan.  If there is a corruption, skip to the next\n-block.  As a side-benefit, we do not get confused when part of the\n-contents of one log file are embedded as a record inside another log\n-file.\n-\n-(2) Splitting at approximate boundaries (e.g., for mapreduce) is\n-simple: find the next block boundary and skip records until we\n-hit a FULL or FIRST record.\n-\n-(3) We do not need extra buffering for large records.\n-\n-Some downsides compared to recordio format:\n-\n-(1) No packing of tiny records.  This could be fixed by adding a new\n-record type, so it is a shortcoming of the current implementation,\n-not necessarily the format.\n-\n-(2) No compression.  Again, this could be fixed by adding new record types."
      },
      {
        "sha": "5fe7e72411b828ddc3453754d451fe357626382e",
        "filename": "src/leveldb/doc/table_format.md",
        "status": "added",
        "additions": 107,
        "deletions": 0,
        "changes": 107,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/doc/table_format.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/doc/table_format.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/table_format.md?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -0,0 +1,107 @@\n+leveldb File format\n+===================\n+\n+    <beginning_of_file>\n+    [data block 1]\n+    [data block 2]\n+    ...\n+    [data block N]\n+    [meta block 1]\n+    ...\n+    [meta block K]\n+    [metaindex block]\n+    [index block]\n+    [Footer]        (fixed size; starts at file_size - sizeof(Footer))\n+    <end_of_file>\n+\n+The file contains internal pointers.  Each such pointer is called\n+a BlockHandle and contains the following information:\n+\n+    offset:   varint64\n+    size:     varint64\n+\n+See [varints](https://developers.google.com/protocol-buffers/docs/encoding#varints)\n+for an explanation of varint64 format.\n+\n+1.  The sequence of key/value pairs in the file are stored in sorted\n+order and partitioned into a sequence of data blocks.  These blocks\n+come one after another at the beginning of the file.  Each data block\n+is formatted according to the code in `block_builder.cc`, and then\n+optionally compressed.\n+\n+2. After the data blocks we store a bunch of meta blocks.  The\n+supported meta block types are described below.  More meta block types\n+may be added in the future.  Each meta block is again formatted using\n+`block_builder.cc` and then optionally compressed.\n+\n+3. A \"metaindex\" block.  It contains one entry for every other meta\n+block where the key is the name of the meta block and the value is a\n+BlockHandle pointing to that meta block.\n+\n+4. An \"index\" block.  This block contains one entry per data block,\n+where the key is a string >= last key in that data block and before\n+the first key in the successive data block.  The value is the\n+BlockHandle for the data block.\n+\n+5. At the very end of the file is a fixed length footer that contains\n+the BlockHandle of the metaindex and index blocks as well as a magic number.\n+\n+        metaindex_handle: char[p];     // Block handle for metaindex\n+        index_handle:     char[q];     // Block handle for index\n+        padding:          char[40-p-q];// zeroed bytes to make fixed length\n+                                       // (40==2*BlockHandle::kMaxEncodedLength)\n+        magic:            fixed64;     // == 0xdb4775248b80fb57 (little-endian)\n+\n+## \"filter\" Meta Block\n+\n+If a `FilterPolicy` was specified when the database was opened, a\n+filter block is stored in each table.  The \"metaindex\" block contains\n+an entry that maps from `filter.<N>` to the BlockHandle for the filter\n+block where `<N>` is the string returned by the filter policy's\n+`Name()` method.\n+\n+The filter block stores a sequence of filters, where filter i contains\n+the output of `FilterPolicy::CreateFilter()` on all keys that are stored\n+in a block whose file offset falls within the range\n+\n+    [ i*base ... (i+1)*base-1 ]\n+\n+Currently, \"base\" is 2KB.  So for example, if blocks X and Y start in\n+the range `[ 0KB .. 2KB-1 ]`, all of the keys in X and Y will be\n+converted to a filter by calling `FilterPolicy::CreateFilter()`, and the\n+resulting filter will be stored as the first filter in the filter\n+block.\n+\n+The filter block is formatted as follows:\n+\n+    [filter 0]\n+    [filter 1]\n+    [filter 2]\n+    ...\n+    [filter N-1]\n+\n+    [offset of filter 0]                  : 4 bytes\n+    [offset of filter 1]                  : 4 bytes\n+    [offset of filter 2]                  : 4 bytes\n+    ...\n+    [offset of filter N-1]                : 4 bytes\n+\n+    [offset of beginning of offset array] : 4 bytes\n+    lg(base)                              : 1 byte\n+\n+The offset array at the end of the filter block allows efficient\n+mapping from a data block offset to the corresponding filter.\n+\n+## \"stats\" Meta Block\n+\n+This meta block contains a bunch of stats.  The key is the name\n+of the statistic.  The value contains the statistic.\n+\n+TODO(postrelease): record following stats.\n+\n+    data size\n+    index size\n+    key size (uncompressed)\n+    value size (uncompressed)\n+    number of entries\n+    number of data blocks"
      },
      {
        "sha": "ca8f9b4460ad85d9e09f14a959ed47bd2812edb5",
        "filename": "src/leveldb/doc/table_format.txt",
        "status": "removed",
        "additions": 0,
        "deletions": 104,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c91ca0ace9bd62eea8158b92cfc53d6d219e37b7/src/leveldb/doc/table_format.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c91ca0ace9bd62eea8158b92cfc53d6d219e37b7/src/leveldb/doc/table_format.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/table_format.txt?ref=c91ca0ace9bd62eea8158b92cfc53d6d219e37b7",
        "patch": "@@ -1,104 +0,0 @@\n-File format\n-===========\n-\n-  <beginning_of_file>\n-  [data block 1]\n-  [data block 2]\n-  ...\n-  [data block N]\n-  [meta block 1]\n-  ...\n-  [meta block K]\n-  [metaindex block]\n-  [index block]\n-  [Footer]        (fixed size; starts at file_size - sizeof(Footer))\n-  <end_of_file>\n-\n-The file contains internal pointers.  Each such pointer is called\n-a BlockHandle and contains the following information:\n-  offset:\t    varint64\n-  size:\t\t    varint64\n-See https://developers.google.com/protocol-buffers/docs/encoding#varints\n-for an explanation of varint64 format.\n-\n-(1) The sequence of key/value pairs in the file are stored in sorted\n-order and partitioned into a sequence of data blocks.  These blocks\n-come one after another at the beginning of the file.  Each data block\n-is formatted according to the code in block_builder.cc, and then\n-optionally compressed.\n-\n-(2) After the data blocks we store a bunch of meta blocks.  The\n-supported meta block types are described below.  More meta block types\n-may be added in the future.  Each meta block is again formatted using\n-block_builder.cc and then optionally compressed.\n-\n-(3) A \"metaindex\" block.  It contains one entry for every other meta\n-block where the key is the name of the meta block and the value is a\n-BlockHandle pointing to that meta block.\n-\n-(4) An \"index\" block.  This block contains one entry per data block,\n-where the key is a string >= last key in that data block and before\n-the first key in the successive data block.  The value is the\n-BlockHandle for the data block.\n-\n-(6) At the very end of the file is a fixed length footer that contains\n-the BlockHandle of the metaindex and index blocks as well as a magic number.\n-       metaindex_handle: char[p];    // Block handle for metaindex\n-       index_handle:     char[q];    // Block handle for index\n-       padding:          char[40-p-q]; // zeroed bytes to make fixed length\n-                                       // (40==2*BlockHandle::kMaxEncodedLength)\n-       magic:            fixed64;    // == 0xdb4775248b80fb57 (little-endian)\n-\n-\"filter\" Meta Block\n--------------------\n-\n-If a \"FilterPolicy\" was specified when the database was opened, a\n-filter block is stored in each table.  The \"metaindex\" block contains\n-an entry that maps from \"filter.<N>\" to the BlockHandle for the filter\n-block where \"<N>\" is the string returned by the filter policy's\n-\"Name()\" method.\n-\n-The filter block stores a sequence of filters, where filter i contains\n-the output of FilterPolicy::CreateFilter() on all keys that are stored\n-in a block whose file offset falls within the range\n-\n-    [ i*base ... (i+1)*base-1 ]\n-\n-Currently, \"base\" is 2KB.  So for example, if blocks X and Y start in\n-the range [ 0KB .. 2KB-1 ], all of the keys in X and Y will be\n-converted to a filter by calling FilterPolicy::CreateFilter(), and the\n-resulting filter will be stored as the first filter in the filter\n-block.\n-\n-The filter block is formatted as follows:\n-\n-     [filter 0]\n-     [filter 1]\n-     [filter 2]\n-     ...\n-     [filter N-1]\n-\n-     [offset of filter 0]                  : 4 bytes\n-     [offset of filter 1]                  : 4 bytes\n-     [offset of filter 2]                  : 4 bytes\n-     ...\n-     [offset of filter N-1]                : 4 bytes\n-\n-     [offset of beginning of offset array] : 4 bytes\n-     lg(base)                              : 1 byte\n-\n-The offset array at the end of the filter block allows efficient\n-mapping from a data block offset to the corresponding filter.\n-\n-\"stats\" Meta Block\n-------------------\n-\n-This meta block contains a bunch of stats.  The key is the name\n-of the statistic.  The value contains the statistic.\n-TODO(postrelease): record following stats.\n-  data size\n-  index size\n-  key size (uncompressed)\n-  value size (uncompressed)\n-  number of entries\n-  number of data blocks"
      },
      {
        "sha": "bfab10a0b725be9ed218783ee8fc98110fa77988",
        "filename": "src/leveldb/include/leveldb/db.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/include/leveldb/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/include/leveldb/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/db.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -14,7 +14,7 @@ namespace leveldb {\n \n // Update Makefile if you change these\n static const int kMajorVersion = 1;\n-static const int kMinorVersion = 19;\n+static const int kMinorVersion = 20;\n \n struct Options;\n struct ReadOptions;"
      },
      {
        "sha": "976e38122aafa88acba169b3fc3506c013a75b61",
        "filename": "src/leveldb/include/leveldb/options.h",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/include/leveldb/options.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/include/leveldb/options.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/options.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -112,6 +112,18 @@ struct Options {\n   // Default: 16\n   int block_restart_interval;\n \n+  // Leveldb will write up to this amount of bytes to a file before\n+  // switching to a new one.\n+  // Most clients should leave this parameter alone.  However if your\n+  // filesystem is more efficient with larger files, you could\n+  // consider increasing the value.  The downside will be longer\n+  // compactions and hence longer latency/performance hiccups.\n+  // Another reason to increase this parameter might be when you are\n+  // initially populating a large database.\n+  //\n+  // Default: 2MB\n+  size_t max_file_size;\n+\n   // Compress blocks using the specified compression algorithm.  This\n   // parameter can be changed dynamically.\n   //"
      },
      {
        "sha": "d79a02230d57fe085949936b26b9a7af413e07b8",
        "filename": "src/leveldb/port/atomic_pointer.h",
        "status": "modified",
        "additions": 25,
        "deletions": 22,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/port/atomic_pointer.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/port/atomic_pointer.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/atomic_pointer.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -46,6 +46,30 @@\n namespace leveldb {\n namespace port {\n \n+// AtomicPointer based on <cstdatomic> if available\n+#if defined(LEVELDB_ATOMIC_PRESENT)\n+class AtomicPointer {\n+ private:\n+  std::atomic<void*> rep_;\n+ public:\n+  AtomicPointer() { }\n+  explicit AtomicPointer(void* v) : rep_(v) { }\n+  inline void* Acquire_Load() const {\n+    return rep_.load(std::memory_order_acquire);\n+  }\n+  inline void Release_Store(void* v) {\n+    rep_.store(v, std::memory_order_release);\n+  }\n+  inline void* NoBarrier_Load() const {\n+    return rep_.load(std::memory_order_relaxed);\n+  }\n+  inline void NoBarrier_Store(void* v) {\n+    rep_.store(v, std::memory_order_relaxed);\n+  }\n+};\n+\n+#else\n+\n // Define MemoryBarrier() if available\n // Windows on x86\n #if defined(OS_WIN) && defined(COMPILER_MSVC) && defined(ARCH_CPU_X86_FAMILY)\n@@ -142,28 +166,6 @@ class AtomicPointer {\n   }\n };\n \n-// AtomicPointer based on <cstdatomic>\n-#elif defined(LEVELDB_ATOMIC_PRESENT)\n-class AtomicPointer {\n- private:\n-  std::atomic<void*> rep_;\n- public:\n-  AtomicPointer() { }\n-  explicit AtomicPointer(void* v) : rep_(v) { }\n-  inline void* Acquire_Load() const {\n-    return rep_.load(std::memory_order_acquire);\n-  }\n-  inline void Release_Store(void* v) {\n-    rep_.store(v, std::memory_order_release);\n-  }\n-  inline void* NoBarrier_Load() const {\n-    return rep_.load(std::memory_order_relaxed);\n-  }\n-  inline void NoBarrier_Store(void* v) {\n-    rep_.store(v, std::memory_order_relaxed);\n-  }\n-};\n-\n // Atomic pointer based on sparc memory barriers\n #elif defined(__sparcv9) && defined(__GNUC__)\n class AtomicPointer {\n@@ -228,6 +230,7 @@ class AtomicPointer {\n #else\n #error Please implement AtomicPointer for this platform.\n \n+#endif\n #endif\n \n #undef LEVELDB_HAVE_MEMORY_BARRIER"
      },
      {
        "sha": "5b1d027de556eb6b308dee1ccea88995bcb038d3",
        "filename": "src/leveldb/port/port_example.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/port/port_example.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/port/port_example.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_example.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -129,6 +129,16 @@ extern bool Snappy_Uncompress(const char* input_data, size_t input_length,\n // The concatenation of all \"data[0,n-1]\" fragments is the heap profile.\n extern bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg);\n \n+// Determine whether a working accelerated crc32 implementation exists\n+// Returns true if AcceleratedCRC32C is safe to call\n+bool HasAcceleratedCRC32C();\n+\n+// Extend the CRC to include the first n bytes of buf.\n+//\n+// Returns zero if the CRC cannot be extended using acceleration, else returns\n+// the newly extended CRC value (which may also be zero).\n+uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size);\n+\n }  // namespace port\n }  // namespace leveldb\n "
      },
      {
        "sha": "ec39e921957f6507e3eb5f5ed5b6e15fea69e527",
        "filename": "src/leveldb/port/port_posix.cc",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/port/port_posix.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/port/port_posix.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_posix.cc?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -8,6 +8,10 @@\n #include <stdio.h>\n #include <string.h>\n \n+#if (defined(__x86_64__) || defined(__i386__)) && defined(__GNUC__)\n+#include <cpuid.h>\n+#endif\n+\n namespace leveldb {\n namespace port {\n \n@@ -49,5 +53,15 @@ void InitOnce(OnceType* once, void (*initializer)()) {\n   PthreadCall(\"once\", pthread_once(once, initializer));\n }\n \n+bool HasAcceleratedCRC32C() {\n+#if (defined(__x86_64__) || defined(__i386__)) && defined(__GNUC__)\n+  unsigned int eax, ebx, ecx, edx;\n+  __get_cpuid(1, &eax, &ebx, &ecx, &edx);\n+  return (ecx & (1 << 20)) != 0;\n+#else\n+  return false;\n+#endif\n+}\n+\n }  // namespace port\n }  // namespace leveldb"
      },
      {
        "sha": "d85fa5d63fe0fc593cb2c9c12471d884622189b6",
        "filename": "src/leveldb/port/port_posix.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/port/port_posix.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/port/port_posix.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_posix.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -152,6 +152,9 @@ inline bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg) {\n   return false;\n }\n \n+bool HasAcceleratedCRC32C();\n+uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size);\n+\n } // namespace port\n } // namespace leveldb\n "
      },
      {
        "sha": "2d49c21dd8b0eb08fa0fd33411c50f2d277c94d6",
        "filename": "src/leveldb/port/port_posix_sse.cc",
        "status": "added",
        "additions": 110,
        "deletions": 0,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/port/port_posix_sse.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/port/port_posix_sse.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_posix_sse.cc?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -0,0 +1,110 @@\n+// Copyright 2016 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// A portable implementation of crc32c, optimized to handle\n+// four bytes at a time.\n+//\n+// In a separate source file to allow this accelerated CRC32C function to be\n+// compiled with the appropriate compiler flags to enable x86 SSE 4.2\n+// instructions.\n+\n+#include <stdint.h>\n+#include <string.h>\n+#include \"port/port.h\"\n+\n+#if defined(LEVELDB_PLATFORM_POSIX_SSE)\n+\n+#if defined(_MSC_VER)\n+#include <intrin.h>\n+#elif defined(__GNUC__) && defined(__SSE4_2__)\n+#include <nmmintrin.h>\n+#endif\n+\n+#endif  // defined(LEVELDB_PLATFORM_POSIX_SSE)\n+\n+namespace leveldb {\n+namespace port {\n+\n+#if defined(LEVELDB_PLATFORM_POSIX_SSE)\n+\n+// Used to fetch a naturally-aligned 32-bit word in little endian byte-order\n+static inline uint32_t LE_LOAD32(const uint8_t *p) {\n+  // SSE is x86 only, so ensured that |p| is always little-endian.\n+  uint32_t word;\n+  memcpy(&word, p, sizeof(word));\n+  return word;\n+}\n+\n+#if defined(_M_X64) || defined(__x86_64__)  // LE_LOAD64 is only used on x64.\n+\n+// Used to fetch a naturally-aligned 64-bit word in little endian byte-order\n+static inline uint64_t LE_LOAD64(const uint8_t *p) {\n+  uint64_t dword;\n+  memcpy(&dword, p, sizeof(dword));\n+  return dword;\n+}\n+\n+#endif  // defined(_M_X64) || defined(__x86_64__)\n+\n+#endif  // defined(LEVELDB_PLATFORM_POSIX_SSE)\n+\n+// For further improvements see Intel publication at:\n+// http://download.intel.com/design/intarch/papers/323405.pdf\n+uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size) {\n+#if !defined(LEVELDB_PLATFORM_POSIX_SSE)\n+  return 0;\n+#else\n+\n+  const uint8_t *p = reinterpret_cast<const uint8_t *>(buf);\n+  const uint8_t *e = p + size;\n+  uint32_t l = crc ^ 0xffffffffu;\n+\n+#define STEP1 do {                              \\\n+    l = _mm_crc32_u8(l, *p++);                  \\\n+} while (0)\n+#define STEP4 do {                              \\\n+    l = _mm_crc32_u32(l, LE_LOAD32(p));         \\\n+    p += 4;                                     \\\n+} while (0)\n+#define STEP8 do {                              \\\n+    l = _mm_crc32_u64(l, LE_LOAD64(p));         \\\n+    p += 8;                                     \\\n+} while (0)\n+\n+  if (size > 16) {\n+    // Process unaligned bytes\n+    for (unsigned int i = reinterpret_cast<uintptr_t>(p) % 8; i; --i) {\n+      STEP1;\n+    }\n+\n+    // _mm_crc32_u64 is only available on x64.\n+#if defined(_M_X64) || defined(__x86_64__)\n+    // Process 8 bytes at a time\n+    while ((e-p) >= 8) {\n+      STEP8;\n+    }\n+    // Process 4 bytes at a time\n+    if ((e-p) >= 4) {\n+      STEP4;\n+    }\n+#else  // !(defined(_M_X64) || defined(__x86_64__))\n+    // Process 4 bytes at a time\n+    while ((e-p) >= 4) {\n+      STEP4;\n+    }\n+#endif  // defined(_M_X64) || defined(__x86_64__)\n+  }\n+  // Process the last few bytes\n+  while (p != e) {\n+    STEP1;\n+  }\n+#undef STEP8\n+#undef STEP4\n+#undef STEP1\n+  return l ^ 0xffffffffu;\n+#endif  // defined(LEVELDB_PLATFORM_POSIX_SSE)\n+}\n+\n+}  // namespace port\n+}  // namespace leveldb"
      },
      {
        "sha": "1be9e8d5b0b41ea458b42bb17f2e3a18eefac315",
        "filename": "src/leveldb/port/port_win.cc",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/port/port_win.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/port/port_win.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_win.cc?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -32,6 +32,7 @@\n \n #include <windows.h>\n #include <cassert>\n+#include <intrin.h>\n \n namespace leveldb {\n namespace port {\n@@ -143,5 +144,15 @@ void AtomicPointer::NoBarrier_Store(void* v) {\n   rep_ = v;\n }\n \n+bool HasAcceleratedCRC32C() {\n+#if defined(__x86_64__) || defined(__i386__)\n+  int cpu_info[4];\n+  __cpuid(cpu_info, 1);\n+  return (cpu_info[2] & (1 << 20)) != 0;\n+#else\n+  return false;\n+#endif\n+}\n+\n }\n }"
      },
      {
        "sha": "e8bf46ef27cd689912cb910e32385bfc55edf3b5",
        "filename": "src/leveldb/port/port_win.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/port/port_win.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/port/port_win.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_win.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -168,6 +168,9 @@ inline bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg) {\n   return false;\n }\n \n+bool HasAcceleratedCRC32C();\n+uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size);\n+\n }\n }\n "
      },
      {
        "sha": "1ed5134170e54c430d8a0318e95ece23235ae1ba",
        "filename": "src/leveldb/table/filter_block.cc",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/table/filter_block.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/table/filter_block.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/filter_block.cc?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -9,7 +9,7 @@\n \n namespace leveldb {\n \n-// See doc/table_format.txt for an explanation of the filter block format.\n+// See doc/table_format.md for an explanation of the filter block format.\n \n // Generate new filter every 2KB of data\n static const size_t kFilterBaseLg = 11;"
      },
      {
        "sha": "b3f40eeeed45f5b2f1b6fafdceb0bddb5691e2e1",
        "filename": "src/leveldb/util/crc32c.cc",
        "status": "modified",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/util/crc32c.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/util/crc32c.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/crc32c.cc?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -8,6 +8,8 @@\n #include \"util/crc32c.h\"\n \n #include <stdint.h>\n+\n+#include \"port/port.h\"\n #include \"util/coding.h\"\n \n namespace leveldb {\n@@ -283,7 +285,27 @@ static inline uint32_t LE_LOAD32(const uint8_t *p) {\n   return DecodeFixed32(reinterpret_cast<const char*>(p));\n }\n \n+// Determine if the CPU running this program can accelerate the CRC32C\n+// calculation.\n+static bool CanAccelerateCRC32C() {\n+  if (!port::HasAcceleratedCRC32C())\n+    return false;\n+\n+  // Double-check that the accelerated implementation functions correctly.\n+  // port::AcceleretedCRC32C returns zero when unable to accelerate.\n+  static const char kTestCRCBuffer[] = \"TestCRCBuffer\";\n+  static const char kBufSize = sizeof(kTestCRCBuffer) - 1;\n+  static const uint32_t kTestCRCValue = 0xdcbc59fa;\n+\n+  return port::AcceleratedCRC32C(0, kTestCRCBuffer, kBufSize) == kTestCRCValue;\n+}\n+\n uint32_t Extend(uint32_t crc, const char* buf, size_t size) {\n+  static bool accelerate = CanAccelerateCRC32C();\n+  if (accelerate) {\n+    return port::AcceleratedCRC32C(crc, buf, size);\n+  }\n+\n   const uint8_t *p = reinterpret_cast<const uint8_t *>(buf);\n   const uint8_t *e = p + size;\n   uint32_t l = crc ^ 0xffffffffu;"
      },
      {
        "sha": "dd852af354c83d7d4839fa1e2a3b55824b4ae43c",
        "filename": "src/leveldb/util/env_posix.cc",
        "status": "modified",
        "additions": 136,
        "deletions": 59,
        "changes": 195,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/util/env_posix.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/util/env_posix.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_posix.cc?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -11,28 +11,85 @@\n #include <stdlib.h>\n #include <string.h>\n #include <sys/mman.h>\n+#include <sys/resource.h>\n #include <sys/stat.h>\n #include <sys/time.h>\n #include <sys/types.h>\n #include <time.h>\n #include <unistd.h>\n #include <deque>\n+#include <limits>\n #include <set>\n #include \"leveldb/env.h\"\n #include \"leveldb/slice.h\"\n #include \"port/port.h\"\n #include \"util/logging.h\"\n #include \"util/mutexlock.h\"\n #include \"util/posix_logger.h\"\n+#include \"util/env_posix_test_helper.h\"\n \n namespace leveldb {\n \n namespace {\n \n+static int open_read_only_file_limit = -1;\n+static int mmap_limit = -1;\n+\n static Status IOError(const std::string& context, int err_number) {\n   return Status::IOError(context, strerror(err_number));\n }\n \n+// Helper class to limit resource usage to avoid exhaustion.\n+// Currently used to limit read-only file descriptors and mmap file usage\n+// so that we do not end up running out of file descriptors, virtual memory,\n+// or running into kernel performance problems for very large databases.\n+class Limiter {\n+ public:\n+  // Limit maximum number of resources to |n|.\n+  Limiter(intptr_t n) {\n+    SetAllowed(n);\n+  }\n+\n+  // If another resource is available, acquire it and return true.\n+  // Else return false.\n+  bool Acquire() {\n+    if (GetAllowed() <= 0) {\n+      return false;\n+    }\n+    MutexLock l(&mu_);\n+    intptr_t x = GetAllowed();\n+    if (x <= 0) {\n+      return false;\n+    } else {\n+      SetAllowed(x - 1);\n+      return true;\n+    }\n+  }\n+\n+  // Release a resource acquired by a previous call to Acquire() that returned\n+  // true.\n+  void Release() {\n+    MutexLock l(&mu_);\n+    SetAllowed(GetAllowed() + 1);\n+  }\n+\n+ private:\n+  port::Mutex mu_;\n+  port::AtomicPointer allowed_;\n+\n+  intptr_t GetAllowed() const {\n+    return reinterpret_cast<intptr_t>(allowed_.Acquire_Load());\n+  }\n+\n+  // REQUIRES: mu_ must be held\n+  void SetAllowed(intptr_t v) {\n+    allowed_.Release_Store(reinterpret_cast<void*>(v));\n+  }\n+\n+  Limiter(const Limiter&);\n+  void operator=(const Limiter&);\n+};\n+\n class PosixSequentialFile: public SequentialFile {\n  private:\n   std::string filename_;\n@@ -70,73 +127,51 @@ class PosixSequentialFile: public SequentialFile {\n class PosixRandomAccessFile: public RandomAccessFile {\n  private:\n   std::string filename_;\n+  bool temporary_fd_;  // If true, fd_ is -1 and we open on every read.\n   int fd_;\n+  Limiter* limiter_;\n \n  public:\n-  PosixRandomAccessFile(const std::string& fname, int fd)\n-      : filename_(fname), fd_(fd) { }\n-  virtual ~PosixRandomAccessFile() { close(fd_); }\n+  PosixRandomAccessFile(const std::string& fname, int fd, Limiter* limiter)\n+      : filename_(fname), fd_(fd), limiter_(limiter) {\n+    temporary_fd_ = !limiter->Acquire();\n+    if (temporary_fd_) {\n+      // Open file on every access.\n+      close(fd_);\n+      fd_ = -1;\n+    }\n+  }\n+\n+  virtual ~PosixRandomAccessFile() {\n+    if (!temporary_fd_) {\n+      close(fd_);\n+      limiter_->Release();\n+    }\n+  }\n \n   virtual Status Read(uint64_t offset, size_t n, Slice* result,\n                       char* scratch) const {\n+    int fd = fd_;\n+    if (temporary_fd_) {\n+      fd = open(filename_.c_str(), O_RDONLY);\n+      if (fd < 0) {\n+        return IOError(filename_, errno);\n+      }\n+    }\n+\n     Status s;\n-    ssize_t r = pread(fd_, scratch, n, static_cast<off_t>(offset));\n+    ssize_t r = pread(fd, scratch, n, static_cast<off_t>(offset));\n     *result = Slice(scratch, (r < 0) ? 0 : r);\n     if (r < 0) {\n       // An error: return a non-ok status\n       s = IOError(filename_, errno);\n     }\n-    return s;\n-  }\n-};\n-\n-// Helper class to limit mmap file usage so that we do not end up\n-// running out virtual memory or running into kernel performance\n-// problems for very large databases.\n-class MmapLimiter {\n- public:\n-  // Up to 1000 mmaps for 64-bit binaries; none for smaller pointer sizes.\n-  MmapLimiter() {\n-    SetAllowed(sizeof(void*) >= 8 ? 1000 : 0);\n-  }\n-\n-  // If another mmap slot is available, acquire it and return true.\n-  // Else return false.\n-  bool Acquire() {\n-    if (GetAllowed() <= 0) {\n-      return false;\n-    }\n-    MutexLock l(&mu_);\n-    intptr_t x = GetAllowed();\n-    if (x <= 0) {\n-      return false;\n-    } else {\n-      SetAllowed(x - 1);\n-      return true;\n+    if (temporary_fd_) {\n+      // Close the temporary file descriptor opened earlier.\n+      close(fd);\n     }\n+    return s;\n   }\n-\n-  // Release a slot acquired by a previous call to Acquire() that returned true.\n-  void Release() {\n-    MutexLock l(&mu_);\n-    SetAllowed(GetAllowed() + 1);\n-  }\n-\n- private:\n-  port::Mutex mu_;\n-  port::AtomicPointer allowed_;\n-\n-  intptr_t GetAllowed() const {\n-    return reinterpret_cast<intptr_t>(allowed_.Acquire_Load());\n-  }\n-\n-  // REQUIRES: mu_ must be held\n-  void SetAllowed(intptr_t v) {\n-    allowed_.Release_Store(reinterpret_cast<void*>(v));\n-  }\n-\n-  MmapLimiter(const MmapLimiter&);\n-  void operator=(const MmapLimiter&);\n };\n \n // mmap() based random-access\n@@ -145,12 +180,12 @@ class PosixMmapReadableFile: public RandomAccessFile {\n   std::string filename_;\n   void* mmapped_region_;\n   size_t length_;\n-  MmapLimiter* limiter_;\n+  Limiter* limiter_;\n \n  public:\n   // base[0,length-1] contains the mmapped contents of the file.\n   PosixMmapReadableFile(const std::string& fname, void* base, size_t length,\n-                        MmapLimiter* limiter)\n+                        Limiter* limiter)\n       : filename_(fname), mmapped_region_(base), length_(length),\n         limiter_(limiter) {\n   }\n@@ -231,7 +266,7 @@ class PosixWritableFile : public WritableFile {\n       if (fd < 0) {\n         s = IOError(dir, errno);\n       } else {\n-        if (fsync(fd) < 0) {\n+        if (fsync(fd) < 0 && errno != EINVAL) {\n           s = IOError(dir, errno);\n         }\n         close(fd);\n@@ -333,7 +368,7 @@ class PosixEnv : public Env {\n         mmap_limit_.Release();\n       }\n     } else {\n-      *result = new PosixRandomAccessFile(fname, fd);\n+      *result = new PosixRandomAccessFile(fname, fd, &fd_limit_);\n     }\n     return s;\n   }\n@@ -533,10 +568,42 @@ class PosixEnv : public Env {\n   BGQueue queue_;\n \n   PosixLockTable locks_;\n-  MmapLimiter mmap_limit_;\n+  Limiter mmap_limit_;\n+  Limiter fd_limit_;\n };\n \n-PosixEnv::PosixEnv() : started_bgthread_(false) {\n+// Return the maximum number of concurrent mmaps.\n+static int MaxMmaps() {\n+  if (mmap_limit >= 0) {\n+    return mmap_limit;\n+  }\n+  // Up to 1000 mmaps for 64-bit binaries; none for smaller pointer sizes.\n+  mmap_limit = sizeof(void*) >= 8 ? 1000 : 0;\n+  return mmap_limit;\n+}\n+\n+// Return the maximum number of read-only files to keep open.\n+static intptr_t MaxOpenFiles() {\n+  if (open_read_only_file_limit >= 0) {\n+    return open_read_only_file_limit;\n+  }\n+  struct rlimit rlim;\n+  if (getrlimit(RLIMIT_NOFILE, &rlim)) {\n+    // getrlimit failed, fallback to hard-coded default.\n+    open_read_only_file_limit = 50;\n+  } else if (rlim.rlim_cur == RLIM_INFINITY) {\n+    open_read_only_file_limit = std::numeric_limits<int>::max();\n+  } else {\n+    // Allow use of 20% of available file descriptors for read-only files.\n+    open_read_only_file_limit = rlim.rlim_cur / 5;\n+  }\n+  return open_read_only_file_limit;\n+}\n+\n+PosixEnv::PosixEnv()\n+    : started_bgthread_(false),\n+      mmap_limit_(MaxMmaps()),\n+      fd_limit_(MaxOpenFiles()) {\n   PthreadCall(\"mutex_init\", pthread_mutex_init(&mu_, NULL));\n   PthreadCall(\"cvar_init\", pthread_cond_init(&bgsignal_, NULL));\n }\n@@ -611,6 +678,16 @@ static pthread_once_t once = PTHREAD_ONCE_INIT;\n static Env* default_env;\n static void InitDefaultEnv() { default_env = new PosixEnv; }\n \n+void EnvPosixTestHelper::SetReadOnlyFDLimit(int limit) {\n+  assert(default_env == NULL);\n+  open_read_only_file_limit = limit;\n+}\n+\n+void EnvPosixTestHelper::SetReadOnlyMMapLimit(int limit) {\n+  assert(default_env == NULL);\n+  mmap_limit = limit;\n+}\n+\n Env* Env::Default() {\n   pthread_once(&once, InitDefaultEnv);\n   return default_env;"
      },
      {
        "sha": "295f8ae4409f2a156c4e298cce4d6c8311e1e1b1",
        "filename": "src/leveldb/util/env_posix_test.cc",
        "status": "added",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/util/env_posix_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/util/env_posix_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_posix_test.cc?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -0,0 +1,66 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"leveldb/env.h\"\n+\n+#include \"port/port.h\"\n+#include \"util/testharness.h\"\n+#include \"util/env_posix_test_helper.h\"\n+\n+namespace leveldb {\n+\n+static const int kDelayMicros = 100000;\n+static const int kReadOnlyFileLimit = 4;\n+static const int kMMapLimit = 4;\n+\n+class EnvPosixTest {\n+ public:\n+  Env* env_;\n+  EnvPosixTest() : env_(Env::Default()) { }\n+\n+  static void SetFileLimits(int read_only_file_limit, int mmap_limit) {\n+    EnvPosixTestHelper::SetReadOnlyFDLimit(read_only_file_limit);\n+    EnvPosixTestHelper::SetReadOnlyMMapLimit(mmap_limit);\n+  }\n+};\n+\n+TEST(EnvPosixTest, TestOpenOnRead) {\n+  // Write some test data to a single file that will be opened |n| times.\n+  std::string test_dir;\n+  ASSERT_OK(env_->GetTestDirectory(&test_dir));\n+  std::string test_file = test_dir + \"/open_on_read.txt\";\n+\n+  FILE* f = fopen(test_file.c_str(), \"w\");\n+  ASSERT_TRUE(f != NULL);\n+  const char kFileData[] = \"abcdefghijklmnopqrstuvwxyz\";\n+  fputs(kFileData, f);\n+  fclose(f);\n+\n+  // Open test file some number above the sum of the two limits to force\n+  // open-on-read behavior of POSIX Env leveldb::RandomAccessFile.\n+  const int kNumFiles = kReadOnlyFileLimit + kMMapLimit + 5;\n+  leveldb::RandomAccessFile* files[kNumFiles] = {0};\n+  for (int i = 0; i < kNumFiles; i++) {\n+    ASSERT_OK(env_->NewRandomAccessFile(test_file, &files[i]));\n+  }\n+  char scratch;\n+  Slice read_result;\n+  for (int i = 0; i < kNumFiles; i++) {\n+    ASSERT_OK(files[i]->Read(i, 1, &read_result, &scratch));\n+    ASSERT_EQ(kFileData[i], read_result[0]);\n+  }\n+  for (int i = 0; i < kNumFiles; i++) {\n+    delete files[i];\n+  }\n+  ASSERT_OK(env_->DeleteFile(test_file));\n+}\n+\n+}  // namespace leveldb\n+\n+int main(int argc, char** argv) {\n+  // All tests currently run with the same read-only file limits.\n+  leveldb::EnvPosixTest::SetFileLimits(leveldb::kReadOnlyFileLimit,\n+                                       leveldb::kMMapLimit);\n+  return leveldb::test::RunAllTests();\n+}"
      },
      {
        "sha": "038696059826042f57808b58505c7f4339c54337",
        "filename": "src/leveldb/util/env_posix_test_helper.h",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/util/env_posix_test_helper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/util/env_posix_test_helper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_posix_test_helper.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_UTIL_ENV_POSIX_TEST_HELPER_H_\n+#define STORAGE_LEVELDB_UTIL_ENV_POSIX_TEST_HELPER_H_\n+\n+namespace leveldb {\n+\n+class EnvPosixTest;\n+\n+// A helper for the POSIX Env to facilitate testing.\n+class EnvPosixTestHelper {\n+ private:\n+  friend class EnvPosixTest;\n+\n+  // Set the maximum number of read-only files that will be opened.\n+  // Must be called before creating an Env.\n+  static void SetReadOnlyFDLimit(int limit);\n+\n+  // Set the maximum number of read-only files that will be mapped via mmap.\n+  // Must be called before creating an Env.\n+  static void SetReadOnlyMMapLimit(int limit);\n+};\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_UTIL_ENV_POSIX_TEST_HELPER_H_"
      },
      {
        "sha": "839ae56a1a49c1b4d60562eca2707d2053ab1236",
        "filename": "src/leveldb/util/env_test.cc",
        "status": "modified",
        "additions": 10,
        "deletions": 8,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/util/env_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/util/env_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_test.cc?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -10,29 +10,31 @@\n namespace leveldb {\n \n static const int kDelayMicros = 100000;\n+static const int kReadOnlyFileLimit = 4;\n+static const int kMMapLimit = 4;\n \n-class EnvPosixTest {\n+class EnvTest {\n  private:\n   port::Mutex mu_;\n   std::string events_;\n \n  public:\n   Env* env_;\n-  EnvPosixTest() : env_(Env::Default()) { }\n+  EnvTest() : env_(Env::Default()) { }\n };\n \n static void SetBool(void* ptr) {\n   reinterpret_cast<port::AtomicPointer*>(ptr)->NoBarrier_Store(ptr);\n }\n \n-TEST(EnvPosixTest, RunImmediately) {\n+TEST(EnvTest, RunImmediately) {\n   port::AtomicPointer called (NULL);\n   env_->Schedule(&SetBool, &called);\n-  Env::Default()->SleepForMicroseconds(kDelayMicros);\n+  env_->SleepForMicroseconds(kDelayMicros);\n   ASSERT_TRUE(called.NoBarrier_Load() != NULL);\n }\n \n-TEST(EnvPosixTest, RunMany) {\n+TEST(EnvTest, RunMany) {\n   port::AtomicPointer last_id (NULL);\n \n   struct CB {\n@@ -59,7 +61,7 @@ TEST(EnvPosixTest, RunMany) {\n   env_->Schedule(&CB::Run, &cb3);\n   env_->Schedule(&CB::Run, &cb4);\n \n-  Env::Default()->SleepForMicroseconds(kDelayMicros);\n+  env_->SleepForMicroseconds(kDelayMicros);\n   void* cur = last_id.Acquire_Load();\n   ASSERT_EQ(4, reinterpret_cast<uintptr_t>(cur));\n }\n@@ -78,7 +80,7 @@ static void ThreadBody(void* arg) {\n   s->mu.Unlock();\n }\n \n-TEST(EnvPosixTest, StartThread) {\n+TEST(EnvTest, StartThread) {\n   State state;\n   state.val = 0;\n   state.num_running = 3;\n@@ -92,7 +94,7 @@ TEST(EnvPosixTest, StartThread) {\n     if (num == 0) {\n       break;\n     }\n-    Env::Default()->SleepForMicroseconds(kDelayMicros);\n+    env_->SleepForMicroseconds(kDelayMicros);\n   }\n   ASSERT_EQ(state.val, 3);\n }"
      },
      {
        "sha": "d32c4e676c3fcd6dd29394298f541832032ef1a7",
        "filename": "src/leveldb/util/env_win.cc",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/util/env_win.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/util/env_win.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_win.cc?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -1,7 +1,7 @@\n // This file contains source that originates from:\n // http://code.google.com/p/leveldbwin/source/browse/trunk/win32_impl_src/env_win32.h\n // http://code.google.com/p/leveldbwin/source/browse/trunk/win32_impl_src/port_win32.cc\n-// Those files dont' have any explict license headers but the \n+// Those files don't have any explicit license headers but the \n // project (http://code.google.com/p/leveldbwin/) lists the 'New BSD License'\n // as the license.\n #if defined(LEVELDB_PLATFORM_WINDOWS)\n@@ -355,11 +355,13 @@ BOOL Win32SequentialFile::_Init()\n \tToWidePath(_filename, path);\n \t_hFile = CreateFileW(path.c_str(),\n                          GENERIC_READ,\n-                         FILE_SHARE_READ,\n+                         FILE_SHARE_READ | FILE_SHARE_WRITE,\n                          NULL,\n                          OPEN_EXISTING,\n-                         FILE_ATTRIBUTE_NORMAL,\n+                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,\n                          NULL);\n+    if (_hFile == INVALID_HANDLE_VALUE)\n+        _hFile = NULL;\n     return _hFile ? TRUE : FALSE;\n }\n \n@@ -403,7 +405,7 @@ BOOL Win32RandomAccessFile::_Init( LPCWSTR path )\n {\n     BOOL bRet = FALSE;\n     if(!_hFile)\n-        _hFile = ::CreateFileW(path,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,\n+        _hFile = ::CreateFileW(path,GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,\n         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,NULL);\n     if(!_hFile || _hFile == INVALID_HANDLE_VALUE )\n         _hFile = NULL;\n@@ -669,7 +671,7 @@ Status Win32Env::GetFileSize( const std::string& fname, uint64_t* file_size )\n \tToWidePath(ModifyPath(path), wpath);\n \n     HANDLE file = ::CreateFileW(wpath.c_str(),\n-        GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);\n+        GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);\n     LARGE_INTEGER li;\n     if(::GetFileSizeEx(file,&li)){\n         *file_size = (uint64_t)li.QuadPart;"
      },
      {
        "sha": "db6160c8f19929e9517e371ba2295e0d0e38e421",
        "filename": "src/leveldb/util/logging.cc",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/util/logging.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/util/logging.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/logging.cc?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -49,7 +49,7 @@ bool ConsumeDecimalNumber(Slice* in, uint64_t* val) {\n   uint64_t v = 0;\n   int digits = 0;\n   while (!in->empty()) {\n-    char c = (*in)[0];\n+    unsigned char c = (*in)[0];\n     if (c >= '0' && c <= '9') {\n       ++digits;\n       const int delta = (c - '0');"
      },
      {
        "sha": "b5e622761357cfa3efb72d01facfd33339d4ce8e",
        "filename": "src/leveldb/util/options.cc",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/util/options.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/leveldb/util/options.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/options.cc?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -21,6 +21,7 @@ Options::Options()\n       block_cache(NULL),\n       block_size(4096),\n       block_restart_interval(16),\n+      max_file_size(2<<20),\n       compression(kSnappyCompression),\n       reuse_logs(false),\n       filter_policy(NULL) {"
      },
      {
        "sha": "93fd6a0eb5b30c1e73cccb2fe4e0644be2f455af",
        "filename": "src/memusage.h",
        "status": "modified",
        "additions": 7,
        "deletions": 10,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/memusage.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -12,10 +12,9 @@\n #include <map>\n #include <set>\n #include <vector>\n+#include <unordered_map>\n+#include <unordered_set>\n \n-#include <boost/foreach.hpp>\n-#include <boost/unordered_set.hpp>\n-#include <boost/unordered_map.hpp>\n \n namespace memusage\n {\n@@ -146,25 +145,23 @@ static inline size_t DynamicUsage(const std::shared_ptr<X>& p)\n     return p ? MallocUsage(sizeof(X)) + MallocUsage(sizeof(stl_shared_counter)) : 0;\n }\n \n-// Boost data structures\n-\n template<typename X>\n-struct boost_unordered_node : private X\n+struct unordered_node : private X\n {\n private:\n     void* ptr;\n };\n \n template<typename X, typename Y>\n-static inline size_t DynamicUsage(const boost::unordered_set<X, Y>& s)\n+static inline size_t DynamicUsage(const std::unordered_set<X, Y>& s)\n {\n-    return MallocUsage(sizeof(boost_unordered_node<X>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n+    return MallocUsage(sizeof(unordered_node<X>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n }\n \n template<typename X, typename Y, typename Z>\n-static inline size_t DynamicUsage(const boost::unordered_map<X, Y, Z>& m)\n+static inline size_t DynamicUsage(const std::unordered_map<X, Y, Z>& m)\n {\n-    return MallocUsage(sizeof(boost_unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n+    return MallocUsage(sizeof(unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n }\n \n }"
      },
      {
        "sha": "f0abea0611b9314c2e150bc8382bdd08172e786f",
        "filename": "src/merkleblock.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/merkleblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/merkleblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/merkleblock.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -59,13 +59,16 @@ CMerkleBlock::CMerkleBlock(const CBlock& block, const std::set<uint256>& txids)\n }\n \n uint256 CPartialMerkleTree::CalcHash(int height, unsigned int pos, const std::vector<uint256> &vTxid) {\n+    //we can never have zero txs in a merkle block, we always need the coinbase tx\n+    //if we do not have this assert, we can hit a memory access violation when indexing into vTxid\n+    assert(vTxid.size() != 0);\n     if (height == 0) {\n         // hash at height 0 is the txids themself\n         return vTxid[pos];\n     } else {\n         // calculate left hash\n         uint256 left = CalcHash(height-1, pos*2, vTxid), right;\n-        // calculate right hash if not beyond the end of the array - copy left hash otherwise1\n+        // calculate right hash if not beyond the end of the array - copy left hash otherwise\n         if (pos*2+1 < CalcTreeWidth(height-1))\n             right = CalcHash(height-1, pos*2+1, vTxid);\n         else\n@@ -153,7 +156,7 @@ uint256 CPartialMerkleTree::ExtractMatches(std::vector<uint256> &vMatch, std::ve\n     if (nTransactions == 0)\n         return uint256();\n     // check for excessively high numbers of transactions\n-    if (nTransactions > MAX_BLOCK_BASE_SIZE / 60) // 60 is the lower bound for the size of a serialized CTransaction\n+    if (nTransactions > MAX_BLOCK_WEIGHT / MIN_TRANSACTION_WEIGHT)\n         return uint256();\n     // there can never be more hashes provided than one for every txid\n     if (vHash.size() > nTransactions)"
      },
      {
        "sha": "f590c487dee0f70d668cf725ffa38560b80a6827",
        "filename": "src/merkleblock.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/merkleblock.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/merkleblock.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/merkleblock.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -23,7 +23,7 @@\n  * storing a bit for each traversed node, signifying whether the node is the\n  * parent of at least one matched leaf txid (or a matched txid itself). In\n  * case we are at the leaf level, or this bit is 0, its merkle node hash is\n- * stored, and its children are not explorer further. Otherwise, no hash is\n+ * stored, and its children are not explored further. Otherwise, no hash is\n  * stored, but we recurse into both (or the only) child branch. During\n  * decoding, the same depth-first traversal is performed, consuming bits and\n  * hashes as they written during encoding.\n@@ -121,6 +121,8 @@ class CPartialMerkleTree\n /**\n  * Used to relay blocks as header + vector<merkle branch>\n  * to filtered nodes.\n+ *\n+ * NOTE: The class assumes that the given CBlock has *at least* 1 transaction. If the CBlock has 0 txs, it will hit an assertion.\n  */\n class CMerkleBlock\n {"
      },
      {
        "sha": "79016bfd3eef4e13297f52749432c3955e5cbe52",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -10,11 +10,13 @@\n #include \"chainparams.h\"\n #include \"coins.h\"\n #include \"consensus/consensus.h\"\n+#include \"consensus/tx_verify.h\"\n #include \"consensus/merkle.h\"\n #include \"consensus/validation.h\"\n #include \"hash.h\"\n #include \"validation.h\"\n #include \"net.h\"\n+#include \"policy/feerate.h\"\n #include \"policy/policy.h\"\n #include \"pow.h\"\n #include \"primitives/transaction.h\"\n@@ -240,7 +242,7 @@ bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost\n bool BlockAssembler::TestPackageTransactions(const CTxMemPool::setEntries& package)\n {\n     uint64_t nPotentialBlockSize = nBlockSize; // only used with fNeedSizeAccounting\n-    BOOST_FOREACH (const CTxMemPool::txiter it, package) {\n+    for (const CTxMemPool::txiter it : package) {\n         if (!IsFinalTx(it->GetTx(), nHeight, nLockTimeCutoff))\n             return false;\n         if (!fIncludeWitness && it->GetTx().HasWitness())\n@@ -282,11 +284,11 @@ int BlockAssembler::UpdatePackagesForAdded(const CTxMemPool::setEntries& already\n         indexed_modified_transaction_set &mapModifiedTx)\n {\n     int nDescendantsUpdated = 0;\n-    BOOST_FOREACH(const CTxMemPool::txiter it, alreadyAdded) {\n+    for (const CTxMemPool::txiter it : alreadyAdded) {\n         CTxMemPool::setEntries descendants;\n         mempool.CalculateDescendants(it, descendants);\n         // Insert all descendants (not yet in block) into the modified set\n-        BOOST_FOREACH(CTxMemPool::txiter desc, descendants) {\n+        for (CTxMemPool::txiter desc : descendants) {\n             if (alreadyAdded.count(desc))\n                 continue;\n             ++nDescendantsUpdated;\n@@ -317,9 +319,7 @@ int BlockAssembler::UpdatePackagesForAdded(const CTxMemPool::setEntries& already\n bool BlockAssembler::SkipMapTxEntry(CTxMemPool::txiter it, indexed_modified_transaction_set &mapModifiedTx, CTxMemPool::setEntries &failedTx)\n {\n     assert (it != mempool.mapTx.end());\n-    if (mapModifiedTx.count(it) || inBlock.count(it) || failedTx.count(it))\n-        return true;\n-    return false;\n+    return mapModifiedTx.count(it) || inBlock.count(it) || failedTx.count(it);\n }\n \n void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, CTxMemPool::txiter entry, std::vector<CTxMemPool::txiter>& sortedEntries)"
      },
      {
        "sha": "5c9cfd78f0444a0a661a4ee7ef78a6910c39d3d5",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -16,9 +16,7 @@\n \n class CBlockIndex;\n class CChainParams;\n-class CReserveKey;\n class CScript;\n-class CWallet;\n \n namespace Consensus { struct Params; };\n "
      },
      {
        "sha": "ca9a173abe7c38b84135694ccdd21f3c2f751302",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 234,
        "deletions": 180,
        "changes": 414,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -64,6 +64,14 @@\n #endif\n #endif\n \n+/** Used to pass flags to the Bind() function */\n+enum BindFlags {\n+    BF_NONE         = 0,\n+    BF_EXPLICIT     = (1U << 0),\n+    BF_REPORT_ERROR = (1U << 1),\n+    BF_WHITELIST    = (1U << 2),\n+};\n+\n const static std::string NET_MESSAGE_COMMAND_OTHER = \"*other*\";\n \n static const uint64_t RANDOMIZER_ID_NETGROUP = 0x6c0edd8036ef4036ULL; // SHA256(\"netgroup\")[0:8]\n@@ -148,7 +156,7 @@ static std::vector<CAddress> convertSeed6(const std::vector<SeedSpec6> &vSeedsIn\n // one by discovery.\n CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices)\n {\n-    CAddress ret(CService(CNetAddr(),GetListenPort()), NODE_NONE);\n+    CAddress ret(CService(CNetAddr(),GetListenPort()), nLocalServices);\n     CService addr;\n     if (GetLocal(addr, paddrPeer))\n     {\n@@ -240,7 +248,7 @@ bool RemoveLocal(const CService& addr)\n /** Make a particular network entirely off-limits (no automatic connects to it) */\n void SetLimited(enum Network net, bool fLimited)\n {\n-    if (net == NET_UNROUTABLE)\n+    if (net == NET_UNROUTABLE || net == NET_INTERNAL)\n         return;\n     LOCK(cs_mapLocalHost);\n     vfLimited[net] = fLimited;\n@@ -295,7 +303,7 @@ bool IsReachable(const CNetAddr& addr)\n CNode* CConnman::FindNode(const CNetAddr& ip)\n {\n     LOCK(cs_vNodes);\n-    BOOST_FOREACH(CNode* pnode, vNodes)\n+    for (CNode* pnode : vNodes)\n         if ((CNetAddr)pnode->addr == ip)\n             return (pnode);\n     return NULL;\n@@ -304,7 +312,7 @@ CNode* CConnman::FindNode(const CNetAddr& ip)\n CNode* CConnman::FindNode(const CSubNet& subNet)\n {\n     LOCK(cs_vNodes);\n-    BOOST_FOREACH(CNode* pnode, vNodes)\n+    for (CNode* pnode : vNodes)\n     if (subNet.Match((CNetAddr)pnode->addr))\n         return (pnode);\n     return NULL;\n@@ -313,7 +321,7 @@ CNode* CConnman::FindNode(const CSubNet& subNet)\n CNode* CConnman::FindNode(const std::string& addrName)\n {\n     LOCK(cs_vNodes);\n-    BOOST_FOREACH(CNode* pnode, vNodes) {\n+    for (CNode* pnode : vNodes) {\n         if (pnode->GetAddrName() == addrName) {\n             return (pnode);\n         }\n@@ -324,7 +332,7 @@ CNode* CConnman::FindNode(const std::string& addrName)\n CNode* CConnman::FindNode(const CService& addr)\n {\n     LOCK(cs_vNodes);\n-    BOOST_FOREACH(CNode* pnode, vNodes)\n+    for (CNode* pnode : vNodes)\n         if ((CService)pnode->addr == addr)\n             return (pnode);\n     return NULL;\n@@ -333,13 +341,29 @@ CNode* CConnman::FindNode(const CService& addr)\n bool CConnman::CheckIncomingNonce(uint64_t nonce)\n {\n     LOCK(cs_vNodes);\n-    BOOST_FOREACH(CNode* pnode, vNodes) {\n+    for (CNode* pnode : vNodes) {\n         if (!pnode->fSuccessfullyConnected && !pnode->fInbound && pnode->GetLocalNonce() == nonce)\n             return false;\n     }\n     return true;\n }\n \n+/** Get the bind address for a socket as CAddress */\n+static CAddress GetBindAddress(SOCKET sock)\n+{\n+    CAddress addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (sock != INVALID_SOCKET) {\n+        if (!getsockname(sock, (struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+            addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);\n+        } else {\n+            LogPrint(BCLog::NET, \"Warning: getsockname failed\\n\");\n+        }\n+    }\n+    return addr_bind;\n+}\n+\n CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure)\n {\n     if (pszDest == NULL) {\n@@ -393,7 +417,8 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n         // Add node\n         NodeId id = GetNewNodeId();\n         uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();\n-        CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addrConnect, CalculateKeyedNetGroup(addrConnect), nonce, pszDest ? pszDest : \"\", false);\n+        CAddress addr_bind = GetBindAddress(hSocket);\n+        CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addrConnect, CalculateKeyedNetGroup(addrConnect), nonce, addr_bind, pszDest ? pszDest : \"\", false);\n         pnode->nServicesExpected = ServiceFlags(addrConnect.nServices & nRelevantServices);\n         pnode->AddRef();\n \n@@ -418,10 +443,10 @@ void CConnman::DumpBanlist()\n \n     CBanDB bandb;\n     banmap_t banmap;\n-    SetBannedSetDirty(false);\n     GetBanned(banmap);\n-    if (!bandb.Write(banmap))\n-        SetBannedSetDirty(true);\n+    if (bandb.Write(banmap)) {\n+        SetBannedSetDirty(false);\n+    }\n \n     LogPrint(BCLog::NET, \"Flushed %d banned node ips/subnets to banlist.dat  %dms\\n\",\n         banmap.size(), GetTimeMillis() - nStart);\n@@ -452,35 +477,31 @@ void CConnman::ClearBanned()\n \n bool CConnman::IsBanned(CNetAddr ip)\n {\n-    bool fResult = false;\n+    LOCK(cs_setBanned);\n+    for (banmap_t::iterator it = setBanned.begin(); it != setBanned.end(); it++)\n     {\n-        LOCK(cs_setBanned);\n-        for (banmap_t::iterator it = setBanned.begin(); it != setBanned.end(); it++)\n-        {\n-            CSubNet subNet = (*it).first;\n-            CBanEntry banEntry = (*it).second;\n+        CSubNet subNet = (*it).first;\n+        CBanEntry banEntry = (*it).second;\n \n-            if(subNet.Match(ip) && GetTime() < banEntry.nBanUntil)\n-                fResult = true;\n+        if (subNet.Match(ip) && GetTime() < banEntry.nBanUntil) {\n+            return true;\n         }\n     }\n-    return fResult;\n+    return false;\n }\n \n bool CConnman::IsBanned(CSubNet subnet)\n {\n-    bool fResult = false;\n+    LOCK(cs_setBanned);\n+    banmap_t::iterator i = setBanned.find(subnet);\n+    if (i != setBanned.end())\n     {\n-        LOCK(cs_setBanned);\n-        banmap_t::iterator i = setBanned.find(subnet);\n-        if (i != setBanned.end())\n-        {\n-            CBanEntry banEntry = (*i).second;\n-            if (GetTime() < banEntry.nBanUntil)\n-                fResult = true;\n+        CBanEntry banEntry = (*i).second;\n+        if (GetTime() < banEntry.nBanUntil) {\n+            return true;\n         }\n     }\n-    return fResult;\n+    return false;\n }\n \n void CConnman::Ban(const CNetAddr& addr, const BanReason &banReason, int64_t bantimeoffset, bool sinceUnixEpoch) {\n@@ -511,7 +532,7 @@ void CConnman::Ban(const CSubNet& subNet, const BanReason &banReason, int64_t ba\n         clientInterface->BannedListChanged();\n     {\n         LOCK(cs_vNodes);\n-        BOOST_FOREACH(CNode* pnode, vNodes) {\n+        for (CNode* pnode : vNodes) {\n             if (subNet.Match((CNetAddr)pnode->addr))\n                 pnode->fDisconnect = true;\n         }\n@@ -541,6 +562,8 @@ bool CConnman::Unban(const CSubNet &subNet) {\n void CConnman::GetBanned(banmap_t &banMap)\n {\n     LOCK(cs_setBanned);\n+    // Sweep the banlist so expired bans are not returned\n+    SweepBanned();\n     banMap = setBanned; //create a thread safe copy\n }\n \n@@ -586,20 +609,13 @@ void CConnman::SetBannedSetDirty(bool dirty)\n \n \n bool CConnman::IsWhitelistedRange(const CNetAddr &addr) {\n-    LOCK(cs_vWhitelistedRange);\n-    BOOST_FOREACH(const CSubNet& subnet, vWhitelistedRange) {\n+    for (const CSubNet& subnet : vWhitelistedRange) {\n         if (subnet.Match(addr))\n             return true;\n     }\n     return false;\n }\n \n-void CConnman::AddWhitelistedRange(const CSubNet &subnet) {\n-    LOCK(cs_vWhitelistedRange);\n-    vWhitelistedRange.push_back(subnet);\n-}\n-\n-\n std::string CNode::GetAddrName() const {\n     LOCK(cs_addrName);\n     return addrName;\n@@ -633,6 +649,7 @@ void CNode::copyStats(CNodeStats &stats)\n     stats.nodeid = this->GetId();\n     X(nServices);\n     X(addr);\n+    X(addrBind);\n     {\n         LOCK(cs_filter);\n         X(fRelayTxes);\n@@ -708,7 +725,7 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes, bool& complete\n             handled = msg.readData(pch, nBytes);\n \n         if (handled < 0)\n-                return false;\n+            return false;\n \n         if (msg.in_data && msg.hdr.nMessageSize > MAX_PROTOCOL_MESSAGE_LENGTH) {\n             LogPrint(BCLog::NET, \"Oversized message from peer=%i, disconnecting\\n\", GetId());\n@@ -786,7 +803,7 @@ int CNetMessage::readHeader(const char *pch, unsigned int nBytes)\n \n     // reject messages larger than MAX_SIZE\n     if (hdr.nMessageSize > MAX_SIZE)\n-            return -1;\n+        return -1;\n \n     // switch state to reading message data\n     in_data = true;\n@@ -939,14 +956,14 @@ bool CConnman::AttemptToEvictConnection()\n     {\n         LOCK(cs_vNodes);\n \n-        BOOST_FOREACH(CNode *node, vNodes) {\n+        for (CNode *node : vNodes) {\n             if (node->fWhitelisted)\n                 continue;\n             if (!node->fInbound)\n                 continue;\n             if (node->fDisconnect)\n                 continue;\n-            NodeEvictionCandidate candidate = {node->id, node->nTimeConnected, node->nMinPingUsecTime,\n+            NodeEvictionCandidate candidate = {node->GetId(), node->nTimeConnected, node->nMinPingUsecTime,\n                                                node->nLastBlockTime, node->nLastTXTime,\n                                                (node->nServices & nRelevantServices) == nRelevantServices,\n                                                node->fRelayTxes, node->pfilter != NULL, node->addr, node->nKeyedNetGroup};\n@@ -999,7 +1016,7 @@ bool CConnman::AttemptToEvictConnection()\n     unsigned int nMostConnections = 0;\n     int64_t nMostConnectionsTime = 0;\n     std::map<uint64_t, std::vector<NodeEvictionCandidate> > mapNetGroupNodes;\n-    BOOST_FOREACH(const NodeEvictionCandidate &node, vEvictionCandidates) {\n+    for (const NodeEvictionCandidate &node : vEvictionCandidates) {\n         mapNetGroupNodes[node.nKeyedNetGroup].push_back(node);\n         int64_t grouptime = mapNetGroupNodes[node.nKeyedNetGroup][0].nTimeConnected;\n         size_t groupsize = mapNetGroupNodes[node.nKeyedNetGroup].size();\n@@ -1034,14 +1051,16 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     int nInbound = 0;\n     int nMaxInbound = nMaxConnections - (nMaxOutbound + nMaxFeeler);\n \n-    if (hSocket != INVALID_SOCKET)\n-        if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr))\n+    if (hSocket != INVALID_SOCKET) {\n+        if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr)) {\n             LogPrintf(\"Warning: Unknown socket family\\n\");\n+        }\n+    }\n \n     bool whitelisted = hListenSocket.whitelisted || IsWhitelistedRange(addr);\n     {\n         LOCK(cs_vNodes);\n-        BOOST_FOREACH(CNode* pnode, vNodes)\n+        for (CNode* pnode : vNodes)\n             if (pnode->fInbound)\n                 nInbound++;\n     }\n@@ -1069,12 +1088,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n \n     // According to the internet TCP_NODELAY is not carried into accepted sockets\n     // on all platforms.  Set it again here just to be sure.\n-    int set = 1;\n-#ifdef WIN32\n-    setsockopt(hSocket, IPPROTO_TCP, TCP_NODELAY, (const char*)&set, sizeof(int));\n-#else\n-    setsockopt(hSocket, IPPROTO_TCP, TCP_NODELAY, (void*)&set, sizeof(int));\n-#endif\n+    SetSocketNoDelay(hSocket);\n \n     if (IsBanned(addr) && !whitelisted)\n     {\n@@ -1095,8 +1109,9 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n \n     NodeId id = GetNewNodeId();\n     uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();\n+    CAddress addr_bind = GetBindAddress(hSocket);\n \n-    CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addr, CalculateKeyedNetGroup(addr), nonce, \"\", true);\n+    CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addr, CalculateKeyedNetGroup(addr), nonce, addr_bind, \"\", true);\n     pnode->AddRef();\n     pnode->fWhitelisted = whitelisted;\n     GetNodeSignals().InitializeNode(pnode, *this);\n@@ -1121,7 +1136,7 @@ void CConnman::ThreadSocketHandler()\n             LOCK(cs_vNodes);\n             // Disconnect unused nodes\n             std::vector<CNode*> vNodesCopy = vNodes;\n-            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n+            for (CNode* pnode : vNodesCopy)\n             {\n                 if (pnode->fDisconnect)\n                 {\n@@ -1143,7 +1158,7 @@ void CConnman::ThreadSocketHandler()\n         {\n             // Delete disconnected nodes\n             std::list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n-            BOOST_FOREACH(CNode* pnode, vNodesDisconnectedCopy)\n+            for (CNode* pnode : vNodesDisconnectedCopy)\n             {\n                 // wait until threads are done using it\n                 if (pnode->GetRefCount() <= 0) {\n@@ -1191,15 +1206,15 @@ void CConnman::ThreadSocketHandler()\n         SOCKET hSocketMax = 0;\n         bool have_fds = false;\n \n-        BOOST_FOREACH(const ListenSocket& hListenSocket, vhListenSocket) {\n+        for (const ListenSocket& hListenSocket : vhListenSocket) {\n             FD_SET(hListenSocket.socket, &fdsetRecv);\n             hSocketMax = std::max(hSocketMax, hListenSocket.socket);\n             have_fds = true;\n         }\n \n         {\n             LOCK(cs_vNodes);\n-            BOOST_FOREACH(CNode* pnode, vNodes)\n+            for (CNode* pnode : vNodes)\n             {\n                 // Implement the following logic:\n                 // * If there is data to send, select() for sending data. As this only\n@@ -1260,7 +1275,7 @@ void CConnman::ThreadSocketHandler()\n         //\n         // Accept new connections\n         //\n-        BOOST_FOREACH(const ListenSocket& hListenSocket, vhListenSocket)\n+        for (const ListenSocket& hListenSocket : vhListenSocket)\n         {\n             if (hListenSocket.socket != INVALID_SOCKET && FD_ISSET(hListenSocket.socket, &fdsetRecv))\n             {\n@@ -1275,10 +1290,10 @@ void CConnman::ThreadSocketHandler()\n         {\n             LOCK(cs_vNodes);\n             vNodesCopy = vNodes;\n-            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n+            for (CNode* pnode : vNodesCopy)\n                 pnode->AddRef();\n         }\n-        BOOST_FOREACH(CNode* pnode, vNodesCopy)\n+        for (CNode* pnode : vNodesCopy)\n         {\n             if (interruptNet)\n                 return;\n@@ -1299,59 +1314,55 @@ void CConnman::ThreadSocketHandler()\n             }\n             if (recvSet || errorSet)\n             {\n+                // typical socket buffer is 8K-64K\n+                char pchBuf[0x10000];\n+                int nBytes = 0;\n                 {\n-                    {\n-                        // typical socket buffer is 8K-64K\n-                        char pchBuf[0x10000];\n-                        int nBytes = 0;\n-                        {\n-                            LOCK(pnode->cs_hSocket);\n-                            if (pnode->hSocket == INVALID_SOCKET)\n-                                continue;\n-                            nBytes = recv(pnode->hSocket, pchBuf, sizeof(pchBuf), MSG_DONTWAIT);\n-                        }\n-                        if (nBytes > 0)\n-                        {\n-                            bool notify = false;\n-                            if (!pnode->ReceiveMsgBytes(pchBuf, nBytes, notify))\n-                                pnode->CloseSocketDisconnect();\n-                            RecordBytesRecv(nBytes);\n-                            if (notify) {\n-                                size_t nSizeAdded = 0;\n-                                auto it(pnode->vRecvMsg.begin());\n-                                for (; it != pnode->vRecvMsg.end(); ++it) {\n-                                    if (!it->complete())\n-                                        break;\n-                                    nSizeAdded += it->vRecv.size() + CMessageHeader::HEADER_SIZE;\n-                                }\n-                                {\n-                                    LOCK(pnode->cs_vProcessMsg);\n-                                    pnode->vProcessMsg.splice(pnode->vProcessMsg.end(), pnode->vRecvMsg, pnode->vRecvMsg.begin(), it);\n-                                    pnode->nProcessQueueSize += nSizeAdded;\n-                                    pnode->fPauseRecv = pnode->nProcessQueueSize > nReceiveFloodSize;\n-                                }\n-                                WakeMessageHandler();\n-                            }\n+                    LOCK(pnode->cs_hSocket);\n+                    if (pnode->hSocket == INVALID_SOCKET)\n+                        continue;\n+                    nBytes = recv(pnode->hSocket, pchBuf, sizeof(pchBuf), MSG_DONTWAIT);\n+                }\n+                if (nBytes > 0)\n+                {\n+                    bool notify = false;\n+                    if (!pnode->ReceiveMsgBytes(pchBuf, nBytes, notify))\n+                        pnode->CloseSocketDisconnect();\n+                    RecordBytesRecv(nBytes);\n+                    if (notify) {\n+                        size_t nSizeAdded = 0;\n+                        auto it(pnode->vRecvMsg.begin());\n+                        for (; it != pnode->vRecvMsg.end(); ++it) {\n+                            if (!it->complete())\n+                                break;\n+                            nSizeAdded += it->vRecv.size() + CMessageHeader::HEADER_SIZE;\n                         }\n-                        else if (nBytes == 0)\n                         {\n-                            // socket closed gracefully\n-                            if (!pnode->fDisconnect) {\n-                                LogPrint(BCLog::NET, \"socket closed\\n\");\n-                            }\n-                            pnode->CloseSocketDisconnect();\n-                        }\n-                        else if (nBytes < 0)\n-                        {\n-                            // error\n-                            int nErr = WSAGetLastError();\n-                            if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n-                            {\n-                                if (!pnode->fDisconnect)\n-                                    LogPrintf(\"socket recv error %s\\n\", NetworkErrorString(nErr));\n-                                pnode->CloseSocketDisconnect();\n-                            }\n+                            LOCK(pnode->cs_vProcessMsg);\n+                            pnode->vProcessMsg.splice(pnode->vProcessMsg.end(), pnode->vRecvMsg, pnode->vRecvMsg.begin(), it);\n+                            pnode->nProcessQueueSize += nSizeAdded;\n+                            pnode->fPauseRecv = pnode->nProcessQueueSize > nReceiveFloodSize;\n                         }\n+                        WakeMessageHandler();\n+                    }\n+                }\n+                else if (nBytes == 0)\n+                {\n+                    // socket closed gracefully\n+                    if (!pnode->fDisconnect) {\n+                        LogPrint(BCLog::NET, \"socket closed\\n\");\n+                    }\n+                    pnode->CloseSocketDisconnect();\n+                }\n+                else if (nBytes < 0)\n+                {\n+                    // error\n+                    int nErr = WSAGetLastError();\n+                    if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n+                    {\n+                        if (!pnode->fDisconnect)\n+                            LogPrintf(\"socket recv error %s\\n\", NetworkErrorString(nErr));\n+                        pnode->CloseSocketDisconnect();\n                     }\n                 }\n             }\n@@ -1376,7 +1387,7 @@ void CConnman::ThreadSocketHandler()\n             {\n                 if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n                 {\n-                    LogPrint(BCLog::NET, \"socket no message in first 60 seconds, %d %d from %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0, pnode->id);\n+                    LogPrint(BCLog::NET, \"socket no message in first 60 seconds, %d %d from %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0, pnode->GetId());\n                     pnode->fDisconnect = true;\n                 }\n                 else if (nTime - pnode->nLastSend > TIMEOUT_INTERVAL)\n@@ -1396,14 +1407,14 @@ void CConnman::ThreadSocketHandler()\n                 }\n                 else if (!pnode->fSuccessfullyConnected)\n                 {\n-                    LogPrintf(\"version handshake timeout from %d\\n\", pnode->id);\n+                    LogPrintf(\"version handshake timeout from %d\\n\", pnode->GetId());\n                     pnode->fDisconnect = true;\n                 }\n             }\n         }\n         {\n             LOCK(cs_vNodes);\n-            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n+            for (CNode* pnode : vNodesCopy)\n                 pnode->Release();\n         }\n     }\n@@ -1584,7 +1595,7 @@ void CConnman::ThreadDNSAddressSeed()\n \n     LogPrintf(\"Loading addresses from DNS seeds (could take a while)\\n\");\n \n-    BOOST_FOREACH(const CDNSSeedData &seed, vSeeds) {\n+    for (const CDNSSeedData &seed : vSeeds) {\n         if (interruptNet) {\n             return;\n         }\n@@ -1594,28 +1605,22 @@ void CConnman::ThreadDNSAddressSeed()\n             std::vector<CNetAddr> vIPs;\n             std::vector<CAddress> vAdd;\n             ServiceFlags requiredServiceBits = nRelevantServices;\n-            if (LookupHost(GetDNSHost(seed, &requiredServiceBits).c_str(), vIPs, 0, true))\n+            std::string host = GetDNSHost(seed, &requiredServiceBits);\n+            CNetAddr resolveSource;\n+            if (!resolveSource.SetInternal(host)) {\n+                continue;\n+            }\n+            if (LookupHost(host.c_str(), vIPs, 0, true))\n             {\n-                BOOST_FOREACH(const CNetAddr& ip, vIPs)\n+                for (const CNetAddr& ip : vIPs)\n                 {\n                     int nOneDay = 24*3600;\n                     CAddress addr = CAddress(CService(ip, Params().GetDefaultPort()), requiredServiceBits);\n                     addr.nTime = GetTime() - 3*nOneDay - GetRand(4*nOneDay); // use a random age between 3 and 7 days old\n                     vAdd.push_back(addr);\n                     found++;\n                 }\n-            }\n-            if (interruptNet) {\n-                return;\n-            }\n-            // TODO: The seed name resolve may fail, yielding an IP of [::], which results in\n-            // addrman assigning the same source to results from different seeds.\n-            // This should switch to a hard-coded stable dummy IP for each seed name, so that the\n-            // resolve is not required at all.\n-            if (!vIPs.empty()) {\n-                CService seedSource;\n-                Lookup(seed.name.c_str(), seedSource, 0, true);\n-                addrman.Add(vAdd, seedSource);\n+                addrman.Add(vAdd, resolveSource);\n             }\n         }\n     }\n@@ -1672,12 +1677,12 @@ void CConnman::ProcessOneShot()\n void CConnman::ThreadOpenConnections()\n {\n     // Connect to specific addresses\n-    if (mapMultiArgs.count(\"-connect\") && mapMultiArgs.at(\"-connect\").size() > 0)\n+    if (gArgs.IsArgSet(\"-connect\"))\n     {\n         for (int64_t nLoop = 0;; nLoop++)\n         {\n             ProcessOneShot();\n-            BOOST_FOREACH(const std::string& strAddr, mapMultiArgs.at(\"-connect\"))\n+            for (const std::string& strAddr : gArgs.GetArgs(\"-connect\"))\n             {\n                 CAddress addr(CService(), NODE_NONE);\n                 OpenNetworkConnection(addr, false, NULL, strAddr.c_str());\n@@ -1714,7 +1719,7 @@ void CConnman::ThreadOpenConnections()\n             if (!done) {\n                 LogPrintf(\"Adding fixed seed nodes as DNS doesn't seem to be available.\\n\");\n                 CNetAddr local;\n-                LookupHost(\"127.0.0.1\", local, false);\n+                local.SetInternal(\"fixedseeds\");\n                 addrman.Add(convertSeed6(Params().FixedSeeds()), local);\n                 done = true;\n             }\n@@ -1728,11 +1733,17 @@ void CConnman::ThreadOpenConnections()\n         // Only connect out to one peer per network group (/16 for IPv4).\n         // Do this here so we don't have to critsect vNodes inside mapAddresses critsect.\n         int nOutbound = 0;\n+        int nOutboundRelevant = 0;\n         std::set<std::vector<unsigned char> > setConnected;\n         {\n             LOCK(cs_vNodes);\n-            BOOST_FOREACH(CNode* pnode, vNodes) {\n+            for (CNode* pnode : vNodes) {\n                 if (!pnode->fInbound && !pnode->fAddnode) {\n+\n+                    // Count the peers that have all relevant services\n+                    if (pnode->fSuccessfullyConnected && !pnode->fFeeler && ((pnode->nServices & nRelevantServices) == nRelevantServices)) {\n+                        nOutboundRelevant++;\n+                    }\n                     // Netgroups for inbound and addnode peers are not excluded because our goal here\n                     // is to not use multiple of our limited outbound slots on a single netgroup\n                     // but inbound and addnode peers do not use our outbound slots.  Inbound peers\n@@ -1750,9 +1761,9 @@ void CConnman::ThreadOpenConnections()\n         //  * Increase the number of connectable addresses in the tried table.\n         //\n         // Method:\n-        //  * Choose a random address from new and attempt to connect to it if we can connect \n+        //  * Choose a random address from new and attempt to connect to it if we can connect\n         //    successfully it is added to tried.\n-        //  * Start attempting feeler connections only after node finishes making outbound \n+        //  * Start attempting feeler connections only after node finishes making outbound\n         //    connections.\n         //  * Only make a feeler connection once every few minutes.\n         //\n@@ -1796,14 +1807,27 @@ void CConnman::ThreadOpenConnections()\n                 continue;\n \n             // only consider nodes missing relevant services after 40 failed attempts and only if less than half the outbound are up.\n-            if ((addr.nServices & nRelevantServices) != nRelevantServices && (nTries < 40 || nOutbound >= (nMaxOutbound >> 1)))\n+            ServiceFlags nRequiredServices = nRelevantServices;\n+            if (nTries >= 40 && nOutbound < (nMaxOutbound >> 1)) {\n+                nRequiredServices = REQUIRED_SERVICES;\n+            }\n+\n+            if ((addr.nServices & nRequiredServices) != nRequiredServices) {\n                 continue;\n+            }\n \n             // do not allow non-default ports, unless after 50 invalid addresses selected already\n             if (addr.GetPort() != Params().GetDefaultPort() && nTries < 50)\n                 continue;\n \n             addrConnect = addr;\n+\n+            // regardless of the services assumed to be available, only require the minimum if half or more outbound have relevant services\n+            if (nOutboundRelevant >= (nMaxOutbound >> 1)) {\n+                addrConnect.nServices = REQUIRED_SERVICES;\n+            } else {\n+                addrConnect.nServices = nRequiredServices;\n+            }\n             break;\n         }\n \n@@ -1830,7 +1854,7 @@ std::vector<AddedNodeInfo> CConnman::GetAddedNodeInfo()\n     {\n         LOCK(cs_vAddedNodes);\n         ret.reserve(vAddedNodes.size());\n-        BOOST_FOREACH(const std::string& strAddNode, vAddedNodes)\n+        for (const std::string& strAddNode : vAddedNodes)\n             lAddresses.push_back(strAddNode);\n     }\n \n@@ -1851,7 +1875,7 @@ std::vector<AddedNodeInfo> CConnman::GetAddedNodeInfo()\n         }\n     }\n \n-    BOOST_FOREACH(const std::string& strAddNode, lAddresses) {\n+    for (const std::string& strAddNode : lAddresses) {\n         CService service(LookupNumeric(strAddNode.c_str(), Params().GetDefaultPort()));\n         if (service.IsValid()) {\n             // strAddNode is an IP:port\n@@ -1879,8 +1903,7 @@ void CConnman::ThreadOpenAddedConnections()\n {\n     {\n         LOCK(cs_vAddedNodes);\n-        if (mapMultiArgs.count(\"-addnode\"))\n-            vAddedNodes = mapMultiArgs.at(\"-addnode\");\n+        vAddedNodes = gArgs.GetArgs(\"-addnode\");\n     }\n \n     while (true)\n@@ -1960,14 +1983,14 @@ void CConnman::ThreadMessageHandler()\n         {\n             LOCK(cs_vNodes);\n             vNodesCopy = vNodes;\n-            BOOST_FOREACH(CNode* pnode, vNodesCopy) {\n+            for (CNode* pnode : vNodesCopy) {\n                 pnode->AddRef();\n             }\n         }\n \n         bool fMoreWork = false;\n \n-        BOOST_FOREACH(CNode* pnode, vNodesCopy)\n+        for (CNode* pnode : vNodesCopy)\n         {\n             if (pnode->fDisconnect)\n                 continue;\n@@ -1989,7 +2012,7 @@ void CConnman::ThreadMessageHandler()\n \n         {\n             LOCK(cs_vNodes);\n-            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n+            for (CNode* pnode : vNodesCopy)\n                 pnode->Release();\n         }\n \n@@ -2053,6 +2076,7 @@ bool CConnman::BindListenPort(const CService &addrBind, std::string& strError, b\n \n     // Set to non-blocking, incoming connections will also inherit this\n     if (!SetSocketNonBlocking(hListenSocket, true)) {\n+        CloseSocket(hListenSocket);\n         strError = strprintf(\"BindListenPort: Setting listening socket to non-blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));\n         LogPrintf(\"%s\\n\", strError);\n         return false;\n@@ -2117,7 +2141,7 @@ void Discover(boost::thread_group& threadGroup)\n         std::vector<CNetAddr> vaddr;\n         if (LookupHost(pszHostName, vaddr, 0, true))\n         {\n-            BOOST_FOREACH (const CNetAddr &addr, vaddr)\n+            for (const CNetAddr &addr : vaddr)\n             {\n                 if (AddLocal(addr, LOCAL_IF))\n                     LogPrintf(\"%s: %s - %s\\n\", __func__, pszHostName, addr.ToString());\n@@ -2159,16 +2183,18 @@ void CConnman::SetNetworkActive(bool active)\n {\n     LogPrint(BCLog::NET, \"SetNetworkActive: %s\\n\", active);\n \n-    if (!active) {\n-        fNetworkActive = false;\n+    if (fNetworkActive == active) {\n+        return;\n+    }\n+\n+    fNetworkActive = active;\n \n+    if (!fNetworkActive) {\n         LOCK(cs_vNodes);\n         // Close sockets to all nodes\n-        BOOST_FOREACH(CNode* pnode, vNodes) {\n+        for (CNode* pnode : vNodes) {\n             pnode->CloseSocketDisconnect();\n         }\n-    } else {\n-        fNetworkActive = true;\n     }\n \n     uiInterface.NotifyNetworkActiveChanged(fNetworkActive);\n@@ -2184,42 +2210,70 @@ CConnman::CConnman(uint64_t nSeed0In, uint64_t nSeed1In) : nSeed0(nSeed0In), nSe\n     nReceiveFloodSize = 0;\n     semOutbound = NULL;\n     semAddnode = NULL;\n-    nMaxConnections = 0;\n-    nMaxOutbound = 0;\n-    nMaxAddnode = 0;\n-    nBestHeight = 0;\n-    clientInterface = NULL;\n     flagInterruptMsgProc = false;\n+\n+    Options connOptions;\n+    Init(connOptions);\n }\n \n NodeId CConnman::GetNewNodeId()\n {\n     return nLastNodeId.fetch_add(1, std::memory_order_relaxed);\n }\n \n-bool CConnman::Start(CScheduler& scheduler, std::string& strNodeError, Options connOptions)\n+\n+bool CConnman::Bind(const CService &addr, unsigned int flags) {\n+    if (!(flags & BF_EXPLICIT) && IsLimited(addr))\n+        return false;\n+    std::string strError;\n+    if (!BindListenPort(addr, strError, (flags & BF_WHITELIST) != 0)) {\n+        if ((flags & BF_REPORT_ERROR) && clientInterface) {\n+            clientInterface->ThreadSafeMessageBox(strError, \"\", CClientUIInterface::MSG_ERROR);\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool CConnman::InitBinds(const std::vector<CService>& binds, const std::vector<CService>& whiteBinds) {\n+    bool fBound = false;\n+    for (const auto& addrBind : binds) {\n+        fBound |= Bind(addrBind, (BF_EXPLICIT | BF_REPORT_ERROR));\n+    }\n+    for (const auto& addrBind : whiteBinds) {\n+        fBound |= Bind(addrBind, (BF_EXPLICIT | BF_REPORT_ERROR | BF_WHITELIST));\n+    }\n+    if (binds.empty() && whiteBinds.empty()) {\n+        struct in_addr inaddr_any;\n+        inaddr_any.s_addr = INADDR_ANY;\n+        fBound |= Bind(CService(in6addr_any, GetListenPort()), BF_NONE);\n+        fBound |= Bind(CService(inaddr_any, GetListenPort()), !fBound ? BF_REPORT_ERROR : BF_NONE);\n+    }\n+    return fBound;\n+}\n+\n+bool CConnman::Start(CScheduler& scheduler, const Options& connOptions)\n {\n+    Init(connOptions);\n+\n     nTotalBytesRecv = 0;\n     nTotalBytesSent = 0;\n     nMaxOutboundTotalBytesSentInCycle = 0;\n     nMaxOutboundCycleStartTime = 0;\n \n-    nRelevantServices = connOptions.nRelevantServices;\n-    nLocalServices = connOptions.nLocalServices;\n-    nMaxConnections = connOptions.nMaxConnections;\n-    nMaxOutbound = std::min((connOptions.nMaxOutbound), nMaxConnections);\n-    nMaxAddnode = connOptions.nMaxAddnode;\n-    nMaxFeeler = connOptions.nMaxFeeler;\n-\n-    nSendBufferMaxSize = connOptions.nSendBufferMaxSize;\n-    nReceiveFloodSize = connOptions.nReceiveFloodSize;\n-\n-    nMaxOutboundLimit = connOptions.nMaxOutboundLimit;\n-    nMaxOutboundTimeframe = connOptions.nMaxOutboundTimeframe;\n+    if (fListen && !InitBinds(connOptions.vBinds, connOptions.vWhiteBinds)) {\n+        if (clientInterface) {\n+            clientInterface->ThreadSafeMessageBox(\n+                _(\"Failed to listen on any port. Use -listen=0 if you want this.\"),\n+                \"\", CClientUIInterface::MSG_ERROR);\n+        }\n+        return false;\n+    }\n \n-    SetBestHeight(connOptions.nBestHeight);\n+    for (const auto& strDest : connOptions.vSeedNodes) {\n+        AddOneShot(strDest);\n+    }\n \n-    clientInterface = connOptions.uiInterface;\n     if (clientInterface) {\n         clientInterface->InitMessage(_(\"Loading P2P addresses...\"));\n     }\n@@ -2291,7 +2345,7 @@ bool CConnman::Start(CScheduler& scheduler, std::string& strNodeError, Options c\n     threadOpenAddedConnections = std::thread(&TraceThread<std::function<void()> >, \"addcon\", std::function<void()>(std::bind(&CConnman::ThreadOpenAddedConnections, this)));\n \n     // Initiate outbound connections unless connect=0\n-    if (!mapMultiArgs.count(\"-connect\") || mapMultiArgs.at(\"-connect\").size() != 1 || mapMultiArgs.at(\"-connect\")[0] != \"0\")\n+    if (!gArgs.IsArgSet(\"-connect\") || gArgs.GetArgs(\"-connect\").size() != 1 || gArgs.GetArgs(\"-connect\")[0] != \"0\")\n         threadOpenConnections = std::thread(&TraceThread<std::function<void()> >, \"opencon\", std::function<void()>(std::bind(&CConnman::ThreadOpenConnections, this)));\n \n     // Process messages\n@@ -2362,18 +2416,18 @@ void CConnman::Stop()\n     }\n \n     // Close sockets\n-    BOOST_FOREACH(CNode* pnode, vNodes)\n+    for (CNode* pnode : vNodes)\n         pnode->CloseSocketDisconnect();\n-    BOOST_FOREACH(ListenSocket& hListenSocket, vhListenSocket)\n+    for (ListenSocket& hListenSocket : vhListenSocket)\n         if (hListenSocket.socket != INVALID_SOCKET)\n             if (!CloseSocket(hListenSocket.socket))\n                 LogPrintf(\"CloseSocket(hListenSocket) failed with error %s\\n\", NetworkErrorString(WSAGetLastError()));\n \n     // clean up some globals (to help leak detection)\n-    BOOST_FOREACH(CNode *pnode, vNodes) {\n+    for (CNode *pnode : vNodes) {\n         DeleteNode(pnode);\n     }\n-    BOOST_FOREACH(CNode *pnode, vNodesDisconnected) {\n+    for (CNode *pnode : vNodesDisconnected) {\n         DeleteNode(pnode);\n     }\n     vNodes.clear();\n@@ -2489,7 +2543,7 @@ bool CConnman::DisconnectNode(NodeId id)\n {\n     LOCK(cs_vNodes);\n     for(CNode* pnode : vNodes) {\n-        if (id == pnode->id) {\n+        if (id == pnode->GetId()) {\n             pnode->fDisconnect = true;\n             return true;\n         }\n@@ -2621,16 +2675,16 @@ int CConnman::GetBestHeight() const\n }\n \n unsigned int CConnman::GetReceiveFloodSize() const { return nReceiveFloodSize; }\n-unsigned int CConnman::GetSendBufferSize() const{ return nSendBufferMaxSize; }\n \n-CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const std::string& addrNameIn, bool fInboundIn) :\n+CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress &addrBindIn, const std::string& addrNameIn, bool fInboundIn) :\n     nTimeConnected(GetSystemTimeInSeconds()),\n     addr(addrIn),\n+    addrBind(addrBindIn),\n     fInbound(fInboundIn),\n-    id(idIn),\n     nKeyedNetGroup(nKeyedNetGroupIn),\n     addrKnown(5000, 0.001),\n     filterInventoryKnown(50000, 0.000001),\n+    id(idIn),\n     nLocalHostNonce(nLocalHostNonceIn),\n     nLocalServices(nLocalServicesIn),\n     nMyStartingHeight(nMyStartingHeightIn),\n@@ -2684,7 +2738,7 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn\n     fPauseSend = false;\n     nProcessQueueSize = 0;\n \n-    BOOST_FOREACH(const std::string &msg, getAllNetMessageTypes())\n+    for (const std::string &msg : getAllNetMessageTypes())\n         mapRecvBytesPerMsgCmd[msg] = 0;\n     mapRecvBytesPerMsgCmd[NET_MESSAGE_COMMAND_OTHER] = 0;\n \n@@ -2746,7 +2800,7 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n {\n     size_t nMessageSize = msg.data.size();\n     size_t nTotalSize = nMessageSize + CMessageHeader::HEADER_SIZE;\n-    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(msg.command.c_str()), nMessageSize, pnode->id);\n+    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(msg.command.c_str()), nMessageSize, pnode->GetId());\n \n     std::vector<unsigned char> serializedHeader;\n     serializedHeader.reserve(CMessageHeader::HEADER_SIZE);\n@@ -2784,7 +2838,7 @@ bool CConnman::ForNode(NodeId id, std::function<bool(CNode* pnode)> func)\n     CNode* found = nullptr;\n     LOCK(cs_vNodes);\n     for (auto&& pnode : vNodes) {\n-        if(pnode->id == id) {\n+        if(pnode->GetId() == id) {\n             found = pnode;\n             break;\n         }\n@@ -2805,5 +2859,5 @@ uint64_t CConnman::CalculateKeyedNetGroup(const CAddress& ad) const\n {\n     std::vector<unsigned char> vchNetGroup(ad.GetGroup());\n \n-    return GetDeterministicRandomizer(RANDOMIZER_ID_NETGROUP).Write(&vchNetGroup[0], vchNetGroup.size()).Finalize();\n+    return GetDeterministicRandomizer(RANDOMIZER_ID_NETGROUP).Write(vchNetGroup.data(), vchNetGroup.size()).Finalize();\n }"
      },
      {
        "sha": "93a76fc09308f15463a2b66eb23e403c7c671a0d",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 42,
        "deletions": 21,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -11,10 +11,10 @@\n #include \"amount.h\"\n #include \"bloom.h\"\n #include \"compat.h\"\n-#include \"fs.h\"\n #include \"hash.h\"\n #include \"limitedmap.h\"\n #include \"netaddress.h\"\n+#include \"policy/feerate.h\"\n #include \"protocol.h\"\n #include \"random.h\"\n #include \"streams.h\"\n@@ -33,10 +33,8 @@\n #include <arpa/inet.h>\n #endif\n \n-#include <boost/foreach.hpp>\n #include <boost/signals2/signal.hpp>\n \n-class CAddrMan;\n class CScheduler;\n class CNode;\n \n@@ -102,7 +100,6 @@ struct AddedNodeInfo\n     bool fInbound;\n };\n \n-class CTransaction;\n class CNodeStats;\n class CClientUIInterface;\n \n@@ -145,13 +142,32 @@ class CConnman\n         unsigned int nReceiveFloodSize = 0;\n         uint64_t nMaxOutboundTimeframe = 0;\n         uint64_t nMaxOutboundLimit = 0;\n+        std::vector<std::string> vSeedNodes;\n+        std::vector<CSubNet> vWhitelistedRange;\n+        std::vector<CService> vBinds, vWhiteBinds;\n     };\n+\n+    void Init(const Options& connOptions) {\n+        nLocalServices = connOptions.nLocalServices;\n+        nRelevantServices = connOptions.nRelevantServices;\n+        nMaxConnections = connOptions.nMaxConnections;\n+        nMaxOutbound = std::min(connOptions.nMaxOutbound, connOptions.nMaxConnections);\n+        nMaxAddnode = connOptions.nMaxAddnode;\n+        nMaxFeeler = connOptions.nMaxFeeler;\n+        nBestHeight = connOptions.nBestHeight;\n+        clientInterface = connOptions.uiInterface;\n+        nSendBufferMaxSize = connOptions.nSendBufferMaxSize;\n+        nReceiveFloodSize = connOptions.nReceiveFloodSize;\n+        nMaxOutboundTimeframe = connOptions.nMaxOutboundTimeframe;\n+        nMaxOutboundLimit = connOptions.nMaxOutboundLimit;\n+        vWhitelistedRange = connOptions.vWhitelistedRange;\n+    }\n+\n     CConnman(uint64_t seed0, uint64_t seed1);\n     ~CConnman();\n-    bool Start(CScheduler& scheduler, std::string& strNodeError, Options options);\n+    bool Start(CScheduler& scheduler, const Options& options);\n     void Stop();\n     void Interrupt();\n-    bool BindListenPort(const CService &bindAddr, std::string& strError, bool fWhitelisted = false);\n     bool GetNetworkActive() const { return fNetworkActive; };\n     void SetNetworkActive(bool active);\n     bool OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound = NULL, const char *strDest = NULL, bool fOneShot = false, bool fFeeler = false, bool fAddnode = false);\n@@ -234,8 +250,6 @@ class CConnman\n     void GetBanned(banmap_t &banmap);\n     void SetBanned(const banmap_t &banmap);\n \n-    void AddOneShot(const std::string& strDest);\n-\n     bool AddNode(const std::string& node);\n     bool RemoveAddedNode(const std::string& node);\n     std::vector<AddedNodeInfo> GetAddedNodeInfo();\n@@ -245,10 +259,6 @@ class CConnman\n     bool DisconnectNode(const std::string& node);\n     bool DisconnectNode(NodeId id);\n \n-    unsigned int GetSendBufferSize() const;\n-\n-    void AddWhitelistedRange(const CSubNet &subnet);\n-\n     ServiceFlags GetLocalServices() const;\n \n     //!set the max outbound target in bytes\n@@ -292,7 +302,11 @@ class CConnman\n         ListenSocket(SOCKET socket_, bool whitelisted_) : socket(socket_), whitelisted(whitelisted_) {}\n     };\n \n+    bool BindListenPort(const CService &bindAddr, std::string& strError, bool fWhitelisted = false);\n+    bool Bind(const CService &addr, unsigned int flags);\n+    bool InitBinds(const std::vector<CService>& binds, const std::vector<CService>& whiteBinds);\n     void ThreadOpenAddedConnections();\n+    void AddOneShot(const std::string& strDest);\n     void ProcessOneShot();\n     void ThreadOpenConnections();\n     void ThreadMessageHandler();\n@@ -348,7 +362,6 @@ class CConnman\n     // Whitelisted ranges. Any node connecting from these is automatically\n     // whitelisted (as well as those connecting to whitelisted binds).\n     std::vector<CSubNet> vWhitelistedRange;\n-    CCriticalSection cs_vWhitelistedRange;\n \n     unsigned int nSendBufferMaxSize;\n     unsigned int nReceiveFloodSize;\n@@ -505,8 +518,12 @@ class CNodeStats\n     double dPingTime;\n     double dPingWait;\n     double dMinPing;\n+    // Our address, as reported by the peer\n     std::string addrLocal;\n+    // Address of this peer\n     CAddress addr;\n+    // Bind address of our side of the connection\n+    CAddress addrBind;\n };\n \n \n@@ -587,7 +604,10 @@ class CNode\n     std::atomic<int64_t> nLastRecv;\n     const int64_t nTimeConnected;\n     std::atomic<int64_t> nTimeOffset;\n+    // Address of this peer\n     const CAddress addr;\n+    // Bind address of our side of the connection\n+    const CAddress addrBind;\n     std::atomic<int> nVersion;\n     // strSubVer is whatever byte array we read from the wire. However, this field is intended\n     // to be printed out, displayed to humans in various forms and so on. So we sanitize it and\n@@ -613,7 +633,6 @@ class CNode\n     CCriticalSection cs_filter;\n     CBloomFilter* pfilter;\n     std::atomic<int> nRefCount;\n-    const NodeId id;\n \n     const uint64_t nKeyedNetGroup;\n     std::atomic_bool fPauseRecv;\n@@ -678,12 +697,13 @@ class CNode\n     CAmount lastSentFeeFilter;\n     int64_t nextSendTimeFeeFilter;\n \n-    CNode(NodeId id, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn, SOCKET hSocketIn, const CAddress &addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const std::string &addrNameIn = \"\", bool fInboundIn = false);\n+    CNode(NodeId id, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn, SOCKET hSocketIn, const CAddress &addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress &addrBindIn, const std::string &addrNameIn = \"\", bool fInboundIn = false);\n     ~CNode();\n \n private:\n     CNode(const CNode&);\n     void operator=(const CNode&);\n+    const NodeId id;\n \n \n     const uint64_t nLocalHostNonce;\n@@ -696,23 +716,24 @@ class CNode\n     mutable CCriticalSection cs_addrName;\n     std::string addrName;\n \n+    // Our address, as reported by the peer\n     CService addrLocal;\n     mutable CCriticalSection cs_addrLocal;\n public:\n \n     NodeId GetId() const {\n-      return id;\n+        return id;\n     }\n \n     uint64_t GetLocalNonce() const {\n-      return nLocalHostNonce;\n+        return nLocalHostNonce;\n     }\n \n     int GetMyStartingHeight() const {\n-      return nMyStartingHeight;\n+        return nMyStartingHeight;\n     }\n \n-    int GetRefCount()\n+    int GetRefCount() const\n     {\n         assert(nRefCount >= 0);\n         return nRefCount;\n@@ -724,7 +745,7 @@ class CNode\n     {\n         nRecvVersion = nVersionIn;\n     }\n-    int GetRecvVersion()\n+    int GetRecvVersion() const\n     {\n         return nRecvVersion;\n     }\n@@ -760,7 +781,7 @@ class CNode\n         // after addresses were pushed.\n         if (_addr.IsValid() && !addrKnown.contains(_addr.GetKey())) {\n             if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n-                vAddrToSend[insecure_rand.rand32() % vAddrToSend.size()] = _addr;\n+                vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\n             } else {\n                 vAddrToSend.push_back(_addr);\n             }"
      },
      {
        "sha": "6fabfcf0aded342656afc1e424fa01ee56891e25",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 218,
        "deletions": 195,
        "changes": 413,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -22,6 +22,7 @@\n #include \"primitives/block.h\"\n #include \"primitives/transaction.h\"\n #include \"random.h\"\n+#include \"reverse_iterator.h\"\n #include \"tinyformat.h\"\n #include \"txmempool.h\"\n #include \"ui_interface.h\"\n@@ -30,8 +31,6 @@\n #include \"utilstrencodings.h\"\n #include \"validationinterface.h\"\n \n-#include <boost/thread.hpp>\n-\n #if defined(NDEBUG)\n # error \"Bitcoin cannot be compiled without assertions.\"\n #endif\n@@ -122,7 +121,7 @@ namespace {\n     MapRelay mapRelay;\n     /** Expiration-time ordered list of (expire time, relay map entry) pairs, protected by cs_main). */\n     std::deque<std::pair<int64_t, MapRelay::iterator>> vRelayExpiration;\n-} // anon namespace\n+} // namespace\n \n //////////////////////////////////////////////////////////////////////////////\n //\n@@ -168,6 +167,8 @@ struct CNodeState {\n     int nUnconnectingHeaders;\n     //! Whether we've started headers synchronization with this peer.\n     bool fSyncStarted;\n+    //! When to potentially disconnect peer for stalling headers download\n+    int64_t nHeadersSyncTimeout;\n     //! Since when we're stalling block download progress (in microseconds), or 0.\n     int64_t nStallingSince;\n     std::list<QueuedBlock> vBlocksInFlight;\n@@ -207,6 +208,7 @@ struct CNodeState {\n         pindexBestHeaderSent = NULL;\n         nUnconnectingHeaders = 0;\n         fSyncStarted = false;\n+        nHeadersSyncTimeout = 0;\n         nStallingSince = 0;\n         nDownloadingSince = 0;\n         nBlocksInFlight = 0;\n@@ -287,7 +289,7 @@ void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n         fUpdateConnectionTime = true;\n     }\n \n-    BOOST_FOREACH(const QueuedBlock& entry, state->vBlocksInFlight) {\n+    for (const QueuedBlock& entry : state->vBlocksInFlight) {\n         mapBlocksInFlight.erase(entry.hash);\n     }\n     EraseOrphansFor(nodeid);\n@@ -303,6 +305,7 @@ void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n         assert(nPreferredDownload == 0);\n         assert(nPeersWithValidatedDownloads == 0);\n     }\n+    LogPrint(BCLog::NET, \"Cleared nodestate for peer=%d\\n\", nodeid);\n }\n \n // Requires cs_main.\n@@ -333,14 +336,16 @@ bool MarkBlockAsReceived(const uint256& hash) {\n // Requires cs_main.\n // returns false, still setting pit, if the block was already in flight from the same peer\n // pit will only be valid as long as the same cs_main lock is being held\n-bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, const CBlockIndex* pindex = NULL, std::list<QueuedBlock>::iterator** pit = NULL) {\n+bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = NULL, std::list<QueuedBlock>::iterator** pit = NULL) {\n     CNodeState *state = State(nodeid);\n     assert(state != NULL);\n \n     // Short-circuit most stuff in case its from the same node\n     std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end() && itInFlight->second.first == nodeid) {\n-        *pit = &itInFlight->second.second;\n+        if (pit) {\n+            *pit = &itInFlight->second.second;\n+        }\n         return false;\n     }\n \n@@ -448,25 +453,6 @@ bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex)\n     return false;\n }\n \n-/** Find the last common ancestor two blocks have.\n- *  Both pa and pb must be non-NULL. */\n-const CBlockIndex* LastCommonAncestor(const CBlockIndex* pa, const CBlockIndex* pb) {\n-    if (pa->nHeight > pb->nHeight) {\n-        pa = pa->GetAncestor(pb->nHeight);\n-    } else if (pb->nHeight > pa->nHeight) {\n-        pb = pb->GetAncestor(pa->nHeight);\n-    }\n-\n-    while (pa != pb && pa && pb) {\n-        pa = pa->pprev;\n-        pb = pb->pprev;\n-    }\n-\n-    // Eventually all chain branches meet at the genesis block.\n-    assert(pa == pb);\n-    return pa;\n-}\n-\n /** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has\n  *  at most count entries. */\n void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) {\n@@ -480,7 +466,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n     // Make sure pindexBestKnownBlock is up to date, we'll need it.\n     ProcessBlockAvailability(nodeid);\n \n-    if (state->pindexBestKnownBlock == NULL || state->pindexBestKnownBlock->nChainWork < chainActive.Tip()->nChainWork) {\n+    if (state->pindexBestKnownBlock == NULL || state->pindexBestKnownBlock->nChainWork < chainActive.Tip()->nChainWork || state->pindexBestKnownBlock->nChainWork < UintToArith256(consensusParams.nMinimumChainWork)) {\n         // This peer has nothing interesting.\n         return;\n     }\n@@ -521,7 +507,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n         // are not yet downloaded and not in flight to vBlocks. In the mean time, update\n         // pindexLastCommonBlock as long as all ancestors are already downloaded, or if it's\n         // already part of our chain (and therefore don't need it even if pruned).\n-        BOOST_FOREACH(const CBlockIndex* pindex, vToFetch) {\n+        for (const CBlockIndex* pindex : vToFetch) {\n             if (!pindex->IsValid(BLOCK_VALID_TREE)) {\n                 // We consider the chain that this peer is on invalid.\n                 return;\n@@ -555,7 +541,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n     }\n }\n \n-} // anon namespace\n+} // namespace\n \n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n     LOCK(cs_main);\n@@ -565,7 +551,7 @@ bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n     stats.nMisbehavior = state->nMisbehavior;\n     stats.nSyncHeight = state->pindexBestKnownBlock ? state->pindexBestKnownBlock->nHeight : -1;\n     stats.nCommonHeight = state->pindexLastCommonBlock ? state->pindexLastCommonBlock->nHeight : -1;\n-    BOOST_FOREACH(const QueuedBlock& queue, state->vBlocksInFlight) {\n+    for (const QueuedBlock& queue : state->vBlocksInFlight) {\n         if (queue.pindex)\n             stats.vHeightInFlight.push_back(queue.pindex->nHeight);\n     }\n@@ -626,7 +612,7 @@ bool AddOrphanTx(const CTransactionRef& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRE\n \n     auto ret = mapOrphanTransactions.emplace(hash, COrphanTx{tx, peer, GetTime() + ORPHAN_TX_EXPIRE_TIME});\n     assert(ret.second);\n-    BOOST_FOREACH(const CTxIn& txin, tx->vin) {\n+    for (const CTxIn& txin : tx->vin) {\n         mapOrphanTransactionsByPrev[txin.prevout].insert(ret.first);\n     }\n \n@@ -642,7 +628,7 @@ int static EraseOrphanTx(uint256 hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n     std::map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.find(hash);\n     if (it == mapOrphanTransactions.end())\n         return 0;\n-    BOOST_FOREACH(const CTxIn& txin, it->second.tx->vin)\n+    for (const CTxIn& txin : it->second.tx->vin)\n     {\n         auto itPrev = mapOrphanTransactionsByPrev.find(txin.prevout);\n         if (itPrev == mapOrphanTransactionsByPrev.end())\n@@ -753,8 +739,8 @@ void PeerLogicValidation::BlockConnected(const std::shared_ptr<const CBlock>& pb\n         const CTransaction& tx = *ptx;\n \n         // Which orphan pool entries must we evict?\n-        for (size_t j = 0; j < tx.vin.size(); j++) {\n-            auto itByPrev = mapOrphanTransactionsByPrev.find(tx.vin[j].prevout);\n+        for (const auto& txin : tx.vin) {\n+            auto itByPrev = mapOrphanTransactionsByPrev.find(txin.prevout);\n             if (itByPrev == mapOrphanTransactionsByPrev.end()) continue;\n             for (auto mi = itByPrev->second.begin(); mi != itByPrev->second.end(); ++mi) {\n                 const CTransaction& orphanTx = *(*mi)->second.tx;\n@@ -767,7 +753,7 @@ void PeerLogicValidation::BlockConnected(const std::shared_ptr<const CBlock>& pb\n     // Erase orphan transactions include or precluded by this block\n     if (vOrphanErase.size()) {\n         int nErased = 0;\n-        BOOST_FOREACH(uint256 &orphanHash, vOrphanErase) {\n+        for (uint256 &orphanHash : vOrphanErase) {\n             nErased += EraseOrphanTx(orphanHash);\n         }\n         LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n@@ -815,7 +801,7 @@ void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std:\n                 !PeerHasHeader(&state, pindex) && PeerHasHeader(&state, pindex->pprev)) {\n \n             LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", \"PeerLogicValidation::NewPoWValidBlock\",\n-                    hashBlock.ToString(), pnode->id);\n+                    hashBlock.ToString(), pnode->GetId());\n             connman->PushMessage(pnode, msgMaker.Make(NetMsgType::CMPCTBLOCK, *pcmpctblock));\n             state.pindexBestHeaderSent = pindex;\n         }\n@@ -842,7 +828,7 @@ void PeerLogicValidation::UpdatedBlockTip(const CBlockIndex *pindexNew, const CB\n         // Relay inventory, but don't relay old inventory during initial block download.\n         connman->ForEachNode([nNewHeight, &vHashes](CNode* pnode) {\n             if (nNewHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : 0)) {\n-                BOOST_REVERSE_FOREACH(const uint256& hash, vHashes) {\n+                for (const uint256& hash : reverse_iterate(vHashes)) {\n                     pnode->PushBlockHash(hash);\n                 }\n             }\n@@ -910,12 +896,11 @@ bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n                 recentRejects->reset();\n             }\n \n-            // Use pcoinsTip->HaveCoinsInCache as a quick approximation to exclude\n-            // requesting or processing some txs which have already been included in a block\n             return recentRejects->contains(inv.hash) ||\n                    mempool.exists(inv.hash) ||\n                    mapOrphanTransactions.count(inv.hash) ||\n-                   pcoinsTip->HaveCoinsInCache(inv.hash);\n+                   pcoinsTip->HaveCoinInCache(COutPoint(inv.hash, 0)) || // Best effort: only try output 0 and 1\n+                   pcoinsTip->HaveCoinInCache(COutPoint(inv.hash, 1));\n         }\n     case MSG_BLOCK:\n     case MSG_WITNESS_BLOCK:\n@@ -950,7 +935,7 @@ static void RelayAddress(const CAddress& addr, bool fReachable, CConnman& connma\n \n     auto sortfunc = [&best, &hasher, nRelayNodes](CNode* pnode) {\n         if (pnode->nVersion >= CADDR_TIME_VERSION) {\n-            uint64_t hashKey = CSipHasher(hasher).Write(pnode->id).Finalize();\n+            uint64_t hashKey = CSipHasher(hasher).Write(pnode->GetId()).Finalize();\n             for (unsigned int i = 0; i < nRelayNodes; i++) {\n                  if (hashKey > best[i].first) {\n                      std::copy(best.begin() + i, best.begin() + nRelayNodes - 1, best.begin() + i + 1);\n@@ -1078,7 +1063,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                             // Thus, the protocol spec specified allows for us to provide duplicate txn here,\n                             // however we MUST always provide at least what the remote peer needs\n                             typedef std::pair<unsigned int, uint256> PairType;\n-                            BOOST_FOREACH(PairType& pair, merkleBlock.vMatchedTxn)\n+                            for (PairType& pair : merkleBlock.vMatchedTxn)\n                                 connman.PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n                         }\n                         // else\n@@ -1162,7 +1147,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n     }\n }\n \n-uint32_t GetFetchFlags(CNode* pfrom, const CBlockIndex* pprev, const Consensus::Params& chainparams) {\n+uint32_t GetFetchFlags(CNode* pfrom) {\n     uint32_t nFetchFlags = 0;\n     if ((pfrom->GetLocalServices() & NODE_WITNESS) && State(pfrom->GetId())->fHaveWitness) {\n         nFetchFlags |= MSG_WITNESS_FLAG;\n@@ -1176,7 +1161,7 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n         if (req.indexes[i] >= block.vtx.size()) {\n             LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 100);\n-            LogPrintf(\"Peer %d sent us a getblocktxn with out-of-bounds tx indices\", pfrom->id);\n+            LogPrintf(\"Peer %d sent us a getblocktxn with out-of-bounds tx indices\", pfrom->GetId());\n             return;\n         }\n         resp.txn[i] = block.vtx[req.indexes[i]];\n@@ -1189,7 +1174,7 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n \n bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n {\n-    LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->id);\n+    LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());\n     if (IsArgSet(\"-dropmessagestest\") && GetRand(GetArg(\"-dropmessagestest\", 0)) == 0)\n     {\n         LogPrintf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n@@ -1268,17 +1253,28 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n         if (pfrom->nServicesExpected & ~nServices)\n         {\n-            LogPrint(BCLog::NET, \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom->id, nServices, pfrom->nServicesExpected);\n+            LogPrint(BCLog::NET, \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom->GetId(), nServices, pfrom->nServicesExpected);\n             connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,\n                                strprintf(\"Expected to offer services %08x\", pfrom->nServicesExpected)));\n             pfrom->fDisconnect = true;\n             return false;\n         }\n \n+        if (nServices & ((1 << 7) | (1 << 5))) {\n+            if (GetTime() < 1533096000) {\n+                // Immediately disconnect peers that use service bits 6 or 8 until August 1st, 2018\n+                // These bits have been used as a flag to indicate that a node is running incompatible\n+                // consensus rules instead of changing the network magic, so we're stuck disconnecting\n+                // based on these service bits, at least for a while.\n+                pfrom->fDisconnect = true;\n+                return false;\n+            }\n+        }\n+\n         if (nVersion < MIN_PEER_PROTO_VERSION)\n         {\n             // disconnect from peers older than this proto version\n-            LogPrintf(\"peer=%d using obsolete version %i; disconnecting\\n\", pfrom->id, nVersion);\n+            LogPrintf(\"peer=%d using obsolete version %i; disconnecting\\n\", pfrom->GetId(), nVersion);\n             connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,\n                                strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION)));\n             pfrom->fDisconnect = true;\n@@ -1380,7 +1376,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         LogPrintf(\"receive version message: %s: version %d, blocks=%d, us=%s, peer=%d%s\\n\",\n                   cleanSubVer, pfrom->nVersion,\n-                  pfrom->nStartingHeight, addrMe.ToString(), pfrom->id,\n+                  pfrom->nStartingHeight, addrMe.ToString(), pfrom->GetId(),\n                   remoteAddr);\n \n         int64_t nTimeOffset = nTime - GetTime();\n@@ -1473,7 +1469,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         std::vector<CAddress> vAddrOk;\n         int64_t nNow = GetAdjustedTime();\n         int64_t nSince = nNow - 10 * 60;\n-        BOOST_FOREACH(CAddress& addr, vAddr)\n+        for (CAddress& addr : vAddr)\n         {\n             if (interruptMsgProc)\n                 return true;\n@@ -1550,19 +1546,15 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         LOCK(cs_main);\n \n-        uint32_t nFetchFlags = GetFetchFlags(pfrom, chainActive.Tip(), chainparams.GetConsensus());\n+        uint32_t nFetchFlags = GetFetchFlags(pfrom);\n \n-        std::vector<CInv> vToFetch;\n-\n-        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n+        for (CInv &inv : vInv)\n         {\n-            CInv &inv = vInv[nInv];\n-\n             if (interruptMsgProc)\n                 return true;\n \n             bool fAlreadyHave = AlreadyHave(inv);\n-            LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom->id);\n+            LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom->GetId());\n \n             if (inv.type == MSG_TX) {\n                 inv.type |= nFetchFlags;\n@@ -1577,14 +1569,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     // we now only provide a getheaders response here. When we receive the headers, we will\n                     // then ask for the blocks we need.\n                     connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), inv.hash));\n-                    LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, inv.hash.ToString(), pfrom->id);\n+                    LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, inv.hash.ToString(), pfrom->GetId());\n                 }\n             }\n             else\n             {\n                 pfrom->AddInventoryKnown(inv);\n                 if (fBlocksOnly) {\n-                    LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol peer=%d\\n\", inv.hash.ToString(), pfrom->id);\n+                    LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol peer=%d\\n\", inv.hash.ToString(), pfrom->GetId());\n                 } else if (!fAlreadyHave && !fImporting && !fReindex && !IsInitialBlockDownload()) {\n                     pfrom->AskFor(inv);\n                 }\n@@ -1593,9 +1585,6 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // Track requests for our stuff\n             GetMainSignals().Inventory(inv.hash);\n         }\n-\n-        if (!vToFetch.empty())\n-            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vToFetch));\n     }\n \n \n@@ -1610,10 +1599,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return error(\"message getdata size() = %u\", vInv.size());\n         }\n \n-        LogPrint(BCLog::NET, \"received getdata (%u invsz) peer=%d\\n\", vInv.size(), pfrom->id);\n+        LogPrint(BCLog::NET, \"received getdata (%u invsz) peer=%d\\n\", vInv.size(), pfrom->GetId());\n \n         if (vInv.size() > 0) {\n-            LogPrint(BCLog::NET, \"received getdata for: %s peer=%d\\n\", vInv[0].ToString(), pfrom->id);\n+            LogPrint(BCLog::NET, \"received getdata for: %s peer=%d\\n\", vInv[0].ToString(), pfrom->GetId());\n         }\n \n         pfrom->vRecvGetData.insert(pfrom->vRecvGetData.end(), vInv.begin(), vInv.end());\n@@ -1653,7 +1642,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (pindex)\n             pindex = chainActive.Next(pindex);\n         int nLimit = 500;\n-        LogPrint(BCLog::NET, \"getblocks %d to %s limit %d from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), nLimit, pfrom->id);\n+        LogPrint(BCLog::NET, \"getblocks %d to %s limit %d from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), nLimit, pfrom->GetId());\n         for (; pindex; pindex = chainActive.Next(pindex))\n         {\n             if (pindex->GetBlockHash() == hashStop)\n@@ -1703,7 +1692,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         BlockMap::iterator it = mapBlockIndex.find(req.blockhash);\n         if (it == mapBlockIndex.end() || !(it->second->nStatus & BLOCK_HAVE_DATA)) {\n-            LogPrintf(\"Peer %d sent us a getblocktxn for a block we don't have\", pfrom->id);\n+            LogPrintf(\"Peer %d sent us a getblocktxn for a block we don't have\", pfrom->GetId());\n             return true;\n         }\n \n@@ -1715,7 +1704,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // might maliciously send lots of getblocktxn requests to trigger\n             // expensive disk reads, because it will require the peer to\n             // actually receive all the data read from disk over the network.\n-            LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block > %i deep\", pfrom->id, MAX_BLOCKTXN_DEPTH);\n+            LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block > %i deep\", pfrom->GetId(), MAX_BLOCKTXN_DEPTH);\n             CInv inv;\n             inv.type = State(pfrom->GetId())->fWantsCmpctWitness ? MSG_WITNESS_BLOCK : MSG_BLOCK;\n             inv.hash = req.blockhash;\n@@ -1740,7 +1729,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         LOCK(cs_main);\n         if (IsInitialBlockDownload() && !pfrom->fWhitelisted) {\n-            LogPrint(BCLog::NET, \"Ignoring getheaders from peer=%d because node is in initial block download\\n\", pfrom->id);\n+            LogPrint(BCLog::NET, \"Ignoring getheaders from peer=%d because node is in initial block download\\n\", pfrom->GetId());\n             return true;\n         }\n \n@@ -1765,7 +1754,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // we must use CBlocks, as CBlockHeaders won't include the 0x00 nTx count at the end\n         std::vector<CBlock> vHeaders;\n         int nLimit = MAX_HEADERS_RESULTS;\n-        LogPrint(BCLog::NET, \"getheaders %d to %s from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), pfrom->id);\n+        LogPrint(BCLog::NET, \"getheaders %d to %s from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), pfrom->GetId());\n         for (; pindex; pindex = chainActive.Next(pindex))\n         {\n             vHeaders.push_back(pindex->GetBlockHeader());\n@@ -1795,7 +1784,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // We are in blocks only mode and peer is either not whitelisted or whitelistrelay is off\n         if (!fRelayTxes && (!pfrom->fWhitelisted || !GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)))\n         {\n-            LogPrint(BCLog::NET, \"transaction sent in violation of protocol peer=%d\\n\", pfrom->id);\n+            LogPrint(BCLog::NET, \"transaction sent in violation of protocol peer=%d\\n\", pfrom->GetId());\n             return true;\n         }\n \n@@ -1828,7 +1817,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             pfrom->nLastTXTime = GetTime();\n \n             LogPrint(BCLog::MEMPOOL, \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",\n-                pfrom->id,\n+                pfrom->GetId(),\n                 tx.GetHash().ToString(),\n                 mempool.size(), mempool.DynamicMemoryUsage() / 1000);\n \n@@ -1890,21 +1879,21 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 }\n             }\n \n-            BOOST_FOREACH(uint256 hash, vEraseQueue)\n+            for (uint256 hash : vEraseQueue)\n                 EraseOrphanTx(hash);\n         }\n         else if (fMissingInputs)\n         {\n             bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n-            BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n+            for (const CTxIn& txin : tx.vin) {\n                 if (recentRejects->contains(txin.prevout.hash)) {\n                     fRejectedParents = true;\n                     break;\n                 }\n             }\n             if (!fRejectedParents) {\n-                uint32_t nFetchFlags = GetFetchFlags(pfrom, chainActive.Tip(), chainparams.GetConsensus());\n-                BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n+                uint32_t nFetchFlags = GetFetchFlags(pfrom);\n+                for (const CTxIn& txin : tx.vin) {\n                     CInv _inv(MSG_TX | nFetchFlags, txin.prevout.hash);\n                     pfrom->AddInventoryKnown(_inv);\n                     if (!AlreadyHave(_inv)) pfrom->AskFor(_inv);\n@@ -1948,10 +1937,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // case.\n                 int nDoS = 0;\n                 if (!state.IsInvalid(nDoS) || nDoS == 0) {\n-                    LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->id);\n+                    LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->GetId());\n                     RelayTransaction(tx, connman);\n                 } else {\n-                    LogPrintf(\"Not relaying invalid transaction %s from whitelisted peer=%d (%s)\\n\", tx.GetHash().ToString(), pfrom->id, FormatStateMessage(state));\n+                    LogPrintf(\"Not relaying invalid transaction %s from whitelisted peer=%d (%s)\\n\", tx.GetHash().ToString(), pfrom->GetId(), FormatStateMessage(state));\n                 }\n             }\n         }\n@@ -1963,7 +1952,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (state.IsInvalid(nDoS))\n         {\n             LogPrint(BCLog::MEMPOOLREJ, \"%s from peer=%d was not accepted: %s\\n\", tx.GetHash().ToString(),\n-                pfrom->id,\n+                pfrom->GetId(),\n                 FormatStateMessage(state));\n             if (state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) // Never send AcceptToMemoryPool's internal codes over P2P\n                 connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n@@ -2000,7 +1989,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     LOCK(cs_main);\n                     Misbehaving(pfrom->GetId(), nDoS);\n                 }\n-                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\\n\", pfrom->id);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\\n\", pfrom->GetId());\n                 return true;\n             }\n         }\n@@ -2040,7 +2029,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // We requested this block for some reason, but our mempool will probably be useless\n                 // so we just grab the block via normal getdata\n                 std::vector<CInv> vInv(1);\n-                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n+                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n                 connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n             }\n             return true;\n@@ -2064,7 +2053,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n                  (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n                 std::list<QueuedBlock>::iterator* queuedBlockIt = NULL;\n-                if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt)) {\n+                if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), pindex, &queuedBlockIt)) {\n                     if (!(*queuedBlockIt)->partialBlock)\n                         (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&mempool));\n                     else {\n@@ -2079,12 +2068,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 if (status == READ_STATUS_INVALID) {\n                     MarkBlockAsReceived(pindex->GetBlockHash()); // Reset in-flight state in case of whitelist\n                     Misbehaving(pfrom->GetId(), 100);\n-                    LogPrintf(\"Peer %d sent us invalid compact block\\n\", pfrom->id);\n+                    LogPrintf(\"Peer %d sent us invalid compact block\\n\", pfrom->GetId());\n                     return true;\n                 } else if (status == READ_STATUS_FAILED) {\n                     // Duplicate txindexes, the block is now in-flight, so just request it\n                     std::vector<CInv> vInv(1);\n-                    vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n+                    vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n                     connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n                     return true;\n                 }\n@@ -2127,7 +2116,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // We requested this block, but its far into the future, so our\n                 // mempool will probably be useless - request the block normally\n                 std::vector<CInv> vInv(1);\n-                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n+                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n                 connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n                 return true;\n             } else {\n@@ -2184,7 +2173,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n             if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n                     it->second.first != pfrom->GetId()) {\n-                LogPrint(BCLog::NET, \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom->id);\n+                LogPrint(BCLog::NET, \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom->GetId());\n                 return true;\n             }\n \n@@ -2193,12 +2182,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             if (status == READ_STATUS_INVALID) {\n                 MarkBlockAsReceived(resp.blockhash); // Reset in-flight state in case of whitelist\n                 Misbehaving(pfrom->GetId(), 100);\n-                LogPrintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom->id);\n+                LogPrintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom->GetId());\n                 return true;\n             } else if (status == READ_STATUS_FAILED) {\n                 // Might have collided, fall back to getdata now :(\n                 std::vector<CInv> invs;\n-                invs.push_back(CInv(MSG_BLOCK | GetFetchFlags(pfrom, chainActive.Tip(), chainparams.GetConsensus()), resp.blockhash));\n+                invs.push_back(CInv(MSG_BLOCK | GetFetchFlags(pfrom), resp.blockhash));\n                 connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, invs));\n             } else {\n                 // Block is either okay, or possibly we received\n@@ -2281,7 +2270,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     headers[0].GetHash().ToString(),\n                     headers[0].hashPrevBlock.ToString(),\n                     pindexBestHeader->nHeight,\n-                    pfrom->id, nodestate->nUnconnectingHeaders);\n+                    pfrom->GetId(), nodestate->nUnconnectingHeaders);\n             // Set hashLastUnknownBlock for this peer, so that if we\n             // eventually get the headers - even from a different peer -\n             // we can use this peer to download.\n@@ -2319,7 +2308,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         LOCK(cs_main);\n         CNodeState *nodestate = State(pfrom->GetId());\n         if (nodestate->nUnconnectingHeaders > 0) {\n-            LogPrint(BCLog::NET, \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom->id, nodestate->nUnconnectingHeaders);\n+            LogPrint(BCLog::NET, \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom->GetId(), nodestate->nUnconnectingHeaders);\n         }\n         nodestate->nUnconnectingHeaders = 0;\n \n@@ -2330,7 +2319,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // Headers message had its maximum size; the peer may have more headers.\n             // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n             // from there instead.\n-            LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->id, pfrom->nStartingHeight);\n+            LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->GetId(), pfrom->nStartingHeight);\n             connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256()));\n         }\n \n@@ -2361,16 +2350,16 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             } else {\n                 std::vector<CInv> vGetData;\n                 // Download as much as possible, from earliest to latest.\n-                BOOST_REVERSE_FOREACH(const CBlockIndex *pindex, vToFetch) {\n+                for (const CBlockIndex *pindex : reverse_iterate(vToFetch)) {\n                     if (nodestate->nBlocksInFlight >= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n                         // Can't download any more from this peer\n                         break;\n                     }\n-                    uint32_t nFetchFlags = GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus());\n+                    uint32_t nFetchFlags = GetFetchFlags(pfrom);\n                     vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                    MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex);\n+                    MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), pindex);\n                     LogPrint(BCLog::NET, \"Requesting block %s from  peer=%d\\n\",\n-                            pindex->GetBlockHash().ToString(), pfrom->id);\n+                            pindex->GetBlockHash().ToString(), pfrom->GetId());\n                 }\n                 if (vGetData.size() > 1) {\n                     LogPrint(BCLog::NET, \"Downloading blocks toward %s (%d) via headers direct fetch\\n\",\n@@ -2393,7 +2382,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();\n         vRecv >> *pblock;\n \n-        LogPrint(BCLog::NET, \"received block %s peer=%d\\n\", pblock->GetHash().ToString(), pfrom->id);\n+        LogPrint(BCLog::NET, \"received block %s peer=%d\\n\", pblock->GetHash().ToString(), pfrom->GetId());\n \n         // Process all blocks from whitelisted peers, even if not requested,\n         // unless we're still syncing with the network.\n@@ -2425,22 +2414,22 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // Making nodes which are behind NAT and can only make outgoing connections ignore\n         // the getaddr message mitigates the attack.\n         if (!pfrom->fInbound) {\n-            LogPrint(BCLog::NET, \"Ignoring \\\"getaddr\\\" from outbound connection. peer=%d\\n\", pfrom->id);\n+            LogPrint(BCLog::NET, \"Ignoring \\\"getaddr\\\" from outbound connection. peer=%d\\n\", pfrom->GetId());\n             return true;\n         }\n \n         // Only send one GetAddr response per connection to reduce resource waste\n         //  and discourage addr stamping of INV announcements.\n         if (pfrom->fSentAddr) {\n-            LogPrint(BCLog::NET, \"Ignoring repeated \\\"getaddr\\\". peer=%d\\n\", pfrom->id);\n+            LogPrint(BCLog::NET, \"Ignoring repeated \\\"getaddr\\\". peer=%d\\n\", pfrom->GetId());\n             return true;\n         }\n         pfrom->fSentAddr = true;\n \n         pfrom->vAddrToSend.clear();\n         std::vector<CAddress> vAddr = connman.GetAddresses();\n         FastRandomContext insecure_rand;\n-        BOOST_FOREACH(const CAddress &addr, vAddr)\n+        for (const CAddress &addr : vAddr)\n             pfrom->PushAddress(addr, insecure_rand);\n     }\n \n@@ -2533,7 +2522,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         if (!(sProblem.empty())) {\n             LogPrint(BCLog::NET, \"pong peer=%d: %s, %x expected, %x received, %u bytes\\n\",\n-                pfrom->id,\n+                pfrom->GetId(),\n                 sProblem,\n                 pfrom->nPingNonceSent,\n                 nonce,\n@@ -2610,7 +2599,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 LOCK(pfrom->cs_feeFilter);\n                 pfrom->minFeeFilter = newFeeFilter;\n             }\n-            LogPrint(BCLog::NET, \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom->id);\n+            LogPrint(BCLog::NET, \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom->GetId());\n         }\n     }\n \n@@ -2621,7 +2610,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n     else {\n         // Ignore unknown commands for extensibility\n-        LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(strCommand), pfrom->id);\n+        LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(strCommand), pfrom->GetId());\n     }\n \n \n@@ -2634,7 +2623,7 @@ static bool SendRejectsAndCheckIfBanned(CNode* pnode, CConnman& connman)\n     AssertLockHeld(cs_main);\n     CNodeState &state = *State(pnode->GetId());\n \n-    BOOST_FOREACH(const CBlockReject& reject, state.rejects) {\n+    for (const CBlockReject& reject : state.rejects) {\n         connman.PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, (std::string)NetMsgType::BLOCK, reject.chRejectCode, reject.strRejectReason, reject.hashBlock));\n     }\n     state.rejects.clear();\n@@ -2681,100 +2670,100 @@ bool ProcessMessages(CNode* pfrom, CConnman& connman, const std::atomic<bool>& i\n     // this maintains the order of responses\n     if (!pfrom->vRecvGetData.empty()) return true;\n \n-        // Don't bother if send buffer is too full to respond anyway\n-        if (pfrom->fPauseSend)\n-            return false;\n+    // Don't bother if send buffer is too full to respond anyway\n+    if (pfrom->fPauseSend)\n+        return false;\n \n-        std::list<CNetMessage> msgs;\n-        {\n-            LOCK(pfrom->cs_vProcessMsg);\n-            if (pfrom->vProcessMsg.empty())\n-                return false;\n-            // Just take one message\n-            msgs.splice(msgs.begin(), pfrom->vProcessMsg, pfrom->vProcessMsg.begin());\n-            pfrom->nProcessQueueSize -= msgs.front().vRecv.size() + CMessageHeader::HEADER_SIZE;\n-            pfrom->fPauseRecv = pfrom->nProcessQueueSize > connman.GetReceiveFloodSize();\n-            fMoreWork = !pfrom->vProcessMsg.empty();\n-        }\n-        CNetMessage& msg(msgs.front());\n-\n-        msg.SetVersion(pfrom->GetRecvVersion());\n-        // Scan for message start\n-        if (memcmp(msg.hdr.pchMessageStart, chainparams.MessageStart(), CMessageHeader::MESSAGE_START_SIZE) != 0) {\n-            LogPrintf(\"PROCESSMESSAGE: INVALID MESSAGESTART %s peer=%d\\n\", SanitizeString(msg.hdr.GetCommand()), pfrom->id);\n-            pfrom->fDisconnect = true;\n+    std::list<CNetMessage> msgs;\n+    {\n+        LOCK(pfrom->cs_vProcessMsg);\n+        if (pfrom->vProcessMsg.empty())\n             return false;\n-        }\n+        // Just take one message\n+        msgs.splice(msgs.begin(), pfrom->vProcessMsg, pfrom->vProcessMsg.begin());\n+        pfrom->nProcessQueueSize -= msgs.front().vRecv.size() + CMessageHeader::HEADER_SIZE;\n+        pfrom->fPauseRecv = pfrom->nProcessQueueSize > connman.GetReceiveFloodSize();\n+        fMoreWork = !pfrom->vProcessMsg.empty();\n+    }\n+    CNetMessage& msg(msgs.front());\n+\n+    msg.SetVersion(pfrom->GetRecvVersion());\n+    // Scan for message start\n+    if (memcmp(msg.hdr.pchMessageStart, chainparams.MessageStart(), CMessageHeader::MESSAGE_START_SIZE) != 0) {\n+        LogPrintf(\"PROCESSMESSAGE: INVALID MESSAGESTART %s peer=%d\\n\", SanitizeString(msg.hdr.GetCommand()), pfrom->GetId());\n+        pfrom->fDisconnect = true;\n+        return false;\n+    }\n \n-        // Read header\n-        CMessageHeader& hdr = msg.hdr;\n-        if (!hdr.IsValid(chainparams.MessageStart()))\n-        {\n-            LogPrintf(\"PROCESSMESSAGE: ERRORS IN HEADER %s peer=%d\\n\", SanitizeString(hdr.GetCommand()), pfrom->id);\n-            return fMoreWork;\n-        }\n-        std::string strCommand = hdr.GetCommand();\n+    // Read header\n+    CMessageHeader& hdr = msg.hdr;\n+    if (!hdr.IsValid(chainparams.MessageStart()))\n+    {\n+        LogPrintf(\"PROCESSMESSAGE: ERRORS IN HEADER %s peer=%d\\n\", SanitizeString(hdr.GetCommand()), pfrom->GetId());\n+        return fMoreWork;\n+    }\n+    std::string strCommand = hdr.GetCommand();\n \n-        // Message size\n-        unsigned int nMessageSize = hdr.nMessageSize;\n+    // Message size\n+    unsigned int nMessageSize = hdr.nMessageSize;\n+\n+    // Checksum\n+    CDataStream& vRecv = msg.vRecv;\n+    const uint256& hash = msg.GetMessageHash();\n+    if (memcmp(hash.begin(), hdr.pchChecksum, CMessageHeader::CHECKSUM_SIZE) != 0)\n+    {\n+        LogPrintf(\"%s(%s, %u bytes): CHECKSUM ERROR expected %s was %s\\n\", __func__,\n+           SanitizeString(strCommand), nMessageSize,\n+           HexStr(hash.begin(), hash.begin()+CMessageHeader::CHECKSUM_SIZE),\n+           HexStr(hdr.pchChecksum, hdr.pchChecksum+CMessageHeader::CHECKSUM_SIZE));\n+        return fMoreWork;\n+    }\n \n-        // Checksum\n-        CDataStream& vRecv = msg.vRecv;\n-        const uint256& hash = msg.GetMessageHash();\n-        if (memcmp(hash.begin(), hdr.pchChecksum, CMessageHeader::CHECKSUM_SIZE) != 0)\n+    // Process message\n+    bool fRet = false;\n+    try\n+    {\n+        fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams, connman, interruptMsgProc);\n+        if (interruptMsgProc)\n+            return false;\n+        if (!pfrom->vRecvGetData.empty())\n+            fMoreWork = true;\n+    }\n+    catch (const std::ios_base::failure& e)\n+    {\n+        connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_MALFORMED, std::string(\"error parsing message\")));\n+        if (strstr(e.what(), \"end of data\"))\n         {\n-            LogPrintf(\"%s(%s, %u bytes): CHECKSUM ERROR expected %s was %s\\n\", __func__,\n-               SanitizeString(strCommand), nMessageSize,\n-               HexStr(hash.begin(), hash.begin()+CMessageHeader::CHECKSUM_SIZE),\n-               HexStr(hdr.pchChecksum, hdr.pchChecksum+CMessageHeader::CHECKSUM_SIZE));\n-            return fMoreWork;\n+            // Allow exceptions from under-length message on vRecv\n+            LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n         }\n-\n-        // Process message\n-        bool fRet = false;\n-        try\n+        else if (strstr(e.what(), \"size too large\"))\n         {\n-            fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams, connman, interruptMsgProc);\n-            if (interruptMsgProc)\n-                return false;\n-            if (!pfrom->vRecvGetData.empty())\n-                fMoreWork = true;\n+            // Allow exceptions from over-long size\n+            LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n         }\n-        catch (const std::ios_base::failure& e)\n+        else if (strstr(e.what(), \"non-canonical ReadCompactSize()\"))\n         {\n-            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_MALFORMED, std::string(\"error parsing message\")));\n-            if (strstr(e.what(), \"end of data\"))\n-            {\n-                // Allow exceptions from under-length message on vRecv\n-                LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n-            }\n-            else if (strstr(e.what(), \"size too large\"))\n-            {\n-                // Allow exceptions from over-long size\n-                LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n-            }\n-            else if (strstr(e.what(), \"non-canonical ReadCompactSize()\"))\n-            {\n-                // Allow exceptions from non-canonical encoding\n-                LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n-            }\n-            else\n-            {\n-                PrintExceptionContinue(&e, \"ProcessMessages()\");\n-            }\n+            // Allow exceptions from non-canonical encoding\n+            LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n         }\n-        catch (const std::exception& e) {\n+        else\n+        {\n             PrintExceptionContinue(&e, \"ProcessMessages()\");\n-        } catch (...) {\n-            PrintExceptionContinue(NULL, \"ProcessMessages()\");\n         }\n+    }\n+    catch (const std::exception& e) {\n+        PrintExceptionContinue(&e, \"ProcessMessages()\");\n+    } catch (...) {\n+        PrintExceptionContinue(NULL, \"ProcessMessages()\");\n+    }\n \n-        if (!fRet) {\n-            LogPrintf(\"%s(%s, %u bytes) FAILED peer=%d\\n\", __func__, SanitizeString(strCommand), nMessageSize, pfrom->id);\n-        }\n+    if (!fRet) {\n+        LogPrintf(\"%s(%s, %u bytes) FAILED peer=%d\\n\", __func__, SanitizeString(strCommand), nMessageSize, pfrom->GetId());\n+    }\n \n-        LOCK(cs_main);\n-        SendRejectsAndCheckIfBanned(pfrom, connman);\n+    LOCK(cs_main);\n+    SendRejectsAndCheckIfBanned(pfrom, connman);\n \n     return fMoreWork;\n }\n@@ -2858,7 +2847,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             pto->nNextAddrSend = PoissonNextSend(nNow, AVG_ADDRESS_BROADCAST_INTERVAL);\n             std::vector<CAddress> vAddr;\n             vAddr.reserve(pto->vAddrToSend.size());\n-            BOOST_FOREACH(const CAddress& addr, pto->vAddrToSend)\n+            for (const CAddress& addr : pto->vAddrToSend)\n             {\n                 if (!pto->addrKnown.contains(addr.GetKey()))\n                 {\n@@ -2888,6 +2877,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             // Only actively request headers from a single peer, unless we're close to today.\n             if ((nSyncStarted == 0 && fFetch) || pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {\n                 state.fSyncStarted = true;\n+                state.nHeadersSyncTimeout = GetTimeMicros() + HEADERS_DOWNLOAD_TIMEOUT_BASE + HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER * (GetAdjustedTime() - pindexBestHeader->GetBlockTime())/(consensusParams.nPowTargetSpacing);\n                 nSyncStarted++;\n                 const CBlockIndex *pindexStart = pindexBestHeader;\n                 /* If possible, start at the block preceding the currently\n@@ -2899,7 +2889,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                    got back an empty response.  */\n                 if (pindexStart->pprev)\n                     pindexStart = pindexStart->pprev;\n-                LogPrint(BCLog::NET, \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->id, pto->nStartingHeight);\n+                LogPrint(BCLog::NET, \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->GetId(), pto->nStartingHeight);\n                 connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexStart), uint256()));\n             }\n         }\n@@ -2929,14 +2919,14 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                                  (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||\n                                 pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n             const CBlockIndex *pBestIndex = NULL; // last header queued for delivery\n-            ProcessBlockAvailability(pto->id); // ensure pindexBestKnownBlock is up-to-date\n+            ProcessBlockAvailability(pto->GetId()); // ensure pindexBestKnownBlock is up-to-date\n \n             if (!fRevertToInv) {\n                 bool fFoundStartingHeader = false;\n                 // Try to find first header that our peer doesn't have, and\n                 // then send all headers past that one.  If we come across any\n                 // headers that aren't on chainActive, give up.\n-                BOOST_FOREACH(const uint256 &hash, pto->vBlockHashesToAnnounce) {\n+                for (const uint256 &hash : pto->vBlockHashesToAnnounce) {\n                     BlockMap::iterator mi = mapBlockIndex.find(hash);\n                     assert(mi != mapBlockIndex.end());\n                     const CBlockIndex *pindex = mi->second;\n@@ -2984,7 +2974,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                     // We only send up to 1 block as header-and-ids, as otherwise\n                     // probably means we're doing an initial-ish-sync or they're slow\n                     LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", __func__,\n-                            vHeaders.front().GetHash().ToString(), pto->id);\n+                            vHeaders.front().GetHash().ToString(), pto->GetId());\n \n                     int nSendFlags = state.fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n \n@@ -3014,10 +3004,10 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                         LogPrint(BCLog::NET, \"%s: %u headers, range (%s, %s), to peer=%d\\n\", __func__,\n                                 vHeaders.size(),\n                                 vHeaders.front().GetHash().ToString(),\n-                                vHeaders.back().GetHash().ToString(), pto->id);\n+                                vHeaders.back().GetHash().ToString(), pto->GetId());\n                     } else {\n                         LogPrint(BCLog::NET, \"%s: sending header %s to peer=%d\\n\", __func__,\n-                                vHeaders.front().GetHash().ToString(), pto->id);\n+                                vHeaders.front().GetHash().ToString(), pto->GetId());\n                     }\n                     connman.PushMessage(pto, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n                     state.pindexBestHeaderSent = pBestIndex;\n@@ -3046,7 +3036,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                     if (!PeerHasHeader(&state, pindex)) {\n                         pto->PushInventory(CInv(MSG_BLOCK, hashToAnnounce));\n                         LogPrint(BCLog::NET, \"%s: sending inv peer=%d hash=%s\\n\", __func__,\n-                            pto->id, hashToAnnounce.ToString());\n+                            pto->GetId(), hashToAnnounce.ToString());\n                     }\n                 }\n             }\n@@ -3062,7 +3052,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             vInv.reserve(std::max<size_t>(pto->vInventoryBlockToSend.size(), INVENTORY_BROADCAST_MAX));\n \n             // Add blocks\n-            BOOST_FOREACH(const uint256& hash, pto->vInventoryBlockToSend) {\n+            for (const uint256& hash : pto->vInventoryBlockToSend) {\n                 vInv.push_back(CInv(MSG_BLOCK, hash));\n                 if (vInv.size() == MAX_INV_SZ) {\n                     connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n@@ -3193,7 +3183,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             // Stalling only triggers when the block download window cannot move. During normal steady state,\n             // the download window should be much larger than the to-be-downloaded set of blocks, so disconnection\n             // should only happen during initial block download.\n-            LogPrintf(\"Peer=%d is stalling block download, disconnecting\\n\", pto->id);\n+            LogPrintf(\"Peer=%d is stalling block download, disconnecting\\n\", pto->GetId());\n             pto->fDisconnect = true;\n             return true;\n         }\n@@ -3206,11 +3196,44 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             QueuedBlock &queuedBlock = state.vBlocksInFlight.front();\n             int nOtherPeersWithValidatedDownloads = nPeersWithValidatedDownloads - (state.nBlocksInFlightValidHeaders > 0);\n             if (nNow > state.nDownloadingSince + consensusParams.nPowTargetSpacing * (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {\n-                LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), pto->id);\n+                LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), pto->GetId());\n                 pto->fDisconnect = true;\n                 return true;\n             }\n         }\n+        // Check for headers sync timeouts\n+        if (state.fSyncStarted && state.nHeadersSyncTimeout < std::numeric_limits<int64_t>::max()) {\n+            // Detect whether this is a stalling initial-headers-sync peer\n+            if (pindexBestHeader->GetBlockTime() <= GetAdjustedTime() - 24*60*60) {\n+                if (nNow > state.nHeadersSyncTimeout && nSyncStarted == 1 && (nPreferredDownload - state.fPreferredDownload >= 1)) {\n+                    // Disconnect a (non-whitelisted) peer if it is our only sync peer,\n+                    // and we have others we could be using instead.\n+                    // Note: If all our peers are inbound, then we won't\n+                    // disconnect our sync peer for stalling; we have bigger\n+                    // problems if we can't get any outbound peers.\n+                    if (!pto->fWhitelisted) {\n+                        LogPrintf(\"Timeout downloading headers from peer=%d, disconnecting\\n\", pto->GetId());\n+                        pto->fDisconnect = true;\n+                        return true;\n+                    } else {\n+                        LogPrintf(\"Timeout downloading headers from whitelisted peer=%d, not disconnecting\\n\", pto->GetId());\n+                        // Reset the headers sync state so that we have a\n+                        // chance to try downloading from a different peer.\n+                        // Note: this will also result in at least one more\n+                        // getheaders message to be sent to\n+                        // this peer (eventually).\n+                        state.fSyncStarted = false;\n+                        nSyncStarted--;\n+                        state.nHeadersSyncTimeout = 0;\n+                    }\n+                }\n+            } else {\n+                // After we've caught up once, reset the timeout so we can't trigger\n+                // disconnect later.\n+                state.nHeadersSyncTimeout = std::numeric_limits<int64_t>::max();\n+            }\n+        }\n+\n \n         //\n         // Message: getdata (blocks)\n@@ -3220,12 +3243,12 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             std::vector<const CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n             FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n-            BOOST_FOREACH(const CBlockIndex *pindex, vToDownload) {\n-                uint32_t nFetchFlags = GetFetchFlags(pto, pindex->pprev, consensusParams);\n+            for (const CBlockIndex *pindex : vToDownload) {\n+                uint32_t nFetchFlags = GetFetchFlags(pto);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), consensusParams, pindex);\n+                MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);\n                 LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n-                    pindex->nHeight, pto->id);\n+                    pindex->nHeight, pto->GetId());\n             }\n             if (state.nBlocksInFlight == 0 && staller != -1) {\n                 if (State(staller)->nStallingSince == 0) {\n@@ -3243,7 +3266,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             const CInv& inv = (*pto->mapAskFor.begin()).second;\n             if (!AlreadyHave(inv))\n             {\n-                LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->id);\n+                LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n                 vGetData.push_back(inv);\n                 if (vGetData.size() >= 1000)\n                 {"
      },
      {
        "sha": "db6d81e6b67f47a56e45a17815fea164c33e263a",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -17,6 +17,10 @@ static const int64_t ORPHAN_TX_EXPIRE_TIME = 20 * 60;\n static const int64_t ORPHAN_TX_EXPIRE_INTERVAL = 5 * 60;\n /** Default number of orphan+recently-replaced txn to keep around for block reconstruction */\n static const unsigned int DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN = 100;\n+/** Headers download timeout expressed in microseconds\n+ *  Timeout = base + per_header * (expected number of headers) */\n+static constexpr int64_t HEADERS_DOWNLOAD_TIMEOUT_BASE = 15 * 60 * 1000000; // 15 minutes\n+static constexpr int64_t HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER = 1000; // 1ms/header\n \n /** Register with a network node to receive its signals */\n void RegisterNodeSignals(CNodeSignals& nodeSignals);"
      },
      {
        "sha": "f31b2fc49b6bf94eb26333a45be54d76de77f004",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 19,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -15,6 +15,9 @@\n static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n static const unsigned char pchOnionCat[] = {0xFD,0x87,0xD8,0x7E,0xEB,0x43};\n \n+// 0xFD + sha256(\"bitcoin\")[0:5]\n+static const unsigned char g_internal_prefix[] = { 0xFD, 0x6B, 0x88, 0xC0, 0x87, 0x24 };\n+\n void CNetAddr::Init()\n {\n     memset(ip, 0, sizeof(ip));\n@@ -42,6 +45,18 @@ void CNetAddr::SetRaw(Network network, const uint8_t *ip_in)\n     }\n }\n \n+bool CNetAddr::SetInternal(const std::string &name)\n+{\n+    if (name.empty()) {\n+        return false;\n+    }\n+    unsigned char hash[32] = {};\n+    CSHA256().Write((const unsigned char*)name.data(), name.size()).Finalize(hash);\n+    memcpy(ip, g_internal_prefix, sizeof(g_internal_prefix));\n+    memcpy(ip + sizeof(g_internal_prefix), hash, sizeof(ip) - sizeof(g_internal_prefix));\n+    return true;\n+}\n+\n bool CNetAddr::SetSpecial(const std::string &strName)\n {\n     if (strName.size()>6 && strName.substr(strName.size() - 6, 6) == \".onion\") {\n@@ -84,7 +99,7 @@ bool CNetAddr::IsIPv4() const\n \n bool CNetAddr::IsIPv6() const\n {\n-    return (!IsIPv4() && !IsTor());\n+    return (!IsIPv4() && !IsTor() && !IsInternal());\n }\n \n bool CNetAddr::IsRFC1918() const\n@@ -179,12 +194,6 @@ bool CNetAddr::IsLocal() const\n    return false;\n }\n \n-bool CNetAddr::IsMulticast() const\n-{\n-    return    (IsIPv4() && (GetByte(3) & 0xF0) == 0xE0)\n-           || (GetByte(15) == 0xFF);\n-}\n-\n bool CNetAddr::IsValid() const\n {\n     // Cleanup 3-byte shifted addresses caused by garbage in size field\n@@ -205,6 +214,9 @@ bool CNetAddr::IsValid() const\n     if (IsRFC3849())\n         return false;\n \n+    if (IsInternal())\n+        return false;\n+\n     if (IsIPv4())\n     {\n         // INADDR_NONE\n@@ -223,11 +235,19 @@ bool CNetAddr::IsValid() const\n \n bool CNetAddr::IsRoutable() const\n {\n-    return IsValid() && !(IsRFC1918() || IsRFC2544() || IsRFC3927() || IsRFC4862() || IsRFC6598() || IsRFC5737() || (IsRFC4193() && !IsTor()) || IsRFC4843() || IsLocal());\n+    return IsValid() && !(IsRFC1918() || IsRFC2544() || IsRFC3927() || IsRFC4862() || IsRFC6598() || IsRFC5737() || (IsRFC4193() && !IsTor()) || IsRFC4843() || IsLocal() || IsInternal());\n+}\n+\n+bool CNetAddr::IsInternal() const\n+{\n+   return memcmp(ip, g_internal_prefix, sizeof(g_internal_prefix)) == 0;\n }\n \n enum Network CNetAddr::GetNetwork() const\n {\n+    if (IsInternal())\n+        return NET_INTERNAL;\n+\n     if (!IsRoutable())\n         return NET_UNROUTABLE;\n \n@@ -244,6 +264,8 @@ std::string CNetAddr::ToStringIP() const\n {\n     if (IsTor())\n         return EncodeBase32(&ip[6], 10) + \".onion\";\n+    if (IsInternal())\n+        return EncodeBase32(ip + sizeof(g_internal_prefix), sizeof(ip) - sizeof(g_internal_prefix)) + \".internal\";\n     CService serv(*this, 0);\n     struct sockaddr_storage sockaddr;\n     socklen_t socklen = sizeof(sockaddr);\n@@ -311,9 +333,15 @@ std::vector<unsigned char> CNetAddr::GetGroup() const\n         nClass = 255;\n         nBits = 0;\n     }\n-\n-    // all unroutable addresses belong to the same group\n-    if (!IsRoutable())\n+    // all internal-usage addresses get their own group\n+    if (IsInternal())\n+    {\n+        nClass = NET_INTERNAL;\n+        nStartByte = sizeof(g_internal_prefix);\n+        nBits = (sizeof(ip) - sizeof(g_internal_prefix)) * 8;\n+    }\n+    // all other unroutable addresses belong to the same group\n+    else if (!IsRoutable())\n     {\n         nClass = NET_UNROUTABLE;\n         nBits = 0;\n@@ -399,7 +427,7 @@ int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n         REACH_PRIVATE\n     };\n \n-    if (!IsRoutable())\n+    if (!IsRoutable() || IsInternal())\n         return REACH_UNREACHABLE;\n \n     int ourNet = GetExtNetwork(this);\n@@ -545,7 +573,7 @@ std::vector<unsigned char> CService::GetKey() const\n {\n      std::vector<unsigned char> vKey;\n      vKey.resize(18);\n-     memcpy(&vKey[0], ip, 16);\n+     memcpy(vKey.data(), ip, 16);\n      vKey[16] = port / 0x100;\n      vKey[17] = port & 0x0FF;\n      return vKey;\n@@ -558,7 +586,7 @@ std::string CService::ToStringPort() const\n \n std::string CService::ToStringIPPort() const\n {\n-    if (IsIPv4() || IsTor()) {\n+    if (IsIPv4() || IsTor() || IsInternal()) {\n         return ToStringIP() + \":\" + ToStringPort();\n     } else {\n         return \"[\" + ToStringIP() + \"]:\" + ToStringPort();\n@@ -570,11 +598,6 @@ std::string CService::ToString() const\n     return ToStringIPPort();\n }\n \n-void CService::SetPort(unsigned short portIn)\n-{\n-    port = portIn;\n-}\n-\n CSubNet::CSubNet():\n     valid(false)\n {"
      },
      {
        "sha": "61afe0f1fe6623e3808f770eff2365d3a00be788",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -22,6 +22,7 @@ enum Network\n     NET_IPV4,\n     NET_IPV6,\n     NET_TOR,\n+    NET_INTERNAL,\n \n     NET_MAX,\n };\n@@ -45,6 +46,12 @@ class CNetAddr\n          */\n         void SetRaw(Network network, const uint8_t *data);\n \n+        /**\n+          * Transform an arbitrary string into a non-routable ipv6 address.\n+          * Useful for mapping resolved addresses back to their source.\n+         */\n+        bool SetInternal(const std::string& name);\n+\n         bool SetSpecial(const std::string &strName); // for Tor addresses\n         bool IsIPv4() const;    // IPv4 mapped address (::FFFF:0:0/96, 0.0.0.0/0)\n         bool IsIPv6() const;    // IPv6 address (not mapped IPv4, not Tor)\n@@ -64,8 +71,8 @@ class CNetAddr\n         bool IsTor() const;\n         bool IsLocal() const;\n         bool IsRoutable() const;\n+        bool IsInternal() const;\n         bool IsValid() const;\n-        bool IsMulticast() const;\n         enum Network GetNetwork() const;\n         std::string ToString() const;\n         std::string ToStringIP() const;\n@@ -141,7 +148,6 @@ class CService : public CNetAddr\n         CService(const struct in_addr& ipv4Addr, unsigned short port);\n         CService(const struct sockaddr_in& addr);\n         void Init();\n-        void SetPort(unsigned short portIn);\n         unsigned short GetPort() const;\n         bool GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const;\n         bool SetSockAddr(const struct sockaddr* paddr);"
      },
      {
        "sha": "8952468ecd37cc2644260e73b1633d65720399f7",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 34,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -58,25 +58,6 @@ std::string GetNetworkName(enum Network net) {\n     }\n }\n \n-void SplitHostPort(std::string in, int &portOut, std::string &hostOut) {\n-    size_t colon = in.find_last_of(':');\n-    // if a : is found, and it either follows a [...], or no other : is in the string, treat it as port separator\n-    bool fHaveColon = colon != in.npos;\n-    bool fBracketed = fHaveColon && (in[0]=='[' && in[colon-1]==']'); // if there is a colon, and in[0]=='[', colon is not 0, so in[colon-1] is safe\n-    bool fMultiColon = fHaveColon && (in.find_last_of(':',colon-1) != in.npos);\n-    if (fHaveColon && (colon==0 || fBracketed || !fMultiColon)) {\n-        int32_t n;\n-        if (ParseInt32(in.substr(colon + 1), &n) && n > 0 && n < 0x10000) {\n-            in = in.substr(0, colon);\n-            portOut = n;\n-        }\n-    }\n-    if (in.size()>0 && in[0] == '[' && in[in.size()-1] == ']')\n-        hostOut = in.substr(1, in.size()-2);\n-    else\n-        hostOut = in;\n-}\n-\n bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n {\n     vIP.clear();\n@@ -108,17 +89,22 @@ bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsign\n     struct addrinfo *aiTrav = aiRes;\n     while (aiTrav != NULL && (nMaxSolutions == 0 || vIP.size() < nMaxSolutions))\n     {\n+        CNetAddr resolved;\n         if (aiTrav->ai_family == AF_INET)\n         {\n             assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in));\n-            vIP.push_back(CNetAddr(((struct sockaddr_in*)(aiTrav->ai_addr))->sin_addr));\n+            resolved = CNetAddr(((struct sockaddr_in*)(aiTrav->ai_addr))->sin_addr);\n         }\n \n         if (aiTrav->ai_family == AF_INET6)\n         {\n             assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in6));\n             struct sockaddr_in6* s6 = (struct sockaddr_in6*) aiTrav->ai_addr;\n-            vIP.push_back(CNetAddr(s6->sin6_addr, s6->sin6_scope_id));\n+            resolved = CNetAddr(s6->sin6_addr, s6->sin6_scope_id);\n+        }\n+        /* Never allow resolving to an internal address. Consider any such result invalid */\n+        if (!resolved.IsInternal()) {\n+            vIP.push_back(resolved);\n         }\n \n         aiTrav = aiTrav->ai_next;\n@@ -217,7 +203,7 @@ enum class IntrRecvError {\n  *\n  * @note This function requires that hSocket is in non-blocking mode.\n  */\n-static IntrRecvError InterruptibleRecv(char* data, size_t len, int timeout, SOCKET& hSocket)\n+static IntrRecvError InterruptibleRecv(char* data, size_t len, int timeout, const SOCKET& hSocket)\n {\n     int64_t curTime = GetTimeMillis();\n     int64_t endTime = curTime + timeout;\n@@ -428,22 +414,20 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n     if (hSocket == INVALID_SOCKET)\n         return false;\n \n-    int set = 1;\n #ifdef SO_NOSIGPIPE\n+    int set = 1;\n     // Different way of disabling SIGPIPE on BSD\n     setsockopt(hSocket, SOL_SOCKET, SO_NOSIGPIPE, (void*)&set, sizeof(int));\n #endif\n \n     //Disable Nagle's algorithm\n-#ifdef WIN32\n-    setsockopt(hSocket, IPPROTO_TCP, TCP_NODELAY, (const char*)&set, sizeof(int));\n-#else\n-    setsockopt(hSocket, IPPROTO_TCP, TCP_NODELAY, (void*)&set, sizeof(int));\n-#endif\n+    SetSocketNoDelay(hSocket);\n \n     // Set to non-blocking\n-    if (!SetSocketNonBlocking(hSocket, true))\n+    if (!SetSocketNonBlocking(hSocket, true)) {\n+        CloseSocket(hSocket);\n         return error(\"ConnectSocketDirectly: Setting socket to non-blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));\n+    }\n \n     if (connect(hSocket, (struct sockaddr*)&sockaddr, len) == SOCKET_ERROR)\n     {\n@@ -562,7 +546,7 @@ static bool ConnectThroughProxy(const proxyType &proxy, const std::string& strDe\n     // do socks negotiation\n     if (proxy.randomize_credentials) {\n         ProxyCredentials random_auth;\n-        static std::atomic_int counter;\n+        static std::atomic_int counter(0);\n         random_auth.username = random_auth.password = strprintf(\"%i\", counter++);\n         if (!Socks5(strDest, (unsigned short)port, &random_auth, hSocket))\n             return false;\n@@ -672,13 +656,14 @@ std::string NetworkErrorString(int err)\n std::string NetworkErrorString(int err)\n {\n     char buf[256];\n-    const char *s = buf;\n     buf[0] = 0;\n     /* Too bad there are two incompatible implementations of the\n      * thread-safe strerror. */\n+    const char *s;\n #ifdef STRERROR_R_CHAR_P /* GNU variant can return a pointer outside the passed buffer */\n     s = strerror_r(err, buf, sizeof(buf));\n #else /* POSIX variant always returns message in buffer */\n+    s = buf;\n     if (strerror_r(err, buf, sizeof(buf)))\n         buf[0] = 0;\n #endif\n@@ -699,7 +684,7 @@ bool CloseSocket(SOCKET& hSocket)\n     return ret != SOCKET_ERROR;\n }\n \n-bool SetSocketNonBlocking(SOCKET& hSocket, bool fNonBlocking)\n+bool SetSocketNonBlocking(const SOCKET& hSocket, bool fNonBlocking)\n {\n     if (fNonBlocking) {\n #ifdef WIN32\n@@ -709,7 +694,6 @@ bool SetSocketNonBlocking(SOCKET& hSocket, bool fNonBlocking)\n         int fFlags = fcntl(hSocket, F_GETFL, 0);\n         if (fcntl(hSocket, F_SETFL, fFlags | O_NONBLOCK) == SOCKET_ERROR) {\n #endif\n-            CloseSocket(hSocket);\n             return false;\n         }\n     } else {\n@@ -720,14 +704,20 @@ bool SetSocketNonBlocking(SOCKET& hSocket, bool fNonBlocking)\n         int fFlags = fcntl(hSocket, F_GETFL, 0);\n         if (fcntl(hSocket, F_SETFL, fFlags & ~O_NONBLOCK) == SOCKET_ERROR) {\n #endif\n-            CloseSocket(hSocket);\n             return false;\n         }\n     }\n \n     return true;\n }\n \n+bool SetSocketNoDelay(const SOCKET& hSocket)\n+{\n+    int set = 1;\n+    int rc = setsockopt(hSocket, IPPROTO_TCP, TCP_NODELAY, (const char*)&set, sizeof(int));\n+    return rc == 0;\n+}\n+\n void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;"
      },
      {
        "sha": "941da31f9ce49e766ab0114d9bb3170b3d730d08",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -39,7 +39,6 @@ class proxyType\n \n enum Network ParseNetwork(std::string net);\n std::string GetNetworkName(enum Network net);\n-void SplitHostPort(std::string in, int &portOut, std::string &hostOut);\n bool SetProxy(enum Network net, const proxyType &addrProxy);\n bool GetProxy(enum Network net, proxyType &proxyInfoOut);\n bool IsProxy(const CNetAddr &addr);\n@@ -58,7 +57,9 @@ std::string NetworkErrorString(int err);\n /** Close socket and set hSocket to INVALID_SOCKET */\n bool CloseSocket(SOCKET& hSocket);\n /** Disable or enable blocking-mode for a socket */\n-bool SetSocketNonBlocking(SOCKET& hSocket, bool fNonBlocking);\n+bool SetSocketNonBlocking(const SOCKET& hSocket, bool fNonBlocking);\n+/** Set the TCP_NODELAY flag on a socket */\n+bool SetSocketNoDelay(const SOCKET& hSocket);\n /**\n  * Convert milliseconds to a struct timeval for e.g. select.\n  */"
      },
      {
        "sha": "a089c02284f047ed68c791cddeedb8d978c91736",
        "filename": "src/policy/feerate.cpp",
        "status": "renamed",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/policy/feerate.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/policy/feerate.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/feerate.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -3,7 +3,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"amount.h\"\n+#include \"feerate.h\"\n \n #include \"tinyformat.h\"\n ",
        "previous_filename": "src/amount.cpp"
      },
      {
        "sha": "565da6c1541e9d8edec25109f31dee25cc35ed0a",
        "filename": "src/policy/feerate.h",
        "status": "added",
        "additions": 55,
        "deletions": 0,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/policy/feerate.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/policy/feerate.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/feerate.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -0,0 +1,55 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_POLICY_FEERATE_H\n+#define BITCOIN_POLICY_FEERATE_H\n+\n+#include \"amount.h\"\n+#include \"serialize.h\"\n+\n+#include <string>\n+\n+extern const std::string CURRENCY_UNIT;\n+\n+/**\n+ * Fee rate in satoshis per kilobyte: CAmount / kB\n+ */\n+class CFeeRate\n+{\n+private:\n+    CAmount nSatoshisPerK; // unit is satoshis-per-1,000-bytes\n+public:\n+    /** Fee rate of 0 satoshis per kB */\n+    CFeeRate() : nSatoshisPerK(0) { }\n+    explicit CFeeRate(const CAmount& _nSatoshisPerK): nSatoshisPerK(_nSatoshisPerK) { }\n+    /** Constructor for a fee rate in satoshis per kB. The size in bytes must not exceed (2^63 - 1)*/\n+    CFeeRate(const CAmount& nFeePaid, size_t nBytes);\n+    CFeeRate(const CFeeRate& other) { nSatoshisPerK = other.nSatoshisPerK; }\n+    /**\n+     * Return the fee in satoshis for the given size in bytes.\n+     */\n+    CAmount GetFee(size_t nBytes) const;\n+    /**\n+     * Return the fee in satoshis for a size of 1000 bytes\n+     */\n+    CAmount GetFeePerK() const { return GetFee(1000); }\n+    friend bool operator<(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK < b.nSatoshisPerK; }\n+    friend bool operator>(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK > b.nSatoshisPerK; }\n+    friend bool operator==(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK == b.nSatoshisPerK; }\n+    friend bool operator<=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK <= b.nSatoshisPerK; }\n+    friend bool operator>=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK >= b.nSatoshisPerK; }\n+    friend bool operator!=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK != b.nSatoshisPerK; }\n+    CFeeRate& operator+=(const CFeeRate& a) { nSatoshisPerK += a.nSatoshisPerK; return *this; }\n+    std::string ToString() const;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        READWRITE(nSatoshisPerK);\n+    }\n+};\n+\n+#endif //  BITCOIN_POLICY_FEERATE_H"
      },
      {
        "sha": "b9476407cf163cc9d882930f02ed5a889a2a6870",
        "filename": "src/policy/fees.cpp",
        "status": "modified",
        "additions": 706,
        "deletions": 147,
        "changes": 853,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/policy/fees.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/policy/fees.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -7,46 +7,210 @@\n #include \"policy/policy.h\"\n \n #include \"amount.h\"\n+#include \"clientversion.h\"\n #include \"primitives/transaction.h\"\n #include \"random.h\"\n #include \"streams.h\"\n #include \"txmempool.h\"\n #include \"util.h\"\n \n-void TxConfirmStats::Initialize(std::vector<double>& defaultBuckets,\n-                                unsigned int maxConfirms, double _decay)\n+static constexpr double INF_FEERATE = 1e99;\n+\n+std::string StringForFeeEstimateHorizon(FeeEstimateHorizon horizon) {\n+    static const std::map<FeeEstimateHorizon, std::string> horizon_strings = {\n+        {FeeEstimateHorizon::SHORT_HALFLIFE, \"short\"},\n+        {FeeEstimateHorizon::MED_HALFLIFE, \"medium\"},\n+        {FeeEstimateHorizon::LONG_HALFLIFE, \"long\"},\n+    };\n+    auto horizon_string = horizon_strings.find(horizon);\n+\n+    if (horizon_string == horizon_strings.end()) return \"unknown\";\n+\n+    return horizon_string->second;\n+}\n+\n+std::string StringForFeeReason(FeeReason reason) {\n+    static const std::map<FeeReason, std::string> fee_reason_strings = {\n+        {FeeReason::NONE, \"None\"},\n+        {FeeReason::HALF_ESTIMATE, \"Half Target 60% Threshold\"},\n+        {FeeReason::FULL_ESTIMATE, \"Target 85% Threshold\"},\n+        {FeeReason::DOUBLE_ESTIMATE, \"Double Target 95% Threshold\"},\n+        {FeeReason::CONSERVATIVE, \"Conservative Double Target longer horizon\"},\n+        {FeeReason::MEMPOOL_MIN, \"Mempool Min Fee\"},\n+        {FeeReason::PAYTXFEE, \"PayTxFee set\"},\n+        {FeeReason::FALLBACK, \"Fallback fee\"},\n+        {FeeReason::REQUIRED, \"Minimum Required Fee\"},\n+        {FeeReason::MAXTXFEE, \"MaxTxFee limit\"}\n+    };\n+    auto reason_string = fee_reason_strings.find(reason);\n+\n+    if (reason_string == fee_reason_strings.end()) return \"Unknown\";\n+\n+    return reason_string->second;\n+}\n+\n+bool FeeModeFromString(const std::string& mode_string, FeeEstimateMode& fee_estimate_mode) {\n+    static const std::map<std::string, FeeEstimateMode> fee_modes = {\n+        {\"UNSET\", FeeEstimateMode::UNSET},\n+        {\"ECONOMICAL\", FeeEstimateMode::ECONOMICAL},\n+        {\"CONSERVATIVE\", FeeEstimateMode::CONSERVATIVE},\n+    };\n+    auto mode = fee_modes.find(mode_string);\n+\n+    if (mode == fee_modes.end()) return false;\n+\n+    fee_estimate_mode = mode->second;\n+    return true;\n+}\n+\n+/**\n+ * We will instantiate an instance of this class to track transactions that were\n+ * included in a block. We will lump transactions into a bucket according to their\n+ * approximate feerate and then track how long it took for those txs to be included in a block\n+ *\n+ * The tracking of unconfirmed (mempool) transactions is completely independent of the\n+ * historical tracking of transactions that have been confirmed in a block.\n+ */\n+class TxConfirmStats\n+{\n+private:\n+    //Define the buckets we will group transactions into\n+    const std::vector<double>& buckets;              // The upper-bound of the range for the bucket (inclusive)\n+    const std::map<double, unsigned int>& bucketMap; // Map of bucket upper-bound to index into all vectors by bucket\n+\n+    // For each bucket X:\n+    // Count the total # of txs in each bucket\n+    // Track the historical moving average of this total over blocks\n+    std::vector<double> txCtAvg;\n+\n+    // Count the total # of txs confirmed within Y blocks in each bucket\n+    // Track the historical moving average of theses totals over blocks\n+    std::vector<std::vector<double>> confAvg; // confAvg[Y][X]\n+\n+    // Track moving avg of txs which have been evicted from the mempool\n+    // after failing to be confirmed within Y blocks\n+    std::vector<std::vector<double>> failAvg; // failAvg[Y][X]\n+\n+    // Sum the total feerate of all tx's in each bucket\n+    // Track the historical moving average of this total over blocks\n+    std::vector<double> avg;\n+\n+    // Combine the conf counts with tx counts to calculate the confirmation % for each Y,X\n+    // Combine the total value with the tx counts to calculate the avg feerate per bucket\n+\n+    double decay;\n+\n+    // Resolution (# of blocks) with which confirmations are tracked\n+    unsigned int scale;\n+\n+    // Mempool counts of outstanding transactions\n+    // For each bucket X, track the number of transactions in the mempool\n+    // that are unconfirmed for each possible confirmation value Y\n+    std::vector<std::vector<int> > unconfTxs;  //unconfTxs[Y][X]\n+    // transactions still unconfirmed after GetMaxConfirms for each bucket\n+    std::vector<int> oldUnconfTxs;\n+\n+    void resizeInMemoryCounters(size_t newbuckets);\n+\n+public:\n+    /**\n+     * Create new TxConfirmStats. This is called by BlockPolicyEstimator's\n+     * constructor with default values.\n+     * @param defaultBuckets contains the upper limits for the bucket boundaries\n+     * @param maxPeriods max number of periods to track\n+     * @param decay how much to decay the historical moving average per block\n+     */\n+    TxConfirmStats(const std::vector<double>& defaultBuckets, const std::map<double, unsigned int>& defaultBucketMap,\n+                   unsigned int maxPeriods, double decay, unsigned int scale);\n+\n+    /** Roll the circular buffer for unconfirmed txs*/\n+    void ClearCurrent(unsigned int nBlockHeight);\n+\n+    /**\n+     * Record a new transaction data point in the current block stats\n+     * @param blocksToConfirm the number of blocks it took this transaction to confirm\n+     * @param val the feerate of the transaction\n+     * @warning blocksToConfirm is 1-based and has to be >= 1\n+     */\n+    void Record(int blocksToConfirm, double val);\n+\n+    /** Record a new transaction entering the mempool*/\n+    unsigned int NewTx(unsigned int nBlockHeight, double val);\n+\n+    /** Remove a transaction from mempool tracking stats*/\n+    void removeTx(unsigned int entryHeight, unsigned int nBestSeenHeight,\n+                  unsigned int bucketIndex, bool inBlock);\n+\n+    /** Update our estimates by decaying our historical moving average and updating\n+        with the data gathered from the current block */\n+    void UpdateMovingAverages();\n+\n+    /**\n+     * Calculate a feerate estimate.  Find the lowest value bucket (or range of buckets\n+     * to make sure we have enough data points) whose transactions still have sufficient likelihood\n+     * of being confirmed within the target number of confirmations\n+     * @param confTarget target number of confirmations\n+     * @param sufficientTxVal required average number of transactions per block in a bucket range\n+     * @param minSuccess the success probability we require\n+     * @param requireGreater return the lowest feerate such that all higher values pass minSuccess OR\n+     *        return the highest feerate such that all lower values fail minSuccess\n+     * @param nBlockHeight the current block height\n+     */\n+    double EstimateMedianVal(int confTarget, double sufficientTxVal,\n+                             double minSuccess, bool requireGreater, unsigned int nBlockHeight,\n+                             EstimationResult *result = nullptr) const;\n+\n+    /** Return the max number of confirms we're tracking */\n+    unsigned int GetMaxConfirms() const { return scale * confAvg.size(); }\n+\n+    /** Write state of estimation data to a file*/\n+    void Write(CAutoFile& fileout) const;\n+\n+    /**\n+     * Read saved state of estimation data from a file and replace all internal data structures and\n+     * variables with this state.\n+     */\n+    void Read(CAutoFile& filein, int nFileVersion, size_t numBuckets);\n+};\n+\n+\n+TxConfirmStats::TxConfirmStats(const std::vector<double>& defaultBuckets,\n+                                const std::map<double, unsigned int>& defaultBucketMap,\n+                               unsigned int maxPeriods, double _decay, unsigned int _scale)\n+    : buckets(defaultBuckets), bucketMap(defaultBucketMap)\n {\n     decay = _decay;\n-    for (unsigned int i = 0; i < defaultBuckets.size(); i++) {\n-        buckets.push_back(defaultBuckets[i]);\n-        bucketMap[defaultBuckets[i]] = i;\n-    }\n-    confAvg.resize(maxConfirms);\n-    curBlockConf.resize(maxConfirms);\n-    unconfTxs.resize(maxConfirms);\n-    for (unsigned int i = 0; i < maxConfirms; i++) {\n+    scale = _scale;\n+    confAvg.resize(maxPeriods);\n+    for (unsigned int i = 0; i < maxPeriods; i++) {\n         confAvg[i].resize(buckets.size());\n-        curBlockConf[i].resize(buckets.size());\n-        unconfTxs[i].resize(buckets.size());\n+    }\n+    failAvg.resize(maxPeriods);\n+    for (unsigned int i = 0; i < maxPeriods; i++) {\n+        failAvg[i].resize(buckets.size());\n     }\n \n-    oldUnconfTxs.resize(buckets.size());\n-    curBlockTxCt.resize(buckets.size());\n     txCtAvg.resize(buckets.size());\n-    curBlockVal.resize(buckets.size());\n     avg.resize(buckets.size());\n+\n+    resizeInMemoryCounters(buckets.size());\n }\n \n-// Zero out the data for the current block\n+void TxConfirmStats::resizeInMemoryCounters(size_t newbuckets) {\n+    // newbuckets must be passed in because the buckets referred to during Read have not been updated yet.\n+    unconfTxs.resize(GetMaxConfirms());\n+    for (unsigned int i = 0; i < unconfTxs.size(); i++) {\n+        unconfTxs[i].resize(newbuckets);\n+    }\n+    oldUnconfTxs.resize(newbuckets);\n+}\n+\n+// Roll the unconfirmed txs circular buffer\n void TxConfirmStats::ClearCurrent(unsigned int nBlockHeight)\n {\n     for (unsigned int j = 0; j < buckets.size(); j++) {\n         oldUnconfTxs[j] += unconfTxs[nBlockHeight%unconfTxs.size()][j];\n         unconfTxs[nBlockHeight%unconfTxs.size()][j] = 0;\n-        for (unsigned int i = 0; i < curBlockConf.size(); i++)\n-            curBlockConf[i][j] = 0;\n-        curBlockTxCt[j] = 0;\n-        curBlockVal[j] = 0;\n     }\n }\n \n@@ -56,33 +220,38 @@ void TxConfirmStats::Record(int blocksToConfirm, double val)\n     // blocksToConfirm is 1-based\n     if (blocksToConfirm < 1)\n         return;\n+    int periodsToConfirm = (blocksToConfirm + scale - 1)/scale;\n     unsigned int bucketindex = bucketMap.lower_bound(val)->second;\n-    for (size_t i = blocksToConfirm; i <= curBlockConf.size(); i++) {\n-        curBlockConf[i - 1][bucketindex]++;\n+    for (size_t i = periodsToConfirm; i <= confAvg.size(); i++) {\n+        confAvg[i - 1][bucketindex]++;\n     }\n-    curBlockTxCt[bucketindex]++;\n-    curBlockVal[bucketindex] += val;\n+    txCtAvg[bucketindex]++;\n+    avg[bucketindex] += val;\n }\n \n void TxConfirmStats::UpdateMovingAverages()\n {\n     for (unsigned int j = 0; j < buckets.size(); j++) {\n         for (unsigned int i = 0; i < confAvg.size(); i++)\n-            confAvg[i][j] = confAvg[i][j] * decay + curBlockConf[i][j];\n-        avg[j] = avg[j] * decay + curBlockVal[j];\n-        txCtAvg[j] = txCtAvg[j] * decay + curBlockTxCt[j];\n+            confAvg[i][j] = confAvg[i][j] * decay;\n+        for (unsigned int i = 0; i < failAvg.size(); i++)\n+            failAvg[i][j] = failAvg[i][j] * decay;\n+        avg[j] = avg[j] * decay;\n+        txCtAvg[j] = txCtAvg[j] * decay;\n     }\n }\n \n // returns -1 on error conditions\n double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n                                          double successBreakPoint, bool requireGreater,\n-                                         unsigned int nBlockHeight)\n+                                         unsigned int nBlockHeight, EstimationResult *result) const\n {\n     // Counters for a bucket (or range of buckets)\n     double nConf = 0; // Number of tx's confirmed within the confTarget\n     double totalNum = 0; // Total number of tx's that were ever confirmed\n     int extraNum = 0;  // Number of tx's still in mempool for confTarget or longer\n+    double failNum = 0; // Number of tx's that were never confirmed but removed from the mempool after confTarget\n+    int periodTarget = (confTarget + scale - 1)/scale;\n \n     int maxbucketindex = buckets.size() - 1;\n \n@@ -105,12 +274,21 @@ double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n \n     bool foundAnswer = false;\n     unsigned int bins = unconfTxs.size();\n+    bool newBucketRange = true;\n+    bool passing = true;\n+    EstimatorBucket passBucket;\n+    EstimatorBucket failBucket;\n \n     // Start counting from highest(default) or lowest feerate transactions\n     for (int bucket = startbucket; bucket >= 0 && bucket <= maxbucketindex; bucket += step) {\n+        if (newBucketRange) {\n+            curNearBucket = bucket;\n+            newBucketRange = false;\n+        }\n         curFarBucket = bucket;\n-        nConf += confAvg[confTarget - 1][bucket];\n+        nConf += confAvg[periodTarget - 1][bucket];\n         totalNum += txCtAvg[bucket];\n+        failNum += failAvg[periodTarget - 1][bucket];\n         for (unsigned int confct = confTarget; confct < GetMaxConfirms(); confct++)\n             extraNum += unconfTxs[(nBlockHeight - confct)%bins][bucket];\n         extraNum += oldUnconfTxs[bucket];\n@@ -119,24 +297,41 @@ double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n         // (Only count the confirmed data points, so that each confirmation count\n         // will be looking at the same amount of data and same bucket breaks)\n         if (totalNum >= sufficientTxVal / (1 - decay)) {\n-            double curPct = nConf / (totalNum + extraNum);\n+            double curPct = nConf / (totalNum + failNum + extraNum);\n \n             // Check to see if we are no longer getting confirmed at the success rate\n-            if (requireGreater && curPct < successBreakPoint)\n-                break;\n-            if (!requireGreater && curPct > successBreakPoint)\n-                break;\n-\n+            if ((requireGreater && curPct < successBreakPoint) || (!requireGreater && curPct > successBreakPoint)) {\n+                if (passing == true) {\n+                    // First time we hit a failure record the failed bucket\n+                    unsigned int failMinBucket = std::min(curNearBucket, curFarBucket);\n+                    unsigned int failMaxBucket = std::max(curNearBucket, curFarBucket);\n+                    failBucket.start = failMinBucket ? buckets[failMinBucket - 1] : 0;\n+                    failBucket.end = buckets[failMaxBucket];\n+                    failBucket.withinTarget = nConf;\n+                    failBucket.totalConfirmed = totalNum;\n+                    failBucket.inMempool = extraNum;\n+                    failBucket.leftMempool = failNum;\n+                    passing = false;\n+                }\n+                continue;\n+            }\n             // Otherwise update the cumulative stats, and the bucket variables\n             // and reset the counters\n             else {\n+                failBucket = EstimatorBucket(); // Reset any failed bucket, currently passing\n                 foundAnswer = true;\n+                passing = true;\n+                passBucket.withinTarget = nConf;\n                 nConf = 0;\n+                passBucket.totalConfirmed = totalNum;\n                 totalNum = 0;\n+                passBucket.inMempool = extraNum;\n+                passBucket.leftMempool = failNum;\n+                failNum = 0;\n                 extraNum = 0;\n                 bestNearBucket = curNearBucket;\n                 bestFarBucket = curFarBucket;\n-                curNearBucket = bucket + step;\n+                newBucketRange = true;\n             }\n         }\n     }\n@@ -148,8 +343,8 @@ double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n     // Find the bucket with the median transaction and then report the average feerate from that bucket\n     // This is a compromise between finding the median which we can't since we don't save all tx's\n     // and reporting the average which is less accurate\n-    unsigned int minBucket = bestNearBucket < bestFarBucket ? bestNearBucket : bestFarBucket;\n-    unsigned int maxBucket = bestNearBucket > bestFarBucket ? bestNearBucket : bestFarBucket;\n+    unsigned int minBucket = std::min(bestNearBucket, bestFarBucket);\n+    unsigned int maxBucket = std::max(bestNearBucket, bestFarBucket);\n     for (unsigned int j = minBucket; j <= maxBucket; j++) {\n         txSum += txCtAvg[j];\n     }\n@@ -163,83 +358,109 @@ double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n                 break;\n             }\n         }\n+\n+        passBucket.start = minBucket ? buckets[minBucket-1] : 0;\n+        passBucket.end = buckets[maxBucket];\n+    }\n+\n+    // If we were passing until we reached last few buckets with insufficient data, then report those as failed\n+    if (passing && !newBucketRange) {\n+        unsigned int failMinBucket = std::min(curNearBucket, curFarBucket);\n+        unsigned int failMaxBucket = std::max(curNearBucket, curFarBucket);\n+        failBucket.start = failMinBucket ? buckets[failMinBucket - 1] : 0;\n+        failBucket.end = buckets[failMaxBucket];\n+        failBucket.withinTarget = nConf;\n+        failBucket.totalConfirmed = totalNum;\n+        failBucket.inMempool = extraNum;\n+        failBucket.leftMempool = failNum;\n     }\n \n-    LogPrint(BCLog::ESTIMATEFEE, \"%3d: For conf success %s %4.2f need feerate %s: %12.5g from buckets %8g - %8g  Cur Bucket stats %6.2f%%  %8.1f/(%.1f+%d mempool)\\n\",\n-             confTarget, requireGreater ? \">\" : \"<\", successBreakPoint,\n-             requireGreater ? \">\" : \"<\", median, buckets[minBucket], buckets[maxBucket],\n-             100 * nConf / (totalNum + extraNum), nConf, totalNum, extraNum);\n+    LogPrint(BCLog::ESTIMATEFEE, \"FeeEst: %d %s%.0f%% decay %.5f: feerate: %g from (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\",\n+             confTarget, requireGreater ? \">\" : \"<\", 100.0 * successBreakPoint, decay,\n+             median, passBucket.start, passBucket.end,\n+             100 * passBucket.withinTarget / (passBucket.totalConfirmed + passBucket.inMempool + passBucket.leftMempool),\n+             passBucket.withinTarget, passBucket.totalConfirmed, passBucket.inMempool, passBucket.leftMempool,\n+             failBucket.start, failBucket.end,\n+             100 * failBucket.withinTarget / (failBucket.totalConfirmed + failBucket.inMempool + failBucket.leftMempool),\n+             failBucket.withinTarget, failBucket.totalConfirmed, failBucket.inMempool, failBucket.leftMempool);\n+\n \n+    if (result) {\n+        result->pass = passBucket;\n+        result->fail = failBucket;\n+        result->decay = decay;\n+        result->scale = scale;\n+    }\n     return median;\n }\n \n-void TxConfirmStats::Write(CAutoFile& fileout)\n+void TxConfirmStats::Write(CAutoFile& fileout) const\n {\n     fileout << decay;\n-    fileout << buckets;\n+    fileout << scale;\n     fileout << avg;\n     fileout << txCtAvg;\n     fileout << confAvg;\n+    fileout << failAvg;\n }\n \n-void TxConfirmStats::Read(CAutoFile& filein)\n+void TxConfirmStats::Read(CAutoFile& filein, int nFileVersion, size_t numBuckets)\n {\n-    // Read data file into temporary variables and do some very basic sanity checking\n-    std::vector<double> fileBuckets;\n-    std::vector<double> fileAvg;\n-    std::vector<std::vector<double> > fileConfAvg;\n-    std::vector<double> fileTxCtAvg;\n-    double fileDecay;\n-    size_t maxConfirms;\n-    size_t numBuckets;\n-\n-    filein >> fileDecay;\n-    if (fileDecay <= 0 || fileDecay >= 1)\n-        throw std::runtime_error(\"Corrupt estimates file. Decay must be between 0 and 1 (non-inclusive)\");\n-    filein >> fileBuckets;\n-    numBuckets = fileBuckets.size();\n-    if (numBuckets <= 1 || numBuckets > 1000)\n-        throw std::runtime_error(\"Corrupt estimates file. Must have between 2 and 1000 feerate buckets\");\n-    filein >> fileAvg;\n-    if (fileAvg.size() != numBuckets)\n+    // Read data file and do some very basic sanity checking\n+    // buckets and bucketMap are not updated yet, so don't access them\n+    // If there is a read failure, we'll just discard this entire object anyway\n+    size_t maxConfirms, maxPeriods;\n+\n+    // The current version will store the decay with each individual TxConfirmStats and also keep a scale factor\n+    if (nFileVersion >= 149900) {\n+        filein >> decay;\n+        if (decay <= 0 || decay >= 1) {\n+            throw std::runtime_error(\"Corrupt estimates file. Decay must be between 0 and 1 (non-inclusive)\");\n+        }\n+        filein >> scale;\n+    }\n+\n+    filein >> avg;\n+    if (avg.size() != numBuckets) {\n         throw std::runtime_error(\"Corrupt estimates file. Mismatch in feerate average bucket count\");\n-    filein >> fileTxCtAvg;\n-    if (fileTxCtAvg.size() != numBuckets)\n+    }\n+    filein >> txCtAvg;\n+    if (txCtAvg.size() != numBuckets) {\n         throw std::runtime_error(\"Corrupt estimates file. Mismatch in tx count bucket count\");\n-    filein >> fileConfAvg;\n-    maxConfirms = fileConfAvg.size();\n-    if (maxConfirms <= 0 || maxConfirms > 6 * 24 * 7) // one week\n-        throw std::runtime_error(\"Corrupt estimates file.  Must maintain estimates for between 1 and 1008 (one week) confirms\");\n-    for (unsigned int i = 0; i < maxConfirms; i++) {\n-        if (fileConfAvg[i].size() != numBuckets)\n-            throw std::runtime_error(\"Corrupt estimates file. Mismatch in feerate conf average bucket count\");\n     }\n-    // Now that we've processed the entire feerate estimate data file and not\n-    // thrown any errors, we can copy it to our data structures\n-    decay = fileDecay;\n-    buckets = fileBuckets;\n-    avg = fileAvg;\n-    confAvg = fileConfAvg;\n-    txCtAvg = fileTxCtAvg;\n-    bucketMap.clear();\n+    filein >> confAvg;\n+    maxPeriods = confAvg.size();\n+    maxConfirms = scale * maxPeriods;\n \n-    // Resize the current block variables which aren't stored in the data file\n-    // to match the number of confirms and buckets\n-    curBlockConf.resize(maxConfirms);\n-    for (unsigned int i = 0; i < maxConfirms; i++) {\n-        curBlockConf[i].resize(buckets.size());\n+    if (maxConfirms <= 0 || maxConfirms > 6 * 24 * 7) { // one week\n+        throw std::runtime_error(\"Corrupt estimates file.  Must maintain estimates for between 1 and 1008 (one week) confirms\");\n+    }\n+    for (unsigned int i = 0; i < maxPeriods; i++) {\n+        if (confAvg[i].size() != numBuckets) {\n+            throw std::runtime_error(\"Corrupt estimates file. Mismatch in feerate conf average bucket count\");\n+        }\n     }\n-    curBlockTxCt.resize(buckets.size());\n-    curBlockVal.resize(buckets.size());\n \n-    unconfTxs.resize(maxConfirms);\n-    for (unsigned int i = 0; i < maxConfirms; i++) {\n-        unconfTxs[i].resize(buckets.size());\n+    if (nFileVersion >= 149900) {\n+        filein >> failAvg;\n+        if (maxPeriods != failAvg.size()) {\n+            throw std::runtime_error(\"Corrupt estimates file. Mismatch in confirms tracked for failures\");\n+        }\n+        for (unsigned int i = 0; i < maxPeriods; i++) {\n+            if (failAvg[i].size() != numBuckets) {\n+                throw std::runtime_error(\"Corrupt estimates file. Mismatch in one of failure average bucket counts\");\n+            }\n+        }\n+    } else {\n+        failAvg.resize(confAvg.size());\n+        for (unsigned int i = 0; i < failAvg.size(); i++) {\n+            failAvg[i].resize(numBuckets);\n+        }\n     }\n-    oldUnconfTxs.resize(buckets.size());\n \n-    for (unsigned int i = 0; i < buckets.size(); i++)\n-        bucketMap[buckets[i]] = i;\n+    // Resize the current block variables which aren't stored in the data file\n+    // to match the number of confirms and buckets\n+    resizeInMemoryCounters(numBuckets);\n \n     LogPrint(BCLog::ESTIMATEFEE, \"Reading estimates: %u buckets counting confirms up to %u blocks\\n\",\n              numBuckets, maxConfirms);\n@@ -253,7 +474,7 @@ unsigned int TxConfirmStats::NewTx(unsigned int nBlockHeight, double val)\n     return bucketindex;\n }\n \n-void TxConfirmStats::removeTx(unsigned int entryHeight, unsigned int nBestSeenHeight, unsigned int bucketindex)\n+void TxConfirmStats::removeTx(unsigned int entryHeight, unsigned int nBestSeenHeight, unsigned int bucketindex, bool inBlock)\n {\n     //nBestSeenHeight is not updated yet for the new block\n     int blocksAgo = nBestSeenHeight - entryHeight;\n@@ -281,18 +502,27 @@ void TxConfirmStats::removeTx(unsigned int entryHeight, unsigned int nBestSeenHe\n                      blockIndex, bucketindex);\n         }\n     }\n+    if (!inBlock && (unsigned int)blocksAgo >= scale) { // Only counts as a failure if not confirmed for entire period\n+        unsigned int periodsAgo = blocksAgo / scale;\n+        for (size_t i = 0; i < periodsAgo && i < failAvg.size(); i++) {\n+            failAvg[i][bucketindex]++;\n+        }\n+    }\n }\n \n // This function is called from CTxMemPool::removeUnchecked to ensure\n // txs removed from the mempool for any reason are no longer\n // tracked. Txs that were part of a block have already been removed in\n // processBlockTx to ensure they are never double tracked, but it is\n // of no harm to try to remove them again.\n-bool CBlockPolicyEstimator::removeTx(uint256 hash)\n+bool CBlockPolicyEstimator::removeTx(uint256 hash, bool inBlock)\n {\n+    LOCK(cs_feeEstimator);\n     std::map<uint256, TxStatsInfo>::iterator pos = mapMemPoolTxs.find(hash);\n     if (pos != mapMemPoolTxs.end()) {\n-        feeStats.removeTx(pos->second.blockHeight, nBestSeenHeight, pos->second.bucketIndex);\n+        feeStats->removeTx(pos->second.blockHeight, nBestSeenHeight, pos->second.bucketIndex, inBlock);\n+        shortStats->removeTx(pos->second.blockHeight, nBestSeenHeight, pos->second.bucketIndex, inBlock);\n+        longStats->removeTx(pos->second.blockHeight, nBestSeenHeight, pos->second.bucketIndex, inBlock);\n         mapMemPoolTxs.erase(hash);\n         return true;\n     } else {\n@@ -301,20 +531,33 @@ bool CBlockPolicyEstimator::removeTx(uint256 hash)\n }\n \n CBlockPolicyEstimator::CBlockPolicyEstimator()\n-    : nBestSeenHeight(0), trackedTxs(0), untrackedTxs(0)\n+    : nBestSeenHeight(0), firstRecordedHeight(0), historicalFirst(0), historicalBest(0), trackedTxs(0), untrackedTxs(0)\n {\n     static_assert(MIN_BUCKET_FEERATE > 0, \"Min feerate must be nonzero\");\n-    minTrackedFee = CFeeRate(MIN_BUCKET_FEERATE);\n-    std::vector<double> vfeelist;\n-    for (double bucketBoundary = minTrackedFee.GetFeePerK(); bucketBoundary <= MAX_BUCKET_FEERATE; bucketBoundary *= FEE_SPACING) {\n-        vfeelist.push_back(bucketBoundary);\n+    size_t bucketIndex = 0;\n+    for (double bucketBoundary = MIN_BUCKET_FEERATE; bucketBoundary <= MAX_BUCKET_FEERATE; bucketBoundary *= FEE_SPACING, bucketIndex++) {\n+        buckets.push_back(bucketBoundary);\n+        bucketMap[bucketBoundary] = bucketIndex;\n     }\n-    vfeelist.push_back(INF_FEERATE);\n-    feeStats.Initialize(vfeelist, MAX_BLOCK_CONFIRMS, DEFAULT_DECAY);\n+    buckets.push_back(INF_FEERATE);\n+    bucketMap[INF_FEERATE] = bucketIndex;\n+    assert(bucketMap.size() == buckets.size());\n+\n+    feeStats = new TxConfirmStats(buckets, bucketMap, MED_BLOCK_PERIODS, MED_DECAY, MED_SCALE);\n+    shortStats = new TxConfirmStats(buckets, bucketMap, SHORT_BLOCK_PERIODS, SHORT_DECAY, SHORT_SCALE);\n+    longStats = new TxConfirmStats(buckets, bucketMap, LONG_BLOCK_PERIODS, LONG_DECAY, LONG_SCALE);\n+}\n+\n+CBlockPolicyEstimator::~CBlockPolicyEstimator()\n+{\n+    delete feeStats;\n+    delete shortStats;\n+    delete longStats;\n }\n \n void CBlockPolicyEstimator::processTransaction(const CTxMemPoolEntry& entry, bool validFeeEstimate)\n {\n+    LOCK(cs_feeEstimator);\n     unsigned int txHeight = entry.GetHeight();\n     uint256 hash = entry.GetTx().GetHash();\n     if (mapMemPoolTxs.count(hash)) {\n@@ -343,12 +586,17 @@ void CBlockPolicyEstimator::processTransaction(const CTxMemPoolEntry& entry, boo\n     CFeeRate feeRate(entry.GetFee(), entry.GetTxSize());\n \n     mapMemPoolTxs[hash].blockHeight = txHeight;\n-    mapMemPoolTxs[hash].bucketIndex = feeStats.NewTx(txHeight, (double)feeRate.GetFeePerK());\n+    unsigned int bucketIndex = feeStats->NewTx(txHeight, (double)feeRate.GetFeePerK());\n+    mapMemPoolTxs[hash].bucketIndex = bucketIndex;\n+    unsigned int bucketIndex2 = shortStats->NewTx(txHeight, (double)feeRate.GetFeePerK());\n+    assert(bucketIndex == bucketIndex2);\n+    unsigned int bucketIndex3 = longStats->NewTx(txHeight, (double)feeRate.GetFeePerK());\n+    assert(bucketIndex == bucketIndex3);\n }\n \n bool CBlockPolicyEstimator::processBlockTx(unsigned int nBlockHeight, const CTxMemPoolEntry* entry)\n {\n-    if (!removeTx(entry->GetTx().GetHash())) {\n+    if (!removeTx(entry->GetTx().GetHash(), true)) {\n         // This transaction wasn't being tracked for fee estimation\n         return false;\n     }\n@@ -367,13 +615,16 @@ bool CBlockPolicyEstimator::processBlockTx(unsigned int nBlockHeight, const CTxM\n     // Feerates are stored and reported as BTC-per-kb:\n     CFeeRate feeRate(entry->GetFee(), entry->GetTxSize());\n \n-    feeStats.Record(blocksToConfirm, (double)feeRate.GetFeePerK());\n+    feeStats->Record(blocksToConfirm, (double)feeRate.GetFeePerK());\n+    shortStats->Record(blocksToConfirm, (double)feeRate.GetFeePerK());\n+    longStats->Record(blocksToConfirm, (double)feeRate.GetFeePerK());\n     return true;\n }\n \n void CBlockPolicyEstimator::processBlock(unsigned int nBlockHeight,\n                                          std::vector<const CTxMemPoolEntry*>& entries)\n {\n+    LOCK(cs_feeEstimator);\n     if (nBlockHeight <= nBestSeenHeight) {\n         // Ignore side chains and re-orgs; assuming they are random\n         // they don't affect the estimate.\n@@ -388,92 +639,400 @@ void CBlockPolicyEstimator::processBlock(unsigned int nBlockHeight,\n     // of unconfirmed txs to remove from tracking.\n     nBestSeenHeight = nBlockHeight;\n \n-    // Clear the current block state and update unconfirmed circular buffer\n-    feeStats.ClearCurrent(nBlockHeight);\n+    // Update unconfirmed circular buffer\n+    feeStats->ClearCurrent(nBlockHeight);\n+    shortStats->ClearCurrent(nBlockHeight);\n+    longStats->ClearCurrent(nBlockHeight);\n+\n+    // Decay all exponential averages\n+    feeStats->UpdateMovingAverages();\n+    shortStats->UpdateMovingAverages();\n+    longStats->UpdateMovingAverages();\n \n     unsigned int countedTxs = 0;\n-    // Repopulate the current block states\n-    for (unsigned int i = 0; i < entries.size(); i++) {\n-        if (processBlockTx(nBlockHeight, entries[i]))\n+    // Update averages with data points from current block\n+    for (const auto& entry : entries) {\n+        if (processBlockTx(nBlockHeight, entry))\n             countedTxs++;\n     }\n \n-    // Update all exponential averages with the current block state\n-    feeStats.UpdateMovingAverages();\n+    if (firstRecordedHeight == 0 && countedTxs > 0) {\n+        firstRecordedHeight = nBestSeenHeight;\n+        LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy first recorded height %u\\n\", firstRecordedHeight);\n+    }\n+\n \n-    LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy after updating estimates for %u of %u txs in block, since last block %u of %u tracked, new mempool map size %u\\n\",\n-             countedTxs, entries.size(), trackedTxs, trackedTxs + untrackedTxs, mapMemPoolTxs.size());\n+    LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy estimates updated by %u of %u block txs, since last block %u of %u tracked, mempool map size %u, max target %u from %s\\n\",\n+             countedTxs, entries.size(), trackedTxs, trackedTxs + untrackedTxs, mapMemPoolTxs.size(),\n+             MaxUsableEstimate(), HistoricalBlockSpan() > BlockSpan() ? \"historical\" : \"current\");\n \n     trackedTxs = 0;\n     untrackedTxs = 0;\n }\n \n-CFeeRate CBlockPolicyEstimator::estimateFee(int confTarget)\n+CFeeRate CBlockPolicyEstimator::estimateFee(int confTarget) const\n {\n-    // Return failure if trying to analyze a target we're not tracking\n     // It's not possible to get reasonable estimates for confTarget of 1\n-    if (confTarget <= 1 || (unsigned int)confTarget > feeStats.GetMaxConfirms())\n+    if (confTarget <= 1)\n+        return CFeeRate(0);\n+\n+    return estimateRawFee(confTarget, DOUBLE_SUCCESS_PCT, FeeEstimateHorizon::MED_HALFLIFE);\n+}\n+\n+CFeeRate CBlockPolicyEstimator::estimateRawFee(int confTarget, double successThreshold, FeeEstimateHorizon horizon, EstimationResult* result) const\n+{\n+    TxConfirmStats* stats;\n+    double sufficientTxs = SUFFICIENT_FEETXS;\n+    switch (horizon) {\n+    case FeeEstimateHorizon::SHORT_HALFLIFE: {\n+        stats = shortStats;\n+        sufficientTxs = SUFFICIENT_TXS_SHORT;\n+        break;\n+    }\n+    case FeeEstimateHorizon::MED_HALFLIFE: {\n+        stats = feeStats;\n+        break;\n+    }\n+    case FeeEstimateHorizon::LONG_HALFLIFE: {\n+        stats = longStats;\n+        break;\n+    }\n+    default: {\n+        throw std::out_of_range(\"CBlockPolicyEstimator::estimateRawFee unknown FeeEstimateHorizon\");\n+    }\n+    }\n+\n+    LOCK(cs_feeEstimator);\n+    // Return failure if trying to analyze a target we're not tracking\n+    if (confTarget <= 0 || (unsigned int)confTarget > stats->GetMaxConfirms())\n+        return CFeeRate(0);\n+    if (successThreshold > 1)\n         return CFeeRate(0);\n \n-    double median = feeStats.EstimateMedianVal(confTarget, SUFFICIENT_FEETXS, MIN_SUCCESS_PCT, true, nBestSeenHeight);\n+    double median = stats->EstimateMedianVal(confTarget, sufficientTxs, successThreshold, true, nBestSeenHeight, result);\n \n     if (median < 0)\n         return CFeeRate(0);\n \n     return CFeeRate(median);\n }\n \n-CFeeRate CBlockPolicyEstimator::estimateSmartFee(int confTarget, int *answerFoundAtTarget, const CTxMemPool& pool)\n+unsigned int CBlockPolicyEstimator::HighestTargetTracked(FeeEstimateHorizon horizon) const\n {\n-    if (answerFoundAtTarget)\n-        *answerFoundAtTarget = confTarget;\n+    switch (horizon) {\n+    case FeeEstimateHorizon::SHORT_HALFLIFE: {\n+        return shortStats->GetMaxConfirms();\n+    }\n+    case FeeEstimateHorizon::MED_HALFLIFE: {\n+        return feeStats->GetMaxConfirms();\n+    }\n+    case FeeEstimateHorizon::LONG_HALFLIFE: {\n+        return longStats->GetMaxConfirms();\n+    }\n+    default: {\n+        throw std::out_of_range(\"CBlockPolicyEstimator::HighestTargetTracked unknown FeeEstimateHorizon\");\n+    }\n+    }\n+}\n+\n+unsigned int CBlockPolicyEstimator::BlockSpan() const\n+{\n+    if (firstRecordedHeight == 0) return 0;\n+    assert(nBestSeenHeight >= firstRecordedHeight);\n+\n+    return nBestSeenHeight - firstRecordedHeight;\n+}\n+\n+unsigned int CBlockPolicyEstimator::HistoricalBlockSpan() const\n+{\n+    if (historicalFirst == 0) return 0;\n+    assert(historicalBest >= historicalFirst);\n+\n+    if (nBestSeenHeight - historicalBest > OLDEST_ESTIMATE_HISTORY) return 0;\n+\n+    return historicalBest - historicalFirst;\n+}\n+\n+unsigned int CBlockPolicyEstimator::MaxUsableEstimate() const\n+{\n+    // Block spans are divided by 2 to make sure there are enough potential failing data points for the estimate\n+    return std::min(longStats->GetMaxConfirms(), std::max(BlockSpan(), HistoricalBlockSpan()) / 2);\n+}\n+\n+/** Return a fee estimate at the required successThreshold from the shortest\n+ * time horizon which tracks confirmations up to the desired target.  If\n+ * checkShorterHorizon is requested, also allow short time horizon estimates\n+ * for a lower target to reduce the given answer */\n+double CBlockPolicyEstimator::estimateCombinedFee(unsigned int confTarget, double successThreshold, bool checkShorterHorizon, EstimationResult *result) const\n+{\n+    double estimate = -1;\n+    if (confTarget >= 1 && confTarget <= longStats->GetMaxConfirms()) {\n+        // Find estimate from shortest time horizon possible\n+        if (confTarget <= shortStats->GetMaxConfirms()) { // short horizon\n+            estimate = shortStats->EstimateMedianVal(confTarget, SUFFICIENT_TXS_SHORT, successThreshold, true, nBestSeenHeight, result);\n+        }\n+        else if (confTarget <= feeStats->GetMaxConfirms()) { // medium horizon\n+            estimate = feeStats->EstimateMedianVal(confTarget, SUFFICIENT_FEETXS, successThreshold, true, nBestSeenHeight, result);\n+        }\n+        else { // long horizon\n+            estimate = longStats->EstimateMedianVal(confTarget, SUFFICIENT_FEETXS, successThreshold, true, nBestSeenHeight, result);\n+        }\n+        if (checkShorterHorizon) {\n+            EstimationResult tempResult;\n+            // If a lower confTarget from a more recent horizon returns a lower answer use it.\n+            if (confTarget > feeStats->GetMaxConfirms()) {\n+                double medMax = feeStats->EstimateMedianVal(feeStats->GetMaxConfirms(), SUFFICIENT_FEETXS, successThreshold, true, nBestSeenHeight, &tempResult);\n+                if (medMax > 0 && (estimate == -1 || medMax < estimate)) {\n+                    estimate = medMax;\n+                    if (result) *result = tempResult;\n+                }\n+            }\n+            if (confTarget > shortStats->GetMaxConfirms()) {\n+                double shortMax = shortStats->EstimateMedianVal(shortStats->GetMaxConfirms(), SUFFICIENT_TXS_SHORT, successThreshold, true, nBestSeenHeight, &tempResult);\n+                if (shortMax > 0 && (estimate == -1 || shortMax < estimate)) {\n+                    estimate = shortMax;\n+                    if (result) *result = tempResult;\n+                }\n+            }\n+        }\n+    }\n+    return estimate;\n+}\n+\n+/** Ensure that for a conservative estimate, the DOUBLE_SUCCESS_PCT is also met\n+ * at 2 * target for any longer time horizons.\n+ */\n+double CBlockPolicyEstimator::estimateConservativeFee(unsigned int doubleTarget, EstimationResult *result) const\n+{\n+    double estimate = -1;\n+    EstimationResult tempResult;\n+    if (doubleTarget <= shortStats->GetMaxConfirms()) {\n+        estimate = feeStats->EstimateMedianVal(doubleTarget, SUFFICIENT_FEETXS, DOUBLE_SUCCESS_PCT, true, nBestSeenHeight, result);\n+    }\n+    if (doubleTarget <= feeStats->GetMaxConfirms()) {\n+        double longEstimate = longStats->EstimateMedianVal(doubleTarget, SUFFICIENT_FEETXS, DOUBLE_SUCCESS_PCT, true, nBestSeenHeight, &tempResult);\n+        if (longEstimate > estimate) {\n+            estimate = longEstimate;\n+            if (result) *result = tempResult;\n+        }\n+    }\n+    return estimate;\n+}\n+\n+/** estimateSmartFee returns the max of the feerates calculated with a 60%\n+ * threshold required at target / 2, an 85% threshold required at target and a\n+ * 95% threshold required at 2 * target.  Each calculation is performed at the\n+ * shortest time horizon which tracks the required target.  Conservative\n+ * estimates, however, required the 95% threshold at 2 * target be met for any\n+ * longer time horizons also.\n+ */\n+CFeeRate CBlockPolicyEstimator::estimateSmartFee(int confTarget, FeeCalculation *feeCalc, bool conservative) const\n+{\n+    LOCK(cs_feeEstimator);\n+\n+    if (feeCalc) {\n+        feeCalc->desiredTarget = confTarget;\n+        feeCalc->returnedTarget = confTarget;\n+    }\n+\n+    double median = -1;\n+    EstimationResult tempResult;\n+\n     // Return failure if trying to analyze a target we're not tracking\n-    if (confTarget <= 0 || (unsigned int)confTarget > feeStats.GetMaxConfirms())\n-        return CFeeRate(0);\n+    if (confTarget <= 0 || (unsigned int)confTarget > longStats->GetMaxConfirms()) {\n+        return CFeeRate(0);  // error condition\n+    }\n \n     // It's not possible to get reasonable estimates for confTarget of 1\n-    if (confTarget == 1)\n-        confTarget = 2;\n+    if (confTarget == 1) confTarget = 2;\n \n-    double median = -1;\n-    while (median < 0 && (unsigned int)confTarget <= feeStats.GetMaxConfirms()) {\n-        median = feeStats.EstimateMedianVal(confTarget++, SUFFICIENT_FEETXS, MIN_SUCCESS_PCT, true, nBestSeenHeight);\n+    unsigned int maxUsableEstimate = MaxUsableEstimate();\n+    if ((unsigned int)confTarget > maxUsableEstimate) {\n+        confTarget = maxUsableEstimate;\n     }\n+    if (feeCalc) feeCalc->returnedTarget = confTarget;\n \n-    if (answerFoundAtTarget)\n-        *answerFoundAtTarget = confTarget - 1;\n+    if (confTarget <= 1) return CFeeRate(0); // error condition\n \n-    // If mempool is limiting txs , return at least the min feerate from the mempool\n-    CAmount minPoolFee = pool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n-    if (minPoolFee > 0 && minPoolFee > median)\n-        return CFeeRate(minPoolFee);\n+    assert(confTarget > 0); //estimateCombinedFee and estimateConservativeFee take unsigned ints\n+    /** true is passed to estimateCombined fee for target/2 and target so\n+     * that we check the max confirms for shorter time horizons as well.\n+     * This is necessary to preserve monotonically increasing estimates.\n+     * For non-conservative estimates we do the same thing for 2*target, but\n+     * for conservative estimates we want to skip these shorter horizons\n+     * checks for 2*target because we are taking the max over all time\n+     * horizons so we already have monotonically increasing estimates and\n+     * the purpose of conservative estimates is not to let short term\n+     * fluctuations lower our estimates by too much.\n+     */\n+    double halfEst = estimateCombinedFee(confTarget/2, HALF_SUCCESS_PCT, true, &tempResult);\n+    if (feeCalc) {\n+        feeCalc->est = tempResult;\n+        feeCalc->reason = FeeReason::HALF_ESTIMATE;\n+    }\n+    median = halfEst;\n+    double actualEst = estimateCombinedFee(confTarget, SUCCESS_PCT, true, &tempResult);\n+    if (actualEst > median) {\n+        median = actualEst;\n+        if (feeCalc) {\n+            feeCalc->est = tempResult;\n+            feeCalc->reason = FeeReason::FULL_ESTIMATE;\n+        }\n+    }\n+    double doubleEst = estimateCombinedFee(2 * confTarget, DOUBLE_SUCCESS_PCT, !conservative, &tempResult);\n+    if (doubleEst > median) {\n+        median = doubleEst;\n+        if (feeCalc) {\n+            feeCalc->est = tempResult;\n+            feeCalc->reason = FeeReason::DOUBLE_ESTIMATE;\n+        }\n+    }\n \n-    if (median < 0)\n-        return CFeeRate(0);\n+    if (conservative || median == -1) {\n+        double consEst =  estimateConservativeFee(2 * confTarget, &tempResult);\n+        if (consEst > median) {\n+            median = consEst;\n+            if (feeCalc) {\n+                feeCalc->est = tempResult;\n+                feeCalc->reason = FeeReason::CONSERVATIVE;\n+            }\n+        }\n+    }\n+\n+    if (median < 0) return CFeeRate(0); // error condition\n \n     return CFeeRate(median);\n }\n \n-void CBlockPolicyEstimator::Write(CAutoFile& fileout)\n+\n+bool CBlockPolicyEstimator::Write(CAutoFile& fileout) const\n {\n-    fileout << nBestSeenHeight;\n-    feeStats.Write(fileout);\n+    try {\n+        LOCK(cs_feeEstimator);\n+        fileout << 149900; // version required to read: 0.14.99 or later\n+        fileout << CLIENT_VERSION; // version that wrote the file\n+        fileout << nBestSeenHeight;\n+        if (BlockSpan() > HistoricalBlockSpan()/2) {\n+            fileout << firstRecordedHeight << nBestSeenHeight;\n+        }\n+        else {\n+            fileout << historicalFirst << historicalBest;\n+        }\n+        fileout << buckets;\n+        feeStats->Write(fileout);\n+        shortStats->Write(fileout);\n+        longStats->Write(fileout);\n+    }\n+    catch (const std::exception&) {\n+        LogPrintf(\"CBlockPolicyEstimator::Write(): unable to write policy estimator data (non-fatal)\\n\");\n+        return false;\n+    }\n+    return true;\n }\n \n-void CBlockPolicyEstimator::Read(CAutoFile& filein, int nFileVersion)\n+bool CBlockPolicyEstimator::Read(CAutoFile& filein)\n {\n-    int nFileBestSeenHeight;\n-    filein >> nFileBestSeenHeight;\n-    feeStats.Read(filein);\n-    nBestSeenHeight = nFileBestSeenHeight;\n-    // if nVersionThatWrote < 139900 then another TxConfirmStats (for priority) follows but can be ignored.\n+    try {\n+        LOCK(cs_feeEstimator);\n+        int nVersionRequired, nVersionThatWrote;\n+        filein >> nVersionRequired >> nVersionThatWrote;\n+        if (nVersionRequired > CLIENT_VERSION)\n+            return error(\"CBlockPolicyEstimator::Read(): up-version (%d) fee estimate file\", nVersionRequired);\n+\n+        // Read fee estimates file into temporary variables so existing data\n+        // structures aren't corrupted if there is an exception.\n+        unsigned int nFileBestSeenHeight;\n+        filein >> nFileBestSeenHeight;\n+\n+        if (nVersionThatWrote < 149900) {\n+            // Read the old fee estimates file for temporary use, but then discard.  Will start collecting data from scratch.\n+            // decay is stored before buckets in old versions, so pre-read decay and pass into TxConfirmStats constructor\n+            double tempDecay;\n+            filein >> tempDecay;\n+            if (tempDecay <= 0 || tempDecay >= 1)\n+                throw std::runtime_error(\"Corrupt estimates file. Decay must be between 0 and 1 (non-inclusive)\");\n+\n+            std::vector<double> tempBuckets;\n+            filein >> tempBuckets;\n+            size_t tempNum = tempBuckets.size();\n+            if (tempNum <= 1 || tempNum > 1000)\n+                throw std::runtime_error(\"Corrupt estimates file. Must have between 2 and 1000 feerate buckets\");\n+\n+            std::map<double, unsigned int> tempMap;\n+\n+            std::unique_ptr<TxConfirmStats> tempFeeStats(new TxConfirmStats(tempBuckets, tempMap, MED_BLOCK_PERIODS, tempDecay, 1));\n+            tempFeeStats->Read(filein, nVersionThatWrote, tempNum);\n+            // if nVersionThatWrote < 139900 then another TxConfirmStats (for priority) follows but can be ignored.\n+\n+            tempMap.clear();\n+            for (unsigned int i = 0; i < tempBuckets.size(); i++) {\n+                tempMap[tempBuckets[i]] = i;\n+            }\n+        }\n+        else { // nVersionThatWrote >= 149900\n+            unsigned int nFileHistoricalFirst, nFileHistoricalBest;\n+            filein >> nFileHistoricalFirst >> nFileHistoricalBest;\n+            if (nFileHistoricalFirst > nFileHistoricalBest || nFileHistoricalBest > nFileBestSeenHeight) {\n+                throw std::runtime_error(\"Corrupt estimates file. Historical block range for estimates is invalid\");\n+            }\n+            std::vector<double> fileBuckets;\n+            filein >> fileBuckets;\n+            size_t numBuckets = fileBuckets.size();\n+            if (numBuckets <= 1 || numBuckets > 1000)\n+                throw std::runtime_error(\"Corrupt estimates file. Must have between 2 and 1000 feerate buckets\");\n+\n+            std::unique_ptr<TxConfirmStats> fileFeeStats(new TxConfirmStats(buckets, bucketMap, MED_BLOCK_PERIODS, MED_DECAY, MED_SCALE));\n+            std::unique_ptr<TxConfirmStats> fileShortStats(new TxConfirmStats(buckets, bucketMap, SHORT_BLOCK_PERIODS, SHORT_DECAY, SHORT_SCALE));\n+            std::unique_ptr<TxConfirmStats> fileLongStats(new TxConfirmStats(buckets, bucketMap, LONG_BLOCK_PERIODS, LONG_DECAY, LONG_SCALE));\n+            fileFeeStats->Read(filein, nVersionThatWrote, numBuckets);\n+            fileShortStats->Read(filein, nVersionThatWrote, numBuckets);\n+            fileLongStats->Read(filein, nVersionThatWrote, numBuckets);\n+\n+            // Fee estimates file parsed correctly\n+            // Copy buckets from file and refresh our bucketmap\n+            buckets = fileBuckets;\n+            bucketMap.clear();\n+            for (unsigned int i = 0; i < buckets.size(); i++) {\n+                bucketMap[buckets[i]] = i;\n+            }\n+\n+            // Destroy old TxConfirmStats and point to new ones that already reference buckets and bucketMap\n+            delete feeStats;\n+            delete shortStats;\n+            delete longStats;\n+            feeStats = fileFeeStats.release();\n+            shortStats = fileShortStats.release();\n+            longStats = fileLongStats.release();\n+\n+            nBestSeenHeight = nFileBestSeenHeight;\n+            historicalFirst = nFileHistoricalFirst;\n+            historicalBest = nFileHistoricalBest;\n+        }\n+    }\n+    catch (const std::exception& e) {\n+        LogPrintf(\"CBlockPolicyEstimator::Read(): unable to read policy estimator data (non-fatal): %s\\n\",e.what());\n+        return false;\n+    }\n+    return true;\n+}\n+\n+void CBlockPolicyEstimator::FlushUnconfirmed(CTxMemPool& pool) {\n+    int64_t startclear = GetTimeMicros();\n+    std::vector<uint256> txids;\n+    pool.queryHashes(txids);\n+    LOCK(cs_feeEstimator);\n+    for (auto& txid : txids) {\n+        removeTx(txid, false);\n+    }\n+    int64_t endclear = GetTimeMicros();\n+    LogPrint(BCLog::ESTIMATEFEE, \"Recorded %u unconfirmed txs from mempool in %gs\\n\",txids.size(), (endclear - startclear)*0.000001);\n }\n \n FeeFilterRounder::FeeFilterRounder(const CFeeRate& minIncrementalFee)\n {\n     CAmount minFeeLimit = std::max(CAmount(1), minIncrementalFee.GetFeePerK() / 2);\n     feeset.insert(0);\n-    for (double bucketBoundary = minFeeLimit; bucketBoundary <= MAX_BUCKET_FEERATE; bucketBoundary *= FEE_SPACING) {\n+    for (double bucketBoundary = minFeeLimit; bucketBoundary <= MAX_FILTER_FEERATE; bucketBoundary *= FEE_FILTER_SPACING) {\n         feeset.insert(bucketBoundary);\n     }\n }"
      },
      {
        "sha": "f4ef793643076ca22ac8fb726b1717f31304c094",
        "filename": "src/policy/fees.h",
        "status": "modified",
        "additions": 186,
        "deletions": 158,
        "changes": 344,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/policy/fees.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/policy/fees.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -6,8 +6,10 @@\n #define BITCOIN_POLICYESTIMATOR_H\n \n #include \"amount.h\"\n+#include \"feerate.h\"\n #include \"uint256.h\"\n #include \"random.h\"\n+#include \"sync.h\"\n \n #include <map>\n #include <string>\n@@ -17,6 +19,7 @@ class CAutoFile;\n class CFeeRate;\n class CTxMemPoolEntry;\n class CTxMemPool;\n+class TxConfirmStats;\n \n /** \\class CBlockPolicyEstimator\n  * The BlockPolicyEstimator is used for estimating the feerate needed\n@@ -39,160 +42,92 @@ class CTxMemPool;\n  * within your desired 5 blocks.\n  *\n  * Here is a brief description of the implementation:\n- * When a transaction enters the mempool, we\n- * track the height of the block chain at entry.  Whenever a block comes in,\n- * we count the number of transactions in each bucket and the total amount of feerate\n- * paid in each bucket. Then we calculate how many blocks Y it took each\n- * transaction to be mined and we track an array of counters in each bucket\n- * for how long it to took transactions to get confirmed from 1 to a max of 25\n- * and we increment all the counters from Y up to 25. This is because for any\n- * number Z>=Y the transaction was successfully mined within Z blocks.  We\n- * want to save a history of this information, so at any time we have a\n- * counter of the total number of transactions that happened in a given feerate\n- * bucket and the total number that were confirmed in each number 1-25 blocks\n- * or less for any bucket.   We save this history by keeping an exponentially\n- * decaying moving average of each one of these stats.  Furthermore we also\n- * keep track of the number unmined (in mempool) transactions in each bucket\n- * and for how many blocks they have been outstanding and use that to increase\n- * the number of transactions we've seen in that feerate bucket when calculating\n- * an estimate for any number of confirmations below the number of blocks\n- * they've been outstanding.\n+ * When a transaction enters the mempool, we track the height of the block chain\n+ * at entry.  All further calculations are conducted only on this set of \"seen\"\n+ * transactions. Whenever a block comes in, we count the number of transactions\n+ * in each bucket and the total amount of feerate paid in each bucket. Then we\n+ * calculate how many blocks Y it took each transaction to be mined.  We convert\n+ * from a number of blocks to a number of periods Y' each encompassing \"scale\"\n+ * blocks.  This is tracked in 3 different data sets each up to a maximum\n+ * number of periods. Within each data set we have an array of counters in each\n+ * feerate bucket and we increment all the counters from Y' up to max periods\n+ * representing that a tx was successfully confirmed in less than or equal to\n+ * that many periods. We want to save a history of this information, so at any\n+ * time we have a counter of the total number of transactions that happened in a\n+ * given feerate bucket and the total number that were confirmed in each of the\n+ * periods or less for any bucket.  We save this history by keeping an\n+ * exponentially decaying moving average of each one of these stats.  This is\n+ * done for a different decay in each of the 3 data sets to keep relevant data\n+ * from different time horizons.  Furthermore we also keep track of the number\n+ * unmined (in mempool or left mempool without being included in a block)\n+ * transactions in each bucket and for how many blocks they have been\n+ * outstanding and use both of these numbers to increase the number of transactions\n+ * we've seen in that feerate bucket when calculating an estimate for any number\n+ * of confirmations below the number of blocks they've been outstanding.\n  */\n \n-/**\n- * We will instantiate an instance of this class to track transactions that were\n- * included in a block. We will lump transactions into a bucket according to their\n- * approximate feerate and then track how long it took for those txs to be included in a block\n- *\n- * The tracking of unconfirmed (mempool) transactions is completely independent of the\n- * historical tracking of transactions that have been confirmed in a block.\n- */\n-class TxConfirmStats\n-{\n-private:\n-    //Define the buckets we will group transactions into\n-    std::vector<double> buckets;              // The upper-bound of the range for the bucket (inclusive)\n-    std::map<double, unsigned int> bucketMap; // Map of bucket upper-bound to index into all vectors by bucket\n-\n-    // For each bucket X:\n-    // Count the total # of txs in each bucket\n-    // Track the historical moving average of this total over blocks\n-    std::vector<double> txCtAvg;\n-    // and calculate the total for the current block to update the moving average\n-    std::vector<int> curBlockTxCt;\n-\n-    // Count the total # of txs confirmed within Y blocks in each bucket\n-    // Track the historical moving average of theses totals over blocks\n-    std::vector<std::vector<double> > confAvg; // confAvg[Y][X]\n-    // and calculate the totals for the current block to update the moving averages\n-    std::vector<std::vector<int> > curBlockConf; // curBlockConf[Y][X]\n-\n-    // Sum the total feerate of all tx's in each bucket\n-    // Track the historical moving average of this total over blocks\n-    std::vector<double> avg;\n-    // and calculate the total for the current block to update the moving average\n-    std::vector<double> curBlockVal;\n-\n-    // Combine the conf counts with tx counts to calculate the confirmation % for each Y,X\n-    // Combine the total value with the tx counts to calculate the avg feerate per bucket\n-\n-    double decay;\n-\n-    // Mempool counts of outstanding transactions\n-    // For each bucket X, track the number of transactions in the mempool\n-    // that are unconfirmed for each possible confirmation value Y\n-    std::vector<std::vector<int> > unconfTxs;  //unconfTxs[Y][X]\n-    // transactions still unconfirmed after MAX_CONFIRMS for each bucket\n-    std::vector<int> oldUnconfTxs;\n-\n-public:\n-    /**\n-     * Initialize the data structures.  This is called by BlockPolicyEstimator's\n-     * constructor with default values.\n-     * @param defaultBuckets contains the upper limits for the bucket boundaries\n-     * @param maxConfirms max number of confirms to track\n-     * @param decay how much to decay the historical moving average per block\n-     */\n-    void Initialize(std::vector<double>& defaultBuckets, unsigned int maxConfirms, double decay);\n-\n-    /** Clear the state of the curBlock variables to start counting for the new block */\n-    void ClearCurrent(unsigned int nBlockHeight);\n-\n-    /**\n-     * Record a new transaction data point in the current block stats\n-     * @param blocksToConfirm the number of blocks it took this transaction to confirm\n-     * @param val the feerate of the transaction\n-     * @warning blocksToConfirm is 1-based and has to be >= 1\n-     */\n-    void Record(int blocksToConfirm, double val);\n-\n-    /** Record a new transaction entering the mempool*/\n-    unsigned int NewTx(unsigned int nBlockHeight, double val);\n-\n-    /** Remove a transaction from mempool tracking stats*/\n-    void removeTx(unsigned int entryHeight, unsigned int nBestSeenHeight,\n-                  unsigned int bucketIndex);\n-\n-    /** Update our estimates by decaying our historical moving average and updating\n-        with the data gathered from the current block */\n-    void UpdateMovingAverages();\n-\n-    /**\n-     * Calculate a feerate estimate.  Find the lowest value bucket (or range of buckets\n-     * to make sure we have enough data points) whose transactions still have sufficient likelihood\n-     * of being confirmed within the target number of confirmations\n-     * @param confTarget target number of confirmations\n-     * @param sufficientTxVal required average number of transactions per block in a bucket range\n-     * @param minSuccess the success probability we require\n-     * @param requireGreater return the lowest feerate such that all higher values pass minSuccess OR\n-     *        return the highest feerate such that all lower values fail minSuccess\n-     * @param nBlockHeight the current block height\n-     */\n-    double EstimateMedianVal(int confTarget, double sufficientTxVal,\n-                             double minSuccess, bool requireGreater, unsigned int nBlockHeight);\n-\n-    /** Return the max number of confirms we're tracking */\n-    unsigned int GetMaxConfirms() { return confAvg.size(); }\n-\n-    /** Write state of estimation data to a file*/\n-    void Write(CAutoFile& fileout);\n-\n-    /**\n-     * Read saved state of estimation data from a file and replace all internal data structures and\n-     * variables with this state.\n-     */\n-    void Read(CAutoFile& filein);\n+/* Identifier for each of the 3 different TxConfirmStats which will track\n+ * history over different time horizons. */\n+enum FeeEstimateHorizon {\n+    SHORT_HALFLIFE = 0,\n+    MED_HALFLIFE = 1,\n+    LONG_HALFLIFE = 2\n };\n \n+std::string StringForFeeEstimateHorizon(FeeEstimateHorizon horizon);\n+\n+/* Enumeration of reason for returned fee estimate */\n+enum class FeeReason {\n+    NONE,\n+    HALF_ESTIMATE,\n+    FULL_ESTIMATE,\n+    DOUBLE_ESTIMATE,\n+    CONSERVATIVE,\n+    MEMPOOL_MIN,\n+    PAYTXFEE,\n+    FALLBACK,\n+    REQUIRED,\n+    MAXTXFEE,\n+};\n \n+std::string StringForFeeReason(FeeReason reason);\n \n-/** Track confirm delays up to 25 blocks, can't estimate beyond that */\n-static const unsigned int MAX_BLOCK_CONFIRMS = 25;\n-\n-/** Decay of .998 is a half-life of 346 blocks or about 2.4 days */\n-static const double DEFAULT_DECAY = .998;\n+/* Used to determine type of fee estimation requested */\n+enum class FeeEstimateMode {\n+    UNSET,        //! Use default settings based on other criteria\n+    ECONOMICAL,   //! Force estimateSmartFee to use non-conservative estimates\n+    CONSERVATIVE, //! Force estimateSmartFee to use conservative estimates\n+};\n \n-/** Require greater than 95% of X feerate transactions to be confirmed within Y blocks for X to be big enough */\n-static const double MIN_SUCCESS_PCT = .95;\n+bool FeeModeFromString(const std::string& mode_string, FeeEstimateMode& fee_estimate_mode);\n \n-/** Require an avg of 1 tx in the combined feerate bucket per block to have stat significance */\n-static const double SUFFICIENT_FEETXS = 1;\n+/* Used to return detailed information about a feerate bucket */\n+struct EstimatorBucket\n+{\n+    double start = -1;\n+    double end = -1;\n+    double withinTarget = 0;\n+    double totalConfirmed = 0;\n+    double inMempool = 0;\n+    double leftMempool = 0;\n+};\n \n-// Minimum and Maximum values for tracking feerates\n-// The MIN_BUCKET_FEERATE should just be set to the lowest reasonable feerate we\n-// might ever want to track.  Historically this has been 1000 since it was\n-// inheriting DEFAULT_MIN_RELAY_TX_FEE and changing it is disruptive as it\n-// invalidates old estimates files. So leave it at 1000 unless it becomes\n-// necessary to lower it, and then lower it substantially.\n-static constexpr double MIN_BUCKET_FEERATE = 1000;\n-static const double MAX_BUCKET_FEERATE = 1e7;\n-static const double INF_FEERATE = MAX_MONEY;\n+/* Used to return detailed information about a fee estimate calculation */\n+struct EstimationResult\n+{\n+    EstimatorBucket pass;\n+    EstimatorBucket fail;\n+    double decay = 0;\n+    unsigned int scale = 0;\n+};\n \n-// We have to lump transactions into buckets based on feerate, but we want to be able\n-// to give accurate estimates over a large range of potential feerates\n-// Therefore it makes sense to exponentially space the buckets\n-/** Spacing of FeeRate buckets */\n-static const double FEE_SPACING = 1.1;\n+struct FeeCalculation\n+{\n+    EstimationResult est;\n+    FeeReason reason = FeeReason::NONE;\n+    int desiredTarget = 0;\n+    int returnedTarget = 0;\n+};\n \n /**\n  *  We want to be able to estimate feerates that are needed on tx's to be included in\n@@ -201,41 +136,104 @@ static const double FEE_SPACING = 1.1;\n  */\n class CBlockPolicyEstimator\n {\n+private:\n+    /** Track confirm delays up to 12 blocks for short horizon */\n+    static constexpr unsigned int SHORT_BLOCK_PERIODS = 12;\n+    static constexpr unsigned int SHORT_SCALE = 1;\n+    /** Track confirm delays up to 48 blocks for medium horizon */\n+    static constexpr unsigned int MED_BLOCK_PERIODS = 24;\n+    static constexpr unsigned int MED_SCALE = 2;\n+    /** Track confirm delays up to 1008 blocks for long horizon */\n+    static constexpr unsigned int LONG_BLOCK_PERIODS = 42;\n+    static constexpr unsigned int LONG_SCALE = 24;\n+    /** Historical estimates that are older than this aren't valid */\n+    static const unsigned int OLDEST_ESTIMATE_HISTORY = 6 * 1008;\n+\n+    /** Decay of .962 is a half-life of 18 blocks or about 3 hours */\n+    static constexpr double SHORT_DECAY = .962;\n+    /** Decay of .998 is a half-life of 144 blocks or about 1 day */\n+    static constexpr double MED_DECAY = .9952;\n+    /** Decay of .9995 is a half-life of 1008 blocks or about 1 week */\n+    static constexpr double LONG_DECAY = .99931;\n+\n+    /** Require greater than 60% of X feerate transactions to be confirmed within Y/2 blocks*/\n+    static constexpr double HALF_SUCCESS_PCT = .6;\n+    /** Require greater than 85% of X feerate transactions to be confirmed within Y blocks*/\n+    static constexpr double SUCCESS_PCT = .85;\n+    /** Require greater than 95% of X feerate transactions to be confirmed within 2 * Y blocks*/\n+    static constexpr double DOUBLE_SUCCESS_PCT = .95;\n+\n+    /** Require an avg of 0.1 tx in the combined feerate bucket per block to have stat significance */\n+    static constexpr double SUFFICIENT_FEETXS = 0.1;\n+    /** Require an avg of 0.5 tx when using short decay since there are fewer blocks considered*/\n+    static constexpr double SUFFICIENT_TXS_SHORT = 0.5;\n+\n+    /** Minimum and Maximum values for tracking feerates\n+     * The MIN_BUCKET_FEERATE should just be set to the lowest reasonable feerate we\n+     * might ever want to track.  Historically this has been 1000 since it was\n+     * inheriting DEFAULT_MIN_RELAY_TX_FEE and changing it is disruptive as it\n+     * invalidates old estimates files. So leave it at 1000 unless it becomes\n+     * necessary to lower it, and then lower it substantially.\n+     */\n+    static constexpr double MIN_BUCKET_FEERATE = 1000;\n+    static constexpr double MAX_BUCKET_FEERATE = 1e7;\n+\n+    /** Spacing of FeeRate buckets\n+     * We have to lump transactions into buckets based on feerate, but we want to be able\n+     * to give accurate estimates over a large range of potential feerates\n+     * Therefore it makes sense to exponentially space the buckets\n+     */\n+    static constexpr double FEE_SPACING = 1.05;\n+\n public:\n     /** Create new BlockPolicyEstimator and initialize stats tracking classes with default values */\n     CBlockPolicyEstimator();\n+    ~CBlockPolicyEstimator();\n \n     /** Process all the transactions that have been included in a block */\n     void processBlock(unsigned int nBlockHeight,\n                       std::vector<const CTxMemPoolEntry*>& entries);\n \n-    /** Process a transaction confirmed in a block*/\n-    bool processBlockTx(unsigned int nBlockHeight, const CTxMemPoolEntry* entry);\n-\n     /** Process a transaction accepted to the mempool*/\n     void processTransaction(const CTxMemPoolEntry& entry, bool validFeeEstimate);\n \n     /** Remove a transaction from the mempool tracking stats*/\n-    bool removeTx(uint256 hash);\n+    bool removeTx(uint256 hash, bool inBlock);\n \n-    /** Return a feerate estimate */\n-    CFeeRate estimateFee(int confTarget);\n+    /** DEPRECATED. Return a feerate estimate */\n+    CFeeRate estimateFee(int confTarget) const;\n \n-    /** Estimate feerate needed to get be included in a block within\n-     *  confTarget blocks. If no answer can be given at confTarget, return an\n-     *  estimate at the lowest target where one can be given.\n+    /** Estimate feerate needed to get be included in a block within confTarget\n+     *  blocks. If no answer can be given at confTarget, return an estimate at\n+     *  the closest target where one can be given.  'conservative' estimates are\n+     *  valid over longer time horizons also.\n      */\n-    CFeeRate estimateSmartFee(int confTarget, int *answerFoundAtTarget, const CTxMemPool& pool);\n+    CFeeRate estimateSmartFee(int confTarget, FeeCalculation *feeCalc, bool conservative) const;\n+\n+    /** Return a specific fee estimate calculation with a given success\n+     * threshold and time horizon, and optionally return detailed data about\n+     * calculation\n+     */\n+    CFeeRate estimateRawFee(int confTarget, double successThreshold, FeeEstimateHorizon horizon, EstimationResult *result = nullptr) const;\n \n     /** Write estimation data to a file */\n-    void Write(CAutoFile& fileout);\n+    bool Write(CAutoFile& fileout) const;\n \n     /** Read estimation data from a file */\n-    void Read(CAutoFile& filein, int nFileVersion);\n+    bool Read(CAutoFile& filein);\n+\n+    /** Empty mempool transactions on shutdown to record failure to confirm for txs still in mempool */\n+    void FlushUnconfirmed(CTxMemPool& pool);\n+\n+    /** Calculation of highest target that estimates are tracked for */\n+    unsigned int HighestTargetTracked(FeeEstimateHorizon horizon) const;\n \n private:\n-    CFeeRate minTrackedFee;    //!< Passed to constructor to avoid dependency on main\n     unsigned int nBestSeenHeight;\n+    unsigned int firstRecordedHeight;\n+    unsigned int historicalFirst;\n+    unsigned int historicalBest;\n+\n     struct TxStatsInfo\n     {\n         unsigned int blockHeight;\n@@ -247,14 +245,43 @@ class CBlockPolicyEstimator\n     std::map<uint256, TxStatsInfo> mapMemPoolTxs;\n \n     /** Classes to track historical data on transaction confirmations */\n-    TxConfirmStats feeStats;\n+    TxConfirmStats* feeStats;\n+    TxConfirmStats* shortStats;\n+    TxConfirmStats* longStats;\n \n     unsigned int trackedTxs;\n     unsigned int untrackedTxs;\n+\n+    std::vector<double> buckets;              // The upper-bound of the range for the bucket (inclusive)\n+    std::map<double, unsigned int> bucketMap; // Map of bucket upper-bound to index into all vectors by bucket\n+\n+    mutable CCriticalSection cs_feeEstimator;\n+\n+    /** Process a transaction confirmed in a block*/\n+    bool processBlockTx(unsigned int nBlockHeight, const CTxMemPoolEntry* entry);\n+\n+    /** Helper for estimateSmartFee */\n+    double estimateCombinedFee(unsigned int confTarget, double successThreshold, bool checkShorterHorizon, EstimationResult *result) const;\n+    /** Helper for estimateSmartFee */\n+    double estimateConservativeFee(unsigned int doubleTarget, EstimationResult *result) const;\n+    /** Number of blocks of data recorded while fee estimates have been running */\n+    unsigned int BlockSpan() const;\n+    /** Number of blocks of recorded fee estimate data represented in saved data file */\n+    unsigned int HistoricalBlockSpan() const;\n+    /** Calculation of highest target that reasonable estimate can be provided for */\n+    unsigned int MaxUsableEstimate() const;\n };\n \n class FeeFilterRounder\n {\n+private:\n+    static constexpr double MAX_FILTER_FEERATE = 1e7;\n+    /** FEE_FILTER_SPACING is just used to provide some quantization of fee\n+     * filter results.  Historically it reused FEE_SPACING, but it is completely\n+     * unrelated, and was made a separate constant so the two concepts are not\n+     * tied together */\n+    static constexpr double FEE_FILTER_SPACING = 1.1;\n+\n public:\n     /** Create new FeeFilterRounder */\n     FeeFilterRounder(const CFeeRate& minIncrementalFee);\n@@ -266,4 +293,5 @@ class FeeFilterRounder\n     std::set<double> feeset;\n     FastRandomContext insecure_rand;\n };\n+\n #endif /*BITCOIN_POLICYESTIMATOR_H */"
      },
      {
        "sha": "605e3e06968eb6741a795edbbc9928c44f7bfa2a",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 6,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -7,12 +7,52 @@\n \n #include \"policy/policy.h\"\n \n+#include \"consensus/validation.h\"\n #include \"validation.h\"\n+#include \"coins.h\"\n #include \"tinyformat.h\"\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n \n-#include <boost/foreach.hpp>\n+\n+CAmount GetDustThreshold(const CTxOut& txout, const CFeeRate& dustRelayFeeIn)\n+{\n+    // \"Dust\" is defined in terms of dustRelayFee,\n+    // which has units satoshis-per-kilobyte.\n+    // If you'd pay more in fees than the value of the output\n+    // to spend something, then we consider it dust.\n+    // A typical spendable non-segwit txout is 34 bytes big, and will\n+    // need a CTxIn of at least 148 bytes to spend:\n+    // so dust is a spendable txout less than\n+    // 182*dustRelayFee/1000 (in satoshis).\n+    // 546 satoshis at the default rate of 3000 sat/kB.\n+    // A typical spendable segwit txout is 31 bytes big, and will\n+    // need a CTxIn of at least 67 bytes to spend:\n+    // so dust is a spendable txout less than\n+    // 98*dustRelayFee/1000 (in satoshis).\n+    // 294 satoshis at the default rate of 3000 sat/kB.\n+    if (txout.scriptPubKey.IsUnspendable())\n+        return 0;\n+\n+    size_t nSize = GetSerializeSize(txout, SER_DISK, 0);\n+    int witnessversion = 0;\n+    std::vector<unsigned char> witnessprogram;\n+\n+    if (txout.scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) {\n+        // sum the sizes of the parts of a transaction input\n+        // with 75% segwit discount applied to the script size.\n+        nSize += (32 + 4 + 1 + (107 / WITNESS_SCALE_FACTOR) + 4);\n+    } else {\n+        nSize += (32 + 4 + 1 + 107 + 4); // the 148 mentioned above\n+    }\n+\n+    return dustRelayFeeIn.GetFee(nSize);\n+}\n+\n+bool IsDust(const CTxOut& txout, const CFeeRate& dustRelayFeeIn)\n+{\n+    return (txout.nValue < GetDustThreshold(txout, dustRelayFeeIn));\n+}\n \n     /**\n      * Check transaction inputs to mitigate two\n@@ -73,7 +113,7 @@ bool IsStandardTx(const CTransaction& tx, std::string& reason, const bool witnes\n         return false;\n     }\n \n-    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+    for (const CTxIn& txin : tx.vin)\n     {\n         // Biggest 'standard' txin is a 15-of-15 P2SH multisig with compressed\n         // keys (remember the 520 byte limit on redeemScript size). That works\n@@ -94,7 +134,7 @@ bool IsStandardTx(const CTransaction& tx, std::string& reason, const bool witnes\n \n     unsigned int nDataOut = 0;\n     txnouttype whichType;\n-    BOOST_FOREACH(const CTxOut& txout, tx.vout) {\n+    for (const CTxOut& txout : tx.vout) {\n         if (!::IsStandard(txout.scriptPubKey, whichType, witnessEnabled)) {\n             reason = \"scriptpubkey\";\n             return false;\n@@ -105,7 +145,7 @@ bool IsStandardTx(const CTransaction& tx, std::string& reason, const bool witnes\n         else if ((whichType == TX_MULTISIG) && (!fIsBareMultisigStd)) {\n             reason = \"bare-multisig\";\n             return false;\n-        } else if (txout.IsDust(dustRelayFee)) {\n+        } else if (IsDust(txout, ::dustRelayFee)) {\n             reason = \"dust\";\n             return false;\n         }\n@@ -127,7 +167,7 @@ bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n \n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n     {\n-        const CTxOut& prev = mapInputs.GetOutputFor(tx.vin[i]);\n+        const CTxOut& prev = mapInputs.AccessCoin(tx.vin[i].prevout).out;\n \n         std::vector<std::vector<unsigned char> > vSolutions;\n         txnouttype whichType;\n@@ -166,7 +206,7 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n         if (tx.vin[i].scriptWitness.IsNull())\n             continue;\n \n-        const CTxOut &prev = mapInputs.GetOutputFor(tx.vin[i]);\n+        const CTxOut &prev = mapInputs.AccessCoin(tx.vin[i].prevout).out;\n \n         // get the scriptPubKey corresponding to this input:\n         CScript prevScript = prev.scriptPubKey;"
      },
      {
        "sha": "c06820f84e6d067ecf5d6fd4a869dabf79b81b68",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -7,12 +7,14 @@\n #define BITCOIN_POLICY_POLICY_H\n \n #include \"consensus/consensus.h\"\n+#include \"feerate.h\"\n #include \"script/interpreter.h\"\n #include \"script/standard.h\"\n \n #include <string>\n \n class CCoinsViewCache;\n+class CTxOut;\n \n /** Default for -blockmaxsize, which controls the maximum size of block the mining code will create **/\n static const unsigned int DEFAULT_BLOCK_MAX_SIZE = 750000;\n@@ -38,12 +40,12 @@ static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEMS = 100;\n static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEM_SIZE = 80;\n /** The maximum size of a standard witnessScript */\n static const unsigned int MAX_STANDARD_P2WSH_SCRIPT_SIZE = 3600;\n-/** Min feerate for defining dust. Historically this has been the same as the\n+/** Min feerate for defining dust. Historically this has been based on the\n  * minRelayTxFee, however changing the dust limit changes which transactions are\n  * standard and should be done with care and ideally rarely. It makes sense to\n  * only increase the dust limit after prior releases were already not creating\n  * outputs below the new threshold */\n-static const unsigned int DUST_RELAY_TX_FEE = 1000;\n+static const unsigned int DUST_RELAY_TX_FEE = 3000;\n /**\n  * Standard script verification flags that standard transactions will comply\n  * with. However scripts violating these flags may still be present in valid\n@@ -72,6 +74,10 @@ static const unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCRIPT_\n static const unsigned int STANDARD_LOCKTIME_VERIFY_FLAGS = LOCKTIME_VERIFY_SEQUENCE |\n                                                            LOCKTIME_MEDIAN_TIME_PAST;\n \n+CAmount GetDustThreshold(const CTxOut& txout, const CFeeRate& dustRelayFee);\n+\n+bool IsDust(const CTxOut& txout, const CFeeRate& dustRelayFee);\n+\n bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType, const bool witnessEnabled = false);\n     /**\n      * Check for standard transaction types"
      },
      {
        "sha": "755ef83c9af11a3d01efa95216b94eb8f897a167",
        "filename": "src/policy/rbf.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/policy/rbf.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/policy/rbf.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -6,7 +6,7 @@\n \n bool SignalsOptInRBF(const CTransaction &tx)\n {\n-    BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n+    for (const CTxIn &txin : tx.vin) {\n         if (txin.nSequence < std::numeric_limits<unsigned int>::max()-1) {\n             return true;\n         }\n@@ -38,7 +38,7 @@ RBFTransactionState IsRBFOptIn(const CTransaction &tx, CTxMemPool &pool)\n     CTxMemPoolEntry entry = *pool.mapTx.find(tx.GetHash());\n     pool.CalculateMemPoolAncestors(entry, setAncestors, noLimit, noLimit, noLimit, noLimit, dummy, false);\n \n-    BOOST_FOREACH(CTxMemPool::txiter it, setAncestors) {\n+    for (CTxMemPool::txiter it : setAncestors) {\n         if (SignalsOptInRBF(it->GetTx())) {\n             return RBF_TRANSACTIONSTATE_REPLACEABLE_BIP125;\n         }"
      },
      {
        "sha": "22c73f3319340453f5f5f254e38761d66f2e70c9",
        "filename": "src/policy/rbf.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/policy/rbf.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/policy/rbf.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -7,6 +7,8 @@\n \n #include \"txmempool.h\"\n \n+static const uint32_t MAX_BIP125_RBF_SEQUENCE = 0xfffffffd;\n+\n enum RBFTransactionState {\n     RBF_TRANSACTIONSTATE_UNKNOWN,\n     RBF_TRANSACTIONSTATE_REPLACEABLE_BIP125,"
      },
      {
        "sha": "46640d6fff8434ea5d10e12ebe69917e4a32b984",
        "filename": "src/prevector.h",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/prevector.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/prevector.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/prevector.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -132,7 +132,7 @@ class prevector {\n         typedef const T* pointer;\n         typedef const T& reference;\n         typedef std::bidirectional_iterator_tag iterator_category;\n-        const_reverse_iterator(T* ptr_) : ptr(ptr_) {}\n+        const_reverse_iterator(const T* ptr_) : ptr(ptr_) {}\n         const_reverse_iterator(reverse_iterator x) : ptr(&(*x)) {}\n         const T& operator*() const { return *ptr; }\n         const T* operator->() const { return ptr; }\n@@ -220,7 +220,7 @@ class prevector {\n         }\n     }\n \n-    prevector() : _size(0) {}\n+    prevector() : _size(0), _union{{}} {}\n \n     explicit prevector(size_type n) : _size(0) {\n         resize(n);\n@@ -387,6 +387,12 @@ class prevector {\n     }\n \n     iterator erase(iterator first, iterator last) {\n+        // Erase is not allowed to the change the object's capacity. That means\n+        // that when starting with an indirectly allocated prevector with\n+        // size and capacity > N, the result may be a still indirectly allocated\n+        // prevector with size <= N and capacity > N. A shrink_to_fit() call is\n+        // necessary to switch to the (more efficient) directly allocated\n+        // representation (with capacity N and size <= N).\n         iterator p = first;\n         char* endp = (char*)&(*end());\n         if (!std::is_trivially_destructible<T>::value) {"
      },
      {
        "sha": "3774ac3e4b54ec4762a6b491566a7f956fce4070",
        "filename": "src/primitives/block.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 12,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/primitives/block.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/primitives/block.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -25,18 +25,8 @@ std::string CBlock::ToString() const\n         hashMerkleRoot.ToString(),\n         nTime, nBits, nNonce,\n         vtx.size());\n-    for (unsigned int i = 0; i < vtx.size(); i++)\n-    {\n-        s << \"  \" << vtx[i]->ToString() << \"\\n\";\n+    for (const auto& tx : vtx) {\n+        s << \"  \" << tx->ToString() << \"\\n\";\n     }\n     return s.str();\n }\n-\n-int64_t GetBlockWeight(const CBlock& block)\n-{\n-    // This implements the weight = (stripped_size * 4) + witness_size formula,\n-    // using only serialization with and without witness data. As witness_size\n-    // is equal to total_size - stripped_size, this formula is identical to:\n-    // weight = (stripped_size * 3) + total_size.\n-    return ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION);\n-}"
      },
      {
        "sha": "c90a1dfa6448631db06e522d3d0876c79a2e4977",
        "filename": "src/primitives/block.h",
        "status": "modified",
        "additions": 1,
        "deletions": 7,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/primitives/block.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/primitives/block.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -129,10 +129,7 @@ struct CBlockLocator\n \n     CBlockLocator() {}\n \n-    CBlockLocator(const std::vector<uint256>& vHaveIn)\n-    {\n-        vHave = vHaveIn;\n-    }\n+    CBlockLocator(const std::vector<uint256>& vHaveIn) : vHave(vHaveIn) {}\n \n     ADD_SERIALIZE_METHODS;\n \n@@ -155,7 +152,4 @@ struct CBlockLocator\n     }\n };\n \n-/** Compute the consensus-critical block weight (see BIP 141). */\n-int64_t GetBlockWeight(const CBlock& tx);\n-\n #endif // BITCOIN_PRIMITIVES_BLOCK_H"
      },
      {
        "sha": "9b6a814e1f3d7ef6409ed46c1bfeddf0ba669a25",
        "filename": "src/primitives/transaction.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 15,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/primitives/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/primitives/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -83,10 +83,9 @@ CTransaction::CTransaction(CMutableTransaction &&tx) : nVersion(tx.nVersion), vi\n CAmount CTransaction::GetValueOut() const\n {\n     CAmount nValueOut = 0;\n-    for (std::vector<CTxOut>::const_iterator it(vout.begin()); it != vout.end(); ++it)\n-    {\n-        nValueOut += it->nValue;\n-        if (!MoneyRange(it->nValue) || !MoneyRange(nValueOut))\n+    for (const auto& tx_out : vout) {\n+        nValueOut += tx_out.nValue;\n+        if (!MoneyRange(tx_out.nValue) || !MoneyRange(nValueOut))\n             throw std::runtime_error(std::string(__func__) + \": value out of range\");\n     }\n     return nValueOut;\n@@ -106,16 +105,11 @@ std::string CTransaction::ToString() const\n         vin.size(),\n         vout.size(),\n         nLockTime);\n-    for (unsigned int i = 0; i < vin.size(); i++)\n-        str += \"    \" + vin[i].ToString() + \"\\n\";\n-    for (unsigned int i = 0; i < vin.size(); i++)\n-        str += \"    \" + vin[i].scriptWitness.ToString() + \"\\n\";\n-    for (unsigned int i = 0; i < vout.size(); i++)\n-        str += \"    \" + vout[i].ToString() + \"\\n\";\n+    for (const auto& tx_in : vin)\n+        str += \"    \" + tx_in.ToString() + \"\\n\";\n+    for (const auto& tx_in : vin)\n+        str += \"    \" + tx_in.scriptWitness.ToString() + \"\\n\";\n+    for (const auto& tx_out : vout)\n+        str += \"    \" + tx_out.ToString() + \"\\n\";\n     return str;\n }\n-\n-int64_t GetTransactionWeight(const CTransaction& tx)\n-{\n-    return ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR -1) + ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n-}"
      },
      {
        "sha": "041034bb8b6f78ed03c995ff8e2877639ffad659",
        "filename": "src/primitives/transaction.h",
        "status": "modified",
        "additions": 5,
        "deletions": 46,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/primitives/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/primitives/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -6,24 +6,23 @@\n #ifndef BITCOIN_PRIMITIVES_TRANSACTION_H\n #define BITCOIN_PRIMITIVES_TRANSACTION_H\n \n+#include <stdint.h>\n #include \"amount.h\"\n #include \"script/script.h\"\n #include \"serialize.h\"\n #include \"uint256.h\"\n \n static const int SERIALIZE_TRANSACTION_NO_WITNESS = 0x40000000;\n \n-static const int WITNESS_SCALE_FACTOR = 4;\n-\n /** An outpoint - a combination of a transaction hash and an index n into its vout */\n class COutPoint\n {\n public:\n     uint256 hash;\n     uint32_t n;\n \n-    COutPoint() { SetNull(); }\n-    COutPoint(uint256 hashIn, uint32_t nIn) { hash = hashIn; n = nIn; }\n+    COutPoint(): n((uint32_t) -1) { }\n+    COutPoint(const uint256& hashIn, uint32_t nIn): hash(hashIn), n(nIn) { }\n \n     ADD_SERIALIZE_METHODS;\n \n@@ -107,7 +106,7 @@ class CTxIn\n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action) {\n         READWRITE(prevout);\n-        READWRITE(*(CScriptBase*)(&scriptSig));\n+        READWRITE(scriptSig);\n         READWRITE(nSequence);\n     }\n \n@@ -147,7 +146,7 @@ class CTxOut\n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action) {\n         READWRITE(nValue);\n-        READWRITE(*(CScriptBase*)(&scriptPubKey));\n+        READWRITE(scriptPubKey);\n     }\n \n     void SetNull()\n@@ -161,43 +160,6 @@ class CTxOut\n         return (nValue == -1);\n     }\n \n-    CAmount GetDustThreshold(const CFeeRate &minRelayTxFee) const\n-    {\n-        // \"Dust\" is defined in terms of CTransaction::minRelayTxFee,\n-        // which has units satoshis-per-kilobyte.\n-        // If you'd pay more than 1/3 in fees\n-        // to spend something, then we consider it dust.\n-        // A typical spendable non-segwit txout is 34 bytes big, and will\n-        // need a CTxIn of at least 148 bytes to spend:\n-        // so dust is a spendable txout less than\n-        // 546*minRelayTxFee/1000 (in satoshis).\n-        // A typical spendable segwit txout is 31 bytes big, and will\n-        // need a CTxIn of at least 67 bytes to spend:\n-        // so dust is a spendable txout less than\n-        // 294*minRelayTxFee/1000 (in satoshis).\n-        if (scriptPubKey.IsUnspendable())\n-            return 0;\n-\n-        size_t nSize = GetSerializeSize(*this, SER_DISK, 0);\n-        int witnessversion = 0;\n-        std::vector<unsigned char> witnessprogram;\n-\n-        if (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) {\n-            // sum the sizes of the parts of a transaction input\n-            // with 75% segwit discount applied to the script size.\n-            nSize += (32 + 4 + 1 + (107 / WITNESS_SCALE_FACTOR) + 4);\n-        } else {\n-            nSize += (32 + 4 + 1 + 107 + 4); // the 148 mentioned above\n-        }\n-\n-        return 3 * minRelayTxFee.GetFee(nSize);\n-    }\n-\n-    bool IsDust(const CFeeRate &minRelayTxFee) const\n-    {\n-        return (nValue < GetDustThreshold(minRelayTxFee));\n-    }\n-\n     friend bool operator==(const CTxOut& a, const CTxOut& b)\n     {\n         return (a.nValue       == b.nValue &&\n@@ -448,7 +410,4 @@ typedef std::shared_ptr<const CTransaction> CTransactionRef;\n static inline CTransactionRef MakeTransactionRef() { return std::make_shared<const CTransaction>(); }\n template <typename Tx> static inline CTransactionRef MakeTransactionRef(Tx&& txIn) { return std::make_shared<const CTransaction>(std::forward<Tx>(txIn)); }\n \n-/** Compute the weight of a transaction, as defined by BIP 141 */\n-int64_t GetTransactionWeight(const CTransaction &tx);\n-\n #endif // BITCOIN_PRIMITIVES_TRANSACTION_H"
      },
      {
        "sha": "da87e40091f65088ce6fff620cb27884bbbbae22",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 6,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -39,7 +39,7 @@ const char *SENDCMPCT=\"sendcmpct\";\n const char *CMPCTBLOCK=\"cmpctblock\";\n const char *GETBLOCKTXN=\"getblocktxn\";\n const char *BLOCKTXN=\"blocktxn\";\n-};\n+} // namespace NetMsgType\n \n /** All known message types. Keep this in the same order as the list of\n  * messages above and in protocol.h.\n@@ -151,11 +151,7 @@ CInv::CInv()\n     hash.SetNull();\n }\n \n-CInv::CInv(int typeIn, const uint256& hashIn)\n-{\n-    type = typeIn;\n-    hash = hashIn;\n-}\n+CInv::CInv(int typeIn, const uint256& hashIn) : type(typeIn), hash(hashIn) {}\n \n bool operator<(const CInv& a, const CInv& b)\n {"
      },
      {
        "sha": "7890bb627de36ccb4f8b48fc657c319f194c7273",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -163,7 +163,7 @@ extern const char *PONG;\n /**\n  * The notfound message is a reply to a getdata message which requested an\n  * object the receiving node does not have available for relay.\n- * @ince protocol version 70001.\n+ * @since protocol version 70001.\n  * @see https://bitcoin.org/en/developer-reference#notfound\n  */\n extern const char *NOTFOUND;"
      },
      {
        "sha": "91af4e56f2d63e22d971134e89947b420440e9d6",
        "filename": "src/pubkey.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/pubkey.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/pubkey.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -11,7 +11,7 @@ namespace\n {\n /* Global secp256k1_context object used for verification. */\n secp256k1_context* secp256k1_context_verify = NULL;\n-}\n+} // namespace\n \n /** This function is taken from the libsecp256k1 distribution and implements\n  *  DER parsing for ECDSA signatures, while supporting an arbitrary subset of\n@@ -172,10 +172,7 @@ bool CPubKey::Verify(const uint256 &hash, const std::vector<unsigned char>& vchS\n     if (!secp256k1_ec_pubkey_parse(secp256k1_context_verify, &pubkey, &(*this)[0], size())) {\n         return false;\n     }\n-    if (vchSig.size() == 0) {\n-        return false;\n-    }\n-    if (!ecdsa_signature_parse_der_lax(secp256k1_context_verify, &sig, &vchSig[0], vchSig.size())) {\n+    if (!ecdsa_signature_parse_der_lax(secp256k1_context_verify, &sig, vchSig.data(), vchSig.size())) {\n         return false;\n     }\n     /* libsecp256k1's ECDSA verification requires lower-S signatures, which have\n@@ -274,7 +271,7 @@ bool CExtPubKey::Derive(CExtPubKey &out, unsigned int _nChild) const {\n \n /* static */ bool CPubKey::CheckLowS(const std::vector<unsigned char>& vchSig) {\n     secp256k1_ecdsa_signature sig;\n-    if (!ecdsa_signature_parse_der_lax(secp256k1_context_verify, &sig, &vchSig[0], vchSig.size())) {\n+    if (!ecdsa_signature_parse_der_lax(secp256k1_context_verify, &sig, vchSig.data(), vchSig.size())) {\n         return false;\n     }\n     return (!secp256k1_ecdsa_signature_normalize(secp256k1_context_verify, NULL, &sig));"
      },
      {
        "sha": "cebac46b952387d714df71efa27a32eeb59e2e00",
        "filename": "src/qt/addressbookpage.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/addressbookpage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/addressbookpage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addressbookpage.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -254,7 +254,7 @@ void AddressBookPage::done(int retval)\n     // Figure out which address was selected, and return it\n     QModelIndexList indexes = table->selectionModel()->selectedRows(AddressTableModel::Address);\n \n-    Q_FOREACH (const QModelIndex& index, indexes) {\n+    for (const QModelIndex& index : indexes) {\n         QVariant address = table->model()->data(index);\n         returnValue = address.toString();\n     }"
      },
      {
        "sha": "3c00fd0809d33a5be8d001084c595b581e874fc6",
        "filename": "src/qt/addressbookpage.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/addressbookpage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/addressbookpage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addressbookpage.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -8,7 +8,6 @@\n #include <QDialog>\n \n class AddressTableModel;\n-class OptionsModel;\n class PlatformStyle;\n \n namespace Ui {\n@@ -20,7 +19,6 @@ class QItemSelection;\n class QMenu;\n class QModelIndex;\n class QSortFilterProxyModel;\n-class QTableView;\n QT_END_NAMESPACE\n \n /** Widget that shows a list of sending or receiving addresses."
      },
      {
        "sha": "2fa032abdc44a10a08f8444b8c7d81aa1fa438e8",
        "filename": "src/qt/addresstablemodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/addresstablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/addresstablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addresstablemodel.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -10,7 +10,6 @@\n #include \"base58.h\"\n #include \"wallet/wallet.h\"\n \n-#include <boost/foreach.hpp>\n \n #include <QFont>\n #include <QDebug>\n@@ -81,7 +80,7 @@ class AddressTablePriv\n         cachedAddressTable.clear();\n         {\n             LOCK(wallet->cs_wallet);\n-            BOOST_FOREACH(const PAIRTYPE(CTxDestination, CAddressBookData)& item, wallet->mapAddressBook)\n+            for (const std::pair<CTxDestination, CAddressBookData>& item : wallet->mapAddressBook)\n             {\n                 const CBitcoinAddress& address = item.first;\n                 bool fMine = IsMine(*wallet, address.Get());"
      },
      {
        "sha": "f8a99506c131ea35169a73cf7240d4b818599282",
        "filename": "src/qt/bantablemodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/bantablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/bantablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bantablemodel.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -181,7 +181,5 @@ void BanTableModel::sort(int column, Qt::SortOrder order)\n \n bool BanTableModel::shouldShow()\n {\n-    if (priv->size() > 0)\n-        return true;\n-    return false;\n+    return priv->size() > 0;\n }"
      },
      {
        "sha": "4a4116c67024cc4bf2f927b708d9f06fcad9345b",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 23,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -178,6 +178,10 @@ class BitcoinCore: public QObject\n     Q_OBJECT\n public:\n     explicit BitcoinCore();\n+    /** Basic initialization, before starting initialization/shutdown thread.\n+     * Return true on success.\n+     */\n+    static bool baseInitialize();\n \n public Q_SLOTS:\n     void initialize();\n@@ -270,26 +274,32 @@ void BitcoinCore::handleRunawayException(const std::exception *e)\n     Q_EMIT runawayException(QString::fromStdString(GetWarnings(\"gui\")));\n }\n \n+bool BitcoinCore::baseInitialize()\n+{\n+    if (!AppInitBasicSetup())\n+    {\n+        return false;\n+    }\n+    if (!AppInitParameterInteraction())\n+    {\n+        return false;\n+    }\n+    if (!AppInitSanityChecks())\n+    {\n+        return false;\n+    }\n+    if (!AppInitLockDataDirectory())\n+    {\n+        return false;\n+    }\n+    return true;\n+}\n+\n void BitcoinCore::initialize()\n {\n     try\n     {\n         qDebug() << __func__ << \": Running initialization in thread\";\n-        if (!AppInitBasicSetup())\n-        {\n-            Q_EMIT initializeResult(false);\n-            return;\n-        }\n-        if (!AppInitParameterInteraction())\n-        {\n-            Q_EMIT initializeResult(false);\n-            return;\n-        }\n-        if (!AppInitSanityChecks())\n-        {\n-            Q_EMIT initializeResult(false);\n-            return;\n-        }\n         bool rv = AppInitMain(threadGroup, scheduler);\n         Q_EMIT initializeResult(rv);\n     } catch (const std::exception& e) {\n@@ -474,9 +484,10 @@ void BitcoinApplication::initializeResult(bool success)\n         window->setClientModel(clientModel);\n \n #ifdef ENABLE_WALLET\n-        if(pwalletMain)\n+        // TODO: Expose secondary wallets\n+        if (!vpwallets.empty())\n         {\n-            walletModel = new WalletModel(platformStyle, pwalletMain, optionsModel);\n+            walletModel = new WalletModel(platformStyle, vpwallets[0], optionsModel);\n \n             window->addWallet(BitcoinGUI::DEFAULT_WALLET, walletModel);\n             window->setCurrentWallet(BitcoinGUI::DEFAULT_WALLET);\n@@ -577,6 +588,7 @@ int main(int argc, char *argv[])\n     //   Need to pass name here as CAmount is a typedef (see http://qt-project.org/doc/qt-5/qmetatype.html#qRegisterMetaType)\n     //   IMPORTANT if it is no longer a typedef use the normal variant above\n     qRegisterMetaType< CAmount >(\"CAmount\");\n+    qRegisterMetaType< std::function<void(void)> >(\"std::function<void(void)>\");\n \n     /// 3. Application identification\n     // must be set before OptionsModel is initialized or translations are loaded,\n@@ -687,23 +699,33 @@ int main(int argc, char *argv[])\n     if (GetBoolArg(\"-splash\", DEFAULT_SPLASHSCREEN) && !GetBoolArg(\"-min\", false))\n         app.createSplashScreen(networkStyle.data());\n \n+    int rv = EXIT_SUCCESS;\n     try\n     {\n         app.createWindow(networkStyle.data());\n-        app.requestInitialize();\n+        // Perform base initialization before spinning up initialization/shutdown thread\n+        // This is acceptable because this function only contains steps that are quick to execute,\n+        // so the GUI thread won't be held up.\n+        if (BitcoinCore::baseInitialize()) {\n+            app.requestInitialize();\n #if defined(Q_OS_WIN) && QT_VERSION >= 0x050000\n-        WinShutdownMonitor::registerShutdownBlockReason(QObject::tr(\"%1 didn't yet exit safely...\").arg(QObject::tr(PACKAGE_NAME)), (HWND)app.getMainWinId());\n+            WinShutdownMonitor::registerShutdownBlockReason(QObject::tr(\"%1 didn't yet exit safely...\").arg(QObject::tr(PACKAGE_NAME)), (HWND)app.getMainWinId());\n #endif\n-        app.exec();\n-        app.requestShutdown();\n-        app.exec();\n+            app.exec();\n+            app.requestShutdown();\n+            app.exec();\n+            rv = app.getReturnValue();\n+        } else {\n+            // A dialog with detailed error will have been shown by InitError()\n+            rv = EXIT_FAILURE;\n+        }\n     } catch (const std::exception& e) {\n         PrintExceptionContinue(&e, \"Runaway exception\");\n         app.handleRunawayException(QString::fromStdString(GetWarnings(\"gui\")));\n     } catch (...) {\n         PrintExceptionContinue(NULL, \"Runaway exception\");\n         app.handleRunawayException(QString::fromStdString(GetWarnings(\"gui\")));\n     }\n-    return app.getReturnValue();\n+    return rv;\n }\n #endif // BITCOIN_QT_TEST"
      },
      {
        "sha": "429c18cba85c309fe2cfe8d9268e26741f81fa33",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -478,6 +478,7 @@ void BitcoinGUI::setClientModel(ClientModel *_clientModel)\n         connect(_clientModel, SIGNAL(numConnectionsChanged(int)), this, SLOT(setNumConnections(int)));\n         connect(_clientModel, SIGNAL(networkActiveChanged(bool)), this, SLOT(setNetworkActive(bool)));\n \n+        modalOverlay->setKnownBestHeight(_clientModel->getHeaderTipHeight(), QDateTime::fromTime_t(_clientModel->getHeaderTipTime()));\n         setNumBlocks(_clientModel->getNumBlocks(), _clientModel->getLastBlockDate(), _clientModel->getVerificationProgress(NULL), false);\n         connect(_clientModel, SIGNAL(numBlocksChanged(int,QDateTime,double,bool)), this, SLOT(setNumBlocks(int,QDateTime,double,bool)));\n \n@@ -505,8 +506,6 @@ void BitcoinGUI::setClientModel(ClientModel *_clientModel)\n             // initialize the disable state of the tray icon with the current value in the model.\n             setTrayIconVisible(optionsModel->getHideTrayIcon());\n         }\n-\n-        modalOverlay->setKnownBestHeight(clientModel->getHeaderTipHeight(), QDateTime::fromTime_t(clientModel->getHeaderTipTime()));\n     } else {\n         // Disable possibility to show main window via action\n         toggleHideAction->setEnabled(false);\n@@ -1007,7 +1006,7 @@ void BitcoinGUI::dropEvent(QDropEvent *event)\n {\n     if(event->mimeData()->hasUrls())\n     {\n-        Q_FOREACH(const QUrl &uri, event->mimeData()->urls())\n+        for (const QUrl &uri : event->mimeData()->urls())\n         {\n             Q_EMIT receivedURI(uri.toString());\n         }\n@@ -1203,7 +1202,7 @@ UnitDisplayStatusBarControl::UnitDisplayStatusBarControl(const PlatformStyle *pl\n     QList<BitcoinUnits::Unit> units = BitcoinUnits::availableUnits();\n     int max_width = 0;\n     const QFontMetrics fm(font());\n-    Q_FOREACH (const BitcoinUnits::Unit unit, units)\n+    for (const BitcoinUnits::Unit unit : units)\n     {\n         max_width = qMax(max_width, fm.width(BitcoinUnits::name(unit)));\n     }\n@@ -1222,7 +1221,7 @@ void UnitDisplayStatusBarControl::mousePressEvent(QMouseEvent *event)\n void UnitDisplayStatusBarControl::createContextMenu()\n {\n     menu = new QMenu(this);\n-    Q_FOREACH(BitcoinUnits::Unit u, BitcoinUnits::availableUnits())\n+    for (BitcoinUnits::Unit u : BitcoinUnits::availableUnits())\n     {\n         QAction *menuAction = new QAction(QString(BitcoinUnits::name(u)), this);\n         menuAction->setData(QVariant(u));"
      },
      {
        "sha": "8731caafc7757f3032cd413454d44d57e7606785",
        "filename": "src/qt/bitcoingui.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/bitcoingui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/bitcoingui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -31,8 +31,6 @@ class WalletModel;\n class HelpMessageDialog;\n class ModalOverlay;\n \n-class CWallet;\n-\n QT_BEGIN_NAMESPACE\n class QAction;\n class QProgressBar;"
      },
      {
        "sha": "9f798ccf6238873dfaf3f95b07547a1a29f7dc12",
        "filename": "src/qt/bitcoinstrings.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 18,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/bitcoinstrings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/bitcoinstrings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinstrings.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -21,9 +21,6 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"A fee rate (in %s/kB) that will be used when fee estimation has insufficient \"\n \"data (default: %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"Accept connections from outside (default: 1 if no -proxy or -connect/-\"\n-\"noconnect)\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Accept relayed transactions received from whitelisted peers even when not \"\n \"relaying transactions (default: %d)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n@@ -37,14 +34,16 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Bind to given address and whitelist peers connecting to it. Use [host]:port \"\n \"notation for IPv6\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"Bind to given address to listen for JSON-RPC connections. Use [host]:port \"\n-\"notation for IPv6. This option can be specified multiple times (default: \"\n-\"bind to all interfaces)\"),\n+\"Bind to given address to listen for JSON-RPC connections. This option is \"\n+\"ignored unless -rpcallowip is also passed. Port is optional and overrides -\"\n+\"rpcport. Use [host]:port notation for IPv6. This option can be specified \"\n+\"multiple times (default: 127.0.0.1 and ::1 i.e., localhost, or if -\"\n+\"rpcallowip has been specified, 0.0.0.0 and :: i.e., all addresses)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Cannot obtain a lock on data directory %s. %s is probably already running.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"Connect only to the specified node(s); -noconnect or -connect=0 alone to \"\n-\"disable automatic connections\"),\n+\"Connect only to the specified node(s); -connect=0 disables automatic \"\n+\"connections\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Create new files with system default permissions, instead of umask 077 (only \"\n \"effective with disabled wallet functionality)\"),\n@@ -62,13 +61,20 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Equivalent bytes per sigop in transactions for relay and mining (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"Error loading %s: You can't enable HD on a already existing non-HD wallet\"),\n+\"Error loading %s: You can't enable HD on an already existing non-HD wallet\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Error loading wallet %s. -wallet parameter must only specify a filename (not \"\n+\"a path).\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Error reading %s! All keys read correctly, but transaction data or address \"\n \"book entries might be missing or incorrect.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Error: Listening for incoming connections failed (listen returned error %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Exclude debugging information for a category. Can be used in conjunction \"\n+\"with -debug=1 to output debug logs for all categories except one or more \"\n+\"specified categories.\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Execute command when a relevant alert is received or we see a really long \"\n \"fork (%s in cmd is replaced by message)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n@@ -134,7 +140,7 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"reindex (download the whole blockchain again in case of pruned node)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Query for peer addresses via DNS lookup, if low on addresses (default: 1 \"\n-\"unless -connect/-noconnect)\"),\n+\"unless -connect used)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Randomize credentials for every proxy connection. This enables Tor stream \"\n \"isolation (default: %u)\"),\n@@ -154,8 +160,6 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Set lowest fee rate (in %s/kB) for transactions to be included in block \"\n \"creation. (default: %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"Set maximum size of high-priority/low-fee transactions in bytes (default: %d)\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Set the number of script verification threads (%u to %d, 0 = auto, <0 = \"\n \"leave that many cores free, default: %d)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n@@ -169,11 +173,19 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"rebuild the block database if you are sure that your computer's date and \"\n \"time are correct\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"The fee rate (in %s/kB) that indicates your tolerance for discarding change \"\n+\"by adding it to the fee (default: %s). Note: An output is discarded if it is \"\n+\"dust at this rate, but we will always discard up to the dust relay fee and a \"\n+\"discard fee above that is limited by the fee estimate for the longest target\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"The transaction amount is too small to send after the fee has been deducted\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"This is a pre-release test build - use at your own risk - do not use for \"\n \"mining or merchant applications\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"This is the transaction fee you may discard if change is smaller than dust \"\n+\"at this level\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"This is the transaction fee you may pay when fee estimates are not available.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"This product includes software developed by the OpenSSL Project for use in \"\n@@ -186,6 +198,9 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Tries to keep outbound traffic under the given target (in MiB per 24h), 0 = \"\n \"no limit (default: %d)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Unable to replay blocks. You will need to rebuild the database using -\"\n+\"reindex-chainstate.\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Unable to rewind the database to a pre-fork state. You will need to \"\n \"redownload the blockchain\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n@@ -225,6 +240,8 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Warning: We do not appear to fully agree with our peers! You may need to \"\n \"upgrade, or other nodes may need to upgrade.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Whether to save the mempool on shutdown and load on restart (default: %u)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Whitelist peers connecting from the given IP address (e.g. 1.2.3.4) or CIDR \"\n \"notated network (e.g. 1.2.3.0/24). Can be specified multiple times.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n@@ -235,13 +252,16 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"mode.  This will redownload the entire blockchain\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"You need to rebuild the database using -reindex-chainstate to change -txindex\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"%d of last 100 blocks have unexpected version\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"%s corrupt, salvage failed\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"%s is set very high!\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"(default: %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"(default: %u)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"(press q to shutdown and continue later)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"-maxmempool must be at least %d MB\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"<category> can be:\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Accept command line and JSON-RPC commands\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Accept connections from outside (default: 1 if no -proxy or -connect)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Accept public REST requests (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Add a node to connect to and attempt to keep the connection open\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Allow DNS lookups for -addnode, -seednode and -connect\"),\n@@ -274,10 +294,14 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error initializing wallet database environmen\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading %s\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading %s: Wallet corrupted\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading %s: Wallet requires newer version of %s\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading %s: You can't disable HD on a already existing HD wallet\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading %s: You can't disable HD on an already existing HD wallet\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading block database\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading wallet %s. -wallet filename must be a regular file.\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading wallet %s. Duplicate -wallet filename specified.\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading wallet %s. Invalid characters in -wallet filename.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error opening block database\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error reading from database, shutting down.\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error upgrading chainstate database\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error: A fatal internal error occurred, see debug.log for details\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error: Disk space is low!\"),\n@@ -291,9 +315,10 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Incorrect or no genesis block found. Wrong da\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Information\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Initialization sanity check failed. %s is shutting down.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Insufficient funds\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid -onion address: '%s'\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid -proxy address: '%s'\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid -onion address or hostname: '%s'\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid -proxy address or hostname: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid amount for -%s=<amount>: '%s'\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid amount for -discardfee=<amount>: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid amount for -fallbackfee=<amount>: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid amount for -paytxfee=<amount>: '%s' (must be at least %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid netmask specified in -whitelist: '%s'\"),\n@@ -302,7 +327,7 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Keep the transaction memory pool below <n> me\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Keypool ran out, please call keypoolrefill first\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Listen for connections on <port> (default: %u or testnet: %u)\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Loading addresses...\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Loading P2P addresses...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Loading banlist...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Loading block index...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Loading wallet...\"),\n@@ -329,12 +354,12 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Rebuild chain state from the currently indexe\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Reducing -maxconnections from %d to %d, because of system limitations.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Relay and mine data carrier transactions (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Relay non-P2SH multisig (default: %u)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Replaying blocks...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Rescan the block chain for missing wallet transactions on startup\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Rescanning...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Rewinding blocks...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Run in the background as a daemon and accept commands\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Send trace/debug info to console instead of debug.log file\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Send transactions as zero-fee transactions if possible (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Send transactions with full-RBF opt-in enabled (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Set database cache size in megabytes (%d to %d, default: %d)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Set key pool size to <n> (default: %u)\"),\n@@ -363,6 +388,7 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Tor control port password (default: empty)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Tor control port to use if onion listening enabled (default: %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Transaction amount too small\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Transaction amounts must not be negative\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Transaction fee and change calculation failed\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Transaction has too long of a mempool chain\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Transaction must have at least one recipient\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Transaction too large for fee policy\"),\n@@ -374,13 +400,15 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unknown network specified in -onlynet: '%s'\")\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unsupported argument -benchmark ignored, use -debug=bench.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unsupported argument -debugnet ignored, use -debug=net.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unsupported argument -tor found, use -onion.\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unsupported logging category %s=%s.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Upgrade wallet to latest format on startup\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Upgrading UTXO database\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Use UPnP to map the listening port (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Use the test chain\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"User Agent comment (%s) contains unsafe characters.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Username for JSON-RPC connections\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Verifying blocks...\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Verifying wallet...\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Verifying wallet(s)...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Wallet %s resides outside data directory %s\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Wallet debugging/testing options:\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Wallet needed to be rewritten: restart %s to complete\"),"
      },
      {
        "sha": "52ce11cefd277df49601a617da143b108512d3a4",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 11,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad",
        "patch": "@@ -9,6 +9,7 @@\n #include \"guiutil.h\"\n #include \"peertablemodel.h\"\n \n+#include \"chain.h\"\n #include \"chainparams.h\"\n #include \"checkpoints.h\"\n #include \"clientversion.h\"\n@@ -17,6 +18,7 @@\n #include \"txmempool.h\"\n #include \"ui_interface.h\"\n #include \"util.h\"\n+#include \"warnings.h\"\n \n #include <stdint.h>\n \n@@ -25,7 +27,6 @@\n \n class CBlockIndex;\n \n-static const int64_t nClientStartupTime = GetTime();\n static int64_t nLastHeaderTipUpdateNotification = 0;\n static int64_t nLastBlockTipUpdateNotification = 0;\n \n@@ -36,6 +37,8 @@ ClientModel::ClientModel(OptionsModel *_optionsModel, QObject *parent) :\n     banTableModel(0),\n     pollTimer(0)\n {\n+    cachedBestHeaderHeight = -1;\n+    cachedBestHeaderTime = -1;\n     peerTableModel = new PeerTableModel(this);\n     banTableModel = new BanTableModel(this);\n     pollTimer = new QTimer(this);\n@@ -74,18 +77,28 @@ int ClientModel::getNumBlocks() const\n \n int ClientModel::getHeaderTipHeight() const\n {\n-    LOCK(cs_main);\n-    if (!pindexBestHeader)\n-        return 0;\n-    return pindexBestHeader->nHeight;\n+    if (cachedBestHeaderHeight == -1) {\n+        // make sure we initially populate the cache via a cs_main lock\n+        // otherwise we need to wait for a tip update\n+        LOCK(cs_main);\n+        if (pindexBestHeader) {\n+            cachedBestHeaderHeight = pindexBestHeader->nHeight;\n+            cachedBestHeaderTime = pindexBestHeader->GetBlockTime();\n+        }\n+    }\n+    return cachedBestHeaderHeight;\n }\n \n int64_t ClientModel::getHeaderTipTime() const\n {\n-    LOCK(cs_main);\n-    if (!pindexBestHeader)\n-        return 0;\n-    return pindexBestHeader->GetBlockTime();\n+    if (cachedBestHeaderTime == -1) {\n+        LOCK(cs_main);\n+        if (pindexBestHeader) {\n+            cachedBestHeaderHeight = pindexBestHeader->nHeight;\n+            cachedBestHeaderTime = pindexBestHeader->GetBlockTime();\n+        }\n+    }\n+    return cachedBestHeaderTime;\n }\n \n quint64 ClientModel::getTotalBytesRecv() const\n@@ -225,7 +238,7 @@ bool ClientModel::isReleaseVersion() const\n \n QString ClientModel::formatClientStartupTime() const\n {\n-    return QDateTime::fromTime_t(nClientStartupTime).toString();\n+    return QDateTime::fromTime_t(GetStartupTime()).toString();\n }\n \n QString ClientModel::dataDir() const\n@@ -283,9 +296,14 @@ static void BlockTipChanged(ClientModel *clientmodel, bool initialSync, const CB\n \n     int64_t& nLastUpdateNotification = fHeader ? nLastHeaderTipUpdateNotification : nLastBlockTipUpdateNotification;\n \n+    if (fHeader) {\n+        // cache best headers time and height to reduce future cs_main locks\n+        clientmodel->cachedBestHeaderHeight = pIndex->nHeight;\n+        clientmodel->cachedBestHeaderTime = pIndex->GetBlockTime();\n+    }\n     // if we are in-sync, update the UI regardless of last update time\n     if (!initialSync || now - nLastUpdateNotification > MODEL_UPDATE_DELAY) {\n-        //pass a async signal to the UI thread\n+        //pass an async signal to the UI thread\n         QMetaObject::invokeMethod(clientmodel, \"numBlocksChanged\", Qt::QueuedConnection,\n                                   Q_ARG(int, pIndex->nHeight),\n                                   Q_ARG(QDateTime, QDateTime::fromTime_t(pIndex->GetBlockTime())),"
      },
      {
        "sha": "6447cae1bb4e03bc4a211a55181b6321a69129f0",
        "filename": "src/qt/clientmodel.h",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/clientmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/clientmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "f3ee0fbe393aeace65b734393481a58623d164f7",
        "filename": "src/qt/coincontroldialog.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 27,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/coincontroldialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/coincontroldialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "99a9f893ffe3ae7092e51861f431683fea4feb08",
        "filename": "src/qt/coincontroldialog.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/coincontroldialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/coincontroldialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "88510b61681dcc06d75a42787faf3bb1e0d5c204",
        "filename": "src/qt/coincontroltreewidget.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/coincontroltreewidget.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/coincontroltreewidget.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroltreewidget.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "14078b9ee810503a326b2d212d001e1777c8316c",
        "filename": "src/qt/forms/optionsdialog.ui",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/forms/optionsdialog.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/forms/optionsdialog.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/optionsdialog.ui?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "1e2f2302b91fd9b975089c4fc27d9c2a9b25cf7b",
        "filename": "src/qt/forms/sendcoinsdialog.ui",
        "status": "modified",
        "additions": 5,
        "deletions": 74,
        "changes": 79,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/forms/sendcoinsdialog.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/forms/sendcoinsdialog.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/sendcoinsdialog.ui?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "bffa81137b230c5e2fb5292b53d41b776e1494c1",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "231a71575347b82dba8e65a56861e5e52044ede2",
        "filename": "src/qt/intro.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/intro.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/intro.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/intro.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "250fc6b5a2546cc02c53e1f2f64ea26625d17f56",
        "filename": "src/qt/locale/bitcoin_af.ts",
        "status": "modified",
        "additions": 105,
        "deletions": 1,
        "changes": 106,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_af.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_af.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_af.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "432e8c3faf8cd33ec9a8c76636b5c77d1c10b958",
        "filename": "src/qt/locale/bitcoin_af_ZA.ts",
        "status": "modified",
        "additions": 64,
        "deletions": 0,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_af_ZA.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_af_ZA.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_af_ZA.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "68c69038fd4b36ae6fdedfc699f4a9d5451b9d03",
        "filename": "src/qt/locale/bitcoin_ar.ts",
        "status": "modified",
        "additions": 29,
        "deletions": 1,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_ar.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_ar.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ar.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "37b7f8532a34341d79abb787f3d823a2ae341e0d",
        "filename": "src/qt/locale/bitcoin_bg.ts",
        "status": "modified",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_bg.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_bg.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_bg.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "2dd724c442a05fc91c7f7ed0d0c880df8c2ed091",
        "filename": "src/qt/locale/bitcoin_ca_ES.ts",
        "status": "modified",
        "additions": 27,
        "deletions": 3,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_ca_ES.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_ca_ES.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ca_ES.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "bc3fcb278e629f4d712b245a4d5d4335f6e3aa91",
        "filename": "src/qt/locale/bitcoin_da.ts",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_da.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_da.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_da.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "dcd228600546a72eec05fdebfc687dadba137fe2",
        "filename": "src/qt/locale/bitcoin_de.ts",
        "status": "modified",
        "additions": 100,
        "deletions": 28,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_de.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_de.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_de.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "2bbc1546a5a042cba322427963f7b35e92f4cb0a",
        "filename": "src/qt/locale/bitcoin_el_GR.ts",
        "status": "modified",
        "additions": 271,
        "deletions": 3,
        "changes": 274,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_el_GR.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_el_GR.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_el_GR.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "821be8987e004b875d84cb45276a856b040c2159",
        "filename": "src/qt/locale/bitcoin_en.ts",
        "status": "modified",
        "additions": 419,
        "deletions": 221,
        "changes": 640,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_en.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_en.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_en.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "16c584c4b10faae31c3d6673d8a9ba79958c4784",
        "filename": "src/qt/locale/bitcoin_eo.ts",
        "status": "modified",
        "additions": 119,
        "deletions": 3,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_eo.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_eo.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_eo.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "1cac03951c61bc5d78f8060e7b1d970e06f2a44b",
        "filename": "src/qt/locale/bitcoin_es.ts",
        "status": "modified",
        "additions": 130,
        "deletions": 2,
        "changes": 132,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_es.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_es.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_es.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "e0ddf7d530f198549fb6ab1eec02fbfa47aad941",
        "filename": "src/qt/locale/bitcoin_es_ES.ts",
        "status": "modified",
        "additions": 88,
        "deletions": 4,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_es_ES.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_es_ES.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_es_ES.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "9b0c908381581e7517e17c3a8ae69e5d9fbd6404",
        "filename": "src/qt/locale/bitcoin_et_EE.ts",
        "status": "modified",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_et_EE.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_et_EE.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_et_EE.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "c9aa1b56249c02023239922b0c18fc101d680d32",
        "filename": "src/qt/locale/bitcoin_fa.ts",
        "status": "modified",
        "additions": 128,
        "deletions": 0,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_fa.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_fa.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_fa.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "b0acc67b920eefb4ea3e4254af69121d86949a9a",
        "filename": "src/qt/locale/bitcoin_fa_IR.ts",
        "status": "modified",
        "additions": 415,
        "deletions": 43,
        "changes": 458,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_fa_IR.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_fa_IR.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_fa_IR.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "38f0e1444cb1aea8f878e898d313d5fcac41ef69",
        "filename": "src/qt/locale/bitcoin_fi.ts",
        "status": "modified",
        "additions": 369,
        "deletions": 9,
        "changes": 378,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_fi.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_fi.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_fi.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "830e6bb05f123d56a474b1c0dc789d7f314fbd82",
        "filename": "src/qt/locale/bitcoin_fr.ts",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_fr.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_fr.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_fr.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "c10cdf95a2ffaa8d834825b45edd36fe87f9090b",
        "filename": "src/qt/locale/bitcoin_fr_FR.ts",
        "status": "modified",
        "additions": 385,
        "deletions": 9,
        "changes": 394,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_fr_FR.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_fr_FR.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_fr_FR.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "82be81e9219c58f2f07ae2c1ca1fbc256f280819",
        "filename": "src/qt/locale/bitcoin_he.ts",
        "status": "modified",
        "additions": 1217,
        "deletions": 31,
        "changes": 1248,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_he.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_he.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_he.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "e1db9c25299ef6de17b96bdf0aeb5350d6d8d43b",
        "filename": "src/qt/locale/bitcoin_hi_IN.ts",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_hi_IN.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_hi_IN.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_hi_IN.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "5c98319c6bd358495e8bd044f1e4ec6a352fba87",
        "filename": "src/qt/locale/bitcoin_hu.ts",
        "status": "modified",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_hu.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_hu.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_hu.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "89ec216ab3dfab0b4c079338acac154d30028eb5",
        "filename": "src/qt/locale/bitcoin_id_ID.ts",
        "status": "modified",
        "additions": 427,
        "deletions": 7,
        "changes": 434,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_id_ID.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_id_ID.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_id_ID.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "d38459c6ff8e13ba796223b9d77415636e1f6d50",
        "filename": "src/qt/locale/bitcoin_it.ts",
        "status": "modified",
        "additions": 994,
        "deletions": 34,
        "changes": 1028,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_it.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_it.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_it.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "ebb30f13e4b62d1dd3a20716791b385b8a418125",
        "filename": "src/qt/locale/bitcoin_it_IT.ts",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_it_IT.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_it_IT.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_it_IT.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "5aa9137753caa61cd1493bc0389ddf2f7a3ee0b2",
        "filename": "src/qt/locale/bitcoin_ka.ts",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_ka.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_ka.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ka.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "c104bdd0db857e1cbb0fb51a575bfb1b22d4d411",
        "filename": "src/qt/locale/bitcoin_ko_KR.ts",
        "status": "modified",
        "additions": 946,
        "deletions": 74,
        "changes": 1020,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_ko_KR.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_ko_KR.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ko_KR.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "7844093e3bb645e0e7dd6726328157d2b6c5f4aa",
        "filename": "src/qt/locale/bitcoin_ms_MY.ts",
        "status": "modified",
        "additions": 333,
        "deletions": 5,
        "changes": 338,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_ms_MY.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_ms_MY.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ms_MY.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "14919c440dfc54f069c64f9152e2eb823414d793",
        "filename": "src/qt/locale/bitcoin_nb.ts",
        "status": "modified",
        "additions": 528,
        "deletions": 12,
        "changes": 540,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_nb.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_nb.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_nb.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "be6e8e0391055a6238fee707cdfc8a3f186d404c",
        "filename": "src/qt/locale/bitcoin_ne.ts",
        "status": "modified",
        "additions": 76,
        "deletions": 0,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_ne.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_ne.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ne.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "e523e832810d794601fce99dba30eb959d4057e3",
        "filename": "src/qt/locale/bitcoin_nl.ts",
        "status": "modified",
        "additions": 298,
        "deletions": 6,
        "changes": 304,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_nl.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_nl.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_nl.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "3675bd060a8e44d8cc94534afecb42197b7b8b35",
        "filename": "src/qt/locale/bitcoin_pl.ts",
        "status": "modified",
        "additions": 196,
        "deletions": 12,
        "changes": 208,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_pl.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_pl.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_pl.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "59724318bbf8a1994dff0f561c38ecdc6c378f2b",
        "filename": "src/qt/locale/bitcoin_pt_BR.ts",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_pt_BR.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_pt_BR.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_pt_BR.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "a45bb59239718ce5989728bc64cfff149024eab2",
        "filename": "src/qt/locale/bitcoin_pt_PT.ts",
        "status": "modified",
        "additions": 834,
        "deletions": 14,
        "changes": 848,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_pt_PT.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_pt_PT.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_pt_PT.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "7d013416ff76b9f7087dcba43ef740b2753f7162",
        "filename": "src/qt/locale/bitcoin_ru.ts",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_ru.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_ru.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ru.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "66ab7c81f49aee4589da2aadce87de7907f18678",
        "filename": "src/qt/locale/bitcoin_ru_RU.ts",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_ru_RU.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_ru_RU.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ru_RU.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "fdf9fc6db6e4bc8f367276e494c6a3c696942bdc",
        "filename": "src/qt/locale/bitcoin_sk.ts",
        "status": "modified",
        "additions": 1313,
        "deletions": 45,
        "changes": 1358,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_sk.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_sk.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_sk.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "ae10378bf23bd38c9089fad85d28884f49a09575",
        "filename": "src/qt/locale/bitcoin_sl_SI.ts",
        "status": "modified",
        "additions": 94,
        "deletions": 2,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_sl_SI.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_sl_SI.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_sl_SI.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "ac5426f1917dd4e6a903b019e87a5dcfff6eaa0d",
        "filename": "src/qt/locale/bitcoin_sv.ts",
        "status": "modified",
        "additions": 888,
        "deletions": 20,
        "changes": 908,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_sv.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_sv.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_sv.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "321effc7e136bb69e3a5b47f4078126cb36a29db",
        "filename": "src/qt/locale/bitcoin_tr.ts",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_tr.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_tr.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_tr.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "7126b2e5c1516228185954a59ec9727c08750ce4",
        "filename": "src/qt/locale/bitcoin_uk.ts",
        "status": "modified",
        "additions": 95,
        "deletions": 3,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_uk.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_uk.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_uk.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "bd0ef617ae7892504cd71bb1653c18a3e4a86619",
        "filename": "src/qt/locale/bitcoin_ur_PK.ts",
        "status": "modified",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_ur_PK.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_ur_PK.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ur_PK.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "8c4bececa1462f88c0f509fbec2e22d327eeb58b",
        "filename": "src/qt/locale/bitcoin_vi_VN.ts",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_vi_VN.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_vi_VN.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_vi_VN.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "77d32402d3cf694653922f14b1121a21495ab177",
        "filename": "src/qt/locale/bitcoin_zh_CN.ts",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_zh_CN.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_zh_CN.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_zh_CN.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "44d4ac1e76287f17d87f5eac2d61c8657e88a9f6",
        "filename": "src/qt/locale/bitcoin_zh_HK.ts",
        "status": "modified",
        "additions": 376,
        "deletions": 6,
        "changes": 382,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_zh_HK.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/locale/bitcoin_zh_HK.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_zh_HK.ts?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "a83f285034fdb8b30330800c28e5913fc6b42fd4",
        "filename": "src/qt/modaloverlay.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/modaloverlay.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/modaloverlay.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/modaloverlay.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "b80b6541dddd2ab3fdfd61f5e657cd18a3a8fd50",
        "filename": "src/qt/optionsdialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/optionsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/optionsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsdialog.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "132ee32748c0bc37c58eca88598298a414900381",
        "filename": "src/qt/paymentserver.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 10,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/paymentserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/paymentserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "42934f8055d0107342d747bb9df09525b8fb66ec",
        "filename": "src/qt/peertablemodel.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/peertablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/peertablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/peertablemodel.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "1f4e1a442f069ee873405b7adcc5ef02c0afdbf1",
        "filename": "src/qt/platformstyle.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/platformstyle.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/platformstyle.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/platformstyle.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "84f43266e125d9936d741acd14f37364ee3a7427",
        "filename": "src/qt/receivecoinsdialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/receivecoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/receivecoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receivecoinsdialog.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "385f98565c71d996ec023e8841da20b237fbeef9",
        "filename": "src/qt/receivecoinsdialog.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/receivecoinsdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/receivecoinsdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receivecoinsdialog.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "4e88c8802c2b8a12caa2bcbd4b0ddb2963a0b738",
        "filename": "src/qt/recentrequeststablemodel.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/recentrequeststablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/recentrequeststablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/recentrequeststablemodel.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "232068bf45c6635d4849de70d49d6731203bed97",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 9,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "a01886c3ea8aefbe9026e04e9c2d3d06e3781700",
        "filename": "src/qt/sendcoinsdialog.cpp",
        "status": "modified",
        "additions": 69,
        "deletions": 77,
        "changes": 146,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/sendcoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/sendcoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "70b4aa5a03ab3080bfd0924db680604971049db2",
        "filename": "src/qt/sendcoinsdialog.h",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/sendcoinsdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/sendcoinsdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "1b7cc69231c14a648ddb045b84208aa297e4a9af",
        "filename": "src/qt/splashscreen.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 1,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/splashscreen.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/splashscreen.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/splashscreen.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "a88ebb98a87400c8d3f06c74b169158564859e95",
        "filename": "src/qt/splashscreen.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/splashscreen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/splashscreen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/splashscreen.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "b9a8ad6e280dc42ddca609ab08806e27eac4ed1a",
        "filename": "src/qt/test/paymentservertests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/test/paymentservertests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/test/paymentservertests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/paymentservertests.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "fbad9e544ae8f00acd2f17d48c54f130d226fcf8",
        "filename": "src/qt/test/rpcnestedtests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 21,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/test/rpcnestedtests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/test/rpcnestedtests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/rpcnestedtests.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "1b28a285f1e65cccbc6dbfe89495b6e5dca2326b",
        "filename": "src/qt/test/test_main.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/test/test_main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/test/test_main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/test_main.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "ff1eb59f16b7cb18b8dc9f4a407891de3de176a9",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 91,
        "deletions": 13,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "5bb863451fd18814e90c229e8ae7d88a886deffb",
        "filename": "src/qt/trafficgraphwidget.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/trafficgraphwidget.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/trafficgraphwidget.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/trafficgraphwidget.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "bcacc47ef3e54d36809821ecf6598494ca898688",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 15,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "03fd734e9293402c7f885d6766e51b1a3ebb7bc3",
        "filename": "src/qt/transactionrecord.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/transactionrecord.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/transactionrecord.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "59f681224fc995b8e5a610d3e107e672a5bc58b5",
        "filename": "src/qt/transactionrecord.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/transactionrecord.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/transactionrecord.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "59cef555b1a6ac6801a9e1a92692ada6d665a958",
        "filename": "src/qt/transactiontablemodel.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/transactiontablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/transactiontablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "43d6e8826ba6fe1699c3899995ead50c48ec0982",
        "filename": "src/qt/transactionview.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 2,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/transactionview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/transactionview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "52e57cae4cf9486d98b7e55278d5ab44b4d32098",
        "filename": "src/qt/transactionview.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/transactionview.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/transactionview.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "c9b344fbd8ab288133ad7d3c2954915141dfd5a9",
        "filename": "src/qt/utilitydialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/utilitydialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/utilitydialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/utilitydialog.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "acaa864148c4cf94fcd301483cd9d5036a737312",
        "filename": "src/qt/utilitydialog.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/utilitydialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/utilitydialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/utilitydialog.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "ba0e1da0c787104f303f76050f095b01a490d4fb",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 102,
        "deletions": 57,
        "changes": 159,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "5258dc669939a2b310e9822def01f17e74c7b920",
        "filename": "src/qt/walletmodel.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/walletmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/walletmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "8bc9ef725e4d94e12025a451334f1e3efb6491f3",
        "filename": "src/qt/walletmodeltransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/walletmodeltransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/qt/walletmodeltransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodeltransaction.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "e07ef444712795b93a3e8b00fa2fb9a4d01c7b62",
        "filename": "src/random.cpp",
        "status": "modified",
        "additions": 202,
        "deletions": 25,
        "changes": 227,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/random.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/random.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "c60ab361795e6823f9c7c204fd292a6f19120b1a",
        "filename": "src/random.h",
        "status": "modified",
        "additions": 87,
        "deletions": 7,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/random.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/random.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "33e3fb4529833d3eb14e89e486e9019206c4c420",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 28,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "409f895ce062f0db78a991de833522e227d51e1c",
        "filename": "src/reverse_iterator.h",
        "status": "added",
        "additions": 39,
        "deletions": 0,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/reverse_iterator.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/reverse_iterator.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/reverse_iterator.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "d65e107e3c4684c9a9232f4dd1bcd5032170034c",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 193,
        "deletions": 75,
        "changes": 268,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "960edfd56f5b6bde590a5b33d018eed717b118a1",
        "filename": "src/rpc/blockchain.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/blockchain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/blockchain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "417945378242ffd9abac3f82c4966a44b867b9db",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 2,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "7d292a4635015035056fba7390f4480ad0d54a91",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 191,
        "deletions": 86,
        "changes": 277,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "868d7002b5ff465f1c317cc6a5b01e723c5cd28d",
        "filename": "src/rpc/mining.h",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/mining.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/mining.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "cd93919eb5799d1fa68076694fb14a13e929b780",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 8,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "6271e0cc83be75de64501aff0d0137d98bd031f4",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 28,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "4bd4702d62441ba8313569dbf2299742d51e2bf0",
        "filename": "src/rpc/protocol.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/protocol.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "b967f2dbf850b33b1da5a519d6cc723fffab12ac",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 183,
        "deletions": 153,
        "changes": 336,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "58640d69d68314ad1eca5d62eaaf4c9daaa29043",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 22,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "dd6f7632456efbf3a8526a1233b6c3e5c5d760de",
        "filename": "src/rpc/server.h",
        "status": "modified",
        "additions": 6,
        "deletions": 12,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/server.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/rpc/server.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "1d3fb1f6ea899af576f75ea2538f3f271c492a87",
        "filename": "src/scheduler.cpp",
        "status": "modified",
        "additions": 73,
        "deletions": 0,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/scheduler.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/scheduler.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scheduler.cpp?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      },
      {
        "sha": "0365d668b209b85eeedb6e1d51e60649d6b57692",
        "filename": "src/scheduler.h",
        "status": "modified",
        "additions": 34,
        "deletions": 3,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/scheduler.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad/src/scheduler.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scheduler.h?ref=9623f7f6fc8a5260ad0e490e0fe356cce3ecfdad"
      }
    ]
  }
]