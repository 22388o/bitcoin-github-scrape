[
  {
    "sha": "54b3431c404c0879ea35091089c33288a3084403",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NGIzNDMxYzQwNGMwODc5ZWEzNTA5MTA4OWMzMzI4OGEzMDg0NDAz",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-08T12:47:58Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-09T11:45:13Z"
      },
      "message": "Add a new peer state tracking class to reduce cs_main contention.\n\nCNodeState was added for validation-state-tracking, and thus,\nlogically, was protected by cs_main. However, as it has grown to\ninclude non-validation state (taking state from CNode), and as\nwe've reduced cs_main usage for other unrelated things, CNodeState\nis left with lots of cs_main locking in net_processing.\n\nIn order to ease transition to something new, this adds only a\ndummy CPeerState which is held as a reference for the duration of\nmessage processing.",
      "tree": {
        "sha": "d8f0dd45127844c0025d43676156a390c87c662c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d8f0dd45127844c0025d43676156a390c87c662c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/54b3431c404c0879ea35091089c33288a3084403",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54b3431c404c0879ea35091089c33288a3084403",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/54b3431c404c0879ea35091089c33288a3084403",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54b3431c404c0879ea35091089c33288a3084403/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5d2ccf0ce9ca1571c650a69319fb9c1e0b626ecb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5d2ccf0ce9ca1571c650a69319fb9c1e0b626ecb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5d2ccf0ce9ca1571c650a69319fb9c1e0b626ecb"
      }
    ],
    "stats": {
      "total": 47,
      "additions": 44,
      "deletions": 3
    },
    "files": [
      {
        "sha": "2817d88e65aaaeb027bd98aed57d791c5e0a891c",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 44,
        "deletions": 3,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54b3431c404c0879ea35091089c33288a3084403/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54b3431c404c0879ea35091089c33288a3084403/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=54b3431c404c0879ea35091089c33288a3084403",
        "patch": "@@ -197,6 +197,17 @@ struct CBlockReject {\n     uint256 hashBlock;\n };\n \n+/**\n+ * Maintain state about nodes, protected by our own lock. Historically we put all\n+ * peer tracking state in CNodeState, however this results in significant cs_main\n+ * contention. Thus, new state tracking should go here, and we should eventually\n+ * move most (non-validation-specific) state here.\n+ */\n+struct CPeerState {\n+    CPeerState() {}\n+};\n+\n+\n /**\n  * Maintain validation-specific state about nodes, protected by cs_main, instead\n  * by CNode's own locks. This simplifies asynchronous operation, where\n@@ -388,7 +399,20 @@ struct CNodeState {\n // Keeps track of the time (in microseconds) when transactions were requested last time\n limitedmap<uint256, int64_t> g_already_asked_for GUARDED_BY(cs_main)(MAX_INV_SZ);\n \n+/** Note that this must be locked BEFORE cs_main! */\n+CCriticalSection cs_peerstate;\n+\n /** Map maintaining per-node state. */\n+static std::map<NodeId, CPeerState> mapPeerState GUARDED_BY(cs_peerstate);\n+\n+static CPeerState *PeerState(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate) LOCKS_EXCLUDED(cs_main) {\n+    std::map<NodeId, CPeerState>::iterator it = mapPeerState.find(pnode);\n+    if (it == mapPeerState.end())\n+        return nullptr;\n+    return &it->second;\n+}\n+\n+/** Map maintaining new per-node state. */\n static std::map<NodeId, CNodeState> mapNodeState GUARDED_BY(cs_main);\n \n static CNodeState *State(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n@@ -756,12 +780,22 @@ void PeerLogicValidation::InitializeNode(CNode *pnode) {\n         LOCK(cs_main);\n         mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName), pnode->fInbound, pnode->m_manual_connection));\n     }\n+    {\n+        LOCK(cs_peerstate);\n+        mapPeerState.emplace_hint(mapPeerState.end(), nodeid, CPeerState{});\n+    }\n+\n     if(!pnode->fInbound)\n         PushNodeVersion(pnode, connman, GetTime());\n }\n \n void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n     fUpdateConnectionTime = false;\n+\n+    LOCK(cs_peerstate);\n+    CPeerState* peerstate = PeerState(nodeid);\n+    assert(peerstate != nullptr);\n+\n     LOCK(cs_main);\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n@@ -784,13 +818,15 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n     assert(g_outbound_peers_with_protect_from_disconnect >= 0);\n \n     mapNodeState.erase(nodeid);\n+    mapPeerState.erase(nodeid);\n \n     if (mapNodeState.empty()) {\n         // Do a consistency check after the last peer is removed.\n         assert(mapBlocksInFlight.empty());\n         assert(nPreferredDownload == 0);\n         assert(nPeersWithValidatedDownloads == 0);\n         assert(g_outbound_peers_with_protect_from_disconnect == 0);\n+        assert(mapPeerState.empty());\n     }\n     LogPrint(BCLog::NET, \"Cleared nodestate for peer=%d\\n\", nodeid);\n }\n@@ -1821,7 +1857,7 @@ void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_se\n     }\n }\n \n-bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc, bool enable_bip61)\n+bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc, bool enable_bip61) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate)\n {\n     LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());\n     if (gArgs.IsArgSet(\"-dropmessagestest\") && GetRand(gArgs.GetArg(\"-dropmessagestest\", 0)) == 0)\n@@ -2763,7 +2799,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         } // cs_main\n \n         if (fProcessBLOCKTXN)\n-            return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman, interruptMsgProc, enable_bip61);\n+            return ProcessMessage(pfrom, peerstate, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman, interruptMsgProc, enable_bip61);\n \n         if (fRevertToHeaderProcessing) {\n             // Headers received from HB compact block peers are permitted to be\n@@ -3193,6 +3229,8 @@ bool PeerLogicValidation::SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_\n bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& interruptMsgProc)\n {\n     const CChainParams& chainparams = Params();\n+    LOCK(cs_peerstate);\n+    CPeerState* peerstate = PeerState(pfrom->GetId());\n     //\n     // Message format\n     //  (4) message start\n@@ -3275,7 +3313,7 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     bool fRet = false;\n     try\n     {\n-        fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams, connman, interruptMsgProc, m_enable_bip61);\n+        fRet = ProcessMessage(pfrom, peerstate, strCommand, vRecv, msg.nTime, chainparams, connman, interruptMsgProc, m_enable_bip61);\n         if (interruptMsgProc)\n             return false;\n         if (!pfrom->vRecvGetData.empty())\n@@ -3484,6 +3522,9 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         // If we get here, the outgoing message serialization version is set and can't change.\n         const CNetMsgMaker msgMaker(pto->GetSendVersion());\n \n+        LOCK(cs_peerstate);\n+        CPeerState* peerstate = PeerState(pto->GetId());\n+\n         //\n         // Message: ping\n         //"
      }
    ]
  },
  {
    "sha": "ce89efbc54636175fdb2e4e8b44a61a154c71f30",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjZTg5ZWZiYzU0NjM2MTc1ZmRiMmU0ZThiNDRhNjFhMTU0YzcxZjMw",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-09T11:18:35Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-09T11:45:13Z"
      },
      "message": "Move nDoS counters to CPeerState (and, thus, out of cs_main)",
      "tree": {
        "sha": "02871f6493cb040443eeca72b06fc2f4a6cd1811",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/02871f6493cb040443eeca72b06fc2f4a6cd1811"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ce89efbc54636175fdb2e4e8b44a61a154c71f30",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ce89efbc54636175fdb2e4e8b44a61a154c71f30",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ce89efbc54636175fdb2e4e8b44a61a154c71f30",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ce89efbc54636175fdb2e4e8b44a61a154c71f30/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "54b3431c404c0879ea35091089c33288a3084403",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54b3431c404c0879ea35091089c33288a3084403",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/54b3431c404c0879ea35091089c33288a3084403"
      }
    ],
    "stats": {
      "total": 113,
      "additions": 59,
      "deletions": 54
    },
    "files": [
      {
        "sha": "56e59598bae40c54df577b1c5d945a443ab32813",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 59,
        "deletions": 54,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce89efbc54636175fdb2e4e8b44a61a154c71f30/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce89efbc54636175fdb2e4e8b44a61a154c71f30/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=ce89efbc54636175fdb2e4e8b44a61a154c71f30",
        "patch": "@@ -91,8 +91,10 @@ std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(g_cs_orphans);\n \n void EraseOrphansFor(NodeId peer);\n \n+/** Note that this must be locked BEFORE cs_main! */\n+CCriticalSection cs_peerstate ACQUIRED_BEFORE(cs_main);\n /** Increase a node's misbehavior score. */\n-void Misbehaving(NodeId nodeid, int howmuch, const std::string& message=\"\") EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+void Misbehaving(NodeId nodeid, int howmuch, const std::string& message=\"\") EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate);\n \n /** Average delay between local address broadcasts in seconds. */\n static constexpr unsigned int AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL = 24 * 60 * 60;\n@@ -204,7 +206,28 @@ struct CBlockReject {\n  * move most (non-validation-specific) state here.\n  */\n struct CPeerState {\n-    CPeerState() {}\n+    //! String name of this peer (debugging/logging purposes).\n+    const std::string name;\n+\n+    //! Whether this peer should be disconnected and banned (unless whitelisted).\n+    bool fShouldBan;\n+    //! Accumulated misbehaviour score for this peer.\n+    int nMisbehavior;\n+\n+    //! Whether this peer is an inbound connection\n+    bool m_is_inbound;\n+\n+    //! Whether this peer is a manual connection\n+    bool m_is_manual_connection;\n+\n+    CPeerState(std::string addrNameIn, bool is_inbound, bool is_manual) :\n+        name(std::move(addrNameIn)),\n+        m_is_inbound(is_inbound),\n+        m_is_manual_connection (is_manual)\n+    {\n+        fShouldBan = false;\n+        nMisbehavior = 0;\n+    }\n };\n \n \n@@ -219,12 +242,6 @@ struct CNodeState {\n     const CService address;\n     //! Whether we have a fully established connection.\n     bool fCurrentlyConnected;\n-    //! Accumulated misbehaviour score for this peer.\n-    int nMisbehavior;\n-    //! Whether this peer should be disconnected and banned (unless whitelisted).\n-    bool fShouldBan;\n-    //! String name of this peer (debugging/logging purposes).\n-    const std::string name;\n     //! List of asynchronously-determined block rejections to notify this peer about.\n     std::vector<CBlockReject> rejects;\n     //! The best known block we know this peer has announced.\n@@ -366,13 +383,11 @@ struct CNodeState {\n     //! Whether this peer is a manual connection\n     bool m_is_manual_connection;\n \n-    CNodeState(CAddress addrIn, std::string addrNameIn, bool is_inbound, bool is_manual) :\n-        address(addrIn), name(std::move(addrNameIn)), m_is_inbound(is_inbound),\n+    CNodeState(CAddress addrIn, bool is_inbound, bool is_manual) :\n+        address(addrIn), m_is_inbound(is_inbound),\n         m_is_manual_connection (is_manual)\n     {\n         fCurrentlyConnected = false;\n-        nMisbehavior = 0;\n-        fShouldBan = false;\n         pindexBestKnownBlock = nullptr;\n         hashLastUnknownBlock.SetNull();\n         pindexLastCommonBlock = nullptr;\n@@ -399,13 +414,10 @@ struct CNodeState {\n // Keeps track of the time (in microseconds) when transactions were requested last time\n limitedmap<uint256, int64_t> g_already_asked_for GUARDED_BY(cs_main)(MAX_INV_SZ);\n \n-/** Note that this must be locked BEFORE cs_main! */\n-CCriticalSection cs_peerstate;\n-\n /** Map maintaining per-node state. */\n static std::map<NodeId, CPeerState> mapPeerState GUARDED_BY(cs_peerstate);\n \n-static CPeerState *PeerState(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate) LOCKS_EXCLUDED(cs_main) {\n+static CPeerState *PeerState(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate) {\n     std::map<NodeId, CPeerState>::iterator it = mapPeerState.find(pnode);\n     if (it == mapPeerState.end())\n         return nullptr;\n@@ -778,11 +790,11 @@ void PeerLogicValidation::InitializeNode(CNode *pnode) {\n     NodeId nodeid = pnode->GetId();\n     {\n         LOCK(cs_main);\n-        mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName), pnode->fInbound, pnode->m_manual_connection));\n+        mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, pnode->fInbound, pnode->m_manual_connection));\n     }\n     {\n         LOCK(cs_peerstate);\n-        mapPeerState.emplace_hint(mapPeerState.end(), nodeid, CPeerState{});\n+        mapPeerState.emplace_hint(mapPeerState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(std::move(addrName), pnode->fInbound, pnode->m_manual_connection));\n     }\n \n     if(!pnode->fInbound)\n@@ -803,7 +815,7 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n     if (state->fSyncStarted)\n         nSyncStarted--;\n \n-    if (state->nMisbehavior == 0 && state->fCurrentlyConnected) {\n+    if (peerstate->nMisbehavior == 0 && state->fCurrentlyConnected) {\n         fUpdateConnectionTime = true;\n     }\n \n@@ -832,11 +844,14 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n }\n \n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n+    LOCK(cs_peerstate);\n+    CPeerState* peerstate = PeerState(nodeid);\n     LOCK(cs_main);\n     CNodeState *state = State(nodeid);\n-    if (state == nullptr)\n+    if (state == nullptr || peerstate == nullptr)\n         return false;\n-    stats.nMisbehavior = state->nMisbehavior;\n+\n+    stats.nMisbehavior = peerstate->nMisbehavior;\n     stats.nSyncHeight = state->pindexBestKnownBlock ? state->pindexBestKnownBlock->nHeight : -1;\n     stats.nCommonHeight = state->pindexLastCommonBlock ? state->pindexLastCommonBlock->nHeight : -1;\n     for (const QueuedBlock& queue : state->vBlocksInFlight) {\n@@ -979,27 +994,28 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n     return nEvicted;\n }\n \n+\n /**\n  * Mark a misbehaving peer to be banned depending upon the value of `-banscore`.\n  */\n-void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate)\n {\n     if (howmuch == 0)\n         return;\n \n-    CNodeState *state = State(pnode);\n-    if (state == nullptr)\n+    CPeerState *peerstate = PeerState(pnode);\n+    if (peerstate == nullptr)\n         return;\n \n-    state->nMisbehavior += howmuch;\n+    peerstate->nMisbehavior += howmuch;\n     int banscore = gArgs.GetArg(\"-banscore\", DEFAULT_BANSCORE_THRESHOLD);\n     std::string message_prefixed = message.empty() ? \"\" : (\": \" + message);\n-    if (state->nMisbehavior >= banscore && state->nMisbehavior - howmuch < banscore)\n+    if (peerstate->nMisbehavior >= banscore && peerstate->nMisbehavior - howmuch < banscore)\n     {\n-        LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d) BAN THRESHOLD EXCEEDED%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n-        state->fShouldBan = true;\n+        LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d) BAN THRESHOLD EXCEEDED%s\\n\", __func__, peerstate->name, pnode, peerstate->nMisbehavior-howmuch, peerstate->nMisbehavior, message_prefixed);\n+        peerstate->fShouldBan = true;\n     } else\n-        LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d)%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n+        LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d)%s\\n\", __func__, peerstate->name, pnode, peerstate->nMisbehavior-howmuch, peerstate->nMisbehavior, message_prefixed);\n }\n \n /**\n@@ -1025,30 +1041,28 @@ static bool TxRelayMayResultInDisconnect(const CValidationState& state)\n  *\n  * Changes here may need to be reflected in TxRelayMayResultInDisconnect().\n  */\n-static bool MaybePunishNode(NodeId nodeid, const CValidationState& state, bool via_compact_block, const std::string& message = \"\") {\n+static bool MaybePunishNode(NodeId nodeid, const CValidationState& state, bool via_compact_block, const std::string& message = \"\") EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate) {\n     switch (state.GetReason()) {\n     case ValidationInvalidReason::NONE:\n         break;\n     // The node is providing invalid data:\n     case ValidationInvalidReason::CONSENSUS:\n     case ValidationInvalidReason::BLOCK_MUTATED:\n         if (!via_compact_block) {\n-            LOCK(cs_main);\n             Misbehaving(nodeid, 100, message);\n             return true;\n         }\n         break;\n     case ValidationInvalidReason::CACHED_INVALID:\n         {\n-            LOCK(cs_main);\n-            CNodeState *node_state = State(nodeid);\n-            if (node_state == nullptr) {\n+            CPeerState *peer_state = PeerState(nodeid);\n+            if (peer_state == nullptr) {\n                 break;\n             }\n \n             // Ban outbound (but not inbound) peers if on an invalid chain.\n             // Exempt HB compact block peers and manual connections.\n-            if (!via_compact_block && !node_state->m_is_inbound && !node_state->m_is_manual_connection) {\n+            if (!via_compact_block && !peer_state->m_is_inbound && !peer_state->m_is_manual_connection) {\n                 Misbehaving(nodeid, 100, message);\n                 return true;\n             }\n@@ -1058,15 +1072,13 @@ static bool MaybePunishNode(NodeId nodeid, const CValidationState& state, bool v\n     case ValidationInvalidReason::BLOCK_CHECKPOINT:\n     case ValidationInvalidReason::BLOCK_INVALID_PREV:\n         {\n-            LOCK(cs_main);\n             Misbehaving(nodeid, 100, message);\n         }\n         return true;\n     // Conflicting (but not necessarily invalid) data or different policy:\n     case ValidationInvalidReason::BLOCK_MISSING_PREV:\n         {\n             // TODO: Handle this much more gracefully (10 DoS points is super arbitrary)\n-            LOCK(cs_main);\n             Misbehaving(nodeid, 10, message);\n         }\n         return true;\n@@ -1254,6 +1266,7 @@ void PeerLogicValidation::UpdatedBlockTip(const CBlockIndex *pindexNew, const CB\n  * peers announce compact blocks.\n  */\n void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationState& state) {\n+    LOCK(cs_peerstate);\n     LOCK(cs_main);\n \n     const uint256 hash(block.GetHash());\n@@ -1598,11 +1611,10 @@ static uint32_t GetFetchFlags(CNode* pfrom) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n     return nFetchFlags;\n }\n \n-inline void static SendBlockTransactions(const CBlock& block, const BlockTransactionsRequest& req, CNode* pfrom, CConnman* connman) {\n+inline void static SendBlockTransactions(const CBlock& block, const BlockTransactionsRequest& req, CNode* pfrom, CConnman* connman) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate) {\n     BlockTransactions resp(req);\n     for (size_t i = 0; i < req.indexes.size(); i++) {\n         if (req.indexes[i] >= block.vtx.size()) {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 100, strprintf(\"Peer %d sent us a getblocktxn with out-of-bounds tx indices\", pfrom->GetId()));\n             return;\n         }\n@@ -1614,7 +1626,7 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n     connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n-bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams, bool via_compact_block)\n+bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams, bool via_compact_block) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate)\n {\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n     size_t nCount = headers.size();\n@@ -1795,9 +1807,10 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n     return true;\n }\n \n-void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_set, std::list<CTransactionRef>& removed_txn) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans)\n+void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_set, std::list<CTransactionRef>& removed_txn) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate, cs_main, g_cs_orphans)\n {\n     AssertLockHeld(cs_main);\n+    AssertLockHeld(cs_peerstate);\n     AssertLockHeld(g_cs_orphans);\n     std::set<NodeId> setMisbehaving;\n     bool done = false;\n@@ -1872,7 +1885,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n                strCommand == NetMsgType::FILTERADD))\n     {\n         if (pfrom->nVersion >= NO_BLOOM_VERSION) {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 100);\n             return false;\n         } else {\n@@ -1913,7 +1925,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n             if (enable_bip61) {\n                 connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, std::string(\"Duplicate version message\")));\n             }\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 1);\n             return false;\n         }\n@@ -2081,7 +2092,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n \n     if (pfrom->nVersion == 0) {\n         // Must have a version message before anything else\n-        LOCK(cs_main);\n         Misbehaving(pfrom->GetId(), 1);\n         return false;\n     }\n@@ -2128,7 +2138,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n \n     if (!pfrom->fSuccessfullyConnected) {\n         // Must have a verack message before anything else\n-        LOCK(cs_main);\n         Misbehaving(pfrom->GetId(), 1);\n         return false;\n     }\n@@ -2142,7 +2151,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n             return true;\n         if (vAddr.size() > 1000)\n         {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 20, strprintf(\"message addr size() = %u\", vAddr.size()));\n             return false;\n         }\n@@ -2218,7 +2226,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n         vRecv >> vInv;\n         if (vInv.size() > MAX_INV_SZ)\n         {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 20, strprintf(\"message inv size() = %u\", vInv.size()));\n             return false;\n         }\n@@ -2276,7 +2283,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n         vRecv >> vInv;\n         if (vInv.size() > MAX_INV_SZ)\n         {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 20, strprintf(\"message getdata size() = %u\", vInv.size()));\n             return false;\n         }\n@@ -2940,7 +2946,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n         // Bypass the normal CBlock deserialization, as we don't want to risk deserializing 2000 full blocks.\n         unsigned int nCount = ReadCompactSize(vRecv);\n         if (nCount > MAX_HEADERS_RESULTS) {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 20, strprintf(\"headers message size = %u\", nCount));\n             return false;\n         }\n@@ -3122,7 +3127,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n         if (!filter.IsWithinSizeConstraints())\n         {\n             // There is no excuse for sending a too-large filter\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 100);\n         }\n         else\n@@ -3153,7 +3157,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n             }\n         }\n         if (bad) {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 100);\n         }\n         return true;\n@@ -3192,10 +3195,12 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n     return true;\n }\n \n-bool PeerLogicValidation::SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_bip61) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+bool PeerLogicValidation::SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_bip61) EXCLUSIVE_LOCKS_REQUIRED(cs_main, cs_peerstate)\n {\n     AssertLockHeld(cs_main);\n+    AssertLockHeld(cs_peerstate);\n     CNodeState &state = *State(pnode->GetId());\n+    CPeerState &peerstate = *PeerState(pnode->GetId());\n \n     if (enable_bip61) {\n         for (const CBlockReject& reject : state.rejects) {\n@@ -3204,8 +3209,8 @@ bool PeerLogicValidation::SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_\n     }\n     state.rejects.clear();\n \n-    if (state.fShouldBan) {\n-        state.fShouldBan = false;\n+    if (peerstate.fShouldBan) {\n+        peerstate.fShouldBan = false;\n         if (pnode->fWhitelisted)\n             LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pnode->addr.ToString());\n         else if (pnode->m_manual_connection)"
      }
    ]
  }
]