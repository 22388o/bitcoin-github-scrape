[
  {
    "sha": "18051c7fbd224e32d9a5fea96f1083210cea3a14",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxODA1MWM3ZmJkMjI0ZTMyZDlhNWZlYTk2ZjEwODMyMTBjZWEzYTE0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-04T18:06:20Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-03-21T14:06:18Z"
      },
      "message": "Abstract out Ctransaction-specific signing into TransactionSignatureCreator",
      "tree": {
        "sha": "d82cbc38c45adc46969bc18dabc4c8621afb6068",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d82cbc38c45adc46969bc18dabc4c8621afb6068"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/18051c7fbd224e32d9a5fea96f1083210cea3a14",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/18051c7fbd224e32d9a5fea96f1083210cea3a14",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/18051c7fbd224e32d9a5fea96f1083210cea3a14",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/18051c7fbd224e32d9a5fea96f1083210cea3a14/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f3948a30cd27928fdf9dffbbf90ea6430c869edf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f3948a30cd27928fdf9dffbbf90ea6430c869edf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f3948a30cd27928fdf9dffbbf90ea6430c869edf"
      }
    ],
    "stats": {
      "total": 130,
      "additions": 90,
      "deletions": 40
    },
    "files": [
      {
        "sha": "eab629cd9133022e4d4e01eebf372dc2b18216f7",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 36,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/18051c7fbd224e32d9a5fea96f1083210cea3a14/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/18051c7fbd224e32d9a5fea96f1083210cea3a14/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=18051c7fbd224e32d9a5fea96f1083210cea3a14",
        "patch": "@@ -17,43 +17,52 @@ using namespace std;\n \n typedef vector<unsigned char> valtype;\n \n-bool Sign1(const CKeyID& address, const CKeyStore& keystore, uint256 hash, int nHashType, CScript& scriptSigRet)\n+TransactionSignatureCreator::TransactionSignatureCreator(const CKeyStore* keystoreIn, const CTransaction* txToIn, unsigned int nInIn, int nHashTypeIn) : BaseSignatureCreator(keystoreIn), txTo(txToIn), nIn(nInIn), nHashType(nHashTypeIn), checker(txTo, nIn) {}\n+\n+bool TransactionSignatureCreator::CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& address, const CScript& scriptCode) const\n {\n     CKey key;\n-    if (!keystore.GetKey(address, key))\n+    if (!keystore->GetKey(address, key))\n         return false;\n \n-    vector<unsigned char> vchSig;\n+    uint256 hash = SignatureHash(scriptCode, *txTo, nIn, nHashType);\n     if (!key.Sign(hash, vchSig))\n         return false;\n     vchSig.push_back((unsigned char)nHashType);\n-    scriptSigRet << vchSig;\n+    return true;\n+}\n \n+static bool Sign1(const CKeyID& address, const BaseSignatureCreator& creator, const CScript& scriptCode, CScript& scriptSigRet)\n+{\n+    vector<unsigned char> vchSig;\n+    if (!creator.CreateSig(vchSig, address, scriptCode))\n+        return false;\n+    scriptSigRet << vchSig;\n     return true;\n }\n \n-bool SignN(const vector<valtype>& multisigdata, const CKeyStore& keystore, uint256 hash, int nHashType, CScript& scriptSigRet)\n+static bool SignN(const vector<valtype>& multisigdata, const BaseSignatureCreator& creator, const CScript& scriptCode, CScript& scriptSigRet)\n {\n     int nSigned = 0;\n     int nRequired = multisigdata.front()[0];\n     for (unsigned int i = 1; i < multisigdata.size()-1 && nSigned < nRequired; i++)\n     {\n         const valtype& pubkey = multisigdata[i];\n         CKeyID keyID = CPubKey(pubkey).GetID();\n-        if (Sign1(keyID, keystore, hash, nHashType, scriptSigRet))\n+        if (Sign1(keyID, creator, scriptCode, scriptSigRet))\n             ++nSigned;\n     }\n     return nSigned==nRequired;\n }\n \n /**\n- * Sign scriptPubKey with private keys stored in keystore, given transaction hash and hash type.\n+ * Sign scriptPubKey using signature made with creator.\n  * Signatures are returned in scriptSigRet (or returns false if scriptPubKey can't be signed),\n  * unless whichTypeRet is TX_SCRIPTHASH, in which case scriptSigRet is the redemption script.\n  * Returns false if scriptPubKey could not be completely satisfied.\n  */\n-bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash, int nHashType,\n-                  CScript& scriptSigRet, txnouttype& whichTypeRet)\n+static bool SignStep(const BaseSignatureCreator& creator, const CScript& scriptPubKey,\n+                     CScript& scriptSigRet, txnouttype& whichTypeRet)\n {\n     scriptSigRet.clear();\n \n@@ -69,61 +78,62 @@ bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash\n         return false;\n     case TX_PUBKEY:\n         keyID = CPubKey(vSolutions[0]).GetID();\n-        return Sign1(keyID, keystore, hash, nHashType, scriptSigRet);\n+        return Sign1(keyID, creator, scriptPubKey, scriptSigRet);\n     case TX_PUBKEYHASH:\n         keyID = CKeyID(uint160(vSolutions[0]));\n-        if (!Sign1(keyID, keystore, hash, nHashType, scriptSigRet))\n+        if (!Sign1(keyID, creator, scriptPubKey, scriptSigRet))\n             return false;\n         else\n         {\n             CPubKey vch;\n-            keystore.GetPubKey(keyID, vch);\n+            creator.KeyStore().GetPubKey(keyID, vch);\n             scriptSigRet << ToByteVector(vch);\n         }\n         return true;\n     case TX_SCRIPTHASH:\n-        return keystore.GetCScript(uint160(vSolutions[0]), scriptSigRet);\n+        return creator.KeyStore().GetCScript(uint160(vSolutions[0]), scriptSigRet);\n \n     case TX_MULTISIG:\n         scriptSigRet << OP_0; // workaround CHECKMULTISIG bug\n-        return (SignN(vSolutions, keystore, hash, nHashType, scriptSigRet));\n+        return (SignN(vSolutions, creator, scriptPubKey, scriptSigRet));\n     }\n     return false;\n }\n \n-bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n+bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& fromPubKey, CScript& scriptSig)\n {\n-    assert(nIn < txTo.vin.size());\n-    CTxIn& txin = txTo.vin[nIn];\n-\n-    // Leave out the signature from the hash, since a signature can't sign itself.\n-    // The checksig op will also drop the signatures from its hash.\n-    uint256 hash = SignatureHash(fromPubKey, txTo, nIn, nHashType);\n-\n     txnouttype whichType;\n-    if (!Solver(keystore, fromPubKey, hash, nHashType, txin.scriptSig, whichType))\n+    if (!SignStep(creator, fromPubKey, scriptSig, whichType))\n         return false;\n \n     if (whichType == TX_SCRIPTHASH)\n     {\n         // Solver returns the subscript that need to be evaluated;\n         // the final scriptSig is the signatures from that\n         // and then the serialized subscript:\n-        CScript subscript = txin.scriptSig;\n-\n-        // Recompute txn hash using subscript in place of scriptPubKey:\n-        uint256 hash2 = SignatureHash(subscript, txTo, nIn, nHashType);\n+        CScript subscript = scriptSig;\n \n         txnouttype subType;\n         bool fSolved =\n-            Solver(keystore, subscript, hash2, nHashType, txin.scriptSig, subType) && subType != TX_SCRIPTHASH;\n+            SignStep(creator, subscript, scriptSig, subType) && subType != TX_SCRIPTHASH;\n         // Append serialized subscript whether or not it is completely signed:\n-        txin.scriptSig << static_cast<valtype>(subscript);\n+        scriptSig << static_cast<valtype>(subscript);\n         if (!fSolved) return false;\n     }\n \n     // Test solution\n-    return VerifyScript(txin.scriptSig, fromPubKey, STANDARD_SCRIPT_VERIFY_FLAGS, MutableTransactionSignatureChecker(&txTo, nIn));\n+    return VerifyScript(scriptSig, fromPubKey, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+}\n+\n+bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n+{\n+    assert(nIn < txTo.vin.size());\n+    CTxIn& txin = txTo.vin[nIn];\n+\n+    CTransaction txToConst(txTo);\n+    TransactionSignatureCreator creator(&keystore, &txToConst, nIn, nHashType);\n+\n+    return ProduceSignature(creator, fromPubKey, txin.scriptSig);\n }\n \n bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n@@ -144,7 +154,7 @@ static CScript PushAll(const vector<valtype>& values)\n     return result;\n }\n \n-static CScript CombineMultisig(const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n+static CScript CombineMultisig(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n                                const vector<valtype>& vSolutions,\n                                const vector<valtype>& sigs1, const vector<valtype>& sigs2)\n {\n@@ -174,7 +184,7 @@ static CScript CombineMultisig(const CScript& scriptPubKey, const CTransaction&\n             if (sigs.count(pubkey))\n                 continue; // Already got a sig for this pubkey\n \n-            if (TransactionSignatureChecker(&txTo, nIn).CheckSig(sig, pubkey, scriptPubKey))\n+            if (checker.CheckSig(sig, pubkey, scriptPubKey))\n             {\n                 sigs[pubkey] = sig;\n                 break;\n@@ -199,7 +209,7 @@ static CScript CombineMultisig(const CScript& scriptPubKey, const CTransaction&\n     return result;\n }\n \n-static CScript CombineSignatures(const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n+static CScript CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n                                  const txnouttype txType, const vector<valtype>& vSolutions,\n                                  vector<valtype>& sigs1, vector<valtype>& sigs2)\n {\n@@ -233,19 +243,26 @@ static CScript CombineSignatures(const CScript& scriptPubKey, const CTransaction\n             Solver(pubKey2, txType2, vSolutions2);\n             sigs1.pop_back();\n             sigs2.pop_back();\n-            CScript result = CombineSignatures(pubKey2, txTo, nIn, txType2, vSolutions2, sigs1, sigs2);\n+            CScript result = CombineSignatures(pubKey2, checker, txType2, vSolutions2, sigs1, sigs2);\n             result << spk;\n             return result;\n         }\n     case TX_MULTISIG:\n-        return CombineMultisig(scriptPubKey, txTo, nIn, vSolutions, sigs1, sigs2);\n+        return CombineMultisig(scriptPubKey, checker, vSolutions, sigs1, sigs2);\n     }\n \n     return CScript();\n }\n \n CScript CombineSignatures(const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                           const CScript& scriptSig1, const CScript& scriptSig2)\n+{\n+    TransactionSignatureChecker checker(&txTo, nIn);\n+    return CombineSignatures(scriptPubKey, checker, scriptSig1, scriptSig2);\n+}\n+\n+CScript CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n+                          const CScript& scriptSig1, const CScript& scriptSig2)\n {\n     txnouttype txType;\n     vector<vector<unsigned char> > vSolutions;\n@@ -256,5 +273,5 @@ CScript CombineSignatures(const CScript& scriptPubKey, const CTransaction& txTo,\n     vector<valtype> stack2;\n     EvalScript(stack2, scriptSig2, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker());\n \n-    return CombineSignatures(scriptPubKey, txTo, nIn, txType, vSolutions, stack1, stack2);\n+    return CombineSignatures(scriptPubKey, checker, txType, vSolutions, stack1, stack2);\n }"
      },
      {
        "sha": "0c4cf61e5e74f2a1fcbe6ac985412a857351244d",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 37,
        "deletions": 4,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/18051c7fbd224e32d9a5fea96f1083210cea3a14/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/18051c7fbd224e32d9a5fea96f1083210cea3a14/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=18051c7fbd224e32d9a5fea96f1083210cea3a14",
        "patch": "@@ -8,19 +8,52 @@\n \n #include \"script/interpreter.h\"\n \n+class CKeyID;\n class CKeyStore;\n class CScript;\n class CTransaction;\n \n struct CMutableTransaction;\n \n+/** Virtual base class for signature creators. */\n+class BaseSignatureCreator {\n+protected:\n+    const CKeyStore* keystore;\n+\n+public:\n+    BaseSignatureCreator(const CKeyStore* keystoreIn) : keystore(keystoreIn) {}\n+    const CKeyStore& KeyStore() const { return *keystore; };\n+    virtual ~BaseSignatureCreator() {}\n+    virtual const BaseSignatureChecker& Checker() const =0;\n+\n+    /** Create a singular (non-script) signature. */\n+    virtual bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode) const =0;\n+};\n+\n+/** A signature creator for transactions. */\n+class TransactionSignatureCreator : public BaseSignatureCreator {\n+    const CTransaction* txTo;\n+    unsigned int nIn;\n+    int nHashType;\n+    const TransactionSignatureChecker checker;\n+\n+public:\n+    TransactionSignatureCreator(const CKeyStore* keystoreIn, const CTransaction* txToIn, unsigned int nInIn, int nHashTypeIn=SIGHASH_ALL);\n+    const BaseSignatureChecker& Checker() const { return checker; }\n+    bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode) const;\n+};\n+\n+/** Produce a script signature using a generic signature creator. */\n+bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& scriptPubKey, CScript& scriptSig);\n+\n+/** Produce a script signature for a transaction. */\n bool SignSignature(const CKeyStore& keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n \n-/**\n- * Given two sets of signatures for scriptPubKey, possibly with OP_0 placeholders,\n- * combine them intelligently and return the result.\n- */\n+/** Combine two script signatures using a generic signature checker, intelligently, possibly with OP_0 placeholders. */\n+CScript CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker, const CScript& scriptSig1, const CScript& scriptSig2);\n+\n+/** Combine two script signatures on transactions. */\n CScript CombineSignatures(const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, const CScript& scriptSig1, const CScript& scriptSig2);\n \n #endif // BITCOIN_SCRIPT_SIGN_H"
      }
    ]
  }
]