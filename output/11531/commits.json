[
  {
    "sha": "3b4ac43bc371561b5fa559bccb17dc0702bd4b69",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozYjRhYzQzYmMzNzE1NjFiNWZhNTU5YmNjYjE3ZGMwNzAyYmQ0YjY5",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-11T19:38:56Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-31T17:36:02Z"
      },
      "message": "Rewrite p2p-acceptblock in preparation for slight behavior changes\n\nRemoves checking whitelisted behavior (which will be removed, the\ndifference in behavior here makes little sense) and no longer\nrequires that blocks at the same work as our tip be dropped if not\nrequested (in part because we *do* request those blocks).",
      "tree": {
        "sha": "5ccd26019e63bf1351b92cead7ba0f872a335556",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5ccd26019e63bf1351b92cead7ba0f872a335556"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3b4ac43bc371561b5fa559bccb17dc0702bd4b69",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3b4ac43bc371561b5fa559bccb17dc0702bd4b69",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3b4ac43bc371561b5fa559bccb17dc0702bd4b69",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3b4ac43bc371561b5fa559bccb17dc0702bd4b69/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d93fa261f079d529a94ff26aa406a49e28d10340",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d93fa261f079d529a94ff26aa406a49e28d10340",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d93fa261f079d529a94ff26aa406a49e28d10340"
      }
    ],
    "stats": {
      "total": 236,
      "additions": 122,
      "deletions": 114
    },
    "files": [
      {
        "sha": "9b2c1a73fc2f2f49f0eee3db4d61c452d1d87e0a",
        "filename": "test/functional/p2p-acceptblock.py",
        "status": "modified",
        "additions": 122,
        "deletions": 114,
        "changes": 236,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b4ac43bc371561b5fa559bccb17dc0702bd4b69/test/functional/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b4ac43bc371561b5fa559bccb17dc0702bd4b69/test/functional/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-acceptblock.py?ref=3b4ac43bc371561b5fa559bccb17dc0702bd4b69",
        "patch": "@@ -4,42 +4,32 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test processing of unrequested blocks.\n \n-Since behavior differs when receiving unrequested blocks from whitelisted peers\n-versus non-whitelisted peers, this tests the behavior of both (effectively two\n-separate tests running in parallel).\n+Setup: two nodes, node0+node1, not connected to each other. Node1 will have\n+nMinimumChainWork set to 0x10, so it won't process low-work unrequested blocks.\n \n-Setup: three nodes, node0+node1+node2, not connected to each other.  Node0 does not\n-whitelist localhost, but node1 does. They will each be on their own chain for\n-this test.  Node2 will have nMinimumChainWork set to 0x10, so it won't process\n-low-work unrequested blocks.\n-\n-We have one NodeConn connection to each, test_node, white_node, and min_work_node,\n-respectively.\n+We have one NodeConn connection to node0 called test_node, and one to node1\n+called min_work_node.\n \n The test:\n 1. Generate one block on each node, to leave IBD.\n \n 2. Mine a new block on each tip, and deliver to each node from node's peer.\n-   The tip should advance for node0 and node1, but node2 should skip processing\n-   due to nMinimumChainWork.\n+   The tip should advance for node0, but node1 should skip processing due to\n+   nMinimumChainWork.\n \n-Node2 is unused in tests 3-7:\n+Node1 is unused in tests 3-7:\n \n-3. Mine a block that forks the previous block, and deliver to each node from\n-   corresponding peer.\n-   Node0 should not process this block (just accept the header), because it is\n-   unrequested and doesn't have more work than the tip.\n-   Node1 should process because this is coming from a whitelisted peer.\n+3. Mine a block that forks from the genesis block, and deliver to test_node.\n+   Node0 should not process this block (just accept the header), because it\n+   is unrequested and doesn't have more or equal work to the tip.\n \n-4. Send another block that builds on the forking block.\n-   Node0 should process this block but be stuck on the shorter chain, because\n-   it's missing an intermediate block.\n-   Node1 should reorg to this longer chain.\n+4a,b. Send another two blocks that build on the forking block.\n+   Node0 should process the second block but be stuck on the shorter chain,\n+   because it's missing an intermediate block.\n \n-4b.Send 288 more blocks on the longer chain.\n+4c.Send 288 more blocks on the longer chain (the number of blocks ahead\n+   we currently store).\n    Node0 should process all but the last block (too far ahead in height).\n-   Send all headers to Node1, and then send the last block in that chain.\n-   Node1 should accept the block because it's coming from a whitelisted peer.\n \n 5. Send a duplicate of the block in #3 to Node0.\n    Node0 should not process the block because it is unrequested, and stay on\n@@ -52,7 +42,7 @@\n 7. Send Node0 the missing block again.\n    Node0 should process and the tip should advance.\n \n-8. Test Node2 is able to sync when connected to node0 (which should have sufficient\n+8. Test Node1 is able to sync when connected to node0 (which should have sufficient\n work on its chain).\n \n \"\"\"\n@@ -71,8 +61,8 @@ def add_options(self, parser):\n \n     def set_test_params(self):\n         self.setup_clean_chain = True\n-        self.num_nodes = 3\n-        self.extra_args = [[], [\"-whitelist=127.0.0.1\"], [\"-minimumchainwork=0x10\"]]\n+        self.num_nodes = 2\n+        self.extra_args = [[], [\"-minimumchainwork=0x10\"]]\n \n     def setup_network(self):\n         # Node0 will be used to test behavior of processing unrequested blocks\n@@ -84,132 +74,149 @@ def setup_network(self):\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n-        test_node = NodeConnCB()   # connects to node0 (not whitelisted)\n-        white_node = NodeConnCB()  # connects to node1 (whitelisted)\n-        min_work_node = NodeConnCB()  # connects to node2 (not whitelisted)\n+        test_node = NodeConnCB()   # connects to node0\n+        min_work_node = NodeConnCB()  # connects to node1\n \n         connections = []\n         connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1], white_node))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(2), self.nodes[2], min_work_node))\n+        connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1], min_work_node))\n         test_node.add_connection(connections[0])\n-        white_node.add_connection(connections[1])\n-        min_work_node.add_connection(connections[2])\n+        min_work_node.add_connection(connections[1])\n \n         NetworkThread().start() # Start up network handling in another thread\n \n         # Test logic begins here\n         test_node.wait_for_verack()\n-        white_node.wait_for_verack()\n         min_work_node.wait_for_verack()\n \n-        # 1. Have nodes mine a block (nodes1/2 leave IBD)\n+        # 1. Have nodes mine a block (leave IBD)\n         [ n.generate(1) for n in self.nodes ]\n         tips = [ int(\"0x\" + n.getbestblockhash(), 0) for n in self.nodes ]\n \n         # 2. Send one block that builds on each tip.\n-        # This should be accepted by nodes 1/2\n+        # This should be accepted by node0\n         blocks_h2 = []  # the height 2 blocks on each node's chain\n         block_time = int(time.time()) + 1\n-        for i in range(3):\n+        for i in range(2):\n             blocks_h2.append(create_block(tips[i], create_coinbase(2), block_time))\n             blocks_h2[i].solve()\n             block_time += 1\n         test_node.send_message(msg_block(blocks_h2[0]))\n-        white_node.send_message(msg_block(blocks_h2[1]))\n-        min_work_node.send_message(msg_block(blocks_h2[2]))\n+        min_work_node.send_message(msg_block(blocks_h2[1]))\n \n-        for x in [test_node, white_node, min_work_node]:\n+        for x in [test_node, min_work_node]:\n             x.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 2)\n-        assert_equal(self.nodes[1].getblockcount(), 2)\n-        assert_equal(self.nodes[2].getblockcount(), 1)\n-        self.log.info(\"First height 2 block accepted by node0/node1; correctly rejected by node2\")\n+        assert_equal(self.nodes[1].getblockcount(), 1)\n+        self.log.info(\"First height 2 block accepted by node0; correctly rejected by node1\")\n \n-        # 3. Send another block that builds on the original tip.\n-        blocks_h2f = []  # Blocks at height 2 that fork off the main chain\n-        for i in range(2):\n-            blocks_h2f.append(create_block(tips[i], create_coinbase(2), blocks_h2[i].nTime+1))\n-            blocks_h2f[i].solve()\n-        test_node.send_message(msg_block(blocks_h2f[0]))\n-        white_node.send_message(msg_block(blocks_h2f[1]))\n+        # 3. Send another block that builds on genesis.\n+        block_h1f = create_block(int(\"0x\" + self.nodes[0].getblockhash(0), 0), create_coinbase(1), block_time)\n+        block_time += 1\n+        block_h1f.solve()\n+        test_node.send_message(msg_block(block_h1f))\n \n-        for x in [test_node, white_node]:\n-            x.sync_with_ping()\n+        test_node.sync_with_ping()\n+        tip_entry_found = False\n         for x in self.nodes[0].getchaintips():\n-            if x['hash'] == blocks_h2f[0].hash:\n+            if x['hash'] == block_h1f.hash:\n                 assert_equal(x['status'], \"headers-only\")\n+                tip_entry_found = True\n+        assert(tip_entry_found)\n+        assert_raises_rpc_error(-1, \"Block not found on disk\", self.nodes[0].getblock, block_h1f.hash)\n+\n+        # 4. Send another two block that build on the fork.\n+        block_h2f = create_block(block_h1f.sha256, create_coinbase(2), block_time)\n+        block_time += 1\n+        block_h2f.solve()\n+        test_node.send_message(msg_block(block_h2f))\n \n-        for x in self.nodes[1].getchaintips():\n-            if x['hash'] == blocks_h2f[1].hash:\n-                assert_equal(x['status'], \"valid-headers\")\n+        test_node.sync_with_ping()\n+        # Since the earlier block was not processed by node, the new block\n+        # can't be fully validated.\n+        tip_entry_found = False\n+        for x in self.nodes[0].getchaintips():\n+            if x['hash'] == block_h2f.hash:\n+                assert_equal(x['status'], \"headers-only\")\n+                tip_entry_found = True\n+        assert(tip_entry_found)\n \n-        self.log.info(\"Second height 2 block accepted only from whitelisted peer\")\n+        # But this block should be accepted by node since it has equal work.\n+        # TODO: We currently drop this block but likely shouldn't\n+        #self.nodes[0].getblock(block_h2f.hash)\n+        self.log.info(\"Second height 2 block accepted, but not reorg'ed to\")\n \n-        # 4. Now send another block that builds on the forking chain.\n-        blocks_h3 = []\n-        for i in range(2):\n-            blocks_h3.append(create_block(blocks_h2f[i].sha256, create_coinbase(3), blocks_h2f[i].nTime+1))\n-            blocks_h3[i].solve()\n-        test_node.send_message(msg_block(blocks_h3[0]))\n-        white_node.send_message(msg_block(blocks_h3[1]))\n+        # 4b. Now send another block that builds on the forking chain.\n+        block_h3 = create_block(block_h2f.sha256, create_coinbase(3), block_h2f.nTime+1)\n+        block_h3.solve()\n+        test_node.send_message(msg_block(block_h3))\n \n-        for x in [test_node, white_node]:\n-            x.sync_with_ping()\n-        # Since the earlier block was not processed by node0, the new block\n+        test_node.sync_with_ping()\n+        # Since the earlier block was not processed by node, the new block\n         # can't be fully validated.\n+        tip_entry_found = False\n         for x in self.nodes[0].getchaintips():\n-            if x['hash'] == blocks_h3[0].hash:\n+            if x['hash'] == block_h3.hash:\n                 assert_equal(x['status'], \"headers-only\")\n+                tip_entry_found = True\n+        assert(tip_entry_found)\n+        self.nodes[0].getblock(block_h3.hash)\n+\n+        # But this block should be accepted by node since it has more work.\n+        self.nodes[0].getblock(block_h3.hash)\n+        self.log.info(\"Unrequested more-work block accepted\")\n+\n+        # 4c. Now mine 288 more blocks and deliver; all should be processed but\n+        # the last (height-too-high) on node (as long as its not missing any headers)\n+        tip = block_h3\n+        all_blocks = []\n+        for i in range(288):\n+            next_block = create_block(tip.sha256, create_coinbase(i + 4), tip.nTime+1)\n+            next_block.solve()\n+            all_blocks.append(next_block)\n+            tip = next_block\n+\n+        # Now send the block at height 5 and check that it wasn't accepted (missing header)\n+        test_node.send_message(msg_block(all_blocks[1]))\n+        test_node.sync_with_ping()\n+        assert_raises_rpc_error(-5, \"Block not found\", self.nodes[0].getblock, all_blocks[1].hash)\n+        assert_raises_rpc_error(-5, \"Block not found\", self.nodes[0].getblockheader, all_blocks[1].hash)\n \n-        # But this block should be accepted by node0 since it has more work.\n-        self.nodes[0].getblock(blocks_h3[0].hash)\n-        self.log.info(\"Unrequested more-work block accepted from non-whitelisted peer\")\n+        # The block at height 5 should be accepted if we provide the missing header, though\n+        headers_message = msg_headers()\n+        headers_message.headers.append(CBlockHeader(all_blocks[0]))\n+        test_node.send_message(headers_message)\n+        test_node.send_message(msg_block(all_blocks[1]))\n+        test_node.sync_with_ping()\n+        self.nodes[0].getblock(all_blocks[1].hash)\n \n-        # Node1 should have accepted and reorged.\n-        assert_equal(self.nodes[1].getblockcount(), 3)\n-        self.log.info(\"Successfully reorged to length 3 chain from whitelisted peer\")\n+        # Now send the blocks in all_blocks\n+        for i in range(288):\n+            test_node.send_message(msg_block(all_blocks[i]))\n+        test_node.sync_with_ping()\n \n-        # 4b. Now mine 288 more blocks and deliver; all should be processed but\n-        # the last (height-too-high) on node0.  Node1 should process the tip if\n-        # we give it the headers chain leading to the tip.\n-        tips = blocks_h3\n-        headers_message = msg_headers()\n-        all_blocks = []   # node0's blocks\n-        for j in range(2):\n-            for i in range(288):\n-                next_block = create_block(tips[j].sha256, create_coinbase(i + 4), tips[j].nTime+1)\n-                next_block.solve()\n-                if j==0:\n-                    test_node.send_message(msg_block(next_block))\n-                    all_blocks.append(next_block)\n-                else:\n-                    headers_message.headers.append(CBlockHeader(next_block))\n-                tips[j] = next_block\n-\n-        time.sleep(2)\n         # Blocks 1-287 should be accepted, block 288 should be ignored because it's too far ahead\n         for x in all_blocks[:-1]:\n             self.nodes[0].getblock(x.hash)\n         assert_raises_rpc_error(-1, \"Block not found on disk\", self.nodes[0].getblock, all_blocks[-1].hash)\n \n-        headers_message.headers.pop() # Ensure the last block is unrequested\n-        white_node.send_message(headers_message) # Send headers leading to tip\n-        white_node.send_message(msg_block(tips[1]))  # Now deliver the tip\n-        white_node.sync_with_ping()\n-        self.nodes[1].getblock(tips[1].hash)\n-        self.log.info(\"Unrequested block far ahead of tip accepted from whitelisted peer\")\n-\n         # 5. Test handling of unrequested block on the node that didn't process\n         # Should still not be processed (even though it has a child that has more\n         # work).\n-        test_node.send_message(msg_block(blocks_h2f[0]))\n \n-        # Here, if the sleep is too short, the test could falsely succeed (if the\n-        # node hasn't processed the block by the time the sleep returns, and then\n-        # the node processes it and incorrectly advances the tip).\n-        # But this would be caught later on, when we verify that an inv triggers\n-        # a getdata request for this block.\n+        # The node should have requested the blocks at some point, so\n+        # disconnect/reconnect first\n+        connections[0].disconnect_node()\n+        test_node.wait_for_disconnect()\n+\n+        test_node = NodeConnCB()   # connects to node (not whitelisted)\n+        connections[0] = NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node)\n+        test_node.add_connection(connections[0])\n+\n+        test_node.wait_for_verack()\n+        test_node.send_message(msg_block(block_h1f))\n+        test_node.send_message(msg_block(block_h2f)) # This should not be required\n+\n         test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 2)\n         self.log.info(\"Unrequested block that would complete more-work chain was ignored\")\n@@ -220,27 +227,28 @@ def run_test(self):\n         with mininode_lock:\n             # Clear state so we can check the getdata request\n             test_node.last_message.pop(\"getdata\", None)\n-            test_node.send_message(msg_inv([CInv(2, blocks_h3[0].sha256)]))\n+            test_node.send_message(msg_inv([CInv(2, block_h3.sha256)]))\n \n         test_node.sync_with_ping()\n         with mininode_lock:\n             getdata = test_node.last_message[\"getdata\"]\n \n         # Check that the getdata includes the right block\n-        assert_equal(getdata.inv[0].hash, blocks_h2f[0].sha256)\n+        assert_equal(getdata.inv[0].hash, block_h1f.sha256)\n         self.log.info(\"Inv at tip triggered getdata for unprocessed block\")\n \n         # 7. Send the missing block for the third time (now it is requested)\n-        test_node.send_message(msg_block(blocks_h2f[0]))\n+        test_node.send_message(msg_block(block_h1f))\n+        test_node.send_message(msg_block(block_h2f)) # This should not be required\n \n         test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 290)\n         self.log.info(\"Successfully reorged to longer chain from non-whitelisted peer\")\n \n-        # 8. Connect node2 to node0 and ensure it is able to sync\n-        connect_nodes(self.nodes[0], 2)\n-        sync_blocks([self.nodes[0], self.nodes[2]])\n-        self.log.info(\"Successfully synced nodes 2 and 0\")\n+        # 8. Connect node1 to node0 and ensure it is able to sync\n+        connect_nodes(self.nodes[0], 1)\n+        sync_blocks([self.nodes[0], self.nodes[1]])\n+        self.log.info(\"Successfully synced nodes 1 and 0\")\n \n         [ c.disconnect_node() for c in connections ]\n "
      }
    ]
  },
  {
    "sha": "3d9c70ca0fd5d42f31114b689714af1825f0ed30",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozZDljNzBjYTBmZDVkNDJmMzExMTRiNjg5NzE0YWYxODI1ZjBlZDMw",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-11T20:01:51Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-31T17:36:06Z"
      },
      "message": "Stop always storing blocks from whitelisted peers\n\nThere is no reason to wish to store blocks on disk always just\nbecause a peer is whitelisted. This appears to be a historical\nquirk to avoid breaking things when the accept limits were added.",
      "tree": {
        "sha": "4eaa24c761798416ad83ab0aac95b1e3f0a5c75d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4eaa24c761798416ad83ab0aac95b1e3f0a5c75d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3d9c70ca0fd5d42f31114b689714af1825f0ed30",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3d9c70ca0fd5d42f31114b689714af1825f0ed30",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3d9c70ca0fd5d42f31114b689714af1825f0ed30",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3d9c70ca0fd5d42f31114b689714af1825f0ed30/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3b4ac43bc371561b5fa559bccb17dc0702bd4b69",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3b4ac43bc371561b5fa559bccb17dc0702bd4b69",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3b4ac43bc371561b5fa559bccb17dc0702bd4b69"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 1,
      "deletions": 5
    },
    "files": [
      {
        "sha": "c093d1d57f905fecd538d52868ec008cbe40a4e7",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3d9c70ca0fd5d42f31114b689714af1825f0ed30/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3d9c70ca0fd5d42f31114b689714af1825f0ed30/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=3d9c70ca0fd5d42f31114b689714af1825f0ed30",
        "patch": "@@ -2480,11 +2480,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         LogPrint(BCLog::NET, \"received block %s peer=%d\\n\", pblock->GetHash().ToString(), pfrom->GetId());\n \n-        // Process all blocks from whitelisted peers, even if not requested,\n-        // unless we're still syncing with the network.\n-        // Such an unrequested block may still be processed, subject to the\n-        // conditions in AcceptBlock().\n-        bool forceProcessing = pfrom->fWhitelisted && !IsInitialBlockDownload();\n+        bool forceProcessing = false;\n         const uint256 hash(pblock->GetHash());\n         {\n             LOCK(cs_main);"
      }
    ]
  },
  {
    "sha": "932f118e6a3779bb3d6c3cc83963cf34ac150e42",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MzJmMTE4ZTZhMzc3OWJiM2Q2YzNjYzgzOTYzY2YzNGFjMTUwZTQy",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-11T20:04:13Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-31T17:36:06Z"
      },
      "message": "Accept unrequested blocks with work equal to our tip\n\nThis is a simple change that makes our accept requirements the\nsame as our request requirements, (ever so slightly) further\ndecoupling our consensus logic from our FindNextBlocksToDownload\nlogic in net_processing.",
      "tree": {
        "sha": "0905a7e98cc673f0cf5550ce0cf576735b73d8d3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0905a7e98cc673f0cf5550ce0cf576735b73d8d3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/932f118e6a3779bb3d6c3cc83963cf34ac150e42",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/932f118e6a3779bb3d6c3cc83963cf34ac150e42",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/932f118e6a3779bb3d6c3cc83963cf34ac150e42",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/932f118e6a3779bb3d6c3cc83963cf34ac150e42/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3d9c70ca0fd5d42f31114b689714af1825f0ed30",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3d9c70ca0fd5d42f31114b689714af1825f0ed30",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3d9c70ca0fd5d42f31114b689714af1825f0ed30"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 5,
      "deletions": 8
    },
    "files": [
      {
        "sha": "9ea8c31b7db75e13e812cb1de4acef51def1d37e",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/932f118e6a3779bb3d6c3cc83963cf34ac150e42/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/932f118e6a3779bb3d6c3cc83963cf34ac150e42/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=932f118e6a3779bb3d6c3cc83963cf34ac150e42",
        "patch": "@@ -3115,7 +3115,7 @@ static bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidation\n     // process an unrequested block if it's new and has enough work to\n     // advance our tip, and isn't too many blocks ahead.\n     bool fAlreadyHave = pindex->nStatus & BLOCK_HAVE_DATA;\n-    bool fHasMoreWork = (chainActive.Tip() ? pindex->nChainWork > chainActive.Tip()->nChainWork : true);\n+    bool fHasMoreOrSameWork = (chainActive.Tip() ? pindex->nChainWork >= chainActive.Tip()->nChainWork : true);\n     // Blocks that are too out-of-order needlessly limit the effectiveness of\n     // pruning, because pruning will not delete block files that contain any\n     // blocks which are too close in height to the tip.  Apply this test\n@@ -3132,9 +3132,9 @@ static bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidation\n     // and unrequested blocks.\n     if (fAlreadyHave) return true;\n     if (!fRequested) {  // If we didn't ask for it:\n-        if (pindex->nTx != 0) return true;  // This is a previously-processed block that was pruned\n-        if (!fHasMoreWork) return true;     // Don't process less-work chains\n-        if (fTooFarAhead) return true;      // Block height is too high\n+        if (pindex->nTx != 0) return true;    // This is a previously-processed block that was pruned\n+        if (!fHasMoreOrSameWork) return true; // Don't process less-work chains\n+        if (fTooFarAhead) return true;        // Block height is too high\n \n         // Protect against DoS attacks from low-work chains.\n         // If our tip is behind, a peer could try to send us"
      },
      {
        "sha": "36e0bd9ec68ce95bcb70e0e6135ac0f7dd631833",
        "filename": "test/functional/p2p-acceptblock.py",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/932f118e6a3779bb3d6c3cc83963cf34ac150e42/test/functional/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/932f118e6a3779bb3d6c3cc83963cf34ac150e42/test/functional/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-acceptblock.py?ref=932f118e6a3779bb3d6c3cc83963cf34ac150e42",
        "patch": "@@ -142,8 +142,7 @@ def run_test(self):\n         assert(tip_entry_found)\n \n         # But this block should be accepted by node since it has equal work.\n-        # TODO: We currently drop this block but likely shouldn't\n-        #self.nodes[0].getblock(block_h2f.hash)\n+        self.nodes[0].getblock(block_h2f.hash)\n         self.log.info(\"Second height 2 block accepted, but not reorg'ed to\")\n \n         # 4b. Now send another block that builds on the forking chain.\n@@ -215,7 +214,6 @@ def run_test(self):\n \n         test_node.wait_for_verack()\n         test_node.send_message(msg_block(block_h1f))\n-        test_node.send_message(msg_block(block_h2f)) # This should not be required\n \n         test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 2)\n@@ -239,7 +237,6 @@ def run_test(self):\n \n         # 7. Send the missing block for the third time (now it is requested)\n         test_node.send_message(msg_block(block_h1f))\n-        test_node.send_message(msg_block(block_h2f)) # This should not be required\n \n         test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 290)"
      }
    ]
  },
  {
    "sha": "015a5258adffb0cf394f387a95ac9c8afc34cfc3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMTVhNTI1OGFkZmZiMGNmMzk0ZjM4N2E5NWFjOWM4YWZjMzRjZmMz",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-19T20:55:31Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-31T17:51:30Z"
      },
      "message": "Reject headers building on invalid chains by tracking invalidity\n\nThis tracks the set of all known invalid-themselves blocks (ie\nblocks which we attempted to connect but which were found to be\ninvalid). This is used to cheaply check if new headers build on an\ninvalid chain.\n\nWhile we're at it we also resolve an edge-case in invalidateblock\non pruned nodes which results in them needing a reindex if they\nfail to reorg.",
      "tree": {
        "sha": "8aeccc239b697447c3fce49fa07807175ad798cb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8aeccc239b697447c3fce49fa07807175ad798cb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/015a5258adffb0cf394f387a95ac9c8afc34cfc3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/015a5258adffb0cf394f387a95ac9c8afc34cfc3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/015a5258adffb0cf394f387a95ac9c8afc34cfc3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/015a5258adffb0cf394f387a95ac9c8afc34cfc3/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "932f118e6a3779bb3d6c3cc83963cf34ac150e42",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/932f118e6a3779bb3d6c3cc83963cf34ac150e42",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/932f118e6a3779bb3d6c3cc83963cf34ac150e42"
      }
    ],
    "stats": {
      "total": 74,
      "additions": 66,
      "deletions": 8
    },
    "files": [
      {
        "sha": "60f44c595ff863fc5155b126760adcaed74f1a5b",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 66,
        "deletions": 8,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/015a5258adffb0cf394f387a95ac9c8afc34cfc3/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/015a5258adffb0cf394f387a95ac9c8afc34cfc3/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=015a5258adffb0cf394f387a95ac9c8afc34cfc3",
        "patch": "@@ -156,6 +156,26 @@ namespace {\n     /** chainwork for the last block that preciousblock has been applied to. */\n     arith_uint256 nLastPreciousChainwork = 0;\n \n+    /** In order to efficiently track invalidity of headers, we keep the set of\n+      * blocks which we tried to connect and found to be invalid here (ie which\n+      * were set to BLOCK_FAILED_VALID since the last restart). We can then\n+      * walk this set and check if a new header is a descendant of something in\n+      * this set, preventing us from having to walk mapBlockIndex when we try\n+      * to connect a bad block and fail.\n+      *\n+      * While this is more complicated than marking everything which descends\n+      * from an invalid block as invalid at the time we discover it to be\n+      * invalid, doing so would require walking all of mapBlockIndex to find all\n+      * descendants. Since this case should be very rare, keeping track of all\n+      * BLOCK_FAILED_VALID blocks in a set should be just fine and work just as\n+      * well.\n+      *\n+      * Because we alreardy walk mapBlockIndex in height-order at startup, we go\n+      * ahead and mark descendants of invalid blocks as FAILED_CHILD at that time,\n+      * instead of putting things in this set.\n+      */\n+    std::set<CBlockIndex*> g_failed_blocks;\n+\n     /** Dirty block index entries. */\n     std::set<CBlockIndex*> setDirtyBlockIndex;\n \n@@ -1180,6 +1200,7 @@ void static InvalidChainFound(CBlockIndex* pindexNew)\n void static InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state) {\n     if (!state.CorruptionPossible()) {\n         pindex->nStatus |= BLOCK_FAILED_VALID;\n+        g_failed_blocks.insert(pindex);\n         setDirtyBlockIndex.insert(pindex);\n         setBlockIndexCandidates.erase(pindex);\n         InvalidChainFound(pindex);\n@@ -2533,17 +2554,18 @@ bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, C\n {\n     AssertLockHeld(cs_main);\n \n-    // Mark the block itself as invalid.\n-    pindex->nStatus |= BLOCK_FAILED_VALID;\n-    setDirtyBlockIndex.insert(pindex);\n-    setBlockIndexCandidates.erase(pindex);\n+    // We first disconnect backwards and then mark the blocks as invalid.\n+    // This prevents a case where pruned nodes may fail to invalidateblock\n+    // and be left unable to start as they have no tip candidates (as there\n+    // are no blocks that meet the \"have data and are not invalid per\n+    // nStatus\" criteria for inclusion in setBlockIndexCandidates).\n+\n+    bool pindex_was_in_chain = false;\n+    CBlockIndex *invalid_walk_tip = chainActive.Tip();\n \n     DisconnectedBlockTransactions disconnectpool;\n     while (chainActive.Contains(pindex)) {\n-        CBlockIndex *pindexWalk = chainActive.Tip();\n-        pindexWalk->nStatus |= BLOCK_FAILED_CHILD;\n-        setDirtyBlockIndex.insert(pindexWalk);\n-        setBlockIndexCandidates.erase(pindexWalk);\n+        pindex_was_in_chain = true;\n         // ActivateBestChain considers blocks already in chainActive\n         // unconditionally valid already, so force disconnect away from it.\n         if (!DisconnectTip(state, chainparams, &disconnectpool)) {\n@@ -2554,6 +2576,21 @@ bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, C\n         }\n     }\n \n+    // Now mark the blocks we just disconnected as descendants invalid\n+    // (note this may not be all descendants).\n+    while (pindex_was_in_chain && invalid_walk_tip != pindex) {\n+        invalid_walk_tip->nStatus |= BLOCK_FAILED_CHILD;\n+        setDirtyBlockIndex.insert(invalid_walk_tip);\n+        setBlockIndexCandidates.erase(invalid_walk_tip);\n+        invalid_walk_tip = invalid_walk_tip->pprev;\n+    }\n+\n+    // Mark the block itself as invalid.\n+    pindex->nStatus |= BLOCK_FAILED_VALID;\n+    setDirtyBlockIndex.insert(pindex);\n+    setBlockIndexCandidates.erase(pindex);\n+    g_failed_blocks.insert(pindex);\n+\n     // DisconnectTip will add transactions to disconnectpool; try to add these\n     // back to the mempool.\n     UpdateMempoolForReorg(disconnectpool, true);\n@@ -2591,6 +2628,7 @@ bool ResetBlockFailureFlags(CBlockIndex *pindex) {\n                 // Reset invalid block marker if it was pointing to one of those.\n                 pindexBestInvalid = nullptr;\n             }\n+            g_failed_blocks.erase(it->second);\n         }\n         it++;\n     }\n@@ -3066,6 +3104,21 @@ static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state\n             return state.DoS(100, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n         if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev, GetAdjustedTime()))\n             return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n+\n+        if (!pindexPrev->IsValid(BLOCK_VALID_SCRIPTS)) {\n+            for (const CBlockIndex* failedit : g_failed_blocks) {\n+                if (pindexPrev->GetAncestor(failedit->nHeight) == failedit) {\n+                    assert(failedit->nStatus & BLOCK_FAILED_VALID);\n+                    CBlockIndex* invalid_walk = pindexPrev;\n+                    while (invalid_walk != failedit) {\n+                        invalid_walk->nStatus |= BLOCK_FAILED_CHILD;\n+                        setDirtyBlockIndex.insert(invalid_walk);\n+                        invalid_walk = invalid_walk->pprev;\n+                    }\n+                    return state.DoS(100, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n+                }\n+            }\n+        }\n     }\n     if (pindex == nullptr)\n         pindex = AddToBlockIndex(block);\n@@ -3492,6 +3545,10 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams)\n                 pindex->nChainTx = pindex->nTx;\n             }\n         }\n+        if (!(pindex->nStatus & BLOCK_FAILED_MASK) && pindex->pprev && (pindex->pprev->nStatus & BLOCK_FAILED_MASK)) {\n+            pindex->nStatus |= BLOCK_FAILED_CHILD;\n+            setDirtyBlockIndex.insert(pindex);\n+        }\n         if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && (pindex->nChainTx || pindex->pprev == nullptr))\n             setBlockIndexCandidates.insert(pindex);\n         if (pindex->nStatus & BLOCK_FAILED_MASK && (!pindexBestInvalid || pindex->nChainWork > pindexBestInvalid->nChainWork))\n@@ -3882,6 +3939,7 @@ void UnloadBlockIndex()\n     nLastBlockFile = 0;\n     nBlockSequenceId = 1;\n     setDirtyBlockIndex.clear();\n+    g_failed_blocks.clear();\n     setDirtyFileInfo.clear();\n     versionbitscache.Clear();\n     for (int b = 0; b < VERSIONBITS_NUM_BITS; b++) {"
      }
    ]
  },
  {
    "sha": "00dcda60f6ee63d35bec640f27efe2338dd71270",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMGRjZGE2MGY2ZWU2M2QzNWJlYzY0MGYyN2VmZTIzMzhkZDcxMjcw",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-11T20:57:43Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-31T17:51:34Z"
      },
      "message": "[qa] test that invalid blocks on an invalid chain get a disconnect",
      "tree": {
        "sha": "e5c038a4552966133a6e62893935c020eb9760fc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e5c038a4552966133a6e62893935c020eb9760fc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/00dcda60f6ee63d35bec640f27efe2338dd71270",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00dcda60f6ee63d35bec640f27efe2338dd71270",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/00dcda60f6ee63d35bec640f27efe2338dd71270",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00dcda60f6ee63d35bec640f27efe2338dd71270/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "015a5258adffb0cf394f387a95ac9c8afc34cfc3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/015a5258adffb0cf394f387a95ac9c8afc34cfc3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/015a5258adffb0cf394f387a95ac9c8afc34cfc3"
      }
    ],
    "stats": {
      "total": 84,
      "additions": 80,
      "deletions": 4
    },
    "files": [
      {
        "sha": "220b7763694ed54f14b3403722ddacc5a544bad8",
        "filename": "test/functional/p2p-acceptblock.py",
        "status": "modified",
        "additions": 80,
        "deletions": 4,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00dcda60f6ee63d35bec640f27efe2338dd71270/test/functional/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00dcda60f6ee63d35bec640f27efe2338dd71270/test/functional/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-acceptblock.py?ref=00dcda60f6ee63d35bec640f27efe2338dd71270",
        "patch": "@@ -42,16 +42,20 @@\n 7. Send Node0 the missing block again.\n    Node0 should process and the tip should advance.\n \n-8. Test Node1 is able to sync when connected to node0 (which should have sufficient\n-work on its chain).\n+8. Create a fork which is invalid at a height longer than the current chain\n+   (ie to which the node will try to reorg) but which has headers built on top\n+   of the invalid block. Check that we get disconnected if we send more headers\n+   on the chain the node now knows to be invalid.\n \n+9. Test Node1 is able to sync when connected to node0 (which should have sufficient\n+   work on its chain).\n \"\"\"\n \n from test_framework.mininode import *\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n import time\n-from test_framework.blocktools import create_block, create_coinbase\n+from test_framework.blocktools import create_block, create_coinbase, create_transaction\n \n class AcceptBlockTest(BitcoinTestFramework):\n     def add_options(self, parser):\n@@ -240,9 +244,81 @@ def run_test(self):\n \n         test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 290)\n+        self.nodes[0].getblock(all_blocks[286].hash)\n+        assert_equal(self.nodes[0].getbestblockhash(), all_blocks[286].hash)\n+        assert_raises_rpc_error(-1, \"Block not found on disk\", self.nodes[0].getblock, all_blocks[287].hash)\n         self.log.info(\"Successfully reorged to longer chain from non-whitelisted peer\")\n \n-        # 8. Connect node1 to node0 and ensure it is able to sync\n+        # 8. Create a chain which is invalid at a height longer than the\n+        # current chain, but which has more blocks on top of that\n+        block_289f = create_block(all_blocks[284].sha256, create_coinbase(289), all_blocks[284].nTime+1)\n+        block_289f.solve()\n+        block_290f = create_block(block_289f.sha256, create_coinbase(290), block_289f.nTime+1)\n+        block_290f.solve()\n+        block_291 = create_block(block_290f.sha256, create_coinbase(291), block_290f.nTime+1)\n+        # block_291 spends a coinbase below maturity!\n+        block_291.vtx.append(create_transaction(block_290f.vtx[0], 0, b\"42\", 1))\n+        block_291.hashMerkleRoot = block_291.calc_merkle_root()\n+        block_291.solve()\n+        block_292 = create_block(block_291.sha256, create_coinbase(292), block_291.nTime+1)\n+        block_292.solve()\n+\n+        # Now send all the headers on the chain and enough blocks to trigger reorg\n+        headers_message = msg_headers()\n+        headers_message.headers.append(CBlockHeader(block_289f))\n+        headers_message.headers.append(CBlockHeader(block_290f))\n+        headers_message.headers.append(CBlockHeader(block_291))\n+        headers_message.headers.append(CBlockHeader(block_292))\n+        test_node.send_message(headers_message)\n+\n+        test_node.sync_with_ping()\n+        tip_entry_found = False\n+        for x in self.nodes[0].getchaintips():\n+            if x['hash'] == block_292.hash:\n+                assert_equal(x['status'], \"headers-only\")\n+                tip_entry_found = True\n+        assert(tip_entry_found)\n+        assert_raises_rpc_error(-1, \"Block not found on disk\", self.nodes[0].getblock, block_292.hash)\n+\n+        test_node.send_message(msg_block(block_289f))\n+        test_node.send_message(msg_block(block_290f))\n+\n+        test_node.sync_with_ping()\n+        self.nodes[0].getblock(block_289f.hash)\n+        self.nodes[0].getblock(block_290f.hash)\n+\n+        test_node.send_message(msg_block(block_291))\n+\n+        # At this point we've sent an obviously-bogus block, wait for full processing\n+        # without assuming whether we will be disconnected or not\n+        try:\n+            # Only wait a short while so the test doesn't take forever if we do get\n+            # disconnected\n+            test_node.sync_with_ping(timeout=1)\n+        except AssertionError:\n+            test_node.wait_for_disconnect()\n+\n+            test_node = NodeConnCB()   # connects to node (not whitelisted)\n+            connections[0] = NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node)\n+            test_node.add_connection(connections[0])\n+\n+            NetworkThread().start() # Start up network handling in another thread\n+            test_node.wait_for_verack()\n+\n+        # We should have failed reorg and switched back to 290 (but have block 291)\n+        assert_equal(self.nodes[0].getblockcount(), 290)\n+        assert_equal(self.nodes[0].getbestblockhash(), all_blocks[286].hash)\n+        assert_equal(self.nodes[0].getblock(block_291.hash)[\"confirmations\"], -1)\n+\n+        # Now send a new header on the invalid chain, indicating we're forked off, and expect to get disconnected\n+        block_293 = create_block(block_292.sha256, create_coinbase(293), block_292.nTime+1)\n+        block_293.solve()\n+        headers_message = msg_headers()\n+        headers_message.headers.append(CBlockHeader(block_293))\n+        test_node.send_message(headers_message)\n+        test_node.wait_for_disconnect()\n+\n+        # 9. Connect node1 to node0 and ensure it is able to sync\n         connect_nodes(self.nodes[0], 1)\n         sync_blocks([self.nodes[0], self.nodes[1]])\n         self.log.info(\"Successfully synced nodes 1 and 0\")"
      }
    ]
  },
  {
    "sha": "f3d4adfa6ff5db180ec09d93f78cdc8bfda26f96",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmM2Q0YWRmYTZmZjVkYjE4MGVjMDlkOTNmNzhjZGM4YmZkYTI2Zjk2",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-31T01:28:42Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-31T17:51:34Z"
      },
      "message": "Make p2p-acceptablock not an extended test",
      "tree": {
        "sha": "30800ef56af6f130665c90a632629a4056692e13",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/30800ef56af6f130665c90a632629a4056692e13"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f3d4adfa6ff5db180ec09d93f78cdc8bfda26f96",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f3d4adfa6ff5db180ec09d93f78cdc8bfda26f96",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f3d4adfa6ff5db180ec09d93f78cdc8bfda26f96",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f3d4adfa6ff5db180ec09d93f78cdc8bfda26f96/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "00dcda60f6ee63d35bec640f27efe2338dd71270",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00dcda60f6ee63d35bec640f27efe2338dd71270",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/00dcda60f6ee63d35bec640f27efe2338dd71270"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "ca36426a0a2b51e721021858f7bc47b3dc33b094",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3d4adfa6ff5db180ec09d93f78cdc8bfda26f96/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3d4adfa6ff5db180ec09d93f78cdc8bfda26f96/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=f3d4adfa6ff5db180ec09d93f78cdc8bfda26f96",
        "patch": "@@ -125,6 +125,7 @@\n     'minchainwork.py',\n     'p2p-fingerprint.py',\n     'uacomment.py',\n+    'p2p-acceptblock.py',\n ]\n \n EXTENDED_SCRIPTS = [\n@@ -152,7 +153,6 @@\n     'txn_clone.py --mineblock',\n     'notifications.py',\n     'invalidateblock.py',\n-    'p2p-acceptblock.py',\n     'replace-by-fee.py',\n ]\n "
      }
    ]
  }
]