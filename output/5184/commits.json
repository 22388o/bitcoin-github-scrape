[
  {
    "sha": "83a033bf442af80e5e6f32ceadaca9a8cf633e32",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4M2EwMzNiZjQ0MmFmODBlNWU2ZjMyY2VhZGFjYTlhOGNmNjMzZTMy",
    "commit": {
      "author": {
        "name": "Michael Ford",
        "email": "fanquake@gmail.com",
        "date": "2014-10-31T01:04:53Z"
      },
      "committer": {
        "name": "Michael Ford",
        "email": "fanquake@gmail.com",
        "date": "2014-10-31T01:04:53Z"
      },
      "message": "Update coins to be doxygen compatible",
      "tree": {
        "sha": "3bfe126870dc9029954eb25f13d68ed87a6d0bdf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3bfe126870dc9029954eb25f13d68ed87a6d0bdf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/83a033bf442af80e5e6f32ceadaca9a8cf633e32",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/83a033bf442af80e5e6f32ceadaca9a8cf633e32",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/83a033bf442af80e5e6f32ceadaca9a8cf633e32",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/83a033bf442af80e5e6f32ceadaca9a8cf633e32/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8d2396c9c41cbd5b8746f48f41180697f58b0681",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8d2396c9c41cbd5b8746f48f41180697f58b0681",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8d2396c9c41cbd5b8746f48f41180697f58b0681"
      }
    ],
    "stats": {
      "total": 129,
      "additions": 73,
      "deletions": 56
    },
    "files": [
      {
        "sha": "c2e802c95364e573729457db7e9814a621839251",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/83a033bf442af80e5e6f32ceadaca9a8cf633e32/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/83a033bf442af80e5e6f32ceadaca9a8cf633e32/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=83a033bf442af80e5e6f32ceadaca9a8cf633e32",
        "patch": "@@ -1,5 +1,5 @@\n-// Copyright (c) 2012-2013 The Bitcoin developers\n-// Distributed under the MIT/X11 software license, see the accompanying\n+// Copyright (c) 2012-2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"coins.h\"\n@@ -8,9 +8,11 @@\n \n #include <assert.h>\n \n-// calculate number of bytes for the bitmask, and its number of non-zero bytes\n-// each bit in the bitmask represents the availability of one output, but the\n-// availabilities of the first two outputs are encoded separately\n+/**\n+ * calculate number of bytes for the bitmask, and its number of non-zero bytes\n+ * each bit in the bitmask represents the availability of one output, but the\n+ * availabilities of the first two outputs are encoded separately\n+ */\n void CCoins::CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) const {\n     unsigned int nLastUsedByte = 0;\n     for (unsigned int b = 0; 2+b*8 < vout.size(); b++) {\n@@ -133,7 +135,7 @@ const CCoins* CCoinsViewCache::AccessCoins(const uint256 &txid) const {\n bool CCoinsViewCache::HaveCoins(const uint256 &txid) const {\n     CCoinsMap::const_iterator it = FetchCoins(txid);\n     // We're using vtx.empty() instead of IsPruned here for performance reasons,\n-    // as we only care about the case where an transaction was replaced entirely\n+    // as we only care about the case where a transaction was replaced entirely\n     // in a reorganization (which wipes vout entirely, as opposed to spending\n     // which just cleans individual outputs).\n     return (it != cacheCoins.end() && !it->second.coins.vout.empty());"
      },
      {
        "sha": "dbe3f8bd3168e1fab73359d96f675ceef4bd246e",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 65,
        "deletions": 50,
        "changes": 115,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/83a033bf442af80e5e6f32ceadaca9a8cf633e32/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/83a033bf442af80e5e6f32ceadaca9a8cf633e32/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=83a033bf442af80e5e6f32ceadaca9a8cf633e32",
        "patch": "@@ -1,6 +1,6 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2013 The Bitcoin developers\n-// Distributed under the MIT/X11 software license, see the accompanying\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #ifndef BITCOIN_COINS_H\n@@ -17,7 +17,8 @@\n #include <boost/foreach.hpp>\n #include <boost/unordered_map.hpp>\n \n-/** pruned version of CTransaction: only retains metadata and unspent transaction outputs\n+/** \n+ * Pruned version of CTransaction: only retains metadata and unspent transaction outputs\n  *\n  * Serialized format:\n  * - VARINT(nVersion)\n@@ -71,17 +72,17 @@\n class CCoins\n {\n public:\n-    // whether transaction is a coinbase\n+    //! whether transaction is a coinbase\n     bool fCoinBase;\n \n-    // unspent transaction outputs; spent outputs are .IsNull(); spent outputs at the end of the array are dropped\n+    //! unspent transaction outputs; spent outputs are .IsNull(); spent outputs at the end of the array are dropped\n     std::vector<CTxOut> vout;\n \n-    // at which height this transaction was included in the active block chain\n+    //! at which height this transaction was included in the active block chain\n     int nHeight;\n \n-    // version of the CTransaction; accesses to this value should probably check for nHeight as well,\n-    // as new tx version will probably only be introduced at certain heights\n+    //! version of the CTransaction; accesses to this value should probably check for nHeight as well,\n+    //! as new tx version will probably only be introduced at certain heights\n     int nVersion;\n \n     void FromTx(const CTransaction &tx, int nHeightIn) {\n@@ -92,7 +93,7 @@ class CCoins\n         ClearUnspendable();\n     }\n \n-    // construct a CCoins from a CTransaction, at a given height\n+    //! construct a CCoins from a CTransaction, at a given height\n     CCoins(const CTransaction &tx, int nHeightIn) {\n         FromTx(tx, nHeightIn);\n     }\n@@ -104,10 +105,10 @@ class CCoins\n         nVersion = 0;\n     }\n \n-    // empty constructor\n+    //! empty constructor\n     CCoins() : fCoinBase(false), vout(0), nHeight(0), nVersion(0) { }\n \n-    // remove spent outputs at the end of vout\n+    //!remove spent outputs at the end of vout\n     void Cleanup() {\n         while (vout.size() > 0 && vout.back().IsNull())\n             vout.pop_back();\n@@ -130,7 +131,7 @@ class CCoins\n         std::swap(to.nVersion, nVersion);\n     }\n \n-    // equality test\n+    //! equality test\n     friend bool operator==(const CCoins &a, const CCoins &b) {\n          // Empty CCoins objects are always equal.\n          if (a.IsPruned() && b.IsPruned())\n@@ -236,19 +237,19 @@ class CCoins\n         Cleanup();\n     }\n \n-    // mark an outpoint spent, and construct undo information\n+    //! mark an outpoint spent, and construct undo information\n     bool Spend(const COutPoint &out, CTxInUndo &undo);\n \n-    // mark a vout spent\n+    //! mark a vout spent\n     bool Spend(int nPos);\n \n-    // check whether a particular output is still available\n+    //! check whether a particular output is still available\n     bool IsAvailable(unsigned int nPos) const {\n         return (nPos < vout.size() && !vout[nPos].IsNull());\n     }\n \n-    // check whether the entire CCoins is spent\n-    // note that only !IsPruned() CCoins can be serialized\n+    //! check whether the entire CCoins is spent\n+    //! note that only !IsPruned() CCoins can be serialized\n     bool IsPruned() const {\n         BOOST_FOREACH(const CTxOut &out, vout)\n             if (!out.IsNull())\n@@ -264,9 +265,12 @@ class CCoinsKeyHasher\n \n public:\n     CCoinsKeyHasher();\n-    // This *must* return size_t. With Boost 1.46 on 32-bit systems the\n-    // unordered_map will behave unpredictably if the custom hasher returns a\n-    // uint64_t, resulting in failures when syncing the chain (#4634).\n+\n+    /**\n+     * This *must* return size_t. With Boost 1.46 on 32-bit systems the\n+     * unordered_map will behave unpredictably if the custom hasher returns a\n+     * uint64_t, resulting in failures when syncing the chain (#4634).\n+     */\n     size_t operator()(const uint256& key) const {\n         return key.GetHash(salt);\n     }\n@@ -305,24 +309,24 @@ struct CCoinsStats\n class CCoinsView\n {\n public:\n-    // Retrieve the CCoins (unspent transaction outputs) for a given txid\n+    //! Retrieve the CCoins (unspent transaction outputs) for a given txid\n     virtual bool GetCoins(const uint256 &txid, CCoins &coins) const;\n \n-    // Just check whether we have data for a given txid.\n-    // This may (but cannot always) return true for fully spent transactions\n+    //! Just check whether we have data for a given txid.\n+    //! This may (but cannot always) return true for fully spent transactions\n     virtual bool HaveCoins(const uint256 &txid) const;\n \n-    // Retrieve the block hash whose state this CCoinsView currently represents\n+    //! Retrieve the block hash whose state this CCoinsView currently represents\n     virtual uint256 GetBestBlock() const;\n \n-    // Do a bulk modification (multiple CCoins changes + BestBlock change).\n-    // The passed mapCoins can be modified.\n+    //! Do a bulk modification (multiple CCoins changes + BestBlock change).\n+    //! The passed mapCoins can be modified.\n     virtual bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n \n-    // Calculate statistics about the unspent transaction output set\n+    //! Calculate statistics about the unspent transaction output set\n     virtual bool GetStats(CCoinsStats &stats) const;\n \n-    // As we use CCoinsViews polymorphically, have a virtual destructor\n+    //! As we use CCoinsViews polymorphically, have a virtual destructor\n     virtual ~CCoinsView() {}\n };\n \n@@ -346,9 +350,11 @@ class CCoinsViewBacked : public CCoinsView\n \n class CCoinsViewCache;\n \n-/** A reference to a mutable cache entry. Encapsulating it allows us to run\n+/** \n+ * A reference to a mutable cache entry. Encapsulating it allows us to run\n  *  cleanup code after the modification is finished, and keeping track of\n- *  concurrent modifications. */\n+ *  concurrent modifications. \n+ */\n class CCoinsModifier\n {\n private:\n@@ -370,8 +376,10 @@ class CCoinsViewCache : public CCoinsViewBacked\n     /* Whether this cache has an active modifier. */\n     bool hasModifier;\n \n-    /* Make mutable so that we can \"fill the cache\" even from Get-methods\n-       declared as \"const\".  */\n+    /**\n+     * Make mutable so that we can \"fill the cache\" even from Get-methods\n+     * declared as \"const\".  \n+     */\n     mutable uint256 hashBlock;\n     mutable CCoinsMap cacheCoins;\n \n@@ -386,37 +394,44 @@ class CCoinsViewCache : public CCoinsViewBacked\n     void SetBestBlock(const uint256 &hashBlock);\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n \n-    // Return a pointer to CCoins in the cache, or NULL if not found. This is\n-    // more efficient than GetCoins. Modifications to other cache entries are\n-    // allowed while accessing the returned pointer.\n+    /**\n+     * Return a pointer to CCoins in the cache, or NULL if not found. This is\n+     * more efficient than GetCoins. Modifications to other cache entries are\n+     * allowed while accessing the returned pointer.\n+     */\n     const CCoins* AccessCoins(const uint256 &txid) const;\n \n-    // Return a modifiable reference to a CCoins. If no entry with the given\n-    // txid exists, a new one is created. Simultaneous modifications are not\n-    // allowed.\n+    /**\n+     * Return a modifiable reference to a CCoins. If no entry with the given\n+     * txid exists, a new one is created. Simultaneous modifications are not\n+     * allowed.\n+     */\n     CCoinsModifier ModifyCoins(const uint256 &txid);\n \n-    // Push the modifications applied to this cache to its base.\n-    // Failure to call this method before destruction will cause the changes to be forgotten.\n-    // If false is returned, the state of this cache (and its backing view) will be undefined.\n+    /**\n+     * Push the modifications applied to this cache to its base.\n+     * Failure to call this method before destruction will cause the changes to be forgotten.\n+     * If false is returned, the state of this cache (and its backing view) will be undefined.\n+     */\n     bool Flush();\n \n-    // Calculate the size of the cache (in number of transactions)\n+    //! Calculate the size of the cache (in number of transactions)\n     unsigned int GetCacheSize() const;\n \n-    /** Amount of bitcoins coming in to a transaction\n-        Note that lightweight clients may not know anything besides the hash of previous transactions,\n-        so may not be able to calculate this.\n-\n-        @param[in] tx\ttransaction for which we are checking input total\n-        @return\tSum of value of all inputs (scriptSigs)\n+    /** \n+     * Amount of bitcoins coming in to a transaction\n+     * Note that lightweight clients may not know anything besides the hash of previous transactions,\n+     * so may not be able to calculate this.\n+     *\n+     * @param[in] tx\ttransaction for which we are checking input total\n+     * @return\tSum of value of all inputs (scriptSigs)\n      */\n     CAmount GetValueIn(const CTransaction& tx) const;\n \n-    // Check whether all prevouts of the transaction are present in the UTXO set represented by this view\n+    //! Check whether all prevouts of the transaction are present in the UTXO set represented by this view\n     bool HaveInputs(const CTransaction& tx) const;\n \n-    // Return priority of tx at height nHeight\n+    //! Return priority of tx at height nHeight\n     double GetPriority(const CTransaction &tx, int nHeight) const;\n \n     const CTxOut &GetOutputFor(const CTxIn& input) const;"
      }
    ]
  }
]