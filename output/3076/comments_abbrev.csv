laanwj,2013-10-10T20:56:11Z,"phexdigit is used in bignum.h too, this can share the same definition now\n",https://github.com/bitcoin/bitcoin/pull/3076#issuecomment-26091009,26091009,
lano1106,2013-10-11T04:56:54Z,"if you like the idea of this pull request, I'll create a v2 that makes bignum use the same array.\n",https://github.com/bitcoin/bitcoin/pull/3076#issuecomment-26114705,26114705,
laanwj,2013-10-20T12:31:24Z,"Some further comments then IMO this can be merged\n\nuint256.h:\n\n```\ninline signed char HexDigit(unsigned char c)\nextern const signed char p_util_hexdigit[256];\n```\n- this function and data structure declaration should be moved to `util.h`, because `util.c` is where the implementation is. Any reason you did this differently?\n- the argument can be a normal `char` instead of `signed char`, so",https://github.com/bitcoin/bitcoin/pull/3076#issuecomment-26672133,26672133,
lano1106,2013-10-23T15:34:04Z,"Wladimir,\n\nI agree with changing input param type.\n\nHowever, the function cannot be moved in util.h Why? Because this would create a circular dependency.\n\nuint256.h would need to include util.h and util.h already include uint256.h. This is arguable that in that case, the array definition could then be moved into a new cpp file uint256.cpp which do not exists right now. I have decided to not ",https://github.com/bitcoin/bitcoin/pull/3076#issuecomment-26915390,26915390,
laanwj,2013-10-25T07:32:14Z,"I understand... bitcoin has always been rife with circular dependencies and I wouldn't want to reintroduce one.\nCreating two new files is overkill, most of the core devs don't like to have many small header files (though it would be more modular, it would also be harder to remember where things are, and increase the file-to-file switching needed during development).\n\nACK after squashing into on",https://github.com/bitcoin/bitcoin/pull/3076#issuecomment-27070656,27070656,
lano1106,2013-10-28T03:12:18Z,"Wladimir,\n\nthanks for contributing to my git education. It has been my first commit squashing ever :-)\n",https://github.com/bitcoin/bitcoin/pull/3076#issuecomment-27187377,27187377,
BitcoinPullTester,2013-10-28T03:35:34Z,"Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/f171ec0c7d084b6bb163d1466edd814cf4dcbc93 for binaries and test log.\nThis test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/cu",https://github.com/bitcoin/bitcoin/pull/3076#issuecomment-27187848,27187848,
lano1106,2013-10-10T19:22:03Z,"I have a small concern about the return type (signed char) that is right shifted by 4 bits in relation to the sign bit.\nUnit test show that it is ok but I am not sure that this is fully portable.\n\nUnless language does an implicit integer promotion, maybe we could help by changing return type to int16 or just int.\n",https://github.com/bitcoin/bitcoin/pull/3076#discussion_r6897600,6897600,src/uint256.h
laanwj,2013-10-10T20:53:50Z,"Yes, he is returning a _signed_ char from HexDigit, whereas unsigned chars are used in the rest of the logic. I think it's a typo?\n",https://github.com/bitcoin/bitcoin/pull/3076#discussion_r6900464,6900464,src/uint256.h
laanwj,2013-10-10T20:58:28Z,"This must return 0 when p_util_hexdigit[c] < 0, otherwise the functionality is changed.\n(the hexdigit in util.cpp has -1 for non-hex characters whereas hexdigit in uint256.h and bignum.h has zeros)\n",https://github.com/bitcoin/bitcoin/pull/3076#discussion_r6900625,6900625,src/uint256.h
lano1106,2013-10-11T04:50:05Z,"No this is intentional. I have kept the original type from the util.cpp array type. It is signed and -1 as a special value to indicate not an hex char.\n\nLet me rephrase the concern. As soon as the sign bit of an integer is on after doing bit manips, you have a negative number that will turn on more bits to 1 if you store the value into a bigger int type. think about -1.\n\nCan't give a specific ",https://github.com/bitcoin/bitcoin/pull/3076#discussion_r6907871,6907871,src/uint256.h
lano1106,2013-10-11T04:55:33Z,I prefer how it was done in util.cpp as it allows you to discriminate between the char '0' and an invalid hex char.\nNote that I have modified the uint256.h code in consequence when it search for the end of the number.\n,https://github.com/bitcoin/bitcoin/pull/3076#discussion_r6907927,6907927,src/uint256.h
laanwj,2013-10-11T07:01:06Z,"Sure, I agree that is generally more useful, but if you intend on keeping it this way, you need to check for the -1 value at the caller site .\n\nIf you return a special error token can't just bitshift and or it into the target value without checking. If you return 0 you can because it's a no-op/ignore. And as SetHex has no way to return parsing errors the only way is to ignore parsing errors.\n",https://github.com/bitcoin/bitcoin/pull/3076#discussion_r6908893,6908893,src/uint256.h
laanwj,2013-10-11T07:03:11Z,"No, this is far from theoretical. Any invalid hex character will return -1 and thus cause things to go haywire.\nYou need to _either_ check for -1 here or make sure that HexDigit returns 0 in case of an invalid hexchar. See my comment below.\n",https://github.com/bitcoin/bitcoin/pull/3076#discussion_r6908917,6908917,src/uint256.h
Diapolo,2013-10-11T10:24:46Z,"An optimizing compiler could just put this away, right? But I guess the same is true for the loop...\n",https://github.com/bitcoin/bitcoin/pull/3076#discussion_r6911941,6911941,src/uint256.h
laanwj,2013-10-11T11:03:50Z,An optimizing compiler could remove the zeroing but only if it can prove that the rest of the function still does the same without it. It's not an issue here.\n,https://github.com/bitcoin/bitcoin/pull/3076#discussion_r6912533,6912533,src/uint256.h
lano1106,2013-10-11T15:08:21Z,"laanwj,\n\nI absolutle agree with you and it is done exactly as you say it should.\n\nin SetHex():\n1. while loop to find the end of the hex str by checking for first char that returns -1.\n2. Then when the string is processed backward to convert BE -> LE, there is no need to check again for -1 as it is impossible that a char that previously did not return -1 does otherwise in subsequent calls.\n\",https://github.com/bitcoin/bitcoin/pull/3076#discussion_r6917505,6917505,src/uint256.h
lano1106,2013-10-11T15:20:02Z,"Diapolo, you are right. with -O2 the for loop or the memset generates identical code.\n\nIt is then only a matter of taste. The memset has the merit of being more compact.\n\nTell me which way you want the code to be in order to accept the request. I'll do the change\n",https://github.com/bitcoin/bitcoin/pull/3076#discussion_r6917883,6917883,src/uint256.h
laanwj,2013-10-11T17:00:06Z,Agreed. So any parse errors will have been caught on first pass. I hadn't noticed that.\n\nIn that case adding an explicit cast of the result to (unsigned char) should be enough to make sure the shift is correct.\n,https://github.com/bitcoin/bitcoin/pull/3076#discussion_r6920479,6920479,src/uint256.h
