[
  {
    "sha": "2dc0235afe3adadc26eb9f898e923277d6aa7c58",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZGMwMjM1YWZlM2FkYWRjMjZlYjlmODk4ZTkyMzI3N2Q2YWE3YzU4",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-02-11T14:23:04Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-03-08T18:12:52Z"
      },
      "message": "doc/style followups in MempoolAcceptResult",
      "tree": {
        "sha": "b692c509fdd25afc5d30a819c02d8559626fcaeb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b692c509fdd25afc5d30a819c02d8559626fcaeb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2dc0235afe3adadc26eb9f898e923277d6aa7c58",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2dc0235afe3adadc26eb9f898e923277d6aa7c58",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2dc0235afe3adadc26eb9f898e923277d6aa7c58",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2dc0235afe3adadc26eb9f898e923277d6aa7c58/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a22653a636e8dfc1b898ef8dd18a77f2d31082a5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a22653a636e8dfc1b898ef8dd18a77f2d31082a5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a22653a636e8dfc1b898ef8dd18a77f2d31082a5"
      }
    ],
    "stats": {
      "total": 12,
      "additions": 6,
      "deletions": 6
    },
    "files": [
      {
        "sha": "a6f9c6bf871733fb6198fb3c16b2238f3447e6be",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2dc0235afe3adadc26eb9f898e923277d6aa7c58/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2dc0235afe3adadc26eb9f898e923277d6aa7c58/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=2dc0235afe3adadc26eb9f898e923277d6aa7c58",
        "patch": "@@ -196,14 +196,14 @@ struct MempoolAcceptResult {\n         VALID, //!> Fully validated, valid.\n         INVALID, //!> Invalid.\n     };\n-    ResultType m_result_type;\n-    TxValidationState m_state;\n+    const ResultType m_result_type;\n+    const TxValidationState m_state;\n \n     // The following fields are only present when m_result_type = ResultType::VALID\n     /** Mempool transactions replaced by the tx per BIP 125 rules. */\n-    std::optional<std::list<CTransactionRef>> m_replaced_transactions;\n-    /** Raw base fees. */\n-    std::optional<CAmount> m_base_fees;\n+    const std::optional<std::list<CTransactionRef>> m_replaced_transactions;\n+    /** Raw base fees in satoshis. */\n+    const std::optional<CAmount> m_base_fees;\n \n     /** Constructor for failure case */\n     explicit MempoolAcceptResult(TxValidationState state)\n@@ -214,7 +214,7 @@ struct MempoolAcceptResult {\n \n     /** Constructor for success case */\n     explicit MempoolAcceptResult(std::list<CTransactionRef>&& replaced_txns, CAmount fees)\n-        : m_result_type(ResultType::VALID), m_state(TxValidationState{}),\n+        : m_result_type(ResultType::VALID), m_state{},\n         m_replaced_transactions(std::move(replaced_txns)), m_base_fees(fees) {}\n };\n "
      }
    ]
  },
  {
    "sha": "ce6a2566f9af515ccce889c280183c50e1aca505",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjZTZhMjU2NmY5YWY1MTVjY2NlODg5YzI4MDE4M2M1MGUxYWNhNTA1",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-02-11T17:36:20Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-03-08T18:20:38Z"
      },
      "message": "[validation] make CheckSequenceLocks accept coinsview\n\nAllows CheckSequenceLocks to use heights and coins from any CoinsView\nprovided. The typical usage would still be to create a CCoinsViewMemPool\nfrom a pool and pass it in.",
      "tree": {
        "sha": "705d10c158ec86d6e30d19355d952da042b6f040",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/705d10c158ec86d6e30d19355d952da042b6f040"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ce6a2566f9af515ccce889c280183c50e1aca505",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ce6a2566f9af515ccce889c280183c50e1aca505",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ce6a2566f9af515ccce889c280183c50e1aca505",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ce6a2566f9af515ccce889c280183c50e1aca505/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2dc0235afe3adadc26eb9f898e923277d6aa7c58",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2dc0235afe3adadc26eb9f898e923277d6aa7c58",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2dc0235afe3adadc26eb9f898e923277d6aa7c58"
      }
    ],
    "stats": {
      "total": 23,
      "additions": 13,
      "deletions": 10
    },
    "files": [
      {
        "sha": "1495504d8b8c9e76603a16860252e81c2114063a",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce6a2566f9af515ccce889c280183c50e1aca505/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce6a2566f9af515ccce889c280183c50e1aca505/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=ce6a2566f9af515ccce889c280183c50e1aca505",
        "patch": "@@ -28,7 +28,8 @@ struct MinerTestingSetup : public TestingSetup {\n     void TestPackageSelection(const CChainParams& chainparams, const CScript& scriptPubKey, const std::vector<CTransactionRef>& txFirst) EXCLUSIVE_LOCKS_REQUIRED(::cs_main, m_node.mempool->cs);\n     bool TestSequenceLocks(const CTransaction& tx, int flags) EXCLUSIVE_LOCKS_REQUIRED(::cs_main, m_node.mempool->cs)\n     {\n-        return CheckSequenceLocks(::ChainstateActive(), *m_node.mempool, tx, flags);\n+        CCoinsViewMemPool viewMempool(&::ChainstateActive().CoinsTip(), *m_node.mempool);\n+        return CheckSequenceLocks(::ChainstateActive(), viewMempool, tx, flags);\n     }\n     BlockAssembler AssemblerForTest(const CChainParams& params);\n };"
      },
      {
        "sha": "866e9bf4eb349c764d171cfd3f12bbff01a98259",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce6a2566f9af515ccce889c280183c50e1aca505/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce6a2566f9af515ccce889c280183c50e1aca505/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=ce6a2566f9af515ccce889c280183c50e1aca505",
        "patch": "@@ -513,7 +513,9 @@ void CTxMemPool::removeForReorg(CChainState& active_chainstate, int flags)\n         LockPoints lp = it->GetLockPoints();\n         assert(std::addressof(::ChainstateActive()) == std::addressof(active_chainstate));\n         bool validLP =  TestLockPointValidity(active_chainstate.m_chain, &lp);\n-        if (!CheckFinalTx(active_chainstate.m_chain.Tip(), tx, flags) || !CheckSequenceLocks(active_chainstate, *this, tx, flags, &lp, validLP)) {\n+        CCoinsViewMemPool viewMempool(&::ChainstateActive().CoinsTip(), *this);\n+        if (!CheckFinalTx(active_chainstate.m_chain.Tip(), tx, flags)\n+            || !CheckSequenceLocks(active_chainstate, viewMempool, tx, flags, &lp, validLP)) {\n             // Note if CheckSequenceLocks fails the LockPoints may still be invalid\n             // So it's critical that we remove the tx and not depend on the LockPoints.\n             txToRemove.insert(it);"
      },
      {
        "sha": "6a541b017ddf5edb52fcac2301f989b842692f37",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce6a2566f9af515ccce889c280183c50e1aca505/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce6a2566f9af515ccce889c280183c50e1aca505/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=ce6a2566f9af515ccce889c280183c50e1aca505",
        "patch": "@@ -262,14 +262,13 @@ bool TestLockPointValidity(CChain& active_chain, const LockPoints* lp)\n }\n \n bool CheckSequenceLocks(CChainState& active_chainstate,\n-                        const CTxMemPool& pool,\n+                        CCoinsView& viewMemPool,\n                         const CTransaction& tx,\n                         int flags,\n                         LockPoints* lp,\n                         bool useExistingLockPoints)\n {\n     AssertLockHeld(cs_main);\n-    AssertLockHeld(pool.cs);\n     assert(std::addressof(::ChainstateActive()) == std::addressof(active_chainstate));\n \n     CBlockIndex* tip = active_chainstate.m_chain.Tip();\n@@ -293,7 +292,6 @@ bool CheckSequenceLocks(CChainState& active_chainstate,\n     }\n     else {\n         // CoinsTip() contains the UTXO set for active_chainstate.m_chain.Tip()\n-        CCoinsViewMemPool viewMemPool(&active_chainstate.CoinsTip(), pool);\n         std::vector<int> prevheights;\n         prevheights.resize(tx.vin.size());\n         for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n@@ -701,10 +699,10 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     // Only accept BIP68 sequence locked transactions that can be mined in the next\n     // block; we don't want our mempool filled up with transactions that can't\n     // be mined yet.\n-    // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n-    // CoinsViewCache instead of create its own\n+    // Pass in m_view which has all of the relevant inputs cached. Note that, since m_view's\n+    // backend was removed, it no longer pulls coins from the mempool.\n     assert(std::addressof(::ChainstateActive()) == std::addressof(m_active_chainstate));\n-    if (!CheckSequenceLocks(m_active_chainstate, m_pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n+    if (!CheckSequenceLocks(m_active_chainstate, m_view, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n         return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, \"non-BIP68-final\");\n \n     assert(std::addressof(g_chainman.m_blockman) == std::addressof(m_active_chainstate.m_blockman));"
      },
      {
        "sha": "412a2054523bc45d195891213639cc15a2fdc51c",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce6a2566f9af515ccce889c280183c50e1aca505/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce6a2566f9af515ccce889c280183c50e1aca505/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=ce6a2566f9af515ccce889c280183c50e1aca505",
        "patch": "@@ -248,6 +248,8 @@ bool TestLockPointValidity(CChain& active_chain, const LockPoints* lp) EXCLUSIVE\n \n /**\n  * Check if transaction will be BIP 68 final in the next block to be created.\n+ * @param[in]   viewMemPool     A CoinsView that provides access to relevant coins for\n+ *                              checking sequence locks. Any CoinsView can be passed in.\n  *\n  * Simulates calling SequenceLocks() with data from the tip of the current active chain.\n  * Optionally stores in LockPoints the resulting height and time calculated and the hash\n@@ -258,11 +260,11 @@ bool TestLockPointValidity(CChain& active_chain, const LockPoints* lp) EXCLUSIVE\n  * See consensus/consensus.h for flag definitions.\n  */\n bool CheckSequenceLocks(CChainState& active_chainstate,\n-                        const CTxMemPool& pool,\n+                        CCoinsView& viewMemPool,\n                         const CTransaction& tx,\n                         int flags,\n                         LockPoints* lp = nullptr,\n-                        bool useExistingLockPoints = false) EXCLUSIVE_LOCKS_REQUIRED(::cs_main, pool.cs);\n+                        bool useExistingLockPoints = false) EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n \n /**\n  * Closure representing one script verification"
      }
    ]
  },
  {
    "sha": "6bc9e810c7666210407c7e9bfb62f828a3f05eec",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YmM5ZTgxMGM3NjY2MjEwNDA3YzdlOWJmYjYyZjgyOGEzZjA1ZWVj",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-02-11T17:38:51Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-03-08T20:58:13Z"
      },
      "message": "[validation] add CoinsViewTemporary for mempool validation\n\nFunctions in CCoinsViewCache need to be marked virtual so that\nCCoinsViewTemporary can override them.",
      "tree": {
        "sha": "4d2424f2f985154f1ed9ba76e9ceb9db728635b5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4d2424f2f985154f1ed9ba76e9ceb9db728635b5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6bc9e810c7666210407c7e9bfb62f828a3f05eec",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6bc9e810c7666210407c7e9bfb62f828a3f05eec",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6bc9e810c7666210407c7e9bfb62f828a3f05eec",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6bc9e810c7666210407c7e9bfb62f828a3f05eec/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ce6a2566f9af515ccce889c280183c50e1aca505",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ce6a2566f9af515ccce889c280183c50e1aca505",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ce6a2566f9af515ccce889c280183c50e1aca505"
      }
    ],
    "stats": {
      "total": 118,
      "additions": 113,
      "deletions": 5
    },
    "files": [
      {
        "sha": "2b7e2f98212fd683ea6b5d3a0bdce4b791cb7acc",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bc9e810c7666210407c7e9bfb62f828a3f05eec/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bc9e810c7666210407c7e9bfb62f828a3f05eec/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=6bc9e810c7666210407c7e9bfb62f828a3f05eec",
        "patch": "@@ -231,8 +231,8 @@ class CCoinsViewCache : public CCoinsViewBacked\n     CCoinsViewCache(const CCoinsViewCache &) = delete;\n \n     // Standard CCoinsView methods\n-    bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n-    bool HaveCoin(const COutPoint &outpoint) const override;\n+    virtual bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n+    virtual bool HaveCoin(const COutPoint &outpoint) const override;\n     uint256 GetBestBlock() const override;\n     void SetBestBlock(const uint256 &hashBlock);\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n@@ -257,7 +257,7 @@ class CCoinsViewCache : public CCoinsViewBacked\n      * on! To be safe, best to not hold the returned reference through any other\n      * calls to this cache.\n      */\n-    const Coin& AccessCoin(const COutPoint &output) const;\n+    virtual const Coin& AccessCoin(const COutPoint &output) const;\n \n     /**\n      * Add a coin. Set possible_overwrite to true if an unspent version may\n@@ -286,7 +286,7 @@ class CCoinsViewCache : public CCoinsViewBacked\n      * Failure to call this method before destruction will cause the changes to be forgotten.\n      * If false is returned, the state of this cache (and its backing view) will be undefined.\n      */\n-    bool Flush();\n+    virtual bool Flush();\n \n     /**\n      * Removes the UTXO with the given outpoint from the cache, if it is"
      },
      {
        "sha": "4ef793b424af7e2a6de766a8f96d471abf86571f",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 109,
        "deletions": 1,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bc9e810c7666210407c7e9bfb62f828a3f05eec/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bc9e810c7666210407c7e9bfb62f828a3f05eec/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=6bc9e810c7666210407c7e9bfb62f828a3f05eec",
        "patch": "@@ -463,6 +463,114 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, TxValidationS\n     return CheckInputScripts(tx, state, view, flags, /* cacheSigStore = */ true, /* cacheFullSciptStore = */ true, txdata);\n }\n \n+/** An empty coin used as a placeholder for a spent coin.*/\n+static const Coin coin_spent;\n+/**\n+ * A CoinsView that adds a memory cache to another CoinsView and serves as temporary scratch space.\n+ * Used by MemPoolAccept class to validate transactions and packages before submitting to mempool.\n+ * A backend can be set to provide read access to chainstate and/or mempool coins, but writing to\n+ * the backend is disabled. Avoid using a CCoinsViewTemporary in consensus-critical paths such\n+ * as writing to the script cache. See CheckInputsFromMempoolAndCache as an example. When not being\n+ * used to validate a package (m_temp_added and m_temp_spent are empty), a CCoinsViewTemporary\n+ * behaves exactly like a CCoinsViewCache.\n+ */\n+class CCoinsViewTemporary : public CCoinsViewCache\n+{\n+protected:\n+    /**\n+    * Coins made available by transactions being validated. Tracking these allows for package\n+    * validation, since we can access transaction outputs without submitting them to mempool.\n+    */\n+    std::map<COutPoint, Coin> m_temp_added;\n+\n+    /**\n+    * Coins spent by transactions being validated. When there are multiple, we need to track these\n+    * in order to distinguish between missing/spent coins and conflicts within a package.\n+    */\n+    std::set<COutPoint> m_temp_spent;\n+\n+public:\n+\n+    CCoinsViewTemporary(CCoinsView* baseIn) : CCoinsViewCache(baseIn) {}\n+\n+    // Delete the copy constructor to prevent accidentally using it when one intends to create a\n+    // CCoinsViewTemporary on top of a base cache.\n+    CCoinsViewTemporary(const CCoinsViewTemporary &) = delete;\n+\n+    bool GetCoin(const COutPoint& outpoint, Coin& coin) const override {\n+        coin = AccessCoin(outpoint);\n+        return !coin.IsSpent();\n+    }\n+\n+    const Coin& AccessCoin(const COutPoint& outpoint) const override {\n+        // Check to see if another tx in the package has already spent this coin (conflict-in-package).\n+        // Coins spent by others in the package are only tracked in m_temp_spent.\n+        if (m_temp_spent.count(outpoint)) {\n+            return coin_spent;\n+        }\n+\n+        // Check to see if the inputs are made available by another tx in the package.\n+        // These Coins would not be available in the underlying CoinsView.\n+        if (auto it = m_temp_added.find(outpoint); it != m_temp_added.end()) {\n+            assert(!it->second.IsSpent());\n+            return it->second;\n+        }\n+        return CCoinsViewCache::AccessCoin(outpoint);\n+    }\n+\n+    bool HaveCoin(const COutPoint& outpoint) const override {\n+        Coin coin;\n+        return GetCoin(outpoint, coin);\n+    }\n+\n+    /**\n+    * Update with coins spent and created by a transaction.\n+    * Only used for package validation.\n+    */\n+    void PackageAddTransaction(const CTransactionRef& tx)\n+    {\n+        // Track Coins spent by this transaction. They must exist and not already be spent.\n+        for (auto input : tx->vin) {\n+            Coin spent_coin;\n+            Assume(GetCoin(input.prevout, spent_coin) && !spent_coin.IsSpent());\n+            m_temp_spent.insert(input.prevout);\n+        }\n+        // Track Coins added by this transaction.\n+        for (unsigned int n = 0; n < tx->vout.size(); ++n) {\n+            m_temp_added.emplace(COutPoint(tx->GetHash(), n), Coin(tx->vout[n], MEMPOOL_HEIGHT, false));\n+        }\n+    }\n+\n+    /**\n+    * Returns whether an outpoint is spent by a transaction in the package being validated.\n+    * Only used for package validation.\n+    */\n+    bool PackageSpends(const COutPoint& outpoint) const {\n+        return m_temp_spent.count(outpoint);\n+    }\n+\n+    /**\n+    * Clear temporary coins, undoing any changes that were made using AddPackageTransaction.\n+    * Note that any coins brought into cacheCoins from the backend are still there, but this\n+    * effectively resets the state to only coins that were available before validation began.\n+    * Only used for package validation.\n+    */\n+    void ClearTemporaryCoins() {\n+        m_temp_added.clear();\n+        m_temp_spent.clear();\n+    }\n+\n+    // A CCoinsViewTemporary is for temporary scratch space only; it should not write to its backend.\n+    bool Flush() override {\n+        throw std::logic_error(\"CCoinsViewTemporary flushing is not supported.\");\n+    }\n+\n+    bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn) override {\n+        throw std::logic_error(\"CCoinsViewTemporary writing is not supported.\");\n+    }\n+\n+};\n+\n namespace {\n \n class MemPoolAccept\n@@ -555,7 +663,7 @@ class MemPoolAccept\n \n private:\n     CTxMemPool& m_pool;\n-    CCoinsViewCache m_view;\n+    CCoinsViewTemporary m_view;\n     CCoinsViewMemPool m_viewmempool;\n     CCoinsView m_dummy;\n "
      }
    ]
  },
  {
    "sha": "7d0e9415d8346cb61c79faf43aa422d74b58dc15",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZDBlOTQxNWQ4MzQ2Y2I2MWM3OWZhZjQzYWE0MjJkNzRiNThkYzE1",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-02-11T17:50:42Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-03-08T21:00:44Z"
      },
      "message": "[validation] package validation test_accept=true\n\nOnly allow test accepts for now. Use the CCoinsViewTemporary to keep\ntrack of coins created by each transaction so that subsequent\ntransactions can spend them. Uncache all coins since we only\never do test accepts (Note this is different from ATMP which doesn't\nuncache for valid test_accepts) to minimize impact on the coins cache.\n\nRequire that the input txns have no conflicts and be ordered\ntopologically. In the future, we should sanitize and sort the package\nbefore validation.",
      "tree": {
        "sha": "e94334bbb61543811ae22c0cae9ff411b9cf0d31",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e94334bbb61543811ae22c0cae9ff411b9cf0d31"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7d0e9415d8346cb61c79faf43aa422d74b58dc15",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d0e9415d8346cb61c79faf43aa422d74b58dc15",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7d0e9415d8346cb61c79faf43aa422d74b58dc15",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d0e9415d8346cb61c79faf43aa422d74b58dc15/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6bc9e810c7666210407c7e9bfb62f828a3f05eec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6bc9e810c7666210407c7e9bfb62f828a3f05eec",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6bc9e810c7666210407c7e9bfb62f828a3f05eec"
      }
    ],
    "stats": {
      "total": 144,
      "additions": 131,
      "deletions": 13
    },
    "files": [
      {
        "sha": "121181393de20fb73a7740b9b41b38b9bab226ca",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 108,
        "deletions": 6,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d0e9415d8346cb61c79faf43aa422d74b58dc15/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d0e9415d8346cb61c79faf43aa422d74b58dc15/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=7d0e9415d8346cb61c79faf43aa422d74b58dc15",
        "patch": "@@ -604,6 +604,12 @@ class MemPoolAccept\n     // Single transaction acceptance\n     MempoolAcceptResult AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n+    /**\n+    * Multiple transaction acceptance. Transactions must not conflict with each other\n+    * and ordered topologically (parents before children) if any dependencies exist.\n+    */\n+    std::vector<MempoolAcceptResult> AcceptMultipleTransactions(std::vector<CTransactionRef>& txns, ATMPArgs& args) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n private:\n     // All the intermediate state that gets passed between the various levels\n     // of checking a given transaction.\n@@ -767,6 +773,10 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n                 setConflicts.insert(ptxConflicting->GetHash());\n             }\n         }\n+        // Check for conflicts with transactions in the same package.\n+        if (m_view.PackageSpends(txin.prevout)) {\n+            return state.Invalid(TxValidationResult::TX_CONFLICT, \"conflict-in-package\");\n+        }\n     }\n \n     LockPoints lp;\n@@ -1166,28 +1176,93 @@ MempoolAcceptResult MemPoolAccept::AcceptSingleTransaction(const CTransactionRef\n \n     Workspace ws(ptx);\n \n-    if (!PreChecks(args, ws)) return MempoolAcceptResult(ws.m_state);\n+    if (!PreChecks(args, ws)) return MempoolAcceptResult(*ws.m_ptx, ws.m_state);\n \n     // Only compute the precomputed transaction data if we need to verify\n     // scripts (ie, other policy checks pass). We perform the inexpensive\n     // checks first and avoid hashing and signature verification unless those\n     // checks pass, to mitigate CPU exhaustion denial-of-service attacks.\n     PrecomputedTransactionData txdata;\n \n-    if (!PolicyScriptChecks(args, ws, txdata)) return MempoolAcceptResult(ws.m_state);\n+    if (!PolicyScriptChecks(args, ws, txdata)) return MempoolAcceptResult(*ws.m_ptx, ws.m_state);\n \n-    if (!ConsensusScriptChecks(args, ws, txdata)) return MempoolAcceptResult(ws.m_state);\n+    if (!ConsensusScriptChecks(args, ws, txdata)) return MempoolAcceptResult(*ws.m_ptx, ws.m_state);\n \n     // Tx was accepted, but not added\n     if (args.m_test_accept) {\n-        return MempoolAcceptResult(std::move(ws.m_replaced_transactions), ws.m_base_fees);\n+        return MempoolAcceptResult(*ws.m_ptx, std::move(ws.m_replaced_transactions), ws.m_base_fees);\n     }\n \n-    if (!Finalize(args, ws)) return MempoolAcceptResult(ws.m_state);\n+    if (!Finalize(args, ws)) return MempoolAcceptResult(*ws.m_ptx, ws.m_state);\n \n     GetMainSignals().TransactionAddedToMempool(ptx, m_pool.GetAndIncrementSequence());\n \n-    return MempoolAcceptResult(std::move(ws.m_replaced_transactions), ws.m_base_fees);\n+    return MempoolAcceptResult(*ws.m_ptx, std::move(ws.m_replaced_transactions), ws.m_base_fees);\n+}\n+\n+std::vector<MempoolAcceptResult> MemPoolAccept::AcceptMultipleTransactions(std::vector<CTransactionRef>& txns, ATMPArgs& args)\n+{\n+    AssertLockHeld(cs_main);\n+    std::vector<Workspace> workspaces{};\n+    const int package_size = txns.size();\n+    workspaces.reserve(package_size);\n+    std::transform(txns.begin(), txns.end(), std::back_inserter(workspaces), [](CTransactionRef& tx) {\n+        return Workspace(tx);\n+    });\n+    std::vector<MempoolAcceptResult> results;\n+    results.reserve(package_size);\n+\n+    LOCK(m_pool.cs);\n+    // Do all PreChecks first and fail fast to avoid running expensive script checks when unnecessary.\n+    for (Workspace& ws : workspaces) {\n+        if (!PreChecks(args, ws)) {\n+            // Exit early to avoid doing pointless work. Return results in the same order as input txns.\n+            const auto failed_or_unfinished = [&, failed_ptx = ws.m_ptx](Workspace& ws) {\n+                                              return ws.m_ptx == failed_ptx\n+                                              ? MempoolAcceptResult(*ws.m_ptx, ws.m_state, /* finished */ true)\n+                                              : MempoolAcceptResult(*ws.m_ptx, ws.m_state, /* finished */ false);\n+            };\n+            std::transform(workspaces.begin(), workspaces.end(), std::back_inserter(results), failed_or_unfinished);\n+            return results;\n+        }\n+        m_view.PackageAddTransaction(ws.m_ptx);\n+    }\n+\n+    // Now that we have verified all inputs are available and there are no conflicts in the package,\n+    // clear the temporary coins (m_temp_added and m_temp_spent), otherwise script checks will error\n+    // on coins that are spent within the package.\n+    m_view.ClearTemporaryCoins();\n+\n+    for (Workspace& ws : workspaces) {\n+        PrecomputedTransactionData txdata;\n+        if (!PolicyScriptChecks(args, ws, txdata)) {\n+            // Exit early to avoid doing pointless work. Return results in the same order as input txns.\n+            CTransactionRef failed_ptx = ws.m_ptx;\n+            const auto failed_or_unfinished = [&failed_ptx](Workspace& ws) {\n+                                              return ws.m_ptx == failed_ptx\n+                                              ? MempoolAcceptResult(*ws.m_ptx, ws.m_state, /* finished */ true)\n+                                              : MempoolAcceptResult(*ws.m_ptx, ws.m_state, /* finished */ false);\n+            };\n+            auto it_curr = std::find_if(workspaces.begin(), workspaces.end(),\n+                                        [& failed_ptx](Workspace& ws) { return ws.m_ptx == failed_ptx; });\n+            // When test_accept=true, transactions that pass PolicyScriptChecks are valid because there are\n+            // no further mempool checks (passing PolicyScriptChecks implies passing ConsensusScriptChecks).\n+            std::transform(workspaces.begin(), it_curr, std::back_inserter(results), [](Workspace& ws) {\n+                           return MempoolAcceptResult(*ws.m_ptx, std::move(ws.m_replaced_transactions), ws.m_base_fees);\n+            });\n+            std::transform(it_curr, workspaces.end(), std::back_inserter(results), failed_or_unfinished);\n+            return results;\n+        }\n+        // Add the coins back because subsequent transaction(s) in the package may need them for\n+        // script checking.\n+        m_view.PackageAddTransaction(ws.m_ptx);\n+    }\n+\n+    std::transform(workspaces.begin(), workspaces.end(), std::back_inserter(results), [](Workspace& ws) {\n+        // All successful MemPoolAcceptResults\n+        return MempoolAcceptResult(*ws.m_ptx, std::move(ws.m_replaced_transactions), ws.m_base_fees);\n+    });\n+    return results;\n }\n \n } // anon namespace\n@@ -1204,6 +1279,9 @@ static MempoolAcceptResult AcceptToMemoryPoolWithTime(const CChainParams& chainp\n \n     assert(std::addressof(::ChainstateActive()) == std::addressof(active_chainstate));\n     const MempoolAcceptResult result = MemPoolAccept(pool, active_chainstate).AcceptSingleTransaction(tx, args);\n+    assert(result.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+           result.m_result_type == MempoolAcceptResult::ResultType::INVALID);\n+\n     if (result.m_result_type != MempoolAcceptResult::ResultType::VALID) {\n         // Remove coins that were not present in the coins cache before calling ATMPW;\n         // this is to prevent memory DoS in case we receive a large number of\n@@ -1226,6 +1304,30 @@ MempoolAcceptResult AcceptToMemoryPool(CChainState& active_chainstate, CTxMemPoo\n     return AcceptToMemoryPoolWithTime(Params(), pool, active_chainstate, tx, GetTime(), bypass_limits, test_accept);\n }\n \n+std::vector<MempoolAcceptResult> ProcessNewPackage(CChainState& active_chainstate, CTxMemPool& pool,\n+                                                   std::vector<CTransactionRef>& txns, bool test_accept)\n+{\n+    AssertLockHeld(cs_main);\n+    assert(test_accept); // Only allow package accept dry-runs (testmempoolaccept RPC).\n+\n+    std::vector<COutPoint> coins_to_uncache;\n+    const CChainParams& chainparams = Params();\n+    MemPoolAccept::ATMPArgs args { chainparams, GetTime(), false, coins_to_uncache, test_accept };\n+    assert(std::addressof(::ChainstateActive()) == std::addressof(active_chainstate));\n+    const std::vector<MempoolAcceptResult> results = MemPoolAccept(pool, active_chainstate).AcceptMultipleTransactions(txns, args);\n+    Assume(txns.size() == results.size());\n+\n+    // Uncache coins pertaining to transactions that were not submitted to the mempool.\n+    // Ensure the cache is still within its size limits.\n+    for (const COutPoint& hashTx : coins_to_uncache) {\n+            active_chainstate.CoinsTip().Uncache(hashTx);\n+    }\n+    BlockValidationState state_dummy;\n+    ::ChainstateActive().FlushStateToDisk(chainparams, state_dummy, FlushStateMode::PERIODIC);\n+\n+    return results;\n+}\n+\n CTransactionRef GetTransaction(const CBlockIndex* const block_index, const CTxMemPool* const mempool, const uint256& hash, const Consensus::Params& consensusParams, uint256& hashBlock)\n {\n     LOCK(cs_main);"
      },
      {
        "sha": "64f1b247431078c37a5c1517febbefb0d14be2af",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 23,
        "deletions": 7,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d0e9415d8346cb61c79faf43aa422d74b58dc15/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d0e9415d8346cb61c79faf43aa422d74b58dc15/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=7d0e9415d8346cb61c79faf43aa422d74b58dc15",
        "patch": "@@ -189,13 +189,17 @@ void PruneBlockFilesManual(CChainState& active_chainstate, int nManualPruneHeigh\n * Validation result for a single transaction mempool acceptance.\n */\n struct MempoolAcceptResult {\n-    /** Used to indicate the results of mempool validation,\n-    * including the possibility of unfinished validation.\n+    /** Used to indicate the results of mempool validation.\n+    * It's possible for a result to be unknown in the case of\n+    * package validation when an earlier tx fails and validation\n+    * is terminated early. See ResultType::UNFINISHED.\n     */\n     enum class ResultType {\n         VALID, //!> Fully validated, valid.\n         INVALID, //!> Invalid.\n+        UNFINISHED, //!> Not fully validated.\n     };\n+    const CTransaction& m_tx;\n     const ResultType m_result_type;\n     const TxValidationState m_state;\n \n@@ -206,15 +210,15 @@ struct MempoolAcceptResult {\n     const std::optional<CAmount> m_base_fees;\n \n     /** Constructor for failure case */\n-    explicit MempoolAcceptResult(TxValidationState state)\n-        : m_result_type(ResultType::INVALID),\n+    explicit MempoolAcceptResult(const CTransaction& tx, TxValidationState state, bool finished=true)\n+        : m_tx(tx), m_result_type(finished ? ResultType::INVALID : ResultType::UNFINISHED),\n         m_state(state), m_replaced_transactions(nullopt), m_base_fees(nullopt) {\n-            Assume(!state.IsValid()); // Can be invalid or error\n+            if (finished) Assume(!state.IsValid()); // Can be invalid or error\n         }\n \n     /** Constructor for success case */\n-    explicit MempoolAcceptResult(std::list<CTransactionRef>&& replaced_txns, CAmount fees)\n-        : m_result_type(ResultType::VALID), m_state{},\n+    explicit MempoolAcceptResult(const CTransaction& tx, std::list<CTransactionRef>&& replaced_txns, CAmount fees)\n+        : m_tx(tx), m_result_type(ResultType::VALID), m_state{},\n         m_replaced_transactions(std::move(replaced_txns)), m_base_fees(fees) {}\n };\n \n@@ -226,6 +230,18 @@ struct MempoolAcceptResult {\n MempoolAcceptResult AcceptToMemoryPool(CChainState& active_chainstate, CTxMemPool& pool, const CTransactionRef& tx,\n                                        bool bypass_limits, bool test_accept=false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n+/**\n+* Atomically test acceptance of multiple transactions.\n+* @param[in]    txns                Group of transactions which may be independent or contain\n+*                                   parent-child dependencies. The transactions must not conflict, i.e.\n+*                                   must not spend the same inputs, even if it would be a valid BIP125\n+*                                   replace-by-fee. Parents must appear before children.\n+* @returns a vector of MempoolAcceptResults for each tx in the same order as\n+* the input txns. If one transaction fails, some results may be unfinished.\n+*/\n+std::vector<MempoolAcceptResult> ProcessNewPackage(CChainState& active_chainstate, CTxMemPool& pool,\n+                                                   std::vector<CTransactionRef>& txns, bool test_accept)\n+                                                   EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n /** Apply the effects of this transaction on the UTXO set represented by view */\n void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, int nHeight);"
      }
    ]
  },
  {
    "sha": "1b90ac977f74ee5307479aec140a6184cd3abb89",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYjkwYWM5NzdmNzRlZTUzMDc0NzlhZWMxNDBhNjE4NGNkM2FiYjg5",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-02-11T18:50:45Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-03-08T21:00:44Z"
      },
      "message": "[rpc] allow multiple txns in testmempoolaccept\n\nOnly allow \"packages\" with no conflicts, sorted in order of dependency,\nand no more than -limitdescendantcount for now.\n\nNote that these groups of transactions don't necessarily need to be\nexactly 1 package or have any dependency relationships.\n\nit may help to use -w to view the diff",
      "tree": {
        "sha": "b7cfdca5ce320b13f56c9c671cad9879c83377be",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b7cfdca5ce320b13f56c9c671cad9879c83377be"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1b90ac977f74ee5307479aec140a6184cd3abb89",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1b90ac977f74ee5307479aec140a6184cd3abb89",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1b90ac977f74ee5307479aec140a6184cd3abb89",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1b90ac977f74ee5307479aec140a6184cd3abb89/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7d0e9415d8346cb61c79faf43aa422d74b58dc15",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d0e9415d8346cb61c79faf43aa422d74b58dc15",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7d0e9415d8346cb61c79faf43aa422d74b58dc15"
      }
    ],
    "stats": {
      "total": 98,
      "additions": 56,
      "deletions": 42
    },
    "files": [
      {
        "sha": "426d72c02b9d00a6f0f99863f757024a1f3a3743",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 41,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b90ac977f74ee5307479aec140a6184cd3abb89/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b90ac977f74ee5307479aec140a6184cd3abb89/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=1b90ac977f74ee5307479aec140a6184cd3abb89",
        "patch": "@@ -876,7 +876,9 @@ static RPCHelpMan sendrawtransaction()\n static RPCHelpMan testmempoolaccept()\n {\n     return RPCHelpMan{\"testmempoolaccept\",\n-                \"\\nReturns result of mempool acceptance tests indicating if raw transaction (serialized, hex-encoded) would be accepted by mempool.\\n\"\n+                \"\\nReturns result of mempool acceptance tests indicating if raw transaction(s) (serialized, hex-encoded) would be accepted by mempool.\\n\"\n+                \"\\nIf multiple transactions are passed in, they must be sorted in order of dependency and not conflict with each other.\\n\"\n+                \"\\nThe maximum number of transactions allowed is determined by the mempool descendant policy (-limitdescendantcount).\\n\"\n                 \"\\nThis checks if the transaction violates the consensus or policy rules.\\n\"\n                 \"\\nSee sendrawtransaction call.\\n\",\n                 {\n@@ -890,13 +892,15 @@ static RPCHelpMan testmempoolaccept()\n                 },\n                 RPCResult{\n                     RPCResult::Type::ARR, \"\", \"The result of the mempool acceptance test for each raw transaction in the input array.\\n\"\n-                        \"Length is exactly one for now.\",\n+                        \"Returns results for each transaction in the same order they were passed in.\\n\"\n+                        \"It is possible for transactions to not be fully validated ('allowed' unset) if an earlier transaction failed.\\n\",\n                     {\n                         {RPCResult::Type::OBJ, \"\", \"\",\n                         {\n                             {RPCResult::Type::STR_HEX, \"txid\", \"The transaction hash in hex\"},\n                             {RPCResult::Type::STR_HEX, \"wtxid\", \"The transaction witness hash in hex\"},\n-                            {RPCResult::Type::BOOL, \"allowed\", \"If the mempool allows this tx to be inserted\"},\n+                            {RPCResult::Type::BOOL, \"allowed\", \"Whether this tx would be accepted to the mempool and passes client-specified maxfeerate.\\n\"\n+                                                               \"If not present, the tx was not fully validated due to a failure in another tx in the list.\"},\n                             {RPCResult::Type::NUM, \"vsize\", \"Virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted (only present when 'allowed' is true)\"},\n                             {RPCResult::Type::OBJ, \"fees\", \"Transaction fees (only present if 'allowed' is true)\",\n                             {\n@@ -923,59 +927,69 @@ static RPCHelpMan testmempoolaccept()\n         UniValueType(), // VNUM or VSTR, checked inside AmountFromValue()\n     });\n \n-    if (request.params[0].get_array().size() != 1) {\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Array must contain exactly one raw transaction for now\");\n+    // A package would not be accepted to the mempool if it had more transactions than the descendant count limit.\n+    const unsigned int max_transactions = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+    if (request.params[0].get_array().size() > max_transactions) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Array cannot contain more than \" + ToString(max_transactions) + \" transactions.\");\n     }\n \n-    CMutableTransaction mtx;\n-    if (!DecodeHexTx(mtx, request.params[0].get_array()[0].get_str())) {\n-        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed. Make sure the tx has at least one input.\");\n-    }\n-    CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n-\n+    const UniValue raw_transactions = request.params[0].get_array();\n     const CFeeRate max_raw_tx_fee_rate = request.params[1].isNull() ?\n                                              DEFAULT_MAX_RAW_TX_FEE_RATE :\n                                              CFeeRate(AmountFromValue(request.params[1]));\n \n     CTxMemPool& mempool = EnsureMemPool(request.context);\n-    int64_t virtual_size = GetVirtualTransactionSize(*tx);\n-    CAmount max_raw_tx_fee = max_raw_tx_fee_rate.GetFee(virtual_size);\n+    std::vector<CTransactionRef> txns;\n+\n+    for (unsigned int i = 0; i < raw_transactions.size(); ++i) {\n+        CMutableTransaction mtx;\n+        if (!DecodeHexTx(mtx, raw_transactions[i].get_str())) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed. Make sure the tx has at least one input.\");\n+        }\n+        txns.emplace_back(MakeTransactionRef(std::move(mtx)));\n+    }\n \n-    UniValue result(UniValue::VARR);\n-    UniValue result_0(UniValue::VOBJ);\n-    result_0.pushKV(\"txid\", tx->GetHash().GetHex());\n-    result_0.pushKV(\"wtxid\", tx->GetWitnessHash().GetHex());\n+    std::vector<MempoolAcceptResult> validation_results =\n+        WITH_LOCK(cs_main, return ProcessNewPackage(::ChainstateActive(), mempool, txns, /* test_accept */ true));\n \n-    const MempoolAcceptResult accept_result = WITH_LOCK(cs_main, return AcceptToMemoryPool(::ChainstateActive(), mempool, std::move(tx),\n-                                                  false /* bypass_limits */, /* test_accept */ true));\n+    UniValue rpc_result(UniValue::VARR);\n \n     // Only return the fee and vsize if the transaction would pass ATMP.\n     // These can be used to calculate the feerate.\n-    if (accept_result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n-        const CAmount fee = accept_result.m_base_fees.value();\n-        // Check that fee does not exceed maximum fee\n-        if (max_raw_tx_fee && fee > max_raw_tx_fee) {\n-            result_0.pushKV(\"allowed\", false);\n-            result_0.pushKV(\"reject-reason\", \"max-fee-exceeded\");\n-        } else {\n-            result_0.pushKV(\"allowed\", true);\n-            result_0.pushKV(\"vsize\", virtual_size);\n-            UniValue fees(UniValue::VOBJ);\n-            fees.pushKV(\"base\", ValueFromAmount(fee));\n-            result_0.pushKV(\"fees\", fees);\n-        }\n-        result.push_back(std::move(result_0));\n-    } else {\n-        result_0.pushKV(\"allowed\", false);\n-        const TxValidationState state = accept_result.m_state;\n-        if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n-            result_0.pushKV(\"reject-reason\", \"missing-inputs\");\n+    for (const MempoolAcceptResult& accept_result : validation_results) {\n+        UniValue result_inner(UniValue::VOBJ);\n+        const CTransaction tx = accept_result.m_tx;\n+        result_inner.pushKV(\"txid\", tx.GetHash().GetHex());\n+        result_inner.pushKV(\"wtxid\", tx.GetWitnessHash().GetHex());\n+        if (accept_result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n+            const CAmount fee = accept_result.m_base_fees.value();\n+            // Check that fee does not exceed maximum fee\n+            const int64_t virtual_size = GetVirtualTransactionSize(tx);\n+            const CAmount max_raw_tx_fee = max_raw_tx_fee_rate.GetFee(virtual_size);\n+            if (max_raw_tx_fee && fee > max_raw_tx_fee) {\n+                result_inner.pushKV(\"allowed\", false);\n+                result_inner.pushKV(\"reject-reason\", \"max-fee-exceeded\");\n+            } else {\n+                result_inner.pushKV(\"allowed\", true);\n+                result_inner.pushKV(\"vsize\", virtual_size);\n+                UniValue fees(UniValue::VOBJ);\n+                fees.pushKV(\"base\", ValueFromAmount(fee));\n+                result_inner.pushKV(\"fees\", fees);\n+            }\n+        } else if (accept_result.m_result_type == MempoolAcceptResult::ResultType::INVALID) {\n+            result_inner.pushKV(\"allowed\", false);\n+            const TxValidationState state = accept_result.m_state;\n+            if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+                result_inner.pushKV(\"reject-reason\", \"missing-inputs\");\n+            } else {\n+                result_inner.pushKV(\"reject-reason\", state.GetRejectReason());\n+            }\n         } else {\n-            result_0.pushKV(\"reject-reason\", state.GetRejectReason());\n+            CHECK_NONFATAL(accept_result.m_result_type == MempoolAcceptResult::ResultType::UNFINISHED);\n         }\n-        result.push_back(std::move(result_0));\n+        rpc_result.push_back(result_inner);\n     }\n-    return result;\n+    return rpc_result;\n },\n     };\n }"
      },
      {
        "sha": "cb8e34b2dddf807e5f8e015a87a96abb9f6e4942",
        "filename": "test/functional/mempool_accept.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b90ac977f74ee5307479aec140a6184cd3abb89/test/functional/mempool_accept.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b90ac977f74ee5307479aec140a6184cd3abb89/test/functional/mempool_accept.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_accept.py?ref=1b90ac977f74ee5307479aec140a6184cd3abb89",
        "patch": "@@ -67,7 +67,7 @@ def run_test(self):\n \n         self.log.info('Should not accept garbage to testmempoolaccept')\n         assert_raises_rpc_error(-3, 'Expected type array, got string', lambda: node.testmempoolaccept(rawtxs='ff00baar'))\n-        assert_raises_rpc_error(-8, 'Array must contain exactly one raw transaction for now', lambda: node.testmempoolaccept(rawtxs=['ff00baar', 'ff22']))\n+        assert_raises_rpc_error(-8, 'Array cannot contain more than 25 transactions.', lambda: node.testmempoolaccept(rawtxs=['ff22']*26))\n         assert_raises_rpc_error(-22, 'TX decode failed', lambda: node.testmempoolaccept(rawtxs=['ff00baar']))\n \n         self.log.info('A transaction already in the blockchain')"
      }
    ]
  },
  {
    "sha": "06f8fce092edf62f5bbabc5de41b2b499046b965",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNmY4ZmNlMDkyZWRmNjJmNWJiYWJjNWRlNDFiMmI0OTkwNDZiOTY1",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-02-23T03:32:58Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-03-08T21:00:44Z"
      },
      "message": "[test] functional test for packages in RPCs",
      "tree": {
        "sha": "04064ef8cfe8f9882097b3c2e69512b2616f0dd6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/04064ef8cfe8f9882097b3c2e69512b2616f0dd6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/06f8fce092edf62f5bbabc5de41b2b499046b965",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/06f8fce092edf62f5bbabc5de41b2b499046b965",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/06f8fce092edf62f5bbabc5de41b2b499046b965",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/06f8fce092edf62f5bbabc5de41b2b499046b965/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1b90ac977f74ee5307479aec140a6184cd3abb89",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1b90ac977f74ee5307479aec140a6184cd3abb89",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1b90ac977f74ee5307479aec140a6184cd3abb89"
      }
    ],
    "stats": {
      "total": 335,
      "additions": 335,
      "deletions": 0
    },
    "files": [
      {
        "sha": "a2e398e5a384253f90b809786810e1a4adc7808a",
        "filename": "test/functional/rpc_packages.py",
        "status": "added",
        "additions": 334,
        "deletions": 0,
        "changes": 334,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/06f8fce092edf62f5bbabc5de41b2b499046b965/test/functional/rpc_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/06f8fce092edf62f5bbabc5de41b2b499046b965/test/functional/rpc_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_packages.py?ref=06f8fce092edf62f5bbabc5de41b2b499046b965",
        "patch": "@@ -0,0 +1,334 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2021 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"RPCs that handle raw transaction packages.\"\"\"\n+\n+from decimal import Decimal\n+from io import BytesIO\n+\n+from test_framework.address import ADDRESS_BCRT1_P2WSH_OP_TRUE\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.messages import (\n+    BIP125_SEQUENCE_NUMBER,\n+    COIN,\n+    CTransaction,\n+    CTxInWitness,\n+)\n+from test_framework.script import (\n+    CScript,\n+    OP_TRUE,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+    hex_str_to_bytes,\n+)\n+\n+class RPCPackagesTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def run_test(self):\n+        self.log.info(\"Generate blocks to create UTXOs\")\n+        node = self.nodes[0]\n+        self.privkeys = [node.get_deterministic_priv_key().key]\n+        self.address = node.get_deterministic_priv_key().address\n+        self.coins = []\n+        # The last 100 coinbase transactions are premature\n+        for b in node.generatetoaddress(120, self.address)[:20]:\n+            coinbase = node.getblock(blockhash=b, verbosity=2)[\"tx\"][0]\n+            self.coins.append({\n+                \"txid\": coinbase[\"txid\"],\n+                \"amount\": coinbase[\"vout\"][0][\"value\"],\n+                \"scriptPubKey\": coinbase[\"vout\"][0][\"scriptPubKey\"],\n+            })\n+\n+        # Create some transactions that can be reused throughout the test. Never submit these to mempool.\n+        self.independent_txns_hex = []\n+        self.independent_txns_testres = []\n+        for _ in range(3):\n+            coin = self.coins.pop()\n+            rawtx = node.createrawtransaction([{\"txid\" : coin[\"txid\"], \"vout\" : 0}],\n+                {self.address : coin[\"amount\"] - Decimal(\"0.0001\")})\n+            signedtx = node.signrawtransactionwithkey(hexstring=rawtx, privkeys=self.privkeys)\n+            assert signedtx[\"complete\"]\n+            testres = node.testmempoolaccept([signedtx[\"hex\"]])\n+            assert testres[0][\"allowed\"]\n+            self.independent_txns_hex.append(signedtx[\"hex\"])\n+            # testmempoolaccept returns a list of length one, avoid creating a 2D list\n+            self.independent_txns_testres.append(testres[0])\n+\n+        self.test_independent()\n+        self.test_chain()\n+        self.test_multiple_children()\n+        self.test_multiple_parents()\n+        self.test_conflicting()\n+        self.test_rbf()\n+\n+    def chain_transaction(self, parent_txid, value, n=0, parent_locking_script=None):\n+        \"\"\"Build a transaction that spends parent_txid.vout[n] and produces one output with amount=value.\n+        Return tuple (CTransaction object, raw hex, scriptPubKey of the output created).\n+        \"\"\"\n+        node = self.nodes[0]\n+        inputs = [{\"txid\" : parent_txid, \"vout\" : n}]\n+        outputs = {self.address : value}\n+        rawtx = node.createrawtransaction(inputs, outputs)\n+        prevtxs = [{\n+            \"txid\": parent_txid,\n+            \"vout\": n,\n+            \"scriptPubKey\": parent_locking_script,\n+            \"amount\": value + Decimal(\"0.0001\"),\n+        }] if parent_locking_script else None\n+        signedtx = node.signrawtransactionwithkey(hexstring=rawtx, privkeys=self.privkeys, prevtxs=prevtxs)\n+        tx = CTransaction()\n+        assert signedtx[\"complete\"]\n+        tx.deserialize(BytesIO(hex_str_to_bytes(signedtx[\"hex\"])))\n+        return (tx, signedtx[\"hex\"], tx.vout[0].scriptPubKey.hex())\n+\n+    def test_independent(self):\n+        self.log.info(\"Test multiple independent transactions in a package\")\n+        node = self.nodes[0]\n+        assert_equal(self.independent_txns_testres, node.testmempoolaccept(rawtxs=self.independent_txns_hex))\n+\n+        self.log.info(\"Test a valid package with garbage inserted\")\n+        garbage_tx = node.createrawtransaction([{\"txid\": \"00\" * 32, \"vout\": 5}], {self.address: 1})\n+        tx = CTransaction()\n+        tx.deserialize(BytesIO(hex_str_to_bytes(garbage_tx)))\n+        testres_bad = node.testmempoolaccept(self.independent_txns_hex + [garbage_tx])\n+        testres_independent_ids = [{\"txid\": res[\"txid\"], \"wtxid\": res[\"wtxid\"]} for res in self.independent_txns_testres]\n+        assert_equal(testres_bad, testres_independent_ids + [\n+            {\"txid\": tx.rehash(), \"wtxid\": tx.getwtxid(), \"allowed\": False, \"reject-reason\": \"missing-inputs\"}\n+        ])\n+\n+        self.log.info(\"Check testmempoolaccept tells us when some transactions completed validation successfully\")\n+        coin = self.coins.pop()\n+        tx_bad_sig_hex = node.createrawtransaction([{\"txid\" : coin[\"txid\"], \"vout\" : 0}],\n+                                           {self.address : coin[\"amount\"] - Decimal(\"0.0001\")})\n+        tx_bad_sig = CTransaction()\n+        tx_bad_sig.deserialize(BytesIO(hex_str_to_bytes(tx_bad_sig_hex)))\n+        testres_bad_sig = node.testmempoolaccept(self.independent_txns_hex + [tx_bad_sig_hex])\n+        assert_equal(testres_bad_sig, self.independent_txns_testres + [{\n+            \"txid\": tx_bad_sig.rehash(),\n+            \"wtxid\": tx_bad_sig.getwtxid(), \"allowed\": False,\n+            \"reject-reason\": \"mandatory-script-verify-flag-failed (Operation not valid with the current stack size)\"\n+        }])\n+\n+        self.log.info(\"Check testmempoolaccept reports txns in packages that exceed max feerate\")\n+        coin = self.coins.pop()\n+        tx_high_fee_raw = node.createrawtransaction([{\"txid\" : coin[\"txid\"], \"vout\" : 0}],\n+                                           {self.address : coin[\"amount\"] - Decimal(\"0.999\")})\n+        tx_high_fee_signed = node.signrawtransactionwithkey(hexstring=tx_high_fee_raw, privkeys=self.privkeys)\n+        assert tx_high_fee_signed[\"complete\"]\n+        tx_high_fee = CTransaction()\n+        tx_high_fee.deserialize(BytesIO(hex_str_to_bytes(tx_high_fee_signed[\"hex\"])))\n+        testres_high_fee = node.testmempoolaccept([tx_high_fee_signed[\"hex\"]])\n+        assert_equal(testres_high_fee, [\n+            {\"txid\": tx_high_fee.rehash(), \"wtxid\": tx_high_fee.getwtxid(), \"allowed\": False, \"reject-reason\": \"max-fee-exceeded\"}\n+        ])\n+        testres_package_high_fee = node.testmempoolaccept(self.independent_txns_hex + [tx_high_fee_signed[\"hex\"]])\n+        assert_equal(testres_package_high_fee, self.independent_txns_testres + testres_high_fee)\n+\n+    def test_chain(self):\n+        node = self.nodes[0]\n+        first_coin = self.coins.pop()\n+\n+        self.log.info(\"Create a chain of 25 transactions\")\n+        parent_locking_script = None\n+        txid = first_coin[\"txid\"]\n+        chain_hex = []\n+        chain_txns = []\n+        value = first_coin[\"amount\"]\n+\n+        for _ in range(25):\n+            value -= Decimal(\"0.0001\") # Deduct reasonable fee\n+            (tx, txhex, parent_locking_script) = self.chain_transaction(txid, value, 0, parent_locking_script)\n+            txid = tx.rehash()\n+            chain_hex.append(txhex)\n+            chain_txns.append(tx)\n+\n+        self.log.info(\"Check that testmempoolaccept requires packages to be sorted by dependency\")\n+        testres_multiple_unsorted = node.testmempoolaccept(rawtxs=chain_hex[::-1])\n+        assert_equal(testres_multiple_unsorted, [{\"txid\": chain_txns[-1].rehash(), \"wtxid\": chain_txns[-1].getwtxid(), \"allowed\": False, \"reject-reason\": \"missing-inputs\"}]\n+                                              + [{\"txid\": tx.rehash(), \"wtxid\": tx.getwtxid()} for tx in chain_txns[::-1]][1:])\n+\n+        self.log.info(\"Testmempoolaccept with entire package\")\n+        testres_multiple = node.testmempoolaccept(rawtxs=chain_hex)\n+\n+        testres_single = []\n+        self.log.info(\"Test accept and then submit each one individually, which should be identical to package testaccept\")\n+        for rawtx in chain_hex:\n+            testres = node.testmempoolaccept([rawtx])\n+            testres_single.append(testres[0])\n+            # Submit the transaction now so its child should have no problem validating\n+            node.sendrawtransaction(rawtx)\n+        assert_equal(testres_single, testres_multiple)\n+\n+        # Clean up by clearing the mempool\n+        node.generate(1)\n+\n+    def test_multiple_children(self):\n+        node = self.nodes[0]\n+\n+        self.log.info(\"Create a package in which a transaction has two children within the package\")\n+        first_coin = self.coins.pop()\n+        value = (first_coin[\"amount\"] - Decimal(\"0.0002\")) / 2 # Deduct reasonable fee and make 2 outputs\n+        inputs = [{\"txid\" : first_coin[\"txid\"], \"vout\" : 0}]\n+        outputs = [{self.address : value}, {ADDRESS_BCRT1_P2WSH_OP_TRUE : value}]\n+        rawtx = node.createrawtransaction(inputs, outputs)\n+\n+        parent_signed = node.signrawtransactionwithkey(hexstring=rawtx, privkeys=self.privkeys)\n+        parent_tx = CTransaction()\n+        assert parent_signed[\"complete\"]\n+        parent_tx.deserialize(BytesIO(hex_str_to_bytes(parent_signed[\"hex\"])))\n+        parent_txid = parent_tx.rehash()\n+        assert node.testmempoolaccept([parent_signed[\"hex\"]])[0][\"allowed\"]\n+\n+        parent_locking_script_a = parent_tx.vout[0].scriptPubKey.hex()\n+        child_value = value - Decimal(\"0.0001\")\n+\n+        # Child A\n+        (_, tx_child_a_hex, _) = self.chain_transaction(parent_txid, child_value, 0, parent_locking_script_a)\n+        assert not node.testmempoolaccept([tx_child_a_hex])[0][\"allowed\"]\n+\n+        # Child B\n+        rawtx_b = node.createrawtransaction([{\"txid\" : parent_txid, \"vout\" : 1}], {self.address : child_value})\n+        tx_child_b = CTransaction()\n+        tx_child_b.deserialize(BytesIO(hex_str_to_bytes(rawtx_b)))\n+        tx_child_b.wit.vtxinwit = [CTxInWitness()]\n+        tx_child_b.wit.vtxinwit[0].scriptWitness.stack = [CScript([OP_TRUE])]\n+        tx_child_b_hex = tx_child_b.serialize().hex()\n+        assert not node.testmempoolaccept([tx_child_b_hex])[0][\"allowed\"]\n+\n+        self.log.info(\"Testmempoolaccept with entire package, should work with children in either order\")\n+        testres_multiple_ab = node.testmempoolaccept(rawtxs=[parent_signed[\"hex\"], tx_child_a_hex, tx_child_b_hex])\n+        testres_multiple_ba = node.testmempoolaccept(rawtxs=[parent_signed[\"hex\"], tx_child_b_hex, tx_child_a_hex])\n+        assert all([testres[\"allowed\"] for testres in testres_multiple_ab + testres_multiple_ba])\n+\n+        testres_single = []\n+        self.log.info(\"Test accept and then submit each one individually, which should be identical to package testaccept\")\n+        for rawtx in [parent_signed[\"hex\"], tx_child_a_hex, tx_child_b_hex]:\n+            testres = node.testmempoolaccept([rawtx])\n+            testres_single.append(testres[0])\n+            # Submit the transaction now so its child should have no problem validating\n+            node.sendrawtransaction(rawtx)\n+        assert_equal(testres_single, testres_multiple_ab)\n+\n+    def test_multiple_parents(self):\n+        node = self.nodes[0]\n+\n+        self.log.info(\"Create a package in which a transaction has two parents within the package\")\n+        # Parent A\n+        parent_a_coin = self.coins.pop()\n+        parent_a_value = parent_a_coin[\"amount\"] - Decimal(\"0.0001\")\n+        (tx_parent_a, hex_parent_a, parent_locking_script_a) = self.chain_transaction(parent_a_coin[\"txid\"], parent_a_value)\n+\n+        # Parent B\n+        parent_b_coin = self.coins.pop()\n+        parent_b_value = parent_b_coin[\"amount\"] - Decimal(\"0.0001\")\n+        (tx_parent_b, hex_parent_b, parent_locking_script_b) = self.chain_transaction(parent_b_coin[\"txid\"], parent_b_value)\n+\n+        # Child\n+        inputs = [{\"txid\" : tx_parent_a.rehash(), \"vout\" : 0}, {\"txid\" : tx_parent_b.rehash(), \"vout\" : 0}]\n+        outputs = {self.address : parent_a_value + parent_b_value - Decimal(\"0.0001\")}\n+        rawtx_child = node.createrawtransaction(inputs, outputs)\n+        prevtxs = [{\"txid\": tx_parent_a.rehash(), \"vout\": 0, \"scriptPubKey\": parent_locking_script_a, \"amount\": parent_a_value},\n+                   {\"txid\": tx_parent_b.rehash(), \"vout\": 0, \"scriptPubKey\": parent_locking_script_b, \"amount\": parent_b_value}]\n+        signedtx_child = node.signrawtransactionwithkey(hexstring=rawtx_child, privkeys=self.privkeys, prevtxs=prevtxs)\n+        assert signedtx_child[\"complete\"]\n+        assert not node.testmempoolaccept([signedtx_child[\"hex\"]])[0][\"allowed\"]\n+\n+        self.log.info(\"Testmempoolaccept with entire package, should work with parents in either order\")\n+        testres_multiple_ab = node.testmempoolaccept(rawtxs=[hex_parent_a, hex_parent_b, signedtx_child[\"hex\"]])\n+        testres_multiple_ba = node.testmempoolaccept(rawtxs=[hex_parent_b, hex_parent_a, signedtx_child[\"hex\"]])\n+        assert all([testres[\"allowed\"] for testres in testres_multiple_ab + testres_multiple_ba])\n+\n+        testres_single = []\n+        self.log.info(\"Test accept and then submit each one individually, which should be identical to package testaccept\")\n+        for rawtx in [hex_parent_a, hex_parent_b, signedtx_child[\"hex\"]]:\n+            testres = node.testmempoolaccept([rawtx])\n+            testres_single.append(testres[0])\n+            # Submit the transaction now so its child should have no problem validating\n+            node.sendrawtransaction(rawtx)\n+        assert_equal(testres_single, testres_multiple_ab)\n+\n+    def test_conflicting(self):\n+        node = self.nodes[0]\n+        prevtx = self.coins.pop()\n+        inputs = [{\"txid\" : prevtx[\"txid\"], \"vout\" : 0}]\n+        output1 = {node.get_deterministic_priv_key().address: 50 - 0.00125}\n+        output2 = {ADDRESS_BCRT1_P2WSH_OP_TRUE: 50 - 0.00125}\n+\n+        # tx1 and tx2 share the same inputs\n+        rawtx1 = node.createrawtransaction(inputs, output1)\n+        rawtx2 = node.createrawtransaction(inputs, output2)\n+        signedtx1 = node.signrawtransactionwithkey(hexstring=rawtx1, privkeys=self.privkeys)\n+        signedtx2 = node.signrawtransactionwithkey(hexstring=rawtx2, privkeys=self.privkeys)\n+        tx1 = CTransaction()\n+        tx1.deserialize(BytesIO(hex_str_to_bytes(signedtx1[\"hex\"])))\n+        tx2 = CTransaction()\n+        tx2.deserialize(BytesIO(hex_str_to_bytes(signedtx2[\"hex\"])))\n+        assert signedtx1[\"complete\"]\n+        assert signedtx2[\"complete\"]\n+\n+        # Ensure tx1 and tx2 are valid by themselves\n+        assert node.testmempoolaccept([signedtx1[\"hex\"]])[0][\"allowed\"]\n+        assert node.testmempoolaccept([signedtx2[\"hex\"]])[0][\"allowed\"]\n+\n+        self.log.info(\"Test duplicate transactions in the same package\")\n+        testres = node.testmempoolaccept([signedtx1[\"hex\"], signedtx1[\"hex\"]])\n+        assert_equal(testres, [\n+            {\"txid\": tx1.rehash(), \"wtxid\": tx1.getwtxid()},\n+            {\"txid\": tx1.rehash(), \"wtxid\": tx1.getwtxid(), \"allowed\": False, \"reject-reason\": \"conflict-in-package\"}\n+        ])\n+\n+        self.log.info(\"Test conflicting transactions in the same package\")\n+        testres = node.testmempoolaccept([signedtx1[\"hex\"], signedtx2[\"hex\"]])\n+        assert_equal(testres, [\n+            {\"txid\": tx1.rehash(), \"wtxid\": tx1.getwtxid()},\n+            {\"txid\": tx2.rehash(), \"wtxid\": tx2.getwtxid(), \"allowed\": False, \"reject-reason\": \"conflict-in-package\"}\n+        ])\n+\n+    def test_rbf(self):\n+        node = self.nodes[0]\n+        coin = self.coins.pop()\n+        inputs = [{\"txid\" : coin[\"txid\"], \"vout\" : 0, \"sequence\": BIP125_SEQUENCE_NUMBER}]\n+        fee = Decimal('0.00125000')\n+        output = {node.get_deterministic_priv_key().address: 50 - fee}\n+        raw_replaceable_tx = node.createrawtransaction(inputs, output)\n+        signed_replaceable_tx = node.signrawtransactionwithkey(hexstring=raw_replaceable_tx, privkeys=self.privkeys)\n+        testres_replaceable = node.testmempoolaccept([signed_replaceable_tx[\"hex\"]])\n+        replaceable_tx = CTransaction()\n+        replaceable_tx.deserialize(BytesIO(hex_str_to_bytes(signed_replaceable_tx[\"hex\"])))\n+        assert_equal(testres_replaceable, [\n+            {\"txid\": replaceable_tx.rehash(), \"wtxid\": replaceable_tx.getwtxid(),\n+            \"allowed\": True, \"vsize\": replaceable_tx.get_vsize(), \"fees\": { \"base\": fee }}\n+        ])\n+\n+        # Replacement transaction is identical except has double the fee\n+        replacement_tx = CTransaction()\n+        replacement_tx.deserialize(BytesIO(hex_str_to_bytes(signed_replaceable_tx[\"hex\"])))\n+        replacement_tx.vout[0].nValue -= int(fee * COIN)  # Doubled fee\n+        signed_replacement_tx = node.signrawtransactionwithkey(replacement_tx.serialize().hex(), self.privkeys)\n+        replacement_tx.deserialize(BytesIO(hex_str_to_bytes(signed_replacement_tx[\"hex\"])))\n+\n+        self.log.info(\"Test that transactions within a package cannot replace each other\")\n+        testres_rbf_conflicting = node.testmempoolaccept([signed_replaceable_tx[\"hex\"], signed_replacement_tx[\"hex\"]])\n+        assert_equal(testres_rbf_conflicting, [\n+            {\"txid\": replaceable_tx.rehash(), \"wtxid\": replaceable_tx.getwtxid()},\n+            {\"txid\": replacement_tx.rehash(), \"wtxid\": replacement_tx.getwtxid(),\n+            \"allowed\": False, \"reject-reason\": \"conflict-in-package\"}\n+        ])\n+\n+        self.log.info(\"Test a package with a transaction replacing a mempool transaction\")\n+        node.sendrawtransaction(signed_replaceable_tx[\"hex\"])\n+        testres_rbf = node.testmempoolaccept(self.independent_txns_hex + [signed_replacement_tx[\"hex\"]])\n+        testres_replacement = testres_replaceable[0]\n+        testres_replacement[\"txid\"] = replacement_tx.rehash()\n+        testres_replacement[\"wtxid\"] = replacement_tx.getwtxid()\n+        testres_replacement[\"fees\"][\"base\"] = Decimal(str(2 * fee))\n+        assert_equal(testres_rbf, self.independent_txns_testres + [testres_replacement])\n+\n+\n+if __name__ == \"__main__\":\n+    RPCPackagesTest().main()"
      },
      {
        "sha": "6803f9858239f4fd93c744a7ece90f1958c099b7",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/06f8fce092edf62f5bbabc5de41b2b499046b965/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/06f8fce092edf62f5bbabc5de41b2b499046b965/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=06f8fce092edf62f5bbabc5de41b2b499046b965",
        "patch": "@@ -210,6 +210,7 @@\n     'mempool_package_onemore.py',\n     'rpc_createmultisig.py --legacy-wallet',\n     'rpc_createmultisig.py --descriptors',\n+    'rpc_packages.py',\n     'feature_versionbits_warning.py',\n     'rpc_preciousblock.py',\n     'wallet_importprunedfunds.py --legacy-wallet',"
      }
    ]
  },
  {
    "sha": "74fe9c2831f60a95f2f3a947525befc7f4306143",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NGZlOWMyODMxZjYwYTk1ZjJmM2E5NDc1MjViZWZjN2Y0MzA2MTQz",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-03-03T22:54:27Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-03-10T21:19:06Z"
      },
      "message": "[validation] add option to bypass contextual timelock checks\n\nThis is for test_accepts only, and not allowed in an actual submission\nto mempool - see assert statements.\n\nProvide an option to bypass BIP68 nSequence and nLockTime checks. This\nmeans clients can use testmempoolaccept to check whether L2 transaction\nchains (which typically have timelock conditions) are valid without\nsubmitting them. Note that BIP112 and BIP65 are still checked since they\nare script (non-contextual) checks. This does not invalidate any\nsignature or script caching.",
      "tree": {
        "sha": "ca888713740336fddd8de8e1e26d8a8e3b7f0ed6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ca888713740336fddd8de8e1e26d8a8e3b7f0ed6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/74fe9c2831f60a95f2f3a947525befc7f4306143",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/74fe9c2831f60a95f2f3a947525befc7f4306143",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/74fe9c2831f60a95f2f3a947525befc7f4306143",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/74fe9c2831f60a95f2f3a947525befc7f4306143/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "06f8fce092edf62f5bbabc5de41b2b499046b965",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/06f8fce092edf62f5bbabc5de41b2b499046b965",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/06f8fce092edf62f5bbabc5de41b2b499046b965"
      }
    ],
    "stats": {
      "total": 27,
      "additions": 18,
      "deletions": 9
    },
    "files": [
      {
        "sha": "67fa3fd2de32d31ef9d9a017abd05be42e50f8e9",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 5,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/74fe9c2831f60a95f2f3a947525befc7f4306143/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/74fe9c2831f60a95f2f3a947525befc7f4306143/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=74fe9c2831f60a95f2f3a947525befc7f4306143",
        "patch": "@@ -590,6 +590,7 @@ class MemPoolAccept\n         const CChainParams& m_chainparams;\n         const int64_t m_accept_time;\n         const bool m_bypass_limits;\n+        const bool m_bypass_timelocks;\n         /*\n          * Return any outpoints which were not previously present in the coins\n          * cache, but were added as a result of validating the tx for mempool\n@@ -730,7 +731,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     // block; we don't want our mempool filled up with transactions that can't\n     // be mined yet.\n     assert(std::addressof(::ChainActive()) == std::addressof(m_active_chainstate.m_chain));\n-    if (!CheckFinalTx(m_active_chainstate.m_chain.Tip(), tx, STANDARD_LOCKTIME_VERIFY_FLAGS))\n+    if (!args.m_bypass_timelocks && !CheckFinalTx(m_active_chainstate.m_chain.Tip(), tx, STANDARD_LOCKTIME_VERIFY_FLAGS))\n         return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, \"non-final\");\n \n     // is it already in the memory pool?\n@@ -820,7 +821,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     // Pass in m_view which has all of the relevant inputs cached. Note that, since m_view's\n     // backend was removed, it no longer pulls coins from the mempool.\n     assert(std::addressof(::ChainstateActive()) == std::addressof(m_active_chainstate));\n-    if (!CheckSequenceLocks(m_active_chainstate, m_view, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n+    if (!args.m_bypass_timelocks && !CheckSequenceLocks(m_active_chainstate, m_view, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n         return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, \"non-BIP68-final\");\n \n     assert(std::addressof(g_chainman.m_blockman) == std::addressof(m_active_chainstate.m_blockman));\n@@ -1123,6 +1124,9 @@ bool MemPoolAccept::ConsensusScriptChecks(const ATMPArgs& args, Workspace& ws, P\n \n bool MemPoolAccept::Finalize(const ATMPArgs& args, Workspace& ws)\n {\n+    // Never submit a transaction without running all checks.\n+    assert(!args.m_bypass_timelocks);\n+\n     const CTransaction& tx = *ws.m_ptx;\n     const uint256& hash = ws.m_hash;\n     TxValidationState& state = ws.m_state;\n@@ -1275,7 +1279,8 @@ static MempoolAcceptResult AcceptToMemoryPoolWithTime(const CChainParams& chainp\n                                                       EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     std::vector<COutPoint> coins_to_uncache;\n-    MemPoolAccept::ATMPArgs args { chainparams, nAcceptTime, bypass_limits, coins_to_uncache, test_accept };\n+    MemPoolAccept::ATMPArgs args { chainparams, nAcceptTime, bypass_limits,\n+                                   /* bypass_timelocks*/ false, coins_to_uncache, test_accept };\n \n     assert(std::addressof(::ChainstateActive()) == std::addressof(active_chainstate));\n     const MempoolAcceptResult result = MemPoolAccept(pool, active_chainstate).AcceptSingleTransaction(tx, args);\n@@ -1305,14 +1310,16 @@ MempoolAcceptResult AcceptToMemoryPool(CChainState& active_chainstate, CTxMemPoo\n }\n \n std::vector<MempoolAcceptResult> ProcessNewPackage(CChainState& active_chainstate, CTxMemPool& pool,\n-                                                   std::vector<CTransactionRef>& txns, bool test_accept)\n+                                                   std::vector<CTransactionRef>& txns, bool test_accept,\n+                                                   bool bypass_timelocks)\n {\n     AssertLockHeld(cs_main);\n     assert(test_accept); // Only allow package accept dry-runs (testmempoolaccept RPC).\n+    if (bypass_timelocks) assert(test_accept); // Only allow bypass_timelocks in dry-runs.\n \n     std::vector<COutPoint> coins_to_uncache;\n     const CChainParams& chainparams = Params();\n-    MemPoolAccept::ATMPArgs args { chainparams, GetTime(), false, coins_to_uncache, test_accept };\n+    MemPoolAccept::ATMPArgs args { chainparams, GetTime(), false, bypass_timelocks, coins_to_uncache, test_accept };\n     assert(std::addressof(::ChainstateActive()) == std::addressof(active_chainstate));\n     const std::vector<MempoolAcceptResult> results = MemPoolAccept(pool, active_chainstate).AcceptMultipleTransactions(txns, args);\n     Assume(txns.size() == results.size());"
      },
      {
        "sha": "a9e47527d289e1c609d62a718f5b347df7313318",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/74fe9c2831f60a95f2f3a947525befc7f4306143/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/74fe9c2831f60a95f2f3a947525befc7f4306143/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=74fe9c2831f60a95f2f3a947525befc7f4306143",
        "patch": "@@ -224,8 +224,8 @@ struct MempoolAcceptResult {\n \n /**\n  * (Try to) add a transaction to the memory pool.\n- * @param[in]  bypass_limits   When true, don't enforce mempool fee limits.\n- * @param[in]  test_accept     When true, run validation checks but don't submit to mempool.\n+ * @param[in]  bypass_limits    When true, don't enforce mempool fee limits.\n+ * @param[in]  test_accept      When true, run validation checks but don't submit to mempool.\n  */\n MempoolAcceptResult AcceptToMemoryPool(CChainState& active_chainstate, CTxMemPool& pool, const CTransactionRef& tx,\n                                        bool bypass_limits, bool test_accept=false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n@@ -236,12 +236,14 @@ MempoolAcceptResult AcceptToMemoryPool(CChainState& active_chainstate, CTxMemPoo\n *                                   parent-child dependencies. The transactions must not conflict, i.e.\n *                                   must not spend the same inputs, even if it would be a valid BIP125\n *                                   replace-by-fee. Parents must appear before children.\n+* @param[in]    bypass_timelocks    When true (test_accept must also be true), don't enforce timelock\n+*                                   rules BIP65 and BIP112.\n * @returns a vector of MempoolAcceptResults for each tx in the same order as\n * the input txns. If one transaction fails, some results may be unfinished.\n */\n std::vector<MempoolAcceptResult> ProcessNewPackage(CChainState& active_chainstate, CTxMemPool& pool,\n-                                                   std::vector<CTransactionRef>& txns, bool test_accept)\n-                                                   EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+                                                   std::vector<CTransactionRef>& txns, bool test_accept,\n+                                                   bool bypass_timelocks=false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n /** Apply the effects of this transaction on the UTXO set represented by view */\n void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, int nHeight);"
      }
    ]
  },
  {
    "sha": "92700936d07484615e0540bbbe04f94d2a6ae273",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MjcwMDkzNmQwNzQ4NDYxNWUwNTQwYmJiZTA0Zjk0ZDJhNmFlMjcz",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-03-03T23:13:36Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-03-10T21:22:52Z"
      },
      "message": "[rpc] add optional bypass_timelocks for testmempoolaccept",
      "tree": {
        "sha": "fdc0abccee1b0eab86aed74c95847781f9c4621d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fdc0abccee1b0eab86aed74c95847781f9c4621d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/92700936d07484615e0540bbbe04f94d2a6ae273",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/92700936d07484615e0540bbbe04f94d2a6ae273",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/92700936d07484615e0540bbbe04f94d2a6ae273",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/92700936d07484615e0540bbbe04f94d2a6ae273/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "74fe9c2831f60a95f2f3a947525befc7f4306143",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/74fe9c2831f60a95f2f3a947525befc7f4306143",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/74fe9c2831f60a95f2f3a947525befc7f4306143"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 5,
      "deletions": 1
    },
    "files": [
      {
        "sha": "4c2813054fa5ba699bef3b5000e6c7721686b556",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92700936d07484615e0540bbbe04f94d2a6ae273/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92700936d07484615e0540bbbe04f94d2a6ae273/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=92700936d07484615e0540bbbe04f94d2a6ae273",
        "patch": "@@ -105,6 +105,7 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"sendrawtransaction\", 1, \"maxfeerate\" },\n     { \"testmempoolaccept\", 0, \"rawtxs\" },\n     { \"testmempoolaccept\", 1, \"maxfeerate\" },\n+    { \"testmempoolaccept\", 2, \"bypass_timelocks\" },\n     { \"combinerawtransaction\", 0, \"txs\" },\n     { \"fundrawtransaction\", 1, \"options\" },\n     { \"fundrawtransaction\", 2, \"iswitness\" },"
      },
      {
        "sha": "3f7e64009b06cab34f30a5289e63dd70e3236e54",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92700936d07484615e0540bbbe04f94d2a6ae273/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92700936d07484615e0540bbbe04f94d2a6ae273/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=92700936d07484615e0540bbbe04f94d2a6ae273",
        "patch": "@@ -889,6 +889,7 @@ static RPCHelpMan testmempoolaccept()\n                         },\n                         },\n                     {\"maxfeerate\", RPCArg::Type::AMOUNT, /* default */ FormatMoney(DEFAULT_MAX_RAW_TX_FEE_RATE.GetFeePerK()), \"Reject transactions whose fee rate is higher than the specified value, expressed in \" + CURRENCY_UNIT + \"/kB\\n\"},\n+                    {\"bypass_timelocks\", RPCArg::Type::BOOL, /* default */ \"false\", \"Don't enforce BIP68 sequence locks and timelocks. Don't use unless you know what you're doing!\\n\"}\n                 },\n                 RPCResult{\n                     RPCResult::Type::ARR, \"\", \"The result of the mempool acceptance test for each raw transaction in the input array.\\n\"\n@@ -937,6 +938,7 @@ static RPCHelpMan testmempoolaccept()\n     const CFeeRate max_raw_tx_fee_rate = request.params[1].isNull() ?\n                                              DEFAULT_MAX_RAW_TX_FEE_RATE :\n                                              CFeeRate(AmountFromValue(request.params[1]));\n+    const bool bypass_timelocks = request.params[2].isNull() ? false : request.params[2].get_bool();\n \n     CTxMemPool& mempool = EnsureMemPool(request.context);\n     std::vector<CTransactionRef> txns;\n@@ -950,7 +952,8 @@ static RPCHelpMan testmempoolaccept()\n     }\n \n     std::vector<MempoolAcceptResult> validation_results =\n-        WITH_LOCK(cs_main, return ProcessNewPackage(::ChainstateActive(), mempool, txns, /* test_accept */ true));\n+        WITH_LOCK(cs_main, return ProcessNewPackage(::ChainstateActive(), mempool, txns, /* test_accept */ true,\n+                  /* bypass_timelocks */ bypass_timelocks));\n \n     UniValue rpc_result(UniValue::VARR);\n "
      }
    ]
  },
  {
    "sha": "9bdaa14de5ad6bb468316a68b7677a71e89e39a9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YmRhYTE0ZGU1YWQ2YmI0NjgzMTZhNjhiNzY3N2E3MWU4OWUzOWE5",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-03-10T22:26:37Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-03-10T23:00:39Z"
      },
      "message": "[test] bypass_timelocks\n\nTest the bypass_timelocks option in testmempoolaccept. This lets us\nbypass BIP68 relative locktime checks (in nSequence) and absolute\nlocktime checks (in nLocktime).  OP_CSV and OP_CLTV script checks are\nstill done, so setting bypass_timelocks=True doesn't mean that bad\nscripts pass.",
      "tree": {
        "sha": "d8058b449b83dc4a3bc8c5598da70b2b17f5bac0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d8058b449b83dc4a3bc8c5598da70b2b17f5bac0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9bdaa14de5ad6bb468316a68b7677a71e89e39a9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9bdaa14de5ad6bb468316a68b7677a71e89e39a9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9bdaa14de5ad6bb468316a68b7677a71e89e39a9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9bdaa14de5ad6bb468316a68b7677a71e89e39a9/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "92700936d07484615e0540bbbe04f94d2a6ae273",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/92700936d07484615e0540bbbe04f94d2a6ae273",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/92700936d07484615e0540bbbe04f94d2a6ae273"
      }
    ],
    "stats": {
      "total": 32,
      "additions": 23,
      "deletions": 9
    },
    "files": [
      {
        "sha": "2a018b4f55010eb0d17f1167c078e5e2a0cce811",
        "filename": "test/functional/feature_bip68_sequence.py",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9bdaa14de5ad6bb468316a68b7677a71e89e39a9/test/functional/feature_bip68_sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9bdaa14de5ad6bb468316a68b7677a71e89e39a9/test/functional/feature_bip68_sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_bip68_sequence.py?ref=9bdaa14de5ad6bb468316a68b7677a71e89e39a9",
        "patch": "@@ -247,6 +247,10 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n             if (orig_tx.hash in node.getrawmempool()):\n                 # sendrawtransaction should fail if the tx is in the mempool\n                 assert_raises_rpc_error(-26, NOT_FINAL_ERROR, node.sendrawtransaction, ToHex(tx))\n+\n+                # Should pass with bypass_timelocks=True but not otherwise\n+                assert not node.testmempoolaccept([ToHex(tx)])[0][\"allowed\"]\n+                assert node.testmempoolaccept(rawtxs=[ToHex(tx)], bypass_timelocks=True)[0][\"allowed\"]\n             else:\n                 # sendrawtransaction should succeed if the tx is not in the mempool\n                 node.sendrawtransaction(ToHex(tx))\n@@ -301,6 +305,9 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n         tx5.vout[0].nValue += int(utxos[0][\"amount\"]*COIN)\n         raw_tx5 = self.nodes[0].signrawtransactionwithwallet(ToHex(tx5))[\"hex\"]\n \n+        # Should pass with bypass_timelocks=True but not otherwise\n+        assert not self.nodes[0].testmempoolaccept(rawtxs=[raw_tx5])[0][\"allowed\"]\n+        assert self.nodes[0].testmempoolaccept(rawtxs=[raw_tx5], bypass_timelocks=True)[0][\"allowed\"]\n         assert_raises_rpc_error(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, raw_tx5)\n \n         # Test mempool-BIP68 consistency after reorg"
      },
      {
        "sha": "2389c1d7013dfb42f1a58b1f061709cc5f5d5a68",
        "filename": "test/functional/feature_cltv.py",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9bdaa14de5ad6bb468316a68b7677a71e89e39a9/test/functional/feature_cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9bdaa14de5ad6bb468316a68b7677a71e89e39a9/test/functional/feature_cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_cltv.py?ref=9bdaa14de5ad6bb468316a68b7677a71e89e39a9",
        "patch": "@@ -125,15 +125,15 @@ def run_test(self):\n \n         # First we show that this tx is valid except for CLTV by getting it\n         # rejected from the mempool for exactly that reason.\n-        assert_equal(\n-            [{\n-                'txid': spendtx.hash,\n-                'wtxid': spendtx.getwtxid(),\n-                'allowed': False,\n-                'reject-reason': 'non-mandatory-script-verify-flag (Negative locktime)',\n-            }],\n-            self.nodes[0].testmempoolaccept(rawtxs=[spendtx.serialize().hex()], maxfeerate=0),\n-        )\n+        expected_testres = [{\n+            'txid': spendtx.hash,\n+            'wtxid': spendtx.getwtxid(),\n+            'allowed': False,\n+            'reject-reason': 'non-mandatory-script-verify-flag (Negative locktime)',\n+        }]\n+        assert_equal(expected_testres, self.nodes[0].testmempoolaccept(rawtxs=[spendtx.serialize().hex()], maxfeerate=0))\n+        # It still shouldn't work with bypass_timelocks=True because this is a script error.\n+        assert_equal(expected_testres, self.nodes[0].testmempoolaccept(rawtxs=[spendtx.serialize().hex()], maxfeerate=0, bypass_timelocks=True))\n \n         # Now we verify that a block with this transaction is also invalid.\n         block.vtx.append(spendtx)"
      },
      {
        "sha": "2b8300a7e964dbf6312de0a22b9960af04c5e710",
        "filename": "test/functional/feature_csv_activation.py",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9bdaa14de5ad6bb468316a68b7677a71e89e39a9/test/functional/feature_csv_activation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9bdaa14de5ad6bb468316a68b7677a71e89e39a9/test/functional/feature_csv_activation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_csv_activation.py?ref=9bdaa14de5ad6bb468316a68b7677a71e89e39a9",
        "patch": "@@ -404,8 +404,10 @@ def run_test(self):\n         self.log.info(\"Test version 1 txs\")\n \n         # -1 OP_CSV tx and (empty stack) OP_CSV tx should fail\n+        assert not self.nodes[0].testmempoolaccept(rawtxs=[ToHex(bip112tx_special_v1)], bypass_timelocks=True)[0][\"allowed\"]\n         self.send_blocks([self.create_test_block([bip112tx_special_v1])], success=False,\n                          reject_reason='non-mandatory-script-verify-flag (Negative locktime)')\n+        assert not self.nodes[0].testmempoolaccept(rawtxs=[ToHex(bip112tx_emptystack_v1)], bypass_timelocks=True)[0][\"allowed\"]\n         self.send_blocks([self.create_test_block([bip112tx_emptystack_v1])], success=False,\n                          reject_reason='non-mandatory-script-verify-flag (Operation not valid with the current stack size)')\n         # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in argument to OP_CSV, version 1 txs should still pass\n@@ -421,12 +423,14 @@ def run_test(self):\n         fail_txs += [tx['tx'] for tx in bip112txs_vary_OP_CSV_v1 if not tx['sdf']]\n         fail_txs += [tx['tx'] for tx in bip112txs_vary_OP_CSV_9_v1 if not tx['sdf']]\n         for tx in fail_txs:\n+            assert not self.nodes[0].testmempoolaccept(rawtxs=[ToHex(tx)], bypass_timelocks=True)[0][\"allowed\"]\n             self.send_blocks([self.create_test_block([tx])], success=False,\n                              reject_reason='non-mandatory-script-verify-flag (Locktime requirement not satisfied)')\n \n         self.log.info(\"Test version 2 txs\")\n \n         # -1 OP_CSV tx and (empty stack) OP_CSV tx should fail\n+        assert not self.nodes[0].testmempoolaccept(rawtxs=[ToHex(bip112tx_special_v2)], bypass_timelocks=True)[0][\"allowed\"]\n         self.send_blocks([self.create_test_block([bip112tx_special_v2])], success=False,\n                          reject_reason='non-mandatory-script-verify-flag (Negative locktime)')\n         self.send_blocks([self.create_test_block([bip112tx_emptystack_v2])], success=False,\n@@ -445,19 +449,22 @@ def run_test(self):\n         fail_txs = all_rlt_txs(bip112txs_vary_nSequence_9_v2)\n         fail_txs += [tx['tx'] for tx in bip112txs_vary_OP_CSV_9_v2 if not tx['sdf']]\n         for tx in fail_txs:\n+            assert not self.nodes[0].testmempoolaccept(rawtxs=[ToHex(tx)], bypass_timelocks=True)[0][\"allowed\"]\n             self.send_blocks([self.create_test_block([tx])], success=False,\n                              reject_reason='non-mandatory-script-verify-flag (Locktime requirement not satisfied)')\n \n         # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in nSequence, tx should fail\n         fail_txs = [tx['tx'] for tx in bip112txs_vary_nSequence_v2 if tx['sdf']]\n         for tx in fail_txs:\n+            assert not self.nodes[0].testmempoolaccept(rawtxs=[ToHex(tx)], bypass_timelocks=True)[0][\"allowed\"]\n             self.send_blocks([self.create_test_block([tx])], success=False,\n                              reject_reason='non-mandatory-script-verify-flag (Locktime requirement not satisfied)')\n \n         # If sequencelock types mismatch, tx should fail\n         fail_txs = [tx['tx'] for tx in bip112txs_vary_nSequence_v2 if not tx['sdf'] and tx['stf']]\n         fail_txs += [tx['tx'] for tx in bip112txs_vary_OP_CSV_v2 if not tx['sdf'] and tx['stf']]\n         for tx in fail_txs:\n+            assert not self.nodes[0].testmempoolaccept(rawtxs=[ToHex(tx)], bypass_timelocks=True)[0][\"allowed\"]\n             self.send_blocks([self.create_test_block([tx])], success=False,\n                              reject_reason='non-mandatory-script-verify-flag (Locktime requirement not satisfied)')\n "
      }
    ]
  }
]