[
  {
    "sha": "dac0995713873484cf14bbd1543be027a020beaa",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYWMwOTk1NzEzODczNDg0Y2YxNGJiZDE1NDNiZTAyN2EwMjBiZWFh",
    "commit": {
      "author": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2013-07-04T10:07:50Z"
      },
      "committer": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2013-07-04T10:07:50Z"
      },
      "message": "Child-pays-for-parent mempool\n\nCalculates total uncommitted fees and transaction size required to\ninclude the transaction in a block for all transactions in the mempool.\nCost is O(1) for mempool.accept() and maximum O(n) when a new block\nchanges what transactions are in the mempool, either due to them being\nmined, conflicts, or a re-org.\n\nNo changes to CreateNewBlock() yet.",
      "tree": {
        "sha": "62588846a5aa6a778a3020ef2fd4c2b0fbed02d5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/62588846a5aa6a778a3020ef2fd4c2b0fbed02d5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dac0995713873484cf14bbd1543be027a020beaa",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dac0995713873484cf14bbd1543be027a020beaa",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dac0995713873484cf14bbd1543be027a020beaa",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dac0995713873484cf14bbd1543be027a020beaa/comments",
    "author": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "28bcf3b7ef804f7084938b21708b29c1f5d7c8f8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/28bcf3b7ef804f7084938b21708b29c1f5d7c8f8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/28bcf3b7ef804f7084938b21708b29c1f5d7c8f8"
      }
    ],
    "stats": {
      "total": 620,
      "additions": 551,
      "deletions": 69
    },
    "files": [
      {
        "sha": "c50a2155807f812020576372c6a23f8e330351bf",
        "filename": "src/core.h",
        "status": "modified",
        "additions": 0,
        "deletions": 13,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dac0995713873484cf14bbd1543be027a020beaa/src/core.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dac0995713873484cf14bbd1543be027a020beaa/src/core.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.h?ref=dac0995713873484cf14bbd1543be027a020beaa",
        "patch": "@@ -45,19 +45,6 @@ class COutPoint\n     void print() const;\n };\n \n-/** An inpoint - a combination of a transaction and an index n into its vin */\n-class CInPoint\n-{\n-public:\n-    CTransaction* ptx;\n-    unsigned int n;\n-\n-    CInPoint() { SetNull(); }\n-    CInPoint(CTransaction* ptxIn, unsigned int nIn) { ptx = ptxIn; n = nIn; }\n-    void SetNull() { ptx = NULL; n = (unsigned int) -1; }\n-    bool IsNull() const { return (ptx == NULL && n == (unsigned int) -1); }\n-};\n-\n /** An input of a transaction.  It contains the location of the previous\n  * transaction's output that it claims and a signature that matches the\n  * output's public key."
      },
      {
        "sha": "c270f1206308130ab9f8b735ca642d40d658e88c",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 170,
        "deletions": 24,
        "changes": 194,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dac0995713873484cf14bbd1543be027a020beaa/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dac0995713873484cf14bbd1543be027a020beaa/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=dac0995713873484cf14bbd1543be027a020beaa",
        "patch": "@@ -807,6 +807,8 @@ bool CTxMemPool::accept(CValidationState &state, CTransaction &tx, bool fLimitFr\n             return false;\n     }\n \n+    int64 nFees;\n+\n     // Check for conflicts with in-memory transactions\n     CTransaction* ptxOld = NULL;\n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n@@ -878,7 +880,7 @@ bool CTxMemPool::accept(CValidationState &state, CTransaction &tx, bool fLimitFr\n         // you should add code here to check that the transaction does a\n         // reasonable number of ECDSA signature verifications.\n \n-        int64 nFees = view.GetValueIn(tx)-GetValueOut(tx);\n+        nFees = view.GetValueIn(tx)-GetValueOut(tx);\n         unsigned int nSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n \n         // Don't accept it if it can't get into a block\n@@ -925,9 +927,9 @@ bool CTxMemPool::accept(CValidationState &state, CTransaction &tx, bool fLimitFr\n         if (ptxOld)\n         {\n             printf(\"CTxMemPool::accept() : replacing tx %s with new version\\n\", ptxOld->GetHash().ToString().c_str());\n-            remove(*ptxOld);\n+            remove(ptxOld->GetHash());\n         }\n-        addUnchecked(hash, tx);\n+        addUnchecked(tx, nFees);\n     }\n \n     ///// are we sure this is ok when loading transactions or restoring block txes\n@@ -942,38 +944,116 @@ bool CTxMemPool::accept(CValidationState &state, CTransaction &tx, bool fLimitFr\n     return true;\n }\n \n+void CMemPoolTx::calcPrioritySums(const CTxMemPool &mempool)\n+{\n+    nSumTxSize = ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION);\n+    nSumTxFees = nFees;\n+    nDepth = 1;\n+\n+    LOCK(mempool.cs);\n+    int64 max_parent_fees = 0;\n+    BOOST_FOREACH(const CTxIn txin, this->vin){\n+        std::map<uint256, CMemPoolTx *>::const_iterator it = mempool.mapTx.find(txin.prevout.hash);\n+        if (it != mempool.mapTx.end()){\n+            CMemPoolTx &parent = *(it->second);\n+\n+            // Calculating sums for the purpose of priority is a bit tricky\n+            // because transactions can have multiple outputs - we need to make\n+            // sure an attacker can't spend multiple outputs of a single high\n+            // fee transaction, directly or indirectly, as a way to make their\n+            // transaction look like it is paying a higher fee than it really\n+            // is.\n+            //\n+            // Thus we take a pessimistic view when we sum the fees and size of\n+            // unconfirmed transactions we depend on by assuming that only the\n+            // largest fee seen is the \"real one\" so we'll never count a fee\n+            // twice. Since the main reason child-pays-for-parent is useful is\n+            // to essentially add a fee to a transaction this dodge doesn't\n+            // badly affect many legit transaction patterns and lets us use\n+            // a pure memoization implementation safely.\n+            max_parent_fees = max(parent.nSumTxFees, max_parent_fees);\n+\n+            // Unconfirmed size is a bad thing, so double-counting is safe. We\n+            // could create a set of all our direct parents, but spending\n+            // multiple outputs of an unconfirmed transaction by a second\n+            // transaction is something rarely done for legit reasons.\n+            nSumTxSize += parent.nSumTxSize;\n+\n+            nDepth = max(nDepth, parent.nDepth + 1);\n+        }\n+    }\n+    nSumTxFees += max_parent_fees;\n+}\n \n-bool CTxMemPool::addUnchecked(const uint256& hash, CTransaction &tx)\n+bool CTxMemPool::addUnchecked(const CTransaction &new_tx, int64 nFees)\n {\n     // Add to memory pool without checking anything.  Don't call this directly,\n     // call CTxMemPool::accept to properly check the transaction first.\n     {\n-        mapTx[hash] = tx;\n-        for (unsigned int i = 0; i < tx.vin.size(); i++)\n-            mapNextTx[tx.vin[i].prevout] = CInPoint(&mapTx[hash], i);\n+        // We assume there exists a mapNextTx entry for every transaction in\n+        // the mempool; sloppily written unittest code sometimes violates this\n+        // assumption.\n+        assert(new_tx.vin.size() > 0);\n+\n+        LOCK(cs);\n+\n+        // We do need to check for duplicates or you would end up with a heapTx\n+        // with more elements in it than mapTx*\n+        uint256 hash = new_tx.GetHash();\n+        if (mapTx.count(hash))\n+            return false;\n+\n+        // FIXME: should use emplace() - what versions of Boost support it?\n+        CMemPoolTx tx(new_tx, nFees);\n+        tx.calcPrioritySums(*this);\n+        boost::heap::fibonacci_heap<CMemPoolTx>::handle_type handle = heapTx.push(tx);\n+\n+        (*handle).handle = handle; // store heap handle for later\n+        CMemPoolTx *ptx= &(*handle); // get pointer to actual copy in the heap\n+\n+        mapTx[hash] = ptx;\n+        for (unsigned int i = 0; i < ptx->vin.size(); i++){\n+            assert(mapNextTx.count(ptx->vin[i].prevout) == 0); // double-spends\n+            mapNextTx[ptx->vin[i].prevout] = CInPoint(ptx, i);\n+        }\n+\n         nTransactionsUpdated++;\n+\n+        assert(heapTx.size() == mapTx.size());\n+        assert(mapTx.size() <= mapNextTx.size()); // all tx's have one or more inputs\n     }\n     return true;\n }\n \n \n-bool CTxMemPool::remove(const CTransaction &tx, bool fRecursive)\n+bool CTxMemPool::remove(const uint256 hash, bool fRecursive)\n {\n     // Remove transaction from memory pool\n     {\n         LOCK(cs);\n-        uint256 hash = tx.GetHash();\n-        if (mapTx.count(hash))\n+        std::map<uint256, CMemPoolTx*>::iterator txit = mapTx.find(hash);\n+        if (txit != mapTx.end())\n         {\n-            if (fRecursive) {\n+            CMemPoolTx &tx = *txit->second;\n+\n+            if (fRecursive){\n                 for (unsigned int i = 0; i < tx.vout.size(); i++) {\n                     std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(hash, i));\n                     if (it != mapNextTx.end())\n-                        remove(*it->second.ptx, true);\n+                        remove(it->second.ptx->GetHash());\n                 }\n             }\n+\n             BOOST_FOREACH(const CTxIn& txin, tx.vin)\n                 mapNextTx.erase(txin.prevout);\n+\n+            // Boost has a bug with removing the last element of a fibonacci\n+            // heap, so check for that case separately.\n+            if (heapTx.size() > 1)\n+                heapTx.erase(tx.handle);\n+            else\n+                heapTx.pop();\n+\n             mapTx.erase(hash);\n             nTransactionsUpdated++;\n         }\n@@ -990,17 +1070,78 @@ bool CTxMemPool::removeConflicts(const CTransaction &tx)\n         if (it != mapNextTx.end()) {\n             const CTransaction &txConflict = *it->second.ptx;\n             if (txConflict != tx)\n-                remove(txConflict, true);\n+                remove(txConflict.GetHash());\n         }\n     }\n     return true;\n }\n \n+void CTxMemPool::updatePriorities(std::set<uint256> &setChangedHashes)\n+{\n+    // Update priorities of transactions depending on any in setChangedHashes.\n+    // This may be because those transactions were removed from the mempool, or\n+    // even added in the case of a re-org. The transactions in setChangedHashed\n+    // are not touched unless they themselves depend on a transaction in\n+    // setChangedHashed.\n+\n+    LOCK(cs);\n+\n+    std::set<uint256> d1,d2;\n+    std::set<uint256> *dirty = &d1;\n+    std::set<uint256> *next_dirty = &d2;\n+\n+    // Populate the initial dirty set with all changed hashes that are either\n+    // not in this mempool, or don't depend on any inputs in the changed hash\n+    // set. This ensures that we'll never do more than O(n) work, important in\n+    // the case of a large re-org.\n+    BOOST_FOREACH(uint256 hash, setChangedHashes){\n+        std::map<uint256, CMemPoolTx *>::iterator it = mapTx.find(hash);\n+        if (it == mapTx.end()){\n+            // The transaction is not in this mempool, safe.\n+            dirty->insert(hash);\n+        } else {\n+            // The transaction is is in this mempool, check if it has any\n+            // inputs already in the dirty set.\n+            bool fOK = true;\n+            BOOST_FOREACH(const CTxIn txin, it->second->vin){\n+                if (setChangedHashes.count(txin.prevout.hash)){\n+                    // tx has a parent already in the set, ignore it.\n+                    fOK = false;\n+                    break;\n+                }\n+            }\n+            if (fOK) dirty->insert(hash);\n+        }\n+    }\n+\n+    int n = 0;\n+    while (!dirty->empty()){\n+        next_dirty->clear();\n+\n+        BOOST_FOREACH(uint256 parent_hash, *dirty){\n+\n+            // Iterate over all the transactions in the mempool that spent an\n+            // output of this changed transaction.\n+            std::map<COutPoint, CInPoint>::iterator it = mapNextTx.lower_bound(COutPoint(parent_hash, 0));\n+            while (it != mapNextTx.end() && it->first.hash == parent_hash){\n+                it->second.ptx->calcPrioritySums(*this);\n+                next_dirty->insert(it->second.ptx->GetHash());\n+                ++it;\n+                n++;\n+            }\n+        }\n+        std::swap(dirty, next_dirty);\n+    }\n+\n+    printf(\"CTxMemPool::updatePriorities() : updated priorities for %d transactions\", n);\n+}\n+\n void CTxMemPool::clear()\n {\n     LOCK(cs);\n     mapTx.clear();\n     mapNextTx.clear();\n+    heapTx.clear();\n     ++nTransactionsUpdated;\n }\n \n@@ -1009,9 +1150,10 @@ void CTxMemPool::queryHashes(std::vector<uint256>& vtxid)\n     vtxid.clear();\n \n     LOCK(cs);\n-    vtxid.reserve(mapTx.size());\n-    for (map<uint256, CTransaction>::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi)\n-        vtxid.push_back((*mi).first);\n+    vtxid.reserve(heapTx.size());\n+    boost::heap::fibonacci_heap<CMemPoolTx>::ordered_iterator it;\n+    for (it = heapTx.ordered_begin(); it != heapTx.ordered_end(); ++it)\n+        vtxid.push_back((*it).GetHash());\n }\n \n \n@@ -2002,10 +2144,14 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n     }\n \n     // Delete redundant memory transactions that are in the connected branch\n+    std::set<uint256> removed_txs;\n     BOOST_FOREACH(CTransaction& tx, vDelete) {\n-        mempool.remove(tx);\n+        uint256 hash = tx.GetHash();\n+        removed_txs.insert(hash);\n+        mempool.remove(hash, false);\n         mempool.removeConflicts(tx);\n     }\n+    mempool.updatePriorities(removed_txs);\n \n     // Update best block in wallet (so we can detect restored wallets)\n     if ((pindexNew->nHeight % 20160) == 0 || (!fIsInitialDownload && (pindexNew->nHeight % 144) == 0))\n@@ -4195,12 +4341,12 @@ unsigned int static ScanHash_CryptoPP(char* pmidstate, char* pdata, char* phash1\n class COrphan\n {\n public:\n-    CTransaction* ptx;\n+    CMemPoolTx* ptx;\n     set<uint256> setDependsOn;\n     double dPriority;\n     double dFeePerKb;\n \n-    COrphan(CTransaction* ptxIn)\n+    COrphan(CMemPoolTx* ptxIn)\n     {\n         ptx = ptxIn;\n         dPriority = dFeePerKb = 0;\n@@ -4220,7 +4366,7 @@ uint64 nLastBlockTx = 0;\n uint64 nLastBlockSize = 0;\n \n // We want to sort transactions by priority and fee, so:\n-typedef boost::tuple<double, double, CTransaction*> TxPriority;\n+typedef boost::tuple<double, double, CMemPoolTx*> TxPriority;\n class TxPriorityCompare\n {\n     bool byFee;\n@@ -4296,9 +4442,9 @@ CBlockTemplate* CreateNewBlock(CReserveKey& reservekey)\n         // This vector will be sorted into a priority queue:\n         vector<TxPriority> vecPriority;\n         vecPriority.reserve(mempool.mapTx.size());\n-        for (map<uint256, CTransaction>::iterator mi = mempool.mapTx.begin(); mi != mempool.mapTx.end(); ++mi)\n+        for (map<uint256, CMemPoolTx *>::iterator mi = mempool.mapTx.begin(); mi != mempool.mapTx.end(); ++mi)\n         {\n-            CTransaction& tx = (*mi).second;\n+            CMemPoolTx& tx = *mi->second;\n             if (tx.IsCoinBase() || !IsFinalTx(tx))\n                 continue;\n \n@@ -4333,7 +4479,7 @@ CBlockTemplate* CreateNewBlock(CReserveKey& reservekey)\n                     }\n                     mapDependers[txin.prevout.hash].push_back(porphan);\n                     porphan->setDependsOn.insert(txin.prevout.hash);\n-                    nTotalIn += mempool.mapTx[txin.prevout.hash].vout[txin.prevout.n].nValue;\n+                    nTotalIn += mempool.mapTx[txin.prevout.hash]->vout[txin.prevout.n].nValue;\n                     continue;\n                 }\n                 const CCoins &coins = view.GetCoins(txin.prevout.hash);\n@@ -4362,7 +4508,7 @@ CBlockTemplate* CreateNewBlock(CReserveKey& reservekey)\n                 porphan->dFeePerKb = dFeePerKb;\n             }\n             else\n-                vecPriority.push_back(TxPriority(dPriority, dFeePerKb, &(*mi).second));\n+                vecPriority.push_back(TxPriority(dPriority, dFeePerKb, mi->second));\n         }\n \n         // Collect transactions into block"
      },
      {
        "sha": "ded9a13d821017872a6c4059c7b110bf6b42f5dd",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 77,
        "deletions": 6,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dac0995713873484cf14bbd1543be027a020beaa/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dac0995713873484cf14bbd1543be027a020beaa/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=dac0995713873484cf14bbd1543be027a020beaa",
        "patch": "@@ -12,6 +12,7 @@\n #include \"script.h\"\n \n #include <list>\n+#include <boost/heap/fibonacci_heap.hpp>\n \n class CWallet;\n class CBlock;\n@@ -1076,41 +1077,111 @@ class CBlockLocator\n };\n \n \n+class CTxMemPool;\n \n+/*** A transaction with the priority/profit information needed by the mempool */\n+class CMemPoolTx : public CTransaction\n+{\n+public:\n+    int64 nFees;\n+    int64 nDepth;\n+    int64 nRecvTime;\n+    int64 nSumTxFees;\n+    int   nSumTxSize;\n+\n+    boost::heap::fibonacci_heap<CMemPoolTx>::handle_type handle;\n+\n+    double FeesPerKB() const{\n+        assert(nSumTxFees >= 0);\n+        assert(nSumTxSize >= 0);\n+\n+        if (nSumTxSize > 0)\n+            return (double)nSumTxFees / ((double)nSumTxSize/1000);\n+        else\n+            return 0;\n+    }\n+\n+    double priority() const{\n+        return FeesPerKB();\n+    }\n \n+    inline bool operator<(const CMemPoolTx& rhs) const{\n+        return priority() < rhs.priority();\n+    }\n+\n+    void calcPrioritySums(const CTxMemPool &mempool);\n \n+    CMemPoolTx(const CTransaction &old_tx, int64 nFees){\n+        CTransaction();\n+        *((CTransaction *)this) = old_tx;\n+        this->nFees = nFees;\n+        nRecvTime = GetTime();\n+    }\n+};\n \n+/** An inpoint - a combination of a transaction pointer and an index n into its vin */\n+class CInPoint\n+{\n+public:\n+    CMemPoolTx* ptx;\n+    unsigned int n;\n \n+    CInPoint() { SetNull(); }\n+    CInPoint(CMemPoolTx* ptxIn, unsigned int nIn) { ptx = ptxIn; n = nIn; }\n+    void SetNull() { ptx = NULL; n = (unsigned int) -1; }\n+    bool IsNull() const { return (ptx == NULL && n == (unsigned int) -1); }\n+};\n \n class CTxMemPool\n {\n public:\n     mutable CCriticalSection cs;\n-    std::map<uint256, CTransaction> mapTx;\n+    boost::heap::fibonacci_heap<CMemPoolTx> heapTx;\n+    std::map<uint256, CMemPoolTx *> mapTx;\n     std::map<COutPoint, CInPoint> mapNextTx;\n \n     bool accept(CValidationState &state, CTransaction &tx, bool fLimitFree, bool* pfMissingInputs);\n-    bool addUnchecked(const uint256& hash, CTransaction &tx);\n-    bool remove(const CTransaction &tx, bool fRecursive = false);\n+    bool addUnchecked(const CTransaction &tx, int64 nFees);\n+    bool remove(const uint256 hash, bool fRecursive = true);\n     bool removeConflicts(const CTransaction &tx);\n+    void updatePriorities(std::set<uint256> &setChangedHashes);\n     void clear();\n     void queryHashes(std::vector<uint256>& vtxid);\n     void pruneSpent(const uint256& hash, CCoins &coins);\n \n     unsigned long size()\n     {\n         LOCK(cs);\n-        return mapTx.size();\n+        return heapTx.size();\n     }\n \n     bool exists(uint256 hash)\n     {\n         return (mapTx.count(hash) != 0);\n     }\n \n-    CTransaction& lookup(uint256 hash)\n+    CMemPoolTx& lookup(uint256 hash)\n+    {\n+        return *(mapTx[hash]->handle);\n+    }\n+\n+    void getTxParents(const CTransaction &tx, std::set<CMemPoolTx *> &parents)\n+    {\n+        BOOST_FOREACH(const CTxIn txin, tx.vin) {\n+            std::map<uint256, CMemPoolTx *>::iterator it = mapTx.find(txin.prevout.hash);\n+            if (it != mapTx.end())\n+                parents.insert(it->second);\n+        }\n+    }\n+\n+    void getTxChildren(const CTransaction &tx, std::set<CMemPoolTx *> &children)\n     {\n-        return mapTx[hash];\n+        uint256 hash = tx.GetHash();\n+        for (unsigned int i = 0; i < tx.vout.size(); i++) {\n+            std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(hash, i));\n+            if (it != mapNextTx.end())\n+                children.insert(it->second.ptx);\n+        }\n     }\n };\n "
      },
      {
        "sha": "c56d12098d2e41b3e383b570935550dff2a0d635",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 2,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dac0995713873484cf14bbd1543be027a020beaa/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dac0995713873484cf14bbd1543be027a020beaa/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=dac0995713873484cf14bbd1543be027a020beaa",
        "patch": "@@ -117,12 +117,27 @@ Value getrawmempool(const Array& params, bool fHelp)\n             \"getrawmempool\\n\"\n             \"Returns all transaction ids in memory pool.\");\n \n+    LOCK(mempool.cs);\n+\n     vector<uint256> vtxid;\n     mempool.queryHashes(vtxid);\n \n     Array a;\n-    BOOST_FOREACH(const uint256& hash, vtxid)\n-        a.push_back(hash.ToString());\n+    BOOST_FOREACH(const uint256& hash, vtxid){\n+        Object rtx;\n+\n+        rtx.push_back(Pair(\"txid\",hash.ToString()));\n+\n+        CMemPoolTx &tx = *(mempool.mapTx[hash]);\n+\n+        rtx.push_back(Pair(\"nFees\",(boost::int64_t)tx.nFees));\n+        rtx.push_back(Pair(\"nDepth\",(boost::int64_t)tx.nDepth));\n+        rtx.push_back(Pair(\"nSumTxFees\",(boost::int64_t)tx.nSumTxFees));\n+        rtx.push_back(Pair(\"nSumTxSize\",(boost::int64_t)tx.nSumTxSize));\n+        rtx.push_back(Pair(\"nRecvTime\",(boost::int64_t)tx.nRecvTime));\n+\n+        a.push_back(rtx);\n+    }\n \n     return a;\n }"
      },
      {
        "sha": "18e13ed1deb782d845a8bc47a8a2fb179a579829",
        "filename": "src/test/mempool_tests.cpp",
        "status": "added",
        "additions": 270,
        "deletions": 0,
        "changes": 270,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dac0995713873484cf14bbd1543be027a020beaa/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dac0995713873484cf14bbd1543be027a020beaa/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=dac0995713873484cf14bbd1543be027a020beaa",
        "patch": "@@ -0,0 +1,270 @@\n+#include <boost/test/unit_test.hpp>\n+\n+#include \"init.h\"\n+#include \"main.h\"\n+#include \"uint256.h\"\n+#include \"util.h\"\n+\n+BOOST_AUTO_TEST_SUITE(mempool_tests)\n+\n+BOOST_AUTO_TEST_CASE(CTxMemPool_add_remove)\n+{\n+    BOOST_CHECK_EQUAL(mempool.size(), 0);\n+\n+    CTransaction tx1,tx2;\n+\n+    tx1.vin.resize(1);\n+    tx1.vout.resize(1);\n+    tx1.vout[0].nValue = 2LL * COIN;\n+\n+    // Adding and removing a single transaction\n+    BOOST_CHECK(!mempool.exists(tx1.GetHash()));\n+\n+    mempool.addUnchecked(tx1, 1);\n+\n+    BOOST_CHECK(mempool.exists(tx1.GetHash()));\n+    BOOST_CHECK_EQUAL(mempool.size(), 1);\n+    BOOST_CHECK(mempool.lookup(tx1.GetHash()) == tx1);\n+\n+    mempool.remove(tx1.GetHash());\n+    BOOST_CHECK(!mempool.exists(tx1.GetHash()));\n+    BOOST_CHECK_EQUAL(mempool.size(), 0);\n+\n+\n+    // Adding and removing a transaction with dependencies, tx2 depends on tx1\n+    tx2.vin.resize(1);\n+    tx2.vin[0].scriptSig = CScript() << OP_1;\n+    tx2.vin[0].prevout.hash = tx1.GetHash();\n+    tx2.vin[0].prevout.n = 0;\n+    tx2.vout.resize(1);\n+    tx2.vout[0].nValue = 1LL * COIN;\n+\n+    mempool.addUnchecked(tx1, 0);\n+    mempool.addUnchecked(tx2, 1LL * COIN);\n+\n+    BOOST_CHECK(mempool.exists(tx1.GetHash()));\n+    BOOST_CHECK(mempool.exists(tx2.GetHash()));\n+    BOOST_CHECK_EQUAL(mempool.size(), 2);\n+\n+\n+    // tx2 depends on tx1, so both should be removed with recursive flag set\n+    mempool.remove(tx1.GetHash());\n+    BOOST_CHECK(!mempool.exists(tx1.GetHash()));\n+    BOOST_CHECK(!mempool.exists(tx2.GetHash()));\n+\n+    BOOST_CHECK_EQUAL(mempool.size(), 0);\n+    BOOST_CHECK_EQUAL(mempool.heapTx.size(), 0);\n+    BOOST_CHECK_EQUAL(mempool.mapTx.size(), 0);\n+    BOOST_CHECK_EQUAL(mempool.mapNextTx.size(), 0);\n+\n+    mempool.clear();\n+}\n+\n+BOOST_AUTO_TEST_CASE(CTxMemPool_priority_tracking)\n+{\n+    BOOST_CHECK(mempool.size() == 0);\n+\n+    CTransaction tx1,tx2,tx3,tx4,tx5,tx6;\n+\n+    // First transaction, 1BTC fee\n+    tx1.vin.resize(1);\n+    tx1.vout.resize(4);\n+    tx1.vout[0].nValue = 10LL * COIN;\n+    tx1.vout[1].nValue = 10LL * COIN;\n+    tx1.vout[2].nValue = 10LL * COIN;\n+    tx1.vout[3].nValue = 10LL * COIN;\n+    BOOST_CHECK(mempool.addUnchecked(tx1, 1LL * COIN));\n+\n+    // Exactly one tx in the heap\n+    BOOST_CHECK(mempool.heapTx.top() == tx1);\n+    BOOST_CHECK_EQUAL(mempool.heapTx.top().nSumTxFees, 1LL * COIN);\n+    BOOST_CHECK_EQUAL(mempool.heapTx.top().nSumTxSize, 87);\n+    BOOST_CHECK_EQUAL(mempool.heapTx.top().nDepth, 1);\n+\n+\n+    // Second tx, 2BTC fee, replaces tx1 as top of the heap\n+    tx2.vin.resize(1);\n+    tx2.vin[0].prevout.n = 1; // need to make tx1 != tx2\n+    tx2.vout.resize(2);\n+    tx2.vout[0].nValue = 10LL * COIN;\n+    tx2.vout[1].nValue = 10LL * COIN;\n+    BOOST_CHECK(mempool.addUnchecked(tx2, 2LL * COIN));\n+\n+    BOOST_CHECK(mempool.heapTx.top() == tx2);\n+    BOOST_CHECK_EQUAL(mempool.heapTx.top().nSumTxFees, 2LL * COIN);\n+    BOOST_CHECK_EQUAL(mempool.heapTx.top().nSumTxSize, 69);\n+    BOOST_CHECK_EQUAL(mempool.heapTx.top().nDepth, 1);\n+\n+\n+    // Third tx, 1BTC fee, top of heap remains unchanged\n+    tx3.vin.resize(1);\n+    tx3.vin[0].prevout.n = 2;\n+    tx3.vout.resize(1);\n+    tx3.vout[0].nValue = 10LL * COIN;\n+    BOOST_CHECK(mempool.addUnchecked(tx3, 1LL * COIN));\n+\n+    BOOST_CHECK(mempool.heapTx.top() == tx2);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx3.GetHash()).nSumTxFees, 1LL * COIN);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx3.GetHash()).nSumTxSize, 60);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx3.GetHash()).nDepth, 1);\n+\n+\n+    // Spend tx1 output 0 with 4BTC fee\n+    tx4.vin.resize(1);\n+    tx4.vin[0].scriptSig = CScript() << OP_1;\n+    tx4.vin[0].prevout.hash = tx1.GetHash();\n+    tx4.vin[0].prevout.n = 0;\n+    tx4.vout.resize(1);\n+    tx4.vout[0].nValue = 6LL * COIN;\n+    BOOST_CHECK(mempool.addUnchecked(tx4, 4LL * COIN));\n+\n+    // tx4 becomes new heap top\n+    BOOST_CHECK(mempool.heapTx.top() == tx4);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx4.GetHash()).nSumTxFees, 5LL * COIN);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx4.GetHash()).nSumTxSize, 87+61);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx4.GetHash()).nDepth, 2);\n+\n+\n+    // Spend tx1 output 1, 2, and tx2 output 1 with 1BTC fee\n+    tx5.vin.resize(3);\n+    tx5.vin[0].scriptSig = CScript() << OP_1;\n+    tx5.vin[0].prevout.hash = tx1.GetHash();\n+    tx5.vin[0].prevout.n = 1;\n+    tx5.vin[1].scriptSig = CScript() << OP_1;\n+    tx5.vin[1].prevout.hash = tx1.GetHash();\n+    tx5.vin[1].prevout.n = 2;\n+    tx5.vin[2].scriptSig = CScript() << OP_1;\n+    tx5.vin[2].prevout.hash = tx2.GetHash();\n+    tx5.vin[2].prevout.n = 1;\n+    tx5.vout.resize(1);\n+    tx5.vout[0].nValue = 29LL * COIN;\n+    BOOST_CHECK(mempool.addUnchecked(tx5, 1LL * COIN));\n+\n+    // Fees counted pessimisticly, only one fee counted out of all three\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx5.GetHash()).nSumTxFees, (2LL + 1LL) * COIN);\n+\n+    // Size also counted pessimisticly, every txin sumed together, which even\n+    // double-counted tx1\n+    BOOST_CHECK_EQUAL(::GetSerializeSize(tx5, SER_NETWORK, PROTOCOL_VERSION), 145);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx5.GetHash()).nSumTxSize, 87+87+69+145);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx5.GetHash()).nDepth, 2);\n+\n+\n+    // Spend tx1.3 and tx5 with 1BTC fee\n+    tx6.vin.resize(2);\n+    tx6.vin[0].scriptSig = CScript() << OP_1;\n+    tx6.vin[0].prevout.hash = tx1.GetHash();\n+    tx6.vin[0].prevout.n = 3;\n+    tx6.vin[1].scriptSig = CScript() << OP_1;\n+    tx6.vin[1].prevout.hash = tx5.GetHash();\n+    tx6.vin[1].prevout.n = 0;\n+    tx6.vout.resize(1);\n+    tx6.vout[0].nValue = 39LL * COIN;\n+    BOOST_CHECK(mempool.addUnchecked(tx6, 1LL * COIN));\n+\n+    // tx6 is not the heap top\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx6.GetHash()).nSumTxFees, 4LL * COIN);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx6.GetHash()).nSumTxSize, 87+(87+87+69+145)+103);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx6.GetHash()).nDepth, 3);\n+\n+\n+    // Remove tx2 and update priorities\n+    std::set<uint256> changed;\n+    changed.insert(tx2.GetHash());\n+    mempool.remove(tx2.GetHash(), false);\n+    mempool.updatePriorities(changed);\n+\n+    // Fees no longer include tx2, but they do include tx1\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx5.GetHash()).nSumTxFees, (1LL + 1LL) * COIN);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx5.GetHash()).nSumTxSize, 87+87+145);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx5.GetHash()).nDepth, 2);\n+\n+    // tx6 updated correctly\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx6.GetHash()).nSumTxFees, (1LL + 1LL + 1LL) * COIN);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx6.GetHash()).nSumTxSize, 87+(87+87+145)+103);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx6.GetHash()).nDepth, 3);\n+\n+\n+    // Remove tx1\n+    changed.clear();\n+    changed.insert(tx1.GetHash());\n+    mempool.remove(tx1.GetHash(), false);\n+    mempool.updatePriorities(changed);\n+\n+    BOOST_CHECK(mempool.heapTx.top() == tx4);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx4.GetHash()).nSumTxFees, 4LL * COIN);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx4.GetHash()).nSumTxSize, 61);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx4.GetHash()).nDepth, 1);\n+\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx5.GetHash()).nSumTxFees, 1LL * COIN);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx5.GetHash()).nSumTxSize, 145);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx5.GetHash()).nDepth, 1);\n+\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx6.GetHash()).nSumTxFees, (1LL + 1LL) * COIN);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx6.GetHash()).nSumTxSize, 145+103);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx6.GetHash()).nDepth, 2);\n+\n+    // Remove tx5\n+    changed.clear();\n+    changed.insert(tx5.GetHash());\n+    mempool.remove(tx5.GetHash(), false);\n+    mempool.updatePriorities(changed);\n+\n+    BOOST_CHECK(mempool.heapTx.top() == tx4);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx4.GetHash()).nSumTxFees, 4LL * COIN);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx4.GetHash()).nSumTxSize, 61);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx4.GetHash()).nDepth, 1);\n+\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx6.GetHash()).nSumTxFees, 1LL * COIN);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx6.GetHash()).nSumTxSize, 103);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx6.GetHash()).nDepth, 1);\n+\n+\n+    // Reinstate tx1, tx2 and tx5 as though a re-org happened and they got put\n+    // back in the mempool. Note how the order ensures the sums won't be\n+    // correct.\n+    BOOST_CHECK(mempool.addUnchecked(tx5, 1LL * COIN));\n+    BOOST_CHECK(mempool.addUnchecked(tx2, 2LL * COIN));\n+    BOOST_CHECK(mempool.addUnchecked(tx1, 1LL * COIN));\n+\n+    changed.clear();\n+    changed.insert(tx1.GetHash());\n+    changed.insert(tx2.GetHash());\n+    changed.insert(tx5.GetHash());\n+    mempool.updatePriorities(changed);\n+\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx1.GetHash()).nSumTxFees, 1LL * COIN);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx1.GetHash()).nSumTxSize, 87);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx1.GetHash()).nDepth, 1);\n+\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx2.GetHash()).nSumTxFees, 2LL * COIN);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx2.GetHash()).nSumTxSize, 69);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx2.GetHash()).nDepth, 1);\n+\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx4.GetHash()).nSumTxFees, 5LL * COIN);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx4.GetHash()).nSumTxSize, 87+61);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx4.GetHash()).nDepth, 2);\n+\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx5.GetHash()).nSumTxFees, (2LL + 1LL) * COIN);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx5.GetHash()).nSumTxSize, 87+87+69+145);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx5.GetHash()).nDepth, 2);\n+\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx6.GetHash()).nSumTxFees, (2LL + 1LL + 1LL) * COIN);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx6.GetHash()).nSumTxSize, (87+87+69+145)+87+103);\n+    BOOST_CHECK_EQUAL(mempool.lookup(tx6.GetHash()).nDepth, 3);\n+\n+\n+    // Remove everything\n+    mempool.remove(tx1.GetHash());\n+    mempool.remove(tx2.GetHash());\n+    mempool.remove(tx3.GetHash());\n+\n+    BOOST_CHECK_EQUAL(mempool.size(), 0);\n+    BOOST_CHECK_EQUAL(mempool.heapTx.size(), 0);\n+    BOOST_CHECK_EQUAL(mempool.mapTx.size(), 0);\n+    BOOST_CHECK_EQUAL(mempool.mapNextTx.size(), 0);\n+\n+    mempool.clear();\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "abef1b52dee6d5531dbd8ec05e9b2bc19e08819a",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 24,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dac0995713873484cf14bbd1543be027a020beaa/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dac0995713873484cf14bbd1543be027a020beaa/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=dac0995713873484cf14bbd1543be027a020beaa",
        "patch": "@@ -94,9 +94,8 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     for (unsigned int i = 0; i < 1001; ++i)\n     {\n         tx.vout[0].nValue -= 1000000;\n-        hash = tx.GetHash();\n-        mempool.addUnchecked(hash, tx);\n-        tx.vin[0].prevout.hash = hash;\n+        mempool.addUnchecked(tx, 0);\n+        tx.vin[0].prevout.hash = tx.GetHash();\n     }\n     BOOST_CHECK(pblocktemplate = CreateNewBlock(reservekey));\n     delete pblocktemplate;\n@@ -114,17 +113,15 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     for (unsigned int i = 0; i < 128; ++i)\n     {\n         tx.vout[0].nValue -= 10000000;\n-        hash = tx.GetHash();\n-        mempool.addUnchecked(hash, tx);\n-        tx.vin[0].prevout.hash = hash;\n+        mempool.addUnchecked(tx, 0);\n+        tx.vin[0].prevout.hash = tx.GetHash();\n     }\n     BOOST_CHECK(pblocktemplate = CreateNewBlock(reservekey));\n     delete pblocktemplate;\n     mempool.clear();\n \n     // orphan in mempool\n-    hash = tx.GetHash();\n-    mempool.addUnchecked(hash, tx);\n+    mempool.addUnchecked(tx, 0);\n     BOOST_CHECK(pblocktemplate = CreateNewBlock(reservekey));\n     delete pblocktemplate;\n     mempool.clear();\n@@ -133,16 +130,14 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vin[0].scriptSig = CScript() << OP_1;\n     tx.vin[0].prevout.hash = txFirst[1]->GetHash();\n     tx.vout[0].nValue = 4900000000LL;\n-    hash = tx.GetHash();\n-    mempool.addUnchecked(hash, tx);\n-    tx.vin[0].prevout.hash = hash;\n+    mempool.addUnchecked(tx, 0);\n+    tx.vin[0].prevout.hash = tx.GetHash();\n     tx.vin.resize(2);\n     tx.vin[1].scriptSig = CScript() << OP_1;\n     tx.vin[1].prevout.hash = txFirst[0]->GetHash();\n     tx.vin[1].prevout.n = 0;\n     tx.vout[0].nValue = 5900000000LL;\n-    hash = tx.GetHash();\n-    mempool.addUnchecked(hash, tx);\n+    mempool.addUnchecked(tx, 0);\n     BOOST_CHECK(pblocktemplate = CreateNewBlock(reservekey));\n     delete pblocktemplate;\n     mempool.clear();\n@@ -152,8 +147,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vin[0].prevout.SetNull();\n     tx.vin[0].scriptSig = CScript() << OP_0 << OP_1;\n     tx.vout[0].nValue = 0;\n-    hash = tx.GetHash();\n-    mempool.addUnchecked(hash, tx);\n+    mempool.addUnchecked(tx, 0);\n     BOOST_CHECK(pblocktemplate = CreateNewBlock(reservekey));\n     delete pblocktemplate;\n     mempool.clear();\n@@ -165,30 +159,29 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].nValue = 4900000000LL;\n     script = CScript() << OP_0;\n     tx.vout[0].scriptPubKey.SetDestination(script.GetID());\n-    hash = tx.GetHash();\n-    mempool.addUnchecked(hash, tx);\n-    tx.vin[0].prevout.hash = hash;\n+    mempool.addUnchecked(tx, 0);\n+    tx.vin[0].prevout.hash = tx.GetHash();\n     tx.vin[0].scriptSig = CScript() << (std::vector<unsigned char>)script;\n     tx.vout[0].nValue -= 1000000;\n-    hash = tx.GetHash();\n-    mempool.addUnchecked(hash,tx);\n+    mempool.addUnchecked(tx, 0);\n     BOOST_CHECK(pblocktemplate = CreateNewBlock(reservekey));\n     delete pblocktemplate;\n     mempool.clear();\n \n     // double spend txn pair in mempool\n+    // disabled: not supported by current mempool\n+#if 0\n     tx.vin[0].prevout.hash = txFirst[0]->GetHash();\n     tx.vin[0].scriptSig = CScript() << OP_1;\n     tx.vout[0].nValue = 4900000000LL;\n     tx.vout[0].scriptPubKey = CScript() << OP_1;\n-    hash = tx.GetHash();\n-    mempool.addUnchecked(hash, tx);\n+    mempool.addUnchecked(tx, 0);\n     tx.vout[0].scriptPubKey = CScript() << OP_2;\n-    hash = tx.GetHash();\n-    mempool.addUnchecked(hash, tx);\n+    mempool.addUnchecked(tx, 0);\n     BOOST_CHECK(pblocktemplate = CreateNewBlock(reservekey));\n     delete pblocktemplate;\n     mempool.clear();\n+#endif\n \n     // subsidy changing\n     int nHeight = pindexBest->nHeight;"
      }
    ]
  },
  {
    "sha": "3e1aabd50c64cc5aeb49d0cd05c4fe6bfc42ce5c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozZTFhYWJkNTBjNjRjYzVhZWI0OWQwY2QwNWM0ZmU2YmZjNDJjZTVj",
    "commit": {
      "author": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2013-07-04T15:21:09Z"
      },
      "committer": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2013-07-04T15:21:09Z"
      },
      "message": "n",
      "tree": {
        "sha": "f50a5d4b7030d932e3a166488fc55daf2605a6d9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f50a5d4b7030d932e3a166488fc55daf2605a6d9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3e1aabd50c64cc5aeb49d0cd05c4fe6bfc42ce5c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3e1aabd50c64cc5aeb49d0cd05c4fe6bfc42ce5c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3e1aabd50c64cc5aeb49d0cd05c4fe6bfc42ce5c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3e1aabd50c64cc5aeb49d0cd05c4fe6bfc42ce5c/comments",
    "author": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dac0995713873484cf14bbd1543be027a020beaa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dac0995713873484cf14bbd1543be027a020beaa",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dac0995713873484cf14bbd1543be027a020beaa"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 4,
      "deletions": 2
    },
    "files": [
      {
        "sha": "f3621b464474ee8886f56cbd3af47170cc560de3",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e1aabd50c64cc5aeb49d0cd05c4fe6bfc42ce5c/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e1aabd50c64cc5aeb49d0cd05c4fe6bfc42ce5c/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=3e1aabd50c64cc5aeb49d0cd05c4fe6bfc42ce5c",
        "patch": "@@ -1133,7 +1133,7 @@ void CTxMemPool::updatePriorities(std::set<uint256> &setChangedHashes)\n         std::swap(dirty, next_dirty);\n     }\n \n-    printf(\"CTxMemPool::updatePriorities() : updated priorities for %d transactions\", n);\n+    printf(\"CTxMemPool::updatePriorities() : updated priorities for %d transactions\\n\", n);\n }\n \n void CTxMemPool::clear()"
      },
      {
        "sha": "ac07449a76e6f618237f37bdafc1a23572276dce",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e1aabd50c64cc5aeb49d0cd05c4fe6bfc42ce5c/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e1aabd50c64cc5aeb49d0cd05c4fe6bfc42ce5c/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=3e1aabd50c64cc5aeb49d0cd05c4fe6bfc42ce5c",
        "patch": "@@ -1096,7 +1096,8 @@ class CMemPoolTx : public CTransaction\n         assert(nSumTxSize >= 0);\n \n         if (nSumTxSize > 0)\n-            return (double)nSumTxFees / ((double)nSumTxSize/1000);\n+            // The +1 makes the order meaningful even for zero-fee txs\n+            return (double)(nSumTxFees+1) / ((double)nSumTxSize/1000);\n         else\n             return 0;\n     }"
      },
      {
        "sha": "a0baf266d22cc23e9e07b794ed96340d146008a5",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e1aabd50c64cc5aeb49d0cd05c4fe6bfc42ce5c/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e1aabd50c64cc5aeb49d0cd05c4fe6bfc42ce5c/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=3e1aabd50c64cc5aeb49d0cd05c4fe6bfc42ce5c",
        "patch": "@@ -130,6 +130,7 @@ Value getrawmempool(const Array& params, bool fHelp)\n \n         CMemPoolTx &tx = *(mempool.mapTx[hash]);\n \n+        rtx.push_back(Pair(\"priority\",tx.priority()));\n         rtx.push_back(Pair(\"nFees\",(boost::int64_t)tx.nFees));\n         rtx.push_back(Pair(\"nDepth\",(boost::int64_t)tx.nDepth));\n         rtx.push_back(Pair(\"nSumTxFees\",(boost::int64_t)tx.nSumTxFees));"
      }
    ]
  },
  {
    "sha": "584c5963412effab498fdcb42280fb3265759a00",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ODRjNTk2MzQxMmVmZmFiNDk4ZmRjYjQyMjgwZmIzMjY1NzU5YTAw",
    "commit": {
      "author": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2013-07-15T04:40:26Z"
      },
      "committer": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2013-07-15T04:40:26Z"
      },
      "message": "n2",
      "tree": {
        "sha": "44e9a7dc2c353e91ab098a6f74d8e581f1b17576",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/44e9a7dc2c353e91ab098a6f74d8e581f1b17576"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/584c5963412effab498fdcb42280fb3265759a00",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/584c5963412effab498fdcb42280fb3265759a00",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/584c5963412effab498fdcb42280fb3265759a00",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/584c5963412effab498fdcb42280fb3265759a00/comments",
    "author": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3e1aabd50c64cc5aeb49d0cd05c4fe6bfc42ce5c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3e1aabd50c64cc5aeb49d0cd05c4fe6bfc42ce5c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3e1aabd50c64cc5aeb49d0cd05c4fe6bfc42ce5c"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 13,
      "deletions": 0
    },
    "files": [
      {
        "sha": "ac04594aaa0ed46a91f3b3461d5528e1fff1d8c5",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/584c5963412effab498fdcb42280fb3265759a00/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/584c5963412effab498fdcb42280fb3265759a00/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=584c5963412effab498fdcb42280fb3265759a00",
        "patch": "@@ -950,6 +950,19 @@ void CMemPoolTx::calcPrioritySums(const CTxMemPool &mempool)\n     nSumTxFees = nFees;\n     nDepth = 1;\n \n+    // FIXME: shouldn't change sums unless we're at a higher priority than our\n+    // parent, otherwise we're essentially free-riding on their priority\n+    //\n+    // So logic should be if we have a higher priority than any parent, then we\n+    // can sum parent fees.\n+    //\n+    // Idea: have a -debugcreateblock flag that can dump the mempool to a log\n+    // file so that the createnewblock decisions can be analyzed after the\n+    // fact.\n+    //\n+    // Idea2: have a -changemempooltxfee, like luke did, to bump up fees for\n+    // transactions artificially.\n+\n     LOCK(mempool.cs);\n     int64 max_parent_fees = 0;\n     BOOST_FOREACH(const CTxIn txin, this->vin){"
      }
    ]
  }
]