NaruFGT,2012-10-25T05:11:03Z,I'd love to see this functionality in the mainstream client.\nDoes anybody know the history of the uint256 structure? I've never heard of that type of hash. I know it's used in signmessage and verifymessage but options for other hash types (possibly enumerated with another argument to sign/verify) might help more people trust the signatures.\n,https://github.com/bitcoin/bitcoin/pull/1957#issuecomment-9766292,9766292,
laanwj,2012-10-25T06:39:24Z,"I'm not against this functionality per-ce, but I don't like to have it in the core. We already suffer from some feature bloat.\n\nI suggest implementing it as an external tool that hashes your file, then signs the resulting hash using the existing `signmessage` call. This keeps everything nice and contained.\n",https://github.com/bitcoin/bitcoin/pull/1957#issuecomment-9767563,9767563,
NaruFGT,2012-10-25T06:55:31Z,"It's a core feature and would benefit many transactions, with a fix on file size limitation (loading the entire file into ram isn't good for performance and scalability) this feature really deserves a position in the main branch.\nAn external tool will lead to lack of addoption and frankly, this feature is far more critical in corperate and business enviroments than a message signature.\nFeature b",https://github.com/bitcoin/bitcoin/pull/1957#issuecomment-9767817,9767817,
laanwj,2012-10-25T07:19:26Z,"It's easy to hash a file in a streaming fashion, you certainly don't need to read it into ram.\n\nAlso you don't need new RPC server calls for this. You can use the existing signmessage/verifymessage RPCs with the hash of the file (and maybe some added salt) as message. You could even generalize it to multiple files by signing a ""manifest"" (similar to how JAR files are signed). As an added bonus, ",https://github.com/bitcoin/bitcoin/pull/1957#issuecomment-9768187,9768187,
NaruFGT,2012-10-25T08:36:26Z,"""Also you don't need new RPC server calls for this.""\nWe actually do, I personally won't trust a hash of a hash. Overloading the signmessage/verifymessage to have an option would be fine, but the feature has to implement the signature hash as a direct hash of the file.\n\nThe signmessage/verifymessage can be done outside of the core as well. This feature needs to be included into the core because ",https://github.com/bitcoin/bitcoin/pull/1957#issuecomment-9769860,9769860,
sipa,2012-10-25T08:43:27Z,"There is no security difference between using a hash, or using a hash of a hash (there's at most a 0.66 bit decrease in entropy, which makes brute-forcing a collision about 1.26 times faster on average). Given the fact that we're already using double-SHA256 for POW and blockids and txids, you should start worrying about Bitcoin's crypto in general then too.\n",https://github.com/bitcoin/bitcoin/pull/1957#issuecomment-9770048,9770048,
NaruFGT,2012-10-25T08:46:59Z,"sipa do you have details about the signmessage/verifymessage uint256 structure and the hash function?\n\nReally the point is that it's a messy implementation, and adds calculation overhead. It can and should be avoided, unless there's a reason we should use hash of a hash.\n",https://github.com/bitcoin/bitcoin/pull/1957#issuecomment-9770138,9770138,
sipa,2012-10-25T08:52:10Z,"The hash function is double-SHA256(""Bitcoin signed message: "" + message). The result of this is stored in a uint256 data type (and unsigned 256-bit integer). It is signed using ECDSA, encoded in a 65-byte structure that allows recovery of the public key. This 65-byte structure is then encoded in base64.\n",https://github.com/bitcoin/bitcoin/pull/1957#issuecomment-9770244,9770244,
robbak,2012-10-25T09:00:20Z,"On 25 October 2012 18:36, NaruFGT notifications@github.com wrote:\n\n> ""Also you don't need new RPC server calls for this.""\n> We actually do, I personally won't trust a hash of a hash. Overloading the\n> signmessage/verifymessage to have an option would be fine, but the feature\n> has to implement the signature hash as a direct hash of the file.\n> \n> The signmessage/verifymessage can be done ou",https://github.com/bitcoin/bitcoin/pull/1957#issuecomment-9770468,9770468,
laanwj,2012-10-25T09:02:38Z,"In addition to that, the whole Merkle tree concept used throughout bitcoin is based on hashes of hashes (of hashes...). Also many code signing approaches rely on hashes of (groups of) hashes, such as the JAR signing I mentioned. Not trusting hashes of hashes is quite irrational. That's ok, we're all paranoid in our own way, but I do recommend learning somewhat more about how Bitcoin works before m",https://github.com/bitcoin/bitcoin/pull/1957#issuecomment-9770535,9770535,
sipa,2012-10-25T09:03:27Z,"@robbak The reason for this method was having the ability to sign messages with keys corresponding to Bitcoin addresses, so one can prove ownership of coins, or prove being the sender of a transaction.\n\nI do agree it doesn't need to do more than what it can already - it just has to core functionality, other use cases can be implemented on top of it.\n",https://github.com/bitcoin/bitcoin/pull/1957#issuecomment-9770566,9770566,
dparrish,2012-10-25T09:13:39Z,"This is why I asked if this was the best way! Discussion is good.\n\nI'd still really like to see a ""standardized"" way of signing files with my bitcoin key, but I agree the API doesn't really need to be any bigger than it is. How about keeping ""signfile"" and ""verifyfile"" as client-side calls that generate a hash of the file that's sent to the server for re-hashing and signing. I think _something_ ",https://github.com/bitcoin/bitcoin/pull/1957#issuecomment-9770839,9770839,
NaruFGT,2012-10-25T09:15:48Z,"""It is signed using ECDSA, encoded in a 65-byte structure that allows recovery of the public key. This 65-byte structure is then encoded in base64.""\nIn this case can a file signature be done in openssl simply using the address private key? That would be standard easy to adopt.\n",https://github.com/bitcoin/bitcoin/pull/1957#issuecomment-9770890,9770890,
sipa,2012-10-28T19:24:01Z,"@NaruFGT sorry, there are no standard encodings that have all necessary data for public key recovery from a signature, so we had to invent our own.\n",https://github.com/bitcoin/bitcoin/pull/1957#issuecomment-9849312,9849312,
gavinandresen,2012-10-29T19:58:10Z,NACK.\n\nI agred that this is feature-creep.\n\nI think this would be much better implemented as a little python or shell script shipped in the contrib/ directory that computed a hash for the file and then called signmessage.\n,https://github.com/bitcoin/bitcoin/pull/1957#issuecomment-9883090,9883090,
BitcoinPullTester,2012-10-30T12:23:53Z,"Automatic sanity-testing: FAILED MERGE, see http://jenkins.bluematt.me/pull-tester/a7b0f3829e30d43632e2bf342631d011c6ddb270 for test log.\n\nThis pull does not merge cleanly onto current master\n",https://github.com/bitcoin/bitcoin/pull/1957#issuecomment-9903634,9903634,
jgarzik,2012-11-16T02:30:43Z,"One explicit NAK, and two ""OK but not in core"" seeming NAKs.  Closing.\n\nPerhaps consider an external utility that does this; look a ""test_bitcoin"" for an example of a non-bitcoind binary that uses core bitcoin data structures.\n",https://github.com/bitcoin/bitcoin/pull/1957#issuecomment-10434566,10434566,
Diapolo,2012-10-25T06:33:34Z,"What happens, if someone tries to feed a >2GB file to this :)?\n",https://github.com/bitcoin/bitcoin/pull/1957#discussion_r1937579,1937579,src/bitcoinrpc.cpp
Diapolo,2012-10-25T06:35:26Z,"This seems like a fix unrelated to this pull, which is also part of another currently open pull.\n",https://github.com/bitcoin/bitcoin/pull/1957#discussion_r1937592,1937592,src/init.cpp
dparrish,2012-10-25T09:10:00Z,"That was an oversight, I'll make this read chunks and hash as it goes.\n",https://github.com/bitcoin/bitcoin/pull/1957#discussion_r1938572,1938572,src/bitcoinrpc.cpp
dparrish,2012-10-25T09:14:39Z,"Yes, that shouldn't be there. Whoops.\n",https://github.com/bitcoin/bitcoin/pull/1957#discussion_r1938612,1938612,src/init.cpp
