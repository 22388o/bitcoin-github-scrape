[
  {
    "sha": "916e0b2f90819968cc27d11b7113de0a3957286d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MTZlMGIyZjkwODE5OTY4Y2MyN2QxMWI3MTEzZGUwYTM5NTcyODZk",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2017-09-19T08:39:08Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2017-09-21T12:33:19Z"
      },
      "message": "doc: Document locks - increase LOCK(...) comment coverage from 2 % to 77 %",
      "tree": {
        "sha": "101d3e539ebebe1ec1c89625aa4591e027d0b422",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/101d3e539ebebe1ec1c89625aa4591e027d0b422"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/916e0b2f90819968cc27d11b7113de0a3957286d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/916e0b2f90819968cc27d11b7113de0a3957286d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/916e0b2f90819968cc27d11b7113de0a3957286d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/916e0b2f90819968cc27d11b7113de0a3957286d/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "98212745c8acb5cc4e688bbb3979bfd46b25f98a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/98212745c8acb5cc4e688bbb3979bfd46b25f98a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/98212745c8acb5cc4e688bbb3979bfd46b25f98a"
      }
    ],
    "stats": {
      "total": 808,
      "additions": 406,
      "deletions": 402
    },
    "files": [
      {
        "sha": "6951f3d0a360bea5ee8f6c43cb9617666f354ad9",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -350,7 +350,7 @@ class CAddrMan\n     template<typename Stream>\n     void Unserialize(Stream& s)\n     {\n-        LOCK(cs);\n+        LOCK(cs); // vRandom\n \n         Clear();\n \n@@ -489,7 +489,8 @@ class CAddrMan\n     //! Return the number of (unique) addresses in all tables.\n     size_t size() const\n     {\n-        LOCK(cs); // TODO: Cache this in an atomic to avoid this overhead\n+        // TODO: Cache this in an atomic to avoid this overhead\n+        LOCK(cs); // vRandom\n         return vRandom.size();\n     }\n "
      },
      {
        "sha": "60ae8621c96fd49403f01eb24ff4185da38b9fba",
        "filename": "src/blockencodings.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/blockencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/blockencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -103,7 +103,7 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n \n     std::vector<bool> have_txn(txn_available.size());\n     {\n-    LOCK(pool->cs);\n+    LOCK(pool->cs); // vTxHashes\n     const std::vector<std::pair<uint256, CTxMemPool::txiter> >& vTxHashes = pool->vTxHashes;\n     for (size_t i = 0; i < vTxHashes.size(); i++) {\n         uint64_t shortid = cmpctblock.GetShortID(vTxHashes[i].first);"
      },
      {
        "sha": "1962a6ba14d5f1e45a1bbf3f2d5d723212efa313",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -17,7 +17,7 @@ bool CBasicKeyStore::GetPubKey(const CKeyID &address, CPubKey &vchPubKeyOut) con\n {\n     CKey key;\n     if (!GetKey(address, key)) {\n-        LOCK(cs_KeyStore);\n+        LOCK(cs_KeyStore); // mapWatchKeys\n         WatchKeyMap::const_iterator it = mapWatchKeys.find(address);\n         if (it != mapWatchKeys.end()) {\n             vchPubKeyOut = it->second;\n@@ -31,7 +31,7 @@ bool CBasicKeyStore::GetPubKey(const CKeyID &address, CPubKey &vchPubKeyOut) con\n \n bool CBasicKeyStore::AddKeyPubKey(const CKey& key, const CPubKey &pubkey)\n {\n-    LOCK(cs_KeyStore);\n+    LOCK(cs_KeyStore); // mapKeys\n     mapKeys[pubkey.GetID()] = key;\n     return true;\n }\n@@ -41,20 +41,20 @@ bool CBasicKeyStore::AddCScript(const CScript& redeemScript)\n     if (redeemScript.size() > MAX_SCRIPT_ELEMENT_SIZE)\n         return error(\"CBasicKeyStore::AddCScript(): redeemScripts > %i bytes are invalid\", MAX_SCRIPT_ELEMENT_SIZE);\n \n-    LOCK(cs_KeyStore);\n+    LOCK(cs_KeyStore); // mapScripts\n     mapScripts[CScriptID(redeemScript)] = redeemScript;\n     return true;\n }\n \n bool CBasicKeyStore::HaveCScript(const CScriptID& hash) const\n {\n-    LOCK(cs_KeyStore);\n+    LOCK(cs_KeyStore); // mapScripts\n     return mapScripts.count(hash) > 0;\n }\n \n bool CBasicKeyStore::GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const\n {\n-    LOCK(cs_KeyStore);\n+    LOCK(cs_KeyStore); // mapScripts\n     ScriptMap::const_iterator mi = mapScripts.find(hash);\n     if (mi != mapScripts.end())\n     {\n@@ -82,7 +82,7 @@ static bool ExtractPubKey(const CScript &dest, CPubKey& pubKeyOut)\n \n bool CBasicKeyStore::AddWatchOnly(const CScript &dest)\n {\n-    LOCK(cs_KeyStore);\n+    LOCK(cs_KeyStore); // mapWatchKeys, setWatchOnly\n     setWatchOnly.insert(dest);\n     CPubKey pubKey;\n     if (ExtractPubKey(dest, pubKey))\n@@ -92,7 +92,7 @@ bool CBasicKeyStore::AddWatchOnly(const CScript &dest)\n \n bool CBasicKeyStore::RemoveWatchOnly(const CScript &dest)\n {\n-    LOCK(cs_KeyStore);\n+    LOCK(cs_KeyStore); // mapWatchKeys, setWatchOnly\n     setWatchOnly.erase(dest);\n     CPubKey pubKey;\n     if (ExtractPubKey(dest, pubKey))\n@@ -102,12 +102,12 @@ bool CBasicKeyStore::RemoveWatchOnly(const CScript &dest)\n \n bool CBasicKeyStore::HaveWatchOnly(const CScript &dest) const\n {\n-    LOCK(cs_KeyStore);\n+    LOCK(cs_KeyStore); // setWatchOnly\n     return setWatchOnly.count(dest) > 0;\n }\n \n bool CBasicKeyStore::HaveWatchOnly() const\n {\n-    LOCK(cs_KeyStore);\n+    LOCK(cs_KeyStore); // setWatchOnly\n     return (!setWatchOnly.empty());\n }"
      },
      {
        "sha": "0436c3424a942f0abbd7d7e7ee18ba0cef8684d8",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -66,14 +66,14 @@ class CBasicKeyStore : public CKeyStore\n     {\n         bool result;\n         {\n-            LOCK(cs_KeyStore);\n+            LOCK(cs_KeyStore); // mapKeys\n             result = (mapKeys.count(address) > 0);\n         }\n         return result;\n     }\n     std::set<CKeyID> GetKeys() const override\n     {\n-        LOCK(cs_KeyStore);\n+        LOCK(cs_KeyStore); // mapKeys\n         std::set<CKeyID> set_address;\n         for (const auto& mi : mapKeys) {\n             set_address.insert(mi.first);\n@@ -83,7 +83,7 @@ class CBasicKeyStore : public CKeyStore\n     bool GetKey(const CKeyID &address, CKey &keyOut) const override\n     {\n         {\n-            LOCK(cs_KeyStore);\n+            LOCK(cs_KeyStore); // mapKeys\n             KeyMap::const_iterator mi = mapKeys.find(address);\n             if (mi != mapKeys.end())\n             {"
      },
      {
        "sha": "5bbf88770024612b98adfe7d80afb9177fcab49d",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -123,7 +123,7 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n     pblocktemplate->vTxFees.push_back(-1); // updated at end\n     pblocktemplate->vTxSigOpsCost.push_back(-1); // updated at end\n \n-    LOCK2(cs_main, mempool.cs);\n+    LOCK2(cs_main, mempool.cs); // chainActive\n     CBlockIndex* pindexPrev = chainActive.Tip();\n     assert(pindexPrev != nullptr);\n     nHeight = pindexPrev->nHeight + 1;"
      },
      {
        "sha": "e7cf74545f2e4410a571042a2ae3858929be8b99",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 78,
        "deletions": 78,
        "changes": 156,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -91,7 +91,7 @@ limitedmap<uint256, int64_t> mapAlreadyAskedFor(MAX_INV_SZ);\n \n void CConnman::AddOneShot(const std::string& strDest)\n {\n-    LOCK(cs_vOneShots);\n+    LOCK(cs_vOneShots); // vOneShots\n     vOneShots.push_back(strDest);\n }\n \n@@ -109,7 +109,7 @@ bool GetLocal(CService& addr, const CNetAddr *paddrPeer)\n     int nBestScore = -1;\n     int nBestReachability = -1;\n     {\n-        LOCK(cs_mapLocalHost);\n+        LOCK(cs_mapLocalHost); // mapLocalHost\n         for (std::map<CNetAddr, LocalServiceInfo>::iterator it = mapLocalHost.begin(); it != mapLocalHost.end(); it++)\n         {\n             int nScore = (*it).second.nScore;\n@@ -163,7 +163,7 @@ CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices)\n \n int GetnScore(const CService& addr)\n {\n-    LOCK(cs_mapLocalHost);\n+    LOCK(cs_mapLocalHost); // mapLocalHost\n     if (mapLocalHost.count(addr) == LOCAL_NONE)\n         return 0;\n     return mapLocalHost[addr].nScore;\n@@ -215,7 +215,7 @@ bool AddLocal(const CService& addr, int nScore)\n     LogPrintf(\"AddLocal(%s,%i)\\n\", addr.ToString(), nScore);\n \n     {\n-        LOCK(cs_mapLocalHost);\n+        LOCK(cs_mapLocalHost); // mapLocalHost\n         bool fAlready = mapLocalHost.count(addr) > 0;\n         LocalServiceInfo &info = mapLocalHost[addr];\n         if (!fAlready || nScore >= info.nScore) {\n@@ -234,7 +234,7 @@ bool AddLocal(const CNetAddr &addr, int nScore)\n \n bool RemoveLocal(const CService& addr)\n {\n-    LOCK(cs_mapLocalHost);\n+    LOCK(cs_mapLocalHost); // mapLocalHost\n     LogPrintf(\"RemoveLocal(%s)\\n\", addr.ToString());\n     mapLocalHost.erase(addr);\n     return true;\n@@ -245,13 +245,13 @@ void SetLimited(enum Network net, bool fLimited)\n {\n     if (net == NET_UNROUTABLE || net == NET_INTERNAL)\n         return;\n-    LOCK(cs_mapLocalHost);\n+    LOCK(cs_mapLocalHost); // vfLimited\n     vfLimited[net] = fLimited;\n }\n \n bool IsLimited(enum Network net)\n {\n-    LOCK(cs_mapLocalHost);\n+    LOCK(cs_mapLocalHost); // vfLimited\n     return vfLimited[net];\n }\n \n@@ -264,7 +264,7 @@ bool IsLimited(const CNetAddr &addr)\n bool SeenLocal(const CService& addr)\n {\n     {\n-        LOCK(cs_mapLocalHost);\n+        LOCK(cs_mapLocalHost); // mapLocalHost\n         if (mapLocalHost.count(addr) == 0)\n             return false;\n         mapLocalHost[addr].nScore++;\n@@ -276,14 +276,14 @@ bool SeenLocal(const CService& addr)\n /** check whether a given address is potentially local */\n bool IsLocal(const CService& addr)\n {\n-    LOCK(cs_mapLocalHost);\n+    LOCK(cs_mapLocalHost); // mapLocalHost\n     return mapLocalHost.count(addr) > 0;\n }\n \n /** check whether a given network is one we can probably connect to */\n bool IsReachable(enum Network net)\n {\n-    LOCK(cs_mapLocalHost);\n+    LOCK(cs_mapLocalHost); // vfLimited\n     return !vfLimited[net];\n }\n \n@@ -297,7 +297,7 @@ bool IsReachable(const CNetAddr& addr)\n \n CNode* CConnman::FindNode(const CNetAddr& ip)\n {\n-    LOCK(cs_vNodes);\n+    LOCK(cs_vNodes); // vNodes\n     for (CNode* pnode : vNodes) {\n         if ((CNetAddr)pnode->addr == ip) {\n             return pnode;\n@@ -308,7 +308,7 @@ CNode* CConnman::FindNode(const CNetAddr& ip)\n \n CNode* CConnman::FindNode(const CSubNet& subNet)\n {\n-    LOCK(cs_vNodes);\n+    LOCK(cs_vNodes); // vNodes\n     for (CNode* pnode : vNodes) {\n         if (subNet.Match((CNetAddr)pnode->addr)) {\n             return pnode;\n@@ -319,7 +319,7 @@ CNode* CConnman::FindNode(const CSubNet& subNet)\n \n CNode* CConnman::FindNode(const std::string& addrName)\n {\n-    LOCK(cs_vNodes);\n+    LOCK(cs_vNodes); // vNodes\n     for (CNode* pnode : vNodes) {\n         if (pnode->GetAddrName() == addrName) {\n             return pnode;\n@@ -330,7 +330,7 @@ CNode* CConnman::FindNode(const std::string& addrName)\n \n CNode* CConnman::FindNode(const CService& addr)\n {\n-    LOCK(cs_vNodes);\n+    LOCK(cs_vNodes); // vNodes\n     for (CNode* pnode : vNodes) {\n         if ((CService)pnode->addr == addr) {\n             return pnode;\n@@ -341,7 +341,7 @@ CNode* CConnman::FindNode(const CService& addr)\n \n bool CConnman::CheckIncomingNonce(uint64_t nonce)\n {\n-    LOCK(cs_vNodes);\n+    LOCK(cs_vNodes); // vNodes\n     for (CNode* pnode : vNodes) {\n         if (!pnode->fSuccessfullyConnected && !pnode->fInbound && pnode->GetLocalNonce() == nonce)\n             return false;\n@@ -456,7 +456,7 @@ void CConnman::DumpBanlist()\n void CNode::CloseSocketDisconnect()\n {\n     fDisconnect = true;\n-    LOCK(cs_hSocket);\n+    LOCK(cs_hSocket); // hSocket\n     if (hSocket != INVALID_SOCKET)\n     {\n         LogPrint(BCLog::NET, \"disconnecting peer=%d\\n\", id);\n@@ -467,7 +467,7 @@ void CNode::CloseSocketDisconnect()\n void CConnman::ClearBanned()\n {\n     {\n-        LOCK(cs_setBanned);\n+        LOCK(cs_setBanned); // setBannedIsDirty, setBanned\n         setBanned.clear();\n         setBannedIsDirty = true;\n     }\n@@ -478,7 +478,7 @@ void CConnman::ClearBanned()\n \n bool CConnman::IsBanned(CNetAddr ip)\n {\n-    LOCK(cs_setBanned);\n+    LOCK(cs_setBanned); // setBanned\n     for (const auto& it : setBanned) {\n         CSubNet subNet = it.first;\n         CBanEntry banEntry = it.second;\n@@ -492,7 +492,7 @@ bool CConnman::IsBanned(CNetAddr ip)\n \n bool CConnman::IsBanned(CSubNet subnet)\n {\n-    LOCK(cs_setBanned);\n+    LOCK(cs_setBanned); // setBanned\n     banmap_t::iterator i = setBanned.find(subnet);\n     if (i != setBanned.end())\n     {\n@@ -520,7 +520,7 @@ void CConnman::Ban(const CSubNet& subNet, const BanReason &banReason, int64_t ba\n     banEntry.nBanUntil = (sinceUnixEpoch ? 0 : GetTime() )+bantimeoffset;\n \n     {\n-        LOCK(cs_setBanned);\n+        LOCK(cs_setBanned); // setBannedIsDirty, setBanned\n         if (setBanned[subNet].nBanUntil < banEntry.nBanUntil) {\n             setBanned[subNet] = banEntry;\n             setBannedIsDirty = true;\n@@ -531,7 +531,7 @@ void CConnman::Ban(const CSubNet& subNet, const BanReason &banReason, int64_t ba\n     if(clientInterface)\n         clientInterface->BannedListChanged();\n     {\n-        LOCK(cs_vNodes);\n+        LOCK(cs_vNodes); // vNodes\n         for (CNode* pnode : vNodes) {\n             if (subNet.Match((CNetAddr)pnode->addr))\n                 pnode->fDisconnect = true;\n@@ -548,7 +548,7 @@ bool CConnman::Unban(const CNetAddr &addr) {\n \n bool CConnman::Unban(const CSubNet &subNet) {\n     {\n-        LOCK(cs_setBanned);\n+        LOCK(cs_setBanned); // setBannedIsDirty, setBanned\n         if (!setBanned.erase(subNet))\n             return false;\n         setBannedIsDirty = true;\n@@ -561,15 +561,15 @@ bool CConnman::Unban(const CSubNet &subNet) {\n \n void CConnman::GetBanned(banmap_t &banMap)\n {\n-    LOCK(cs_setBanned);\n+    LOCK(cs_setBanned); // setBanned\n     // Sweep the banlist so expired bans are not returned\n     SweepBanned();\n     banMap = setBanned; //create a thread safe copy\n }\n \n void CConnman::SetBanned(const banmap_t &banMap)\n {\n-    LOCK(cs_setBanned);\n+    LOCK(cs_setBanned); // setBannedIsDirty, setBanned\n     setBanned = banMap;\n     setBannedIsDirty = true;\n }\n@@ -578,7 +578,7 @@ void CConnman::SweepBanned()\n {\n     int64_t now = GetTime();\n \n-    LOCK(cs_setBanned);\n+    LOCK(cs_setBanned); // setBannedIsDirty, setBanned\n     banmap_t::iterator it = setBanned.begin();\n     while(it != setBanned.end())\n     {\n@@ -597,13 +597,13 @@ void CConnman::SweepBanned()\n \n bool CConnman::BannedSetIsDirty()\n {\n-    LOCK(cs_setBanned);\n+    LOCK(cs_setBanned); // setBannedIsDirty\n     return setBannedIsDirty;\n }\n \n void CConnman::SetBannedSetDirty(bool dirty)\n {\n-    LOCK(cs_setBanned); //reuse setBanned lock for the isDirty flag\n+    LOCK(cs_setBanned); // setBannedIsDirty\n     setBannedIsDirty = dirty;\n }\n \n@@ -617,24 +617,24 @@ bool CConnman::IsWhitelistedRange(const CNetAddr &addr) {\n }\n \n std::string CNode::GetAddrName() const {\n-    LOCK(cs_addrName);\n+    LOCK(cs_addrName); // addrName\n     return addrName;\n }\n \n void CNode::MaybeSetAddrName(const std::string& addrNameIn) {\n-    LOCK(cs_addrName);\n+    LOCK(cs_addrName); // addrName\n     if (addrName.empty()) {\n         addrName = addrNameIn;\n     }\n }\n \n CService CNode::GetAddrLocal() const {\n-    LOCK(cs_addrLocal);\n+    LOCK(cs_addrLocal); // addrLocal\n     return addrLocal;\n }\n \n void CNode::SetAddrLocal(const CService& addrLocalIn) {\n-    LOCK(cs_addrLocal);\n+    LOCK(cs_addrLocal); // addrLocal\n     if (addrLocal.IsValid()) {\n         error(\"Addr local already set for node: %i. Refusing to change from %s to %s\", id, addrLocal.ToString(), addrLocalIn.ToString());\n     } else {\n@@ -651,7 +651,7 @@ void CNode::copyStats(CNodeStats &stats)\n     X(addr);\n     X(addrBind);\n     {\n-        LOCK(cs_filter);\n+        LOCK(cs_filter); // fRelayTxes\n         X(fRelayTxes);\n     }\n     X(nLastSend);\n@@ -661,19 +661,19 @@ void CNode::copyStats(CNodeStats &stats)\n     stats.addrName = GetAddrName();\n     X(nVersion);\n     {\n-        LOCK(cs_SubVer);\n+        LOCK(cs_SubVer); // cleanSubVer\n         X(cleanSubVer);\n     }\n     X(fInbound);\n     X(fAddnode);\n     X(nStartingHeight);\n     {\n-        LOCK(cs_vSend);\n+        LOCK(cs_vSend); // nSendBytes, mapSendBytesPerMsgCmd\n         X(mapSendBytesPerMsgCmd);\n         X(nSendBytes);\n     }\n     {\n-        LOCK(cs_vRecv);\n+        LOCK(cs_vRecv); // mapRecvBytesPerMsgCmd, nRecvBytes\n         X(mapRecvBytesPerMsgCmd);\n         X(nRecvBytes);\n     }\n@@ -705,7 +705,7 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes, bool& complete\n {\n     complete = false;\n     int64_t nTimeMicros = GetTimeMicros();\n-    LOCK(cs_vRecv);\n+    LOCK(cs_vRecv); // mapRecvBytesPerMsgCmd, nRecvBytes\n     nLastRecv = nTimeMicros / 1000000;\n     nRecvBytes += nBytes;\n     while (nBytes > 0) {\n@@ -855,7 +855,7 @@ size_t CConnman::SocketSendData(CNode *pnode) const\n         assert(data.size() > pnode->nSendOffset);\n         int nBytes = 0;\n         {\n-            LOCK(pnode->cs_hSocket);\n+            LOCK(pnode->cs_hSocket); // hSocket\n             if (pnode->hSocket == INVALID_SOCKET)\n                 break;\n             nBytes = send(pnode->hSocket, reinterpret_cast<const char*>(data.data()) + pnode->nSendOffset, data.size() - pnode->nSendOffset, MSG_NOSIGNAL | MSG_DONTWAIT);\n@@ -954,7 +954,7 @@ bool CConnman::AttemptToEvictConnection()\n {\n     std::vector<NodeEvictionCandidate> vEvictionCandidates;\n     {\n-        LOCK(cs_vNodes);\n+        LOCK(cs_vNodes); // vNodes\n \n         for (const CNode* node : vNodes) {\n             if (node->fWhitelisted)\n@@ -1033,7 +1033,7 @@ bool CConnman::AttemptToEvictConnection()\n \n     // Disconnect from the network group with the most connections\n     NodeId evicted = vEvictionCandidates.front().id;\n-    LOCK(cs_vNodes);\n+    LOCK(cs_vNodes); // vNodes\n     for (CNode* pnode : vNodes) {\n         if (pnode->GetId() == evicted) {\n             pnode->fDisconnect = true;\n@@ -1059,7 +1059,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n \n     bool whitelisted = hListenSocket.whitelisted || IsWhitelistedRange(addr);\n     {\n-        LOCK(cs_vNodes);\n+        LOCK(cs_vNodes); // vNodes\n         for (const CNode* pnode : vNodes) {\n             if (pnode->fInbound) nInbound++;\n         }\n@@ -1119,7 +1119,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     LogPrint(BCLog::NET, \"connection from %s accepted\\n\", addr.ToString());\n \n     {\n-        LOCK(cs_vNodes);\n+        LOCK(cs_vNodes); // vNodes\n         vNodes.push_back(pnode);\n     }\n }\n@@ -1133,7 +1133,7 @@ void CConnman::ThreadSocketHandler()\n         // Disconnect nodes\n         //\n         {\n-            LOCK(cs_vNodes);\n+            LOCK(cs_vNodes); // vNodes\n             // Disconnect unused nodes\n             std::vector<CNode*> vNodesCopy = vNodes;\n             for (CNode* pnode : vNodesCopy)\n@@ -1181,7 +1181,7 @@ void CConnman::ThreadSocketHandler()\n         }\n         size_t vNodesSize;\n         {\n-            LOCK(cs_vNodes);\n+            LOCK(cs_vNodes); // vNodes\n             vNodesSize = vNodes.size();\n         }\n         if(vNodesSize != nPrevNodeCount) {\n@@ -1213,7 +1213,7 @@ void CConnman::ThreadSocketHandler()\n         }\n \n         {\n-            LOCK(cs_vNodes);\n+            LOCK(cs_vNodes); // vNodes\n             for (CNode* pnode : vNodes)\n             {\n                 // Implement the following logic:\n@@ -1230,11 +1230,11 @@ void CConnman::ThreadSocketHandler()\n                 bool select_recv = !pnode->fPauseRecv;\n                 bool select_send;\n                 {\n-                    LOCK(pnode->cs_vSend);\n+                    LOCK(pnode->cs_vSend); // vSendMsg\n                     select_send = !pnode->vSendMsg.empty();\n                 }\n \n-                LOCK(pnode->cs_hSocket);\n+                LOCK(pnode->cs_hSocket); // hSocket\n                 if (pnode->hSocket == INVALID_SOCKET)\n                     continue;\n \n@@ -1288,7 +1288,7 @@ void CConnman::ThreadSocketHandler()\n         //\n         std::vector<CNode*> vNodesCopy;\n         {\n-            LOCK(cs_vNodes);\n+            LOCK(cs_vNodes); // vNodes\n             vNodesCopy = vNodes;\n             for (CNode* pnode : vNodesCopy)\n                 pnode->AddRef();\n@@ -1305,7 +1305,7 @@ void CConnman::ThreadSocketHandler()\n             bool sendSet = false;\n             bool errorSet = false;\n             {\n-                LOCK(pnode->cs_hSocket);\n+                LOCK(pnode->cs_hSocket); // hSocket\n                 if (pnode->hSocket == INVALID_SOCKET)\n                     continue;\n                 recvSet = FD_ISSET(pnode->hSocket, &fdsetRecv);\n@@ -1318,7 +1318,7 @@ void CConnman::ThreadSocketHandler()\n                 char pchBuf[0x10000];\n                 int nBytes = 0;\n                 {\n-                    LOCK(pnode->cs_hSocket);\n+                    LOCK(pnode->cs_hSocket); // hSocket\n                     if (pnode->hSocket == INVALID_SOCKET)\n                         continue;\n                     nBytes = recv(pnode->hSocket, pchBuf, sizeof(pchBuf), MSG_DONTWAIT);\n@@ -1338,7 +1338,7 @@ void CConnman::ThreadSocketHandler()\n                             nSizeAdded += it->vRecv.size() + CMessageHeader::HEADER_SIZE;\n                         }\n                         {\n-                            LOCK(pnode->cs_vProcessMsg);\n+                            LOCK(pnode->cs_vProcessMsg); // vProcessMsg\n                             pnode->vProcessMsg.splice(pnode->vProcessMsg.end(), pnode->vRecvMsg, pnode->vRecvMsg.begin(), it);\n                             pnode->nProcessQueueSize += nSizeAdded;\n                             pnode->fPauseRecv = pnode->nProcessQueueSize > nReceiveFloodSize;\n@@ -1372,7 +1372,7 @@ void CConnman::ThreadSocketHandler()\n             //\n             if (sendSet)\n             {\n-                LOCK(pnode->cs_vSend);\n+                LOCK(pnode->cs_vSend); // SocketSendData(...)\n                 size_t nBytes = SocketSendData(pnode);\n                 if (nBytes) {\n                     RecordBytesSent(nBytes);\n@@ -1579,7 +1579,7 @@ void CConnman::ThreadDNSAddressSeed()\n         if (!interruptNet.sleep_for(std::chrono::seconds(11)))\n             return;\n \n-        LOCK(cs_vNodes);\n+        LOCK(cs_vNodes); // vNodes\n         int nRelevant = 0;\n         for (auto pnode : vNodes) {\n             nRelevant += pnode->fSuccessfullyConnected && ((pnode->nServices & nRelevantServices) == nRelevantServices);\n@@ -1660,7 +1660,7 @@ void CConnman::ProcessOneShot()\n {\n     std::string strDest;\n     {\n-        LOCK(cs_vOneShots);\n+        LOCK(cs_vOneShots); // vOneShots\n         if (vOneShots.empty())\n             return;\n         strDest = vOneShots.front();\n@@ -1736,7 +1736,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n         int nOutboundRelevant = 0;\n         std::set<std::vector<unsigned char> > setConnected;\n         {\n-            LOCK(cs_vNodes);\n+            LOCK(cs_vNodes); // vNodes\n             for (CNode* pnode : vNodes) {\n                 if (!pnode->fInbound && !pnode->fAddnode) {\n \n@@ -1852,7 +1852,7 @@ std::vector<AddedNodeInfo> CConnman::GetAddedNodeInfo()\n \n     std::list<std::string> lAddresses(0);\n     {\n-        LOCK(cs_vAddedNodes);\n+        LOCK(cs_vAddedNodes); // vAddedNodes\n         ret.reserve(vAddedNodes.size());\n         std::copy(vAddedNodes.cbegin(), vAddedNodes.cend(), std::back_inserter(lAddresses));\n     }\n@@ -1862,7 +1862,7 @@ std::vector<AddedNodeInfo> CConnman::GetAddedNodeInfo()\n     std::map<CService, bool> mapConnected;\n     std::map<std::string, std::pair<bool, CService>> mapConnectedByName;\n     {\n-        LOCK(cs_vNodes);\n+        LOCK(cs_vNodes); // vNodes\n         for (const CNode* pnode : vNodes) {\n             if (pnode->addr.IsValid()) {\n                 mapConnected[pnode->addr] = pnode->fInbound;\n@@ -1901,7 +1901,7 @@ std::vector<AddedNodeInfo> CConnman::GetAddedNodeInfo()\n void CConnman::ThreadOpenAddedConnections()\n {\n     {\n-        LOCK(cs_vAddedNodes);\n+        LOCK(cs_vAddedNodes); // vAddedNodes\n         vAddedNodes = gArgs.GetArgs(\"-addnode\");\n     }\n \n@@ -1967,7 +1967,7 @@ bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFai\n \n     m_msgproc->InitializeNode(pnode);\n     {\n-        LOCK(cs_vNodes);\n+        LOCK(cs_vNodes); // vNodes\n         vNodes.push_back(pnode);\n     }\n \n@@ -1980,7 +1980,7 @@ void CConnman::ThreadMessageHandler()\n     {\n         std::vector<CNode*> vNodesCopy;\n         {\n-            LOCK(cs_vNodes);\n+            LOCK(cs_vNodes); // vNodes\n             vNodesCopy = vNodes;\n             for (CNode* pnode : vNodesCopy) {\n                 pnode->AddRef();\n@@ -2189,7 +2189,7 @@ void CConnman::SetNetworkActive(bool active)\n     fNetworkActive = active;\n \n     if (!fNetworkActive) {\n-        LOCK(cs_vNodes);\n+        LOCK(cs_vNodes); // vNodes\n         // Close sockets to all nodes\n         for (CNode* pnode : vNodes) {\n             pnode->CloseSocketDisconnect();\n@@ -2490,7 +2490,7 @@ std::vector<CAddress> CConnman::GetAddresses()\n \n bool CConnman::AddNode(const std::string& strNode)\n {\n-    LOCK(cs_vAddedNodes);\n+    LOCK(cs_vAddedNodes); // vAddedNodes\n     for (const std::string& it : vAddedNodes) {\n         if (strNode == it) return false;\n     }\n@@ -2501,7 +2501,7 @@ bool CConnman::AddNode(const std::string& strNode)\n \n bool CConnman::RemoveAddedNode(const std::string& strNode)\n {\n-    LOCK(cs_vAddedNodes);\n+    LOCK(cs_vAddedNodes); // vAddedNodes\n     for(std::vector<std::string>::iterator it = vAddedNodes.begin(); it != vAddedNodes.end(); ++it) {\n         if (strNode == *it) {\n             vAddedNodes.erase(it);\n@@ -2513,7 +2513,7 @@ bool CConnman::RemoveAddedNode(const std::string& strNode)\n \n size_t CConnman::GetNodeCount(NumConnections flags)\n {\n-    LOCK(cs_vNodes);\n+    LOCK(cs_vNodes); // vNodes\n     if (flags == CConnman::CONNECTIONS_ALL) // Shortcut if we want total\n         return vNodes.size();\n \n@@ -2530,7 +2530,7 @@ size_t CConnman::GetNodeCount(NumConnections flags)\n void CConnman::GetNodeStats(std::vector<CNodeStats>& vstats)\n {\n     vstats.clear();\n-    LOCK(cs_vNodes);\n+    LOCK(cs_vNodes); // vNodes\n     vstats.reserve(vNodes.size());\n     for (CNode* pnode : vNodes) {\n         vstats.emplace_back();\n@@ -2549,7 +2549,7 @@ bool CConnman::DisconnectNode(const std::string& strNode)\n }\n bool CConnman::DisconnectNode(NodeId id)\n {\n-    LOCK(cs_vNodes);\n+    LOCK(cs_vNodes); // vNodes\n     for(CNode* pnode : vNodes) {\n         if (id == pnode->GetId()) {\n             pnode->fDisconnect = true;\n@@ -2561,13 +2561,13 @@ bool CConnman::DisconnectNode(NodeId id)\n \n void CConnman::RecordBytesRecv(uint64_t bytes)\n {\n-    LOCK(cs_totalBytesRecv);\n+    LOCK(cs_totalBytesRecv); // nTotalBytesRecv\n     nTotalBytesRecv += bytes;\n }\n \n void CConnman::RecordBytesSent(uint64_t bytes)\n {\n-    LOCK(cs_totalBytesSent);\n+    LOCK(cs_totalBytesSent); // nMaxOutboundTotalBytesSentInCycle, nMaxOutboundTimeframe, nTotalBytesSent, nMaxOutboundCycleStartTime\n     nTotalBytesSent += bytes;\n \n     uint64_t now = GetTime();\n@@ -2584,25 +2584,25 @@ void CConnman::RecordBytesSent(uint64_t bytes)\n \n void CConnman::SetMaxOutboundTarget(uint64_t limit)\n {\n-    LOCK(cs_totalBytesSent);\n+    LOCK(cs_totalBytesSent); // nMaxOutboundLimit\n     nMaxOutboundLimit = limit;\n }\n \n uint64_t CConnman::GetMaxOutboundTarget()\n {\n-    LOCK(cs_totalBytesSent);\n+    LOCK(cs_totalBytesSent); // nMaxOutboundLimit\n     return nMaxOutboundLimit;\n }\n \n uint64_t CConnman::GetMaxOutboundTimeframe()\n {\n-    LOCK(cs_totalBytesSent);\n+    LOCK(cs_totalBytesSent); // nMaxOutboundTimeframe\n     return nMaxOutboundTimeframe;\n }\n \n uint64_t CConnman::GetMaxOutboundTimeLeftInCycle()\n {\n-    LOCK(cs_totalBytesSent);\n+    LOCK(cs_totalBytesSent); // nMaxOutboundLimit, nMaxOutboundTimeframe, nMaxOutboundCycleStartTime\n     if (nMaxOutboundLimit == 0)\n         return 0;\n \n@@ -2616,7 +2616,7 @@ uint64_t CConnman::GetMaxOutboundTimeLeftInCycle()\n \n void CConnman::SetMaxOutboundTimeframe(uint64_t timeframe)\n {\n-    LOCK(cs_totalBytesSent);\n+    LOCK(cs_totalBytesSent); // nMaxOutboundTimeframe, nMaxOutboundCycleStartTime\n     if (nMaxOutboundTimeframe != timeframe)\n     {\n         // reset measure-cycle in case of changing\n@@ -2628,7 +2628,7 @@ void CConnman::SetMaxOutboundTimeframe(uint64_t timeframe)\n \n bool CConnman::OutboundTargetReached(bool historicalBlockServingLimit)\n {\n-    LOCK(cs_totalBytesSent);\n+    LOCK(cs_totalBytesSent); // nMaxOutboundLimit, nMaxOutboundTotalBytesSentInCycle\n     if (nMaxOutboundLimit == 0)\n         return false;\n \n@@ -2648,7 +2648,7 @@ bool CConnman::OutboundTargetReached(bool historicalBlockServingLimit)\n \n uint64_t CConnman::GetOutboundTargetBytesLeft()\n {\n-    LOCK(cs_totalBytesSent);\n+    LOCK(cs_totalBytesSent); // nMaxOutboundLimit, nMaxOutboundTotalBytesSentInCycle\n     if (nMaxOutboundLimit == 0)\n         return 0;\n \n@@ -2657,13 +2657,13 @@ uint64_t CConnman::GetOutboundTargetBytesLeft()\n \n uint64_t CConnman::GetTotalBytesRecv()\n {\n-    LOCK(cs_totalBytesRecv);\n+    LOCK(cs_totalBytesRecv); // nTotalBytesRecv\n     return nTotalBytesRecv;\n }\n \n uint64_t CConnman::GetTotalBytesSent()\n {\n-    LOCK(cs_totalBytesSent);\n+    LOCK(cs_totalBytesSent); // nTotalBytesSent\n     return nTotalBytesSent;\n }\n \n@@ -2820,7 +2820,7 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n \n     size_t nBytesSent = 0;\n     {\n-        LOCK(pnode->cs_vSend);\n+        LOCK(pnode->cs_vSend); // vSendMsg, mapSendBytesPerMsgCmd, SocketSendData(...)\n         bool optimisticSend(pnode->vSendMsg.empty());\n \n         //log total amount of bytes per command\n@@ -2844,7 +2844,7 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n bool CConnman::ForNode(NodeId id, std::function<bool(CNode* pnode)> func)\n {\n     CNode* found = nullptr;\n-    LOCK(cs_vNodes);\n+    LOCK(cs_vNodes); // vNodes\n     for (auto&& pnode : vNodes) {\n         if(pnode->GetId() == id) {\n             found = pnode;"
      },
      {
        "sha": "c9168981685c8dc12a5a31acb9848e6c517e297d",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -183,7 +183,7 @@ class CConnman\n     template<typename Callable>\n     void ForEachNode(Callable&& func)\n     {\n-        LOCK(cs_vNodes);\n+        LOCK(cs_vNodes); // vNodes\n         for (auto&& node : vNodes) {\n             if (NodeFullyConnected(node))\n                 func(node);\n@@ -203,7 +203,7 @@ class CConnman\n     template<typename Callable, typename CallableAfter>\n     void ForEachNodeThen(Callable&& pre, CallableAfter&& post)\n     {\n-        LOCK(cs_vNodes);\n+        LOCK(cs_vNodes); // vNodes\n         for (auto&& node : vNodes) {\n             if (NodeFullyConnected(node))\n                 pre(node);\n@@ -795,14 +795,14 @@ class CNode\n     void AddInventoryKnown(const CInv& inv)\n     {\n         {\n-            LOCK(cs_inventory);\n+            LOCK(cs_inventory); // filterInventoryKnown\n             filterInventoryKnown.insert(inv.hash);\n         }\n     }\n \n     void PushInventory(const CInv& inv)\n     {\n-        LOCK(cs_inventory);\n+        LOCK(cs_inventory); // vInventoryBlockToSend, filterInventoryKnown\n         if (inv.type == MSG_TX) {\n             if (!filterInventoryKnown.contains(inv.hash)) {\n                 setInventoryTxToSend.insert(inv.hash);\n@@ -814,7 +814,7 @@ class CNode\n \n     void PushBlockHash(const uint256 &hash)\n     {\n-        LOCK(cs_inventory);\n+        LOCK(cs_inventory); // vBlockHashesToAnnounce\n         vBlockHashesToAnnounce.push_back(hash);\n     }\n "
      },
      {
        "sha": "51694363d48dd2f0daf9de614ee3178db1aa05c6",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 62,
        "deletions": 62,
        "changes": 124,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -501,7 +501,7 @@ void PeerLogicValidation::InitializeNode(CNode *pnode) {\n     std::string addrName = pnode->GetAddrName();\n     NodeId nodeid = pnode->GetId();\n     {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // mapNodeState\n         mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName)));\n     }\n     if(!pnode->fInbound)\n@@ -510,7 +510,7 @@ void PeerLogicValidation::InitializeNode(CNode *pnode) {\n \n void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n     fUpdateConnectionTime = false;\n-    LOCK(cs_main);\n+    LOCK(cs_main); // State(...), mapNodeState, EraseOrphansFor(...), mapBlocksInFlight\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n \n@@ -541,7 +541,7 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n }\n \n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n-    LOCK(cs_main);\n+    LOCK(cs_main); // State(...)\n     CNodeState *state = State(nodeid);\n     if (state == nullptr)\n         return false;\n@@ -712,7 +712,7 @@ PeerLogicValidation::PeerLogicValidation(CConnman* connmanIn) : connman(connmanI\n }\n \n void PeerLogicValidation::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindex, const std::vector<CTransactionRef>& vtxConflicted) {\n-    LOCK(cs_main);\n+    LOCK(cs_main); // mapOrphanTransactionsByPrev, EraseOrphanTx(...)\n \n     std::vector<uint256> vOrphanErase;\n \n@@ -763,7 +763,7 @@ void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std:\n     uint256 hashBlock(pblock->GetHash());\n \n     {\n-        LOCK(cs_most_recent_block);\n+        LOCK(cs_most_recent_block); // most_recent_block_hash, most_recent_compact_block, fWitnessesPresentInMostRecentCompactBlock, most_recent_block\n         most_recent_block_hash = hashBlock;\n         most_recent_block = pblock;\n         most_recent_compact_block = pcmpctblock;\n@@ -821,7 +821,7 @@ void PeerLogicValidation::UpdatedBlockTip(const CBlockIndex *pindexNew, const CB\n }\n \n void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationState& state) {\n-    LOCK(cs_main);\n+    LOCK(cs_main); // State(...), Misbehaving(...), MaybeSetPeerAsAnnouncingHeaderAndIDs(...), mapBlockSource, mapBlocksInFlight\n \n     const uint256 hash(block.GetHash());\n     std::map<uint256, std::pair<NodeId, bool>>::iterator it = mapBlockSource.find(hash);\n@@ -941,7 +941,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n     std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();\n     std::vector<CInv> vNotFound;\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n-    LOCK(cs_main);\n+    LOCK(cs_main); // pindexBestHeader, chainActive, mapRelay, State(...), CanDirectFetch(...), mapBlockIndex\n \n     while (it != pfrom->vRecvGetData.end()) {\n         // Don't bother if send buffer is too full to respond anyway\n@@ -963,7 +963,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                 std::shared_ptr<const CBlockHeaderAndShortTxIDs> a_recent_compact_block;\n                 bool fWitnessesPresentInARecentCompactBlock;\n                 {\n-                    LOCK(cs_most_recent_block);\n+                    LOCK(cs_most_recent_block); // most_recent_compact_block, fWitnessesPresentInMostRecentCompactBlock, most_recent_block\n                     a_recent_block = most_recent_block;\n                     a_recent_compact_block = most_recent_compact_block;\n                     fWitnessesPresentInARecentCompactBlock = fWitnessesPresentInMostRecentCompactBlock;\n@@ -1140,14 +1140,14 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n     BlockTransactions resp(req);\n     for (size_t i = 0; i < req.indexes.size(); i++) {\n         if (req.indexes[i] >= block.vtx.size()) {\n-            LOCK(cs_main);\n+            LOCK(cs_main); // Misbehaving(...)\n             Misbehaving(pfrom->GetId(), 100);\n             LogPrintf(\"Peer %d sent us a getblocktxn with out-of-bounds tx indices\", pfrom->GetId());\n             return;\n         }\n         resp.txn[i] = block.vtx[req.indexes[i]];\n     }\n-    LOCK(cs_main);\n+    LOCK(cs_main); // State(...)\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n     int nSendFlags = State(pfrom->GetId())->fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n     connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n@@ -1168,7 +1168,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                strCommand == NetMsgType::FILTERADD))\n     {\n         if (pfrom->nVersion >= NO_BLOOM_VERSION) {\n-            LOCK(cs_main);\n+            LOCK(cs_main); // Misbehaving(...)\n             Misbehaving(pfrom->GetId(), 100);\n             return false;\n         } else {\n@@ -1207,7 +1207,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (pfrom->nVersion != 0)\n         {\n             connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, std::string(\"Duplicate version message\")));\n-            LOCK(cs_main);\n+            LOCK(cs_main); // Misbehaving(...)\n             Misbehaving(pfrom->GetId(), 1);\n             return false;\n         }\n@@ -1297,14 +1297,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         pfrom->nServices = nServices;\n         pfrom->SetAddrLocal(addrMe);\n         {\n-            LOCK(pfrom->cs_SubVer);\n+            LOCK(pfrom->cs_SubVer); // cleanSubVer, strSubVer\n             pfrom->strSubVer = strSubVer;\n             pfrom->cleanSubVer = cleanSubVer;\n         }\n         pfrom->nStartingHeight = nStartingHeight;\n         pfrom->fClient = !(nServices & NODE_NETWORK);\n         {\n-            LOCK(pfrom->cs_filter);\n+            LOCK(pfrom->cs_filter); // fRelayTxes\n             pfrom->fRelayTxes = fRelay; // set to true after we get the first filter* message\n         }\n \n@@ -1314,13 +1314,13 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         if((nServices & NODE_WITNESS))\n         {\n-            LOCK(cs_main);\n+            LOCK(cs_main); // State(...)\n             State(pfrom->GetId())->fHaveWitness = true;\n         }\n \n         // Potentially mark this peer as a preferred download peer.\n         {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // State(...)\n         UpdatePreferredDownload(pfrom, State(pfrom->GetId()));\n         }\n \n@@ -1382,7 +1382,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n     else if (pfrom->nVersion == 0)\n     {\n         // Must have a version message before anything else\n-        LOCK(cs_main);\n+        LOCK(cs_main); // Misbehaving(...)\n         Misbehaving(pfrom->GetId(), 1);\n         return false;\n     }\n@@ -1396,7 +1396,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         if (!pfrom->fInbound) {\n             // Mark this node as currently connected, so we update its timestamp later.\n-            LOCK(cs_main);\n+            LOCK(cs_main); // State(...)\n             State(pfrom->GetId())->fCurrentlyConnected = true;\n         }\n \n@@ -1426,7 +1426,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n     else if (!pfrom->fSuccessfullyConnected)\n     {\n         // Must have a verack message before anything else\n-        LOCK(cs_main);\n+        LOCK(cs_main); // Misbehaving(...)\n         Misbehaving(pfrom->GetId(), 1);\n         return false;\n     }\n@@ -1441,7 +1441,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return true;\n         if (vAddr.size() > 1000)\n         {\n-            LOCK(cs_main);\n+            LOCK(cs_main); // Misbehaving(...)\n             Misbehaving(pfrom->GetId(), 20);\n             return error(\"message addr size() = %u\", vAddr.size());\n         }\n@@ -1480,7 +1480,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n     else if (strCommand == NetMsgType::SENDHEADERS)\n     {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // State(...)\n         State(pfrom->GetId())->fPreferHeaders = true;\n     }\n \n@@ -1490,7 +1490,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         uint64_t nCMPCTBLOCKVersion = 0;\n         vRecv >> fAnnounceUsingCMPCTBLOCK >> nCMPCTBLOCKVersion;\n         if (nCMPCTBLOCKVersion == 1 || ((pfrom->GetLocalServices() & NODE_WITNESS) && nCMPCTBLOCKVersion == 2)) {\n-            LOCK(cs_main);\n+            LOCK(cs_main); // State(...)\n             // fProvidesHeaderAndIDs is used to \"lock in\" version of compact blocks we send (fWantsCmpctWitness)\n             if (!State(pfrom->GetId())->fProvidesHeaderAndIDs) {\n                 State(pfrom->GetId())->fProvidesHeaderAndIDs = true;\n@@ -1514,7 +1514,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         vRecv >> vInv;\n         if (vInv.size() > MAX_INV_SZ)\n         {\n-            LOCK(cs_main);\n+            LOCK(cs_main); // Misbehaving(...)\n             Misbehaving(pfrom->GetId(), 20);\n             return error(\"message inv size() = %u\", vInv.size());\n         }\n@@ -1525,7 +1525,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (pfrom->fWhitelisted && gArgs.GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY))\n             fBlocksOnly = false;\n \n-        LOCK(cs_main);\n+        LOCK(cs_main); // GetFetchFlags(...), UpdateBlockAvailability(...), AlreadyHave(...), mapBlocksInFlight, chainActive\n \n         uint32_t nFetchFlags = GetFetchFlags(pfrom);\n \n@@ -1575,7 +1575,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         vRecv >> vInv;\n         if (vInv.size() > MAX_INV_SZ)\n         {\n-            LOCK(cs_main);\n+            LOCK(cs_main); // Misbehaving(...)\n             Misbehaving(pfrom->GetId(), 20);\n             return error(\"message getdata size() = %u\", vInv.size());\n         }\n@@ -1607,14 +1607,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         {\n             std::shared_ptr<const CBlock> a_recent_block;\n             {\n-                LOCK(cs_most_recent_block);\n+                LOCK(cs_most_recent_block); // most_recent_block\n                 a_recent_block = most_recent_block;\n             }\n             CValidationState dummy;\n             ActivateBestChain(dummy, Params(), a_recent_block);\n         }\n \n-        LOCK(cs_main);\n+        LOCK(cs_main); // chainActive\n \n         // Find the last block the caller has in the main chain\n         const CBlockIndex* pindex = FindForkInGlobalIndex(chainActive, locator);\n@@ -1659,7 +1659,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         std::shared_ptr<const CBlock> recent_block;\n         {\n-            LOCK(cs_most_recent_block);\n+            LOCK(cs_most_recent_block); // most_recent_block_hash, most_recent_block\n             if (most_recent_block_hash == req.blockhash)\n                 recent_block = most_recent_block;\n             // Unlock cs_most_recent_block to avoid cs_main lock inversion\n@@ -1669,7 +1669,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return true;\n         }\n \n-        LOCK(cs_main);\n+        LOCK(cs_main); // State(...), chainActive, mapBlockIndex\n \n         BlockMap::iterator it = mapBlockIndex.find(req.blockhash);\n         if (it == mapBlockIndex.end() || !(it->second->nStatus & BLOCK_HAVE_DATA)) {\n@@ -1708,7 +1708,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         uint256 hashStop;\n         vRecv >> locator >> hashStop;\n \n-        LOCK(cs_main);\n+        LOCK(cs_main); // State(...), chainActive, mapBlockIndex\n         if (IsInitialBlockDownload() && !pfrom->fWhitelisted) {\n             LogPrint(BCLog::NET, \"Ignoring getheaders from peer=%d because node is in initial block download\\n\", pfrom->GetId());\n             return true;\n@@ -1778,7 +1778,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         CInv inv(MSG_TX, tx.GetHash());\n         pfrom->AddInventoryKnown(inv);\n \n-        LOCK(cs_main);\n+        LOCK(cs_main); // AddToCompactExtraTransactions(...), AlreadyHave(...), recentRejects, mapOrphanTransactionsByPrev, EraseOrphanTx(...), AddOrphanTx(...), Misbehaving(...), LimitOrphanTxSize(...), GetFetchFlags(...)\n \n         bool fMissingInputs = false;\n         CValidationState state;\n@@ -1951,7 +1951,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         vRecv >> cmpctblock;\n \n         {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // chainActive, mapBlockIndex\n \n         if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n             // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n@@ -1967,7 +1967,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             int nDoS;\n             if (state.IsInvalid(nDoS)) {\n                 if (nDoS > 0) {\n-                    LOCK(cs_main);\n+                    LOCK(cs_main); // Misbehaving(...)\n                     Misbehaving(pfrom->GetId(), nDoS);\n                 }\n                 LogPrintf(\"Peer %d sent us invalid header via cmpctblock\\n\", pfrom->GetId());\n@@ -1993,7 +1993,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         bool fBlockReconstructed = false;\n \n         {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // chainActive, mapBlocksInFlight, UpdateBlockAvailability(...), State(...), CanDirectFetch(...), Misbehaving(...), GetFetchFlags(...), MarkBlockAsInFlight(...), MarkBlockAsReceived(...)\n         // If AcceptBlockHeader returned true, it set pindex\n         assert(pindex);\n         UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n@@ -2121,18 +2121,18 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // If we got here, we were able to optimistically reconstruct a\n             // block that is in flight from some other peer.\n             {\n-                LOCK(cs_main);\n+                LOCK(cs_main); // mapBlockSource\n                 mapBlockSource.emplace(pblock->GetHash(), std::make_pair(pfrom->GetId(), false));\n             }\n             bool fNewBlock = false;\n             ProcessNewBlock(chainparams, pblock, true, &fNewBlock);\n             if (fNewBlock) {\n                 pfrom->nLastBlockTime = GetTime();\n             } else {\n-                LOCK(cs_main);\n+                LOCK(cs_main); // mapBlockSource\n                 mapBlockSource.erase(pblock->GetHash());\n             }\n-            LOCK(cs_main); // hold cs_main for CBlockIndex::IsValid()\n+            LOCK(cs_main); // MarkBlockAsReceived(...)\n             if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS)) {\n                 // Clear download state for this block, which is in\n                 // process from some other peer.  We do this after calling\n@@ -2152,7 +2152,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();\n         bool fBlockRead = false;\n         {\n-            LOCK(cs_main);\n+            LOCK(cs_main); // Misbehaving(...), GetFetchFlags(...), mapBlockSource, MarkBlockAsReceived(...), mapBlocksInFlight\n \n             std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n             if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n@@ -2209,7 +2209,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             if (fNewBlock) {\n                 pfrom->nLastBlockTime = GetTime();\n             } else {\n-                LOCK(cs_main);\n+                LOCK(cs_main); // mapBlockSource\n                 mapBlockSource.erase(pblock->GetHash());\n             }\n         }\n@@ -2223,7 +2223,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // Bypass the normal CBlock deserialization, as we don't want to risk deserializing 2000 full blocks.\n         unsigned int nCount = ReadCompactSize(vRecv);\n         if (nCount > MAX_HEADERS_RESULTS) {\n-            LOCK(cs_main);\n+            LOCK(cs_main); // Misbehaving(...)\n             Misbehaving(pfrom->GetId(), 20);\n             return error(\"headers message size = %u\", nCount);\n         }\n@@ -2240,7 +2240,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         const CBlockIndex *pindexLast = nullptr;\n         {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // State(...), Misbehaving(...), chainActive, UpdateBlockAvailability(...), mapBlockIndex\n         CNodeState *nodestate = State(pfrom->GetId());\n \n         // If this looks like it could be a block announcement (nCount <\n@@ -2285,15 +2285,15 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             int nDoS;\n             if (state.IsInvalid(nDoS)) {\n                 if (nDoS > 0) {\n-                    LOCK(cs_main);\n+                    LOCK(cs_main); // Misbehaving(...)\n                     Misbehaving(pfrom->GetId(), nDoS);\n                 }\n                 return error(\"invalid header received\");\n             }\n         }\n \n         {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // chainActive, mapBlocksInFlight, UpdateBlockAvailability(...), State(...), CanDirectFetch(...), GetFetchFlags(...), MarkBlockAsInFlight(...)\n         CNodeState *nodestate = State(pfrom->GetId());\n         if (nodestate->nUnconnectingHeaders > 0) {\n             LogPrint(BCLog::NET, \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom->GetId(), nodestate->nUnconnectingHeaders);\n@@ -2379,7 +2379,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         bool forceProcessing = pfrom->fWhitelisted && !IsInitialBlockDownload();\n         const uint256 hash(pblock->GetHash());\n         {\n-            LOCK(cs_main);\n+            LOCK(cs_main); // mapBlockSource, MarkBlockAsReceived(...)\n             // Also always process if we requested the block explicitly, as we may\n             // need it even though it is not a candidate for a new best tip.\n             forceProcessing |= MarkBlockAsReceived(hash);\n@@ -2392,7 +2392,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (fNewBlock) {\n             pfrom->nLastBlockTime = GetTime();\n         } else {\n-            LOCK(cs_main);\n+            LOCK(cs_main); // mapBlockSource\n             mapBlockSource.erase(pblock->GetHash());\n         }\n     }\n@@ -2442,7 +2442,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return true;\n         }\n \n-        LOCK(pfrom->cs_inventory);\n+        LOCK(pfrom->cs_inventory); // fSendMempool\n         pfrom->fSendMempool = true;\n     }\n \n@@ -2534,12 +2534,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (!filter.IsWithinSizeConstraints())\n         {\n             // There is no excuse for sending a too-large filter\n-            LOCK(cs_main);\n+            LOCK(cs_main); // Misbehaving(...)\n             Misbehaving(pfrom->GetId(), 100);\n         }\n         else\n         {\n-            LOCK(pfrom->cs_filter);\n+            LOCK(pfrom->cs_filter); // pfilter, fRelayTxes\n             delete pfrom->pfilter;\n             pfrom->pfilter = new CBloomFilter(filter);\n             pfrom->pfilter->UpdateEmptyFull();\n@@ -2559,23 +2559,23 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (vData.size() > MAX_SCRIPT_ELEMENT_SIZE) {\n             bad = true;\n         } else {\n-            LOCK(pfrom->cs_filter);\n+            LOCK(pfrom->cs_filter); // pfilter\n             if (pfrom->pfilter) {\n                 pfrom->pfilter->insert(vData);\n             } else {\n                 bad = true;\n             }\n         }\n         if (bad) {\n-            LOCK(cs_main);\n+            LOCK(cs_main); // Misbehaving(...)\n             Misbehaving(pfrom->GetId(), 100);\n         }\n     }\n \n \n     else if (strCommand == NetMsgType::FILTERCLEAR)\n     {\n-        LOCK(pfrom->cs_filter);\n+        LOCK(pfrom->cs_filter); // fRelayTxes\n         if (pfrom->GetLocalServices() & NODE_BLOOM) {\n             delete pfrom->pfilter;\n             pfrom->pfilter = new CBloomFilter();\n@@ -2588,7 +2588,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         vRecv >> newFeeFilter;\n         if (MoneyRange(newFeeFilter)) {\n             {\n-                LOCK(pfrom->cs_feeFilter);\n+                LOCK(pfrom->cs_feeFilter); // minFeeFilter\n                 pfrom->minFeeFilter = newFeeFilter;\n             }\n             LogPrint(BCLog::NET, \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom->GetId());\n@@ -2668,7 +2668,7 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n \n     std::list<CNetMessage> msgs;\n     {\n-        LOCK(pfrom->cs_vProcessMsg);\n+        LOCK(pfrom->cs_vProcessMsg); // vProcessMsg\n         if (pfrom->vProcessMsg.empty())\n             return false;\n         // Just take one message\n@@ -2754,7 +2754,7 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n         LogPrintf(\"%s(%s, %u bytes) FAILED peer=%d\\n\", __func__, SanitizeString(strCommand), nMessageSize, pfrom->GetId());\n     }\n \n-    LOCK(cs_main);\n+    LOCK(cs_main); // SendRejectsAndCheckIfBanned(...)\n     SendRejectsAndCheckIfBanned(pfrom, connman);\n \n     return fMoreWork;\n@@ -2905,7 +2905,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto, std::atomic<bool>& interruptM\n             // If no header would connect, or if we have too many\n             // blocks, or if the peer doesn't want headers, just\n             // add all to the inv queue.\n-            LOCK(pto->cs_inventory);\n+            LOCK(pto->cs_inventory); // vBlockHashesToAnnounce\n             std::vector<CBlock> vHeaders;\n             bool fRevertToInv = ((!state.fPreferHeaders &&\n                                  (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||\n@@ -2972,7 +2972,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto, std::atomic<bool>& interruptM\n \n                     bool fGotBlockFromCache = false;\n                     {\n-                        LOCK(cs_most_recent_block);\n+                        LOCK(cs_most_recent_block); // most_recent_block_hash, most_recent_compact_block, most_recent_block, fWitnessesPresentInMostRecentCompactBlock\n                         if (most_recent_block_hash == pBestIndex->GetBlockHash()) {\n                             if (state.fWantsCmpctWitness || !fWitnessesPresentInMostRecentCompactBlock)\n                                 connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *most_recent_compact_block));\n@@ -3040,7 +3040,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto, std::atomic<bool>& interruptM\n         //\n         std::vector<CInv> vInv;\n         {\n-            LOCK(pto->cs_inventory);\n+            LOCK(pto->cs_inventory); // vInventoryBlockToSend, filterInventoryKnown, fSendMempool\n             vInv.reserve(std::max<size_t>(pto->vInventoryBlockToSend.size(), INVENTORY_BROADCAST_MAX));\n \n             // Add blocks\n@@ -3063,7 +3063,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto, std::atomic<bool>& interruptM\n \n             // Time to send but the peer has requested we not relay transactions.\n             if (fSendTrickle) {\n-                LOCK(pto->cs_filter);\n+                LOCK(pto->cs_filter); // fRelayTxes\n                 if (!pto->fRelayTxes) pto->setInventoryTxToSend.clear();\n             }\n \n@@ -3073,11 +3073,11 @@ bool PeerLogicValidation::SendMessages(CNode* pto, std::atomic<bool>& interruptM\n                 pto->fSendMempool = false;\n                 CAmount filterrate = 0;\n                 {\n-                    LOCK(pto->cs_feeFilter);\n+                    LOCK(pto->cs_feeFilter); // minFeeFilter\n                     filterrate = pto->minFeeFilter;\n                 }\n \n-                LOCK(pto->cs_filter);\n+                LOCK(pto->cs_filter); // pfilter\n \n                 for (const auto& txinfo : vtxinfo) {\n                     const uint256& hash = txinfo.tx->GetHash();\n@@ -3110,7 +3110,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto, std::atomic<bool>& interruptM\n                 }\n                 CAmount filterrate = 0;\n                 {\n-                    LOCK(pto->cs_feeFilter);\n+                    LOCK(pto->cs_feeFilter); // minFeeFilter\n                     filterrate = pto->minFeeFilter;\n                 }\n                 // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n@@ -3120,7 +3120,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto, std::atomic<bool>& interruptM\n                 // No reason to drain out at many times the network's capacity,\n                 // especially since we have many peers and some will draw much shorter delays.\n                 unsigned int nRelayedTransactions = 0;\n-                LOCK(pto->cs_filter);\n+                LOCK(pto->cs_filter); // pfilter\n                 while (!vInvTx.empty() && nRelayedTransactions < INVENTORY_BROADCAST_MAX) {\n                     // Fetch the top element from the heap\n                     std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);"
      },
      {
        "sha": "316162e3fce2ae40eda8896d15bb8a24b4a98af2",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -490,14 +490,14 @@ bool SetProxy(enum Network net, const proxyType &addrProxy) {\n     assert(net >= 0 && net < NET_MAX);\n     if (!addrProxy.IsValid())\n         return false;\n-    LOCK(cs_proxyInfos);\n+    LOCK(cs_proxyInfos); // proxyInfo\n     proxyInfo[net] = addrProxy;\n     return true;\n }\n \n bool GetProxy(enum Network net, proxyType &proxyInfoOut) {\n     assert(net >= 0 && net < NET_MAX);\n-    LOCK(cs_proxyInfos);\n+    LOCK(cs_proxyInfos); // proxyInfo\n     if (!proxyInfo[net].IsValid())\n         return false;\n     proxyInfoOut = proxyInfo[net];\n@@ -507,26 +507,26 @@ bool GetProxy(enum Network net, proxyType &proxyInfoOut) {\n bool SetNameProxy(const proxyType &addrProxy) {\n     if (!addrProxy.IsValid())\n         return false;\n-    LOCK(cs_proxyInfos);\n+    LOCK(cs_proxyInfos); // nameProxy\n     nameProxy = addrProxy;\n     return true;\n }\n \n bool GetNameProxy(proxyType &nameProxyOut) {\n-    LOCK(cs_proxyInfos);\n+    LOCK(cs_proxyInfos); // nameProxy\n     if(!nameProxy.IsValid())\n         return false;\n     nameProxyOut = nameProxy;\n     return true;\n }\n \n bool HaveNameProxy() {\n-    LOCK(cs_proxyInfos);\n+    LOCK(cs_proxyInfos); // nameProxy\n     return nameProxy.IsValid();\n }\n \n bool IsProxy(const CNetAddr &addr) {\n-    LOCK(cs_proxyInfos);\n+    LOCK(cs_proxyInfos); // proxyInfo\n     for (int i = 0; i < NET_MAX; i++) {\n         if (addr == (CNetAddr)proxyInfo[i].proxy)\n             return true;"
      },
      {
        "sha": "2e7a8f0db2e033cb731fb4e1dbc9443d309e9c67",
        "filename": "src/policy/fees.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/policy/fees.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/policy/fees.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -517,7 +517,7 @@ void TxConfirmStats::removeTx(unsigned int entryHeight, unsigned int nBestSeenHe\n // of no harm to try to remove them again.\n bool CBlockPolicyEstimator::removeTx(uint256 hash, bool inBlock)\n {\n-    LOCK(cs_feeEstimator);\n+    LOCK(cs_feeEstimator); // feeStats, mapMemPoolTxs, shortStats, longStats, nBestSeenHeight\n     std::map<uint256, TxStatsInfo>::iterator pos = mapMemPoolTxs.find(hash);\n     if (pos != mapMemPoolTxs.end()) {\n         feeStats->removeTx(pos->second.blockHeight, nBestSeenHeight, pos->second.bucketIndex, inBlock);\n@@ -557,7 +557,7 @@ CBlockPolicyEstimator::~CBlockPolicyEstimator()\n \n void CBlockPolicyEstimator::processTransaction(const CTxMemPoolEntry& entry, bool validFeeEstimate)\n {\n-    LOCK(cs_feeEstimator);\n+    LOCK(cs_feeEstimator); // feeStats, mapMemPoolTxs, longStats, shortStats, trackedTxs, untrackedTxs, nBestSeenHeight\n     unsigned int txHeight = entry.GetHeight();\n     uint256 hash = entry.GetTx().GetHash();\n     if (mapMemPoolTxs.count(hash)) {\n@@ -624,7 +624,7 @@ bool CBlockPolicyEstimator::processBlockTx(unsigned int nBlockHeight, const CTxM\n void CBlockPolicyEstimator::processBlock(unsigned int nBlockHeight,\n                                          std::vector<const CTxMemPoolEntry*>& entries)\n {\n-    LOCK(cs_feeEstimator);\n+    LOCK(cs_feeEstimator); // firstRecordedHeight, feeStats, mapMemPoolTxs, longStats, shortStats, processBlockTx(...), trackedTxs, untrackedTxs, nBestSeenHeight\n     if (nBlockHeight <= nBestSeenHeight) {\n         // Ignore side chains and re-orgs; assuming they are random\n         // they don't affect the estimate.\n@@ -702,7 +702,7 @@ CFeeRate CBlockPolicyEstimator::estimateRawFee(int confTarget, double successThr\n     }\n     }\n \n-    LOCK(cs_feeEstimator);\n+    LOCK(cs_feeEstimator); // nBestSeenHeight\n     // Return failure if trying to analyze a target we're not tracking\n     if (confTarget <= 0 || (unsigned int)confTarget > stats->GetMaxConfirms())\n         return CFeeRate(0);\n@@ -828,7 +828,7 @@ double CBlockPolicyEstimator::estimateConservativeFee(unsigned int doubleTarget,\n  */\n CFeeRate CBlockPolicyEstimator::estimateSmartFee(int confTarget, FeeCalculation *feeCalc, bool conservative) const\n {\n-    LOCK(cs_feeEstimator);\n+    LOCK(cs_feeEstimator); // estimateConservativeFee(...), estimateCombinedFee(...), MaxUsableEstimate(...), longStats\n \n     if (feeCalc) {\n         feeCalc->desiredTarget = confTarget;\n@@ -908,7 +908,7 @@ CFeeRate CBlockPolicyEstimator::estimateSmartFee(int confTarget, FeeCalculation\n bool CBlockPolicyEstimator::Write(CAutoFile& fileout) const\n {\n     try {\n-        LOCK(cs_feeEstimator);\n+        LOCK(cs_feeEstimator); // feeStats, BlockSpan(...), longStats, HistoricalBlockSpan(...), shortStats\n         fileout << 149900; // version required to read: 0.14.99 or later\n         fileout << CLIENT_VERSION; // version that wrote the file\n         fileout << nBestSeenHeight;\n@@ -933,7 +933,7 @@ bool CBlockPolicyEstimator::Write(CAutoFile& fileout) const\n bool CBlockPolicyEstimator::Read(CAutoFile& filein)\n {\n     try {\n-        LOCK(cs_feeEstimator);\n+        LOCK(cs_feeEstimator); // historicalBest, bucketMap, buckets, historicalFirst, nBestSeenHeight\n         int nVersionRequired, nVersionThatWrote;\n         filein >> nVersionRequired >> nVersionThatWrote;\n         if (nVersionRequired > CLIENT_VERSION)"
      },
      {
        "sha": "a1496cdda93dc412c9811c5aa68ee145fbae6dd7",
        "filename": "src/qt/addresstablemodel.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/qt/addresstablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/qt/addresstablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addresstablemodel.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -79,7 +79,7 @@ class AddressTablePriv\n     {\n         cachedAddressTable.clear();\n         {\n-            LOCK(wallet->cs_wallet);\n+            LOCK(wallet->cs_wallet); // mapAddressBook\n             for (const std::pair<CTxDestination, CAddressBookData>& item : wallet->mapAddressBook)\n             {\n                 const CTxDestination& address = item.first;\n@@ -245,7 +245,7 @@ bool AddressTableModel::setData(const QModelIndex &index, const QVariant &value,\n \n     if(role == Qt::EditRole)\n     {\n-        LOCK(wallet->cs_wallet); /* For SetAddressBook / DelAddressBook */\n+        LOCK(wallet->cs_wallet); // mapAddressBook\n         CTxDestination curAddress = DecodeDestination(rec->address.toStdString());\n         if(index.column() == Label)\n         {\n@@ -357,7 +357,7 @@ QString AddressTableModel::addRow(const QString &type, const QString &label, con\n         }\n         // Check for duplicate addresses\n         {\n-            LOCK(wallet->cs_wallet);\n+            LOCK(wallet->cs_wallet); // mapAddressBook\n             if(wallet->mapAddressBook.count(DecodeDestination(strAddress)))\n             {\n                 editStatus = DUPLICATE_ADDRESS;\n@@ -422,7 +422,7 @@ bool AddressTableModel::removeRows(int row, int count, const QModelIndex &parent\n QString AddressTableModel::labelForAddress(const QString &address) const\n {\n     {\n-        LOCK(wallet->cs_wallet);\n+        LOCK(wallet->cs_wallet); // mapAddressBook\n         CTxDestination destination = DecodeDestination(address.toStdString());\n         std::map<CTxDestination, CAddressBookData>::iterator mi = wallet->mapAddressBook.find(destination);\n         if (mi != wallet->mapAddressBook.end())"
      },
      {
        "sha": "62a225d412c18a98873676927d19c322751cebe4",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -71,7 +71,7 @@ int ClientModel::getNumConnections(unsigned int flags) const\n \n int ClientModel::getNumBlocks() const\n {\n-    LOCK(cs_main);\n+    LOCK(cs_main); // chainActive\n     return chainActive.Height();\n }\n \n@@ -80,7 +80,7 @@ int ClientModel::getHeaderTipHeight() const\n     if (cachedBestHeaderHeight == -1) {\n         // make sure we initially populate the cache via a cs_main lock\n         // otherwise we need to wait for a tip update\n-        LOCK(cs_main);\n+        LOCK(cs_main); // pindexBestHeader\n         if (pindexBestHeader) {\n             cachedBestHeaderHeight = pindexBestHeader->nHeight;\n             cachedBestHeaderTime = pindexBestHeader->GetBlockTime();\n@@ -92,7 +92,7 @@ int ClientModel::getHeaderTipHeight() const\n int64_t ClientModel::getHeaderTipTime() const\n {\n     if (cachedBestHeaderTime == -1) {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // pindexBestHeader\n         if (pindexBestHeader) {\n             cachedBestHeaderHeight = pindexBestHeader->nHeight;\n             cachedBestHeaderTime = pindexBestHeader->GetBlockTime();\n@@ -117,7 +117,7 @@ quint64 ClientModel::getTotalBytesSent() const\n \n QDateTime ClientModel::getLastBlockDate() const\n {\n-    LOCK(cs_main);\n+    LOCK(cs_main); // chainActive\n \n     if (chainActive.Tip())\n         return QDateTime::fromTime_t(chainActive.Tip()->GetBlockTime());\n@@ -140,7 +140,7 @@ double ClientModel::getVerificationProgress(const CBlockIndex *tipIn) const\n     CBlockIndex *tip = const_cast<CBlockIndex *>(tipIn);\n     if (!tip)\n     {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // chainActive\n         tip = chainActive.Tip();\n     }\n     return GuessVerificationProgress(Params().TxData(), tip);"
      },
      {
        "sha": "d20bfba06a0160b72a8b37bde09f97e40f73b178",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -51,7 +51,7 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n {\n     QString strHTML;\n \n-    LOCK2(cs_main, wallet->cs_wallet);\n+    LOCK2(cs_main, wallet->cs_wallet); // pcoinsTip, FormatTxStatus(...), mapAddressBook\n     strHTML.reserve(4000);\n     strHTML += \"<html><font face='verdana, arial, helvetica, sans-serif'>\";\n "
      },
      {
        "sha": "567847ca1d8b635035529d9b273f2f00c5f29a7a",
        "filename": "src/qt/transactiontablemodel.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/qt/transactiontablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/qt/transactiontablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -79,7 +79,7 @@ class TransactionTablePriv\n         qDebug() << \"TransactionTablePriv::refreshWallet\";\n         cachedWallet.clear();\n         {\n-            LOCK2(cs_main, wallet->cs_wallet);\n+            LOCK2(cs_main, wallet->cs_wallet); // mapWallet\n             for(std::map<uint256, CWalletTx>::iterator it = wallet->mapWallet.begin(); it != wallet->mapWallet.end(); ++it)\n             {\n                 if(TransactionRecord::showTransaction(it->second))\n@@ -128,7 +128,7 @@ class TransactionTablePriv\n             }\n             if(showTransaction)\n             {\n-                LOCK2(cs_main, wallet->cs_wallet);\n+                LOCK2(cs_main, wallet->cs_wallet); // mapWallet\n                 // Find transaction in wallet\n                 std::map<uint256, CWalletTx>::iterator mi = wallet->mapWallet.find(hash);\n                 if(mi == wallet->mapWallet.end())\n@@ -214,7 +214,7 @@ class TransactionTablePriv\n     QString describe(TransactionRecord *rec, int unit)\n     {\n         {\n-            LOCK2(cs_main, wallet->cs_wallet);\n+            LOCK2(cs_main, wallet->cs_wallet); // mapWallet\n             std::map<uint256, CWalletTx>::iterator mi = wallet->mapWallet.find(rec->hash);\n             if(mi != wallet->mapWallet.end())\n             {\n@@ -226,7 +226,7 @@ class TransactionTablePriv\n \n     QString getTxHex(TransactionRecord *rec)\n     {\n-        LOCK2(cs_main, wallet->cs_wallet);\n+        LOCK2(cs_main, wallet->cs_wallet); // mapWallet\n         std::map<uint256, CWalletTx>::iterator mi = wallet->mapWallet.find(rec->hash);\n         if(mi != wallet->mapWallet.end())\n         {"
      },
      {
        "sha": "3d87ccd142a8d7ddbb56de4d80f7693916482075",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -350,7 +350,7 @@ WalletModel::SendCoinsReturn WalletModel::sendCoins(WalletModelTransaction &tran\n             CTxDestination dest = DecodeDestination(strAddress);\n             std::string strLabel = rcp.label.toStdString();\n             {\n-                LOCK(wallet->cs_wallet);\n+                LOCK(wallet->cs_wallet); // mapAddressBook\n \n                 std::map<CTxDestination, CAddressBookData>::iterator mi = wallet->mapAddressBook.find(dest);\n \n@@ -573,7 +573,7 @@ bool WalletModel::getPrivKey(const CKeyID &address, CKey& vchPrivKeyOut) const\n // returns a list of COutputs from COutPoints\n void WalletModel::getOutputs(const std::vector<COutPoint>& vOutpoints, std::vector<COutput>& vOutputs)\n {\n-    LOCK2(cs_main, wallet->cs_wallet);\n+    LOCK2(cs_main, wallet->cs_wallet); // mapWallet\n     for (const COutPoint& outpoint : vOutpoints)\n     {\n         auto it = wallet->mapWallet.find(outpoint.hash);"
      },
      {
        "sha": "15a45ed54ce8ed59e95e1899d8182f52f5578293",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -146,7 +146,7 @@ static bool rest_headers(HTTPRequest* req,\n     std::vector<const CBlockIndex *> headers;\n     headers.reserve(count);\n     {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // chainActive, mapBlockIndex\n         BlockMap::const_iterator it = mapBlockIndex.find(hash);\n         const CBlockIndex *pindex = (it != mapBlockIndex.end()) ? it->second : nullptr;\n         while (pindex != nullptr && chainActive.Contains(pindex)) {\n@@ -208,7 +208,7 @@ static bool rest_block(HTTPRequest* req,\n     CBlock block;\n     CBlockIndex* pblockindex = nullptr;\n     {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // mapBlockIndex\n         if (mapBlockIndex.count(hash) == 0)\n             return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not found\");\n "
      },
      {
        "sha": "e5c0acc9e468d6f0e55ecdd342cfd798b1a66c25",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 19,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -160,7 +160,7 @@ UniValue getblockcount(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getblockcount\", \"\")\n         );\n \n-    LOCK(cs_main);\n+    LOCK(cs_main); // chainActive\n     return chainActive.Height();\n }\n \n@@ -177,7 +177,7 @@ UniValue getbestblockhash(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getbestblockhash\", \"\")\n         );\n \n-    LOCK(cs_main);\n+    LOCK(cs_main); // chainActive\n     return chainActive.Tip()->GetBlockHash().GetHex();\n }\n \n@@ -326,7 +326,7 @@ UniValue getdifficulty(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getdifficulty\", \"\")\n         );\n \n-    LOCK(cs_main);\n+    LOCK(cs_main); // GetDifficulty(...)\n     return GetDifficulty();\n }\n \n@@ -386,7 +386,7 @@ UniValue mempoolToJSON(bool fVerbose)\n {\n     if (fVerbose)\n     {\n-        LOCK(mempool.cs);\n+        LOCK(mempool.cs); // mapTx, entryToJSON(...)\n         UniValue o(UniValue::VOBJ);\n         for (const CTxMemPoolEntry& e : mempool.mapTx)\n         {\n@@ -474,7 +474,7 @@ UniValue getmempoolancestors(const JSONRPCRequest& request)\n \n     uint256 hash = ParseHashV(request.params[0], \"parameter 1\");\n \n-    LOCK(mempool.cs);\n+    LOCK(mempool.cs); // mapTx, entryToJSON(...)\n \n     CTxMemPool::txiter it = mempool.mapTx.find(hash);\n     if (it == mempool.mapTx.end()) {\n@@ -538,7 +538,7 @@ UniValue getmempooldescendants(const JSONRPCRequest& request)\n \n     uint256 hash = ParseHashV(request.params[0], \"parameter 1\");\n \n-    LOCK(mempool.cs);\n+    LOCK(mempool.cs); // mapTx, entryToJSON(...)\n \n     CTxMemPool::txiter it = mempool.mapTx.find(hash);\n     if (it == mempool.mapTx.end()) {\n@@ -590,7 +590,7 @@ UniValue getmempoolentry(const JSONRPCRequest& request)\n \n     uint256 hash = ParseHashV(request.params[0], \"parameter 1\");\n \n-    LOCK(mempool.cs);\n+    LOCK(mempool.cs); // mapTx, entryToJSON(...)\n \n     CTxMemPool::txiter it = mempool.mapTx.find(hash);\n     if (it == mempool.mapTx.end()) {\n@@ -618,7 +618,7 @@ UniValue getblockhash(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getblockhash\", \"1000\")\n         );\n \n-    LOCK(cs_main);\n+    LOCK(cs_main); // chainActive\n \n     int nHeight = request.params[0].get_int();\n     if (nHeight < 0 || nHeight > chainActive.Height())\n@@ -662,7 +662,7 @@ UniValue getblockheader(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getblockheader\", \"\\\"00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09\\\"\")\n         );\n \n-    LOCK(cs_main);\n+    LOCK(cs_main); // blockheaderToJSON(...), mapBlockIndex\n \n     std::string strHash = request.params[0].get_str();\n     uint256 hash(uint256S(strHash));\n@@ -737,7 +737,7 @@ UniValue getblock(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getblock\", \"\\\"00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09\\\"\")\n         );\n \n-    LOCK(cs_main);\n+    LOCK(cs_main); // blockToJSON(...), mapBlockIndex\n \n     std::string strHash = request.params[0].get_str();\n     uint256 hash(uint256S(strHash));\n@@ -819,7 +819,7 @@ static bool GetUTXOStats(CCoinsView *view, CCoinsStats &stats)\n     CHashWriter ss(SER_GETHASH, PROTOCOL_VERSION);\n     stats.hashBlock = pcursor->GetBestBlock();\n     {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // mapBlockIndex\n         stats.nHeight = mapBlockIndex.find(stats.hashBlock)->second->nHeight;\n     }\n     ss << stats.hashBlock;\n@@ -866,7 +866,7 @@ UniValue pruneblockchain(const JSONRPCRequest& request)\n     if (!fPruneMode)\n         throw JSONRPCError(RPC_MISC_ERROR, \"Cannot prune blocks because node is not in prune mode.\");\n \n-    LOCK(cs_main);\n+    LOCK(cs_main); // chainActive\n \n     int heightParam = request.params[0].get_int();\n     if (heightParam < 0)\n@@ -978,7 +978,7 @@ UniValue gettxout(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"gettxout\", \"\\\"txid\\\", 1\")\n         );\n \n-    LOCK(cs_main);\n+    LOCK(cs_main); // pcoinsTip, mapBlockIndex\n \n     UniValue ret(UniValue::VOBJ);\n \n@@ -1168,7 +1168,7 @@ UniValue getblockchaininfo(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getblockchaininfo\", \"\")\n         );\n \n-    LOCK(cs_main);\n+    LOCK(cs_main); // GetDifficulty(...), pindexBestHeader, chainActive\n \n     UniValue obj(UniValue::VOBJ);\n     obj.push_back(Pair(\"chain\",                 Params().NetworkIDString()));\n@@ -1252,7 +1252,7 @@ UniValue getchaintips(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getchaintips\", \"\")\n         );\n \n-    LOCK(cs_main);\n+    LOCK(cs_main); // chainActive, mapBlockIndex\n \n     /*\n      * Idea:  the set of chain tips is chainActive.tip, plus orphan blocks which do not have another orphan building off of them.\n@@ -1378,7 +1378,7 @@ UniValue preciousblock(const JSONRPCRequest& request)\n     CBlockIndex* pblockindex;\n \n     {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // mapBlockIndex\n         if (mapBlockIndex.count(hash) == 0)\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n \n@@ -1414,7 +1414,7 @@ UniValue invalidateblock(const JSONRPCRequest& request)\n     CValidationState state;\n \n     {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // mapBlockIndex\n         if (mapBlockIndex.count(hash) == 0)\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n \n@@ -1452,7 +1452,7 @@ UniValue reconsiderblock(const JSONRPCRequest& request)\n     uint256 hash(uint256S(strHash));\n \n     {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // mapBlockIndex\n         if (mapBlockIndex.count(hash) == 0)\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n \n@@ -1504,7 +1504,7 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     }\n \n     {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // chainActive, mapBlockIndex\n         if (havehash) {\n             auto it = mapBlockIndex.find(hash);\n             if (it == mapBlockIndex.end()) {"
      },
      {
        "sha": "0297412dbbcc9ca8715024e1fb5039fa13a94651",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -101,7 +101,7 @@ UniValue getnetworkhashps(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getnetworkhashps\", \"\")\n        );\n \n-    LOCK(cs_main);\n+    LOCK(cs_main); // GetNetworkHashPS(...)\n     return GetNetworkHashPS(!request.params[0].isNull() ? request.params[0].get_int() : 120, !request.params[1].isNull() ? request.params[1].get_int() : -1);\n }\n \n@@ -112,7 +112,7 @@ UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGen\n     int nHeight = 0;\n \n     {   // Don't keep cs_main locked\n-        LOCK(cs_main);\n+        LOCK(cs_main); // chainActive\n         nHeight = chainActive.Height();\n         nHeightEnd = nHeight+nGenerate;\n     }\n@@ -125,7 +125,7 @@ UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGen\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Couldn't create new block\");\n         CBlock *pblock = &pblocktemplate->block;\n         {\n-            LOCK(cs_main);\n+            LOCK(cs_main); // chainActive\n             IncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);\n         }\n         while (nMaxTries > 0 && pblock->nNonce < nInnerLoopCount && !CheckProofOfWork(pblock->GetHash(), pblock->nBits, Params().GetConsensus())) {\n@@ -210,7 +210,7 @@ UniValue getmininginfo(const JSONRPCRequest& request)\n         );\n \n \n-    LOCK(cs_main);\n+    LOCK(cs_main); // chainActive\n \n     UniValue obj(UniValue::VOBJ);\n     obj.push_back(Pair(\"blocks\",           (int)chainActive.Height()));\n@@ -728,7 +728,7 @@ UniValue submitblock(const JSONRPCRequest& request)\n     uint256 hash = block.GetHash();\n     bool fBlockPresent = false;\n     {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // mapBlockIndex\n         BlockMap::iterator mi = mapBlockIndex.find(hash);\n         if (mi != mapBlockIndex.end()) {\n             CBlockIndex *pindex = mi->second;\n@@ -744,7 +744,7 @@ UniValue submitblock(const JSONRPCRequest& request)\n     }\n \n     {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // mapBlockIndex\n         BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n         if (mi != mapBlockIndex.end()) {\n             UpdateUncommittedBlockStructures(block, mi->second, Params().GetConsensus());"
      },
      {
        "sha": "3dbb6a5ac502d80e4e92fa222be62b9c3b0fb066",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -472,7 +472,7 @@ UniValue getnetworkinfo(const JSONRPCRequest& request)\n     obj.push_back(Pair(\"incrementalfee\", ValueFromAmount(::incrementalRelayFee.GetFeePerK())));\n     UniValue localAddresses(UniValue::VARR);\n     {\n-        LOCK(cs_mapLocalHost);\n+        LOCK(cs_mapLocalHost); // mapLocalHost\n         for (const std::pair<CNetAddr, LocalServiceInfo> &item : mapLocalHost)\n         {\n             UniValue rec(UniValue::VOBJ);"
      },
      {
        "sha": "addf744dd17acaff40b01658f5d3cc08e9997cd5",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -132,7 +132,7 @@ UniValue getrawtransaction(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getrawtransaction\", \"\\\"mytxid\\\", true\")\n         );\n \n-    LOCK(cs_main);\n+    LOCK(cs_main); // TxToJSON(...)\n \n     uint256 hash = ParseHashV(request.params[0], \"parameter 1\");\n \n@@ -204,7 +204,7 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n        oneTxid = hash;\n     }\n \n-    LOCK(cs_main);\n+    LOCK(cs_main); // chainActive, mapBlockIndex\n \n     CBlockIndex* pblockindex = nullptr;\n \n@@ -278,7 +278,7 @@ UniValue verifytxoutproof(const JSONRPCRequest& request)\n     if (merkleBlock.txn.ExtractMatches(vMatch, vIndex) != merkleBlock.header.hashMerkleRoot)\n         return res;\n \n-    LOCK(cs_main);\n+    LOCK(cs_main); // chainActive, mapBlockIndex\n \n     if (!mapBlockIndex.count(merkleBlock.header.GetHash()) || !chainActive.Contains(mapBlockIndex[merkleBlock.header.GetHash()]))\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found in chain\");\n@@ -912,7 +912,7 @@ UniValue sendrawtransaction(const JSONRPCRequest& request)\n         );\n \n     ObserveSafeMode();\n-    LOCK(cs_main);\n+    LOCK(cs_main); // pcoinsTip\n     RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL});\n \n     // parse hex string from parameter"
      },
      {
        "sha": "0554b2faec936dcbad2b2397f5011dbd6c64ddd1",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -334,20 +334,20 @@ bool IsRPCRunning()\n \n void SetRPCWarmupStatus(const std::string& newStatus)\n {\n-    LOCK(cs_rpcWarmup);\n+    LOCK(cs_rpcWarmup); // rpcWarmupStatus\n     rpcWarmupStatus = newStatus;\n }\n \n void SetRPCWarmupFinished()\n {\n-    LOCK(cs_rpcWarmup);\n+    LOCK(cs_rpcWarmup); // fRPCInWarmup\n     assert(fRPCInWarmup);\n     fRPCInWarmup = false;\n }\n \n bool RPCIsInWarmup(std::string *outStatus)\n {\n-    LOCK(cs_rpcWarmup);\n+    LOCK(cs_rpcWarmup); // rpcWarmupStatus, fRPCInWarmup\n     if (outStatus)\n         *outStatus = rpcWarmupStatus;\n     return fRPCInWarmup;\n@@ -469,7 +469,7 @@ UniValue CRPCTable::execute(const JSONRPCRequest &request) const\n {\n     // Return immediately if in warmup\n     {\n-        LOCK(cs_rpcWarmup);\n+        LOCK(cs_rpcWarmup); // fRPCInWarmup\n         if (fRPCInWarmup)\n             throw JSONRPCError(RPC_IN_WARMUP, rpcWarmupStatus);\n     }"
      },
      {
        "sha": "7e47dd09446c42b4735c3546d2e04c15db127a16",
        "filename": "src/scheduler.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/scheduler.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/scheduler.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scheduler.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -148,7 +148,7 @@ bool CScheduler::AreThreadsServicingQueue() const {\n \n void SingleThreadedSchedulerClient::MaybeScheduleProcessQueue() {\n     {\n-        LOCK(m_cs_callbacks_pending);\n+        LOCK(m_cs_callbacks_pending); // m_are_callbacks_running, m_callbacks_pending\n         // Try to avoid scheduling too many copies here, but if we\n         // accidentally have two ProcessQueue's scheduled at once its\n         // not a big deal.\n@@ -161,7 +161,7 @@ void SingleThreadedSchedulerClient::MaybeScheduleProcessQueue() {\n void SingleThreadedSchedulerClient::ProcessQueue() {\n     std::function<void (void)> callback;\n     {\n-        LOCK(m_cs_callbacks_pending);\n+        LOCK(m_cs_callbacks_pending); // m_are_callbacks_running, m_callbacks_pending\n         if (m_are_callbacks_running) return;\n         if (m_callbacks_pending.empty()) return;\n         m_are_callbacks_running = true;\n@@ -191,7 +191,7 @@ void SingleThreadedSchedulerClient::AddToProcessQueue(std::function<void (void)>\n     assert(m_pscheduler);\n \n     {\n-        LOCK(m_cs_callbacks_pending);\n+        LOCK(m_cs_callbacks_pending); // m_callbacks_pending\n         m_callbacks_pending.emplace_back(std::move(func));\n     }\n     MaybeScheduleProcessQueue();\n@@ -202,7 +202,7 @@ void SingleThreadedSchedulerClient::EmptyQueue() {\n     bool should_continue = true;\n     while (should_continue) {\n         ProcessQueue();\n-        LOCK(m_cs_callbacks_pending);\n+        LOCK(m_cs_callbacks_pending); // m_callbacks_pending\n         should_continue = !m_callbacks_pending.empty();\n     }\n }"
      },
      {
        "sha": "91c360d5213c18e2d55fb7fe4b0278d6f7020dee",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -206,7 +206,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     entry.nFee = 11;\n     entry.nHeight = 11;\n \n-    LOCK(cs_main);\n+    LOCK(cs_main); // pcoinsTip, CreateBlockIndex(...), chainActive\n     fCheckpointsEnabled = false;\n \n     // Simple block creation, nothing special yet:"
      },
      {
        "sha": "30c90d521f15bb011cfea7b93e00f7ae7c4db84c",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -191,7 +191,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         spend_tx.vin[0].scriptSig << vchSig;\n     }\n \n-    LOCK(cs_main);\n+    LOCK(cs_main); // pcoinsTip, chainActive\n \n     // Test that invalidity under a set of flags doesn't preclude validity\n     // under other (eg consensus) flags."
      },
      {
        "sha": "8866923a565a022612806afb7f555bb843a6e260",
        "filename": "src/timedata.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/timedata.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/timedata.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -28,7 +28,7 @@ static int64_t nTimeOffset = 0;\n  */\n int64_t GetTimeOffset()\n {\n-    LOCK(cs_nTimeOffset);\n+    LOCK(cs_nTimeOffset); // nTimeOffset\n     return nTimeOffset;\n }\n \n@@ -46,7 +46,7 @@ static int64_t abs64(int64_t n)\n \n void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n {\n-    LOCK(cs_nTimeOffset);\n+    LOCK(cs_nTimeOffset); // nTimeOffset\n     // Ignore duplicates\n     static std::set<CNetAddr> setKnown;\n     if (setKnown.size() == BITCOIN_TIMEDATA_MAX_SAMPLES)"
      },
      {
        "sha": "58eed7d49851a1e176cfecad32906bb22c2b8214",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 24,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -108,7 +108,7 @@ void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendan\n // for each such descendant, also update the ancestor state to include the parent.\n void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256> &vHashesToUpdate)\n {\n-    LOCK(cs);\n+    LOCK(cs); // mapTx, mapNextTx, UpdateForDescendants(...)\n     // For each entry in vHashesToUpdate, store the set of in-mempool, but not\n     // in-vHashesToUpdate transactions, so that we don't have to recalculate\n     // descendants when we come across a previously seen entry.\n@@ -151,7 +151,7 @@ void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256> &vHashes\n \n bool CTxMemPool::CalculateMemPoolAncestors(const CTxMemPoolEntry &entry, setEntries &setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string &errString, bool fSearchForParents /* = true */) const\n {\n-    LOCK(cs);\n+    LOCK(cs); // mapTx\n \n     setEntries parentHashes;\n     const CTransaction &tx = entry.GetTx();\n@@ -341,19 +341,19 @@ CTxMemPool::CTxMemPool(CBlockPolicyEstimator* estimator) :\n \n bool CTxMemPool::isSpent(const COutPoint& outpoint)\n {\n-    LOCK(cs);\n+    LOCK(cs); // mapNextTx\n     return mapNextTx.count(outpoint);\n }\n \n unsigned int CTxMemPool::GetTransactionsUpdated() const\n {\n-    LOCK(cs);\n+    LOCK(cs); // nTransactionsUpdated\n     return nTransactionsUpdated;\n }\n \n void CTxMemPool::AddTransactionsUpdated(unsigned int n)\n {\n-    LOCK(cs);\n+    LOCK(cs); // nTransactionsUpdated\n     nTransactionsUpdated += n;\n }\n \n@@ -363,7 +363,7 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,\n     // Add to memory pool without checking anything.\n     // Used by AcceptToMemoryPool(), which DOES do\n     // all the appropriate checks.\n-    LOCK(cs);\n+    LOCK(cs); // UpdateAncestorsOf(...), cachedInnerUsage, UpdateEntryForAncestors(...), mapDeltas, mapTx, mapNextTx, nTransactionsUpdated, vTxHashes, totalTxSize, minerPolicyEstimator\n     indexed_transaction_set::iterator newit = mapTx.insert(entry).first;\n     mapLinks.insert(make_pair(newit, TxLinks()));\n \n@@ -474,7 +474,7 @@ void CTxMemPool::removeRecursive(const CTransaction &origTx, MemPoolRemovalReaso\n {\n     // Remove transaction from memory pool\n     {\n-        LOCK(cs);\n+        LOCK(cs); // mapTx, mapNextTx\n         setEntries txToRemove;\n         txiter origit = mapTx.find(origTx.GetHash());\n         if (origit != mapTx.end()) {\n@@ -505,7 +505,7 @@ void CTxMemPool::removeRecursive(const CTransaction &origTx, MemPoolRemovalReaso\n void CTxMemPool::removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight, int flags)\n {\n     // Remove transactions spending a coinbase which are now immature and no-longer-final transactions\n-    LOCK(cs);\n+    LOCK(cs); // mapTx\n     setEntries txToRemove;\n     for (indexed_transaction_set::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n         const CTransaction& tx = it->GetTx();\n@@ -542,7 +542,7 @@ void CTxMemPool::removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMem\n void CTxMemPool::removeConflicts(const CTransaction &tx)\n {\n     // Remove transactions which depend on inputs of tx, recursively\n-    LOCK(cs);\n+    LOCK(cs); // mapNextTx\n     for (const CTxIn &txin : tx.vin) {\n         auto it = mapNextTx.find(txin.prevout);\n         if (it != mapNextTx.end()) {\n@@ -561,7 +561,7 @@ void CTxMemPool::removeConflicts(const CTransaction &tx)\n  */\n void CTxMemPool::removeForBlock(const std::vector<CTransactionRef>& vtx, unsigned int nBlockHeight)\n {\n-    LOCK(cs);\n+    LOCK(cs); // lastRollingFeeUpdate, mapTx, blockSinceLastRollingFeeBump, minerPolicyEstimator\n     std::vector<const CTxMemPoolEntry*> entries;\n     for (const auto& tx : vtx)\n     {\n@@ -603,7 +603,7 @@ void CTxMemPool::_clear()\n \n void CTxMemPool::clear()\n {\n-    LOCK(cs);\n+    LOCK(cs); // _clear(...)\n     _clear();\n }\n \n@@ -738,7 +738,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n \n bool CTxMemPool::CompareDepthAndScore(const uint256& hasha, const uint256& hashb)\n {\n-    LOCK(cs);\n+    LOCK(cs); // mapTx\n     indexed_transaction_set::const_iterator i = mapTx.find(hasha);\n     if (i == mapTx.end()) return false;\n     indexed_transaction_set::const_iterator j = mapTx.find(hashb);\n@@ -783,7 +783,7 @@ std::vector<CTxMemPool::indexed_transaction_set::const_iterator> CTxMemPool::Get\n \n void CTxMemPool::queryHashes(std::vector<uint256>& vtxid)\n {\n-    LOCK(cs);\n+    LOCK(cs); // mapTx, GetSortedDepthAndScore(...)\n     auto iters = GetSortedDepthAndScore();\n \n     vtxid.clear();\n@@ -800,7 +800,7 @@ static TxMempoolInfo GetInfo(CTxMemPool::indexed_transaction_set::const_iterator\n \n std::vector<TxMempoolInfo> CTxMemPool::infoAll() const\n {\n-    LOCK(cs);\n+    LOCK(cs); // mapTx, GetSortedDepthAndScore(...)\n     auto iters = GetSortedDepthAndScore();\n \n     std::vector<TxMempoolInfo> ret;\n@@ -814,7 +814,7 @@ std::vector<TxMempoolInfo> CTxMemPool::infoAll() const\n \n CTransactionRef CTxMemPool::get(const uint256& hash) const\n {\n-    LOCK(cs);\n+    LOCK(cs); // mapTx\n     indexed_transaction_set::const_iterator i = mapTx.find(hash);\n     if (i == mapTx.end())\n         return nullptr;\n@@ -823,7 +823,7 @@ CTransactionRef CTxMemPool::get(const uint256& hash) const\n \n TxMempoolInfo CTxMemPool::info(const uint256& hash) const\n {\n-    LOCK(cs);\n+    LOCK(cs); // mapTx\n     indexed_transaction_set::const_iterator i = mapTx.find(hash);\n     if (i == mapTx.end())\n         return TxMempoolInfo();\n@@ -833,7 +833,7 @@ TxMempoolInfo CTxMemPool::info(const uint256& hash) const\n void CTxMemPool::PrioritiseTransaction(const uint256& hash, const CAmount& nFeeDelta)\n {\n     {\n-        LOCK(cs);\n+        LOCK(cs); // mapDeltas, mapTx, nTransactionsUpdated\n         CAmount &delta = mapDeltas[hash];\n         delta += nFeeDelta;\n         txiter it = mapTx.find(hash);\n@@ -862,7 +862,7 @@ void CTxMemPool::PrioritiseTransaction(const uint256& hash, const CAmount& nFeeD\n \n void CTxMemPool::ApplyDelta(const uint256 hash, CAmount &nFeeDelta) const\n {\n-    LOCK(cs);\n+    LOCK(cs); // mapDeltas\n     std::map<uint256, CAmount>::const_iterator pos = mapDeltas.find(hash);\n     if (pos == mapDeltas.end())\n         return;\n@@ -872,7 +872,7 @@ void CTxMemPool::ApplyDelta(const uint256 hash, CAmount &nFeeDelta) const\n \n void CTxMemPool::ClearPrioritisation(const uint256 hash)\n {\n-    LOCK(cs);\n+    LOCK(cs); // mapDeltas\n     mapDeltas.erase(hash);\n }\n \n@@ -903,7 +903,7 @@ bool CCoinsViewMemPool::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n }\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n-    LOCK(cs);\n+    LOCK(cs); // mapTx, cachedInnerUsage\n     // Estimate the overhead of mapTx to be 15 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n     return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 15 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + memusage::DynamicUsage(mapLinks) + memusage::DynamicUsage(vTxHashes) + cachedInnerUsage;\n }\n@@ -917,7 +917,7 @@ void CTxMemPool::RemoveStaged(setEntries &stage, bool updateDescendants, MemPool\n }\n \n int CTxMemPool::Expire(int64_t time) {\n-    LOCK(cs);\n+    LOCK(cs); // RemoveStaged(...), mapTx\n     indexed_transaction_set::index<entry_time>::type::iterator it = mapTx.get<entry_time>().begin();\n     setEntries toremove;\n     while (it != mapTx.get<entry_time>().end() && it->GetTime() < time) {\n@@ -979,7 +979,7 @@ const CTxMemPool::setEntries & CTxMemPool::GetMemPoolChildren(txiter entry) cons\n }\n \n CFeeRate CTxMemPool::GetMinFee(size_t sizelimit) const {\n-    LOCK(cs);\n+    LOCK(cs); // rollingMinimumFeeRate, blockSinceLastRollingFeeBump, lastRollingFeeUpdate\n     if (!blockSinceLastRollingFeeBump || rollingMinimumFeeRate == 0)\n         return CFeeRate(rollingMinimumFeeRate);\n \n@@ -1011,7 +1011,7 @@ void CTxMemPool::trackPackageRemoved(const CFeeRate& rate) {\n }\n \n void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<COutPoint>* pvNoSpendsRemaining) {\n-    LOCK(cs);\n+    LOCK(cs); // RemoveStaged(...), mapTx, trackPackageRemoved(...)\n \n     unsigned nTxnRemoved = 0;\n     CFeeRate maxFeeRateRemoved(0);\n@@ -1054,7 +1054,7 @@ void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<COutPoint>* pvNoSpends\n }\n \n bool CTxMemPool::TransactionWithinChainLimit(const uint256& txid, size_t chainLimit) const {\n-    LOCK(cs);\n+    LOCK(cs); // mapTx\n     auto it = mapTx.find(txid);\n     return it == mapTx.end() || (it->GetCountWithAncestors() < chainLimit &&\n        it->GetCountWithDescendants() < chainLimit);"
      },
      {
        "sha": "2fbc8db06b5e6c2bdfc728b024eb4d1f6acaca78",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -599,19 +599,19 @@ class CTxMemPool\n \n     unsigned long size()\n     {\n-        LOCK(cs);\n+        LOCK(cs); // mapTx\n         return mapTx.size();\n     }\n \n     uint64_t GetTotalTxSize() const\n     {\n-        LOCK(cs);\n+        LOCK(cs); // totalTxSize\n         return totalTxSize;\n     }\n \n     bool exists(uint256 hash) const\n     {\n-        LOCK(cs);\n+        LOCK(cs); // mapTx\n         return (mapTx.count(hash) != 0);\n     }\n "
      },
      {
        "sha": "e05f0d3239a99d4136c053dcfc82856d5216b3ad",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -385,7 +385,7 @@ static void InterpretNegativeSetting(std::string& strKey, std::string& strValue)\n \n void ArgsManager::ParseParameters(int argc, const char* const argv[])\n {\n-    LOCK(cs_args);\n+    LOCK(cs_args); // mapArgs, mapMultiArgs\n     mapArgs.clear();\n     mapMultiArgs.clear();\n \n@@ -421,37 +421,37 @@ void ArgsManager::ParseParameters(int argc, const char* const argv[])\n \n std::vector<std::string> ArgsManager::GetArgs(const std::string& strArg) const\n {\n-    LOCK(cs_args);\n+    LOCK(cs_args); // mapMultiArgs\n     auto it = mapMultiArgs.find(strArg);\n     if (it != mapMultiArgs.end()) return it->second;\n     return {};\n }\n \n bool ArgsManager::IsArgSet(const std::string& strArg) const\n {\n-    LOCK(cs_args);\n+    LOCK(cs_args); // mapArgs\n     return mapArgs.count(strArg);\n }\n \n std::string ArgsManager::GetArg(const std::string& strArg, const std::string& strDefault) const\n {\n-    LOCK(cs_args);\n+    LOCK(cs_args); // mapArgs\n     auto it = mapArgs.find(strArg);\n     if (it != mapArgs.end()) return it->second;\n     return strDefault;\n }\n \n int64_t ArgsManager::GetArg(const std::string& strArg, int64_t nDefault) const\n {\n-    LOCK(cs_args);\n+    LOCK(cs_args); // mapArgs\n     auto it = mapArgs.find(strArg);\n     if (it != mapArgs.end()) return atoi64(it->second);\n     return nDefault;\n }\n \n bool ArgsManager::GetBoolArg(const std::string& strArg, bool fDefault) const\n {\n-    LOCK(cs_args);\n+    LOCK(cs_args); // mapArgs\n     auto it = mapArgs.find(strArg);\n     if (it != mapArgs.end()) return InterpretBool(it->second);\n     return fDefault;\n@@ -475,7 +475,7 @@ bool ArgsManager::SoftSetBoolArg(const std::string& strArg, bool fValue)\n \n void ArgsManager::ForceSetArg(const std::string& strArg, const std::string& strValue)\n {\n-    LOCK(cs_args);\n+    LOCK(cs_args); // mapArgs, mapMultiArgs\n     mapArgs[strArg] = strValue;\n     mapMultiArgs[strArg] = {strValue};\n }\n@@ -581,7 +581,7 @@ const fs::path &GetDataDir(bool fNetSpecific)\n \n void ClearDatadirCache()\n {\n-    LOCK(csPathCached);\n+    LOCK(csPathCached); // pathCached, pathCachedNetSpecific\n \n     pathCached = fs::path();\n     pathCachedNetSpecific = fs::path();\n@@ -603,7 +603,7 @@ void ArgsManager::ReadConfigFile(const std::string& confPath)\n         return; // No bitcoin.conf file is OK\n \n     {\n-        LOCK(cs_args);\n+        LOCK(cs_args); // mapArgs, mapMultiArgs\n         std::set<std::string> setOptions;\n         setOptions.insert(\"*\");\n "
      },
      {
        "sha": "2cd43a2b4b21ff57dcf3dc3d505a2f842612d771",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 29,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -485,7 +485,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n     // Check for conflicts with in-memory transactions\n     std::set<uint256> setConflicts;\n     {\n-    LOCK(pool.cs); // protect pool.mapNextTx\n+    LOCK(pool.cs); // mapNextTx\n     for (const CTxIn &txin : tx.vin)\n     {\n         auto itConflicting = pool.mapNextTx.find(txin.prevout);\n@@ -670,7 +670,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // If we don't hold the lock allConflicting might be incomplete; the\n         // subsequent RemoveStaged() and addUnchecked() calls don't guarantee\n         // mempool consistency for us.\n-        LOCK(pool.cs);\n+        LOCK(pool.cs); // mapTx\n         const bool fReplacementTransaction = setConflicts.size();\n         if (fReplacementTransaction)\n         {\n@@ -907,7 +907,7 @@ bool GetTransaction(const uint256 &hash, CTransactionRef &txOut, const Consensus\n {\n     CBlockIndex *pindexSlow = nullptr;\n \n-    LOCK(cs_main);\n+    LOCK(cs_main); // pblocktree, chainActive\n \n     CTransactionRef ptx = mempool.get(hash);\n     if (ptx)\n@@ -1044,7 +1044,7 @@ bool IsInitialBlockDownload()\n     if (latchToFalse.load(std::memory_order_relaxed))\n         return false;\n \n-    LOCK(cs_main);\n+    LOCK(cs_main); // chainActive\n     if (latchToFalse.load(std::memory_order_relaxed))\n         return false;\n     if (fImporting || fReindex)\n@@ -1208,7 +1208,7 @@ bool CScriptCheck::operator()() {\n \n int GetSpendHeight(const CCoinsViewCache& inputs)\n {\n-    LOCK(cs_main);\n+    LOCK(cs_main); // mapBlockIndex\n     CBlockIndex* pindexPrev = mapBlockIndex.find(inputs.GetBestBlock())->second;\n     return pindexPrev->nHeight + 1;\n }\n@@ -1510,7 +1510,7 @@ static DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex*\n \n void static FlushBlockFile(bool fFinalize = false)\n {\n-    LOCK(cs_LastBlockFile);\n+    LOCK(cs_LastBlockFile); // nLastBlockFile\n \n     CDiskBlockPos posOld(nLastBlockFile, 0);\n \n@@ -1872,7 +1872,7 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n  */\n bool static FlushStateToDisk(const CChainParams& chainparams, CValidationState &state, FlushStateMode mode, int nManualPruneHeight) {\n     int64_t nMempoolUsage = mempool.DynamicMemoryUsage();\n-    LOCK(cs_main);\n+    LOCK(cs_main); // pcoinsTip, pblocktree, chainActive\n     static int64_t nLastWrite = 0;\n     static int64_t nLastFlush = 0;\n     static int64_t nLastSetChain = 0;\n@@ -1882,7 +1882,7 @@ bool static FlushStateToDisk(const CChainParams& chainparams, CValidationState &\n     int64_t nNow = 0;\n     try {\n     {\n-        LOCK(cs_LastBlockFile);\n+        LOCK(cs_LastBlockFile); // nLastBlockFile, fCheckForPruning\n         if (fPruneMode && (fCheckForPruning || nManualPruneHeight > 0) && !fReindex) {\n             if (nManualPruneHeight > 0) {\n                 FindFilesToPruneManual(setFilesToPrune, nManualPruneHeight);\n@@ -2439,7 +2439,7 @@ bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams,\n         const CBlockIndex *pindexFork;\n         bool fInitialDownload;\n         {\n-            LOCK(cs_main);\n+            LOCK(cs_main); // chainActive, ActivateBestChainStep(...), FindMostWorkChain(...)\n             ConnectTrace connectTrace(mempool); // Destructed before cs_main is unlocked\n \n             CBlockIndex *pindexOldTip = chainActive.Tip();\n@@ -2497,7 +2497,7 @@ bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams,\n bool PreciousBlock(CValidationState& state, const CChainParams& params, CBlockIndex *pindex)\n {\n     {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // PruneBlockIndexCandidates(...), chainActive\n         if (pindex->nChainWork < chainActive.Tip()->nChainWork) {\n             // Nothing to do, this block is not at the tip.\n             return true;\n@@ -2661,7 +2661,7 @@ static bool ReceivedBlockTransactions(const CBlock &block, CValidationState& sta\n             queue.pop_front();\n             pindex->nChainTx = (pindex->pprev ? pindex->pprev->nChainTx : 0) + pindex->nTx;\n             {\n-                LOCK(cs_nBlockSequenceId);\n+                LOCK(cs_nBlockSequenceId); // nBlockSequenceId\n                 pindex->nSequenceId = nBlockSequenceId++;\n             }\n             if (chainActive.Tip() == nullptr || !setBlockIndexCandidates.value_comp()(pindex, chainActive.Tip())) {\n@@ -2686,7 +2686,7 @@ static bool ReceivedBlockTransactions(const CBlock &block, CValidationState& sta\n \n static bool FindBlockPos(CValidationState &state, CDiskBlockPos &pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown = false)\n {\n-    LOCK(cs_LastBlockFile);\n+    LOCK(cs_LastBlockFile); // nLastBlockFile, fCheckForPruning\n \n     unsigned int nFile = fKnown ? pos.nFile : nLastBlockFile;\n     if (vinfoBlockFile.size() <= nFile) {\n@@ -2745,7 +2745,7 @@ static bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos,\n {\n     pos.nFile = nFile;\n \n-    LOCK(cs_LastBlockFile);\n+    LOCK(cs_LastBlockFile); // fCheckForPruning\n \n     unsigned int nNewSize;\n     pos.nPos = vinfoBlockFile[nFile].nUndoSize;\n@@ -3077,7 +3077,7 @@ static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state\n bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& headers, CValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex)\n {\n     {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // AcceptBlockHeader(...)\n         for (const CBlockHeader& header : headers) {\n             CBlockIndex *pindex = nullptr; // Use a temp pindex instead of ppindex to avoid a const_cast\n             if (!AcceptBlockHeader(header, state, chainparams, &pindex)) {\n@@ -3182,7 +3182,7 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n         // belt-and-suspenders.\n         bool ret = CheckBlock(*pblock, state, chainparams.GetConsensus());\n \n-        LOCK(cs_main);\n+        LOCK(cs_main); // AcceptBlock(...)\n \n         if (ret) {\n             // Store to disk\n@@ -3289,7 +3289,7 @@ static void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPr\n {\n     assert(fPruneMode && nManualPruneHeight > 0);\n \n-    LOCK2(cs_main, cs_LastBlockFile);\n+    LOCK2(cs_main, cs_LastBlockFile); // chainActive, PruneOneBlockFile(...), nLastBlockFile\n     if (chainActive.Tip() == nullptr)\n         return;\n \n@@ -3331,7 +3331,7 @@ void PruneBlockFilesManual(int nManualPruneHeight)\n  */\n static void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight)\n {\n-    LOCK2(cs_main, cs_LastBlockFile);\n+    LOCK2(cs_main, cs_LastBlockFile); // chainActive, PruneOneBlockFile(...), nLastBlockFile\n     if (chainActive.Tip() == nullptr || nPruneTarget == 0) {\n         return;\n     }\n@@ -3582,7 +3582,7 @@ CVerifyDB::~CVerifyDB()\n \n bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview, int nCheckLevel, int nCheckDepth)\n {\n-    LOCK(cs_main);\n+    LOCK(cs_main); // pcoinsTip, chainActive, ConnectBlock(...)\n     if (chainActive.Tip() == nullptr || chainActive.Tip()->pprev == nullptr)\n         return true;\n \n@@ -3697,7 +3697,7 @@ static bool RollforwardBlock(const CBlockIndex* pindex, CCoinsViewCache& inputs,\n \n bool ReplayBlocks(const CChainParams& params, CCoinsView* view)\n {\n-    LOCK(cs_main);\n+    LOCK(cs_main); // mapBlockIndex\n \n     CCoinsViewCache cache(view);\n \n@@ -3762,7 +3762,7 @@ bool ReplayBlocks(const CChainParams& params, CCoinsView* view)\n \n bool RewindBlockIndex(const CChainParams& params)\n {\n-    LOCK(cs_main);\n+    LOCK(cs_main); // PruneBlockIndexCandidates(...), chainActive, mapBlockIndex, DisconnectTip(...)\n \n     // Note that during -reindex-chainstate we are called with an empty chainActive!\n \n@@ -3858,7 +3858,7 @@ bool RewindBlockIndex(const CChainParams& params)\n // block index state\n void UnloadBlockIndex()\n {\n-    LOCK(cs_main);\n+    LOCK(cs_main); // mapBlockIndex, chainActive, versionbitscache, warningcache\n     setBlockIndexCandidates.clear();\n     chainActive.SetTip(nullptr);\n     pindexBestInvalid = nullptr;\n@@ -3909,7 +3909,7 @@ bool LoadBlockIndex(const CChainParams& chainparams)\n \n bool LoadGenesisBlock(const CChainParams& chainparams)\n {\n-    LOCK(cs_main);\n+    LOCK(cs_main); // AddToBlockIndex(...), mapBlockIndex\n \n     // Check whether we're already initialized by checking for genesis in\n     // mapBlockIndex. Note that we can't use chainActive here, since it is\n@@ -4030,7 +4030,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n                         {\n                             LogPrint(BCLog::REINDEX, \"%s: Processing out of order child %s of %s\\n\", __func__, pblockrecursive->GetHash().ToString(),\n                                     head.ToString());\n-                            LOCK(cs_main);\n+                            LOCK(cs_main); // AcceptBlock(...)\n                             CValidationState dummy;\n                             if (AcceptBlock(pblockrecursive, dummy, chainparams, nullptr, true, &it->second, nullptr))\n                             {\n@@ -4061,7 +4061,7 @@ void static CheckBlockIndex(const Consensus::Params& consensusParams)\n         return;\n     }\n \n-    LOCK(cs_main);\n+    LOCK(cs_main); // chainActive, mapBlockIndex\n \n     // During a reindex, we read the genesis block and call CheckBlockIndex before ActivateBestChain,\n     // so we have the genesis block in mapBlockIndex but no active chain.  (A few of the tests when\n@@ -4251,19 +4251,19 @@ CBlockFileInfo* GetBlockFileInfo(size_t n)\n \n ThresholdState VersionBitsTipState(const Consensus::Params& params, Consensus::DeploymentPos pos)\n {\n-    LOCK(cs_main);\n+    LOCK(cs_main); // chainActive\n     return VersionBitsState(chainActive.Tip(), params, pos, versionbitscache);\n }\n \n BIP9Stats VersionBitsTipStatistics(const Consensus::Params& params, Consensus::DeploymentPos pos)\n {\n-    LOCK(cs_main);\n+    LOCK(cs_main); // chainActive\n     return VersionBitsStatistics(chainActive.Tip(), params, pos);\n }\n \n int VersionBitsTipStateSinceHeight(const Consensus::Params& params, Consensus::DeploymentPos pos)\n {\n-    LOCK(cs_main);\n+    LOCK(cs_main); // chainActive\n     return VersionBitsStateSinceHeight(chainActive.Tip(), params, pos, versionbitscache);\n }\n \n@@ -4307,7 +4307,7 @@ bool LoadMempool(void)\n             }\n             CValidationState state;\n             if (nTime + nExpiryTimeout > nNow) {\n-                LOCK(cs_main);\n+                LOCK(cs_main); // AcceptToMemoryPoolWithTime(...)\n                 AcceptToMemoryPoolWithTime(chainparams, mempool, state, tx, true, nullptr, nTime, nullptr, false, 0);\n                 if (state.IsValid()) {\n                     ++count;\n@@ -4343,7 +4343,7 @@ bool DumpMempool(void)\n     std::vector<TxMempoolInfo> vinfo;\n \n     {\n-        LOCK(mempool.cs);\n+        LOCK(mempool.cs); // mapDeltas\n         for (const auto &i : mempool.mapDeltas) {\n             mapDeltas[i.first] = i.second;\n         }"
      },
      {
        "sha": "b9b1be877367e651349d87d9111616f2b09ddcce",
        "filename": "src/wallet/crypter.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/crypter.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -143,7 +143,7 @@ static bool DecryptKey(const CKeyingMaterial& vMasterKey, const std::vector<unsi\n \n bool CCryptoKeyStore::SetCrypted()\n {\n-    LOCK(cs_KeyStore);\n+    LOCK(cs_KeyStore); // mapKeys\n     if (fUseCrypto)\n         return true;\n     if (!mapKeys.empty())\n@@ -158,7 +158,7 @@ bool CCryptoKeyStore::Lock()\n         return false;\n \n     {\n-        LOCK(cs_KeyStore);\n+        LOCK(cs_KeyStore); // vMasterKey\n         vMasterKey.clear();\n     }\n \n@@ -169,7 +169,7 @@ bool CCryptoKeyStore::Lock()\n bool CCryptoKeyStore::Unlock(const CKeyingMaterial& vMasterKeyIn)\n {\n     {\n-        LOCK(cs_KeyStore);\n+        LOCK(cs_KeyStore); // mapCryptedKeys, vMasterKey\n         if (!SetCrypted())\n             return false;\n \n@@ -229,7 +229,7 @@ bool CCryptoKeyStore::AddKeyPubKey(const CKey& key, const CPubKey &pubkey)\n bool CCryptoKeyStore::AddCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret)\n {\n     {\n-        LOCK(cs_KeyStore);\n+        LOCK(cs_KeyStore); // mapCryptedKeys\n         if (!SetCrypted())\n             return false;\n \n@@ -241,7 +241,7 @@ bool CCryptoKeyStore::AddCryptedKey(const CPubKey &vchPubKey, const std::vector<\n bool CCryptoKeyStore::GetKey(const CKeyID &address, CKey& keyOut) const\n {\n     {\n-        LOCK(cs_KeyStore);\n+        LOCK(cs_KeyStore); // mapCryptedKeys\n         if (!IsCrypted())\n             return CBasicKeyStore::GetKey(address, keyOut);\n \n@@ -259,7 +259,7 @@ bool CCryptoKeyStore::GetKey(const CKeyID &address, CKey& keyOut) const\n bool CCryptoKeyStore::GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const\n {\n     {\n-        LOCK(cs_KeyStore);\n+        LOCK(cs_KeyStore); // mapCryptedKeys\n         if (!IsCrypted())\n             return CBasicKeyStore::GetPubKey(address, vchPubKeyOut);\n \n@@ -277,7 +277,7 @@ bool CCryptoKeyStore::GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) co\n bool CCryptoKeyStore::EncryptKeys(CKeyingMaterial& vMasterKeyIn)\n {\n     {\n-        LOCK(cs_KeyStore);\n+        LOCK(cs_KeyStore); // mapKeys, mapCryptedKeys\n         if (!mapCryptedKeys.empty() || IsCrypted())\n             return false;\n "
      },
      {
        "sha": "b422aed1c9b790770f1045893bc8b0c8c3832be1",
        "filename": "src/wallet/crypter.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/crypter.h?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -148,7 +148,7 @@ class CCryptoKeyStore : public CBasicKeyStore\n             return false;\n         bool result;\n         {\n-            LOCK(cs_KeyStore);\n+            LOCK(cs_KeyStore); // vMasterKey\n             result = vMasterKey.empty();\n         }\n         return result;\n@@ -161,7 +161,7 @@ class CCryptoKeyStore : public CBasicKeyStore\n     bool HaveKey(const CKeyID &address) const override\n     {\n         {\n-            LOCK(cs_KeyStore);\n+            LOCK(cs_KeyStore); // mapCryptedKeys\n             if (!IsCrypted()) {\n                 return CBasicKeyStore::HaveKey(address);\n             }\n@@ -173,7 +173,7 @@ class CCryptoKeyStore : public CBasicKeyStore\n     bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override;\n     std::set<CKeyID> GetKeys() const override\n     {\n-        LOCK(cs_KeyStore);\n+        LOCK(cs_KeyStore); // mapCryptedKeys\n         if (!IsCrypted()) {\n             return CBasicKeyStore::GetKeys();\n         }"
      },
      {
        "sha": "d8641bd7824ed85ec7c3cd3b0387e13ac248c9f4",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -145,7 +145,7 @@ void CDBEnv::MakeMock()\n \n CDBEnv::VerifyResult CDBEnv::Verify(const std::string& strFile, recoverFunc_type recoverFunc, std::string& out_backup_filename)\n {\n-    LOCK(cs_db);\n+    LOCK(cs_db); // mapFileUseCount\n     assert(mapFileUseCount.count(strFile) == 0);\n \n     Db db(dbenv, 0);\n@@ -291,7 +291,7 @@ static const char *DATA_END = \"DATA=END\";\n \n bool CDBEnv::Salvage(const std::string& strFile, bool fAggressive, std::vector<CDBEnv::KeyValPair>& vResult)\n {\n-    LOCK(cs_db);\n+    LOCK(cs_db); // mapFileUseCount\n     assert(mapFileUseCount.count(strFile) == 0);\n \n     u_int32_t flags = DB_SALVAGE;\n@@ -452,15 +452,15 @@ void CDB::Close()\n         Flush();\n \n     {\n-        LOCK(env->cs_db);\n+        LOCK(env->cs_db); // mapFileUseCount\n         --env->mapFileUseCount[strFile];\n     }\n }\n \n void CDBEnv::CloseDb(const std::string& strFile)\n {\n     {\n-        LOCK(cs_db);\n+        LOCK(cs_db); // mapDb\n         if (mapDb[strFile] != nullptr) {\n             // Close the database handle\n             Db* pdb = mapDb[strFile];\n@@ -480,7 +480,7 @@ bool CDB::Rewrite(CWalletDBWrapper& dbw, const char* pszSkip)\n     const std::string& strFile = dbw.strFile;\n     while (true) {\n         {\n-            LOCK(env->cs_db);\n+            LOCK(env->cs_db); // mapFileUseCount\n             if (!env->mapFileUseCount.count(strFile) || env->mapFileUseCount[strFile] == 0) {\n                 // Flush log data to the dat file\n                 env->CloseDb(strFile);\n@@ -569,7 +569,7 @@ void CDBEnv::Flush(bool fShutdown)\n     if (!fDbEnvInit)\n         return;\n     {\n-        LOCK(cs_db);\n+        LOCK(cs_db); // mapFileUseCount\n         std::map<std::string, int>::iterator mi = mapFileUseCount.begin();\n         while (mi != mapFileUseCount.end()) {\n             std::string strFile = (*mi).first;\n@@ -657,7 +657,7 @@ bool CWalletDBWrapper::Backup(const std::string& strDest)\n     while (true)\n     {\n         {\n-            LOCK(env->cs_db);\n+            LOCK(env->cs_db); // mapFileUseCount\n             if (!env->mapFileUseCount.count(strFile) || env->mapFileUseCount[strFile] == 0)\n             {\n                 // Flush log data to the dat file"
      },
      {
        "sha": "f844263c54ceba252e0fd0487f52bb7f3b42a837",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -51,7 +51,7 @@ bool CFeeBumper::preconditionChecks(const CWallet *pWallet, const CWalletTx& wtx\n     }\n \n     {\n-        LOCK(mempool.cs);\n+        LOCK(mempool.cs); // mapTx\n         auto it_mp = mempool.mapTx.find(wtx.GetHash());\n         if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n             vErrors.push_back(\"Transaction has descendants in the mempool\");"
      },
      {
        "sha": "d551efe3ac15e134ad59908832ea627f0039d14f",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -101,7 +101,7 @@ UniValue importprivkey(const JSONRPCRequest& request)\n         );\n \n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LOCK2(cs_main, pwallet->cs_wallet); // mapKeyMetadata\n \n     EnsureWalletIsUnlocked(pwallet);\n \n@@ -319,7 +319,7 @@ UniValue importprunedfunds(const JSONRPCRequest& request)\n     unsigned int txnIndex = 0;\n     if (merkleBlock.txn.ExtractMatches(vMatch, vIndex) == merkleBlock.header.hashMerkleRoot) {\n \n-        LOCK(cs_main);\n+        LOCK(cs_main); // chainActive, mapBlockIndex\n \n         if (!mapBlockIndex.count(merkleBlock.header.GetHash()) || !chainActive.Contains(mapBlockIndex[merkleBlock.header.GetHash()]))\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found in chain\");\n@@ -471,7 +471,7 @@ UniValue importwallet(const JSONRPCRequest& request)\n     if (fPruneMode)\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Importing wallets is disabled in pruned mode\");\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LOCK2(cs_main, pwallet->cs_wallet); // chainActive, mapKeyMetadata\n \n     EnsureWalletIsUnlocked(pwallet);\n \n@@ -612,7 +612,7 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"dumpwallet\", \"\\\"test\\\"\")\n         );\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LOCK2(cs_main, pwallet->cs_wallet); // chainActive, mapKeyMetadata, mapAddressBook\n \n     EnsureWalletIsUnlocked(pwallet);\n \n@@ -1079,7 +1079,7 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n         }\n     }\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LOCK2(cs_main, pwallet->cs_wallet); // chainActive, ProcessImport(...)\n     EnsureWalletIsUnlocked(pwallet);\n \n     // Verify all timestamps are present before importing any keys."
      },
      {
        "sha": "1d72ae35f8ff7f62b205e209c1b296db862a934f",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -275,7 +275,7 @@ UniValue setaccount(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"setaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\", \\\"tabby\\\"\")\n         );\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LOCK2(cs_main, pwallet->cs_wallet); // mapAddressBook\n \n     CTxDestination dest = DecodeDestination(request.params[0].get_str());\n     if (!IsValidDestination(dest)) {\n@@ -324,7 +324,7 @@ UniValue getaccount(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\"\")\n         );\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LOCK2(cs_main, pwallet->cs_wallet); // mapAddressBook\n \n     CTxDestination dest = DecodeDestination(request.params[0].get_str());\n     if (!IsValidDestination(dest)) {\n@@ -363,7 +363,7 @@ UniValue getaddressesbyaccount(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getaddressesbyaccount\", \"\\\"tabby\\\"\")\n         );\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LOCK2(cs_main, pwallet->cs_wallet); // mapAddressBook\n \n     std::string strAccount = AccountFromValue(request.params[0]);\n \n@@ -533,7 +533,7 @@ UniValue listaddressgroupings(const JSONRPCRequest& request)\n         );\n \n     ObserveSafeMode();\n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LOCK2(cs_main, pwallet->cs_wallet); // mapAddressBook\n \n     UniValue jsonGroupings(UniValue::VARR);\n     std::map<CTxDestination, CAmount> balances = pwallet->GetAddressBalances();\n@@ -645,7 +645,7 @@ UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n        );\n \n     ObserveSafeMode();\n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LOCK2(cs_main, pwallet->cs_wallet); // mapWallet\n \n     // Bitcoin address\n     CTxDestination dest = DecodeDestination(request.params[0].get_str());\n@@ -707,7 +707,7 @@ UniValue getreceivedbyaccount(const JSONRPCRequest& request)\n         );\n \n     ObserveSafeMode();\n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LOCK2(cs_main, pwallet->cs_wallet); // mapWallet\n \n     // Minimum confirmations\n     int nMinDepth = 1;\n@@ -1229,7 +1229,7 @@ UniValue addwitnessaddress(const JSONRPCRequest& request)\n     }\n \n     {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // chainActive\n         if (!IsWitnessEnabled(chainActive.Tip(), Params().GetConsensus()) && !gArgs.GetBoolArg(\"-walletprematurewitness\", false)) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Segregated witness not enabled on network\");\n         }\n@@ -1423,7 +1423,7 @@ UniValue listreceivedbyaddress(const JSONRPCRequest& request)\n         );\n \n     ObserveSafeMode();\n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LOCK2(cs_main, pwallet->cs_wallet); // ListReceived(...)\n \n     return ListReceived(pwallet, request.params, false);\n }\n@@ -1463,7 +1463,7 @@ UniValue listreceivedbyaccount(const JSONRPCRequest& request)\n         );\n \n     ObserveSafeMode();\n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LOCK2(cs_main, pwallet->cs_wallet); // ListReceived(...)\n \n     return ListReceived(pwallet, request.params, true);\n }\n@@ -1651,7 +1651,7 @@ UniValue listtransactions(const JSONRPCRequest& request)\n         );\n \n     ObserveSafeMode();\n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LOCK2(cs_main, pwallet->cs_wallet); // ListTransactions(...)\n \n     std::string strAccount = \"*\";\n     if (!request.params[0].isNull())\n@@ -1745,7 +1745,7 @@ UniValue listaccounts(const JSONRPCRequest& request)\n         );\n \n     ObserveSafeMode();\n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LOCK2(cs_main, pwallet->cs_wallet); // mapWallet, mapAddressBook\n \n     int nMinDepth = 1;\n     if (!request.params[0].isNull())\n@@ -1854,7 +1854,7 @@ UniValue listsinceblock(const JSONRPCRequest& request)\n         );\n \n     ObserveSafeMode();\n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LOCK2(cs_main, pwallet->cs_wallet); // chainActive, ListTransactions(...), mapBlockIndex, mapWallet\n \n     const CBlockIndex* pindex = nullptr;    // Block index of the specified block or the common ancestor, if the block provided was in a deactivated chain.\n     const CBlockIndex* paltindex = nullptr; // Block index of the specified block, even if it's in a deactivated chain.\n@@ -1986,7 +1986,7 @@ UniValue gettransaction(const JSONRPCRequest& request)\n         );\n \n     ObserveSafeMode();\n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LOCK2(cs_main, pwallet->cs_wallet); // ListTransactions(...), WalletTxToJSON(...), mapWallet\n \n     uint256 hash;\n     hash.SetHex(request.params[0].get_str());\n@@ -2048,7 +2048,7 @@ UniValue abandontransaction(const JSONRPCRequest& request)\n         );\n \n     ObserveSafeMode();\n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LOCK2(cs_main, pwallet->cs_wallet); // mapWallet\n \n     uint256 hash;\n     hash.SetHex(request.params[0].get_str());\n@@ -2112,7 +2112,7 @@ UniValue keypoolrefill(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"keypoolrefill\", \"\")\n         );\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LOCK2(cs_main, pwallet->cs_wallet); // GetKeyPoolSize(...)\n \n     // 0 is interpreted by TopUpKeyPool() as the default keypool size given by -keypool\n     unsigned int kpSize = 0;\n@@ -2560,7 +2560,7 @@ UniValue getwalletinfo(const JSONRPCRequest& request)\n         );\n \n     ObserveSafeMode();\n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LOCK2(cs_main, pwallet->cs_wallet); // CanSupportFeature(...), GetKeyPoolSize(...), mapWallet\n \n     UniValue obj(UniValue::VOBJ);\n \n@@ -2772,7 +2772,7 @@ UniValue listunspent(const JSONRPCRequest& request)\n     UniValue results(UniValue::VARR);\n     std::vector<COutput> vecOutputs;\n     assert(pwallet != nullptr);\n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LOCK2(cs_main, pwallet->cs_wallet); // mapAddressBook\n \n     pwallet->AvailableCoins(vecOutputs, !include_unsafe, nullptr, nMinimumAmount, nMaximumAmount, nMinimumSumAmount, nMaximumCount, nMinDepth, nMaxDepth);\n     for (const COutput& out : vecOutputs) {"
      },
      {
        "sha": "930246346c141306f069b50fc485aa3f73899bd9",
        "filename": "src/wallet/test/accounting_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/test/accounting_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/test/accounting_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/accounting_tests.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -35,7 +35,7 @@ BOOST_AUTO_TEST_CASE(acc_orderupgrade)\n     CAccountingEntry ae;\n     std::map<CAmount, CAccountingEntry> results;\n \n-    LOCK(pwalletMain->cs_wallet);\n+    LOCK(pwalletMain->cs_wallet); // mapWallet, nOrderPosNext\n \n     ae.strAccount = \"\";\n     ae.nCreditDebit = 1;"
      },
      {
        "sha": "7e17e3e023db92e15f8771d013047d3062d7cfb3",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -372,7 +372,7 @@ static void AddKey(CWallet& wallet, const CKey& key)\n \n BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n {\n-    LOCK(cs_main);\n+    LOCK(cs_main); // chainActive\n \n     // Cap last block file size, and mine new block in a new block file.\n     CBlockIndex* const nullBlock = nullptr;\n@@ -449,7 +449,7 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n // than or equal to key birthday.\n BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n {\n-    LOCK(cs_main);\n+    LOCK(cs_main); // chainActive\n \n     // Create two blocks with same timestamp to verify that importwallet rescan\n     // will pick up both blocks, not just the first.\n@@ -467,7 +467,7 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n     // Import key into wallet and call dumpwallet to create backup file.\n     {\n         CWallet wallet;\n-        LOCK(wallet.cs_wallet);\n+        LOCK(wallet.cs_wallet); // mapKeyMetadata\n         wallet.mapKeyMetadata[coinbaseKey.GetPubKey().GetID()].nCreateTime = KEY_TIME;\n         wallet.AddKeyPubKey(coinbaseKey, coinbaseKey.GetPubKey());\n \n@@ -512,7 +512,7 @@ BOOST_FIXTURE_TEST_CASE(coin_mark_dirty_immature_credit, TestChain100Setup)\n {\n     CWallet wallet;\n     CWalletTx wtx(&wallet, MakeTransactionRef(coinbaseTxns.back()));\n-    LOCK2(cs_main, wallet.cs_wallet);\n+    LOCK2(cs_main, wallet.cs_wallet); // chainActive\n     wtx.hashBlock = chainActive.Tip()->GetBlockHash();\n     wtx.nIndex = 0;\n \n@@ -638,7 +638,7 @@ class ListCoinsTestingSetup : public TestChain100Setup\n BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n {\n     std::string coinbaseAddress = coinbaseKey.GetPubKey().GetID().ToString();\n-    LOCK2(cs_main, wallet->cs_wallet);\n+    LOCK2(cs_main, wallet->cs_wallet); // AddTx(...)\n \n     // Confirm ListCoins initially returns 1 coin grouped under coinbaseKey\n     // address."
      },
      {
        "sha": "3d9be60dc7a8d9ad6a59c61630e2b3dd59b331fc",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 48,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -116,7 +116,7 @@ class CAffectedKeysVisitor : public boost::static_visitor<void> {\n \n const CWalletTx* CWallet::GetWalletTx(const uint256& hash) const\n {\n-    LOCK(cs_wallet);\n+    LOCK(cs_wallet); // mapWallet\n     std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(hash);\n     if (it == mapWallet.end())\n         return nullptr;\n@@ -252,7 +252,7 @@ bool CWallet::AddCryptedKey(const CPubKey &vchPubKey,\n     if (!CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret))\n         return false;\n     {\n-        LOCK(cs_wallet);\n+        LOCK(cs_wallet); // mapKeyMetadata\n         if (pwalletdbEncryption)\n             return pwalletdbEncryption->WriteCryptedKey(vchPubKey,\n                                                         vchCryptedSecret,\n@@ -356,7 +356,7 @@ bool CWallet::Unlock(const SecureString& strWalletPassphrase)\n     CKeyingMaterial _vMasterKey;\n \n     {\n-        LOCK(cs_wallet);\n+        LOCK(cs_wallet); // mapMasterKeys\n         for (const MasterKeyMap::value_type& pMasterKey : mapMasterKeys)\n         {\n             if(!crypter.SetKeyFromPassphrase(strWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n@@ -375,7 +375,7 @@ bool CWallet::ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase,\n     bool fWasLocked = IsLocked();\n \n     {\n-        LOCK(cs_wallet);\n+        LOCK(cs_wallet); // mapMasterKeys\n         Lock();\n \n         CCrypter crypter;\n@@ -424,7 +424,7 @@ void CWallet::SetBestChain(const CBlockLocator& loc)\n \n bool CWallet::SetMinVersion(enum WalletFeature nVersion, CWalletDB* pwalletdbIn, bool fExplicit)\n {\n-    LOCK(cs_wallet); // nWalletVersion\n+    LOCK(cs_wallet); // nWalletVersion, nWalletMaxVersion\n     if (nWalletVersion >= nVersion)\n         return true;\n \n@@ -613,7 +613,7 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n         return false;\n \n     {\n-        LOCK(cs_wallet);\n+        LOCK(cs_wallet); // mapMasterKeys\n         mapMasterKeys[++nMasterKeyMaxID] = kMasterKey;\n         assert(!pwalletdbEncryption);\n         pwalletdbEncryption = new CWalletDB(*dbw);\n@@ -671,7 +671,7 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n \n DBErrors CWallet::ReorderTransactions()\n {\n-    LOCK(cs_wallet);\n+    LOCK(cs_wallet); // mapWallet, nOrderPosNext\n     CWalletDB walletdb(*dbw);\n \n     // Old wallets didn't have any defined order for transactions\n@@ -833,15 +833,15 @@ bool CWallet::GetAccountPubkey(CPubKey &pubKey, std::string strAccount, bool bFo\n void CWallet::MarkDirty()\n {\n     {\n-        LOCK(cs_wallet);\n+        LOCK(cs_wallet); // mapWallet\n         for (std::pair<const uint256, CWalletTx>& item : mapWallet)\n             item.second.MarkDirty();\n     }\n }\n \n bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n {\n-    LOCK(cs_wallet);\n+    LOCK(cs_wallet); // mapWallet\n \n     auto mi = mapWallet.find(originalHash);\n \n@@ -870,7 +870,7 @@ bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n \n bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose)\n {\n-    LOCK(cs_wallet);\n+    LOCK(cs_wallet); // IncOrderPosNext(...), AddToSpends(...), mapWallet\n \n     CWalletDB walletdb(*dbw, \"r+\", fFlushOnClose);\n \n@@ -1046,7 +1046,7 @@ bool CWallet::TransactionCanBeAbandoned(const uint256& hashTx) const\n \n bool CWallet::AbandonTransaction(const uint256& hashTx)\n {\n-    LOCK2(cs_main, cs_wallet);\n+    LOCK2(cs_main, cs_wallet); // mapWallet, mapTxSpends\n \n     CWalletDB walletdb(*dbw, \"r+\");\n \n@@ -1107,7 +1107,7 @@ bool CWallet::AbandonTransaction(const uint256& hashTx)\n \n void CWallet::MarkConflicted(const uint256& hashBlock, const uint256& hashTx)\n {\n-    LOCK2(cs_main, cs_wallet);\n+    LOCK2(cs_main, cs_wallet); // chainActive, mapBlockIndex, mapWallet, mapTxSpends\n \n     int conflictconfirms = 0;\n     if (mapBlockIndex.count(hashBlock)) {\n@@ -1184,12 +1184,12 @@ void CWallet::SyncTransaction(const CTransactionRef& ptx, const CBlockIndex *pin\n }\n \n void CWallet::TransactionAddedToMempool(const CTransactionRef& ptx) {\n-    LOCK2(cs_main, cs_wallet);\n+    LOCK2(cs_main, cs_wallet); // SyncTransaction(...)\n     SyncTransaction(ptx);\n }\n \n void CWallet::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex *pindex, const std::vector<CTransactionRef>& vtxConflicted) {\n-    LOCK2(cs_main, cs_wallet);\n+    LOCK2(cs_main, cs_wallet); // SyncTransaction(...)\n     // TODO: Temporarily ensure that mempool removals are notified before\n     // connected transactions.  This shouldn't matter, but the abandoned\n     // state of transactions in our wallet is currently cleared when we\n@@ -1207,7 +1207,7 @@ void CWallet::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const\n }\n \n void CWallet::BlockDisconnected(const std::shared_ptr<const CBlock>& pblock) {\n-    LOCK2(cs_main, cs_wallet);\n+    LOCK2(cs_main, cs_wallet); // SyncTransaction(...)\n \n     for (const CTransactionRef& ptx : pblock->vtx) {\n         SyncTransaction(ptx);\n@@ -1219,7 +1219,7 @@ void CWallet::BlockDisconnected(const std::shared_ptr<const CBlock>& pblock) {\n isminetype CWallet::IsMine(const CTxIn &txin) const\n {\n     {\n-        LOCK(cs_wallet);\n+        LOCK(cs_wallet); // mapWallet\n         std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n         if (mi != mapWallet.end())\n         {\n@@ -1236,7 +1236,7 @@ isminetype CWallet::IsMine(const CTxIn &txin) const\n CAmount CWallet::GetDebit(const CTxIn &txin, const isminefilter& filter) const\n {\n     {\n-        LOCK(cs_wallet);\n+        LOCK(cs_wallet); // mapWallet\n         std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n         if (mi != mapWallet.end())\n         {\n@@ -1276,7 +1276,7 @@ bool CWallet::IsChange(const CTxOut& txout) const\n         if (!ExtractDestination(txout.scriptPubKey, address))\n             return true;\n \n-        LOCK(cs_wallet);\n+        LOCK(cs_wallet); // mapAddressBook\n         if (!mapAddressBook.count(address))\n             return true;\n     }\n@@ -1317,7 +1317,7 @@ CAmount CWallet::GetDebit(const CTransaction& tx, const isminefilter& filter) co\n \n bool CWallet::IsAllFromMe(const CTransaction& tx, const isminefilter& filter) const\n {\n-    LOCK(cs_wallet);\n+    LOCK(cs_wallet); // mapWallet\n \n     for (const CTxIn& txin : tx.vin)\n     {\n@@ -1377,7 +1377,7 @@ CPubKey CWallet::GenerateNewHDMasterKey()\n     metadata.hdMasterKeyID = pubkey.GetID();\n \n     {\n-        LOCK(cs_wallet);\n+        LOCK(cs_wallet); // AddKeyPubKey(...), mapKeyMetadata\n \n         // mem store the metadata\n         mapKeyMetadata[pubkey.GetID()] = metadata;\n@@ -1392,7 +1392,7 @@ CPubKey CWallet::GenerateNewHDMasterKey()\n \n bool CWallet::SetHDMasterKey(const CPubKey& pubkey)\n {\n-    LOCK(cs_wallet);\n+    LOCK(cs_wallet); // CanSupportFeature(...)\n     // store the keyid (hash160) together with\n     // the child index counter in the database\n     // as a hdchain object\n@@ -1430,7 +1430,7 @@ int CWalletTx::GetRequestCount() const\n     // Returns -1 if it wasn't being tracked\n     int nRequests = -1;\n     {\n-        LOCK(pwallet->cs_wallet);\n+        LOCK(pwallet->cs_wallet); // mapRequestCount\n         if (IsCoinBase())\n         {\n             // Generated block\n@@ -1565,7 +1565,7 @@ CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool f\n     CBlockIndex* pindex = pindexStart;\n     CBlockIndex* ret = nullptr;\n     {\n-        LOCK2(cs_main, cs_wallet);\n+        LOCK2(cs_main, cs_wallet); // chainActive, AddToWalletIfInvolvingMe(...)\n         fAbortRescan = false;\n         fScanningWallet = true;\n \n@@ -1606,7 +1606,7 @@ void CWallet::ReacceptWalletTransactions()\n     // If transactions aren't being broadcasted, don't let them into local mempool either\n     if (!fBroadcastTransactions)\n         return;\n-    LOCK2(cs_main, cs_wallet);\n+    LOCK2(cs_main, cs_wallet); // mapWallet\n     std::map<int64_t, CWalletTx*> mapSorted;\n \n     // Sort pending wallet transactions based on their initial wallet insertion order\n@@ -1878,7 +1878,7 @@ std::vector<uint256> CWallet::ResendWalletTransactionsBefore(int64_t nTime, CCon\n {\n     std::vector<uint256> result;\n \n-    LOCK(cs_wallet);\n+    LOCK(cs_wallet); // mapWallet\n \n     // Sort them in chronological order\n     std::multimap<unsigned int, CWalletTx*> mapSorted;\n@@ -1937,7 +1937,7 @@ CAmount CWallet::GetBalance() const\n {\n     CAmount nTotal = 0;\n     {\n-        LOCK2(cs_main, cs_wallet);\n+        LOCK2(cs_main, cs_wallet); // mapWallet\n         for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n@@ -1953,7 +1953,7 @@ CAmount CWallet::GetUnconfirmedBalance() const\n {\n     CAmount nTotal = 0;\n     {\n-        LOCK2(cs_main, cs_wallet);\n+        LOCK2(cs_main, cs_wallet); // mapWallet\n         for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n@@ -1968,7 +1968,7 @@ CAmount CWallet::GetImmatureBalance() const\n {\n     CAmount nTotal = 0;\n     {\n-        LOCK2(cs_main, cs_wallet);\n+        LOCK2(cs_main, cs_wallet); // mapWallet\n         for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n@@ -1982,7 +1982,7 @@ CAmount CWallet::GetWatchOnlyBalance() const\n {\n     CAmount nTotal = 0;\n     {\n-        LOCK2(cs_main, cs_wallet);\n+        LOCK2(cs_main, cs_wallet); // mapWallet\n         for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n@@ -1998,7 +1998,7 @@ CAmount CWallet::GetUnconfirmedWatchOnlyBalance() const\n {\n     CAmount nTotal = 0;\n     {\n-        LOCK2(cs_main, cs_wallet);\n+        LOCK2(cs_main, cs_wallet); // mapWallet\n         for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n@@ -2013,7 +2013,7 @@ CAmount CWallet::GetImmatureWatchOnlyBalance() const\n {\n     CAmount nTotal = 0;\n     {\n-        LOCK2(cs_main, cs_wallet);\n+        LOCK2(cs_main, cs_wallet); // mapWallet\n         for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n@@ -2031,7 +2031,7 @@ CAmount CWallet::GetImmatureWatchOnlyBalance() const\n // trusted.\n CAmount CWallet::GetLegacyBalance(const isminefilter& filter, int minDepth, const std::string* account) const\n {\n-    LOCK2(cs_main, cs_wallet);\n+    LOCK2(cs_main, cs_wallet); // mapWallet\n \n     CAmount balance = 0;\n     for (const auto& entry : mapWallet) {\n@@ -2086,7 +2086,7 @@ void CWallet::AvailableCoins(std::vector<COutput> &vCoins, bool fOnlySafe, const\n     vCoins.clear();\n \n     {\n-        LOCK2(cs_main, cs_wallet);\n+        LOCK2(cs_main, cs_wallet); // IsSpent(...), mapWallet\n \n         CAmount nTotal = 0;\n \n@@ -2209,7 +2209,7 @@ std::map<CTxDestination, std::vector<COutput>> CWallet::ListCoins() const\n     std::vector<COutput> availableCoins;\n     AvailableCoins(availableCoins);\n \n-    LOCK2(cs_main, cs_wallet);\n+    LOCK2(cs_main, cs_wallet); // mapWallet\n     for (auto& coin : availableCoins) {\n         CTxDestination address;\n         if (coin.fSpendable &&\n@@ -2617,7 +2617,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n     unsigned int nBytes;\n     {\n         std::set<CInputCoin> setCoins;\n-        LOCK2(cs_main, cs_wallet);\n+        LOCK2(cs_main, cs_wallet); // SelectCoins(...)\n         {\n             std::vector<COutput> vAvailableCoins;\n             AvailableCoins(vAvailableCoins, true, &coin_control);\n@@ -2916,7 +2916,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey, CConnman* connman, CValidationState& state)\n {\n     {\n-        LOCK2(cs_main, cs_wallet);\n+        LOCK2(cs_main, cs_wallet); // mapRequestCount, mapWallet\n         LogPrintf(\"CommitTransaction:\\n%s\", wtxNew.tx->ToString());\n         {\n             // Take key pair from key pool so it won't be used again\n@@ -2979,7 +2979,7 @@ bool CWallet::AddAccountingEntry(const CAccountingEntry& acentry, CWalletDB *pwa\n \n DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n {\n-    LOCK2(cs_main, cs_wallet);\n+    LOCK2(cs_main, cs_wallet); // setInternalKeyPool, setExternalKeyPool\n \n     fFirstRunRet = false;\n     DBErrors nLoadWalletRet = CWalletDB(*dbw,\"cr+\").LoadWallet(this);\n@@ -3043,7 +3043,7 @@ DBErrors CWallet::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n     {\n         if (dbw->Rewrite(\"\\x04pool\"))\n         {\n-            LOCK(cs_wallet);\n+            LOCK(cs_wallet); // setInternalKeyPool, setExternalKeyPool\n             setInternalKeyPool.clear();\n             setExternalKeyPool.clear();\n             m_pool_key_to_index.clear();\n@@ -3120,7 +3120,7 @@ const std::string& CWallet::GetAccountName(const CScript& scriptPubKey) const\n bool CWallet::NewKeyPool()\n {\n     {\n-        LOCK(cs_wallet);\n+        LOCK(cs_wallet); // setInternalKeyPool, setExternalKeyPool\n         CWalletDB walletdb(*dbw);\n \n         for (int64_t nIndex : setInternalKeyPool) {\n@@ -3171,7 +3171,7 @@ void CWallet::LoadKeyPool(int64_t nIndex, const CKeyPool &keypool)\n bool CWallet::TopUpKeyPool(unsigned int kpSize)\n {\n     {\n-        LOCK(cs_wallet);\n+        LOCK(cs_wallet); // setInternalKeyPool, CanSupportFeature(...), GenerateNewKey(...), setExternalKeyPool\n \n         if (IsLocked())\n             return false;\n@@ -3228,7 +3228,7 @@ void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRe\n     nIndex = -1;\n     keypool.vchPubKey = CPubKey();\n     {\n-        LOCK(cs_wallet);\n+        LOCK(cs_wallet); // CanSupportFeature(...)\n \n         if (!IsLocked())\n             TopUpKeyPool();\n@@ -3273,7 +3273,7 @@ void CWallet::ReturnKey(int64_t nIndex, bool fInternal, const CPubKey& pubkey)\n {\n     // Return to key pool\n     {\n-        LOCK(cs_wallet);\n+        LOCK(cs_wallet); // setInternalKeyPool, setExternalKeyPool\n         if (fInternal) {\n             setInternalKeyPool.insert(nIndex);\n         } else {\n@@ -3288,7 +3288,7 @@ bool CWallet::GetKeyFromPool(CPubKey& result, bool internal)\n {\n     CKeyPool keypool;\n     {\n-        LOCK(cs_wallet);\n+        LOCK(cs_wallet); // GenerateNewKey(...)\n         int64_t nIndex = 0;\n         ReserveKeyFromKeyPool(nIndex, keypool, internal);\n         if (nIndex == -1)\n@@ -3320,7 +3320,7 @@ static int64_t GetOldestKeyTimeInPool(const std::set<int64_t>& setKeyPool, CWall\n \n int64_t CWallet::GetOldestKeyPoolTime()\n {\n-    LOCK(cs_wallet);\n+    LOCK(cs_wallet); // CanSupportFeature(...)\n \n     CWalletDB walletdb(*dbw);\n \n@@ -3338,7 +3338,7 @@ std::map<CTxDestination, CAmount> CWallet::GetAddressBalances()\n     std::map<CTxDestination, CAmount> balances;\n \n     {\n-        LOCK(cs_wallet);\n+        LOCK(cs_wallet); // IsSpent(...), mapWallet\n         for (const auto& walletEntry : mapWallet)\n         {\n             const CWalletTx *pcoin = &walletEntry.second;\n@@ -3468,7 +3468,7 @@ std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings()\n \n std::set<CTxDestination> CWallet::GetAccountAddresses(const std::string& strAccount) const\n {\n-    LOCK(cs_wallet);\n+    LOCK(cs_wallet); // mapAddressBook\n     std::set<CTxDestination> result;\n     for (const std::pair<CTxDestination, CAddressBookData>& item : mapAddressBook)\n     {\n@@ -3743,7 +3743,7 @@ bool CWallet::GetDestData(const CTxDestination &dest, const std::string &key, st\n \n std::vector<std::string> CWallet::GetDestValues(const std::string& prefix) const\n {\n-    LOCK(cs_wallet);\n+    LOCK(cs_wallet); // mapAddressBook\n     std::vector<std::string> values;\n     for (const auto& address : mapAddressBook) {\n         for (const auto& data : address.second.destdata) {\n@@ -3934,7 +3934,7 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n     walletInstance->SetBroadcastTransactions(gArgs.GetBoolArg(\"-walletbroadcast\", DEFAULT_WALLETBROADCAST));\n \n     {\n-        LOCK(walletInstance->cs_wallet);\n+        LOCK(walletInstance->cs_wallet); // mapWallet, GetKeyPoolSize(...), mapAddressBook\n         LogPrintf(\"setKeyPool.size() = %u\\n\",      walletInstance->GetKeyPoolSize());\n         LogPrintf(\"mapWallet.size() = %u\\n\",       walletInstance->mapWallet.size());\n         LogPrintf(\"mapAddressBook.size() = %u\\n\",  walletInstance->mapAddressBook.size());"
      },
      {
        "sha": "a4ed83b03c7b7f45e23ba5b9a98c5526cb8e109b",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -1011,7 +1011,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     void Inventory(const uint256 &hash) override\n     {\n         {\n-            LOCK(cs_wallet);\n+            LOCK(cs_wallet); // mapRequestCount\n             std::map<uint256, int>::iterator mi = mapRequestCount.find(hash);\n             if (mi != mapRequestCount.end())\n                 (*mi).second++;\n@@ -1033,7 +1033,10 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     bool SetMaxVersion(int nVersion);\n \n     //! get the current wallet format (the oldest client version guaranteed to understand this wallet)\n-    int GetVersion() { LOCK(cs_wallet); return nWalletVersion; }\n+    int GetVersion() {\n+        LOCK(cs_wallet); // nWalletVersion\n+        return nWalletVersion;\n+    }\n \n     //! Get wallet transactions that conflict with given transaction (spend same outputs)\n     std::set<uint256> GetConflicts(const uint256& txid) const;"
      },
      {
        "sha": "03671c5c256f0360077cbcdcfe8bec2555804d5c",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -528,7 +528,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n     bool fNoncriticalErrors = false;\n     DBErrors result = DB_LOAD_OK;\n \n-    LOCK(pwallet->cs_wallet);\n+    LOCK(pwallet->cs_wallet); // LoadMinVersion(...), mapWallet, ReadKeyValue(...)\n     try {\n         int nMinVersion = 0;\n         if (batch.Read((std::string)\"minversion\", nMinVersion))\n@@ -799,7 +799,7 @@ bool CWalletDB::RecoverKeysOnlyFilter(void *callbackData, CDataStream ssKey, CDa\n     bool fReadOK;\n     {\n         // Required in LoadKeyMetadata():\n-        LOCK(dummyWallet->cs_wallet);\n+        LOCK(dummyWallet->cs_wallet); // ReadKeyValue(...)\n         fReadOK = ReadKeyValue(dummyWallet, ssKey, ssValue,\n                                dummyWss, strType, strErr);\n     }"
      },
      {
        "sha": "669a18cb8f95726a7d6afe933c79875d6be6d3ac",
        "filename": "src/warnings.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/916e0b2f90819968cc27d11b7113de0a3957286d/src/warnings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/916e0b2f90819968cc27d11b7113de0a3957286d/src/warnings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/warnings.cpp?ref=916e0b2f90819968cc27d11b7113de0a3957286d",
        "patch": "@@ -15,25 +15,25 @@ bool fLargeWorkInvalidChainFound = false;\n \n void SetMiscWarning(const std::string& strWarning)\n {\n-    LOCK(cs_warnings);\n+    LOCK(cs_warnings); // strMiscWarning\n     strMiscWarning = strWarning;\n }\n \n void SetfLargeWorkForkFound(bool flag)\n {\n-    LOCK(cs_warnings);\n+    LOCK(cs_warnings); // fLargeWorkForkFound\n     fLargeWorkForkFound = flag;\n }\n \n bool GetfLargeWorkForkFound()\n {\n-    LOCK(cs_warnings);\n+    LOCK(cs_warnings); // fLargeWorkForkFound\n     return fLargeWorkForkFound;\n }\n \n void SetfLargeWorkInvalidChainFound(bool flag)\n {\n-    LOCK(cs_warnings);\n+    LOCK(cs_warnings); // fLargeWorkInvalidChainFound\n     fLargeWorkInvalidChainFound = flag;\n }\n \n@@ -44,7 +44,7 @@ std::string GetWarnings(const std::string& strFor)\n     std::string strGUI;\n     const std::string uiAlertSeperator = \"<hr />\";\n \n-    LOCK(cs_warnings);\n+    LOCK(cs_warnings); // strMiscWarning, fLargeWorkForkFound, fLargeWorkInvalidChainFound\n \n     if (!CLIENT_VERSION_IS_RELEASE) {\n         strStatusBar = \"This is a pre-release test build - use at your own risk - do not use for mining or merchant applications\";"
      }
    ]
  }
]