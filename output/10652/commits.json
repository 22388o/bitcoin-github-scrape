[
  {
    "sha": "ff57eb4bbdfc96c5a25f78c8f37d5edabf1ceb76",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZjU3ZWI0YmJkZmM5NmM1YTI1Zjc4YzhmMzdkNWVkYWJmMWNlYjc2",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-12-29T19:44:21Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-08-03T21:30:12Z"
      },
      "message": "Turn mapBlocksInFlight into a multimap",
      "tree": {
        "sha": "280406eaff44beae369d27aaf0927fd0318cdfce",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/280406eaff44beae369d27aaf0927fd0318cdfce"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ff57eb4bbdfc96c5a25f78c8f37d5edabf1ceb76",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff57eb4bbdfc96c5a25f78c8f37d5edabf1ceb76",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ff57eb4bbdfc96c5a25f78c8f37d5edabf1ceb76",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff57eb4bbdfc96c5a25f78c8f37d5edabf1ceb76/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ca4c545cc7e8c06bc8d9d4db1dd2d8f5fe011902",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ca4c545cc7e8c06bc8d9d4db1dd2d8f5fe011902",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ca4c545cc7e8c06bc8d9d4db1dd2d8f5fe011902"
      }
    ],
    "stats": {
      "total": 149,
      "additions": 97,
      "deletions": 52
    },
    "files": [
      {
        "sha": "c4262636f165039822912dfc06745f707816a716",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 97,
        "deletions": 52,
        "changes": 149,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff57eb4bbdfc96c5a25f78c8f37d5edabf1ceb76/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff57eb4bbdfc96c5a25f78c8f37d5edabf1ceb76/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=ff57eb4bbdfc96c5a25f78c8f37d5edabf1ceb76",
        "patch": "@@ -105,7 +105,8 @@ namespace {\n         bool fValidatedHeaders;                                  //!< Whether this block has validated headers at the time of request.\n         std::unique_ptr<PartiallyDownloadedBlock> partialBlock;  //!< Optional, used for CMPCTBLOCK downloads\n     };\n-    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> > mapBlocksInFlight;\n+    typedef std::multimap<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator>> BlockDownloadMap;\n+    BlockDownloadMap mmapBlocksInFlight;\n \n     /** Stack of nodes which we have set to announce using compact blocks */\n     std::list<NodeId> lNodesAnnouncingHeaderAndIDs;\n@@ -233,7 +234,6 @@ CNodeState *State(NodeId pnode) {\n         return NULL;\n     return &it->second;\n }\n-\n void UpdatePreferredDownload(CNode* node, CNodeState* state)\n {\n     nPreferredDownload -= state->fPreferredDownload;\n@@ -277,6 +277,44 @@ void InitializeNode(CNode *pnode, CConnman& connman) {\n         PushNodeVersion(pnode, connman, GetTime());\n }\n \n+// Requires cs_main\n+// Helper function for MarkBlockAsReceived and MarkBlockAsNotInFlight\n+static void ClearDownloadState(BlockDownloadMap::iterator itInFlight) {\n+    AssertLockHeld(cs_main);\n+\n+    CNodeState *state = State(itInFlight->second.first);\n+    state->nBlocksInFlightValidHeaders -= itInFlight->second.second->fValidatedHeaders;\n+    if (state->nBlocksInFlightValidHeaders == 0 && itInFlight->second.second->fValidatedHeaders) {\n+        // Last validated block on the queue was received.\n+        nPeersWithValidatedDownloads--;\n+    }\n+    if (state->vBlocksInFlight.begin() == itInFlight->second.second) {\n+        // First block on the queue was received, update the start download time for the next one\n+        state->nDownloadingSince = std::max(state->nDownloadingSince, GetTimeMicros());\n+    }\n+    state->vBlocksInFlight.erase(itInFlight->second.second);\n+    state->nBlocksInFlight--;\n+    state->nStallingSince = 0;\n+}\n+\n+// Requires cs_main.\n+// Used to remove block from mmapBlocksInFlight and clear the download state for\n+// a block if for some reason block was not received. Download state clearing is\n+// skipped as an optimization in FinalizeNode.\n+static void MarkBlockAsNotInFlight(const uint256& hash, NodeId nodeid, bool clearState = true) {\n+    AssertLockHeld(cs_main);\n+\n+    std::pair<BlockDownloadMap::iterator, BlockDownloadMap::iterator> range = mmapBlocksInFlight.equal_range(hash);\n+    while (range.first != range.second) {\n+        BlockDownloadMap::iterator itInFlight = range.first;\n+        range.first++;\n+        if (itInFlight->second.first == nodeid) {\n+            if (clearState) ClearDownloadState(itInFlight);\n+            mmapBlocksInFlight.erase(itInFlight);\n+        }\n+    }\n+}\n+\n void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n     fUpdateConnectionTime = false;\n     LOCK(cs_main);\n@@ -290,7 +328,7 @@ void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n     }\n \n     for (const QueuedBlock& entry : state->vBlocksInFlight) {\n-        mapBlocksInFlight.erase(entry.hash);\n+        MarkBlockAsNotInFlight(entry.hash, nodeid, false);\n     }\n     EraseOrphansFor(nodeid);\n     nPreferredDownload -= state->fPreferredDownload;\n@@ -301,57 +339,48 @@ void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n \n     if (mapNodeState.empty()) {\n         // Do a consistency check after the last peer is removed.\n-        assert(mapBlocksInFlight.empty());\n+        assert(mmapBlocksInFlight.empty());\n         assert(nPreferredDownload == 0);\n         assert(nPeersWithValidatedDownloads == 0);\n     }\n     LogPrint(BCLog::NET, \"Cleared nodestate for peer=%d\\n\", nodeid);\n }\n \n+\n // Requires cs_main.\n // Returns a bool indicating whether we requested this block.\n-// Also used if a block was /not/ received and timed out or started with another peer\n bool MarkBlockAsReceived(const uint256& hash) {\n-    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n-    if (itInFlight != mapBlocksInFlight.end()) {\n-        CNodeState *state = State(itInFlight->second.first);\n-        state->nBlocksInFlightValidHeaders -= itInFlight->second.second->fValidatedHeaders;\n-        if (state->nBlocksInFlightValidHeaders == 0 && itInFlight->second.second->fValidatedHeaders) {\n-            // Last validated block on the queue was received.\n-            nPeersWithValidatedDownloads--;\n-        }\n-        if (state->vBlocksInFlight.begin() == itInFlight->second.second) {\n-            // First block on the queue was received, update the start download time for the next one\n-            state->nDownloadingSince = std::max(state->nDownloadingSince, GetTimeMicros());\n-        }\n-        state->vBlocksInFlight.erase(itInFlight->second.second);\n-        state->nBlocksInFlight--;\n-        state->nStallingSince = 0;\n-        mapBlocksInFlight.erase(itInFlight);\n-        return true;\n-    }\n-    return false;\n+    bool found = false;\n+    std::pair<BlockDownloadMap::iterator, BlockDownloadMap::iterator> range = mmapBlocksInFlight.equal_range(hash);\n+    while (range.first != range.second) {\n+        found = true;\n+        ClearDownloadState(range.first);\n+        range.first = mmapBlocksInFlight.erase(range.first);\n+    }\n+    return found;\n }\n \n // Requires cs_main.\n // returns false, still setting pit, if the block was already in flight from the same peer\n // pit will only be valid as long as the same cs_main lock is being held\n bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = NULL, std::list<QueuedBlock>::iterator** pit = NULL) {\n+    AssertLockHeld(cs_main);\n     CNodeState *state = State(nodeid);\n     assert(state != NULL);\n \n     // Short-circuit most stuff in case its from the same node\n-    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n-    if (itInFlight != mapBlocksInFlight.end() && itInFlight->second.first == nodeid) {\n-        if (pit) {\n-            *pit = &itInFlight->second.second;\n+    std::pair<BlockDownloadMap::iterator, BlockDownloadMap::iterator> range = mmapBlocksInFlight.equal_range(hash);\n+    while (range.first != range.second) {\n+        BlockDownloadMap::iterator itInFlight = range.first;\n+        range.first++;\n+        if (itInFlight->second.first == nodeid) {\n+            if (pit) {\n+                *pit = &itInFlight->second.second;\n+            }\n+            return false;\n         }\n-        return false;\n     }\n \n-    // Make sure it's not listed somewhere already.\n-    MarkBlockAsReceived(hash);\n-\n     std::list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(),\n             {hash, pindex, pindex != NULL, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&mempool) : NULL)});\n     state->nBlocksInFlight++;\n@@ -363,7 +392,7 @@ bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex*\n     if (state->nBlocksInFlightValidHeaders == 1 && pindex != NULL) {\n         nPeersWithValidatedDownloads++;\n     }\n-    itInFlight = mapBlocksInFlight.insert(std::make_pair(hash, std::make_pair(nodeid, it))).first;\n+    BlockDownloadMap::iterator itInFlight = mmapBlocksInFlight.insert(std::make_pair(hash, std::make_pair(nodeid, it)));\n     if (pit)\n         *pit = &itInFlight->second.second;\n     return true;\n@@ -519,7 +548,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n             if (pindex->nStatus & BLOCK_HAVE_DATA || chainActive.Contains(pindex)) {\n                 if (pindex->nChainTx)\n                     state->pindexLastCommonBlock = pindex;\n-            } else if (mapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n+            } else if (mmapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n                 // The block is not already downloaded, and not yet in flight.\n                 if (pindex->nHeight > nWindowEnd) {\n                     // We reached the end of the window.\n@@ -535,7 +564,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n                 }\n             } else if (waitingfor == -1) {\n                 // This is the first already-in-flight block.\n-                waitingfor = mapBlocksInFlight[pindex->GetBlockHash()].first;\n+                waitingfor = mmapBlocksInFlight.lower_bound(pindex->GetBlockHash())->second.first;\n             }\n         }\n     }\n@@ -863,7 +892,7 @@ void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationSta\n     //    just check that there are currently no other blocks in flight.\n     else if (state.IsValid() &&\n              !IsInitialBlockDownload() &&\n-             mapBlocksInFlight.count(hash) == mapBlocksInFlight.size()) {\n+             mmapBlocksInFlight.count(hash) == mmapBlocksInFlight.size()) {\n         if (it != mapBlockSource.end()) {\n             MaybeSetPeerAsAnnouncingHeaderAndIDs(it->second.first, *connman);\n         }\n@@ -1551,7 +1580,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n             if (inv.type == MSG_BLOCK) {\n                 UpdateBlockAvailability(pfrom->GetId(), inv.hash);\n-                if (!fAlreadyHave && !fImporting && !fReindex && !mapBlocksInFlight.count(inv.hash)) {\n+                if (!fAlreadyHave && !fImporting && !fReindex && !mmapBlocksInFlight.count(inv.hash)) {\n                     // We used to request the full block here, but since headers-announcements are now the\n                     // primary method of announcement on the network, and since, in the case that a node\n                     // fell back to inv we probably have a reorg which we should get the headers for first,\n@@ -2006,12 +2035,18 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         assert(pindex);\n         UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n \n-        std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n-        bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n-\n         if (pindex->nStatus & BLOCK_HAVE_DATA) // Nothing to do here\n             return true;\n \n+        std::pair<BlockDownloadMap::iterator, BlockDownloadMap::iterator> rangeInFlight = mmapBlocksInFlight.equal_range(pindex->GetBlockHash());\n+        bool fAlreadyInFlight = rangeInFlight.first != rangeInFlight.second;\n+        bool fInFlightFromSamePeer = false;\n+        while (rangeInFlight.first != rangeInFlight.second) {\n+            if (rangeInFlight.first->second.first == pfrom->GetId())\n+                fInFlightFromSamePeer = true;\n+            rangeInFlight.first++;\n+        }\n+\n         if (pindex->nChainWork <= chainActive.Tip()->nChainWork || // We know something better\n                 pindex->nTx != 0) { // We had this block at some point, but pruned it\n             if (fAlreadyInFlight) {\n@@ -2040,8 +2075,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // possibilities in compact block processing...\n         if (pindex->nHeight <= chainActive.Height() + 2) {\n             if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n-                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n-                std::list<QueuedBlock>::iterator* queuedBlockIt = NULL;\n+                fInFlightFromSamePeer) {\n+                std::list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n                 if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), pindex, &queuedBlockIt)) {\n                     if (!(*queuedBlockIt)->partialBlock)\n                         (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&mempool));\n@@ -2055,7 +2090,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n                 ReadStatus status = partialBlock.InitData(cmpctblock, vExtraTxnForCompact);\n                 if (status == READ_STATUS_INVALID) {\n-                    MarkBlockAsReceived(pindex->GetBlockHash()); // Reset in-flight state in case of whitelist\n+                    MarkBlockAsNotInFlight(pindex->GetBlockHash(), pfrom->GetId()); // Reset in-flight state in case of whitelist\n                     Misbehaving(pfrom->GetId(), 100);\n                     LogPrintf(\"Peer %d sent us invalid compact block\\n\", pfrom->GetId());\n                     return true;\n@@ -2159,17 +2194,27 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         {\n             LOCK(cs_main);\n \n-            std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n-            if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n-                    it->second.first != pfrom->GetId()) {\n+            bool expected_BLOCKTXN = false;\n+            std::pair<BlockDownloadMap::iterator, BlockDownloadMap::iterator> rangeInFlight = mmapBlocksInFlight.equal_range(resp.blockhash);\n+            while (rangeInFlight.first != rangeInFlight.second) {\n+                if (rangeInFlight.first->second.first == pfrom->GetId()) {\n+                    if (rangeInFlight.first->second.second->partialBlock) {\n+                        expected_BLOCKTXN = true;\n+                    }\n+                    break;\n+                }\n+                rangeInFlight.first++;\n+            }\n+\n+            if (!expected_BLOCKTXN) {\n                 LogPrint(BCLog::NET, \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom->GetId());\n                 return true;\n             }\n \n-            PartiallyDownloadedBlock& partialBlock = *it->second.second->partialBlock;\n+            PartiallyDownloadedBlock& partialBlock = *rangeInFlight.first->second.second->partialBlock;\n             ReadStatus status = partialBlock.FillBlock(*pblock, resp.txn);\n             if (status == READ_STATUS_INVALID) {\n-                MarkBlockAsReceived(resp.blockhash); // Reset in-flight state in case of whitelist\n+                MarkBlockAsNotInFlight(resp.blockhash, pfrom->GetId()); // Reset in-flight state in case of whitelist\n                 Misbehaving(pfrom->GetId(), 100);\n                 LogPrintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom->GetId());\n                 return true;\n@@ -2196,7 +2241,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // though the block was successfully read, and rely on the\n                 // handling in ProcessNewBlock to ensure the block index is\n                 // updated, reject messages go out, etc.\n-                MarkBlockAsReceived(resp.blockhash); // it is now an empty pointer\n+                MarkBlockAsNotInFlight(resp.blockhash, pfrom->GetId()); // it is now an empty pointer\n                 fBlockRead = true;\n                 // mapBlockSource is only used for sending reject messages and DoS scores,\n                 // so the race between here and cs_main in ProcessNewBlock is fine.\n@@ -2208,7 +2253,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         } // Don't hold cs_main when we call into ProcessNewBlock\n         if (fBlockRead) {\n             bool fNewBlock = false;\n-            // Since we requested this block (it was in mapBlocksInFlight), force it to be processed,\n+            // Since we requested this block (it was in mmapBlocksInFlight), force it to be processed,\n             // even if it would not be a candidate for new tip (missing previous block, chain not long enough, etc)\n             ProcessNewBlock(chainparams, pblock, true, &fNewBlock);\n             if (fNewBlock)\n@@ -2321,7 +2366,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.\n             while (pindexWalk && !chainActive.Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n                 if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&\n-                        !mapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&\n+                        !mmapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&\n                         (!IsWitnessEnabled(pindexWalk->pprev, chainparams.GetConsensus()) || State(pfrom->GetId())->fHaveWitness)) {\n                     // We don't have this block, and it's not yet in flight.\n                     vToFetch.push_back(pindexWalk);\n@@ -2355,7 +2400,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                             pindexLast->GetBlockHash().ToString(), pindexLast->nHeight);\n                 }\n                 if (vGetData.size() > 0) {\n-                    if (nodestate->fSupportsDesiredCmpctVersion && vGetData.size() == 1 && mapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n+                    if (nodestate->fSupportsDesiredCmpctVersion && vGetData.size() == 1 && mmapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n                         // In any case, we want to download using a compact block, not a regular one\n                         vGetData[0] = CInv(MSG_CMPCT_BLOCK, vGetData[0].hash);\n                     }"
      }
    ]
  },
  {
    "sha": "b4592659b960384f09e26168a0de331a4c334752",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNDU5MjY1OWI5NjAzODRmMDllMjYxNjhhMGRlMzMxYTRjMzM0NzUy",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-06-06T20:13:55Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-08-03T21:30:12Z"
      },
      "message": "Call NewPoWValidBlock callbacks for all new blocks, not just !IBD\n\nThis pushes some \"is this callback useful\" logic down into\nnet_processing, which is useful for later changes as it allows for\nmore notifications to be used.",
      "tree": {
        "sha": "05ae6f54771419e02ac05d8e08e598dc361742c7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/05ae6f54771419e02ac05d8e08e598dc361742c7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b4592659b960384f09e26168a0de331a4c334752",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4592659b960384f09e26168a0de331a4c334752",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b4592659b960384f09e26168a0de331a4c334752",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4592659b960384f09e26168a0de331a4c334752/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ff57eb4bbdfc96c5a25f78c8f37d5edabf1ceb76",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff57eb4bbdfc96c5a25f78c8f37d5edabf1ceb76",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ff57eb4bbdfc96c5a25f78c8f37d5edabf1ceb76"
      }
    ],
    "stats": {
      "total": 32,
      "additions": 19,
      "deletions": 13
    },
    "files": [
      {
        "sha": "8cd5f587f62dbd09fec730cab7529587f0332259",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4592659b960384f09e26168a0de331a4c334752/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4592659b960384f09e26168a0de331a4c334752/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b4592659b960384f09e26168a0de331a4c334752",
        "patch": "@@ -796,7 +796,10 @@ static std::shared_ptr<const CBlockHeaderAndShortTxIDs> most_recent_compact_bloc\n static uint256 most_recent_block_hash;\n static bool fWitnessesPresentInMostRecentCompactBlock;\n \n-void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) {\n+void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock, bool fNewCandidateTip) {\n+    if (!fNewCandidateTip || IsInitialBlockDownload())\n+        return;\n+\n     std::shared_ptr<const CBlockHeaderAndShortTxIDs> pcmpctblock = std::make_shared<const CBlockHeaderAndShortTxIDs> (*pblock, true);\n     const CNetMsgMaker msgMaker(PROTOCOL_VERSION);\n "
      },
      {
        "sha": "8940e45522aca10f5a0004e60f6c3bc5885c536f",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4592659b960384f09e26168a0de331a4c334752/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4592659b960384f09e26168a0de331a4c334752/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=b4592659b960384f09e26168a0de331a4c334752",
        "patch": "@@ -37,7 +37,7 @@ class PeerLogicValidation : public CValidationInterface {\n     void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected, const std::vector<CTransactionRef>& vtxConflicted) override;\n     void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;\n     void BlockChecked(const CBlock& block, const CValidationState& state) override;\n-    void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) override;\n+    void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock, bool fNewCandidateTip) override;\n };\n \n struct CNodeStateStats {"
      },
      {
        "sha": "99f21deb4231d8517ffb75ffcb8dbf3664c269b0",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4592659b960384f09e26168a0de331a4c334752/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4592659b960384f09e26168a0de331a4c334752/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=b4592659b960384f09e26168a0de331a4c334752",
        "patch": "@@ -3141,9 +3141,7 @@ static bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidation\n     }\n \n     // Header is valid/has work, merkle tree and segwit merkle tree are good...RELAY NOW\n-    // (but if it does not build on our best tip, let the SendMessages loop relay it)\n-    if (!IsInitialBlockDownload() && chainActive.Tip() == pindex->pprev)\n-        GetMainSignals().NewPoWValidBlock(pindex, pblock);\n+    GetMainSignals().NewPoWValidBlock(pindex, pblock, chainActive.Tip() == pindex->pprev);\n \n     int nHeight = pindex->nHeight;\n "
      },
      {
        "sha": "a40bb0d887cebadc142014fd83ab71a6f2c69706",
        "filename": "src/validationinterface.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4592659b960384f09e26168a0de331a4c334752/src/validationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4592659b960384f09e26168a0de331a4c334752/src/validationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.cpp?ref=b4592659b960384f09e26168a0de331a4c334752",
        "patch": "@@ -23,7 +23,7 @@ struct MainSignalsInstance {\n     boost::signals2::signal<void (const uint256 &)> Inventory;\n     boost::signals2::signal<void (int64_t nBestBlockTime, CConnman* connman)> Broadcast;\n     boost::signals2::signal<void (const CBlock&, const CValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n+    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&, bool)> NewPoWValidBlock;\n \n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n@@ -62,7 +62,7 @@ void RegisterValidationInterface(CValidationInterface* pwalletIn) {\n     g_signals.m_internals->Inventory.connect(boost::bind(&CValidationInterface::Inventory, pwalletIn, _1));\n     g_signals.m_internals->Broadcast.connect(boost::bind(&CValidationInterface::ResendWalletTransactions, pwalletIn, _1, _2));\n     g_signals.m_internals->BlockChecked.connect(boost::bind(&CValidationInterface::BlockChecked, pwalletIn, _1, _2));\n-    g_signals.m_internals->NewPoWValidBlock.connect(boost::bind(&CValidationInterface::NewPoWValidBlock, pwalletIn, _1, _2));\n+    g_signals.m_internals->NewPoWValidBlock.connect(boost::bind(&CValidationInterface::NewPoWValidBlock, pwalletIn, _1, _2, _3));\n }\n \n void UnregisterValidationInterface(CValidationInterface* pwalletIn) {\n@@ -74,7 +74,7 @@ void UnregisterValidationInterface(CValidationInterface* pwalletIn) {\n     g_signals.m_internals->BlockConnected.disconnect(boost::bind(&CValidationInterface::BlockConnected, pwalletIn, _1, _2, _3));\n     g_signals.m_internals->BlockDisconnected.disconnect(boost::bind(&CValidationInterface::BlockDisconnected, pwalletIn, _1));\n     g_signals.m_internals->UpdatedBlockTip.disconnect(boost::bind(&CValidationInterface::UpdatedBlockTip, pwalletIn, _1, _2, _3));\n-    g_signals.m_internals->NewPoWValidBlock.disconnect(boost::bind(&CValidationInterface::NewPoWValidBlock, pwalletIn, _1, _2));\n+    g_signals.m_internals->NewPoWValidBlock.disconnect(boost::bind(&CValidationInterface::NewPoWValidBlock, pwalletIn, _1, _2, _3));\n }\n \n void UnregisterAllValidationInterfaces() {\n@@ -121,6 +121,6 @@ void CMainSignals::BlockChecked(const CBlock& block, const CValidationState& sta\n     m_internals->BlockChecked(block, state);\n }\n \n-void CMainSignals::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock> &block) {\n-    m_internals->NewPoWValidBlock(pindex, block);\n+void CMainSignals::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock> &block, bool fNewCandidateTip) {\n+    m_internals->NewPoWValidBlock(pindex, block, fNewCandidateTip);\n }"
      },
      {
        "sha": "c3d30391dcf1676f70172d641c5a8a756767dcf9",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 8,
        "deletions": 3,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4592659b960384f09e26168a0de331a4c334752/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4592659b960384f09e26168a0de331a4c334752/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=b4592659b960384f09e26168a0de331a4c334752",
        "patch": "@@ -58,8 +58,13 @@ class CValidationInterface {\n     virtual void BlockChecked(const CBlock&, const CValidationState&) {}\n     /**\n      * Notifies listeners that a block which builds directly on our current tip\n-     * has been received and connected to the headers tree, though not validated yet */\n-    virtual void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& block) {};\n+     * has been received and connected to the headers tree, though not validated yet.\n+     * If the new block builds on the current best tip, the final bool argument is\n+     * set to true, otherwise it is false.\n+     * Consider if you need an IsInitialBlockDownload check in your client (and note\n+     * that any such calls will be racy wrt the state when the callback was generated)\n+     * */\n+    virtual void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& block, bool fNewCandidateTip) {};\n     friend void ::RegisterValidationInterface(CValidationInterface*);\n     friend void ::UnregisterValidationInterface(CValidationInterface*);\n     friend void ::UnregisterAllValidationInterfaces();\n@@ -91,7 +96,7 @@ class CMainSignals {\n     void Inventory(const uint256 &);\n     void Broadcast(int64_t nBestBlockTime, CConnman* connman);\n     void BlockChecked(const CBlock&, const CValidationState&);\n-    void NewPoWValidBlock(const CBlockIndex *, const std::shared_ptr<const CBlock>&);\n+    void NewPoWValidBlock(const CBlockIndex *, const std::shared_ptr<const CBlock>&, bool);\n };\n \n CMainSignals& GetMainSignals();"
      }
    ]
  },
  {
    "sha": "61c9b81df0e8da31c7c51f4041b8f57155b49c86",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MWM5YjgxZGYwZThkYTMxYzdjNTFmNDA0MWI4ZjU3MTU1YjQ5Yzg2",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-06-06T20:16:58Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-08-03T21:30:12Z"
      },
      "message": "MarkBlockAsReceived on NewPoWValidBlock at receive.\n\nThe received block could be malleated, so this is both simpler, and\nsupports parallel downloads.",
      "tree": {
        "sha": "8ff14dd864198cf6e5dd0b80e3e2982faeda363b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8ff14dd864198cf6e5dd0b80e3e2982faeda363b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/61c9b81df0e8da31c7c51f4041b8f57155b49c86",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61c9b81df0e8da31c7c51f4041b8f57155b49c86",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/61c9b81df0e8da31c7c51f4041b8f57155b49c86",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61c9b81df0e8da31c7c51f4041b8f57155b49c86/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b4592659b960384f09e26168a0de331a4c334752",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4592659b960384f09e26168a0de331a4c334752",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b4592659b960384f09e26168a0de331a4c334752"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 8,
      "deletions": 12
    },
    "files": [
      {
        "sha": "e21377f2892004386d2e456d1c352252e9faf41d",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 12,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61c9b81df0e8da31c7c51f4041b8f57155b49c86/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61c9b81df0e8da31c7c51f4041b8f57155b49c86/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=61c9b81df0e8da31c7c51f4041b8f57155b49c86",
        "patch": "@@ -347,9 +347,9 @@ void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n }\n \n \n-// Requires cs_main.\n // Returns a bool indicating whether we requested this block.\n bool MarkBlockAsReceived(const uint256& hash) {\n+    LOCK(cs_main);\n     bool found = false;\n     std::pair<BlockDownloadMap::iterator, BlockDownloadMap::iterator> range = mmapBlocksInFlight.equal_range(hash);\n     while (range.first != range.second) {\n@@ -797,6 +797,9 @@ static uint256 most_recent_block_hash;\n static bool fWitnessesPresentInMostRecentCompactBlock;\n \n void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock, bool fNewCandidateTip) {\n+    // The block was received in non-malleated form (and is/will be stored on disk).\n+    // We can consider all in-flight requests completed\n+    MarkBlockAsReceived(pindex->GetBlockHash());\n     if (!fNewCandidateTip || IsInitialBlockDownload())\n         return;\n \n@@ -2174,17 +2177,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             ProcessNewBlock(chainparams, pblock, true, &fNewBlock);\n             if (fNewBlock)\n                 pfrom->nLastBlockTime = GetTime();\n-\n-            LOCK(cs_main); // hold cs_main for CBlockIndex::IsValid()\n-            if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS)) {\n-                // Clear download state for this block, which is in\n-                // process from some other peer.  We do this after calling\n-                // ProcessNewBlock so that a malleated cmpctblock announcement\n-                // can't be used to interfere with block relay.\n-                MarkBlockAsReceived(pblock->GetHash());\n-            }\n         }\n-\n     }\n \n     else if (strCommand == NetMsgType::BLOCKTXN && !fImporting && !fReindex) // Ignore blocks received while importing\n@@ -2431,7 +2424,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             LOCK(cs_main);\n             // Also always process if we requested the block explicitly, as we may\n             // need it even though it is not a candidate for a new best tip.\n-            forceProcessing |= MarkBlockAsReceived(hash);\n+            // TODO: Only process if requested from this peer?\n+            forceProcessing |= mmapBlocksInFlight.count(hash);\n+            // Block is no longer in flight from this peer\n+            MarkBlockAsNotInFlight(hash, pfrom->GetId());\n             // mapBlockSource is only used for sending reject messages and DoS scores,\n             // so the race between here and cs_main in ProcessNewBlock is fine.\n             mapBlockSource.emplace(hash, std::make_pair(pfrom->GetId(), true));"
      }
    ]
  },
  {
    "sha": "8689df48cede961a12afa66431fe8c05fc511b46",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4Njg5ZGY0OGNlZGU5NjFhMTJhZmE2NjQzMWZlOGMwNWZjNTExYjQ2",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-12-29T22:23:07Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-08-03T21:30:12Z"
      },
      "message": "Only request full blocks from the peer we thought had the block in-flight\n\nThis is a change in behavior so that if for some reason we request a block from a peer, we don't allow an unsolicited CMPCT_BLOCK announcement for that same block to cause a request for a full block from the uninvited peer (as some type of request is already outstanding from the original peer)",
      "tree": {
        "sha": "3542b6eb1d5d725a7770447cd5ece630c034383d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3542b6eb1d5d725a7770447cd5ece630c034383d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8689df48cede961a12afa66431fe8c05fc511b46",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8689df48cede961a12afa66431fe8c05fc511b46",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8689df48cede961a12afa66431fe8c05fc511b46",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8689df48cede961a12afa66431fe8c05fc511b46/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "61c9b81df0e8da31c7c51f4041b8f57155b49c86",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61c9b81df0e8da31c7c51f4041b8f57155b49c86",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/61c9b81df0e8da31c7c51f4041b8f57155b49c86"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 3,
      "deletions": 3
    },
    "files": [
      {
        "sha": "687834300ce881a557937f9dfafb3b8b969b67fd",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8689df48cede961a12afa66431fe8c05fc511b46/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8689df48cede961a12afa66431fe8c05fc511b46/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=8689df48cede961a12afa66431fe8c05fc511b46",
        "patch": "@@ -2055,7 +2055,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         if (pindex->nChainWork <= chainActive.Tip()->nChainWork || // We know something better\n                 pindex->nTx != 0) { // We had this block at some point, but pruned it\n-            if (fAlreadyInFlight) {\n+            if (fInFlightFromSamePeer) {\n                 // We requested this block for some reason, but our mempool will probably be useless\n                 // so we just grab the block via normal getdata\n                 std::vector<CInv> vInv(1);\n@@ -2066,7 +2066,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n \n         // If we're not close to tip yet, give up and let parallel block fetch work its magic\n-        if (!fAlreadyInFlight && !CanDirectFetch(chainparams.GetConsensus()))\n+        if (!fInFlightFromSamePeer && !CanDirectFetch(chainparams.GetConsensus()))\n             return true;\n \n         CNodeState *nodestate = State(pfrom->GetId());\n@@ -2142,7 +2142,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 }\n             }\n         } else {\n-            if (fAlreadyInFlight) {\n+            if (fInFlightFromSamePeer) {\n                 // We requested this block, but its far into the future, so our\n                 // mempool will probably be useless - request the block normally\n                 std::vector<CInv> vInv(1);"
      }
    ]
  }
]