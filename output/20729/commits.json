[
  {
    "sha": "c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjM2UzYTE2ZDFkZGEzODZlMzg3YjVlZjgwYTNhMzgxYzdhMWU0ZmRi",
    "commit": {
      "author": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2020-12-19T22:14:31Z"
      },
      "committer": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2021-02-12T16:59:02Z"
      },
      "message": "scripted-diff: clean up outbound connection type naming\n\n-BEGIN VERIFY SCRIPT-\ns() { git grep -l \"$1\" src test/functional doc/files.md doc/reduce-*.md | xargs sed -i \"s/$1/$2/g\"; }\n\ns 'ConnectionType::OUTBOUND '            'ConnectionType::OUTBOUND_FULL_RELAY '\ns 'IsFullOutboundConn'                   'IsOutboundFullRelayConn'\ns 'GetExtraFullOutboundCount'            'GetExtraOutboundFullRelayCount'\ns 'full_outbound_peers'                  'outbound_full_relay_peers'\ns 'GetTryNewOutboundPeer'                'GetTryNewOutboundFullRelayPeer'\ns 'SetTryNewOutboundPeer'                'SetTryNewOutboundFullRelayPeer'\ns 'm_try_another_outbound_peer'          'm_try_another_outbound_full_relay_peer'\ns 'outbound (full-relay)'                'outbound-full-relay'\ns 'outbound full-relay'                  'outbound-full-relay'\ns 'outbound, full-relay'                 'outbound-full-relay'\ns 'outbounds'                            'outbound-full-relay connections'\ns 'f\"outbound: '                         'f\"outbound-full-relay: '\ns ' full-relay'                          ' outbound-full-relay'\ns 'to an extra outbound peer'            'to an extra outbound-full-relay peer'\ns 'try another outbound peer'            'try another outbound-full-relay peer'\ns '(tx, block, addr) outbound'           '(tx, block, addr)'\ns 'we deal with extra outbound peers'    'we deal with extra outbound-full-relay peers'\ns 'outbound peers we have in excess'     'outbound-full-relay peers we have in excess'\ns 'some outbound connections are not'    'some outbound-full-relay connections are not'\ns 'or this is a'                         'or if this is an'\n\ns 'ConnectionType::BLOCK_RELAY'          'ConnectionType::OUTBOUND_BLOCK_RELAY'\ns ' BLOCK_RELAY'                         ' OUTBOUND_BLOCK_RELAY'\ns 'IsBlockOnlyConn'                      'IsOutboundBlockRelayConn'\ns 'GetExtraBlockRelayCount'              'GetExtraOutboundBlockRelayCount'\ns 'block_relay_peers'                    'outbound_block_relay_peers'\ns 'MAX_BLOCK_RELAY_ONLY_ANCHORS'         'MAX_OUTBOUND_BLOCK_RELAY_ANCHORS'\ns 'MAX_BLOCK_RELAY_ONLY_CONNECTIONS'     'MAX_OUTBOUND_BLOCK_RELAY_CONNECTIONS'\ns 'EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL' 'EXTRA_OUTBOUND_BLOCK_RELAY_PEER_INTERVAL'\ns 'm_start_extra_block_relay_peers'      'm_start_extra_outbound_block_relay_peers'\ns 'outgoing block-relay-only'            'outbound-block-relay'\ns 'outbound block-relay-only'            'outbound-block-relay'\ns 'outbound block-relay'                 'outbound-block-relay'\ns 'block-relay only outbound'            'outbound-block-relay'\ns 'block-relay-only outgoing'            'outbound-block-relay'\ns 'block-relay only peers'               'outbound-block-relay peers'\ns 'block-relay-only'                     'outbound-block-relay'\n\ns ' a outbound'                          ' an outbound'\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "846fd1fb6c46369305d683cc2f53cfc023f8f684",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/846fd1fb6c46369305d683cc2f53cfc023f8f684"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEd6u7+MhX7zEv6RP5T1chs9Djkh0FAmAms90ACgkQT1chs9Dj\nkh0Elg/+O7B4HPkxisSjOD9FYC5qd3jiZQf+Q0pFq02bdn7j0BDw+BncxTZUgw/u\nfF/RynZs45NP2VEEB+2JpT8FL4a3F+hQa1AH2ILCM3lHBJcHyzf8NGc/W72e89+E\nddwP/xPWUx68BjtcA4tYuf8A31SFkKszZxbW9q7WPJJ/DyQVX++8Ov0rbYmvkd+3\nd5Li7fWBH7kLJwfQ4A+iRJoXkwZxeR/ABmbOwwkVTr8c455vIUbPiF8AGKudF9To\nfXE4J7R++WhGc9+lznAvkIi+o/8F6JdWurQUjzPhCYbh7DBtDGaFj6Wotgqa7+N3\n2AgxVZLY4MFbhPaXEIOZ4ze67BQlFgZWp8p+oDzFHcpY4p2EJ1KAHsMjfNuF4e0n\ncHyQyo+yJbKiewc3ZkIBc1o4hJdSq4CrD+sUPFyqkVQJ3Jv0Qi6qoJGQmuXzJMvJ\nmueS7V+bqr5oCy8I5bd/zeSZWysaesf2TF56+LqkWpAf29us86hC/eHnf/jMfHJZ\nkvwHLXeJg4P9fe2+eUmymE75WID+Vns8/dR/5aA2dYGOE8NB1gV3Z8XgJ+a+s6+J\n7CXPm94PLfh8AmCMArKItFP2dlt6Ynz+FLjavpJ8ZIdyGJKEYLEjdri7ReID4VMW\nJepHwxEwuxg4Wirwzz2/HYEfNR9NF6UiawC4sNH3VjiC8ToLrW8=\n=KoHS\n-----END PGP SIGNATURE-----\n-----BEGIN OPENTIMESTAMPS GIT TIMESTAMP-----\n\nAQHwIN7LdOJGVZJIaNDQBCBR5FGUnoy2YsIXqDSFx1Td0lsBCP/wEAMqJctkLXBR\ncY7pOIFccqkI8QRgJqYN8AgFTPZNp/FbVwCD3+MNLvkMjikoaHR0cHM6Ly9maW5u\nZXkuY2FsZW5kYXIuZXRlcm5pdHl3YWxsLmNvbf/wECHq5XcovR52lBLVNoVF7ScI\n8QRgJrPf8AgPkGfAVCLmvgCD3+MNLvkMjiwraHR0cHM6Ly9ib2IuYnRjLmNhbGVu\nZGFyLm9wZW50aW1lc3RhbXBzLm9yZ//wEIdgR3zjHFwUIPFJrokJOusI8QRgJrPe\n8AixZichwtnBOQCD3+MNLvkMjiMiaHR0cHM6Ly9idGMuY2FsZW5kYXIuY2F0YWxs\nYXh5LmNvbfAQ6/hghqT0yUc8SQOIG8UmKQjxBGAms97wCGf+YoW8D+QlAIPf4w0u\n+QyOLi1odHRwczovL2FsaWNlLmJ0Yy5jYWxlbmRhci5vcGVudGltZXN0YW1wcy5v\ncmc=\n-----END OPENTIMESTAMPS GIT TIMESTAMP-----",
        "payload": "tree 846fd1fb6c46369305d683cc2f53cfc023f8f684\nparent e9c037ba64dd5b073fccf059ef75db1c97abd0bd\nauthor Jon Atack <jon@atack.com> 1608416071 +0100\ncommitter Jon Atack <jon@atack.com> 1613149142 +0100\n\nscripted-diff: clean up outbound connection type naming\n\n-BEGIN VERIFY SCRIPT-\ns() { git grep -l \"$1\" src test/functional doc/files.md doc/reduce-*.md | xargs sed -i \"s/$1/$2/g\"; }\n\ns 'ConnectionType::OUTBOUND '            'ConnectionType::OUTBOUND_FULL_RELAY '\ns 'IsFullOutboundConn'                   'IsOutboundFullRelayConn'\ns 'GetExtraFullOutboundCount'            'GetExtraOutboundFullRelayCount'\ns 'full_outbound_peers'                  'outbound_full_relay_peers'\ns 'GetTryNewOutboundPeer'                'GetTryNewOutboundFullRelayPeer'\ns 'SetTryNewOutboundPeer'                'SetTryNewOutboundFullRelayPeer'\ns 'm_try_another_outbound_peer'          'm_try_another_outbound_full_relay_peer'\ns 'outbound (full-relay)'                'outbound-full-relay'\ns 'outbound full-relay'                  'outbound-full-relay'\ns 'outbound, full-relay'                 'outbound-full-relay'\ns 'outbounds'                            'outbound-full-relay connections'\ns 'f\"outbound: '                         'f\"outbound-full-relay: '\ns ' full-relay'                          ' outbound-full-relay'\ns 'to an extra outbound peer'            'to an extra outbound-full-relay peer'\ns 'try another outbound peer'            'try another outbound-full-relay peer'\ns '(tx, block, addr) outbound'           '(tx, block, addr)'\ns 'we deal with extra outbound peers'    'we deal with extra outbound-full-relay peers'\ns 'outbound peers we have in excess'     'outbound-full-relay peers we have in excess'\ns 'some outbound connections are not'    'some outbound-full-relay connections are not'\ns 'or this is a'                         'or if this is an'\n\ns 'ConnectionType::BLOCK_RELAY'          'ConnectionType::OUTBOUND_BLOCK_RELAY'\ns ' BLOCK_RELAY'                         ' OUTBOUND_BLOCK_RELAY'\ns 'IsBlockOnlyConn'                      'IsOutboundBlockRelayConn'\ns 'GetExtraBlockRelayCount'              'GetExtraOutboundBlockRelayCount'\ns 'block_relay_peers'                    'outbound_block_relay_peers'\ns 'MAX_BLOCK_RELAY_ONLY_ANCHORS'         'MAX_OUTBOUND_BLOCK_RELAY_ANCHORS'\ns 'MAX_BLOCK_RELAY_ONLY_CONNECTIONS'     'MAX_OUTBOUND_BLOCK_RELAY_CONNECTIONS'\ns 'EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL' 'EXTRA_OUTBOUND_BLOCK_RELAY_PEER_INTERVAL'\ns 'm_start_extra_block_relay_peers'      'm_start_extra_outbound_block_relay_peers'\ns 'outgoing block-relay-only'            'outbound-block-relay'\ns 'outbound block-relay-only'            'outbound-block-relay'\ns 'outbound block-relay'                 'outbound-block-relay'\ns 'block-relay only outbound'            'outbound-block-relay'\ns 'block-relay-only outgoing'            'outbound-block-relay'\ns 'block-relay only peers'               'outbound-block-relay peers'\ns 'block-relay-only'                     'outbound-block-relay'\n\ns ' a outbound'                          ' an outbound'\n-END VERIFY SCRIPT-\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/comments",
    "author": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e9c037ba64dd5b073fccf059ef75db1c97abd0bd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9c037ba64dd5b073fccf059ef75db1c97abd0bd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e9c037ba64dd5b073fccf059ef75db1c97abd0bd"
      }
    ],
    "stats": {
      "total": 346,
      "additions": 173,
      "deletions": 173
    },
    "files": [
      {
        "sha": "6bb53a94d73fa13525dde92149b03d87f5e57860",
        "filename": "doc/files.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/doc/files.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/doc/files.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/files.md?ref=c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
        "patch": "@@ -54,7 +54,7 @@ Subdirectory       | File(s)               | Description\n `indexes/blockfilter/basic/db/` | LevelDB database      | Blockfilter index LevelDB database for the basic filtertype; *optional*, used if `-blockfilterindex=basic`\n `indexes/blockfilter/basic/`    | `fltrNNNNN.dat`<sup>[\\[2\\]](#note2)</sup> | Blockfilter index filters for the basic filtertype; *optional*, used if `-blockfilterindex=basic`\n `wallets/`         |                       | [Contains wallets](#multi-wallet-environment); can be specified by `-walletdir` option; if `wallets/` subdirectory does not exist, wallets reside in the [data directory](#data-directory-location)\n-`./`               | `anchors.dat`         | Anchor IP address database, created on shutdown and deleted at startup. Anchors are last known outgoing block-relay-only peers that are tried to re-connect to on startup\n+`./`               | `anchors.dat`         | Anchor IP address database, created on shutdown and deleted at startup. Anchors are last known outbound-block-relay peers that are tried to re-connect to on startup\n `./`               | `banlist.dat`         | Stores the IPs/subnets of banned nodes\n `./`               | `bitcoin.conf`        | User-defined [configuration settings](bitcoin-conf.md) for `bitcoind` or `bitcoin-qt`. File is not written to by the software and must be created manually. Path can be specified by `-conf` option\n `./`               | `bitcoind.pid`        | Stores the process ID (PID) of `bitcoind` or `bitcoin-qt` while running; created at start and deleted on shutdown; can be specified by `-pid` option"
      },
      {
        "sha": "f710b7cfd773c6f9e16624325e8cbd8ccb027c6a",
        "filename": "doc/reduce-memory.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/doc/reduce-memory.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/doc/reduce-memory.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/reduce-memory.md?ref=c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
        "patch": "@@ -26,7 +26,7 @@ The size of some in-memory caches can be reduced. As caches trade off memory usa\n \n - `-maxconnections=<n>` - the maximum number of connections, this defaults to 125. Each active connection takes up some\n   memory. This option applies only if incoming connections are enabled, otherwise the number of connections will never\n-  be more than 10. Of the 10 outbound peers, there can be 8 full-relay connections and 2 block-relay-only ones.\n+  be more than 10. Of the 10 outbound peers, there can be 8 outbound-full-relay connections and 2 outbound-block-relay ones.\n \n ## Thread configuration\n "
      },
      {
        "sha": "5b173570c653feb572a68dfa99d988a49c56444a",
        "filename": "doc/reduce-traffic.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/doc/reduce-traffic.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/doc/reduce-traffic.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/reduce-traffic.md?ref=c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
        "patch": "@@ -5,8 +5,8 @@ Some node operators need to deal with bandwidth caps imposed by their ISPs.\n \n By default, Bitcoin Core allows up to 125 connections to different peers, 10 of\n which are outbound. You can therefore, have at most 115 inbound connections.\n-Of the 10 outbound peers, there can be 8 full-relay connections and 2\n-block-relay-only ones.\n+Of the 10 outbound peers, there can be 8 outbound-full-relay connections and 2\n+outbound-block-relay ones.\n \n The default settings can result in relatively significant traffic consumption.\n "
      },
      {
        "sha": "b371cf8e34a222d4a448e67a29dfd2a17d87974b",
        "filename": "src/addrdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/addrdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/addrdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.cpp?ref=c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
        "patch": "@@ -160,7 +160,7 @@ bool CAddrDB::Read(CAddrMan& addr, CDataStream& ssPeers)\n \n void DumpAnchors(const fs::path& anchors_db_path, const std::vector<CAddress>& anchors)\n {\n-    LOG_TIME_SECONDS(strprintf(\"Flush %d outbound block-relay-only peer addresses to anchors.dat\", anchors.size()));\n+    LOG_TIME_SECONDS(strprintf(\"Flush %d outbound-block-relay peer addresses to anchors.dat\", anchors.size()));\n     SerializeFileDB(\"anchors\", anchors_db_path, anchors);\n }\n "
      },
      {
        "sha": "ac5b34b7d1dc2fbc204095c5b9fbd56d33d95356",
        "filename": "src/addrdb.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/addrdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/addrdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.h?ref=c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
        "patch": "@@ -76,7 +76,7 @@ class CBanDB\n /**\n  * Dump the anchor IP address database (anchors.dat)\n  *\n- * Anchors are last known outgoing block-relay-only peers that are\n+ * Anchors are last known outbound-block-relay peers that are\n  * tried to re-connect to on startup.\n  */\n void DumpAnchors(const fs::path& anchors_db_path, const std::vector<CAddress>& anchors);"
      },
      {
        "sha": "2a3efae8943c54eef8647c66ded4dcc356421704",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
        "patch": "@@ -304,7 +304,7 @@ class NetinfoRequestHandler : public BaseRequestHandler\n     static constexpr uint8_t m_networks_size{4};\n     const std::array<std::string, m_networks_size> m_networks{{\"ipv4\", \"ipv6\", \"onion\", \"i2p\"}};\n     std::array<std::array<uint16_t, m_networks_size + 1>, 3> m_counts{{{}}}; //!< Peer counts by (in/out/total, networks/total)\n-    uint8_t m_block_relay_peers_count{0};\n+    uint8_t m_outbound_block_relay_peers_count{0};\n     uint8_t m_manual_peers_count{0};\n     int8_t NetworkStringToId(const std::string& str) const\n     {\n@@ -361,7 +361,7 @@ class NetinfoRequestHandler : public BaseRequestHandler\n     std::string ConnectionTypeForNetinfo(const std::string& conn_type) const\n     {\n         if (conn_type == \"outbound-full-relay\") return \"full\";\n-        if (conn_type == \"block-relay-only\") return \"block\";\n+        if (conn_type == \"outbound-block-relay\") return \"block\";\n         if (conn_type == \"manual\" || conn_type == \"feeler\") return conn_type;\n         if (conn_type == \"addr-fetch\") return \"addr\";\n         return \"\";\n@@ -479,7 +479,7 @@ class NetinfoRequestHandler : public BaseRequestHandler\n             ++m_counts.at(is_outbound).at(m_networks_size); // in/out overall\n             ++m_counts.at(2).at(network_id);                // total by network\n             ++m_counts.at(2).at(m_networks_size);           // total overall\n-            if (conn_type == \"block-relay-only\") ++m_block_relay_peers_count;\n+            if (conn_type == \"outbound-block-relay\") ++m_outbound_block_relay_peers_count;\n             if (conn_type == \"manual\") ++m_manual_peers_count;\n             if (DetailsRequested()) {\n                 // Push data for this peer to the peers vector.\n@@ -553,7 +553,7 @@ class NetinfoRequestHandler : public BaseRequestHandler\n             if (m_is_i2p_on) result += strprintf(\"   %5i\", m_counts.at(i).at(3)); // i2p peers count\n             result += strprintf(\"   %5i\", m_counts.at(i).at(m_networks_size)); // total peers count\n             if (i == 1) { // the outbound row has two extra columns for block relay and manual peer counts\n-                result += strprintf(\"   %5i\", m_block_relay_peers_count);\n+                result += strprintf(\"   %5i\", m_outbound_block_relay_peers_count);\n                 if (m_manual_peers_count) result += strprintf(\"   %5i\", m_manual_peers_count);\n             }\n         }"
      },
      {
        "sha": "ecb60bcadaedd31493da944dfcb8840aa34e27a3",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
        "patch": "@@ -200,7 +200,7 @@ void Shutdown(NodeContext& node)\n     // using the other before destroying them.\n     if (node.peerman) UnregisterValidationInterface(node.peerman.get());\n     // Follow the lock order requirements:\n-    // * CheckForStaleTipAndEvictPeers locks cs_main before indirectly calling GetExtraFullOutboundCount\n+    // * CheckForStaleTipAndEvictPeers locks cs_main before indirectly calling GetExtraOutboundFullRelayCount\n     //   which locks cs_vNodes.\n     // * ProcessMessage locks cs_main and g_cs_orphans before indirectly calling ForEachNode which\n     //   locks cs_vNodes.\n@@ -1916,7 +1916,7 @@ bool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA\n     connOptions.nLocalServices = nLocalServices;\n     connOptions.nMaxConnections = nMaxConnections;\n     connOptions.m_max_outbound_full_relay = std::min(MAX_OUTBOUND_FULL_RELAY_CONNECTIONS, connOptions.nMaxConnections);\n-    connOptions.m_max_outbound_block_relay = std::min(MAX_BLOCK_RELAY_ONLY_CONNECTIONS, connOptions.nMaxConnections-connOptions.m_max_outbound_full_relay);\n+    connOptions.m_max_outbound_block_relay = std::min(MAX_OUTBOUND_BLOCK_RELAY_CONNECTIONS, connOptions.nMaxConnections-connOptions.m_max_outbound_full_relay);\n     connOptions.nMaxAddnode = MAX_ADDNODE_CONNECTIONS;\n     connOptions.nMaxFeeler = MAX_FEELER_CONNECTIONS;\n     connOptions.uiInterface = &uiInterface;"
      },
      {
        "sha": "a3a2521ab81fa85d8a0bec99c87e886ac467b921",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 50,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
        "patch": "@@ -41,9 +41,9 @@\n \n #include <math.h>\n \n-/** Maximum number of block-relay-only anchor connections */\n-static constexpr size_t MAX_BLOCK_RELAY_ONLY_ANCHORS = 2;\n-static_assert (MAX_BLOCK_RELAY_ONLY_ANCHORS <= static_cast<size_t>(MAX_BLOCK_RELAY_ONLY_CONNECTIONS), \"MAX_BLOCK_RELAY_ONLY_ANCHORS must not exceed MAX_BLOCK_RELAY_ONLY_CONNECTIONS.\");\n+/** Maximum number of outbound-block-relay anchor connections */\n+static constexpr size_t MAX_OUTBOUND_BLOCK_RELAY_ANCHORS = 2;\n+static_assert (MAX_OUTBOUND_BLOCK_RELAY_ANCHORS <= static_cast<size_t>(MAX_OUTBOUND_BLOCK_RELAY_CONNECTIONS), \"MAX_OUTBOUND_BLOCK_RELAY_ANCHORS must not exceed MAX_OUTBOUND_BLOCK_RELAY_CONNECTIONS.\");\n /** Anchor IP address database file name */\n const char* const ANCHORS_DATABASE_FILENAME = \"anchors.dat\";\n \n@@ -513,8 +513,8 @@ std::string ConnectionTypeAsString(ConnectionType conn_type)\n         return \"feeler\";\n     case ConnectionType::OUTBOUND_FULL_RELAY:\n         return \"outbound-full-relay\";\n-    case ConnectionType::BLOCK_RELAY:\n-        return \"block-relay-only\";\n+    case ConnectionType::OUTBOUND_BLOCK_RELAY:\n+        return \"outbound-block-relay\";\n     case ConnectionType::ADDR_FETCH:\n         return \"addr-fetch\";\n     } // no default case, so the compiler can warn about missing cases\n@@ -872,7 +872,7 @@ static bool CompareNodeTXTime(const NodeEvictionCandidate &a, const NodeEviction\n     return a.nTimeConnected > b.nTimeConnected;\n }\n \n-// Pick out the potential block-relay only peers, and sort them by last block time.\n+// Pick out the potential outbound-block-relay peers, and sort them by last block time.\n static bool CompareNodeBlockRelayOnlyTime(const NodeEvictionCandidate &a, const NodeEvictionCandidate &b)\n {\n     if (a.fRelayTxes != b.fRelayTxes) return a.fRelayTxes;\n@@ -1129,7 +1129,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n \n bool CConnman::AddConnection(const std::string& address, ConnectionType conn_type)\n {\n-    if (conn_type != ConnectionType::OUTBOUND_FULL_RELAY && conn_type != ConnectionType::BLOCK_RELAY) return false;\n+    if (conn_type != ConnectionType::OUTBOUND_FULL_RELAY && conn_type != ConnectionType::OUTBOUND_BLOCK_RELAY) return false;\n \n     const int max_connections = conn_type == ConnectionType::OUTBOUND_FULL_RELAY ? m_max_outbound_full_relay : m_max_outbound_block_relay;\n \n@@ -1703,15 +1703,15 @@ void CConnman::ProcessAddrFetch()\n     }\n }\n \n-bool CConnman::GetTryNewOutboundPeer()\n+bool CConnman::GetTryNewOutboundFullRelayPeer()\n {\n-    return m_try_another_outbound_peer;\n+    return m_try_another_outbound_full_relay_peer;\n }\n \n-void CConnman::SetTryNewOutboundPeer(bool flag)\n+void CConnman::SetTryNewOutboundFullRelayPeer(bool flag)\n {\n-    m_try_another_outbound_peer = flag;\n-    LogPrint(BCLog::NET, \"net: setting try another outbound peer=%s\\n\", flag ? \"true\" : \"false\");\n+    m_try_another_outbound_full_relay_peer = flag;\n+    LogPrint(BCLog::NET, \"net: setting try another outbound-full-relay peer=%s\\n\", flag ? \"true\" : \"false\");\n }\n \n // Return the number of peers we have over our outbound connection limit\n@@ -1720,32 +1720,32 @@ void CConnman::SetTryNewOutboundPeer(bool flag)\n // Also exclude peers that haven't finished initial connection handshake yet\n // (so that we don't decide we're over our desired connection limit, and then\n // evict some peer that has finished the handshake)\n-int CConnman::GetExtraFullOutboundCount()\n+int CConnman::GetExtraOutboundFullRelayCount()\n {\n-    int full_outbound_peers = 0;\n+    int outbound_full_relay_peers = 0;\n     {\n         LOCK(cs_vNodes);\n         for (const CNode* pnode : vNodes) {\n-            if (pnode->fSuccessfullyConnected && !pnode->fDisconnect && pnode->IsFullOutboundConn()) {\n-                ++full_outbound_peers;\n+            if (pnode->fSuccessfullyConnected && !pnode->fDisconnect && pnode->IsOutboundFullRelayConn()) {\n+                ++outbound_full_relay_peers;\n             }\n         }\n     }\n-    return std::max(full_outbound_peers - m_max_outbound_full_relay, 0);\n+    return std::max(outbound_full_relay_peers - m_max_outbound_full_relay, 0);\n }\n \n-int CConnman::GetExtraBlockRelayCount()\n+int CConnman::GetExtraOutboundBlockRelayCount()\n {\n-    int block_relay_peers = 0;\n+    int outbound_block_relay_peers = 0;\n     {\n         LOCK(cs_vNodes);\n         for (const CNode* pnode : vNodes) {\n-            if (pnode->fSuccessfullyConnected && !pnode->fDisconnect && pnode->IsBlockOnlyConn()) {\n-                ++block_relay_peers;\n+            if (pnode->fSuccessfullyConnected && !pnode->fDisconnect && pnode->IsOutboundBlockRelayConn()) {\n+                ++outbound_block_relay_peers;\n             }\n         }\n     }\n-    return std::max(block_relay_peers - m_max_outbound_block_relay, 0);\n+    return std::max(outbound_block_relay_peers - m_max_outbound_block_relay, 0);\n }\n \n void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n@@ -1777,7 +1777,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n     // Minimum time before next feeler connection (in microseconds).\n \n     int64_t nNextFeeler = PoissonNextSend(count_microseconds(start), FEELER_INTERVAL);\n-    int64_t nNextExtraBlockRelay = PoissonNextSend(count_microseconds(start), EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL);\n+    int64_t nNextExtraBlockRelay = PoissonNextSend(count_microseconds(start), EXTRA_OUTBOUND_BLOCK_RELAY_PEER_INTERVAL);\n     const bool dnsseed = gArgs.GetBoolArg(\"-dnsseed\", DEFAULT_DNSSEED);\n     bool add_fixed_seeds = gArgs.GetBoolArg(\"-fixedseeds\", DEFAULT_FIXEDSEEDS);\n \n@@ -1838,8 +1838,8 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n         {\n             LOCK(cs_vNodes);\n             for (const CNode* pnode : vNodes) {\n-                if (pnode->IsFullOutboundConn()) nOutboundFullRelay++;\n-                if (pnode->IsBlockOnlyConn()) nOutboundBlockRelay++;\n+                if (pnode->IsOutboundFullRelayConn()) nOutboundFullRelay++;\n+                if (pnode->IsOutboundBlockRelayConn()) nOutboundBlockRelay++;\n \n                 // Netgroups for inbound and manual peers are not excluded because our goal here\n                 // is to not use multiple of our limited outbound slots on a single netgroup\n@@ -1851,7 +1851,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n                     case ConnectionType::MANUAL:\n                         break;\n                     case ConnectionType::OUTBOUND_FULL_RELAY:\n-                    case ConnectionType::BLOCK_RELAY:\n+                    case ConnectionType::OUTBOUND_BLOCK_RELAY:\n                     case ConnectionType::ADDR_FETCH:\n                     case ConnectionType::FEELER:\n                         setConnected.insert(pnode->addr.GetGroup(addrman.m_asmap));\n@@ -1865,26 +1865,26 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n         bool fFeeler = false;\n \n         // Determine what type of connection to open. Opening\n-        // BLOCK_RELAY connections to addresses from anchors.dat gets the highest\n+        // OUTBOUND_BLOCK_RELAY connections to addresses from anchors.dat gets the highest\n         // priority. Then we open OUTBOUND_FULL_RELAY priority until we\n-        // meet our full-relay capacity. Then we open BLOCK_RELAY connection\n-        // until we hit our block-relay-only peer limit.\n-        // GetTryNewOutboundPeer() gets set when a stale tip is detected, so we\n+        // meet our outbound-full-relay capacity. Then we open OUTBOUND_BLOCK_RELAY connection\n+        // until we hit our outbound-block-relay peer limit.\n+        // GetTryNewOutboundFullRelayPeer() gets set when a stale tip is detected, so we\n         // try opening an additional OUTBOUND_FULL_RELAY connection. If none of\n         // these conditions are met, check to see if it's time to try an extra\n-        // block-relay-only peer (to confirm our tip is current, see below) or the nNextFeeler\n+        // outbound-block-relay peer (to confirm our tip is current, see below) or the nNextFeeler\n         // timer to decide if we should open a FEELER.\n \n         if (!m_anchors.empty() && (nOutboundBlockRelay < m_max_outbound_block_relay)) {\n-            conn_type = ConnectionType::BLOCK_RELAY;\n+            conn_type = ConnectionType::OUTBOUND_BLOCK_RELAY;\n             anchor = true;\n         } else if (nOutboundFullRelay < m_max_outbound_full_relay) {\n             // OUTBOUND_FULL_RELAY\n         } else if (nOutboundBlockRelay < m_max_outbound_block_relay) {\n-            conn_type = ConnectionType::BLOCK_RELAY;\n-        } else if (GetTryNewOutboundPeer()) {\n+            conn_type = ConnectionType::OUTBOUND_BLOCK_RELAY;\n+        } else if (GetTryNewOutboundFullRelayPeer()) {\n             // OUTBOUND_FULL_RELAY\n-        } else if (nTime > nNextExtraBlockRelay && m_start_extra_block_relay_peers) {\n+        } else if (nTime > nNextExtraBlockRelay && m_start_extra_outbound_block_relay_peers) {\n             // Periodically connect to a peer (using regular outbound selection\n             // methodology from addrman) and stay connected long enough to sync\n             // headers, but not much else.\n@@ -1895,19 +1895,19 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n             // because every few minutes we're finding a new peer to learn headers\n             // from.\n             //\n-            // This is similar to the logic for trying extra outbound (full-relay)\n+            // This is similar to the logic for trying extra outbound-full-relay\n             // peers, except:\n             // - we do this all the time on a poisson timer, rather than just when\n             //   our tip is stale\n-            // - we potentially disconnect our next-youngest block-relay-only peer, if our\n-            //   newest block-relay-only peer delivers a block more recently.\n+            // - we potentially disconnect our next-youngest outbound-block-relay peer, if our\n+            //   newest outbound-block-relay peer delivers a block more recently.\n             //   See the eviction logic in net_processing.cpp.\n             //\n-            // Because we can promote these connections to block-relay-only\n+            // Because we can promote these connections to outbound-block-relay\n             // connections, they do not get their own ConnectionType enum\n-            // (similar to how we deal with extra outbound peers).\n-            nNextExtraBlockRelay = PoissonNextSend(nTime, EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL);\n-            conn_type = ConnectionType::BLOCK_RELAY;\n+            // (similar to how we deal with extra outbound-full-relay peers).\n+            nNextExtraBlockRelay = PoissonNextSend(nTime, EXTRA_OUTBOUND_BLOCK_RELAY_PEER_INTERVAL);\n+            conn_type = ConnectionType::OUTBOUND_BLOCK_RELAY;\n         } else if (nTime > nNextFeeler) {\n             nNextFeeler = PoissonNextSend(nTime, FEELER_INTERVAL);\n             conn_type = ConnectionType::FEELER;\n@@ -2025,7 +2025,7 @@ std::vector<CAddress> CConnman::GetCurrentBlockRelayOnlyConns() const\n     std::vector<CAddress> ret;\n     LOCK(cs_vNodes);\n     for (const CNode* pnode : vNodes) {\n-        if (pnode->IsBlockOnlyConn()) {\n+        if (pnode->IsOutboundBlockRelayConn()) {\n             ret.push_back(pnode->addr);\n         }\n     }\n@@ -2327,7 +2327,7 @@ void CConnman::SetNetworkActive(bool active)\n CConnman::CConnman(uint64_t nSeed0In, uint64_t nSeed1In, bool network_active)\n     : nSeed0(nSeed0In), nSeed1(nSeed1In)\n {\n-    SetTryNewOutboundPeer(false);\n+    SetTryNewOutboundFullRelayPeer(false);\n \n     Options connOptions;\n     Init(connOptions);\n@@ -2421,10 +2421,10 @@ bool CConnman::Start(CScheduler& scheduler, const Options& connOptions)\n     if (m_use_addrman_outgoing) {\n         // Load addresses from anchors.dat\n         m_anchors = ReadAnchors(GetDataDir() / ANCHORS_DATABASE_FILENAME);\n-        if (m_anchors.size() > MAX_BLOCK_RELAY_ONLY_ANCHORS) {\n-            m_anchors.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS);\n+        if (m_anchors.size() > MAX_OUTBOUND_BLOCK_RELAY_ANCHORS) {\n+            m_anchors.resize(MAX_OUTBOUND_BLOCK_RELAY_ANCHORS);\n         }\n-        LogPrintf(\"%i block-relay-only anchors will be tried for connections.\\n\", m_anchors.size());\n+        LogPrintf(\"%i outbound-block-relay anchors will be tried for connections.\\n\", m_anchors.size());\n     }\n \n     uiInterface.InitMessage(_(\"Starting network threads...\").translated);\n@@ -2546,8 +2546,8 @@ void CConnman::StopNodes()\n         if (m_use_addrman_outgoing) {\n             // Anchor connections are only dumped during clean shutdown.\n             std::vector<CAddress> anchors_to_dump = GetCurrentBlockRelayOnlyConns();\n-            if (anchors_to_dump.size() > MAX_BLOCK_RELAY_ONLY_ANCHORS) {\n-                anchors_to_dump.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS);\n+            if (anchors_to_dump.size() > MAX_OUTBOUND_BLOCK_RELAY_ANCHORS) {\n+                anchors_to_dump.resize(MAX_OUTBOUND_BLOCK_RELAY_ANCHORS);\n             }\n             DumpAnchors(GetDataDir() / ANCHORS_DATABASE_FILENAME, anchors_to_dump);\n         }\n@@ -2865,7 +2865,7 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const\n     if (inbound_onion) assert(conn_type_in == ConnectionType::INBOUND);\n     hSocket = hSocketIn;\n     addrName = addrNameIn == \"\" ? addr.ToStringIPPort() : addrNameIn;\n-    if (conn_type_in != ConnectionType::BLOCK_RELAY) {\n+    if (conn_type_in != ConnectionType::OUTBOUND_BLOCK_RELAY) {\n         m_tx_relay = MakeUnique<TxRelay>();\n     }\n "
      },
      {
        "sha": "f9689c6677d73b3d40e53ab998add4b70b49781c",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 34,
        "deletions": 34,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
        "patch": "@@ -50,8 +50,8 @@ static const bool DEFAULT_WHITELISTFORCERELAY = false;\n static const int TIMEOUT_INTERVAL = 20 * 60;\n /** Run the feeler connection loop once every 2 minutes or 120 seconds. **/\n static const int FEELER_INTERVAL = 120;\n-/** Run the extra block-relay-only connection loop once every 5 minutes. **/\n-static const int EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL = 300;\n+/** Run the extra outbound-block-relay connection loop once every 5 minutes. **/\n+static const int EXTRA_OUTBOUND_BLOCK_RELAY_PEER_INTERVAL = 300;\n /** The maximum number of addresses from our addrman to return in response to a getaddr message. */\n static constexpr size_t MAX_ADDR_TO_SEND = 1000;\n /** Maximum length of incoming protocol messages (no message over 4 MB is currently acceptable). */\n@@ -62,8 +62,8 @@ static const unsigned int MAX_SUBVERSION_LENGTH = 256;\n static const int MAX_OUTBOUND_FULL_RELAY_CONNECTIONS = 8;\n /** Maximum number of addnode outgoing nodes */\n static const int MAX_ADDNODE_CONNECTIONS = 8;\n-/** Maximum number of block-relay-only outgoing connections */\n-static const int MAX_BLOCK_RELAY_ONLY_CONNECTIONS = 2;\n+/** Maximum number of outbound-block-relay connections */\n+static const int MAX_OUTBOUND_BLOCK_RELAY_CONNECTIONS = 2;\n /** Maximum number of feeler connections */\n static const int MAX_FEELER_CONNECTIONS = 1;\n /** -listen default */\n@@ -161,15 +161,15 @@ enum class ConnectionType {\n     FEELER,\n \n     /**\n-     * We use block-relay-only connections to help prevent against partition\n+     * We use outbound-block-relay connections to help prevent against partition\n      * attacks. By not relaying transactions or addresses, these connections\n      * are harder to detect by a third party, thus helping obfuscate the\n      * network topology. We automatically attempt to open\n-     * MAX_BLOCK_RELAY_ONLY_ANCHORS using addresses from our anchors.dat. Then\n-     * addresses from our AddrMan if MAX_BLOCK_RELAY_ONLY_CONNECTIONS\n+     * MAX_OUTBOUND_BLOCK_RELAY_ANCHORS using addresses from our anchors.dat. Then\n+     * addresses from our AddrMan if MAX_OUTBOUND_BLOCK_RELAY_CONNECTIONS\n      * isn't reached yet.\n      */\n-    BLOCK_RELAY,\n+    OUTBOUND_BLOCK_RELAY,\n \n     /**\n      * AddrFetch connections are short lived connections used to solicit\n@@ -463,7 +463,7 @@ class CNode\n     bool IsOutboundOrBlockRelayConn() const {\n         switch (m_conn_type) {\n             case ConnectionType::OUTBOUND_FULL_RELAY:\n-            case ConnectionType::BLOCK_RELAY:\n+            case ConnectionType::OUTBOUND_BLOCK_RELAY:\n                 return true;\n             case ConnectionType::INBOUND:\n             case ConnectionType::MANUAL:\n@@ -475,16 +475,16 @@ class CNode\n         assert(false);\n     }\n \n-    bool IsFullOutboundConn() const {\n+    bool IsOutboundFullRelayConn() const {\n         return m_conn_type == ConnectionType::OUTBOUND_FULL_RELAY;\n     }\n \n     bool IsManualConn() const {\n         return m_conn_type == ConnectionType::MANUAL;\n     }\n \n-    bool IsBlockOnlyConn() const {\n-        return m_conn_type == ConnectionType::BLOCK_RELAY;\n+    bool IsOutboundBlockRelayConn() const {\n+        return m_conn_type == ConnectionType::OUTBOUND_BLOCK_RELAY;\n     }\n \n     bool IsFeelerConn() const {\n@@ -502,10 +502,10 @@ class CNode\n     /* Whether we send addr messages over this connection */\n     bool RelayAddrsWithConn() const\n     {\n-        // Don't relay addr messages to peers that we connect to as block-relay-only\n+        // Don't relay addr messages to peers that we connect to as outbound-block-relay\n         // peers (to prevent adversaries from inferring these links from addr\n         // traffic).\n-        return m_conn_type != ConnectionType::BLOCK_RELAY;\n+        return m_conn_type != ConnectionType::OUTBOUND_BLOCK_RELAY;\n     }\n \n     bool ExpectServicesFromConn() const {\n@@ -515,7 +515,7 @@ class CNode\n             case ConnectionType::FEELER:\n                 return false;\n             case ConnectionType::OUTBOUND_FULL_RELAY:\n-            case ConnectionType::BLOCK_RELAY:\n+            case ConnectionType::OUTBOUND_BLOCK_RELAY:\n             case ConnectionType::ADDR_FETCH:\n                 return true;\n         } // no default case, so the compiler can warn about missing cases\n@@ -942,23 +942,23 @@ class CConnman\n \n     // This allows temporarily exceeding m_max_outbound_full_relay, with the goal of finding\n     // a peer that is better than all our current peers.\n-    void SetTryNewOutboundPeer(bool flag);\n-    bool GetTryNewOutboundPeer();\n+    void SetTryNewOutboundFullRelayPeer(bool flag);\n+    bool GetTryNewOutboundFullRelayPeer();\n \n     void StartExtraBlockRelayPeers() {\n-        LogPrint(BCLog::NET, \"net: enabling extra block-relay-only peers\\n\");\n-        m_start_extra_block_relay_peers = true;\n+        LogPrint(BCLog::NET, \"net: enabling extra outbound-block-relay peers\\n\");\n+        m_start_extra_outbound_block_relay_peers = true;\n     }\n \n-    // Return the number of outbound peers we have in excess of our target (eg,\n-    // if we previously called SetTryNewOutboundPeer(true), and have since set\n+    // Return the number of outbound-full-relay peers we have in excess of our target (eg,\n+    // if we previously called SetTryNewOutboundFullRelayPeer(true), and have since set\n     // to false, we may have extra peers that we wish to disconnect). This may\n     // return a value less than (num_outbound_connections - num_outbound_slots)\n-    // in cases where some outbound connections are not yet fully connected, or\n+    // in cases where some outbound-full-relay connections are not yet fully connected, or\n     // not yet fully disconnected.\n-    int GetExtraFullOutboundCount();\n-    // Count the number of block-relay-only peers we have over our limit.\n-    int GetExtraBlockRelayCount();\n+    int GetExtraOutboundFullRelayCount();\n+    // Count the number of outbound-block-relay peers we have over our limit.\n+    int GetExtraOutboundBlockRelayCount();\n \n     bool AddNode(const std::string& node);\n     bool RemoveAddedNode(const std::string& node);\n@@ -968,7 +968,7 @@ class CConnman\n      * Attempts to open a connection. Currently only used from tests.\n      *\n      * @param[in]   address     Address of node to try connecting to\n-     * @param[in]   conn_type   ConnectionType::OUTBOUND or ConnectionType::BLOCK_RELAY\n+     * @param[in]   conn_type   ConnectionType::OUTBOUND_FULL_RELAY or ConnectionType::OUTBOUND_BLOCK_RELAY\n      * @return      bool        Returns false if there are no available\n      *                          slots for this connection:\n      *                          - conn_type not a supported ConnectionType\n@@ -1088,7 +1088,7 @@ class CConnman\n     void RecordBytesSent(uint64_t bytes);\n \n     /**\n-     * Return vector of current BLOCK_RELAY peers.\n+     * Return vector of current OUTBOUND_BLOCK_RELAY peers.\n      */\n     std::vector<CAddress> GetCurrentBlockRelayOnlyConns() const;\n \n@@ -1175,10 +1175,10 @@ class CConnman\n     std::unique_ptr<CSemaphore> semAddnode;\n     int nMaxConnections;\n \n-    // How many full-relay (tx, block, addr) outbound peers we want\n+    // How many outbound-full-relay (tx, block, addr) peers we want\n     int m_max_outbound_full_relay;\n \n-    // How many block-relay only outbound peers we want\n+    // How many outbound-block-relay peers we want\n     // We do not relay tx or addr messages with these peers\n     int m_max_outbound_block_relay;\n \n@@ -1193,7 +1193,7 @@ class CConnman\n \n     /**\n      * Addresses that were saved during the previous clean shutdown. We'll\n-     * attempt to make block-relay-only connections to them.\n+     * attempt to make outbound-block-relay connections to them.\n      */\n     std::vector<CAddress> m_anchors;\n \n@@ -1215,16 +1215,16 @@ class CConnman\n     std::thread threadOpenConnections;\n     std::thread threadMessageHandler;\n \n-    /** flag for deciding to connect to an extra outbound peer,\n+    /** flag for deciding to connect to an extra outbound-full-relay peer,\n      *  in excess of m_max_outbound_full_relay\n      *  This takes the place of a feeler connection */\n-    std::atomic_bool m_try_another_outbound_peer;\n+    std::atomic_bool m_try_another_outbound_full_relay_peer;\n \n-    /** flag for initiating extra block-relay-only peer connections.\n+    /** flag for initiating extra outbound-block-relay peer connections.\n      *  this should only be enabled after initial chain sync has occurred,\n      *  as these connections are intended to be short-lived and low-bandwidth.\n      */\n-    std::atomic_bool m_start_extra_block_relay_peers{false};\n+    std::atomic_bool m_start_extra_outbound_block_relay_peers{false};\n \n     std::atomic<int64_t> m_next_send_inv_to_incoming{0};\n "
      },
      {
        "sha": "13857660b5757bacf1479a60cbeb432bb2c8a6d5",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 28,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
        "patch": "@@ -332,7 +332,7 @@ class PeerManagerImpl final : public PeerManager\n     const bool m_ignore_incoming_txs;\n \n     /** Whether we've completed initial sync yet, for determining when to turn\n-      * on extra block-relay-only peers. */\n+      * on extra outbound-block-relay peers. */\n     bool m_initial_sync_finished{false};\n \n     /** Protects m_peer_map. This mutex must not be locked while holding a lock\n@@ -519,7 +519,7 @@ struct CNodeState {\n       * Both are only in effect for outbound, non-manual, non-protected connections.\n       * Any peer protected (m_protect = true) is not chosen for eviction. A peer is\n       * marked as protected if all of these are true:\n-      *   - its connection type is IsBlockOnlyConn() == false\n+      *   - its connection type is IsOutboundBlockRelayConn() == false\n       *   - it gave us a valid connecting header\n       *   - we haven't reached MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT yet\n       *   - it has a better chain than we have\n@@ -991,8 +991,8 @@ void PeerManagerImpl::FinalizeNode(const CNode& node, bool& fUpdateConnectionTim\n         nSyncStarted--;\n \n     if (node.fSuccessfullyConnected && misbehavior == 0 &&\n-        !node.IsBlockOnlyConn() && !node.IsInboundConn()) {\n-        // Only change visible addrman state for outbound, full-relay peers\n+        !node.IsOutboundBlockRelayConn() && !node.IsInboundConn()) {\n+        // Only change visible addrman state for outbound-full-relay peers\n         fUpdateConnectionTime = true;\n     }\n \n@@ -2140,12 +2140,12 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n             }\n         }\n \n-        // If this is an outbound full-relay peer, check to see if we should protect\n+        // If this is an outbound-full-relay peer, check to see if we should protect\n         // it from the bad/lagging chain logic.\n-        // Note that outbound block-relay peers are excluded from this protection, and\n+        // Note that outbound-block-relay peers are excluded from this protection, and\n         // thus always subject to eviction under the bad/lagging chain logic.\n         // See ChainSyncTimeoutState.\n-        if (!pfrom.fDisconnect && pfrom.IsFullOutboundConn() && nodestate->pindexBestKnownBlock != nullptr) {\n+        if (!pfrom.fDisconnect && pfrom.IsOutboundFullRelayConn() && nodestate->pindexBestKnownBlock != nullptr) {\n             if (g_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= ::ChainActive().Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n                 LogPrint(BCLog::NET, \"Protecting outbound peer=%d from eviction\\n\", pfrom.GetId());\n                 nodestate->m_chain_sync.m_protect = true;\n@@ -2593,7 +2593,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         UpdatePreferredDownload(pfrom, State(pfrom.GetId()));\n         }\n \n-        if (!pfrom.IsInboundConn() && !pfrom.IsBlockOnlyConn()) {\n+        if (!pfrom.IsInboundConn() && !pfrom.IsOutboundBlockRelayConn()) {\n             // For outbound peers, we try to relay our address (so that other\n             // nodes can try to find us more quickly, as we have no guarantee\n             // that an outbound peer is even aware of how to reach us) and do a\n@@ -2602,8 +2602,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // empty and no one will know who we are, so these mechanisms are\n             // important to help us connect to the network.\n             //\n-            // We skip this for block-relay-only peers to avoid potentially leaking\n-            // information about our block-relay-only connections via address relay.\n+            // We skip this for outbound-block-relay peers to avoid potentially leaking\n+            // information about our outbound-block-relay connections via address relay.\n             if (fListen && !::ChainstateActive().IsInitialBlockDownload())\n             {\n                 CAddress addr = GetLocalAddress(&pfrom.addr, pfrom.GetLocalServices());\n@@ -2629,12 +2629,12 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // connection success so that addrman will have an up-to-date\n             // notion of which peers are online and available.\n             //\n-            // While we strive to not leak information about block-relay-only\n+            // While we strive to not leak information about outbound-block-relay\n             // connections via the addrman, not moving an address to the tried\n             // table is also potentially detrimental because new-table entries\n             // are subject to eviction in the event of addrman collisions.  We\n             // mitigate the information-leak by never calling\n-            // CAddrMan::Connected() on block-relay-only peers; see\n+            // CAddrMan::Connected() on outbound-block-relay peers; see\n             // FinalizeNode().\n             //\n             // This moves an address from New to Tried table in Addrman,\n@@ -2863,8 +2863,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             return;\n         }\n \n-        // We won't accept tx inv's if we're in blocks-only mode, or this is a\n-        // block-relay-only peer\n+        // We won't accept tx inv's if we're in blocks-only mode, or if this is an\n+        // outbound-block-relay peer\n         bool fBlocksOnly = m_ignore_incoming_txs || (pfrom.m_tx_relay == nullptr);\n \n         // Allow peers with relay permission to send data other than blocks in blocks only mode\n@@ -3140,7 +3140,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n     if (msg_type == NetMsgType::TX) {\n         // Stop processing the transaction early if\n         // 1) We are in blocks only mode and peer has no relay permission\n-        // 2) This peer is a block-relay-only peer\n+        // 2) This peer is an outbound-block-relay peer\n         if ((m_ignore_incoming_txs && !pfrom.HasPermission(PF_RELAY)) || (pfrom.m_tx_relay == nullptr))\n         {\n             LogPrint(BCLog::NET, \"transaction sent in violation of protocol peer=%d\\n\", pfrom.GetId());\n@@ -4143,17 +4143,17 @@ void PeerManagerImpl::ConsiderEviction(CNode& pto, int64_t time_in_seconds)\n \n void PeerManagerImpl::EvictExtraOutboundPeers(int64_t time_in_seconds)\n {\n-    // If we have any extra block-relay-only peers, disconnect the youngest unless\n+    // If we have any extra outbound-block-relay peers, disconnect the youngest unless\n     // it's given us a block -- in which case, compare with the second-youngest, and\n     // out of those two, disconnect the peer who least recently gave us a block.\n-    // The youngest block-relay-only peer would be the extra peer we connected\n+    // The youngest outbound-block-relay peer would be the extra peer we connected\n     // to temporarily in order to sync our tip; see net.cpp.\n     // Note that we use higher nodeid as a measure for most recent connection.\n-    if (m_connman.GetExtraBlockRelayCount() > 0) {\n+    if (m_connman.GetExtraOutboundBlockRelayCount() > 0) {\n         std::pair<NodeId, int64_t> youngest_peer{-1, 0}, next_youngest_peer{-1, 0};\n \n         m_connman.ForEachNode([&](CNode* pnode) {\n-            if (!pnode->IsBlockOnlyConn() || pnode->fDisconnect) return;\n+            if (!pnode->IsOutboundBlockRelayConn() || pnode->fDisconnect) return;\n             if (pnode->GetId() > youngest_peer.first) {\n                 next_youngest_peer = youngest_peer;\n                 youngest_peer.first = pnode->GetId();\n@@ -4162,7 +4162,7 @@ void PeerManagerImpl::EvictExtraOutboundPeers(int64_t time_in_seconds)\n         });\n         NodeId to_disconnect = youngest_peer.first;\n         if (youngest_peer.second > next_youngest_peer.second) {\n-            // Our newest block-relay-only peer gave us a block more recently;\n+            // Our newest outbound-block-relay peer gave us a block more recently;\n             // disconnect our second youngest.\n             to_disconnect = next_youngest_peer.first;\n         }\n@@ -4177,18 +4177,18 @@ void PeerManagerImpl::EvictExtraOutboundPeers(int64_t time_in_seconds)\n             if (node_state == nullptr ||\n                 (time_in_seconds - pnode->nTimeConnected >= MINIMUM_CONNECT_TIME && node_state->nBlocksInFlight == 0)) {\n                 pnode->fDisconnect = true;\n-                LogPrint(BCLog::NET, \"disconnecting extra block-relay-only peer=%d (last block received at time %d)\\n\", pnode->GetId(), pnode->nLastBlockTime);\n+                LogPrint(BCLog::NET, \"disconnecting extra outbound-block-relay peer=%d (last block received at time %d)\\n\", pnode->GetId(), pnode->nLastBlockTime);\n                 return true;\n             } else {\n-                LogPrint(BCLog::NET, \"keeping block-relay-only peer=%d chosen for eviction (connect time: %d, blocks_in_flight: %d)\\n\",\n+                LogPrint(BCLog::NET, \"keeping outbound-block-relay peer=%d chosen for eviction (connect time: %d, blocks_in_flight: %d)\\n\",\n                     pnode->GetId(), pnode->nTimeConnected, node_state->nBlocksInFlight);\n             }\n             return false;\n         });\n     }\n \n     // Check whether we have too many outbound-full-relay peers\n-    if (m_connman.GetExtraFullOutboundCount() > 0) {\n+    if (m_connman.GetExtraOutboundFullRelayCount() > 0) {\n         // If we have more outbound-full-relay peers than we target, disconnect one.\n         // Pick the outbound-full-relay peer that least recently announced\n         // us a new block, with ties broken by choosing the more recent\n@@ -4201,7 +4201,7 @@ void PeerManagerImpl::EvictExtraOutboundPeers(int64_t time_in_seconds)\n \n             // Only consider outbound-full-relay peers that are not already\n             // marked for disconnection\n-            if (!pnode->IsFullOutboundConn() || pnode->fDisconnect) return;\n+            if (!pnode->IsOutboundFullRelayConn() || pnode->fDisconnect) return;\n             CNodeState *state = State(pnode->GetId());\n             if (state == nullptr) return; // shouldn't be possible, but just in case\n             // Don't evict our protected peers\n@@ -4236,7 +4236,7 @@ void PeerManagerImpl::EvictExtraOutboundPeers(int64_t time_in_seconds)\n                 // detected a stale tip. Don't try any more extra peers until\n                 // we next detect a stale tip, to limit the load we put on the\n                 // network from these extra connections.\n-                m_connman.SetTryNewOutboundPeer(false);\n+                m_connman.SetTryNewOutboundFullRelayPeer(false);\n             }\n         }\n     }\n@@ -4255,9 +4255,9 @@ void PeerManagerImpl::CheckForStaleTipAndEvictPeers()\n         // outbound peer\n         if (!fImporting && !fReindex && m_connman.GetNetworkActive() && m_connman.GetUseAddrmanOutgoing() && TipMayBeStale(m_chainparams.GetConsensus())) {\n             LogPrintf(\"Potential stale tip detected, will try using extra outbound peer (last tip update: %d seconds ago)\\n\", time_in_seconds - g_last_tip_update);\n-            m_connman.SetTryNewOutboundPeer(true);\n-        } else if (m_connman.GetTryNewOutboundPeer()) {\n-            m_connman.SetTryNewOutboundPeer(false);\n+            m_connman.SetTryNewOutboundFullRelayPeer(true);\n+        } else if (m_connman.GetTryNewOutboundFullRelayPeer()) {\n+            m_connman.SetTryNewOutboundFullRelayPeer(false);\n         }\n         m_stale_tip_check_time = time_in_seconds + STALE_CHECK_INTERVAL;\n     }"
      },
      {
        "sha": "8d322f513af802504dda12d7e5077a6b9ef869f0",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
        "patch": "@@ -771,7 +771,7 @@ QString ConnectionTypeToQString(ConnectionType conn_type)\n     switch (conn_type) {\n     case ConnectionType::INBOUND: return QObject::tr(\"Inbound\");\n     case ConnectionType::OUTBOUND_FULL_RELAY: return QObject::tr(\"Outbound Full Relay\");\n-    case ConnectionType::BLOCK_RELAY: return QObject::tr(\"Outbound Block Relay\");\n+    case ConnectionType::OUTBOUND_BLOCK_RELAY: return QObject::tr(\"Outbound Block Relay\");\n     case ConnectionType::MANUAL: return QObject::tr(\"Outbound Manual\");\n     case ConnectionType::FEELER: return QObject::tr(\"Outbound Feeler\");\n     case ConnectionType::ADDR_FETCH: return QObject::tr(\"Outbound Address Fetch\");"
      },
      {
        "sha": "1d0afd0797db1b92dbc5126a5b13361d7edba648",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
        "patch": "@@ -32,7 +32,7 @@\n \n const std::vector<std::string> CONNECTION_TYPE_DOC{\n         \"outbound-full-relay (default automatic connections)\",\n-        \"block-relay-only (does not relay transactions or addresses)\",\n+        \"outbound-block-relay (does not relay transactions or addresses)\",\n         \"inbound (initiated by the peer)\",\n         \"manual (added via addnode RPC or -addnode/-connect configuration options)\",\n         \"addr-fetch (short-lived automatic connection for soliciting addresses)\",\n@@ -321,7 +321,7 @@ static RPCHelpMan addconnection()\n         \"\\nOpen an outbound connection to a specified node. This RPC is for testing only.\\n\",\n         {\n             {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The IP address and port to attempt connecting to.\"},\n-            {\"connection_type\", RPCArg::Type::STR, RPCArg::Optional::NO, \"Type of connection to open, either \\\"outbound-full-relay\\\" or \\\"block-relay-only\\\".\"},\n+            {\"connection_type\", RPCArg::Type::STR, RPCArg::Optional::NO, \"Type of connection to open, either \\\"outbound-full-relay\\\" or \\\"outbound-block-relay\\\".\"},\n         },\n         RPCResult{\n             RPCResult::Type::OBJ, \"\", \"\",\n@@ -345,8 +345,8 @@ static RPCHelpMan addconnection()\n     ConnectionType conn_type{};\n     if (conn_type_in == \"outbound-full-relay\") {\n         conn_type = ConnectionType::OUTBOUND_FULL_RELAY;\n-    } else if (conn_type_in == \"block-relay-only\") {\n-        conn_type = ConnectionType::BLOCK_RELAY;\n+    } else if (conn_type_in == \"outbound-block-relay\") {\n+        conn_type = ConnectionType::OUTBOUND_BLOCK_RELAY;\n     } else {\n         throw JSONRPCError(RPC_INVALID_PARAMETER, self.ToString());\n     }"
      },
      {
        "sha": "010b096cc93d3d803a88922aef17e9be72670f7c",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
        "patch": "@@ -179,7 +179,7 @@ BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n     // Now tip should definitely be stale, and we should look for an extra\n     // outbound peer\n     peerLogic->CheckForStaleTipAndEvictPeers();\n-    BOOST_CHECK(connman->GetTryNewOutboundPeer());\n+    BOOST_CHECK(connman->GetTryNewOutboundFullRelayPeer());\n \n     // Still no peers should be marked for disconnection\n     for (const CNode *node : vNodes) {"
      },
      {
        "sha": "cc0671dee574e5aa4d06d513ce24816551d8a93e",
        "filename": "src/test/fuzz/connman.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/test/fuzz/connman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/test/fuzz/connman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/connman.cpp?ref=c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
        "patch": "@@ -128,11 +128,11 @@ FUZZ_TARGET_INIT(connman, initialize_connman)\n                 connman.SetServices(random_service, ConsumeWeakEnum(fuzzed_data_provider, ALL_SERVICE_FLAGS));\n             },\n             [&] {\n-                connman.SetTryNewOutboundPeer(fuzzed_data_provider.ConsumeBool());\n+                connman.SetTryNewOutboundFullRelayPeer(fuzzed_data_provider.ConsumeBool());\n             });\n     }\n     (void)connman.GetAddedNodeInfo();\n-    (void)connman.GetExtraFullOutboundCount();\n+    (void)connman.GetExtraOutboundFullRelayCount();\n     (void)connman.GetLocalServices();\n     (void)connman.GetMaxOutboundTarget();\n     (void)connman.GetMaxOutboundTimeframe();\n@@ -144,6 +144,6 @@ FUZZ_TARGET_INIT(connman, initialize_connman)\n     (void)connman.GetReceiveFloodSize();\n     (void)connman.GetTotalBytesRecv();\n     (void)connman.GetTotalBytesSent();\n-    (void)connman.GetTryNewOutboundPeer();\n+    (void)connman.GetTryNewOutboundFullRelayPeer();\n     (void)connman.GetUseAddrmanOutgoing();\n }"
      },
      {
        "sha": "97cf7ef6bb5f1e6d1fdfaa375bf03f666aba6a33",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
        "patch": "@@ -193,9 +193,9 @@ BOOST_AUTO_TEST_CASE(cnode_simple_test)\n         /* nKeyedNetGroupIn = */ 0,\n         /* nLocalHostNonceIn = */ 0,\n         CAddress(), pszDest, ConnectionType::OUTBOUND_FULL_RELAY);\n-    BOOST_CHECK(pnode1->IsFullOutboundConn() == true);\n+    BOOST_CHECK(pnode1->IsOutboundFullRelayConn() == true);\n     BOOST_CHECK(pnode1->IsManualConn() == false);\n-    BOOST_CHECK(pnode1->IsBlockOnlyConn() == false);\n+    BOOST_CHECK(pnode1->IsOutboundBlockRelayConn() == false);\n     BOOST_CHECK(pnode1->IsFeelerConn() == false);\n     BOOST_CHECK(pnode1->IsAddrFetchConn() == false);\n     BOOST_CHECK(pnode1->IsInboundConn() == false);\n@@ -208,9 +208,9 @@ BOOST_AUTO_TEST_CASE(cnode_simple_test)\n         /* nLocalHostNonceIn = */ 1,\n         CAddress(), pszDest, ConnectionType::INBOUND,\n         /* inbound_onion = */ false);\n-    BOOST_CHECK(pnode2->IsFullOutboundConn() == false);\n+    BOOST_CHECK(pnode2->IsOutboundFullRelayConn() == false);\n     BOOST_CHECK(pnode2->IsManualConn() == false);\n-    BOOST_CHECK(pnode2->IsBlockOnlyConn() == false);\n+    BOOST_CHECK(pnode2->IsOutboundBlockRelayConn() == false);\n     BOOST_CHECK(pnode2->IsFeelerConn() == false);\n     BOOST_CHECK(pnode2->IsAddrFetchConn() == false);\n     BOOST_CHECK(pnode2->IsInboundConn() == true);\n@@ -223,9 +223,9 @@ BOOST_AUTO_TEST_CASE(cnode_simple_test)\n         /* nLocalHostNonceIn = */ 0,\n         CAddress(), pszDest, ConnectionType::OUTBOUND_FULL_RELAY,\n         /* inbound_onion = */ false);\n-    BOOST_CHECK(pnode3->IsFullOutboundConn() == true);\n+    BOOST_CHECK(pnode3->IsOutboundFullRelayConn() == true);\n     BOOST_CHECK(pnode3->IsManualConn() == false);\n-    BOOST_CHECK(pnode3->IsBlockOnlyConn() == false);\n+    BOOST_CHECK(pnode3->IsOutboundBlockRelayConn() == false);\n     BOOST_CHECK(pnode3->IsFeelerConn() == false);\n     BOOST_CHECK(pnode3->IsAddrFetchConn() == false);\n     BOOST_CHECK(pnode3->IsInboundConn() == false);\n@@ -238,9 +238,9 @@ BOOST_AUTO_TEST_CASE(cnode_simple_test)\n         /* nLocalHostNonceIn = */ 1,\n         CAddress(), pszDest, ConnectionType::INBOUND,\n         /* inbound_onion = */ true);\n-    BOOST_CHECK(pnode4->IsFullOutboundConn() == false);\n+    BOOST_CHECK(pnode4->IsOutboundFullRelayConn() == false);\n     BOOST_CHECK(pnode4->IsManualConn() == false);\n-    BOOST_CHECK(pnode4->IsBlockOnlyConn() == false);\n+    BOOST_CHECK(pnode4->IsOutboundBlockRelayConn() == false);\n     BOOST_CHECK(pnode4->IsFeelerConn() == false);\n     BOOST_CHECK(pnode4->IsAddrFetchConn() == false);\n     BOOST_CHECK(pnode4->IsInboundConn() == true);"
      },
      {
        "sha": "384431823f82198317121b11ea5a8c06d450d521",
        "filename": "src/test/util/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/test/util/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/src/test/util/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/net.h?ref=c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
        "patch": "@@ -57,7 +57,7 @@ constexpr ConnectionType ALL_CONNECTION_TYPES[]{\n     ConnectionType::OUTBOUND_FULL_RELAY,\n     ConnectionType::MANUAL,\n     ConnectionType::FEELER,\n-    ConnectionType::BLOCK_RELAY,\n+    ConnectionType::OUTBOUND_BLOCK_RELAY,\n     ConnectionType::ADDR_FETCH,\n };\n "
      },
      {
        "sha": "38da59bdc15ad7c230cb5950cd78084227a8c46e",
        "filename": "test/functional/p2p_add_connections.py",
        "status": "modified",
        "additions": 24,
        "deletions": 24,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/test/functional/p2p_add_connections.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/test/functional/p2p_add_connections.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_add_connections.py?ref=c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
        "patch": "@@ -24,32 +24,32 @@ def setup_network(self):\n         # Don't connect the nodes\n \n     def run_test(self):\n-        self.log.info(\"Add 8 outbounds to node 0\")\n+        self.log.info(\"Add 8 outbound-full-relay connections to node 0\")\n         for i in range(8):\n-            self.log.info(f\"outbound: {i}\")\n+            self.log.info(f\"outbound-full-relay: {i}\")\n             self.nodes[0].add_outbound_p2p_connection(P2PInterface(), p2p_idx=i, connection_type=\"outbound-full-relay\")\n \n-        self.log.info(\"Add 2 block-relay-only connections to node 0\")\n+        self.log.info(\"Add 2 outbound-block-relay connections to node 0\")\n         for i in range(2):\n-            self.log.info(f\"block-relay-only: {i}\")\n+            self.log.info(f\"outbound-block-relay: {i}\")\n             # set p2p_idx based on the outbound connections already open to the\n-            # node, so add 8 to account for the previous full-relay connections\n-            self.nodes[0].add_outbound_p2p_connection(P2PInterface(), p2p_idx=i + 8, connection_type=\"block-relay-only\")\n+            # node, so add 8 to account for the previous outbound-full-relay connections\n+            self.nodes[0].add_outbound_p2p_connection(P2PInterface(), p2p_idx=i + 8, connection_type=\"outbound-block-relay\")\n \n-        self.log.info(\"Add 2 block-relay-only connections to node 1\")\n+        self.log.info(\"Add 2 outbound-block-relay connections to node 1\")\n         for i in range(2):\n-            self.log.info(f\"block-relay-only: {i}\")\n-            self.nodes[1].add_outbound_p2p_connection(P2PInterface(), p2p_idx=i, connection_type=\"block-relay-only\")\n+            self.log.info(f\"outbound-block-relay: {i}\")\n+            self.nodes[1].add_outbound_p2p_connection(P2PInterface(), p2p_idx=i, connection_type=\"outbound-block-relay\")\n \n         self.log.info(\"Add 5 inbound connections to node 1\")\n         for i in range(5):\n             self.log.info(f\"inbound: {i}\")\n             self.nodes[1].add_p2p_connection(P2PInterface())\n \n-        self.log.info(\"Add 8 outbounds to node 1\")\n+        self.log.info(\"Add 8 outbound-full-relay connections to node 1\")\n         for i in range(8):\n-            self.log.info(f\"outbound: {i}\")\n-            # bump p2p_idx to account for the 2 existing outbounds on node 1\n+            self.log.info(f\"outbound-full-relay: {i}\")\n+            # bump p2p_idx to account for the 2 existing outbound-full-relay connections on node 1\n             self.nodes[1].add_outbound_p2p_connection(P2PInterface(), p2p_idx=i + 2)\n \n         self.log.info(\"Check the connections opened as expected\")\n@@ -60,33 +60,33 @@ def run_test(self):\n         self.nodes[0].disconnect_p2ps()\n         check_node_connections(node=self.nodes[0], num_in=0, num_out=0)\n \n-        self.log.info(\"Add 8 outbounds to node 0\")\n+        self.log.info(\"Add 8 outbound-full-relay connections to node 0\")\n         for i in range(8):\n-            self.log.info(f\"outbound: {i}\")\n+            self.log.info(f\"outbound-full-relay: {i}\")\n             self.nodes[0].add_outbound_p2p_connection(P2PInterface(), p2p_idx=i)\n         check_node_connections(node=self.nodes[0], num_in=0, num_out=8)\n \n-        self.log.info(\"Add 2 block-relay-only connections to node 0\")\n+        self.log.info(\"Add 2 outbound-block-relay connections to node 0\")\n         for i in range(2):\n-            self.log.info(f\"block-relay-only: {i}\")\n-            # bump p2p_idx to account for the 8 existing outbounds on node 0\n-            self.nodes[0].add_outbound_p2p_connection(P2PInterface(), p2p_idx=i + 8, connection_type=\"block-relay-only\")\n+            self.log.info(f\"outbound-block-relay: {i}\")\n+            # bump p2p_idx to account for the 8 existing outbound-full-relay connections on node 0\n+            self.nodes[0].add_outbound_p2p_connection(P2PInterface(), p2p_idx=i + 8, connection_type=\"outbound-block-relay\")\n         check_node_connections(node=self.nodes[0], num_in=0, num_out=10)\n \n         self.log.info(\"Restart node 0 and try to reconnect to p2ps\")\n         self.restart_node(0)\n \n-        self.log.info(\"Add 4 outbounds to node 0\")\n+        self.log.info(\"Add 4 outbound-full-relay connections to node 0\")\n         for i in range(4):\n-            self.log.info(f\"outbound: {i}\")\n+            self.log.info(f\"outbound-full-relay: {i}\")\n             self.nodes[0].add_outbound_p2p_connection(P2PInterface(), p2p_idx=i)\n         check_node_connections(node=self.nodes[0], num_in=0, num_out=4)\n \n-        self.log.info(\"Add 2 block-relay-only connections to node 0\")\n+        self.log.info(\"Add 2 outbound-block-relay connections to node 0\")\n         for i in range(2):\n-            self.log.info(f\"block-relay-only: {i}\")\n-            # bump p2p_idx to account for the 4 existing outbounds on node 0\n-            self.nodes[0].add_outbound_p2p_connection(P2PInterface(), p2p_idx=i + 4, connection_type=\"block-relay-only\")\n+            self.log.info(f\"outbound-block-relay: {i}\")\n+            # bump p2p_idx to account for the 4 existing outbound-full-relay connections on node 0\n+            self.nodes[0].add_outbound_p2p_connection(P2PInterface(), p2p_idx=i + 4, connection_type=\"outbound-block-relay\")\n         check_node_connections(node=self.nodes[0], num_in=0, num_out=6)\n \n         check_node_connections(node=self.nodes[1], num_in=5, num_out=10)"
      },
      {
        "sha": "db8c949187dd5a58db85ddfa6e03f5189b788e63",
        "filename": "test/functional/p2p_blocksonly.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/test/functional/p2p_blocksonly.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/test/functional/p2p_blocksonly.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_blocksonly.py?ref=c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
        "patch": "@@ -2,7 +2,7 @@\n # Copyright (c) 2019-2020 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Test p2p blocksonly mode & block-relay-only connections.\"\"\"\n+\"\"\"Test p2p blocksonly mode & outbound-block-relay connections.\"\"\"\n \n import time\n \n@@ -72,17 +72,17 @@ def blocksonly_mode_tests(self):\n         self.nodes[0].generate(1)\n \n     def blocks_relay_conn_tests(self):\n-        self.log.info('Tests with node in normal mode with block-relay-only connections')\n+        self.log.info('Tests with node in normal mode with outbound-block-relay connections')\n         self.restart_node(0, [\"-noblocksonly\"])  # disables blocks only mode\n         assert_equal(self.nodes[0].getnetworkinfo()['localrelay'], True)\n \n-        # Ensure we disconnect if a block-relay-only connection sends us a transaction\n-        self.nodes[0].add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"block-relay-only\")\n+        # Ensure we disconnect if an outbound-block-relay connection sends us a transaction\n+        self.nodes[0].add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-block-relay\")\n         assert_equal(self.nodes[0].getpeerinfo()[0]['relaytxes'], False)\n         _, txid, tx_hex = self.check_p2p_tx_violation(index=2)\n \n         self.log.info(\"Check that txs from RPC are not sent to blockrelay connection\")\n-        conn = self.nodes[0].add_outbound_p2p_connection(P2PTxInvStore(), p2p_idx=1, connection_type=\"block-relay-only\")\n+        conn = self.nodes[0].add_outbound_p2p_connection(P2PTxInvStore(), p2p_idx=1, connection_type=\"outbound-block-relay\")\n \n         self.nodes[0].sendrawtransaction(tx_hex)\n "
      },
      {
        "sha": "f36a37a2edafa0de6ca93dd55837bc57d51440cf",
        "filename": "test/functional/test_framework/test_node.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/test/functional/test_framework/test_node.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb/test/functional/test_framework/test_node.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_node.py?ref=c3e3a16d1dda386e387b5ef80a3a381c7a1e4fdb",
        "patch": "@@ -549,8 +549,8 @@ def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, **kwargs):\n \n     def add_outbound_p2p_connection(self, p2p_conn, *, p2p_idx, connection_type=\"outbound-full-relay\", **kwargs):\n         \"\"\"Add an outbound p2p connection from node. Either\n-        full-relay(\"outbound-full-relay\") or\n-        block-relay-only(\"block-relay-only\") connection.\n+        outbound-full-relay(\"outbound-full-relay\") or\n+        outbound-block-relay(\"outbound-block-relay\") connection.\n \n         This method adds the p2p connection to the self.p2ps list and returns\n         the connection to the caller."
      }
    ]
  }
]