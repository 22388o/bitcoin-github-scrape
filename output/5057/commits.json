[
  {
    "sha": "d3fd120f325d710a64d0d5efe68e3fb29e33cd38",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkM2ZkMTIwZjMyNWQ3MTBhNjRkMGQ1ZWZlNjhlM2ZiMjllMzNjZDM4",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-07-11T22:02:35Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-06T06:28:48Z"
      },
      "message": "Headers-first synchronization\n\nMany changes:\n* Do not use 'getblocks', but 'getheaders', and use it to build a headers tree.\n* Blocks are fetched in parallel from all available outbound peers, using a\n  limited moving window. When one peer stalls the movement of the window, it is\n  disconnected.\n* No more orphan blocks. At all. We only ever request a block for which we have\n  verified the headers, and store it to disk immediately. This means that a\n  disk-fill attack would require PoW.\n* Require protocol version 31800 for every peer (released in december 2010).\n* No more syncnode (we sync from everyone we can, though limited to 1 during\n  initial *headers* sync).\n* Introduce some extra named constants, comments and asserts.",
      "tree": {
        "sha": "ff7c9f71d2c4212cf3216eec0d59d1c80a1d7362",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ff7c9f71d2c4212cf3216eec0d59d1c80a1d7362"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d3fd120f325d710a64d0d5efe68e3fb29e33cd38",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d3fd120f325d710a64d0d5efe68e3fb29e33cd38",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d3fd120f325d710a64d0d5efe68e3fb29e33cd38",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d3fd120f325d710a64d0d5efe68e3fb29e33cd38/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5505a1b13f75af9f0f6421b42d97c06e079db345",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5505a1b13f75af9f0f6421b42d97c06e079db345",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5505a1b13f75af9f0f6421b42d97c06e079db345"
      }
    ],
    "stats": {
      "total": 745,
      "additions": 375,
      "deletions": 370
    },
    "files": [
      {
        "sha": "4e6a466c6a38087d58ac81432f7c94e8b39679f0",
        "filename": "src/chain.h",
        "status": "modified",
        "additions": 25,
        "deletions": 7,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d3fd120f325d710a64d0d5efe68e3fb29e33cd38/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d3fd120f325d710a64d0d5efe68e3fb29e33cd38/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=d3fd120f325d710a64d0d5efe68e3fb29e33cd38",
        "patch": "@@ -49,12 +49,29 @@ struct CDiskBlockPos\n };\n \n enum BlockStatus {\n+    // Unused.\n     BLOCK_VALID_UNKNOWN      =    0,\n-    BLOCK_VALID_HEADER       =    1, // parsed, version ok, hash satisfies claimed PoW, 1 <= vtx count <= max, timestamp not in future\n-    BLOCK_VALID_TREE         =    2, // parent found, difficulty matches, timestamp >= median previous, checkpoint\n-    BLOCK_VALID_TRANSACTIONS =    3, // only first tx is coinbase, 2 <= coinbase input script length <= 100, transactions valid, no duplicate txids, sigops, size, merkle root\n-    BLOCK_VALID_CHAIN        =    4, // outputs do not overspend inputs, no double spends, coinbase output ok, immature coinbase spends, BIP30\n-    BLOCK_VALID_SCRIPTS      =    5, // scripts/signatures ok\n+\n+    // Parsed, version ok, hash satisfies claimed PoW, 1 <= vtx count <= max, timestamp not in future\n+    BLOCK_VALID_HEADER       =    1,\n+\n+    // All parent headers found, difficulty matches, timestamp >= median previous, checkpoint. Implies all parents\n+    // are also at least TREE.\n+    BLOCK_VALID_TREE         =    2,\n+\n+    // Only first tx is coinbase, 2 <= coinbase input script length <= 100, transactions valid, no duplicate txids,\n+    // sigops, size, merkle root. Implies all parents are at least TREE but not necessarily TRANSACTIONS. When all\n+    // parent blocks also have TRANSACTIONS, CBlockIndex::nChainTx will be set.\n+    BLOCK_VALID_TRANSACTIONS =    3,\n+\n+    // Outputs do not overspend inputs, no double spends, coinbase output ok, immature coinbase spends, BIP30.\n+    // Implies all parents are also at least CHAIN.\n+    BLOCK_VALID_CHAIN        =    4,\n+\n+    // Scripts & signatures ok. Implies all parents are also at least SCRIPTS.\n+    BLOCK_VALID_SCRIPTS      =    5,\n+\n+    // All validity bits.\n     BLOCK_VALID_MASK         =   BLOCK_VALID_HEADER | BLOCK_VALID_TREE | BLOCK_VALID_TRANSACTIONS |\n                                  BLOCK_VALID_CHAIN | BLOCK_VALID_SCRIPTS,\n \n@@ -103,7 +120,8 @@ class CBlockIndex\n     // Note: in a potential headers-first mode, this number cannot be relied upon\n     unsigned int nTx;\n \n-    // (memory only) Number of transactions in the chain up to and including this block\n+    // (memory only) Number of transactions in the chain up to and including this block.\n+    // This value will be non-zero only if and only if transactions for this block and all its parents are available.\n     unsigned int nChainTx; // change to 64-bit type when necessary; won't happen before 2030\n \n     // Verification status of this block. See enum BlockStatus\n@@ -146,7 +164,7 @@ class CBlockIndex\n         SetNull();\n     }\n \n-    CBlockIndex(CBlockHeader& block)\n+    CBlockIndex(const CBlockHeader& block)\n     {\n         SetNull();\n "
      },
      {
        "sha": "052d499e3878803c723fe7e00ea94e0c40fa9986",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 334,
        "deletions": 274,
        "changes": 608,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d3fd120f325d710a64d0d5efe68e3fb29e33cd38/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d3fd120f325d710a64d0d5efe68e3fb29e33cd38/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=d3fd120f325d710a64d0d5efe68e3fb29e33cd38",
        "patch": "@@ -56,14 +56,6 @@ CFeeRate minRelayTxFee = CFeeRate(1000);\n \n CTxMemPool mempool(::minRelayTxFee);\n \n-struct COrphanBlock {\n-    uint256 hashBlock;\n-    uint256 hashPrev;\n-    vector<unsigned char> vchBlock;\n-};\n-map<uint256, COrphanBlock*> mapOrphanBlocks;\n-multimap<uint256, COrphanBlock*> mapOrphanBlocksByPrev;\n-\n struct COrphanTx {\n     CTransaction tx;\n     NodeId fromPeer;\n@@ -106,6 +98,12 @@ namespace {\n     // The set of all CBlockIndex entries with BLOCK_VALID_TRANSACTIONS or better that are at least\n     // as good as our current tip. Entries may be failed, though.\n     set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexValid;\n+    // Best header we've seen so far (used for getheaders queries' starting points).\n+    CBlockIndex *pindexBestHeader = NULL;\n+    // Number of nodes with fSyncStarted.\n+    int nSyncStarted = 0;\n+    // All pairs A->B, where A (or one if its ancestors) misses transactions, but B has transactions.\n+    multimap<CBlockIndex*, CBlockIndex*> mapBlocksUnlinked;\n \n     CCriticalSection cs_LastBlockFile;\n     CBlockFileInfo infoLastBlockFile;\n@@ -125,11 +123,10 @@ namespace {\n     // Protected by cs_main.\n     struct QueuedBlock {\n         uint256 hash;\n+        CBlockIndex *pindex;  // Optional.\n         int64_t nTime;  // Time of \"getdata\" request in microseconds.\n-        int nQueuedBefore;  // Number of blocks in flight at the time of request.\n     };\n     map<uint256, pair<NodeId, list<QueuedBlock>::iterator> > mapBlocksInFlight;\n-    map<uint256, pair<NodeId, list<uint256>::iterator> > mapBlocksToDownload;\n \n } // anon namespace\n \n@@ -220,22 +217,24 @@ struct CNodeState {\n     CBlockIndex *pindexBestKnownBlock;\n     // The hash of the last unknown block this peer has announced.\n     uint256 hashLastUnknownBlock;\n+    // The last full block we both have.\n+    CBlockIndex *pindexLastCommonBlock;\n+    // Whether we've started headers synchronization with this peer.\n+    bool fSyncStarted;\n+    // Since when we're stalling block download progress (in microseconds), or 0.\n+    int64_t nStallingSince;\n     list<QueuedBlock> vBlocksInFlight;\n     int nBlocksInFlight;\n-    list<uint256> vBlocksToDownload;\n-    int nBlocksToDownload;\n-    int64_t nLastBlockReceive;\n-    int64_t nLastBlockProcess;\n \n     CNodeState() {\n         nMisbehavior = 0;\n         fShouldBan = false;\n         pindexBestKnownBlock = NULL;\n         hashLastUnknownBlock = uint256(0);\n-        nBlocksToDownload = 0;\n+        pindexLastCommonBlock = NULL;\n+        fSyncStarted = false;\n+        nStallingSince = 0;\n         nBlocksInFlight = 0;\n-        nLastBlockReceive = 0;\n-        nLastBlockProcess = 0;\n     }\n };\n \n@@ -266,64 +265,37 @@ void FinalizeNode(NodeId nodeid) {\n     LOCK(cs_main);\n     CNodeState *state = State(nodeid);\n \n+    if (state->fSyncStarted)\n+        nSyncStarted--;\n+\n     BOOST_FOREACH(const QueuedBlock& entry, state->vBlocksInFlight)\n         mapBlocksInFlight.erase(entry.hash);\n-    BOOST_FOREACH(const uint256& hash, state->vBlocksToDownload)\n-        mapBlocksToDownload.erase(hash);\n     EraseOrphansFor(nodeid);\n \n     mapNodeState.erase(nodeid);\n }\n \n // Requires cs_main.\n-void MarkBlockAsReceived(const uint256 &hash, NodeId nodeFrom = -1) {\n-    map<uint256, pair<NodeId, list<uint256>::iterator> >::iterator itToDownload = mapBlocksToDownload.find(hash);\n-    if (itToDownload != mapBlocksToDownload.end()) {\n-        CNodeState *state = State(itToDownload->second.first);\n-        state->vBlocksToDownload.erase(itToDownload->second.second);\n-        state->nBlocksToDownload--;\n-        mapBlocksToDownload.erase(itToDownload);\n-    }\n-\n+void MarkBlockAsReceived(const uint256& hash) {\n     map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end()) {\n         CNodeState *state = State(itInFlight->second.first);\n         state->vBlocksInFlight.erase(itInFlight->second.second);\n         state->nBlocksInFlight--;\n-        if (itInFlight->second.first == nodeFrom)\n-            state->nLastBlockReceive = GetTimeMicros();\n+        state->nStallingSince = 0;\n         mapBlocksInFlight.erase(itInFlight);\n     }\n }\n \n // Requires cs_main.\n-bool AddBlockToQueue(NodeId nodeid, const uint256 &hash) {\n-    if (mapBlocksToDownload.count(hash) || mapBlocksInFlight.count(hash))\n-        return false;\n-\n-    CNodeState *state = State(nodeid);\n-    if (state == NULL)\n-        return false;\n-\n-    list<uint256>::iterator it = state->vBlocksToDownload.insert(state->vBlocksToDownload.end(), hash);\n-    state->nBlocksToDownload++;\n-    if (state->nBlocksToDownload > 5000)\n-        Misbehaving(nodeid, 10);\n-    mapBlocksToDownload[hash] = std::make_pair(nodeid, it);\n-    return true;\n-}\n-\n-// Requires cs_main.\n-void MarkBlockAsInFlight(NodeId nodeid, const uint256 &hash) {\n+void MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, CBlockIndex *pindex = NULL) {\n     CNodeState *state = State(nodeid);\n     assert(state != NULL);\n \n     // Make sure it's not listed somewhere already.\n     MarkBlockAsReceived(hash);\n \n-    QueuedBlock newentry = {hash, GetTimeMicros(), state->nBlocksInFlight};\n-    if (state->nBlocksInFlight == 0)\n-        state->nLastBlockReceive = newentry.nTime; // Reset when a first request is sent.\n+    QueuedBlock newentry = {hash, pindex, GetTimeMicros()};\n     list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(), newentry);\n     state->nBlocksInFlight++;\n     mapBlocksInFlight[hash] = std::make_pair(nodeid, it);\n@@ -362,6 +334,103 @@ void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n     }\n }\n \n+/** Find the last common ancestor two blocks have.\n+ *  Both pa and pb must be non-NULL. */\n+CBlockIndex* LastCommonAncestor(CBlockIndex* pa, CBlockIndex* pb) {\n+    if (pa->nHeight > pb->nHeight) {\n+        pa = pa->GetAncestor(pb->nHeight);\n+    } else if (pb->nHeight > pa->nHeight) {\n+        pb = pb->GetAncestor(pa->nHeight);\n+    }\n+\n+    while (pa != pb && pa && pb) {\n+        pa = pa->pprev;\n+        pb = pb->pprev;\n+    }\n+\n+    // Eventually all chain branches meet at the genesis block.\n+    assert(pa == pb);\n+    return pa;\n+}\n+\n+/** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has\n+ *  at most count entries. */\n+void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<CBlockIndex*>& vBlocks, NodeId& nodeStaller) {\n+    if (count == 0)\n+        return;\n+\n+    vBlocks.reserve(vBlocks.size() + count);\n+    CNodeState *state = State(nodeid);\n+    assert(state != NULL);\n+\n+    // Make sure pindexBestKnownBlock is up to date, we'll need it.\n+    ProcessBlockAvailability(nodeid);\n+\n+    if (state->pindexBestKnownBlock == NULL || state->pindexBestKnownBlock->nChainWork < chainActive.Tip()->nChainWork) {\n+        // This peer has nothing interesting.\n+        return;\n+    }\n+\n+    if (state->pindexLastCommonBlock == NULL) {\n+        // Bootstrap quickly by guessing a parent of our best tip is the forking point.\n+        // Guessing wrong in either direction is not a problem.\n+        state->pindexLastCommonBlock = chainActive[std::min(state->pindexBestKnownBlock->nHeight, chainActive.Height())];\n+    }\n+\n+    // If the peer reorganized, our previous pindexLastCommonBlock may not be an ancestor\n+    // of their current tip anymore. Go back enough to fix that.\n+    state->pindexLastCommonBlock = LastCommonAncestor(state->pindexLastCommonBlock, state->pindexBestKnownBlock);\n+    if (state->pindexLastCommonBlock == state->pindexBestKnownBlock)\n+        return;\n+\n+    std::vector<CBlockIndex*> vToFetch;\n+    CBlockIndex *pindexWalk = state->pindexLastCommonBlock;\n+    // Never fetch further than the best block we know the peer has, or more than BLOCK_DOWNLOAD_WINDOW + 1 beyond our\n+    // current tip. The +1 is so we can detect stalling, namely if we would be able to download that next block if the\n+    // window were 1 larger.\n+    int nMaxHeight = std::min<int>(state->pindexBestKnownBlock->nHeight, chainActive.Height() + BLOCK_DOWNLOAD_WINDOW + 1);\n+    NodeId waitingfor = -1;\n+    while (pindexWalk->nHeight < nMaxHeight) {\n+        // Read up to 128 (or more, if more blocks than that are needed) successors of pindexWalk (towards\n+        // pindexBestKnownBlock) into vToFetch. We fetch 128, because CBlockIndex::GetAncestor may be as expensive\n+        // as iterating over ~100 CBlockIndex* entries anyway.\n+        int nToFetch = std::min(nMaxHeight - pindexWalk->nHeight, std::max<int>(count - vBlocks.size(), 128));\n+        vToFetch.resize(nToFetch);\n+        pindexWalk = state->pindexBestKnownBlock->GetAncestor(pindexWalk->nHeight + nToFetch);\n+        vToFetch[nToFetch - 1] = pindexWalk;\n+        for (unsigned int i = nToFetch - 1; i > 0; i--) {\n+            vToFetch[i - 1] = vToFetch[i]->pprev;\n+        }\n+\n+        // Iterate over those blocks in vToFetch (in forward direction), adding the ones that\n+        // are not yet downloaded and not in flight to vBlocks. In the mean time, update\n+        // pindexLastCommonBlock as long as all ancestors are already downloaded.\n+        BOOST_FOREACH(CBlockIndex* pindex, vToFetch) {\n+            if (pindex->nStatus & BLOCK_HAVE_DATA) {\n+                if (pindex->nChainTx)\n+                    state->pindexLastCommonBlock = pindex;\n+            } else if (mapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n+                // The block is not already downloaded, and not yet in flight.\n+                if (pindex->nHeight > chainActive.Height() + (int)BLOCK_DOWNLOAD_WINDOW) {\n+                    // We reached the end of the window.\n+                    if (vBlocks.size() == 0 && waitingfor != nodeid) {\n+                        // We aren't able to fetch anything, but we would be if the download window was one larger.\n+                        nodeStaller = waitingfor;\n+                    }\n+                    return;\n+                }\n+                vBlocks.push_back(pindex);\n+                if (vBlocks.size() == count) {\n+                    return;\n+                }\n+            } else if (waitingfor == -1) {\n+                // This is the first already-in-flight block.\n+                waitingfor = mapBlocksInFlight[pindex->GetBlockHash()].first;\n+            }\n+        }\n+    }\n+}\n+\n } // anon namespace\n \n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n@@ -1086,46 +1155,6 @@ bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex)\n     return true;\n }\n \n-uint256 static GetOrphanRoot(const uint256& hash)\n-{\n-    map<uint256, COrphanBlock*>::iterator it = mapOrphanBlocks.find(hash);\n-    if (it == mapOrphanBlocks.end())\n-        return hash;\n-\n-    // Work back to the first block in the orphan chain\n-    do {\n-        map<uint256, COrphanBlock*>::iterator it2 = mapOrphanBlocks.find(it->second->hashPrev);\n-        if (it2 == mapOrphanBlocks.end())\n-            return it->first;\n-        it = it2;\n-    } while(true);\n-}\n-\n-// Remove a random orphan block (which does not have any dependent orphans).\n-void static PruneOrphanBlocks()\n-{\n-    if (mapOrphanBlocksByPrev.size() <= (size_t)std::max((int64_t)0, GetArg(\"-maxorphanblocks\", DEFAULT_MAX_ORPHAN_BLOCKS)))\n-        return;\n-\n-    // Pick a random orphan block.\n-    int pos = insecure_rand() % mapOrphanBlocksByPrev.size();\n-    std::multimap<uint256, COrphanBlock*>::iterator it = mapOrphanBlocksByPrev.begin();\n-    while (pos--) it++;\n-\n-    // As long as this block has other orphans depending on it, move to one of those successors.\n-    do {\n-        std::multimap<uint256, COrphanBlock*>::iterator it2 = mapOrphanBlocksByPrev.find(it->second->hashBlock);\n-        if (it2 == mapOrphanBlocksByPrev.end())\n-            break;\n-        it = it2;\n-    } while(1);\n-\n-    uint256 hash = it->second->hashBlock;\n-    delete it->second;\n-    mapOrphanBlocksByPrev.erase(it);\n-    mapOrphanBlocks.erase(hash);\n-}\n-\n CAmount GetBlockValue(int nHeight, const CAmount& nFees)\n {\n     int64_t nSubsidy = 50 * COIN;\n@@ -1674,11 +1703,6 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n     if (fJustCheck)\n         return true;\n \n-    // Correct transaction counts.\n-    pindex->nTx = block.vtx.size();\n-    if (pindex->pprev)\n-        pindex->nChainTx = pindex->pprev->nChainTx + block.vtx.size();\n-\n     // Write undo information to disk\n     if (pindex->GetUndoPos().IsNull() || !pindex->IsValid(BLOCK_VALID_SCRIPTS))\n     {\n@@ -1907,6 +1931,8 @@ static CBlockIndex* FindMostWorkChain() {\n         CBlockIndex *pindexTest = pindexNew;\n         bool fInvalidAncestor = false;\n         while (pindexTest && !chainActive.Contains(pindexTest)) {\n+            assert(pindexTest->nStatus & BLOCK_HAVE_DATA);\n+            assert(pindexTest->nChainTx || pindexTest->nHeight == 0);\n             if (pindexTest->nStatus & BLOCK_FAILED_MASK) {\n                 // Candidate has an invalid ancestor, remove entire chain from the set.\n                 if (pindexBestInvalid == NULL || pindexNew->nChainWork > pindexBestInvalid->nChainWork)\n@@ -2039,7 +2065,7 @@ bool ActivateBestChain(CValidationState &state, CBlock *pblock) {\n     return true;\n }\n \n-CBlockIndex* AddToBlockIndex(CBlockHeader& block)\n+CBlockIndex* AddToBlockIndex(const CBlockHeader& block)\n {\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n@@ -2050,10 +2076,10 @@ CBlockIndex* AddToBlockIndex(CBlockHeader& block)\n     // Construct new block index object\n     CBlockIndex* pindexNew = new CBlockIndex(block);\n     assert(pindexNew);\n-    {\n-         LOCK(cs_nBlockSequenceId);\n-         pindexNew->nSequenceId = nBlockSequenceId++;\n-    }\n+    // We assign the sequence id to blocks only when the full data is available,\n+    // to avoid miners withholding blocks but broadcasting headers, to get a\n+    // competitive advantage.\n+    pindexNew->nSequenceId = 0;\n     BlockMap::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n     pindexNew->phashBlock = &((*mi).first);\n     BlockMap::iterator miPrev = mapBlockIndex.find(block.hashPrevBlock);\n@@ -2065,6 +2091,11 @@ CBlockIndex* AddToBlockIndex(CBlockHeader& block)\n     }\n     pindexNew->nChainWork = (pindexNew->pprev ? pindexNew->pprev->nChainWork : 0) + pindexNew->GetBlockWork();\n     pindexNew->RaiseValidity(BLOCK_VALID_TREE);\n+    if (pindexBestHeader == NULL || pindexBestHeader->nChainWork < pindexNew->nChainWork)\n+        pindexBestHeader = pindexNew;\n+\n+    // Ok if it fails, we'll download the header again next time.\n+    pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexNew));\n \n     return pindexNew;\n }\n@@ -2073,30 +2104,45 @@ CBlockIndex* AddToBlockIndex(CBlockHeader& block)\n bool ReceivedBlockTransactions(const CBlock &block, CValidationState& state, CBlockIndex *pindexNew, const CDiskBlockPos& pos)\n {\n     pindexNew->nTx = block.vtx.size();\n-    if (pindexNew->pprev) {\n-        // Not the genesis block.\n-        if (pindexNew->pprev->nChainTx) {\n-            // This parent's block's total number transactions is known, so compute outs.\n-            pindexNew->nChainTx = pindexNew->pprev->nChainTx + pindexNew->nTx;\n-        } else {\n-            // The total number of transactions isn't known yet.\n-            // We will compute it when the block is connected.\n-            pindexNew->nChainTx = 0;\n-        }\n-    } else {\n-        // Genesis block.\n-        pindexNew->nChainTx = pindexNew->nTx;\n-    }\n+    pindexNew->nChainTx = 0;\n     pindexNew->nFile = pos.nFile;\n     pindexNew->nDataPos = pos.nPos;\n     pindexNew->nUndoPos = 0;\n     pindexNew->nStatus |= BLOCK_HAVE_DATA;\n+    pindexNew->RaiseValidity(BLOCK_VALID_TRANSACTIONS);\n+    {\n+         LOCK(cs_nBlockSequenceId);\n+         pindexNew->nSequenceId = nBlockSequenceId++;\n+    }\n \n-    if (pindexNew->RaiseValidity(BLOCK_VALID_TRANSACTIONS))\n-        setBlockIndexValid.insert(pindexNew);\n+    if (pindexNew->pprev == NULL || pindexNew->pprev->nChainTx) {\n+        // If pindexNew is the genesis block or all parents are BLOCK_VALID_TRANSACTIONS.\n+        deque<CBlockIndex*> queue;\n+        queue.push_back(pindexNew);\n \n-    if (!pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexNew)))\n-        return state.Abort(\"Failed to write block index\");\n+        // Recursively process any descendant blocks that now may be eligible to be connected.\n+        while (!queue.empty()) {\n+            CBlockIndex *pindex = queue.front();\n+            queue.pop_front();\n+            pindex->nChainTx = (pindex->pprev ? pindex->pprev->nChainTx : 0) + pindex->nTx;\n+            setBlockIndexValid.insert(pindex);\n+            std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = mapBlocksUnlinked.equal_range(pindex);\n+            while (range.first != range.second) {\n+                std::multimap<CBlockIndex*, CBlockIndex*>::iterator it = range.first;\n+                queue.push_back(it->second);\n+                range.first++;\n+                mapBlocksUnlinked.erase(it);\n+            }\n+            if (!pblocktree->WriteBlockIndex(CDiskBlockIndex(pindex)))\n+                return state.Abort(\"Failed to write block index\");\n+        }\n+    } else {\n+        if (pindexNew->pprev && pindexNew->pprev->IsValid(BLOCK_VALID_TREE)) {\n+            mapBlocksUnlinked.insert(std::make_pair(pindexNew->pprev, pindexNew));\n+        }\n+        if (!pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexNew)))\n+            return state.Abort(\"Failed to write block index\");\n+    }\n \n     return true;\n }\n@@ -2212,12 +2258,31 @@ bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, bool f\n \n bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bool fCheckMerkleRoot)\n {\n-    // These are checks that are independent of context\n-    // that can be verified before saving an orphan block.\n+    // These are checks that are independent of context.\n \n     if (!CheckBlockHeader(block, state, fCheckPOW))\n         return false;\n \n+    // Check the merkle root.\n+    if (fCheckMerkleRoot) {\n+        bool mutated;\n+        uint256 hashMerkleRoot2 = block.BuildMerkleTree(&mutated);\n+        if (block.hashMerkleRoot != hashMerkleRoot2)\n+            return state.DoS(100, error(\"CheckBlock() : hashMerkleRoot mismatch\"),\n+                             REJECT_INVALID, \"bad-txnmrklroot\", true);\n+\n+        // Check for merkle tree malleability (CVE-2012-2459): repeating sequences\n+        // of transactions in a block without affecting the merkle root of a block,\n+        // while still invalidating it.\n+        if (mutated)\n+            return state.DoS(100, error(\"CheckBlock() : duplicate transaction\"),\n+                             REJECT_INVALID, \"bad-txns-duplicate\", true);\n+    }\n+\n+    // All potential-corruption validation must be done before we do any\n+    // transaction validation, as otherwise we may mark the header as invalid\n+    // because we receive the wrong transactions for it.\n+\n     // Size limits\n     if (block.vtx.empty() || block.vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n         return state.DoS(100, error(\"CheckBlock() : size limits failed\"),\n@@ -2237,15 +2302,6 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n         if (!CheckTransaction(tx, state))\n             return error(\"CheckBlock() : CheckTransaction failed\");\n \n-    // Check for merkle tree malleability (CVE-2012-2459): repeating sequences\n-    // of transactions in a block without affecting the merkle root of a block,\n-    // while still invalidating it.\n-    bool mutated;\n-    uint256 hashMerkleRoot2 = block.BuildMerkleTree(&mutated);\n-    if (mutated)\n-        return state.DoS(100, error(\"CheckBlock() : duplicate transaction\"),\n-                         REJECT_INVALID, \"bad-txns-duplicate\", true);\n-\n     unsigned int nSigOps = 0;\n     BOOST_FOREACH(const CTransaction& tx, block.vtx)\n     {\n@@ -2255,25 +2311,24 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n         return state.DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"),\n                          REJECT_INVALID, \"bad-blk-sigops\", true);\n \n-    // Check merkle root\n-    if (fCheckMerkleRoot && block.hashMerkleRoot != hashMerkleRoot2)\n-        return state.DoS(100, error(\"CheckBlock() : hashMerkleRoot mismatch\"),\n-                         REJECT_INVALID, \"bad-txnmrklroot\", true);\n-\n     return true;\n }\n \n-bool AcceptBlockHeader(CBlockHeader& block, CValidationState& state, CBlockIndex** ppindex)\n+bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, CBlockIndex** ppindex)\n {\n     AssertLockHeld(cs_main);\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n     BlockMap::iterator miSelf = mapBlockIndex.find(hash);\n     CBlockIndex *pindex = NULL;\n     if (miSelf != mapBlockIndex.end()) {\n+        // Block header is already known.\n         pindex = miSelf->second;\n+        if (ppindex)\n+            *ppindex = pindex;\n         if (pindex->nStatus & BLOCK_FAILED_MASK)\n             return state.Invalid(error(\"%s : block is marked invalid\", __func__), 0, \"duplicate\");\n+        return true;\n     }\n \n     CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint();\n@@ -2351,6 +2406,12 @@ bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex** ppindex,\n     if (!AcceptBlockHeader(block, state, &pindex))\n         return false;\n \n+    if (pindex->nStatus & BLOCK_HAVE_DATA) {\n+        // TODO: deal better with duplicate blocks.\n+        // return state.DoS(20, error(\"AcceptBlock() : already have block %d %s\", pindex->nHeight, pindex->GetBlockHash().ToString()), REJECT_DUPLICATE, \"duplicate\");\n+        return true;\n+    }\n+\n     if (!CheckBlock(block, state)) {\n         if (state.IsInvalid() && !state.CorruptionPossible()) {\n             pindex->nStatus |= BLOCK_FAILED_VALID;\n@@ -2463,93 +2524,26 @@ void CBlockIndex::BuildSkip()\n         pskip = pprev->GetAncestor(GetSkipHeight(nHeight));\n }\n \n-void PushGetBlocks(CNode* pnode, CBlockIndex* pindexBegin, uint256 hashEnd)\n-{\n-    AssertLockHeld(cs_main);\n-    // Filter out duplicate requests\n-    if (pindexBegin == pnode->pindexLastGetBlocksBegin && hashEnd == pnode->hashLastGetBlocksEnd)\n-        return;\n-    pnode->pindexLastGetBlocksBegin = pindexBegin;\n-    pnode->hashLastGetBlocksEnd = hashEnd;\n-\n-    pnode->PushMessage(\"getblocks\", chainActive.GetLocator(pindexBegin), hashEnd);\n-}\n-\n bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBlockPos *dbp)\n {\n-    // Check for duplicate\n-    uint256 hash = pblock->GetHash();\n-\n-    {\n-    LOCK(cs_main);\n-    if (mapBlockIndex.count(hash))\n-        return state.Invalid(error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString()), 0, \"duplicate\");\n-    if (mapOrphanBlocks.count(hash))\n-        return state.Invalid(error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString()), 0, \"duplicate\");\n-\n     // Preliminary checks\n-    if (!CheckBlock(*pblock, state))\n-        return error(\"ProcessBlock() : CheckBlock FAILED\");\n+    bool checked = CheckBlock(*pblock, state);\n \n-    // If we don't already have its previous block (with full data), shunt it off to holding area until we get it\n-    BlockMap::iterator it = mapBlockIndex.find(pblock->hashPrevBlock);\n-    if (pblock->hashPrevBlock != 0 && (it == mapBlockIndex.end() || !(it->second->nStatus & BLOCK_HAVE_DATA)))\n     {\n-        LogPrintf(\"ProcessBlock: ORPHAN BLOCK %lu, prev=%s\\n\", (unsigned long)mapOrphanBlocks.size(), pblock->hashPrevBlock.ToString());\n-\n-        // Accept orphans as long as there is a node to request its parents from\n-        if (pfrom) {\n-            PruneOrphanBlocks();\n-            COrphanBlock* pblock2 = new COrphanBlock();\n-            {\n-                CDataStream ss(SER_DISK, CLIENT_VERSION);\n-                ss << *pblock;\n-                pblock2->vchBlock = std::vector<unsigned char>(ss.begin(), ss.end());\n-            }\n-            pblock2->hashBlock = hash;\n-            pblock2->hashPrev = pblock->hashPrevBlock;\n-            mapOrphanBlocks.insert(make_pair(hash, pblock2));\n-            mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrev, pblock2));\n-\n-            // Ask this guy to fill in what we're missing\n-            PushGetBlocks(pfrom, chainActive.Tip(), GetOrphanRoot(hash));\n+        LOCK(cs_main);\n+        MarkBlockAsReceived(pblock->GetHash());\n+        if (!checked) {\n+            return error(\"ProcessBlock() : CheckBlock FAILED\");\n         }\n-        return true;\n-    }\n \n-    // Store to disk\n-    CBlockIndex *pindex = NULL;\n-    bool ret = AcceptBlock(*pblock, state, &pindex, dbp);\n-    if (!ret)\n-        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n-\n-    // Recursively process any orphan blocks that depended on this one\n-    vector<uint256> vWorkQueue;\n-    vWorkQueue.push_back(hash);\n-    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n-    {\n-        uint256 hashPrev = vWorkQueue[i];\n-        for (multimap<uint256, COrphanBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n-             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n-             ++mi)\n-        {\n-            CBlock block;\n-            {\n-                CDataStream ss(mi->second->vchBlock, SER_DISK, CLIENT_VERSION);\n-                ss >> block;\n-            }\n-            block.BuildMerkleTree();\n-            // Use a dummy CValidationState so someone can't setup nodes to counter-DoS based on orphan resolution (that is, feeding people an invalid block based on LegitBlockX in order to get anyone relaying LegitBlockX banned)\n-            CValidationState stateDummy;\n-            CBlockIndex *pindexChild = NULL;\n-            if (AcceptBlock(block, stateDummy, &pindexChild))\n-                vWorkQueue.push_back(mi->second->hashBlock);\n-            mapOrphanBlocks.erase(mi->second->hashBlock);\n-            delete mi->second;\n+        // Store to disk\n+        CBlockIndex *pindex = NULL;\n+        bool ret = AcceptBlock(*pblock, state, &pindex, dbp);\n+        if (pindex && pfrom) {\n+            mapBlockSource[pindex->GetBlockHash()] = pfrom->GetId();\n         }\n-        mapOrphanBlocksByPrev.erase(hashPrev);\n-    }\n-\n+        if (!ret)\n+            return error(\"ProcessBlock() : AcceptBlock FAILED\");\n     }\n \n     if (!ActivateBestChain(state, pblock))\n@@ -2815,13 +2809,26 @@ bool static LoadBlockIndexDB()\n     {\n         CBlockIndex* pindex = item.second;\n         pindex->nChainWork = (pindex->pprev ? pindex->pprev->nChainWork : 0) + pindex->GetBlockWork();\n-        pindex->nChainTx = (pindex->pprev ? pindex->pprev->nChainTx : 0) + pindex->nTx;\n-        if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS))\n+        if (pindex->nStatus & BLOCK_HAVE_DATA) {\n+            if (pindex->pprev) {\n+                if (pindex->pprev->nChainTx) {\n+                    pindex->nChainTx = pindex->pprev->nChainTx + pindex->nTx;\n+                } else {\n+                    pindex->nChainTx = 0;\n+                    mapBlocksUnlinked.insert(std::make_pair(pindex->pprev, pindex));\n+                }\n+            } else {\n+                pindex->nChainTx = pindex->nTx;\n+            }\n+        }\n+        if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && (pindex->nChainTx || pindex->pprev == NULL))\n             setBlockIndexValid.insert(pindex);\n         if (pindex->nStatus & BLOCK_FAILED_MASK && (!pindexBestInvalid || pindex->nChainWork > pindexBestInvalid->nChainWork))\n             pindexBestInvalid = pindex;\n         if (pindex->pprev)\n             pindex->BuildSkip();\n+        if (pindex->IsValid(BLOCK_VALID_TREE) && (pindexBestHeader == NULL || CBlockIndexWorkComparator()(pindexBestHeader, pindex)))\n+            pindexBestHeader = pindex;\n     }\n \n     // Load block file info\n@@ -3233,8 +3240,7 @@ bool static AlreadyHave(const CInv& inv)\n                 pcoinsTip->HaveCoins(inv.hash);\n         }\n     case MSG_BLOCK:\n-        return mapBlockIndex.count(inv.hash) ||\n-               mapOrphanBlocks.count(inv.hash);\n+        return mapBlockIndex.count(inv.hash);\n     }\n     // Don't know what it is, just say we already got one\n     return true;\n@@ -3382,10 +3388,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         return true;\n     }\n \n-    {\n-        LOCK(cs_main);\n-        State(pfrom->GetId())->nLastBlockProcess = GetTimeMicros();\n-    }\n \n \n \n@@ -3594,6 +3596,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         LOCK(cs_main);\n \n+        std::vector<CInv> vToFetch;\n+\n         for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n         {\n             const CInv &inv = vInv[nInv];\n@@ -3604,19 +3608,29 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             bool fAlreadyHave = AlreadyHave(inv);\n             LogPrint(\"net\", \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom->id);\n \n-            if (!fAlreadyHave) {\n-                if (!fImporting && !fReindex) {\n-                    if (inv.type == MSG_BLOCK)\n-                        AddBlockToQueue(pfrom->GetId(), inv.hash);\n-                    else\n-                        pfrom->AskFor(inv);\n-                }\n-            } else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n-                PushGetBlocks(pfrom, chainActive.Tip(), GetOrphanRoot(inv.hash));\n-            }\n+            if (!fAlreadyHave && !fImporting && !fReindex && inv.type != MSG_BLOCK)\n+                pfrom->AskFor(inv);\n \n-            if (inv.type == MSG_BLOCK)\n+            if (inv.type == MSG_BLOCK) {\n                 UpdateBlockAvailability(pfrom->GetId(), inv.hash);\n+                if (!fAlreadyHave && !fImporting && !fReindex && !mapBlocksInFlight.count(inv.hash)) {\n+                    // First request the headers preceeding the announced block. In the normal fully-synced\n+                    // case where a new block is announced that succeeds the current tip (no reorganization),\n+                    // there are no such headers.\n+                    // Secondly, and only when we are close to being synced, we request the announced block directly,\n+                    // to avoid an extra round-trip. Note that we must *first* ask for the headers, so by the\n+                    // time the block arrives, the header chain leading up to it is already validated. Not\n+                    // doing this will result in the received block being rejected as an orphan in case it is\n+                    // not a direct successor.\n+                    pfrom->PushMessage(\"getheaders\", chainActive.GetLocator(pindexBestHeader), inv.hash);\n+                    if (chainActive.Tip()->GetBlockTime() > GetAdjustedTime() - Params().TargetSpacing() * 20) {\n+                        vToFetch.push_back(inv);\n+                        // Mark block as in flight already, even though the actual \"getdata\" message only goes out\n+                        // later (within the same cs_main lock, though).\n+                        MarkBlockAsInFlight(pfrom->GetId(), inv.hash);\n+                    }\n+                }\n+            }\n \n             // Track requests for our stuff\n             g_signals.Inventory(inv.hash);\n@@ -3626,6 +3640,9 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 return error(\"send buffer size() = %u\", pfrom->nSendSize);\n             }\n         }\n+\n+        if (!vToFetch.empty())\n+            pfrom->PushMessage(\"getdata\", vToFetch);\n     }\n \n \n@@ -3713,7 +3730,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         // we must use CBlocks, as CBlockHeaders won't include the 0x00 nTx count at the end\n         vector<CBlock> vHeaders;\n-        int nLimit = 2000;\n+        int nLimit = MAX_HEADERS_RESULTS;\n         LogPrint(\"net\", \"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString());\n         for (; pindex; pindex = chainActive.Next(pindex))\n         {\n@@ -3833,22 +3850,66 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == \"headers\" && !fImporting && !fReindex) // Ignore headers received while importing\n+    {\n+        std::vector<CBlockHeader> headers;\n+\n+        // Bypass the normal CBlock deserialization, as we don't want to risk deserializing 2000 full blocks.\n+        unsigned int nCount = ReadCompactSize(vRecv);\n+        if (nCount > MAX_HEADERS_RESULTS) {\n+            Misbehaving(pfrom->GetId(), 20);\n+            return error(\"headers message size = %u\", nCount);\n+        }\n+        headers.resize(nCount);\n+        for (unsigned int n = 0; n < nCount; n++) {\n+            vRecv >> headers[n];\n+            ReadCompactSize(vRecv); // ignore tx count; assume it is 0.\n+        }\n+\n+        LOCK(cs_main);\n+\n+        if (nCount == 0) {\n+            // Nothing interesting. Stop asking this peers for more headers.\n+            return true;\n+        }\n+\n+        CBlockIndex *pindexLast = NULL;\n+        BOOST_FOREACH(const CBlockHeader& header, headers) {\n+            CValidationState state;\n+            if (pindexLast != NULL && header.hashPrevBlock != pindexLast->GetBlockHash()) {\n+                Misbehaving(pfrom->GetId(), 20);\n+                return error(\"non-continuous headers sequence\");\n+            }\n+            if (!AcceptBlockHeader(header, state, &pindexLast)) {\n+                int nDoS;\n+                if (state.IsInvalid(nDoS)) {\n+                    if (nDoS > 0)\n+                        Misbehaving(pfrom->GetId(), nDoS);\n+                    return error(\"invalid header received\");\n+                }\n+            }\n+        }\n+\n+        if (pindexLast)\n+            UpdateBlockAvailability(pfrom->GetId(), pindexLast->GetBlockHash());\n+\n+        if (nCount == MAX_HEADERS_RESULTS && pindexLast) {\n+            // Headers message had its maximum size; the peer may have more headers.\n+            // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n+            // from there instead.\n+            pfrom->PushMessage(\"getheaders\", chainActive.GetLocator(pindexLast), uint256(0));\n+        }\n+    }\n+\n     else if (strCommand == \"block\" && !fImporting && !fReindex) // Ignore blocks received while importing\n     {\n         CBlock block;\n         vRecv >> block;\n \n-        LogPrint(\"net\", \"received block %s peer=%d\\n\", block.GetHash().ToString(), pfrom->id);\n-\n         CInv inv(MSG_BLOCK, block.GetHash());\n-        pfrom->AddInventoryKnown(inv);\n+        LogPrint(\"net\", \"received block %s peer=%d\\n\", inv.hash.ToString(), pfrom->id);\n \n-        {\n-            LOCK(cs_main);\n-            // Remember who we got this block from.\n-            mapBlockSource[inv.hash] = pfrom->GetId();\n-            MarkBlockAsReceived(inv.hash, pfrom->GetId());\n-        }\n+        pfrom->AddInventoryKnown(inv);\n \n         CValidationState state;\n         ProcessBlock(state, pfrom, &block);\n@@ -4330,9 +4391,17 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         state.rejects.clear();\n \n         // Start block sync\n-        if (pto->fStartSync && !fImporting && !fReindex) {\n-            pto->fStartSync = false;\n-            PushGetBlocks(pto, chainActive.Tip(), uint256(0));\n+        if (pindexBestHeader == NULL)\n+            pindexBestHeader = chainActive.Tip();\n+        bool fFetch = !pto->fInbound || (pindexBestHeader && (state.pindexLastCommonBlock ? state.pindexLastCommonBlock->nHeight : 0) + 144 > pindexBestHeader->nHeight);\n+        if (!state.fSyncStarted && !pto->fClient && fFetch && !fImporting && !fReindex) {\n+            // Only actively request headers from a single peer, unless we're close to today.\n+            if (nSyncStarted == 0 || pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {\n+                state.fSyncStarted = true;\n+                nSyncStarted++;\n+                CBlockIndex *pindexStart = pindexBestHeader->pprev ? pindexBestHeader->pprev : pindexBestHeader;\n+                pto->PushMessage(\"getheaders\", chainActive.GetLocator(pindexStart), uint256(0));\n+            }\n         }\n \n         // Resend wallet transactions that haven't gotten in a block yet\n@@ -4391,35 +4460,32 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         if (!vInv.empty())\n             pto->PushMessage(\"inv\", vInv);\n \n-\n-        // Detect stalled peers. Require that blocks are in flight, we haven't\n-        // received a (requested) block in one minute, and that all blocks are\n-        // in flight for over two minutes, since we first had a chance to\n-        // process an incoming block.\n+        // Detect whether we're stalling\n         int64_t nNow = GetTimeMicros();\n-        if (!pto->fDisconnect && state.nBlocksInFlight &&\n-            state.nLastBlockReceive < state.nLastBlockProcess - BLOCK_DOWNLOAD_TIMEOUT*1000000 &&\n-            state.vBlocksInFlight.front().nTime < state.nLastBlockProcess - 2*BLOCK_DOWNLOAD_TIMEOUT*1000000) {\n-            LogPrintf(\"Peer %s is stalling block download, disconnecting\\n\", state.name);\n+        if (!pto->fDisconnect && state.nStallingSince && state.nStallingSince < nNow - 1000000 * BLOCK_STALLING_TIMEOUT) {\n+            // Stalling only triggers when the block download window cannot move. During normal steady state,\n+            // the download window should be much larger than the to-be-downloaded set of blocks, so disconnection\n+            // should only happen during initial block download.\n+            LogPrintf(\"Peer=%d is stalling block download, disconnecting\\n\", pto->id);\n             pto->fDisconnect = true;\n         }\n \n-        // Update knowledge of peer's block availability.\n-        ProcessBlockAvailability(pto->GetId());\n-\n         //\n         // Message: getdata (blocks)\n         //\n         vector<CInv> vGetData;\n-        while (!pto->fDisconnect && state.nBlocksToDownload && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n-            uint256 hash = state.vBlocksToDownload.front();\n-            vGetData.push_back(CInv(MSG_BLOCK, hash));\n-            MarkBlockAsInFlight(pto->GetId(), hash);\n-            LogPrint(\"net\", \"Requesting block %s peer=%d\\n\", hash.ToString(), pto->id);\n-            if (vGetData.size() >= 1000)\n-            {\n-                pto->PushMessage(\"getdata\", vGetData);\n-                vGetData.clear();\n+        if (!pto->fDisconnect && !pto->fClient && fFetch && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+            vector<CBlockIndex*> vToDownload;\n+            NodeId staller = -1;\n+            FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller);\n+            BOOST_FOREACH(CBlockIndex *pindex, vToDownload) {\n+                vGetData.push_back(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n+                MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);\n+                LogPrint(\"net\", \"Requesting block %s peer=%d\\n\", pindex->GetBlockHash().ToString(), pto->id);\n+            }\n+            if (state.nBlocksInFlight == 0 && staller != -1) {\n+                if (State(staller)->nStallingSince == 0)\n+                    State(staller)->nStallingSince = nNow;\n             }\n         }\n \n@@ -4526,12 +4592,6 @@ class CMainCleanup\n             delete (*it1).second;\n         mapBlockIndex.clear();\n \n-        // orphan blocks\n-        std::map<uint256, COrphanBlock*>::iterator it2 = mapOrphanBlocks.begin();\n-        for (; it2 != mapOrphanBlocks.end(); it2++)\n-            delete (*it2).second;\n-        mapOrphanBlocks.clear();\n-\n         // orphan transactions\n         mapOrphanTransactions.clear();\n         mapOrphanTransactionsByPrev.clear();"
      },
      {
        "sha": "674f2fe4a4f7f4f1cb2bfb8fad46bffa1333e4fa",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 12,
        "deletions": 9,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d3fd120f325d710a64d0d5efe68e3fb29e33cd38/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d3fd120f325d710a64d0d5efe68e3fb29e33cd38/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=d3fd120f325d710a64d0d5efe68e3fb29e33cd38",
        "patch": "@@ -72,9 +72,17 @@ static const int MAX_SCRIPTCHECK_THREADS = 16;\n /** -par default (number of script-checking threads, 0 = auto) */\n static const int DEFAULT_SCRIPTCHECK_THREADS = 0;\n /** Number of blocks that can be requested at any given time from a single peer. */\n-static const int MAX_BLOCKS_IN_TRANSIT_PER_PEER = 128;\n-/** Timeout in seconds before considering a block download peer unresponsive. */\n-static const unsigned int BLOCK_DOWNLOAD_TIMEOUT = 60;\n+static const int MAX_BLOCKS_IN_TRANSIT_PER_PEER = 16;\n+/** Timeout in seconds during which a peer must stall block download progress before being disconnected. */\n+static const unsigned int BLOCK_STALLING_TIMEOUT = 2;\n+/** Number of headers sent in one getheaders result. We rely on the assumption that if a peer sends\n+ *  less than this number, we reached their tip. Changing this value is a protocol upgrade. */\n+static const unsigned int MAX_HEADERS_RESULTS = 2000;\n+/** Size of the \"block download window\": how far ahead of our current height do we fetch?\n+ *  Larger windows tolerate larger download speed differences between peer, but increase the potential\n+ *  degree of disordering of blocks on disk (which make reindexing and in the future perhaps pruning\n+ *  harder). We'll probably want to make this a per-peer adaptive value at some point. */\n+static const unsigned int BLOCK_DOWNLOAD_WINDOW = 1024;\n \n /** \"reject\" message codes **/\n static const unsigned char REJECT_MALFORMED = 0x01;\n@@ -137,8 +145,6 @@ void RegisterNodeSignals(CNodeSignals& nodeSignals);\n /** Unregister a network node */\n void UnregisterNodeSignals(CNodeSignals& nodeSignals);\n \n-void PushGetBlocks(CNode* pnode, CBlockIndex* pindexBegin, uint256 hashEnd);\n-\n /** Process an incoming block */\n bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBlockPos *dbp = NULL);\n /** Check whether enough disk space is available for an incoming block */\n@@ -439,17 +445,14 @@ bool DisconnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex\n // Apply the effects of this block (with given index) on the UTXO set represented by coins\n bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& coins, bool fJustCheck = false);\n \n-// Add this block to the block index, and if necessary, switch the active block chain to this\n-bool AddToBlockIndex(CBlock& block, CValidationState& state, const CDiskBlockPos& pos);\n-\n // Context-independent validity checks\n bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, bool fCheckPOW = true);\n bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW = true, bool fCheckMerkleRoot = true);\n \n // Store block on disk\n // if dbp is provided, the file is known to already reside on disk\n bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex **pindex, CDiskBlockPos* dbp = NULL);\n-bool AcceptBlockHeader(CBlockHeader& block, CValidationState& state, CBlockIndex **ppindex= NULL);\n+bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, CBlockIndex **ppindex= NULL);\n \n \n "
      },
      {
        "sha": "32ad106a0fb9454d10d18f51eebc59d435fb3874",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 50,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d3fd120f325d710a64d0d5efe68e3fb29e33cd38/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d3fd120f325d710a64d0d5efe68e3fb29e33cd38/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=d3fd120f325d710a64d0d5efe68e3fb29e33cd38",
        "patch": "@@ -73,7 +73,6 @@ map<CNetAddr, LocalServiceInfo> mapLocalHost;\n static bool vfReachable[NET_MAX] = {};\n static bool vfLimited[NET_MAX] = {};\n static CNode* pnodeLocalHost = NULL;\n-static CNode* pnodeSync = NULL;\n uint64_t nLocalHostNonce = 0;\n static std::vector<ListenSocket> vhListenSocket;\n CAddrMan addrman;\n@@ -518,10 +517,6 @@ void CNode::CloseSocketDisconnect()\n     TRY_LOCK(cs_vRecvMsg, lockRecv);\n     if (lockRecv)\n         vRecvMsg.clear();\n-\n-    // if this was the sync node, we'll need a new one\n-    if (this == pnodeSync)\n-        pnodeSync = NULL;\n }\n \n void CNode::PushVersion()\n@@ -614,7 +609,6 @@ void CNode::copyStats(CNodeStats &stats)\n     X(nSendBytes);\n     X(nRecvBytes);\n     X(fWhitelisted);\n-    stats.fSyncNode = (this == pnodeSync);\n \n     // It is common for nodes with good ping times to suddenly become lagged,\n     // due to a new block arriving or other large transfer.\n@@ -1486,61 +1480,20 @@ bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOu\n }\n \n \n-// for now, use a very simple selection metric: the node from which we received\n-// most recently\n-static int64_t NodeSyncScore(const CNode *pnode) {\n-    return pnode->nLastRecv;\n-}\n-\n-void static StartSync(const vector<CNode*> &vNodes) {\n-    CNode *pnodeNewSync = NULL;\n-    int64_t nBestScore = 0;\n-\n-    int nBestHeight = g_signals.GetHeight().get_value_or(0);\n-\n-    // Iterate over all nodes\n-    BOOST_FOREACH(CNode* pnode, vNodes) {\n-        // check preconditions for allowing a sync\n-        if (!pnode->fClient && !pnode->fOneShot &&\n-            !pnode->fDisconnect && pnode->fSuccessfullyConnected &&\n-            (pnode->nStartingHeight > (nBestHeight - 144)) &&\n-            (pnode->nVersion < NOBLKS_VERSION_START || pnode->nVersion >= NOBLKS_VERSION_END)) {\n-            // if ok, compare node's score with the best so far\n-            int64_t nScore = NodeSyncScore(pnode);\n-            if (pnodeNewSync == NULL || nScore > nBestScore) {\n-                pnodeNewSync = pnode;\n-                nBestScore = nScore;\n-            }\n-        }\n-    }\n-    // if a new sync candidate was found, start sync!\n-    if (pnodeNewSync) {\n-        pnodeNewSync->fStartSync = true;\n-        pnodeSync = pnodeNewSync;\n-    }\n-}\n-\n void ThreadMessageHandler()\n {\n     SetThreadPriority(THREAD_PRIORITY_BELOW_NORMAL);\n     while (true)\n     {\n-        bool fHaveSyncNode = false;\n-\n         vector<CNode*> vNodesCopy;\n         {\n             LOCK(cs_vNodes);\n             vNodesCopy = vNodes;\n             BOOST_FOREACH(CNode* pnode, vNodesCopy) {\n                 pnode->AddRef();\n-                if (pnode == pnodeSync)\n-                    fHaveSyncNode = true;\n             }\n         }\n \n-        if (!fHaveSyncNode)\n-            StartSync(vNodesCopy);\n-\n         // Poll the connected nodes for messages\n         CNode* pnodeTrickle = NULL;\n         if (!vNodesCopy.empty())\n@@ -2060,10 +2013,7 @@ CNode::CNode(SOCKET hSocketIn, CAddress addrIn, std::string addrNameIn, bool fIn\n     nSendSize = 0;\n     nSendOffset = 0;\n     hashContinue = 0;\n-    pindexLastGetBlocksBegin = 0;\n-    hashLastGetBlocksEnd = 0;\n     nStartingHeight = -1;\n-    fStartSync = false;\n     fGetAddr = false;\n     fRelayTxes = false;\n     setInventoryKnown.max_size(SendBufferSize() / 1000);"
      },
      {
        "sha": "18da24183f6e718e3162f2062ba301f374eae434",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d3fd120f325d710a64d0d5efe68e3fb29e33cd38/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d3fd120f325d710a64d0d5efe68e3fb29e33cd38/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=d3fd120f325d710a64d0d5efe68e3fb29e33cd38",
        "patch": "@@ -158,7 +158,6 @@ class CNodeStats\n     int nStartingHeight;\n     uint64_t nSendBytes;\n     uint64_t nRecvBytes;\n-    bool fSyncNode;\n     bool fWhitelisted;\n     double dPingTime;\n     double dPingWait;\n@@ -276,10 +275,7 @@ class CNode\n \n public:\n     uint256 hashContinue;\n-    CBlockIndex* pindexLastGetBlocksBegin;\n-    uint256 hashLastGetBlocksEnd;\n     int nStartingHeight;\n-    bool fStartSync;\n \n     // flood relay\n     std::vector<CAddress> vAddrToSend;"
      },
      {
        "sha": "898df2b080b302706fa607d9d87a7fa7a6228ab2",
        "filename": "src/qt/forms/rpcconsole.ui",
        "status": "modified",
        "additions": 0,
        "deletions": 23,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d3fd120f325d710a64d0d5efe68e3fb29e33cd38/src/qt/forms/rpcconsole.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d3fd120f325d710a64d0d5efe68e3fb29e33cd38/src/qt/forms/rpcconsole.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/rpcconsole.ui?ref=d3fd120f325d710a64d0d5efe68e3fb29e33cd38",
        "patch": "@@ -836,29 +836,6 @@\n             </property>\n            </widget>\n           </item>\n-          <item row=\"4\" column=\"0\">\n-           <widget class=\"QLabel\" name=\"label_25\">\n-            <property name=\"text\">\n-             <string>Sync Node</string>\n-            </property>\n-           </widget>\n-          </item>\n-          <item row=\"4\" column=\"2\">\n-           <widget class=\"QLabel\" name=\"peerSyncNode\">\n-            <property name=\"cursor\">\n-             <cursorShape>IBeamCursor</cursorShape>\n-            </property>\n-            <property name=\"text\">\n-             <string>N/A</string>\n-            </property>\n-            <property name=\"textFormat\">\n-             <enum>Qt::PlainText</enum>\n-            </property>\n-            <property name=\"textInteractionFlags\">\n-             <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByKeyboard|Qt::TextSelectableByMouse</set>\n-            </property>\n-           </widget>\n-          </item>\n           <item row=\"5\" column=\"0\">\n            <widget class=\"QLabel\" name=\"label_29\">\n             <property name=\"text\">"
      },
      {
        "sha": "2d2d448b49f46b694eaa07fa19cf790c3c309921",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d3fd120f325d710a64d0d5efe68e3fb29e33cd38/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d3fd120f325d710a64d0d5efe68e3fb29e33cd38/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=d3fd120f325d710a64d0d5efe68e3fb29e33cd38",
        "patch": "@@ -611,7 +611,6 @@ void RPCConsole::updateNodeDetail(const CNodeCombinedStats *stats)\n     ui->peerSubversion->setText(QString::fromStdString(stats->nodeStats.cleanSubVer));\n     ui->peerDirection->setText(stats->nodeStats.fInbound ? tr(\"Inbound\") : tr(\"Outbound\"));\n     ui->peerHeight->setText(QString(\"%1\").arg(stats->nodeStats.nStartingHeight));\n-    ui->peerSyncNode->setText(stats->nodeStats.fSyncNode ? tr(\"Yes\") : tr(\"No\"));\n \n     // This check fails for example if the lock was busy and\n     // nodeStateStats couldn't be fetched."
      },
      {
        "sha": "3bc4bb30c3df2206a871aaf051fb4ac2f6c486d9",
        "filename": "src/rpcnet.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d3fd120f325d710a64d0d5efe68e3fb29e33cd38/src/rpcnet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d3fd120f325d710a64d0d5efe68e3fb29e33cd38/src/rpcnet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcnet.cpp?ref=d3fd120f325d710a64d0d5efe68e3fb29e33cd38",
        "patch": "@@ -139,7 +139,6 @@ Value getpeerinfo(const Array& params, bool fHelp)\n             obj.push_back(Pair(\"banscore\", statestats.nMisbehavior));\n             obj.push_back(Pair(\"syncheight\", statestats.nSyncHeight));\n         }\n-        obj.push_back(Pair(\"syncnode\", stats.fSyncNode));\n         obj.push_back(Pair(\"whitelisted\", stats.fWhitelisted));\n \n         ret.push_back(obj);"
      },
      {
        "sha": "a1e440de24ddd152ecaa4b9a19f7e4500310c465",
        "filename": "src/version.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d3fd120f325d710a64d0d5efe68e3fb29e33cd38/src/version.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d3fd120f325d710a64d0d5efe68e3fb29e33cd38/src/version.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/version.h?ref=d3fd120f325d710a64d0d5efe68e3fb29e33cd38",
        "patch": "@@ -33,8 +33,11 @@ static const int PROTOCOL_VERSION = 70002;\n // initial proto version, to be increased after version/verack negotiation\n static const int INIT_PROTO_VERSION = 209;\n \n+// In this version, 'getheaders' was introduced.\n+static const int GETHEADERS_VERSION = 31800;\n+\n // disconnect from peers older than this proto version\n-static const int MIN_PEER_PROTO_VERSION = 209;\n+static const int MIN_PEER_PROTO_VERSION = GETHEADERS_VERSION;\n \n // nTime field added to CAddress, starting with this version;\n // if possible, avoid requesting addresses nodes older than this"
      }
    ]
  },
  {
    "sha": "39dc93c3f2f8c2fc5099383feba92c7c81cfc0a9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozOWRjOTNjM2YyZjhjMmZjNTA5OTM4M2ZlYmE5MmM3YzgxY2ZjMGE5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-07-11T22:03:10Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-06T06:28:54Z"
      },
      "message": "RPC additions after headers-first",
      "tree": {
        "sha": "c5a902d61a5957b766a686449dfab7aa8a025147",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c5a902d61a5957b766a686449dfab7aa8a025147"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/39dc93c3f2f8c2fc5099383feba92c7c81cfc0a9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39dc93c3f2f8c2fc5099383feba92c7c81cfc0a9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/39dc93c3f2f8c2fc5099383feba92c7c81cfc0a9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39dc93c3f2f8c2fc5099383feba92c7c81cfc0a9/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d3fd120f325d710a64d0d5efe68e3fb29e33cd38",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d3fd120f325d710a64d0d5efe68e3fb29e33cd38",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d3fd120f325d710a64d0d5efe68e3fb29e33cd38"
      }
    ],
    "stats": {
      "total": 31,
      "additions": 27,
      "deletions": 4
    },
    "files": [
      {
        "sha": "a4255d80cca8550d644162c22885e48c604e2543",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 2,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39dc93c3f2f8c2fc5099383feba92c7c81cfc0a9/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39dc93c3f2f8c2fc5099383feba92c7c81cfc0a9/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=39dc93c3f2f8c2fc5099383feba92c7c81cfc0a9",
        "patch": "@@ -41,6 +41,7 @@ CCriticalSection cs_main;\n \n BlockMap mapBlockIndex;\n CChain chainActive;\n+CBlockIndex *pindexBestHeader = NULL;\n int64_t nTimeBestReceived = 0;\n CWaitableCriticalSection csBestBlock;\n CConditionVariable cvBlockChange;\n@@ -51,6 +52,7 @@ bool fTxIndex = false;\n bool fIsBareMultisigStd = true;\n unsigned int nCoinCacheSize = 5000;\n \n+\n /** Fees smaller than this (in satoshi) are considered zero fee (for relaying and mining) */\n CFeeRate minRelayTxFee = CFeeRate(1000);\n \n@@ -98,8 +100,6 @@ namespace {\n     // The set of all CBlockIndex entries with BLOCK_VALID_TRANSACTIONS or better that are at least\n     // as good as our current tip. Entries may be failed, though.\n     set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexValid;\n-    // Best header we've seen so far (used for getheaders queries' starting points).\n-    CBlockIndex *pindexBestHeader = NULL;\n     // Number of nodes with fSyncStarted.\n     int nSyncStarted = 0;\n     // All pairs A->B, where A (or one if its ancestors) misses transactions, but B has transactions.\n@@ -440,6 +440,11 @@ bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n         return false;\n     stats.nMisbehavior = state->nMisbehavior;\n     stats.nSyncHeight = state->pindexBestKnownBlock ? state->pindexBestKnownBlock->nHeight : -1;\n+    stats.nCommonHeight = state->pindexLastCommonBlock ? state->pindexLastCommonBlock->nHeight : -1;\n+    BOOST_FOREACH(const QueuedBlock& queue, state->vBlocksInFlight) {\n+        if (queue.pindex)\n+            stats.vHeightInFlight.push_back(queue.pindex->nHeight);\n+    }\n     return true;\n }\n "
      },
      {
        "sha": "7939b087ecc13bf6d27e7134d1beb00df0365eea",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39dc93c3f2f8c2fc5099383feba92c7c81cfc0a9/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39dc93c3f2f8c2fc5099383feba92c7c81cfc0a9/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=39dc93c3f2f8c2fc5099383feba92c7c81cfc0a9",
        "patch": "@@ -118,6 +118,9 @@ extern bool fIsBareMultisigStd;\n extern unsigned int nCoinCacheSize;\n extern CFeeRate minRelayTxFee;\n \n+// Best header we've seen so far (used for getheaders queries' starting points).\n+extern CBlockIndex *pindexBestHeader;\n+\n // Minimum disk space required - used in CheckDiskSpace()\n static const uint64_t nMinDiskSpace = 52428800;\n \n@@ -199,6 +202,8 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n struct CNodeStateStats {\n     int nMisbehavior;\n     int nSyncHeight;\n+    int nCommonHeight;\n+    std::vector<int> vHeightInFlight;\n };\n \n struct CDiskTxPos : public CDiskBlockPos"
      },
      {
        "sha": "39e468c2a48cf3586e87a1cdec88d3ea827975ad",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39dc93c3f2f8c2fc5099383feba92c7c81cfc0a9/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39dc93c3f2f8c2fc5099383feba92c7c81cfc0a9/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=39dc93c3f2f8c2fc5099383feba92c7c81cfc0a9",
        "patch": "@@ -445,6 +445,7 @@ Value getblockchaininfo(const Array& params, bool fHelp)\n             \"{\\n\"\n             \"  \\\"chain\\\": \\\"xxxx\\\",        (string) current network name as defined in BIP70 (main, test, regtest)\\n\"\n             \"  \\\"blocks\\\": xxxxxx,         (numeric) the current number of blocks processed in the server\\n\"\n+            \"  \\\"headers\\\": xxxxxx,        (numeric) the current number of headers we have validated\\n\"\n             \"  \\\"bestblockhash\\\": \\\"...\\\", (string) the hash of the currently best block\\n\"\n             \"  \\\"difficulty\\\": xxxxxx,     (numeric) the current difficulty\\n\"\n             \"  \\\"verificationprogress\\\": xxxx, (numeric) estimate of verification progress [0..1]\\n\"\n@@ -458,6 +459,7 @@ Value getblockchaininfo(const Array& params, bool fHelp)\n     Object obj;\n     obj.push_back(Pair(\"chain\",                 Params().NetworkIDString()));\n     obj.push_back(Pair(\"blocks\",                (int)chainActive.Height()));\n+    obj.push_back(Pair(\"headers\",               pindexBestHeader ? pindexBestHeader->nHeight : -1));\n     obj.push_back(Pair(\"bestblockhash\",         chainActive.Tip()->GetBlockHash().GetHex()));\n     obj.push_back(Pair(\"difficulty\",            (double)GetDifficulty()));\n     obj.push_back(Pair(\"verificationprogress\",  Checkpoints::GuessVerificationProgress(chainActive.Tip())));"
      },
      {
        "sha": "12dcd5b5401f7142d39b89ba2d8085dd0bf83d0f",
        "filename": "src/rpcnet.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 2,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39dc93c3f2f8c2fc5099383feba92c7c81cfc0a9/src/rpcnet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39dc93c3f2f8c2fc5099383feba92c7c81cfc0a9/src/rpcnet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcnet.cpp?ref=39dc93c3f2f8c2fc5099383feba92c7c81cfc0a9",
        "patch": "@@ -97,7 +97,12 @@ Value getpeerinfo(const Array& params, bool fHelp)\n             \"    \\\"inbound\\\": true|false,     (boolean) Inbound (true) or Outbound (false)\\n\"\n             \"    \\\"startingheight\\\": n,       (numeric) The starting height (block) of the peer\\n\"\n             \"    \\\"banscore\\\": n,             (numeric) The ban score\\n\"\n-            \"    \\\"syncnode\\\": true|false     (boolean) if sync node\\n\"\n+            \"    \\\"synced_headers\\\": n,       (numeric) The last header we have in common with this peer\\n\"\n+            \"    \\\"synced_blocks\\\": n,        (numeric) The last block we have in common with this peer\\n\"\n+            \"    \\\"inflight\\\": [\\n\"\n+            \"       n,                        (numeric) The heights of blocks we're currently asking from this peer\\n\"\n+            \"       ...\\n\"\n+            \"    ]\\n\"\n             \"  }\\n\"\n             \"  ,...\\n\"\n             \"]\\n\"\n@@ -137,7 +142,13 @@ Value getpeerinfo(const Array& params, bool fHelp)\n         obj.push_back(Pair(\"startingheight\", stats.nStartingHeight));\n         if (fStateStats) {\n             obj.push_back(Pair(\"banscore\", statestats.nMisbehavior));\n-            obj.push_back(Pair(\"syncheight\", statestats.nSyncHeight));\n+            obj.push_back(Pair(\"synced_headers\", statestats.nSyncHeight));\n+            obj.push_back(Pair(\"synced_blocks\", statestats.nCommonHeight));\n+            Array heights;\n+            BOOST_FOREACH(int height, statestats.vHeightInFlight) {\n+                heights.push_back(height);\n+            }\n+            obj.push_back(Pair(\"inflight\", heights));\n         }\n         obj.push_back(Pair(\"whitelisted\", stats.fWhitelisted));\n "
      }
    ]
  },
  {
    "sha": "e30045d5b4873ced633aab1adce5ed271f6e2260",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMzAwNDVkNWI0ODczY2VkNjMzYWFiMWFkY2U1ZWQyNzFmNmUyMjYw",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-09-06T19:16:25Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-06T06:28:54Z"
      },
      "message": "Remove CheckMinWork, as we always know all parent headers",
      "tree": {
        "sha": "295cb9764636ebb58c9044f1c7cf81d6a539c006",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/295cb9764636ebb58c9044f1c7cf81d6a539c006"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e30045d5b4873ced633aab1adce5ed271f6e2260",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e30045d5b4873ced633aab1adce5ed271f6e2260",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e30045d5b4873ced633aab1adce5ed271f6e2260",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e30045d5b4873ced633aab1adce5ed271f6e2260/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "39dc93c3f2f8c2fc5099383feba92c7c81cfc0a9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39dc93c3f2f8c2fc5099383feba92c7c81cfc0a9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/39dc93c3f2f8c2fc5099383feba92c7c81cfc0a9"
      }
    ],
    "stats": {
      "total": 97,
      "additions": 0,
      "deletions": 97
    },
    "files": [
      {
        "sha": "1c93da5f9ddd96ee2213e26e08a1ec8183fa8fe8",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 17,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e30045d5b4873ced633aab1adce5ed271f6e2260/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e30045d5b4873ced633aab1adce5ed271f6e2260/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=e30045d5b4873ced633aab1adce5ed271f6e2260",
        "patch": "@@ -2336,23 +2336,6 @@ bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, CBloc\n         return true;\n     }\n \n-    CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint();\n-    if (pcheckpoint && block.hashPrevBlock != (chainActive.Tip() ? chainActive.Tip()->GetBlockHash() : uint256(0)))\n-    {\n-        // Extra checks to prevent \"fill up memory by spamming with bogus blocks\"\n-        int64_t deltaTime = block.GetBlockTime() - pcheckpoint->GetBlockTime();\n-        if (deltaTime < 0)\n-        {\n-            return state.DoS(100, error(\"%s : block with timestamp before last checkpoint\", __func__),\n-                             REJECT_CHECKPOINT, \"time-too-old\");\n-        }\n-        if (!CheckMinWork(block.nBits, pcheckpoint->nBits, deltaTime))\n-        {\n-            return state.DoS(100, error(\"%s : block with too little proof-of-work\", __func__),\n-                             REJECT_INVALID, \"bad-diffbits\");\n-        }\n-    }\n-\n     // Get prev block index\n     CBlockIndex* pindexPrev = NULL;\n     int nHeight = 0;"
      },
      {
        "sha": "75fbfc6a6d5088b11ed3cffcdec4c76dcc507cb8",
        "filename": "src/pow.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 33,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e30045d5b4873ced633aab1adce5ed271f6e2260/src/pow.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e30045d5b4873ced633aab1adce5ed271f6e2260/src/pow.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow.cpp?ref=e30045d5b4873ced633aab1adce5ed271f6e2260",
        "patch": "@@ -98,39 +98,6 @@ bool CheckProofOfWork(uint256 hash, unsigned int nBits)\n     return true;\n }\n \n-//\n-// true if nBits is greater than the minimum amount of work that could\n-// possibly be required deltaTime after minimum work required was nBase\n-//\n-bool CheckMinWork(unsigned int nBits, unsigned int nBase, int64_t deltaTime)\n-{\n-    bool fOverflow = false;\n-    uint256 bnNewBlock;\n-    bnNewBlock.SetCompact(nBits, NULL, &fOverflow);\n-    if (fOverflow)\n-        return false;\n-\n-    const uint256 &bnLimit = Params().ProofOfWorkLimit();\n-    // Testnet has min-difficulty blocks\n-    // after Params().TargetSpacing()*2 time between blocks:\n-    if (Params().AllowMinDifficultyBlocks() && deltaTime > Params().TargetSpacing()*2)\n-        return bnNewBlock <= bnLimit;\n-\n-    uint256 bnResult;\n-    bnResult.SetCompact(nBase);\n-    while (deltaTime > 0 && bnResult < bnLimit)\n-    {\n-        // Maximum 400% adjustment...\n-        bnResult *= 4;\n-        // ... in best-case exactly 4-times-normal target time\n-        deltaTime -= Params().TargetTimespan()*4;\n-    }\n-    if (bnResult > bnLimit)\n-        bnResult = bnLimit;\n-\n-    return bnNewBlock <= bnResult;\n-}\n-\n void UpdateTime(CBlockHeader* pblock, const CBlockIndex* pindexPrev)\n {\n     pblock->nTime = std::max(pindexPrev->GetMedianTimePast()+1, GetAdjustedTime());"
      },
      {
        "sha": "233d1f37953f60798474bbc74529434b3b7bcef4",
        "filename": "src/pow.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e30045d5b4873ced633aab1adce5ed271f6e2260/src/pow.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e30045d5b4873ced633aab1adce5ed271f6e2260/src/pow.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow.h?ref=e30045d5b4873ced633aab1adce5ed271f6e2260",
        "patch": "@@ -16,8 +16,6 @@ unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHead\n \n /** Check whether a block hash satisfies the proof-of-work requirement specified by nBits */\n bool CheckProofOfWork(uint256 hash, unsigned int nBits);\n-/** Check the work is more than the minimum a received block needs, without knowing its direct parent */\n-bool CheckMinWork(unsigned int nBits, unsigned int nBase, int64_t deltaTime);\n \n void UpdateTime(CBlockHeader* block, const CBlockIndex* pindexPrev);\n "
      },
      {
        "sha": "f9746fdaa5c657b31d565c340cf1c2f93ee6e990",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 45,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e30045d5b4873ced633aab1adce5ed271f6e2260/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e30045d5b4873ced633aab1adce5ed271f6e2260/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=e30045d5b4873ced633aab1adce5ed271f6e2260",
        "patch": "@@ -106,51 +106,6 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     BOOST_CHECK(!CNode::IsBanned(addr));\n }\n \n-static bool CheckNBits(unsigned int nbits1, int64_t time1, unsigned int nbits2, int64_t time2)\\\n-{\n-    if (time1 > time2)\n-        return CheckNBits(nbits2, time2, nbits1, time1);\n-    int64_t deltaTime = time2-time1;\n-\n-    return CheckMinWork(nbits2, nbits1, deltaTime);\n-}\n-\n-BOOST_AUTO_TEST_CASE(DoS_checknbits)\n-{\n-    using namespace boost::assign; // for 'map_list_of()'\n-\n-    // Timestamps,nBits from the bitcoin block chain.\n-    // These are the block-chain checkpoint blocks\n-    typedef std::map<int64_t, unsigned int> BlockData;\n-    BlockData chainData =\n-        map_list_of(1239852051,486604799)(1262749024,486594666)\n-        (1279305360,469854461)(1280200847,469830746)(1281678674,469809688)\n-        (1296207707,453179945)(1302624061,453036989)(1309640330,437004818)\n-        (1313172719,436789733);\n-\n-    // Make sure CheckNBits considers every combination of block-chain-lock-in-points\n-    // \"sane\":\n-    BOOST_FOREACH(const BlockData::value_type& i, chainData)\n-    {\n-        BOOST_FOREACH(const BlockData::value_type& j, chainData)\n-        {\n-            BOOST_CHECK(CheckNBits(i.second, i.first, j.second, j.first));\n-        }\n-    }\n-\n-    // Test a couple of insane combinations:\n-    BlockData::value_type firstcheck = *(chainData.begin());\n-    BlockData::value_type lastcheck = *(chainData.rbegin());\n-\n-    // First checkpoint difficulty at or a while after the last checkpoint time should fail when\n-    // compared to last checkpoint\n-    BOOST_CHECK(!CheckNBits(firstcheck.second, lastcheck.first+60*10, lastcheck.second, lastcheck.first));\n-    BOOST_CHECK(!CheckNBits(firstcheck.second, lastcheck.first+60*60*24*14, lastcheck.second, lastcheck.first));\n-\n-    // ... but OK if enough time passed for difficulty to adjust downward:\n-    BOOST_CHECK(CheckNBits(firstcheck.second, lastcheck.first+60*60*24*365*4, lastcheck.second, lastcheck.first));\n-}\n-\n CTransaction RandomOrphan()\n {\n     std::map<uint256, COrphanTx>::iterator it;"
      }
    ]
  },
  {
    "sha": "84d1ee56b8762a6f527519c635ced64bd6067a59",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NGQxZWU1NmI4NzYyYTZmNTI3NTE5YzYzNWNlZDY0YmQ2MDY3YTU5",
    "commit": {
      "author": {
        "name": "R E Broadley",
        "email": "rebroad+github@gmail.com",
        "date": "2014-09-02T10:16:32Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-06T06:28:54Z"
      },
      "message": "Improve getheaders (sending) logging",
      "tree": {
        "sha": "0afb32edd0f3a1974c79263f74bc579cdb9edc0e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0afb32edd0f3a1974c79263f74bc579cdb9edc0e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/84d1ee56b8762a6f527519c635ced64bd6067a59",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/84d1ee56b8762a6f527519c635ced64bd6067a59",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/84d1ee56b8762a6f527519c635ced64bd6067a59",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/84d1ee56b8762a6f527519c635ced64bd6067a59/comments",
    "author": {
      "login": "rebroad",
      "id": 1530283,
      "node_id": "MDQ6VXNlcjE1MzAyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rebroad",
      "html_url": "https://github.com/rebroad",
      "followers_url": "https://api.github.com/users/rebroad/followers",
      "following_url": "https://api.github.com/users/rebroad/following{/other_user}",
      "gists_url": "https://api.github.com/users/rebroad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
      "organizations_url": "https://api.github.com/users/rebroad/orgs",
      "repos_url": "https://api.github.com/users/rebroad/repos",
      "events_url": "https://api.github.com/users/rebroad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rebroad/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e30045d5b4873ced633aab1adce5ed271f6e2260",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e30045d5b4873ced633aab1adce5ed271f6e2260",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e30045d5b4873ced633aab1adce5ed271f6e2260"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 4,
      "deletions": 1
    },
    "files": [
      {
        "sha": "f7d15f56f5bd8a4754b4b9fec593922af9aa7457",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/84d1ee56b8762a6f527519c635ced64bd6067a59/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/84d1ee56b8762a6f527519c635ced64bd6067a59/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=84d1ee56b8762a6f527519c635ced64bd6067a59",
        "patch": "@@ -3617,6 +3617,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                         // later (within the same cs_main lock, though).\n                         MarkBlockAsInFlight(pfrom->GetId(), inv.hash);\n                     }\n+                    LogPrint(\"net\", \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, inv.hash.ToString(), pfrom->id);\n                 }\n             }\n \n@@ -3719,7 +3720,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         // we must use CBlocks, as CBlockHeaders won't include the 0x00 nTx count at the end\n         vector<CBlock> vHeaders;\n         int nLimit = MAX_HEADERS_RESULTS;\n-        LogPrint(\"net\", \"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString());\n+        LogPrint(\"net\", \"getheaders %d to %s from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString(), pfrom->id);\n         for (; pindex; pindex = chainActive.Next(pindex))\n         {\n             vHeaders.push_back(pindex->GetBlockHeader());\n@@ -3885,6 +3886,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             // Headers message had its maximum size; the peer may have more headers.\n             // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n             // from there instead.\n+            LogPrint(\"net\", \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->id, pfrom->nStartingHeight);\n             pfrom->PushMessage(\"getheaders\", chainActive.GetLocator(pindexLast), uint256(0));\n         }\n     }\n@@ -4388,6 +4390,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n                 state.fSyncStarted = true;\n                 nSyncStarted++;\n                 CBlockIndex *pindexStart = pindexBestHeader->pprev ? pindexBestHeader->pprev : pindexBestHeader;\n+                LogPrint(\"net\", \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->id, pto->nStartingHeight);\n                 pto->PushMessage(\"getheaders\", chainActive.GetLocator(pindexStart), uint256(0));\n             }\n         }"
      }
    ]
  },
  {
    "sha": "2ea9ff53c8dc15a1cfbd0766d58df978fde1d3bf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZWE5ZmY1M2M4ZGMxNWExY2ZiZDA3NjZkNThkZjk3OGZkZTFkM2Jm",
    "commit": {
      "author": {
        "name": "R E Broadley",
        "email": "rebroad+github@gmail.com",
        "date": "2014-09-03T18:31:01Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-06T06:28:55Z"
      },
      "message": "Better logging of stalling",
      "tree": {
        "sha": "06d3e092428d7ea94017f2f1a32511d2003760ff",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/06d3e092428d7ea94017f2f1a32511d2003760ff"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2ea9ff53c8dc15a1cfbd0766d58df978fde1d3bf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2ea9ff53c8dc15a1cfbd0766d58df978fde1d3bf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2ea9ff53c8dc15a1cfbd0766d58df978fde1d3bf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2ea9ff53c8dc15a1cfbd0766d58df978fde1d3bf/comments",
    "author": {
      "login": "rebroad",
      "id": 1530283,
      "node_id": "MDQ6VXNlcjE1MzAyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rebroad",
      "html_url": "https://github.com/rebroad",
      "followers_url": "https://api.github.com/users/rebroad/followers",
      "following_url": "https://api.github.com/users/rebroad/following{/other_user}",
      "gists_url": "https://api.github.com/users/rebroad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
      "organizations_url": "https://api.github.com/users/rebroad/orgs",
      "repos_url": "https://api.github.com/users/rebroad/repos",
      "events_url": "https://api.github.com/users/rebroad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rebroad/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "84d1ee56b8762a6f527519c635ced64bd6067a59",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/84d1ee56b8762a6f527519c635ced64bd6067a59",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/84d1ee56b8762a6f527519c635ced64bd6067a59"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 3,
      "deletions": 1
    },
    "files": [
      {
        "sha": "3a5f157ce2e39d32c9ded2f03fec935aeb4bf55e",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ea9ff53c8dc15a1cfbd0766d58df978fde1d3bf/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ea9ff53c8dc15a1cfbd0766d58df978fde1d3bf/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=2ea9ff53c8dc15a1cfbd0766d58df978fde1d3bf",
        "patch": "@@ -4475,8 +4475,10 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n                 LogPrint(\"net\", \"Requesting block %s peer=%d\\n\", pindex->GetBlockHash().ToString(), pto->id);\n             }\n             if (state.nBlocksInFlight == 0 && staller != -1) {\n-                if (State(staller)->nStallingSince == 0)\n+                if (State(staller)->nStallingSince == 0) {\n                     State(staller)->nStallingSince = nNow;\n+                    LogPrint(\"net\", \"Stall started peer=%d\\n\", staller);\n+                }\n             }\n         }\n "
      }
    ]
  },
  {
    "sha": "9a3ab2c81484e34971dcb6c0cdbd421f842c93de",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YTNhYjJjODE0ODRlMzQ5NzFkY2I2YzBjZGJkNDIxZjg0MmM5M2Rl",
    "commit": {
      "author": {
        "name": "R E Broadley",
        "email": "rebroad+github@gmail.com",
        "date": "2014-09-05T15:32:22Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-06T06:28:55Z"
      },
      "message": "Add height to \"Requesting block\" debug",
      "tree": {
        "sha": "b13330280a48f91f6cc0320c8c7e8ae58d505ece",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b13330280a48f91f6cc0320c8c7e8ae58d505ece"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9a3ab2c81484e34971dcb6c0cdbd421f842c93de",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9a3ab2c81484e34971dcb6c0cdbd421f842c93de",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9a3ab2c81484e34971dcb6c0cdbd421f842c93de",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9a3ab2c81484e34971dcb6c0cdbd421f842c93de/comments",
    "author": {
      "login": "rebroad",
      "id": 1530283,
      "node_id": "MDQ6VXNlcjE1MzAyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rebroad",
      "html_url": "https://github.com/rebroad",
      "followers_url": "https://api.github.com/users/rebroad/followers",
      "following_url": "https://api.github.com/users/rebroad/following{/other_user}",
      "gists_url": "https://api.github.com/users/rebroad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
      "organizations_url": "https://api.github.com/users/rebroad/orgs",
      "repos_url": "https://api.github.com/users/rebroad/repos",
      "events_url": "https://api.github.com/users/rebroad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rebroad/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2ea9ff53c8dc15a1cfbd0766d58df978fde1d3bf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2ea9ff53c8dc15a1cfbd0766d58df978fde1d3bf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2ea9ff53c8dc15a1cfbd0766d58df978fde1d3bf"
      }
    ],
    "stats": {
      "total": 3,
      "additions": 2,
      "deletions": 1
    },
    "files": [
      {
        "sha": "77c6be4174827f6822d82febc23b84935d320ef0",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9a3ab2c81484e34971dcb6c0cdbd421f842c93de/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9a3ab2c81484e34971dcb6c0cdbd421f842c93de/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=9a3ab2c81484e34971dcb6c0cdbd421f842c93de",
        "patch": "@@ -4472,7 +4472,8 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n             BOOST_FOREACH(CBlockIndex *pindex, vToDownload) {\n                 vGetData.push_back(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n                 MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);\n-                LogPrint(\"net\", \"Requesting block %s peer=%d\\n\", pindex->GetBlockHash().ToString(), pto->id);\n+                LogPrint(\"net\", \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n+                    pindex->nHeight, pto->id);\n             }\n             if (state.nBlocksInFlight == 0 && staller != -1) {\n                 if (State(staller)->nStallingSince == 0) {"
      }
    ]
  },
  {
    "sha": "f062199453b9df0657a637970b05cbaaeb1e0666",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMDYyMTk5NDUzYjlkZjA2NTdhNjM3OTcwYjA1Y2JhYWViMWUwNjY2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-06T06:31:33Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-06T06:31:33Z"
      },
      "message": "Rename setBlockIndexValid to setBlockIndexCandidateTips",
      "tree": {
        "sha": "fb727b0f4f591c6a914b7912cae8887b3660bd57",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fb727b0f4f591c6a914b7912cae8887b3660bd57"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f062199453b9df0657a637970b05cbaaeb1e0666",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f062199453b9df0657a637970b05cbaaeb1e0666",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f062199453b9df0657a637970b05cbaaeb1e0666",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f062199453b9df0657a637970b05cbaaeb1e0666/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9a3ab2c81484e34971dcb6c0cdbd421f842c93de",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9a3ab2c81484e34971dcb6c0cdbd421f842c93de",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9a3ab2c81484e34971dcb6c0cdbd421f842c93de"
      }
    ],
    "stats": {
      "total": 30,
      "additions": 15,
      "deletions": 15
    },
    "files": [
      {
        "sha": "c3aed00cdf2bba3df6d00a89141672c782a4c340",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f062199453b9df0657a637970b05cbaaeb1e0666/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f062199453b9df0657a637970b05cbaaeb1e0666/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=f062199453b9df0657a637970b05cbaaeb1e0666",
        "patch": "@@ -99,7 +99,7 @@ namespace {\n \n     // The set of all CBlockIndex entries with BLOCK_VALID_TRANSACTIONS or better that are at least\n     // as good as our current tip. Entries may be failed, though.\n-    set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexValid;\n+    set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexCandidateTips;\n     // Number of nodes with fSyncStarted.\n     int nSyncStarted = 0;\n     // All pairs A->B, where A (or one if its ancestors) misses transactions, but B has transactions.\n@@ -1323,7 +1323,7 @@ void static InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state\n     if (!state.CorruptionPossible()) {\n         pindex->nStatus |= BLOCK_FAILED_VALID;\n         pblocktree->WriteBlockIndex(CDiskBlockIndex(pindex));\n-        setBlockIndexValid.erase(pindex);\n+        setBlockIndexCandidateTips.erase(pindex);\n         InvalidChainFound(pindex);\n     }\n }\n@@ -1925,8 +1925,8 @@ static CBlockIndex* FindMostWorkChain() {\n \n         // Find the best candidate header.\n         {\n-            std::set<CBlockIndex*, CBlockIndexWorkComparator>::reverse_iterator it = setBlockIndexValid.rbegin();\n-            if (it == setBlockIndexValid.rend())\n+            std::set<CBlockIndex*, CBlockIndexWorkComparator>::reverse_iterator it = setBlockIndexCandidateTips.rbegin();\n+            if (it == setBlockIndexCandidateTips.rend())\n                 return NULL;\n             pindexNew = *it;\n         }\n@@ -1945,10 +1945,10 @@ static CBlockIndex* FindMostWorkChain() {\n                 CBlockIndex *pindexFailed = pindexNew;\n                 while (pindexTest != pindexFailed) {\n                     pindexFailed->nStatus |= BLOCK_FAILED_CHILD;\n-                    setBlockIndexValid.erase(pindexFailed);\n+                    setBlockIndexCandidateTips.erase(pindexFailed);\n                     pindexFailed = pindexFailed->pprev;\n                 }\n-                setBlockIndexValid.erase(pindexTest);\n+                setBlockIndexCandidateTips.erase(pindexTest);\n                 fInvalidAncestor = true;\n                 break;\n             }\n@@ -1997,15 +1997,15 @@ static bool ActivateBestChainStep(CValidationState &state, CBlockIndex *pindexMo\n                 return false;\n             }\n         } else {\n-            // Delete all entries in setBlockIndexValid that are worse than our new current block.\n+            // Delete all entries in setBlockIndexCandidateTips that are worse than our new current block.\n             // Note that we can't delete the current block itself, as we may need to return to it later in case a\n             // reorganization to a better block fails.\n-            std::set<CBlockIndex*, CBlockIndexWorkComparator>::iterator it = setBlockIndexValid.begin();\n-            while (setBlockIndexValid.value_comp()(*it, chainActive.Tip())) {\n-                setBlockIndexValid.erase(it++);\n+            std::set<CBlockIndex*, CBlockIndexWorkComparator>::iterator it = setBlockIndexCandidateTips.begin();\n+            while (setBlockIndexCandidateTips.value_comp()(*it, chainActive.Tip())) {\n+                setBlockIndexCandidateTips.erase(it++);\n             }\n-            // Either the current tip or a successor of it we're working towards is left in setBlockIndexValid.\n-            assert(!setBlockIndexValid.empty());\n+            // Either the current tip or a successor of it we're working towards is left in setBlockIndexCandidateTips.\n+            assert(!setBlockIndexCandidateTips.empty());\n             if (!pindexOldTip || chainActive.Tip()->nChainWork > pindexOldTip->nChainWork) {\n                 // We're in a better position than we were. Return temporarily to release the lock.\n                 break;\n@@ -2130,7 +2130,7 @@ bool ReceivedBlockTransactions(const CBlock &block, CValidationState& state, CBl\n             CBlockIndex *pindex = queue.front();\n             queue.pop_front();\n             pindex->nChainTx = (pindex->pprev ? pindex->pprev->nChainTx : 0) + pindex->nTx;\n-            setBlockIndexValid.insert(pindex);\n+            setBlockIndexCandidateTips.insert(pindex);\n             std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = mapBlocksUnlinked.equal_range(pindex);\n             while (range.first != range.second) {\n                 std::multimap<CBlockIndex*, CBlockIndex*>::iterator it = range.first;\n@@ -2810,7 +2810,7 @@ bool static LoadBlockIndexDB()\n             }\n         }\n         if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && (pindex->nChainTx || pindex->pprev == NULL))\n-            setBlockIndexValid.insert(pindex);\n+            setBlockIndexCandidateTips.insert(pindex);\n         if (pindex->nStatus & BLOCK_FAILED_MASK && (!pindexBestInvalid || pindex->nChainWork > pindexBestInvalid->nChainWork))\n             pindexBestInvalid = pindex;\n         if (pindex->pprev)\n@@ -2954,7 +2954,7 @@ bool CVerifyDB::VerifyDB(CCoinsView *coinsview, int nCheckLevel, int nCheckDepth\n void UnloadBlockIndex()\n {\n     mapBlockIndex.clear();\n-    setBlockIndexValid.clear();\n+    setBlockIndexCandidateTips.clear();\n     chainActive.SetTip(NULL);\n     pindexBestInvalid = NULL;\n }"
      }
    ]
  },
  {
    "sha": "8377e2807b3d9ba4548a5414b1de906859217923",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4Mzc3ZTI4MDdiM2Q5YmE0NTQ4YTU0MTRiMWRlOTA2ODU5MjE3OTIz",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-10-07T16:06:30Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-10-07T16:17:49Z"
      },
      "message": "Make -reindex cope with out-of-order blocks\n\nRemember out-of-order block headers along with disk positions. This is\nlikely the simplest and least-impact way to make -reindex work with\nheaders first.\n\nBased on top of #4468.",
      "tree": {
        "sha": "65031d9fcaf545326028e78b4d921de4d047c59b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/65031d9fcaf545326028e78b4d921de4d047c59b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8377e2807b3d9ba4548a5414b1de906859217923",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8377e2807b3d9ba4548a5414b1de906859217923",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8377e2807b3d9ba4548a5414b1de906859217923",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8377e2807b3d9ba4548a5414b1de906859217923/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f062199453b9df0657a637970b05cbaaeb1e0666",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f062199453b9df0657a637970b05cbaaeb1e0666",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f062199453b9df0657a637970b05cbaaeb1e0666"
      }
    ],
    "stats": {
      "total": 60,
      "additions": 52,
      "deletions": 8
    },
    "files": [
      {
        "sha": "e22055e76e61fbdcb93ac1fb00edf17d61bb19bd",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 8,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8377e2807b3d9ba4548a5414b1de906859217923/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8377e2807b3d9ba4548a5414b1de906859217923/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=8377e2807b3d9ba4548a5414b1de906859217923",
        "patch": "@@ -3077,6 +3077,8 @@ void PrintBlockTree()\n \n bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n {\n+    // Map of disk positions for blocks with unknown parent (only used for reindex)\n+    static std::multimap<uint256, CDiskBlockPos> mapBlocksUnknownParent;\n     int64_t nStart = GetTimeMillis();\n \n     int nLoaded = 0;\n@@ -3119,20 +3121,62 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n             try {\n                 // read block\n                 uint64_t nBlockPos = blkdat.GetPos();\n+                if (nBlockPos < nStartByte) // skip already indexed part\n+                    continue;\n+                if (dbp)\n+                    dbp->nPos = nBlockPos;\n                 blkdat.SetLimit(nBlockPos + nSize);\n+\n+                // read block header\n+                CBlockHeader blockhdr;\n+                blkdat >> blockhdr;\n+                nRewind = blkdat.GetPos();\n+\n+                // process block header\n+                uint256 hash = blockhdr.GetHash();\n+                if (hash != Params().HashGenesisBlock() && mapBlockIndex.find(blockhdr.hashPrevBlock) == mapBlockIndex.end()) {\n+                    LogPrint(\"reindex\", \"%s: Out of order block %s, parent %s not known\\n\", __func__, hash.ToString(),\n+                            blockhdr.hashPrevBlock.ToString());\n+                    if (dbp)\n+                        mapBlocksUnknownParent.insert(std::make_pair(blockhdr.hashPrevBlock, *dbp));\n+                    // TODO a slight optimization would be: blkdat.Skip(nSize - 80)\n+                    continue;\n+                }\n+\n+                // read block\n+                blkdat.SetPos(nBlockPos);\n                 CBlock block;\n                 blkdat >> block;\n                 nRewind = blkdat.GetPos();\n \n                 // process block\n-                if (nBlockPos >= nStartByte) {\n-                    if (dbp)\n-                        dbp->nPos = nBlockPos;\n-                    CValidationState state;\n-                    if (ProcessBlock(state, NULL, &block, dbp))\n-                        nLoaded++;\n-                    if (state.IsError())\n-                        break;\n+                CValidationState state;\n+                if (ProcessBlock(state, NULL, &block, dbp))\n+                    nLoaded++;\n+                if (state.IsError())\n+                    break;\n+\n+                // Recursively process earlier encountered successors of this block\n+                deque<uint256> queue;\n+                queue.push_back(hash);\n+                while (!queue.empty()) {\n+                    uint256 head = queue.front();\n+                    queue.pop_front();\n+                    std::pair<std::multimap<uint256, CDiskBlockPos>::iterator, std::multimap<uint256, CDiskBlockPos>::iterator> range = mapBlocksUnknownParent.equal_range(head);\n+                    while (range.first != range.second) {\n+                        std::multimap<uint256, CDiskBlockPos>::iterator it = range.first;\n+                        ReadBlockFromDisk(block, it->second);\n+                        LogPrintf(\"%s: Processing out of order child %s of %s\\n\", __func__, block.GetHash().ToString(),\n+                                head.ToString());\n+                        CValidationState dummy;\n+                        if (ProcessBlock(dummy, NULL, &block, &it->second))\n+                        {\n+                            nLoaded++;\n+                            queue.push_back(block.GetHash());\n+                        }\n+                        range.first++;\n+                        mapBlocksUnknownParent.erase(it);\n+                    }\n                 }\n             } catch (std::exception &e) {\n                 LogPrintf(\"%s : Deserialize or I/O error - %s\", __func__, e.what());"
      }
    ]
  },
  {
    "sha": "6213af13e452e28ec2d8bbc470fdfb66c30633b7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MjEzYWYxM2U0NTJlMjhlYzJkOGJiYzQ3MGZkZmI2NmMzMDYzM2I3",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-10-07T16:36:01Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-10-07T16:36:01Z"
      },
      "message": "squashme: don't ignore ReadBlockFromDisk return value",
      "tree": {
        "sha": "51a97d0f2a65ce3d8b46a3ef01cbba5b01a45d79",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/51a97d0f2a65ce3d8b46a3ef01cbba5b01a45d79"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6213af13e452e28ec2d8bbc470fdfb66c30633b7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6213af13e452e28ec2d8bbc470fdfb66c30633b7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6213af13e452e28ec2d8bbc470fdfb66c30633b7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6213af13e452e28ec2d8bbc470fdfb66c30633b7/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8377e2807b3d9ba4548a5414b1de906859217923",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8377e2807b3d9ba4548a5414b1de906859217923",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8377e2807b3d9ba4548a5414b1de906859217923"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 9,
      "deletions": 7
    },
    "files": [
      {
        "sha": "5a205293f21e273c128591f3f733f0d634ceecd3",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 7,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6213af13e452e28ec2d8bbc470fdfb66c30633b7/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6213af13e452e28ec2d8bbc470fdfb66c30633b7/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=6213af13e452e28ec2d8bbc470fdfb66c30633b7",
        "patch": "@@ -3165,14 +3165,16 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n                     std::pair<std::multimap<uint256, CDiskBlockPos>::iterator, std::multimap<uint256, CDiskBlockPos>::iterator> range = mapBlocksUnknownParent.equal_range(head);\n                     while (range.first != range.second) {\n                         std::multimap<uint256, CDiskBlockPos>::iterator it = range.first;\n-                        ReadBlockFromDisk(block, it->second);\n-                        LogPrintf(\"%s: Processing out of order child %s of %s\\n\", __func__, block.GetHash().ToString(),\n-                                head.ToString());\n-                        CValidationState dummy;\n-                        if (ProcessBlock(dummy, NULL, &block, &it->second))\n+                        if (ReadBlockFromDisk(block, it->second))\n                         {\n-                            nLoaded++;\n-                            queue.push_back(block.GetHash());\n+                            LogPrintf(\"%s: Processing out of order child %s of %s\\n\", __func__, block.GetHash().ToString(),\n+                                    head.ToString());\n+                            CValidationState dummy;\n+                            if (ProcessBlock(dummy, NULL, &block, &it->second))\n+                            {\n+                                nLoaded++;\n+                                queue.push_back(block.GetHash());\n+                            }\n                         }\n                         range.first++;\n                         mapBlocksUnknownParent.erase(it);"
      }
    ]
  },
  {
    "sha": "f08c86342e17e6eaa0baccc6d92e40106f6ef5c2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMDhjODYzNDJlMTdlNmVhYTBiYWNjYzZkOTJlNDAxMDZmNmVmNWMy",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-10-07T18:23:57Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-10-07T18:23:57Z"
      },
      "message": "squashme: allow interruption while processing out-of-order blocks",
      "tree": {
        "sha": "b5f483816736622383d171cbc3d2a2417ed91167",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b5f483816736622383d171cbc3d2a2417ed91167"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f08c86342e17e6eaa0baccc6d92e40106f6ef5c2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f08c86342e17e6eaa0baccc6d92e40106f6ef5c2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f08c86342e17e6eaa0baccc6d92e40106f6ef5c2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f08c86342e17e6eaa0baccc6d92e40106f6ef5c2/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6213af13e452e28ec2d8bbc470fdfb66c30633b7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6213af13e452e28ec2d8bbc470fdfb66c30633b7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6213af13e452e28ec2d8bbc470fdfb66c30633b7"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 2,
      "deletions": 0
    },
    "files": [
      {
        "sha": "3229fa27be9a23de4f037251f576b68a62ce96eb",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f08c86342e17e6eaa0baccc6d92e40106f6ef5c2/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f08c86342e17e6eaa0baccc6d92e40106f6ef5c2/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=f08c86342e17e6eaa0baccc6d92e40106f6ef5c2",
        "patch": "@@ -3164,6 +3164,8 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n                     queue.pop_front();\n                     std::pair<std::multimap<uint256, CDiskBlockPos>::iterator, std::multimap<uint256, CDiskBlockPos>::iterator> range = mapBlocksUnknownParent.equal_range(head);\n                     while (range.first != range.second) {\n+                        boost::this_thread::interruption_point();\n+\n                         std::multimap<uint256, CDiskBlockPos>::iterator it = range.first;\n                         if (ReadBlockFromDisk(block, it->second))\n                         {"
      }
    ]
  },
  {
    "sha": "da1fa384856677efd97a8f456694e48d940fba53",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYTFmYTM4NDg1NjY3N2VmZDk3YThmNDU2Njk0ZTQ4ZDk0MGZiYTUz",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-10-07T19:20:42Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-10-07T19:20:42Z"
      },
      "message": "squashme: reduce debug logging",
      "tree": {
        "sha": "3964e6abeb18d58fb8ee68037708f27225e318db",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3964e6abeb18d58fb8ee68037708f27225e318db"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/da1fa384856677efd97a8f456694e48d940fba53",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/da1fa384856677efd97a8f456694e48d940fba53",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/da1fa384856677efd97a8f456694e48d940fba53",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/da1fa384856677efd97a8f456694e48d940fba53/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f08c86342e17e6eaa0baccc6d92e40106f6ef5c2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f08c86342e17e6eaa0baccc6d92e40106f6ef5c2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f08c86342e17e6eaa0baccc6d92e40106f6ef5c2"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "7d8e03d921850cc60f3eba8796265cf1fa58e16d",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/da1fa384856677efd97a8f456694e48d940fba53/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/da1fa384856677efd97a8f456694e48d940fba53/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=da1fa384856677efd97a8f456694e48d940fba53",
        "patch": "@@ -3169,7 +3169,7 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n                         std::multimap<uint256, CDiskBlockPos>::iterator it = range.first;\n                         if (ReadBlockFromDisk(block, it->second))\n                         {\n-                            LogPrintf(\"%s: Processing out of order child %s of %s\\n\", __func__, block.GetHash().ToString(),\n+                            LogPrint(\"reindex\", \"%s: Processing out of order child %s of %s\\n\", __func__, block.GetHash().ToString(),\n                                     head.ToString());\n                             CValidationState dummy;\n                             if (ProcessBlock(dummy, NULL, &block, &it->second))"
      }
    ]
  }
]