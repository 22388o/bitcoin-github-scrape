[
  {
    "sha": "1b6e6fcfd2f8a8def148ea0f50af202d5cae318a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYjZlNmZjZmQyZjhhOGRlZjE0OGVhMGY1MGFmMjAyZDVjYWUzMThh",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-03-27T14:36:30Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-05-03T18:38:30Z"
      },
      "message": "rename: CChainState.chainActive -> m_chain\n\nThis can't be a scripted-diff due to the confusion of the global\nchainActive and the CChainState member of the same name.\n\nThis specific rename makes the following chainActive -> ::ChainActive() diff\nscriptable.",
      "tree": {
        "sha": "f1fe0e65fcc3f377b2cbe2c721985be3c9f18c3f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f1fe0e65fcc3f377b2cbe2c721985be3c9f18c3f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1b6e6fcfd2f8a8def148ea0f50af202d5cae318a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1b6e6fcfd2f8a8def148ea0f50af202d5cae318a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1b6e6fcfd2f8a8def148ea0f50af202d5cae318a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1b6e6fcfd2f8a8def148ea0f50af202d5cae318a/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "94daebf327e38ebb0c578bffbabe76961e11d9ee",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/94daebf327e38ebb0c578bffbabe76961e11d9ee",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/94daebf327e38ebb0c578bffbabe76961e11d9ee"
      }
    ],
    "stats": {
      "total": 112,
      "additions": 57,
      "deletions": 55
    },
    "files": [
      {
        "sha": "3fef0e293414dad8ca5b9f49939a999904c5ffc7",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 57,
        "deletions": 55,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b6e6fcfd2f8a8def148ea0f50af202d5cae318a/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b6e6fcfd2f8a8def148ea0f50af202d5cae318a/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=1b6e6fcfd2f8a8def148ea0f50af202d5cae318a",
        "patch": "@@ -157,7 +157,9 @@ class CChainState {\n     CCriticalSection m_cs_chainstate;\n \n public:\n-    CChain chainActive;\n+    //! The current chain of blockheaders we consult and build on.\n+    //! @see CChain, CBlockIndex.\n+    CChain m_chain;\n     BlockMap mapBlockIndex GUARDED_BY(cs_main);\n     std::multimap<CBlockIndex*, CBlockIndex*> mapBlocksUnlinked;\n     CBlockIndex *pindexBestInvalid = nullptr;\n@@ -231,7 +233,7 @@ class CChainState {\n RecursiveMutex cs_main;\n \n BlockMap& mapBlockIndex = g_chainstate.mapBlockIndex;\n-CChain& chainActive = g_chainstate.chainActive;\n+CChain& chainActive = g_chainstate.m_chain;\n CBlockIndex *pindexBestHeader = nullptr;\n Mutex g_best_block_mutex;\n std::condition_variable g_best_block_cv;\n@@ -2268,7 +2270,7 @@ void static UpdateTip(const CBlockIndex *pindexNew, const CChainParams& chainPar\n \n }\n \n-/** Disconnect chainActive's tip.\n+/** Disconnect m_chain's tip.\n   * After calling, the mempool will be in an inconsistent state, with\n   * transactions from disconnected blocks being added to disconnectpool.  You\n   * should make the mempool consistent again by calling UpdateMempoolForReorg.\n@@ -2280,7 +2282,7 @@ void static UpdateTip(const CBlockIndex *pindexNew, const CChainParams& chainPar\n   */\n bool CChainState::DisconnectTip(CValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions *disconnectpool)\n {\n-    CBlockIndex *pindexDelete = chainActive.Tip();\n+    CBlockIndex *pindexDelete = m_chain.Tip();\n     assert(pindexDelete);\n     // Read block from disk.\n     std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();\n@@ -2315,7 +2317,7 @@ bool CChainState::DisconnectTip(CValidationState& state, const CChainParams& cha\n         }\n     }\n \n-    chainActive.SetTip(pindexDelete->pprev);\n+    m_chain.SetTip(pindexDelete->pprev);\n \n     UpdateTip(pindexDelete->pprev, chainparams);\n     // Let wallets know transactions went from 1-confirmed to\n@@ -2393,14 +2395,14 @@ class ConnectTrace {\n };\n \n /**\n- * Connect a new block to chainActive. pblock is either nullptr or a pointer to a CBlock\n+ * Connect a new block to m_chain. pblock is either nullptr or a pointer to a CBlock\n  * corresponding to pindexNew, to bypass loading it again from disk.\n  *\n  * The block is added to connectTrace if connection succeeds.\n  */\n bool CChainState::ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool)\n {\n-    assert(pindexNew->pprev == chainActive.Tip());\n+    assert(pindexNew->pprev == m_chain.Tip());\n     // Read block from disk.\n     int64_t nTime1 = GetTimeMicros();\n     std::shared_ptr<const CBlock> pthisBlock;\n@@ -2441,8 +2443,8 @@ bool CChainState::ConnectTip(CValidationState& state, const CChainParams& chainp\n     // Remove conflicting transactions from the mempool.;\n     mempool.removeForBlock(blockConnecting.vtx, pindexNew->nHeight);\n     disconnectpool.removeForBlock(blockConnecting.vtx);\n-    // Update chainActive & related variables.\n-    chainActive.SetTip(pindexNew);\n+    // Update m_chain & related variables.\n+    m_chain.SetTip(pindexNew);\n     UpdateTip(pindexNew, chainparams);\n \n     int64_t nTime6 = GetTimeMicros(); nTimePostConnect += nTime6 - nTime5; nTimeTotal += nTime6 - nTime1;\n@@ -2473,7 +2475,7 @@ CBlockIndex* CChainState::FindMostWorkChain() {\n         // Just going until the active chain is an optimization, as we know all blocks in it are valid already.\n         CBlockIndex *pindexTest = pindexNew;\n         bool fInvalidAncestor = false;\n-        while (pindexTest && !chainActive.Contains(pindexTest)) {\n+        while (pindexTest && !m_chain.Contains(pindexTest)) {\n             assert(pindexTest->HaveTxsDownloaded() || pindexTest->nHeight == 0);\n \n             // Pruned nodes may have entries in setBlockIndexCandidates for\n@@ -2516,7 +2518,7 @@ void CChainState::PruneBlockIndexCandidates() {\n     // Note that we can't delete the current block itself, as we may need to return to it later in case a\n     // reorganization to a better block fails.\n     std::set<CBlockIndex*, CBlockIndexWorkComparator>::iterator it = setBlockIndexCandidates.begin();\n-    while (it != setBlockIndexCandidates.end() && setBlockIndexCandidates.value_comp()(*it, chainActive.Tip())) {\n+    while (it != setBlockIndexCandidates.end() && setBlockIndexCandidates.value_comp()(*it, m_chain.Tip())) {\n         setBlockIndexCandidates.erase(it++);\n     }\n     // Either the current tip or a successor of it we're working towards is left in setBlockIndexCandidates.\n@@ -2531,13 +2533,13 @@ bool CChainState::ActivateBestChainStep(CValidationState& state, const CChainPar\n {\n     AssertLockHeld(cs_main);\n \n-    const CBlockIndex *pindexOldTip = chainActive.Tip();\n-    const CBlockIndex *pindexFork = chainActive.FindFork(pindexMostWork);\n+    const CBlockIndex *pindexOldTip = m_chain.Tip();\n+    const CBlockIndex *pindexFork = m_chain.FindFork(pindexMostWork);\n \n     // Disconnect active blocks which are no longer in the best chain.\n     bool fBlocksDisconnected = false;\n     DisconnectedBlockTransactions disconnectpool;\n-    while (chainActive.Tip() && chainActive.Tip() != pindexFork) {\n+    while (m_chain.Tip() && m_chain.Tip() != pindexFork) {\n         if (!DisconnectTip(state, chainparams, &disconnectpool)) {\n             // This is likely a fatal error, but keep the mempool consistent,\n             // just in case. Only remove from the mempool in this case.\n@@ -2585,7 +2587,7 @@ bool CChainState::ActivateBestChainStep(CValidationState& state, const CChainPar\n                 }\n             } else {\n                 PruneBlockIndexCandidates();\n-                if (!pindexOldTip || chainActive.Tip()->nChainWork > pindexOldTip->nChainWork) {\n+                if (!pindexOldTip || m_chain.Tip()->nChainWork > pindexOldTip->nChainWork) {\n                     // We're in a better position than we were. Return temporarily to release the lock.\n                     fContinue = false;\n                     break;\n@@ -2677,7 +2679,7 @@ bool CChainState::ActivateBestChain(CValidationState &state, const CChainParams&\n \n         {\n             LOCK(cs_main);\n-            CBlockIndex* starting_tip = chainActive.Tip();\n+            CBlockIndex* starting_tip = m_chain.Tip();\n             bool blocks_connected = false;\n             do {\n                 // We absolutely may not unlock cs_main until we've made forward progress\n@@ -2689,7 +2691,7 @@ bool CChainState::ActivateBestChain(CValidationState &state, const CChainParams&\n                 }\n \n                 // Whether we have anything to do at all.\n-                if (pindexMostWork == nullptr || pindexMostWork == chainActive.Tip()) {\n+                if (pindexMostWork == nullptr || pindexMostWork == m_chain.Tip()) {\n                     break;\n                 }\n \n@@ -2703,16 +2705,16 @@ bool CChainState::ActivateBestChain(CValidationState &state, const CChainParams&\n                     // Wipe cache, we may need another branch now.\n                     pindexMostWork = nullptr;\n                 }\n-                pindexNewTip = chainActive.Tip();\n+                pindexNewTip = m_chain.Tip();\n \n                 for (const PerBlockConnectTrace& trace : connectTrace.GetBlocksConnected()) {\n                     assert(trace.pblock && trace.pindex);\n                     GetMainSignals().BlockConnected(trace.pblock, trace.pindex, trace.conflictedTxs);\n                 }\n-            } while (!chainActive.Tip() || (starting_tip && CBlockIndexWorkComparator()(chainActive.Tip(), starting_tip)));\n+            } while (!m_chain.Tip() || (starting_tip && CBlockIndexWorkComparator()(m_chain.Tip(), starting_tip)));\n             if (!blocks_connected) return true;\n \n-            const CBlockIndex* pindexFork = chainActive.FindFork(starting_tip);\n+            const CBlockIndex* pindexFork = m_chain.FindFork(starting_tip);\n             bool fInitialDownload = IsInitialBlockDownload();\n \n             // Notify external listeners about the new tip.\n@@ -2754,15 +2756,15 @@ bool CChainState::PreciousBlock(CValidationState& state, const CChainParams& par\n {\n     {\n         LOCK(cs_main);\n-        if (pindex->nChainWork < chainActive.Tip()->nChainWork) {\n+        if (pindex->nChainWork < m_chain.Tip()->nChainWork) {\n             // Nothing to do, this block is not at the tip.\n             return true;\n         }\n-        if (chainActive.Tip()->nChainWork > nLastPreciousChainwork) {\n+        if (m_chain.Tip()->nChainWork > nLastPreciousChainwork) {\n             // The chain has been extended since the last call, reset the counter.\n             nBlockReverseSequenceId = -1;\n         }\n-        nLastPreciousChainwork = chainActive.Tip()->nChainWork;\n+        nLastPreciousChainwork = m_chain.Tip()->nChainWork;\n         setBlockIndexCandidates.erase(pindex);\n         pindex->nSequenceId = nBlockReverseSequenceId;\n         if (nBlockReverseSequenceId > std::numeric_limits<int32_t>::min()) {\n@@ -2796,11 +2798,11 @@ bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& c\n         LimitValidationInterfaceQueue();\n \n         LOCK(cs_main);\n-        if (!chainActive.Contains(pindex)) break;\n+        if (!m_chain.Contains(pindex)) break;\n         pindex_was_in_chain = true;\n-        CBlockIndex *invalid_walk_tip = chainActive.Tip();\n+        CBlockIndex *invalid_walk_tip = m_chain.Tip();\n \n-        // ActivateBestChain considers blocks already in chainActive\n+        // ActivateBestChain considers blocks already in m_chain\n         // unconditionally valid already, so force disconnect away from it.\n         DisconnectedBlockTransactions disconnectpool;\n         bool ret = DisconnectTip(state, chainparams, &disconnectpool);\n@@ -2811,7 +2813,7 @@ bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& c\n         // keeping the mempool up to date is probably futile anyway).\n         UpdateMempoolForReorg(disconnectpool, /* fAddToMempool = */ (++disconnected <= 10) && ret);\n         if (!ret) return false;\n-        assert(invalid_walk_tip->pprev == chainActive.Tip());\n+        assert(invalid_walk_tip->pprev == m_chain.Tip());\n \n         // We immediately mark the disconnected blocks as invalid.\n         // This prevents a case where pruned nodes may fail to invalidateblock\n@@ -2836,7 +2838,7 @@ bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& c\n \n     {\n         LOCK(cs_main);\n-        if (chainActive.Contains(to_mark_failed)) {\n+        if (m_chain.Contains(to_mark_failed)) {\n             // If the to-be-marked invalid block is in the active chain, something is interfering and we can't proceed.\n             return false;\n         }\n@@ -2851,7 +2853,7 @@ bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& c\n         // add it again.\n         BlockMap::iterator it = mapBlockIndex.begin();\n         while (it != mapBlockIndex.end()) {\n-            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && !setBlockIndexCandidates.value_comp()(it->second, chainActive.Tip())) {\n+            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && !setBlockIndexCandidates.value_comp()(it->second, m_chain.Tip())) {\n                 setBlockIndexCandidates.insert(it->second);\n             }\n             it++;\n@@ -2882,7 +2884,7 @@ void CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {\n         if (!it->second->IsValid() && it->second->GetAncestor(nHeight) == pindex) {\n             it->second->nStatus &= ~BLOCK_FAILED_MASK;\n             setDirtyBlockIndex.insert(it->second);\n-            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && setBlockIndexCandidates.value_comp()(chainActive.Tip(), it->second)) {\n+            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && setBlockIndexCandidates.value_comp()(m_chain.Tip(), it->second)) {\n                 setBlockIndexCandidates.insert(it->second);\n             }\n             if (it->second == pindexBestInvalid) {\n@@ -2974,7 +2976,7 @@ void CChainState::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pi\n                 LOCK(cs_nBlockSequenceId);\n                 pindex->nSequenceId = nBlockSequenceId++;\n             }\n-            if (chainActive.Tip() == nullptr || !setBlockIndexCandidates.value_comp()(pindex, chainActive.Tip())) {\n+            if (m_chain.Tip() == nullptr || !setBlockIndexCandidates.value_comp()(pindex, m_chain.Tip())) {\n                 setBlockIndexCandidates.insert(pindex);\n             }\n             std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = mapBlocksUnlinked.equal_range(pindex);\n@@ -3494,13 +3496,13 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n     // process an unrequested block if it's new and has enough work to\n     // advance our tip, and isn't too many blocks ahead.\n     bool fAlreadyHave = pindex->nStatus & BLOCK_HAVE_DATA;\n-    bool fHasMoreOrSameWork = (chainActive.Tip() ? pindex->nChainWork >= chainActive.Tip()->nChainWork : true);\n+    bool fHasMoreOrSameWork = (m_chain.Tip() ? pindex->nChainWork >= m_chain.Tip()->nChainWork : true);\n     // Blocks that are too out-of-order needlessly limit the effectiveness of\n     // pruning, because pruning will not delete block files that contain any\n     // blocks which are too close in height to the tip.  Apply this test\n     // regardless of whether pruning is enabled; it should generally be safe to\n     // not process unrequested blocks.\n-    bool fTooFarAhead = (pindex->nHeight > int(chainActive.Height() + MIN_BLOCKS_TO_KEEP));\n+    bool fTooFarAhead = (pindex->nHeight > int(m_chain.Height() + MIN_BLOCKS_TO_KEEP));\n \n     // TODO: Decouple this function from the block download logic by removing fRequested\n     // This requires some new chain data structure to efficiently look up if a\n@@ -3533,7 +3535,7 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n \n     // Header is valid/has work, merkle tree and segwit merkle tree are good...RELAY NOW\n     // (but if it does not build on our best tip, let the SendMessages loop relay it)\n-    if (!IsInitialBlockDownload() && chainActive.Tip() == pindex->pprev)\n+    if (!IsInitialBlockDownload() && m_chain.Tip() == pindex->pprev)\n         GetMainSignals().NewPoWValidBlock(pindex, pblock);\n \n     // Write block to history file\n@@ -4165,7 +4167,7 @@ bool ReplayBlocks(const CChainParams& params, CCoinsView* view) {\n void CChainState::EraseBlockData(CBlockIndex* index)\n {\n     AssertLockHeld(cs_main);\n-    assert(!chainActive.Contains(index)); // Make sure this block isn't active\n+    assert(!m_chain.Contains(index)); // Make sure this block isn't active\n \n     // Reduce validity\n     index->nStatus = std::min<unsigned int>(index->nStatus & BLOCK_VALID_MASK, BLOCK_VALID_TREE) | (index->nStatus & ~BLOCK_VALID_MASK);\n@@ -4199,15 +4201,15 @@ void CChainState::EraseBlockData(CBlockIndex* index)\n \n bool CChainState::RewindBlockIndex(const CChainParams& params)\n {\n-    // Note that during -reindex-chainstate we are called with an empty chainActive!\n+    // Note that during -reindex-chainstate we are called with an empty m_chain!\n \n     // First erase all post-segwit blocks without witness not in the main chain,\n     // as this can we done without costly DisconnectTip calls. Active\n     // blocks will be dealt with below (releasing cs_main in between).\n     {\n         LOCK(cs_main);\n         for (const auto& entry : mapBlockIndex) {\n-            if (IsWitnessEnabled(entry.second->pprev, params.GetConsensus()) && !(entry.second->nStatus & BLOCK_OPT_WITNESS) && !chainActive.Contains(entry.second)) {\n+            if (IsWitnessEnabled(entry.second->pprev, params.GetConsensus()) && !(entry.second->nStatus & BLOCK_OPT_WITNESS) && !m_chain.Contains(entry.second)) {\n                 EraseBlockData(entry.second);\n             }\n         }\n@@ -4218,17 +4220,17 @@ bool CChainState::RewindBlockIndex(const CChainParams& params)\n     int nHeight = 1;\n     {\n         LOCK(cs_main);\n-        while (nHeight <= chainActive.Height()) {\n+        while (nHeight <= m_chain.Height()) {\n             // Although SCRIPT_VERIFY_WITNESS is now generally enforced on all\n             // blocks in ConnectBlock, we don't need to go back and\n             // re-download/re-verify blocks from before segwit actually activated.\n-            if (IsWitnessEnabled(chainActive[nHeight - 1], params.GetConsensus()) && !(chainActive[nHeight]->nStatus & BLOCK_OPT_WITNESS)) {\n+            if (IsWitnessEnabled(m_chain[nHeight - 1], params.GetConsensus()) && !(m_chain[nHeight]->nStatus & BLOCK_OPT_WITNESS)) {\n                 break;\n             }\n             nHeight++;\n         }\n \n-        tip = chainActive.Tip();\n+        tip = m_chain.Tip();\n     }\n     // nHeight is now the height of the first insufficiently-validated block, or tipheight + 1\n \n@@ -4238,7 +4240,7 @@ bool CChainState::RewindBlockIndex(const CChainParams& params)\n         {\n             LOCK(cs_main);\n             // Make sure nothing changed from under us (this won't happen because RewindBlockIndex runs before importing/network are active)\n-            assert(tip == chainActive.Tip());\n+            assert(tip == m_chain.Tip());\n             if (tip == nullptr || tip->nHeight < nHeight) break;\n             if (fPruneMode && !(tip->nStatus & BLOCK_HAVE_DATA)) {\n                 // If pruning, don't try rewinding past the HAVE_DATA point;\n@@ -4258,9 +4260,9 @@ bool CChainState::RewindBlockIndex(const CChainParams& params)\n             // We do this after actual disconnecting, otherwise we'll end up writing the lack of data\n             // to disk before writing the chainstate, resulting in a failure to continue if interrupted.\n             // Note: If we encounter an insufficiently validated block that\n-            // is on chainActive, it must be because we are a pruning node, and\n+            // is on m_chain, it must be because we are a pruning node, and\n             // this block or some successor doesn't HAVE_DATA, so we were unable to\n-            // rewind all the way.  Blocks remaining on chainActive at this point\n+            // rewind all the way.  Blocks remaining on m_chain at this point\n             // must not have their validity reduced.\n             EraseBlockData(tip);\n \n@@ -4278,9 +4280,9 @@ bool CChainState::RewindBlockIndex(const CChainParams& params)\n \n     {\n         LOCK(cs_main);\n-        if (chainActive.Tip() != nullptr) {\n+        if (m_chain.Tip() != nullptr) {\n             // We can't prune block index candidates based on our tip if we have\n-            // no tip due to chainActive being empty!\n+            // no tip due to m_chain being empty!\n             PruneBlockIndexCandidates();\n \n             CheckBlockIndex(params.GetConsensus());\n@@ -4371,7 +4373,7 @@ bool CChainState::LoadGenesisBlock(const CChainParams& chainparams)\n     LOCK(cs_main);\n \n     // Check whether we're already initialized by checking for genesis in\n-    // mapBlockIndex. Note that we can't use chainActive here, since it is\n+    // mapBlockIndex. Note that we can't use m_chain here, since it is\n     // set based on the coins db, not the block index db, which is the only\n     // thing loaded at this point.\n     if (mapBlockIndex.count(chainparams.GenesisBlock().GetHash()))\n@@ -4528,8 +4530,8 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n \n     // During a reindex, we read the genesis block and call CheckBlockIndex before ActivateBestChain,\n     // so we have the genesis block in mapBlockIndex but no active chain.  (A few of the tests when\n-    // iterating the block tree require that chainActive has been initialized.)\n-    if (chainActive.Height() < 0) {\n+    // iterating the block tree require that m_chain has been initialized.)\n+    if (m_chain.Height() < 0) {\n         assert(mapBlockIndex.size() <= 1);\n         return;\n     }\n@@ -4573,7 +4575,7 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n         if (pindex->pprev == nullptr) {\n             // Genesis block checks.\n             assert(pindex->GetBlockHash() == consensusParams.hashGenesisBlock); // Genesis block's hash must match.\n-            assert(pindex == chainActive.Genesis()); // The current active chain's genesis block must be this block.\n+            assert(pindex == m_chain.Genesis()); // The current active chain's genesis block must be this block.\n         }\n         if (!pindex->HaveTxsDownloaded()) assert(pindex->nSequenceId <= 0); // nSequenceId can't be set positive for blocks that aren't linked (negative is used for preciousblock)\n         // VALID_TRANSACTIONS is equivalent to nTx > 0 for all nodes (whether or not pruning has occurred).\n@@ -4602,13 +4604,13 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n             // Checks for not-invalid blocks.\n             assert((pindex->nStatus & BLOCK_FAILED_MASK) == 0); // The failed mask cannot be set for blocks without invalid parents.\n         }\n-        if (!CBlockIndexWorkComparator()(pindex, chainActive.Tip()) && pindexFirstNeverProcessed == nullptr) {\n+        if (!CBlockIndexWorkComparator()(pindex, m_chain.Tip()) && pindexFirstNeverProcessed == nullptr) {\n             if (pindexFirstInvalid == nullptr) {\n                 // If this block sorts at least as good as the current tip and\n                 // is valid and we have all data for its parents, it must be in\n-                // setBlockIndexCandidates.  chainActive.Tip() must also be there\n+                // setBlockIndexCandidates.  m_chain.Tip() must also be there\n                 // even if some data has been pruned.\n-                if (pindexFirstMissing == nullptr || pindex == chainActive.Tip()) {\n+                if (pindexFirstMissing == nullptr || pindex == m_chain.Tip()) {\n                     assert(setBlockIndexCandidates.count(pindex));\n                 }\n                 // If some parent is missing, then it could be that this block was in\n@@ -4642,11 +4644,11 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n             //  - it has a descendant that at some point had more work than the\n             //    tip, and\n             //  - we tried switching to that descendant but were missing\n-            //    data for some intermediate block between chainActive and the\n+            //    data for some intermediate block between m_chain and the\n             //    tip.\n-            // So if this block is itself better than chainActive.Tip() and it wasn't in\n+            // So if this block is itself better than m_chain.Tip() and it wasn't in\n             // setBlockIndexCandidates, then it must be in mapBlocksUnlinked.\n-            if (!CBlockIndexWorkComparator()(pindex, chainActive.Tip()) && setBlockIndexCandidates.count(pindex) == 0) {\n+            if (!CBlockIndexWorkComparator()(pindex, m_chain.Tip()) && setBlockIndexCandidates.count(pindex) == 0) {\n                 if (pindexFirstInvalid == nullptr) {\n                     assert(foundInUnlinked);\n                 }"
      }
    ]
  },
  {
    "sha": "a3a609079c76dd2bbc72127488bf466cc61d8940",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphM2E2MDkwNzljNzZkZDJiYmM3MjEyNzQ4OGJmNDY2Y2M2MWQ4OTQw",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-03-27T14:55:57Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-05-03T18:38:38Z"
      },
      "message": "refactoring: introduce unused ChainActive()\n\nin preparation for the following scripted-diff commit.",
      "tree": {
        "sha": "6e1dd1993f60b0d3cdf5fedbc396f0fb57921d2d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6e1dd1993f60b0d3cdf5fedbc396f0fb57921d2d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a3a609079c76dd2bbc72127488bf466cc61d8940",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a3a609079c76dd2bbc72127488bf466cc61d8940",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a3a609079c76dd2bbc72127488bf466cc61d8940",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a3a609079c76dd2bbc72127488bf466cc61d8940/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1b6e6fcfd2f8a8def148ea0f50af202d5cae318a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1b6e6fcfd2f8a8def148ea0f50af202d5cae318a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1b6e6fcfd2f8a8def148ea0f50af202d5cae318a"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 5,
      "deletions": 0
    },
    "files": [
      {
        "sha": "ec9f9c6100db226b48cbc8b9940313dbe5110e64",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a3a609079c76dd2bbc72127488bf466cc61d8940/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a3a609079c76dd2bbc72127488bf466cc61d8940/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=a3a609079c76dd2bbc72127488bf466cc61d8940",
        "patch": "@@ -220,6 +220,8 @@ class CChainState {\n     void EraseBlockData(CBlockIndex* index) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n } g_chainstate;\n \n+CChain& ChainActive() { return g_chainstate.m_chain; }\n+\n /**\n  * Mutex to guard access to validation specific variables, such as reading\n  * or changing the chainstate."
      },
      {
        "sha": "cec6c7d003647a377f1c76c512aa037d95b6c895",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a3a609079c76dd2bbc72127488bf466cc61d8940/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a3a609079c76dd2bbc72127488bf466cc61d8940/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=a3a609079c76dd2bbc72127488bf466cc61d8940",
        "patch": "@@ -438,6 +438,9 @@ void ResetBlockFailureFlags(CBlockIndex* pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_mai\n /** The currently-connected chain of blocks (protected by cs_main). */\n extern CChain& chainActive;\n \n+/** @returns the most-work chain. */\n+CChain& ChainActive();\n+\n /** Global variable that points to the coins database (protected by cs_main) */\n extern std::unique_ptr<CCoinsViewDB> pcoinsdbview;\n "
      }
    ]
  },
  {
    "sha": "631940aab228ccca64c15e05d5953f40381a0ffc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MzE5NDBhYWIyMjhjY2NhNjRjMTVlMDVkNTk1M2Y0MDM4MWEwZmZj",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-03-27T15:14:25Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-05-03T19:02:54Z"
      },
      "message": "scripted-diff: replace chainActive -> ::ChainActive()\n\nThough at the moment ChainActive() simply references `g_chainstate.m_chain`,\ndoing this change now clears the way for multiple chainstate usage and allows\nus to script the diff.\n\n-BEGIN VERIFY SCRIPT-\ngit grep -l \"chainActive\" | grep -E '(h|cpp)$' | xargs sed -i '/chainActive =/b; /extern CChain& chainActive/b; s/\\(::\\)\\{0,1\\}chainActive/::ChainActive()/g'\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "694cfe15bf0a6d9271fc9b6c10fda5a77c935580",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/694cfe15bf0a6d9271fc9b6c10fda5a77c935580"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/631940aab228ccca64c15e05d5953f40381a0ffc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/631940aab228ccca64c15e05d5953f40381a0ffc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/631940aab228ccca64c15e05d5953f40381a0ffc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/631940aab228ccca64c15e05d5953f40381a0ffc/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a3a609079c76dd2bbc72127488bf466cc61d8940",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a3a609079c76dd2bbc72127488bf466cc61d8940",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a3a609079c76dd2bbc72127488bf466cc61d8940"
      }
    ],
    "stats": {
      "total": 494,
      "additions": 247,
      "deletions": 247
    },
    "files": [
      {
        "sha": "d0e010954699cbcbe9e1b12b373ae560d6f5eb17",
        "filename": "src/bench/bench.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/bench/bench.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/bench/bench.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -114,8 +114,8 @@ void benchmark::BenchRunner::RunAll(Printer& printer, uint64_t num_evals, double\n     for (const auto& p : benchmarks()) {\n         TestingSetup test{CBaseChainParams::REGTEST};\n         {\n-            assert(::chainActive.Height() == 0);\n-            const bool witness_enabled{IsWitnessEnabled(::chainActive.Tip(), Params().GetConsensus())};\n+            assert(::ChainActive().Height() == 0);\n+            const bool witness_enabled{IsWitnessEnabled(::ChainActive().Tip(), Params().GetConsensus())};\n             assert(witness_enabled);\n         }\n "
      },
      {
        "sha": "aa3f219b184d6ccda4fc97ea7f6719666f12ade5",
        "filename": "src/bench/duplicate_inputs.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/bench/duplicate_inputs.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/bench/duplicate_inputs.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/duplicate_inputs.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -29,7 +29,7 @@ static void DuplicateInputs(benchmark::State& state)\n     CMutableTransaction coinbaseTx{};\n     CMutableTransaction naughtyTx{};\n \n-    CBlockIndex* pindexPrev = ::chainActive.Tip();\n+    CBlockIndex* pindexPrev = ::ChainActive().Tip();\n     assert(pindexPrev != nullptr);\n     block.nBits = GetNextWorkRequired(pindexPrev, &block, chainparams.GetConsensus());\n     block.nNonce = 0;"
      },
      {
        "sha": "bcc8e2ce7c68c32c9ea922fc858ca152f7f04f80",
        "filename": "src/index/base.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/index/base.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/index/base.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/base.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -63,9 +63,9 @@ bool BaseIndex::Init()\n     if (locator.IsNull()) {\n         m_best_block_index = nullptr;\n     } else {\n-        m_best_block_index = FindForkInGlobalIndex(chainActive, locator);\n+        m_best_block_index = FindForkInGlobalIndex(::ChainActive(), locator);\n     }\n-    m_synced = m_best_block_index.load() == chainActive.Tip();\n+    m_synced = m_best_block_index.load() == ::ChainActive().Tip();\n     return true;\n }\n \n@@ -74,15 +74,15 @@ static const CBlockIndex* NextSyncBlock(const CBlockIndex* pindex_prev) EXCLUSIV\n     AssertLockHeld(cs_main);\n \n     if (!pindex_prev) {\n-        return chainActive.Genesis();\n+        return ::ChainActive().Genesis();\n     }\n \n-    const CBlockIndex* pindex = chainActive.Next(pindex_prev);\n+    const CBlockIndex* pindex = ::ChainActive().Next(pindex_prev);\n     if (pindex) {\n         return pindex;\n     }\n \n-    return chainActive.Next(chainActive.FindFork(pindex_prev));\n+    return ::ChainActive().Next(::ChainActive().FindFork(pindex_prev));\n }\n \n void BaseIndex::ThreadSync()\n@@ -168,7 +168,7 @@ bool BaseIndex::Commit()\n bool BaseIndex::CommitInternal(CDBBatch& batch)\n {\n     LOCK(cs_main);\n-    GetDB().WriteBestBlock(batch, chainActive.GetLocator(m_best_block_index));\n+    GetDB().WriteBestBlock(batch, ::ChainActive().GetLocator(m_best_block_index));\n     return true;\n }\n \n@@ -280,9 +280,9 @@ bool BaseIndex::BlockUntilSyncedToCurrentChain()\n \n     {\n         // Skip the queue-draining stuff if we know we're caught up with\n-        // chainActive.Tip().\n+        // ::ChainActive().Tip().\n         LOCK(cs_main);\n-        const CBlockIndex* chain_tip = chainActive.Tip();\n+        const CBlockIndex* chain_tip = ::ChainActive().Tip();\n         const CBlockIndex* best_block_index = m_best_block_index.load();\n         if (best_block_index->GetAncestor(chain_tip->nHeight) == chain_tip) {\n             return true;"
      },
      {
        "sha": "929b85bfb5eddd5e1bcbab2a77507086a9010c90",
        "filename": "src/index/txindex.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/index/txindex.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/index/txindex.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -236,7 +236,7 @@ bool TxIndex::Init()\n     // Attempt to migrate txindex from the old database to the new one. Even if\n     // chain_tip is null, the node could be reindexing and we still want to\n     // delete txindex records in the old database.\n-    if (!m_db->MigrateData(*pblocktree, chainActive.GetLocator())) {\n+    if (!m_db->MigrateData(*pblocktree, ::ChainActive().GetLocator())) {\n         return false;\n     }\n "
      },
      {
        "sha": "8095105cce38f453a981da5fc08ac7735a883c3d",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -490,7 +490,7 @@ void SetupServerArgs()\n         \"and level 4 tries to reconnect the blocks, \"\n         \"each level includes the checks of the previous levels \"\n         \"(0-4, default: %u)\", DEFAULT_CHECKLEVEL), true, OptionsCategory::DEBUG_TEST);\n-    gArgs.AddArg(\"-checkblockindex\", strprintf(\"Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive and mapBlocksUnlinked occasionally. (default: %u, regtest: %u)\", defaultChainParams->DefaultConsistencyChecks(), regtestChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-checkblockindex\", strprintf(\"Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, ::ChainActive() and mapBlocksUnlinked occasionally. (default: %u, regtest: %u)\", defaultChainParams->DefaultConsistencyChecks(), regtestChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);\n     gArgs.AddArg(\"-checkmempool=<n>\", strprintf(\"Run checks every <n> transactions (default: %u, regtest: %u)\", defaultChainParams->DefaultConsistencyChecks(), regtestChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);\n     gArgs.AddArg(\"-checkpoints\", strprintf(\"Disable expensive verification for known chain history (default: %u)\", DEFAULT_CHECKPOINTS_ENABLED), true, OptionsCategory::DEBUG_TEST);\n     gArgs.AddArg(\"-deprecatedrpc=<method>\", \"Allows deprecated RPC method(s) to be used\", true, OptionsCategory::DEBUG_TEST);\n@@ -1572,12 +1572,12 @@ bool AppInitMain(InitInterfaces& interfaces)\n \n                 is_coinsview_empty = fReset || fReindexChainState || pcoinsTip->GetBestBlock().IsNull();\n                 if (!is_coinsview_empty) {\n-                    // LoadChainTip sets chainActive based on pcoinsTip's best block\n+                    // LoadChainTip sets ::ChainActive() based on pcoinsTip's best block\n                     if (!LoadChainTip(chainparams)) {\n                         strLoadError = _(\"Error initializing block database\");\n                         break;\n                     }\n-                    assert(chainActive.Tip() != nullptr);\n+                    assert(::ChainActive().Tip() != nullptr);\n                 }\n             } catch (const std::exception& e) {\n                 LogPrintf(\"%s\\n\", e.what());\n@@ -1587,7 +1587,7 @@ bool AppInitMain(InitInterfaces& interfaces)\n \n             if (!fReset) {\n                 // Note that RewindBlockIndex MUST run even if we're about to -reindex-chainstate.\n-                // It both disconnects blocks based on chainActive, and drops block data in\n+                // It both disconnects blocks based on ::ChainActive(), and drops block data in\n                 // mapBlockIndex based on lack of available witness data.\n                 uiInterface.InitMessage(_(\"Rewinding blocks...\"));\n                 if (!RewindBlockIndex(chainparams)) {\n@@ -1605,7 +1605,7 @@ bool AppInitMain(InitInterfaces& interfaces)\n                             MIN_BLOCKS_TO_KEEP);\n                     }\n \n-                    CBlockIndex* tip = chainActive.Tip();\n+                    CBlockIndex* tip = ::ChainActive().Tip();\n                     RPCNotifyBlockChange(true, tip);\n                     if (tip && tip->nTime > GetAdjustedTime() + 2 * 60 * 60) {\n                         strLoadError = _(\"The block database contains a block which appears to be from the future. \"\n@@ -1719,7 +1719,7 @@ bool AppInitMain(InitInterfaces& interfaces)\n     // Either install a handler to notify us when genesis activates, or set fHaveGenesis directly.\n     // No locking, as this happens before any background thread is started.\n     boost::signals2::connection block_notify_genesis_wait_connection;\n-    if (chainActive.Tip() == nullptr) {\n+    if (::ChainActive().Tip() == nullptr) {\n         block_notify_genesis_wait_connection = uiInterface.NotifyBlockTip_connect(BlockNotifyGenesisWait);\n     } else {\n         fHaveGenesis = true;\n@@ -1759,7 +1759,7 @@ bool AppInitMain(InitInterfaces& interfaces)\n     {\n         LOCK(cs_main);\n         LogPrintf(\"mapBlockIndex.size() = %u\\n\", mapBlockIndex.size());\n-        chain_active_height = chainActive.Height();\n+        chain_active_height = ::ChainActive().Height();\n     }\n     LogPrintf(\"nBestHeight = %d\\n\", chain_active_height);\n "
      },
      {
        "sha": "fcbc442d124f3e1ab03372123f2d4c8a1325c71d",
        "filename": "src/interfaces/chain.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/interfaces/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/interfaces/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -41,7 +41,7 @@ class LockImpl : public Chain::Lock\n {\n     Optional<int> getHeight() override\n     {\n-        int height = ::chainActive.Height();\n+        int height = ::ChainActive().Height();\n         if (height >= 0) {\n             return height;\n         }\n@@ -50,7 +50,7 @@ class LockImpl : public Chain::Lock\n     Optional<int> getBlockHeight(const uint256& hash) override\n     {\n         CBlockIndex* block = LookupBlockIndex(hash);\n-        if (block && ::chainActive.Contains(block)) {\n+        if (block && ::ChainActive().Contains(block)) {\n             return block->nHeight;\n         }\n         return nullopt;\n@@ -63,30 +63,30 @@ class LockImpl : public Chain::Lock\n     }\n     uint256 getBlockHash(int height) override\n     {\n-        CBlockIndex* block = ::chainActive[height];\n+        CBlockIndex* block = ::ChainActive()[height];\n         assert(block != nullptr);\n         return block->GetBlockHash();\n     }\n     int64_t getBlockTime(int height) override\n     {\n-        CBlockIndex* block = ::chainActive[height];\n+        CBlockIndex* block = ::ChainActive()[height];\n         assert(block != nullptr);\n         return block->GetBlockTime();\n     }\n     int64_t getBlockMedianTimePast(int height) override\n     {\n-        CBlockIndex* block = ::chainActive[height];\n+        CBlockIndex* block = ::ChainActive()[height];\n         assert(block != nullptr);\n         return block->GetMedianTimePast();\n     }\n     bool haveBlockOnDisk(int height) override\n     {\n-        CBlockIndex* block = ::chainActive[height];\n+        CBlockIndex* block = ::ChainActive()[height];\n         return block && ((block->nStatus & BLOCK_HAVE_DATA) != 0) && block->nTx > 0;\n     }\n     Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height, uint256* hash) override\n     {\n-        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time, height);\n+        CBlockIndex* block = ::ChainActive().FindEarliestAtLeast(time, height);\n         if (block) {\n             if (hash) *hash = block->GetBlockHash();\n             return block->nHeight;\n@@ -96,7 +96,7 @@ class LockImpl : public Chain::Lock\n     Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n     {\n         if (::fPruneMode) {\n-            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            CBlockIndex* block = stop_height ? ::ChainActive()[*stop_height] : ::ChainActive().Tip();\n             while (block && block->nHeight >= start_height) {\n                 if ((block->nStatus & BLOCK_HAVE_DATA) == 0) {\n                     return block->nHeight;\n@@ -109,7 +109,7 @@ class LockImpl : public Chain::Lock\n     Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n     {\n         const CBlockIndex* block = LookupBlockIndex(hash);\n-        const CBlockIndex* fork = block ? ::chainActive.FindFork(block) : nullptr;\n+        const CBlockIndex* fork = block ? ::ChainActive().FindFork(block) : nullptr;\n         if (height) {\n             if (block) {\n                 *height = block->nHeight;\n@@ -122,11 +122,11 @@ class LockImpl : public Chain::Lock\n         }\n         return nullopt;\n     }\n-    CBlockLocator getTipLocator() override { return ::chainActive.GetLocator(); }\n+    CBlockLocator getTipLocator() override { return ::ChainActive().GetLocator(); }\n     Optional<int> findLocatorFork(const CBlockLocator& locator) override\n     {\n         LockAnnotation lock(::cs_main);\n-        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::ChainActive(), locator)) {\n             return fork->nHeight;\n         }\n         return nullopt;\n@@ -341,9 +341,9 @@ class ChainImpl : public Chain\n     {\n         if (!old_tip.IsNull()) {\n             LOCK(::cs_main);\n-            if (old_tip == ::chainActive.Tip()->GetBlockHash()) return;\n+            if (old_tip == ::ChainActive().Tip()->GetBlockHash()) return;\n             CBlockIndex* block = LookupBlockIndex(old_tip);\n-            if (block && block->GetAncestor(::chainActive.Height()) == ::chainActive.Tip()) return;\n+            if (block && block->GetAncestor(::ChainActive().Height()) == ::ChainActive().Tip()) return;\n         }\n         SyncWithValidationInterfaceQueue();\n     }"
      },
      {
        "sha": "618cd02ea66faa2658a4ef6e1259a0a411ff718f",
        "filename": "src/interfaces/node.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/interfaces/node.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/interfaces/node.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/node.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -178,13 +178,13 @@ class NodeImpl : public Node\n     int getNumBlocks() override\n     {\n         LOCK(::cs_main);\n-        return ::chainActive.Height();\n+        return ::ChainActive().Height();\n     }\n     int64_t getLastBlockTime() override\n     {\n         LOCK(::cs_main);\n-        if (::chainActive.Tip()) {\n-            return ::chainActive.Tip()->GetBlockTime();\n+        if (::ChainActive().Tip()) {\n+            return ::ChainActive().Tip()->GetBlockTime();\n         }\n         return Params().GenesisBlock().GetBlockTime(); // Genesis block's time of current network\n     }\n@@ -193,7 +193,7 @@ class NodeImpl : public Node\n         const CBlockIndex* tip;\n         {\n             LOCK(::cs_main);\n-            tip = ::chainActive.Tip();\n+            tip = ::ChainActive().Tip();\n         }\n         return GuessVerificationProgress(Params().TxData(), tip);\n     }"
      },
      {
        "sha": "3d53515435de443ddbbe8f3769f817f7862fd85b",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -109,7 +109,7 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n     pblocktemplate->vTxSigOpsCost.push_back(-1); // updated at end\n \n     LOCK2(cs_main, mempool.cs);\n-    CBlockIndex* pindexPrev = chainActive.Tip();\n+    CBlockIndex* pindexPrev = ::ChainActive().Tip();\n     assert(pindexPrev != nullptr);\n     nHeight = pindexPrev->nHeight + 1;\n "
      },
      {
        "sha": "9da8364ae4f4075867cafccb26b380fd4ff19762",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 45,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -570,7 +570,7 @@ static bool TipMayBeStale(const Consensus::Params &consensusParams) EXCLUSIVE_LO\n \n static bool CanDirectFetch(const Consensus::Params &consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    return chainActive.Tip()->GetBlockTime() > GetAdjustedTime() - consensusParams.nPowTargetSpacing * 20;\n+    return ::ChainActive().Tip()->GetBlockTime() > GetAdjustedTime() - consensusParams.nPowTargetSpacing * 20;\n }\n \n static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n@@ -596,15 +596,15 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     // Make sure pindexBestKnownBlock is up to date, we'll need it.\n     ProcessBlockAvailability(nodeid);\n \n-    if (state->pindexBestKnownBlock == nullptr || state->pindexBestKnownBlock->nChainWork < chainActive.Tip()->nChainWork || state->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n+    if (state->pindexBestKnownBlock == nullptr || state->pindexBestKnownBlock->nChainWork < ::ChainActive().Tip()->nChainWork || state->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n         // This peer has nothing interesting.\n         return;\n     }\n \n     if (state->pindexLastCommonBlock == nullptr) {\n         // Bootstrap quickly by guessing a parent of our best tip is the forking point.\n         // Guessing wrong in either direction is not a problem.\n-        state->pindexLastCommonBlock = chainActive[std::min(state->pindexBestKnownBlock->nHeight, chainActive.Height())];\n+        state->pindexLastCommonBlock = ::ChainActive()[std::min(state->pindexBestKnownBlock->nHeight, ::ChainActive().Height())];\n     }\n \n     // If the peer reorganized, our previous pindexLastCommonBlock may not be an ancestor\n@@ -646,7 +646,7 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n                 // We wouldn't download this block or its descendants from this peer.\n                 return;\n             }\n-            if (pindex->nStatus & BLOCK_HAVE_DATA || chainActive.Contains(pindex)) {\n+            if (pindex->nStatus & BLOCK_HAVE_DATA || ::ChainActive().Contains(pindex)) {\n                 if (pindex->HaveTxsDownloaded())\n                     state->pindexLastCommonBlock = pindex;\n             } else if (mapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n@@ -978,7 +978,7 @@ void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIV\n static bool BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     AssertLockHeld(cs_main);\n-    if (chainActive.Contains(pindex)) return true;\n+    if (::ChainActive().Contains(pindex)) return true;\n     return pindex->IsValid(BLOCK_VALID_SCRIPTS) && (pindexBestHeader != nullptr) &&\n         (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() < STALE_RELAY_AGE_LIMIT) &&\n         (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, consensusParams) < STALE_RELAY_AGE_LIMIT);\n@@ -1090,7 +1090,7 @@ void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std:\n \n /**\n  * Update our best height and announce any block hashes which weren't previously\n- * in chainActive to our peers.\n+ * in ::ChainActive() to our peers.\n  */\n void PeerLogicValidation::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) {\n     const int nNewHeight = pindexNew->nHeight;\n@@ -1173,13 +1173,13 @@ bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n     case MSG_WITNESS_TX:\n         {\n             assert(recentRejects);\n-            if (chainActive.Tip()->GetBlockHash() != hashRecentRejectsChainTip)\n+            if (::ChainActive().Tip()->GetBlockHash() != hashRecentRejectsChainTip)\n             {\n                 // If the chain tip has changed previously rejected transactions\n                 // might be now valid, e.g. due to a nLockTime'd tx becoming valid,\n                 // or a double-spend. Reset the rejects filter and give those\n                 // txs a second chance.\n-                hashRecentRejectsChainTip = chainActive.Tip()->GetBlockHash();\n+                hashRecentRejectsChainTip = ::ChainActive().Tip()->GetBlockHash();\n                 recentRejects->reset();\n             }\n \n@@ -1304,7 +1304,7 @@ void static ProcessGetBlockData(CNode* pfrom, const CChainParams& chainparams, c\n     }\n     // Avoid leaking prune-height by never sending blocks below the NODE_NETWORK_LIMITED threshold\n     if (send && !pfrom->fWhitelisted && (\n-            (((pfrom->GetLocalServices() & NODE_NETWORK_LIMITED) == NODE_NETWORK_LIMITED) && ((pfrom->GetLocalServices() & NODE_NETWORK) != NODE_NETWORK) && (chainActive.Tip()->nHeight - pindex->nHeight > (int)NODE_NETWORK_LIMITED_MIN_BLOCKS + 2 /* add two blocks buffer extension for possible races */) )\n+            (((pfrom->GetLocalServices() & NODE_NETWORK_LIMITED) == NODE_NETWORK_LIMITED) && ((pfrom->GetLocalServices() & NODE_NETWORK) != NODE_NETWORK) && (::ChainActive().Tip()->nHeight - pindex->nHeight > (int)NODE_NETWORK_LIMITED_MIN_BLOCKS + 2 /* add two blocks buffer extension for possible races */) )\n        )) {\n         LogPrint(BCLog::NET, \"Ignore block request below NODE_NETWORK_LIMITED threshold from peer=%d\\n\", pfrom->GetId());\n \n@@ -1374,7 +1374,7 @@ void static ProcessGetBlockData(CNode* pfrom, const CChainParams& chainparams, c\n                 // instead we respond with the full, non-compact block.\n                 bool fPeerWantsWitness = State(pfrom->GetId())->fWantsCmpctWitness;\n                 int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n-                if (CanDirectFetch(consensusParams) && pindex->nHeight >= chainActive.Height() - MAX_CMPCTBLOCK_DEPTH) {\n+                if (CanDirectFetch(consensusParams) && pindex->nHeight >= ::ChainActive().Height() - MAX_CMPCTBLOCK_DEPTH) {\n                     if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == pindex->GetBlockHash()) {\n                         connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n                     } else {\n@@ -1394,7 +1394,7 @@ void static ProcessGetBlockData(CNode* pfrom, const CChainParams& chainparams, c\n             // and we want it right after the last block so they don't\n             // wait for other stuff first.\n             std::vector<CInv> vInv;\n-            vInv.push_back(CInv(MSG_BLOCK, chainActive.Tip()->GetBlockHash()));\n+            vInv.push_back(CInv(MSG_BLOCK, ::ChainActive().Tip()->GetBlockHash()));\n             connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n             pfrom->hashContinue.SetNull();\n         }\n@@ -1515,7 +1515,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n         //   nUnconnectingHeaders gets reset back to 0.\n         if (!LookupBlockIndex(headers[0].hashPrevBlock) && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n             nodestate->nUnconnectingHeaders++;\n-            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), uint256()));\n             LogPrint(BCLog::NET, \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n                     headers[0].GetHash().ToString(),\n                     headers[0].hashPrevBlock.ToString(),\n@@ -1612,26 +1612,26 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n         // because it is set in UpdateBlockAvailability. Some nullptr checks\n         // are still present, however, as belt-and-suspenders.\n \n-        if (received_new_header && pindexLast->nChainWork > chainActive.Tip()->nChainWork) {\n+        if (received_new_header && pindexLast->nChainWork > ::ChainActive().Tip()->nChainWork) {\n             nodestate->m_last_block_announcement = GetTime();\n         }\n \n         if (nCount == MAX_HEADERS_RESULTS) {\n             // Headers message had its maximum size; the peer may have more headers.\n-            // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n+            // TODO: optimize: if pindexLast is an ancestor of ::ChainActive().Tip or pindexBestHeader, continue\n             // from there instead.\n             LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->GetId(), pfrom->nStartingHeight);\n-            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256()));\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexLast), uint256()));\n         }\n \n         bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());\n         // If this set of headers is valid and ends in a block with at least as\n         // much work as our tip, download as much as possible.\n-        if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && chainActive.Tip()->nChainWork <= pindexLast->nChainWork) {\n+        if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && ::ChainActive().Tip()->nChainWork <= pindexLast->nChainWork) {\n             std::vector<const CBlockIndex*> vToFetch;\n             const CBlockIndex *pindexWalk = pindexLast;\n             // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.\n-            while (pindexWalk && !chainActive.Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+            while (pindexWalk && !::ChainActive().Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n                 if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&\n                         !mapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&\n                         (!IsWitnessEnabled(pindexWalk->pprev, chainparams.GetConsensus()) || State(pfrom->GetId())->fHaveWitness)) {\n@@ -1644,7 +1644,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n             // very large reorg at a time we think we're close to caught up to\n             // the main chain -- this shouldn't really happen.  Bail out on the\n             // direct fetch and rely on parallel download instead.\n-            if (!chainActive.Contains(pindexWalk)) {\n+            if (!::ChainActive().Contains(pindexWalk)) {\n                 LogPrint(BCLog::NET, \"Large reorg, won't direct fetch to %s (%d)\\n\",\n                         pindexLast->GetBlockHash().ToString(),\n                         pindexLast->nHeight);\n@@ -1685,7 +1685,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n                 // us sync -- disconnect if using an outbound slot (unless\n                 // whitelisted or addnode).\n                 // Note: We compare their tip to nMinimumChainWork (rather than\n-                // chainActive.Tip()) because we won't start block download\n+                // ::ChainActive().Tip()) because we won't start block download\n                 // until we have a headers chain that has at least\n                 // nMinimumChainWork, even if a peer has a chain past our tip,\n                 // as an anti-DoS measure.\n@@ -1699,7 +1699,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n         if (!pfrom->fDisconnect && IsOutboundDisconnectionCandidate(pfrom) && nodestate->pindexBestKnownBlock != nullptr) {\n             // If this is an outbound peer, check to see if we should protect\n             // it from the bad/lagging chain logic.\n-            if (g_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= chainActive.Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n+            if (g_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= ::ChainActive().Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n                 LogPrint(BCLog::NET, \"Protecting outbound peer=%d from eviction\\n\", pfrom->GetId());\n                 nodestate->m_chain_sync.m_protect = true;\n                 ++g_outbound_peers_with_protect_from_disconnect;\n@@ -2168,7 +2168,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     // fell back to inv we probably have a reorg which we should get the headers for first,\n                     // we now only provide a getheaders response here. When we receive the headers, we will\n                     // then ask for the blocks we need.\n-                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), inv.hash));\n+                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), inv.hash));\n                     LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, inv.hash.ToString(), pfrom->GetId());\n                 }\n             }\n@@ -2239,14 +2239,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         LOCK(cs_main);\n \n         // Find the last block the caller has in the main chain\n-        const CBlockIndex* pindex = FindForkInGlobalIndex(chainActive, locator);\n+        const CBlockIndex* pindex = FindForkInGlobalIndex(::ChainActive(), locator);\n \n         // Send the rest of the chain\n         if (pindex)\n-            pindex = chainActive.Next(pindex);\n+            pindex = ::ChainActive().Next(pindex);\n         int nLimit = 500;\n         LogPrint(BCLog::NET, \"getblocks %d to %s limit %d from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), nLimit, pfrom->GetId());\n-        for (; pindex; pindex = chainActive.Next(pindex))\n+        for (; pindex; pindex = ::ChainActive().Next(pindex))\n         {\n             if (pindex->GetBlockHash() == hashStop)\n             {\n@@ -2256,7 +2256,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // If pruning, don't inv blocks unless we have on disk and are likely to still have\n             // for some reasonable time window (1 hour) that block relay might require.\n             const int nPrunedBlocksLikelyToHave = MIN_BLOCKS_TO_KEEP - 3600 / chainparams.GetConsensus().nPowTargetSpacing;\n-            if (fPruneMode && (!(pindex->nStatus & BLOCK_HAVE_DATA) || pindex->nHeight <= chainActive.Tip()->nHeight - nPrunedBlocksLikelyToHave))\n+            if (fPruneMode && (!(pindex->nStatus & BLOCK_HAVE_DATA) || pindex->nHeight <= ::ChainActive().Tip()->nHeight - nPrunedBlocksLikelyToHave))\n             {\n                 LogPrint(BCLog::NET, \" getblocks stopping, pruned or too old block at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n                 break;\n@@ -2298,7 +2298,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return true;\n         }\n \n-        if (pindex->nHeight < chainActive.Height() - MAX_BLOCKTXN_DEPTH) {\n+        if (pindex->nHeight < ::ChainActive().Height() - MAX_BLOCKTXN_DEPTH) {\n             // If an older block is requested (should never happen in practice,\n             // but can happen in tests) send a block response instead of a\n             // blocktxn response. Sending a full block response instead of a\n@@ -2358,23 +2358,23 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         else\n         {\n             // Find the last block the caller has in the main chain\n-            pindex = FindForkInGlobalIndex(chainActive, locator);\n+            pindex = FindForkInGlobalIndex(::ChainActive(), locator);\n             if (pindex)\n-                pindex = chainActive.Next(pindex);\n+                pindex = ::ChainActive().Next(pindex);\n         }\n \n         // we must use CBlocks, as CBlockHeaders won't include the 0x00 nTx count at the end\n         std::vector<CBlock> vHeaders;\n         int nLimit = MAX_HEADERS_RESULTS;\n         LogPrint(BCLog::NET, \"getheaders %d to %s from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), pfrom->GetId());\n-        for (; pindex; pindex = chainActive.Next(pindex))\n+        for (; pindex; pindex = ::ChainActive().Next(pindex))\n         {\n             vHeaders.push_back(pindex->GetBlockHeader());\n             if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)\n                 break;\n         }\n-        // pindex can be nullptr either if we sent chainActive.Tip() OR\n-        // if our peer has chainActive.Tip() (and thus we are sending an empty\n+        // pindex can be nullptr either if we sent ::ChainActive().Tip() OR\n+        // if our peer has ::ChainActive().Tip() (and thus we are sending an empty\n         // headers message). In both cases it's safe to update\n         // pindexBestHeaderSent to be our tip.\n         //\n@@ -2385,7 +2385,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // without the new block. By resetting the BestHeaderSent, we ensure we\n         // will re-announce the new block via headers (or compact blocks again)\n         // in the SendMessages logic.\n-        nodestate->pindexBestHeaderSent = pindex ? pindex : chainActive.Tip();\n+        nodestate->pindexBestHeaderSent = pindex ? pindex : ::ChainActive().Tip();\n         connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n         return true;\n     }\n@@ -2562,7 +2562,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (!LookupBlockIndex(cmpctblock.header.hashPrevBlock)) {\n             // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n             if (!IsInitialBlockDownload())\n-                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n+                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), uint256()));\n             return true;\n         }\n \n@@ -2612,7 +2612,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         // If this was a new header with more work than our tip, update the\n         // peer's last block announcement time\n-        if (received_new_header && pindex->nChainWork > chainActive.Tip()->nChainWork) {\n+        if (received_new_header && pindex->nChainWork > ::ChainActive().Tip()->nChainWork) {\n             nodestate->m_last_block_announcement = GetTime();\n         }\n \n@@ -2622,7 +2622,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (pindex->nStatus & BLOCK_HAVE_DATA) // Nothing to do here\n             return true;\n \n-        if (pindex->nChainWork <= chainActive.Tip()->nChainWork || // We know something better\n+        if (pindex->nChainWork <= ::ChainActive().Tip()->nChainWork || // We know something better\n                 pindex->nTx != 0) { // We had this block at some point, but pruned it\n             if (fAlreadyInFlight) {\n                 // We requested this block for some reason, but our mempool will probably be useless\n@@ -2646,7 +2646,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         // We want to be a bit conservative just to be extra careful about DoS\n         // possibilities in compact block processing...\n-        if (pindex->nHeight <= chainActive.Height() + 2) {\n+        if (pindex->nHeight <= ::ChainActive().Height() + 2) {\n             if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n                  (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n                 std::list<QueuedBlock>::iterator* queuedBlockIt = nullptr;\n@@ -3301,7 +3301,7 @@ void PeerLogicValidation::ConsiderEviction(CNode *pto, int64_t time_in_seconds)\n         // their chain has more work than ours, we should sync to it,\n         // unless it's invalid, in which case we should find that out and\n         // disconnect from them elsewhere).\n-        if (state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= chainActive.Tip()->nChainWork) {\n+        if (state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= ::ChainActive().Tip()->nChainWork) {\n             if (state.m_chain_sync.m_timeout != 0) {\n                 state.m_chain_sync.m_timeout = 0;\n                 state.m_chain_sync.m_work_header = nullptr;\n@@ -3313,7 +3313,7 @@ void PeerLogicValidation::ConsiderEviction(CNode *pto, int64_t time_in_seconds)\n             // where we checked against our tip.\n             // Either way, set a new timeout based on current tip.\n             state.m_chain_sync.m_timeout = time_in_seconds + CHAIN_SYNC_TIMEOUT;\n-            state.m_chain_sync.m_work_header = chainActive.Tip();\n+            state.m_chain_sync.m_work_header = ::ChainActive().Tip();\n             state.m_chain_sync.m_sent_getheaders = false;\n         } else if (state.m_chain_sync.m_timeout > 0 && time_in_seconds > state.m_chain_sync.m_timeout) {\n             // No evidence yet that our peer has synced to a chain with work equal to that\n@@ -3326,7 +3326,7 @@ void PeerLogicValidation::ConsiderEviction(CNode *pto, int64_t time_in_seconds)\n             } else {\n                 assert(state.m_chain_sync.m_work_header);\n                 LogPrint(BCLog::NET, \"sending getheaders to outbound peer=%d to verify chain work (current best known block:%s, benchmark blockhash: %s)\\n\", pto->GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\", state.m_chain_sync.m_work_header->GetBlockHash().ToString());\n-                connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(state.m_chain_sync.m_work_header->pprev), uint256()));\n+                connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(state.m_chain_sync.m_work_header->pprev), uint256()));\n                 state.m_chain_sync.m_sent_getheaders = true;\n                 constexpr int64_t HEADERS_RESPONSE_TIME = 120; // 2 minutes\n                 // Bump the timeout to allow a response, which could clear the timeout\n@@ -3524,7 +3524,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n \n         // Start block sync\n         if (pindexBestHeader == nullptr)\n-            pindexBestHeader = chainActive.Tip();\n+            pindexBestHeader = ::ChainActive().Tip();\n         bool fFetch = state.fPreferredDownload || (nPreferredDownload == 0 && !pto->fClient && !pto->fOneShot); // Download if this is a nice peer, or we have no nice peers and this one might do.\n         if (!state.fSyncStarted && !pto->fClient && !fImporting && !fReindex) {\n             // Only actively request headers from a single peer, unless we're close to today.\n@@ -3543,7 +3543,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                 if (pindexStart->pprev)\n                     pindexStart = pindexStart->pprev;\n                 LogPrint(BCLog::NET, \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->GetId(), pto->nStartingHeight);\n-                connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexStart), uint256()));\n+                connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexStart), uint256()));\n             }\n         }\n \n@@ -3570,11 +3570,11 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                 bool fFoundStartingHeader = false;\n                 // Try to find first header that our peer doesn't have, and\n                 // then send all headers past that one.  If we come across any\n-                // headers that aren't on chainActive, give up.\n+                // headers that aren't on ::ChainActive(), give up.\n                 for (const uint256 &hash : pto->vBlockHashesToAnnounce) {\n                     const CBlockIndex* pindex = LookupBlockIndex(hash);\n                     assert(pindex);\n-                    if (chainActive[pindex->nHeight] != pindex) {\n+                    if (::ChainActive()[pindex->nHeight] != pindex) {\n                         // Bail out if we reorged away from this block\n                         fRevertToInv = true;\n                         break;\n@@ -3670,9 +3670,9 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                     // Warn if we're announcing a block that is not on the main chain.\n                     // This should be very rare and could be optimized out.\n                     // Just log for now.\n-                    if (chainActive[pindex->nHeight] != pindex) {\n+                    if (::ChainActive()[pindex->nHeight] != pindex) {\n                         LogPrint(BCLog::NET, \"Announcing block %s not on main chain (tip=%s)\\n\",\n-                            hashToAnnounce.ToString(), chainActive.Tip()->GetBlockHash().ToString());\n+                            hashToAnnounce.ToString(), ::ChainActive().Tip()->GetBlockHash().ToString());\n                     }\n \n                     // If the peer's chain has this block, don't inv it back."
      },
      {
        "sha": "6456eec016aab6db49dccd1d0cab316d68d022e0",
        "filename": "src/policy/fees.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/policy/fees.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/policy/fees.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -526,7 +526,7 @@ void CBlockPolicyEstimator::processTransaction(const CTxMemPoolEntry& entry, boo\n     if (txHeight != nBestSeenHeight) {\n         // Ignore side chains and re-orgs; assuming they are random they don't\n         // affect the estimate.  We'll potentially double count transactions in 1-block reorgs.\n-        // Ignore txs if BlockPolicyEstimator is not in sync with chainActive.Tip().\n+        // Ignore txs if BlockPolicyEstimator is not in sync with ::ChainActive().Tip().\n         // It will be synced next time a block is processed.\n         return;\n     }"
      },
      {
        "sha": "e1e14e99c0b0791445140a610ee4a8a078312330",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -149,7 +149,7 @@ void TestGUI()\n         reserver.reserve();\n         CWallet::ScanResult result = wallet->ScanForWalletTransactions(locked_chain->getBlockHash(0), {} /* stop_block */, reserver, true /* fUpdate */);\n         QCOMPARE(result.status, CWallet::ScanResult::SUCCESS);\n-        QCOMPARE(result.last_scanned_block, chainActive.Tip()->GetBlockHash());\n+        QCOMPARE(result.last_scanned_block, ::ChainActive().Tip()->GetBlockHash());\n         QVERIFY(result.last_failed_block.IsNull());\n     }\n     wallet->SetBroadcastTransactions(true);"
      },
      {
        "sha": "ab409947d35a038d6a54f5442883e91ef783a74e",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -141,13 +141,13 @@ static bool rest_headers(HTTPRequest* req,\n     headers.reserve(count);\n     {\n         LOCK(cs_main);\n-        tip = chainActive.Tip();\n+        tip = ::ChainActive().Tip();\n         const CBlockIndex* pindex = LookupBlockIndex(hash);\n-        while (pindex != nullptr && chainActive.Contains(pindex)) {\n+        while (pindex != nullptr && ::ChainActive().Contains(pindex)) {\n             headers.push_back(pindex);\n             if (headers.size() == (unsigned long)count)\n                 break;\n-            pindex = chainActive.Next(pindex);\n+            pindex = ::ChainActive().Next(pindex);\n         }\n     }\n \n@@ -209,7 +209,7 @@ static bool rest_block(HTTPRequest* req,\n     CBlockIndex* tip = nullptr;\n     {\n         LOCK(cs_main);\n-        tip = chainActive.Tip();\n+        tip = ::ChainActive().Tip();\n         pblockindex = LookupBlockIndex(hash);\n         if (!pblockindex) {\n             return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not found\");\n@@ -522,7 +522,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         // serialize data\n         // use exact same output as mentioned in Bip64\n         CDataStream ssGetUTXOResponse(SER_NETWORK, PROTOCOL_VERSION);\n-        ssGetUTXOResponse << chainActive.Height() << chainActive.Tip()->GetBlockHash() << bitmap << outs;\n+        ssGetUTXOResponse << ::ChainActive().Height() << ::ChainActive().Tip()->GetBlockHash() << bitmap << outs;\n         std::string ssGetUTXOResponseString = ssGetUTXOResponse.str();\n \n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n@@ -532,7 +532,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n \n     case RetFormat::HEX: {\n         CDataStream ssGetUTXOResponse(SER_NETWORK, PROTOCOL_VERSION);\n-        ssGetUTXOResponse << chainActive.Height() << chainActive.Tip()->GetBlockHash() << bitmap << outs;\n+        ssGetUTXOResponse << ::ChainActive().Height() << ::ChainActive().Tip()->GetBlockHash() << bitmap << outs;\n         std::string strHex = HexStr(ssGetUTXOResponse.begin(), ssGetUTXOResponse.end()) + \"\\n\";\n \n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n@@ -545,8 +545,8 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n \n         // pack in some essentials\n         // use more or less the same output as mentioned in Bip64\n-        objGetUTXOResponse.pushKV(\"chainHeight\", chainActive.Height());\n-        objGetUTXOResponse.pushKV(\"chaintipHash\", chainActive.Tip()->GetBlockHash().GetHex());\n+        objGetUTXOResponse.pushKV(\"chainHeight\", ::ChainActive().Height());\n+        objGetUTXOResponse.pushKV(\"chaintipHash\", ::ChainActive().Tip()->GetBlockHash().GetHex());\n         objGetUTXOResponse.pushKV(\"bitmap\", bitmapStringRepresentation);\n \n         UniValue utxos(UniValue::VARR);\n@@ -590,10 +590,10 @@ static bool rest_blockhash_by_height(HTTPRequest* req,\n     CBlockIndex* pblockindex = nullptr;\n     {\n         LOCK(cs_main);\n-        if (blockheight > chainActive.Height()) {\n+        if (blockheight > ::ChainActive().Height()) {\n             return RESTERR(req, HTTP_NOT_FOUND, \"Block height out of range\");\n         }\n-        pblockindex = chainActive[blockheight];\n+        pblockindex = ::ChainActive()[blockheight];\n     }\n     switch (rf) {\n     case RetFormat::BINARY: {"
      },
      {
        "sha": "3d0fa8eb2b1aab90c9a7355ed105d75a656913a5",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 22,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -182,7 +182,7 @@ static UniValue getblockcount(const JSONRPCRequest& request)\n             }.ToString());\n \n     LOCK(cs_main);\n-    return chainActive.Height();\n+    return ::ChainActive().Height();\n }\n \n static UniValue getbestblockhash(const JSONRPCRequest& request)\n@@ -202,7 +202,7 @@ static UniValue getbestblockhash(const JSONRPCRequest& request)\n             }.ToString());\n \n     LOCK(cs_main);\n-    return chainActive.Tip()->GetBlockHash().GetHex();\n+    return ::ChainActive().Tip()->GetBlockHash().GetHex();\n }\n \n void RPCNotifyBlockChange(bool ibd, const CBlockIndex * pindex)\n@@ -381,7 +381,7 @@ static UniValue getdifficulty(const JSONRPCRequest& request)\n             }.ToString());\n \n     LOCK(cs_main);\n-    return GetDifficulty(chainActive.Tip());\n+    return GetDifficulty(::ChainActive().Tip());\n }\n \n static std::string EntryDescriptionString()\n@@ -732,10 +732,10 @@ static UniValue getblockhash(const JSONRPCRequest& request)\n     LOCK(cs_main);\n \n     int nHeight = request.params[0].get_int();\n-    if (nHeight < 0 || nHeight > chainActive.Height())\n+    if (nHeight < 0 || nHeight > ::ChainActive().Height())\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Block height out of range\");\n \n-    CBlockIndex* pblockindex = chainActive[nHeight];\n+    CBlockIndex* pblockindex = ::ChainActive()[nHeight];\n     return pblockindex->GetBlockHash().GetHex();\n }\n \n@@ -791,7 +791,7 @@ static UniValue getblockheader(const JSONRPCRequest& request)\n     {\n         LOCK(cs_main);\n         pblockindex = LookupBlockIndex(hash);\n-        tip = chainActive.Tip();\n+        tip = ::ChainActive().Tip();\n     }\n \n     if (!pblockindex) {\n@@ -904,7 +904,7 @@ static UniValue getblock(const JSONRPCRequest& request)\n     {\n         LOCK(cs_main);\n         pblockindex = LookupBlockIndex(hash);\n-        tip = chainActive.Tip();\n+        tip = ::ChainActive().Tip();\n \n         if (!pblockindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n@@ -1026,15 +1026,15 @@ static UniValue pruneblockchain(const JSONRPCRequest& request)\n     // too low to be a block time (corresponds to timestamp from Sep 2001).\n     if (heightParam > 1000000000) {\n         // Add a 2 hour buffer to include blocks which might have had old timestamps\n-        CBlockIndex* pindex = chainActive.FindEarliestAtLeast(heightParam - TIMESTAMP_WINDOW, 0);\n+        CBlockIndex* pindex = ::ChainActive().FindEarliestAtLeast(heightParam - TIMESTAMP_WINDOW, 0);\n         if (!pindex) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Could not find block with at least the specified timestamp.\");\n         }\n         heightParam = pindex->nHeight;\n     }\n \n     unsigned int height = (unsigned int) heightParam;\n-    unsigned int chainHeight = (unsigned int) chainActive.Height();\n+    unsigned int chainHeight = (unsigned int) ::ChainActive().Height();\n     if (chainHeight < Params().PruneAfterHeight())\n         throw JSONRPCError(RPC_MISC_ERROR, \"Blockchain is too short for pruning.\");\n     else if (height > chainHeight)\n@@ -1333,10 +1333,10 @@ UniValue getblockchaininfo(const JSONRPCRequest& request)\n \n     LOCK(cs_main);\n \n-    const CBlockIndex* tip = chainActive.Tip();\n+    const CBlockIndex* tip = ::ChainActive().Tip();\n     UniValue obj(UniValue::VOBJ);\n     obj.pushKV(\"chain\",                 Params().NetworkIDString());\n-    obj.pushKV(\"blocks\",                (int)chainActive.Height());\n+    obj.pushKV(\"blocks\",                (int)::ChainActive().Height());\n     obj.pushKV(\"headers\",               pindexBestHeader ? pindexBestHeader->nHeight : -1);\n     obj.pushKV(\"bestblockhash\",         tip->GetBlockHash().GetHex());\n     obj.pushKV(\"difficulty\",            (double)GetDifficulty(tip));\n@@ -1433,19 +1433,19 @@ static UniValue getchaintips(const JSONRPCRequest& request)\n     LOCK(cs_main);\n \n     /*\n-     * Idea:  the set of chain tips is chainActive.tip, plus orphan blocks which do not have another orphan building off of them.\n+     * Idea:  the set of chain tips is ::ChainActive().tip, plus orphan blocks which do not have another orphan building off of them.\n      * Algorithm:\n      *  - Make one pass through mapBlockIndex, picking out the orphan blocks, and also storing a set of the orphan block's pprev pointers.\n      *  - Iterate through the orphan blocks. If the block isn't pointed to by another orphan, it is a chain tip.\n-     *  - add chainActive.Tip()\n+     *  - add ::ChainActive().Tip()\n      */\n     std::set<const CBlockIndex*, CompareBlocksByHeight> setTips;\n     std::set<const CBlockIndex*> setOrphans;\n     std::set<const CBlockIndex*> setPrevs;\n \n     for (const std::pair<const uint256, CBlockIndex*>& item : mapBlockIndex)\n     {\n-        if (!chainActive.Contains(item.second)) {\n+        if (!::ChainActive().Contains(item.second)) {\n             setOrphans.insert(item.second);\n             setPrevs.insert(item.second->pprev);\n         }\n@@ -1459,7 +1459,7 @@ static UniValue getchaintips(const JSONRPCRequest& request)\n     }\n \n     // Always report the currently active tip.\n-    setTips.insert(chainActive.Tip());\n+    setTips.insert(::ChainActive().Tip());\n \n     /* Construct the output array.  */\n     UniValue res(UniValue::VARR);\n@@ -1469,11 +1469,11 @@ static UniValue getchaintips(const JSONRPCRequest& request)\n         obj.pushKV(\"height\", block->nHeight);\n         obj.pushKV(\"hash\", block->phashBlock->GetHex());\n \n-        const int branchLen = block->nHeight - chainActive.FindFork(block)->nHeight;\n+        const int branchLen = block->nHeight - ::ChainActive().FindFork(block)->nHeight;\n         obj.pushKV(\"branchlen\", branchLen);\n \n         std::string status;\n-        if (chainActive.Contains(block)) {\n+        if (::ChainActive().Contains(block)) {\n             // This block is part of the currently active chain.\n             status = \"active\";\n         } else if (block->nStatus & BLOCK_FAILED_MASK) {\n@@ -1694,15 +1694,15 @@ static UniValue getchaintxstats(const JSONRPCRequest& request)\n \n     if (request.params[1].isNull()) {\n         LOCK(cs_main);\n-        pindex = chainActive.Tip();\n+        pindex = ::ChainActive().Tip();\n     } else {\n         uint256 hash(ParseHashV(request.params[1], \"blockhash\"));\n         LOCK(cs_main);\n         pindex = LookupBlockIndex(hash);\n         if (!pindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         }\n-        if (!chainActive.Contains(pindex)) {\n+        if (!::ChainActive().Contains(pindex)) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Block is not in main chain\");\n         }\n     }\n@@ -1863,22 +1863,22 @@ static UniValue getblockstats(const JSONRPCRequest& request)\n     CBlockIndex* pindex;\n     if (request.params[0].isNum()) {\n         const int height = request.params[0].get_int();\n-        const int current_tip = chainActive.Height();\n+        const int current_tip = ::ChainActive().Height();\n         if (height < 0) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d is negative\", height));\n         }\n         if (height > current_tip) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d after current tip %d\", height, current_tip));\n         }\n \n-        pindex = chainActive[height];\n+        pindex = ::ChainActive()[height];\n     } else {\n         const uint256 hash(ParseHashV(request.params[0], \"hash_or_height\"));\n         pindex = LookupBlockIndex(hash);\n         if (!pindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         }\n-        if (!chainActive.Contains(pindex)) {\n+        if (!::ChainActive().Contains(pindex)) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Block is not in chain %s\", Params().NetworkIDString()));\n         }\n     }"
      },
      {
        "sha": "18315621007bb48c920057c8385d1890e9cfc1bf",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -40,10 +40,10 @@\n  * If 'height' is nonnegative, compute the estimate at the time when a given block was found.\n  */\n static UniValue GetNetworkHashPS(int lookup, int height) {\n-    CBlockIndex *pb = chainActive.Tip();\n+    CBlockIndex *pb = ::ChainActive().Tip();\n \n-    if (height >= 0 && height < chainActive.Height())\n-        pb = chainActive[height];\n+    if (height >= 0 && height < ::ChainActive().Height())\n+        pb = ::ChainActive()[height];\n \n     if (pb == nullptr || !pb->nHeight)\n         return 0;\n@@ -109,7 +109,7 @@ static UniValue generateBlocks(const CScript& coinbase_script, int nGenerate, ui\n \n     {   // Don't keep cs_main locked\n         LOCK(cs_main);\n-        nHeight = chainActive.Height();\n+        nHeight = ::ChainActive().Height();\n         nHeightEnd = nHeight+nGenerate;\n     }\n     unsigned int nExtraNonce = 0;\n@@ -122,7 +122,7 @@ static UniValue generateBlocks(const CScript& coinbase_script, int nGenerate, ui\n         CBlock *pblock = &pblocktemplate->block;\n         {\n             LOCK(cs_main);\n-            IncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);\n+            IncrementExtraNonce(pblock, ::ChainActive().Tip(), nExtraNonce);\n         }\n         while (nMaxTries > 0 && pblock->nNonce < nInnerLoopCount && !CheckProofOfWork(pblock->GetHash(), pblock->nBits, Params().GetConsensus())) {\n             ++pblock->nNonce;\n@@ -210,10 +210,10 @@ static UniValue getmininginfo(const JSONRPCRequest& request)\n     LOCK(cs_main);\n \n     UniValue obj(UniValue::VOBJ);\n-    obj.pushKV(\"blocks\",           (int)chainActive.Height());\n+    obj.pushKV(\"blocks\",           (int)::ChainActive().Height());\n     if (BlockAssembler::m_last_block_weight) obj.pushKV(\"currentblockweight\", *BlockAssembler::m_last_block_weight);\n     if (BlockAssembler::m_last_block_num_txs) obj.pushKV(\"currentblocktx\", *BlockAssembler::m_last_block_num_txs);\n-    obj.pushKV(\"difficulty\",       (double)GetDifficulty(chainActive.Tip()));\n+    obj.pushKV(\"difficulty\",       (double)GetDifficulty(::ChainActive().Tip()));\n     obj.pushKV(\"networkhashps\",    getnetworkhashps(request));\n     obj.pushKV(\"pooledtx\",         (uint64_t)mempool.size());\n     obj.pushKV(\"chain\",            Params().NetworkIDString());\n@@ -409,7 +409,7 @@ static UniValue getblocktemplate(const JSONRPCRequest& request)\n                 return \"duplicate-inconclusive\";\n             }\n \n-            CBlockIndex* const pindexPrev = chainActive.Tip();\n+            CBlockIndex* const pindexPrev = ::ChainActive().Tip();\n             // TestBlockValidity only supports blocks built on the current Tip\n             if (block.hashPrevBlock != pindexPrev->GetBlockHash())\n                 return \"inconclusive-not-best-prevblk\";\n@@ -465,7 +465,7 @@ static UniValue getblocktemplate(const JSONRPCRequest& request)\n         else\n         {\n             // NOTE: Spec does not specify behaviour for non-string longpollid, but this makes testing easier\n-            hashWatchedChain = chainActive.Tip()->GetBlockHash();\n+            hashWatchedChain = ::ChainActive().Tip()->GetBlockHash();\n             nTransactionsUpdatedLastLP = nTransactionsUpdatedLast;\n         }\n \n@@ -503,15 +503,15 @@ static UniValue getblocktemplate(const JSONRPCRequest& request)\n     static CBlockIndex* pindexPrev;\n     static int64_t nStart;\n     static std::unique_ptr<CBlockTemplate> pblocktemplate;\n-    if (pindexPrev != chainActive.Tip() ||\n+    if (pindexPrev != ::ChainActive().Tip() ||\n         (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 5))\n     {\n         // Clear pindexPrev so future calls make a new block, despite any failures from here on\n         pindexPrev = nullptr;\n \n         // Store the pindexBest used before CreateNewBlock, to avoid races\n         nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();\n-        CBlockIndex* pindexPrevNew = chainActive.Tip();\n+        CBlockIndex* pindexPrevNew = ::ChainActive().Tip();\n         nStart = GetTime();\n \n         // Create new block\n@@ -646,7 +646,7 @@ static UniValue getblocktemplate(const JSONRPCRequest& request)\n     result.pushKV(\"transactions\", transactions);\n     result.pushKV(\"coinbaseaux\", aux);\n     result.pushKV(\"coinbasevalue\", (int64_t)pblock->vtx[0]->vout[0].nValue);\n-    result.pushKV(\"longpollid\", chainActive.Tip()->GetBlockHash().GetHex() + i64tostr(nTransactionsUpdatedLast));\n+    result.pushKV(\"longpollid\", ::ChainActive().Tip()->GetBlockHash().GetHex() + i64tostr(nTransactionsUpdatedLast));\n     result.pushKV(\"target\", hashTarget.GetHex());\n     result.pushKV(\"mintime\", (int64_t)pindexPrev->GetMedianTimePast()+1);\n     result.pushKV(\"mutable\", aMutable);"
      },
      {
        "sha": "0a820af11456128649f5c1fcb7a416875db840db",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -64,8 +64,8 @@ static void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue&\n         entry.pushKV(\"blockhash\", hashBlock.GetHex());\n         CBlockIndex* pindex = LookupBlockIndex(hashBlock);\n         if (pindex) {\n-            if (chainActive.Contains(pindex)) {\n-                entry.pushKV(\"confirmations\", 1 + chainActive.Height() - pindex->nHeight);\n+            if (::ChainActive().Contains(pindex)) {\n+                entry.pushKV(\"confirmations\", 1 + ::ChainActive().Height() - pindex->nHeight);\n                 entry.pushKV(\"time\", pindex->GetBlockTime());\n                 entry.pushKV(\"blocktime\", pindex->GetBlockTime());\n             }\n@@ -184,7 +184,7 @@ static UniValue getrawtransaction(const JSONRPCRequest& request)\n         if (!blockindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block hash not found\");\n         }\n-        in_active_chain = chainActive.Contains(blockindex);\n+        in_active_chain = ::ChainActive().Contains(blockindex);\n     }\n \n     bool f_txindex_ready = false;\n@@ -274,7 +274,7 @@ static UniValue gettxoutproof(const JSONRPCRequest& request)\n         for (const auto& tx : setTxids) {\n             const Coin& coin = AccessByTxid(*pcoinsTip, tx);\n             if (!coin.IsSpent()) {\n-                pblockindex = chainActive[coin.nHeight];\n+                pblockindex = ::ChainActive()[coin.nHeight];\n                 break;\n             }\n         }\n@@ -348,7 +348,7 @@ static UniValue verifytxoutproof(const JSONRPCRequest& request)\n     LOCK(cs_main);\n \n     const CBlockIndex* pindex = LookupBlockIndex(merkleBlock.header.GetHash());\n-    if (!pindex || !chainActive.Contains(pindex) || pindex->nTx == 0) {\n+    if (!pindex || !::ChainActive().Contains(pindex) || pindex->nTx == 0) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found in chain\");\n     }\n "
      },
      {
        "sha": "a720d07e1c35c355db5b7ece9e10f6ebc39dd9a9",
        "filename": "src/test/blockfilter_index_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/test/blockfilter_index_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/test/blockfilter_index_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/blockfilter_index_tests.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -125,9 +125,9 @@ BOOST_FIXTURE_TEST_CASE(blockfilter_index_initial_sync, TestChain100Setup)\n         std::vector<BlockFilter> filters;\n         std::vector<uint256> filter_hashes;\n \n-        for (const CBlockIndex* block_index = chainActive.Genesis();\n+        for (const CBlockIndex* block_index = ::ChainActive().Genesis();\n              block_index != nullptr;\n-             block_index = chainActive.Next(block_index)) {\n+             block_index = ::ChainActive().Next(block_index)) {\n             BOOST_CHECK(!filter_index.LookupFilter(block_index, filter));\n             BOOST_CHECK(!filter_index.LookupFilterHeader(block_index, filter_header));\n             BOOST_CHECK(!filter_index.LookupFilterRange(block_index->nHeight, block_index, filters));\n@@ -153,9 +153,9 @@ BOOST_FIXTURE_TEST_CASE(blockfilter_index_initial_sync, TestChain100Setup)\n     {\n         LOCK(cs_main);\n         const CBlockIndex* block_index;\n-        for (block_index = chainActive.Genesis();\n+        for (block_index = ::ChainActive().Genesis();\n              block_index != nullptr;\n-             block_index = chainActive.Next(block_index)) {\n+             block_index = ::ChainActive().Next(block_index)) {\n             CheckFilterLookups(filter_index, block_index, last_header);\n         }\n     }\n@@ -164,7 +164,7 @@ BOOST_FIXTURE_TEST_CASE(blockfilter_index_initial_sync, TestChain100Setup)\n     const CBlockIndex* tip;\n     {\n         LOCK(cs_main);\n-        tip = chainActive.Tip();\n+        tip = ::ChainActive().Tip();\n     }\n     CScript coinbase_script_pub_key = GetScriptForDestination(coinbaseKey.GetPubKey().GetID());\n     std::vector<std::shared_ptr<CBlock>> chainA, chainB;\n@@ -250,7 +250,7 @@ BOOST_FIXTURE_TEST_CASE(blockfilter_index_initial_sync, TestChain100Setup)\n \n     {\n         LOCK(cs_main);\n-        tip = chainActive.Tip();\n+        tip = ::ChainActive().Tip();\n     }\n     BOOST_CHECK(filter_index.LookupFilterRange(0, tip, filters));\n     BOOST_CHECK(filter_index.LookupFilterHashRange(0, tip, filter_hashes));"
      },
      {
        "sha": "c5d3611dfa8370db758b0a6f26ea670cd98f4076",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -90,8 +90,8 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     // This test requires that we have a chain with non-zero work.\n     {\n         LOCK(cs_main);\n-        BOOST_CHECK(chainActive.Tip() != nullptr);\n-        BOOST_CHECK(chainActive.Tip()->nChainWork > 0);\n+        BOOST_CHECK(::ChainActive().Tip() != nullptr);\n+        BOOST_CHECK(::ChainActive().Tip()->nChainWork > 0);\n     }\n \n     // Test starts here"
      },
      {
        "sha": "9ab1c348fa0020822e20d24367578aac39792637",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 30,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -86,7 +86,7 @@ static CBlockIndex CreateBlockIndex(int nHeight)\n {\n     CBlockIndex index;\n     index.nHeight = nHeight;\n-    index.pprev = chainActive.Tip();\n+    index.pprev = ::ChainActive().Tip();\n     return index;\n }\n \n@@ -231,17 +231,17 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         {\n             LOCK(cs_main);\n             pblock->nVersion = 1;\n-            pblock->nTime = chainActive.Tip()->GetMedianTimePast()+1;\n+            pblock->nTime = ::ChainActive().Tip()->GetMedianTimePast()+1;\n             CMutableTransaction txCoinbase(*pblock->vtx[0]);\n             txCoinbase.nVersion = 1;\n             txCoinbase.vin[0].scriptSig = CScript();\n             txCoinbase.vin[0].scriptSig.push_back(blockinfo[i].extranonce);\n-            txCoinbase.vin[0].scriptSig.push_back(chainActive.Height());\n+            txCoinbase.vin[0].scriptSig.push_back(::ChainActive().Height());\n             txCoinbase.vout.resize(1); // Ignore the (optional) segwit commitment added by CreateNewBlock (as the hardcoded nonces don't account for this)\n             txCoinbase.vout[0].scriptPubKey = CScript();\n             pblock->vtx[0] = MakeTransactionRef(std::move(txCoinbase));\n             if (txFirst.size() == 0)\n-                baseheight = chainActive.Height();\n+                baseheight = ::ChainActive().Height();\n             if (txFirst.size() < 4)\n                 txFirst.push_back(pblock->vtx[0]);\n             pblock->hashMerkleRoot = BlockMerkleRoot(*pblock);\n@@ -367,29 +367,29 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     mempool.clear();\n \n     // subsidy changing\n-    int nHeight = chainActive.Height();\n+    int nHeight = ::ChainActive().Height();\n     // Create an actual 209999-long block chain (without valid blocks).\n-    while (chainActive.Tip()->nHeight < 209999) {\n-        CBlockIndex* prev = chainActive.Tip();\n+    while (::ChainActive().Tip()->nHeight < 209999) {\n+        CBlockIndex* prev = ::ChainActive().Tip();\n         CBlockIndex* next = new CBlockIndex();\n         next->phashBlock = new uint256(InsecureRand256());\n         pcoinsTip->SetBestBlock(next->GetBlockHash());\n         next->pprev = prev;\n         next->nHeight = prev->nHeight + 1;\n         next->BuildSkip();\n-        chainActive.SetTip(next);\n+        ::ChainActive().SetTip(next);\n     }\n     BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n     // Extend to a 210000-long block chain.\n-    while (chainActive.Tip()->nHeight < 210000) {\n-        CBlockIndex* prev = chainActive.Tip();\n+    while (::ChainActive().Tip()->nHeight < 210000) {\n+        CBlockIndex* prev = ::ChainActive().Tip();\n         CBlockIndex* next = new CBlockIndex();\n         next->phashBlock = new uint256(InsecureRand256());\n         pcoinsTip->SetBestBlock(next->GetBlockHash());\n         next->pprev = prev;\n         next->nHeight = prev->nHeight + 1;\n         next->BuildSkip();\n-        chainActive.SetTip(next);\n+        ::ChainActive().SetTip(next);\n     }\n     BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n \n@@ -412,16 +412,16 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     mempool.clear();\n \n     // Delete the dummy blocks again.\n-    while (chainActive.Tip()->nHeight > nHeight) {\n-        CBlockIndex* del = chainActive.Tip();\n-        chainActive.SetTip(del->pprev);\n+    while (::ChainActive().Tip()->nHeight > nHeight) {\n+        CBlockIndex* del = ::ChainActive().Tip();\n+        ::ChainActive().SetTip(del->pprev);\n         pcoinsTip->SetBestBlock(del->pprev->GetBlockHash());\n         delete del->phashBlock;\n         delete del;\n     }\n \n     // non-final txs in mempool\n-    SetMockTime(chainActive.Tip()->GetMedianTimePast()+1);\n+    SetMockTime(::ChainActive().Tip()->GetMedianTimePast()+1);\n     int flags = LOCKTIME_VERIFY_SEQUENCE|LOCKTIME_MEDIAN_TIME_PAST;\n     // height map\n     std::vector<int> prevheights;\n@@ -433,7 +433,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vin[0].prevout.hash = txFirst[0]->GetHash(); // only 1 transaction\n     tx.vin[0].prevout.n = 0;\n     tx.vin[0].scriptSig = CScript() << OP_1;\n-    tx.vin[0].nSequence = chainActive.Tip()->nHeight + 1; // txFirst[0] is the 2nd block\n+    tx.vin[0].nSequence = ::ChainActive().Tip()->nHeight + 1; // txFirst[0] is the 2nd block\n     prevheights[0] = baseheight + 1;\n     tx.vout.resize(1);\n     tx.vout[0].nValue = BLOCKSUBSIDY-HIGHFEE;\n@@ -443,48 +443,48 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     mempool.addUnchecked(entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n     BOOST_CHECK(CheckFinalTx(CTransaction(tx), flags)); // Locktime passes\n     BOOST_CHECK(!TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks fail\n-    BOOST_CHECK(SequenceLocks(CTransaction(tx), flags, &prevheights, CreateBlockIndex(chainActive.Tip()->nHeight + 2))); // Sequence locks pass on 2nd block\n+    BOOST_CHECK(SequenceLocks(CTransaction(tx), flags, &prevheights, CreateBlockIndex(::ChainActive().Tip()->nHeight + 2))); // Sequence locks pass on 2nd block\n \n     // relative time locked\n     tx.vin[0].prevout.hash = txFirst[1]->GetHash();\n-    tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG | (((chainActive.Tip()->GetMedianTimePast()+1-chainActive[1]->GetMedianTimePast()) >> CTxIn::SEQUENCE_LOCKTIME_GRANULARITY) + 1); // txFirst[1] is the 3rd block\n+    tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG | (((::ChainActive().Tip()->GetMedianTimePast()+1-::ChainActive()[1]->GetMedianTimePast()) >> CTxIn::SEQUENCE_LOCKTIME_GRANULARITY) + 1); // txFirst[1] is the 3rd block\n     prevheights[0] = baseheight + 2;\n     hash = tx.GetHash();\n     mempool.addUnchecked(entry.Time(GetTime()).FromTx(tx));\n     BOOST_CHECK(CheckFinalTx(CTransaction(tx), flags)); // Locktime passes\n     BOOST_CHECK(!TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks fail\n \n     for (int i = 0; i < CBlockIndex::nMedianTimeSpan; i++)\n-        chainActive.Tip()->GetAncestor(chainActive.Tip()->nHeight - i)->nTime += 512; //Trick the MedianTimePast\n-    BOOST_CHECK(SequenceLocks(CTransaction(tx), flags, &prevheights, CreateBlockIndex(chainActive.Tip()->nHeight + 1))); // Sequence locks pass 512 seconds later\n+        ::ChainActive().Tip()->GetAncestor(::ChainActive().Tip()->nHeight - i)->nTime += 512; //Trick the MedianTimePast\n+    BOOST_CHECK(SequenceLocks(CTransaction(tx), flags, &prevheights, CreateBlockIndex(::ChainActive().Tip()->nHeight + 1))); // Sequence locks pass 512 seconds later\n     for (int i = 0; i < CBlockIndex::nMedianTimeSpan; i++)\n-        chainActive.Tip()->GetAncestor(chainActive.Tip()->nHeight - i)->nTime -= 512; //undo tricked MTP\n+        ::ChainActive().Tip()->GetAncestor(::ChainActive().Tip()->nHeight - i)->nTime -= 512; //undo tricked MTP\n \n     // absolute height locked\n     tx.vin[0].prevout.hash = txFirst[2]->GetHash();\n     tx.vin[0].nSequence = CTxIn::SEQUENCE_FINAL - 1;\n     prevheights[0] = baseheight + 3;\n-    tx.nLockTime = chainActive.Tip()->nHeight + 1;\n+    tx.nLockTime = ::ChainActive().Tip()->nHeight + 1;\n     hash = tx.GetHash();\n     mempool.addUnchecked(entry.Time(GetTime()).FromTx(tx));\n     BOOST_CHECK(!CheckFinalTx(CTransaction(tx), flags)); // Locktime fails\n     BOOST_CHECK(TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks pass\n-    BOOST_CHECK(IsFinalTx(CTransaction(tx), chainActive.Tip()->nHeight + 2, chainActive.Tip()->GetMedianTimePast())); // Locktime passes on 2nd block\n+    BOOST_CHECK(IsFinalTx(CTransaction(tx), ::ChainActive().Tip()->nHeight + 2, ::ChainActive().Tip()->GetMedianTimePast())); // Locktime passes on 2nd block\n \n     // absolute time locked\n     tx.vin[0].prevout.hash = txFirst[3]->GetHash();\n-    tx.nLockTime = chainActive.Tip()->GetMedianTimePast();\n+    tx.nLockTime = ::ChainActive().Tip()->GetMedianTimePast();\n     prevheights.resize(1);\n     prevheights[0] = baseheight + 4;\n     hash = tx.GetHash();\n     mempool.addUnchecked(entry.Time(GetTime()).FromTx(tx));\n     BOOST_CHECK(!CheckFinalTx(CTransaction(tx), flags)); // Locktime fails\n     BOOST_CHECK(TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks pass\n-    BOOST_CHECK(IsFinalTx(CTransaction(tx), chainActive.Tip()->nHeight + 2, chainActive.Tip()->GetMedianTimePast() + 1)); // Locktime passes 1 second later\n+    BOOST_CHECK(IsFinalTx(CTransaction(tx), ::ChainActive().Tip()->nHeight + 2, ::ChainActive().Tip()->GetMedianTimePast() + 1)); // Locktime passes 1 second later\n \n     // mempool-dependent transactions (not added)\n     tx.vin[0].prevout.hash = hash;\n-    prevheights[0] = chainActive.Tip()->nHeight + 1;\n+    prevheights[0] = ::ChainActive().Tip()->nHeight + 1;\n     tx.nLockTime = 0;\n     tx.vin[0].nSequence = 0;\n     BOOST_CHECK(CheckFinalTx(CTransaction(tx), flags)); // Locktime passes\n@@ -505,14 +505,14 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 3U);\n     // However if we advance height by 1 and time by 512, all of them should be mined\n     for (int i = 0; i < CBlockIndex::nMedianTimeSpan; i++)\n-        chainActive.Tip()->GetAncestor(chainActive.Tip()->nHeight - i)->nTime += 512; //Trick the MedianTimePast\n-    chainActive.Tip()->nHeight++;\n-    SetMockTime(chainActive.Tip()->GetMedianTimePast() + 1);\n+        ::ChainActive().Tip()->GetAncestor(::ChainActive().Tip()->nHeight - i)->nTime += 512; //Trick the MedianTimePast\n+    ::ChainActive().Tip()->nHeight++;\n+    SetMockTime(::ChainActive().Tip()->GetMedianTimePast() + 1);\n \n     BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n     BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 5U);\n \n-    chainActive.Tip()->nHeight--;\n+    ::ChainActive().Tip()->nHeight--;\n     SetMockTime(0);\n     mempool.clear();\n "
      },
      {
        "sha": "5b454da52be107c133389e8445fe5f200853e45e",
        "filename": "src/test/setup_common.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/test/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/test/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/setup_common.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -151,7 +151,7 @@ TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransaction>&\n     {\n         LOCK(cs_main);\n         unsigned int extraNonce = 0;\n-        IncrementExtraNonce(&block, chainActive.Tip(), extraNonce);\n+        IncrementExtraNonce(&block, ::ChainActive().Tip(), extraNonce);\n     }\n \n     while (!CheckProofOfWork(block.GetHash(), block.nBits, chainparams.GetConsensus())) ++block.nNonce;"
      },
      {
        "sha": "1077a3eaa5fc14de1cea68ae9473d604d0a235fa",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -66,26 +66,26 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n \n     // Test 1: block with both of those transactions should be rejected.\n     block = CreateAndProcessBlock(spends, scriptPubKey);\n-    BOOST_CHECK(chainActive.Tip()->GetBlockHash() != block.GetHash());\n+    BOOST_CHECK(::ChainActive().Tip()->GetBlockHash() != block.GetHash());\n \n     // Test 2: ... and should be rejected if spend1 is in the memory pool\n     BOOST_CHECK(ToMemPool(spends[0]));\n     block = CreateAndProcessBlock(spends, scriptPubKey);\n-    BOOST_CHECK(chainActive.Tip()->GetBlockHash() != block.GetHash());\n+    BOOST_CHECK(::ChainActive().Tip()->GetBlockHash() != block.GetHash());\n     mempool.clear();\n \n     // Test 3: ... and should be rejected if spend2 is in the memory pool\n     BOOST_CHECK(ToMemPool(spends[1]));\n     block = CreateAndProcessBlock(spends, scriptPubKey);\n-    BOOST_CHECK(chainActive.Tip()->GetBlockHash() != block.GetHash());\n+    BOOST_CHECK(::ChainActive().Tip()->GetBlockHash() != block.GetHash());\n     mempool.clear();\n \n     // Final sanity test: first spend in mempool, second in block, that's OK:\n     std::vector<CMutableTransaction> oneSpend;\n     oneSpend.push_back(spends[0]);\n     BOOST_CHECK(ToMemPool(spends[1]));\n     block = CreateAndProcessBlock(oneSpend, scriptPubKey);\n-    BOOST_CHECK(chainActive.Tip()->GetBlockHash() == block.GetHash());\n+    BOOST_CHECK(::ChainActive().Tip()->GetBlockHash() == block.GetHash());\n     // spends[1] should have been removed from the mempool when the\n     // block with spends[0] is accepted:\n     BOOST_CHECK_EQUAL(mempool.size(), 0U);\n@@ -220,7 +220,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n \n     block = CreateAndProcessBlock({spend_tx}, p2pk_scriptPubKey);\n     LOCK(cs_main);\n-    BOOST_CHECK(chainActive.Tip()->GetBlockHash() == block.GetHash());\n+    BOOST_CHECK(::ChainActive().Tip()->GetBlockHash() == block.GetHash());\n     BOOST_CHECK(pcoinsTip->GetBestBlock() == block.GetHash());\n \n     // Test P2SH: construct a transaction that is valid without P2SH, and"
      },
      {
        "sha": "2afa88bd2c3c6bfb94f14b8e663f119cb67a8eaf",
        "filename": "src/test/util.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/test/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/test/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -84,7 +84,7 @@ std::shared_ptr<CBlock> PrepareBlock(const CScript& coinbase_scriptPubKey)\n             .CreateNewBlock(coinbase_scriptPubKey)\n             ->block);\n \n-    block->nTime = ::chainActive.Tip()->GetMedianTimePast() + 1;\n+    block->nTime = ::ChainActive().Tip()->GetMedianTimePast() + 1;\n     block->hashMerkleRoot = BlockMerkleRoot(*block);\n \n     return block;"
      },
      {
        "sha": "7c8d4ea49dea2f0f5380bb4d3afbc4498d1b0472",
        "filename": "src/test/validation_block_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/test/validation_block_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/test/validation_block_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_block_tests.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -144,7 +144,7 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n     const CBlockIndex* initial_tip = nullptr;\n     {\n         LOCK(cs_main);\n-        initial_tip = chainActive.Tip();\n+        initial_tip = ::ChainActive().Tip();\n     }\n     TestSubscriber sub(initial_tip->GetBlockHash());\n     RegisterValidationInterface(&sub);\n@@ -181,7 +181,7 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n \n     UnregisterValidationInterface(&sub);\n \n-    BOOST_CHECK_EQUAL(sub.m_expected_tip, chainActive.Tip()->GetBlockHash());\n+    BOOST_CHECK_EQUAL(sub.m_expected_tip, ::ChainActive().Tip()->GetBlockHash());\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "ce0b762336d243264772264bc3e23a34f29494fc",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -496,7 +496,7 @@ class CTxMemPool\n      * By design, it is guaranteed that:\n      *\n      * 1. Locking both `cs_main` and `mempool.cs` will give a view of mempool\n-     *    that is consistent with current chain tip (`chainActive` and\n+     *    that is consistent with current chain tip (`::ChainActive()` and\n      *    `pcoinsTip`) and is fully populated. Fully populated means that if the\n      *    current active chain is missing transactions that were present in a\n      *    previously active chain, all the missing transactions will have been"
      },
      {
        "sha": "ea4cfd52c5c5e0a89e243bbc0a196d1af8da0ddc",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 54,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -340,21 +340,21 @@ bool CheckFinalTx(const CTransaction &tx, int flags)\n     // scheduled, so no flags are set.\n     flags = std::max(flags, 0);\n \n-    // CheckFinalTx() uses chainActive.Height()+1 to evaluate\n+    // CheckFinalTx() uses ::ChainActive().Height()+1 to evaluate\n     // nLockTime because when IsFinalTx() is called within\n     // CBlock::AcceptBlock(), the height of the block *being*\n     // evaluated is what is used. Thus if we want to know if a\n     // transaction can be part of the *next* block, we need to call\n-    // IsFinalTx() with one more than chainActive.Height().\n-    const int nBlockHeight = chainActive.Height() + 1;\n+    // IsFinalTx() with one more than ::ChainActive().Height().\n+    const int nBlockHeight = ::ChainActive().Height() + 1;\n \n     // BIP113 requires that time-locked transactions have nLockTime set to\n     // less than the median time of the previous block they're contained in.\n     // When the next block is created its previous block will be the current\n     // chain tip, so we use that to calculate the median time passed to\n     // IsFinalTx() if LOCKTIME_MEDIAN_TIME_PAST is set.\n     const int64_t nBlockTime = (flags & LOCKTIME_MEDIAN_TIME_PAST)\n-                             ? chainActive.Tip()->GetMedianTimePast()\n+                             ? ::ChainActive().Tip()->GetMedianTimePast()\n                              : GetAdjustedTime();\n \n     return IsFinalTx(tx, nBlockHeight, nBlockTime);\n@@ -367,9 +367,9 @@ bool TestLockPointValidity(const LockPoints* lp)\n     // If there are relative lock times then the maxInputBlock will be set\n     // If there are no relative lock times, the LockPoints don't depend on the chain\n     if (lp->maxInputBlock) {\n-        // Check whether chainActive is an extension of the block at which the LockPoints\n+        // Check whether ::ChainActive() is an extension of the block at which the LockPoints\n         // calculation was valid.  If not LockPoints are no longer valid\n-        if (!chainActive.Contains(lp->maxInputBlock)) {\n+        if (!::ChainActive().Contains(lp->maxInputBlock)) {\n             return false;\n         }\n     }\n@@ -383,17 +383,17 @@ bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flag\n     AssertLockHeld(cs_main);\n     AssertLockHeld(pool.cs);\n \n-    CBlockIndex* tip = chainActive.Tip();\n+    CBlockIndex* tip = ::ChainActive().Tip();\n     assert(tip != nullptr);\n \n     CBlockIndex index;\n     index.pprev = tip;\n-    // CheckSequenceLocks() uses chainActive.Height()+1 to evaluate\n+    // CheckSequenceLocks() uses ::ChainActive().Height()+1 to evaluate\n     // height based locks because when SequenceLocks() is called within\n     // ConnectBlock(), the height of the block *being*\n     // evaluated is what is used.\n     // Thus if we want to know if a transaction can be part of the\n-    // *next* block, we need to use one more than chainActive.Height()\n+    // *next* block, we need to use one more than ::ChainActive().Height()\n     index.nHeight = tip->nHeight + 1;\n \n     std::pair<int, int64_t> lockPair;\n@@ -403,7 +403,7 @@ bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flag\n         lockPair.second = lp->time;\n     }\n     else {\n-        // pcoinsTip contains the UTXO set for chainActive.Tip()\n+        // pcoinsTip contains the UTXO set for ::ChainActive().Tip()\n         CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool);\n         std::vector<int> prevheights;\n         prevheights.resize(tx.vin.size());\n@@ -470,9 +470,9 @@ static bool IsCurrentForFeeEstimation() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n     AssertLockHeld(cs_main);\n     if (IsInitialBlockDownload())\n         return false;\n-    if (chainActive.Tip()->GetBlockTime() < (GetTime() - MAX_FEE_ESTIMATION_TIP_AGE))\n+    if (::ChainActive().Tip()->GetBlockTime() < (GetTime() - MAX_FEE_ESTIMATION_TIP_AGE))\n         return false;\n-    if (chainActive.Height() < pindexBestHeader->nHeight - 1)\n+    if (::ChainActive().Height() < pindexBestHeader->nHeight - 1)\n         return false;\n     return true;\n }\n@@ -524,7 +524,7 @@ static void UpdateMempoolForReorg(DisconnectedBlockTransactions &disconnectpool,\n     mempool.UpdateTransactionsFromBlock(vHashUpdate);\n \n     // We also need to remove any now-immature transactions\n-    mempool.removeForReorg(pcoinsTip.get(), chainActive.Tip()->nHeight + 1, STANDARD_LOCKTIME_VERIFY_FLAGS);\n+    mempool.removeForReorg(pcoinsTip.get(), ::ChainActive().Tip()->nHeight + 1, STANDARD_LOCKTIME_VERIFY_FLAGS);\n     // Re-limit mempool size, in case we added any transactions\n     LimitMempoolSize(mempool, gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n }\n@@ -731,7 +731,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             }\n         }\n \n-        CTxMemPoolEntry entry(ptx, nFees, nAcceptTime, chainActive.Height(),\n+        CTxMemPoolEntry entry(ptx, nFees, nAcceptTime, ::ChainActive().Height(),\n                               fSpendsCoinbase, nSigOpsCost, lp);\n         unsigned int nSize = entry.GetTxSize();\n \n@@ -937,7 +937,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // There is a similar check in CreateNewBlock() to prevent creating\n         // invalid blocks (using TestBlockValidity), however allowing such\n         // transactions into the mempool can be exploited as a DoS attack.\n-        unsigned int currentBlockScriptVerifyFlags = GetBlockScriptFlags(chainActive.Tip(), chainparams.GetConsensus());\n+        unsigned int currentBlockScriptVerifyFlags = GetBlockScriptFlags(::ChainActive().Tip(), chainparams.GetConsensus());\n         if (!CheckInputsFromMempoolAndCache(tx, state, view, pool, currentBlockScriptVerifyFlags, true, txdata)) {\n             return error(\"%s: BUG! PLEASE REPORT THIS! CheckInputs failed against latest-block but not STANDARD flags %s, %s\",\n                     __func__, hash.ToString(), FormatStateMessage(state));\n@@ -1191,11 +1191,11 @@ bool IsInitialBlockDownload()\n         return false;\n     if (fImporting || fReindex)\n         return true;\n-    if (chainActive.Tip() == nullptr)\n+    if (::ChainActive().Tip() == nullptr)\n         return true;\n-    if (chainActive.Tip()->nChainWork < nMinimumChainWork)\n+    if (::ChainActive().Tip()->nChainWork < nMinimumChainWork)\n         return true;\n-    if (chainActive.Tip()->GetBlockTime() < (GetTime() - nMaxTipAge))\n+    if (::ChainActive().Tip()->GetBlockTime() < (GetTime() - nMaxTipAge))\n         return true;\n     LogPrintf(\"Leaving InitialBlockDownload (latching to false)\\n\");\n     latchToFalse.store(true, std::memory_order_relaxed);\n@@ -1232,10 +1232,10 @@ static void CheckForkWarningConditions() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n \n     // If our best fork is no longer within 72 blocks (+/- 12 hours if no one mines it)\n     // of our head, drop it\n-    if (pindexBestForkTip && chainActive.Height() - pindexBestForkTip->nHeight >= 72)\n+    if (pindexBestForkTip && ::ChainActive().Height() - pindexBestForkTip->nHeight >= 72)\n         pindexBestForkTip = nullptr;\n \n-    if (pindexBestForkTip || (pindexBestInvalid && pindexBestInvalid->nChainWork > chainActive.Tip()->nChainWork + (GetBlockProof(*chainActive.Tip()) * 6)))\n+    if (pindexBestForkTip || (pindexBestInvalid && pindexBestInvalid->nChainWork > ::ChainActive().Tip()->nChainWork + (GetBlockProof(*::ChainActive().Tip()) * 6)))\n     {\n         if (!GetfLargeWorkForkFound() && pindexBestForkBase)\n         {\n@@ -1268,7 +1268,7 @@ static void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip) E\n     AssertLockHeld(cs_main);\n     // If we are on a fork that is sufficiently large, set a warning flag\n     CBlockIndex* pfork = pindexNewForkTip;\n-    CBlockIndex* plonger = chainActive.Tip();\n+    CBlockIndex* plonger = ::ChainActive().Tip();\n     while (pfork && pfork != plonger)\n     {\n         while (plonger && plonger->nHeight > pfork->nHeight)\n@@ -1287,7 +1287,7 @@ static void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip) E\n     // the 7-block condition and from this always have the most-likely-to-cause-warning fork\n     if (pfork && (!pindexBestForkTip || pindexNewForkTip->nHeight > pindexBestForkTip->nHeight) &&\n             pindexNewForkTip->nChainWork - pfork->nChainWork > (GetBlockProof(*pfork) * 7) &&\n-            chainActive.Height() - pindexNewForkTip->nHeight < 72)\n+            ::ChainActive().Height() - pindexNewForkTip->nHeight < 72)\n     {\n         pindexBestForkTip = pindexNewForkTip;\n         pindexBestForkBase = pfork;\n@@ -1304,10 +1304,10 @@ void static InvalidChainFound(CBlockIndex* pindexNew) EXCLUSIVE_LOCKS_REQUIRED(c\n     LogPrintf(\"%s: invalid block=%s  height=%d  log2_work=%.8g  date=%s\\n\", __func__,\n       pindexNew->GetBlockHash().ToString(), pindexNew->nHeight,\n       log(pindexNew->nChainWork.getdouble())/log(2.0), FormatISO8601DateTime(pindexNew->GetBlockTime()));\n-    CBlockIndex *tip = chainActive.Tip();\n+    CBlockIndex *tip = ::ChainActive().Tip();\n     assert (tip);\n     LogPrintf(\"%s:  current best=%s  height=%d  log2_work=%.8g  date=%s\\n\", __func__,\n-      tip->GetBlockHash().ToString(), chainActive.Height(), log(tip->nChainWork.getdouble())/log(2.0),\n+      tip->GetBlockHash().ToString(), ::ChainActive().Height(), log(tip->nChainWork.getdouble())/log(2.0),\n       FormatISO8601DateTime(tip->GetBlockTime()));\n     CheckForkWarningConditions();\n }\n@@ -2180,7 +2180,7 @@ bool static FlushStateToDisk(const CChainParams& chainparams, CValidationState &\n     }\n     if (full_flush_completed) {\n         // Update best block in wallet (so we can detect restored wallets).\n-        GetMainSignals().ChainStateFlushed(chainActive.GetLocator());\n+        GetMainSignals().ChainStateFlushed(::ChainActive().GetLocator());\n     }\n     } catch (const std::runtime_error& e) {\n         return AbortNode(state, std::string(\"System error while flushing: \") + e.what());\n@@ -3598,7 +3598,7 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckPOW, bool fCheckMerkleRoot)\n {\n     AssertLockHeld(cs_main);\n-    assert(pindexPrev && pindexPrev == chainActive.Tip());\n+    assert(pindexPrev && pindexPrev == ::ChainActive().Tip());\n     CCoinsViewCache viewNew(pcoinsTip.get());\n     uint256 block_hash(block.GetHash());\n     CBlockIndex indexDummy(block);\n@@ -3687,11 +3687,11 @@ static void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPr\n     assert(fPruneMode && nManualPruneHeight > 0);\n \n     LOCK2(cs_main, cs_LastBlockFile);\n-    if (chainActive.Tip() == nullptr)\n+    if (::ChainActive().Tip() == nullptr)\n         return;\n \n     // last block to prune is the lesser of (user-specified height, MIN_BLOCKS_TO_KEEP from the tip)\n-    unsigned int nLastBlockWeCanPrune = std::min((unsigned)nManualPruneHeight, chainActive.Tip()->nHeight - MIN_BLOCKS_TO_KEEP);\n+    unsigned int nLastBlockWeCanPrune = std::min((unsigned)nManualPruneHeight, ::ChainActive().Tip()->nHeight - MIN_BLOCKS_TO_KEEP);\n     int count=0;\n     for (int fileNumber = 0; fileNumber < nLastBlockFile; fileNumber++) {\n         if (vinfoBlockFile[fileNumber].nSize == 0 || vinfoBlockFile[fileNumber].nHeightLast > nLastBlockWeCanPrune)\n@@ -3731,14 +3731,14 @@ void PruneBlockFilesManual(int nManualPruneHeight)\n static void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight)\n {\n     LOCK2(cs_main, cs_LastBlockFile);\n-    if (chainActive.Tip() == nullptr || nPruneTarget == 0) {\n+    if (::ChainActive().Tip() == nullptr || nPruneTarget == 0) {\n         return;\n     }\n-    if ((uint64_t)chainActive.Tip()->nHeight <= nPruneAfterHeight) {\n+    if ((uint64_t)::ChainActive().Tip()->nHeight <= nPruneAfterHeight) {\n         return;\n     }\n \n-    unsigned int nLastBlockWeCanPrune = chainActive.Tip()->nHeight - MIN_BLOCKS_TO_KEEP;\n+    unsigned int nLastBlockWeCanPrune = ::ChainActive().Tip()->nHeight - MIN_BLOCKS_TO_KEEP;\n     uint64_t nCurrentUsage = CalculateCurrentUsage();\n     // We don't check to prune until after we've allocated new space for files\n     // So we should leave a buffer under our target to account for another allocation\n@@ -3935,11 +3935,11 @@ bool LoadChainTip(const CChainParams& chainparams)\n {\n     AssertLockHeld(cs_main);\n \n-    if (chainActive.Tip() && chainActive.Tip()->GetBlockHash() == pcoinsTip->GetBestBlock()) return true;\n+    if (::ChainActive().Tip() && ::ChainActive().Tip()->GetBlockHash() == pcoinsTip->GetBestBlock()) return true;\n \n     if (pcoinsTip->GetBestBlock().IsNull() && mapBlockIndex.size() == 1) {\n         // In case we just added the genesis block, connect it now, so\n-        // that we always have a chainActive.Tip() when we return.\n+        // that we always have a ::ChainActive().Tip() when we return.\n         LogPrintf(\"%s: Connecting genesis block...\\n\", __func__);\n         CValidationState state;\n         if (!ActivateBestChain(state, chainparams)) {\n@@ -3953,14 +3953,14 @@ bool LoadChainTip(const CChainParams& chainparams)\n     if (!pindex) {\n         return false;\n     }\n-    chainActive.SetTip(pindex);\n+    ::ChainActive().SetTip(pindex);\n \n     g_chainstate.PruneBlockIndexCandidates();\n \n     LogPrintf(\"Loaded best chain: hashBestChain=%s height=%d date=%s progress=%f\\n\",\n-        chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(),\n-        FormatISO8601DateTime(chainActive.Tip()->GetBlockTime()),\n-        GuessVerificationProgress(chainparams.TxData(), chainActive.Tip()));\n+        ::ChainActive().Tip()->GetBlockHash().ToString(), ::ChainActive().Height(),\n+        FormatISO8601DateTime(::ChainActive().Tip()->GetBlockTime()),\n+        GuessVerificationProgress(chainparams.TxData(), ::ChainActive().Tip()));\n     return true;\n }\n \n@@ -3977,12 +3977,12 @@ CVerifyDB::~CVerifyDB()\n bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview, int nCheckLevel, int nCheckDepth)\n {\n     LOCK(cs_main);\n-    if (chainActive.Tip() == nullptr || chainActive.Tip()->pprev == nullptr)\n+    if (::ChainActive().Tip() == nullptr || ::ChainActive().Tip()->pprev == nullptr)\n         return true;\n \n     // Verify blocks in the best chain\n-    if (nCheckDepth <= 0 || nCheckDepth > chainActive.Height())\n-        nCheckDepth = chainActive.Height();\n+    if (nCheckDepth <= 0 || nCheckDepth > ::ChainActive().Height())\n+        nCheckDepth = ::ChainActive().Height();\n     nCheckLevel = std::max(0, std::min(4, nCheckLevel));\n     LogPrintf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel);\n     CCoinsViewCache coins(coinsview);\n@@ -3992,16 +3992,16 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n     CValidationState state;\n     int reportDone = 0;\n     LogPrintf(\"[0%%]...\"); /* Continued */\n-    for (pindex = chainActive.Tip(); pindex && pindex->pprev; pindex = pindex->pprev) {\n+    for (pindex = ::ChainActive().Tip(); pindex && pindex->pprev; pindex = pindex->pprev) {\n         boost::this_thread::interruption_point();\n-        const int percentageDone = std::max(1, std::min(99, (int)(((double)(chainActive.Height() - pindex->nHeight)) / (double)nCheckDepth * (nCheckLevel >= 4 ? 50 : 100))));\n+        const int percentageDone = std::max(1, std::min(99, (int)(((double)(::ChainActive().Height() - pindex->nHeight)) / (double)nCheckDepth * (nCheckLevel >= 4 ? 50 : 100))));\n         if (reportDone < percentageDone/10) {\n             // report every 10% step\n             LogPrintf(\"[%d%%]...\", percentageDone); /* Continued */\n             reportDone = percentageDone/10;\n         }\n         uiInterface.ShowProgress(_(\"Verifying blocks...\"), percentageDone, false);\n-        if (pindex->nHeight <= chainActive.Height()-nCheckDepth)\n+        if (pindex->nHeight <= ::ChainActive().Height()-nCheckDepth)\n             break;\n         if (fPruneMode && !(pindex->nStatus & BLOCK_HAVE_DATA)) {\n             // If pruning, only go back as far as we have data.\n@@ -4043,23 +4043,23 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n             return true;\n     }\n     if (pindexFailure)\n-        return error(\"VerifyDB(): *** coin database inconsistencies found (last %i blocks, %i good transactions before that)\\n\", chainActive.Height() - pindexFailure->nHeight + 1, nGoodTransactions);\n+        return error(\"VerifyDB(): *** coin database inconsistencies found (last %i blocks, %i good transactions before that)\\n\", ::ChainActive().Height() - pindexFailure->nHeight + 1, nGoodTransactions);\n \n     // store block count as we move pindex at check level >= 4\n-    int block_count = chainActive.Height() - pindex->nHeight;\n+    int block_count = ::ChainActive().Height() - pindex->nHeight;\n \n     // check level 4: try reconnecting blocks\n     if (nCheckLevel >= 4) {\n-        while (pindex != chainActive.Tip()) {\n+        while (pindex != ::ChainActive().Tip()) {\n             boost::this_thread::interruption_point();\n-            const int percentageDone = std::max(1, std::min(99, 100 - (int)(((double)(chainActive.Height() - pindex->nHeight)) / (double)nCheckDepth * 50)));\n+            const int percentageDone = std::max(1, std::min(99, 100 - (int)(((double)(::ChainActive().Height() - pindex->nHeight)) / (double)nCheckDepth * 50)));\n             if (reportDone < percentageDone/10) {\n                 // report every 10% step\n                 LogPrintf(\"[%d%%]...\", percentageDone); /* Continued */\n                 reportDone = percentageDone/10;\n             }\n             uiInterface.ShowProgress(_(\"Verifying blocks...\"), percentageDone, false);\n-            pindex = chainActive.Next(pindex);\n+            pindex = ::ChainActive().Next(pindex);\n             CBlock block;\n             if (!ReadBlockFromDisk(block, pindex, chainparams.GetConsensus()))\n                 return error(\"VerifyDB(): *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n@@ -4299,8 +4299,8 @@ bool RewindBlockIndex(const CChainParams& params) {\n         return false;\n     }\n \n-    if (chainActive.Tip() != nullptr) {\n-        // FlushStateToDisk can possibly read chainActive. Be conservative\n+    if (::ChainActive().Tip() != nullptr) {\n+        // FlushStateToDisk can possibly read ::ChainActive(). Be conservative\n         // and skip it here, we're about to -reindex-chainstate anyway, so\n         // it'll get called a bunch real soon.\n         CValidationState state;\n@@ -4325,7 +4325,7 @@ void CChainState::UnloadBlockIndex() {\n void UnloadBlockIndex()\n {\n     LOCK(cs_main);\n-    chainActive.SetTip(nullptr);\n+    ::ChainActive().SetTip(nullptr);\n     pindexBestInvalid = nullptr;\n     pindexBestHeader = nullptr;\n     mempool.clear();\n@@ -4721,19 +4721,19 @@ CBlockFileInfo* GetBlockFileInfo(size_t n)\n ThresholdState VersionBitsTipState(const Consensus::Params& params, Consensus::DeploymentPos pos)\n {\n     LOCK(cs_main);\n-    return VersionBitsState(chainActive.Tip(), params, pos, versionbitscache);\n+    return VersionBitsState(::ChainActive().Tip(), params, pos, versionbitscache);\n }\n \n BIP9Stats VersionBitsTipStatistics(const Consensus::Params& params, Consensus::DeploymentPos pos)\n {\n     LOCK(cs_main);\n-    return VersionBitsStatistics(chainActive.Tip(), params, pos);\n+    return VersionBitsStatistics(::ChainActive().Tip(), params, pos);\n }\n \n int VersionBitsTipStateSinceHeight(const Consensus::Params& params, Consensus::DeploymentPos pos)\n {\n     LOCK(cs_main);\n-    return VersionBitsStateSinceHeight(chainActive.Tip(), params, pos, versionbitscache);\n+    return VersionBitsStateSinceHeight(::ChainActive().Tip(), params, pos, versionbitscache);\n }\n \n static const uint64_t MEMPOOL_DUMP_VERSION = 1;"
      },
      {
        "sha": "e43573d51a4d67a88048734df8b2182082ade95c",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -176,7 +176,7 @@ extern bool fHavePruned;\n extern bool fPruneMode;\n /** Number of MiB of block files that we're trying to stay below. */\n extern uint64_t nPruneTarget;\n-/** Block files containing a block-height within MIN_BLOCKS_TO_KEEP of chainActive.Tip() will not be pruned. */\n+/** Block files containing a block-height within MIN_BLOCKS_TO_KEEP of ::ChainActive().Tip() will not be pruned. */\n static const unsigned int MIN_BLOCKS_TO_KEEP = 288;\n /** Minimum blocks required to signal NODE_NETWORK_LIMITED */\n static const unsigned int NODE_NETWORK_LIMITED_MIN_BLOCKS = 288;"
      },
      {
        "sha": "8857a78deef013a432a454bf0fd51483e9ce50c3",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -39,10 +39,10 @@ BOOST_FIXTURE_TEST_CASE(scan_for_wallet_transactions, TestChain100Setup)\n     auto chain = interfaces::MakeChain();\n \n     // Cap last block file size, and mine new block in a new block file.\n-    CBlockIndex* oldTip = chainActive.Tip();\n+    CBlockIndex* oldTip = ::ChainActive().Tip();\n     GetBlockFileInfo(oldTip->GetBlockPos().nFile)->nSize = MAX_BLOCKFILE_SIZE;\n     CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n-    CBlockIndex* newTip = chainActive.Tip();\n+    CBlockIndex* newTip = ::ChainActive().Tip();\n \n     LockAnnotation lock(::cs_main);\n     auto locked_chain = chain->lock();\n@@ -119,10 +119,10 @@ BOOST_FIXTURE_TEST_CASE(importmulti_rescan, TestChain100Setup)\n     auto chain = interfaces::MakeChain();\n \n     // Cap last block file size, and mine new block in a new block file.\n-    CBlockIndex* oldTip = chainActive.Tip();\n+    CBlockIndex* oldTip = ::ChainActive().Tip();\n     GetBlockFileInfo(oldTip->GetBlockPos().nFile)->nSize = MAX_BLOCKFILE_SIZE;\n     CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n-    CBlockIndex* newTip = chainActive.Tip();\n+    CBlockIndex* newTip = ::ChainActive().Tip();\n \n     LockAnnotation lock(::cs_main);\n     auto locked_chain = chain->lock();\n@@ -181,7 +181,7 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n \n     // Create two blocks with same timestamp to verify that importwallet rescan\n     // will pick up both blocks, not just the first.\n-    const int64_t BLOCK_TIME = chainActive.Tip()->GetBlockTimeMax() + 5;\n+    const int64_t BLOCK_TIME = ::ChainActive().Tip()->GetBlockTimeMax() + 5;\n     SetMockTime(BLOCK_TIME);\n     m_coinbase_txns.emplace_back(CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey())).vtx[0]);\n     m_coinbase_txns.emplace_back(CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey())).vtx[0]);\n@@ -249,7 +249,7 @@ BOOST_FIXTURE_TEST_CASE(coin_mark_dirty_immature_credit, TestChain100Setup)\n     CWalletTx wtx(&wallet, m_coinbase_txns.back());\n     auto locked_chain = chain->lock();\n     LOCK(wallet.cs_wallet);\n-    wtx.hashBlock = chainActive.Tip()->GetBlockHash();\n+    wtx.hashBlock = ::ChainActive().Tip()->GetBlockHash();\n     wtx.nIndex = 0;\n \n     // Call GetImmatureCredit() once before adding the key to the wallet to\n@@ -346,10 +346,10 @@ class ListCoinsTestingSetup : public TestChain100Setup\n         AddKey(*wallet, coinbaseKey);\n         WalletRescanReserver reserver(wallet.get());\n         reserver.reserve();\n-        CWallet::ScanResult result = wallet->ScanForWalletTransactions(chainActive.Genesis()->GetBlockHash(), {} /* stop_block */, reserver, false /* update */);\n+        CWallet::ScanResult result = wallet->ScanForWalletTransactions(::ChainActive().Genesis()->GetBlockHash(), {} /* stop_block */, reserver, false /* update */);\n         BOOST_CHECK_EQUAL(result.status, CWallet::ScanResult::SUCCESS);\n-        BOOST_CHECK_EQUAL(result.last_scanned_block, chainActive.Tip()->GetBlockHash());\n-        BOOST_CHECK_EQUAL(*result.last_scanned_height, chainActive.Height());\n+        BOOST_CHECK_EQUAL(result.last_scanned_block, ::ChainActive().Tip()->GetBlockHash());\n+        BOOST_CHECK_EQUAL(*result.last_scanned_height, ::ChainActive().Height());\n         BOOST_CHECK(result.last_failed_block.IsNull());\n     }\n \n@@ -378,7 +378,7 @@ class ListCoinsTestingSetup : public TestChain100Setup\n         LOCK(wallet->cs_wallet);\n         auto it = wallet->mapWallet.find(tx->GetHash());\n         BOOST_CHECK(it != wallet->mapWallet.end());\n-        it->second.SetMerkleBranch(chainActive.Tip()->GetBlockHash(), 1);\n+        it->second.SetMerkleBranch(::ChainActive().Tip()->GetBlockHash(), 1);\n         return it->second;\n     }\n "
      },
      {
        "sha": "5e32f2154b7c5ecc57d81b7a29681ef489901f12",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/631940aab228ccca64c15e05d5953f40381a0ffc/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/631940aab228ccca64c15e05d5953f40381a0ffc/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=631940aab228ccca64c15e05d5953f40381a0ffc",
        "patch": "@@ -1288,7 +1288,7 @@ void CWallet::UpdatedBlockTip()\n void CWallet::BlockUntilSyncedToCurrentChain() {\n     AssertLockNotHeld(cs_wallet);\n     // Skip the queue-draining stuff if we know we're caught up with\n-    // chainActive.Tip(), otherwise put a callback in the validation interface queue and wait\n+    // ::ChainActive().Tip(), otherwise put a callback in the validation interface queue and wait\n     // for the queue to drain enough to execute it (indicating we are caught up\n     // at least with the time we entered this function).\n     uint256 last_block_hash = WITH_LOCK(cs_wallet, return m_last_block_processed);"
      }
    ]
  },
  {
    "sha": "486c1eea863a41e597ae4fddc392f446f2518b4b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ODZjMWVlYTg2M2E0MWU1OTdhZTRmZGRjMzkyZjQ0NmYyNTE4YjRi",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-03-27T17:54:18Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-05-03T19:03:05Z"
      },
      "message": "refactoring: remove unused chainActive",
      "tree": {
        "sha": "008b6d2dc7e51fe1b01341f2eabf75085d16f2b3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/008b6d2dc7e51fe1b01341f2eabf75085d16f2b3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/486c1eea863a41e597ae4fddc392f446f2518b4b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/486c1eea863a41e597ae4fddc392f446f2518b4b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/486c1eea863a41e597ae4fddc392f446f2518b4b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/486c1eea863a41e597ae4fddc392f446f2518b4b/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "631940aab228ccca64c15e05d5953f40381a0ffc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/631940aab228ccca64c15e05d5953f40381a0ffc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/631940aab228ccca64c15e05d5953f40381a0ffc"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 0,
      "deletions": 4
    },
    "files": [
      {
        "sha": "e94574b7ba644ea7e8112414566351cf03ca42e0",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/486c1eea863a41e597ae4fddc392f446f2518b4b/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/486c1eea863a41e597ae4fddc392f446f2518b4b/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=486c1eea863a41e597ae4fddc392f446f2518b4b",
        "patch": "@@ -235,7 +235,6 @@ CChain& ChainActive() { return g_chainstate.m_chain; }\n RecursiveMutex cs_main;\n \n BlockMap& mapBlockIndex = g_chainstate.mapBlockIndex;\n-CChain& chainActive = g_chainstate.m_chain;\n CBlockIndex *pindexBestHeader = nullptr;\n Mutex g_best_block_mutex;\n std::condition_variable g_best_block_cv;"
      },
      {
        "sha": "7efb11fc9f77ec2f5988b3275fcad047c952675d",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/486c1eea863a41e597ae4fddc392f446f2518b4b/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/486c1eea863a41e597ae4fddc392f446f2518b4b/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=486c1eea863a41e597ae4fddc392f446f2518b4b",
        "patch": "@@ -435,9 +435,6 @@ bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, C\n /** Remove invalidity status from a block and its descendants. */\n void ResetBlockFailureFlags(CBlockIndex* pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-/** The currently-connected chain of blocks (protected by cs_main). */\n-extern CChain& chainActive;\n-\n /** @returns the most-work chain. */\n CChain& ChainActive();\n "
      }
    ]
  }
]