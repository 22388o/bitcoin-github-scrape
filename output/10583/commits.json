[
  {
    "sha": "39633ecd5c18ca29cb551f701e57e8cec3e609da",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozOTYzM2VjZDVjMThjYTI5Y2I1NTFmNzAxZTU3ZThjZWMzZTYwOWRh",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-12-04T16:42:15Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-02-15T23:11:06Z"
      },
      "message": "[rpc] split wallet and non-wallet parts of DescribeAddressVisitor",
      "tree": {
        "sha": "ce600b48acabc66921f2865c98186502d09728e5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ce600b48acabc66921f2865c98186502d09728e5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/39633ecd5c18ca29cb551f701e57e8cec3e609da",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39633ecd5c18ca29cb551f701e57e8cec3e609da",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/39633ecd5c18ca29cb551f701e57e8cec3e609da",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39633ecd5c18ca29cb551f701e57e8cec3e609da/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3fa556aee2030e3b7e7609d9b11b4d6e5ff3ec2c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3fa556aee2030e3b7e7609d9b11b4d6e5ff3ec2c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3fa556aee2030e3b7e7609d9b11b4d6e5ff3ec2c"
      }
    ],
    "stats": {
      "total": 89,
      "additions": 63,
      "deletions": 26
    },
    "files": [
      {
        "sha": "a1e39be64e72c2d6c7e334f0fbcd33fcaa5470a0",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 63,
        "deletions": 26,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39633ecd5c18ca29cb551f701e57e8cec3e609da/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39633ecd5c18ca29cb551f701e57e8cec3e609da/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=39633ecd5c18ca29cb551f701e57e8cec3e609da",
        "patch": "@@ -33,13 +33,62 @@\n \n #include <univalue.h>\n \n-#ifdef ENABLE_WALLET\n class DescribeAddressVisitor : public boost::static_visitor<UniValue>\n {\n public:\n-    CWallet * const pwallet;\n+    explicit DescribeAddressVisitor() {}\n+\n+    UniValue operator()(const CNoDestination &dest) const { return UniValue(UniValue::VOBJ); }\n+\n+    UniValue operator()(const CKeyID &keyID) const {\n+        UniValue obj(UniValue::VOBJ);\n+        obj.pushKV(\"isscript\", false);\n+        obj.pushKV(\"iswitness\", false);\n+        return obj;\n+    }\n+\n+    UniValue operator()(const CScriptID &scriptID) const {\n+        UniValue obj(UniValue::VOBJ);\n+        obj.pushKV(\"isscript\", true);\n+        obj.pushKV(\"iswitness\", false);\n+        return obj;\n+    }\n+\n+    UniValue operator()(const WitnessV0KeyHash& id) const\n+    {\n+        UniValue obj(UniValue::VOBJ);\n+        obj.pushKV(\"isscript\", false);\n+        obj.pushKV(\"iswitness\", true);\n+        obj.pushKV(\"witness_version\", 0);\n+        obj.pushKV(\"witness_program\", HexStr(id.begin(), id.end()));\n+        return obj;\n+    }\n+\n+    UniValue operator()(const WitnessV0ScriptHash& id) const\n+    {\n+        UniValue obj(UniValue::VOBJ);\n+        obj.pushKV(\"isscript\", true);\n+        obj.pushKV(\"iswitness\", true);\n+        obj.pushKV(\"witness_version\", 0);\n+        obj.pushKV(\"witness_program\", HexStr(id.begin(), id.end()));\n+        return obj;\n+    }\n \n-    explicit DescribeAddressVisitor(CWallet *_pwallet) : pwallet(_pwallet) {}\n+    UniValue operator()(const WitnessUnknown& id) const\n+    {\n+        UniValue obj(UniValue::VOBJ);\n+        obj.pushKV(\"iswitness\", true);\n+        obj.pushKV(\"witness_version\", (int)id.version);\n+        obj.pushKV(\"witness_program\", HexStr(id.program, id.program + id.length));\n+        return obj;\n+    }\n+};\n+\n+#ifdef ENABLE_WALLET\n+class DescribeWalletAddressVisitor : public boost::static_visitor<UniValue>\n+{\n+public:\n+    CWallet * const pwallet;\n \n     void ProcessSubScript(const CScript& subscript, UniValue& obj, bool include_addresses = false) const\n     {\n@@ -54,7 +103,11 @@ class DescribeAddressVisitor : public boost::static_visitor<UniValue>\n         UniValue a(UniValue::VARR);\n         if (ExtractDestination(subscript, embedded)) {\n             // Only when the script corresponds to an address.\n-            UniValue subobj = boost::apply_visitor(*this, embedded);\n+            UniValue subobj(UniValue::VOBJ);\n+            UniValue detail = boost::apply_visitor(DescribeAddressVisitor(), embedded);\n+            subobj.pushKVs(detail);\n+            UniValue wallet_detail = boost::apply_visitor(*this, embedded);\n+            subobj.pushKVs(wallet_detail);\n             subobj.pushKV(\"address\", EncodeDestination(embedded));\n             subobj.pushKV(\"scriptPubKey\", HexStr(subscript.begin(), subscript.end()));\n             // Always report the pubkey at the top level, so that `getnewaddress()['pubkey']` always works.\n@@ -81,13 +134,13 @@ class DescribeAddressVisitor : public boost::static_visitor<UniValue>\n         if (include_addresses) obj.pushKV(\"addresses\", std::move(a));\n     }\n \n+    explicit DescribeWalletAddressVisitor(CWallet *_pwallet) : pwallet(_pwallet) {}\n+\n     UniValue operator()(const CNoDestination &dest) const { return UniValue(UniValue::VOBJ); }\n \n     UniValue operator()(const CKeyID &keyID) const {\n         UniValue obj(UniValue::VOBJ);\n         CPubKey vchPubKey;\n-        obj.pushKV(\"isscript\", false);\n-        obj.pushKV(\"iswitness\", false);\n         if (pwallet && pwallet->GetPubKey(keyID, vchPubKey)) {\n             obj.pushKV(\"pubkey\", HexStr(vchPubKey));\n             obj.pushKV(\"iscompressed\", vchPubKey.IsCompressed());\n@@ -98,8 +151,6 @@ class DescribeAddressVisitor : public boost::static_visitor<UniValue>\n     UniValue operator()(const CScriptID &scriptID) const {\n         UniValue obj(UniValue::VOBJ);\n         CScript subscript;\n-        obj.pushKV(\"isscript\", true);\n-        obj.pushKV(\"iswitness\", false);\n         if (pwallet && pwallet->GetCScript(scriptID, subscript)) {\n             ProcessSubScript(subscript, obj, true);\n         }\n@@ -110,10 +161,6 @@ class DescribeAddressVisitor : public boost::static_visitor<UniValue>\n     {\n         UniValue obj(UniValue::VOBJ);\n         CPubKey pubkey;\n-        obj.pushKV(\"isscript\", false);\n-        obj.pushKV(\"iswitness\", true);\n-        obj.pushKV(\"witness_version\", 0);\n-        obj.pushKV(\"witness_program\", HexStr(id.begin(), id.end()));\n         if (pwallet && pwallet->GetPubKey(CKeyID(id), pubkey)) {\n             obj.pushKV(\"pubkey\", HexStr(pubkey));\n         }\n@@ -124,10 +171,6 @@ class DescribeAddressVisitor : public boost::static_visitor<UniValue>\n     {\n         UniValue obj(UniValue::VOBJ);\n         CScript subscript;\n-        obj.pushKV(\"isscript\", true);\n-        obj.pushKV(\"iswitness\", true);\n-        obj.pushKV(\"witness_version\", 0);\n-        obj.pushKV(\"witness_program\", HexStr(id.begin(), id.end()));\n         CRIPEMD160 hasher;\n         uint160 hash;\n         hasher.Write(id.begin(), 32).Finalize(hash.begin());\n@@ -137,15 +180,7 @@ class DescribeAddressVisitor : public boost::static_visitor<UniValue>\n         return obj;\n     }\n \n-    UniValue operator()(const WitnessUnknown& id) const\n-    {\n-        UniValue obj(UniValue::VOBJ);\n-        CScript subscript;\n-        obj.pushKV(\"iswitness\", true);\n-        obj.pushKV(\"witness_version\", (int)id.version);\n-        obj.pushKV(\"witness_program\", HexStr(id.program, id.program + id.length));\n-        return obj;\n-    }\n+    UniValue operator()(const WitnessUnknown& id) const { return UniValue(UniValue::VOBJ); }\n };\n #endif\n \n@@ -219,8 +254,10 @@ UniValue validateaddress(const JSONRPCRequest& request)\n         isminetype mine = pwallet ? IsMine(*pwallet, dest) : ISMINE_NO;\n         ret.pushKV(\"ismine\", bool(mine & ISMINE_SPENDABLE));\n         ret.pushKV(\"iswatchonly\", bool(mine & ISMINE_WATCH_ONLY));\n-        UniValue detail = boost::apply_visitor(DescribeAddressVisitor(pwallet), dest);\n+        UniValue detail = boost::apply_visitor(DescribeAddressVisitor(), dest);\n         ret.pushKVs(detail);\n+        UniValue wallet_detail = boost::apply_visitor(DescribeWalletAddressVisitor(pwallet), dest);\n+        ret.pushKVs(wallet_detail);\n         if (pwallet && pwallet->mapAddressBook.count(dest)) {\n             ret.pushKV(\"account\", pwallet->mapAddressBook[dest].name);\n         }"
      }
    ]
  },
  {
    "sha": "1598f32304cd55b83ecc623ee0f9e30b4e087b7d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNTk4ZjMyMzA0Y2Q1NWI4M2VjYzYyM2VlMGY5ZTMwYjRlMDg3Yjdk",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-12-04T17:49:20Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-02-16T17:09:26Z"
      },
      "message": "[rpc] Move DescribeAddressVisitor to rpc/util",
      "tree": {
        "sha": "ec538026ed4ed137e19b75ea104f8ba3d71ab8f3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ec538026ed4ed137e19b75ea104f8ba3d71ab8f3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1598f32304cd55b83ecc623ee0f9e30b4e087b7d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1598f32304cd55b83ecc623ee0f9e30b4e087b7d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1598f32304cd55b83ecc623ee0f9e30b4e087b7d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1598f32304cd55b83ecc623ee0f9e30b4e087b7d/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "39633ecd5c18ca29cb551f701e57e8cec3e609da",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39633ecd5c18ca29cb551f701e57e8cec3e609da",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/39633ecd5c18ca29cb551f701e57e8cec3e609da"
      }
    ],
    "stats": {
      "total": 137,
      "additions": 83,
      "deletions": 54
    },
    "files": [
      {
        "sha": "aa1647a63a74df644e6e4efb43fc0e33cc1c461e",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1598f32304cd55b83ecc623ee0f9e30b4e087b7d/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1598f32304cd55b83ecc623ee0f9e30b4e087b7d/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=1598f32304cd55b83ecc623ee0f9e30b4e087b7d",
        "patch": "@@ -215,6 +215,7 @@ libbitcoin_server_a_SOURCES = \\\n   rpc/rawtransaction.cpp \\\n   rpc/safemode.cpp \\\n   rpc/server.cpp \\\n+  rpc/util.cpp \\\n   script/sigcache.cpp \\\n   script/ismine.cpp \\\n   timedata.cpp \\"
      },
      {
        "sha": "f7d62a6326937a4aa859bf39890e49c5ba333d69",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 54,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1598f32304cd55b83ecc623ee0f9e30b4e087b7d/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1598f32304cd55b83ecc623ee0f9e30b4e087b7d/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=1598f32304cd55b83ecc623ee0f9e30b4e087b7d",
        "patch": "@@ -33,57 +33,6 @@\n \n #include <univalue.h>\n \n-class DescribeAddressVisitor : public boost::static_visitor<UniValue>\n-{\n-public:\n-    explicit DescribeAddressVisitor() {}\n-\n-    UniValue operator()(const CNoDestination &dest) const { return UniValue(UniValue::VOBJ); }\n-\n-    UniValue operator()(const CKeyID &keyID) const {\n-        UniValue obj(UniValue::VOBJ);\n-        obj.pushKV(\"isscript\", false);\n-        obj.pushKV(\"iswitness\", false);\n-        return obj;\n-    }\n-\n-    UniValue operator()(const CScriptID &scriptID) const {\n-        UniValue obj(UniValue::VOBJ);\n-        obj.pushKV(\"isscript\", true);\n-        obj.pushKV(\"iswitness\", false);\n-        return obj;\n-    }\n-\n-    UniValue operator()(const WitnessV0KeyHash& id) const\n-    {\n-        UniValue obj(UniValue::VOBJ);\n-        obj.pushKV(\"isscript\", false);\n-        obj.pushKV(\"iswitness\", true);\n-        obj.pushKV(\"witness_version\", 0);\n-        obj.pushKV(\"witness_program\", HexStr(id.begin(), id.end()));\n-        return obj;\n-    }\n-\n-    UniValue operator()(const WitnessV0ScriptHash& id) const\n-    {\n-        UniValue obj(UniValue::VOBJ);\n-        obj.pushKV(\"isscript\", true);\n-        obj.pushKV(\"iswitness\", true);\n-        obj.pushKV(\"witness_version\", 0);\n-        obj.pushKV(\"witness_program\", HexStr(id.begin(), id.end()));\n-        return obj;\n-    }\n-\n-    UniValue operator()(const WitnessUnknown& id) const\n-    {\n-        UniValue obj(UniValue::VOBJ);\n-        obj.pushKV(\"iswitness\", true);\n-        obj.pushKV(\"witness_version\", (int)id.version);\n-        obj.pushKV(\"witness_program\", HexStr(id.program, id.program + id.length));\n-        return obj;\n-    }\n-};\n-\n #ifdef ENABLE_WALLET\n class DescribeWalletAddressVisitor : public boost::static_visitor<UniValue>\n {\n@@ -182,6 +131,15 @@ class DescribeWalletAddressVisitor : public boost::static_visitor<UniValue>\n \n     UniValue operator()(const WitnessUnknown& id) const { return UniValue(UniValue::VOBJ); }\n };\n+\n+UniValue DescribeWalletAddress(CWallet* pwallet, const CTxDestination& dest)\n+{\n+    UniValue ret(UniValue::VOBJ);\n+    UniValue detail = DescribeAddress(dest);\n+    ret.pushKVs(detail);\n+    ret.pushKVs(boost::apply_visitor(DescribeWalletAddressVisitor(pwallet), dest));\n+    return ret;\n+}\n #endif\n \n UniValue validateaddress(const JSONRPCRequest& request)\n@@ -254,10 +212,8 @@ UniValue validateaddress(const JSONRPCRequest& request)\n         isminetype mine = pwallet ? IsMine(*pwallet, dest) : ISMINE_NO;\n         ret.pushKV(\"ismine\", bool(mine & ISMINE_SPENDABLE));\n         ret.pushKV(\"iswatchonly\", bool(mine & ISMINE_WATCH_ONLY));\n-        UniValue detail = boost::apply_visitor(DescribeAddressVisitor(), dest);\n+        UniValue detail = DescribeWalletAddress(pwallet, dest);\n         ret.pushKVs(detail);\n-        UniValue wallet_detail = boost::apply_visitor(DescribeWalletAddressVisitor(pwallet), dest);\n-        ret.pushKVs(wallet_detail);\n         if (pwallet && pwallet->mapAddressBook.count(dest)) {\n             ret.pushKV(\"account\", pwallet->mapAddressBook[dest].name);\n         }\n@@ -284,6 +240,8 @@ UniValue validateaddress(const JSONRPCRequest& request)\n                 }\n             }\n         }\n+#else\n+        ret.pushKvs = DescribeAddress(dest);\n #endif\n     }\n     return ret;"
      },
      {
        "sha": "cdcb68d15f94a9c13f14adb799c3e0dc28581591",
        "filename": "src/rpc/util.cpp",
        "status": "modified",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1598f32304cd55b83ecc623ee0f9e30b4e087b7d/src/rpc/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1598f32304cd55b83ecc623ee0f9e30b4e087b7d/src/rpc/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.cpp?ref=1598f32304cd55b83ecc623ee0f9e30b4e087b7d",
        "patch": "@@ -66,3 +66,64 @@ CScript CreateMultisigRedeemscript(const int required, const std::vector<CPubKey\n \n     return result;\n }\n+\n+class DescribeAddressVisitor : public boost::static_visitor<UniValue>\n+{\n+public:\n+    explicit DescribeAddressVisitor() {}\n+\n+    UniValue operator()(const CNoDestination& dest) const\n+    {\n+        return UniValue(UniValue::VOBJ);\n+    }\n+\n+    UniValue operator()(const CKeyID& keyID) const\n+    {\n+        UniValue obj(UniValue::VOBJ);\n+        obj.pushKV(\"isscript\", false);\n+        obj.pushKV(\"iswitness\", false);\n+        return obj;\n+    }\n+\n+    UniValue operator()(const CScriptID& scriptID) const\n+    {\n+        UniValue obj(UniValue::VOBJ);\n+        obj.pushKV(\"isscript\", true);\n+        obj.pushKV(\"iswitness\", false);\n+        return obj;\n+    }\n+\n+    UniValue operator()(const WitnessV0KeyHash& id) const\n+    {\n+        UniValue obj(UniValue::VOBJ);\n+        obj.pushKV(\"isscript\", false);\n+        obj.pushKV(\"iswitness\", true);\n+        obj.pushKV(\"witness_version\", 0);\n+        obj.pushKV(\"witness_program\", HexStr(id.begin(), id.end()));\n+        return obj;\n+    }\n+\n+    UniValue operator()(const WitnessV0ScriptHash& id) const\n+    {\n+        UniValue obj(UniValue::VOBJ);\n+        obj.pushKV(\"isscript\", true);\n+        obj.pushKV(\"iswitness\", true);\n+        obj.pushKV(\"witness_version\", 0);\n+        obj.pushKV(\"witness_program\", HexStr(id.begin(), id.end()));\n+        return obj;\n+    }\n+\n+    UniValue operator()(const WitnessUnknown& id) const\n+    {\n+        UniValue obj(UniValue::VOBJ);\n+        obj.pushKV(\"iswitness\", true);\n+        obj.pushKV(\"witness_version\", (int)id.version);\n+        obj.pushKV(\"witness_program\", HexStr(id.program, id.program + id.length));\n+        return obj;\n+    }\n+};\n+\n+UniValue DescribeAddress(const CTxDestination& dest)\n+{\n+    return boost::apply_visitor(DescribeAddressVisitor(), dest);\n+}"
      },
      {
        "sha": "5380d45a8356288ae66bdd2623406cdbda3cdbb1",
        "filename": "src/rpc/util.h",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1598f32304cd55b83ecc623ee0f9e30b4e087b7d/src/rpc/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1598f32304cd55b83ecc623ee0f9e30b4e087b7d/src/rpc/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.h?ref=1598f32304cd55b83ecc623ee0f9e30b4e087b7d",
        "patch": "@@ -5,6 +5,13 @@\n #ifndef BITCOIN_RPC_UTIL_H\n #define BITCOIN_RPC_UTIL_H\n \n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <univalue.h>\n+#include <utilstrencodings.h>\n+\n+#include <boost/variant/static_visitor.hpp>\n+\n #include <string>\n #include <vector>\n \n@@ -16,4 +23,6 @@ CPubKey HexToPubKey(const std::string& hex_in);\n CPubKey AddrToPubKey(CKeyStore* const keystore, const std::string& addr_in);\n CScript CreateMultisigRedeemscript(const int required, const std::vector<CPubKey>& pubkeys);\n \n+UniValue DescribeAddress(const CTxDestination& dest);\n+\n #endif // BITCOIN_RPC_UTIL_H"
      }
    ]
  },
  {
    "sha": "b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiOThiZmM1ZWQwZGExZWZlZjFlZmY1NTJhN2UxYTdjZTljYWYxMzBm",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2017-06-13T01:53:46Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-02-16T17:09:32Z"
      },
      "message": "Create getaddressinfo RPC and deprecate parts of validateaddress\n\nMoves the parts of validateaddress which require the wallet into getaddressinfo\nwhich is part of the wallet RPCs. Mark those parts of validateaddress which\nrequire the wallet as deprecated.\n\nValidateaddress will  call getaddressinfo\nfor the data that both share for right now.\n\nMoves IsMine functions to libbitcoin_common and then links libbitcoin_wallet\nbefore libbitcoin_common in order to prevent linker errors since IsMine is no\nlonger used in libbitcoin_server.",
      "tree": {
        "sha": "6124ecff8ff0e24d707d85e790c591fac92ee2b0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6124ecff8ff0e24d707d85e790c591fac92ee2b0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1598f32304cd55b83ecc623ee0f9e30b4e087b7d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1598f32304cd55b83ecc623ee0f9e30b4e087b7d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1598f32304cd55b83ecc623ee0f9e30b4e087b7d"
      }
    ],
    "stats": {
      "total": 447,
      "additions": 253,
      "deletions": 194
    },
    "files": [
      {
        "sha": "9ca2b2c82a94a572612af6b5fccff8c339268888",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f",
        "patch": "@@ -135,10 +135,10 @@ BITCOIN_CORE_H = \\\n   rpc/register.h \\\n   rpc/util.h \\\n   scheduler.h \\\n+  script/ismine.h \\\n   script/sigcache.h \\\n   script/sign.h \\\n   script/standard.h \\\n-  script/ismine.h \\\n   streams.h \\\n   support/allocators/secure.h \\\n   support/allocators/zeroafterfree.h \\\n@@ -215,9 +215,7 @@ libbitcoin_server_a_SOURCES = \\\n   rpc/rawtransaction.cpp \\\n   rpc/safemode.cpp \\\n   rpc/server.cpp \\\n-  rpc/util.cpp \\\n   script/sigcache.cpp \\\n-  script/ismine.cpp \\\n   timedata.cpp \\\n   torcontrol.cpp \\\n   txdb.cpp \\\n@@ -334,6 +332,7 @@ libbitcoin_common_a_SOURCES = \\\n   policy/feerate.cpp \\\n   protocol.cpp \\\n   scheduler.cpp \\\n+  script/ismine.cpp \\\n   script/sign.cpp \\\n   script/standard.cpp \\\n   warnings.cpp \\\n@@ -390,10 +389,10 @@ endif\n \n bitcoind_LDADD = \\\n   $(LIBBITCOIN_SERVER) \\\n+  $(LIBBITCOIN_WALLET) \\\n   $(LIBBITCOIN_COMMON) \\\n   $(LIBUNIVALUE) \\\n   $(LIBBITCOIN_UTIL) \\\n-  $(LIBBITCOIN_WALLET) \\\n   $(LIBBITCOIN_ZMQ) \\\n   $(LIBBITCOIN_CONSENSUS) \\\n   $(LIBBITCOIN_CRYPTO) \\"
      },
      {
        "sha": "13c27299f8980331ff6089ab124fec664dc32625",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f",
        "patch": "@@ -35,6 +35,7 @@ bench_bench_bitcoin_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(EVENT_CLFAGS\n bench_bench_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n bench_bench_bitcoin_LDADD = \\\n   $(LIBBITCOIN_SERVER) \\\n+  $(LIBBITCOIN_WALLET) \\\n   $(LIBBITCOIN_COMMON) \\\n   $(LIBBITCOIN_UTIL) \\\n   $(LIBBITCOIN_CONSENSUS) \\\n@@ -51,7 +52,6 @@ endif\n \n if ENABLE_WALLET\n bench_bench_bitcoin_SOURCES += bench/coin_selection.cpp\n-bench_bench_bitcoin_LDADD += $(LIBBITCOIN_WALLET) $(LIBBITCOIN_CRYPTO)\n endif\n \n bench_bench_bitcoin_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)"
      },
      {
        "sha": "61bd59e9edab595ac14632cb63bd370d0d5904fa",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 181,
        "changes": 202,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f",
        "patch": "@@ -33,216 +33,56 @@\n \n #include <univalue.h>\n \n-#ifdef ENABLE_WALLET\n-class DescribeWalletAddressVisitor : public boost::static_visitor<UniValue>\n-{\n-public:\n-    CWallet * const pwallet;\n-\n-    void ProcessSubScript(const CScript& subscript, UniValue& obj, bool include_addresses = false) const\n-    {\n-        // Always present: script type and redeemscript\n-        txnouttype which_type;\n-        std::vector<std::vector<unsigned char>> solutions_data;\n-        Solver(subscript, which_type, solutions_data);\n-        obj.pushKV(\"script\", GetTxnOutputType(which_type));\n-        obj.pushKV(\"hex\", HexStr(subscript.begin(), subscript.end()));\n-\n-        CTxDestination embedded;\n-        UniValue a(UniValue::VARR);\n-        if (ExtractDestination(subscript, embedded)) {\n-            // Only when the script corresponds to an address.\n-            UniValue subobj(UniValue::VOBJ);\n-            UniValue detail = boost::apply_visitor(DescribeAddressVisitor(), embedded);\n-            subobj.pushKVs(detail);\n-            UniValue wallet_detail = boost::apply_visitor(*this, embedded);\n-            subobj.pushKVs(wallet_detail);\n-            subobj.pushKV(\"address\", EncodeDestination(embedded));\n-            subobj.pushKV(\"scriptPubKey\", HexStr(subscript.begin(), subscript.end()));\n-            // Always report the pubkey at the top level, so that `getnewaddress()['pubkey']` always works.\n-            if (subobj.exists(\"pubkey\")) obj.pushKV(\"pubkey\", subobj[\"pubkey\"]);\n-            obj.pushKV(\"embedded\", std::move(subobj));\n-            if (include_addresses) a.push_back(EncodeDestination(embedded));\n-        } else if (which_type == TX_MULTISIG) {\n-            // Also report some information on multisig scripts (which do not have a corresponding address).\n-            // TODO: abstract out the common functionality between this logic and ExtractDestinations.\n-            obj.pushKV(\"sigsrequired\", solutions_data[0][0]);\n-            UniValue pubkeys(UniValue::VARR);\n-            for (size_t i = 1; i < solutions_data.size() - 1; ++i) {\n-                CPubKey key(solutions_data[i].begin(), solutions_data[i].end());\n-                if (include_addresses) a.push_back(EncodeDestination(key.GetID()));\n-                pubkeys.push_back(HexStr(key.begin(), key.end()));\n-            }\n-            obj.pushKV(\"pubkeys\", std::move(pubkeys));\n-        }\n-\n-        // The \"addresses\" field is confusing because it refers to public keys using their P2PKH address.\n-        // For that reason, only add the 'addresses' field when needed for backward compatibility. New applications\n-        // can use the 'embedded'->'address' field for P2SH or P2WSH wrapped addresses, and 'pubkeys' for\n-        // inspecting multisig participants.\n-        if (include_addresses) obj.pushKV(\"addresses\", std::move(a));\n-    }\n-\n-    explicit DescribeWalletAddressVisitor(CWallet *_pwallet) : pwallet(_pwallet) {}\n-\n-    UniValue operator()(const CNoDestination &dest) const { return UniValue(UniValue::VOBJ); }\n-\n-    UniValue operator()(const CKeyID &keyID) const {\n-        UniValue obj(UniValue::VOBJ);\n-        CPubKey vchPubKey;\n-        if (pwallet && pwallet->GetPubKey(keyID, vchPubKey)) {\n-            obj.pushKV(\"pubkey\", HexStr(vchPubKey));\n-            obj.pushKV(\"iscompressed\", vchPubKey.IsCompressed());\n-        }\n-        return obj;\n-    }\n-\n-    UniValue operator()(const CScriptID &scriptID) const {\n-        UniValue obj(UniValue::VOBJ);\n-        CScript subscript;\n-        if (pwallet && pwallet->GetCScript(scriptID, subscript)) {\n-            ProcessSubScript(subscript, obj, true);\n-        }\n-        return obj;\n-    }\n-\n-    UniValue operator()(const WitnessV0KeyHash& id) const\n-    {\n-        UniValue obj(UniValue::VOBJ);\n-        CPubKey pubkey;\n-        if (pwallet && pwallet->GetPubKey(CKeyID(id), pubkey)) {\n-            obj.pushKV(\"pubkey\", HexStr(pubkey));\n-        }\n-        return obj;\n-    }\n-\n-    UniValue operator()(const WitnessV0ScriptHash& id) const\n-    {\n-        UniValue obj(UniValue::VOBJ);\n-        CScript subscript;\n-        CRIPEMD160 hasher;\n-        uint160 hash;\n-        hasher.Write(id.begin(), 32).Finalize(hash.begin());\n-        if (pwallet && pwallet->GetCScript(CScriptID(hash), subscript)) {\n-            ProcessSubScript(subscript, obj);\n-        }\n-        return obj;\n-    }\n-\n-    UniValue operator()(const WitnessUnknown& id) const { return UniValue(UniValue::VOBJ); }\n-};\n-\n-UniValue DescribeWalletAddress(CWallet* pwallet, const CTxDestination& dest)\n-{\n-    UniValue ret(UniValue::VOBJ);\n-    UniValue detail = DescribeAddress(dest);\n-    ret.pushKVs(detail);\n-    ret.pushKVs(boost::apply_visitor(DescribeWalletAddressVisitor(pwallet), dest));\n-    return ret;\n-}\n-#endif\n-\n UniValue validateaddress(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n         throw std::runtime_error(\n             \"validateaddress \\\"address\\\"\\n\"\n             \"\\nReturn information about the given bitcoin address.\\n\"\n+            \"DEPRECATION WARNING: Parts of this command have been deprecated and moved to getaddressinfo. Clients must\\n\"\n+            \"transition to using getaddressinfo to access this information before upgrading to v0.18. The following deprecated\\n\"\n+            \"fields have moved to getaddressinfo and will only be shown here with -deprecatedrpc=validateaddress: ismine, iswatchonly,\\n\"\n+            \"script, hex, pubkeys, sigsrequired, pubkey, addresses, embedded, iscompressed, account, timestamp, hdkeypath, kdmasterkeyid.\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"address\\\"     (string, required) The bitcoin address to validate\\n\"\n+            \"1. \\\"address\\\"                    (string, required) The bitcoin address to validate\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"isvalid\\\" : true|false,       (boolean) If the address is valid or not. If not, this is the only property returned.\\n\"\n             \"  \\\"address\\\" : \\\"address\\\",        (string) The bitcoin address validated\\n\"\n             \"  \\\"scriptPubKey\\\" : \\\"hex\\\",       (string) The hex encoded scriptPubKey generated by the address\\n\"\n-            \"  \\\"ismine\\\" : true|false,        (boolean) If the address is yours or not\\n\"\n-            \"  \\\"iswatchonly\\\" : true|false,   (boolean) If the address is watchonly\\n\"\n-            \"  \\\"isscript\\\" : true|false,      (boolean, optional) If the address is P2SH or P2WSH. Not included for unknown witness types.\\n\"\n-            \"  \\\"iswitness\\\" : true|false,     (boolean) If the address is P2WPKH, P2WSH, or an unknown witness version\\n\"\n-            \"  \\\"witness_version\\\" : version   (number, optional) For all witness output types, gives the version number.\\n\"\n-            \"  \\\"witness_program\\\" : \\\"hex\\\"     (string, optional) For all witness output types, gives the script or key hash present in the address.\\n\"\n-            \"  \\\"script\\\" : \\\"type\\\"             (string, optional) The output script type. Only if \\\"isscript\\\" is true and the redeemscript is known. Possible types: nonstandard, pubkey, pubkeyhash, scripthash, multisig, nulldata, witness_v0_keyhash, witness_v0_scripthash, witness_unknown\\n\"\n-            \"  \\\"hex\\\" : \\\"hex\\\",                (string, optional) The redeemscript for the P2SH or P2WSH address\\n\"\n-            \"  \\\"addresses\\\"                   (string, optional) Array of addresses associated with the known redeemscript (only if \\\"iswitness\\\" is false). This field is superseded by the \\\"pubkeys\\\" field and the address inside \\\"embedded\\\".\\n\"\n-            \"    [\\n\"\n-            \"      \\\"address\\\"\\n\"\n-            \"      ,...\\n\"\n-            \"    ]\\n\"\n-            \"  \\\"pubkeys\\\"                     (string, optional) Array of pubkeys associated with the known redeemscript (only if \\\"script\\\" is \\\"multisig\\\")\\n\"\n-            \"    [\\n\"\n-            \"      \\\"pubkey\\\"\\n\"\n-            \"      ,...\\n\"\n-            \"    ]\\n\"\n-            \"  \\\"sigsrequired\\\" : xxxxx        (numeric, optional) Number of signatures required to spend multisig output (only if \\\"script\\\" is \\\"multisig\\\")\\n\"\n-            \"  \\\"pubkey\\\" : \\\"publickeyhex\\\",    (string, optional) The hex value of the raw public key, for single-key addresses (possibly embedded in P2SH or P2WSH)\\n\"\n-            \"  \\\"embedded\\\" : {...},           (object, optional) information about the address embedded in P2SH or P2WSH, if relevant and known. It includes all validateaddress output fields for the embedded address, excluding \\\"isvalid\\\", metadata (\\\"timestamp\\\", \\\"hdkeypath\\\", \\\"hdmasterkeyid\\\") and relation to the wallet (\\\"ismine\\\", \\\"iswatchonly\\\", \\\"account\\\").\\n\"\n-            \"  \\\"iscompressed\\\" : true|false,  (boolean) If the address is compressed\\n\"\n-            \"  \\\"account\\\" : \\\"account\\\"         (string) DEPRECATED. The account associated with the address, \\\"\\\" is the default account\\n\"\n-            \"  \\\"timestamp\\\" : timestamp,      (number, optional) The creation time of the key if available in seconds since epoch (Jan 1 1970 GMT)\\n\"\n-            \"  \\\"hdkeypath\\\" : \\\"keypath\\\"       (string, optional) The HD keypath if the key is HD and available\\n\"\n-            \"  \\\"hdmasterkeyid\\\" : \\\"<hash160>\\\" (string, optional) The Hash160 of the HD master pubkey\\n\"\n+            \"  \\\"isscript\\\" : true|false,      (boolean) If the key is a script\\n\"\n+            \"  \\\"iswitness\\\" : true|false,     (boolean) If the address is a witness address\\n\"\n+            \"  \\\"witness_version\\\" : version   (numeric, optional) The version number of the witness program\\n\"\n+            \"  \\\"witness_program\\\" : \\\"hex\\\"     (string, optional) The hex value of the witness program\\n\"\n             \"}\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"validateaddress\", \"\\\"1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc\\\"\")\n             + HelpExampleRpc(\"validateaddress\", \"\\\"1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc\\\"\")\n         );\n \n-#ifdef ENABLE_WALLET\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n-\n-    LOCK2(cs_main, pwallet ? &pwallet->cs_wallet : nullptr);\n-#else\n-    LOCK(cs_main);\n-#endif\n-\n     CTxDestination dest = DecodeDestination(request.params[0].get_str());\n     bool isValid = IsValidDestination(dest);\n \n     UniValue ret(UniValue::VOBJ);\n     ret.pushKV(\"isvalid\", isValid);\n     if (isValid)\n     {\n-        std::string currentAddress = EncodeDestination(dest);\n-        ret.pushKV(\"address\", currentAddress);\n-\n-        CScript scriptPubKey = GetScriptForDestination(dest);\n-        ret.pushKV(\"scriptPubKey\", HexStr(scriptPubKey.begin(), scriptPubKey.end()));\n \n #ifdef ENABLE_WALLET\n-        isminetype mine = pwallet ? IsMine(*pwallet, dest) : ISMINE_NO;\n-        ret.pushKV(\"ismine\", bool(mine & ISMINE_SPENDABLE));\n-        ret.pushKV(\"iswatchonly\", bool(mine & ISMINE_WATCH_ONLY));\n-        UniValue detail = DescribeWalletAddress(pwallet, dest);\n-        ret.pushKVs(detail);\n-        if (pwallet && pwallet->mapAddressBook.count(dest)) {\n-            ret.pushKV(\"account\", pwallet->mapAddressBook[dest].name);\n-        }\n-        if (pwallet) {\n-            const CKeyMetadata* meta = nullptr;\n-            CKeyID key_id = GetKeyForDestination(*pwallet, dest);\n-            if (!key_id.IsNull()) {\n-                auto it = pwallet->mapKeyMetadata.find(key_id);\n-                if (it != pwallet->mapKeyMetadata.end()) {\n-                    meta = &it->second;\n-                }\n-            }\n-            if (!meta) {\n-                auto it = pwallet->m_script_metadata.find(CScriptID(scriptPubKey));\n-                if (it != pwallet->m_script_metadata.end()) {\n-                    meta = &it->second;\n-                }\n-            }\n-            if (meta) {\n-                ret.pushKV(\"timestamp\", meta->nCreateTime);\n-                if (!meta->hdKeypath.empty()) {\n-                    ret.pushKV(\"hdkeypath\", meta->hdKeypath);\n-                    ret.pushKV(\"hdmasterkeyid\", meta->hdMasterKeyID.GetHex());\n-                }\n-            }\n+        if (!::vpwallets.empty() && IsDeprecatedRPCEnabled(\"validateaddress\")) {\n+            ret.pushKVs(getaddressinfo(request));\n         }\n-#else\n-        ret.pushKvs = DescribeAddress(dest);\n #endif\n+        if (ret[\"address\"].isNull()) {\n+            std::string currentAddress = EncodeDestination(dest);\n+            ret.pushKV(\"address\", currentAddress);\n+\n+            CScript scriptPubKey = GetScriptForDestination(dest);\n+            ret.pushKV(\"scriptPubKey\", HexStr(scriptPubKey.begin(), scriptPubKey.end()));;\n+\n+            UniValue detail = DescribeAddress(dest);\n+            ret.pushKVs(detail);\n+        }\n     }\n     return ret;\n }"
      },
      {
        "sha": "b504b842741b4f8110ac46a4f1d97f41a4848c57",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 205,
        "deletions": 0,
        "changes": 205,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f",
        "patch": "@@ -25,6 +25,7 @@\n #include <utilmoneystr.h>\n #include <wallet/coincontrol.h>\n #include <wallet/feebumper.h>\n+#include <wallet/rpcwallet.h>\n #include <wallet/wallet.h>\n #include <wallet/walletdb.h>\n #include <wallet/walletutil.h>\n@@ -3514,6 +3515,209 @@ UniValue rescanblockchain(const JSONRPCRequest& request)\n     return response;\n }\n \n+class DescribeWalletAddressVisitor : public boost::static_visitor<UniValue>\n+{\n+public:\n+    CWallet * const pwallet;\n+\n+    void ProcessSubScript(const CScript& subscript, UniValue& obj, bool include_addresses = false) const\n+    {\n+        // Always present: script type and redeemscript\n+        txnouttype which_type;\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        Solver(subscript, which_type, solutions_data);\n+        obj.pushKV(\"script\", GetTxnOutputType(which_type));\n+        obj.pushKV(\"hex\", HexStr(subscript.begin(), subscript.end()));\n+\n+        CTxDestination embedded;\n+        UniValue a(UniValue::VARR);\n+        if (ExtractDestination(subscript, embedded)) {\n+            // Only when the script corresponds to an address.\n+            UniValue subobj(UniValue::VOBJ);\n+            UniValue detail = DescribeAddress(embedded);\n+            subobj.pushKVs(detail);\n+            UniValue wallet_detail = boost::apply_visitor(*this, embedded);\n+            subobj.pushKVs(wallet_detail);\n+            subobj.pushKV(\"address\", EncodeDestination(embedded));\n+            subobj.pushKV(\"scriptPubKey\", HexStr(subscript.begin(), subscript.end()));\n+            // Always report the pubkey at the top level, so that `getnewaddress()['pubkey']` always works.\n+            if (subobj.exists(\"pubkey\")) obj.pushKV(\"pubkey\", subobj[\"pubkey\"]);\n+            obj.pushKV(\"embedded\", std::move(subobj));\n+            if (include_addresses) a.push_back(EncodeDestination(embedded));\n+        } else if (which_type == TX_MULTISIG) {\n+            // Also report some information on multisig scripts (which do not have a corresponding address).\n+            // TODO: abstract out the common functionality between this logic and ExtractDestinations.\n+            obj.pushKV(\"sigsrequired\", solutions_data[0][0]);\n+            UniValue pubkeys(UniValue::VARR);\n+            for (size_t i = 1; i < solutions_data.size() - 1; ++i) {\n+                CPubKey key(solutions_data[i].begin(), solutions_data[i].end());\n+                if (include_addresses) a.push_back(EncodeDestination(key.GetID()));\n+                pubkeys.push_back(HexStr(key.begin(), key.end()));\n+            }\n+            obj.pushKV(\"pubkeys\", std::move(pubkeys));\n+        }\n+\n+        // The \"addresses\" field is confusing because it refers to public keys using their P2PKH address.\n+        // For that reason, only add the 'addresses' field when needed for backward compatibility. New applications\n+        // can use the 'embedded'->'address' field for P2SH or P2WSH wrapped addresses, and 'pubkeys' for\n+        // inspecting multisig participants.\n+        if (include_addresses) obj.pushKV(\"addresses\", std::move(a));\n+    }\n+\n+    explicit DescribeWalletAddressVisitor(CWallet* _pwallet) : pwallet(_pwallet) {}\n+\n+    UniValue operator()(const CNoDestination& dest) const { return UniValue(UniValue::VOBJ); }\n+\n+    UniValue operator()(const CKeyID& keyID) const\n+    {\n+        UniValue obj(UniValue::VOBJ);\n+        CPubKey vchPubKey;\n+        if (pwallet && pwallet->GetPubKey(keyID, vchPubKey)) {\n+            obj.pushKV(\"pubkey\", HexStr(vchPubKey));\n+            obj.pushKV(\"iscompressed\", vchPubKey.IsCompressed());\n+        }\n+        return obj;\n+    }\n+\n+    UniValue operator()(const CScriptID& scriptID) const\n+    {\n+        UniValue obj(UniValue::VOBJ);\n+        CScript subscript;\n+        if (pwallet && pwallet->GetCScript(scriptID, subscript)) {\n+            ProcessSubScript(subscript, obj, IsDeprecatedRPCEnabled(\"validateaddress\"));\n+        }\n+        return obj;\n+    }\n+\n+    UniValue operator()(const WitnessV0KeyHash& id) const\n+    {\n+        UniValue obj(UniValue::VOBJ);\n+        CPubKey pubkey;\n+        if (pwallet && pwallet->GetPubKey(CKeyID(id), pubkey)) {\n+            obj.pushKV(\"pubkey\", HexStr(pubkey));\n+        }\n+        return obj;\n+    }\n+\n+    UniValue operator()(const WitnessV0ScriptHash& id) const\n+    {\n+        UniValue obj(UniValue::VOBJ);\n+        CScript subscript;\n+        CRIPEMD160 hasher;\n+        uint160 hash;\n+        hasher.Write(id.begin(), 32).Finalize(hash.begin());\n+        if (pwallet && pwallet->GetCScript(CScriptID(hash), subscript)) {\n+            ProcessSubScript(subscript, obj);\n+        }\n+        return obj;\n+    }\n+\n+    UniValue operator()(const WitnessUnknown& id) const { return UniValue(UniValue::VOBJ); }\n+};\n+\n+UniValue DescribeWalletAddress(CWallet* pwallet, const CTxDestination& dest)\n+{\n+    UniValue ret(UniValue::VOBJ);\n+    UniValue detail = DescribeAddress(dest);\n+    ret.pushKVs(detail);\n+    ret.pushKVs(boost::apply_visitor(DescribeWalletAddressVisitor(pwallet), dest));\n+    return ret;\n+}\n+\n+UniValue getaddressinfo(const JSONRPCRequest& request)\n+{\n+    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() != 1) {\n+        throw std::runtime_error(\n+            \"getaddressinfo \\\"address\\\"\\n\"\n+            \"\\nReturn information about the given bitcoin address. Some information requires the address\\n\"\n+            \"to be in the wallet.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"address\\\"                    (string, required) The bitcoin address to get the information of.\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"address\\\" : \\\"address\\\",        (string) The bitcoin address validated\\n\"\n+            \"  \\\"scriptPubKey\\\" : \\\"hex\\\",       (string) The hex encoded scriptPubKey generated by the address\\n\"\n+            \"  \\\"ismine\\\" : true|false,        (boolean) If the address is yours or not\\n\"\n+            \"  \\\"iswatchonly\\\" : true|false,   (boolean) If the address is watchonly\\n\"\n+            \"  \\\"isscript\\\" : true|false,      (boolean) If the key is a script\\n\"\n+            \"  \\\"iswitness\\\" : true|false,     (boolean) If the address is a witness address\\n\"\n+            \"  \\\"witness_version\\\" : version   (numeric, optional) The version number of the witness program\\n\"\n+            \"  \\\"witness_program\\\" : \\\"hex\\\"     (string, optional) The hex value of the witness program\\n\"\n+            \"  \\\"script\\\" : \\\"type\\\"             (string, optional) The output script type. Only if \\\"isscript\\\" is true and the redeemscript is known. Possible types: nonstandard, pubkey, pubkeyhash, scripthash, multisig, nulldata, witness_v0_keyhash, witness_v0_scripthash, witness_unknown\\n\"\n+            \"  \\\"hex\\\" : \\\"hex\\\",                (string, optional) The redeemscript for the p2sh address\\n\"\n+            \"  \\\"pubkeys\\\"                     (string, optional) Array of pubkeys associated with the known redeemscript (only if \\\"script\\\" is \\\"multisig\\\")\\n\"\n+            \"    [\\n\"\n+            \"      \\\"pubkey\\\"\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"  \\\"sigsrequired\\\" : xxxxx        (numeric, optional) Number of signatures required to spend multisig output (only if \\\"script\\\" is \\\"multisig\\\")\\n\"\n+            \"  \\\"pubkey\\\" : \\\"publickeyhex\\\",    (string, optional) The hex value of the raw public key, for single-key addresses (possibly embedded in P2SH or P2WSH)\\n\"\n+            \"  \\\"embedded\\\" : {...},           (object, optional) Information about the address embedded in P2SH or P2WSH, if relevant and known. It includes all getaddressinfo output fields for the embedded address, excluding metadata (\\\"timestamp\\\", \\\"hdkeypath\\\", \\\"hdmasterkeyid\\\") and relation to the wallet (\\\"ismine\\\", \\\"iswatchonly\\\", \\\"account\\\").\\n\"\n+            \"  \\\"iscompressed\\\" : true|false,  (boolean) If the address is compressed\\n\"\n+            \"  \\\"account\\\" : \\\"account\\\"         (string) The account associated with the address, \\\"\\\" is the default account\\n\"\n+            \"  \\\"timestamp\\\" : timestamp,      (number, optional) The creation time of the key if available in seconds since epoch (Jan 1 1970 GMT)\\n\"\n+            \"  \\\"hdkeypath\\\" : \\\"keypath\\\"       (string, optional) The HD keypath if the key is HD and available\\n\"\n+            \"  \\\"hdmasterkeyid\\\" : \\\"<hash160>\\\" (string, optional) The Hash160 of the HD master pubkey\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getaddressinfo\", \"\\\"1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc\\\"\")\n+            + HelpExampleRpc(\"getaddressinfo\", \"\\\"1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc\\\"\")\n+        );\n+    }\n+\n+    LOCK(pwallet->cs_wallet);\n+\n+    UniValue ret(UniValue::VOBJ);\n+    CTxDestination dest = DecodeDestination(request.params[0].get_str());\n+\n+    // Make sure the destination is valid\n+    if (!IsValidDestination(dest)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    std::string currentAddress = EncodeDestination(dest);\n+    ret.pushKV(\"address\", currentAddress);\n+\n+    CScript scriptPubKey = GetScriptForDestination(dest);\n+    ret.pushKV(\"scriptPubKey\", HexStr(scriptPubKey.begin(), scriptPubKey.end()));\n+\n+    isminetype mine = IsMine(*pwallet, dest);\n+    ret.pushKV(\"ismine\", bool(mine & ISMINE_SPENDABLE));\n+    ret.pushKV(\"iswatchonly\", bool(mine & ISMINE_WATCH_ONLY));\n+    UniValue detail = DescribeWalletAddress(pwallet, dest);\n+    ret.pushKVs(detail);\n+    if (pwallet->mapAddressBook.count(dest)) {\n+        ret.pushKV(\"account\", pwallet->mapAddressBook[dest].name);\n+    }\n+    const CKeyMetadata* meta = nullptr;\n+    CKeyID key_id = GetKeyForDestination(*pwallet, dest);\n+    if (!key_id.IsNull()) {\n+        auto it = pwallet->mapKeyMetadata.find(key_id);\n+        if (it != pwallet->mapKeyMetadata.end()) {\n+            meta = &it->second;\n+        }\n+    }\n+    if (!meta) {\n+        auto it = pwallet->m_script_metadata.find(CScriptID(scriptPubKey));\n+        if (it != pwallet->m_script_metadata.end()) {\n+            meta = &it->second;\n+        }\n+    }\n+    if (meta) {\n+        ret.pushKV(\"timestamp\", meta->nCreateTime);\n+        if (!meta->hdKeypath.empty()) {\n+            ret.pushKV(\"hdkeypath\", meta->hdKeypath);\n+            ret.pushKV(\"hdmasterkeyid\", meta->hdMasterKeyID.GetHex());\n+        }\n+    }\n+    return ret;\n+}\n+\n extern UniValue abortrescan(const JSONRPCRequest& request); // in rpcdump.cpp\n extern UniValue dumpprivkey(const JSONRPCRequest& request); // in rpcdump.cpp\n extern UniValue importprivkey(const JSONRPCRequest& request);\n@@ -3543,6 +3747,7 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             \"getaccountaddress\",        &getaccountaddress,        {\"account\"} },\n     { \"wallet\",             \"getaccount\",               &getaccount,               {\"address\"} },\n     { \"wallet\",             \"getaddressesbyaccount\",    &getaddressesbyaccount,    {\"account\"} },\n+    { \"wallet\",             \"getaddressinfo\",           &getaddressinfo,           {\"address\"} },\n     { \"wallet\",             \"getbalance\",               &getbalance,               {\"account\",\"minconf\",\"include_watchonly\"} },\n     { \"wallet\",             \"getnewaddress\",            &getnewaddress,            {\"account\",\"address_type\"} },\n     { \"wallet\",             \"getrawchangeaddress\",      &getrawchangeaddress,      {\"address_type\"} },"
      },
      {
        "sha": "43cf0416650c1b0408eda63ee829ffdb226b955b",
        "filename": "src/wallet/rpcwallet.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f/src/wallet/rpcwallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f/src/wallet/rpcwallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.h?ref=b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f",
        "patch": "@@ -10,6 +10,7 @@\n class CRPCTable;\n class CWallet;\n class JSONRPCRequest;\n+class UniValue;\n \n void RegisterWalletRPCCommands(CRPCTable &t);\n \n@@ -25,4 +26,6 @@ std::string HelpRequiringPassphrase(CWallet *);\n void EnsureWalletIsUnlocked(CWallet *);\n bool EnsureWalletIsAvailable(CWallet *, bool avoidException);\n \n+UniValue getaddressinfo(const JSONRPCRequest& request);\n+\n #endif //BITCOIN_WALLET_RPCWALLET_H"
      },
      {
        "sha": "b94b9d8fae2c4ab6af0804488e91f30c106b56c5",
        "filename": "test/functional/rpc_deprecated.py",
        "status": "modified",
        "additions": 8,
        "deletions": 5,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f/test/functional/rpc_deprecated.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f/test/functional/rpc_deprecated.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_deprecated.py?ref=b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f",
        "patch": "@@ -9,7 +9,7 @@ class DeprecatedRpcTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 2\n         self.setup_clean_chain = True\n-        self.extra_args = [[], []]\n+        self.extra_args = [[], [\"-deprecatedrpc=validateaddress\"]]\n \n     def run_test(self):\n         # This test should be used to verify correct behaviour of deprecated\n@@ -18,10 +18,13 @@ def run_test(self):\n         # self.log.info(\"Make sure that -deprecatedrpc=createmultisig allows it to take addresses\")\n         # assert_raises_rpc_error(-5, \"Invalid public key\", self.nodes[0].createmultisig, 1, [self.nodes[0].getnewaddress()])\n         # self.nodes[1].createmultisig(1, [self.nodes[1].getnewaddress()])\n-        #\n-        # There are currently no deprecated RPC methods in master, so this\n-        # test is currently empty.\n-        pass\n+\n+        self.log.info(\"Test validateaddress deprecation\")\n+        SOME_ADDRESS = \"mnvGjUy3NMj67yJ6gkK5o9e5RS33Z2Vqcu\" # This is just some random address to pass as a parameter to validateaddress\n+        dep_validate_address = self.nodes[0].validateaddress(SOME_ADDRESS)\n+        assert \"ismine\" not in dep_validate_address\n+        not_dep_val = self.nodes[1].validateaddress(SOME_ADDRESS)\n+        assert \"ismine\" in not_dep_val\n \n if __name__ == '__main__':\n     DeprecatedRpcTest().main()"
      },
      {
        "sha": "5d2428e6ef259a1b705f269348905f17facb235f",
        "filename": "test/functional/wallet_address_types.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f/test/functional/wallet_address_types.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f/test/functional/wallet_address_types.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_address_types.py?ref=b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f",
        "patch": "@@ -93,8 +93,8 @@ def get_balances(self, confirmed=True):\n \n     def test_address(self, node, address, multisig, typ):\n         \"\"\"Run sanity checks on an address.\"\"\"\n-        info = self.nodes[node].validateaddress(address)\n-        assert(info['isvalid'])\n+        info = self.nodes[node].getaddressinfo(address)\n+        assert(self.nodes[node].validateaddress(address)['isvalid'])\n         if not multisig and typ == 'legacy':\n             # P2PKH\n             assert(not info['isscript'])"
      },
      {
        "sha": "d041b4c1958c5fa2f121afd7181f772c9f9277ce",
        "filename": "test/functional/wallet_basic.py",
        "status": "modified",
        "additions": 10,
        "deletions": 1,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f/test/functional/wallet_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f/test/functional/wallet_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_basic.py?ref=b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f",
        "patch": "@@ -66,7 +66,7 @@ def run_test(self):\n         assert_equal(txout['value'], 50)\n         txout = self.nodes[0].gettxout(txid=confirmed_txid, n=confirmed_index, include_mempool=True)\n         assert_equal(txout['value'], 50)\n-        \n+\n         # Send 21 BTC from 0 to 2 using sendtoaddress call.\n         # Locked memory should use at least 32 bytes to sign each transaction\n         self.log.info(\"test getmemoryinfo\")\n@@ -442,5 +442,14 @@ def run_test(self):\n         # Verify nothing new in wallet\n         assert_equal(total_txs, len(self.nodes[0].listtransactions(\"*\",99999)))\n \n+        # Test getaddressinfo. Note that these addresses are taken from disablewallet.py\n+        assert_raises_rpc_error(-5, \"Invalid address\", self.nodes[0].getaddressinfo, \"3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy\")\n+        address_info = self.nodes[0].getaddressinfo(\"mneYUmWYsuk7kySiURxCi3AGxrAqZxLgPZ\")\n+        assert_equal(address_info['address'], \"mneYUmWYsuk7kySiURxCi3AGxrAqZxLgPZ\")\n+        assert_equal(address_info[\"scriptPubKey\"], \"76a9144e3854046c7bd1594ac904e4793b6a45b36dea0988ac\")\n+        assert not address_info[\"ismine\"]\n+        assert not address_info[\"iswatchonly\"]\n+        assert not address_info[\"isscript\"]\n+\n if __name__ == '__main__':\n     WalletTest().main()"
      }
    ]
  },
  {
    "sha": "b22cce014852b082d80f1cc35f902b375cba0318",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMjJjY2UwMTQ4NTJiMDgyZDgwZjFjYzM1ZjkwMmIzNzVjYmEwMzE4",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-02-09T16:12:27Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-02-16T17:09:36Z"
      },
      "message": "scripted-diff: validateaddress to getaddressinfo in tests\n\nChange all instances of validateaddress to getaddressinfo since it seems that\nno test actually uses validateaddress for actually validating addresses.\n\n-BEGIN VERIFY SCRIPT-\nfind ./test/functional -path '*py' -not -path ./test/functional/wallet_disable.py -not -path ./test/functional/rpc_deprecated.py -not -path ./test/functional/wallet_address_types.py -exec sed -i'' -e 's/validateaddress/getaddressinfo/g' {} \\;\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "d0b165fa758a6b55077d1ff1ddca771efe11e4ad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d0b165fa758a6b55077d1ff1ddca771efe11e4ad"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b22cce014852b082d80f1cc35f902b375cba0318",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b22cce014852b082d80f1cc35f902b375cba0318",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b22cce014852b082d80f1cc35f902b375cba0318",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b22cce014852b082d80f1cc35f902b375cba0318/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b98bfc5ed0da1efef1eff552a7e1a7ce9caf130f"
      }
    ],
    "stats": {
      "total": 208,
      "additions": 104,
      "deletions": 104
    },
    "files": [
      {
        "sha": "9093cc04e8638ed06151ec8d24a5458c035cdd61",
        "filename": "test/functional/feature_segwit.py",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/feature_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/feature_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_segwit.py?ref=b22cce014852b082d80f1cc35f902b375cba0318",
        "patch": "@@ -96,7 +96,7 @@ def run_test(self):\n         wit_ids = [] # wit_ids[NODE][VER] is an array of txids that spend to a witness version VER pkscript to an address for NODE via bare witness\n         for i in range(3):\n             newaddress = self.nodes[i].getnewaddress()\n-            self.pubkey.append(self.nodes[i].validateaddress(newaddress)[\"pubkey\"])\n+            self.pubkey.append(self.nodes[i].getaddressinfo(newaddress)[\"pubkey\"])\n             multiscript = CScript([OP_1, hex_str_to_bytes(self.pubkey[-1]), OP_1, OP_CHECKMULTISIG])\n             p2sh_addr = self.nodes[i].addwitnessaddress(newaddress)\n             bip173_addr = self.nodes[i].addwitnessaddress(newaddress, False)\n@@ -274,8 +274,8 @@ def run_test(self):\n         uncompressed_spendable_address = [\"mvozP4UwyGD2mGZU4D2eMvMLPB9WkMmMQu\"]\n         self.nodes[0].importprivkey(\"cNC8eQ5dg3mFAVePDX4ddmPYpPbw41r9bm2jd1nLJT77e6RrzTRR\")\n         compressed_spendable_address = [\"mmWQubrDomqpgSYekvsU7HWEVjLFHAakLe\"]\n-        assert ((self.nodes[0].validateaddress(uncompressed_spendable_address[0])['iscompressed'] == False))\n-        assert ((self.nodes[0].validateaddress(compressed_spendable_address[0])['iscompressed'] == True))\n+        assert ((self.nodes[0].getaddressinfo(uncompressed_spendable_address[0])['iscompressed'] == False))\n+        assert ((self.nodes[0].getaddressinfo(compressed_spendable_address[0])['iscompressed'] == True))\n \n         self.nodes[0].importpubkey(pubkeys[0])\n         compressed_solvable_address = [key_to_p2pkh(pubkeys[0])]\n@@ -308,7 +308,7 @@ def run_test(self):\n         solvable_after_importaddress.append(CScript([OP_HASH160, hash160(script), OP_EQUAL]))\n \n         for i in compressed_spendable_address:\n-            v = self.nodes[0].validateaddress(i)\n+            v = self.nodes[0].getaddressinfo(i)\n             if (v['isscript']):\n                 [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n                 # bare and p2sh multisig with compressed keys should always be spendable\n@@ -325,7 +325,7 @@ def run_test(self):\n                 spendable_anytime.extend([p2wpkh, p2sh_p2wpkh])\n \n         for i in uncompressed_spendable_address:\n-            v = self.nodes[0].validateaddress(i)\n+            v = self.nodes[0].getaddressinfo(i)\n             if (v['isscript']):\n                 [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n                 # bare and p2sh multisig with uncompressed keys should always be spendable\n@@ -342,7 +342,7 @@ def run_test(self):\n                 unseen_anytime.extend([p2wpkh, p2sh_p2wpkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n \n         for i in compressed_solvable_address:\n-            v = self.nodes[0].validateaddress(i)\n+            v = self.nodes[0].getaddressinfo(i)\n             if (v['isscript']):\n                 # Multisig without private is not seen after addmultisigaddress, but seen after importaddress\n                 [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n@@ -355,7 +355,7 @@ def run_test(self):\n                 solvable_after_importaddress.extend([p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n \n         for i in uncompressed_solvable_address:\n-            v = self.nodes[0].validateaddress(i)\n+            v = self.nodes[0].getaddressinfo(i)\n             if (v['isscript']):\n                 [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n                 # Base uncompressed multisig without private is not seen after addmultisigaddress, but seen after importaddress\n@@ -395,7 +395,7 @@ def run_test(self):\n \n         importlist = []\n         for i in compressed_spendable_address + uncompressed_spendable_address + compressed_solvable_address + uncompressed_solvable_address:\n-            v = self.nodes[0].validateaddress(i)\n+            v = self.nodes[0].getaddressinfo(i)\n             if (v['isscript']):\n                 bare = hex_str_to_bytes(v['hex'])\n                 importlist.append(bytes_to_hex_str(bare))\n@@ -473,7 +473,7 @@ def run_test(self):\n         premature_witaddress = []\n \n         for i in compressed_spendable_address:\n-            v = self.nodes[0].validateaddress(i)\n+            v = self.nodes[0].getaddressinfo(i)\n             if (v['isscript']):\n                 [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n                 # P2WSH and P2SH(P2WSH) multisig with compressed keys are spendable after addwitnessaddress\n@@ -485,7 +485,7 @@ def run_test(self):\n                 spendable_anytime.extend([p2wpkh, p2sh_p2wpkh])\n \n         for i in uncompressed_spendable_address + uncompressed_solvable_address:\n-            v = self.nodes[0].validateaddress(i)\n+            v = self.nodes[0].getaddressinfo(i)\n             if (v['isscript']):\n                 [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n                 # P2WSH and P2SH(P2WSH) multisig with uncompressed keys are never seen\n@@ -496,7 +496,7 @@ def run_test(self):\n                 unseen_anytime.extend([p2wpkh, p2sh_p2wpkh])\n \n         for i in compressed_solvable_address:\n-            v = self.nodes[0].validateaddress(i)\n+            v = self.nodes[0].getaddressinfo(i)\n             if (v['isscript']):\n                 # P2WSH multisig without private key are seen after addwitnessaddress\n                 [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n@@ -519,7 +519,7 @@ def run_test(self):\n             assert_raises_rpc_error(-4, \"Public key or redeemscript not known to wallet, or the key is uncompressed\", self.nodes[0].addwitnessaddress, i)\n \n         # after importaddress it should pass addwitnessaddress\n-        v = self.nodes[0].validateaddress(compressed_solvable_address[1])\n+        v = self.nodes[0].getaddressinfo(compressed_solvable_address[1])\n         self.nodes[0].importaddress(v['hex'],\"\",False,True)\n         for i in compressed_spendable_address + compressed_solvable_address + premature_witaddress:\n             witaddress = self.nodes[0].addwitnessaddress(i)"
      },
      {
        "sha": "de436e3ea1055c424151e821f6d0ea10b08900cd",
        "filename": "test/functional/rpc_fundrawtransaction.py",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/rpc_fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/rpc_fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_fundrawtransaction.py?ref=b22cce014852b082d80f1cc35f902b375cba0318",
        "patch": "@@ -53,7 +53,7 @@ def run_test(self):\n         assert_equal(rawmatch[\"changepos\"], -1)\n \n         watchonly_address = self.nodes[0].getnewaddress()\n-        watchonly_pubkey = self.nodes[0].validateaddress(watchonly_address)[\"pubkey\"]\n+        watchonly_pubkey = self.nodes[0].getaddressinfo(watchonly_address)[\"pubkey\"]\n         watchonly_amount = Decimal(200)\n         self.nodes[3].importpubkey(watchonly_pubkey, \"\", True)\n         watchonly_txid = self.nodes[0].sendtoaddress(watchonly_address, watchonly_amount)\n@@ -371,8 +371,8 @@ def run_test(self):\n         addr1 = self.nodes[1].getnewaddress()\n         addr2 = self.nodes[1].getnewaddress()\n \n-        addr1Obj = self.nodes[1].validateaddress(addr1)\n-        addr2Obj = self.nodes[1].validateaddress(addr2)\n+        addr1Obj = self.nodes[1].getaddressinfo(addr1)\n+        addr2Obj = self.nodes[1].getaddressinfo(addr2)\n \n         mSigObj = self.nodes[1].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])['address']\n \n@@ -401,11 +401,11 @@ def run_test(self):\n         addr4 = self.nodes[1].getnewaddress()\n         addr5 = self.nodes[1].getnewaddress()\n \n-        addr1Obj = self.nodes[1].validateaddress(addr1)\n-        addr2Obj = self.nodes[1].validateaddress(addr2)\n-        addr3Obj = self.nodes[1].validateaddress(addr3)\n-        addr4Obj = self.nodes[1].validateaddress(addr4)\n-        addr5Obj = self.nodes[1].validateaddress(addr5)\n+        addr1Obj = self.nodes[1].getaddressinfo(addr1)\n+        addr2Obj = self.nodes[1].getaddressinfo(addr2)\n+        addr3Obj = self.nodes[1].getaddressinfo(addr3)\n+        addr4Obj = self.nodes[1].getaddressinfo(addr4)\n+        addr5Obj = self.nodes[1].getaddressinfo(addr5)\n \n         mSigObj = self.nodes[1].addmultisigaddress(4, [addr1Obj['pubkey'], addr2Obj['pubkey'], addr3Obj['pubkey'], addr4Obj['pubkey'], addr5Obj['pubkey']])['address']\n \n@@ -431,8 +431,8 @@ def run_test(self):\n         addr1 = self.nodes[2].getnewaddress()\n         addr2 = self.nodes[2].getnewaddress()\n \n-        addr1Obj = self.nodes[2].validateaddress(addr1)\n-        addr2Obj = self.nodes[2].validateaddress(addr2)\n+        addr1Obj = self.nodes[2].getaddressinfo(addr1)\n+        addr2Obj = self.nodes[2].getaddressinfo(addr2)\n \n         mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])['address']\n "
      },
      {
        "sha": "e4b8b2ec2bf38e8452754728b059aba6715c8b56",
        "filename": "test/functional/rpc_listtransactions.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/rpc_listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/rpc_listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_listtransactions.py?ref=b22cce014852b082d80f1cc35f902b375cba0318",
        "patch": "@@ -81,7 +81,7 @@ def run_test(self):\n                            {\"category\":\"receive\",\"amount\":Decimal(\"0.44\")},\n                            {\"txid\":txid, \"account\" : \"toself\"} )\n \n-        pubkey = self.nodes[1].validateaddress(self.nodes[1].getnewaddress())['pubkey']\n+        pubkey = self.nodes[1].getaddressinfo(self.nodes[1].getnewaddress())['pubkey']\n         multisig = self.nodes[1].createmultisig(1, [pubkey])\n         self.nodes[0].importaddress(multisig[\"redeemScript\"], \"watchonly\", False, True)\n         txid = self.nodes[1].sendtoaddress(multisig[\"address\"], 0.1)"
      },
      {
        "sha": "2cb902e8f00014aa088fdf63c8eb0a74707d7589",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=b22cce014852b082d80f1cc35f902b375cba0318",
        "patch": "@@ -146,8 +146,8 @@ def run_test(self):\n         addr1 = self.nodes[2].getnewaddress()\n         addr2 = self.nodes[2].getnewaddress()\n \n-        addr1Obj = self.nodes[2].validateaddress(addr1)\n-        addr2Obj = self.nodes[2].validateaddress(addr2)\n+        addr1Obj = self.nodes[2].getaddressinfo(addr1)\n+        addr2Obj = self.nodes[2].getaddressinfo(addr2)\n \n         # Tests for createmultisig and addmultisigaddress\n         assert_raises_rpc_error(-5, \"Invalid public key\", self.nodes[0].createmultisig, 1, [\"01020304\"])\n@@ -173,9 +173,9 @@ def run_test(self):\n         addr2 = self.nodes[2].getnewaddress()\n         addr3 = self.nodes[2].getnewaddress()\n \n-        addr1Obj = self.nodes[1].validateaddress(addr1)\n-        addr2Obj = self.nodes[2].validateaddress(addr2)\n-        addr3Obj = self.nodes[2].validateaddress(addr3)\n+        addr1Obj = self.nodes[1].getaddressinfo(addr1)\n+        addr2Obj = self.nodes[2].getaddressinfo(addr2)\n+        addr3Obj = self.nodes[2].getaddressinfo(addr3)\n \n         mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey'], addr3Obj['pubkey']])['address']\n \n@@ -219,12 +219,12 @@ def run_test(self):\n         addr1 = self.nodes[1].getnewaddress()\n         addr2 = self.nodes[2].getnewaddress()\n \n-        addr1Obj = self.nodes[1].validateaddress(addr1)\n-        addr2Obj = self.nodes[2].validateaddress(addr2)\n+        addr1Obj = self.nodes[1].getaddressinfo(addr1)\n+        addr2Obj = self.nodes[2].getaddressinfo(addr2)\n \n         self.nodes[1].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])['address']\n         mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])['address']\n-        mSigObjValid = self.nodes[2].validateaddress(mSigObj)\n+        mSigObjValid = self.nodes[2].getaddressinfo(mSigObj)\n \n         txId = self.nodes[0].sendtoaddress(mSigObj, 2.2)\n         decTx = self.nodes[0].gettransaction(txId)"
      },
      {
        "sha": "e1e01570cbf6f29b2c0550d7f3d9acbc1d396b1b",
        "filename": "test/functional/test_framework/blocktools.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/test_framework/blocktools.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/test_framework/blocktools.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/blocktools.py?ref=b22cce014852b082d80f1cc35f902b375cba0318",
        "patch": "@@ -149,7 +149,7 @@ def create_witness_tx(node, use_p2wsh, utxo, pubkey, encode_p2sh, amount):\n     else:\n         addr = key_to_p2sh_p2wpkh(pubkey) if encode_p2sh else key_to_p2wpkh(pubkey)\n     if not encode_p2sh:\n-        assert_equal(node.validateaddress(addr)['scriptPubKey'], witness_script(use_p2wsh, pubkey))\n+        assert_equal(node.getaddressinfo(addr)['scriptPubKey'], witness_script(use_p2wsh, pubkey))\n     return node.createrawtransaction([utxo], {addr: amount})\n \n # Create a transaction spending a given utxo to a segwit output corresponding"
      },
      {
        "sha": "b644f3495c6fe739aba1420f9ac6f94d943937c8",
        "filename": "test/functional/wallet_basic.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/wallet_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/wallet_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_basic.py?ref=b22cce014852b082d80f1cc35f902b375cba0318",
        "patch": "@@ -317,7 +317,7 @@ def run_test(self):\n         self.nodes[1].importaddress(address_to_import)\n \n         # 3. Validate that the imported address is watch-only on node1\n-        assert(self.nodes[1].validateaddress(address_to_import)[\"iswatchonly\"])\n+        assert(self.nodes[1].getaddressinfo(address_to_import)[\"iswatchonly\"])\n \n         # 4. Check that the unspents after import are not spendable\n         assert_array_result(self.nodes[1].listunspent(),"
      },
      {
        "sha": "4db217d886e0f760be821be852db5be043c898bd",
        "filename": "test/functional/wallet_bumpfee.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/wallet_bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/wallet_bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_bumpfee.py?ref=b22cce014852b082d80f1cc35f902b375cba0318",
        "patch": "@@ -104,7 +104,7 @@ def test_segwit_bumpfee_succeeds(rbf_node, dest_address):\n     # which spends it, and make sure bumpfee can be called on it.\n \n     segwit_in = next(u for u in rbf_node.listunspent() if u[\"amount\"] == Decimal(\"0.001\"))\n-    segwit_out = rbf_node.validateaddress(rbf_node.getnewaddress())\n+    segwit_out = rbf_node.getaddressinfo(rbf_node.getnewaddress())\n     rbf_node.addwitnessaddress(segwit_out[\"address\"])\n     segwitid = send_to_witness(\n         use_p2wsh=False,"
      },
      {
        "sha": "e171a2600266092560e0d122fd40eacb4089c166",
        "filename": "test/functional/wallet_dump.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/wallet_dump.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/wallet_dump.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_dump.py?ref=b22cce014852b082d80f1cc35f902b375cba0318",
        "patch": "@@ -97,7 +97,7 @@ def run_test (self):\n         addrs = []\n         for i in range(0,test_addr_count):\n             addr = self.nodes[0].getnewaddress()\n-            vaddr= self.nodes[0].validateaddress(addr) #required to get hd keypath\n+            vaddr= self.nodes[0].getaddressinfo(addr) #required to get hd keypath\n             addrs.append(vaddr)\n         # Should be a no-op:\n         self.nodes[0].keypoolrefill()\n@@ -143,13 +143,13 @@ def run_test (self):\n         self.start_node(0, ['-wallet=w2'])\n \n         # Make sure the address is not IsMine before import\n-        result = self.nodes[0].validateaddress(multisig_addr)\n+        result = self.nodes[0].getaddressinfo(multisig_addr)\n         assert(result['ismine'] == False)\n \n         self.nodes[0].importwallet(os.path.abspath(tmpdir + \"/node0/wallet.unencrypted.dump\"))\n \n         # Now check IsMine is true\n-        result = self.nodes[0].validateaddress(multisig_addr)\n+        result = self.nodes[0].getaddressinfo(multisig_addr)\n         assert(result['ismine'] == True)\n \n if __name__ == '__main__':"
      },
      {
        "sha": "91f77dd5ba5f146863eac194effa7b29fa6d5d43",
        "filename": "test/functional/wallet_hd.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/wallet_hd.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/wallet_hd.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_hd.py?ref=b22cce014852b082d80f1cc35f902b375cba0318",
        "patch": "@@ -33,7 +33,7 @@ def run_test (self):\n \n         # create an internal key\n         change_addr = self.nodes[1].getrawchangeaddress()\n-        change_addrV= self.nodes[1].validateaddress(change_addr)\n+        change_addrV= self.nodes[1].getaddressinfo(change_addr)\n         assert_equal(change_addrV[\"hdkeypath\"], \"m/0'/1'/0'\") #first internal child key\n \n         # Import a non-HD private key in the HD wallet\n@@ -51,7 +51,7 @@ def run_test (self):\n         num_hd_adds = 300\n         for i in range(num_hd_adds):\n             hd_add = self.nodes[1].getnewaddress()\n-            hd_info = self.nodes[1].validateaddress(hd_add)\n+            hd_info = self.nodes[1].getaddressinfo(hd_add)\n             assert_equal(hd_info[\"hdkeypath\"], \"m/0'/0'/\"+str(i)+\"'\")\n             assert_equal(hd_info[\"hdmasterkeyid\"], masterkeyid)\n             self.nodes[0].sendtoaddress(hd_add, 1)\n@@ -61,7 +61,7 @@ def run_test (self):\n \n         # create an internal key (again)\n         change_addr = self.nodes[1].getrawchangeaddress()\n-        change_addrV= self.nodes[1].validateaddress(change_addr)\n+        change_addrV= self.nodes[1].getaddressinfo(change_addr)\n         assert_equal(change_addrV[\"hdkeypath\"], \"m/0'/1'/1'\") #second internal child key\n \n         self.sync_all()\n@@ -80,7 +80,7 @@ def run_test (self):\n         hd_add_2 = None\n         for _ in range(num_hd_adds):\n             hd_add_2 = self.nodes[1].getnewaddress()\n-            hd_info_2 = self.nodes[1].validateaddress(hd_add_2)\n+            hd_info_2 = self.nodes[1].getaddressinfo(hd_add_2)\n             assert_equal(hd_info_2[\"hdkeypath\"], \"m/0'/0'/\"+str(_)+\"'\")\n             assert_equal(hd_info_2[\"hdmasterkeyid\"], masterkeyid)\n         assert_equal(hd_add, hd_add_2)\n@@ -114,7 +114,7 @@ def run_test (self):\n         keypath = \"\"\n         for out in outs:\n             if out['value'] != 1:\n-                keypath = self.nodes[1].validateaddress(out['scriptPubKey']['addresses'][0])['hdkeypath']\n+                keypath = self.nodes[1].getaddressinfo(out['scriptPubKey']['addresses'][0])['hdkeypath']\n \n         assert_equal(keypath[0:7], \"m/0'/1'\")\n "
      },
      {
        "sha": "3288ce4b60e6cac8ce0a8e6ef566921dae37089e",
        "filename": "test/functional/wallet_import_rescan.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/wallet_import_rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/wallet_import_rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_import_rescan.py?ref=b22cce014852b082d80f1cc35f902b375cba0318",
        "patch": "@@ -134,7 +134,7 @@ def run_test(self):\n         # each possible type of wallet import RPC.\n         for i, variant in enumerate(IMPORT_VARIANTS):\n             variant.label = \"label {} {}\".format(i, variant)\n-            variant.address = self.nodes[1].validateaddress(self.nodes[1].getnewaddress(variant.label))\n+            variant.address = self.nodes[1].getaddressinfo(self.nodes[1].getnewaddress(variant.label))\n             variant.key = self.nodes[1].dumpprivkey(variant.address[\"address\"])\n             variant.initial_amount = 10 - (i + 1) / 4.0\n             variant.initial_txid = self.nodes[0].sendtoaddress(variant.address[\"address\"], variant.initial_amount)"
      },
      {
        "sha": "56ebc2622ab7729eae5f335d7d1d0b58182e98c2",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 51,
        "deletions": 51,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=b22cce014852b082d80f1cc35f902b375cba0318",
        "patch": "@@ -21,7 +21,7 @@ def run_test (self):\n         self.nodes[1].generate(1)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n \n-        node0_address1 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        node0_address1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n \n         #Check only one address\n         assert_equal(node0_address1['ismine'], True)\n@@ -30,7 +30,7 @@ def run_test (self):\n         assert_equal(self.nodes[1].getblockcount(),1)\n \n         #Address Test - before import\n-        address_info = self.nodes[1].validateaddress(node0_address1['address'])\n+        address_info = self.nodes[1].getaddressinfo(node0_address1['address'])\n         assert_equal(address_info['iswatchonly'], False)\n         assert_equal(address_info['ismine'], False)\n \n@@ -39,15 +39,15 @@ def run_test (self):\n \n         # Bitcoin Address\n         self.log.info(\"Should import an address\")\n-        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n                 \"address\": address['address']\n             },\n             \"timestamp\": \"now\",\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].validateaddress(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal(address_assert['timestamp'], timestamp)\n@@ -67,37 +67,37 @@ def run_test (self):\n \n         # ScriptPubKey + internal\n         self.log.info(\"Should import a scriptPubKey with internal flag\")\n-        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": address['scriptPubKey'],\n             \"timestamp\": \"now\",\n             \"internal\": True\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].validateaddress(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal(address_assert['timestamp'], timestamp)\n \n         # ScriptPubKey + !internal\n         self.log.info(\"Should not import a scriptPubKey without internal flag\")\n-        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": address['scriptPubKey'],\n             \"timestamp\": \"now\",\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -8)\n         assert_equal(result[0]['error']['message'], 'Internal must be set for hex scriptPubKey')\n-        address_assert = self.nodes[1].validateaddress(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n \n \n         # Address + Public key + !Internal\n         self.log.info(\"Should import an address with public key\")\n-        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n                 \"address\": address['address']\n@@ -106,15 +106,15 @@ def run_test (self):\n             \"pubkeys\": [ address['pubkey'] ]\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].validateaddress(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal(address_assert['timestamp'], timestamp)\n \n \n         # ScriptPubKey + Public key + internal\n         self.log.info(\"Should import a scriptPubKey with internal and with public key\")\n-        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         request = [{\n             \"scriptPubKey\": address['scriptPubKey'],\n             \"timestamp\": \"now\",\n@@ -123,14 +123,14 @@ def run_test (self):\n         }]\n         result = self.nodes[1].importmulti(request)\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].validateaddress(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal(address_assert['timestamp'], timestamp)\n \n         # ScriptPubKey + Public key + !internal\n         self.log.info(\"Should not import a scriptPubKey without internal and with public key\")\n-        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         request = [{\n             \"scriptPubKey\": address['scriptPubKey'],\n             \"timestamp\": \"now\",\n@@ -140,14 +140,14 @@ def run_test (self):\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -8)\n         assert_equal(result[0]['error']['message'], 'Internal must be set for hex scriptPubKey')\n-        address_assert = self.nodes[1].validateaddress(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n \n         # Address + Private key + !watchonly\n         self.log.info(\"Should import an address with private key\")\n-        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n                 \"address\": address['address']\n@@ -156,7 +156,7 @@ def run_test (self):\n             \"keys\": [ self.nodes[0].dumpprivkey(address['address']) ]\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].validateaddress(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], True)\n         assert_equal(address_assert['timestamp'], timestamp)\n@@ -175,7 +175,7 @@ def run_test (self):\n \n         # Address + Private key + watchonly\n         self.log.info(\"Should not import an address with private key and with watchonly\")\n-        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n                 \"address\": address['address']\n@@ -187,29 +187,29 @@ def run_test (self):\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -8)\n         assert_equal(result[0]['error']['message'], 'Incompatibility found between watchonly and keys')\n-        address_assert = self.nodes[1].validateaddress(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n \n         # ScriptPubKey + Private key + internal\n         self.log.info(\"Should import a scriptPubKey with internal and with private key\")\n-        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": address['scriptPubKey'],\n             \"timestamp\": \"now\",\n             \"keys\": [ self.nodes[0].dumpprivkey(address['address']) ],\n             \"internal\": True\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].validateaddress(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], True)\n         assert_equal(address_assert['timestamp'], timestamp)\n \n         # ScriptPubKey + Private key + !internal\n         self.log.info(\"Should not import a scriptPubKey without internal and with private key\")\n-        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": address['scriptPubKey'],\n             \"timestamp\": \"now\",\n@@ -218,16 +218,16 @@ def run_test (self):\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -8)\n         assert_equal(result[0]['error']['message'], 'Internal must be set for hex scriptPubKey')\n-        address_assert = self.nodes[1].validateaddress(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n \n \n         # P2SH address\n-        sig_address_1 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n-        sig_address_2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n-        sig_address_3 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        sig_address_2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        sig_address_3 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['pubkey'], sig_address_2['pubkey'], sig_address_3['pubkey']])\n         self.nodes[1].generate(100)\n         transactionid = self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n@@ -242,7 +242,7 @@ def run_test (self):\n             \"timestamp\": \"now\",\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].validateaddress(multi_sig_script['address'])\n+        address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n         assert_equal(address_assert['isscript'], True)\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['timestamp'], timestamp)\n@@ -252,9 +252,9 @@ def run_test (self):\n \n \n         # P2SH + Redeem script\n-        sig_address_1 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n-        sig_address_2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n-        sig_address_3 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        sig_address_2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        sig_address_3 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['pubkey'], sig_address_2['pubkey'], sig_address_3['pubkey']])\n         self.nodes[1].generate(100)\n         transactionid = self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n@@ -270,7 +270,7 @@ def run_test (self):\n             \"redeemscript\": multi_sig_script['redeemScript']\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].validateaddress(multi_sig_script['address'])\n+        address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n         assert_equal(address_assert['timestamp'], timestamp)\n \n         p2shunspent = self.nodes[1].listunspent(0,999999, [multi_sig_script['address']])[0]\n@@ -279,9 +279,9 @@ def run_test (self):\n \n \n         # P2SH + Redeem script + Private Keys + !Watchonly\n-        sig_address_1 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n-        sig_address_2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n-        sig_address_3 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        sig_address_2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        sig_address_3 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['pubkey'], sig_address_2['pubkey'], sig_address_3['pubkey']])\n         self.nodes[1].generate(100)\n         transactionid = self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n@@ -298,17 +298,17 @@ def run_test (self):\n             \"keys\": [ self.nodes[0].dumpprivkey(sig_address_1['address']), self.nodes[0].dumpprivkey(sig_address_2['address'])]\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].validateaddress(multi_sig_script['address'])\n+        address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n         assert_equal(address_assert['timestamp'], timestamp)\n \n         p2shunspent = self.nodes[1].listunspent(0,999999, [multi_sig_script['address']])[0]\n         assert_equal(p2shunspent['spendable'], False)\n         assert_equal(p2shunspent['solvable'], True)\n \n         # P2SH + Redeem script + Private Keys + Watchonly\n-        sig_address_1 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n-        sig_address_2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n-        sig_address_3 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        sig_address_2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        sig_address_3 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['pubkey'], sig_address_2['pubkey'], sig_address_3['pubkey']])\n         self.nodes[1].generate(100)\n         transactionid = self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n@@ -332,8 +332,8 @@ def run_test (self):\n \n         # Address + Public key + !Internal + Wrong pubkey\n         self.log.info(\"Should not import an address with a wrong public key\")\n-        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n-        address2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        address2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n                 \"address\": address['address']\n@@ -344,16 +344,16 @@ def run_test (self):\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -5)\n         assert_equal(result[0]['error']['message'], 'Consistency check failed')\n-        address_assert = self.nodes[1].validateaddress(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n \n \n         # ScriptPubKey + Public key + internal + Wrong pubkey\n         self.log.info(\"Should not import a scriptPubKey with internal and with a wrong public key\")\n-        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n-        address2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        address2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         request = [{\n             \"scriptPubKey\": address['scriptPubKey'],\n             \"timestamp\": \"now\",\n@@ -364,16 +364,16 @@ def run_test (self):\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -5)\n         assert_equal(result[0]['error']['message'], 'Consistency check failed')\n-        address_assert = self.nodes[1].validateaddress(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n \n \n         # Address + Private key + !watchonly + Wrong private key\n         self.log.info(\"Should not import an address with a wrong private key\")\n-        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n-        address2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        address2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n                 \"address\": address['address']\n@@ -384,16 +384,16 @@ def run_test (self):\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -5)\n         assert_equal(result[0]['error']['message'], 'Consistency check failed')\n-        address_assert = self.nodes[1].validateaddress(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n \n \n         # ScriptPubKey + Private key + internal + Wrong private key\n         self.log.info(\"Should not import a scriptPubKey with internal and with a wrong private key\")\n-        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n-        address2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        address2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": address['scriptPubKey'],\n             \"timestamp\": \"now\",\n@@ -403,7 +403,7 @@ def run_test (self):\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -5)\n         assert_equal(result[0]['error']['message'], 'Consistency check failed')\n-        address_assert = self.nodes[1].validateaddress(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n@@ -419,7 +419,7 @@ def run_test (self):\n             \"timestamp\": \"now\",\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].validateaddress(watchonly_address)\n+        address_assert = self.nodes[1].getaddressinfo(watchonly_address)\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal(address_assert['timestamp'], timestamp)\n@@ -429,7 +429,7 @@ def run_test (self):\n         # restart nodes to check for proper serialization/deserialization of watch only address\n         self.stop_nodes()\n         self.start_nodes()\n-        address_assert = self.nodes[1].validateaddress(watchonly_address)\n+        address_assert = self.nodes[1].getaddressinfo(watchonly_address)\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal(address_assert['timestamp'], watchonly_timestamp)"
      },
      {
        "sha": "4d349db23f9da1a42d2dec025e6b6086e4a65928",
        "filename": "test/functional/wallet_importprunedfunds.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/wallet_importprunedfunds.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/wallet_importprunedfunds.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importprunedfunds.py?ref=b22cce014852b082d80f1cc35f902b375cba0318",
        "patch": "@@ -26,7 +26,7 @@ def run_test(self):\n         address3_privkey = self.nodes[0].dumpprivkey(address3)                              # Using privkey\n \n         #Check only one address\n-        address_info = self.nodes[0].validateaddress(address1)\n+        address_info = self.nodes[0].getaddressinfo(address1)\n         assert_equal(address_info['ismine'], True)\n \n         self.sync_all()\n@@ -35,15 +35,15 @@ def run_test(self):\n         assert_equal(self.nodes[1].getblockcount(),101)\n \n         #Address Test - before import\n-        address_info = self.nodes[1].validateaddress(address1)\n+        address_info = self.nodes[1].getaddressinfo(address1)\n         assert_equal(address_info['iswatchonly'], False)\n         assert_equal(address_info['ismine'], False)\n \n-        address_info = self.nodes[1].validateaddress(address2)\n+        address_info = self.nodes[1].getaddressinfo(address2)\n         assert_equal(address_info['iswatchonly'], False)\n         assert_equal(address_info['ismine'], False)\n \n-        address_info = self.nodes[1].validateaddress(address3)\n+        address_info = self.nodes[1].getaddressinfo(address3)\n         assert_equal(address_info['iswatchonly'], False)\n         assert_equal(address_info['ismine'], False)\n \n@@ -86,13 +86,13 @@ def run_test(self):\n         assert_equal(balance3, Decimal('0.075'))\n \n         #Addresses Test - after import\n-        address_info = self.nodes[1].validateaddress(address1)\n+        address_info = self.nodes[1].getaddressinfo(address1)\n         assert_equal(address_info['iswatchonly'], False)\n         assert_equal(address_info['ismine'], False)\n-        address_info = self.nodes[1].validateaddress(address2)\n+        address_info = self.nodes[1].getaddressinfo(address2)\n         assert_equal(address_info['iswatchonly'], True)\n         assert_equal(address_info['ismine'], False)\n-        address_info = self.nodes[1].validateaddress(address3)\n+        address_info = self.nodes[1].getaddressinfo(address3)\n         assert_equal(address_info['iswatchonly'], False)\n         assert_equal(address_info['ismine'], True)\n "
      },
      {
        "sha": "9825e4d89448fb1e6ab21a1d3438a475839bbb23",
        "filename": "test/functional/wallet_keypool.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/wallet_keypool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/wallet_keypool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_keypool.py?ref=b22cce014852b082d80f1cc35f902b375cba0318",
        "patch": "@@ -14,7 +14,7 @@ def set_test_params(self):\n     def run_test(self):\n         nodes = self.nodes\n         addr_before_encrypting = nodes[0].getnewaddress()\n-        addr_before_encrypting_data = nodes[0].validateaddress(addr_before_encrypting)\n+        addr_before_encrypting_data = nodes[0].getaddressinfo(addr_before_encrypting)\n         wallet_info_old = nodes[0].getwalletinfo()\n         assert(addr_before_encrypting_data['hdmasterkeyid'] == wallet_info_old['hdmasterkeyid'])\n         \n@@ -24,7 +24,7 @@ def run_test(self):\n         self.start_node(0)\n         # Keep creating keys\n         addr = nodes[0].getnewaddress()\n-        addr_data = nodes[0].validateaddress(addr)\n+        addr_data = nodes[0].getaddressinfo(addr)\n         wallet_info = nodes[0].getwalletinfo()\n         assert(addr_before_encrypting_data['hdmasterkeyid'] != wallet_info['hdmasterkeyid'])\n         assert(addr_data['hdmasterkeyid'] == wallet_info['hdmasterkeyid'])"
      },
      {
        "sha": "e7b76dfaf2ee3fdd10bdf8224778bf8efd6568f3",
        "filename": "test/functional/wallet_keypool_topup.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/wallet_keypool_topup.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b22cce014852b082d80f1cc35f902b375cba0318/test/functional/wallet_keypool_topup.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_keypool_topup.py?ref=b22cce014852b082d80f1cc35f902b375cba0318",
        "patch": "@@ -68,7 +68,7 @@ def run_test(self):\n         assert_equal(self.nodes[1].listtransactions()[0]['category'], \"receive\")\n \n         # Check that we have marked all keys up to the used keypool key as used\n-        assert_equal(self.nodes[1].validateaddress(self.nodes[1].getnewaddress())['hdkeypath'], \"m/0'/0'/110'\")\n+        assert_equal(self.nodes[1].getaddressinfo(self.nodes[1].getnewaddress())['hdkeypath'], \"m/0'/0'/110'\")\n \n if __name__ == '__main__':\n     KeypoolRestoreTest().main()"
      }
    ]
  }
]