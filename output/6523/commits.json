[
  {
    "sha": "0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowY2U3Mzk4NWE4MGMzYmIwYzlhMjAyNGY4ZGY2Y2U2OGM2NDhkYmI4",
    "commit": {
      "author": {
        "name": "Casey Rodarmor",
        "email": "casey@rodarmor.com",
        "date": "2015-08-05T21:47:34Z"
      },
      "committer": {
        "name": "Casey Rodarmor",
        "email": "casey@rodarmor.com",
        "date": "2015-08-21T19:31:37Z"
      },
      "message": "Add p2p-fullblocktest.py",
      "tree": {
        "sha": "b78eda0e18074aa748107c6296abacb034b299bf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b78eda0e18074aa748107c6296abacb034b299bf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/comments",
    "author": {
      "login": "casey",
      "id": 1945,
      "node_id": "MDQ6VXNlcjE5NDU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1945?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/casey",
      "html_url": "https://github.com/casey",
      "followers_url": "https://api.github.com/users/casey/followers",
      "following_url": "https://api.github.com/users/casey/following{/other_user}",
      "gists_url": "https://api.github.com/users/casey/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/casey/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/casey/subscriptions",
      "organizations_url": "https://api.github.com/users/casey/orgs",
      "repos_url": "https://api.github.com/users/casey/repos",
      "events_url": "https://api.github.com/users/casey/events{/privacy}",
      "received_events_url": "https://api.github.com/users/casey/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "casey",
      "id": 1945,
      "node_id": "MDQ6VXNlcjE5NDU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1945?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/casey",
      "html_url": "https://github.com/casey",
      "followers_url": "https://api.github.com/users/casey/followers",
      "following_url": "https://api.github.com/users/casey/following{/other_user}",
      "gists_url": "https://api.github.com/users/casey/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/casey/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/casey/subscriptions",
      "organizations_url": "https://api.github.com/users/casey/orgs",
      "repos_url": "https://api.github.com/users/casey/repos",
      "events_url": "https://api.github.com/users/casey/events{/privacy}",
      "received_events_url": "https://api.github.com/users/casey/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "49793fbb097e9f00149a054adeddad07f0444c12",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/49793fbb097e9f00149a054adeddad07f0444c12",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/49793fbb097e9f00149a054adeddad07f0444c12"
      }
    ],
    "stats": {
      "total": 755,
      "additions": 702,
      "deletions": 53
    },
    "files": [
      {
        "sha": "5d581819dac5f21c8c6f72aaa6910a29aa030c99",
        "filename": "qa/pull-tester/rpc-tests.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/pull-tester/rpc-tests.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/pull-tester/rpc-tests.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.sh?ref=0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8",
        "patch": "@@ -36,6 +36,7 @@ testScripts=(\n     'nodehandling.py'\n     'reindex.py'\n     'decodescript.py'\n+    'p2p-fullblocktest.py'\n );\n testScriptsExt=(\n     'bipdersig-p2p.py'"
      },
      {
        "sha": "c6d17212821c391f74ee511bc63f40a50f95fd12",
        "filename": "qa/rpc-tests/README.md",
        "status": "modified",
        "additions": 103,
        "deletions": 2,
        "changes": 105,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/README.md?ref=0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8",
        "patch": "@@ -1,5 +1,5 @@\n-Regression tests of RPC interface\n-=================================\n+Regression tests\n+================\n \n ### [python-bitcoinrpc](https://github.com/jgarzik/python-bitcoinrpc)\n Git subtree of [https://github.com/jgarzik/python-bitcoinrpc](https://github.com/jgarzik/python-bitcoinrpc).\n@@ -12,6 +12,28 @@ Base class for new regression tests.\n ### [test_framework/util.py](test_framework/util.py)\n Generally useful functions.\n \n+### [test_framework/mininode.py](test_framework/mininode.py)\n+Basic code to support p2p connectivity to a bitcoind.\n+\n+### [test_framework/comptool.py](test_framework/comptool.py)\n+Framework for comparison-tool style, p2p tests.\n+\n+### [test_framework/script.py](test_framework/script.py)\n+Utilities for manipulating transaction scripts (originally from python-bitcoinlib)\n+\n+### [test_framework/blockstore.py](test_framework/blockstore.py)\n+Implements disk-backed block and tx storage.\n+\n+### [test_framework/key.py](test_framework/key.py)\n+Wrapper around OpenSSL EC_Key (originally from python-bitcoinlib)\n+\n+### [test_framework/bignum.py](test_framework/bignum.py)\n+Helpers for script.py\n+\n+### [test_framework/blocktools.py](test_framework/blocktools.py)\n+Helper functions for creating blocks and transactions.\n+\n+\n Notes\n =====\n \n@@ -49,3 +71,82 @@ to recover with:\n rm -rf cache\n killall bitcoind\n ```\n+\n+P2P test design notes\n+---------------------\n+\n+## Mininode\n+\n+* ```mininode.py``` contains all the definitions for objects that pass\n+over the network (```CBlock```, ```CTransaction```, etc, along with the network-level\n+wrappers for them, ```msg_block```, ```msg_tx```, etc).\n+\n+* P2P tests have two threads.  One thread handles all network communication\n+with the bitcoind(s) being tested (using python's asyncore package); the other\n+implements the test logic.\n+\n+* ```NodeConn``` is the class used to connect to a bitcoind.  If you implement\n+a callback class that derives from ```NodeConnCB``` and pass that to the\n+```NodeConn``` object, your code will receive the appropriate callbacks when\n+events of interest arrive.  NOTE: be sure to call\n+```self.create_callback_map()``` in your derived classes' ```__init__```\n+function, so that the correct mappings are set up between p2p messages and your\n+callback functions.\n+\n+* You can pass the same handler to multiple ```NodeConn```'s if you like, or pass\n+different ones to each -- whatever makes the most sense for your test.\n+\n+* Call ```NetworkThread.start()``` after all ```NodeConn``` objects are created to\n+start the networking thread.  (Continue with the test logic in your existing\n+thread.)\n+\n+* RPC calls are available in p2p tests.\n+\n+* Can be used to write free-form tests, where specific p2p-protocol behavior\n+is tested.  Examples: ```p2p-accept-block.py```, ```maxblocksinflight.py```.\n+\n+## Comptool\n+\n+* Testing framework for writing tests that compare the block/tx acceptance\n+behavior of a bitcoind against 1 or more other bitcoind instances, or against\n+known outcomes, or both.\n+\n+* Set the ```num_nodes``` variable (defined in ```ComparisonTestFramework```) to start up\n+1 or more nodes.  If using 1 node, then ```--testbinary``` can be used as a command line\n+option to change the bitcoind binary used by the test.  If using 2 or more nodes,\n+then ```--refbinary``` can be optionally used to change the bitcoind that will be used\n+on nodes 2 and up.\n+\n+* Implement a (generator) function called ```get_tests()``` which yields ```TestInstance```s.\n+Each ```TestInstance``` consists of:\n+  - a list of ```[object, outcome, hash]``` entries\n+    * ```object``` is a ```CBlock```, ```CTransaction```, or\n+    ```CBlockHeader```.  ```CBlock```'s and ```CTransaction```'s are tested for\n+    acceptance.  ```CBlockHeader```s can be used so that the test runner can deliver\n+    complete headers-chains when requested from the bitcoind, to allow writing\n+    tests where blocks can be delivered out of order but still processed by\n+    headers-first bitcoind's.\n+    * ```outcome``` is ```True```, ```False```, or ```None```.  If ```True```\n+    or ```False```, the tip is compared with the expected tip -- either the\n+    block passed in, or the hash specified as the optional 3rd entry.  If\n+    ```None``` is specified, then the test will compare all the bitcoind's\n+    being tested to see if they all agree on what the best tip is.\n+    * ```hash``` is the block hash of the tip to compare against. Optional to\n+    specify; if left out then the hash of the block passed in will be used as\n+    the expected tip.  This allows for specifying an expected tip while testing\n+    the handling of either invalid blocks or blocks delivered out of order,\n+    which complete a longer chain.\n+  - ```sync_every_block```: ```True/False```.  If ```False```, then all blocks\n+    are inv'ed together, and the test runner waits until the node receives the\n+    last one, and tests only the last block for tip acceptance using the\n+    outcome and specified tip.  If ```True```, then each block is tested in\n+    sequence and synced (this is slower when processing many blocks).\n+  - ```sync_every_transaction```: ```True/False```.  Analogous to\n+    ```sync_every_block```, except if the outcome on the last tx is \"None\",\n+    then the contents of the entire mempool are compared across all bitcoind\n+    connections.  If ```True``` or ```False```, then only the last tx's\n+    acceptance is tested against the given outcome.\n+\n+* For examples of tests written in this framework, see\n+  ```invalidblockrequest.py``` and ```p2p-fullblocktest.py```.\n+"
      },
      {
        "sha": "ec1678cc2cfe9de4e5de3f4570666701fbdfe806",
        "filename": "qa/rpc-tests/bipdersig-p2p.py",
        "status": "modified",
        "additions": 15,
        "deletions": 8,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/bipdersig-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/bipdersig-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bipdersig-p2p.py?ref=0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8",
        "patch": "@@ -75,32 +75,35 @@ def create_transaction(self, node, coinbase, to_address, amount):\n     def get_tests(self):\n \n         self.coinbase_blocks = self.nodes[0].generate(2)\n+        height = 3  # height of the next block to build\n         self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n         self.nodeaddress = self.nodes[0].getnewaddress()\n         self.last_block_time = time.time()\n \n         ''' 98 more version 2 blocks '''\n         test_blocks = []\n         for i in xrange(98):\n-            block = create_block(self.tip, create_coinbase(2), self.last_block_time + 1)\n+            block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n             block.nVersion = 2\n             block.rehash()\n             block.solve()\n             test_blocks.append([block, True])\n             self.last_block_time += 1\n             self.tip = block.sha256\n+            height += 1\n         yield TestInstance(test_blocks, sync_every_block=False)\n \n         ''' Mine 749 version 3 blocks '''\n         test_blocks = []\n         for i in xrange(749):\n-            block = create_block(self.tip, create_coinbase(2), self.last_block_time + 1)\n+            block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n             block.nVersion = 3\n             block.rehash()\n             block.solve()\n             test_blocks.append([block, True])\n             self.last_block_time += 1\n             self.tip = block.sha256\n+            height += 1\n         yield TestInstance(test_blocks, sync_every_block=False)\n \n         ''' \n@@ -112,7 +115,7 @@ def get_tests(self):\n         unDERify(spendtx)\n         spendtx.rehash()\n \n-        block = create_block(self.tip, create_coinbase(2), self.last_block_time + 1)\n+        block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n         block.nVersion = 3\n         block.vtx.append(spendtx)\n         block.hashMerkleRoot = block.calc_merkle_root()\n@@ -121,6 +124,7 @@ def get_tests(self):\n \n         self.last_block_time += 1\n         self.tip = block.sha256\n+        height += 1\n         yield TestInstance([[block, True]])\n \n         ''' \n@@ -132,7 +136,7 @@ def get_tests(self):\n         unDERify(spendtx)\n         spendtx.rehash()\n \n-        block = create_block(self.tip, create_coinbase(1), self.last_block_time + 1)\n+        block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n         block.nVersion = 3\n         block.vtx.append(spendtx)\n         block.hashMerkleRoot = block.calc_merkle_root()\n@@ -144,35 +148,38 @@ def get_tests(self):\n         ''' Mine 199 new version blocks on last valid tip '''\n         test_blocks = []\n         for i in xrange(199):\n-            block = create_block(self.tip, create_coinbase(1), self.last_block_time + 1)\n+            block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n             block.nVersion = 3\n             block.rehash()\n             block.solve()\n             test_blocks.append([block, True])\n             self.last_block_time += 1\n             self.tip = block.sha256\n+            height += 1\n         yield TestInstance(test_blocks, sync_every_block=False)\n \n         ''' Mine 1 old version block '''\n-        block = create_block(self.tip, create_coinbase(1), self.last_block_time + 1)\n+        block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n         block.nVersion = 2\n         block.rehash()\n         block.solve()\n         self.last_block_time += 1\n         self.tip = block.sha256\n+        height += 1\n         yield TestInstance([[block, True]])\n \n         ''' Mine 1 new version block '''\n-        block = create_block(self.tip, create_coinbase(1), self.last_block_time + 1)\n+        block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n         block.nVersion = 3\n         block.rehash()\n         block.solve()\n         self.last_block_time += 1\n         self.tip = block.sha256\n+        height += 1\n         yield TestInstance([[block, True]])\n \n         ''' Mine 1 old version block, should be invalid '''\n-        block = create_block(self.tip, create_coinbase(1), self.last_block_time + 1)\n+        block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n         block.nVersion = 2\n         block.rehash()\n         block.solve()"
      },
      {
        "sha": "6a7980cd45a522e091540bf9d8f4d452da024df0",
        "filename": "qa/rpc-tests/invalidblockrequest.py",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/invalidblockrequest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/invalidblockrequest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/invalidblockrequest.py?ref=0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8",
        "patch": "@@ -46,24 +46,27 @@ def get_tests(self):\n         '''\n         Create a new block with an anyone-can-spend coinbase\n         '''\n-        block = create_block(self.tip, create_coinbase(), self.block_time)\n+        height = 1\n+        block = create_block(self.tip, create_coinbase(height), self.block_time)\n         self.block_time += 1\n         block.solve()\n         # Save the coinbase for later\n         self.block1 = block\n         self.tip = block.sha256\n+        height += 1\n         yield TestInstance([[block, True]])\n \n         '''\n         Now we need that block to mature so we can spend the coinbase.\n         '''\n         test = TestInstance(sync_every_block=False)\n         for i in xrange(100):\n-            block = create_block(self.tip, create_coinbase(), self.block_time)\n+            block = create_block(self.tip, create_coinbase(height), self.block_time)\n             block.solve()\n             self.tip = block.sha256\n             self.block_time += 1\n             test.blocks_and_transactions.append([block, True])\n+            height += 1\n         yield test\n \n         '''\n@@ -73,7 +76,7 @@ def get_tests(self):\n         coinbase, spend of that spend).  Duplicate the 3rd transaction to \n         leave merkle root and blockheader unchanged but invalidate the block.\n         '''\n-        block2 = create_block(self.tip, create_coinbase(), self.block_time)\n+        block2 = create_block(self.tip, create_coinbase(height), self.block_time)\n         self.block_time += 1\n \n         # chr(81) is OP_TRUE\n@@ -95,11 +98,12 @@ def get_tests(self):\n \n         self.tip = block2.sha256\n         yield TestInstance([[block2, False], [block2_orig, True]])\n+        height += 1\n \n         '''\n         Make sure that a totally screwed up block is not valid.\n         '''\n-        block3 = create_block(self.tip, create_coinbase(), self.block_time)\n+        block3 = create_block(self.tip, create_coinbase(height), self.block_time)\n         self.block_time += 1\n         block3.vtx[0].vout[0].nValue = 100*100000000 # Too high!\n         block3.vtx[0].sha256=None"
      },
      {
        "sha": "700deab207152482c26325e27d947473ff8b10e9",
        "filename": "qa/rpc-tests/p2p-acceptblock.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-acceptblock.py?ref=0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8",
        "patch": "@@ -153,7 +153,7 @@ def run_test(self):\n         blocks_h2 = []  # the height 2 blocks on each node's chain\n         block_time = time.time() + 1\n         for i in xrange(2):\n-            blocks_h2.append(create_block(tips[i], create_coinbase(), block_time))\n+            blocks_h2.append(create_block(tips[i], create_coinbase(2), block_time))\n             blocks_h2[i].solve()\n             block_time += 1\n         test_node.send_message(msg_block(blocks_h2[0]))\n@@ -167,7 +167,7 @@ def run_test(self):\n         # 3. Send another block that builds on the original tip.\n         blocks_h2f = []  # Blocks at height 2 that fork off the main chain\n         for i in xrange(2):\n-            blocks_h2f.append(create_block(tips[i], create_coinbase(), blocks_h2[i].nTime+1))\n+            blocks_h2f.append(create_block(tips[i], create_coinbase(2), blocks_h2[i].nTime+1))\n             blocks_h2f[i].solve()\n         test_node.send_message(msg_block(blocks_h2f[0]))\n         white_node.send_message(msg_block(blocks_h2f[1]))\n@@ -186,7 +186,7 @@ def run_test(self):\n         # 4. Now send another block that builds on the forking chain.\n         blocks_h3 = []\n         for i in xrange(2):\n-            blocks_h3.append(create_block(blocks_h2f[i].sha256, create_coinbase(), blocks_h2f[i].nTime+1))\n+            blocks_h3.append(create_block(blocks_h2f[i].sha256, create_coinbase(3), blocks_h2f[i].nTime+1))\n             blocks_h3[i].solve()\n         test_node.send_message(msg_block(blocks_h3[0]))\n         white_node.send_message(msg_block(blocks_h3[1]))\n@@ -217,7 +217,7 @@ def run_test(self):\n         all_blocks = []   # node0's blocks\n         for j in xrange(2):\n             for i in xrange(288):\n-                next_block = create_block(tips[j].sha256, create_coinbase(), tips[j].nTime+1)\n+                next_block = create_block(tips[j].sha256, create_coinbase(i + 4), tips[j].nTime+1)\n                 next_block.solve()\n                 if j==0:\n                     test_node.send_message(msg_block(next_block))"
      },
      {
        "sha": "9555940cece5e4789f9c6657f687ae74b733a402",
        "filename": "qa/rpc-tests/p2p-fullblocktest.py",
        "status": "added",
        "additions": 272,
        "deletions": 0,
        "changes": 272,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/p2p-fullblocktest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/p2p-fullblocktest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-fullblocktest.py?ref=0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8",
        "patch": "@@ -0,0 +1,272 @@\n+#!/usr/bin/env python2\n+\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from test_framework.test_framework import ComparisonTestFramework\n+from test_framework.util import *\n+from test_framework.comptool import TestManager, TestInstance\n+from test_framework.mininode import *\n+from test_framework.blocktools import *\n+import logging\n+import copy\n+import time\n+import numbers\n+from test_framework.key import CECKey\n+from test_framework.script import CScript, CScriptOp, SignatureHash, SIGHASH_ALL, OP_TRUE\n+\n+class PreviousSpendableOutput(object):\n+    def __init__(self, tx = CTransaction(), n = -1):\n+        self.tx = tx\n+        self.n = n  # the output we're spending\n+\n+'''\n+This reimplements tests from the bitcoinj/FullBlockTestGenerator used\n+by the pull-tester.\n+\n+We use the testing framework in which we expect a particular answer from\n+each test.\n+'''\n+\n+class FullBlockTest(ComparisonTestFramework):\n+\n+    ''' Can either run this test as 1 node with expected answers, or two and compare them. \n+        Change the \"outcome\" variable from each TestInstance object to only do the comparison. '''\n+    def __init__(self):\n+        self.num_nodes = 1\n+        self.block_heights = {}\n+        self.coinbase_key = CECKey()\n+        self.coinbase_key.set_secretbytes(bytes(\"horsebattery\"))\n+        self.coinbase_pubkey = self.coinbase_key.get_pubkey()\n+        self.block_time = int(time.time())+1\n+        self.tip = None\n+        self.blocks = {}\n+\n+    def run_test(self):\n+        test = TestManager(self, self.options.tmpdir)\n+        test.add_all_connections(self.nodes)\n+        NetworkThread().start() # Start up network handling in another thread\n+        test.run()\n+\n+    def add_transactions_to_block(self, block, tx_list):\n+        [ tx.rehash() for tx in tx_list ]\n+        block.vtx.extend(tx_list)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        block.rehash()\n+        return block\n+    \n+    # Create a block on top of self.tip, and advance self.tip to point to the new block\n+    # if spend is specified, then 1 satoshi will be spent from that to an anyone-can-spend output,\n+    # and rest will go to fees.\n+    def next_block(self, number, spend=None, additional_coinbase_value=0, script=None):\n+        if self.tip == None:\n+            base_block_hash = self.genesis_hash\n+        else:\n+            base_block_hash = self.tip.sha256\n+        # First create the coinbase\n+        height = self.block_heights[base_block_hash] + 1\n+        coinbase = create_coinbase(height, self.coinbase_pubkey)\n+        coinbase.vout[0].nValue += additional_coinbase_value\n+        if (spend != None):\n+            coinbase.vout[0].nValue += spend.tx.vout[spend.n].nValue - 1 # all but one satoshi to fees\n+        coinbase.rehash()\n+        block = create_block(base_block_hash, coinbase, self.block_time)\n+        if (spend != None):\n+            tx = CTransaction()\n+            tx.vin.append(CTxIn(COutPoint(spend.tx.sha256, spend.n), \"\", 0xffffffff))  # no signature yet\n+            # This copies the java comparison tool testing behavior: the first\n+            # txout has a garbage scriptPubKey, \"to make sure we're not\n+            # pre-verifying too much\" (?)\n+            tx.vout.append(CTxOut(0, CScript([random.randint(0,255), height & 255])))\n+            if script == None:\n+                tx.vout.append(CTxOut(1, CScript([OP_TRUE])))\n+            else:\n+                tx.vout.append(CTxOut(1, script))\n+            # Now sign it if necessary\n+            scriptSig = \"\"\n+            scriptPubKey = bytearray(spend.tx.vout[spend.n].scriptPubKey)\n+            if (scriptPubKey[0] == OP_TRUE):  # looks like an anyone-can-spend\n+                scriptSig = CScript([OP_TRUE])\n+            else:\n+                # We have to actually sign it\n+                (sighash, err) = SignatureHash(spend.tx.vout[spend.n].scriptPubKey, tx, 0, SIGHASH_ALL)\n+                scriptSig = CScript([self.coinbase_key.sign(sighash) + bytes(bytearray([SIGHASH_ALL]))])\n+            tx.vin[0].scriptSig = scriptSig\n+            # Now add the transaction to the block\n+            block = self.add_transactions_to_block(block, [tx])\n+        block.solve()\n+        self.tip = block\n+        self.block_heights[block.sha256] = height\n+        self.block_time += 1\n+        assert number not in self.blocks\n+        self.blocks[number] = block\n+        return block\n+\n+    def get_tests(self):\n+        self.genesis_hash = int(self.nodes[0].getbestblockhash(), 16)\n+        self.block_heights[self.genesis_hash] = 0\n+        spendable_outputs = []\n+\n+        # save the current tip so it can be spent by a later block\n+        def save_spendable_output():\n+            spendable_outputs.append(self.tip)\n+\n+        # get an output that we previous marked as spendable\n+        def get_spendable_output():\n+            return PreviousSpendableOutput(spendable_outputs.pop(0).vtx[0], 0)\n+\n+        # returns a test case that asserts that the current tip was accepted\n+        def accepted():\n+            return TestInstance([[self.tip, True]])\n+\n+        # returns a test case that asserts that the current tip was rejected\n+        def rejected():\n+            return TestInstance([[self.tip, False]])\n+       \n+        # move the tip back to a previous block\n+        def tip(number):\n+            self.tip = self.blocks[number]\n+\n+        # creates a new block and advances the tip to that block\n+        block = self.next_block\n+\n+\n+        # Create a new block\n+        block(0)\n+        save_spendable_output()\n+        yield accepted()\n+\n+\n+        # Now we need that block to mature so we can spend the coinbase.\n+        test = TestInstance(sync_every_block=False)\n+        for i in range(100):\n+            block(1000 + i)\n+            test.blocks_and_transactions.append([self.tip, True])\n+            save_spendable_output()\n+        yield test\n+\n+\n+        # Start by bulding a couple of blocks on top (which output is spent is in parentheses):\n+        #     genesis -> b1 (0) -> b2 (1)\n+        out0 = get_spendable_output()\n+        block(1, spend=out0)\n+        save_spendable_output()\n+        yield accepted()\n+\n+        out1 = get_spendable_output()\n+        block(2, spend=out1)\n+        # Inv again, then deliver twice (shouldn't break anything).\n+        yield accepted()\n+\n+\n+        # so fork like this:\n+        # \n+        #     genesis -> b1 (0) -> b2 (1)\n+        #                      \\-> b3 (1)\n+        # \n+        # Nothing should happen at this point. We saw b2 first so it takes priority.\n+        tip(1)\n+        block(3, spend=out1)\n+        # Deliver twice (should still not break anything)\n+        yield rejected()\n+\n+\n+        # Now we add another block to make the alternative chain longer.\n+        # \n+        #     genesis -> b1 (0) -> b2 (1)\n+        #                      \\-> b3 (1) -> b4 (2)\n+        out2 = get_spendable_output()\n+        block(4, spend=out2)\n+        yield accepted()\n+\n+\n+        # ... and back to the first chain.\n+        #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6 (3)\n+        #                      \\-> b3 (1) -> b4 (2)\n+        tip(2)\n+        block(5, spend=out2)\n+        save_spendable_output()\n+        yield rejected()\n+\n+        out3 = get_spendable_output()\n+        block(6, spend=out3)\n+        yield accepted()\n+\n+\n+        # Try to create a fork that double-spends\n+        #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6 (3)\n+        #                                          \\-> b7 (2) -> b8 (4)\n+        #                      \\-> b3 (1) -> b4 (2)\n+        tip(5)\n+        block(7, spend=out2)\n+        yield rejected()\n+\n+        out4 = get_spendable_output()\n+        block(8, spend=out4)\n+        yield rejected()\n+\n+\n+        # Try to create a block that has too much fee\n+        #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6 (3)\n+        #                                                    \\-> b9 (4)\n+        #                      \\-> b3 (1) -> b4 (2)\n+        tip(6)\n+        block(9, spend=out4, additional_coinbase_value=1)\n+        yield rejected()\n+\n+        \n+        # Create a fork that ends in a block with too much fee (the one that causes the reorg)\n+        #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n+        #                                          \\-> b10 (3) -> b11 (4)\n+        #                      \\-> b3 (1) -> b4 (2)\n+        tip(5)\n+        block(10, spend=out3)\n+        yield rejected()\n+\n+        block(11, spend=out4, additional_coinbase_value=1)\n+        yield rejected()\n+\n+\n+        # Try again, but with a valid fork first\n+        #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n+        #                                          \\-> b12 (3) -> b13 (4) -> b14 (5)\n+        #                                              (b12 added last)\n+        #                      \\-> b3 (1) -> b4 (2)\n+        tip(5)\n+        b12 = block(12, spend=out3)\n+        save_spendable_output()\n+        #yield TestInstance([[b12, False]])\n+        b13 = block(13, spend=out4)\n+        # Deliver the block header for b12, and the block b13.\n+        # b13 should be accepted but the tip won't advance until b12 is delivered.\n+        yield TestInstance([[CBlockHeader(b12), None], [b13, False]])\n+\n+        save_spendable_output()\n+        out5 = get_spendable_output()\n+        # b14 is invalid, but the node won't know that until it tries to connect\n+        # Tip still can't advance because b12 is missing\n+        block(14, spend=out5, additional_coinbase_value=1)\n+        yield rejected()\n+\n+        yield TestInstance([[b12, True, b13.sha256]]) # New tip should be b13.\n+\n+        \n+        # Test that a block with a lot of checksigs is okay\n+        lots_of_checksigs = CScript([OP_CHECKSIG] * (1000000 / 50 - 1))\n+        tip(13)\n+        block(15, spend=out5, script=lots_of_checksigs)\n+        yield accepted()\n+\n+\n+        # Test that a block with too many checksigs is rejected\n+        out6 = get_spendable_output()\n+        too_many_checksigs = CScript([OP_CHECKSIG] * (1000000 / 50))\n+        block(16, spend=out6, script=too_many_checksigs)\n+        yield rejected()\n+\n+\n+\n+if __name__ == '__main__':\n+    FullBlockTest().main()"
      },
      {
        "sha": "afc44b51b5416b9bfa5589a5e8653ee5dfbffad7",
        "filename": "qa/rpc-tests/script_test.py",
        "status": "modified",
        "additions": 13,
        "deletions": 7,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/script_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/script_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/script_test.py?ref=0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8",
        "patch": "@@ -124,10 +124,10 @@ def ParseScript(json_script):\n     return parsed_script\n             \n class TestBuilder(object):\n-    def create_credit_tx(self, scriptPubKey):\n+    def create_credit_tx(self, scriptPubKey, height):\n         # self.tx1 is a coinbase transaction, modeled after the one created by script_tests.cpp\n         # This allows us to reuse signatures created in the unit test framework.\n-        self.tx1 = create_coinbase()                 # this has a bip34 scriptsig,\n+        self.tx1 = create_coinbase(height)                 # this has a bip34 scriptsig,\n         self.tx1.vin[0].scriptSig = CScript([0, 0])  # but this matches the unit tests\n         self.tx1.vout[0].nValue = 0\n         self.tx1.vout[0].scriptPubKey = scriptPubKey\n@@ -168,24 +168,26 @@ def generate_test_instance(self, pubkeystring, scriptsigstring):\n \n         test = TestInstance(sync_every_block=False)\n         test_build = TestBuilder()\n-        test_build.create_credit_tx(scriptpubkey)\n+        test_build.create_credit_tx(scriptpubkey, self.height)\n         test_build.create_spend_tx(scriptsig)\n         test_build.rehash()\n \n         block = create_block(self.tip, test_build.tx1, self.block_time)\n         self.block_time += 1\n         block.solve()\n         self.tip = block.sha256\n+        self.height += 1\n         test.blocks_and_transactions = [[block, True]]\n \n         for i in xrange(100):\n-            block = create_block(self.tip, create_coinbase(), self.block_time)\n+            block = create_block(self.tip, create_coinbase(self.height), self.block_time)\n             self.block_time += 1\n             block.solve()\n             self.tip = block.sha256\n+            self.height += 1\n             test.blocks_and_transactions.append([block, True])\n \n-        block = create_block(self.tip, create_coinbase(), self.block_time)\n+        block = create_block(self.tip, create_coinbase(self.height), self.block_time)\n         self.block_time += 1\n         block.vtx.append(test_build.tx2)\n         block.hashMerkleRoot = block.calc_merkle_root()\n@@ -198,26 +200,29 @@ def generate_test_instance(self, pubkeystring, scriptsigstring):\n     def get_tests(self):\n         self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n         self.block_time = 1333230000  # before the BIP16 switchover\n+        self.height = 1\n \n         '''\n         Create a new block with an anyone-can-spend coinbase\n         '''\n-        block = create_block(self.tip, create_coinbase(), self.block_time)\n+        block = create_block(self.tip, create_coinbase(self.height), self.block_time)\n         self.block_time += 1\n         block.solve()\n         self.tip = block.sha256\n+        self.height += 1\n         yield TestInstance(objects=[[block, True]])\n \n         '''\n         Build out to 100 blocks total, maturing the coinbase.\n         '''\n         test = TestInstance(objects=[], sync_every_block=False, sync_every_tx=False)\n         for i in xrange(100):\n-            b = create_block(self.tip, create_coinbase(), self.block_time)\n+            b = create_block(self.tip, create_coinbase(self.height), self.block_time)\n             b.solve()\n             test.blocks_and_transactions.append([b, True])\n             self.tip = b.sha256\n             self.block_time += 1\n+            self.height += 1\n         yield test\n  \n         ''' Iterate through script tests. '''\n@@ -229,6 +234,7 @@ def get_tests(self):\n                 self.nodes[1].invalidateblock(self.nodes[1].getblockhash(102))\n \n             self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+            self.height = 102\n \n             [scriptsig, scriptpubkey, flags] = script_test[0:3]\n             flags = ParseScriptFlags(flags)"
      },
      {
        "sha": "b9775b477cc280cdf8f565427dedb65e325cae47",
        "filename": "qa/rpc-tests/test_framework/blockstore.py",
        "status": "modified",
        "additions": 17,
        "deletions": 6,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/test_framework/blockstore.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/test_framework/blockstore.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/blockstore.py?ref=0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8",
        "patch": "@@ -10,6 +10,7 @@ class BlockStore(object):\n     def __init__(self, datadir):\n         self.blockDB = dbm.open(datadir + \"/blocks\", 'c')\n         self.currentBlock = 0L\n+        self.headers_map = dict()\n     \n     def close(self):\n         self.blockDB.close()\n@@ -26,24 +27,30 @@ def get(self, blockhash):\n         ret.calc_sha256()\n         return ret\n \n+    def get_header(self, blockhash):\n+        try:\n+            return self.headers_map[blockhash]\n+        except KeyError:\n+            return None\n+\n     # Note: this pulls full blocks out of the database just to retrieve\n     # the headers -- perhaps we could keep a separate data structure\n     # to avoid this overhead.\n     def headers_for(self, locator, hash_stop, current_tip=None):\n         if current_tip is None:\n             current_tip = self.currentBlock\n-        current_block = self.get(current_tip)\n-        if current_block is None:\n+        current_block_header = self.get_header(current_tip)\n+        if current_block_header is None:\n             return None\n \n         response = msg_headers()\n-        headersList = [ CBlockHeader(current_block) ]\n+        headersList = [ current_block_header ]\n         maxheaders = 2000\n         while (headersList[0].sha256 not in locator.vHave):\n             prevBlockHash = headersList[0].hashPrevBlock\n-            prevBlock = self.get(prevBlockHash)\n-            if prevBlock is not None:\n-                headersList.insert(0, CBlockHeader(prevBlock))\n+            prevBlockHeader = self.get_header(prevBlockHash)\n+            if prevBlockHeader is not None:\n+                headersList.insert(0, prevBlockHeader)\n             else:\n                 break\n         headersList = headersList[:maxheaders] # truncate if we have too many\n@@ -61,6 +68,10 @@ def add_block(self, block):\n         except TypeError as e:\n             print \"Unexpected error: \", sys.exc_info()[0], e.args\n         self.currentBlock = block.sha256\n+        self.headers_map[block.sha256] = CBlockHeader(block)\n+\n+    def add_header(self, header):\n+        self.headers_map[header.sha256] = header\n \n     def get_blocks(self, inv):\n         responses = []"
      },
      {
        "sha": "59aa8c15cc936626ca87b4654ebd1afe28f44555",
        "filename": "qa/rpc-tests/test_framework/blocktools.py",
        "status": "modified",
        "additions": 11,
        "deletions": 9,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/test_framework/blocktools.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/test_framework/blocktools.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/blocktools.py?ref=0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8",
        "patch": "@@ -5,7 +5,7 @@\n #\n \n from mininode import *\n-from script import CScript, CScriptOp\n+from script import CScript, CScriptOp, OP_TRUE, OP_CHECKSIG\n \n # Create a block (with regtest difficulty)\n def create_block(hashprev, coinbase, nTime=None):\n@@ -37,19 +37,21 @@ def serialize_script_num(value):\n         r[-1] |= 0x80\n     return r\n \n-counter=1\n-# Create an anyone-can-spend coinbase transaction, assuming no miner fees\n-def create_coinbase(heightAdjust = 0):\n-    global counter\n+# Create a coinbase transaction, assuming no miner fees.\n+# If pubkey is passed in, the coinbase output will be a P2PK output;\n+# otherwise an anyone-can-spend output.\n+def create_coinbase(height, pubkey = None):\n     coinbase = CTransaction()\n     coinbase.vin.append(CTxIn(COutPoint(0, 0xffffffff), \n-                ser_string(serialize_script_num(counter+heightAdjust)), 0xffffffff))\n-    counter += 1\n+                ser_string(serialize_script_num(height)), 0xffffffff))\n     coinbaseoutput = CTxOut()\n     coinbaseoutput.nValue = 50*100000000\n-    halvings = int((counter+heightAdjust)/150) # regtest\n+    halvings = int(height/150) # regtest\n     coinbaseoutput.nValue >>= halvings\n-    coinbaseoutput.scriptPubKey = \"\"\n+    if (pubkey != None):\n+        coinbaseoutput.scriptPubKey = CScript([pubkey, OP_CHECKSIG])\n+    else:\n+        coinbaseoutput.scriptPubKey = CScript([OP_TRUE])\n     coinbase.vout = [ coinbaseoutput ]\n     coinbase.calc_sha256()\n     return coinbase"
      },
      {
        "sha": "e0b3ce040d84e9d6dc1993d55cfa9744287c1a01",
        "filename": "qa/rpc-tests/test_framework/comptool.py",
        "status": "modified",
        "additions": 41,
        "deletions": 11,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/test_framework/comptool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/test_framework/comptool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/comptool.py?ref=0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8",
        "patch": "@@ -122,12 +122,19 @@ def send_mempool(self):\n # Instances of these are generated by the test generator, and fed into the\n # comptool.\n #\n-# \"blocks_and_transactions\" should be an array of [obj, True/False/None]:\n-#  - obj is either a CBlock or a CTransaction, and \n+# \"blocks_and_transactions\" should be an array of\n+#    [obj, True/False/None, hash/None]:\n+#  - obj is either a CBlock, CBlockHeader, or a CTransaction, and\n #  - the second value indicates whether the object should be accepted\n #    into the blockchain or mempool (for tests where we expect a certain\n #    answer), or \"None\" if we don't expect a certain answer and are just\n #    comparing the behavior of the nodes being tested.\n+#  - the third value is the hash to test the tip against (if None or omitted,\n+#    use the hash of the block)\n+#  - NOTE: if a block header, no test is performed; instead the header is\n+#    just added to the block_store.  This is to facilitate block delivery\n+#    when communicating with headers-first clients (when withholding an\n+#    intermediate block).\n # sync_every_block: if True, then each block will be inv'ed, synced, and\n #    nodes will be tested based on the outcome for the block.  If False,\n #    then inv's accumulate until all blocks are processed (or max inv size\n@@ -194,7 +201,6 @@ def blocks_requested():\n         if not wait_until(blocks_requested, attempts=20*num_blocks):\n             # print [ c.cb.block_request_map for c in self.connections ]\n             raise AssertionError(\"Not all nodes requested block\")\n-        # --> Answer request (we did this inline!)\n \n         # Send getheaders message\n         [ c.cb.send_getheaders() for c in self.connections ]\n@@ -217,7 +223,6 @@ def transaction_requested():\n         if not wait_until(transaction_requested, attempts=20*num_events):\n             # print [ c.cb.tx_request_map for c in self.connections ]\n             raise AssertionError(\"Not all nodes requested transaction\")\n-        # --> Answer request (we did this inline!)\n \n         # Get the mempool\n         [ c.cb.send_mempool() for c in self.connections ]\n@@ -272,29 +277,55 @@ def run(self):\n             # We use these variables to keep track of the last block\n             # and last transaction in the tests, which are used\n             # if we're not syncing on every block or every tx.\n-            [ block, block_outcome ] = [ None, None ]\n+            [ block, block_outcome, tip ] = [ None, None, None ]\n             [ tx, tx_outcome ] = [ None, None ]\n             invqueue = []\n \n-            for b_or_t, outcome in test_instance.blocks_and_transactions:\n+            for test_obj in test_instance.blocks_and_transactions:\n+                b_or_t = test_obj[0]\n+                outcome = test_obj[1]\n                 # Determine if we're dealing with a block or tx\n                 if isinstance(b_or_t, CBlock):  # Block test runner\n                     block = b_or_t\n                     block_outcome = outcome\n+                    tip = block.sha256\n+                    # each test_obj can have an optional third argument\n+                    # to specify the tip we should compare with\n+                    # (default is to use the block being tested)\n+                    if len(test_obj) >= 3:\n+                        tip = test_obj[2]\n+\n                     # Add to shared block_store, set as current block\n+                    # If there was an open getdata request for the block\n+                    # previously, and we didn't have an entry in the\n+                    # block_store, then immediately deliver, because the\n+                    # node wouldn't send another getdata request while\n+                    # the earlier one is outstanding.\n+                    first_block_with_hash = True\n+                    if self.block_store.get(block.sha256) is not None:\n+                        first_block_with_hash = False\n                     with mininode_lock:\n                         self.block_store.add_block(block)\n                         for c in self.connections:\n-                            c.cb.block_request_map[block.sha256] = False\n+                            if first_block_with_hash and block.sha256 in c.cb.block_request_map and c.cb.block_request_map[block.sha256] == True:\n+                                # There was a previous request for this block hash\n+                                # Most likely, we delivered a header for this block\n+                                # but never had the block to respond to the getdata\n+                                c.send_message(msg_block(block))\n+                            else:\n+                                c.cb.block_request_map[block.sha256] = False\n                     # Either send inv's to each node and sync, or add\n                     # to invqueue for later inv'ing.\n                     if (test_instance.sync_every_block):\n                         [ c.cb.send_inv(block) for c in self.connections ]\n                         self.sync_blocks(block.sha256, 1)\n-                        if (not self.check_results(block.sha256, outcome)):\n+                        if (not self.check_results(tip, outcome)):\n                             raise AssertionError(\"Test failed at test %d\" % test_number)\n                     else:\n                         invqueue.append(CInv(2, block.sha256))\n+                elif isinstance(b_or_t, CBlockHeader):\n+                    block_header = b_or_t\n+                    self.block_store.add_header(block_header)\n                 else:  # Tx test runner\n                     assert(isinstance(b_or_t, CTransaction))\n                     tx = b_or_t\n@@ -322,9 +353,8 @@ def run(self):\n                 if len(invqueue) > 0:\n                     [ c.send_message(msg_inv(invqueue)) for c in self.connections ]\n                     invqueue = []\n-                self.sync_blocks(block.sha256,\n-                                 len(test_instance.blocks_and_transactions))\n-                if (not self.check_results(block.sha256, block_outcome)):\n+                self.sync_blocks(block.sha256, len(test_instance.blocks_and_transactions))\n+                if (not self.check_results(tip, block_outcome)):\n                     raise AssertionError(\"Block test failed at test %d\" % test_number)\n             if (not test_instance.sync_every_tx and tx is not None):\n                 if len(invqueue) > 0:"
      },
      {
        "sha": "ba3038fe044f49f54e0d6286e22ae9d4cbcde7df",
        "filename": "qa/rpc-tests/test_framework/key.py",
        "status": "added",
        "additions": 215,
        "deletions": 0,
        "changes": 215,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/test_framework/key.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/test_framework/key.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/key.py?ref=0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8",
        "patch": "@@ -0,0 +1,215 @@\n+# Copyright (c) 2011 Sam Rushing\n+#\n+# key.py - OpenSSL wrapper\n+#\n+# This file is modified from python-bitcoinlib.\n+#\n+\n+\"\"\"ECC secp256k1 crypto routines\n+\n+WARNING: This module does not mlock() secrets; your private keys may end up on\n+disk in swap! Use with caution!\n+\"\"\"\n+\n+import ctypes\n+import ctypes.util\n+import hashlib\n+import sys\n+\n+ssl = ctypes.cdll.LoadLibrary(ctypes.util.find_library ('ssl') or 'libeay32')\n+\n+ssl.BN_new.restype = ctypes.c_void_p\n+ssl.BN_new.argtypes = []\n+\n+ssl.BN_bin2bn.restype = ctypes.c_void_p\n+ssl.BN_bin2bn.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.c_void_p]\n+\n+ssl.BN_CTX_free.restype = None\n+ssl.BN_CTX_free.argtypes = [ctypes.c_void_p]\n+\n+ssl.BN_CTX_new.restype = ctypes.c_void_p\n+ssl.BN_CTX_new.argtypes = []\n+\n+ssl.ECDH_compute_key.restype = ctypes.c_int\n+ssl.ECDH_compute_key.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p]\n+\n+ssl.ECDSA_sign.restype = ctypes.c_int\n+ssl.ECDSA_sign.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n+\n+ssl.ECDSA_verify.restype = ctypes.c_int\n+ssl.ECDSA_verify.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p]\n+\n+ssl.EC_KEY_free.restype = None\n+ssl.EC_KEY_free.argtypes = [ctypes.c_void_p]\n+\n+ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n+ssl.EC_KEY_new_by_curve_name.argtypes = [ctypes.c_int]\n+\n+ssl.EC_KEY_get0_group.restype = ctypes.c_void_p\n+ssl.EC_KEY_get0_group.argtypes = [ctypes.c_void_p]\n+\n+ssl.EC_KEY_get0_public_key.restype = ctypes.c_void_p\n+ssl.EC_KEY_get0_public_key.argtypes = [ctypes.c_void_p]\n+\n+ssl.EC_KEY_set_private_key.restype = ctypes.c_int\n+ssl.EC_KEY_set_private_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n+\n+ssl.EC_KEY_set_conv_form.restype = None\n+ssl.EC_KEY_set_conv_form.argtypes = [ctypes.c_void_p, ctypes.c_int]\n+\n+ssl.EC_KEY_set_public_key.restype = ctypes.c_int\n+ssl.EC_KEY_set_public_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n+\n+ssl.i2o_ECPublicKey.restype = ctypes.c_void_p\n+ssl.i2o_ECPublicKey.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n+\n+ssl.EC_POINT_new.restype = ctypes.c_void_p\n+ssl.EC_POINT_new.argtypes = [ctypes.c_void_p]\n+\n+ssl.EC_POINT_free.restype = None\n+ssl.EC_POINT_free.argtypes = [ctypes.c_void_p]\n+\n+ssl.EC_POINT_mul.restype = ctypes.c_int\n+ssl.EC_POINT_mul.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n+\n+# this specifies the curve used with ECDSA.\n+NID_secp256k1 = 714 # from openssl/obj_mac.h\n+\n+# Thx to Sam Devlin for the ctypes magic 64-bit fix.\n+def _check_result(val, func, args):\n+    if val == 0:\n+        raise ValueError\n+    else:\n+        return ctypes.c_void_p (val)\n+\n+ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n+ssl.EC_KEY_new_by_curve_name.errcheck = _check_result\n+\n+class CECKey(object):\n+    \"\"\"Wrapper around OpenSSL's EC_KEY\"\"\"\n+\n+    POINT_CONVERSION_COMPRESSED = 2\n+    POINT_CONVERSION_UNCOMPRESSED = 4\n+\n+    def __init__(self):\n+        self.k = ssl.EC_KEY_new_by_curve_name(NID_secp256k1)\n+\n+    def __del__(self):\n+        if ssl:\n+            ssl.EC_KEY_free(self.k)\n+        self.k = None\n+\n+    def set_secretbytes(self, secret):\n+        priv_key = ssl.BN_bin2bn(secret, 32, ssl.BN_new())\n+        group = ssl.EC_KEY_get0_group(self.k)\n+        pub_key = ssl.EC_POINT_new(group)\n+        ctx = ssl.BN_CTX_new()\n+        if not ssl.EC_POINT_mul(group, pub_key, priv_key, None, None, ctx):\n+            raise ValueError(\"Could not derive public key from the supplied secret.\")\n+        ssl.EC_POINT_mul(group, pub_key, priv_key, None, None, ctx)\n+        ssl.EC_KEY_set_private_key(self.k, priv_key)\n+        ssl.EC_KEY_set_public_key(self.k, pub_key)\n+        ssl.EC_POINT_free(pub_key)\n+        ssl.BN_CTX_free(ctx)\n+        return self.k\n+\n+    def set_privkey(self, key):\n+        self.mb = ctypes.create_string_buffer(key)\n+        return ssl.d2i_ECPrivateKey(ctypes.byref(self.k), ctypes.byref(ctypes.pointer(self.mb)), len(key))\n+\n+    def set_pubkey(self, key):\n+        self.mb = ctypes.create_string_buffer(key)\n+        return ssl.o2i_ECPublicKey(ctypes.byref(self.k), ctypes.byref(ctypes.pointer(self.mb)), len(key))\n+\n+    def get_privkey(self):\n+        size = ssl.i2d_ECPrivateKey(self.k, 0)\n+        mb_pri = ctypes.create_string_buffer(size)\n+        ssl.i2d_ECPrivateKey(self.k, ctypes.byref(ctypes.pointer(mb_pri)))\n+        return mb_pri.raw\n+\n+    def get_pubkey(self):\n+        size = ssl.i2o_ECPublicKey(self.k, 0)\n+        mb = ctypes.create_string_buffer(size)\n+        ssl.i2o_ECPublicKey(self.k, ctypes.byref(ctypes.pointer(mb)))\n+        return mb.raw\n+\n+    def get_raw_ecdh_key(self, other_pubkey):\n+        ecdh_keybuffer = ctypes.create_string_buffer(32)\n+        r = ssl.ECDH_compute_key(ctypes.pointer(ecdh_keybuffer), 32,\n+                                 ssl.EC_KEY_get0_public_key(other_pubkey.k),\n+                                 self.k, 0)\n+        if r != 32:\n+            raise Exception('CKey.get_ecdh_key(): ECDH_compute_key() failed')\n+        return ecdh_keybuffer.raw\n+\n+    def get_ecdh_key(self, other_pubkey, kdf=lambda k: hashlib.sha256(k).digest()):\n+        # FIXME: be warned it's not clear what the kdf should be as a default\n+        r = self.get_raw_ecdh_key(other_pubkey)\n+        return kdf(r)\n+\n+    def sign(self, hash):\n+        # FIXME: need unit tests for below cases\n+        if not isinstance(hash, bytes):\n+            raise TypeError('Hash must be bytes instance; got %r' % hash.__class__)\n+        if len(hash) != 32:\n+            raise ValueError('Hash must be exactly 32 bytes long')\n+\n+        sig_size0 = ctypes.c_uint32()\n+        sig_size0.value = ssl.ECDSA_size(self.k)\n+        mb_sig = ctypes.create_string_buffer(sig_size0.value)\n+        result = ssl.ECDSA_sign(0, hash, len(hash), mb_sig, ctypes.byref(sig_size0), self.k)\n+        assert 1 == result\n+        return mb_sig.raw[:sig_size0.value]\n+\n+    def verify(self, hash, sig):\n+        \"\"\"Verify a DER signature\"\"\"\n+        return ssl.ECDSA_verify(0, hash, len(hash), sig, len(sig), self.k) == 1\n+\n+    def set_compressed(self, compressed):\n+        if compressed:\n+            form = self.POINT_CONVERSION_COMPRESSED\n+        else:\n+            form = self.POINT_CONVERSION_UNCOMPRESSED\n+        ssl.EC_KEY_set_conv_form(self.k, form)\n+\n+\n+class CPubKey(bytes):\n+    \"\"\"An encapsulated public key\n+\n+    Attributes:\n+\n+    is_valid      - Corresponds to CPubKey.IsValid()\n+    is_fullyvalid - Corresponds to CPubKey.IsFullyValid()\n+    is_compressed - Corresponds to CPubKey.IsCompressed()\n+    \"\"\"\n+\n+    def __new__(cls, buf, _cec_key=None):\n+        self = super(CPubKey, cls).__new__(cls, buf)\n+        if _cec_key is None:\n+            _cec_key = CECKey()\n+        self._cec_key = _cec_key\n+        self.is_fullyvalid = _cec_key.set_pubkey(self) != 0\n+        return self\n+\n+    @property\n+    def is_valid(self):\n+        return len(self) > 0\n+\n+    @property\n+    def is_compressed(self):\n+        return len(self) == 33\n+\n+    def verify(self, hash, sig):\n+        return self._cec_key.verify(hash, sig)\n+\n+    def __str__(self):\n+        return repr(self)\n+\n+    def __repr__(self):\n+        # Always have represent as b'<secret>' so test cases don't have to\n+        # change for py2/3\n+        if sys.version > '3':\n+            return '%s(%s)' % (self.__class__.__name__, super(CPubKey, self).__repr__())\n+        else:\n+            return '%s(b%s)' % (self.__class__.__name__, super(CPubKey, self).__repr__())\n+"
      },
      {
        "sha": "0a78cf6fb1b3cca598325dd344880bcb89ba1187",
        "filename": "qa/rpc-tests/test_framework/script.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/test_framework/script.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8/qa/rpc-tests/test_framework/script.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/script.py?ref=0ce73985a80c3bb0c9a2024f8df6ce68c648dbb8",
        "patch": "@@ -27,7 +27,7 @@\n import copy\n import struct\n \n-import test_framework.bignum\n+from test_framework.bignum import bn2vch\n \n MAX_SCRIPT_SIZE = 10000\n MAX_SCRIPT_ELEMENT_SIZE = 520\n@@ -664,7 +664,7 @@ def __coerce_instance(cls, other):\n             elif other == -1:\n                 other = bytes(bchr(OP_1NEGATE))\n             else:\n-                other = CScriptOp.encode_op_pushdata(bignum.bn2vch(other))\n+                other = CScriptOp.encode_op_pushdata(bn2vch(other))\n         elif isinstance(other, (bytes, bytearray)):\n             other = CScriptOp.encode_op_pushdata(other)\n         return other"
      }
    ]
  }
]