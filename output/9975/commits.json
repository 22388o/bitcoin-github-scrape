[
  {
    "sha": "143439c0c141712d2ca57f291c0888b6a18cb98b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNDM0MzljMGMxNDE3MTJkMmNhNTdmMjkxYzA4ODhiNmExOGNiOThi",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-06-02T15:52:24Z"
      },
      "committer": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-05T15:09:16Z"
      },
      "message": "--- bitcore start ---",
      "tree": {
        "sha": "0337e1910c7348807edcbc2256bd14225c0a28f3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0337e1910c7348807edcbc2256bd14225c0a28f3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/143439c0c141712d2ca57f291c0888b6a18cb98b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/143439c0c141712d2ca57f291c0888b6a18cb98b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/143439c0c141712d2ca57f291c0888b6a18cb98b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/143439c0c141712d2ca57f291c0888b6a18cb98b/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "a402396dce64c42ea73535b7dde4a9164d430438",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a402396dce64c42ea73535b7dde4a9164d430438",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a402396dce64c42ea73535b7dde4a9164d430438"
      }
    ],
    "stats": {
      "total": 0,
      "additions": 0,
      "deletions": 0
    },
    "files": []
  },
  {
    "sha": "017f548ea6d89423ef568117447e61dd5707ec42",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMTdmNTQ4ZWE2ZDg5NDIzZWY1NjgxMTc0NDdlNjFkZDU3MDdlYzQy",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-04T18:58:32Z"
      },
      "committer": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-05T15:28:13Z"
      },
      "message": "indexes: adds additional address, spent and timestamp indexes\n\nAdds new bitcoin.conf configuration options for three new indexes:\n-addressindex=1\n-spentindex=1\n-timestampindex=1\n\nThe addressindex records all changes to an address for retrieving txids, balances and\nunspent outputs for addresses. Changes are stored and sorted in block order. Both p2sh\nand p2pkh address types are supported. The index records two sets of key/value pairs.\nThe first records all activity and is useful for viewing transaction history and\nall changes. The second is specifically for retrieving unspent outputs by address, and\nis smaller as values are removed once they are spent.\n\nThe spentindex has multiple purposes and brings closer together inputs and outputs of\ntransactions. The main purpose is to efficiently determine the address and amount of\nan input's previous output. The second purpose is to be able to determine which\ninput spent an output.\n\nThe timestampindex keeps track of timestamps with block hashes and is useful for searching\nblocks by date instead of by height. This is useful for a block explorer that will give\nsearch options by date. The index uses logical time correction to make sure that the\nresults are sorted in block order. The logical time of a block is actual timestamp of the\nblock, unless it is less than (earlier) the previous block's logical time, and in that\ncase it is one second greater than the previous block's logical time.\n\nIncludes logical time fix by Chethan Krishna\n\nConflicts:\n\tsrc/main.cpp\n\tsrc/main.h\n\tsrc/txdb.cpp\n\tsrc/txdb.h\n\tsrc/txmempool.h",
      "tree": {
        "sha": "71041301222803e4e645ac3305ee907be5f56f36",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/71041301222803e4e645ac3305ee907be5f56f36"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/017f548ea6d89423ef568117447e61dd5707ec42",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/017f548ea6d89423ef568117447e61dd5707ec42",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/017f548ea6d89423ef568117447e61dd5707ec42",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/017f548ea6d89423ef568117447e61dd5707ec42/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "143439c0c141712d2ca57f291c0888b6a18cb98b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/143439c0c141712d2ca57f291c0888b6a18cb98b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/143439c0c141712d2ca57f291c0888b6a18cb98b"
      }
    ],
    "stats": {
      "total": 1196,
      "additions": 1196,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f135f567eb7b242943a0d6dfe5d8bf8c5bf4993c",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/017f548ea6d89423ef568117447e61dd5707ec42/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/017f548ea6d89423ef568117447e61dd5707ec42/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=017f548ea6d89423ef568117447e61dd5707ec42",
        "patch": "@@ -71,6 +71,8 @@ endif\n .PHONY: FORCE check-symbols check-security\n # bitcoin core #\n BITCOIN_CORE_H = \\\n+  addressindex.h \\\n+  spentindex.h \\\n   addrman.h \\\n   base58.h \\\n   bloom.h \\"
      },
      {
        "sha": "9e734b84dcdcaa7581674d0ba8644a6df5e178a2",
        "filename": "src/addressindex.h",
        "status": "added",
        "additions": 82,
        "deletions": 0,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/017f548ea6d89423ef568117447e61dd5707ec42/src/addressindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/017f548ea6d89423ef568117447e61dd5707ec42/src/addressindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addressindex.h?ref=017f548ea6d89423ef568117447e61dd5707ec42",
        "patch": "@@ -0,0 +1,82 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_ADDRESSINDEX_H\n+#define BITCOIN_ADDRESSINDEX_H\n+\n+#include \"uint256.h\"\n+#include \"amount.h\"\n+\n+struct CMempoolAddressDelta\n+{\n+    int64_t time;\n+    CAmount amount;\n+    uint256 prevhash;\n+    unsigned int prevout;\n+\n+    CMempoolAddressDelta(int64_t t, CAmount a, uint256 hash, unsigned int out) {\n+        time = t;\n+        amount = a;\n+        prevhash = hash;\n+        prevout = out;\n+    }\n+\n+    CMempoolAddressDelta(int64_t t, CAmount a) {\n+        time = t;\n+        amount = a;\n+        prevhash.SetNull();\n+        prevout = 0;\n+    }\n+};\n+\n+struct CMempoolAddressDeltaKey\n+{\n+    int type;\n+    uint160 addressBytes;\n+    uint256 txhash;\n+    unsigned int index;\n+    int spending;\n+\n+    CMempoolAddressDeltaKey(int addressType, uint160 addressHash, uint256 hash, unsigned int i, int s) {\n+        type = addressType;\n+        addressBytes = addressHash;\n+        txhash = hash;\n+        index = i;\n+        spending = s;\n+    }\n+\n+    CMempoolAddressDeltaKey(int addressType, uint160 addressHash) {\n+        type = addressType;\n+        addressBytes = addressHash;\n+        txhash.SetNull();\n+        index = 0;\n+        spending = 0;\n+    }\n+};\n+\n+struct CMempoolAddressDeltaKeyCompare\n+{\n+    bool operator()(const CMempoolAddressDeltaKey& a, const CMempoolAddressDeltaKey& b) const {\n+        if (a.type == b.type) {\n+            if (a.addressBytes == b.addressBytes) {\n+                if (a.txhash == b.txhash) {\n+                    if (a.index == b.index) {\n+                        return a.spending < b.spending;\n+                    } else {\n+                        return a.index < b.index;\n+                    }\n+                } else {\n+                    return a.txhash < b.txhash;\n+                }\n+            } else {\n+                return a.addressBytes < b.addressBytes;\n+            }\n+        } else {\n+            return a.type < b.type;\n+        }\n+    }\n+};\n+\n+#endif // BITCOIN_ADDRESSINDEX_H"
      },
      {
        "sha": "ab7eed4f344bd744962b0f1009ac67f5f4863e2e",
        "filename": "src/base58.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/017f548ea6d89423ef568117447e61dd5707ec42/src/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/017f548ea6d89423ef568117447e61dd5707ec42/src/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.cpp?ref=017f548ea6d89423ef568117447e61dd5707ec42",
        "patch": "@@ -267,6 +267,23 @@ CTxDestination CBitcoinAddress::Get() const\n         return CNoDestination();\n }\n \n+bool CBitcoinAddress::GetIndexKey(uint160& hashBytes, int& type) const\n+{\n+    if (!IsValid()) {\n+        return false;\n+    } else if (vchVersion == Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS)) {\n+        memcpy(&hashBytes, &vchData[0], 20);\n+        type = 1;\n+        return true;\n+    } else if (vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS)) {\n+        memcpy(&hashBytes, &vchData[0], 20);\n+        type = 2;\n+        return true;\n+    }\n+\n+    return false;\n+}\n+\n bool CBitcoinAddress::GetKeyID(CKeyID& keyID) const\n {\n     if (!IsValid() || vchVersion != Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS))"
      },
      {
        "sha": "6c2297e220838fdc24f0f2dc61cbde0c01ad3cf2",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/017f548ea6d89423ef568117447e61dd5707ec42/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/017f548ea6d89423ef568117447e61dd5707ec42/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=017f548ea6d89423ef568117447e61dd5707ec42",
        "patch": "@@ -116,6 +116,7 @@ class CBitcoinAddress : public CBase58Data {\n \n     CTxDestination Get() const;\n     bool GetKeyID(CKeyID &keyID) const;\n+    bool GetIndexKey(uint160& hashBytes, int& type) const;\n     bool IsScript() const;\n };\n "
      },
      {
        "sha": "3a1d807b1257ce7fcc12c02206e393a92c73cbfd",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/017f548ea6d89423ef568117447e61dd5707ec42/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/017f548ea6d89423ef568117447e61dd5707ec42/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=017f548ea6d89423ef568117447e61dd5707ec42",
        "patch": "@@ -340,6 +340,10 @@ std::string HelpMessage(HelpMessageMode mode)\n #endif\n     strUsage += HelpMessageOpt(\"-txindex\", strprintf(_(\"Maintain a full transaction index, used by the getrawtransaction rpc call (default: %u)\"), DEFAULT_TXINDEX));\n \n+    strUsage += HelpMessageOpt(\"-addressindex\", strprintf(_(\"Maintain a full address index, used to query for the balance, txids and unspent outputs for addresses (default: %u)\"), DEFAULT_ADDRESSINDEX));\n+    strUsage += HelpMessageOpt(\"-timestampindex\", strprintf(_(\"Maintain a timestamp index for block hashes, used to query blocks hashes by a range of timestamps (default: %u)\"), DEFAULT_TIMESTAMPINDEX));\n+    strUsage += HelpMessageOpt(\"-spentindex\", strprintf(_(\"Maintain a full spent index, used to query the spending txid and input index for an outpoint (default: %u)\"), DEFAULT_SPENTINDEX));\n+\n     strUsage += HelpMessageGroup(_(\"Connection options:\"));\n     strUsage += HelpMessageOpt(\"-addnode=<ip>\", _(\"Add a node to connect to and attempt to keep the connection open\"));\n     strUsage += HelpMessageOpt(\"-banscore=<n>\", strprintf(_(\"Threshold for disconnecting misbehaving peers (default: %u)\"), DEFAULT_BANSCORE_THRESHOLD));"
      },
      {
        "sha": "1232a098d0dfa937546cede13562033483e369b0",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 271,
        "deletions": 0,
        "changes": 271,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/017f548ea6d89423ef568117447e61dd5707ec42/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/017f548ea6d89423ef568117447e61dd5707ec42/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=017f548ea6d89423ef568117447e61dd5707ec42",
        "patch": "@@ -70,6 +70,9 @@ int nScriptCheckThreads = 0;\n bool fImporting = false;\n bool fReindex = false;\n bool fTxIndex = false;\n+bool fAddressIndex = false;\n+bool fTimestampIndex = false;\n+bool fSpentIndex = false;\n bool fHavePruned = false;\n bool fPruneMode = false;\n bool fIsBareMultisigStd = DEFAULT_PERMIT_BAREMULTISIG;\n@@ -1538,6 +1541,16 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         // Store transaction in memory\n         pool.addUnchecked(hash, entry, setAncestors, !IsInitialBlockDownload());\n \n+        // Add memory address index\n+        if (fAddressIndex) {\n+            pool.addAddressIndex(entry, view);\n+        }\n+\n+        // Add memory spent index\n+        if (fSpentIndex) {\n+            pool.addSpentIndex(entry, view);\n+        }\n+\n         // trim mempool and check if tx was trimmed\n         if (!fOverrideMempoolLimit) {\n             LimitMempoolSize(pool, GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n@@ -1563,6 +1576,55 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n     return res;\n }\n \n+bool GetTimestampIndex(const unsigned int &high, const unsigned int &low, const bool fActiveOnly, std::vector<std::pair<uint256, unsigned int> > &hashes)\n+{\n+    if (!fTimestampIndex)\n+        return error(\"Timestamp index not enabled\");\n+\n+    if (!pblocktree->ReadTimestampIndex(high, low, fActiveOnly, hashes))\n+        return error(\"Unable to get hashes for timestamps\");\n+\n+    return true;\n+}\n+\n+bool GetSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value)\n+{\n+    if (!fSpentIndex)\n+        return false;\n+\n+    if (mempool.getSpentIndex(key, value))\n+        return true;\n+\n+    if (!pblocktree->ReadSpentIndex(key, value))\n+        return false;\n+\n+    return true;\n+}\n+\n+bool GetAddressIndex(uint160 addressHash, int type,\n+                     std::vector<std::pair<CAddressIndexKey, CAmount> > &addressIndex, int start, int end)\n+{\n+    if (!fAddressIndex)\n+        return error(\"address index not enabled\");\n+\n+    if (!pblocktree->ReadAddressIndex(addressHash, type, addressIndex, start, end))\n+        return error(\"unable to get txids for address\");\n+\n+    return true;\n+}\n+\n+bool GetAddressUnspent(uint160 addressHash, int type,\n+                       std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > &unspentOutputs)\n+{\n+    if (!fAddressIndex)\n+        return error(\"address index not enabled\");\n+\n+    if (!pblocktree->ReadAddressUnspentIndex(addressHash, type, unspentOutputs))\n+        return error(\"unable to get txids for address\");\n+\n+    return true;\n+}\n+\n /** Return transaction in tx, and if it was found inside a block, its hash is placed in hashBlock */\n bool GetTransaction(const uint256 &hash, CTransaction &txOut, const Consensus::Params& consensusParams, uint256 &hashBlock, bool fAllowSlow)\n {\n@@ -2162,11 +2224,46 @@ bool DisconnectBlock(const CBlock& block, CValidationState& state, const CBlockI\n     if (blockUndo.vtxundo.size() + 1 != block.vtx.size())\n         return error(\"DisconnectBlock(): block and undo data inconsistent\");\n \n+    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;\n+    std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > addressUnspentIndex;\n+    std::vector<std::pair<CSpentIndexKey, CSpentIndexValue> > spentIndex;\n+\n     // undo transactions in reverse order\n     for (int i = block.vtx.size() - 1; i >= 0; i--) {\n         const CTransaction &tx = block.vtx[i];\n         uint256 hash = tx.GetHash();\n \n+        if (fAddressIndex) {\n+\n+            for (unsigned int k = tx.vout.size(); k-- > 0;) {\n+                const CTxOut &out = tx.vout[k];\n+\n+                if (out.scriptPubKey.IsPayToScriptHash()) {\n+                    vector<unsigned char> hashBytes(out.scriptPubKey.begin()+2, out.scriptPubKey.begin()+22);\n+\n+                    // undo receiving activity\n+                    addressIndex.push_back(make_pair(CAddressIndexKey(2, uint160(hashBytes), pindex->nHeight, i, hash, k, false), out.nValue));\n+\n+                    // undo unspent index\n+                    addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(2, uint160(hashBytes), hash, k), CAddressUnspentValue()));\n+\n+                } else if (out.scriptPubKey.IsPayToPublicKeyHash()) {\n+                    vector<unsigned char> hashBytes(out.scriptPubKey.begin()+3, out.scriptPubKey.begin()+23);\n+\n+                    // undo receiving activity\n+                    addressIndex.push_back(make_pair(CAddressIndexKey(1, uint160(hashBytes), pindex->nHeight, i, hash, k, false), out.nValue));\n+\n+                    // undo unspent index\n+                    addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(1, uint160(hashBytes), hash, k), CAddressUnspentValue()));\n+\n+                } else {\n+                    continue;\n+                }\n+\n+            }\n+\n+        }\n+\n         // Check that all outputs are available and match the outputs in the block itself\n         // exactly.\n         {\n@@ -2196,10 +2293,45 @@ bool DisconnectBlock(const CBlock& block, CValidationState& state, const CBlockI\n                 const CTxInUndo &undo = txundo.vprevout[j];\n                 if (!ApplyTxInUndo(undo, view, out))\n                     fClean = false;\n+\n+                const CTxIn input = tx.vin[j];\n+\n+                if (fSpentIndex) {\n+                    // undo and delete the spent index\n+                    spentIndex.push_back(make_pair(CSpentIndexKey(input.prevout.hash, input.prevout.n), CSpentIndexValue()));\n+                }\n+\n+                if (fAddressIndex) {\n+                    const CTxOut &prevout = view.GetOutputFor(tx.vin[j]);\n+                    if (prevout.scriptPubKey.IsPayToScriptHash()) {\n+                        vector<unsigned char> hashBytes(prevout.scriptPubKey.begin()+2, prevout.scriptPubKey.begin()+22);\n+\n+                        // undo spending activity\n+                        addressIndex.push_back(make_pair(CAddressIndexKey(2, uint160(hashBytes), pindex->nHeight, i, hash, j, true), prevout.nValue * -1));\n+\n+                        // restore unspent index\n+                        addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(2, uint160(hashBytes), input.prevout.hash, input.prevout.n), CAddressUnspentValue(prevout.nValue, prevout.scriptPubKey, undo.nHeight)));\n+\n+\n+                    } else if (prevout.scriptPubKey.IsPayToPublicKeyHash()) {\n+                        vector<unsigned char> hashBytes(prevout.scriptPubKey.begin()+3, prevout.scriptPubKey.begin()+23);\n+\n+                        // undo spending activity\n+                        addressIndex.push_back(make_pair(CAddressIndexKey(1, uint160(hashBytes), pindex->nHeight, i, hash, j, true), prevout.nValue * -1));\n+\n+                        // restore unspent index\n+                        addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(1, uint160(hashBytes), input.prevout.hash, input.prevout.n), CAddressUnspentValue(prevout.nValue, prevout.scriptPubKey, undo.nHeight)));\n+\n+                    } else {\n+                        continue;\n+                    }\n+                }\n+\n             }\n         }\n     }\n \n+\n     // move best block pointer to prevout block\n     view.SetBestBlock(pindex->pprev->GetBlockHash());\n \n@@ -2208,6 +2340,15 @@ bool DisconnectBlock(const CBlock& block, CValidationState& state, const CBlockI\n         return true;\n     }\n \n+    if (fAddressIndex) {\n+        if (!pblocktree->EraseAddressIndex(addressIndex)) {\n+            return AbortNode(state, \"Failed to delete address index\");\n+        }\n+        if (!pblocktree->UpdateAddressUnspentIndex(addressUnspentIndex)) {\n+            return AbortNode(state, \"Failed to write address unspent index\");\n+        }\n+    }\n+\n     return fClean;\n }\n \n@@ -2412,9 +2553,14 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n     std::vector<std::pair<uint256, CDiskTxPos> > vPos;\n     vPos.reserve(block.vtx.size());\n     blockundo.vtxundo.reserve(block.vtx.size() - 1);\n+    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;\n+    std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > addressUnspentIndex;\n+    std::vector<std::pair<CSpentIndexKey, CSpentIndexValue> > spentIndex;\n+\n     for (unsigned int i = 0; i < block.vtx.size(); i++)\n     {\n         const CTransaction &tx = block.vtx[i];\n+        const uint256 txhash = tx.GetHash();\n \n         nInputs += tx.vin.size();\n \n@@ -2447,6 +2593,43 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n                 return state.DoS(100, error(\"%s: contains a non-BIP68-final transaction\", __func__),\n                                  REJECT_INVALID, \"bad-txns-nonfinal\");\n             }\n+\n+            if (fAddressIndex || fSpentIndex)\n+            {\n+                for (size_t j = 0; j < tx.vin.size(); j++) {\n+\n+                    const CTxIn input = tx.vin[j];\n+                    const CTxOut &prevout = view.GetOutputFor(tx.vin[j]);\n+                    uint160 hashBytes;\n+                    int addressType;\n+\n+                    if (prevout.scriptPubKey.IsPayToScriptHash()) {\n+                        hashBytes = uint160(vector <unsigned char>(prevout.scriptPubKey.begin()+2, prevout.scriptPubKey.begin()+22));\n+                        addressType = 2;\n+                    } else if (prevout.scriptPubKey.IsPayToPublicKeyHash()) {\n+                        hashBytes = uint160(vector <unsigned char>(prevout.scriptPubKey.begin()+3, prevout.scriptPubKey.begin()+23));\n+                        addressType = 1;\n+                    } else {\n+                        hashBytes.SetNull();\n+                        addressType = 0;\n+                    }\n+\n+                    if (fAddressIndex && addressType > 0) {\n+                        // record spending activity\n+                        addressIndex.push_back(make_pair(CAddressIndexKey(addressType, hashBytes, pindex->nHeight, i, txhash, j, true), prevout.nValue * -1));\n+\n+                        // remove address from unspent index\n+                        addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(addressType, hashBytes, input.prevout.hash, input.prevout.n), CAddressUnspentValue()));\n+                    }\n+\n+                    if (fSpentIndex) {\n+                        // add the spent index to determine the txid and input that spent an output\n+                        // and to find the amount and address from an input\n+                        spentIndex.push_back(make_pair(CSpentIndexKey(input.prevout.hash, input.prevout.n), CSpentIndexValue(txhash, j, pindex->nHeight, prevout.nValue, addressType, hashBytes)));\n+                    }\n+                }\n+\n+            }\n         }\n \n         // GetTransactionSigOpCost counts 3 types of sigops:\n@@ -2470,6 +2653,35 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n             control.Add(vChecks);\n         }\n \n+        if (fAddressIndex) {\n+            for (unsigned int k = 0; k < tx.vout.size(); k++) {\n+                const CTxOut &out = tx.vout[k];\n+\n+                if (out.scriptPubKey.IsPayToScriptHash()) {\n+                    vector<unsigned char> hashBytes(out.scriptPubKey.begin()+2, out.scriptPubKey.begin()+22);\n+\n+                    // record receiving activity\n+                    addressIndex.push_back(make_pair(CAddressIndexKey(2, uint160(hashBytes), pindex->nHeight, i, txhash, k, false), out.nValue));\n+\n+                    // record unspent output\n+                    addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(2, uint160(hashBytes), txhash, k), CAddressUnspentValue(out.nValue, out.scriptPubKey, pindex->nHeight)));\n+\n+                } else if (out.scriptPubKey.IsPayToPublicKeyHash()) {\n+                    vector<unsigned char> hashBytes(out.scriptPubKey.begin()+3, out.scriptPubKey.begin()+23);\n+\n+                    // record receiving activity\n+                    addressIndex.push_back(make_pair(CAddressIndexKey(1, uint160(hashBytes), pindex->nHeight, i, txhash, k, false), out.nValue));\n+\n+                    // record unspent output\n+                    addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(1, uint160(hashBytes), txhash, k), CAddressUnspentValue(out.nValue, out.scriptPubKey, pindex->nHeight)));\n+\n+                } else {\n+                    continue;\n+                }\n+\n+            }\n+        }\n+\n         CTxUndo undoDummy;\n         if (i > 0) {\n             blockundo.vtxundo.push_back(CTxUndo());\n@@ -2520,6 +2732,41 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n         if (!pblocktree->WriteTxIndex(vPos))\n             return AbortNode(state, \"Failed to write transaction index\");\n \n+    if (fAddressIndex) {\n+        if (!pblocktree->WriteAddressIndex(addressIndex)) {\n+            return AbortNode(state, \"Failed to write address index\");\n+        }\n+\n+        if (!pblocktree->UpdateAddressUnspentIndex(addressUnspentIndex)) {\n+            return AbortNode(state, \"Failed to write address unspent index\");\n+        }\n+    }\n+\n+    if (fSpentIndex)\n+        if (!pblocktree->UpdateSpentIndex(spentIndex))\n+            return AbortNode(state, \"Failed to write transaction index\");\n+\n+    if (fTimestampIndex) {\n+        unsigned int logicalTS = pindex->nTime;\n+        unsigned int prevLogicalTS = 0;\n+\n+        // retrieve logical timestamp of the previous block\n+        if (pindex->pprev)\n+            if (!pblocktree->ReadTimestampBlockIndex(pindex->pprev->GetBlockHash(), prevLogicalTS))\n+                LogPrintf(\"%s: Failed to read previous block's logical timestamp\\n\", __func__);\n+\n+        if (logicalTS <= prevLogicalTS) {\n+            logicalTS = prevLogicalTS + 1;\n+            LogPrintf(\"%s: Previous logical timestamp is newer Actual[%d] prevLogical[%d] Logical[%d]\\n\", __func__, pindex->nTime, prevLogicalTS, logicalTS);\n+        }\n+\n+        if (!pblocktree->WriteTimestampIndex(CTimestampIndexKey(logicalTS, pindex->GetBlockHash())))\n+            return AbortNode(state, \"Failed to write timestamp index\");\n+\n+        if (!pblocktree->WriteTimestampBlockIndex(CTimestampBlockIndexKey(pindex->GetBlockHash()), CTimestampBlockIndexValue(logicalTS)))\n+            return AbortNode(state, \"Failed to write blockhash index\");\n+    }\n+\n     // add this block to the view's block chain\n     view.SetBestBlock(pindex->GetBlockHash());\n \n@@ -4055,6 +4302,18 @@ bool static LoadBlockIndexDB()\n     pblocktree->ReadFlag(\"txindex\", fTxIndex);\n     LogPrintf(\"%s: transaction index %s\\n\", __func__, fTxIndex ? \"enabled\" : \"disabled\");\n \n+    // Check whether we have an address index\n+    pblocktree->ReadFlag(\"addressindex\", fAddressIndex);\n+    LogPrintf(\"%s: address index %s\\n\", __func__, fAddressIndex ? \"enabled\" : \"disabled\");\n+\n+    // Check whether we have a timestamp index\n+    pblocktree->ReadFlag(\"timestampindex\", fTimestampIndex);\n+    LogPrintf(\"%s: timestamp index %s\\n\", __func__, fTimestampIndex ? \"enabled\" : \"disabled\");\n+\n+    // Check whether we have a spent index\n+    pblocktree->ReadFlag(\"spentindex\", fSpentIndex);\n+    LogPrintf(\"%s: spent index %s\\n\", __func__, fSpentIndex ? \"enabled\" : \"disabled\");\n+\n     // Load pointer to end of best chain\n     BlockMap::iterator it = mapBlockIndex.find(pcoinsTip->GetBestBlock());\n     if (it == mapBlockIndex.end())\n@@ -4314,6 +4573,18 @@ bool InitBlockIndex(const CChainParams& chainparams)\n     // Use the provided setting for -txindex in the new database\n     fTxIndex = GetBoolArg(\"-txindex\", DEFAULT_TXINDEX);\n     pblocktree->WriteFlag(\"txindex\", fTxIndex);\n+\n+    // Use the provided setting for -addressindex in the new database\n+    fAddressIndex = GetBoolArg(\"-addressindex\", DEFAULT_ADDRESSINDEX);\n+    pblocktree->WriteFlag(\"addressindex\", fAddressIndex);\n+\n+    // Use the provided setting for -timestampindex in the new database\n+    fTimestampIndex = GetBoolArg(\"-timestampindex\", DEFAULT_TIMESTAMPINDEX);\n+    pblocktree->WriteFlag(\"timestampindex\", fTimestampIndex);\n+\n+    fSpentIndex = GetBoolArg(\"-spentindex\", DEFAULT_SPENTINDEX);\n+    pblocktree->WriteFlag(\"spentindex\", fSpentIndex);\n+\n     LogPrintf(\"Initializing databases...\\n\");\n \n     // Only add the genesis block if not reindexing (in which case we reuse the one already on disk)"
      },
      {
        "sha": "558aee8b09ce50155af235f3220de39e4e2df79b",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 341,
        "deletions": 0,
        "changes": 341,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/017f548ea6d89423ef568117447e61dd5707ec42/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/017f548ea6d89423ef568117447e61dd5707ec42/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=017f548ea6d89423ef568117447e61dd5707ec42",
        "patch": "@@ -17,6 +17,7 @@\n #include \"script/script_error.h\"\n #include \"sync.h\"\n #include \"versionbits.h\"\n+#include \"spentindex.h\"\n \n #include <algorithm>\n #include <exception>\n@@ -126,6 +127,9 @@ static const int64_t DEFAULT_MAX_TIP_AGE = 24 * 60 * 60;\n static const bool DEFAULT_PERMIT_BAREMULTISIG = true;\n static const bool DEFAULT_CHECKPOINTS_ENABLED = true;\n static const bool DEFAULT_TXINDEX = false;\n+static const bool DEFAULT_ADDRESSINDEX = false;\n+static const bool DEFAULT_TIMESTAMPINDEX = false;\n+static const bool DEFAULT_SPENTINDEX = false;\n static const unsigned int DEFAULT_BANSCORE_THRESHOLD = 100;\n \n static const bool DEFAULT_TESTSAFEMODE = false;\n@@ -314,7 +318,337 @@ struct CNodeStateStats {\n     std::vector<int> vHeightInFlight;\n };\n \n+struct CTimestampIndexIteratorKey {\n+    unsigned int timestamp;\n \n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 4;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata32be(s, timestamp);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        timestamp = ser_readdata32be(s);\n+    }\n+\n+    CTimestampIndexIteratorKey(unsigned int time) {\n+        timestamp = time;\n+    }\n+\n+    CTimestampIndexIteratorKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        timestamp = 0;\n+    }\n+};\n+\n+struct CTimestampIndexKey {\n+    unsigned int timestamp;\n+    uint256 blockHash;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 36;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata32be(s, timestamp);\n+        blockHash.Serialize(s, nType, nVersion);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        timestamp = ser_readdata32be(s);\n+        blockHash.Unserialize(s, nType, nVersion);\n+    }\n+\n+    CTimestampIndexKey(unsigned int time, uint256 hash) {\n+        timestamp = time;\n+        blockHash = hash;\n+    }\n+\n+    CTimestampIndexKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        timestamp = 0;\n+        blockHash.SetNull();\n+    }\n+};\n+\n+struct CTimestampBlockIndexKey {\n+    uint256 blockHash;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 32;\n+    }\n+\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        blockHash.Serialize(s, nType, nVersion);\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        blockHash.Unserialize(s, nType, nVersion);\n+    }\n+\n+    CTimestampBlockIndexKey(uint256 hash) {\n+        blockHash = hash;\n+    }\n+\n+    CTimestampBlockIndexKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        blockHash.SetNull();\n+    }\n+};\n+\n+struct CTimestampBlockIndexValue {\n+    unsigned int ltimestamp;\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 4;\n+    }\n+\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata32be(s, ltimestamp);\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        ltimestamp = ser_readdata32be(s);\n+    }\n+\n+    CTimestampBlockIndexValue (unsigned int time) {\n+        ltimestamp = time;\n+    }\n+\n+    CTimestampBlockIndexValue() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        ltimestamp = 0;\n+    }\n+};\n+\n+struct CAddressUnspentKey {\n+    unsigned int type;\n+    uint160 hashBytes;\n+    uint256 txhash;\n+    size_t index;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 57;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata8(s, type);\n+        hashBytes.Serialize(s, nType, nVersion);\n+        txhash.Serialize(s, nType, nVersion);\n+        ser_writedata32(s, index);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        type = ser_readdata8(s);\n+        hashBytes.Unserialize(s, nType, nVersion);\n+        txhash.Unserialize(s, nType, nVersion);\n+        index = ser_readdata32(s);\n+    }\n+\n+    CAddressUnspentKey(unsigned int addressType, uint160 addressHash, uint256 txid, size_t indexValue) {\n+        type = addressType;\n+        hashBytes = addressHash;\n+        txhash = txid;\n+        index = indexValue;\n+    }\n+\n+    CAddressUnspentKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        type = 0;\n+        hashBytes.SetNull();\n+        txhash.SetNull();\n+        index = 0;\n+    }\n+};\n+\n+struct CAddressUnspentValue {\n+    CAmount satoshis;\n+    CScript script;\n+    int blockHeight;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(satoshis);\n+        READWRITE(*(CScriptBase*)(&script));\n+        READWRITE(blockHeight);\n+    }\n+\n+    CAddressUnspentValue(CAmount sats, CScript scriptPubKey, int height) {\n+        satoshis = sats;\n+        script = scriptPubKey;\n+        blockHeight = height;\n+    }\n+\n+    CAddressUnspentValue() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        satoshis = -1;\n+        script.clear();\n+        blockHeight = 0;\n+    }\n+\n+    bool IsNull() const {\n+        return (satoshis == -1);\n+    }\n+};\n+\n+struct CAddressIndexKey {\n+    unsigned int type;\n+    uint160 hashBytes;\n+    int blockHeight;\n+    unsigned int txindex;\n+    uint256 txhash;\n+    size_t index;\n+    bool spending;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 66;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata8(s, type);\n+        hashBytes.Serialize(s, nType, nVersion);\n+        // Heights are stored big-endian for key sorting in LevelDB\n+        ser_writedata32be(s, blockHeight);\n+        ser_writedata32be(s, txindex);\n+        txhash.Serialize(s, nType, nVersion);\n+        ser_writedata32(s, index);\n+        char f = spending;\n+        ser_writedata8(s, f);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        type = ser_readdata8(s);\n+        hashBytes.Unserialize(s, nType, nVersion);\n+        blockHeight = ser_readdata32be(s);\n+        txindex = ser_readdata32be(s);\n+        txhash.Unserialize(s, nType, nVersion);\n+        index = ser_readdata32(s);\n+        char f = ser_readdata8(s);\n+        spending = f;\n+    }\n+\n+    CAddressIndexKey(unsigned int addressType, uint160 addressHash, int height, int blockindex,\n+                     uint256 txid, size_t indexValue, bool isSpending) {\n+        type = addressType;\n+        hashBytes = addressHash;\n+        blockHeight = height;\n+        txindex = blockindex;\n+        txhash = txid;\n+        index = indexValue;\n+        spending = isSpending;\n+    }\n+\n+    CAddressIndexKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        type = 0;\n+        hashBytes.SetNull();\n+        blockHeight = 0;\n+        txindex = 0;\n+        txhash.SetNull();\n+        index = 0;\n+        spending = false;\n+    }\n+\n+};\n+\n+struct CAddressIndexIteratorKey {\n+    unsigned int type;\n+    uint160 hashBytes;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 21;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata8(s, type);\n+        hashBytes.Serialize(s, nType, nVersion);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        type = ser_readdata8(s);\n+        hashBytes.Unserialize(s, nType, nVersion);\n+    }\n+\n+    CAddressIndexIteratorKey(unsigned int addressType, uint160 addressHash) {\n+        type = addressType;\n+        hashBytes = addressHash;\n+    }\n+\n+    CAddressIndexIteratorKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        type = 0;\n+        hashBytes.SetNull();\n+    }\n+};\n+\n+struct CAddressIndexIteratorHeightKey {\n+    unsigned int type;\n+    uint160 hashBytes;\n+    int blockHeight;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 25;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata8(s, type);\n+        hashBytes.Serialize(s, nType, nVersion);\n+        ser_writedata32be(s, blockHeight);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        type = ser_readdata8(s);\n+        hashBytes.Unserialize(s, nType, nVersion);\n+        blockHeight = ser_readdata32be(s);\n+    }\n+\n+    CAddressIndexIteratorHeightKey(unsigned int addressType, uint160 addressHash, int height) {\n+        type = addressType;\n+        hashBytes = addressHash;\n+        blockHeight = height;\n+    }\n+\n+    CAddressIndexIteratorHeightKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        type = 0;\n+        hashBytes.SetNull();\n+        blockHeight = 0;\n+    }\n+};\n \n /** \n  * Count ECDSA signature operations the old-fashioned (pre-0.6) way\n@@ -430,6 +764,13 @@ class CScriptCheck\n     ScriptError GetScriptError() const { return error; }\n };\n \n+bool GetTimestampIndex(const unsigned int &high, const unsigned int &low, const bool fActiveOnly, std::vector<std::pair<uint256, unsigned int> > &hashes);\n+bool GetSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value);\n+bool GetAddressIndex(uint160 addressHash, int type,\n+                     std::vector<std::pair<CAddressIndexKey, CAmount> > &addressIndex,\n+                     int start = 0, int end = 0);\n+bool GetAddressUnspent(uint160 addressHash, int type,\n+                       std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > &unspentOutputs);\n \n /** Functions for disk access for blocks */\n bool WriteBlockToDisk(const CBlock& block, CDiskBlockPos& pos, const CMessageHeader::MessageStartChars& messageStart);"
      },
      {
        "sha": "eb1174e2e2f2a8afe1a625271bb1f3790ae3779e",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/017f548ea6d89423ef568117447e61dd5707ec42/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/017f548ea6d89423ef568117447e61dd5707ec42/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=017f548ea6d89423ef568117447e61dd5707ec42",
        "patch": "@@ -201,6 +201,17 @@ unsigned int CScript::GetSigOpCount(const CScript& scriptSig) const\n     return subscript.GetSigOpCount(true);\n }\n \n+bool CScript::IsPayToPublicKeyHash() const\n+{\n+    // Extra-fast test for pay-to-pubkey-hash CScripts:\n+    return (this->size() == 25 &&\n+\t    (*this)[0] == OP_DUP &&\n+\t    (*this)[1] == OP_HASH160 &&\n+\t    (*this)[2] == 0x14 &&\n+\t    (*this)[23] == OP_EQUALVERIFY &&\n+\t    (*this)[24] == OP_CHECKSIG);\n+}\n+\n bool CScript::IsPayToScriptHash() const\n {\n     // Extra-fast test for pay-to-script-hash CScripts:"
      },
      {
        "sha": "e6303e7058433953976f10086ebf9722832079c2",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/017f548ea6d89423ef568117447e61dd5707ec42/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/017f548ea6d89423ef568117447e61dd5707ec42/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=017f548ea6d89423ef568117447e61dd5707ec42",
        "patch": "@@ -620,6 +620,8 @@ class CScript : public CScriptBase\n      */\n     unsigned int GetSigOpCount(const CScript& scriptSig) const;\n \n+    bool IsPayToPublicKeyHash() const;\n+\n     bool IsPayToScriptHash() const;\n     bool IsPayToWitnessScriptHash() const;\n     bool IsWitnessProgram(int& version, std::vector<unsigned char>& program) const;"
      },
      {
        "sha": "3fa23e27d025141cba74837d46c02d8bba0fa3c1",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/017f548ea6d89423ef568117447e61dd5707ec42/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/017f548ea6d89423ef568117447e61dd5707ec42/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=017f548ea6d89423ef568117447e61dd5707ec42",
        "patch": "@@ -91,6 +91,11 @@ template<typename Stream> inline void ser_writedata32(Stream &s, uint32_t obj)\n     obj = htole32(obj);\n     s.write((char*)&obj, 4);\n }\n+template<typename Stream> inline void ser_writedata32be(Stream &s, uint32_t obj)\n+{\n+    obj = htobe32(obj);\n+    s.write((char*)&obj, 4);\n+}\n template<typename Stream> inline void ser_writedata64(Stream &s, uint64_t obj)\n {\n     obj = htole64(obj);\n@@ -114,6 +119,12 @@ template<typename Stream> inline uint32_t ser_readdata32(Stream &s)\n     s.read((char*)&obj, 4);\n     return le32toh(obj);\n }\n+template<typename Stream> inline uint32_t ser_readdata32be(Stream &s)\n+{\n+    uint32_t obj;\n+    s.read((char*)&obj, 4);\n+    return be32toh(obj);\n+}\n template<typename Stream> inline uint64_t ser_readdata64(Stream &s)\n {\n     uint64_t obj;"
      },
      {
        "sha": "bd5da45d60dbc0d7377779329c90e597e0f1841e",
        "filename": "src/spentindex.h",
        "status": "added",
        "additions": 98,
        "deletions": 0,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/017f548ea6d89423ef568117447e61dd5707ec42/src/spentindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/017f548ea6d89423ef568117447e61dd5707ec42/src/spentindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/spentindex.h?ref=017f548ea6d89423ef568117447e61dd5707ec42",
        "patch": "@@ -0,0 +1,98 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SPENTINDEX_H\n+#define BITCOIN_SPENTINDEX_H\n+\n+#include \"uint256.h\"\n+#include \"amount.h\"\n+\n+struct CSpentIndexKey {\n+    uint256 txid;\n+    unsigned int outputIndex;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(txid);\n+        READWRITE(outputIndex);\n+    }\n+\n+    CSpentIndexKey(uint256 t, unsigned int i) {\n+        txid = t;\n+        outputIndex = i;\n+    }\n+\n+    CSpentIndexKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        txid.SetNull();\n+        outputIndex = 0;\n+    }\n+\n+};\n+\n+struct CSpentIndexValue {\n+    uint256 txid;\n+    unsigned int inputIndex;\n+    int blockHeight;\n+    CAmount satoshis;\n+    int addressType;\n+    uint160 addressHash;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(txid);\n+        READWRITE(inputIndex);\n+        READWRITE(blockHeight);\n+        READWRITE(satoshis);\n+        READWRITE(addressType);\n+        READWRITE(addressHash);\n+    }\n+\n+    CSpentIndexValue(uint256 t, unsigned int i, int h, CAmount s, int type, uint160 a) {\n+        txid = t;\n+        inputIndex = i;\n+        blockHeight = h;\n+        satoshis = s;\n+        addressType = type;\n+        addressHash = a;\n+    }\n+\n+    CSpentIndexValue() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        txid.SetNull();\n+        inputIndex = 0;\n+        blockHeight = 0;\n+        satoshis = 0;\n+        addressType = 0;\n+        addressHash.SetNull();\n+    }\n+\n+    bool IsNull() const {\n+        return txid.IsNull();\n+    }\n+};\n+\n+struct CSpentIndexKeyCompare\n+{\n+    bool operator()(const CSpentIndexKey& a, const CSpentIndexKey& b) const {\n+        if (a.txid == b.txid) {\n+            return a.outputIndex < b.outputIndex;\n+        } else {\n+            return a.txid < b.txid;\n+        }\n+    }\n+};\n+\n+#endif // BITCOIN_SPENTINDEX_H"
      },
      {
        "sha": "2dced3b24e523a139c304823dd600ba35c4084b1",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 166,
        "deletions": 0,
        "changes": 166,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/017f548ea6d89423ef568117447e61dd5707ec42/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/017f548ea6d89423ef568117447e61dd5707ec42/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=017f548ea6d89423ef568117447e61dd5707ec42",
        "patch": "@@ -19,6 +19,11 @@ using namespace std;\n static const char DB_COINS = 'c';\n static const char DB_BLOCK_FILES = 'f';\n static const char DB_TXINDEX = 't';\n+static const char DB_ADDRESSINDEX = 'a';\n+static const char DB_ADDRESSUNSPENTINDEX = 'u';\n+static const char DB_TIMESTAMPINDEX = 's';\n+static const char DB_BLOCKHASHINDEX = 'z';\n+static const char DB_SPENTINDEX = 'p';\n static const char DB_BLOCK_INDEX = 'b';\n \n static const char DB_BEST_BLOCK = 'B';\n@@ -159,6 +164,157 @@ bool CBlockTreeDB::WriteTxIndex(const std::vector<std::pair<uint256, CDiskTxPos>\n     return WriteBatch(batch);\n }\n \n+bool CBlockTreeDB::ReadSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value) {\n+    return Read(make_pair(DB_SPENTINDEX, key), value);\n+}\n+\n+bool CBlockTreeDB::UpdateSpentIndex(const std::vector<std::pair<CSpentIndexKey, CSpentIndexValue> >&vect) {\n+    CDBBatch batch(&GetObfuscateKey());\n+    for (std::vector<std::pair<CSpentIndexKey,CSpentIndexValue> >::const_iterator it=vect.begin(); it!=vect.end(); it++) {\n+        if (it->second.IsNull()) {\n+            batch.Erase(make_pair(DB_SPENTINDEX, it->first));\n+        } else {\n+            batch.Write(make_pair(DB_SPENTINDEX, it->first), it->second);\n+        }\n+    }\n+    return WriteBatch(batch);\n+}\n+\n+bool CBlockTreeDB::UpdateAddressUnspentIndex(const std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue > >&vect) {\n+    CDBBatch batch(&GetObfuscateKey());\n+    for (std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> >::const_iterator it=vect.begin(); it!=vect.end(); it++) {\n+        if (it->second.IsNull()) {\n+            batch.Erase(make_pair(DB_ADDRESSUNSPENTINDEX, it->first));\n+        } else {\n+            batch.Write(make_pair(DB_ADDRESSUNSPENTINDEX, it->first), it->second);\n+        }\n+    }\n+    return WriteBatch(batch);\n+}\n+\n+bool CBlockTreeDB::ReadAddressUnspentIndex(uint160 addressHash, int type,\n+                                           std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > &unspentOutputs) {\n+\n+    boost::scoped_ptr<CDBIterator> pcursor(NewIterator());\n+\n+    pcursor->Seek(make_pair(DB_ADDRESSUNSPENTINDEX, CAddressIndexIteratorKey(type, addressHash)));\n+\n+    while (pcursor->Valid()) {\n+        boost::this_thread::interruption_point();\n+        std::pair<char,CAddressUnspentKey> key;\n+        if (pcursor->GetKey(key) && key.first == DB_ADDRESSUNSPENTINDEX && key.second.hashBytes == addressHash) {\n+            CAddressUnspentValue nValue;\n+            if (pcursor->GetValue(nValue)) {\n+                unspentOutputs.push_back(make_pair(key.second, nValue));\n+                pcursor->Next();\n+            } else {\n+                return error(\"failed to get address unspent value\");\n+            }\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+bool CBlockTreeDB::WriteAddressIndex(const std::vector<std::pair<CAddressIndexKey, CAmount > >&vect) {\n+    CDBBatch batch(&GetObfuscateKey());\n+    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=vect.begin(); it!=vect.end(); it++)\n+        batch.Write(make_pair(DB_ADDRESSINDEX, it->first), it->second);\n+    return WriteBatch(batch);\n+}\n+\n+bool CBlockTreeDB::EraseAddressIndex(const std::vector<std::pair<CAddressIndexKey, CAmount > >&vect) {\n+    CDBBatch batch(&GetObfuscateKey());\n+    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=vect.begin(); it!=vect.end(); it++)\n+        batch.Erase(make_pair(DB_ADDRESSINDEX, it->first));\n+    return WriteBatch(batch);\n+}\n+\n+bool CBlockTreeDB::ReadAddressIndex(uint160 addressHash, int type,\n+                                    std::vector<std::pair<CAddressIndexKey, CAmount> > &addressIndex,\n+                                    int start, int end) {\n+\n+    boost::scoped_ptr<CDBIterator> pcursor(NewIterator());\n+\n+    if (start > 0 && end > 0) {\n+        pcursor->Seek(make_pair(DB_ADDRESSINDEX, CAddressIndexIteratorHeightKey(type, addressHash, start)));\n+    } else {\n+        pcursor->Seek(make_pair(DB_ADDRESSINDEX, CAddressIndexIteratorKey(type, addressHash)));\n+    }\n+\n+    while (pcursor->Valid()) {\n+        boost::this_thread::interruption_point();\n+        std::pair<char,CAddressIndexKey> key;\n+        if (pcursor->GetKey(key) && key.first == DB_ADDRESSINDEX && key.second.hashBytes == addressHash) {\n+            if (end > 0 && key.second.blockHeight > end) {\n+                break;\n+            }\n+            CAmount nValue;\n+            if (pcursor->GetValue(nValue)) {\n+                addressIndex.push_back(make_pair(key.second, nValue));\n+                pcursor->Next();\n+            } else {\n+                return error(\"failed to get address index value\");\n+            }\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+bool CBlockTreeDB::WriteTimestampIndex(const CTimestampIndexKey &timestampIndex) {\n+    CDBBatch batch(&GetObfuscateKey());\n+    batch.Write(make_pair(DB_TIMESTAMPINDEX, timestampIndex), 0);\n+    return WriteBatch(batch);\n+}\n+\n+bool CBlockTreeDB::ReadTimestampIndex(const unsigned int &high, const unsigned int &low, const bool fActiveOnly, std::vector<std::pair<uint256, unsigned int> > &hashes) {\n+\n+    boost::scoped_ptr<CDBIterator> pcursor(NewIterator());\n+\n+    pcursor->Seek(make_pair(DB_TIMESTAMPINDEX, CTimestampIndexIteratorKey(low)));\n+\n+    while (pcursor->Valid()) {\n+        boost::this_thread::interruption_point();\n+        std::pair<char, CTimestampIndexKey> key;\n+        if (pcursor->GetKey(key) && key.first == DB_TIMESTAMPINDEX && key.second.timestamp < high) {\n+            if (fActiveOnly) {\n+                if (blockOnchainActive(key.second.blockHash)) {\n+                    hashes.push_back(std::make_pair(key.second.blockHash, key.second.timestamp));\n+                }\n+            } else {\n+                hashes.push_back(std::make_pair(key.second.blockHash, key.second.timestamp));\n+            }\n+\n+            pcursor->Next();\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+bool CBlockTreeDB::WriteTimestampBlockIndex(const CTimestampBlockIndexKey &blockhashIndex, const CTimestampBlockIndexValue &logicalts) {\n+    CDBBatch batch(&GetObfuscateKey());\n+    batch.Write(make_pair(DB_BLOCKHASHINDEX, blockhashIndex), logicalts);\n+    return WriteBatch(batch);\n+}\n+\n+bool CBlockTreeDB::ReadTimestampBlockIndex(const uint256 &hash, unsigned int &ltimestamp) {\n+\n+    CTimestampBlockIndexValue(lts);\n+    if (!Read(std::make_pair(DB_BLOCKHASHINDEX, hash), lts))\n+\treturn false;\n+\n+    ltimestamp = lts.ltimestamp;\n+    return true;\n+}\n+\n bool CBlockTreeDB::WriteFlag(const std::string &name, bool fValue) {\n     return Write(std::make_pair(DB_FLAG, name), fValue ? '1' : '0');\n }\n@@ -171,6 +327,16 @@ bool CBlockTreeDB::ReadFlag(const std::string &name, bool &fValue) {\n     return true;\n }\n \n+bool CBlockTreeDB::blockOnchainActive(const uint256 &hash) {\n+    CBlockIndex* pblockindex = mapBlockIndex[hash];\n+    \n+    if (!chainActive.Contains(pblockindex)) {\n+        return false;\n+    }\n+    \n+    return true;\n+}\n+\n bool CBlockTreeDB::LoadBlockIndexGuts(boost::function<CBlockIndex*(const uint256&)> insertBlockIndex)\n {\n     boost::scoped_ptr<CDBIterator> pcursor(NewIterator());"
      },
      {
        "sha": "706312a6ce8976c782357c42e35245dec85a1bfa",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/017f548ea6d89423ef568117447e61dd5707ec42/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/017f548ea6d89423ef568117447e61dd5707ec42/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=017f548ea6d89423ef568117447e61dd5707ec42",
        "patch": "@@ -19,6 +19,17 @@\n \n class CBlockIndex;\n class CCoinsViewDBCursor;\n+struct CAddressUnspentKey;\n+struct CAddressUnspentValue;\n+struct CAddressIndexKey;\n+struct CAddressIndexIteratorKey;\n+struct CAddressIndexIteratorHeightKey;\n+struct CTimestampIndexKey;\n+struct CTimestampIndexIteratorKey;\n+struct CTimestampBlockIndexKey;\n+struct CTimestampBlockIndexValue;\n+struct CSpentIndexKey;\n+struct CSpentIndexValue;\n class uint256;\n \n //! -dbcache default (MiB)\n@@ -114,9 +125,24 @@ class CBlockTreeDB : public CDBWrapper\n     bool ReadReindexing(bool &fReindex);\n     bool ReadTxIndex(const uint256 &txid, CDiskTxPos &pos);\n     bool WriteTxIndex(const std::vector<std::pair<uint256, CDiskTxPos> > &list);\n+    bool ReadSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value);\n+    bool UpdateSpentIndex(const std::vector<std::pair<CSpentIndexKey, CSpentIndexValue> >&vect);\n+    bool UpdateAddressUnspentIndex(const std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue > >&vect);\n+    bool ReadAddressUnspentIndex(uint160 addressHash, int type,\n+                                 std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > &vect);\n+    bool WriteAddressIndex(const std::vector<std::pair<CAddressIndexKey, CAmount> > &vect);\n+    bool EraseAddressIndex(const std::vector<std::pair<CAddressIndexKey, CAmount> > &vect);\n+    bool ReadAddressIndex(uint160 addressHash, int type,\n+                          std::vector<std::pair<CAddressIndexKey, CAmount> > &addressIndex,\n+                          int start = 0, int end = 0);\n+    bool WriteTimestampIndex(const CTimestampIndexKey &timestampIndex);\n+    bool ReadTimestampIndex(const unsigned int &high, const unsigned int &low, const bool fActiveOnly, std::vector<std::pair<uint256, unsigned int> > &vect);\n+    bool WriteTimestampBlockIndex(const CTimestampBlockIndexKey &blockhashIndex, const CTimestampBlockIndexValue &logicalts);\n+    bool ReadTimestampBlockIndex(const uint256 &hash, unsigned int &logicalTS);\n     bool WriteFlag(const std::string &name, bool fValue);\n     bool ReadFlag(const std::string &name, bool &fValue);\n     bool LoadBlockIndexGuts(boost::function<CBlockIndex*(const uint256&)> insertBlockIndex);\n+    bool blockOnchainActive(const uint256 &hash);\n };\n \n #endif // BITCOIN_TXDB_H"
      },
      {
        "sha": "16cdbacf856374f983105e8be3008b5eeb6629c5",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 141,
        "deletions": 0,
        "changes": 141,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/017f548ea6d89423ef568117447e61dd5707ec42/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/017f548ea6d89423ef568117447e61dd5707ec42/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=017f548ea6d89423ef568117447e61dd5707ec42",
        "patch": "@@ -450,6 +450,145 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,\n     return true;\n }\n \n+void CTxMemPool::addAddressIndex(const CTxMemPoolEntry &entry, const CCoinsViewCache &view)\n+{\n+    LOCK(cs);\n+    const CTransaction& tx = entry.GetTx();\n+    std::vector<CMempoolAddressDeltaKey> inserted;\n+\n+    uint256 txhash = tx.GetHash();\n+    for (unsigned int j = 0; j < tx.vin.size(); j++) {\n+        const CTxIn input = tx.vin[j];\n+        const CTxOut &prevout = view.GetOutputFor(input);\n+        if (prevout.scriptPubKey.IsPayToScriptHash()) {\n+            vector<unsigned char> hashBytes(prevout.scriptPubKey.begin()+2, prevout.scriptPubKey.begin()+22);\n+            CMempoolAddressDeltaKey key(2, uint160(hashBytes), txhash, j, 1);\n+            CMempoolAddressDelta delta(entry.GetTime(), prevout.nValue * -1, input.prevout.hash, input.prevout.n);\n+            mapAddress.insert(make_pair(key, delta));\n+            inserted.push_back(key);\n+        } else if (prevout.scriptPubKey.IsPayToPublicKeyHash()) {\n+            vector<unsigned char> hashBytes(prevout.scriptPubKey.begin()+3, prevout.scriptPubKey.begin()+23);\n+            CMempoolAddressDeltaKey key(1, uint160(hashBytes), txhash, j, 1);\n+            CMempoolAddressDelta delta(entry.GetTime(), prevout.nValue * -1, input.prevout.hash, input.prevout.n);\n+            mapAddress.insert(make_pair(key, delta));\n+            inserted.push_back(key);\n+        }\n+    }\n+\n+    for (unsigned int k = 0; k < tx.vout.size(); k++) {\n+        const CTxOut &out = tx.vout[k];\n+        if (out.scriptPubKey.IsPayToScriptHash()) {\n+            vector<unsigned char> hashBytes(out.scriptPubKey.begin()+2, out.scriptPubKey.begin()+22);\n+            CMempoolAddressDeltaKey key(2, uint160(hashBytes), txhash, k, 0);\n+            mapAddress.insert(make_pair(key, CMempoolAddressDelta(entry.GetTime(), out.nValue)));\n+            inserted.push_back(key);\n+        } else if (out.scriptPubKey.IsPayToPublicKeyHash()) {\n+            vector<unsigned char> hashBytes(out.scriptPubKey.begin()+3, out.scriptPubKey.begin()+23);\n+            std::pair<addressDeltaMap::iterator,bool> ret;\n+            CMempoolAddressDeltaKey key(1, uint160(hashBytes), txhash, k, 0);\n+            mapAddress.insert(make_pair(key, CMempoolAddressDelta(entry.GetTime(), out.nValue)));\n+            inserted.push_back(key);\n+        }\n+    }\n+\n+    mapAddressInserted.insert(make_pair(txhash, inserted));\n+}\n+\n+bool CTxMemPool::getAddressIndex(std::vector<std::pair<uint160, int> > &addresses,\n+                                 std::vector<std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> > &results)\n+{\n+    LOCK(cs);\n+    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n+        addressDeltaMap::iterator ait = mapAddress.lower_bound(CMempoolAddressDeltaKey((*it).second, (*it).first));\n+        while (ait != mapAddress.end() && (*ait).first.addressBytes == (*it).first && (*ait).first.type == (*it).second) {\n+            results.push_back(*ait);\n+            ait++;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool CTxMemPool::removeAddressIndex(const uint256 txhash)\n+{\n+    LOCK(cs);\n+    addressDeltaMapInserted::iterator it = mapAddressInserted.find(txhash);\n+\n+    if (it != mapAddressInserted.end()) {\n+        std::vector<CMempoolAddressDeltaKey> keys = (*it).second;\n+        for (std::vector<CMempoolAddressDeltaKey>::iterator mit = keys.begin(); mit != keys.end(); mit++) {\n+            mapAddress.erase(*mit);\n+        }\n+        mapAddressInserted.erase(it);\n+    }\n+\n+    return true;\n+}\n+\n+void CTxMemPool::addSpentIndex(const CTxMemPoolEntry &entry, const CCoinsViewCache &view)\n+{\n+    LOCK(cs);\n+\n+    const CTransaction& tx = entry.GetTx();\n+    std::vector<CSpentIndexKey> inserted;\n+\n+    uint256 txhash = tx.GetHash();\n+    for (unsigned int j = 0; j < tx.vin.size(); j++) {\n+        const CTxIn input = tx.vin[j];\n+        const CTxOut &prevout = view.GetOutputFor(input);\n+        uint160 addressHash;\n+        int addressType;\n+\n+        if (prevout.scriptPubKey.IsPayToScriptHash()) {\n+            addressHash = uint160(vector<unsigned char> (prevout.scriptPubKey.begin()+2, prevout.scriptPubKey.begin()+22));\n+            addressType = 2;\n+        } else if (prevout.scriptPubKey.IsPayToPublicKeyHash()) {\n+            addressHash = uint160(vector<unsigned char> (prevout.scriptPubKey.begin()+3, prevout.scriptPubKey.begin()+23));\n+            addressType = 1;\n+        } else {\n+            addressHash.SetNull();\n+            addressType = 0;\n+        }\n+\n+        CSpentIndexKey key = CSpentIndexKey(input.prevout.hash, input.prevout.n);\n+        CSpentIndexValue value = CSpentIndexValue(txhash, j, -1, prevout.nValue, addressType, addressHash);\n+\n+        mapSpent.insert(make_pair(key, value));\n+        inserted.push_back(key);\n+\n+    }\n+\n+    mapSpentInserted.insert(make_pair(txhash, inserted));\n+}\n+\n+bool CTxMemPool::getSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value)\n+{\n+    LOCK(cs);\n+    mapSpentIndex::iterator it;\n+\n+    it = mapSpent.find(key);\n+    if (it != mapSpent.end()) {\n+        value = it->second;\n+        return true;\n+    }\n+    return false;\n+}\n+\n+bool CTxMemPool::removeSpentIndex(const uint256 txhash)\n+{\n+    LOCK(cs);\n+    mapSpentIndexInserted::iterator it = mapSpentInserted.find(txhash);\n+\n+    if (it != mapSpentInserted.end()) {\n+        std::vector<CSpentIndexKey> keys = (*it).second;\n+        for (std::vector<CSpentIndexKey>::iterator mit = keys.begin(); mit != keys.end(); mit++) {\n+            mapSpent.erase(*mit);\n+        }\n+        mapSpentInserted.erase(it);\n+    }\n+\n+    return true;\n+}\n+\n void CTxMemPool::removeUnchecked(txiter it)\n {\n     const uint256 hash = it->GetTx().GetHash();\n@@ -472,6 +611,8 @@ void CTxMemPool::removeUnchecked(txiter it)\n     mapTx.erase(it);\n     nTransactionsUpdated++;\n     minerPolicyEstimator->removeTx(hash);\n+    removeAddressIndex(hash);\n+    removeSpentIndex(hash);\n }\n \n // Calculates descendants of entry that are not already in setDescendants, and adds to"
      },
      {
        "sha": "c5a8f5135a434d37bcfb9ad4df8534e6b19c437b",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/017f548ea6d89423ef568117447e61dd5707ec42/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/017f548ea6d89423ef568117447e61dd5707ec42/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=017f548ea6d89423ef568117447e61dd5707ec42",
        "patch": "@@ -10,6 +10,8 @@\n #include <memory>\n #include <set>\n \n+#include \"addressindex.h\"\n+#include \"spentindex.h\"\n #include \"amount.h\"\n #include \"coins.h\"\n #include \"indirectmap.h\"\n@@ -484,6 +486,18 @@ class CTxMemPool\n     typedef std::map<txiter, TxLinks, CompareIteratorByHash> txlinksMap;\n     txlinksMap mapLinks;\n \n+    typedef std::map<CMempoolAddressDeltaKey, CMempoolAddressDelta, CMempoolAddressDeltaKeyCompare> addressDeltaMap;\n+    addressDeltaMap mapAddress;\n+\n+    typedef std::map<uint256, std::vector<CMempoolAddressDeltaKey> > addressDeltaMapInserted;\n+    addressDeltaMapInserted mapAddressInserted;\n+\n+    typedef std::map<CSpentIndexKey, CSpentIndexValue, CSpentIndexKeyCompare> mapSpentIndex;\n+    mapSpentIndex mapSpent;\n+\n+    typedef std::map<uint256, std::vector<CSpentIndexKey> > mapSpentIndexInserted;\n+    mapSpentIndexInserted mapSpentInserted;\n+\n     void UpdateParent(txiter entry, txiter parent, bool add);\n     void UpdateChild(txiter entry, txiter child, bool add);\n \n@@ -517,6 +531,15 @@ class CTxMemPool\n     bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, bool fCurrentEstimate = true);\n     bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, setEntries &setAncestors, bool fCurrentEstimate = true);\n \n+    void addAddressIndex(const CTxMemPoolEntry &entry, const CCoinsViewCache &view);\n+    bool getAddressIndex(std::vector<std::pair<uint160, int> > &addresses,\n+                         std::vector<std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> > &results);\n+    bool removeAddressIndex(const uint256 txhash);\n+\n+    void addSpentIndex(const CTxMemPoolEntry &entry, const CCoinsViewCache &view);\n+    bool getSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value);\n+    bool removeSpentIndex(const uint256 txhash);\n+\n     void removeRecursive(const CTransaction &tx, std::list<CTransaction>& removed);\n     void removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight, int flags);\n     void removeConflicts(const CTransaction &tx, std::list<CTransaction>& removed);"
      }
    ]
  },
  {
    "sha": "877c241faf8022d98aeda4a31f33158d8ea5855a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NzdjMjQxZmFmODAyMmQ5OGFlZGE0YTMxZjMzMTU4ZDhlYTU4NTVh",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-04T19:00:31Z"
      },
      "committer": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-05T16:46:35Z"
      },
      "message": "rpc: adds rpc commands for address, spent and timestamp indexes\n\nAdds new rpc commands that use the address, spent and timestamp indexes,\nincluding the new commands:\n\n- getblockdeltas\n- getblockhashes\n- getaddressmempool\n- getaddressutxos\n- getaddressdeltas\n- getaddressbalance\n- getaddresstxids\n- getspentinfo\n\nAnd modifications to the command:\n- getrawtransaction\n\nConflicts:\n\tsrc/rpc/blockchain.cpp\n\tsrc/rpc/client.cpp\n\tsrc/rpc/misc.cpp\n\tsrc/rpc/rawtransaction.cpp\n\tsrc/rpc/server.cpp\n\tsrc/rpcserver.h",
      "tree": {
        "sha": "0099079ac2033b1163c5380308112e6455a4ea29",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0099079ac2033b1163c5380308112e6455a4ea29"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/877c241faf8022d98aeda4a31f33158d8ea5855a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/877c241faf8022d98aeda4a31f33158d8ea5855a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/877c241faf8022d98aeda4a31f33158d8ea5855a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/877c241faf8022d98aeda4a31f33158d8ea5855a/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "017f548ea6d89423ef568117447e61dd5707ec42",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/017f548ea6d89423ef568117447e61dd5707ec42",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/017f548ea6d89423ef568117447e61dd5707ec42"
      }
    ],
    "stats": {
      "total": 886,
      "additions": 879,
      "deletions": 7
    },
    "files": [
      {
        "sha": "2bfc77a73db72e75c0c48d6f9b5ad515d01a30c5",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 210,
        "deletions": 0,
        "changes": 210,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/877c241faf8022d98aeda4a31f33158d8ea5855a/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/877c241faf8022d98aeda4a31f33158d8ea5855a/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=877c241faf8022d98aeda4a31f33158d8ea5855a",
        "patch": "@@ -4,6 +4,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"amount.h\"\n+#include \"base58.h\"\n #include \"chain.h\"\n #include \"chainparams.h\"\n #include \"checkpoints.h\"\n@@ -13,6 +14,10 @@\n #include \"policy/policy.h\"\n #include \"primitives/transaction.h\"\n #include \"rpc/server.h\"\n+#include \"script/script.h\"\n+#include \"script/script_error.h\"\n+#include \"script/sign.h\"\n+#include \"script/standard.h\"\n #include \"streams.h\"\n #include \"sync.h\"\n #include \"txmempool.h\"\n@@ -90,6 +95,112 @@ UniValue blockheaderToJSON(const CBlockIndex* blockindex)\n     return result;\n }\n \n+UniValue blockToDeltasJSON(const CBlock& block, const CBlockIndex* blockindex)\n+{\n+    UniValue result(UniValue::VOBJ);\n+    result.push_back(Pair(\"hash\", block.GetHash().GetHex()));\n+    int confirmations = -1;\n+    // Only report confirmations if the block is on the main chain\n+    if (chainActive.Contains(blockindex)) {\n+        confirmations = chainActive.Height() - blockindex->nHeight + 1;\n+    } else {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block is an orphan\");\n+    }\n+    result.push_back(Pair(\"confirmations\", confirmations));\n+    result.push_back(Pair(\"size\", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION)));\n+    result.push_back(Pair(\"height\", blockindex->nHeight));\n+    result.push_back(Pair(\"version\", block.nVersion));\n+    result.push_back(Pair(\"merkleroot\", block.hashMerkleRoot.GetHex()));\n+\n+    UniValue deltas(UniValue::VARR);\n+\n+    for (unsigned int i = 0; i < block.vtx.size(); i++) {\n+        const CTransaction &tx = block.vtx[i];\n+        const uint256 txhash = tx.GetHash();\n+\n+        UniValue entry(UniValue::VOBJ);\n+        entry.push_back(Pair(\"txid\", txhash.GetHex()));\n+        entry.push_back(Pair(\"index\", (int)i));\n+\n+        UniValue inputs(UniValue::VARR);\n+\n+        if (!tx.IsCoinBase()) {\n+\n+            for (size_t j = 0; j < tx.vin.size(); j++) {\n+                const CTxIn input = tx.vin[j];\n+\n+                UniValue delta(UniValue::VOBJ);\n+\n+                CSpentIndexValue spentInfo;\n+                CSpentIndexKey spentKey(input.prevout.hash, input.prevout.n);\n+\n+                if (GetSpentIndex(spentKey, spentInfo)) {\n+                    if (spentInfo.addressType == 1) {\n+                        delta.push_back(Pair(\"address\", CBitcoinAddress(CKeyID(spentInfo.addressHash)).ToString()));\n+                    } else if (spentInfo.addressType == 2)  {\n+                        delta.push_back(Pair(\"address\", CBitcoinAddress(CScriptID(spentInfo.addressHash)).ToString()));\n+                    } else {\n+                        continue;\n+                    }\n+                    delta.push_back(Pair(\"satoshis\", -1 * spentInfo.satoshis));\n+                    delta.push_back(Pair(\"index\", (int)j));\n+                    delta.push_back(Pair(\"prevtxid\", input.prevout.hash.GetHex()));\n+                    delta.push_back(Pair(\"prevout\", (int)input.prevout.n));\n+\n+                    inputs.push_back(delta);\n+                } else {\n+                    throw JSONRPCError(RPC_INTERNAL_ERROR, \"Spent information not available\");\n+                }\n+\n+            }\n+        }\n+\n+        entry.push_back(Pair(\"inputs\", inputs));\n+\n+        UniValue outputs(UniValue::VARR);\n+\n+        for (unsigned int k = 0; k < tx.vout.size(); k++) {\n+            const CTxOut &out = tx.vout[k];\n+\n+            UniValue delta(UniValue::VOBJ);\n+\n+            if (out.scriptPubKey.IsPayToScriptHash()) {\n+                vector<unsigned char> hashBytes(out.scriptPubKey.begin()+2, out.scriptPubKey.begin()+22);\n+                delta.push_back(Pair(\"address\", CBitcoinAddress(CScriptID(uint160(hashBytes))).ToString()));\n+\n+            } else if (out.scriptPubKey.IsPayToPublicKeyHash()) {\n+                vector<unsigned char> hashBytes(out.scriptPubKey.begin()+3, out.scriptPubKey.begin()+23);\n+                delta.push_back(Pair(\"address\", CBitcoinAddress(CKeyID(uint160(hashBytes))).ToString()));\n+            } else {\n+                continue;\n+            }\n+\n+            delta.push_back(Pair(\"satoshis\", out.nValue));\n+            delta.push_back(Pair(\"index\", (int)k));\n+\n+            outputs.push_back(delta);\n+        }\n+\n+        entry.push_back(Pair(\"outputs\", outputs));\n+        deltas.push_back(entry);\n+\n+    }\n+    result.push_back(Pair(\"deltas\", deltas));\n+    result.push_back(Pair(\"time\", block.GetBlockTime()));\n+    result.push_back(Pair(\"mediantime\", (int64_t)blockindex->GetMedianTimePast()));\n+    result.push_back(Pair(\"nonce\", (uint64_t)block.nNonce));\n+    result.push_back(Pair(\"bits\", strprintf(\"%08x\", block.nBits)));\n+    result.push_back(Pair(\"difficulty\", GetDifficulty(blockindex)));\n+    result.push_back(Pair(\"chainwork\", blockindex->nChainWork.GetHex()));\n+\n+    if (blockindex->pprev)\n+        result.push_back(Pair(\"previousblockhash\", blockindex->pprev->GetBlockHash().GetHex()));\n+    CBlockIndex *pnext = chainActive.Next(blockindex);\n+    if (pnext)\n+        result.push_back(Pair(\"nextblockhash\", pnext->GetBlockHash().GetHex()));\n+    return result;\n+}\n+\n UniValue blockToJSON(const CBlock& block, const CBlockIndex* blockindex, bool txDetails = false)\n {\n     UniValue result(UniValue::VOBJ);\n@@ -459,6 +570,102 @@ UniValue getmempoolentry(const UniValue& params, bool fHelp)\n     return info;\n }\n \n+UniValue getblockdeltas(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\"\");\n+\n+    std::string strHash = params[0].get_str();\n+    uint256 hash(uint256S(strHash));\n+\n+    if (mapBlockIndex.count(hash) == 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n+\n+    CBlock block;\n+    CBlockIndex* pblockindex = mapBlockIndex[hash];\n+\n+    if (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0)\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"Block not available (pruned data)\");\n+\n+    if(!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus()))\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"Can't read block from disk\");\n+\n+    return blockToDeltasJSON(block, pblockindex);\n+}\n+\n+UniValue getblockhashes(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 2)\n+        throw runtime_error(\n+            \"getblockhashes timestamp\\n\"\n+            \"\\nReturns array of hashes of blocks within the timestamp range provided.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. high         (numeric, required) The newer block timestamp\\n\"\n+            \"2. low          (numeric, required) The older block timestamp\\n\"\n+            \"3. options      (string, required) A json object\\n\"\n+            \"    {\\n\"\n+            \"      \\\"noOrphans\\\":true   (boolean) will only include blocks on the main chain\\n\"\n+            \"      \\\"logicalTimes\\\":true   (boolean) will include logical timestamps with hashes\\n\"\n+            \"    }\\n\"\n+            \"\\nResult:\\n\"\n+            \"[\\n\"\n+            \"  \\\"hash\\\"         (string) The block hash\\n\"\n+            \"]\\n\"\n+            \"[\\n\"\n+            \"  {\\n\"\n+            \"    \\\"blockhash\\\": (string) The block hash\\n\"\n+            \"    \\\"logicalts\\\": (numeric) The logical timestamp\\n\"\n+            \"  }\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockhashes\", \"1231614698 1231024505\")\n+            + HelpExampleRpc(\"getblockhashes\", \"1231614698, 1231024505\")\n+            + HelpExampleCli(\"getblockhashes\", \"1231614698 1231024505 '{\\\"noOrphans\\\":false, \\\"logicalTimes\\\":true}'\")\n+            );\n+\n+    unsigned int high = params[0].get_int();\n+    unsigned int low = params[1].get_int();\n+    bool fActiveOnly = false;\n+    bool fLogicalTS = false;\n+\n+    if (params.size() > 2) {\n+        if (params[2].isObject()) {\n+            UniValue noOrphans = find_value(params[2].get_obj(), \"noOrphans\");\n+            UniValue returnLogical = find_value(params[2].get_obj(), \"logicalTimes\");\n+\n+            if (noOrphans.isBool())\n+                fActiveOnly = noOrphans.get_bool();\n+\n+            if (returnLogical.isBool())\n+                fLogicalTS = returnLogical.get_bool();\n+        }\n+    }\n+\n+    std::vector<std::pair<uint256, unsigned int> > blockHashes;\n+\n+    if (fActiveOnly)\n+        LOCK(cs_main);\n+\n+    if (!GetTimestampIndex(high, low, fActiveOnly, blockHashes)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for block hashes\");\n+    }\n+\n+    UniValue result(UniValue::VARR);\n+\n+    for (std::vector<std::pair<uint256, unsigned int> >::const_iterator it=blockHashes.begin(); it!=blockHashes.end(); it++) {\n+        if (fLogicalTS) {\n+            UniValue item(UniValue::VOBJ);\n+            item.push_back(Pair(\"blockhash\", it->first.GetHex()));\n+            item.push_back(Pair(\"logicalts\", (int)it->second));\n+            result.push_back(item);\n+        } else {\n+            result.push_back(it->first.GetHex());\n+        }\n+    }\n+\n+    return result;\n+}\n+\n UniValue getblockhash(const UniValue& params, bool fHelp)\n {\n     if (fHelp || params.size() != 1)\n@@ -1191,6 +1398,8 @@ static const CRPCCommand commands[] =\n     { \"blockchain\",         \"getbestblockhash\",       &getbestblockhash,       true  },\n     { \"blockchain\",         \"getblockcount\",          &getblockcount,          true  },\n     { \"blockchain\",         \"getblock\",               &getblock,               true  },\n+    { \"blockchain\",         \"getblockdeltas\",         &getblockdeltas,         false },\n+    { \"blockchain\",         \"getblockhashes\",         &getblockhashes,         true  },\n     { \"blockchain\",         \"getblockhash\",           &getblockhash,           true  },\n     { \"blockchain\",         \"getblockheader\",         &getblockheader,         true  },\n     { \"blockchain\",         \"getchaintips\",           &getchaintips,           true  },\n@@ -1203,6 +1412,7 @@ static const CRPCCommand commands[] =\n     { \"blockchain\",         \"gettxout\",               &gettxout,               true  },\n     { \"blockchain\",         \"gettxoutsetinfo\",        &gettxoutsetinfo,        true  },\n     { \"blockchain\",         \"verifychain\",            &verifychain,            true  },\n+    { \"blockchain\",         \"getspentinfo\",           &getspentinfo,           false },\n \n     /* Not shown in help */\n     { \"hidden\",             \"invalidateblock\",        &invalidateblock,        true  },"
      },
      {
        "sha": "5f1dc78c579adc324b4cbc322a9b80c53498af4d",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/877c241faf8022d98aeda4a31f33158d8ea5855a/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/877c241faf8022d98aeda4a31f33158d8ea5855a/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=877c241faf8022d98aeda4a31f33158d8ea5855a",
        "patch": "@@ -104,6 +104,15 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"setban\", 3 },\n     { \"getmempoolancestors\", 1 },\n     { \"getmempooldescendants\", 1 },\n+    { \"getblockhashes\", 0 },\n+    { \"getblockhashes\", 1 },\n+    { \"getblockhashes\", 2 },\n+    { \"getspentinfo\", 0},\n+    { \"getaddresstxids\", 0},\n+    { \"getaddressbalance\", 0},\n+    { \"getaddressdeltas\", 0},\n+    { \"getaddressutxos\", 0},\n+    { \"getaddressmempool\", 0},\n };\n \n class CRPCConvertTable"
      },
      {
        "sha": "9ad0802c97b72876d5db4cc11f7e193ae52a697c",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 535,
        "deletions": 0,
        "changes": 535,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/877c241faf8022d98aeda4a31f33158d8ea5855a/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/877c241faf8022d98aeda4a31f33158d8ea5855a/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=877c241faf8022d98aeda4a31f33158d8ea5855a",
        "patch": "@@ -11,6 +11,7 @@\n #include \"netbase.h\"\n #include \"rpc/server.h\"\n #include \"timedata.h\"\n+#include \"txmempool.h\"\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n #ifdef ENABLE_WALLET\n@@ -494,6 +495,13 @@ static const CRPCCommand commands[] =\n     { \"util\",               \"verifymessage\",          &verifymessage,          true  },\n     { \"util\",               \"signmessagewithprivkey\", &signmessagewithprivkey, true  },\n \n+    /* Address index */\n+    { \"addressindex\",       \"getaddressmempool\",      &getaddressmempool,      true  },\n+    { \"addressindex\",       \"getaddressutxos\",        &getaddressutxos,        false },\n+    { \"addressindex\",       \"getaddressdeltas\",       &getaddressdeltas,       false },\n+    { \"addressindex\",       \"getaddresstxids\",        &getaddresstxids,        false },\n+    { \"addressindex\",       \"getaddressbalance\",      &getaddressbalance,      false },\n+\n     /* Not shown in help */\n     { \"hidden\",             \"setmocktime\",            &setmocktime,            true  },\n };\n@@ -503,3 +511,530 @@ void RegisterMiscRPCCommands(CRPCTable &tableRPC)\n     for (unsigned int vcidx = 0; vcidx < ARRAYLEN(commands); vcidx++)\n         tableRPC.appendCommand(commands[vcidx].name, &commands[vcidx]);\n }\n+\n+bool getAddressFromIndex(const int &type, const uint160 &hash, std::string &address)\n+{\n+    if (type == 2) {\n+        address = CBitcoinAddress(CScriptID(hash)).ToString();\n+    } else if (type == 1) {\n+        address = CBitcoinAddress(CKeyID(hash)).ToString();\n+    } else {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool getAddressesFromParams(const UniValue& params, std::vector<std::pair<uint160, int> > &addresses)\n+{\n+    if (params[0].isStr()) {\n+        CBitcoinAddress address(params[0].get_str());\n+        uint160 hashBytes;\n+        int type = 0;\n+        if (!address.GetIndexKey(hashBytes, type)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+        }\n+        addresses.push_back(std::make_pair(hashBytes, type));\n+    } else if (params[0].isObject()) {\n+\n+        UniValue addressValues = find_value(params[0].get_obj(), \"addresses\");\n+        if (!addressValues.isArray()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Addresses is expected to be an array\");\n+        }\n+\n+        std::vector<UniValue> values = addressValues.getValues();\n+\n+        for (std::vector<UniValue>::iterator it = values.begin(); it != values.end(); ++it) {\n+\n+            CBitcoinAddress address(it->get_str());\n+            uint160 hashBytes;\n+            int type = 0;\n+            if (!address.GetIndexKey(hashBytes, type)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+            }\n+            addresses.push_back(std::make_pair(hashBytes, type));\n+        }\n+    } else {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    return true;\n+}\n+\n+bool heightSort(std::pair<CAddressUnspentKey, CAddressUnspentValue> a,\n+                std::pair<CAddressUnspentKey, CAddressUnspentValue> b) {\n+    return a.second.blockHeight < b.second.blockHeight;\n+}\n+\n+bool timestampSort(std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> a,\n+                   std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> b) {\n+    return a.second.time < b.second.time;\n+}\n+\n+UniValue getaddressmempool(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"getaddressmempool\\n\"\n+            \"\\nReturns all mempool deltas for an address (requires addressindex to be enabled).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"addresses\\\"\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"}\\n\"\n+            \"\\nResult:\\n\"\n+            \"[\\n\"\n+            \"  {\\n\"\n+            \"    \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"    \\\"txid\\\"  (string) The related txid\\n\"\n+            \"    \\\"index\\\"  (number) The related input or output index\\n\"\n+            \"    \\\"satoshis\\\"  (number) The difference of satoshis\\n\"\n+            \"    \\\"timestamp\\\"  (number) The time the transaction entered the mempool (seconds)\\n\"\n+            \"    \\\"prevtxid\\\"  (string) The previous txid (if spending)\\n\"\n+            \"    \\\"prevout\\\"  (string) The previous transaction output index (if spending)\\n\"\n+            \"  }\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getaddressmempool\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n+            + HelpExampleRpc(\"getaddressmempool\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n+        );\n+\n+    std::vector<std::pair<uint160, int> > addresses;\n+\n+    if (!getAddressesFromParams(params, addresses)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    std::vector<std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> > indexes;\n+\n+    if (!mempool.getAddressIndex(addresses, indexes)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+    }\n+\n+    std::sort(indexes.begin(), indexes.end(), timestampSort);\n+\n+    UniValue result(UniValue::VARR);\n+\n+    for (std::vector<std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> >::iterator it = indexes.begin();\n+         it != indexes.end(); it++) {\n+\n+        std::string address;\n+        if (!getAddressFromIndex(it->first.type, it->first.addressBytes, address)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unknown address type\");\n+        }\n+\n+        UniValue delta(UniValue::VOBJ);\n+        delta.push_back(Pair(\"address\", address));\n+        delta.push_back(Pair(\"txid\", it->first.txhash.GetHex()));\n+        delta.push_back(Pair(\"index\", (int)it->first.index));\n+        delta.push_back(Pair(\"satoshis\", it->second.amount));\n+        delta.push_back(Pair(\"timestamp\", it->second.time));\n+        if (it->second.amount < 0) {\n+            delta.push_back(Pair(\"prevtxid\", it->second.prevhash.GetHex()));\n+            delta.push_back(Pair(\"prevout\", (int)it->second.prevout));\n+        }\n+        result.push_back(delta);\n+    }\n+\n+    return result;\n+}\n+\n+UniValue getaddressutxos(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"getaddressutxos\\n\"\n+            \"\\nReturns all unspent outputs for an address (requires addressindex to be enabled).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"addresses\\\"\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"      ,...\\n\"\n+            \"    ],\\n\"\n+            \"  \\\"chainInfo\\\"  (boolean) Include chain info with results\\n\"\n+            \"}\\n\"\n+            \"\\nResult\\n\"\n+            \"[\\n\"\n+            \"  {\\n\"\n+            \"    \\\"address\\\"  (string) The address base58check encoded\\n\"\n+            \"    \\\"txid\\\"  (string) The output txid\\n\"\n+            \"    \\\"height\\\"  (number) The block height\\n\"\n+            \"    \\\"outputIndex\\\"  (number) The output index\\n\"\n+            \"    \\\"script\\\"  (strin) The script hex encoded\\n\"\n+            \"    \\\"satoshis\\\"  (number) The number of satoshis of the output\\n\"\n+            \"  }\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getaddressutxos\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n+            + HelpExampleRpc(\"getaddressutxos\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n+            );\n+\n+    bool includeChainInfo = false;\n+    if (params[0].isObject()) {\n+        UniValue chainInfo = find_value(params[0].get_obj(), \"chainInfo\");\n+        if (chainInfo.isBool()) {\n+            includeChainInfo = chainInfo.get_bool();\n+        }\n+    }\n+\n+    std::vector<std::pair<uint160, int> > addresses;\n+\n+    if (!getAddressesFromParams(params, addresses)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > unspentOutputs;\n+\n+    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n+        if (!GetAddressUnspent((*it).first, (*it).second, unspentOutputs)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+        }\n+    }\n+\n+    std::sort(unspentOutputs.begin(), unspentOutputs.end(), heightSort);\n+\n+    UniValue utxos(UniValue::VARR);\n+\n+    for (std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> >::const_iterator it=unspentOutputs.begin(); it!=unspentOutputs.end(); it++) {\n+        UniValue output(UniValue::VOBJ);\n+        std::string address;\n+        if (!getAddressFromIndex(it->first.type, it->first.hashBytes, address)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unknown address type\");\n+        }\n+\n+        output.push_back(Pair(\"address\", address));\n+        output.push_back(Pair(\"txid\", it->first.txhash.GetHex()));\n+        output.push_back(Pair(\"outputIndex\", (int)it->first.index));\n+        output.push_back(Pair(\"script\", HexStr(it->second.script.begin(), it->second.script.end())));\n+        output.push_back(Pair(\"satoshis\", it->second.satoshis));\n+        output.push_back(Pair(\"height\", it->second.blockHeight));\n+        utxos.push_back(output);\n+    }\n+\n+    if (includeChainInfo) {\n+        UniValue result(UniValue::VOBJ);\n+        result.push_back(Pair(\"utxos\", utxos));\n+\n+        LOCK(cs_main);\n+        result.push_back(Pair(\"hash\", chainActive.Tip()->GetBlockHash().GetHex()));\n+        result.push_back(Pair(\"height\", (int)chainActive.Height()));\n+        return result;\n+    } else {\n+        return utxos;\n+    }\n+}\n+\n+UniValue getaddressdeltas(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1 || !params[0].isObject())\n+        throw runtime_error(\n+            \"getaddressdeltas\\n\"\n+            \"\\nReturns all changes for an address (requires addressindex to be enabled).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"addresses\\\"\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"  \\\"start\\\" (number) The start block height\\n\"\n+            \"  \\\"end\\\" (number) The end block height\\n\"\n+            \"  \\\"chainInfo\\\" (boolean) Include chain info in results, only applies if start and end specified\\n\"\n+            \"}\\n\"\n+            \"\\nResult:\\n\"\n+            \"[\\n\"\n+            \"  {\\n\"\n+            \"    \\\"satoshis\\\"  (number) The difference of satoshis\\n\"\n+            \"    \\\"txid\\\"  (string) The related txid\\n\"\n+            \"    \\\"index\\\"  (number) The related input or output index\\n\"\n+            \"    \\\"height\\\"  (number) The block height\\n\"\n+            \"    \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"  }\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getaddressdeltas\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n+            + HelpExampleRpc(\"getaddressdeltas\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n+        );\n+\n+\n+    UniValue startValue = find_value(params[0].get_obj(), \"start\");\n+    UniValue endValue = find_value(params[0].get_obj(), \"end\");\n+\n+    UniValue chainInfo = find_value(params[0].get_obj(), \"chainInfo\");\n+    bool includeChainInfo = false;\n+    if (chainInfo.isBool()) {\n+        includeChainInfo = chainInfo.get_bool();\n+    }\n+\n+    int start = 0;\n+    int end = 0;\n+\n+    if (startValue.isNum() && endValue.isNum()) {\n+        start = startValue.get_int();\n+        end = endValue.get_int();\n+        if (start <= 0 || end <= 0) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Start and end is expected to be greater than zero\");\n+        }\n+        if (end < start) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"End value is expected to be greater than start\");\n+        }\n+    }\n+\n+    std::vector<std::pair<uint160, int> > addresses;\n+\n+    if (!getAddressesFromParams(params, addresses)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;\n+\n+    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n+        if (start > 0 && end > 0) {\n+            if (!GetAddressIndex((*it).first, (*it).second, addressIndex, start, end)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+            }\n+        } else {\n+            if (!GetAddressIndex((*it).first, (*it).second, addressIndex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+            }\n+        }\n+    }\n+\n+    UniValue deltas(UniValue::VARR);\n+\n+    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=addressIndex.begin(); it!=addressIndex.end(); it++) {\n+        std::string address;\n+        if (!getAddressFromIndex(it->first.type, it->first.hashBytes, address)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unknown address type\");\n+        }\n+\n+        UniValue delta(UniValue::VOBJ);\n+        delta.push_back(Pair(\"satoshis\", it->second));\n+        delta.push_back(Pair(\"txid\", it->first.txhash.GetHex()));\n+        delta.push_back(Pair(\"index\", (int)it->first.index));\n+        delta.push_back(Pair(\"blockindex\", (int)it->first.txindex));\n+        delta.push_back(Pair(\"height\", it->first.blockHeight));\n+        delta.push_back(Pair(\"address\", address));\n+        deltas.push_back(delta);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    if (includeChainInfo && start > 0 && end > 0) {\n+        LOCK(cs_main);\n+\n+        if (start > chainActive.Height() || end > chainActive.Height()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Start or end is outside chain range\");\n+        }\n+\n+        CBlockIndex* startIndex = chainActive[start];\n+        CBlockIndex* endIndex = chainActive[end];\n+\n+        UniValue startInfo(UniValue::VOBJ);\n+        UniValue endInfo(UniValue::VOBJ);\n+\n+        startInfo.push_back(Pair(\"hash\", startIndex->GetBlockHash().GetHex()));\n+        startInfo.push_back(Pair(\"height\", start));\n+\n+        endInfo.push_back(Pair(\"hash\", endIndex->GetBlockHash().GetHex()));\n+        endInfo.push_back(Pair(\"height\", end));\n+\n+        result.push_back(Pair(\"deltas\", deltas));\n+        result.push_back(Pair(\"start\", startInfo));\n+        result.push_back(Pair(\"end\", endInfo));\n+\n+        return result;\n+    } else {\n+        return deltas;\n+    }\n+}\n+\n+UniValue getaddressbalance(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"getaddressbalance\\n\"\n+            \"\\nReturns the balance for an address(es) (requires addressindex to be enabled).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"addresses\\\"\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"}\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"balance\\\"  (string) The current balance in satoshis\\n\"\n+            \"  \\\"received\\\"  (string) The total number of satoshis received (including change)\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getaddressbalance\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n+            + HelpExampleRpc(\"getaddressbalance\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n+        );\n+\n+    std::vector<std::pair<uint160, int> > addresses;\n+\n+    if (!getAddressesFromParams(params, addresses)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;\n+\n+    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n+        if (!GetAddressIndex((*it).first, (*it).second, addressIndex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+        }\n+    }\n+\n+    CAmount balance = 0;\n+    CAmount received = 0;\n+\n+    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=addressIndex.begin(); it!=addressIndex.end(); it++) {\n+        if (it->second > 0) {\n+            received += it->second;\n+        }\n+        balance += it->second;\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    result.push_back(Pair(\"balance\", balance));\n+    result.push_back(Pair(\"received\", received));\n+\n+    return result;\n+\n+}\n+\n+UniValue getaddresstxids(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"getaddresstxids\\n\"\n+            \"\\nReturns the txids for an address(es) (requires addressindex to be enabled).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"addresses\\\"\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"  \\\"start\\\" (number) The start block height\\n\"\n+            \"  \\\"end\\\" (number) The end block height\\n\"\n+            \"}\\n\"\n+            \"\\nResult:\\n\"\n+            \"[\\n\"\n+            \"  \\\"transactionid\\\"  (string) The transaction id\\n\"\n+            \"  ,...\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getaddresstxids\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n+            + HelpExampleRpc(\"getaddresstxids\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n+        );\n+\n+    std::vector<std::pair<uint160, int> > addresses;\n+\n+    if (!getAddressesFromParams(params, addresses)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    int start = 0;\n+    int end = 0;\n+    if (params[0].isObject()) {\n+        UniValue startValue = find_value(params[0].get_obj(), \"start\");\n+        UniValue endValue = find_value(params[0].get_obj(), \"end\");\n+        if (startValue.isNum() && endValue.isNum()) {\n+            start = startValue.get_int();\n+            end = endValue.get_int();\n+        }\n+    }\n+\n+    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;\n+\n+    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n+        if (start > 0 && end > 0) {\n+            if (!GetAddressIndex((*it).first, (*it).second, addressIndex, start, end)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+            }\n+        } else {\n+            if (!GetAddressIndex((*it).first, (*it).second, addressIndex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+            }\n+        }\n+    }\n+\n+    std::set<std::pair<int, std::string> > txids;\n+    UniValue result(UniValue::VARR);\n+\n+    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=addressIndex.begin(); it!=addressIndex.end(); it++) {\n+        int height = it->first.blockHeight;\n+        std::string txid = it->first.txhash.GetHex();\n+\n+        if (addresses.size() > 1) {\n+            txids.insert(std::make_pair(height, txid));\n+        } else {\n+            if (txids.insert(std::make_pair(height, txid)).second) {\n+                result.push_back(txid);\n+            }\n+        }\n+    }\n+\n+    if (addresses.size() > 1) {\n+        for (std::set<std::pair<int, std::string> >::const_iterator it=txids.begin(); it!=txids.end(); it++) {\n+            result.push_back(it->second);\n+        }\n+    }\n+\n+    return result;\n+\n+}\n+\n+UniValue getspentinfo(const UniValue& params, bool fHelp)\n+{\n+\n+    if (fHelp || params.size() != 1 || !params[0].isObject())\n+        throw runtime_error(\n+            \"getspentinfo\\n\"\n+            \"\\nReturns the txid and index where an output is spent.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\" (string) The hex string of the txid\\n\"\n+            \"  \\\"index\\\" (number) The start block height\\n\"\n+            \"}\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\"  (string) The transaction id\\n\"\n+            \"  \\\"index\\\"  (number) The spending input index\\n\"\n+            \"  ,...\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getspentinfo\", \"'{\\\"txid\\\": \\\"0437cd7f8525ceed2324359c2d0ba26006d92d856a9c20fa0241106ee5a597c9\\\", \\\"index\\\": 0}'\")\n+            + HelpExampleRpc(\"getspentinfo\", \"{\\\"txid\\\": \\\"0437cd7f8525ceed2324359c2d0ba26006d92d856a9c20fa0241106ee5a597c9\\\", \\\"index\\\": 0}\")\n+        );\n+\n+    UniValue txidValue = find_value(params[0].get_obj(), \"txid\");\n+    UniValue indexValue = find_value(params[0].get_obj(), \"index\");\n+\n+    if (!txidValue.isStr() || !indexValue.isNum()) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid txid or index\");\n+    }\n+\n+    uint256 txid = ParseHashV(txidValue, \"txid\");\n+    int outputIndex = indexValue.get_int();\n+\n+    CSpentIndexKey key(txid, outputIndex);\n+    CSpentIndexValue value;\n+\n+    if (!GetSpentIndex(key, value)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unable to get spent info\");\n+    }\n+\n+    UniValue obj(UniValue::VOBJ);\n+    obj.push_back(Pair(\"txid\", value.txid.GetHex()));\n+    obj.push_back(Pair(\"index\", (int)value.inputIndex));\n+    obj.push_back(Pair(\"height\", value.blockHeight));\n+\n+    return obj;\n+}"
      },
      {
        "sha": "dd6dfc75d53193569ed26dbd35b2c2db72997645",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 125,
        "deletions": 7,
        "changes": 132,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/877c241faf8022d98aeda4a31f33158d8ea5855a/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/877c241faf8022d98aeda4a31f33158d8ea5855a/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=877c241faf8022d98aeda4a31f33158d8ea5855a",
        "patch": "@@ -59,6 +59,99 @@ void ScriptPubKeyToJSON(const CScript& scriptPubKey, UniValue& out, bool fInclud\n     out.push_back(Pair(\"addresses\", a));\n }\n \n+void TxToJSONExpanded(const CTransaction& tx, const uint256 hashBlock, UniValue& entry,\n+                      int nHeight = 0, int nConfirmations = 0, int nBlockTime = 0)\n+{\n+\n+    uint256 txid = tx.GetHash();\n+    entry.push_back(Pair(\"txid\", txid.GetHex()));\n+    entry.push_back(Pair(\"hash\", tx.GetWitnessHash().GetHex()));\n+    entry.push_back(Pair(\"size\", (int)::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION)));\n+    entry.push_back(Pair(\"vsize\", (int)::GetVirtualTransactionSize(tx)));\n+    entry.push_back(Pair(\"version\", tx.nVersion));\n+    entry.push_back(Pair(\"locktime\", (int64_t)tx.nLockTime));\n+    UniValue vin(UniValue::VARR);\n+    BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n+        UniValue in(UniValue::VOBJ);\n+        if (tx.IsCoinBase())\n+            in.push_back(Pair(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n+        else {\n+            in.push_back(Pair(\"txid\", txin.prevout.hash.GetHex()));\n+            in.push_back(Pair(\"vout\", (int64_t)txin.prevout.n));\n+            UniValue o(UniValue::VOBJ);\n+            o.push_back(Pair(\"asm\", ScriptToAsmStr(txin.scriptSig, true)));\n+            o.push_back(Pair(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n+            in.push_back(Pair(\"scriptSig\", o));\n+\n+            // Add address and value info if spentindex enabled\n+            CSpentIndexValue spentInfo;\n+            CSpentIndexKey spentKey(txin.prevout.hash, txin.prevout.n);\n+            if (GetSpentIndex(spentKey, spentInfo)) {\n+                in.push_back(Pair(\"value\", ValueFromAmount(spentInfo.satoshis)));\n+                in.push_back(Pair(\"valueSat\", spentInfo.satoshis));\n+                if (spentInfo.addressType == 1) {\n+                    in.push_back(Pair(\"address\", CBitcoinAddress(CKeyID(spentInfo.addressHash)).ToString()));\n+                } else if (spentInfo.addressType == 2)  {\n+                    in.push_back(Pair(\"address\", CBitcoinAddress(CScriptID(spentInfo.addressHash)).ToString()));\n+                }\n+            }\n+\n+        }\n+        if (!tx.wit.IsNull()) {\n+            if (!tx.wit.vtxinwit[i].IsNull()) {\n+                UniValue txinwitness(UniValue::VARR);\n+                for (unsigned int j = 0; j < tx.wit.vtxinwit[i].scriptWitness.stack.size(); j++) {\n+                    std::vector<unsigned char> item = tx.wit.vtxinwit[i].scriptWitness.stack[j];\n+                    txinwitness.push_back(HexStr(item.begin(), item.end()));\n+                }\n+                in.push_back(Pair(\"txinwitness\", txinwitness));\n+            }\n+\n+        }\n+        in.push_back(Pair(\"sequence\", (int64_t)txin.nSequence));\n+        vin.push_back(in);\n+    }\n+    entry.push_back(Pair(\"vin\", vin));\n+    UniValue vout(UniValue::VARR);\n+    for (unsigned int i = 0; i < tx.vout.size(); i++) {\n+        const CTxOut& txout = tx.vout[i];\n+        UniValue out(UniValue::VOBJ);\n+        out.push_back(Pair(\"value\", ValueFromAmount(txout.nValue)));\n+        out.push_back(Pair(\"valueSat\", txout.nValue));\n+        out.push_back(Pair(\"n\", (int64_t)i));\n+        UniValue o(UniValue::VOBJ);\n+        ScriptPubKeyToJSON(txout.scriptPubKey, o, true);\n+        out.push_back(Pair(\"scriptPubKey\", o));\n+\n+        // Add spent information if spentindex is enabled\n+        CSpentIndexValue spentInfo;\n+        CSpentIndexKey spentKey(txid, i);\n+        if (GetSpentIndex(spentKey, spentInfo)) {\n+            out.push_back(Pair(\"spentTxId\", spentInfo.txid.GetHex()));\n+            out.push_back(Pair(\"spentIndex\", (int)spentInfo.inputIndex));\n+            out.push_back(Pair(\"spentHeight\", spentInfo.blockHeight));\n+        }\n+\n+        vout.push_back(out);\n+    }\n+    entry.push_back(Pair(\"vout\", vout));\n+\n+    if (!hashBlock.IsNull()) {\n+        entry.push_back(Pair(\"blockhash\", hashBlock.GetHex()));\n+\n+        if (nConfirmations > 0) {\n+            entry.push_back(Pair(\"height\", nHeight));\n+            entry.push_back(Pair(\"confirmations\", nConfirmations));\n+            entry.push_back(Pair(\"time\", nBlockTime));\n+            entry.push_back(Pair(\"blocktime\", nBlockTime));\n+        } else {\n+            entry.push_back(Pair(\"height\", -1));\n+            entry.push_back(Pair(\"confirmations\", 0));\n+        }\n+    }\n+\n+}\n+\n void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n {\n     entry.push_back(Pair(\"txid\", tx.GetHash().GetHex()));\n@@ -97,11 +190,13 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n         vin.push_back(in);\n     }\n     entry.push_back(Pair(\"vin\", vin));\n+\n     UniValue vout(UniValue::VARR);\n     for (unsigned int i = 0; i < tx.vout.size(); i++) {\n         const CTxOut& txout = tx.vout[i];\n         UniValue out(UniValue::VOBJ);\n         out.push_back(Pair(\"value\", ValueFromAmount(txout.nValue)));\n+        out.push_back(Pair(\"valueSat\", txout.nValue));\n         out.push_back(Pair(\"n\", (int64_t)i));\n         UniValue o(UniValue::VOBJ);\n         ScriptPubKeyToJSON(txout.scriptPubKey, o, true);\n@@ -116,12 +211,14 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n         if (mi != mapBlockIndex.end() && (*mi).second) {\n             CBlockIndex* pindex = (*mi).second;\n             if (chainActive.Contains(pindex)) {\n+                entry.push_back(Pair(\"height\", pindex->nHeight));\n                 entry.push_back(Pair(\"confirmations\", 1 + chainActive.Height() - pindex->nHeight));\n                 entry.push_back(Pair(\"time\", pindex->GetBlockTime()));\n                 entry.push_back(Pair(\"blocktime\", pindex->GetBlockTime()));\n-            }\n-            else\n+            } else {\n+                entry.push_back(Pair(\"height\", -1));\n                 entry.push_back(Pair(\"confirmations\", 0));\n+            }\n         }\n     }\n }\n@@ -196,18 +293,38 @@ UniValue getrawtransaction(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"getrawtransaction\", \"\\\"mytxid\\\", 1\")\n         );\n \n-    LOCK(cs_main);\n-\n     uint256 hash = ParseHashV(params[0], \"parameter 1\");\n \n     bool fVerbose = false;\n     if (params.size() > 1)\n         fVerbose = (params[1].get_int() != 0);\n \n     CTransaction tx;\n+\n     uint256 hashBlock;\n-    if (!GetTransaction(hash, tx, Params().GetConsensus(), hashBlock, true))\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available about transaction\");\n+    int nHeight = 0;\n+    int nConfirmations = 0;\n+    int nBlockTime = 0;\n+\n+    {\n+        LOCK(cs_main);\n+        if (!GetTransaction(hash, tx, Params().GetConsensus(), hashBlock, true))\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available about transaction\");\n+\n+        BlockMap::iterator mi = mapBlockIndex.find(hashBlock);\n+        if (mi != mapBlockIndex.end() && (*mi).second) {\n+            CBlockIndex* pindex = (*mi).second;\n+            if (chainActive.Contains(pindex)) {\n+                nHeight = pindex->nHeight;\n+                nConfirmations = 1 + chainActive.Height() - pindex->nHeight;\n+                nBlockTime = pindex->GetBlockTime();\n+            } else {\n+                nHeight = -1;\n+                nConfirmations = 0;\n+                nBlockTime = pindex->GetBlockTime();\n+            }\n+        }\n+    }\n \n     string strHex = EncodeHexTx(tx);\n \n@@ -216,7 +333,8 @@ UniValue getrawtransaction(const UniValue& params, bool fHelp)\n \n     UniValue result(UniValue::VOBJ);\n     result.push_back(Pair(\"hex\", strHex));\n-    TxToJSON(tx, hashBlock, result);\n+    TxToJSONExpanded(tx, hashBlock, result, nHeight, nConfirmations, nBlockTime);\n+\n     return result;\n }\n "
      }
    ]
  },
  {
    "sha": "d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNjBlZGQzZjhkYTNhZTdiNjBkNDliOWEwYzk3ZjJjZDBmYmU1ZTBj",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-04T19:01:44Z"
      },
      "committer": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-05T16:46:54Z"
      },
      "message": "tests: adds rpc tests for address, spent and timestamp indexes\n\nTests the functionality of the indexes as well as the rpc commands",
      "tree": {
        "sha": "45ec2688a0dd847bd0c13f38810116e7f6ce9961",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/45ec2688a0dd847bd0c13f38810116e7f6ce9961"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "877c241faf8022d98aeda4a31f33158d8ea5855a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/877c241faf8022d98aeda4a31f33158d8ea5855a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/877c241faf8022d98aeda4a31f33158d8ea5855a"
      }
    ],
    "stats": {
      "total": 625,
      "additions": 625,
      "deletions": 0
    },
    "files": [
      {
        "sha": "482a550c5db18ae275c96ce82d165b952abefd44",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c",
        "patch": "@@ -127,6 +127,9 @@\n     'signrawtransactions.py',\n     'nodehandling.py',\n     'reindex.py',\n+    'addressindex.py',\n+    'timestampindex.py',\n+    'spentindex.py',\n     'decodescript.py',\n     'blockchain.py',\n     'disablewallet.py',"
      },
      {
        "sha": "8b0b6d38af41ef9ad856eb391f9bb6b98a6cd701",
        "filename": "qa/rpc-tests/addressindex.py",
        "status": "added",
        "additions": 349,
        "deletions": 0,
        "changes": 349,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c/qa/rpc-tests/addressindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c/qa/rpc-tests/addressindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/addressindex.py?ref=d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c",
        "patch": "@@ -0,0 +1,349 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test addressindex generation and fetching\n+#\n+\n+import time\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.script import *\n+from test_framework.mininode import *\n+import binascii\n+\n+class AddressIndexTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 4)\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        # Nodes 0/1 are \"wallet\" nodes\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-relaypriority=0\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-addressindex\"]))\n+        # Nodes 2/3 are used for testing\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\", \"-addressindex\", \"-relaypriority=0\"]))\n+        self.nodes.append(start_node(3, self.options.tmpdir, [\"-debug\", \"-addressindex\"]))\n+        connect_nodes(self.nodes[0], 1)\n+        connect_nodes(self.nodes[0], 2)\n+        connect_nodes(self.nodes[0], 3)\n+\n+        self.is_network_split = False\n+        self.sync_all()\n+\n+    def run_test(self):\n+        print \"Mining blocks...\"\n+        self.nodes[0].generate(105)\n+        self.sync_all()\n+\n+        chain_height = self.nodes[1].getblockcount()\n+        assert_equal(chain_height, 105)\n+        assert_equal(self.nodes[1].getbalance(), 0)\n+        assert_equal(self.nodes[2].getbalance(), 0)\n+\n+        # Check that balances are correct\n+        balance0 = self.nodes[1].getaddressbalance(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\")\n+        assert_equal(balance0[\"balance\"], 0)\n+\n+        # Check p2pkh and p2sh address indexes\n+        print \"Testing p2pkh and p2sh address index...\"\n+\n+        txid0 = self.nodes[0].sendtoaddress(\"mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs\", 10)\n+        self.nodes[0].generate(1)\n+\n+        txidb0 = self.nodes[0].sendtoaddress(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\", 10)\n+        self.nodes[0].generate(1)\n+\n+        txid1 = self.nodes[0].sendtoaddress(\"mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs\", 15)\n+        self.nodes[0].generate(1)\n+\n+        txidb1 = self.nodes[0].sendtoaddress(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\", 15)\n+        self.nodes[0].generate(1)\n+\n+        txid2 = self.nodes[0].sendtoaddress(\"mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs\", 20)\n+        self.nodes[0].generate(1)\n+\n+        txidb2 = self.nodes[0].sendtoaddress(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\", 20)\n+        self.nodes[0].generate(1)\n+\n+        self.sync_all()\n+\n+        txids = self.nodes[1].getaddresstxids(\"mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs\")\n+        assert_equal(len(txids), 3)\n+        assert_equal(txids[0], txid0)\n+        assert_equal(txids[1], txid1)\n+        assert_equal(txids[2], txid2)\n+\n+        txidsb = self.nodes[1].getaddresstxids(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\")\n+        assert_equal(len(txidsb), 3)\n+        assert_equal(txidsb[0], txidb0)\n+        assert_equal(txidsb[1], txidb1)\n+        assert_equal(txidsb[2], txidb2)\n+\n+        # Check that limiting by height works\n+        print \"Testing querying txids by range of block heights..\"\n+        height_txids = self.nodes[1].getaddresstxids({\n+            \"addresses\": [\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\"],\n+            \"start\": 105,\n+            \"end\": 110\n+        })\n+        assert_equal(len(height_txids), 2)\n+        assert_equal(height_txids[0], txidb0)\n+        assert_equal(height_txids[1], txidb1)\n+\n+        # Check that multiple addresses works\n+        multitxids = self.nodes[1].getaddresstxids({\"addresses\": [\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\", \"mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs\"]})\n+        assert_equal(len(multitxids), 6)\n+        assert_equal(multitxids[0], txid0)\n+        assert_equal(multitxids[1], txidb0)\n+        assert_equal(multitxids[2], txid1)\n+        assert_equal(multitxids[3], txidb1)\n+        assert_equal(multitxids[4], txid2)\n+        assert_equal(multitxids[5], txidb2)\n+\n+        # Check that balances are correct\n+        balance0 = self.nodes[1].getaddressbalance(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\")\n+        assert_equal(balance0[\"balance\"], 45 * 100000000)\n+\n+        # Check that outputs with the same address will only return one txid\n+        print \"Testing for txid uniqueness...\"\n+        addressHash = \"6349a418fc4578d10a372b54b45c280cc8c4382f\".decode(\"hex\")\n+        scriptPubKey = CScript([OP_HASH160, addressHash, OP_EQUAL])\n+        unspent = self.nodes[0].listunspent()\n+        tx = CTransaction()\n+        tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n+        tx.vout = [CTxOut(10, scriptPubKey), CTxOut(11, scriptPubKey)]\n+        tx.rehash()\n+\n+        signed_tx = self.nodes[0].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        sent_txid = self.nodes[0].sendrawtransaction(signed_tx[\"hex\"], True)\n+\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        txidsmany = self.nodes[1].getaddresstxids(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\")\n+        assert_equal(len(txidsmany), 4)\n+        assert_equal(txidsmany[3], sent_txid)\n+\n+        # Check that balances are correct\n+        print \"Testing balances...\"\n+        balance0 = self.nodes[1].getaddressbalance(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\")\n+        assert_equal(balance0[\"balance\"], 45 * 100000000 + 21)\n+\n+        # Check that balances are correct after spending\n+        print \"Testing balances after spending...\"\n+        privkey2 = \"cSdkPxkAjA4HDr5VHgsebAPDEh9Gyub4HK8UJr2DFGGqKKy4K5sG\"\n+        address2 = \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\"\n+        addressHash2 = \"0b2f0a0c31bfe0406b0ccc1381fdbe311946dadc\".decode(\"hex\")\n+        scriptPubKey2 = CScript([OP_DUP, OP_HASH160, addressHash2, OP_EQUALVERIFY, OP_CHECKSIG])\n+        self.nodes[0].importprivkey(privkey2)\n+\n+        unspent = self.nodes[0].listunspent()\n+        tx = CTransaction()\n+        tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n+        amount = unspent[0][\"amount\"] * 100000000\n+        tx.vout = [CTxOut(amount, scriptPubKey2)]\n+        tx.rehash()\n+        signed_tx = self.nodes[0].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        spending_txid = self.nodes[0].sendrawtransaction(signed_tx[\"hex\"], True)\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        balance1 = self.nodes[1].getaddressbalance(address2)\n+        assert_equal(balance1[\"balance\"], amount)\n+\n+        tx = CTransaction()\n+        tx.vin = [CTxIn(COutPoint(int(spending_txid, 16), 0))]\n+        send_amount = 1 * 100000000 + 12840\n+        change_amount = amount - send_amount - 10000\n+        tx.vout = [CTxOut(change_amount, scriptPubKey2), CTxOut(send_amount, scriptPubKey)]\n+        tx.rehash()\n+\n+        signed_tx = self.nodes[0].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        sent_txid = self.nodes[0].sendrawtransaction(signed_tx[\"hex\"], True)\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        balance2 = self.nodes[1].getaddressbalance(address2)\n+        assert_equal(balance2[\"balance\"], change_amount)\n+\n+        # Check that deltas are returned correctly\n+        deltas = self.nodes[1].getaddressdeltas({\"addresses\": [address2], \"start\": 1, \"end\": 200})\n+        balance3 = 0\n+        for delta in deltas:\n+            balance3 += delta[\"satoshis\"]\n+        assert_equal(balance3, change_amount)\n+        assert_equal(deltas[0][\"address\"], address2)\n+        assert_equal(deltas[0][\"blockindex\"], 1)\n+\n+        # Check that entire range will be queried\n+        deltasAll = self.nodes[1].getaddressdeltas({\"addresses\": [address2]})\n+        assert_equal(len(deltasAll), len(deltas))\n+\n+        # Check that deltas can be returned from range of block heights\n+        deltas = self.nodes[1].getaddressdeltas({\"addresses\": [address2], \"start\": 113, \"end\": 113})\n+        assert_equal(len(deltas), 1)\n+\n+        # Check that unspent outputs can be queried\n+        print \"Testing utxos...\"\n+        utxos = self.nodes[1].getaddressutxos({\"addresses\": [address2]})\n+        assert_equal(len(utxos), 1)\n+        assert_equal(utxos[0][\"satoshis\"], change_amount)\n+\n+        # Check that indexes will be updated with a reorg\n+        print \"Testing reorg...\"\n+\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        self.nodes[1].invalidateblock(best_hash)\n+        self.nodes[2].invalidateblock(best_hash)\n+        self.nodes[3].invalidateblock(best_hash)\n+        self.sync_all()\n+\n+        balance4 = self.nodes[1].getaddressbalance(address2)\n+        assert_equal(balance4, balance1)\n+\n+        utxos2 = self.nodes[1].getaddressutxos({\"addresses\": [address2]})\n+        assert_equal(len(utxos2), 1)\n+        assert_equal(utxos2[0][\"satoshis\"], amount)\n+\n+        # Check sorting of utxos\n+        self.nodes[2].generate(150)\n+\n+        txidsort1 = self.nodes[2].sendtoaddress(address2, 50)\n+        self.nodes[2].generate(1)\n+        txidsort2 = self.nodes[2].sendtoaddress(address2, 50)\n+        self.nodes[2].generate(1)\n+        self.sync_all()\n+\n+        utxos3 = self.nodes[1].getaddressutxos({\"addresses\": [address2]})\n+        assert_equal(len(utxos3), 3)\n+        assert_equal(utxos3[0][\"height\"], 114)\n+        assert_equal(utxos3[1][\"height\"], 264)\n+        assert_equal(utxos3[2][\"height\"], 265)\n+\n+        # Check mempool indexing\n+        print \"Testing mempool indexing...\"\n+\n+        privKey3 = \"cVfUn53hAbRrDEuMexyfgDpZPhF7KqXpS8UZevsyTDaugB7HZ3CD\"\n+        address3 = \"mw4ynwhS7MmrQ27hr82kgqu7zryNDK26JB\"\n+        addressHash3 = \"aa9872b5bbcdb511d89e0e11aa27da73fd2c3f50\".decode(\"hex\")\n+        scriptPubKey3 = CScript([OP_DUP, OP_HASH160, addressHash3, OP_EQUALVERIFY, OP_CHECKSIG])\n+        address4 = \"2N8oFVB2vThAKury4vnLquW2zVjsYjjAkYQ\"\n+        scriptPubKey4 = CScript([OP_HASH160, addressHash3, OP_EQUAL])\n+        unspent = self.nodes[2].listunspent()\n+\n+        tx = CTransaction()\n+        tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n+        amount = unspent[0][\"amount\"] * 100000000\n+        tx.vout = [CTxOut(amount, scriptPubKey3)]\n+        tx.rehash()\n+        signed_tx = self.nodes[2].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        memtxid1 = self.nodes[2].sendrawtransaction(signed_tx[\"hex\"], True)\n+        time.sleep(2)\n+\n+        tx2 = CTransaction()\n+        tx2.vin = [CTxIn(COutPoint(int(unspent[1][\"txid\"], 16), unspent[1][\"vout\"]))]\n+        amount = unspent[1][\"amount\"] * 100000000\n+        tx2.vout = [\n+            CTxOut(amount / 4, scriptPubKey3),\n+            CTxOut(amount / 4, scriptPubKey3),\n+            CTxOut(amount / 4, scriptPubKey4),\n+            CTxOut(amount / 4, scriptPubKey4)\n+        ]\n+        tx2.rehash()\n+        signed_tx2 = self.nodes[2].signrawtransaction(binascii.hexlify(tx2.serialize()).decode(\"utf-8\"))\n+        memtxid2 = self.nodes[2].sendrawtransaction(signed_tx2[\"hex\"], True)\n+        time.sleep(2)\n+\n+        mempool = self.nodes[2].getaddressmempool({\"addresses\": [address3]})\n+        assert_equal(len(mempool), 3)\n+        assert_equal(mempool[0][\"txid\"], memtxid1)\n+        assert_equal(mempool[0][\"address\"], address3)\n+        assert_equal(mempool[0][\"index\"], 0)\n+        assert_equal(mempool[1][\"txid\"], memtxid2)\n+        assert_equal(mempool[1][\"index\"], 0)\n+        assert_equal(mempool[2][\"txid\"], memtxid2)\n+        assert_equal(mempool[2][\"index\"], 1)\n+\n+        self.nodes[2].generate(1);\n+        self.sync_all();\n+        mempool2 = self.nodes[2].getaddressmempool({\"addresses\": [address3]})\n+        assert_equal(len(mempool2), 0)\n+\n+        tx = CTransaction()\n+        tx.vin = [\n+            CTxIn(COutPoint(int(memtxid2, 16), 0)),\n+            CTxIn(COutPoint(int(memtxid2, 16), 1))\n+        ]\n+        tx.vout = [CTxOut(amount / 2 - 10000, scriptPubKey2)]\n+        tx.rehash()\n+        self.nodes[2].importprivkey(privKey3)\n+        signed_tx3 = self.nodes[2].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        memtxid3 = self.nodes[2].sendrawtransaction(signed_tx3[\"hex\"], True)\n+        time.sleep(2)\n+\n+        mempool3 = self.nodes[2].getaddressmempool({\"addresses\": [address3]})\n+        assert_equal(len(mempool3), 2)\n+        assert_equal(mempool3[0][\"prevtxid\"], memtxid2)\n+        assert_equal(mempool3[0][\"prevout\"], 0)\n+        assert_equal(mempool3[1][\"prevtxid\"], memtxid2)\n+        assert_equal(mempool3[1][\"prevout\"], 1)\n+\n+        # sending and receiving to the same address\n+        privkey1 = \"cQY2s58LhzUCmEXN8jtAp1Etnijx78YRZ466w4ikX1V4UpTpbsf8\"\n+        address1 = \"myAUWSHnwsQrhuMWv4Br6QsCnpB41vFwHn\"\n+        address1hash = \"c192bff751af8efec15135d42bfeedf91a6f3e34\".decode(\"hex\")\n+        address1script = CScript([OP_DUP, OP_HASH160, address1hash, OP_EQUALVERIFY, OP_CHECKSIG])\n+\n+        self.nodes[0].sendtoaddress(address1, 10)\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        utxos = self.nodes[1].getaddressutxos({\"addresses\": [address1]})\n+        assert_equal(len(utxos), 1)\n+\n+        tx = CTransaction()\n+        tx.vin = [\n+            CTxIn(COutPoint(int(utxos[0][\"txid\"], 16), utxos[0][\"outputIndex\"]))\n+        ]\n+        amount = utxos[0][\"satoshis\"] - 1000\n+        tx.vout = [CTxOut(amount, address1script)]\n+        tx.rehash()\n+        self.nodes[0].importprivkey(privkey1)\n+        signed_tx = self.nodes[0].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        mem_txid = self.nodes[0].sendrawtransaction(signed_tx[\"hex\"], True)\n+\n+        self.sync_all()\n+        mempool_deltas = self.nodes[2].getaddressmempool({\"addresses\": [address1]})\n+        assert_equal(len(mempool_deltas), 2)\n+\n+        # Include chaininfo in results\n+        print \"Testing results with chain info...\"\n+\n+        deltas_with_info = self.nodes[1].getaddressdeltas({\n+            \"addresses\": [address2],\n+            \"start\": 1,\n+            \"end\": 200,\n+            \"chainInfo\": True\n+        })\n+        start_block_hash = self.nodes[1].getblockhash(1);\n+        end_block_hash = self.nodes[1].getblockhash(200);\n+        assert_equal(deltas_with_info[\"start\"][\"height\"], 1)\n+        assert_equal(deltas_with_info[\"start\"][\"hash\"], start_block_hash)\n+        assert_equal(deltas_with_info[\"end\"][\"height\"], 200)\n+        assert_equal(deltas_with_info[\"end\"][\"hash\"], end_block_hash)\n+\n+        utxos_with_info = self.nodes[1].getaddressutxos({\"addresses\": [address2], \"chainInfo\": True})\n+        expected_tip_block_hash = self.nodes[1].getblockhash(267);\n+        assert_equal(utxos_with_info[\"height\"], 267)\n+        assert_equal(utxos_with_info[\"hash\"], expected_tip_block_hash)\n+\n+        print \"Passed\\n\"\n+\n+\n+if __name__ == '__main__':\n+    AddressIndexTest().main()"
      },
      {
        "sha": "1366dbe315e4f1ae88cd3281cb6c4da21edf04f7",
        "filename": "qa/rpc-tests/spentindex.py",
        "status": "added",
        "additions": 139,
        "deletions": 0,
        "changes": 139,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c/qa/rpc-tests/spentindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c/qa/rpc-tests/spentindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/spentindex.py?ref=d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c",
        "patch": "@@ -0,0 +1,139 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test addressindex generation and fetching\n+#\n+\n+import time\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.script import *\n+from test_framework.mininode import *\n+import binascii\n+\n+class SpentIndexTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 4)\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        # Nodes 0/1 are \"wallet\" nodes\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-spentindex\"]))\n+        # Nodes 2/3 are used for testing\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\", \"-spentindex\"]))\n+        self.nodes.append(start_node(3, self.options.tmpdir, [\"-debug\", \"-spentindex\", \"-txindex\"]))\n+        connect_nodes(self.nodes[0], 1)\n+        connect_nodes(self.nodes[0], 2)\n+        connect_nodes(self.nodes[0], 3)\n+\n+        self.is_network_split = False\n+        self.sync_all()\n+\n+    def run_test(self):\n+        print \"Mining blocks...\"\n+        self.nodes[0].generate(105)\n+        self.sync_all()\n+\n+        chain_height = self.nodes[1].getblockcount()\n+        assert_equal(chain_height, 105)\n+\n+        # Check that\n+        print \"Testing spent index...\"\n+\n+        privkey = \"cSdkPxkAjA4HDr5VHgsebAPDEh9Gyub4HK8UJr2DFGGqKKy4K5sG\"\n+        address = \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\"\n+        addressHash = \"0b2f0a0c31bfe0406b0ccc1381fdbe311946dadc\".decode(\"hex\")\n+        scriptPubKey = CScript([OP_DUP, OP_HASH160, addressHash, OP_EQUALVERIFY, OP_CHECKSIG])\n+        unspent = self.nodes[0].listunspent()\n+        tx = CTransaction()\n+        amount = unspent[0][\"amount\"] * 100000000\n+        tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n+        tx.vout = [CTxOut(amount, scriptPubKey)]\n+        tx.rehash()\n+\n+        signed_tx = self.nodes[0].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        txid = self.nodes[0].sendrawtransaction(signed_tx[\"hex\"], True)\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        print \"Testing getspentinfo method...\"\n+\n+        # Check that the spentinfo works standalone\n+        info = self.nodes[1].getspentinfo({\"txid\": unspent[0][\"txid\"], \"index\": unspent[0][\"vout\"]})\n+        assert_equal(info[\"txid\"], txid)\n+        assert_equal(info[\"index\"], 0)\n+        assert_equal(info[\"height\"], 106)\n+\n+        print \"Testing getrawtransaction method...\"\n+\n+        # Check that verbose raw transaction includes spent info\n+        txVerbose = self.nodes[3].getrawtransaction(unspent[0][\"txid\"], 1)\n+        assert_equal(txVerbose[\"vout\"][unspent[0][\"vout\"]][\"spentTxId\"], txid)\n+        assert_equal(txVerbose[\"vout\"][unspent[0][\"vout\"]][\"spentIndex\"], 0)\n+        assert_equal(txVerbose[\"vout\"][unspent[0][\"vout\"]][\"spentHeight\"], 106)\n+\n+        # Check that verbose raw transaction includes input values\n+        txVerbose2 = self.nodes[3].getrawtransaction(txid, 1)\n+        assert_equal(txVerbose2[\"vin\"][0][\"value\"], Decimal(unspent[0][\"amount\"]))\n+        assert_equal(txVerbose2[\"vin\"][0][\"valueSat\"], amount)\n+\n+        # Check that verbose raw transaction includes address values and input values\n+        privkey2 = \"cSdkPxkAjA4HDr5VHgsebAPDEh9Gyub4HK8UJr2DFGGqKKy4K5sG\"\n+        address2 = \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\"\n+        addressHash2 = \"0b2f0a0c31bfe0406b0ccc1381fdbe311946dadc\".decode(\"hex\")\n+        scriptPubKey2 = CScript([OP_DUP, OP_HASH160, addressHash2, OP_EQUALVERIFY, OP_CHECKSIG])\n+        tx2 = CTransaction()\n+        tx2.vin = [CTxIn(COutPoint(int(txid, 16), 0))]\n+        tx2.vout = [CTxOut(amount, scriptPubKey2)]\n+        tx.rehash()\n+        self.nodes[0].importprivkey(privkey)\n+        signed_tx2 = self.nodes[0].signrawtransaction(binascii.hexlify(tx2.serialize()).decode(\"utf-8\"))\n+        txid2 = self.nodes[0].sendrawtransaction(signed_tx2[\"hex\"], True)\n+\n+        # Check the mempool index\n+        self.sync_all()\n+        txVerbose3 = self.nodes[1].getrawtransaction(txid2, 1)\n+        assert_equal(txVerbose3[\"vin\"][0][\"address\"], address2)\n+        assert_equal(txVerbose3[\"vin\"][0][\"value\"], Decimal(unspent[0][\"amount\"]))\n+        assert_equal(txVerbose3[\"vin\"][0][\"valueSat\"], amount)\n+\n+        # Check the database index\n+        block_hash = self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        txVerbose4 = self.nodes[3].getrawtransaction(txid2, 1)\n+        assert_equal(txVerbose4[\"vin\"][0][\"address\"], address2)\n+        assert_equal(txVerbose4[\"vin\"][0][\"value\"], Decimal(unspent[0][\"amount\"]))\n+        assert_equal(txVerbose4[\"vin\"][0][\"valueSat\"], amount)\n+\n+\n+        # Check block deltas\n+        print \"Testing getblockdeltas...\"\n+\n+        block = self.nodes[3].getblockdeltas(block_hash[0])\n+        assert_equal(len(block[\"deltas\"]), 2)\n+        assert_equal(block[\"deltas\"][0][\"index\"], 0)\n+        assert_equal(len(block[\"deltas\"][0][\"inputs\"]), 0)\n+        assert_equal(len(block[\"deltas\"][0][\"outputs\"]), 0)\n+        assert_equal(block[\"deltas\"][1][\"index\"], 1)\n+        assert_equal(block[\"deltas\"][1][\"txid\"], txid2)\n+        assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"index\"], 0)\n+        assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"address\"], \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\")\n+        assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"satoshis\"], amount * -1)\n+        assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"prevtxid\"], txid)\n+        assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"prevout\"], 0)\n+        assert_equal(block[\"deltas\"][1][\"outputs\"][0][\"index\"], 0)\n+        assert_equal(block[\"deltas\"][1][\"outputs\"][0][\"address\"], \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\")\n+        assert_equal(block[\"deltas\"][1][\"outputs\"][0][\"satoshis\"], amount)\n+\n+        print \"Passed\\n\"\n+\n+\n+if __name__ == '__main__':\n+    SpentIndexTest().main()"
      },
      {
        "sha": "289c81b2a5212df1c623d4aaced5bda32a1906c3",
        "filename": "qa/rpc-tests/timestampindex.py",
        "status": "added",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c/qa/rpc-tests/timestampindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c/qa/rpc-tests/timestampindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/timestampindex.py?ref=d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c",
        "patch": "@@ -0,0 +1,61 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test timestampindex generation and fetching\n+#\n+\n+import time\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+\n+class TimestampIndexTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 4)\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        # Nodes 0/1 are \"wallet\" nodes\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-timestampindex\"]))\n+        # Nodes 2/3 are used for testing\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\"]))\n+        self.nodes.append(start_node(3, self.options.tmpdir, [\"-debug\", \"-timestampindex\"]))\n+        connect_nodes(self.nodes[0], 1)\n+        connect_nodes(self.nodes[0], 2)\n+        connect_nodes(self.nodes[0], 3)\n+\n+        self.is_network_split = False\n+        self.sync_all()\n+\n+    def run_test(self):\n+        print \"Mining 25 blocks...\"\n+        blockhashes = self.nodes[0].generate(25)\n+        time.sleep(3)\n+        print \"Mining 25 blocks...\"\n+        blockhashes.extend(self.nodes[0].generate(25))\n+        time.sleep(3)\n+        print \"Mining 25 blocks...\"\n+        blockhashes.extend(self.nodes[0].generate(25))\n+        self.sync_all()\n+        low = self.nodes[1].getblock(blockhashes[0])[\"time\"]\n+        high = low + 76\n+\n+        print \"Checking timestamp index...\"\n+        hashes = self.nodes[1].getblockhashes(high, low)\n+\n+        assert_equal(len(hashes), len(blockhashes))\n+\n+        assert_equal(hashes, blockhashes)\n+\n+        print \"Passed\\n\"\n+\n+\n+if __name__ == '__main__':\n+    TimestampIndexTest().main()"
      },
      {
        "sha": "b139253b769ec2a7ecb51bf94f463291bb6a0a28",
        "filename": "qa/rpc-tests/txindex.py",
        "status": "added",
        "additions": 73,
        "deletions": 0,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c/qa/rpc-tests/txindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c/qa/rpc-tests/txindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/txindex.py?ref=d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c",
        "patch": "@@ -0,0 +1,73 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test txindex generation and fetching\n+#\n+\n+import time\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.script import *\n+from test_framework.mininode import *\n+import binascii\n+\n+class TxIndexTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 4)\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        # Nodes 0/1 are \"wallet\" nodes\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-txindex\"]))\n+        # Nodes 2/3 are used for testing\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\", \"-txindex\"]))\n+        self.nodes.append(start_node(3, self.options.tmpdir, [\"-debug\", \"-txindex\"]))\n+        connect_nodes(self.nodes[0], 1)\n+        connect_nodes(self.nodes[0], 2)\n+        connect_nodes(self.nodes[0], 3)\n+\n+        self.is_network_split = False\n+        self.sync_all()\n+\n+    def run_test(self):\n+        print \"Mining blocks...\"\n+        self.nodes[0].generate(105)\n+        self.sync_all()\n+\n+        chain_height = self.nodes[1].getblockcount()\n+        assert_equal(chain_height, 105)\n+\n+        print \"Testing transaction index...\"\n+\n+        privkey = \"cSdkPxkAjA4HDr5VHgsebAPDEh9Gyub4HK8UJr2DFGGqKKy4K5sG\"\n+        address = \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\"\n+        addressHash = \"0b2f0a0c31bfe0406b0ccc1381fdbe311946dadc\".decode(\"hex\")\n+        scriptPubKey = CScript([OP_DUP, OP_HASH160, addressHash, OP_EQUALVERIFY, OP_CHECKSIG])\n+        unspent = self.nodes[0].listunspent()\n+        tx = CTransaction()\n+        amount = unspent[0][\"amount\"] * 100000000\n+        tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n+        tx.vout = [CTxOut(amount, scriptPubKey)]\n+        tx.rehash()\n+\n+        signed_tx = self.nodes[0].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        txid = self.nodes[0].sendrawtransaction(signed_tx[\"hex\"], True)\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        # Check verbose raw transaction results\n+        verbose = self.nodes[3].getrawtransaction(unspent[0][\"txid\"], 1)\n+        assert_equal(verbose[\"vout\"][0][\"valueSat\"], 5000000000);\n+        assert_equal(verbose[\"vout\"][0][\"value\"], 50);\n+\n+        print \"Passed\\n\"\n+\n+\n+if __name__ == '__main__':\n+    TxIndexTest().main()"
      }
    ]
  },
  {
    "sha": "e151d694149bd543dd94bab18d428325c9dc6d09",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMTUxZDY5NDE0OWJkNTQzZGQ5NGJhYjE4ZDQyODMyNWM5ZGM2ZDA5",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-04T19:03:13Z"
      },
      "committer": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-05T16:47:04Z"
      },
      "message": "tests: adds unit test for IsPayToPublicKeyHash method",
      "tree": {
        "sha": "6212fbc1e66e0c7e7c3cf9c96151c347452dcdd7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6212fbc1e66e0c7e7c3cf9c96151c347452dcdd7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e151d694149bd543dd94bab18d428325c9dc6d09",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e151d694149bd543dd94bab18d428325c9dc6d09",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e151d694149bd543dd94bab18d428325c9dc6d09",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e151d694149bd543dd94bab18d428325c9dc6d09/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d60edd3f8da3ae7b60d49b9a0c97f2cd0fbe5e0c"
      }
    ],
    "stats": {
      "total": 60,
      "additions": 60,
      "deletions": 0
    },
    "files": [
      {
        "sha": "22031da95f94ceb56427c672c87e51168125e170",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e151d694149bd543dd94bab18d428325c9dc6d09/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e151d694149bd543dd94bab18d428325c9dc6d09/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=e151d694149bd543dd94bab18d428325c9dc6d09",
        "patch": "@@ -72,6 +72,7 @@ BITCOIN_TESTS =\\\n   test/sanity_tests.cpp \\\n   test/scheduler_tests.cpp \\\n   test/script_P2SH_tests.cpp \\\n+  test/script_P2PKH_tests.cpp \\\n   test/script_tests.cpp \\\n   test/scriptnum_tests.cpp \\\n   test/serialize_tests.cpp \\"
      },
      {
        "sha": "3a7dc16608aaac610bf97577a66cf4038d3f4396",
        "filename": "src/test/script_P2PKH_tests.cpp",
        "status": "added",
        "additions": 59,
        "deletions": 0,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e151d694149bd543dd94bab18d428325c9dc6d09/src/test/script_P2PKH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e151d694149bd543dd94bab18d428325c9dc6d09/src/test/script_P2PKH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2PKH_tests.cpp?ref=e151d694149bd543dd94bab18d428325c9dc6d09",
        "patch": "@@ -0,0 +1,59 @@\n+// Copyright (c) 2012-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"script/script.h\"\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+using namespace std;\n+\n+BOOST_FIXTURE_TEST_SUITE(script_P2PKH_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(IsPayToPublicKeyHash)\n+{\n+    // Test CScript::IsPayToPublicKeyHash()\n+    uint160 dummy;\n+    CScript p2pkh;\n+    p2pkh << OP_DUP << OP_HASH160 << ToByteVector(dummy) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(p2pkh.IsPayToPublicKeyHash());\n+\n+    static const unsigned char direct[] = {\n+        OP_DUP, OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUALVERIFY, OP_CHECKSIG\n+    };\n+    BOOST_CHECK(CScript(direct, direct+sizeof(direct)).IsPayToPublicKeyHash());\n+\n+    static const unsigned char notp2pkh1[] = {\n+        OP_DUP, OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUALVERIFY, OP_CHECKSIG, OP_CHECKSIG\n+    };\n+    BOOST_CHECK(!CScript(notp2pkh1, notp2pkh1+sizeof(notp2pkh1)).IsPayToPublicKeyHash());\n+\n+    static const unsigned char p2sh[] = {\n+        OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL\n+    };\n+    BOOST_CHECK(!CScript(p2sh, p2sh+sizeof(p2sh)).IsPayToPublicKeyHash());\n+\n+    static const unsigned char extra[] = {\n+        OP_DUP, OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUALVERIFY, OP_CHECKSIG, OP_CHECKSIG\n+    };\n+    BOOST_CHECK(!CScript(extra, extra+sizeof(extra)).IsPayToPublicKeyHash());\n+\n+    static const unsigned char missing[] = {\n+        OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUALVERIFY, OP_CHECKSIG, OP_RETURN\n+    };\n+    BOOST_CHECK(!CScript(missing, missing+sizeof(missing)).IsPayToPublicKeyHash());\n+\n+    static const unsigned char missing2[] = {\n+        OP_DUP, OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+    };\n+    BOOST_CHECK(!CScript(missing2, missing2+sizeof(missing)).IsPayToPublicKeyHash());\n+\n+    static const unsigned char tooshort[] = {\n+        OP_DUP, OP_HASH160, 2, 0,0, OP_EQUALVERIFY, OP_CHECKSIG\n+    };\n+    BOOST_CHECK(!CScript(tooshort, tooshort+sizeof(direct)).IsPayToPublicKeyHash());\n+\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "5839cc2524971c1b38e1c49ba2d028d22162120a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ODM5Y2MyNTI0OTcxYzFiMzhlMWM0OWJhMmQwMjhkMjIxNjIxMjBh",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-05T18:21:25Z"
      },
      "committer": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-05T23:28:22Z"
      },
      "message": "indexes: refactoring and fixes applying changes to 0.13",
      "tree": {
        "sha": "faf50fe5997c6711479388e533cc88d4a10da5b9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/faf50fe5997c6711479388e533cc88d4a10da5b9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5839cc2524971c1b38e1c49ba2d028d22162120a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5839cc2524971c1b38e1c49ba2d028d22162120a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5839cc2524971c1b38e1c49ba2d028d22162120a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5839cc2524971c1b38e1c49ba2d028d22162120a/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "e151d694149bd543dd94bab18d428325c9dc6d09",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e151d694149bd543dd94bab18d428325c9dc6d09",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e151d694149bd543dd94bab18d428325c9dc6d09"
      }
    ],
    "stats": {
      "total": 791,
      "additions": 401,
      "deletions": 390
    },
    "files": [
      {
        "sha": "dbb09c7fe9b4c4e2d76a1facdc57d031520c498f",
        "filename": "src/addressindex.h",
        "status": "modified",
        "additions": 213,
        "deletions": 0,
        "changes": 213,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5839cc2524971c1b38e1c49ba2d028d22162120a/src/addressindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5839cc2524971c1b38e1c49ba2d028d22162120a/src/addressindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addressindex.h?ref=5839cc2524971c1b38e1c49ba2d028d22162120a",
        "patch": "@@ -8,6 +8,219 @@\n \n #include \"uint256.h\"\n #include \"amount.h\"\n+#include \"script/script.h\"\n+\n+struct CAddressUnspentKey {\n+    unsigned int type;\n+    uint160 hashBytes;\n+    uint256 txhash;\n+    size_t index;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 57;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata8(s, type);\n+        hashBytes.Serialize(s, nType, nVersion);\n+        txhash.Serialize(s, nType, nVersion);\n+        ser_writedata32(s, index);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        type = ser_readdata8(s);\n+        hashBytes.Unserialize(s, nType, nVersion);\n+        txhash.Unserialize(s, nType, nVersion);\n+        index = ser_readdata32(s);\n+    }\n+\n+    CAddressUnspentKey(unsigned int addressType, uint160 addressHash, uint256 txid, size_t indexValue) {\n+        type = addressType;\n+        hashBytes = addressHash;\n+        txhash = txid;\n+        index = indexValue;\n+    }\n+\n+    CAddressUnspentKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        type = 0;\n+        hashBytes.SetNull();\n+        txhash.SetNull();\n+        index = 0;\n+    }\n+};\n+\n+struct CAddressUnspentValue {\n+    CAmount satoshis;\n+    CScript script;\n+    int blockHeight;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(satoshis);\n+        READWRITE(*(CScriptBase*)(&script));\n+        READWRITE(blockHeight);\n+    }\n+\n+    CAddressUnspentValue(CAmount sats, CScript scriptPubKey, int height) {\n+        satoshis = sats;\n+        script = scriptPubKey;\n+        blockHeight = height;\n+    }\n+\n+    CAddressUnspentValue() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        satoshis = -1;\n+        script.clear();\n+        blockHeight = 0;\n+    }\n+\n+    bool IsNull() const {\n+        return (satoshis == -1);\n+    }\n+};\n+\n+struct CAddressIndexKey {\n+    unsigned int type;\n+    uint160 hashBytes;\n+    int blockHeight;\n+    unsigned int txindex;\n+    uint256 txhash;\n+    size_t index;\n+    bool spending;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 66;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata8(s, type);\n+        hashBytes.Serialize(s, nType, nVersion);\n+        // Heights are stored big-endian for key sorting in LevelDB\n+        ser_writedata32be(s, blockHeight);\n+        ser_writedata32be(s, txindex);\n+        txhash.Serialize(s, nType, nVersion);\n+        ser_writedata32(s, index);\n+        char f = spending;\n+        ser_writedata8(s, f);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        type = ser_readdata8(s);\n+        hashBytes.Unserialize(s, nType, nVersion);\n+        blockHeight = ser_readdata32be(s);\n+        txindex = ser_readdata32be(s);\n+        txhash.Unserialize(s, nType, nVersion);\n+        index = ser_readdata32(s);\n+        char f = ser_readdata8(s);\n+        spending = f;\n+    }\n+\n+    CAddressIndexKey(unsigned int addressType, uint160 addressHash, int height, int blockindex,\n+                     uint256 txid, size_t indexValue, bool isSpending) {\n+        type = addressType;\n+        hashBytes = addressHash;\n+        blockHeight = height;\n+        txindex = blockindex;\n+        txhash = txid;\n+        index = indexValue;\n+        spending = isSpending;\n+    }\n+\n+    CAddressIndexKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        type = 0;\n+        hashBytes.SetNull();\n+        blockHeight = 0;\n+        txindex = 0;\n+        txhash.SetNull();\n+        index = 0;\n+        spending = false;\n+    }\n+\n+};\n+\n+struct CAddressIndexIteratorKey {\n+    unsigned int type;\n+    uint160 hashBytes;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 21;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata8(s, type);\n+        hashBytes.Serialize(s, nType, nVersion);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        type = ser_readdata8(s);\n+        hashBytes.Unserialize(s, nType, nVersion);\n+    }\n+\n+    CAddressIndexIteratorKey(unsigned int addressType, uint160 addressHash) {\n+        type = addressType;\n+        hashBytes = addressHash;\n+    }\n+\n+    CAddressIndexIteratorKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        type = 0;\n+        hashBytes.SetNull();\n+    }\n+};\n+\n+struct CAddressIndexIteratorHeightKey {\n+    unsigned int type;\n+    uint160 hashBytes;\n+    int blockHeight;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 25;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata8(s, type);\n+        hashBytes.Serialize(s, nType, nVersion);\n+        ser_writedata32be(s, blockHeight);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        type = ser_readdata8(s);\n+        hashBytes.Unserialize(s, nType, nVersion);\n+        blockHeight = ser_readdata32be(s);\n+    }\n+\n+    CAddressIndexIteratorHeightKey(unsigned int addressType, uint160 addressHash, int height) {\n+        type = addressType;\n+        hashBytes = addressHash;\n+        blockHeight = height;\n+    }\n+\n+    CAddressIndexIteratorHeightKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        type = 0;\n+        hashBytes.SetNull();\n+        blockHeight = 0;\n+    }\n+};\n \n struct CMempoolAddressDelta\n {"
      },
      {
        "sha": "c90f8273b0cc9e439f520ab257f6f69775d7e83e",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5839cc2524971c1b38e1c49ba2d028d22162120a/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5839cc2524971c1b38e1c49ba2d028d22162120a/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=5839cc2524971c1b38e1c49ba2d028d22162120a",
        "patch": "@@ -1601,6 +1601,17 @@ bool GetSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value)\n     return true;\n }\n \n+bool HashOnchainActive(const uint256 &hash)\n+{\n+    CBlockIndex* pblockindex = mapBlockIndex[hash];\n+\n+    if (!chainActive.Contains(pblockindex)) {\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n bool GetAddressIndex(uint160 addressHash, int type,\n                      std::vector<std::pair<CAddressIndexKey, CAmount> > &addressIndex, int start, int end)\n {"
      },
      {
        "sha": "3119fc49062311cc3320c9e84411a61d42035f11",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 3,
        "deletions": 332,
        "changes": 335,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5839cc2524971c1b38e1c49ba2d028d22162120a/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5839cc2524971c1b38e1c49ba2d028d22162120a/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=5839cc2524971c1b38e1c49ba2d028d22162120a",
        "patch": "@@ -18,6 +18,8 @@\n #include \"sync.h\"\n #include \"versionbits.h\"\n #include \"spentindex.h\"\n+#include \"addressindex.h\"\n+#include \"timestampindex.h\"\n \n #include <algorithm>\n #include <exception>\n@@ -318,338 +320,6 @@ struct CNodeStateStats {\n     std::vector<int> vHeightInFlight;\n };\n \n-struct CTimestampIndexIteratorKey {\n-    unsigned int timestamp;\n-\n-    size_t GetSerializeSize(int nType, int nVersion) const {\n-        return 4;\n-    }\n-    template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n-        ser_writedata32be(s, timestamp);\n-    }\n-    template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n-        timestamp = ser_readdata32be(s);\n-    }\n-\n-    CTimestampIndexIteratorKey(unsigned int time) {\n-        timestamp = time;\n-    }\n-\n-    CTimestampIndexIteratorKey() {\n-        SetNull();\n-    }\n-\n-    void SetNull() {\n-        timestamp = 0;\n-    }\n-};\n-\n-struct CTimestampIndexKey {\n-    unsigned int timestamp;\n-    uint256 blockHash;\n-\n-    size_t GetSerializeSize(int nType, int nVersion) const {\n-        return 36;\n-    }\n-    template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n-        ser_writedata32be(s, timestamp);\n-        blockHash.Serialize(s, nType, nVersion);\n-    }\n-    template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n-        timestamp = ser_readdata32be(s);\n-        blockHash.Unserialize(s, nType, nVersion);\n-    }\n-\n-    CTimestampIndexKey(unsigned int time, uint256 hash) {\n-        timestamp = time;\n-        blockHash = hash;\n-    }\n-\n-    CTimestampIndexKey() {\n-        SetNull();\n-    }\n-\n-    void SetNull() {\n-        timestamp = 0;\n-        blockHash.SetNull();\n-    }\n-};\n-\n-struct CTimestampBlockIndexKey {\n-    uint256 blockHash;\n-\n-    size_t GetSerializeSize(int nType, int nVersion) const {\n-        return 32;\n-    }\n-\n-    template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n-        blockHash.Serialize(s, nType, nVersion);\n-    }\n-\n-    template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n-        blockHash.Unserialize(s, nType, nVersion);\n-    }\n-\n-    CTimestampBlockIndexKey(uint256 hash) {\n-        blockHash = hash;\n-    }\n-\n-    CTimestampBlockIndexKey() {\n-        SetNull();\n-    }\n-\n-    void SetNull() {\n-        blockHash.SetNull();\n-    }\n-};\n-\n-struct CTimestampBlockIndexValue {\n-    unsigned int ltimestamp;\n-    size_t GetSerializeSize(int nType, int nVersion) const {\n-        return 4;\n-    }\n-\n-    template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n-        ser_writedata32be(s, ltimestamp);\n-    }\n-\n-    template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n-        ltimestamp = ser_readdata32be(s);\n-    }\n-\n-    CTimestampBlockIndexValue (unsigned int time) {\n-        ltimestamp = time;\n-    }\n-\n-    CTimestampBlockIndexValue() {\n-        SetNull();\n-    }\n-\n-    void SetNull() {\n-        ltimestamp = 0;\n-    }\n-};\n-\n-struct CAddressUnspentKey {\n-    unsigned int type;\n-    uint160 hashBytes;\n-    uint256 txhash;\n-    size_t index;\n-\n-    size_t GetSerializeSize(int nType, int nVersion) const {\n-        return 57;\n-    }\n-    template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n-        ser_writedata8(s, type);\n-        hashBytes.Serialize(s, nType, nVersion);\n-        txhash.Serialize(s, nType, nVersion);\n-        ser_writedata32(s, index);\n-    }\n-    template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n-        type = ser_readdata8(s);\n-        hashBytes.Unserialize(s, nType, nVersion);\n-        txhash.Unserialize(s, nType, nVersion);\n-        index = ser_readdata32(s);\n-    }\n-\n-    CAddressUnspentKey(unsigned int addressType, uint160 addressHash, uint256 txid, size_t indexValue) {\n-        type = addressType;\n-        hashBytes = addressHash;\n-        txhash = txid;\n-        index = indexValue;\n-    }\n-\n-    CAddressUnspentKey() {\n-        SetNull();\n-    }\n-\n-    void SetNull() {\n-        type = 0;\n-        hashBytes.SetNull();\n-        txhash.SetNull();\n-        index = 0;\n-    }\n-};\n-\n-struct CAddressUnspentValue {\n-    CAmount satoshis;\n-    CScript script;\n-    int blockHeight;\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-        READWRITE(satoshis);\n-        READWRITE(*(CScriptBase*)(&script));\n-        READWRITE(blockHeight);\n-    }\n-\n-    CAddressUnspentValue(CAmount sats, CScript scriptPubKey, int height) {\n-        satoshis = sats;\n-        script = scriptPubKey;\n-        blockHeight = height;\n-    }\n-\n-    CAddressUnspentValue() {\n-        SetNull();\n-    }\n-\n-    void SetNull() {\n-        satoshis = -1;\n-        script.clear();\n-        blockHeight = 0;\n-    }\n-\n-    bool IsNull() const {\n-        return (satoshis == -1);\n-    }\n-};\n-\n-struct CAddressIndexKey {\n-    unsigned int type;\n-    uint160 hashBytes;\n-    int blockHeight;\n-    unsigned int txindex;\n-    uint256 txhash;\n-    size_t index;\n-    bool spending;\n-\n-    size_t GetSerializeSize(int nType, int nVersion) const {\n-        return 66;\n-    }\n-    template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n-        ser_writedata8(s, type);\n-        hashBytes.Serialize(s, nType, nVersion);\n-        // Heights are stored big-endian for key sorting in LevelDB\n-        ser_writedata32be(s, blockHeight);\n-        ser_writedata32be(s, txindex);\n-        txhash.Serialize(s, nType, nVersion);\n-        ser_writedata32(s, index);\n-        char f = spending;\n-        ser_writedata8(s, f);\n-    }\n-    template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n-        type = ser_readdata8(s);\n-        hashBytes.Unserialize(s, nType, nVersion);\n-        blockHeight = ser_readdata32be(s);\n-        txindex = ser_readdata32be(s);\n-        txhash.Unserialize(s, nType, nVersion);\n-        index = ser_readdata32(s);\n-        char f = ser_readdata8(s);\n-        spending = f;\n-    }\n-\n-    CAddressIndexKey(unsigned int addressType, uint160 addressHash, int height, int blockindex,\n-                     uint256 txid, size_t indexValue, bool isSpending) {\n-        type = addressType;\n-        hashBytes = addressHash;\n-        blockHeight = height;\n-        txindex = blockindex;\n-        txhash = txid;\n-        index = indexValue;\n-        spending = isSpending;\n-    }\n-\n-    CAddressIndexKey() {\n-        SetNull();\n-    }\n-\n-    void SetNull() {\n-        type = 0;\n-        hashBytes.SetNull();\n-        blockHeight = 0;\n-        txindex = 0;\n-        txhash.SetNull();\n-        index = 0;\n-        spending = false;\n-    }\n-\n-};\n-\n-struct CAddressIndexIteratorKey {\n-    unsigned int type;\n-    uint160 hashBytes;\n-\n-    size_t GetSerializeSize(int nType, int nVersion) const {\n-        return 21;\n-    }\n-    template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n-        ser_writedata8(s, type);\n-        hashBytes.Serialize(s, nType, nVersion);\n-    }\n-    template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n-        type = ser_readdata8(s);\n-        hashBytes.Unserialize(s, nType, nVersion);\n-    }\n-\n-    CAddressIndexIteratorKey(unsigned int addressType, uint160 addressHash) {\n-        type = addressType;\n-        hashBytes = addressHash;\n-    }\n-\n-    CAddressIndexIteratorKey() {\n-        SetNull();\n-    }\n-\n-    void SetNull() {\n-        type = 0;\n-        hashBytes.SetNull();\n-    }\n-};\n-\n-struct CAddressIndexIteratorHeightKey {\n-    unsigned int type;\n-    uint160 hashBytes;\n-    int blockHeight;\n-\n-    size_t GetSerializeSize(int nType, int nVersion) const {\n-        return 25;\n-    }\n-    template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n-        ser_writedata8(s, type);\n-        hashBytes.Serialize(s, nType, nVersion);\n-        ser_writedata32be(s, blockHeight);\n-    }\n-    template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n-        type = ser_readdata8(s);\n-        hashBytes.Unserialize(s, nType, nVersion);\n-        blockHeight = ser_readdata32be(s);\n-    }\n-\n-    CAddressIndexIteratorHeightKey(unsigned int addressType, uint160 addressHash, int height) {\n-        type = addressType;\n-        hashBytes = addressHash;\n-        blockHeight = height;\n-    }\n-\n-    CAddressIndexIteratorHeightKey() {\n-        SetNull();\n-    }\n-\n-    void SetNull() {\n-        type = 0;\n-        hashBytes.SetNull();\n-        blockHeight = 0;\n-    }\n-};\n-\n /** \n  * Count ECDSA signature operations the old-fashioned (pre-0.6) way\n  * @return number of sigops this transaction's outputs will produce when spent\n@@ -766,6 +436,7 @@ class CScriptCheck\n \n bool GetTimestampIndex(const unsigned int &high, const unsigned int &low, const bool fActiveOnly, std::vector<std::pair<uint256, unsigned int> > &hashes);\n bool GetSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value);\n+bool HashOnchainActive(const uint256 &hash);\n bool GetAddressIndex(uint160 addressHash, int type,\n                      std::vector<std::pair<CAddressIndexKey, CAmount> > &addressIndex,\n                      int start = 0, int end = 0);"
      },
      {
        "sha": "e347fbb4ca2d1fd21b0fc4d589bb076efe9fe644",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5839cc2524971c1b38e1c49ba2d028d22162120a/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5839cc2524971c1b38e1c49ba2d028d22162120a/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=5839cc2524971c1b38e1c49ba2d028d22162120a",
        "patch": "@@ -1412,7 +1412,6 @@ static const CRPCCommand commands[] =\n     { \"blockchain\",         \"gettxout\",               &gettxout,               true  },\n     { \"blockchain\",         \"gettxoutsetinfo\",        &gettxoutsetinfo,        true  },\n     { \"blockchain\",         \"verifychain\",            &verifychain,            true  },\n-    { \"blockchain\",         \"getspentinfo\",           &getspentinfo,           false },\n \n     /* Not shown in help */\n     { \"hidden\",             \"invalidateblock\",        &invalidateblock,        true  },"
      },
      {
        "sha": "715b371f27b58620aaa237d3d0325ea4538ec647",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 27,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5839cc2524971c1b38e1c49ba2d028d22162120a/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5839cc2524971c1b38e1c49ba2d028d22162120a/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=5839cc2524971c1b38e1c49ba2d028d22162120a",
        "patch": "@@ -485,33 +485,6 @@ UniValue setmocktime(const UniValue& params, bool fHelp)\n     return NullUniValue;\n }\n \n-static const CRPCCommand commands[] =\n-{ //  category              name                      actor (function)         okSafeMode\n-  //  --------------------- ------------------------  -----------------------  ----------\n-    { \"control\",            \"getinfo\",                &getinfo,                true  }, /* uses wallet if enabled */\n-    { \"util\",               \"validateaddress\",        &validateaddress,        true  }, /* uses wallet if enabled */\n-    { \"util\",               \"createmultisig\",         &createmultisig,         true  },\n-    { \"util\",               \"createwitnessaddress\",   &createwitnessaddress,   true  },\n-    { \"util\",               \"verifymessage\",          &verifymessage,          true  },\n-    { \"util\",               \"signmessagewithprivkey\", &signmessagewithprivkey, true  },\n-\n-    /* Address index */\n-    { \"addressindex\",       \"getaddressmempool\",      &getaddressmempool,      true  },\n-    { \"addressindex\",       \"getaddressutxos\",        &getaddressutxos,        false },\n-    { \"addressindex\",       \"getaddressdeltas\",       &getaddressdeltas,       false },\n-    { \"addressindex\",       \"getaddresstxids\",        &getaddresstxids,        false },\n-    { \"addressindex\",       \"getaddressbalance\",      &getaddressbalance,      false },\n-\n-    /* Not shown in help */\n-    { \"hidden\",             \"setmocktime\",            &setmocktime,            true  },\n-};\n-\n-void RegisterMiscRPCCommands(CRPCTable &tableRPC)\n-{\n-    for (unsigned int vcidx = 0; vcidx < ARRAYLEN(commands); vcidx++)\n-        tableRPC.appendCommand(commands[vcidx].name, &commands[vcidx]);\n-}\n-\n bool getAddressFromIndex(const int &type, const uint160 &hash, std::string &address)\n {\n     if (type == 2) {\n@@ -1038,3 +1011,33 @@ UniValue getspentinfo(const UniValue& params, bool fHelp)\n \n     return obj;\n }\n+\n+static const CRPCCommand commands[] =\n+{ //  category              name                      actor (function)         okSafeMode\n+  //  --------------------- ------------------------  -----------------------  ----------\n+    { \"control\",            \"getinfo\",                &getinfo,                true  }, /* uses wallet if enabled */\n+    { \"util\",               \"validateaddress\",        &validateaddress,        true  }, /* uses wallet if enabled */\n+    { \"util\",               \"createmultisig\",         &createmultisig,         true  },\n+    { \"util\",               \"createwitnessaddress\",   &createwitnessaddress,   true  },\n+    { \"util\",               \"verifymessage\",          &verifymessage,          true  },\n+    { \"util\",               \"signmessagewithprivkey\", &signmessagewithprivkey, true  },\n+\n+    /* Address index */\n+    { \"addressindex\",       \"getaddressmempool\",      &getaddressmempool,      true  },\n+    { \"addressindex\",       \"getaddressutxos\",        &getaddressutxos,        false },\n+    { \"addressindex\",       \"getaddressdeltas\",       &getaddressdeltas,       false },\n+    { \"addressindex\",       \"getaddresstxids\",        &getaddresstxids,        false },\n+    { \"addressindex\",       \"getaddressbalance\",      &getaddressbalance,      false },\n+\n+    /* Blockchain */\n+    { \"blockchain\",         \"getspentinfo\",           &getspentinfo,           false },\n+\n+    /* Not shown in help */\n+    { \"hidden\",             \"setmocktime\",            &setmocktime,            true  },\n+};\n+\n+void RegisterMiscRPCCommands(CRPCTable &tableRPC)\n+{\n+    for (unsigned int vcidx = 0; vcidx < ARRAYLEN(commands); vcidx++)\n+        tableRPC.appendCommand(commands[vcidx].name, &commands[vcidx]);\n+}"
      },
      {
        "sha": "e84baf7bc0050a04eeaf8eaa7da0c375f38bae23",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5839cc2524971c1b38e1c49ba2d028d22162120a/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5839cc2524971c1b38e1c49ba2d028d22162120a/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=5839cc2524971c1b38e1c49ba2d028d22162120a",
        "patch": "@@ -71,7 +71,8 @@ void TxToJSONExpanded(const CTransaction& tx, const uint256 hashBlock, UniValue&\n     entry.push_back(Pair(\"version\", tx.nVersion));\n     entry.push_back(Pair(\"locktime\", (int64_t)tx.nLockTime));\n     UniValue vin(UniValue::VARR);\n-    BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n+    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+        const CTxIn& txin = tx.vin[i];\n         UniValue in(UniValue::VOBJ);\n         if (tx.IsCoinBase())\n             in.push_back(Pair(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));"
      },
      {
        "sha": "ea792797e18e1bef590c0e8798fb9cfa28c67a3a",
        "filename": "src/timestampindex.h",
        "status": "added",
        "additions": 131,
        "deletions": 0,
        "changes": 131,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5839cc2524971c1b38e1c49ba2d028d22162120a/src/timestampindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5839cc2524971c1b38e1c49ba2d028d22162120a/src/timestampindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timestampindex.h?ref=5839cc2524971c1b38e1c49ba2d028d22162120a",
        "patch": "@@ -0,0 +1,131 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TIMESTAMPINDEX_H\n+#define BITCOIN_TIMESTAMPINDEX_H\n+\n+#include \"uint256.h\"\n+\n+struct CTimestampIndexIteratorKey {\n+    unsigned int timestamp;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 4;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata32be(s, timestamp);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        timestamp = ser_readdata32be(s);\n+    }\n+\n+    CTimestampIndexIteratorKey(unsigned int time) {\n+        timestamp = time;\n+    }\n+\n+    CTimestampIndexIteratorKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        timestamp = 0;\n+    }\n+};\n+\n+struct CTimestampIndexKey {\n+    unsigned int timestamp;\n+    uint256 blockHash;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 36;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata32be(s, timestamp);\n+        blockHash.Serialize(s, nType, nVersion);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        timestamp = ser_readdata32be(s);\n+        blockHash.Unserialize(s, nType, nVersion);\n+    }\n+\n+    CTimestampIndexKey(unsigned int time, uint256 hash) {\n+        timestamp = time;\n+        blockHash = hash;\n+    }\n+\n+    CTimestampIndexKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        timestamp = 0;\n+        blockHash.SetNull();\n+    }\n+};\n+\n+struct CTimestampBlockIndexKey {\n+    uint256 blockHash;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 32;\n+    }\n+\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        blockHash.Serialize(s, nType, nVersion);\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        blockHash.Unserialize(s, nType, nVersion);\n+    }\n+\n+    CTimestampBlockIndexKey(uint256 hash) {\n+        blockHash = hash;\n+    }\n+\n+    CTimestampBlockIndexKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        blockHash.SetNull();\n+    }\n+};\n+\n+struct CTimestampBlockIndexValue {\n+    unsigned int ltimestamp;\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 4;\n+    }\n+\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata32be(s, ltimestamp);\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        ltimestamp = ser_readdata32be(s);\n+    }\n+\n+    CTimestampBlockIndexValue (unsigned int time) {\n+        ltimestamp = time;\n+    }\n+\n+    CTimestampBlockIndexValue() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        ltimestamp = 0;\n+    }\n+};\n+\n+#endif // BITCOIN_TIMESTAMPINDEX_H"
      },
      {
        "sha": "2849f6628749ab5e901226e6515dede0f9504657",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 17,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5839cc2524971c1b38e1c49ba2d028d22162120a/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5839cc2524971c1b38e1c49ba2d028d22162120a/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=5839cc2524971c1b38e1c49ba2d028d22162120a",
        "patch": "@@ -169,7 +169,7 @@ bool CBlockTreeDB::ReadSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value)\n }\n \n bool CBlockTreeDB::UpdateSpentIndex(const std::vector<std::pair<CSpentIndexKey, CSpentIndexValue> >&vect) {\n-    CDBBatch batch(&GetObfuscateKey());\n+    CDBBatch batch(*this);\n     for (std::vector<std::pair<CSpentIndexKey,CSpentIndexValue> >::const_iterator it=vect.begin(); it!=vect.end(); it++) {\n         if (it->second.IsNull()) {\n             batch.Erase(make_pair(DB_SPENTINDEX, it->first));\n@@ -181,7 +181,7 @@ bool CBlockTreeDB::UpdateSpentIndex(const std::vector<std::pair<CSpentIndexKey,\n }\n \n bool CBlockTreeDB::UpdateAddressUnspentIndex(const std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue > >&vect) {\n-    CDBBatch batch(&GetObfuscateKey());\n+    CDBBatch batch(*this);\n     for (std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> >::const_iterator it=vect.begin(); it!=vect.end(); it++) {\n         if (it->second.IsNull()) {\n             batch.Erase(make_pair(DB_ADDRESSUNSPENTINDEX, it->first));\n@@ -219,14 +219,14 @@ bool CBlockTreeDB::ReadAddressUnspentIndex(uint160 addressHash, int type,\n }\n \n bool CBlockTreeDB::WriteAddressIndex(const std::vector<std::pair<CAddressIndexKey, CAmount > >&vect) {\n-    CDBBatch batch(&GetObfuscateKey());\n+    CDBBatch batch(*this);\n     for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=vect.begin(); it!=vect.end(); it++)\n         batch.Write(make_pair(DB_ADDRESSINDEX, it->first), it->second);\n     return WriteBatch(batch);\n }\n \n bool CBlockTreeDB::EraseAddressIndex(const std::vector<std::pair<CAddressIndexKey, CAmount > >&vect) {\n-    CDBBatch batch(&GetObfuscateKey());\n+    CDBBatch batch(*this);\n     for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=vect.begin(); it!=vect.end(); it++)\n         batch.Erase(make_pair(DB_ADDRESSINDEX, it->first));\n     return WriteBatch(batch);\n@@ -267,7 +267,7 @@ bool CBlockTreeDB::ReadAddressIndex(uint160 addressHash, int type,\n }\n \n bool CBlockTreeDB::WriteTimestampIndex(const CTimestampIndexKey &timestampIndex) {\n-    CDBBatch batch(&GetObfuscateKey());\n+    CDBBatch batch(*this);\n     batch.Write(make_pair(DB_TIMESTAMPINDEX, timestampIndex), 0);\n     return WriteBatch(batch);\n }\n@@ -283,7 +283,7 @@ bool CBlockTreeDB::ReadTimestampIndex(const unsigned int &high, const unsigned i\n         std::pair<char, CTimestampIndexKey> key;\n         if (pcursor->GetKey(key) && key.first == DB_TIMESTAMPINDEX && key.second.timestamp < high) {\n             if (fActiveOnly) {\n-                if (blockOnchainActive(key.second.blockHash)) {\n+                if (HashOnchainActive(key.second.blockHash)) {\n                     hashes.push_back(std::make_pair(key.second.blockHash, key.second.timestamp));\n                 }\n             } else {\n@@ -300,7 +300,7 @@ bool CBlockTreeDB::ReadTimestampIndex(const unsigned int &high, const unsigned i\n }\n \n bool CBlockTreeDB::WriteTimestampBlockIndex(const CTimestampBlockIndexKey &blockhashIndex, const CTimestampBlockIndexValue &logicalts) {\n-    CDBBatch batch(&GetObfuscateKey());\n+    CDBBatch batch(*this);\n     batch.Write(make_pair(DB_BLOCKHASHINDEX, blockhashIndex), logicalts);\n     return WriteBatch(batch);\n }\n@@ -327,16 +327,6 @@ bool CBlockTreeDB::ReadFlag(const std::string &name, bool &fValue) {\n     return true;\n }\n \n-bool CBlockTreeDB::blockOnchainActive(const uint256 &hash) {\n-    CBlockIndex* pblockindex = mapBlockIndex[hash];\n-    \n-    if (!chainActive.Contains(pblockindex)) {\n-        return false;\n-    }\n-    \n-    return true;\n-}\n-\n bool CBlockTreeDB::LoadBlockIndexGuts(boost::function<CBlockIndex*(const uint256&)> insertBlockIndex)\n {\n     boost::scoped_ptr<CDBIterator> pcursor(NewIterator());"
      },
      {
        "sha": "4e2f9d7ead9c15a42a2928d82a680216adeb8e2f",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 4,
        "deletions": 12,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5839cc2524971c1b38e1c49ba2d028d22162120a/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5839cc2524971c1b38e1c49ba2d028d22162120a/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=5839cc2524971c1b38e1c49ba2d028d22162120a",
        "patch": "@@ -6,9 +6,13 @@\n #ifndef BITCOIN_TXDB_H\n #define BITCOIN_TXDB_H\n \n+#include \"main.h\"\n #include \"coins.h\"\n #include \"dbwrapper.h\"\n #include \"chain.h\"\n+#include \"addressindex.h\"\n+#include \"spentindex.h\"\n+#include \"timestampindex.h\"\n \n #include <map>\n #include <string>\n@@ -19,17 +23,6 @@\n \n class CBlockIndex;\n class CCoinsViewDBCursor;\n-struct CAddressUnspentKey;\n-struct CAddressUnspentValue;\n-struct CAddressIndexKey;\n-struct CAddressIndexIteratorKey;\n-struct CAddressIndexIteratorHeightKey;\n-struct CTimestampIndexKey;\n-struct CTimestampIndexIteratorKey;\n-struct CTimestampBlockIndexKey;\n-struct CTimestampBlockIndexValue;\n-struct CSpentIndexKey;\n-struct CSpentIndexValue;\n class uint256;\n \n //! -dbcache default (MiB)\n@@ -142,7 +135,6 @@ class CBlockTreeDB : public CDBWrapper\n     bool WriteFlag(const std::string &name, bool fValue);\n     bool ReadFlag(const std::string &name, bool &fValue);\n     bool LoadBlockIndexGuts(boost::function<CBlockIndex*(const uint256&)> insertBlockIndex);\n-    bool blockOnchainActive(const uint256 &hash);\n };\n \n #endif // BITCOIN_TXDB_H"
      }
    ]
  },
  {
    "sha": "90b4c17dc50ceb120e718b4babc14748ce12d2d6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MGI0YzE3ZGM1MGNlYjEyMGU3MThiNGJhYmMxNDc0OGNlMTJkMmQ2",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-05T22:39:13Z"
      },
      "committer": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-05T23:28:40Z"
      },
      "message": "indexes: additional logging and checks for indexes",
      "tree": {
        "sha": "bf9487e22788a7851ffdb8ebd723f196bd776c5a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bf9487e22788a7851ffdb8ebd723f196bd776c5a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/90b4c17dc50ceb120e718b4babc14748ce12d2d6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/90b4c17dc50ceb120e718b4babc14748ce12d2d6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/90b4c17dc50ceb120e718b4babc14748ce12d2d6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/90b4c17dc50ceb120e718b4babc14748ce12d2d6/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "5839cc2524971c1b38e1c49ba2d028d22162120a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5839cc2524971c1b38e1c49ba2d028d22162120a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5839cc2524971c1b38e1c49ba2d028d22162120a"
      }
    ],
    "stats": {
      "total": 27,
      "additions": 27,
      "deletions": 0
    },
    "files": [
      {
        "sha": "c7a3b7629ca026db7e59aa91bb41e879813870f9",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90b4c17dc50ceb120e718b4babc14748ce12d2d6/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90b4c17dc50ceb120e718b4babc14748ce12d2d6/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=90b4c17dc50ceb120e718b4babc14748ce12d2d6",
        "patch": "@@ -1283,6 +1283,24 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n                     break;\n                 }\n \n+                // Check for changed -addressindex state\n+                if (fAddressIndex != GetBoolArg(\"-addressindex\", DEFAULT_ADDRESSINDEX)) {\n+                    strLoadError = _(\"You need to rebuild the database using -reindex-chainstate to change -addressindex\");\n+                    break;\n+                }\n+\n+                // Check for changed -spentindex state\n+                if (fSpentIndex != GetBoolArg(\"-spentindex\", DEFAULT_SPENTINDEX)) {\n+                    strLoadError = _(\"You need to rebuild the database using -reindex-chainstate to change -spentindex\");\n+                    break;\n+                }\n+\n+                // Check for changed -timestampindex state\n+                if (fTimestampIndex != GetBoolArg(\"-timestampindex\", DEFAULT_TIMESTAMPINDEX)) {\n+                    strLoadError = _(\"You need to rebuild the database using -reindex-chainstate to change -timestampindex\");\n+                    break;\n+                }\n+\n                 // Check for changed -prune state.  What we are concerned about is a user who has pruned blocks\n                 // in the past, but is now trying to run unpruned.\n                 if (fHavePruned && !fPruneMode) {"
      },
      {
        "sha": "b1b9abe7f0864d5c4e2cc3a51da6806439218448",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90b4c17dc50ceb120e718b4babc14748ce12d2d6/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90b4c17dc50ceb120e718b4babc14748ce12d2d6/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=90b4c17dc50ceb120e718b4babc14748ce12d2d6",
        "patch": "@@ -2451,6 +2451,7 @@ static int64_t nTimeTotal = 0;\n bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex,\n                   CCoinsViewCache& view, const CChainParams& chainparams, bool fJustCheck)\n {\n+\n     AssertLockHeld(cs_main);\n \n     int64_t nTimeStart = GetTimeMicros();\n@@ -4584,17 +4585,22 @@ bool InitBlockIndex(const CChainParams& chainparams)\n     // Use the provided setting for -txindex in the new database\n     fTxIndex = GetBoolArg(\"-txindex\", DEFAULT_TXINDEX);\n     pblocktree->WriteFlag(\"txindex\", fTxIndex);\n+    LogPrintf(\"%s: transaction index %s\\n\", __func__, fTxIndex ? \"enabled\" : \"disabled\");\n \n     // Use the provided setting for -addressindex in the new database\n     fAddressIndex = GetBoolArg(\"-addressindex\", DEFAULT_ADDRESSINDEX);\n     pblocktree->WriteFlag(\"addressindex\", fAddressIndex);\n+    LogPrintf(\"%s: address index %s\\n\", __func__, fAddressIndex ? \"enabled\" : \"disabled\");\n \n     // Use the provided setting for -timestampindex in the new database\n     fTimestampIndex = GetBoolArg(\"-timestampindex\", DEFAULT_TIMESTAMPINDEX);\n     pblocktree->WriteFlag(\"timestampindex\", fTimestampIndex);\n+    LogPrintf(\"%s: timestamp index %s\\n\", __func__, fTimestampIndex ? \"enabled\" : \"disabled\");\n \n+    // Use the provided setting for -spentindex in the new database\n     fSpentIndex = GetBoolArg(\"-spentindex\", DEFAULT_SPENTINDEX);\n     pblocktree->WriteFlag(\"spentindex\", fSpentIndex);\n+    LogPrintf(\"%s: spent index %s\\n\", __func__, fSpentIndex ? \"enabled\" : \"disabled\");\n \n     LogPrintf(\"Initializing databases...\\n\");\n "
      },
      {
        "sha": "87c8255b337ae940e749d641a9e35e6115be0088",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90b4c17dc50ceb120e718b4babc14748ce12d2d6/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90b4c17dc50ceb120e718b4babc14748ce12d2d6/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=90b4c17dc50ceb120e718b4babc14748ce12d2d6",
        "patch": "@@ -168,6 +168,9 @@ extern bool fImporting;\n extern bool fReindex;\n extern int nScriptCheckThreads;\n extern bool fTxIndex;\n+extern bool fAddressIndex;\n+extern bool fSpentIndex;\n+extern bool fTimestampIndex;\n extern bool fIsBareMultisigStd;\n extern bool fRequireStandard;\n extern bool fCheckBlockIndex;"
      }
    ]
  },
  {
    "sha": "394b6a5ce1ec4ebc128e3b1550a4a352232b50a0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozOTRiNmE1Y2UxZWM0ZWJjMTI4ZTNiMTU1MGE0YTM1MjIzMmI1MGEw",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-05T22:39:57Z"
      },
      "committer": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-05T23:28:52Z"
      },
      "message": "tests: update rpc index tests for 0.13",
      "tree": {
        "sha": "a7e35f6a82fcb2c274eef977b920050815216ed1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a7e35f6a82fcb2c274eef977b920050815216ed1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/394b6a5ce1ec4ebc128e3b1550a4a352232b50a0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/394b6a5ce1ec4ebc128e3b1550a4a352232b50a0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/394b6a5ce1ec4ebc128e3b1550a4a352232b50a0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/394b6a5ce1ec4ebc128e3b1550a4a352232b50a0/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "90b4c17dc50ceb120e718b4babc14748ce12d2d6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/90b4c17dc50ceb120e718b4babc14748ce12d2d6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/90b4c17dc50ceb120e718b4babc14748ce12d2d6"
      }
    ],
    "stats": {
      "total": 102,
      "additions": 52,
      "deletions": 50
    },
    "files": [
      {
        "sha": "6968e0dca8133fe91e0f7c81903a72ba3afc0d0d",
        "filename": "qa/rpc-tests/addressindex.py",
        "status": "modified",
        "additions": 26,
        "deletions": 26,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/394b6a5ce1ec4ebc128e3b1550a4a352232b50a0/qa/rpc-tests/addressindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/394b6a5ce1ec4ebc128e3b1550a4a352232b50a0/qa/rpc-tests/addressindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/addressindex.py?ref=394b6a5ce1ec4ebc128e3b1550a4a352232b50a0",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python2\n+#!/usr/bin/env python3\n # Copyright (c) 2014-2015 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n@@ -36,7 +36,7 @@ def setup_network(self):\n         self.sync_all()\n \n     def run_test(self):\n-        print \"Mining blocks...\"\n+        print(\"Mining blocks...\")\n         self.nodes[0].generate(105)\n         self.sync_all()\n \n@@ -50,7 +50,7 @@ def run_test(self):\n         assert_equal(balance0[\"balance\"], 0)\n \n         # Check p2pkh and p2sh address indexes\n-        print \"Testing p2pkh and p2sh address index...\"\n+        print(\"Testing p2pkh and p2sh address index...\")\n \n         txid0 = self.nodes[0].sendtoaddress(\"mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs\", 10)\n         self.nodes[0].generate(1)\n@@ -85,7 +85,7 @@ def run_test(self):\n         assert_equal(txidsb[2], txidb2)\n \n         # Check that limiting by height works\n-        print \"Testing querying txids by range of block heights..\"\n+        print(\"Testing querying txids by range of block heights..\")\n         height_txids = self.nodes[1].getaddresstxids({\n             \"addresses\": [\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\"],\n             \"start\": 105,\n@@ -110,8 +110,8 @@ def run_test(self):\n         assert_equal(balance0[\"balance\"], 45 * 100000000)\n \n         # Check that outputs with the same address will only return one txid\n-        print \"Testing for txid uniqueness...\"\n-        addressHash = \"6349a418fc4578d10a372b54b45c280cc8c4382f\".decode(\"hex\")\n+        print(\"Testing for txid uniqueness...\")\n+        addressHash = bytes([99,73,164,24,252,69,120,209,10,55,43,84,180,92,40,12,200,196,56,47])\n         scriptPubKey = CScript([OP_HASH160, addressHash, OP_EQUAL])\n         unspent = self.nodes[0].listunspent()\n         tx = CTransaction()\n@@ -130,22 +130,22 @@ def run_test(self):\n         assert_equal(txidsmany[3], sent_txid)\n \n         # Check that balances are correct\n-        print \"Testing balances...\"\n+        print(\"Testing balances...\")\n         balance0 = self.nodes[1].getaddressbalance(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\")\n         assert_equal(balance0[\"balance\"], 45 * 100000000 + 21)\n \n         # Check that balances are correct after spending\n-        print \"Testing balances after spending...\"\n+        print(\"Testing balances after spending...\")\n         privkey2 = \"cSdkPxkAjA4HDr5VHgsebAPDEh9Gyub4HK8UJr2DFGGqKKy4K5sG\"\n         address2 = \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\"\n-        addressHash2 = \"0b2f0a0c31bfe0406b0ccc1381fdbe311946dadc\".decode(\"hex\")\n+        addressHash2 = bytes([11,47,10,12,49,191,224,64,107,12,204,19,129,253,190,49,25,70,218,220])\n         scriptPubKey2 = CScript([OP_DUP, OP_HASH160, addressHash2, OP_EQUALVERIFY, OP_CHECKSIG])\n         self.nodes[0].importprivkey(privkey2)\n \n         unspent = self.nodes[0].listunspent()\n         tx = CTransaction()\n         tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n-        amount = unspent[0][\"amount\"] * 100000000\n+        amount = int(unspent[0][\"amount\"] * 100000000 - 100000)\n         tx.vout = [CTxOut(amount, scriptPubKey2)]\n         tx.rehash()\n         signed_tx = self.nodes[0].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n@@ -188,13 +188,13 @@ def run_test(self):\n         assert_equal(len(deltas), 1)\n \n         # Check that unspent outputs can be queried\n-        print \"Testing utxos...\"\n+        print(\"Testing utxos...\")\n         utxos = self.nodes[1].getaddressutxos({\"addresses\": [address2]})\n         assert_equal(len(utxos), 1)\n         assert_equal(utxos[0][\"satoshis\"], change_amount)\n \n         # Check that indexes will be updated with a reorg\n-        print \"Testing reorg...\"\n+        print(\"Testing reorg...\")\n \n         best_hash = self.nodes[0].getbestblockhash()\n         self.nodes[0].invalidateblock(best_hash)\n@@ -226,19 +226,19 @@ def run_test(self):\n         assert_equal(utxos3[2][\"height\"], 265)\n \n         # Check mempool indexing\n-        print \"Testing mempool indexing...\"\n+        print(\"Testing mempool indexing...\")\n \n         privKey3 = \"cVfUn53hAbRrDEuMexyfgDpZPhF7KqXpS8UZevsyTDaugB7HZ3CD\"\n         address3 = \"mw4ynwhS7MmrQ27hr82kgqu7zryNDK26JB\"\n-        addressHash3 = \"aa9872b5bbcdb511d89e0e11aa27da73fd2c3f50\".decode(\"hex\")\n+        addressHash3 = bytes([170,152,114,181,187,205,181,17,216,158,14,17,170,39,218,115,253,44,63,80])\n         scriptPubKey3 = CScript([OP_DUP, OP_HASH160, addressHash3, OP_EQUALVERIFY, OP_CHECKSIG])\n         address4 = \"2N8oFVB2vThAKury4vnLquW2zVjsYjjAkYQ\"\n         scriptPubKey4 = CScript([OP_HASH160, addressHash3, OP_EQUAL])\n         unspent = self.nodes[2].listunspent()\n \n         tx = CTransaction()\n         tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n-        amount = unspent[0][\"amount\"] * 100000000\n+        amount = int(unspent[0][\"amount\"] * 100000000 - 100000)\n         tx.vout = [CTxOut(amount, scriptPubKey3)]\n         tx.rehash()\n         signed_tx = self.nodes[2].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n@@ -247,12 +247,12 @@ def run_test(self):\n \n         tx2 = CTransaction()\n         tx2.vin = [CTxIn(COutPoint(int(unspent[1][\"txid\"], 16), unspent[1][\"vout\"]))]\n-        amount = unspent[1][\"amount\"] * 100000000\n+        amount = int(unspent[1][\"amount\"] * 100000000 - 100000)\n         tx2.vout = [\n-            CTxOut(amount / 4, scriptPubKey3),\n-            CTxOut(amount / 4, scriptPubKey3),\n-            CTxOut(amount / 4, scriptPubKey4),\n-            CTxOut(amount / 4, scriptPubKey4)\n+            CTxOut(int(amount / 4), scriptPubKey3),\n+            CTxOut(int(amount / 4), scriptPubKey3),\n+            CTxOut(int(amount / 4), scriptPubKey4),\n+            CTxOut(int(amount / 4), scriptPubKey4)\n         ]\n         tx2.rehash()\n         signed_tx2 = self.nodes[2].signrawtransaction(binascii.hexlify(tx2.serialize()).decode(\"utf-8\"))\n@@ -269,7 +269,7 @@ def run_test(self):\n         assert_equal(mempool[2][\"txid\"], memtxid2)\n         assert_equal(mempool[2][\"index\"], 1)\n \n-        self.nodes[2].generate(1);\n+        blk_hashes = self.nodes[2].generate(1);\n         self.sync_all();\n         mempool2 = self.nodes[2].getaddressmempool({\"addresses\": [address3]})\n         assert_equal(len(mempool2), 0)\n@@ -279,7 +279,7 @@ def run_test(self):\n             CTxIn(COutPoint(int(memtxid2, 16), 0)),\n             CTxIn(COutPoint(int(memtxid2, 16), 1))\n         ]\n-        tx.vout = [CTxOut(amount / 2 - 10000, scriptPubKey2)]\n+        tx.vout = [CTxOut(int(amount / 2 - 10000), scriptPubKey2)]\n         tx.rehash()\n         self.nodes[2].importprivkey(privKey3)\n         signed_tx3 = self.nodes[2].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n@@ -296,7 +296,7 @@ def run_test(self):\n         # sending and receiving to the same address\n         privkey1 = \"cQY2s58LhzUCmEXN8jtAp1Etnijx78YRZ466w4ikX1V4UpTpbsf8\"\n         address1 = \"myAUWSHnwsQrhuMWv4Br6QsCnpB41vFwHn\"\n-        address1hash = \"c192bff751af8efec15135d42bfeedf91a6f3e34\".decode(\"hex\")\n+        address1hash = bytes([193,146,191,247,81,175,142,254,193,81,53,212,43,254,237,249,26,111,62,52])\n         address1script = CScript([OP_DUP, OP_HASH160, address1hash, OP_EQUALVERIFY, OP_CHECKSIG])\n \n         self.nodes[0].sendtoaddress(address1, 10)\n@@ -310,7 +310,7 @@ def run_test(self):\n         tx.vin = [\n             CTxIn(COutPoint(int(utxos[0][\"txid\"], 16), utxos[0][\"outputIndex\"]))\n         ]\n-        amount = utxos[0][\"satoshis\"] - 1000\n+        amount = int(utxos[0][\"satoshis\"] - 1000)\n         tx.vout = [CTxOut(amount, address1script)]\n         tx.rehash()\n         self.nodes[0].importprivkey(privkey1)\n@@ -322,7 +322,7 @@ def run_test(self):\n         assert_equal(len(mempool_deltas), 2)\n \n         # Include chaininfo in results\n-        print \"Testing results with chain info...\"\n+        print(\"Testing results with chain info...\")\n \n         deltas_with_info = self.nodes[1].getaddressdeltas({\n             \"addresses\": [address2],\n@@ -342,7 +342,7 @@ def run_test(self):\n         assert_equal(utxos_with_info[\"height\"], 267)\n         assert_equal(utxos_with_info[\"hash\"], expected_tip_block_hash)\n \n-        print \"Passed\\n\"\n+        print(\"Passed\\n\")\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "4119a11aef04ea97a44eaa2a9d2225ef24ae483b",
        "filename": "qa/rpc-tests/spentindex.py",
        "status": "modified",
        "additions": 20,
        "deletions": 18,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/394b6a5ce1ec4ebc128e3b1550a4a352232b50a0/qa/rpc-tests/spentindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/394b6a5ce1ec4ebc128e3b1550a4a352232b50a0/qa/rpc-tests/spentindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/spentindex.py?ref=394b6a5ce1ec4ebc128e3b1550a4a352232b50a0",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python2\n+#!/usr/bin/env python3\n # Copyright (c) 2014-2015 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n@@ -36,23 +36,24 @@ def setup_network(self):\n         self.sync_all()\n \n     def run_test(self):\n-        print \"Mining blocks...\"\n+        print(\"Mining blocks...\")\n         self.nodes[0].generate(105)\n         self.sync_all()\n \n         chain_height = self.nodes[1].getblockcount()\n         assert_equal(chain_height, 105)\n \n         # Check that\n-        print \"Testing spent index...\"\n+        print(\"Testing spent index...\")\n \n+        feeSatoshis = 10000\n         privkey = \"cSdkPxkAjA4HDr5VHgsebAPDEh9Gyub4HK8UJr2DFGGqKKy4K5sG\"\n         address = \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\"\n-        addressHash = \"0b2f0a0c31bfe0406b0ccc1381fdbe311946dadc\".decode(\"hex\")\n+        addressHash = bytes([11,47,10,12,49,191,224,64,107,12,204,19,129,253,190,49,25,70,218,220])\n         scriptPubKey = CScript([OP_DUP, OP_HASH160, addressHash, OP_EQUALVERIFY, OP_CHECKSIG])\n         unspent = self.nodes[0].listunspent()\n         tx = CTransaction()\n-        amount = unspent[0][\"amount\"] * 100000000\n+        amount = int(unspent[0][\"amount\"] * 100000000 - feeSatoshis)\n         tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n         tx.vout = [CTxOut(amount, scriptPubKey)]\n         tx.rehash()\n@@ -62,15 +63,15 @@ def run_test(self):\n         self.nodes[0].generate(1)\n         self.sync_all()\n \n-        print \"Testing getspentinfo method...\"\n+        print(\"Testing getspentinfo method...\")\n \n         # Check that the spentinfo works standalone\n         info = self.nodes[1].getspentinfo({\"txid\": unspent[0][\"txid\"], \"index\": unspent[0][\"vout\"]})\n         assert_equal(info[\"txid\"], txid)\n         assert_equal(info[\"index\"], 0)\n         assert_equal(info[\"height\"], 106)\n \n-        print \"Testing getrawtransaction method...\"\n+        print(\"Testing getrawtransaction method...\")\n \n         # Check that verbose raw transaction includes spent info\n         txVerbose = self.nodes[3].getrawtransaction(unspent[0][\"txid\"], 1)\n@@ -80,16 +81,17 @@ def run_test(self):\n \n         # Check that verbose raw transaction includes input values\n         txVerbose2 = self.nodes[3].getrawtransaction(txid, 1)\n-        assert_equal(txVerbose2[\"vin\"][0][\"value\"], Decimal(unspent[0][\"amount\"]))\n-        assert_equal(txVerbose2[\"vin\"][0][\"valueSat\"], amount)\n+        assert_equal(float(txVerbose2[\"vin\"][0][\"value\"]), (amount + feeSatoshis) / 100000000)\n+        assert_equal(txVerbose2[\"vin\"][0][\"valueSat\"], amount + feeSatoshis)\n \n         # Check that verbose raw transaction includes address values and input values\n         privkey2 = \"cSdkPxkAjA4HDr5VHgsebAPDEh9Gyub4HK8UJr2DFGGqKKy4K5sG\"\n         address2 = \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\"\n-        addressHash2 = \"0b2f0a0c31bfe0406b0ccc1381fdbe311946dadc\".decode(\"hex\")\n+        addressHash2 = bytes([11,47,10,12,49,191,224,64,107,12,204,19,129,253,190,49,25,70,218,220])\n         scriptPubKey2 = CScript([OP_DUP, OP_HASH160, addressHash2, OP_EQUALVERIFY, OP_CHECKSIG])\n         tx2 = CTransaction()\n         tx2.vin = [CTxIn(COutPoint(int(txid, 16), 0))]\n+        amount = int(amount - feeSatoshis);\n         tx2.vout = [CTxOut(amount, scriptPubKey2)]\n         tx.rehash()\n         self.nodes[0].importprivkey(privkey)\n@@ -100,21 +102,21 @@ def run_test(self):\n         self.sync_all()\n         txVerbose3 = self.nodes[1].getrawtransaction(txid2, 1)\n         assert_equal(txVerbose3[\"vin\"][0][\"address\"], address2)\n-        assert_equal(txVerbose3[\"vin\"][0][\"value\"], Decimal(unspent[0][\"amount\"]))\n-        assert_equal(txVerbose3[\"vin\"][0][\"valueSat\"], amount)\n+        assert_equal(txVerbose3[\"vin\"][0][\"valueSat\"], amount + feeSatoshis)\n+        assert_equal(float(txVerbose3[\"vin\"][0][\"value\"]), (amount + feeSatoshis) / 100000000)\n+\n \n         # Check the database index\n         block_hash = self.nodes[0].generate(1)\n         self.sync_all()\n \n         txVerbose4 = self.nodes[3].getrawtransaction(txid2, 1)\n         assert_equal(txVerbose4[\"vin\"][0][\"address\"], address2)\n-        assert_equal(txVerbose4[\"vin\"][0][\"value\"], Decimal(unspent[0][\"amount\"]))\n-        assert_equal(txVerbose4[\"vin\"][0][\"valueSat\"], amount)\n-\n+        assert_equal(txVerbose4[\"vin\"][0][\"valueSat\"], amount + feeSatoshis)\n+        assert_equal(float(txVerbose4[\"vin\"][0][\"value\"]), (amount + feeSatoshis) / 100000000)\n \n         # Check block deltas\n-        print \"Testing getblockdeltas...\"\n+        print(\"Testing getblockdeltas...\")\n \n         block = self.nodes[3].getblockdeltas(block_hash[0])\n         assert_equal(len(block[\"deltas\"]), 2)\n@@ -125,14 +127,14 @@ def run_test(self):\n         assert_equal(block[\"deltas\"][1][\"txid\"], txid2)\n         assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"index\"], 0)\n         assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"address\"], \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\")\n-        assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"satoshis\"], amount * -1)\n+        assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"satoshis\"], (amount + feeSatoshis) * -1)\n         assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"prevtxid\"], txid)\n         assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"prevout\"], 0)\n         assert_equal(block[\"deltas\"][1][\"outputs\"][0][\"index\"], 0)\n         assert_equal(block[\"deltas\"][1][\"outputs\"][0][\"address\"], \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\")\n         assert_equal(block[\"deltas\"][1][\"outputs\"][0][\"satoshis\"], amount)\n \n-        print \"Passed\\n\"\n+        print(\"Passed\\n\")\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "85942b7ef6929f2e43d29168815d87ac415d610a",
        "filename": "qa/rpc-tests/timestampindex.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/394b6a5ce1ec4ebc128e3b1550a4a352232b50a0/qa/rpc-tests/timestampindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/394b6a5ce1ec4ebc128e3b1550a4a352232b50a0/qa/rpc-tests/timestampindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/timestampindex.py?ref=394b6a5ce1ec4ebc128e3b1550a4a352232b50a0",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python2\n+#!/usr/bin/env python3\n # Copyright (c) 2014-2015 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n@@ -35,26 +35,26 @@ def setup_network(self):\n         self.sync_all()\n \n     def run_test(self):\n-        print \"Mining 25 blocks...\"\n+        print(\"Mining 25 blocks...\")\n         blockhashes = self.nodes[0].generate(25)\n         time.sleep(3)\n-        print \"Mining 25 blocks...\"\n+        print(\"Mining 25 blocks...\")\n         blockhashes.extend(self.nodes[0].generate(25))\n         time.sleep(3)\n-        print \"Mining 25 blocks...\"\n+        print(\"Mining 25 blocks...\")\n         blockhashes.extend(self.nodes[0].generate(25))\n         self.sync_all()\n         low = self.nodes[1].getblock(blockhashes[0])[\"time\"]\n         high = low + 76\n \n-        print \"Checking timestamp index...\"\n+        print(\"Checking timestamp index...\")\n         hashes = self.nodes[1].getblockhashes(high, low)\n \n         assert_equal(len(hashes), len(blockhashes))\n \n         assert_equal(hashes, blockhashes)\n \n-        print \"Passed\\n\"\n+        print(\"Passed\\n\")\n \n \n if __name__ == '__main__':"
      }
    ]
  },
  {
    "sha": "c91d78b578a8700a45be936cb5bb0931df8f4b87",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjOTFkNzhiNTc4YTg3MDBhNDViZTkzNmNiNWJiMDkzMWRmOGY0Yjg3",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-07-13T22:38:04Z"
      },
      "committer": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-05T23:35:38Z"
      },
      "message": "db: add options to configure block index database\n\nThere was a previous assumption that blockindex would be quite small. With addressindex\nand spentindex enabled the blockindex is much larger and the amount of cache allocated for\nit should also increase. Furthermore, enabling compression should decrease the amount of\ndisk space required and less data to write/read. The default leveldb max_open_files is set to\n1000, for the blockindex the default is set to 1000 with compression. The 64 value that is\ncurrent is kept for the utxo database and does not enable compression. Two additional options\nare added here to be able to configure the values for leveldb and the block index:\n\n- `-dbmaxopenfiles` A number of files for leveldb to keep open\n- `-dbcompression` Boolean 0 or 1 to enable snappy leveldb compression\n\nConflicts:\n\tsrc/dbwrapper.cpp\n\tsrc/init.cpp",
      "tree": {
        "sha": "fb9dc584a76f834875189fc508b045d049266ee2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fb9dc584a76f834875189fc508b045d049266ee2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c91d78b578a8700a45be936cb5bb0931df8f4b87",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c91d78b578a8700a45be936cb5bb0931df8f4b87",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c91d78b578a8700a45be936cb5bb0931df8f4b87",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c91d78b578a8700a45be936cb5bb0931df8f4b87/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "394b6a5ce1ec4ebc128e3b1550a4a352232b50a0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/394b6a5ce1ec4ebc128e3b1550a4a352232b50a0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/394b6a5ce1ec4ebc128e3b1550a4a352232b50a0"
      }
    ],
    "stats": {
      "total": 53,
      "additions": 36,
      "deletions": 17
    },
    "files": [
      {
        "sha": "74d9c7bbe93e8e663dc13b91911cae9558416ce4",
        "filename": "src/dbwrapper.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c91d78b578a8700a45be936cb5bb0931df8f4b87/src/dbwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c91d78b578a8700a45be936cb5bb0931df8f4b87/src/dbwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.cpp?ref=c91d78b578a8700a45be936cb5bb0931df8f4b87",
        "patch": "@@ -15,14 +15,14 @@\n #include <memenv.h>\n #include <stdint.h>\n \n-static leveldb::Options GetOptions(size_t nCacheSize)\n+static leveldb::Options GetOptions(size_t nCacheSize, bool compression, int maxOpenFiles)\n {\n     leveldb::Options options;\n     options.block_cache = leveldb::NewLRUCache(nCacheSize / 2);\n     options.write_buffer_size = nCacheSize / 4; // up to two write buffers may be held in memory simultaneously\n     options.filter_policy = leveldb::NewBloomFilterPolicy(10);\n-    options.compression = leveldb::kNoCompression;\n-    options.max_open_files = 64;\n+    options.compression = compression ? leveldb::kSnappyCompression : leveldb::kNoCompression;\n+    options.max_open_files = maxOpenFiles;\n     if (leveldb::kMajorVersion > 1 || (leveldb::kMajorVersion == 1 && leveldb::kMinorVersion >= 16)) {\n         // LevelDB versions before 1.16 consider short writes to be corruption. Only trigger error\n         // on corruption in later versions.\n@@ -31,14 +31,14 @@ static leveldb::Options GetOptions(size_t nCacheSize)\n     return options;\n }\n \n-CDBWrapper::CDBWrapper(const boost::filesystem::path& path, size_t nCacheSize, bool fMemory, bool fWipe, bool obfuscate)\n+CDBWrapper::CDBWrapper(const boost::filesystem::path& path, size_t nCacheSize, bool fMemory, bool fWipe, bool obfuscate, bool compression, int maxOpenFiles)\n {\n     penv = NULL;\n     readoptions.verify_checksums = true;\n     iteroptions.verify_checksums = true;\n     iteroptions.fill_cache = false;\n     syncoptions.sync = true;\n-    options = GetOptions(nCacheSize);\n+    options = GetOptions(nCacheSize, compression, maxOpenFiles);\n     options.create_if_missing = true;\n     if (fMemory) {\n         penv = leveldb::NewMemEnv(leveldb::Env::Default());"
      },
      {
        "sha": "20b5f849e055be60f21fd9549e9d043d3da8f894",
        "filename": "src/dbwrapper.h",
        "status": "modified",
        "additions": 9,
        "deletions": 7,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c91d78b578a8700a45be936cb5bb0931df8f4b87/src/dbwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c91d78b578a8700a45be936cb5bb0931df8f4b87/src/dbwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.h?ref=c91d78b578a8700a45be936cb5bb0931df8f4b87",
        "patch": "@@ -186,14 +186,16 @@ class CDBWrapper\n \n public:\n     /**\n-     * @param[in] path        Location in the filesystem where leveldb data will be stored.\n-     * @param[in] nCacheSize  Configures various leveldb cache settings.\n-     * @param[in] fMemory     If true, use leveldb's memory environment.\n-     * @param[in] fWipe       If true, remove all existing data.\n-     * @param[in] obfuscate   If true, store data obfuscated via simple XOR. If false, XOR\n-     *                        with a zero'd byte array.\n+     * @param[in] path          Location in the filesystem where leveldb data will be stored.\n+     * @param[in] nCacheSize    Configures various leveldb cache settings.\n+     * @param[in] fMemory       If true, use leveldb's memory environment.\n+     * @param[in] fWipe         If true, remove all existing data.\n+     * @param[in] obfuscate     If true, store data obfuscated via simple XOR. If false, XOR\n+     *                          with a zero'd byte array.\n+     * @param[in] compression   Enable snappy compression for the database\n+     * @param[in] maxOpenFiles  The maximum number of open files for the database\n      */\n-    CDBWrapper(const boost::filesystem::path& path, size_t nCacheSize, bool fMemory = false, bool fWipe = false, bool obfuscate = false);\n+    CDBWrapper(const boost::filesystem::path& path, size_t nCacheSize, bool fMemory = false, bool fWipe = false, bool obfuscate = false, bool compression = false, int maxOpenFiles = 64);\n     ~CDBWrapper();\n \n     template <typename K, typename V>"
      },
      {
        "sha": "fb9c8b40d47a9b19cdc6165a04c14e00739dbbae",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 2,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c91d78b578a8700a45be936cb5bb0931df8f4b87/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c91d78b578a8700a45be936cb5bb0931df8f4b87/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=c91d78b578a8700a45be936cb5bb0931df8f4b87",
        "patch": "@@ -1217,18 +1217,32 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n         }\n     }\n \n+    // block tree db settings\n+    int dbMaxOpenFiles = GetArg(\"-dbmaxopenfiles\", DEFAULT_DB_MAX_OPEN_FILES);\n+    bool dbCompression = GetBoolArg(\"-dbcompression\", DEFAULT_DB_COMPRESSION);\n+\n+    LogPrintf(\"Block index database configuration:\\n\");\n+    LogPrintf(\"* Using %d max open files\\n\", dbMaxOpenFiles);\n+    LogPrintf(\"* Compression is %s\\n\", dbCompression ? \"enabled\" : \"disabled\");\n+\n     // cache size calculations\n     int64_t nTotalCache = (GetArg(\"-dbcache\", nDefaultDbCache) << 20);\n     nTotalCache = std::max(nTotalCache, nMinDbCache << 20); // total cache cannot be less than nMinDbCache\n     nTotalCache = std::min(nTotalCache, nMaxDbCache << 20); // total cache cannot be greated than nMaxDbcache\n     int64_t nBlockTreeDBCache = nTotalCache / 8;\n-    nBlockTreeDBCache = std::min(nBlockTreeDBCache, (GetBoolArg(\"-txindex\", DEFAULT_TXINDEX) ? nMaxBlockDBAndTxIndexCache : nMaxBlockDBCache) << 20);\n+    if (GetBoolArg(\"-addressindex\", DEFAULT_ADDRESSINDEX) || GetBoolArg(\"-spentindex\", DEFAULT_SPENTINDEX)) {\n+        // enable 3/4 of the cache if addressindex and/or spentindex is enabled\n+        nBlockTreeDBCache = nTotalCache * 3 / 4;\n+    } else {\n+        nBlockTreeDBCache = std::min(nBlockTreeDBCache, (GetBoolArg(\"-txindex\", DEFAULT_TXINDEX) ? nMaxBlockDBAndTxIndexCache : nMaxBlockDBCache) << 20);\n+    }\n     nTotalCache -= nBlockTreeDBCache;\n     int64_t nCoinDBCache = std::min(nTotalCache / 2, (nTotalCache / 4) + (1 << 23)); // use 25%-50% of the remainder for disk cache\n     nCoinDBCache = std::min(nCoinDBCache, nMaxCoinsDBCache << 20); // cap total coins db cache\n     nTotalCache -= nCoinDBCache;\n     nCoinCacheUsage = nTotalCache; // the rest goes to in-memory cache\n     LogPrintf(\"Cache configuration:\\n\");\n+    LogPrintf(\"* Max cache setting possible %.1fMiB\\n\", nMaxDbCache);\n     LogPrintf(\"* Using %.1fMiB for block index database\\n\", nBlockTreeDBCache * (1.0 / 1024 / 1024));\n     LogPrintf(\"* Using %.1fMiB for chain state database\\n\", nCoinDBCache * (1.0 / 1024 / 1024));\n     LogPrintf(\"* Using %.1fMiB for in-memory UTXO set\\n\", nCoinCacheUsage * (1.0 / 1024 / 1024));\n@@ -1249,8 +1263,9 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n                 delete pcoinscatcher;\n                 delete pblocktree;\n \n-                pblocktree = new CBlockTreeDB(nBlockTreeDBCache, false, fReindex);\n+                pblocktree = new CBlockTreeDB(nBlockTreeDBCache, false, fReindex, dbCompression, dbMaxOpenFiles);\n                 pcoinsdbview = new CCoinsViewDB(nCoinDBCache, false, fReindex || fReindexChainState);\n+\n                 pcoinscatcher = new CCoinsViewErrorCatcher(pcoinsdbview);\n                 pcoinsTip = new CCoinsViewCache(pcoinscatcher);\n "
      },
      {
        "sha": "c47c6d16f9013df19a1365aa32c21042e694aaba",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c91d78b578a8700a45be936cb5bb0931df8f4b87/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c91d78b578a8700a45be936cb5bb0931df8f4b87/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=c91d78b578a8700a45be936cb5bb0931df8f4b87",
        "patch": "@@ -132,6 +132,8 @@ static const bool DEFAULT_TXINDEX = false;\n static const bool DEFAULT_ADDRESSINDEX = false;\n static const bool DEFAULT_TIMESTAMPINDEX = false;\n static const bool DEFAULT_SPENTINDEX = false;\n+static const unsigned int DEFAULT_DB_MAX_OPEN_FILES = 1000;\n+static const bool DEFAULT_DB_COMPRESSION = true;\n static const unsigned int DEFAULT_BANSCORE_THRESHOLD = 100;\n \n static const bool DEFAULT_TESTSAFEMODE = false;"
      },
      {
        "sha": "b2b34e002911810b341eeda986c015abc38278e9",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c91d78b578a8700a45be936cb5bb0931df8f4b87/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c91d78b578a8700a45be936cb5bb0931df8f4b87/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=c91d78b578a8700a45be936cb5bb0931df8f4b87",
        "patch": "@@ -32,7 +32,7 @@ static const char DB_REINDEX_FLAG = 'R';\n static const char DB_LAST_BLOCK = 'l';\n \n \n-CCoinsViewDB::CCoinsViewDB(size_t nCacheSize, bool fMemory, bool fWipe) : db(GetDataDir() / \"chainstate\", nCacheSize, fMemory, fWipe, true) \n+CCoinsViewDB::CCoinsViewDB(size_t nCacheSize, bool fMemory, bool fWipe) : db(GetDataDir() / \"chainstate\", nCacheSize, fMemory, fWipe, true, false, 64)\n {\n }\n \n@@ -74,7 +74,7 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     return db.WriteBatch(batch);\n }\n \n-CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory, bool fWipe) : CDBWrapper(GetDataDir() / \"blocks\" / \"index\", nCacheSize, fMemory, fWipe) {\n+CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory, bool fWipe, bool compression, int maxOpenFiles) : CDBWrapper(GetDataDir() / \"blocks\" / \"index\", nCacheSize, fMemory, fWipe, false, compression, maxOpenFiles) {\n }\n \n bool CBlockTreeDB::ReadBlockFileInfo(int nFile, CBlockFileInfo &info) {"
      },
      {
        "sha": "261b8a84e5dea932e164de942dc2427ffd51e728",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c91d78b578a8700a45be936cb5bb0931df8f4b87/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c91d78b578a8700a45be936cb5bb0931df8f4b87/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=c91d78b578a8700a45be936cb5bb0931df8f4b87",
        "patch": "@@ -106,7 +106,7 @@ class CCoinsViewDBCursor: public CCoinsViewCursor\n class CBlockTreeDB : public CDBWrapper\n {\n public:\n-    CBlockTreeDB(size_t nCacheSize, bool fMemory = false, bool fWipe = false);\n+    CBlockTreeDB(size_t nCacheSize, bool fMemory = false, bool fWipe = false, bool compression = true, int maxOpenFiles = 1000);\n private:\n     CBlockTreeDB(const CBlockTreeDB&);\n     void operator=(const CBlockTreeDB&);"
      }
    ]
  },
  {
    "sha": "7726e584cb441c7e384b9917c7fce2f7a3c25081",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NzI2ZTU4NGNiNDQxYzdlMzg0Yjk5MTdjN2ZjZTJmN2EzYzI1MDgx",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-07-14T20:30:31Z"
      },
      "committer": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-05T23:36:13Z"
      },
      "message": "tests: test dbwrapper options compression and maxopenfiles",
      "tree": {
        "sha": "650f83b41401022ae9bd0b1c388b566ed3485631",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/650f83b41401022ae9bd0b1c388b566ed3485631"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7726e584cb441c7e384b9917c7fce2f7a3c25081",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7726e584cb441c7e384b9917c7fce2f7a3c25081",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7726e584cb441c7e384b9917c7fce2f7a3c25081",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7726e584cb441c7e384b9917c7fce2f7a3c25081/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "c91d78b578a8700a45be936cb5bb0931df8f4b87",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c91d78b578a8700a45be936cb5bb0931df8f4b87",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c91d78b578a8700a45be936cb5bb0931df8f4b87"
      }
    ],
    "stats": {
      "total": 43,
      "additions": 43,
      "deletions": 0
    },
    "files": [
      {
        "sha": "33a4e78e3d60c38977638130c183f20deda3d59e",
        "filename": "src/test/dbwrapper_tests.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 0,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7726e584cb441c7e384b9917c7fce2f7a3c25081/src/test/dbwrapper_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7726e584cb441c7e384b9917c7fce2f7a3c25081/src/test/dbwrapper_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/dbwrapper_tests.cpp?ref=7726e584cb441c7e384b9917c7fce2f7a3c25081",
        "patch": "@@ -47,6 +47,49 @@ BOOST_AUTO_TEST_CASE(dbwrapper)\n     }\n }\n \n+BOOST_AUTO_TEST_CASE(dbwrapper_compression)\n+{\n+    // Perform tests both with compression and without\n+    for (int i = 0; i < 2; i++) {\n+        bool compression = (bool)i;\n+        path ph = temp_directory_path() / unique_path();\n+        CDBWrapper dbw(ph, (1 << 20), true, false, false, compression);\n+        char key = 'k';\n+        uint256 in = GetRandHash();\n+        uint256 res;\n+\n+        BOOST_CHECK(dbw.Write(key, in));\n+        BOOST_CHECK(dbw.Read(key, res));\n+        BOOST_CHECK_EQUAL(res.ToString(), in.ToString());\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(dbwrapper_maxopenfiles_64)\n+{\n+    path ph = temp_directory_path() / unique_path();\n+    CDBWrapper dbw(ph, (1 << 20), true, false, false, false, 64);\n+    char key = 'k';\n+    uint256 in = GetRandHash();\n+    uint256 res;\n+\n+    BOOST_CHECK(dbw.Write(key, in));\n+    BOOST_CHECK(dbw.Read(key, res));\n+    BOOST_CHECK_EQUAL(res.ToString(), in.ToString());\n+}\n+\n+BOOST_AUTO_TEST_CASE(dbwrapper_maxopenfiles_1000)\n+{\n+    path ph = temp_directory_path() / unique_path();\n+    CDBWrapper dbw(ph, (1 << 20), true, false, false, false, 1000);\n+    char key = 'k';\n+    uint256 in = GetRandHash();\n+    uint256 res;\n+\n+    BOOST_CHECK(dbw.Write(key, in));\n+    BOOST_CHECK(dbw.Read(key, res));\n+    BOOST_CHECK_EQUAL(res.ToString(), in.ToString());\n+}\n+\n // Test batch operations\n BOOST_AUTO_TEST_CASE(dbwrapper_batch)\n {"
      }
    ]
  },
  {
    "sha": "50d53a471e70883a292d3028c1349fac7c9c54cf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MGQ1M2E0NzFlNzA4ODNhMjkyZDMwMjhjMTM0OWZhYzdjOWM1NGNm",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-06T00:24:42Z"
      },
      "committer": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-06T00:24:42Z"
      },
      "message": "doc: optional dbmaxopenfiles and dbcompression",
      "tree": {
        "sha": "2effccfac7ef4e2c63e0e03ce1623ac602344dd2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2effccfac7ef4e2c63e0e03ce1623ac602344dd2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/50d53a471e70883a292d3028c1349fac7c9c54cf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/50d53a471e70883a292d3028c1349fac7c9c54cf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/50d53a471e70883a292d3028c1349fac7c9c54cf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/50d53a471e70883a292d3028c1349fac7c9c54cf/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "7726e584cb441c7e384b9917c7fce2f7a3c25081",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7726e584cb441c7e384b9917c7fce2f7a3c25081",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7726e584cb441c7e384b9917c7fce2f7a3c25081"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "a42c4453091b7378c0d4b44c2b8faca4286a46e0",
        "filename": "contrib/devtools/check-doc.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50d53a471e70883a292d3028c1349fac7c9c54cf/contrib/devtools/check-doc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50d53a471e70883a292d3028c1349fac7c9c54cf/contrib/devtools/check-doc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/check-doc.py?ref=50d53a471e70883a292d3028c1349fac7c9c54cf",
        "patch": "@@ -21,7 +21,7 @@\n REGEX_ARG = re.compile(r'(?:map(?:Multi)?Args(?:\\.count\\(|\\[)|Get(?:Bool)?Arg\\()\\\"(\\-[^\\\"]+?)\\\"')\n REGEX_DOC = re.compile(r'HelpMessageOpt\\(\\\"(\\-[^\\\"=]+?)(?:=|\\\")')\n # list unsupported, deprecated and duplicate args as they need no documentation\n-SET_DOC_OPTIONAL = set(['-rpcssl', '-benchmark', '-h', '-help', '-socks', '-tor', '-debugnet', '-whitelistalwaysrelay', '-prematurewitness', '-walletprematurewitness', '-promiscuousmempoolflags', '-blockminsize'])\n+SET_DOC_OPTIONAL = set(['-rpcssl', '-benchmark', '-h', '-help', '-socks', '-tor', '-debugnet', '-whitelistalwaysrelay', '-prematurewitness', '-walletprematurewitness', '-promiscuousmempoolflags', '-blockminsize', '-dbmaxopenfiles', '-dbcompression'])\n \n def main():\n   used = check_output(CMD_GREP_ARGS, shell=True)"
      }
    ]
  },
  {
    "sha": "b1a487097218600914091f9fe9085535b14e1447",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMWE0ODcwOTcyMTg2MDA5MTQwOTFmOWZlOTA4NTUzNWIxNGUxNDQ3",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "courier@braydon.com",
        "date": "2016-10-07T02:04:59Z"
      },
      "committer": {
        "name": "Braydon Fuller",
        "email": "courier@braydon.com",
        "date": "2016-10-07T02:04:59Z"
      },
      "message": "tests: include and fix txindex test with rpc tests",
      "tree": {
        "sha": "5cb48b5886331491f4cea0cc569f9c439264f926",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5cb48b5886331491f4cea0cc569f9c439264f926"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b1a487097218600914091f9fe9085535b14e1447",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b1a487097218600914091f9fe9085535b14e1447",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b1a487097218600914091f9fe9085535b14e1447",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b1a487097218600914091f9fe9085535b14e1447/comments",
    "author": {
      "login": "braydonf",
      "id": 544777,
      "node_id": "MDQ6VXNlcjU0NDc3Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/544777?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/braydonf",
      "html_url": "https://github.com/braydonf",
      "followers_url": "https://api.github.com/users/braydonf/followers",
      "following_url": "https://api.github.com/users/braydonf/following{/other_user}",
      "gists_url": "https://api.github.com/users/braydonf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/braydonf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/braydonf/subscriptions",
      "organizations_url": "https://api.github.com/users/braydonf/orgs",
      "repos_url": "https://api.github.com/users/braydonf/repos",
      "events_url": "https://api.github.com/users/braydonf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/braydonf/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "braydonf",
      "id": 544777,
      "node_id": "MDQ6VXNlcjU0NDc3Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/544777?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/braydonf",
      "html_url": "https://github.com/braydonf",
      "followers_url": "https://api.github.com/users/braydonf/followers",
      "following_url": "https://api.github.com/users/braydonf/following{/other_user}",
      "gists_url": "https://api.github.com/users/braydonf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/braydonf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/braydonf/subscriptions",
      "organizations_url": "https://api.github.com/users/braydonf/orgs",
      "repos_url": "https://api.github.com/users/braydonf/repos",
      "events_url": "https://api.github.com/users/braydonf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/braydonf/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "50d53a471e70883a292d3028c1349fac7c9c54cf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/50d53a471e70883a292d3028c1349fac7c9c54cf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/50d53a471e70883a292d3028c1349fac7c9c54cf"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 7,
      "deletions": 6
    },
    "files": [
      {
        "sha": "95de1723d6da73581ba5d1a288c2393673c60e55",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1a487097218600914091f9fe9085535b14e1447/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1a487097218600914091f9fe9085535b14e1447/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=b1a487097218600914091f9fe9085535b14e1447",
        "patch": "@@ -130,6 +130,7 @@\n     'addressindex.py',\n     'timestampindex.py',\n     'spentindex.py',\n+    'txindex.py',\n     'decodescript.py',\n     'blockchain.py',\n     'disablewallet.py',"
      },
      {
        "sha": "08e176c96bfa9f7bd724911f0b6b9539a074a441",
        "filename": "qa/rpc-tests/txindex.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1a487097218600914091f9fe9085535b14e1447/qa/rpc-tests/txindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1a487097218600914091f9fe9085535b14e1447/qa/rpc-tests/txindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/txindex.py?ref=b1a487097218600914091f9fe9085535b14e1447",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python2\n+#!/usr/bin/env python3\n # Copyright (c) 2014-2015 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n@@ -36,22 +36,22 @@ def setup_network(self):\n         self.sync_all()\n \n     def run_test(self):\n-        print \"Mining blocks...\"\n+        print(\"Mining blocks...\")\n         self.nodes[0].generate(105)\n         self.sync_all()\n \n         chain_height = self.nodes[1].getblockcount()\n         assert_equal(chain_height, 105)\n \n-        print \"Testing transaction index...\"\n+        print(\"Testing transaction index...\")\n \n         privkey = \"cSdkPxkAjA4HDr5VHgsebAPDEh9Gyub4HK8UJr2DFGGqKKy4K5sG\"\n         address = \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\"\n-        addressHash = \"0b2f0a0c31bfe0406b0ccc1381fdbe311946dadc\".decode(\"hex\")\n+        addressHash = bytes([11,47,10,12,49,191,224,64,107,12,204,19,129,253,190,49,25,70,218,220])\n         scriptPubKey = CScript([OP_DUP, OP_HASH160, addressHash, OP_EQUALVERIFY, OP_CHECKSIG])\n         unspent = self.nodes[0].listunspent()\n         tx = CTransaction()\n-        amount = unspent[0][\"amount\"] * 100000000\n+        amount = int(unspent[0][\"amount\"] * 100000000)\n         tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n         tx.vout = [CTxOut(amount, scriptPubKey)]\n         tx.rehash()\n@@ -66,7 +66,7 @@ def run_test(self):\n         assert_equal(verbose[\"vout\"][0][\"valueSat\"], 5000000000);\n         assert_equal(verbose[\"vout\"][0][\"value\"], 50);\n \n-        print \"Passed\\n\"\n+        print(\"Passed\\n\")\n \n \n if __name__ == '__main__':"
      }
    ]
  },
  {
    "sha": "48228479f063bc33c98b3231d264101cd692a6be",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ODIyODQ3OWYwNjNiYzMzYzk4YjMyMzFkMjY0MTAxY2Q2OTJhNmJl",
    "commit": {
      "author": {
        "name": "Chris Kleeschulte",
        "email": "kleetus@users.noreply.github.com",
        "date": "2016-10-07T13:23:57Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2016-10-07T13:23:57Z"
      },
      "message": "Merge pull request #35 from braydonf/0.13-bitcore\n\nUpdate to 0.13.0",
      "tree": {
        "sha": "5cb48b5886331491f4cea0cc569f9c439264f926",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5cb48b5886331491f4cea0cc569f9c439264f926"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/48228479f063bc33c98b3231d264101cd692a6be",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/48228479f063bc33c98b3231d264101cd692a6be",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/48228479f063bc33c98b3231d264101cd692a6be",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/48228479f063bc33c98b3231d264101cd692a6be/comments",
    "author": {
      "login": "kleetus",
      "id": 12446,
      "node_id": "MDQ6VXNlcjEyNDQ2",
      "avatar_url": "https://avatars.githubusercontent.com/u/12446?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kleetus",
      "html_url": "https://github.com/kleetus",
      "followers_url": "https://api.github.com/users/kleetus/followers",
      "following_url": "https://api.github.com/users/kleetus/following{/other_user}",
      "gists_url": "https://api.github.com/users/kleetus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kleetus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kleetus/subscriptions",
      "organizations_url": "https://api.github.com/users/kleetus/orgs",
      "repos_url": "https://api.github.com/users/kleetus/repos",
      "events_url": "https://api.github.com/users/kleetus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kleetus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a402396dce64c42ea73535b7dde4a9164d430438",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a402396dce64c42ea73535b7dde4a9164d430438",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a402396dce64c42ea73535b7dde4a9164d430438"
      },
      {
        "sha": "b1a487097218600914091f9fe9085535b14e1447",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b1a487097218600914091f9fe9085535b14e1447",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b1a487097218600914091f9fe9085535b14e1447"
      }
    ],
    "stats": {
      "total": 2910,
      "additions": 2883,
      "deletions": 27
    },
    "files": [
      {
        "sha": "a42c4453091b7378c0d4b44c2b8faca4286a46e0",
        "filename": "contrib/devtools/check-doc.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/contrib/devtools/check-doc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/contrib/devtools/check-doc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/check-doc.py?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -21,7 +21,7 @@\n REGEX_ARG = re.compile(r'(?:map(?:Multi)?Args(?:\\.count\\(|\\[)|Get(?:Bool)?Arg\\()\\\"(\\-[^\\\"]+?)\\\"')\n REGEX_DOC = re.compile(r'HelpMessageOpt\\(\\\"(\\-[^\\\"=]+?)(?:=|\\\")')\n # list unsupported, deprecated and duplicate args as they need no documentation\n-SET_DOC_OPTIONAL = set(['-rpcssl', '-benchmark', '-h', '-help', '-socks', '-tor', '-debugnet', '-whitelistalwaysrelay', '-prematurewitness', '-walletprematurewitness', '-promiscuousmempoolflags', '-blockminsize'])\n+SET_DOC_OPTIONAL = set(['-rpcssl', '-benchmark', '-h', '-help', '-socks', '-tor', '-debugnet', '-whitelistalwaysrelay', '-prematurewitness', '-walletprematurewitness', '-promiscuousmempoolflags', '-blockminsize', '-dbmaxopenfiles', '-dbcompression'])\n \n def main():\n   used = check_output(CMD_GREP_ARGS, shell=True)"
      },
      {
        "sha": "95de1723d6da73581ba5d1a288c2393673c60e55",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -127,6 +127,10 @@\n     'signrawtransactions.py',\n     'nodehandling.py',\n     'reindex.py',\n+    'addressindex.py',\n+    'timestampindex.py',\n+    'spentindex.py',\n+    'txindex.py',\n     'decodescript.py',\n     'blockchain.py',\n     'disablewallet.py',"
      },
      {
        "sha": "6968e0dca8133fe91e0f7c81903a72ba3afc0d0d",
        "filename": "qa/rpc-tests/addressindex.py",
        "status": "added",
        "additions": 349,
        "deletions": 0,
        "changes": 349,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/qa/rpc-tests/addressindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/qa/rpc-tests/addressindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/addressindex.py?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -0,0 +1,349 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test addressindex generation and fetching\n+#\n+\n+import time\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.script import *\n+from test_framework.mininode import *\n+import binascii\n+\n+class AddressIndexTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 4)\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        # Nodes 0/1 are \"wallet\" nodes\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-relaypriority=0\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-addressindex\"]))\n+        # Nodes 2/3 are used for testing\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\", \"-addressindex\", \"-relaypriority=0\"]))\n+        self.nodes.append(start_node(3, self.options.tmpdir, [\"-debug\", \"-addressindex\"]))\n+        connect_nodes(self.nodes[0], 1)\n+        connect_nodes(self.nodes[0], 2)\n+        connect_nodes(self.nodes[0], 3)\n+\n+        self.is_network_split = False\n+        self.sync_all()\n+\n+    def run_test(self):\n+        print(\"Mining blocks...\")\n+        self.nodes[0].generate(105)\n+        self.sync_all()\n+\n+        chain_height = self.nodes[1].getblockcount()\n+        assert_equal(chain_height, 105)\n+        assert_equal(self.nodes[1].getbalance(), 0)\n+        assert_equal(self.nodes[2].getbalance(), 0)\n+\n+        # Check that balances are correct\n+        balance0 = self.nodes[1].getaddressbalance(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\")\n+        assert_equal(balance0[\"balance\"], 0)\n+\n+        # Check p2pkh and p2sh address indexes\n+        print(\"Testing p2pkh and p2sh address index...\")\n+\n+        txid0 = self.nodes[0].sendtoaddress(\"mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs\", 10)\n+        self.nodes[0].generate(1)\n+\n+        txidb0 = self.nodes[0].sendtoaddress(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\", 10)\n+        self.nodes[0].generate(1)\n+\n+        txid1 = self.nodes[0].sendtoaddress(\"mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs\", 15)\n+        self.nodes[0].generate(1)\n+\n+        txidb1 = self.nodes[0].sendtoaddress(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\", 15)\n+        self.nodes[0].generate(1)\n+\n+        txid2 = self.nodes[0].sendtoaddress(\"mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs\", 20)\n+        self.nodes[0].generate(1)\n+\n+        txidb2 = self.nodes[0].sendtoaddress(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\", 20)\n+        self.nodes[0].generate(1)\n+\n+        self.sync_all()\n+\n+        txids = self.nodes[1].getaddresstxids(\"mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs\")\n+        assert_equal(len(txids), 3)\n+        assert_equal(txids[0], txid0)\n+        assert_equal(txids[1], txid1)\n+        assert_equal(txids[2], txid2)\n+\n+        txidsb = self.nodes[1].getaddresstxids(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\")\n+        assert_equal(len(txidsb), 3)\n+        assert_equal(txidsb[0], txidb0)\n+        assert_equal(txidsb[1], txidb1)\n+        assert_equal(txidsb[2], txidb2)\n+\n+        # Check that limiting by height works\n+        print(\"Testing querying txids by range of block heights..\")\n+        height_txids = self.nodes[1].getaddresstxids({\n+            \"addresses\": [\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\"],\n+            \"start\": 105,\n+            \"end\": 110\n+        })\n+        assert_equal(len(height_txids), 2)\n+        assert_equal(height_txids[0], txidb0)\n+        assert_equal(height_txids[1], txidb1)\n+\n+        # Check that multiple addresses works\n+        multitxids = self.nodes[1].getaddresstxids({\"addresses\": [\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\", \"mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs\"]})\n+        assert_equal(len(multitxids), 6)\n+        assert_equal(multitxids[0], txid0)\n+        assert_equal(multitxids[1], txidb0)\n+        assert_equal(multitxids[2], txid1)\n+        assert_equal(multitxids[3], txidb1)\n+        assert_equal(multitxids[4], txid2)\n+        assert_equal(multitxids[5], txidb2)\n+\n+        # Check that balances are correct\n+        balance0 = self.nodes[1].getaddressbalance(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\")\n+        assert_equal(balance0[\"balance\"], 45 * 100000000)\n+\n+        # Check that outputs with the same address will only return one txid\n+        print(\"Testing for txid uniqueness...\")\n+        addressHash = bytes([99,73,164,24,252,69,120,209,10,55,43,84,180,92,40,12,200,196,56,47])\n+        scriptPubKey = CScript([OP_HASH160, addressHash, OP_EQUAL])\n+        unspent = self.nodes[0].listunspent()\n+        tx = CTransaction()\n+        tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n+        tx.vout = [CTxOut(10, scriptPubKey), CTxOut(11, scriptPubKey)]\n+        tx.rehash()\n+\n+        signed_tx = self.nodes[0].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        sent_txid = self.nodes[0].sendrawtransaction(signed_tx[\"hex\"], True)\n+\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        txidsmany = self.nodes[1].getaddresstxids(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\")\n+        assert_equal(len(txidsmany), 4)\n+        assert_equal(txidsmany[3], sent_txid)\n+\n+        # Check that balances are correct\n+        print(\"Testing balances...\")\n+        balance0 = self.nodes[1].getaddressbalance(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\")\n+        assert_equal(balance0[\"balance\"], 45 * 100000000 + 21)\n+\n+        # Check that balances are correct after spending\n+        print(\"Testing balances after spending...\")\n+        privkey2 = \"cSdkPxkAjA4HDr5VHgsebAPDEh9Gyub4HK8UJr2DFGGqKKy4K5sG\"\n+        address2 = \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\"\n+        addressHash2 = bytes([11,47,10,12,49,191,224,64,107,12,204,19,129,253,190,49,25,70,218,220])\n+        scriptPubKey2 = CScript([OP_DUP, OP_HASH160, addressHash2, OP_EQUALVERIFY, OP_CHECKSIG])\n+        self.nodes[0].importprivkey(privkey2)\n+\n+        unspent = self.nodes[0].listunspent()\n+        tx = CTransaction()\n+        tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n+        amount = int(unspent[0][\"amount\"] * 100000000 - 100000)\n+        tx.vout = [CTxOut(amount, scriptPubKey2)]\n+        tx.rehash()\n+        signed_tx = self.nodes[0].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        spending_txid = self.nodes[0].sendrawtransaction(signed_tx[\"hex\"], True)\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        balance1 = self.nodes[1].getaddressbalance(address2)\n+        assert_equal(balance1[\"balance\"], amount)\n+\n+        tx = CTransaction()\n+        tx.vin = [CTxIn(COutPoint(int(spending_txid, 16), 0))]\n+        send_amount = 1 * 100000000 + 12840\n+        change_amount = amount - send_amount - 10000\n+        tx.vout = [CTxOut(change_amount, scriptPubKey2), CTxOut(send_amount, scriptPubKey)]\n+        tx.rehash()\n+\n+        signed_tx = self.nodes[0].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        sent_txid = self.nodes[0].sendrawtransaction(signed_tx[\"hex\"], True)\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        balance2 = self.nodes[1].getaddressbalance(address2)\n+        assert_equal(balance2[\"balance\"], change_amount)\n+\n+        # Check that deltas are returned correctly\n+        deltas = self.nodes[1].getaddressdeltas({\"addresses\": [address2], \"start\": 1, \"end\": 200})\n+        balance3 = 0\n+        for delta in deltas:\n+            balance3 += delta[\"satoshis\"]\n+        assert_equal(balance3, change_amount)\n+        assert_equal(deltas[0][\"address\"], address2)\n+        assert_equal(deltas[0][\"blockindex\"], 1)\n+\n+        # Check that entire range will be queried\n+        deltasAll = self.nodes[1].getaddressdeltas({\"addresses\": [address2]})\n+        assert_equal(len(deltasAll), len(deltas))\n+\n+        # Check that deltas can be returned from range of block heights\n+        deltas = self.nodes[1].getaddressdeltas({\"addresses\": [address2], \"start\": 113, \"end\": 113})\n+        assert_equal(len(deltas), 1)\n+\n+        # Check that unspent outputs can be queried\n+        print(\"Testing utxos...\")\n+        utxos = self.nodes[1].getaddressutxos({\"addresses\": [address2]})\n+        assert_equal(len(utxos), 1)\n+        assert_equal(utxos[0][\"satoshis\"], change_amount)\n+\n+        # Check that indexes will be updated with a reorg\n+        print(\"Testing reorg...\")\n+\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        self.nodes[1].invalidateblock(best_hash)\n+        self.nodes[2].invalidateblock(best_hash)\n+        self.nodes[3].invalidateblock(best_hash)\n+        self.sync_all()\n+\n+        balance4 = self.nodes[1].getaddressbalance(address2)\n+        assert_equal(balance4, balance1)\n+\n+        utxos2 = self.nodes[1].getaddressutxos({\"addresses\": [address2]})\n+        assert_equal(len(utxos2), 1)\n+        assert_equal(utxos2[0][\"satoshis\"], amount)\n+\n+        # Check sorting of utxos\n+        self.nodes[2].generate(150)\n+\n+        txidsort1 = self.nodes[2].sendtoaddress(address2, 50)\n+        self.nodes[2].generate(1)\n+        txidsort2 = self.nodes[2].sendtoaddress(address2, 50)\n+        self.nodes[2].generate(1)\n+        self.sync_all()\n+\n+        utxos3 = self.nodes[1].getaddressutxos({\"addresses\": [address2]})\n+        assert_equal(len(utxos3), 3)\n+        assert_equal(utxos3[0][\"height\"], 114)\n+        assert_equal(utxos3[1][\"height\"], 264)\n+        assert_equal(utxos3[2][\"height\"], 265)\n+\n+        # Check mempool indexing\n+        print(\"Testing mempool indexing...\")\n+\n+        privKey3 = \"cVfUn53hAbRrDEuMexyfgDpZPhF7KqXpS8UZevsyTDaugB7HZ3CD\"\n+        address3 = \"mw4ynwhS7MmrQ27hr82kgqu7zryNDK26JB\"\n+        addressHash3 = bytes([170,152,114,181,187,205,181,17,216,158,14,17,170,39,218,115,253,44,63,80])\n+        scriptPubKey3 = CScript([OP_DUP, OP_HASH160, addressHash3, OP_EQUALVERIFY, OP_CHECKSIG])\n+        address4 = \"2N8oFVB2vThAKury4vnLquW2zVjsYjjAkYQ\"\n+        scriptPubKey4 = CScript([OP_HASH160, addressHash3, OP_EQUAL])\n+        unspent = self.nodes[2].listunspent()\n+\n+        tx = CTransaction()\n+        tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n+        amount = int(unspent[0][\"amount\"] * 100000000 - 100000)\n+        tx.vout = [CTxOut(amount, scriptPubKey3)]\n+        tx.rehash()\n+        signed_tx = self.nodes[2].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        memtxid1 = self.nodes[2].sendrawtransaction(signed_tx[\"hex\"], True)\n+        time.sleep(2)\n+\n+        tx2 = CTransaction()\n+        tx2.vin = [CTxIn(COutPoint(int(unspent[1][\"txid\"], 16), unspent[1][\"vout\"]))]\n+        amount = int(unspent[1][\"amount\"] * 100000000 - 100000)\n+        tx2.vout = [\n+            CTxOut(int(amount / 4), scriptPubKey3),\n+            CTxOut(int(amount / 4), scriptPubKey3),\n+            CTxOut(int(amount / 4), scriptPubKey4),\n+            CTxOut(int(amount / 4), scriptPubKey4)\n+        ]\n+        tx2.rehash()\n+        signed_tx2 = self.nodes[2].signrawtransaction(binascii.hexlify(tx2.serialize()).decode(\"utf-8\"))\n+        memtxid2 = self.nodes[2].sendrawtransaction(signed_tx2[\"hex\"], True)\n+        time.sleep(2)\n+\n+        mempool = self.nodes[2].getaddressmempool({\"addresses\": [address3]})\n+        assert_equal(len(mempool), 3)\n+        assert_equal(mempool[0][\"txid\"], memtxid1)\n+        assert_equal(mempool[0][\"address\"], address3)\n+        assert_equal(mempool[0][\"index\"], 0)\n+        assert_equal(mempool[1][\"txid\"], memtxid2)\n+        assert_equal(mempool[1][\"index\"], 0)\n+        assert_equal(mempool[2][\"txid\"], memtxid2)\n+        assert_equal(mempool[2][\"index\"], 1)\n+\n+        blk_hashes = self.nodes[2].generate(1);\n+        self.sync_all();\n+        mempool2 = self.nodes[2].getaddressmempool({\"addresses\": [address3]})\n+        assert_equal(len(mempool2), 0)\n+\n+        tx = CTransaction()\n+        tx.vin = [\n+            CTxIn(COutPoint(int(memtxid2, 16), 0)),\n+            CTxIn(COutPoint(int(memtxid2, 16), 1))\n+        ]\n+        tx.vout = [CTxOut(int(amount / 2 - 10000), scriptPubKey2)]\n+        tx.rehash()\n+        self.nodes[2].importprivkey(privKey3)\n+        signed_tx3 = self.nodes[2].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        memtxid3 = self.nodes[2].sendrawtransaction(signed_tx3[\"hex\"], True)\n+        time.sleep(2)\n+\n+        mempool3 = self.nodes[2].getaddressmempool({\"addresses\": [address3]})\n+        assert_equal(len(mempool3), 2)\n+        assert_equal(mempool3[0][\"prevtxid\"], memtxid2)\n+        assert_equal(mempool3[0][\"prevout\"], 0)\n+        assert_equal(mempool3[1][\"prevtxid\"], memtxid2)\n+        assert_equal(mempool3[1][\"prevout\"], 1)\n+\n+        # sending and receiving to the same address\n+        privkey1 = \"cQY2s58LhzUCmEXN8jtAp1Etnijx78YRZ466w4ikX1V4UpTpbsf8\"\n+        address1 = \"myAUWSHnwsQrhuMWv4Br6QsCnpB41vFwHn\"\n+        address1hash = bytes([193,146,191,247,81,175,142,254,193,81,53,212,43,254,237,249,26,111,62,52])\n+        address1script = CScript([OP_DUP, OP_HASH160, address1hash, OP_EQUALVERIFY, OP_CHECKSIG])\n+\n+        self.nodes[0].sendtoaddress(address1, 10)\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        utxos = self.nodes[1].getaddressutxos({\"addresses\": [address1]})\n+        assert_equal(len(utxos), 1)\n+\n+        tx = CTransaction()\n+        tx.vin = [\n+            CTxIn(COutPoint(int(utxos[0][\"txid\"], 16), utxos[0][\"outputIndex\"]))\n+        ]\n+        amount = int(utxos[0][\"satoshis\"] - 1000)\n+        tx.vout = [CTxOut(amount, address1script)]\n+        tx.rehash()\n+        self.nodes[0].importprivkey(privkey1)\n+        signed_tx = self.nodes[0].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        mem_txid = self.nodes[0].sendrawtransaction(signed_tx[\"hex\"], True)\n+\n+        self.sync_all()\n+        mempool_deltas = self.nodes[2].getaddressmempool({\"addresses\": [address1]})\n+        assert_equal(len(mempool_deltas), 2)\n+\n+        # Include chaininfo in results\n+        print(\"Testing results with chain info...\")\n+\n+        deltas_with_info = self.nodes[1].getaddressdeltas({\n+            \"addresses\": [address2],\n+            \"start\": 1,\n+            \"end\": 200,\n+            \"chainInfo\": True\n+        })\n+        start_block_hash = self.nodes[1].getblockhash(1);\n+        end_block_hash = self.nodes[1].getblockhash(200);\n+        assert_equal(deltas_with_info[\"start\"][\"height\"], 1)\n+        assert_equal(deltas_with_info[\"start\"][\"hash\"], start_block_hash)\n+        assert_equal(deltas_with_info[\"end\"][\"height\"], 200)\n+        assert_equal(deltas_with_info[\"end\"][\"hash\"], end_block_hash)\n+\n+        utxos_with_info = self.nodes[1].getaddressutxos({\"addresses\": [address2], \"chainInfo\": True})\n+        expected_tip_block_hash = self.nodes[1].getblockhash(267);\n+        assert_equal(utxos_with_info[\"height\"], 267)\n+        assert_equal(utxos_with_info[\"hash\"], expected_tip_block_hash)\n+\n+        print(\"Passed\\n\")\n+\n+\n+if __name__ == '__main__':\n+    AddressIndexTest().main()"
      },
      {
        "sha": "4119a11aef04ea97a44eaa2a9d2225ef24ae483b",
        "filename": "qa/rpc-tests/spentindex.py",
        "status": "added",
        "additions": 141,
        "deletions": 0,
        "changes": 141,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/qa/rpc-tests/spentindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/qa/rpc-tests/spentindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/spentindex.py?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -0,0 +1,141 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test addressindex generation and fetching\n+#\n+\n+import time\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.script import *\n+from test_framework.mininode import *\n+import binascii\n+\n+class SpentIndexTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 4)\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        # Nodes 0/1 are \"wallet\" nodes\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-spentindex\"]))\n+        # Nodes 2/3 are used for testing\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\", \"-spentindex\"]))\n+        self.nodes.append(start_node(3, self.options.tmpdir, [\"-debug\", \"-spentindex\", \"-txindex\"]))\n+        connect_nodes(self.nodes[0], 1)\n+        connect_nodes(self.nodes[0], 2)\n+        connect_nodes(self.nodes[0], 3)\n+\n+        self.is_network_split = False\n+        self.sync_all()\n+\n+    def run_test(self):\n+        print(\"Mining blocks...\")\n+        self.nodes[0].generate(105)\n+        self.sync_all()\n+\n+        chain_height = self.nodes[1].getblockcount()\n+        assert_equal(chain_height, 105)\n+\n+        # Check that\n+        print(\"Testing spent index...\")\n+\n+        feeSatoshis = 10000\n+        privkey = \"cSdkPxkAjA4HDr5VHgsebAPDEh9Gyub4HK8UJr2DFGGqKKy4K5sG\"\n+        address = \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\"\n+        addressHash = bytes([11,47,10,12,49,191,224,64,107,12,204,19,129,253,190,49,25,70,218,220])\n+        scriptPubKey = CScript([OP_DUP, OP_HASH160, addressHash, OP_EQUALVERIFY, OP_CHECKSIG])\n+        unspent = self.nodes[0].listunspent()\n+        tx = CTransaction()\n+        amount = int(unspent[0][\"amount\"] * 100000000 - feeSatoshis)\n+        tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n+        tx.vout = [CTxOut(amount, scriptPubKey)]\n+        tx.rehash()\n+\n+        signed_tx = self.nodes[0].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        txid = self.nodes[0].sendrawtransaction(signed_tx[\"hex\"], True)\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        print(\"Testing getspentinfo method...\")\n+\n+        # Check that the spentinfo works standalone\n+        info = self.nodes[1].getspentinfo({\"txid\": unspent[0][\"txid\"], \"index\": unspent[0][\"vout\"]})\n+        assert_equal(info[\"txid\"], txid)\n+        assert_equal(info[\"index\"], 0)\n+        assert_equal(info[\"height\"], 106)\n+\n+        print(\"Testing getrawtransaction method...\")\n+\n+        # Check that verbose raw transaction includes spent info\n+        txVerbose = self.nodes[3].getrawtransaction(unspent[0][\"txid\"], 1)\n+        assert_equal(txVerbose[\"vout\"][unspent[0][\"vout\"]][\"spentTxId\"], txid)\n+        assert_equal(txVerbose[\"vout\"][unspent[0][\"vout\"]][\"spentIndex\"], 0)\n+        assert_equal(txVerbose[\"vout\"][unspent[0][\"vout\"]][\"spentHeight\"], 106)\n+\n+        # Check that verbose raw transaction includes input values\n+        txVerbose2 = self.nodes[3].getrawtransaction(txid, 1)\n+        assert_equal(float(txVerbose2[\"vin\"][0][\"value\"]), (amount + feeSatoshis) / 100000000)\n+        assert_equal(txVerbose2[\"vin\"][0][\"valueSat\"], amount + feeSatoshis)\n+\n+        # Check that verbose raw transaction includes address values and input values\n+        privkey2 = \"cSdkPxkAjA4HDr5VHgsebAPDEh9Gyub4HK8UJr2DFGGqKKy4K5sG\"\n+        address2 = \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\"\n+        addressHash2 = bytes([11,47,10,12,49,191,224,64,107,12,204,19,129,253,190,49,25,70,218,220])\n+        scriptPubKey2 = CScript([OP_DUP, OP_HASH160, addressHash2, OP_EQUALVERIFY, OP_CHECKSIG])\n+        tx2 = CTransaction()\n+        tx2.vin = [CTxIn(COutPoint(int(txid, 16), 0))]\n+        amount = int(amount - feeSatoshis);\n+        tx2.vout = [CTxOut(amount, scriptPubKey2)]\n+        tx.rehash()\n+        self.nodes[0].importprivkey(privkey)\n+        signed_tx2 = self.nodes[0].signrawtransaction(binascii.hexlify(tx2.serialize()).decode(\"utf-8\"))\n+        txid2 = self.nodes[0].sendrawtransaction(signed_tx2[\"hex\"], True)\n+\n+        # Check the mempool index\n+        self.sync_all()\n+        txVerbose3 = self.nodes[1].getrawtransaction(txid2, 1)\n+        assert_equal(txVerbose3[\"vin\"][0][\"address\"], address2)\n+        assert_equal(txVerbose3[\"vin\"][0][\"valueSat\"], amount + feeSatoshis)\n+        assert_equal(float(txVerbose3[\"vin\"][0][\"value\"]), (amount + feeSatoshis) / 100000000)\n+\n+\n+        # Check the database index\n+        block_hash = self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        txVerbose4 = self.nodes[3].getrawtransaction(txid2, 1)\n+        assert_equal(txVerbose4[\"vin\"][0][\"address\"], address2)\n+        assert_equal(txVerbose4[\"vin\"][0][\"valueSat\"], amount + feeSatoshis)\n+        assert_equal(float(txVerbose4[\"vin\"][0][\"value\"]), (amount + feeSatoshis) / 100000000)\n+\n+        # Check block deltas\n+        print(\"Testing getblockdeltas...\")\n+\n+        block = self.nodes[3].getblockdeltas(block_hash[0])\n+        assert_equal(len(block[\"deltas\"]), 2)\n+        assert_equal(block[\"deltas\"][0][\"index\"], 0)\n+        assert_equal(len(block[\"deltas\"][0][\"inputs\"]), 0)\n+        assert_equal(len(block[\"deltas\"][0][\"outputs\"]), 0)\n+        assert_equal(block[\"deltas\"][1][\"index\"], 1)\n+        assert_equal(block[\"deltas\"][1][\"txid\"], txid2)\n+        assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"index\"], 0)\n+        assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"address\"], \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\")\n+        assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"satoshis\"], (amount + feeSatoshis) * -1)\n+        assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"prevtxid\"], txid)\n+        assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"prevout\"], 0)\n+        assert_equal(block[\"deltas\"][1][\"outputs\"][0][\"index\"], 0)\n+        assert_equal(block[\"deltas\"][1][\"outputs\"][0][\"address\"], \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\")\n+        assert_equal(block[\"deltas\"][1][\"outputs\"][0][\"satoshis\"], amount)\n+\n+        print(\"Passed\\n\")\n+\n+\n+if __name__ == '__main__':\n+    SpentIndexTest().main()"
      },
      {
        "sha": "85942b7ef6929f2e43d29168815d87ac415d610a",
        "filename": "qa/rpc-tests/timestampindex.py",
        "status": "added",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/qa/rpc-tests/timestampindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/qa/rpc-tests/timestampindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/timestampindex.py?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -0,0 +1,61 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test timestampindex generation and fetching\n+#\n+\n+import time\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+\n+class TimestampIndexTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 4)\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        # Nodes 0/1 are \"wallet\" nodes\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-timestampindex\"]))\n+        # Nodes 2/3 are used for testing\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\"]))\n+        self.nodes.append(start_node(3, self.options.tmpdir, [\"-debug\", \"-timestampindex\"]))\n+        connect_nodes(self.nodes[0], 1)\n+        connect_nodes(self.nodes[0], 2)\n+        connect_nodes(self.nodes[0], 3)\n+\n+        self.is_network_split = False\n+        self.sync_all()\n+\n+    def run_test(self):\n+        print(\"Mining 25 blocks...\")\n+        blockhashes = self.nodes[0].generate(25)\n+        time.sleep(3)\n+        print(\"Mining 25 blocks...\")\n+        blockhashes.extend(self.nodes[0].generate(25))\n+        time.sleep(3)\n+        print(\"Mining 25 blocks...\")\n+        blockhashes.extend(self.nodes[0].generate(25))\n+        self.sync_all()\n+        low = self.nodes[1].getblock(blockhashes[0])[\"time\"]\n+        high = low + 76\n+\n+        print(\"Checking timestamp index...\")\n+        hashes = self.nodes[1].getblockhashes(high, low)\n+\n+        assert_equal(len(hashes), len(blockhashes))\n+\n+        assert_equal(hashes, blockhashes)\n+\n+        print(\"Passed\\n\")\n+\n+\n+if __name__ == '__main__':\n+    TimestampIndexTest().main()"
      },
      {
        "sha": "08e176c96bfa9f7bd724911f0b6b9539a074a441",
        "filename": "qa/rpc-tests/txindex.py",
        "status": "added",
        "additions": 73,
        "deletions": 0,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/qa/rpc-tests/txindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/qa/rpc-tests/txindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/txindex.py?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -0,0 +1,73 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test txindex generation and fetching\n+#\n+\n+import time\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.script import *\n+from test_framework.mininode import *\n+import binascii\n+\n+class TxIndexTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 4)\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        # Nodes 0/1 are \"wallet\" nodes\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-txindex\"]))\n+        # Nodes 2/3 are used for testing\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\", \"-txindex\"]))\n+        self.nodes.append(start_node(3, self.options.tmpdir, [\"-debug\", \"-txindex\"]))\n+        connect_nodes(self.nodes[0], 1)\n+        connect_nodes(self.nodes[0], 2)\n+        connect_nodes(self.nodes[0], 3)\n+\n+        self.is_network_split = False\n+        self.sync_all()\n+\n+    def run_test(self):\n+        print(\"Mining blocks...\")\n+        self.nodes[0].generate(105)\n+        self.sync_all()\n+\n+        chain_height = self.nodes[1].getblockcount()\n+        assert_equal(chain_height, 105)\n+\n+        print(\"Testing transaction index...\")\n+\n+        privkey = \"cSdkPxkAjA4HDr5VHgsebAPDEh9Gyub4HK8UJr2DFGGqKKy4K5sG\"\n+        address = \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\"\n+        addressHash = bytes([11,47,10,12,49,191,224,64,107,12,204,19,129,253,190,49,25,70,218,220])\n+        scriptPubKey = CScript([OP_DUP, OP_HASH160, addressHash, OP_EQUALVERIFY, OP_CHECKSIG])\n+        unspent = self.nodes[0].listunspent()\n+        tx = CTransaction()\n+        amount = int(unspent[0][\"amount\"] * 100000000)\n+        tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n+        tx.vout = [CTxOut(amount, scriptPubKey)]\n+        tx.rehash()\n+\n+        signed_tx = self.nodes[0].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        txid = self.nodes[0].sendrawtransaction(signed_tx[\"hex\"], True)\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        # Check verbose raw transaction results\n+        verbose = self.nodes[3].getrawtransaction(unspent[0][\"txid\"], 1)\n+        assert_equal(verbose[\"vout\"][0][\"valueSat\"], 5000000000);\n+        assert_equal(verbose[\"vout\"][0][\"value\"], 50);\n+\n+        print(\"Passed\\n\")\n+\n+\n+if __name__ == '__main__':\n+    TxIndexTest().main()"
      },
      {
        "sha": "f135f567eb7b242943a0d6dfe5d8bf8c5bf4993c",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -71,6 +71,8 @@ endif\n .PHONY: FORCE check-symbols check-security\n # bitcoin core #\n BITCOIN_CORE_H = \\\n+  addressindex.h \\\n+  spentindex.h \\\n   addrman.h \\\n   base58.h \\\n   bloom.h \\"
      },
      {
        "sha": "22031da95f94ceb56427c672c87e51168125e170",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -72,6 +72,7 @@ BITCOIN_TESTS =\\\n   test/sanity_tests.cpp \\\n   test/scheduler_tests.cpp \\\n   test/script_P2SH_tests.cpp \\\n+  test/script_P2PKH_tests.cpp \\\n   test/script_tests.cpp \\\n   test/scriptnum_tests.cpp \\\n   test/serialize_tests.cpp \\"
      },
      {
        "sha": "dbb09c7fe9b4c4e2d76a1facdc57d031520c498f",
        "filename": "src/addressindex.h",
        "status": "added",
        "additions": 295,
        "deletions": 0,
        "changes": 295,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/addressindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/addressindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addressindex.h?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -0,0 +1,295 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_ADDRESSINDEX_H\n+#define BITCOIN_ADDRESSINDEX_H\n+\n+#include \"uint256.h\"\n+#include \"amount.h\"\n+#include \"script/script.h\"\n+\n+struct CAddressUnspentKey {\n+    unsigned int type;\n+    uint160 hashBytes;\n+    uint256 txhash;\n+    size_t index;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 57;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata8(s, type);\n+        hashBytes.Serialize(s, nType, nVersion);\n+        txhash.Serialize(s, nType, nVersion);\n+        ser_writedata32(s, index);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        type = ser_readdata8(s);\n+        hashBytes.Unserialize(s, nType, nVersion);\n+        txhash.Unserialize(s, nType, nVersion);\n+        index = ser_readdata32(s);\n+    }\n+\n+    CAddressUnspentKey(unsigned int addressType, uint160 addressHash, uint256 txid, size_t indexValue) {\n+        type = addressType;\n+        hashBytes = addressHash;\n+        txhash = txid;\n+        index = indexValue;\n+    }\n+\n+    CAddressUnspentKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        type = 0;\n+        hashBytes.SetNull();\n+        txhash.SetNull();\n+        index = 0;\n+    }\n+};\n+\n+struct CAddressUnspentValue {\n+    CAmount satoshis;\n+    CScript script;\n+    int blockHeight;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(satoshis);\n+        READWRITE(*(CScriptBase*)(&script));\n+        READWRITE(blockHeight);\n+    }\n+\n+    CAddressUnspentValue(CAmount sats, CScript scriptPubKey, int height) {\n+        satoshis = sats;\n+        script = scriptPubKey;\n+        blockHeight = height;\n+    }\n+\n+    CAddressUnspentValue() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        satoshis = -1;\n+        script.clear();\n+        blockHeight = 0;\n+    }\n+\n+    bool IsNull() const {\n+        return (satoshis == -1);\n+    }\n+};\n+\n+struct CAddressIndexKey {\n+    unsigned int type;\n+    uint160 hashBytes;\n+    int blockHeight;\n+    unsigned int txindex;\n+    uint256 txhash;\n+    size_t index;\n+    bool spending;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 66;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata8(s, type);\n+        hashBytes.Serialize(s, nType, nVersion);\n+        // Heights are stored big-endian for key sorting in LevelDB\n+        ser_writedata32be(s, blockHeight);\n+        ser_writedata32be(s, txindex);\n+        txhash.Serialize(s, nType, nVersion);\n+        ser_writedata32(s, index);\n+        char f = spending;\n+        ser_writedata8(s, f);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        type = ser_readdata8(s);\n+        hashBytes.Unserialize(s, nType, nVersion);\n+        blockHeight = ser_readdata32be(s);\n+        txindex = ser_readdata32be(s);\n+        txhash.Unserialize(s, nType, nVersion);\n+        index = ser_readdata32(s);\n+        char f = ser_readdata8(s);\n+        spending = f;\n+    }\n+\n+    CAddressIndexKey(unsigned int addressType, uint160 addressHash, int height, int blockindex,\n+                     uint256 txid, size_t indexValue, bool isSpending) {\n+        type = addressType;\n+        hashBytes = addressHash;\n+        blockHeight = height;\n+        txindex = blockindex;\n+        txhash = txid;\n+        index = indexValue;\n+        spending = isSpending;\n+    }\n+\n+    CAddressIndexKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        type = 0;\n+        hashBytes.SetNull();\n+        blockHeight = 0;\n+        txindex = 0;\n+        txhash.SetNull();\n+        index = 0;\n+        spending = false;\n+    }\n+\n+};\n+\n+struct CAddressIndexIteratorKey {\n+    unsigned int type;\n+    uint160 hashBytes;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 21;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata8(s, type);\n+        hashBytes.Serialize(s, nType, nVersion);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        type = ser_readdata8(s);\n+        hashBytes.Unserialize(s, nType, nVersion);\n+    }\n+\n+    CAddressIndexIteratorKey(unsigned int addressType, uint160 addressHash) {\n+        type = addressType;\n+        hashBytes = addressHash;\n+    }\n+\n+    CAddressIndexIteratorKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        type = 0;\n+        hashBytes.SetNull();\n+    }\n+};\n+\n+struct CAddressIndexIteratorHeightKey {\n+    unsigned int type;\n+    uint160 hashBytes;\n+    int blockHeight;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 25;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata8(s, type);\n+        hashBytes.Serialize(s, nType, nVersion);\n+        ser_writedata32be(s, blockHeight);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        type = ser_readdata8(s);\n+        hashBytes.Unserialize(s, nType, nVersion);\n+        blockHeight = ser_readdata32be(s);\n+    }\n+\n+    CAddressIndexIteratorHeightKey(unsigned int addressType, uint160 addressHash, int height) {\n+        type = addressType;\n+        hashBytes = addressHash;\n+        blockHeight = height;\n+    }\n+\n+    CAddressIndexIteratorHeightKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        type = 0;\n+        hashBytes.SetNull();\n+        blockHeight = 0;\n+    }\n+};\n+\n+struct CMempoolAddressDelta\n+{\n+    int64_t time;\n+    CAmount amount;\n+    uint256 prevhash;\n+    unsigned int prevout;\n+\n+    CMempoolAddressDelta(int64_t t, CAmount a, uint256 hash, unsigned int out) {\n+        time = t;\n+        amount = a;\n+        prevhash = hash;\n+        prevout = out;\n+    }\n+\n+    CMempoolAddressDelta(int64_t t, CAmount a) {\n+        time = t;\n+        amount = a;\n+        prevhash.SetNull();\n+        prevout = 0;\n+    }\n+};\n+\n+struct CMempoolAddressDeltaKey\n+{\n+    int type;\n+    uint160 addressBytes;\n+    uint256 txhash;\n+    unsigned int index;\n+    int spending;\n+\n+    CMempoolAddressDeltaKey(int addressType, uint160 addressHash, uint256 hash, unsigned int i, int s) {\n+        type = addressType;\n+        addressBytes = addressHash;\n+        txhash = hash;\n+        index = i;\n+        spending = s;\n+    }\n+\n+    CMempoolAddressDeltaKey(int addressType, uint160 addressHash) {\n+        type = addressType;\n+        addressBytes = addressHash;\n+        txhash.SetNull();\n+        index = 0;\n+        spending = 0;\n+    }\n+};\n+\n+struct CMempoolAddressDeltaKeyCompare\n+{\n+    bool operator()(const CMempoolAddressDeltaKey& a, const CMempoolAddressDeltaKey& b) const {\n+        if (a.type == b.type) {\n+            if (a.addressBytes == b.addressBytes) {\n+                if (a.txhash == b.txhash) {\n+                    if (a.index == b.index) {\n+                        return a.spending < b.spending;\n+                    } else {\n+                        return a.index < b.index;\n+                    }\n+                } else {\n+                    return a.txhash < b.txhash;\n+                }\n+            } else {\n+                return a.addressBytes < b.addressBytes;\n+            }\n+        } else {\n+            return a.type < b.type;\n+        }\n+    }\n+};\n+\n+#endif // BITCOIN_ADDRESSINDEX_H"
      },
      {
        "sha": "ab7eed4f344bd744962b0f1009ac67f5f4863e2e",
        "filename": "src/base58.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.cpp?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -267,6 +267,23 @@ CTxDestination CBitcoinAddress::Get() const\n         return CNoDestination();\n }\n \n+bool CBitcoinAddress::GetIndexKey(uint160& hashBytes, int& type) const\n+{\n+    if (!IsValid()) {\n+        return false;\n+    } else if (vchVersion == Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS)) {\n+        memcpy(&hashBytes, &vchData[0], 20);\n+        type = 1;\n+        return true;\n+    } else if (vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS)) {\n+        memcpy(&hashBytes, &vchData[0], 20);\n+        type = 2;\n+        return true;\n+    }\n+\n+    return false;\n+}\n+\n bool CBitcoinAddress::GetKeyID(CKeyID& keyID) const\n {\n     if (!IsValid() || vchVersion != Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS))"
      },
      {
        "sha": "6c2297e220838fdc24f0f2dc61cbde0c01ad3cf2",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -116,6 +116,7 @@ class CBitcoinAddress : public CBase58Data {\n \n     CTxDestination Get() const;\n     bool GetKeyID(CKeyID &keyID) const;\n+    bool GetIndexKey(uint160& hashBytes, int& type) const;\n     bool IsScript() const;\n };\n "
      },
      {
        "sha": "74d9c7bbe93e8e663dc13b91911cae9558416ce4",
        "filename": "src/dbwrapper.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/dbwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/dbwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.cpp?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -15,14 +15,14 @@\n #include <memenv.h>\n #include <stdint.h>\n \n-static leveldb::Options GetOptions(size_t nCacheSize)\n+static leveldb::Options GetOptions(size_t nCacheSize, bool compression, int maxOpenFiles)\n {\n     leveldb::Options options;\n     options.block_cache = leveldb::NewLRUCache(nCacheSize / 2);\n     options.write_buffer_size = nCacheSize / 4; // up to two write buffers may be held in memory simultaneously\n     options.filter_policy = leveldb::NewBloomFilterPolicy(10);\n-    options.compression = leveldb::kNoCompression;\n-    options.max_open_files = 64;\n+    options.compression = compression ? leveldb::kSnappyCompression : leveldb::kNoCompression;\n+    options.max_open_files = maxOpenFiles;\n     if (leveldb::kMajorVersion > 1 || (leveldb::kMajorVersion == 1 && leveldb::kMinorVersion >= 16)) {\n         // LevelDB versions before 1.16 consider short writes to be corruption. Only trigger error\n         // on corruption in later versions.\n@@ -31,14 +31,14 @@ static leveldb::Options GetOptions(size_t nCacheSize)\n     return options;\n }\n \n-CDBWrapper::CDBWrapper(const boost::filesystem::path& path, size_t nCacheSize, bool fMemory, bool fWipe, bool obfuscate)\n+CDBWrapper::CDBWrapper(const boost::filesystem::path& path, size_t nCacheSize, bool fMemory, bool fWipe, bool obfuscate, bool compression, int maxOpenFiles)\n {\n     penv = NULL;\n     readoptions.verify_checksums = true;\n     iteroptions.verify_checksums = true;\n     iteroptions.fill_cache = false;\n     syncoptions.sync = true;\n-    options = GetOptions(nCacheSize);\n+    options = GetOptions(nCacheSize, compression, maxOpenFiles);\n     options.create_if_missing = true;\n     if (fMemory) {\n         penv = leveldb::NewMemEnv(leveldb::Env::Default());"
      },
      {
        "sha": "20b5f849e055be60f21fd9549e9d043d3da8f894",
        "filename": "src/dbwrapper.h",
        "status": "modified",
        "additions": 9,
        "deletions": 7,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/dbwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/dbwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.h?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -186,14 +186,16 @@ class CDBWrapper\n \n public:\n     /**\n-     * @param[in] path        Location in the filesystem where leveldb data will be stored.\n-     * @param[in] nCacheSize  Configures various leveldb cache settings.\n-     * @param[in] fMemory     If true, use leveldb's memory environment.\n-     * @param[in] fWipe       If true, remove all existing data.\n-     * @param[in] obfuscate   If true, store data obfuscated via simple XOR. If false, XOR\n-     *                        with a zero'd byte array.\n+     * @param[in] path          Location in the filesystem where leveldb data will be stored.\n+     * @param[in] nCacheSize    Configures various leveldb cache settings.\n+     * @param[in] fMemory       If true, use leveldb's memory environment.\n+     * @param[in] fWipe         If true, remove all existing data.\n+     * @param[in] obfuscate     If true, store data obfuscated via simple XOR. If false, XOR\n+     *                          with a zero'd byte array.\n+     * @param[in] compression   Enable snappy compression for the database\n+     * @param[in] maxOpenFiles  The maximum number of open files for the database\n      */\n-    CDBWrapper(const boost::filesystem::path& path, size_t nCacheSize, bool fMemory = false, bool fWipe = false, bool obfuscate = false);\n+    CDBWrapper(const boost::filesystem::path& path, size_t nCacheSize, bool fMemory = false, bool fWipe = false, bool obfuscate = false, bool compression = false, int maxOpenFiles = 64);\n     ~CDBWrapper();\n \n     template <typename K, typename V>"
      },
      {
        "sha": "fb9c8b40d47a9b19cdc6165a04c14e00739dbbae",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 2,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -340,6 +340,10 @@ std::string HelpMessage(HelpMessageMode mode)\n #endif\n     strUsage += HelpMessageOpt(\"-txindex\", strprintf(_(\"Maintain a full transaction index, used by the getrawtransaction rpc call (default: %u)\"), DEFAULT_TXINDEX));\n \n+    strUsage += HelpMessageOpt(\"-addressindex\", strprintf(_(\"Maintain a full address index, used to query for the balance, txids and unspent outputs for addresses (default: %u)\"), DEFAULT_ADDRESSINDEX));\n+    strUsage += HelpMessageOpt(\"-timestampindex\", strprintf(_(\"Maintain a timestamp index for block hashes, used to query blocks hashes by a range of timestamps (default: %u)\"), DEFAULT_TIMESTAMPINDEX));\n+    strUsage += HelpMessageOpt(\"-spentindex\", strprintf(_(\"Maintain a full spent index, used to query the spending txid and input index for an outpoint (default: %u)\"), DEFAULT_SPENTINDEX));\n+\n     strUsage += HelpMessageGroup(_(\"Connection options:\"));\n     strUsage += HelpMessageOpt(\"-addnode=<ip>\", _(\"Add a node to connect to and attempt to keep the connection open\"));\n     strUsage += HelpMessageOpt(\"-banscore=<n>\", strprintf(_(\"Threshold for disconnecting misbehaving peers (default: %u)\"), DEFAULT_BANSCORE_THRESHOLD));\n@@ -1213,18 +1217,32 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n         }\n     }\n \n+    // block tree db settings\n+    int dbMaxOpenFiles = GetArg(\"-dbmaxopenfiles\", DEFAULT_DB_MAX_OPEN_FILES);\n+    bool dbCompression = GetBoolArg(\"-dbcompression\", DEFAULT_DB_COMPRESSION);\n+\n+    LogPrintf(\"Block index database configuration:\\n\");\n+    LogPrintf(\"* Using %d max open files\\n\", dbMaxOpenFiles);\n+    LogPrintf(\"* Compression is %s\\n\", dbCompression ? \"enabled\" : \"disabled\");\n+\n     // cache size calculations\n     int64_t nTotalCache = (GetArg(\"-dbcache\", nDefaultDbCache) << 20);\n     nTotalCache = std::max(nTotalCache, nMinDbCache << 20); // total cache cannot be less than nMinDbCache\n     nTotalCache = std::min(nTotalCache, nMaxDbCache << 20); // total cache cannot be greated than nMaxDbcache\n     int64_t nBlockTreeDBCache = nTotalCache / 8;\n-    nBlockTreeDBCache = std::min(nBlockTreeDBCache, (GetBoolArg(\"-txindex\", DEFAULT_TXINDEX) ? nMaxBlockDBAndTxIndexCache : nMaxBlockDBCache) << 20);\n+    if (GetBoolArg(\"-addressindex\", DEFAULT_ADDRESSINDEX) || GetBoolArg(\"-spentindex\", DEFAULT_SPENTINDEX)) {\n+        // enable 3/4 of the cache if addressindex and/or spentindex is enabled\n+        nBlockTreeDBCache = nTotalCache * 3 / 4;\n+    } else {\n+        nBlockTreeDBCache = std::min(nBlockTreeDBCache, (GetBoolArg(\"-txindex\", DEFAULT_TXINDEX) ? nMaxBlockDBAndTxIndexCache : nMaxBlockDBCache) << 20);\n+    }\n     nTotalCache -= nBlockTreeDBCache;\n     int64_t nCoinDBCache = std::min(nTotalCache / 2, (nTotalCache / 4) + (1 << 23)); // use 25%-50% of the remainder for disk cache\n     nCoinDBCache = std::min(nCoinDBCache, nMaxCoinsDBCache << 20); // cap total coins db cache\n     nTotalCache -= nCoinDBCache;\n     nCoinCacheUsage = nTotalCache; // the rest goes to in-memory cache\n     LogPrintf(\"Cache configuration:\\n\");\n+    LogPrintf(\"* Max cache setting possible %.1fMiB\\n\", nMaxDbCache);\n     LogPrintf(\"* Using %.1fMiB for block index database\\n\", nBlockTreeDBCache * (1.0 / 1024 / 1024));\n     LogPrintf(\"* Using %.1fMiB for chain state database\\n\", nCoinDBCache * (1.0 / 1024 / 1024));\n     LogPrintf(\"* Using %.1fMiB for in-memory UTXO set\\n\", nCoinCacheUsage * (1.0 / 1024 / 1024));\n@@ -1245,8 +1263,9 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n                 delete pcoinscatcher;\n                 delete pblocktree;\n \n-                pblocktree = new CBlockTreeDB(nBlockTreeDBCache, false, fReindex);\n+                pblocktree = new CBlockTreeDB(nBlockTreeDBCache, false, fReindex, dbCompression, dbMaxOpenFiles);\n                 pcoinsdbview = new CCoinsViewDB(nCoinDBCache, false, fReindex || fReindexChainState);\n+\n                 pcoinscatcher = new CCoinsViewErrorCatcher(pcoinsdbview);\n                 pcoinsTip = new CCoinsViewCache(pcoinscatcher);\n \n@@ -1279,6 +1298,24 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n                     break;\n                 }\n \n+                // Check for changed -addressindex state\n+                if (fAddressIndex != GetBoolArg(\"-addressindex\", DEFAULT_ADDRESSINDEX)) {\n+                    strLoadError = _(\"You need to rebuild the database using -reindex-chainstate to change -addressindex\");\n+                    break;\n+                }\n+\n+                // Check for changed -spentindex state\n+                if (fSpentIndex != GetBoolArg(\"-spentindex\", DEFAULT_SPENTINDEX)) {\n+                    strLoadError = _(\"You need to rebuild the database using -reindex-chainstate to change -spentindex\");\n+                    break;\n+                }\n+\n+                // Check for changed -timestampindex state\n+                if (fTimestampIndex != GetBoolArg(\"-timestampindex\", DEFAULT_TIMESTAMPINDEX)) {\n+                    strLoadError = _(\"You need to rebuild the database using -reindex-chainstate to change -timestampindex\");\n+                    break;\n+                }\n+\n                 // Check for changed -prune state.  What we are concerned about is a user who has pruned blocks\n                 // in the past, but is now trying to run unpruned.\n                 if (fHavePruned && !fPruneMode) {"
      },
      {
        "sha": "b1b9abe7f0864d5c4e2cc3a51da6806439218448",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 288,
        "deletions": 0,
        "changes": 288,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -70,6 +70,9 @@ int nScriptCheckThreads = 0;\n bool fImporting = false;\n bool fReindex = false;\n bool fTxIndex = false;\n+bool fAddressIndex = false;\n+bool fTimestampIndex = false;\n+bool fSpentIndex = false;\n bool fHavePruned = false;\n bool fPruneMode = false;\n bool fIsBareMultisigStd = DEFAULT_PERMIT_BAREMULTISIG;\n@@ -1538,6 +1541,16 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         // Store transaction in memory\n         pool.addUnchecked(hash, entry, setAncestors, !IsInitialBlockDownload());\n \n+        // Add memory address index\n+        if (fAddressIndex) {\n+            pool.addAddressIndex(entry, view);\n+        }\n+\n+        // Add memory spent index\n+        if (fSpentIndex) {\n+            pool.addSpentIndex(entry, view);\n+        }\n+\n         // trim mempool and check if tx was trimmed\n         if (!fOverrideMempoolLimit) {\n             LimitMempoolSize(pool, GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n@@ -1563,6 +1576,66 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n     return res;\n }\n \n+bool GetTimestampIndex(const unsigned int &high, const unsigned int &low, const bool fActiveOnly, std::vector<std::pair<uint256, unsigned int> > &hashes)\n+{\n+    if (!fTimestampIndex)\n+        return error(\"Timestamp index not enabled\");\n+\n+    if (!pblocktree->ReadTimestampIndex(high, low, fActiveOnly, hashes))\n+        return error(\"Unable to get hashes for timestamps\");\n+\n+    return true;\n+}\n+\n+bool GetSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value)\n+{\n+    if (!fSpentIndex)\n+        return false;\n+\n+    if (mempool.getSpentIndex(key, value))\n+        return true;\n+\n+    if (!pblocktree->ReadSpentIndex(key, value))\n+        return false;\n+\n+    return true;\n+}\n+\n+bool HashOnchainActive(const uint256 &hash)\n+{\n+    CBlockIndex* pblockindex = mapBlockIndex[hash];\n+\n+    if (!chainActive.Contains(pblockindex)) {\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n+bool GetAddressIndex(uint160 addressHash, int type,\n+                     std::vector<std::pair<CAddressIndexKey, CAmount> > &addressIndex, int start, int end)\n+{\n+    if (!fAddressIndex)\n+        return error(\"address index not enabled\");\n+\n+    if (!pblocktree->ReadAddressIndex(addressHash, type, addressIndex, start, end))\n+        return error(\"unable to get txids for address\");\n+\n+    return true;\n+}\n+\n+bool GetAddressUnspent(uint160 addressHash, int type,\n+                       std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > &unspentOutputs)\n+{\n+    if (!fAddressIndex)\n+        return error(\"address index not enabled\");\n+\n+    if (!pblocktree->ReadAddressUnspentIndex(addressHash, type, unspentOutputs))\n+        return error(\"unable to get txids for address\");\n+\n+    return true;\n+}\n+\n /** Return transaction in tx, and if it was found inside a block, its hash is placed in hashBlock */\n bool GetTransaction(const uint256 &hash, CTransaction &txOut, const Consensus::Params& consensusParams, uint256 &hashBlock, bool fAllowSlow)\n {\n@@ -2162,11 +2235,46 @@ bool DisconnectBlock(const CBlock& block, CValidationState& state, const CBlockI\n     if (blockUndo.vtxundo.size() + 1 != block.vtx.size())\n         return error(\"DisconnectBlock(): block and undo data inconsistent\");\n \n+    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;\n+    std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > addressUnspentIndex;\n+    std::vector<std::pair<CSpentIndexKey, CSpentIndexValue> > spentIndex;\n+\n     // undo transactions in reverse order\n     for (int i = block.vtx.size() - 1; i >= 0; i--) {\n         const CTransaction &tx = block.vtx[i];\n         uint256 hash = tx.GetHash();\n \n+        if (fAddressIndex) {\n+\n+            for (unsigned int k = tx.vout.size(); k-- > 0;) {\n+                const CTxOut &out = tx.vout[k];\n+\n+                if (out.scriptPubKey.IsPayToScriptHash()) {\n+                    vector<unsigned char> hashBytes(out.scriptPubKey.begin()+2, out.scriptPubKey.begin()+22);\n+\n+                    // undo receiving activity\n+                    addressIndex.push_back(make_pair(CAddressIndexKey(2, uint160(hashBytes), pindex->nHeight, i, hash, k, false), out.nValue));\n+\n+                    // undo unspent index\n+                    addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(2, uint160(hashBytes), hash, k), CAddressUnspentValue()));\n+\n+                } else if (out.scriptPubKey.IsPayToPublicKeyHash()) {\n+                    vector<unsigned char> hashBytes(out.scriptPubKey.begin()+3, out.scriptPubKey.begin()+23);\n+\n+                    // undo receiving activity\n+                    addressIndex.push_back(make_pair(CAddressIndexKey(1, uint160(hashBytes), pindex->nHeight, i, hash, k, false), out.nValue));\n+\n+                    // undo unspent index\n+                    addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(1, uint160(hashBytes), hash, k), CAddressUnspentValue()));\n+\n+                } else {\n+                    continue;\n+                }\n+\n+            }\n+\n+        }\n+\n         // Check that all outputs are available and match the outputs in the block itself\n         // exactly.\n         {\n@@ -2196,10 +2304,45 @@ bool DisconnectBlock(const CBlock& block, CValidationState& state, const CBlockI\n                 const CTxInUndo &undo = txundo.vprevout[j];\n                 if (!ApplyTxInUndo(undo, view, out))\n                     fClean = false;\n+\n+                const CTxIn input = tx.vin[j];\n+\n+                if (fSpentIndex) {\n+                    // undo and delete the spent index\n+                    spentIndex.push_back(make_pair(CSpentIndexKey(input.prevout.hash, input.prevout.n), CSpentIndexValue()));\n+                }\n+\n+                if (fAddressIndex) {\n+                    const CTxOut &prevout = view.GetOutputFor(tx.vin[j]);\n+                    if (prevout.scriptPubKey.IsPayToScriptHash()) {\n+                        vector<unsigned char> hashBytes(prevout.scriptPubKey.begin()+2, prevout.scriptPubKey.begin()+22);\n+\n+                        // undo spending activity\n+                        addressIndex.push_back(make_pair(CAddressIndexKey(2, uint160(hashBytes), pindex->nHeight, i, hash, j, true), prevout.nValue * -1));\n+\n+                        // restore unspent index\n+                        addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(2, uint160(hashBytes), input.prevout.hash, input.prevout.n), CAddressUnspentValue(prevout.nValue, prevout.scriptPubKey, undo.nHeight)));\n+\n+\n+                    } else if (prevout.scriptPubKey.IsPayToPublicKeyHash()) {\n+                        vector<unsigned char> hashBytes(prevout.scriptPubKey.begin()+3, prevout.scriptPubKey.begin()+23);\n+\n+                        // undo spending activity\n+                        addressIndex.push_back(make_pair(CAddressIndexKey(1, uint160(hashBytes), pindex->nHeight, i, hash, j, true), prevout.nValue * -1));\n+\n+                        // restore unspent index\n+                        addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(1, uint160(hashBytes), input.prevout.hash, input.prevout.n), CAddressUnspentValue(prevout.nValue, prevout.scriptPubKey, undo.nHeight)));\n+\n+                    } else {\n+                        continue;\n+                    }\n+                }\n+\n             }\n         }\n     }\n \n+\n     // move best block pointer to prevout block\n     view.SetBestBlock(pindex->pprev->GetBlockHash());\n \n@@ -2208,6 +2351,15 @@ bool DisconnectBlock(const CBlock& block, CValidationState& state, const CBlockI\n         return true;\n     }\n \n+    if (fAddressIndex) {\n+        if (!pblocktree->EraseAddressIndex(addressIndex)) {\n+            return AbortNode(state, \"Failed to delete address index\");\n+        }\n+        if (!pblocktree->UpdateAddressUnspentIndex(addressUnspentIndex)) {\n+            return AbortNode(state, \"Failed to write address unspent index\");\n+        }\n+    }\n+\n     return fClean;\n }\n \n@@ -2299,6 +2451,7 @@ static int64_t nTimeTotal = 0;\n bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex,\n                   CCoinsViewCache& view, const CChainParams& chainparams, bool fJustCheck)\n {\n+\n     AssertLockHeld(cs_main);\n \n     int64_t nTimeStart = GetTimeMicros();\n@@ -2412,9 +2565,14 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n     std::vector<std::pair<uint256, CDiskTxPos> > vPos;\n     vPos.reserve(block.vtx.size());\n     blockundo.vtxundo.reserve(block.vtx.size() - 1);\n+    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;\n+    std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > addressUnspentIndex;\n+    std::vector<std::pair<CSpentIndexKey, CSpentIndexValue> > spentIndex;\n+\n     for (unsigned int i = 0; i < block.vtx.size(); i++)\n     {\n         const CTransaction &tx = block.vtx[i];\n+        const uint256 txhash = tx.GetHash();\n \n         nInputs += tx.vin.size();\n \n@@ -2447,6 +2605,43 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n                 return state.DoS(100, error(\"%s: contains a non-BIP68-final transaction\", __func__),\n                                  REJECT_INVALID, \"bad-txns-nonfinal\");\n             }\n+\n+            if (fAddressIndex || fSpentIndex)\n+            {\n+                for (size_t j = 0; j < tx.vin.size(); j++) {\n+\n+                    const CTxIn input = tx.vin[j];\n+                    const CTxOut &prevout = view.GetOutputFor(tx.vin[j]);\n+                    uint160 hashBytes;\n+                    int addressType;\n+\n+                    if (prevout.scriptPubKey.IsPayToScriptHash()) {\n+                        hashBytes = uint160(vector <unsigned char>(prevout.scriptPubKey.begin()+2, prevout.scriptPubKey.begin()+22));\n+                        addressType = 2;\n+                    } else if (prevout.scriptPubKey.IsPayToPublicKeyHash()) {\n+                        hashBytes = uint160(vector <unsigned char>(prevout.scriptPubKey.begin()+3, prevout.scriptPubKey.begin()+23));\n+                        addressType = 1;\n+                    } else {\n+                        hashBytes.SetNull();\n+                        addressType = 0;\n+                    }\n+\n+                    if (fAddressIndex && addressType > 0) {\n+                        // record spending activity\n+                        addressIndex.push_back(make_pair(CAddressIndexKey(addressType, hashBytes, pindex->nHeight, i, txhash, j, true), prevout.nValue * -1));\n+\n+                        // remove address from unspent index\n+                        addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(addressType, hashBytes, input.prevout.hash, input.prevout.n), CAddressUnspentValue()));\n+                    }\n+\n+                    if (fSpentIndex) {\n+                        // add the spent index to determine the txid and input that spent an output\n+                        // and to find the amount and address from an input\n+                        spentIndex.push_back(make_pair(CSpentIndexKey(input.prevout.hash, input.prevout.n), CSpentIndexValue(txhash, j, pindex->nHeight, prevout.nValue, addressType, hashBytes)));\n+                    }\n+                }\n+\n+            }\n         }\n \n         // GetTransactionSigOpCost counts 3 types of sigops:\n@@ -2470,6 +2665,35 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n             control.Add(vChecks);\n         }\n \n+        if (fAddressIndex) {\n+            for (unsigned int k = 0; k < tx.vout.size(); k++) {\n+                const CTxOut &out = tx.vout[k];\n+\n+                if (out.scriptPubKey.IsPayToScriptHash()) {\n+                    vector<unsigned char> hashBytes(out.scriptPubKey.begin()+2, out.scriptPubKey.begin()+22);\n+\n+                    // record receiving activity\n+                    addressIndex.push_back(make_pair(CAddressIndexKey(2, uint160(hashBytes), pindex->nHeight, i, txhash, k, false), out.nValue));\n+\n+                    // record unspent output\n+                    addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(2, uint160(hashBytes), txhash, k), CAddressUnspentValue(out.nValue, out.scriptPubKey, pindex->nHeight)));\n+\n+                } else if (out.scriptPubKey.IsPayToPublicKeyHash()) {\n+                    vector<unsigned char> hashBytes(out.scriptPubKey.begin()+3, out.scriptPubKey.begin()+23);\n+\n+                    // record receiving activity\n+                    addressIndex.push_back(make_pair(CAddressIndexKey(1, uint160(hashBytes), pindex->nHeight, i, txhash, k, false), out.nValue));\n+\n+                    // record unspent output\n+                    addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(1, uint160(hashBytes), txhash, k), CAddressUnspentValue(out.nValue, out.scriptPubKey, pindex->nHeight)));\n+\n+                } else {\n+                    continue;\n+                }\n+\n+            }\n+        }\n+\n         CTxUndo undoDummy;\n         if (i > 0) {\n             blockundo.vtxundo.push_back(CTxUndo());\n@@ -2520,6 +2744,41 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n         if (!pblocktree->WriteTxIndex(vPos))\n             return AbortNode(state, \"Failed to write transaction index\");\n \n+    if (fAddressIndex) {\n+        if (!pblocktree->WriteAddressIndex(addressIndex)) {\n+            return AbortNode(state, \"Failed to write address index\");\n+        }\n+\n+        if (!pblocktree->UpdateAddressUnspentIndex(addressUnspentIndex)) {\n+            return AbortNode(state, \"Failed to write address unspent index\");\n+        }\n+    }\n+\n+    if (fSpentIndex)\n+        if (!pblocktree->UpdateSpentIndex(spentIndex))\n+            return AbortNode(state, \"Failed to write transaction index\");\n+\n+    if (fTimestampIndex) {\n+        unsigned int logicalTS = pindex->nTime;\n+        unsigned int prevLogicalTS = 0;\n+\n+        // retrieve logical timestamp of the previous block\n+        if (pindex->pprev)\n+            if (!pblocktree->ReadTimestampBlockIndex(pindex->pprev->GetBlockHash(), prevLogicalTS))\n+                LogPrintf(\"%s: Failed to read previous block's logical timestamp\\n\", __func__);\n+\n+        if (logicalTS <= prevLogicalTS) {\n+            logicalTS = prevLogicalTS + 1;\n+            LogPrintf(\"%s: Previous logical timestamp is newer Actual[%d] prevLogical[%d] Logical[%d]\\n\", __func__, pindex->nTime, prevLogicalTS, logicalTS);\n+        }\n+\n+        if (!pblocktree->WriteTimestampIndex(CTimestampIndexKey(logicalTS, pindex->GetBlockHash())))\n+            return AbortNode(state, \"Failed to write timestamp index\");\n+\n+        if (!pblocktree->WriteTimestampBlockIndex(CTimestampBlockIndexKey(pindex->GetBlockHash()), CTimestampBlockIndexValue(logicalTS)))\n+            return AbortNode(state, \"Failed to write blockhash index\");\n+    }\n+\n     // add this block to the view's block chain\n     view.SetBestBlock(pindex->GetBlockHash());\n \n@@ -4055,6 +4314,18 @@ bool static LoadBlockIndexDB()\n     pblocktree->ReadFlag(\"txindex\", fTxIndex);\n     LogPrintf(\"%s: transaction index %s\\n\", __func__, fTxIndex ? \"enabled\" : \"disabled\");\n \n+    // Check whether we have an address index\n+    pblocktree->ReadFlag(\"addressindex\", fAddressIndex);\n+    LogPrintf(\"%s: address index %s\\n\", __func__, fAddressIndex ? \"enabled\" : \"disabled\");\n+\n+    // Check whether we have a timestamp index\n+    pblocktree->ReadFlag(\"timestampindex\", fTimestampIndex);\n+    LogPrintf(\"%s: timestamp index %s\\n\", __func__, fTimestampIndex ? \"enabled\" : \"disabled\");\n+\n+    // Check whether we have a spent index\n+    pblocktree->ReadFlag(\"spentindex\", fSpentIndex);\n+    LogPrintf(\"%s: spent index %s\\n\", __func__, fSpentIndex ? \"enabled\" : \"disabled\");\n+\n     // Load pointer to end of best chain\n     BlockMap::iterator it = mapBlockIndex.find(pcoinsTip->GetBestBlock());\n     if (it == mapBlockIndex.end())\n@@ -4314,6 +4585,23 @@ bool InitBlockIndex(const CChainParams& chainparams)\n     // Use the provided setting for -txindex in the new database\n     fTxIndex = GetBoolArg(\"-txindex\", DEFAULT_TXINDEX);\n     pblocktree->WriteFlag(\"txindex\", fTxIndex);\n+    LogPrintf(\"%s: transaction index %s\\n\", __func__, fTxIndex ? \"enabled\" : \"disabled\");\n+\n+    // Use the provided setting for -addressindex in the new database\n+    fAddressIndex = GetBoolArg(\"-addressindex\", DEFAULT_ADDRESSINDEX);\n+    pblocktree->WriteFlag(\"addressindex\", fAddressIndex);\n+    LogPrintf(\"%s: address index %s\\n\", __func__, fAddressIndex ? \"enabled\" : \"disabled\");\n+\n+    // Use the provided setting for -timestampindex in the new database\n+    fTimestampIndex = GetBoolArg(\"-timestampindex\", DEFAULT_TIMESTAMPINDEX);\n+    pblocktree->WriteFlag(\"timestampindex\", fTimestampIndex);\n+    LogPrintf(\"%s: timestamp index %s\\n\", __func__, fTimestampIndex ? \"enabled\" : \"disabled\");\n+\n+    // Use the provided setting for -spentindex in the new database\n+    fSpentIndex = GetBoolArg(\"-spentindex\", DEFAULT_SPENTINDEX);\n+    pblocktree->WriteFlag(\"spentindex\", fSpentIndex);\n+    LogPrintf(\"%s: spent index %s\\n\", __func__, fSpentIndex ? \"enabled\" : \"disabled\");\n+\n     LogPrintf(\"Initializing databases...\\n\");\n \n     // Only add the genesis block if not reindexing (in which case we reuse the one already on disk)"
      },
      {
        "sha": "c47c6d16f9013df19a1365aa32c21042e694aaba",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 19,
        "deletions": 2,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -17,6 +17,9 @@\n #include \"script/script_error.h\"\n #include \"sync.h\"\n #include \"versionbits.h\"\n+#include \"spentindex.h\"\n+#include \"addressindex.h\"\n+#include \"timestampindex.h\"\n \n #include <algorithm>\n #include <exception>\n@@ -126,6 +129,11 @@ static const int64_t DEFAULT_MAX_TIP_AGE = 24 * 60 * 60;\n static const bool DEFAULT_PERMIT_BAREMULTISIG = true;\n static const bool DEFAULT_CHECKPOINTS_ENABLED = true;\n static const bool DEFAULT_TXINDEX = false;\n+static const bool DEFAULT_ADDRESSINDEX = false;\n+static const bool DEFAULT_TIMESTAMPINDEX = false;\n+static const bool DEFAULT_SPENTINDEX = false;\n+static const unsigned int DEFAULT_DB_MAX_OPEN_FILES = 1000;\n+static const bool DEFAULT_DB_COMPRESSION = true;\n static const unsigned int DEFAULT_BANSCORE_THRESHOLD = 100;\n \n static const bool DEFAULT_TESTSAFEMODE = false;\n@@ -162,6 +170,9 @@ extern bool fImporting;\n extern bool fReindex;\n extern int nScriptCheckThreads;\n extern bool fTxIndex;\n+extern bool fAddressIndex;\n+extern bool fSpentIndex;\n+extern bool fTimestampIndex;\n extern bool fIsBareMultisigStd;\n extern bool fRequireStandard;\n extern bool fCheckBlockIndex;\n@@ -314,8 +325,6 @@ struct CNodeStateStats {\n     std::vector<int> vHeightInFlight;\n };\n \n-\n-\n /** \n  * Count ECDSA signature operations the old-fashioned (pre-0.6) way\n  * @return number of sigops this transaction's outputs will produce when spent\n@@ -430,6 +439,14 @@ class CScriptCheck\n     ScriptError GetScriptError() const { return error; }\n };\n \n+bool GetTimestampIndex(const unsigned int &high, const unsigned int &low, const bool fActiveOnly, std::vector<std::pair<uint256, unsigned int> > &hashes);\n+bool GetSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value);\n+bool HashOnchainActive(const uint256 &hash);\n+bool GetAddressIndex(uint160 addressHash, int type,\n+                     std::vector<std::pair<CAddressIndexKey, CAmount> > &addressIndex,\n+                     int start = 0, int end = 0);\n+bool GetAddressUnspent(uint160 addressHash, int type,\n+                       std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > &unspentOutputs);\n \n /** Functions for disk access for blocks */\n bool WriteBlockToDisk(const CBlock& block, CDiskBlockPos& pos, const CMessageHeader::MessageStartChars& messageStart);"
      },
      {
        "sha": "e347fbb4ca2d1fd21b0fc4d589bb076efe9fe644",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 209,
        "deletions": 0,
        "changes": 209,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -4,6 +4,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"amount.h\"\n+#include \"base58.h\"\n #include \"chain.h\"\n #include \"chainparams.h\"\n #include \"checkpoints.h\"\n@@ -13,6 +14,10 @@\n #include \"policy/policy.h\"\n #include \"primitives/transaction.h\"\n #include \"rpc/server.h\"\n+#include \"script/script.h\"\n+#include \"script/script_error.h\"\n+#include \"script/sign.h\"\n+#include \"script/standard.h\"\n #include \"streams.h\"\n #include \"sync.h\"\n #include \"txmempool.h\"\n@@ -90,6 +95,112 @@ UniValue blockheaderToJSON(const CBlockIndex* blockindex)\n     return result;\n }\n \n+UniValue blockToDeltasJSON(const CBlock& block, const CBlockIndex* blockindex)\n+{\n+    UniValue result(UniValue::VOBJ);\n+    result.push_back(Pair(\"hash\", block.GetHash().GetHex()));\n+    int confirmations = -1;\n+    // Only report confirmations if the block is on the main chain\n+    if (chainActive.Contains(blockindex)) {\n+        confirmations = chainActive.Height() - blockindex->nHeight + 1;\n+    } else {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block is an orphan\");\n+    }\n+    result.push_back(Pair(\"confirmations\", confirmations));\n+    result.push_back(Pair(\"size\", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION)));\n+    result.push_back(Pair(\"height\", blockindex->nHeight));\n+    result.push_back(Pair(\"version\", block.nVersion));\n+    result.push_back(Pair(\"merkleroot\", block.hashMerkleRoot.GetHex()));\n+\n+    UniValue deltas(UniValue::VARR);\n+\n+    for (unsigned int i = 0; i < block.vtx.size(); i++) {\n+        const CTransaction &tx = block.vtx[i];\n+        const uint256 txhash = tx.GetHash();\n+\n+        UniValue entry(UniValue::VOBJ);\n+        entry.push_back(Pair(\"txid\", txhash.GetHex()));\n+        entry.push_back(Pair(\"index\", (int)i));\n+\n+        UniValue inputs(UniValue::VARR);\n+\n+        if (!tx.IsCoinBase()) {\n+\n+            for (size_t j = 0; j < tx.vin.size(); j++) {\n+                const CTxIn input = tx.vin[j];\n+\n+                UniValue delta(UniValue::VOBJ);\n+\n+                CSpentIndexValue spentInfo;\n+                CSpentIndexKey spentKey(input.prevout.hash, input.prevout.n);\n+\n+                if (GetSpentIndex(spentKey, spentInfo)) {\n+                    if (spentInfo.addressType == 1) {\n+                        delta.push_back(Pair(\"address\", CBitcoinAddress(CKeyID(spentInfo.addressHash)).ToString()));\n+                    } else if (spentInfo.addressType == 2)  {\n+                        delta.push_back(Pair(\"address\", CBitcoinAddress(CScriptID(spentInfo.addressHash)).ToString()));\n+                    } else {\n+                        continue;\n+                    }\n+                    delta.push_back(Pair(\"satoshis\", -1 * spentInfo.satoshis));\n+                    delta.push_back(Pair(\"index\", (int)j));\n+                    delta.push_back(Pair(\"prevtxid\", input.prevout.hash.GetHex()));\n+                    delta.push_back(Pair(\"prevout\", (int)input.prevout.n));\n+\n+                    inputs.push_back(delta);\n+                } else {\n+                    throw JSONRPCError(RPC_INTERNAL_ERROR, \"Spent information not available\");\n+                }\n+\n+            }\n+        }\n+\n+        entry.push_back(Pair(\"inputs\", inputs));\n+\n+        UniValue outputs(UniValue::VARR);\n+\n+        for (unsigned int k = 0; k < tx.vout.size(); k++) {\n+            const CTxOut &out = tx.vout[k];\n+\n+            UniValue delta(UniValue::VOBJ);\n+\n+            if (out.scriptPubKey.IsPayToScriptHash()) {\n+                vector<unsigned char> hashBytes(out.scriptPubKey.begin()+2, out.scriptPubKey.begin()+22);\n+                delta.push_back(Pair(\"address\", CBitcoinAddress(CScriptID(uint160(hashBytes))).ToString()));\n+\n+            } else if (out.scriptPubKey.IsPayToPublicKeyHash()) {\n+                vector<unsigned char> hashBytes(out.scriptPubKey.begin()+3, out.scriptPubKey.begin()+23);\n+                delta.push_back(Pair(\"address\", CBitcoinAddress(CKeyID(uint160(hashBytes))).ToString()));\n+            } else {\n+                continue;\n+            }\n+\n+            delta.push_back(Pair(\"satoshis\", out.nValue));\n+            delta.push_back(Pair(\"index\", (int)k));\n+\n+            outputs.push_back(delta);\n+        }\n+\n+        entry.push_back(Pair(\"outputs\", outputs));\n+        deltas.push_back(entry);\n+\n+    }\n+    result.push_back(Pair(\"deltas\", deltas));\n+    result.push_back(Pair(\"time\", block.GetBlockTime()));\n+    result.push_back(Pair(\"mediantime\", (int64_t)blockindex->GetMedianTimePast()));\n+    result.push_back(Pair(\"nonce\", (uint64_t)block.nNonce));\n+    result.push_back(Pair(\"bits\", strprintf(\"%08x\", block.nBits)));\n+    result.push_back(Pair(\"difficulty\", GetDifficulty(blockindex)));\n+    result.push_back(Pair(\"chainwork\", blockindex->nChainWork.GetHex()));\n+\n+    if (blockindex->pprev)\n+        result.push_back(Pair(\"previousblockhash\", blockindex->pprev->GetBlockHash().GetHex()));\n+    CBlockIndex *pnext = chainActive.Next(blockindex);\n+    if (pnext)\n+        result.push_back(Pair(\"nextblockhash\", pnext->GetBlockHash().GetHex()));\n+    return result;\n+}\n+\n UniValue blockToJSON(const CBlock& block, const CBlockIndex* blockindex, bool txDetails = false)\n {\n     UniValue result(UniValue::VOBJ);\n@@ -459,6 +570,102 @@ UniValue getmempoolentry(const UniValue& params, bool fHelp)\n     return info;\n }\n \n+UniValue getblockdeltas(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\"\");\n+\n+    std::string strHash = params[0].get_str();\n+    uint256 hash(uint256S(strHash));\n+\n+    if (mapBlockIndex.count(hash) == 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n+\n+    CBlock block;\n+    CBlockIndex* pblockindex = mapBlockIndex[hash];\n+\n+    if (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0)\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"Block not available (pruned data)\");\n+\n+    if(!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus()))\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"Can't read block from disk\");\n+\n+    return blockToDeltasJSON(block, pblockindex);\n+}\n+\n+UniValue getblockhashes(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 2)\n+        throw runtime_error(\n+            \"getblockhashes timestamp\\n\"\n+            \"\\nReturns array of hashes of blocks within the timestamp range provided.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. high         (numeric, required) The newer block timestamp\\n\"\n+            \"2. low          (numeric, required) The older block timestamp\\n\"\n+            \"3. options      (string, required) A json object\\n\"\n+            \"    {\\n\"\n+            \"      \\\"noOrphans\\\":true   (boolean) will only include blocks on the main chain\\n\"\n+            \"      \\\"logicalTimes\\\":true   (boolean) will include logical timestamps with hashes\\n\"\n+            \"    }\\n\"\n+            \"\\nResult:\\n\"\n+            \"[\\n\"\n+            \"  \\\"hash\\\"         (string) The block hash\\n\"\n+            \"]\\n\"\n+            \"[\\n\"\n+            \"  {\\n\"\n+            \"    \\\"blockhash\\\": (string) The block hash\\n\"\n+            \"    \\\"logicalts\\\": (numeric) The logical timestamp\\n\"\n+            \"  }\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockhashes\", \"1231614698 1231024505\")\n+            + HelpExampleRpc(\"getblockhashes\", \"1231614698, 1231024505\")\n+            + HelpExampleCli(\"getblockhashes\", \"1231614698 1231024505 '{\\\"noOrphans\\\":false, \\\"logicalTimes\\\":true}'\")\n+            );\n+\n+    unsigned int high = params[0].get_int();\n+    unsigned int low = params[1].get_int();\n+    bool fActiveOnly = false;\n+    bool fLogicalTS = false;\n+\n+    if (params.size() > 2) {\n+        if (params[2].isObject()) {\n+            UniValue noOrphans = find_value(params[2].get_obj(), \"noOrphans\");\n+            UniValue returnLogical = find_value(params[2].get_obj(), \"logicalTimes\");\n+\n+            if (noOrphans.isBool())\n+                fActiveOnly = noOrphans.get_bool();\n+\n+            if (returnLogical.isBool())\n+                fLogicalTS = returnLogical.get_bool();\n+        }\n+    }\n+\n+    std::vector<std::pair<uint256, unsigned int> > blockHashes;\n+\n+    if (fActiveOnly)\n+        LOCK(cs_main);\n+\n+    if (!GetTimestampIndex(high, low, fActiveOnly, blockHashes)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for block hashes\");\n+    }\n+\n+    UniValue result(UniValue::VARR);\n+\n+    for (std::vector<std::pair<uint256, unsigned int> >::const_iterator it=blockHashes.begin(); it!=blockHashes.end(); it++) {\n+        if (fLogicalTS) {\n+            UniValue item(UniValue::VOBJ);\n+            item.push_back(Pair(\"blockhash\", it->first.GetHex()));\n+            item.push_back(Pair(\"logicalts\", (int)it->second));\n+            result.push_back(item);\n+        } else {\n+            result.push_back(it->first.GetHex());\n+        }\n+    }\n+\n+    return result;\n+}\n+\n UniValue getblockhash(const UniValue& params, bool fHelp)\n {\n     if (fHelp || params.size() != 1)\n@@ -1191,6 +1398,8 @@ static const CRPCCommand commands[] =\n     { \"blockchain\",         \"getbestblockhash\",       &getbestblockhash,       true  },\n     { \"blockchain\",         \"getblockcount\",          &getblockcount,          true  },\n     { \"blockchain\",         \"getblock\",               &getblock,               true  },\n+    { \"blockchain\",         \"getblockdeltas\",         &getblockdeltas,         false },\n+    { \"blockchain\",         \"getblockhashes\",         &getblockhashes,         true  },\n     { \"blockchain\",         \"getblockhash\",           &getblockhash,           true  },\n     { \"blockchain\",         \"getblockheader\",         &getblockheader,         true  },\n     { \"blockchain\",         \"getchaintips\",           &getchaintips,           true  },"
      },
      {
        "sha": "5f1dc78c579adc324b4cbc322a9b80c53498af4d",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -104,6 +104,15 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"setban\", 3 },\n     { \"getmempoolancestors\", 1 },\n     { \"getmempooldescendants\", 1 },\n+    { \"getblockhashes\", 0 },\n+    { \"getblockhashes\", 1 },\n+    { \"getblockhashes\", 2 },\n+    { \"getspentinfo\", 0},\n+    { \"getaddresstxids\", 0},\n+    { \"getaddressbalance\", 0},\n+    { \"getaddressdeltas\", 0},\n+    { \"getaddressutxos\", 0},\n+    { \"getaddressmempool\", 0},\n };\n \n class CRPCConvertTable"
      },
      {
        "sha": "715b371f27b58620aaa237d3d0325ea4538ec647",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 538,
        "deletions": 0,
        "changes": 538,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -11,6 +11,7 @@\n #include \"netbase.h\"\n #include \"rpc/server.h\"\n #include \"timedata.h\"\n+#include \"txmempool.h\"\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n #ifdef ENABLE_WALLET\n@@ -484,6 +485,533 @@ UniValue setmocktime(const UniValue& params, bool fHelp)\n     return NullUniValue;\n }\n \n+bool getAddressFromIndex(const int &type, const uint160 &hash, std::string &address)\n+{\n+    if (type == 2) {\n+        address = CBitcoinAddress(CScriptID(hash)).ToString();\n+    } else if (type == 1) {\n+        address = CBitcoinAddress(CKeyID(hash)).ToString();\n+    } else {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool getAddressesFromParams(const UniValue& params, std::vector<std::pair<uint160, int> > &addresses)\n+{\n+    if (params[0].isStr()) {\n+        CBitcoinAddress address(params[0].get_str());\n+        uint160 hashBytes;\n+        int type = 0;\n+        if (!address.GetIndexKey(hashBytes, type)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+        }\n+        addresses.push_back(std::make_pair(hashBytes, type));\n+    } else if (params[0].isObject()) {\n+\n+        UniValue addressValues = find_value(params[0].get_obj(), \"addresses\");\n+        if (!addressValues.isArray()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Addresses is expected to be an array\");\n+        }\n+\n+        std::vector<UniValue> values = addressValues.getValues();\n+\n+        for (std::vector<UniValue>::iterator it = values.begin(); it != values.end(); ++it) {\n+\n+            CBitcoinAddress address(it->get_str());\n+            uint160 hashBytes;\n+            int type = 0;\n+            if (!address.GetIndexKey(hashBytes, type)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+            }\n+            addresses.push_back(std::make_pair(hashBytes, type));\n+        }\n+    } else {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    return true;\n+}\n+\n+bool heightSort(std::pair<CAddressUnspentKey, CAddressUnspentValue> a,\n+                std::pair<CAddressUnspentKey, CAddressUnspentValue> b) {\n+    return a.second.blockHeight < b.second.blockHeight;\n+}\n+\n+bool timestampSort(std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> a,\n+                   std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> b) {\n+    return a.second.time < b.second.time;\n+}\n+\n+UniValue getaddressmempool(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"getaddressmempool\\n\"\n+            \"\\nReturns all mempool deltas for an address (requires addressindex to be enabled).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"addresses\\\"\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"}\\n\"\n+            \"\\nResult:\\n\"\n+            \"[\\n\"\n+            \"  {\\n\"\n+            \"    \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"    \\\"txid\\\"  (string) The related txid\\n\"\n+            \"    \\\"index\\\"  (number) The related input or output index\\n\"\n+            \"    \\\"satoshis\\\"  (number) The difference of satoshis\\n\"\n+            \"    \\\"timestamp\\\"  (number) The time the transaction entered the mempool (seconds)\\n\"\n+            \"    \\\"prevtxid\\\"  (string) The previous txid (if spending)\\n\"\n+            \"    \\\"prevout\\\"  (string) The previous transaction output index (if spending)\\n\"\n+            \"  }\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getaddressmempool\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n+            + HelpExampleRpc(\"getaddressmempool\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n+        );\n+\n+    std::vector<std::pair<uint160, int> > addresses;\n+\n+    if (!getAddressesFromParams(params, addresses)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    std::vector<std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> > indexes;\n+\n+    if (!mempool.getAddressIndex(addresses, indexes)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+    }\n+\n+    std::sort(indexes.begin(), indexes.end(), timestampSort);\n+\n+    UniValue result(UniValue::VARR);\n+\n+    for (std::vector<std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> >::iterator it = indexes.begin();\n+         it != indexes.end(); it++) {\n+\n+        std::string address;\n+        if (!getAddressFromIndex(it->first.type, it->first.addressBytes, address)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unknown address type\");\n+        }\n+\n+        UniValue delta(UniValue::VOBJ);\n+        delta.push_back(Pair(\"address\", address));\n+        delta.push_back(Pair(\"txid\", it->first.txhash.GetHex()));\n+        delta.push_back(Pair(\"index\", (int)it->first.index));\n+        delta.push_back(Pair(\"satoshis\", it->second.amount));\n+        delta.push_back(Pair(\"timestamp\", it->second.time));\n+        if (it->second.amount < 0) {\n+            delta.push_back(Pair(\"prevtxid\", it->second.prevhash.GetHex()));\n+            delta.push_back(Pair(\"prevout\", (int)it->second.prevout));\n+        }\n+        result.push_back(delta);\n+    }\n+\n+    return result;\n+}\n+\n+UniValue getaddressutxos(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"getaddressutxos\\n\"\n+            \"\\nReturns all unspent outputs for an address (requires addressindex to be enabled).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"addresses\\\"\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"      ,...\\n\"\n+            \"    ],\\n\"\n+            \"  \\\"chainInfo\\\"  (boolean) Include chain info with results\\n\"\n+            \"}\\n\"\n+            \"\\nResult\\n\"\n+            \"[\\n\"\n+            \"  {\\n\"\n+            \"    \\\"address\\\"  (string) The address base58check encoded\\n\"\n+            \"    \\\"txid\\\"  (string) The output txid\\n\"\n+            \"    \\\"height\\\"  (number) The block height\\n\"\n+            \"    \\\"outputIndex\\\"  (number) The output index\\n\"\n+            \"    \\\"script\\\"  (strin) The script hex encoded\\n\"\n+            \"    \\\"satoshis\\\"  (number) The number of satoshis of the output\\n\"\n+            \"  }\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getaddressutxos\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n+            + HelpExampleRpc(\"getaddressutxos\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n+            );\n+\n+    bool includeChainInfo = false;\n+    if (params[0].isObject()) {\n+        UniValue chainInfo = find_value(params[0].get_obj(), \"chainInfo\");\n+        if (chainInfo.isBool()) {\n+            includeChainInfo = chainInfo.get_bool();\n+        }\n+    }\n+\n+    std::vector<std::pair<uint160, int> > addresses;\n+\n+    if (!getAddressesFromParams(params, addresses)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > unspentOutputs;\n+\n+    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n+        if (!GetAddressUnspent((*it).first, (*it).second, unspentOutputs)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+        }\n+    }\n+\n+    std::sort(unspentOutputs.begin(), unspentOutputs.end(), heightSort);\n+\n+    UniValue utxos(UniValue::VARR);\n+\n+    for (std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> >::const_iterator it=unspentOutputs.begin(); it!=unspentOutputs.end(); it++) {\n+        UniValue output(UniValue::VOBJ);\n+        std::string address;\n+        if (!getAddressFromIndex(it->first.type, it->first.hashBytes, address)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unknown address type\");\n+        }\n+\n+        output.push_back(Pair(\"address\", address));\n+        output.push_back(Pair(\"txid\", it->first.txhash.GetHex()));\n+        output.push_back(Pair(\"outputIndex\", (int)it->first.index));\n+        output.push_back(Pair(\"script\", HexStr(it->second.script.begin(), it->second.script.end())));\n+        output.push_back(Pair(\"satoshis\", it->second.satoshis));\n+        output.push_back(Pair(\"height\", it->second.blockHeight));\n+        utxos.push_back(output);\n+    }\n+\n+    if (includeChainInfo) {\n+        UniValue result(UniValue::VOBJ);\n+        result.push_back(Pair(\"utxos\", utxos));\n+\n+        LOCK(cs_main);\n+        result.push_back(Pair(\"hash\", chainActive.Tip()->GetBlockHash().GetHex()));\n+        result.push_back(Pair(\"height\", (int)chainActive.Height()));\n+        return result;\n+    } else {\n+        return utxos;\n+    }\n+}\n+\n+UniValue getaddressdeltas(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1 || !params[0].isObject())\n+        throw runtime_error(\n+            \"getaddressdeltas\\n\"\n+            \"\\nReturns all changes for an address (requires addressindex to be enabled).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"addresses\\\"\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"  \\\"start\\\" (number) The start block height\\n\"\n+            \"  \\\"end\\\" (number) The end block height\\n\"\n+            \"  \\\"chainInfo\\\" (boolean) Include chain info in results, only applies if start and end specified\\n\"\n+            \"}\\n\"\n+            \"\\nResult:\\n\"\n+            \"[\\n\"\n+            \"  {\\n\"\n+            \"    \\\"satoshis\\\"  (number) The difference of satoshis\\n\"\n+            \"    \\\"txid\\\"  (string) The related txid\\n\"\n+            \"    \\\"index\\\"  (number) The related input or output index\\n\"\n+            \"    \\\"height\\\"  (number) The block height\\n\"\n+            \"    \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"  }\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getaddressdeltas\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n+            + HelpExampleRpc(\"getaddressdeltas\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n+        );\n+\n+\n+    UniValue startValue = find_value(params[0].get_obj(), \"start\");\n+    UniValue endValue = find_value(params[0].get_obj(), \"end\");\n+\n+    UniValue chainInfo = find_value(params[0].get_obj(), \"chainInfo\");\n+    bool includeChainInfo = false;\n+    if (chainInfo.isBool()) {\n+        includeChainInfo = chainInfo.get_bool();\n+    }\n+\n+    int start = 0;\n+    int end = 0;\n+\n+    if (startValue.isNum() && endValue.isNum()) {\n+        start = startValue.get_int();\n+        end = endValue.get_int();\n+        if (start <= 0 || end <= 0) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Start and end is expected to be greater than zero\");\n+        }\n+        if (end < start) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"End value is expected to be greater than start\");\n+        }\n+    }\n+\n+    std::vector<std::pair<uint160, int> > addresses;\n+\n+    if (!getAddressesFromParams(params, addresses)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;\n+\n+    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n+        if (start > 0 && end > 0) {\n+            if (!GetAddressIndex((*it).first, (*it).second, addressIndex, start, end)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+            }\n+        } else {\n+            if (!GetAddressIndex((*it).first, (*it).second, addressIndex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+            }\n+        }\n+    }\n+\n+    UniValue deltas(UniValue::VARR);\n+\n+    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=addressIndex.begin(); it!=addressIndex.end(); it++) {\n+        std::string address;\n+        if (!getAddressFromIndex(it->first.type, it->first.hashBytes, address)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unknown address type\");\n+        }\n+\n+        UniValue delta(UniValue::VOBJ);\n+        delta.push_back(Pair(\"satoshis\", it->second));\n+        delta.push_back(Pair(\"txid\", it->first.txhash.GetHex()));\n+        delta.push_back(Pair(\"index\", (int)it->first.index));\n+        delta.push_back(Pair(\"blockindex\", (int)it->first.txindex));\n+        delta.push_back(Pair(\"height\", it->first.blockHeight));\n+        delta.push_back(Pair(\"address\", address));\n+        deltas.push_back(delta);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    if (includeChainInfo && start > 0 && end > 0) {\n+        LOCK(cs_main);\n+\n+        if (start > chainActive.Height() || end > chainActive.Height()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Start or end is outside chain range\");\n+        }\n+\n+        CBlockIndex* startIndex = chainActive[start];\n+        CBlockIndex* endIndex = chainActive[end];\n+\n+        UniValue startInfo(UniValue::VOBJ);\n+        UniValue endInfo(UniValue::VOBJ);\n+\n+        startInfo.push_back(Pair(\"hash\", startIndex->GetBlockHash().GetHex()));\n+        startInfo.push_back(Pair(\"height\", start));\n+\n+        endInfo.push_back(Pair(\"hash\", endIndex->GetBlockHash().GetHex()));\n+        endInfo.push_back(Pair(\"height\", end));\n+\n+        result.push_back(Pair(\"deltas\", deltas));\n+        result.push_back(Pair(\"start\", startInfo));\n+        result.push_back(Pair(\"end\", endInfo));\n+\n+        return result;\n+    } else {\n+        return deltas;\n+    }\n+}\n+\n+UniValue getaddressbalance(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"getaddressbalance\\n\"\n+            \"\\nReturns the balance for an address(es) (requires addressindex to be enabled).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"addresses\\\"\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"}\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"balance\\\"  (string) The current balance in satoshis\\n\"\n+            \"  \\\"received\\\"  (string) The total number of satoshis received (including change)\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getaddressbalance\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n+            + HelpExampleRpc(\"getaddressbalance\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n+        );\n+\n+    std::vector<std::pair<uint160, int> > addresses;\n+\n+    if (!getAddressesFromParams(params, addresses)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;\n+\n+    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n+        if (!GetAddressIndex((*it).first, (*it).second, addressIndex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+        }\n+    }\n+\n+    CAmount balance = 0;\n+    CAmount received = 0;\n+\n+    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=addressIndex.begin(); it!=addressIndex.end(); it++) {\n+        if (it->second > 0) {\n+            received += it->second;\n+        }\n+        balance += it->second;\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    result.push_back(Pair(\"balance\", balance));\n+    result.push_back(Pair(\"received\", received));\n+\n+    return result;\n+\n+}\n+\n+UniValue getaddresstxids(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"getaddresstxids\\n\"\n+            \"\\nReturns the txids for an address(es) (requires addressindex to be enabled).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"addresses\\\"\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"  \\\"start\\\" (number) The start block height\\n\"\n+            \"  \\\"end\\\" (number) The end block height\\n\"\n+            \"}\\n\"\n+            \"\\nResult:\\n\"\n+            \"[\\n\"\n+            \"  \\\"transactionid\\\"  (string) The transaction id\\n\"\n+            \"  ,...\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getaddresstxids\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n+            + HelpExampleRpc(\"getaddresstxids\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n+        );\n+\n+    std::vector<std::pair<uint160, int> > addresses;\n+\n+    if (!getAddressesFromParams(params, addresses)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    int start = 0;\n+    int end = 0;\n+    if (params[0].isObject()) {\n+        UniValue startValue = find_value(params[0].get_obj(), \"start\");\n+        UniValue endValue = find_value(params[0].get_obj(), \"end\");\n+        if (startValue.isNum() && endValue.isNum()) {\n+            start = startValue.get_int();\n+            end = endValue.get_int();\n+        }\n+    }\n+\n+    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;\n+\n+    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n+        if (start > 0 && end > 0) {\n+            if (!GetAddressIndex((*it).first, (*it).second, addressIndex, start, end)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+            }\n+        } else {\n+            if (!GetAddressIndex((*it).first, (*it).second, addressIndex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+            }\n+        }\n+    }\n+\n+    std::set<std::pair<int, std::string> > txids;\n+    UniValue result(UniValue::VARR);\n+\n+    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=addressIndex.begin(); it!=addressIndex.end(); it++) {\n+        int height = it->first.blockHeight;\n+        std::string txid = it->first.txhash.GetHex();\n+\n+        if (addresses.size() > 1) {\n+            txids.insert(std::make_pair(height, txid));\n+        } else {\n+            if (txids.insert(std::make_pair(height, txid)).second) {\n+                result.push_back(txid);\n+            }\n+        }\n+    }\n+\n+    if (addresses.size() > 1) {\n+        for (std::set<std::pair<int, std::string> >::const_iterator it=txids.begin(); it!=txids.end(); it++) {\n+            result.push_back(it->second);\n+        }\n+    }\n+\n+    return result;\n+\n+}\n+\n+UniValue getspentinfo(const UniValue& params, bool fHelp)\n+{\n+\n+    if (fHelp || params.size() != 1 || !params[0].isObject())\n+        throw runtime_error(\n+            \"getspentinfo\\n\"\n+            \"\\nReturns the txid and index where an output is spent.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\" (string) The hex string of the txid\\n\"\n+            \"  \\\"index\\\" (number) The start block height\\n\"\n+            \"}\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\"  (string) The transaction id\\n\"\n+            \"  \\\"index\\\"  (number) The spending input index\\n\"\n+            \"  ,...\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getspentinfo\", \"'{\\\"txid\\\": \\\"0437cd7f8525ceed2324359c2d0ba26006d92d856a9c20fa0241106ee5a597c9\\\", \\\"index\\\": 0}'\")\n+            + HelpExampleRpc(\"getspentinfo\", \"{\\\"txid\\\": \\\"0437cd7f8525ceed2324359c2d0ba26006d92d856a9c20fa0241106ee5a597c9\\\", \\\"index\\\": 0}\")\n+        );\n+\n+    UniValue txidValue = find_value(params[0].get_obj(), \"txid\");\n+    UniValue indexValue = find_value(params[0].get_obj(), \"index\");\n+\n+    if (!txidValue.isStr() || !indexValue.isNum()) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid txid or index\");\n+    }\n+\n+    uint256 txid = ParseHashV(txidValue, \"txid\");\n+    int outputIndex = indexValue.get_int();\n+\n+    CSpentIndexKey key(txid, outputIndex);\n+    CSpentIndexValue value;\n+\n+    if (!GetSpentIndex(key, value)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unable to get spent info\");\n+    }\n+\n+    UniValue obj(UniValue::VOBJ);\n+    obj.push_back(Pair(\"txid\", value.txid.GetHex()));\n+    obj.push_back(Pair(\"index\", (int)value.inputIndex));\n+    obj.push_back(Pair(\"height\", value.blockHeight));\n+\n+    return obj;\n+}\n+\n static const CRPCCommand commands[] =\n { //  category              name                      actor (function)         okSafeMode\n   //  --------------------- ------------------------  -----------------------  ----------\n@@ -494,6 +1022,16 @@ static const CRPCCommand commands[] =\n     { \"util\",               \"verifymessage\",          &verifymessage,          true  },\n     { \"util\",               \"signmessagewithprivkey\", &signmessagewithprivkey, true  },\n \n+    /* Address index */\n+    { \"addressindex\",       \"getaddressmempool\",      &getaddressmempool,      true  },\n+    { \"addressindex\",       \"getaddressutxos\",        &getaddressutxos,        false },\n+    { \"addressindex\",       \"getaddressdeltas\",       &getaddressdeltas,       false },\n+    { \"addressindex\",       \"getaddresstxids\",        &getaddresstxids,        false },\n+    { \"addressindex\",       \"getaddressbalance\",      &getaddressbalance,      false },\n+\n+    /* Blockchain */\n+    { \"blockchain\",         \"getspentinfo\",           &getspentinfo,           false },\n+\n     /* Not shown in help */\n     { \"hidden\",             \"setmocktime\",            &setmocktime,            true  },\n };"
      },
      {
        "sha": "e84baf7bc0050a04eeaf8eaa7da0c375f38bae23",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 126,
        "deletions": 7,
        "changes": 133,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -59,6 +59,100 @@ void ScriptPubKeyToJSON(const CScript& scriptPubKey, UniValue& out, bool fInclud\n     out.push_back(Pair(\"addresses\", a));\n }\n \n+void TxToJSONExpanded(const CTransaction& tx, const uint256 hashBlock, UniValue& entry,\n+                      int nHeight = 0, int nConfirmations = 0, int nBlockTime = 0)\n+{\n+\n+    uint256 txid = tx.GetHash();\n+    entry.push_back(Pair(\"txid\", txid.GetHex()));\n+    entry.push_back(Pair(\"hash\", tx.GetWitnessHash().GetHex()));\n+    entry.push_back(Pair(\"size\", (int)::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION)));\n+    entry.push_back(Pair(\"vsize\", (int)::GetVirtualTransactionSize(tx)));\n+    entry.push_back(Pair(\"version\", tx.nVersion));\n+    entry.push_back(Pair(\"locktime\", (int64_t)tx.nLockTime));\n+    UniValue vin(UniValue::VARR);\n+    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+        const CTxIn& txin = tx.vin[i];\n+        UniValue in(UniValue::VOBJ);\n+        if (tx.IsCoinBase())\n+            in.push_back(Pair(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n+        else {\n+            in.push_back(Pair(\"txid\", txin.prevout.hash.GetHex()));\n+            in.push_back(Pair(\"vout\", (int64_t)txin.prevout.n));\n+            UniValue o(UniValue::VOBJ);\n+            o.push_back(Pair(\"asm\", ScriptToAsmStr(txin.scriptSig, true)));\n+            o.push_back(Pair(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n+            in.push_back(Pair(\"scriptSig\", o));\n+\n+            // Add address and value info if spentindex enabled\n+            CSpentIndexValue spentInfo;\n+            CSpentIndexKey spentKey(txin.prevout.hash, txin.prevout.n);\n+            if (GetSpentIndex(spentKey, spentInfo)) {\n+                in.push_back(Pair(\"value\", ValueFromAmount(spentInfo.satoshis)));\n+                in.push_back(Pair(\"valueSat\", spentInfo.satoshis));\n+                if (spentInfo.addressType == 1) {\n+                    in.push_back(Pair(\"address\", CBitcoinAddress(CKeyID(spentInfo.addressHash)).ToString()));\n+                } else if (spentInfo.addressType == 2)  {\n+                    in.push_back(Pair(\"address\", CBitcoinAddress(CScriptID(spentInfo.addressHash)).ToString()));\n+                }\n+            }\n+\n+        }\n+        if (!tx.wit.IsNull()) {\n+            if (!tx.wit.vtxinwit[i].IsNull()) {\n+                UniValue txinwitness(UniValue::VARR);\n+                for (unsigned int j = 0; j < tx.wit.vtxinwit[i].scriptWitness.stack.size(); j++) {\n+                    std::vector<unsigned char> item = tx.wit.vtxinwit[i].scriptWitness.stack[j];\n+                    txinwitness.push_back(HexStr(item.begin(), item.end()));\n+                }\n+                in.push_back(Pair(\"txinwitness\", txinwitness));\n+            }\n+\n+        }\n+        in.push_back(Pair(\"sequence\", (int64_t)txin.nSequence));\n+        vin.push_back(in);\n+    }\n+    entry.push_back(Pair(\"vin\", vin));\n+    UniValue vout(UniValue::VARR);\n+    for (unsigned int i = 0; i < tx.vout.size(); i++) {\n+        const CTxOut& txout = tx.vout[i];\n+        UniValue out(UniValue::VOBJ);\n+        out.push_back(Pair(\"value\", ValueFromAmount(txout.nValue)));\n+        out.push_back(Pair(\"valueSat\", txout.nValue));\n+        out.push_back(Pair(\"n\", (int64_t)i));\n+        UniValue o(UniValue::VOBJ);\n+        ScriptPubKeyToJSON(txout.scriptPubKey, o, true);\n+        out.push_back(Pair(\"scriptPubKey\", o));\n+\n+        // Add spent information if spentindex is enabled\n+        CSpentIndexValue spentInfo;\n+        CSpentIndexKey spentKey(txid, i);\n+        if (GetSpentIndex(spentKey, spentInfo)) {\n+            out.push_back(Pair(\"spentTxId\", spentInfo.txid.GetHex()));\n+            out.push_back(Pair(\"spentIndex\", (int)spentInfo.inputIndex));\n+            out.push_back(Pair(\"spentHeight\", spentInfo.blockHeight));\n+        }\n+\n+        vout.push_back(out);\n+    }\n+    entry.push_back(Pair(\"vout\", vout));\n+\n+    if (!hashBlock.IsNull()) {\n+        entry.push_back(Pair(\"blockhash\", hashBlock.GetHex()));\n+\n+        if (nConfirmations > 0) {\n+            entry.push_back(Pair(\"height\", nHeight));\n+            entry.push_back(Pair(\"confirmations\", nConfirmations));\n+            entry.push_back(Pair(\"time\", nBlockTime));\n+            entry.push_back(Pair(\"blocktime\", nBlockTime));\n+        } else {\n+            entry.push_back(Pair(\"height\", -1));\n+            entry.push_back(Pair(\"confirmations\", 0));\n+        }\n+    }\n+\n+}\n+\n void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n {\n     entry.push_back(Pair(\"txid\", tx.GetHash().GetHex()));\n@@ -97,11 +191,13 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n         vin.push_back(in);\n     }\n     entry.push_back(Pair(\"vin\", vin));\n+\n     UniValue vout(UniValue::VARR);\n     for (unsigned int i = 0; i < tx.vout.size(); i++) {\n         const CTxOut& txout = tx.vout[i];\n         UniValue out(UniValue::VOBJ);\n         out.push_back(Pair(\"value\", ValueFromAmount(txout.nValue)));\n+        out.push_back(Pair(\"valueSat\", txout.nValue));\n         out.push_back(Pair(\"n\", (int64_t)i));\n         UniValue o(UniValue::VOBJ);\n         ScriptPubKeyToJSON(txout.scriptPubKey, o, true);\n@@ -116,12 +212,14 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n         if (mi != mapBlockIndex.end() && (*mi).second) {\n             CBlockIndex* pindex = (*mi).second;\n             if (chainActive.Contains(pindex)) {\n+                entry.push_back(Pair(\"height\", pindex->nHeight));\n                 entry.push_back(Pair(\"confirmations\", 1 + chainActive.Height() - pindex->nHeight));\n                 entry.push_back(Pair(\"time\", pindex->GetBlockTime()));\n                 entry.push_back(Pair(\"blocktime\", pindex->GetBlockTime()));\n-            }\n-            else\n+            } else {\n+                entry.push_back(Pair(\"height\", -1));\n                 entry.push_back(Pair(\"confirmations\", 0));\n+            }\n         }\n     }\n }\n@@ -196,18 +294,38 @@ UniValue getrawtransaction(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"getrawtransaction\", \"\\\"mytxid\\\", 1\")\n         );\n \n-    LOCK(cs_main);\n-\n     uint256 hash = ParseHashV(params[0], \"parameter 1\");\n \n     bool fVerbose = false;\n     if (params.size() > 1)\n         fVerbose = (params[1].get_int() != 0);\n \n     CTransaction tx;\n+\n     uint256 hashBlock;\n-    if (!GetTransaction(hash, tx, Params().GetConsensus(), hashBlock, true))\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available about transaction\");\n+    int nHeight = 0;\n+    int nConfirmations = 0;\n+    int nBlockTime = 0;\n+\n+    {\n+        LOCK(cs_main);\n+        if (!GetTransaction(hash, tx, Params().GetConsensus(), hashBlock, true))\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available about transaction\");\n+\n+        BlockMap::iterator mi = mapBlockIndex.find(hashBlock);\n+        if (mi != mapBlockIndex.end() && (*mi).second) {\n+            CBlockIndex* pindex = (*mi).second;\n+            if (chainActive.Contains(pindex)) {\n+                nHeight = pindex->nHeight;\n+                nConfirmations = 1 + chainActive.Height() - pindex->nHeight;\n+                nBlockTime = pindex->GetBlockTime();\n+            } else {\n+                nHeight = -1;\n+                nConfirmations = 0;\n+                nBlockTime = pindex->GetBlockTime();\n+            }\n+        }\n+    }\n \n     string strHex = EncodeHexTx(tx);\n \n@@ -216,7 +334,8 @@ UniValue getrawtransaction(const UniValue& params, bool fHelp)\n \n     UniValue result(UniValue::VOBJ);\n     result.push_back(Pair(\"hex\", strHex));\n-    TxToJSON(tx, hashBlock, result);\n+    TxToJSONExpanded(tx, hashBlock, result, nHeight, nConfirmations, nBlockTime);\n+\n     return result;\n }\n "
      },
      {
        "sha": "eb1174e2e2f2a8afe1a625271bb1f3790ae3779e",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -201,6 +201,17 @@ unsigned int CScript::GetSigOpCount(const CScript& scriptSig) const\n     return subscript.GetSigOpCount(true);\n }\n \n+bool CScript::IsPayToPublicKeyHash() const\n+{\n+    // Extra-fast test for pay-to-pubkey-hash CScripts:\n+    return (this->size() == 25 &&\n+\t    (*this)[0] == OP_DUP &&\n+\t    (*this)[1] == OP_HASH160 &&\n+\t    (*this)[2] == 0x14 &&\n+\t    (*this)[23] == OP_EQUALVERIFY &&\n+\t    (*this)[24] == OP_CHECKSIG);\n+}\n+\n bool CScript::IsPayToScriptHash() const\n {\n     // Extra-fast test for pay-to-script-hash CScripts:"
      },
      {
        "sha": "e6303e7058433953976f10086ebf9722832079c2",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -620,6 +620,8 @@ class CScript : public CScriptBase\n      */\n     unsigned int GetSigOpCount(const CScript& scriptSig) const;\n \n+    bool IsPayToPublicKeyHash() const;\n+\n     bool IsPayToScriptHash() const;\n     bool IsPayToWitnessScriptHash() const;\n     bool IsWitnessProgram(int& version, std::vector<unsigned char>& program) const;"
      },
      {
        "sha": "3fa23e27d025141cba74837d46c02d8bba0fa3c1",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -91,6 +91,11 @@ template<typename Stream> inline void ser_writedata32(Stream &s, uint32_t obj)\n     obj = htole32(obj);\n     s.write((char*)&obj, 4);\n }\n+template<typename Stream> inline void ser_writedata32be(Stream &s, uint32_t obj)\n+{\n+    obj = htobe32(obj);\n+    s.write((char*)&obj, 4);\n+}\n template<typename Stream> inline void ser_writedata64(Stream &s, uint64_t obj)\n {\n     obj = htole64(obj);\n@@ -114,6 +119,12 @@ template<typename Stream> inline uint32_t ser_readdata32(Stream &s)\n     s.read((char*)&obj, 4);\n     return le32toh(obj);\n }\n+template<typename Stream> inline uint32_t ser_readdata32be(Stream &s)\n+{\n+    uint32_t obj;\n+    s.read((char*)&obj, 4);\n+    return be32toh(obj);\n+}\n template<typename Stream> inline uint64_t ser_readdata64(Stream &s)\n {\n     uint64_t obj;"
      },
      {
        "sha": "bd5da45d60dbc0d7377779329c90e597e0f1841e",
        "filename": "src/spentindex.h",
        "status": "added",
        "additions": 98,
        "deletions": 0,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/spentindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/spentindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/spentindex.h?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -0,0 +1,98 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SPENTINDEX_H\n+#define BITCOIN_SPENTINDEX_H\n+\n+#include \"uint256.h\"\n+#include \"amount.h\"\n+\n+struct CSpentIndexKey {\n+    uint256 txid;\n+    unsigned int outputIndex;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(txid);\n+        READWRITE(outputIndex);\n+    }\n+\n+    CSpentIndexKey(uint256 t, unsigned int i) {\n+        txid = t;\n+        outputIndex = i;\n+    }\n+\n+    CSpentIndexKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        txid.SetNull();\n+        outputIndex = 0;\n+    }\n+\n+};\n+\n+struct CSpentIndexValue {\n+    uint256 txid;\n+    unsigned int inputIndex;\n+    int blockHeight;\n+    CAmount satoshis;\n+    int addressType;\n+    uint160 addressHash;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(txid);\n+        READWRITE(inputIndex);\n+        READWRITE(blockHeight);\n+        READWRITE(satoshis);\n+        READWRITE(addressType);\n+        READWRITE(addressHash);\n+    }\n+\n+    CSpentIndexValue(uint256 t, unsigned int i, int h, CAmount s, int type, uint160 a) {\n+        txid = t;\n+        inputIndex = i;\n+        blockHeight = h;\n+        satoshis = s;\n+        addressType = type;\n+        addressHash = a;\n+    }\n+\n+    CSpentIndexValue() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        txid.SetNull();\n+        inputIndex = 0;\n+        blockHeight = 0;\n+        satoshis = 0;\n+        addressType = 0;\n+        addressHash.SetNull();\n+    }\n+\n+    bool IsNull() const {\n+        return txid.IsNull();\n+    }\n+};\n+\n+struct CSpentIndexKeyCompare\n+{\n+    bool operator()(const CSpentIndexKey& a, const CSpentIndexKey& b) const {\n+        if (a.txid == b.txid) {\n+            return a.outputIndex < b.outputIndex;\n+        } else {\n+            return a.txid < b.txid;\n+        }\n+    }\n+};\n+\n+#endif // BITCOIN_SPENTINDEX_H"
      },
      {
        "sha": "33a4e78e3d60c38977638130c183f20deda3d59e",
        "filename": "src/test/dbwrapper_tests.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 0,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/test/dbwrapper_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/test/dbwrapper_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/dbwrapper_tests.cpp?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -47,6 +47,49 @@ BOOST_AUTO_TEST_CASE(dbwrapper)\n     }\n }\n \n+BOOST_AUTO_TEST_CASE(dbwrapper_compression)\n+{\n+    // Perform tests both with compression and without\n+    for (int i = 0; i < 2; i++) {\n+        bool compression = (bool)i;\n+        path ph = temp_directory_path() / unique_path();\n+        CDBWrapper dbw(ph, (1 << 20), true, false, false, compression);\n+        char key = 'k';\n+        uint256 in = GetRandHash();\n+        uint256 res;\n+\n+        BOOST_CHECK(dbw.Write(key, in));\n+        BOOST_CHECK(dbw.Read(key, res));\n+        BOOST_CHECK_EQUAL(res.ToString(), in.ToString());\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(dbwrapper_maxopenfiles_64)\n+{\n+    path ph = temp_directory_path() / unique_path();\n+    CDBWrapper dbw(ph, (1 << 20), true, false, false, false, 64);\n+    char key = 'k';\n+    uint256 in = GetRandHash();\n+    uint256 res;\n+\n+    BOOST_CHECK(dbw.Write(key, in));\n+    BOOST_CHECK(dbw.Read(key, res));\n+    BOOST_CHECK_EQUAL(res.ToString(), in.ToString());\n+}\n+\n+BOOST_AUTO_TEST_CASE(dbwrapper_maxopenfiles_1000)\n+{\n+    path ph = temp_directory_path() / unique_path();\n+    CDBWrapper dbw(ph, (1 << 20), true, false, false, false, 1000);\n+    char key = 'k';\n+    uint256 in = GetRandHash();\n+    uint256 res;\n+\n+    BOOST_CHECK(dbw.Write(key, in));\n+    BOOST_CHECK(dbw.Read(key, res));\n+    BOOST_CHECK_EQUAL(res.ToString(), in.ToString());\n+}\n+\n // Test batch operations\n BOOST_AUTO_TEST_CASE(dbwrapper_batch)\n {"
      },
      {
        "sha": "3a7dc16608aaac610bf97577a66cf4038d3f4396",
        "filename": "src/test/script_P2PKH_tests.cpp",
        "status": "added",
        "additions": 59,
        "deletions": 0,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/test/script_P2PKH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/test/script_P2PKH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2PKH_tests.cpp?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -0,0 +1,59 @@\n+// Copyright (c) 2012-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"script/script.h\"\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+using namespace std;\n+\n+BOOST_FIXTURE_TEST_SUITE(script_P2PKH_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(IsPayToPublicKeyHash)\n+{\n+    // Test CScript::IsPayToPublicKeyHash()\n+    uint160 dummy;\n+    CScript p2pkh;\n+    p2pkh << OP_DUP << OP_HASH160 << ToByteVector(dummy) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(p2pkh.IsPayToPublicKeyHash());\n+\n+    static const unsigned char direct[] = {\n+        OP_DUP, OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUALVERIFY, OP_CHECKSIG\n+    };\n+    BOOST_CHECK(CScript(direct, direct+sizeof(direct)).IsPayToPublicKeyHash());\n+\n+    static const unsigned char notp2pkh1[] = {\n+        OP_DUP, OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUALVERIFY, OP_CHECKSIG, OP_CHECKSIG\n+    };\n+    BOOST_CHECK(!CScript(notp2pkh1, notp2pkh1+sizeof(notp2pkh1)).IsPayToPublicKeyHash());\n+\n+    static const unsigned char p2sh[] = {\n+        OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL\n+    };\n+    BOOST_CHECK(!CScript(p2sh, p2sh+sizeof(p2sh)).IsPayToPublicKeyHash());\n+\n+    static const unsigned char extra[] = {\n+        OP_DUP, OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUALVERIFY, OP_CHECKSIG, OP_CHECKSIG\n+    };\n+    BOOST_CHECK(!CScript(extra, extra+sizeof(extra)).IsPayToPublicKeyHash());\n+\n+    static const unsigned char missing[] = {\n+        OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUALVERIFY, OP_CHECKSIG, OP_RETURN\n+    };\n+    BOOST_CHECK(!CScript(missing, missing+sizeof(missing)).IsPayToPublicKeyHash());\n+\n+    static const unsigned char missing2[] = {\n+        OP_DUP, OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+    };\n+    BOOST_CHECK(!CScript(missing2, missing2+sizeof(missing)).IsPayToPublicKeyHash());\n+\n+    static const unsigned char tooshort[] = {\n+        OP_DUP, OP_HASH160, 2, 0,0, OP_EQUALVERIFY, OP_CHECKSIG\n+    };\n+    BOOST_CHECK(!CScript(tooshort, tooshort+sizeof(direct)).IsPayToPublicKeyHash());\n+\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "ea792797e18e1bef590c0e8798fb9cfa28c67a3a",
        "filename": "src/timestampindex.h",
        "status": "added",
        "additions": 131,
        "deletions": 0,
        "changes": 131,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/timestampindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/timestampindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timestampindex.h?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -0,0 +1,131 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TIMESTAMPINDEX_H\n+#define BITCOIN_TIMESTAMPINDEX_H\n+\n+#include \"uint256.h\"\n+\n+struct CTimestampIndexIteratorKey {\n+    unsigned int timestamp;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 4;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata32be(s, timestamp);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        timestamp = ser_readdata32be(s);\n+    }\n+\n+    CTimestampIndexIteratorKey(unsigned int time) {\n+        timestamp = time;\n+    }\n+\n+    CTimestampIndexIteratorKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        timestamp = 0;\n+    }\n+};\n+\n+struct CTimestampIndexKey {\n+    unsigned int timestamp;\n+    uint256 blockHash;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 36;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata32be(s, timestamp);\n+        blockHash.Serialize(s, nType, nVersion);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        timestamp = ser_readdata32be(s);\n+        blockHash.Unserialize(s, nType, nVersion);\n+    }\n+\n+    CTimestampIndexKey(unsigned int time, uint256 hash) {\n+        timestamp = time;\n+        blockHash = hash;\n+    }\n+\n+    CTimestampIndexKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        timestamp = 0;\n+        blockHash.SetNull();\n+    }\n+};\n+\n+struct CTimestampBlockIndexKey {\n+    uint256 blockHash;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 32;\n+    }\n+\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        blockHash.Serialize(s, nType, nVersion);\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        blockHash.Unserialize(s, nType, nVersion);\n+    }\n+\n+    CTimestampBlockIndexKey(uint256 hash) {\n+        blockHash = hash;\n+    }\n+\n+    CTimestampBlockIndexKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        blockHash.SetNull();\n+    }\n+};\n+\n+struct CTimestampBlockIndexValue {\n+    unsigned int ltimestamp;\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 4;\n+    }\n+\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata32be(s, ltimestamp);\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        ltimestamp = ser_readdata32be(s);\n+    }\n+\n+    CTimestampBlockIndexValue (unsigned int time) {\n+        ltimestamp = time;\n+    }\n+\n+    CTimestampBlockIndexValue() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        ltimestamp = 0;\n+    }\n+};\n+\n+#endif // BITCOIN_TIMESTAMPINDEX_H"
      },
      {
        "sha": "b2b34e002911810b341eeda986c015abc38278e9",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 158,
        "deletions": 2,
        "changes": 160,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -19,6 +19,11 @@ using namespace std;\n static const char DB_COINS = 'c';\n static const char DB_BLOCK_FILES = 'f';\n static const char DB_TXINDEX = 't';\n+static const char DB_ADDRESSINDEX = 'a';\n+static const char DB_ADDRESSUNSPENTINDEX = 'u';\n+static const char DB_TIMESTAMPINDEX = 's';\n+static const char DB_BLOCKHASHINDEX = 'z';\n+static const char DB_SPENTINDEX = 'p';\n static const char DB_BLOCK_INDEX = 'b';\n \n static const char DB_BEST_BLOCK = 'B';\n@@ -27,7 +32,7 @@ static const char DB_REINDEX_FLAG = 'R';\n static const char DB_LAST_BLOCK = 'l';\n \n \n-CCoinsViewDB::CCoinsViewDB(size_t nCacheSize, bool fMemory, bool fWipe) : db(GetDataDir() / \"chainstate\", nCacheSize, fMemory, fWipe, true) \n+CCoinsViewDB::CCoinsViewDB(size_t nCacheSize, bool fMemory, bool fWipe) : db(GetDataDir() / \"chainstate\", nCacheSize, fMemory, fWipe, true, false, 64)\n {\n }\n \n@@ -69,7 +74,7 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     return db.WriteBatch(batch);\n }\n \n-CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory, bool fWipe) : CDBWrapper(GetDataDir() / \"blocks\" / \"index\", nCacheSize, fMemory, fWipe) {\n+CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory, bool fWipe, bool compression, int maxOpenFiles) : CDBWrapper(GetDataDir() / \"blocks\" / \"index\", nCacheSize, fMemory, fWipe, false, compression, maxOpenFiles) {\n }\n \n bool CBlockTreeDB::ReadBlockFileInfo(int nFile, CBlockFileInfo &info) {\n@@ -159,6 +164,157 @@ bool CBlockTreeDB::WriteTxIndex(const std::vector<std::pair<uint256, CDiskTxPos>\n     return WriteBatch(batch);\n }\n \n+bool CBlockTreeDB::ReadSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value) {\n+    return Read(make_pair(DB_SPENTINDEX, key), value);\n+}\n+\n+bool CBlockTreeDB::UpdateSpentIndex(const std::vector<std::pair<CSpentIndexKey, CSpentIndexValue> >&vect) {\n+    CDBBatch batch(*this);\n+    for (std::vector<std::pair<CSpentIndexKey,CSpentIndexValue> >::const_iterator it=vect.begin(); it!=vect.end(); it++) {\n+        if (it->second.IsNull()) {\n+            batch.Erase(make_pair(DB_SPENTINDEX, it->first));\n+        } else {\n+            batch.Write(make_pair(DB_SPENTINDEX, it->first), it->second);\n+        }\n+    }\n+    return WriteBatch(batch);\n+}\n+\n+bool CBlockTreeDB::UpdateAddressUnspentIndex(const std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue > >&vect) {\n+    CDBBatch batch(*this);\n+    for (std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> >::const_iterator it=vect.begin(); it!=vect.end(); it++) {\n+        if (it->second.IsNull()) {\n+            batch.Erase(make_pair(DB_ADDRESSUNSPENTINDEX, it->first));\n+        } else {\n+            batch.Write(make_pair(DB_ADDRESSUNSPENTINDEX, it->first), it->second);\n+        }\n+    }\n+    return WriteBatch(batch);\n+}\n+\n+bool CBlockTreeDB::ReadAddressUnspentIndex(uint160 addressHash, int type,\n+                                           std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > &unspentOutputs) {\n+\n+    boost::scoped_ptr<CDBIterator> pcursor(NewIterator());\n+\n+    pcursor->Seek(make_pair(DB_ADDRESSUNSPENTINDEX, CAddressIndexIteratorKey(type, addressHash)));\n+\n+    while (pcursor->Valid()) {\n+        boost::this_thread::interruption_point();\n+        std::pair<char,CAddressUnspentKey> key;\n+        if (pcursor->GetKey(key) && key.first == DB_ADDRESSUNSPENTINDEX && key.second.hashBytes == addressHash) {\n+            CAddressUnspentValue nValue;\n+            if (pcursor->GetValue(nValue)) {\n+                unspentOutputs.push_back(make_pair(key.second, nValue));\n+                pcursor->Next();\n+            } else {\n+                return error(\"failed to get address unspent value\");\n+            }\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+bool CBlockTreeDB::WriteAddressIndex(const std::vector<std::pair<CAddressIndexKey, CAmount > >&vect) {\n+    CDBBatch batch(*this);\n+    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=vect.begin(); it!=vect.end(); it++)\n+        batch.Write(make_pair(DB_ADDRESSINDEX, it->first), it->second);\n+    return WriteBatch(batch);\n+}\n+\n+bool CBlockTreeDB::EraseAddressIndex(const std::vector<std::pair<CAddressIndexKey, CAmount > >&vect) {\n+    CDBBatch batch(*this);\n+    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=vect.begin(); it!=vect.end(); it++)\n+        batch.Erase(make_pair(DB_ADDRESSINDEX, it->first));\n+    return WriteBatch(batch);\n+}\n+\n+bool CBlockTreeDB::ReadAddressIndex(uint160 addressHash, int type,\n+                                    std::vector<std::pair<CAddressIndexKey, CAmount> > &addressIndex,\n+                                    int start, int end) {\n+\n+    boost::scoped_ptr<CDBIterator> pcursor(NewIterator());\n+\n+    if (start > 0 && end > 0) {\n+        pcursor->Seek(make_pair(DB_ADDRESSINDEX, CAddressIndexIteratorHeightKey(type, addressHash, start)));\n+    } else {\n+        pcursor->Seek(make_pair(DB_ADDRESSINDEX, CAddressIndexIteratorKey(type, addressHash)));\n+    }\n+\n+    while (pcursor->Valid()) {\n+        boost::this_thread::interruption_point();\n+        std::pair<char,CAddressIndexKey> key;\n+        if (pcursor->GetKey(key) && key.first == DB_ADDRESSINDEX && key.second.hashBytes == addressHash) {\n+            if (end > 0 && key.second.blockHeight > end) {\n+                break;\n+            }\n+            CAmount nValue;\n+            if (pcursor->GetValue(nValue)) {\n+                addressIndex.push_back(make_pair(key.second, nValue));\n+                pcursor->Next();\n+            } else {\n+                return error(\"failed to get address index value\");\n+            }\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+bool CBlockTreeDB::WriteTimestampIndex(const CTimestampIndexKey &timestampIndex) {\n+    CDBBatch batch(*this);\n+    batch.Write(make_pair(DB_TIMESTAMPINDEX, timestampIndex), 0);\n+    return WriteBatch(batch);\n+}\n+\n+bool CBlockTreeDB::ReadTimestampIndex(const unsigned int &high, const unsigned int &low, const bool fActiveOnly, std::vector<std::pair<uint256, unsigned int> > &hashes) {\n+\n+    boost::scoped_ptr<CDBIterator> pcursor(NewIterator());\n+\n+    pcursor->Seek(make_pair(DB_TIMESTAMPINDEX, CTimestampIndexIteratorKey(low)));\n+\n+    while (pcursor->Valid()) {\n+        boost::this_thread::interruption_point();\n+        std::pair<char, CTimestampIndexKey> key;\n+        if (pcursor->GetKey(key) && key.first == DB_TIMESTAMPINDEX && key.second.timestamp < high) {\n+            if (fActiveOnly) {\n+                if (HashOnchainActive(key.second.blockHash)) {\n+                    hashes.push_back(std::make_pair(key.second.blockHash, key.second.timestamp));\n+                }\n+            } else {\n+                hashes.push_back(std::make_pair(key.second.blockHash, key.second.timestamp));\n+            }\n+\n+            pcursor->Next();\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+bool CBlockTreeDB::WriteTimestampBlockIndex(const CTimestampBlockIndexKey &blockhashIndex, const CTimestampBlockIndexValue &logicalts) {\n+    CDBBatch batch(*this);\n+    batch.Write(make_pair(DB_BLOCKHASHINDEX, blockhashIndex), logicalts);\n+    return WriteBatch(batch);\n+}\n+\n+bool CBlockTreeDB::ReadTimestampBlockIndex(const uint256 &hash, unsigned int &ltimestamp) {\n+\n+    CTimestampBlockIndexValue(lts);\n+    if (!Read(std::make_pair(DB_BLOCKHASHINDEX, hash), lts))\n+\treturn false;\n+\n+    ltimestamp = lts.ltimestamp;\n+    return true;\n+}\n+\n bool CBlockTreeDB::WriteFlag(const std::string &name, bool fValue) {\n     return Write(std::make_pair(DB_FLAG, name), fValue ? '1' : '0');\n }"
      },
      {
        "sha": "261b8a84e5dea932e164de942dc2427ffd51e728",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 19,
        "deletions": 1,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -6,9 +6,13 @@\n #ifndef BITCOIN_TXDB_H\n #define BITCOIN_TXDB_H\n \n+#include \"main.h\"\n #include \"coins.h\"\n #include \"dbwrapper.h\"\n #include \"chain.h\"\n+#include \"addressindex.h\"\n+#include \"spentindex.h\"\n+#include \"timestampindex.h\"\n \n #include <map>\n #include <string>\n@@ -102,7 +106,7 @@ class CCoinsViewDBCursor: public CCoinsViewCursor\n class CBlockTreeDB : public CDBWrapper\n {\n public:\n-    CBlockTreeDB(size_t nCacheSize, bool fMemory = false, bool fWipe = false);\n+    CBlockTreeDB(size_t nCacheSize, bool fMemory = false, bool fWipe = false, bool compression = true, int maxOpenFiles = 1000);\n private:\n     CBlockTreeDB(const CBlockTreeDB&);\n     void operator=(const CBlockTreeDB&);\n@@ -114,6 +118,20 @@ class CBlockTreeDB : public CDBWrapper\n     bool ReadReindexing(bool &fReindex);\n     bool ReadTxIndex(const uint256 &txid, CDiskTxPos &pos);\n     bool WriteTxIndex(const std::vector<std::pair<uint256, CDiskTxPos> > &list);\n+    bool ReadSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value);\n+    bool UpdateSpentIndex(const std::vector<std::pair<CSpentIndexKey, CSpentIndexValue> >&vect);\n+    bool UpdateAddressUnspentIndex(const std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue > >&vect);\n+    bool ReadAddressUnspentIndex(uint160 addressHash, int type,\n+                                 std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > &vect);\n+    bool WriteAddressIndex(const std::vector<std::pair<CAddressIndexKey, CAmount> > &vect);\n+    bool EraseAddressIndex(const std::vector<std::pair<CAddressIndexKey, CAmount> > &vect);\n+    bool ReadAddressIndex(uint160 addressHash, int type,\n+                          std::vector<std::pair<CAddressIndexKey, CAmount> > &addressIndex,\n+                          int start = 0, int end = 0);\n+    bool WriteTimestampIndex(const CTimestampIndexKey &timestampIndex);\n+    bool ReadTimestampIndex(const unsigned int &high, const unsigned int &low, const bool fActiveOnly, std::vector<std::pair<uint256, unsigned int> > &vect);\n+    bool WriteTimestampBlockIndex(const CTimestampBlockIndexKey &blockhashIndex, const CTimestampBlockIndexValue &logicalts);\n+    bool ReadTimestampBlockIndex(const uint256 &hash, unsigned int &logicalTS);\n     bool WriteFlag(const std::string &name, bool fValue);\n     bool ReadFlag(const std::string &name, bool &fValue);\n     bool LoadBlockIndexGuts(boost::function<CBlockIndex*(const uint256&)> insertBlockIndex);"
      },
      {
        "sha": "16cdbacf856374f983105e8be3008b5eeb6629c5",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 141,
        "deletions": 0,
        "changes": 141,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -450,6 +450,145 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,\n     return true;\n }\n \n+void CTxMemPool::addAddressIndex(const CTxMemPoolEntry &entry, const CCoinsViewCache &view)\n+{\n+    LOCK(cs);\n+    const CTransaction& tx = entry.GetTx();\n+    std::vector<CMempoolAddressDeltaKey> inserted;\n+\n+    uint256 txhash = tx.GetHash();\n+    for (unsigned int j = 0; j < tx.vin.size(); j++) {\n+        const CTxIn input = tx.vin[j];\n+        const CTxOut &prevout = view.GetOutputFor(input);\n+        if (prevout.scriptPubKey.IsPayToScriptHash()) {\n+            vector<unsigned char> hashBytes(prevout.scriptPubKey.begin()+2, prevout.scriptPubKey.begin()+22);\n+            CMempoolAddressDeltaKey key(2, uint160(hashBytes), txhash, j, 1);\n+            CMempoolAddressDelta delta(entry.GetTime(), prevout.nValue * -1, input.prevout.hash, input.prevout.n);\n+            mapAddress.insert(make_pair(key, delta));\n+            inserted.push_back(key);\n+        } else if (prevout.scriptPubKey.IsPayToPublicKeyHash()) {\n+            vector<unsigned char> hashBytes(prevout.scriptPubKey.begin()+3, prevout.scriptPubKey.begin()+23);\n+            CMempoolAddressDeltaKey key(1, uint160(hashBytes), txhash, j, 1);\n+            CMempoolAddressDelta delta(entry.GetTime(), prevout.nValue * -1, input.prevout.hash, input.prevout.n);\n+            mapAddress.insert(make_pair(key, delta));\n+            inserted.push_back(key);\n+        }\n+    }\n+\n+    for (unsigned int k = 0; k < tx.vout.size(); k++) {\n+        const CTxOut &out = tx.vout[k];\n+        if (out.scriptPubKey.IsPayToScriptHash()) {\n+            vector<unsigned char> hashBytes(out.scriptPubKey.begin()+2, out.scriptPubKey.begin()+22);\n+            CMempoolAddressDeltaKey key(2, uint160(hashBytes), txhash, k, 0);\n+            mapAddress.insert(make_pair(key, CMempoolAddressDelta(entry.GetTime(), out.nValue)));\n+            inserted.push_back(key);\n+        } else if (out.scriptPubKey.IsPayToPublicKeyHash()) {\n+            vector<unsigned char> hashBytes(out.scriptPubKey.begin()+3, out.scriptPubKey.begin()+23);\n+            std::pair<addressDeltaMap::iterator,bool> ret;\n+            CMempoolAddressDeltaKey key(1, uint160(hashBytes), txhash, k, 0);\n+            mapAddress.insert(make_pair(key, CMempoolAddressDelta(entry.GetTime(), out.nValue)));\n+            inserted.push_back(key);\n+        }\n+    }\n+\n+    mapAddressInserted.insert(make_pair(txhash, inserted));\n+}\n+\n+bool CTxMemPool::getAddressIndex(std::vector<std::pair<uint160, int> > &addresses,\n+                                 std::vector<std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> > &results)\n+{\n+    LOCK(cs);\n+    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n+        addressDeltaMap::iterator ait = mapAddress.lower_bound(CMempoolAddressDeltaKey((*it).second, (*it).first));\n+        while (ait != mapAddress.end() && (*ait).first.addressBytes == (*it).first && (*ait).first.type == (*it).second) {\n+            results.push_back(*ait);\n+            ait++;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool CTxMemPool::removeAddressIndex(const uint256 txhash)\n+{\n+    LOCK(cs);\n+    addressDeltaMapInserted::iterator it = mapAddressInserted.find(txhash);\n+\n+    if (it != mapAddressInserted.end()) {\n+        std::vector<CMempoolAddressDeltaKey> keys = (*it).second;\n+        for (std::vector<CMempoolAddressDeltaKey>::iterator mit = keys.begin(); mit != keys.end(); mit++) {\n+            mapAddress.erase(*mit);\n+        }\n+        mapAddressInserted.erase(it);\n+    }\n+\n+    return true;\n+}\n+\n+void CTxMemPool::addSpentIndex(const CTxMemPoolEntry &entry, const CCoinsViewCache &view)\n+{\n+    LOCK(cs);\n+\n+    const CTransaction& tx = entry.GetTx();\n+    std::vector<CSpentIndexKey> inserted;\n+\n+    uint256 txhash = tx.GetHash();\n+    for (unsigned int j = 0; j < tx.vin.size(); j++) {\n+        const CTxIn input = tx.vin[j];\n+        const CTxOut &prevout = view.GetOutputFor(input);\n+        uint160 addressHash;\n+        int addressType;\n+\n+        if (prevout.scriptPubKey.IsPayToScriptHash()) {\n+            addressHash = uint160(vector<unsigned char> (prevout.scriptPubKey.begin()+2, prevout.scriptPubKey.begin()+22));\n+            addressType = 2;\n+        } else if (prevout.scriptPubKey.IsPayToPublicKeyHash()) {\n+            addressHash = uint160(vector<unsigned char> (prevout.scriptPubKey.begin()+3, prevout.scriptPubKey.begin()+23));\n+            addressType = 1;\n+        } else {\n+            addressHash.SetNull();\n+            addressType = 0;\n+        }\n+\n+        CSpentIndexKey key = CSpentIndexKey(input.prevout.hash, input.prevout.n);\n+        CSpentIndexValue value = CSpentIndexValue(txhash, j, -1, prevout.nValue, addressType, addressHash);\n+\n+        mapSpent.insert(make_pair(key, value));\n+        inserted.push_back(key);\n+\n+    }\n+\n+    mapSpentInserted.insert(make_pair(txhash, inserted));\n+}\n+\n+bool CTxMemPool::getSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value)\n+{\n+    LOCK(cs);\n+    mapSpentIndex::iterator it;\n+\n+    it = mapSpent.find(key);\n+    if (it != mapSpent.end()) {\n+        value = it->second;\n+        return true;\n+    }\n+    return false;\n+}\n+\n+bool CTxMemPool::removeSpentIndex(const uint256 txhash)\n+{\n+    LOCK(cs);\n+    mapSpentIndexInserted::iterator it = mapSpentInserted.find(txhash);\n+\n+    if (it != mapSpentInserted.end()) {\n+        std::vector<CSpentIndexKey> keys = (*it).second;\n+        for (std::vector<CSpentIndexKey>::iterator mit = keys.begin(); mit != keys.end(); mit++) {\n+            mapSpent.erase(*mit);\n+        }\n+        mapSpentInserted.erase(it);\n+    }\n+\n+    return true;\n+}\n+\n void CTxMemPool::removeUnchecked(txiter it)\n {\n     const uint256 hash = it->GetTx().GetHash();\n@@ -472,6 +611,8 @@ void CTxMemPool::removeUnchecked(txiter it)\n     mapTx.erase(it);\n     nTransactionsUpdated++;\n     minerPolicyEstimator->removeTx(hash);\n+    removeAddressIndex(hash);\n+    removeSpentIndex(hash);\n }\n \n // Calculates descendants of entry that are not already in setDescendants, and adds to"
      },
      {
        "sha": "c5a8f5135a434d37bcfb9ad4df8534e6b19c437b",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48228479f063bc33c98b3231d264101cd692a6be/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48228479f063bc33c98b3231d264101cd692a6be/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=48228479f063bc33c98b3231d264101cd692a6be",
        "patch": "@@ -10,6 +10,8 @@\n #include <memory>\n #include <set>\n \n+#include \"addressindex.h\"\n+#include \"spentindex.h\"\n #include \"amount.h\"\n #include \"coins.h\"\n #include \"indirectmap.h\"\n@@ -484,6 +486,18 @@ class CTxMemPool\n     typedef std::map<txiter, TxLinks, CompareIteratorByHash> txlinksMap;\n     txlinksMap mapLinks;\n \n+    typedef std::map<CMempoolAddressDeltaKey, CMempoolAddressDelta, CMempoolAddressDeltaKeyCompare> addressDeltaMap;\n+    addressDeltaMap mapAddress;\n+\n+    typedef std::map<uint256, std::vector<CMempoolAddressDeltaKey> > addressDeltaMapInserted;\n+    addressDeltaMapInserted mapAddressInserted;\n+\n+    typedef std::map<CSpentIndexKey, CSpentIndexValue, CSpentIndexKeyCompare> mapSpentIndex;\n+    mapSpentIndex mapSpent;\n+\n+    typedef std::map<uint256, std::vector<CSpentIndexKey> > mapSpentIndexInserted;\n+    mapSpentIndexInserted mapSpentInserted;\n+\n     void UpdateParent(txiter entry, txiter parent, bool add);\n     void UpdateChild(txiter entry, txiter child, bool add);\n \n@@ -517,6 +531,15 @@ class CTxMemPool\n     bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, bool fCurrentEstimate = true);\n     bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, setEntries &setAncestors, bool fCurrentEstimate = true);\n \n+    void addAddressIndex(const CTxMemPoolEntry &entry, const CCoinsViewCache &view);\n+    bool getAddressIndex(std::vector<std::pair<uint160, int> > &addresses,\n+                         std::vector<std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> > &results);\n+    bool removeAddressIndex(const uint256 txhash);\n+\n+    void addSpentIndex(const CTxMemPoolEntry &entry, const CCoinsViewCache &view);\n+    bool getSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value);\n+    bool removeSpentIndex(const uint256 txhash);\n+\n     void removeRecursive(const CTransaction &tx, std::list<CTransaction>& removed);\n     void removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight, int flags);\n     void removeConflicts(const CTransaction &tx, std::list<CTransaction>& removed);"
      }
    ]
  },
  {
    "sha": "1fde065c0f4a9d57d9ccf0c8703c41ab36beeba8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZmRlMDY1YzBmNGE5ZDU3ZDljY2YwYzg3MDNjNDFhYjM2YmVlYmE4",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-07T15:49:40Z"
      },
      "committer": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-07T15:49:40Z"
      },
      "message": "build: include timestampindex.h in makefile",
      "tree": {
        "sha": "0a96597db0f9c8068a6a8c29966184bc9b26bac1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0a96597db0f9c8068a6a8c29966184bc9b26bac1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1fde065c0f4a9d57d9ccf0c8703c41ab36beeba8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1fde065c0f4a9d57d9ccf0c8703c41ab36beeba8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1fde065c0f4a9d57d9ccf0c8703c41ab36beeba8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1fde065c0f4a9d57d9ccf0c8703c41ab36beeba8/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "50d53a471e70883a292d3028c1349fac7c9c54cf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/50d53a471e70883a292d3028c1349fac7c9c54cf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/50d53a471e70883a292d3028c1349fac7c9c54cf"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "acf86816d5e7e8d879f9d80399be5962df9f20d7",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1fde065c0f4a9d57d9ccf0c8703c41ab36beeba8/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1fde065c0f4a9d57d9ccf0c8703c41ab36beeba8/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=1fde065c0f4a9d57d9ccf0c8703c41ab36beeba8",
        "patch": "@@ -73,6 +73,7 @@ endif\n BITCOIN_CORE_H = \\\n   addressindex.h \\\n   spentindex.h \\\n+  timestampindex.h \\\n   addrman.h \\\n   base58.h \\\n   bloom.h \\"
      }
    ]
  },
  {
    "sha": "1f0598705c3176f70325cd56a5446fec3ca4f13c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZjA1OTg3MDVjMzE3NmY3MDMyNWNkNTZhNTQ0NmZlYzNjYTRmMTNj",
    "commit": {
      "author": {
        "name": "Chris Kleeschulte",
        "email": "kleetus@users.noreply.github.com",
        "date": "2016-11-04T15:30:48Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2016-11-04T15:30:48Z"
      },
      "message": "Merge pull request #36 from braydonf/0.13-bitcore-tsb\n\nbuild: include timestampindex.h in makefile",
      "tree": {
        "sha": "9be1b58255f02643133b7a22f51519bb0a7a7f0d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9be1b58255f02643133b7a22f51519bb0a7a7f0d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1f0598705c3176f70325cd56a5446fec3ca4f13c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1f0598705c3176f70325cd56a5446fec3ca4f13c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1f0598705c3176f70325cd56a5446fec3ca4f13c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1f0598705c3176f70325cd56a5446fec3ca4f13c/comments",
    "author": {
      "login": "kleetus",
      "id": 12446,
      "node_id": "MDQ6VXNlcjEyNDQ2",
      "avatar_url": "https://avatars.githubusercontent.com/u/12446?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kleetus",
      "html_url": "https://github.com/kleetus",
      "followers_url": "https://api.github.com/users/kleetus/followers",
      "following_url": "https://api.github.com/users/kleetus/following{/other_user}",
      "gists_url": "https://api.github.com/users/kleetus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kleetus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kleetus/subscriptions",
      "organizations_url": "https://api.github.com/users/kleetus/orgs",
      "repos_url": "https://api.github.com/users/kleetus/repos",
      "events_url": "https://api.github.com/users/kleetus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kleetus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "48228479f063bc33c98b3231d264101cd692a6be",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/48228479f063bc33c98b3231d264101cd692a6be",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/48228479f063bc33c98b3231d264101cd692a6be"
      },
      {
        "sha": "1fde065c0f4a9d57d9ccf0c8703c41ab36beeba8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1fde065c0f4a9d57d9ccf0c8703c41ab36beeba8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1fde065c0f4a9d57d9ccf0c8703c41ab36beeba8"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "acf86816d5e7e8d879f9d80399be5962df9f20d7",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f0598705c3176f70325cd56a5446fec3ca4f13c/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f0598705c3176f70325cd56a5446fec3ca4f13c/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=1f0598705c3176f70325cd56a5446fec3ca4f13c",
        "patch": "@@ -73,6 +73,7 @@ endif\n BITCOIN_CORE_H = \\\n   addressindex.h \\\n   spentindex.h \\\n+  timestampindex.h \\\n   addrman.h \\\n   base58.h \\\n   bloom.h \\"
      }
    ]
  }
]