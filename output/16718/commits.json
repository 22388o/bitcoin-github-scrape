[
  {
    "sha": "6f9882ce4a817c9f14aa7526165ab6e278de890e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2Zjk4ODJjZTRhODE3YzlmMTRhYTc1MjYxNjVhYjZlMjc4ZGU4OTBl",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-08-22T18:19:41Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-08-23T17:19:12Z"
      },
      "message": "Use robin_hood.unordered_node_map for CCoinsViewCache.cacheCoins",
      "tree": {
        "sha": "4d8296b9b1360bd9d07726ca57ee519ab741bd1a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4d8296b9b1360bd9d07726ca57ee519ab741bd1a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6f9882ce4a817c9f14aa7526165ab6e278de890e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6f9882ce4a817c9f14aa7526165ab6e278de890e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6f9882ce4a817c9f14aa7526165ab6e278de890e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6f9882ce4a817c9f14aa7526165ab6e278de890e/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "52b9797119d5ee20b255efc68931ac7e158e325d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/52b9797119d5ee20b255efc68931ac7e158e325d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/52b9797119d5ee20b255efc68931ac7e158e325d"
      }
    ],
    "stats": {
      "total": 2053,
      "additions": 2048,
      "deletions": 5
    },
    "files": [
      {
        "sha": "afe97618b0dc5bdb5604d24147dbda45b9fe1d65",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f9882ce4a817c9f14aa7526165ab6e278de890e/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f9882ce4a817c9f14aa7526165ab6e278de890e/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=6f9882ce4a817c9f14aa7526165ab6e278de890e",
        "patch": "@@ -10,6 +10,7 @@\n #include <compressor.h>\n #include <core_memusage.h>\n #include <crypto/siphash.h>\n+#include <robin_hood.h>\n #include <memusage.h>\n #include <serialize.h>\n #include <uint256.h>\n@@ -120,7 +121,7 @@ struct CCoinsCacheEntry\n     explicit CCoinsCacheEntry(Coin&& coin_) : coin(std::move(coin_)), flags(0) {}\n };\n \n-typedef std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher> CCoinsMap;\n+typedef robin_hood::unordered_node_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher> CCoinsMap;\n \n /** Cursor for iterating over CoinsView state */\n class CCoinsViewCursor"
      },
      {
        "sha": "5ca96e8a84a25986508cbbb8d50f7d9ea5118ece",
        "filename": "src/memusage.h",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f9882ce4a817c9f14aa7526165ab6e278de890e/src/memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f9882ce4a817c9f14aa7526165ab6e278de890e/src/memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/memusage.h?ref=6f9882ce4a817c9f14aa7526165ab6e278de890e",
        "patch": "@@ -6,6 +6,7 @@\n #define BITCOIN_MEMUSAGE_H\n \n #include <indirectmap.h>\n+#include <robin_hood.h>\n \n #include <stdlib.h>\n \n@@ -16,7 +17,6 @@\n #include <unordered_map>\n #include <unordered_set>\n \n-\n namespace memusage\n {\n \n@@ -165,6 +165,12 @@ static inline size_t DynamicUsage(const std::unordered_map<X, Y, Z>& m)\n     return MallocUsage(sizeof(unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n }\n \n+template<typename X, typename Y, typename Z>\n+static inline size_t DynamicUsage(const robin_hood::unordered_node_map<X, Y, Z>& m)\n+{\n+    return MallocUsage(sizeof(unordered_node<robin_hood::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * (m.mask() + 1));\n+}\n+\n }\n \n #endif // BITCOIN_MEMUSAGE_H"
      },
      {
        "sha": "afe0326f3ef65d55a08445da5d5392adb734d217",
        "filename": "src/robin_hood.h",
        "status": "added",
        "additions": 2037,
        "deletions": 0,
        "changes": 2037,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f9882ce4a817c9f14aa7526165ab6e278de890e/src/robin_hood.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f9882ce4a817c9f14aa7526165ab6e278de890e/src/robin_hood.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/robin_hood.h?ref=6f9882ce4a817c9f14aa7526165ab6e278de890e",
        "patch": "@@ -0,0 +1,2037 @@\n+//                 ______  _____                 ______                _________\n+//  ______________ ___  /_ ___(_)_______         ___  /_ ______ ______ ______  /\n+//  __  ___/_  __ \\__  __ \\__  / __  __ \\        __  __ \\_  __ \\_  __ \\_  __  /\n+//  _  /    / /_/ /_  /_/ /_  /  _  / / /        _  / / // /_/ // /_/ // /_/ /\n+//  /_/     \\____/ /_.___/ /_/   /_/ /_/ ________/_/ /_/ \\____/ \\____/ \\__,_/\n+//                                      _/_____/\n+//\n+// robin_hood::unordered_map for C++11\n+// version 3.4.0\n+// https://github.com/martinus/robin-hood-hashing\n+//\n+// Licensed under the MIT License <http://opensource.org/licenses/MIT>.\n+// SPDX-License-Identifier: MIT\n+// Copyright (c) 2018-2019 Martin Ankerl <http://martin.ankerl.com>\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files (the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions:\n+//\n+// The above copyright notice and this permission notice shall be included in all\n+// copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+// SOFTWARE.\n+\n+#ifndef ROBIN_HOOD_H_INCLUDED\n+#define ROBIN_HOOD_H_INCLUDED\n+\n+// see https://semver.org/\n+#define ROBIN_HOOD_VERSION_MAJOR 3 // for incompatible API changes\n+#define ROBIN_HOOD_VERSION_MINOR 4 // for adding functionality in a backwards-compatible manner\n+#define ROBIN_HOOD_VERSION_PATCH 0 // for backwards-compatible bug fixes\n+\n+#include <algorithm>\n+#include <cstdlib>\n+#include <cstring>\n+#include <functional>\n+#include <stdexcept>\n+#include <string>\n+#include <type_traits>\n+#include <utility>\n+\n+// #define ROBIN_HOOD_LOG_ENABLED\n+#ifdef ROBIN_HOOD_LOG_ENABLED\n+#    include <iostream>\n+#    define ROBIN_HOOD_LOG(x) std::cout << __FUNCTION__ << \"@\" << __LINE__ << \": \" << x << std::endl\n+#else\n+#    define ROBIN_HOOD_LOG(x)\n+#endif\n+\n+// #define ROBIN_HOOD_TRACE_ENABLED\n+#ifdef ROBIN_HOOD_TRACE_ENABLED\n+#    include <iostream>\n+#    define ROBIN_HOOD_TRACE(x) \\\n+        std::cout << __FUNCTION__ << \"@\" << __LINE__ << \": \" << x << std::endl\n+#else\n+#    define ROBIN_HOOD_TRACE(x)\n+#endif\n+\n+// all non-argument macros should use this facility. See\n+// https://www.fluentcpp.com/2019/05/28/better-macros-better-flags/\n+#define ROBIN_HOOD(x) ROBIN_HOOD_PRIVATE_DEFINITION_##x()\n+\n+// mark unused members with this macro\n+#define ROBIN_HOOD_UNUSED(identifier)\n+\n+// bitness\n+#if SIZE_MAX == UINT32_MAX\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_BITNESS() 32\n+#elif SIZE_MAX == UINT64_MAX\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_BITNESS() 64\n+#else\n+#    error Unsupported bitness\n+#endif\n+\n+// endianess\n+#ifdef _WIN32\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_LITTLE_ENDIAN() 1\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_BIG_ENDIAN() 0\n+#else\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_LITTLE_ENDIAN() \\\n+        (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_BIG_ENDIAN() (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+#endif\n+\n+// inline\n+#ifdef _WIN32\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_NOINLINE() __declspec(noinline)\n+#else\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_NOINLINE() __attribute__((noinline))\n+#endif\n+\n+// exceptions\n+#if !defined(__cpp_exceptions) && !defined(__EXCEPTIONS) && !defined(_CPPUNWIND)\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_HAS_EXCEPTIONS() 0\n+#else\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_HAS_EXCEPTIONS() 1\n+#endif\n+\n+// count leading/trailing bits\n+#ifdef _WIN32\n+#    if ROBIN_HOOD(BITNESS) == 32\n+#        define ROBIN_HOOD_PRIVATE_DEFINITION_BITSCANFORWARD() _BitScanForward\n+#    else\n+#        define ROBIN_HOOD_PRIVATE_DEFINITION_BITSCANFORWARD() _BitScanForward64\n+#    endif\n+#    include <intrin.h>\n+#    pragma intrinsic(ROBIN_HOOD(BITSCANFORWARD))\n+#    define ROBIN_HOOD_COUNT_TRAILING_ZEROES(x)                                       \\\n+        [](size_t mask) noexcept->int {                                               \\\n+            unsigned long index;                                                      \\\n+            return ROBIN_HOOD(BITSCANFORWARD)(&index, mask) ? static_cast<int>(index) \\\n+                                                            : ROBIN_HOOD(BITNESS);    \\\n+        }                                                                             \\\n+        (x)\n+#else\n+#    if ROBIN_HOOD(BITNESS) == 32\n+#        define ROBIN_HOOD_PRIVATE_DEFINITION_CTZ() __builtin_ctzl\n+#        define ROBIN_HOOD_PRIVATE_DEFINITION_CLZ() __builtin_clzl\n+#    else\n+#        define ROBIN_HOOD_PRIVATE_DEFINITION_CTZ() __builtin_ctzll\n+#        define ROBIN_HOOD_PRIVATE_DEFINITION_CLZ() __builtin_clzll\n+#    endif\n+#    define ROBIN_HOOD_COUNT_LEADING_ZEROES(x) ((x) ? ROBIN_HOOD(CLZ)(x) : ROBIN_HOOD(BITNESS))\n+#    define ROBIN_HOOD_COUNT_TRAILING_ZEROES(x) ((x) ? ROBIN_HOOD(CTZ)(x) : ROBIN_HOOD(BITNESS))\n+#endif\n+\n+// fallthrough\n+#ifndef __has_cpp_attribute // For backwards compatibility\n+#    define __has_cpp_attribute(x) 0\n+#endif\n+#if __has_cpp_attribute(clang::fallthrough)\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_FALLTHROUGH() [[clang::fallthrough]]\n+#elif __has_cpp_attribute(gnu::fallthrough)\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_FALLTHROUGH() [[gnu::fallthrough]]\n+#else\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_FALLTHROUGH()\n+#endif\n+\n+// likely/unlikely\n+#if defined(_WIN32)\n+#    define ROBIN_HOOD_LIKELY(condition) condition\n+#    define ROBIN_HOOD_UNLIKELY(condition) condition\n+#else\n+#    define ROBIN_HOOD_LIKELY(condition) __builtin_expect(condition, 1)\n+#    define ROBIN_HOOD_UNLIKELY(condition) __builtin_expect(condition, 0)\n+#endif\n+\n+// workaround missing \"is_trivially_copyable\" in g++ < 5.0\n+// See https://stackoverflow.com/a/31798726/48181\n+#if defined(__GNUC__) && __GNUC__ < 5\n+#    define ROBIN_HOOD_IS_TRIVIALLY_COPYABLE(...) __has_trivial_copy(__VA_ARGS__)\n+#else\n+#    define ROBIN_HOOD_IS_TRIVIALLY_COPYABLE(...) std::is_trivially_copyable<__VA_ARGS__>::value\n+#endif\n+\n+// helpers for C++ versions, see https://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html\n+#define ROBIN_HOOD_PRIVATE_DEFINITION_CXX() __cplusplus\n+#define ROBIN_HOOD_PRIVATE_DEFINITION_CXX98() 199711L\n+#define ROBIN_HOOD_PRIVATE_DEFINITION_CXX11() 201103L\n+#define ROBIN_HOOD_PRIVATE_DEFINITION_CXX14() 201402L\n+#define ROBIN_HOOD_PRIVATE_DEFINITION_CXX17() 201703L\n+\n+#if ROBIN_HOOD(CXX) >= ROBIN_HOOD(CXX17)\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_NODISCARD() [[nodiscard]]\n+#else\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_NODISCARD()\n+#endif\n+\n+namespace robin_hood {\n+\n+#if ROBIN_HOOD(CXX) >= ROBIN_HOOD(CXX14)\n+#    define ROBIN_HOOD_STD std\n+#else\n+\n+// c++11 compatibility layer\n+namespace ROBIN_HOOD_STD {\n+template <class T>\n+struct alignment_of\n+    : std::integral_constant<std::size_t, alignof(typename std::remove_all_extents<T>::type)> {};\n+\n+template <class T, T... Ints>\n+class integer_sequence {\n+public:\n+    using value_type = T;\n+    static_assert(std::is_integral<value_type>::value, \"not integral type\");\n+    static constexpr std::size_t size() noexcept {\n+        return sizeof...(Ints);\n+    }\n+};\n+template <std::size_t... Inds>\n+using index_sequence = integer_sequence<std::size_t, Inds...>;\n+\n+namespace detail_ {\n+template <class T, T Begin, T End, bool>\n+struct IntSeqImpl {\n+    using TValue = T;\n+    static_assert(std::is_integral<TValue>::value, \"not integral type\");\n+    static_assert(Begin >= 0 && Begin < End, \"unexpected argument (Begin<0 || Begin<=End)\");\n+\n+    template <class, class>\n+    struct IntSeqCombiner;\n+\n+    template <TValue... Inds0, TValue... Inds1>\n+    struct IntSeqCombiner<integer_sequence<TValue, Inds0...>, integer_sequence<TValue, Inds1...>> {\n+        using TResult = integer_sequence<TValue, Inds0..., Inds1...>;\n+    };\n+\n+    using TResult =\n+        typename IntSeqCombiner<typename IntSeqImpl<TValue, Begin, Begin + (End - Begin) / 2,\n+                                                    (End - Begin) / 2 == 1>::TResult,\n+                                typename IntSeqImpl<TValue, Begin + (End - Begin) / 2, End,\n+                                                    (End - Begin + 1) / 2 == 1>::TResult>::TResult;\n+};\n+\n+template <class T, T Begin>\n+struct IntSeqImpl<T, Begin, Begin, false> {\n+    using TValue = T;\n+    static_assert(std::is_integral<TValue>::value, \"not integral type\");\n+    static_assert(Begin >= 0, \"unexpected argument (Begin<0)\");\n+    using TResult = integer_sequence<TValue>;\n+};\n+\n+template <class T, T Begin, T End>\n+struct IntSeqImpl<T, Begin, End, true> {\n+    using TValue = T;\n+    static_assert(std::is_integral<TValue>::value, \"not integral type\");\n+    static_assert(Begin >= 0, \"unexpected argument (Begin<0)\");\n+    using TResult = integer_sequence<TValue, Begin>;\n+};\n+} // namespace detail_\n+\n+template <class T, T N>\n+using make_integer_sequence = typename detail_::IntSeqImpl<T, 0, N, (N - 0) == 1>::TResult;\n+\n+template <std::size_t N>\n+using make_index_sequence = make_integer_sequence<std::size_t, N>;\n+\n+template <class... T>\n+using index_sequence_for = make_index_sequence<sizeof...(T)>;\n+\n+} // namespace ROBIN_HOOD_STD\n+\n+#endif\n+\n+namespace detail {\n+\n+// umul\n+#if defined(__SIZEOF_INT128__)\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_HAS_UMUL128() 1\n+#    if defined(__GNUC__) || defined(__clang__)\n+#        pragma GCC diagnostic push\n+#        pragma GCC diagnostic ignored \"-Wpedantic\"\n+using uint128_t = unsigned __int128;\n+#        pragma GCC diagnostic pop\n+#    endif\n+inline uint64_t umul128(uint64_t a, uint64_t b, uint64_t* high) noexcept {\n+    auto result = static_cast<uint128_t>(a) * static_cast<uint128_t>(b);\n+    *high = static_cast<uint64_t>(result >> 64U);\n+    return static_cast<uint64_t>(result);\n+}\n+#elif (defined(_WIN32) && ROBIN_HOOD(BITNESS) == 64)\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_HAS_UMUL128() 1\n+#    include <intrin.h> // for __umulh\n+#    pragma intrinsic(__umulh)\n+#    ifndef _M_ARM64\n+#        pragma intrinsic(_umul128)\n+#    endif\n+inline uint64_t umul128(uint64_t a, uint64_t b, uint64_t* high) noexcept {\n+#    ifdef _M_ARM64\n+    *high = __umulh(a, b);\n+    return ((uint64_t)(a)) * (b);\n+#    else\n+    return _umul128(a, b, high);\n+#    endif\n+}\n+#else\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_HAS_UMUL128() 0\n+#endif\n+\n+// This cast gets rid of warnings like \"cast from 'uint8_t*' {aka 'unsigned char*'} to\n+// 'uint64_t*' {aka 'long unsigned int*'} increases required alignment of target type\". Use with\n+// care!\n+template <typename T>\n+inline T reinterpret_cast_no_cast_align_warning(void* ptr) noexcept {\n+    return reinterpret_cast<T>(ptr);\n+}\n+\n+template <typename T>\n+inline T reinterpret_cast_no_cast_align_warning(void const* ptr) noexcept {\n+    return reinterpret_cast<T>(ptr);\n+}\n+\n+// make sure this is not inlined as it is slow and dramatically enlarges code, thus making other\n+// inlinings more difficult. Throws are also generally the slow path.\n+template <typename E, typename... Args>\n+ROBIN_HOOD(NOINLINE)\n+#if ROBIN_HOOD(HAS_EXCEPTIONS)\n+void doThrow(Args&&... args) {\n+    // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-array-to-pointer-decay)\n+    throw E(std::forward<Args>(args)...);\n+}\n+#else\n+void doThrow(Args&&... ROBIN_HOOD_UNUSED(args) /*unused*/) {\n+    abort();\n+}\n+#endif\n+\n+template <typename E, typename T, typename... Args>\n+T* assertNotNull(T* t, Args&&... args) {\n+    if (ROBIN_HOOD_UNLIKELY(nullptr == t)) {\n+        doThrow<E>(std::forward<Args>(args)...);\n+    }\n+    return t;\n+}\n+\n+template <typename T>\n+inline T unaligned_load(void const* ptr) noexcept {\n+    // using memcpy so we don't get into unaligned load problems.\n+    // compiler should optimize this very well anyways.\n+    T t;\n+    std::memcpy(&t, ptr, sizeof(T));\n+    return t;\n+}\n+\n+// Allocates bulks of memory for objects of type T. This deallocates the memory in the destructor,\n+// and keeps a linked list of the allocated memory around. Overhead per allocation is the size of a\n+// pointer.\n+template <typename T, size_t MinNumAllocs = 4, size_t MaxNumAllocs = 256>\n+class BulkPoolAllocator {\n+public:\n+    BulkPoolAllocator() noexcept = default;\n+\n+    // does not copy anything, just creates a new allocator.\n+    BulkPoolAllocator(const BulkPoolAllocator& ROBIN_HOOD_UNUSED(o) /*unused*/) noexcept\n+        : mHead(nullptr)\n+        , mListForFree(nullptr) {}\n+\n+    BulkPoolAllocator(BulkPoolAllocator&& o) noexcept\n+        : mHead(o.mHead)\n+        , mListForFree(o.mListForFree) {\n+        o.mListForFree = nullptr;\n+        o.mHead = nullptr;\n+    }\n+\n+    BulkPoolAllocator& operator=(BulkPoolAllocator&& o) noexcept {\n+        reset();\n+        mHead = o.mHead;\n+        mListForFree = o.mListForFree;\n+        o.mListForFree = nullptr;\n+        o.mHead = nullptr;\n+        return *this;\n+    }\n+\n+    BulkPoolAllocator&\n+    operator=(const BulkPoolAllocator& ROBIN_HOOD_UNUSED(o) /*unused*/) noexcept {\n+        // does not do anything\n+        return *this;\n+    }\n+\n+    ~BulkPoolAllocator() noexcept {\n+        reset();\n+    }\n+\n+    // Deallocates all allocated memory.\n+    void reset() noexcept {\n+        while (mListForFree) {\n+            T* tmp = *mListForFree;\n+            free(mListForFree);\n+            mListForFree = reinterpret_cast_no_cast_align_warning<T**>(tmp);\n+        }\n+        mHead = nullptr;\n+    }\n+\n+    // allocates, but does NOT initialize. Use in-place new constructor, e.g.\n+    //   T* obj = pool.allocate();\n+    //   ::new (static_cast<void*>(obj)) T();\n+    T* allocate() {\n+        T* tmp = mHead;\n+        if (!tmp) {\n+            tmp = performAllocation();\n+        }\n+\n+        mHead = *reinterpret_cast_no_cast_align_warning<T**>(tmp);\n+        return tmp;\n+    }\n+\n+    // does not actually deallocate but puts it in store.\n+    // make sure you have already called the destructor! e.g. with\n+    //  obj->~T();\n+    //  pool.deallocate(obj);\n+    void deallocate(T* obj) noexcept {\n+        *reinterpret_cast_no_cast_align_warning<T**>(obj) = mHead;\n+        mHead = obj;\n+    }\n+\n+    // Adds an already allocated block of memory to the allocator. This allocator is from now on\n+    // responsible for freeing the data (with free()). If the provided data is not large enough to\n+    // make use of, it is immediately freed. Otherwise it is reused and freed in the destructor.\n+    void addOrFree(void* ptr, const size_t numBytes) noexcept {\n+        // calculate number of available elements in ptr\n+        if (numBytes < ALIGNMENT + ALIGNED_SIZE) {\n+            // not enough data for at least one element. Free and return.\n+            free(ptr);\n+        } else {\n+            add(ptr, numBytes);\n+        }\n+    }\n+\n+    void swap(BulkPoolAllocator<T, MinNumAllocs, MaxNumAllocs>& other) noexcept {\n+        using std::swap;\n+        swap(mHead, other.mHead);\n+        swap(mListForFree, other.mListForFree);\n+    }\n+\n+private:\n+    // iterates the list of allocated memory to calculate how many to alloc next.\n+    // Recalculating this each time saves us a size_t member.\n+    // This ignores the fact that memory blocks might have been added manually with addOrFree. In\n+    // practice, this should not matter much.\n+    ROBIN_HOOD(NODISCARD) size_t calcNumElementsToAlloc() const noexcept {\n+        auto tmp = mListForFree;\n+        size_t numAllocs = MinNumAllocs;\n+\n+        while (numAllocs * 2 <= MaxNumAllocs && tmp) {\n+            auto x = reinterpret_cast<T***>(tmp);\n+            tmp = *x;\n+            numAllocs *= 2;\n+        }\n+\n+        return numAllocs;\n+    }\n+\n+    // WARNING: Underflow if numBytes < ALIGNMENT! This is guarded in addOrFree().\n+    void add(void* ptr, const size_t numBytes) noexcept {\n+        const size_t numElements = (numBytes - ALIGNMENT) / ALIGNED_SIZE;\n+\n+        auto data = reinterpret_cast<T**>(ptr);\n+\n+        // link free list\n+        auto x = reinterpret_cast<T***>(data);\n+        *x = mListForFree;\n+        mListForFree = data;\n+\n+        // create linked list for newly allocated data\n+        auto const headT =\n+            reinterpret_cast_no_cast_align_warning<T*>(reinterpret_cast<char*>(ptr) + ALIGNMENT);\n+\n+        auto const head = reinterpret_cast<char*>(headT);\n+\n+        // Visual Studio compiler automatically unrolls this loop, which is pretty cool\n+        for (size_t i = 0; i < numElements; ++i) {\n+            *reinterpret_cast_no_cast_align_warning<char**>(head + i * ALIGNED_SIZE) =\n+                head + (i + 1) * ALIGNED_SIZE;\n+        }\n+\n+        // last one points to 0\n+        *reinterpret_cast_no_cast_align_warning<T**>(head + (numElements - 1) * ALIGNED_SIZE) =\n+            mHead;\n+        mHead = headT;\n+    }\n+\n+    // Called when no memory is available (mHead == 0).\n+    // Don't inline this slow path.\n+    ROBIN_HOOD(NOINLINE) T* performAllocation() {\n+        size_t const numElementsToAlloc = calcNumElementsToAlloc();\n+\n+        // alloc new memory: [prev |T, T, ... T]\n+        // std::cout << (sizeof(T*) + ALIGNED_SIZE * numElementsToAlloc) << \" bytes\" << std::endl;\n+        size_t const bytes = ALIGNMENT + ALIGNED_SIZE * numElementsToAlloc;\n+        add(assertNotNull<std::bad_alloc>(malloc(bytes)), bytes);\n+        return mHead;\n+    }\n+\n+    // enforce byte alignment of the T's\n+#if ROBIN_HOOD(CXX) >= ROBIN_HOOD(CXX14)\n+    static constexpr size_t ALIGNMENT =\n+        (std::max)(std::alignment_of<T>::value, std::alignment_of<T*>::value);\n+#else\n+    static const size_t ALIGNMENT =\n+        (ROBIN_HOOD_STD::alignment_of<T>::value > ROBIN_HOOD_STD::alignment_of<T*>::value)\n+            ? ROBIN_HOOD_STD::alignment_of<T>::value\n+            : +ROBIN_HOOD_STD::alignment_of<T*>::value; // the + is for walkarround\n+#endif\n+\n+    static constexpr size_t ALIGNED_SIZE = ((sizeof(T) - 1) / ALIGNMENT + 1) * ALIGNMENT;\n+\n+    static_assert(MinNumAllocs >= 1, \"MinNumAllocs\");\n+    static_assert(MaxNumAllocs >= MinNumAllocs, \"MaxNumAllocs\");\n+    static_assert(ALIGNED_SIZE >= sizeof(T*), \"ALIGNED_SIZE\");\n+    static_assert(0 == (ALIGNED_SIZE % sizeof(T*)), \"ALIGNED_SIZE mod\");\n+    static_assert(ALIGNMENT >= sizeof(T*), \"ALIGNMENT\");\n+\n+    T* mHead{nullptr};\n+    T** mListForFree{nullptr};\n+};\n+\n+template <typename T, size_t MinSize, size_t MaxSize, bool IsFlatMap>\n+struct NodeAllocator;\n+\n+// dummy allocator that does nothing\n+template <typename T, size_t MinSize, size_t MaxSize>\n+struct NodeAllocator<T, MinSize, MaxSize, true> {\n+\n+    // we are not using the data, so just free it.\n+    void addOrFree(void* ptr, size_t ROBIN_HOOD_UNUSED(numBytes) /*unused*/) noexcept {\n+        free(ptr);\n+    }\n+};\n+\n+template <typename T, size_t MinSize, size_t MaxSize>\n+struct NodeAllocator<T, MinSize, MaxSize, false> : public BulkPoolAllocator<T, MinSize, MaxSize> {};\n+\n+// dummy hash, unsed as mixer when robin_hood::hash is already used\n+template <typename T>\n+struct identity_hash {\n+    constexpr size_t operator()(T const& obj) const noexcept {\n+        return static_cast<size_t>(obj);\n+    }\n+};\n+\n+// c++14 doesn't have is_nothrow_swappable, and clang++ 6.0.1 doesn't like it either, so I'm making\n+// my own here.\n+namespace swappable {\n+using std::swap;\n+template <typename T>\n+struct nothrow {\n+    static const bool value = noexcept(swap(std::declval<T&>(), std::declval<T&>()));\n+};\n+\n+} // namespace swappable\n+\n+} // namespace detail\n+\n+struct is_transparent_tag {};\n+\n+// A custom pair implementation is used in the map because std::pair is not is_trivially_copyable,\n+// which means it would  not be allowed to be used in std::memcpy. This struct is copyable, which is\n+// also tested.\n+template <typename T1, typename T2>\n+struct pair {\n+    using first_type = T1;\n+    using second_type = T2;\n+\n+    template <typename U1 = T1, typename U2 = T2,\n+              typename = typename std::enable_if<std::is_default_constructible<U1>::value &&\n+                                                 std::is_default_constructible<U2>::value>::type>\n+    constexpr pair() noexcept(noexcept(U1()) && noexcept(U2()))\n+        : first()\n+        , second() {}\n+\n+    // pair constructors are explicit so we don't accidentally call this ctor when we don't have to.\n+    explicit constexpr pair(std::pair<T1, T2> const& o) noexcept(\n+        noexcept(T1(std::declval<T1 const&>())) && noexcept(T2(std::declval<T2 const&>())))\n+        : first(o.first)\n+        , second(o.second) {}\n+\n+    // pair constructors are explicit so we don't accidentally call this ctor when we don't have to.\n+    explicit constexpr pair(std::pair<T1, T2>&& o) noexcept(\n+        noexcept(T1(std::move(std::declval<T1&&>()))) &&\n+        noexcept(T2(std::move(std::declval<T2&&>()))))\n+        : first(std::move(o.first))\n+        , second(std::move(o.second)) {}\n+\n+    constexpr pair(T1&& a, T2&& b) noexcept(noexcept(T1(std::move(std::declval<T1&&>()))) &&\n+                                            noexcept(T2(std::move(std::declval<T2&&>()))))\n+        : first(std::move(a))\n+        , second(std::move(b)) {}\n+\n+    template <typename U1, typename U2>\n+    constexpr pair(U1&& a, U2&& b) noexcept(noexcept(T1(std::forward<U1>(std::declval<U1&&>()))) &&\n+                                            noexcept(T2(std::forward<U2>(std::declval<U2&&>()))))\n+        : first(std::forward<U1>(a))\n+        , second(std::forward<U2>(b)) {}\n+\n+    template <typename... U1, typename... U2>\n+    constexpr pair(\n+        std::piecewise_construct_t /*unused*/, std::tuple<U1...> a,\n+        std::tuple<U2...> b) noexcept(noexcept(pair(std::declval<std::tuple<U1...>&>(),\n+                                                    std::declval<std::tuple<U2...>&>(),\n+                                                    ROBIN_HOOD_STD::index_sequence_for<U1...>(),\n+                                                    ROBIN_HOOD_STD::index_sequence_for<U2...>())))\n+        : pair(a, b, ROBIN_HOOD_STD::index_sequence_for<U1...>(),\n+               ROBIN_HOOD_STD::index_sequence_for<U2...>()) {}\n+\n+    // constructor called from the std::piecewise_construct_t ctor\n+    template <typename... U1, size_t... I1, typename... U2, size_t... I2>\n+    pair(std::tuple<U1...>& a, std::tuple<U2...>& b,\n+         ROBIN_HOOD_STD::index_sequence<I1...> /*unused*/,\n+         ROBIN_HOOD_STD::index_sequence<\n+             I2...> /*unused*/) noexcept(noexcept(T1(std::\n+                                                         forward<U1>(std::get<I1>(\n+                                                             std::declval<\n+                                                                 std::tuple<U1...>&>()))...)) &&\n+                                         noexcept(T2(std::forward<U2>(\n+                                             std::get<I2>(std::declval<std::tuple<U2...>&>()))...)))\n+        : first(std::forward<U1>(std::get<I1>(a))...)\n+        , second(std::forward<U2>(std::get<I2>(b))...) {\n+        // make visual studio compiler happy about warning about unused a & b.\n+        // Visual studio's pair implementation disables warning 4100.\n+        (void)a;\n+        (void)b;\n+    }\n+\n+    ROBIN_HOOD(NODISCARD) first_type& getFirst() noexcept {\n+        return first;\n+    }\n+    ROBIN_HOOD(NODISCARD) first_type const& getFirst() const noexcept {\n+        return first;\n+    }\n+    ROBIN_HOOD(NODISCARD) second_type& getSecond() noexcept {\n+        return second;\n+    }\n+    ROBIN_HOOD(NODISCARD) second_type const& getSecond() const noexcept {\n+        return second;\n+    }\n+\n+    void swap(pair<T1, T2>& o) noexcept((detail::swappable::nothrow<T1>::value) &&\n+                                        (detail::swappable::nothrow<T2>::value)) {\n+        using std::swap;\n+        swap(first, o.first);\n+        swap(second, o.second);\n+    }\n+\n+    T1 first;  // NOLINT(misc-non-private-member-variables-in-classes)\n+    T2 second; // NOLINT(misc-non-private-member-variables-in-classes)\n+};\n+\n+template <typename A, typename B>\n+void swap(pair<A, B>& a, pair<A, B>& b) noexcept(\n+    noexcept(std::declval<pair<A, B>&>().swap(std::declval<pair<A, B>&>()))) {\n+    a.swap(b);\n+}\n+\n+// Hash an arbitrary amount of bytes. This is basically Murmur2 hash without caring about big\n+// endianness. TODO(martinus) add a fallback for very large strings?\n+static size_t hash_bytes(void const* ptr, size_t const len) noexcept {\n+    static constexpr uint64_t m = UINT64_C(0xc6a4a7935bd1e995);\n+    static constexpr uint64_t seed = UINT64_C(0xe17a1465);\n+    static constexpr unsigned int r = 47;\n+\n+    auto const data64 = static_cast<uint64_t const*>(ptr);\n+    uint64_t h = seed ^ (len * m);\n+\n+    size_t const n_blocks = len / 8;\n+    for (size_t i = 0; i < n_blocks; ++i) {\n+        auto k = detail::unaligned_load<uint64_t>(data64 + i);\n+\n+        k *= m;\n+        k ^= k >> r;\n+        k *= m;\n+\n+        h ^= k;\n+        h *= m;\n+    }\n+\n+    auto const data8 = reinterpret_cast<uint8_t const*>(data64 + n_blocks);\n+    switch (len & 7U) {\n+    case 7:\n+        h ^= static_cast<uint64_t>(data8[6]) << 48U;\n+        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n+    case 6:\n+        h ^= static_cast<uint64_t>(data8[5]) << 40U;\n+        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n+    case 5:\n+        h ^= static_cast<uint64_t>(data8[4]) << 32U;\n+        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n+    case 4:\n+        h ^= static_cast<uint64_t>(data8[3]) << 24U;\n+        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n+    case 3:\n+        h ^= static_cast<uint64_t>(data8[2]) << 16U;\n+        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n+    case 2:\n+        h ^= static_cast<uint64_t>(data8[1]) << 8U;\n+        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n+    case 1:\n+        h ^= static_cast<uint64_t>(data8[0]);\n+        h *= m;\n+        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n+    default:\n+        break;\n+    }\n+\n+    h ^= h >> r;\n+    h *= m;\n+    h ^= h >> r;\n+    return static_cast<size_t>(h);\n+}\n+\n+inline size_t hash_int(uint64_t obj) noexcept {\n+#if ROBIN_HOOD(HAS_UMUL128)\n+    // 167079903232 masksum, 120428523 ops best: 0xde5fb9d2630458e9\n+    static constexpr uint64_t k = UINT64_C(0xde5fb9d2630458e9);\n+    uint64_t h;\n+    uint64_t l = detail::umul128(obj, k, &h);\n+    return h + l;\n+#elif ROBIN_HOOD(BITNESS) == 32\n+    uint64_t const r = obj * UINT64_C(0xca4bcaa75ec3f625);\n+    auto h = static_cast<uint32_t>(r >> 32U);\n+    auto l = static_cast<uint32_t>(r);\n+    return h + l;\n+#else\n+    // murmurhash 3 finalizer\n+    uint64_t h = obj;\n+    h ^= h >> 33;\n+    h *= 0xff51afd7ed558ccd;\n+    h ^= h >> 33;\n+    h *= 0xc4ceb9fe1a85ec53;\n+    h ^= h >> 33;\n+    return static_cast<size_t>(h);\n+#endif\n+}\n+\n+// A thin wrapper around std::hash, performing an additional simple mixing step of the result.\n+template <typename T>\n+struct hash : public std::hash<T> {\n+    size_t operator()(T const& obj) const\n+        noexcept(noexcept(std::declval<std::hash<T>>().operator()(std::declval<T const&>()))) {\n+        // call base hash\n+        auto result = std::hash<T>::operator()(obj);\n+        // return mixed of that, to be save against identity has\n+        return hash_int(static_cast<uint64_t>(result));\n+    }\n+};\n+\n+template <>\n+struct hash<std::string> {\n+    size_t operator()(std::string const& str) const noexcept {\n+        return hash_bytes(str.data(), str.size());\n+    }\n+};\n+\n+template <class T>\n+struct hash<T*> {\n+    size_t operator()(T* ptr) const noexcept {\n+        return hash_int(reinterpret_cast<size_t>(ptr));\n+    }\n+};\n+\n+#define ROBIN_HOOD_HASH_INT(T)                           \\\n+    template <>                                          \\\n+    struct hash<T> {                                     \\\n+        size_t operator()(T obj) const noexcept {        \\\n+            return hash_int(static_cast<uint64_t>(obj)); \\\n+        }                                                \\\n+    }\n+\n+#if defined(__GNUC__) && !defined(__clang__)\n+#    pragma GCC diagnostic push\n+#    pragma GCC diagnostic ignored \"-Wuseless-cast\"\n+#endif\n+// see https://en.cppreference.com/w/cpp/utility/hash\n+ROBIN_HOOD_HASH_INT(bool);\n+ROBIN_HOOD_HASH_INT(char);\n+ROBIN_HOOD_HASH_INT(signed char);\n+ROBIN_HOOD_HASH_INT(unsigned char);\n+ROBIN_HOOD_HASH_INT(char16_t);\n+ROBIN_HOOD_HASH_INT(char32_t);\n+ROBIN_HOOD_HASH_INT(wchar_t);\n+ROBIN_HOOD_HASH_INT(short);\n+ROBIN_HOOD_HASH_INT(unsigned short);\n+ROBIN_HOOD_HASH_INT(int);\n+ROBIN_HOOD_HASH_INT(unsigned int);\n+ROBIN_HOOD_HASH_INT(long);\n+ROBIN_HOOD_HASH_INT(long long);\n+ROBIN_HOOD_HASH_INT(unsigned long);\n+ROBIN_HOOD_HASH_INT(unsigned long long);\n+#if defined(__GNUC__) && !defined(__clang__)\n+#    pragma GCC diagnostic pop\n+#endif\n+namespace detail {\n+\n+// A highly optimized hashmap implementation, using the Robin Hood algorithm.\n+//\n+// In most cases, this map should be usable as a drop-in replacement for std::unordered_map, but be\n+// about 2x faster in most cases and require much less allocations.\n+//\n+// This implementation uses the following memory layout:\n+//\n+// [Node, Node, ... Node | info, info, ... infoSentinel ]\n+//\n+// * Node: either a DataNode that directly has the std::pair<key, val> as member,\n+//   or a DataNode with a pointer to std::pair<key,val>. Which DataNode representation to use\n+//   depends on how fast the swap() operation is. Heuristically, this is automatically choosen based\n+//   on sizeof(). there are always 2^n Nodes.\n+//\n+// * info: Each Node in the map has a corresponding info byte, so there are 2^n info bytes.\n+//   Each byte is initialized to 0, meaning the corresponding Node is empty. Set to 1 means the\n+//   corresponding node contains data. Set to 2 means the corresponding Node is filled, but it\n+//   actually belongs to the previous position and was pushed out because that place is already\n+//   taken.\n+//\n+// * infoSentinel: Sentinel byte set to 1, so that iterator's ++ can stop at end() without the need\n+// for a idx\n+//   variable.\n+//\n+// According to STL, order of templates has effect on throughput. That's why I've moved the boolean\n+// to the front.\n+// https://www.reddit.com/r/cpp/comments/ahp6iu/compile_time_binary_size_reductions_and_cs_future/eeguck4/\n+template <bool IsFlatMap, size_t MaxLoadFactor100, typename Key, typename T, typename Hash,\n+          typename KeyEqual>\n+class unordered_map\n+    : public Hash,\n+      public KeyEqual,\n+      detail::NodeAllocator<\n+          robin_hood::pair<typename std::conditional<IsFlatMap, Key, Key const>::type, T>, 4, 16384,\n+          IsFlatMap> {\n+public:\n+    using key_type = Key;\n+    using mapped_type = T;\n+    using value_type =\n+        robin_hood::pair<typename std::conditional<IsFlatMap, Key, Key const>::type, T>;\n+    using size_type = size_t;\n+    using hasher = Hash;\n+    using key_equal = KeyEqual;\n+    using Self =\n+        unordered_map<IsFlatMap, MaxLoadFactor100, key_type, mapped_type, hasher, key_equal>;\n+    static constexpr bool is_flat_map = IsFlatMap;\n+\n+private:\n+    static_assert(MaxLoadFactor100 > 10 && MaxLoadFactor100 < 100,\n+                  \"MaxLoadFactor100 needs to be >10 && < 100\");\n+\n+    // configuration defaults\n+\n+    // make sure we have 8 elements, needed to quickly rehash mInfo\n+    static constexpr size_t InitialNumElements = sizeof(uint64_t);\n+    static constexpr uint32_t InitialInfoNumBits = 5;\n+    static constexpr uint8_t InitialInfoInc = 1U << InitialInfoNumBits;\n+    static constexpr uint8_t InitialInfoHashShift = sizeof(size_t) * 8 - InitialInfoNumBits;\n+    using DataPool = detail::NodeAllocator<value_type, 4, 16384, IsFlatMap>;\n+\n+    // type needs to be wider than uint8_t.\n+    using InfoType = uint32_t;\n+\n+    // DataNode ////////////////////////////////////////////////////////\n+\n+    // Primary template for the data node. We have special implementations for small and big\n+    // objects. For large objects it is assumed that swap() is fairly slow, so we allocate these on\n+    // the heap so swap merely swaps a pointer.\n+    template <typename M, bool>\n+    class DataNode {};\n+\n+    // Small: just allocate on the stack.\n+    template <typename M>\n+    class DataNode<M, true> final {\n+    public:\n+        template <typename... Args>\n+        explicit DataNode(M& ROBIN_HOOD_UNUSED(map) /*unused*/, Args&&... args) noexcept(\n+            noexcept(value_type(std::forward<Args>(args)...)))\n+            : mData(std::forward<Args>(args)...) {}\n+\n+        DataNode(M& ROBIN_HOOD_UNUSED(map) /*unused*/, DataNode<M, true>&& n) noexcept(\n+            std::is_nothrow_move_constructible<value_type>::value)\n+            : mData(std::move(n.mData)) {}\n+\n+        // doesn't do anything\n+        void destroy(M& ROBIN_HOOD_UNUSED(map) /*unused*/) noexcept {}\n+        void destroyDoNotDeallocate() noexcept {}\n+\n+        value_type const* operator->() const noexcept {\n+            return &mData;\n+        }\n+        value_type* operator->() noexcept {\n+            return &mData;\n+        }\n+\n+        const value_type& operator*() const noexcept {\n+            return mData;\n+        }\n+\n+        value_type& operator*() noexcept {\n+            return mData;\n+        }\n+\n+        ROBIN_HOOD(NODISCARD) typename value_type::first_type& getFirst() noexcept {\n+            return mData.first;\n+        }\n+\n+        ROBIN_HOOD(NODISCARD) typename value_type::first_type const& getFirst() const noexcept {\n+            return mData.first;\n+        }\n+\n+        ROBIN_HOOD(NODISCARD) typename value_type::second_type& getSecond() noexcept {\n+            return mData.second;\n+        }\n+\n+        ROBIN_HOOD(NODISCARD) typename value_type::second_type const& getSecond() const noexcept {\n+            return mData.second;\n+        }\n+\n+        void swap(DataNode<M, true>& o) noexcept(\n+            noexcept(std::declval<value_type>().swap(std::declval<value_type>()))) {\n+            mData.swap(o.mData);\n+        }\n+\n+    private:\n+        value_type mData;\n+    };\n+\n+    // big object: allocate on heap.\n+    template <typename M>\n+    class DataNode<M, false> {\n+    public:\n+        template <typename... Args>\n+        explicit DataNode(M& map, Args&&... args)\n+            : mData(map.allocate()) {\n+            ::new (static_cast<void*>(mData)) value_type(std::forward<Args>(args)...);\n+        }\n+\n+        DataNode(M& ROBIN_HOOD_UNUSED(map) /*unused*/, DataNode<M, false>&& n) noexcept\n+            : mData(std::move(n.mData)) {}\n+\n+        void destroy(M& map) noexcept {\n+            // don't deallocate, just put it into list of datapool.\n+            mData->~value_type();\n+            map.deallocate(mData);\n+        }\n+\n+        void destroyDoNotDeallocate() noexcept {\n+            mData->~value_type();\n+        }\n+\n+        value_type const* operator->() const noexcept {\n+            return mData;\n+        }\n+\n+        value_type* operator->() noexcept {\n+            return mData;\n+        }\n+\n+        const value_type& operator*() const {\n+            return *mData;\n+        }\n+\n+        value_type& operator*() {\n+            return *mData;\n+        }\n+\n+        ROBIN_HOOD(NODISCARD) typename value_type::first_type& getFirst() {\n+            return mData->first;\n+        }\n+\n+        ROBIN_HOOD(NODISCARD) typename value_type::first_type const& getFirst() const {\n+            return mData->first;\n+        }\n+\n+        ROBIN_HOOD(NODISCARD) typename value_type::second_type& getSecond() {\n+            return mData->second;\n+        }\n+\n+        ROBIN_HOOD(NODISCARD) typename value_type::second_type const& getSecond() const {\n+            return mData->second;\n+        }\n+\n+        void swap(DataNode<M, false>& o) noexcept {\n+            using std::swap;\n+            swap(mData, o.mData);\n+        }\n+\n+    private:\n+        value_type* mData;\n+    };\n+\n+    using Node = DataNode<Self, IsFlatMap>;\n+\n+    // Cloner //////////////////////////////////////////////////////////\n+\n+    template <typename M, bool UseMemcpy>\n+    struct Cloner;\n+\n+    // fast path: Just copy data, without allocating anything.\n+    template <typename M>\n+    struct Cloner<M, true> {\n+        void operator()(M const& source, M& target) const {\n+            // std::memcpy(target.mKeyVals, source.mKeyVals,\n+            //             target.calcNumBytesTotal(target.mMask + 1));\n+            auto src = reinterpret_cast<char const*>(source.mKeyVals);\n+            auto tgt = reinterpret_cast<char*>(target.mKeyVals);\n+            std::copy(src, src + target.calcNumBytesTotal(target.mMask + 1), tgt);\n+        }\n+    };\n+\n+    template <typename M>\n+    struct Cloner<M, false> {\n+        void operator()(M const& s, M& t) const {\n+            std::copy(s.mInfo, s.mInfo + t.calcNumBytesInfo(t.mMask + 1), t.mInfo);\n+\n+            for (size_t i = 0; i < t.mMask + 1; ++i) {\n+                if (t.mInfo[i]) {\n+                    ::new (static_cast<void*>(t.mKeyVals + i)) Node(t, *s.mKeyVals[i]);\n+                }\n+            }\n+        }\n+    };\n+\n+    // Destroyer ///////////////////////////////////////////////////////\n+\n+    template <typename M, bool IsFlatMapAndTrivial>\n+    struct Destroyer {};\n+\n+    template <typename M>\n+    struct Destroyer<M, true> {\n+        void nodes(M& m) const noexcept {\n+            m.mNumElements = 0;\n+        }\n+\n+        void nodesDoNotDeallocate(M& m) const noexcept {\n+            m.mNumElements = 0;\n+        }\n+    };\n+\n+    template <typename M>\n+    struct Destroyer<M, false> {\n+        void nodes(M& m) const noexcept {\n+            m.mNumElements = 0;\n+            // clear also resets mInfo to 0, that's sometimes not necessary.\n+            for (size_t idx = 0; idx <= m.mMask; ++idx) {\n+                if (0 != m.mInfo[idx]) {\n+                    Node& n = m.mKeyVals[idx];\n+                    n.destroy(m);\n+                    n.~Node();\n+                }\n+            }\n+        }\n+\n+        void nodesDoNotDeallocate(M& m) const noexcept {\n+            m.mNumElements = 0;\n+            // clear also resets mInfo to 0, that's sometimes not necessary.\n+            for (size_t idx = 0; idx <= m.mMask; ++idx) {\n+                if (0 != m.mInfo[idx]) {\n+                    Node& n = m.mKeyVals[idx];\n+                    n.destroyDoNotDeallocate();\n+                    n.~Node();\n+                }\n+            }\n+        }\n+    };\n+\n+    // Iter ////////////////////////////////////////////////////////////\n+\n+    struct fast_forward_tag {};\n+\n+    // generic iterator for both const_iterator and iterator.\n+    template <bool IsConst>\n+    // NOLINTNEXTLINE(hicpp-special-member-functions,cppcoreguidelines-special-member-functions)\n+    class Iter {\n+    private:\n+        using NodePtr = typename std::conditional<IsConst, Node const*, Node*>::type;\n+\n+    public:\n+        using difference_type = std::ptrdiff_t;\n+        using value_type = typename Self::value_type;\n+        using reference = typename std::conditional<IsConst, value_type const&, value_type&>::type;\n+        using pointer = typename std::conditional<IsConst, value_type const*, value_type*>::type;\n+        using iterator_category = std::forward_iterator_tag;\n+\n+        // default constructed iterator can be compared to itself, but WON'T return true when\n+        // compared to end().\n+        Iter() = default;\n+\n+        // Rule of zero: nothing specified. The conversion constructor is only enabled for iterator\n+        // to const_iterator, so it doesn't accidentally work as a copy ctor.\n+\n+        // Conversion constructor from iterator to const_iterator.\n+        template <bool OtherIsConst,\n+                  typename = typename std::enable_if<IsConst && !OtherIsConst>::type>\n+        // NOLINTNEXTLINE(hicpp-explicit-conversions)\n+        Iter(Iter<OtherIsConst> const& other) noexcept\n+            : mKeyVals(other.mKeyVals)\n+            , mInfo(other.mInfo) {}\n+\n+        Iter(NodePtr valPtr, uint8_t const* infoPtr) noexcept\n+            : mKeyVals(valPtr)\n+            , mInfo(infoPtr) {}\n+\n+        Iter(NodePtr valPtr, uint8_t const* infoPtr,\n+             fast_forward_tag ROBIN_HOOD_UNUSED(tag) /*unused*/) noexcept\n+            : mKeyVals(valPtr)\n+            , mInfo(infoPtr) {\n+            fastForward();\n+        }\n+\n+        template <bool OtherIsConst,\n+                  typename = typename std::enable_if<IsConst && !OtherIsConst>::type>\n+        Iter& operator=(Iter<OtherIsConst> const& other) noexcept {\n+            mKeyVals = other.mKeyVals;\n+            mInfo = other.mInfo;\n+            return *this;\n+        }\n+\n+        // prefix increment. Undefined behavior if we are at end()!\n+        Iter& operator++() noexcept {\n+            mInfo++;\n+            mKeyVals++;\n+            fastForward();\n+            return *this;\n+        }\n+\n+        reference operator*() const {\n+            return **mKeyVals;\n+        }\n+\n+        pointer operator->() const {\n+            return &**mKeyVals;\n+        }\n+\n+        template <bool O>\n+        bool operator==(Iter<O> const& o) const noexcept {\n+            return mKeyVals == o.mKeyVals;\n+        }\n+\n+        template <bool O>\n+        bool operator!=(Iter<O> const& o) const noexcept {\n+            return mKeyVals != o.mKeyVals;\n+        }\n+\n+    private:\n+        // fast forward to the next non-free info byte\n+        void fastForward() noexcept {\n+            int inc;\n+            do {\n+                auto const n = detail::unaligned_load<size_t>(mInfo);\n+#if ROBIN_HOOD(LITTLE_ENDIAN)\n+                inc = ROBIN_HOOD_COUNT_TRAILING_ZEROES(n) / 8;\n+#else\n+                inc = ROBIN_HOOD_COUNT_LEADING_ZEROES(n) / 8;\n+#endif\n+                mInfo += inc;\n+                mKeyVals += inc;\n+            } while (inc == static_cast<int>(sizeof(size_t)));\n+        }\n+\n+        friend class unordered_map<IsFlatMap, MaxLoadFactor100, key_type, mapped_type, hasher,\n+                                   key_equal>;\n+        NodePtr mKeyVals{nullptr};\n+        uint8_t const* mInfo{nullptr};\n+    };\n+\n+    ////////////////////////////////////////////////////////////////////\n+\n+    // highly performance relevant code.\n+    // Lower bits are used for indexing into the array (2^n size)\n+    // The upper 1-5 bits need to be a reasonable good hash, to save comparisons.\n+    template <typename HashKey>\n+    void keyToIdx(HashKey&& key, size_t* idx, InfoType* info) const {\n+        // for a user-specified hash that is *not* robin_hood::hash, apply robin_hood::hash as an\n+        // additional mixing step. This serves as a bad hash prevention, if the given data is badly\n+        // mixed.\n+        using Mix =\n+            typename std::conditional<std::is_same<::robin_hood::hash<key_type>, hasher>::value,\n+                                      ::robin_hood::detail::identity_hash<size_t>,\n+                                      ::robin_hood::hash<size_t>>::type;\n+        *idx = Mix{}(Hash::operator()(key));\n+\n+        *info = mInfoInc + static_cast<InfoType>(*idx >> mInfoHashShift);\n+        *idx &= mMask;\n+    }\n+\n+    // forwards the index by one, wrapping around at the end\n+    void next(InfoType* info, size_t* idx) const noexcept {\n+        *idx = (*idx + 1) & mMask;\n+        *info += mInfoInc;\n+    }\n+\n+    void nextWhileLess(InfoType* info, size_t* idx) const noexcept {\n+        // unrolling this by hand did not bring any speedups.\n+        while (*info < mInfo[*idx]) {\n+            next(info, idx);\n+        }\n+    }\n+\n+    // Shift everything up by one element. Tries to move stuff around.\n+    // True if some shifting has occured (entry under idx is a constructed object)\n+    // Fals if no shift has occured (entry under idx is unconstructed memory)\n+    void\n+    shiftUp(size_t idx,\n+            size_t const insertion_idx) noexcept(std::is_nothrow_move_assignable<Node>::value) {\n+        while (idx != insertion_idx) {\n+            size_t prev_idx = (idx - 1) & mMask;\n+            if (mInfo[idx]) {\n+                mKeyVals[idx] = std::move(mKeyVals[prev_idx]);\n+            } else {\n+                ::new (static_cast<void*>(mKeyVals + idx)) Node(std::move(mKeyVals[prev_idx]));\n+            }\n+            mInfo[idx] = static_cast<uint8_t>(mInfo[prev_idx] + mInfoInc);\n+            if (ROBIN_HOOD_UNLIKELY(mInfo[idx] + mInfoInc > 0xFF)) {\n+                mMaxNumElementsAllowed = 0;\n+            }\n+            idx = prev_idx;\n+        }\n+    }\n+\n+    void shiftDown(size_t idx) noexcept(std::is_nothrow_move_assignable<Node>::value) {\n+        // until we find one that is either empty or has zero offset.\n+        // TODO(martinus) we don't need to move everything, just the last one for the same bucket.\n+        mKeyVals[idx].destroy(*this);\n+\n+        // until we find one that is either empty or has zero offset.\n+        size_t nextIdx = (idx + 1) & mMask;\n+        while (mInfo[nextIdx] >= 2 * mInfoInc) {\n+            mInfo[idx] = static_cast<uint8_t>(mInfo[nextIdx] - mInfoInc);\n+            mKeyVals[idx] = std::move(mKeyVals[nextIdx]);\n+            idx = nextIdx;\n+            nextIdx = (idx + 1) & mMask;\n+        }\n+\n+        mInfo[idx] = 0;\n+        // don't destroy, we've moved it\n+        // mKeyVals[idx].destroy(*this);\n+        mKeyVals[idx].~Node();\n+    }\n+\n+    // copy of find(), except that it returns iterator instead of const_iterator.\n+    template <typename Other>\n+    ROBIN_HOOD(NODISCARD)\n+    size_t findIdx(Other const& key) const {\n+        size_t idx;\n+        InfoType info;\n+        keyToIdx(key, &idx, &info);\n+\n+        do {\n+            // unrolling this twice gives a bit of a speedup. More unrolling did not help.\n+            if (info == mInfo[idx] && KeyEqual::operator()(key, mKeyVals[idx].getFirst())) {\n+                return idx;\n+            }\n+            next(&info, &idx);\n+            if (info == mInfo[idx] && KeyEqual::operator()(key, mKeyVals[idx].getFirst())) {\n+                return idx;\n+            }\n+            next(&info, &idx);\n+        } while (info <= mInfo[idx]);\n+\n+        // nothing found!\n+        return mMask == 0 ? 0 : mMask + 1;\n+    }\n+\n+    void cloneData(const unordered_map& o) {\n+        Cloner<unordered_map, IsFlatMap && ROBIN_HOOD_IS_TRIVIALLY_COPYABLE(Node)>()(o, *this);\n+    }\n+\n+    // inserts a keyval that is guaranteed to be new, e.g. when the hashmap is resized.\n+    // @return index where the element was created\n+    size_t insert_move(Node&& keyval) {\n+        // we don't retry, fail if overflowing\n+        // don't need to check max num elements\n+        if (0 == mMaxNumElementsAllowed && !try_increase_info()) {\n+            throwOverflowError();\n+        }\n+\n+        size_t idx;\n+        InfoType info;\n+        keyToIdx(keyval.getFirst(), &idx, &info);\n+\n+        // skip forward. Use <= because we are certain that the element is not there.\n+        while (info <= mInfo[idx]) {\n+            idx = (idx + 1) & mMask;\n+            info += mInfoInc;\n+        }\n+\n+        // key not found, so we are now exactly where we want to insert it.\n+        auto const insertion_idx = idx;\n+        auto const insertion_info = static_cast<uint8_t>(info);\n+        if (ROBIN_HOOD_UNLIKELY(insertion_info + mInfoInc > 0xFF)) {\n+            mMaxNumElementsAllowed = 0;\n+        }\n+\n+        // find an empty spot\n+        while (0 != mInfo[idx]) {\n+            next(&info, &idx);\n+        }\n+\n+        auto& l = mKeyVals[insertion_idx];\n+        if (idx == insertion_idx) {\n+            ::new (static_cast<void*>(&l)) Node(std::move(keyval));\n+        } else {\n+            shiftUp(idx, insertion_idx);\n+            l = std::move(keyval);\n+        }\n+\n+        // put at empty spot\n+        mInfo[insertion_idx] = insertion_info;\n+\n+        ++mNumElements;\n+        return insertion_idx;\n+    }\n+\n+public:\n+    using iterator = Iter<false>;\n+    using const_iterator = Iter<true>;\n+\n+    // Creates an empty hash map. Nothing is allocated yet, this happens at the first insert. This\n+    // tremendously speeds up ctor & dtor of a map that never receives an element. The penalty is\n+    // payed at the first insert, and not before. Lookup of this empty map works because everybody\n+    // points to DummyInfoByte::b. parameter bucket_count is dictated by the standard, but we can\n+    // ignore it.\n+    explicit unordered_map(size_t ROBIN_HOOD_UNUSED(bucket_count) /*unused*/ = 0,\n+                           const Hash& h = Hash{},\n+                           const KeyEqual& equal = KeyEqual{}) noexcept(noexcept(Hash(h)) &&\n+                                                                        noexcept(KeyEqual(equal)))\n+        : Hash(h)\n+        , KeyEqual(equal) {\n+        ROBIN_HOOD_TRACE(this);\n+    }\n+\n+    template <typename Iter>\n+    unordered_map(Iter first, Iter last, size_t ROBIN_HOOD_UNUSED(bucket_count) /*unused*/ = 0,\n+                  const Hash& h = Hash{}, const KeyEqual& equal = KeyEqual{})\n+        : Hash(h)\n+        , KeyEqual(equal) {\n+        ROBIN_HOOD_TRACE(this);\n+        insert(first, last);\n+    }\n+\n+    unordered_map(std::initializer_list<value_type> initlist,\n+                  size_t ROBIN_HOOD_UNUSED(bucket_count) /*unused*/ = 0, const Hash& h = Hash{},\n+                  const KeyEqual& equal = KeyEqual{})\n+        : Hash(h)\n+        , KeyEqual(equal) {\n+        ROBIN_HOOD_TRACE(this);\n+        insert(initlist.begin(), initlist.end());\n+    }\n+\n+    unordered_map(unordered_map&& o) noexcept\n+        : Hash(std::move(static_cast<Hash&>(o)))\n+        , KeyEqual(std::move(static_cast<KeyEqual&>(o)))\n+        , DataPool(std::move(static_cast<DataPool&>(o))) {\n+        ROBIN_HOOD_TRACE(this);\n+        if (o.mMask) {\n+            mKeyVals = std::move(o.mKeyVals);\n+            mInfo = std::move(o.mInfo);\n+            mNumElements = std::move(o.mNumElements);\n+            mMask = std::move(o.mMask);\n+            mMaxNumElementsAllowed = std::move(o.mMaxNumElementsAllowed);\n+            mInfoInc = std::move(o.mInfoInc);\n+            mInfoHashShift = std::move(o.mInfoHashShift);\n+            // set other's mask to 0 so its destructor won't do anything\n+            o.init();\n+        }\n+    }\n+\n+    unordered_map& operator=(unordered_map&& o) noexcept {\n+        ROBIN_HOOD_TRACE(this);\n+        if (&o != this) {\n+            if (o.mMask) {\n+                // only move stuff if the other map actually has some data\n+                destroy();\n+                mKeyVals = std::move(o.mKeyVals);\n+                mInfo = std::move(o.mInfo);\n+                mNumElements = std::move(o.mNumElements);\n+                mMask = std::move(o.mMask);\n+                mMaxNumElementsAllowed = std::move(o.mMaxNumElementsAllowed);\n+                mInfoInc = std::move(o.mInfoInc);\n+                mInfoHashShift = std::move(o.mInfoHashShift);\n+                Hash::operator=(std::move(static_cast<Hash&>(o)));\n+                KeyEqual::operator=(std::move(static_cast<KeyEqual&>(o)));\n+                DataPool::operator=(std::move(static_cast<DataPool&>(o)));\n+\n+                o.init();\n+\n+            } else {\n+                // nothing in the other map => just clear us.\n+                clear();\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    unordered_map(const unordered_map& o)\n+        : Hash(static_cast<const Hash&>(o))\n+        , KeyEqual(static_cast<const KeyEqual&>(o))\n+        , DataPool(static_cast<const DataPool&>(o)) {\n+        ROBIN_HOOD_TRACE(this);\n+        if (!o.empty()) {\n+            // not empty: create an exact copy. it is also possible to just iterate through all\n+            // elements and insert them, but copying is probably faster.\n+\n+            mKeyVals = static_cast<Node*>(\n+                detail::assertNotNull<std::bad_alloc>(malloc(calcNumBytesTotal(o.mMask + 1))));\n+            // no need for calloc because clonData does memcpy\n+            mInfo = reinterpret_cast<uint8_t*>(mKeyVals + o.mMask + 1);\n+            mNumElements = o.mNumElements;\n+            mMask = o.mMask;\n+            mMaxNumElementsAllowed = o.mMaxNumElementsAllowed;\n+            mInfoInc = o.mInfoInc;\n+            mInfoHashShift = o.mInfoHashShift;\n+            cloneData(o);\n+        }\n+    }\n+\n+    // Creates a copy of the given map. Copy constructor of each entry is used.\n+    unordered_map& operator=(unordered_map const& o) {\n+        ROBIN_HOOD_TRACE(this);\n+        if (&o == this) {\n+            // prevent assigning of itself\n+            return *this;\n+        }\n+\n+        // we keep using the old allocator and not assign the new one, because we want to keep the\n+        // memory available. when it is the same size.\n+        if (o.empty()) {\n+            if (0 == mMask) {\n+                // nothing to do, we are empty too\n+                return *this;\n+            }\n+\n+            // not empty: destroy what we have there\n+            // clear also resets mInfo to 0, that's sometimes not necessary.\n+            destroy();\n+            init();\n+            Hash::operator=(static_cast<const Hash&>(o));\n+            KeyEqual::operator=(static_cast<const KeyEqual&>(o));\n+            DataPool::operator=(static_cast<DataPool const&>(o));\n+\n+            return *this;\n+        }\n+\n+        // clean up old stuff\n+        Destroyer<Self, IsFlatMap && std::is_trivially_destructible<Node>::value>{}.nodes(*this);\n+\n+        if (mMask != o.mMask) {\n+            // no luck: we don't have the same array size allocated, so we need to realloc.\n+            if (0 != mMask) {\n+                // only deallocate if we actually have data!\n+                free(mKeyVals);\n+            }\n+\n+            mKeyVals = static_cast<Node*>(\n+                detail::assertNotNull<std::bad_alloc>(malloc(calcNumBytesTotal(o.mMask + 1))));\n+\n+            // no need for calloc here because cloneData performs a memcpy.\n+            mInfo = reinterpret_cast<uint8_t*>(mKeyVals + o.mMask + 1);\n+            // sentinel is set in cloneData\n+        }\n+        Hash::operator=(static_cast<const Hash&>(o));\n+        KeyEqual::operator=(static_cast<const KeyEqual&>(o));\n+        DataPool::operator=(static_cast<DataPool const&>(o));\n+        mNumElements = o.mNumElements;\n+        mMask = o.mMask;\n+        mMaxNumElementsAllowed = o.mMaxNumElementsAllowed;\n+        mInfoInc = o.mInfoInc;\n+        mInfoHashShift = o.mInfoHashShift;\n+        cloneData(o);\n+\n+        return *this;\n+    }\n+\n+    // Swaps everything between the two maps.\n+    void swap(unordered_map& o) {\n+        ROBIN_HOOD_TRACE(this);\n+        using std::swap;\n+        swap(o, *this);\n+    }\n+\n+    // Clears all data, without resizing.\n+    void clear() {\n+        ROBIN_HOOD_TRACE(this);\n+        if (empty()) {\n+            // don't do anything! also important because we don't want to write to DummyInfoByte::b,\n+            // even though we would just write 0 to it.\n+            return;\n+        }\n+\n+        Destroyer<Self, IsFlatMap && std::is_trivially_destructible<Node>::value>{}.nodes(*this);\n+\n+        // clear everything except the sentinel\n+        // std::memset(mInfo, 0, sizeof(uint8_t) * (mMask + 1));\n+        uint8_t const z = 0;\n+        std::fill(mInfo, mInfo + (sizeof(uint8_t) * (mMask + 1)), z);\n+\n+        mInfoInc = InitialInfoInc;\n+        mInfoHashShift = InitialInfoHashShift;\n+    }\n+\n+    // Destroys the map and all it's contents.\n+    ~unordered_map() {\n+        ROBIN_HOOD_TRACE(this);\n+        destroy();\n+    }\n+\n+    // Checks if both maps contain the same entries. Order is irrelevant.\n+    bool operator==(const unordered_map& other) const {\n+        ROBIN_HOOD_TRACE(this);\n+        if (other.size() != size()) {\n+            return false;\n+        }\n+        for (auto const& otherEntry : other) {\n+            auto const myIt = find(otherEntry.first);\n+            if (myIt == end() || !(myIt->second == otherEntry.second)) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    bool operator!=(const unordered_map& other) const {\n+        ROBIN_HOOD_TRACE(this);\n+        return !operator==(other);\n+    }\n+\n+    mapped_type& operator[](const key_type& key) {\n+        ROBIN_HOOD_TRACE(this);\n+        return doCreateByKey(key);\n+    }\n+\n+    mapped_type& operator[](key_type&& key) {\n+        ROBIN_HOOD_TRACE(this);\n+        return doCreateByKey(std::move(key));\n+    }\n+\n+    template <typename Iter>\n+    void insert(Iter first, Iter last) {\n+        for (; first != last; ++first) {\n+            // value_type ctor needed because this might be called with std::pair's\n+            insert(value_type(*first));\n+        }\n+    }\n+\n+    template <typename... Args>\n+    std::pair<iterator, bool> emplace(Args&&... args) {\n+        ROBIN_HOOD_TRACE(this);\n+        Node n{*this, std::forward<Args>(args)...};\n+        auto r = doInsert(std::move(n));\n+        if (!r.second) {\n+            // insertion not possible: destroy node\n+            // NOLINTNEXTLINE(bugprone-use-after-move)\n+            n.destroy(*this);\n+        }\n+        return r;\n+    }\n+\n+    std::pair<iterator, bool> insert(const value_type& keyval) {\n+        ROBIN_HOOD_TRACE(this);\n+        return doInsert(keyval);\n+    }\n+\n+    std::pair<iterator, bool> insert(value_type&& keyval) {\n+        return doInsert(std::move(keyval));\n+    }\n+\n+    // Returns 1 if key is found, 0 otherwise.\n+    size_t count(const key_type& key) const { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        auto kv = mKeyVals + findIdx(key);\n+        if (kv != reinterpret_cast_no_cast_align_warning<Node*>(mInfo)) {\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    // Returns a reference to the value found for key.\n+    // Throws std::out_of_range if element cannot be found\n+    mapped_type& at(key_type const& key) {\n+        ROBIN_HOOD_TRACE(this);\n+        auto kv = mKeyVals + findIdx(key);\n+        if (kv == reinterpret_cast_no_cast_align_warning<Node*>(mInfo)) {\n+            doThrow<std::out_of_range>(\"key not found\");\n+        }\n+        return kv->getSecond();\n+    }\n+\n+    // Returns a reference to the value found for key.\n+    // Throws std::out_of_range if element cannot be found\n+    mapped_type const& at(key_type const& key) const { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        auto kv = mKeyVals + findIdx(key);\n+        if (kv == reinterpret_cast_no_cast_align_warning<Node*>(mInfo)) {\n+            doThrow<std::out_of_range>(\"key not found\");\n+        }\n+        return kv->getSecond();\n+    }\n+\n+    const_iterator find(const key_type& key) const { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        const size_t idx = findIdx(key);\n+        return const_iterator{mKeyVals + idx, mInfo + idx};\n+    }\n+\n+    template <typename OtherKey>\n+    const_iterator find(const OtherKey& key, is_transparent_tag /*unused*/) const {\n+        ROBIN_HOOD_TRACE(this);\n+        const size_t idx = findIdx(key);\n+        return const_iterator{mKeyVals + idx, mInfo + idx};\n+    }\n+\n+    iterator find(const key_type& key) {\n+        ROBIN_HOOD_TRACE(this);\n+        const size_t idx = findIdx(key);\n+        return iterator{mKeyVals + idx, mInfo + idx};\n+    }\n+\n+    template <typename OtherKey>\n+    iterator find(const OtherKey& key, is_transparent_tag /*unused*/) {\n+        ROBIN_HOOD_TRACE(this);\n+        const size_t idx = findIdx(key);\n+        return iterator{mKeyVals + idx, mInfo + idx};\n+    }\n+\n+    iterator begin() {\n+        ROBIN_HOOD_TRACE(this);\n+        if (empty()) {\n+            return end();\n+        }\n+        return iterator(mKeyVals, mInfo, fast_forward_tag{});\n+    }\n+    const_iterator begin() const { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        return cbegin();\n+    }\n+    const_iterator cbegin() const { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        if (empty()) {\n+            return cend();\n+        }\n+        return const_iterator(mKeyVals, mInfo, fast_forward_tag{});\n+    }\n+\n+    iterator end() {\n+        ROBIN_HOOD_TRACE(this);\n+        // no need to supply valid info pointer: end() must not be dereferenced, and only node\n+        // pointer is compared.\n+        return iterator{reinterpret_cast_no_cast_align_warning<Node*>(mInfo), nullptr};\n+    }\n+    const_iterator end() const { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        return cend();\n+    }\n+    const_iterator cend() const { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        return const_iterator{reinterpret_cast_no_cast_align_warning<Node*>(mInfo), nullptr};\n+    }\n+\n+    iterator erase(const_iterator pos) {\n+        ROBIN_HOOD_TRACE(this);\n+        // its safe to perform const cast here\n+        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-const-cast)\n+        return erase(iterator{const_cast<Node*>(pos.mKeyVals), const_cast<uint8_t*>(pos.mInfo)});\n+    }\n+\n+    // Erases element at pos, returns iterator to the next element.\n+    iterator erase(iterator pos) {\n+        ROBIN_HOOD_TRACE(this);\n+        // we assume that pos always points to a valid entry, and not end().\n+        auto const idx = static_cast<size_t>(pos.mKeyVals - mKeyVals);\n+\n+        shiftDown(idx);\n+        --mNumElements;\n+\n+        if (*pos.mInfo) {\n+            // we've backward shifted, return this again\n+            return pos;\n+        }\n+\n+        // no backward shift, return next element\n+        return ++pos;\n+    }\n+\n+    size_t erase(const key_type& key) {\n+        ROBIN_HOOD_TRACE(this);\n+        size_t idx;\n+        InfoType info;\n+        keyToIdx(key, &idx, &info);\n+\n+        // check while info matches with the source idx\n+        do {\n+            if (info == mInfo[idx] && KeyEqual::operator()(key, mKeyVals[idx].getFirst())) {\n+                shiftDown(idx);\n+                --mNumElements;\n+                return 1;\n+            }\n+            next(&info, &idx);\n+        } while (info <= mInfo[idx]);\n+\n+        // nothing found to delete\n+        return 0;\n+    }\n+\n+    // reserves space for the specified number of elements. Makes sure the old data fits.\n+    // exactly the same as reserve(c).\n+    void rehash(size_t c) {\n+        reserve(c);\n+    }\n+\n+    // reserves space for the specified number of elements. Makes sure the old data fits.\n+    // Exactly the same as resize(c). Use resize(0) to shrink to fit.\n+    void reserve(size_t c) {\n+        ROBIN_HOOD_TRACE(this);\n+        auto const minElementsAllowed = (std::max)(c, mNumElements);\n+        auto newSize = InitialNumElements;\n+        while (calcMaxNumElementsAllowed(newSize) < minElementsAllowed && newSize != 0) {\n+            newSize *= 2;\n+        }\n+        if (ROBIN_HOOD_UNLIKELY(newSize == 0)) {\n+            throwOverflowError();\n+        }\n+\n+        rehashPowerOfTwo(newSize);\n+    }\n+\n+    size_type size() const noexcept { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        return mNumElements;\n+    }\n+\n+    size_type max_size() const noexcept { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        return static_cast<size_type>(-1);\n+    }\n+\n+    ROBIN_HOOD(NODISCARD) bool empty() const noexcept {\n+        ROBIN_HOOD_TRACE(this);\n+        return 0 == mNumElements;\n+    }\n+\n+    float max_load_factor() const noexcept { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        return MaxLoadFactor100 / 100.0F;\n+    }\n+\n+    // Average number of elements per bucket. Since we allow only 1 per bucket\n+    float load_factor() const noexcept { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        return static_cast<float>(size()) / static_cast<float>(mMask + 1);\n+    }\n+\n+    ROBIN_HOOD(NODISCARD) size_t mask() const noexcept {\n+        ROBIN_HOOD_TRACE(this);\n+        return mMask;\n+    }\n+\n+    ROBIN_HOOD(NODISCARD) size_t calcMaxNumElementsAllowed(size_t maxElements) const noexcept {\n+        if (ROBIN_HOOD_LIKELY(maxElements <= (std::numeric_limits<size_t>::max)() / 100)) {\n+            return maxElements * MaxLoadFactor100 / 100;\n+        }\n+\n+        // we might be a bit inprecise, but since maxElements is quite large that doesn't matter\n+        return (maxElements / 100) * MaxLoadFactor100;\n+    }\n+\n+    ROBIN_HOOD(NODISCARD) size_t calcNumBytesInfo(size_t numElements) const {\n+        return numElements + sizeof(uint64_t);\n+    }\n+\n+    // calculation ony allowed for 2^n values\n+    ROBIN_HOOD(NODISCARD) size_t calcNumBytesTotal(size_t numElements) const {\n+#if ROBIN_HOOD(BITNESS) == 64\n+        return numElements * sizeof(Node) + calcNumBytesInfo(numElements);\n+#else\n+        // make sure we're doing 64bit operations, so we are at least safe against 32bit overflows.\n+        auto const ne = static_cast<uint64_t>(numElements);\n+        auto const s = static_cast<uint64_t>(sizeof(Node));\n+        auto const infos = static_cast<uint64_t>(calcNumBytesInfo(numElements));\n+\n+        auto const total64 = ne * s + infos;\n+        auto const total = static_cast<size_t>(total64);\n+\n+        if (ROBIN_HOOD_UNLIKELY(static_cast<uint64_t>(total) != total64)) {\n+            throwOverflowError();\n+        }\n+        return total;\n+#endif\n+    }\n+\n+private:\n+    // reserves space for at least the specified number of elements.\n+    // only works if numBuckets if power of two\n+    void rehashPowerOfTwo(size_t numBuckets) {\n+        ROBIN_HOOD_TRACE(this);\n+\n+        Node* const oldKeyVals = mKeyVals;\n+        uint8_t const* const oldInfo = mInfo;\n+\n+        const size_t oldMaxElements = mMask + 1;\n+\n+        // resize operation: move stuff\n+        init_data(numBuckets);\n+        if (oldMaxElements > 1) {\n+            for (size_t i = 0; i < oldMaxElements; ++i) {\n+                if (oldInfo[i] != 0) {\n+                    insert_move(std::move(oldKeyVals[i]));\n+                    // destroy the node but DON'T destroy the data.\n+                    oldKeyVals[i].~Node();\n+                }\n+            }\n+\n+            // don't destroy old data: put it into the pool instead\n+            DataPool::addOrFree(oldKeyVals, calcNumBytesTotal(oldMaxElements));\n+        }\n+    }\n+\n+    ROBIN_HOOD(NOINLINE) void throwOverflowError() const {\n+#if ROBIN_HOOD(HAS_EXCEPTIONS)\n+        throw std::overflow_error(\"robin_hood::map overflow\");\n+#else\n+        abort();\n+#endif\n+    }\n+\n+    void init_data(size_t max_elements) {\n+        mNumElements = 0;\n+        mMask = max_elements - 1;\n+        mMaxNumElementsAllowed = calcMaxNumElementsAllowed(max_elements);\n+\n+        // calloc also zeroes everything\n+        mKeyVals = reinterpret_cast<Node*>(\n+            detail::assertNotNull<std::bad_alloc>(calloc(1, calcNumBytesTotal(max_elements))));\n+        mInfo = reinterpret_cast<uint8_t*>(mKeyVals + max_elements);\n+\n+        // set sentinel\n+        mInfo[max_elements] = 1;\n+\n+        mInfoInc = InitialInfoInc;\n+        mInfoHashShift = InitialInfoHashShift;\n+    }\n+\n+    template <typename Arg>\n+    mapped_type& doCreateByKey(Arg&& key) {\n+        while (true) {\n+            size_t idx;\n+            InfoType info;\n+            keyToIdx(key, &idx, &info);\n+            nextWhileLess(&info, &idx);\n+\n+            // while we potentially have a match. Can't do a do-while here because when mInfo is 0\n+            // we don't want to skip forward\n+            while (info == mInfo[idx]) {\n+                if (KeyEqual::operator()(key, mKeyVals[idx].getFirst())) {\n+                    // key already exists, do not insert.\n+                    return mKeyVals[idx].getSecond();\n+                }\n+                next(&info, &idx);\n+            }\n+\n+            // unlikely that this evaluates to true\n+            if (ROBIN_HOOD_UNLIKELY(mNumElements >= mMaxNumElementsAllowed)) {\n+                increase_size();\n+                continue;\n+            }\n+\n+            // key not found, so we are now exactly where we want to insert it.\n+            auto const insertion_idx = idx;\n+            auto const insertion_info = info;\n+            if (ROBIN_HOOD_UNLIKELY(insertion_info + mInfoInc > 0xFF)) {\n+                mMaxNumElementsAllowed = 0;\n+            }\n+\n+            // find an empty spot\n+            while (0 != mInfo[idx]) {\n+                next(&info, &idx);\n+            }\n+\n+            auto& l = mKeyVals[insertion_idx];\n+            if (idx == insertion_idx) {\n+                // put at empty spot. This forwards all arguments into the node where the object is\n+                // constructed exactly where it is needed.\n+                ::new (static_cast<void*>(&l))\n+                    Node(*this, std::piecewise_construct,\n+                         std::forward_as_tuple(std::forward<Arg>(key)), std::forward_as_tuple());\n+            } else {\n+                shiftUp(idx, insertion_idx);\n+                l = Node(*this, std::piecewise_construct,\n+                         std::forward_as_tuple(std::forward<Arg>(key)), std::forward_as_tuple());\n+            }\n+\n+            // mKeyVals[idx].getFirst() = std::move(key);\n+            mInfo[insertion_idx] = static_cast<uint8_t>(insertion_info);\n+\n+            ++mNumElements;\n+            return mKeyVals[insertion_idx].getSecond();\n+        }\n+    }\n+\n+    // This is exactly the same code as operator[], except for the return values\n+    template <typename Arg>\n+    std::pair<iterator, bool> doInsert(Arg&& keyval) {\n+        while (true) {\n+            size_t idx;\n+            InfoType info;\n+            keyToIdx(keyval.getFirst(), &idx, &info);\n+            nextWhileLess(&info, &idx);\n+\n+            // while we potentially have a match\n+            while (info == mInfo[idx]) {\n+                if (KeyEqual::operator()(keyval.getFirst(), mKeyVals[idx].getFirst())) {\n+                    // key already exists, do NOT insert.\n+                    // see http://en.cppreference.com/w/cpp/container/unordered_map/insert\n+                    return std::make_pair<iterator, bool>(iterator(mKeyVals + idx, mInfo + idx),\n+                                                          false);\n+                }\n+                next(&info, &idx);\n+            }\n+\n+            // unlikely that this evaluates to true\n+            if (ROBIN_HOOD_UNLIKELY(mNumElements >= mMaxNumElementsAllowed)) {\n+                increase_size();\n+                continue;\n+            }\n+\n+            // key not found, so we are now exactly where we want to insert it.\n+            auto const insertion_idx = idx;\n+            auto const insertion_info = info;\n+            if (ROBIN_HOOD_UNLIKELY(insertion_info + mInfoInc > 0xFF)) {\n+                mMaxNumElementsAllowed = 0;\n+            }\n+\n+            // find an empty spot\n+            while (0 != mInfo[idx]) {\n+                next(&info, &idx);\n+            }\n+\n+            auto& l = mKeyVals[insertion_idx];\n+            if (idx == insertion_idx) {\n+                ::new (static_cast<void*>(&l)) Node(*this, std::forward<Arg>(keyval));\n+            } else {\n+                shiftUp(idx, insertion_idx);\n+                l = Node(*this, std::forward<Arg>(keyval));\n+            }\n+\n+            // put at empty spot\n+            mInfo[insertion_idx] = static_cast<uint8_t>(insertion_info);\n+\n+            ++mNumElements;\n+            return std::make_pair(iterator(mKeyVals + insertion_idx, mInfo + insertion_idx), true);\n+        }\n+    }\n+\n+    bool try_increase_info() {\n+        ROBIN_HOOD_LOG(\"mInfoInc=\" << mInfoInc << \", numElements=\" << mNumElements\n+                                   << \", maxNumElementsAllowed=\"\n+                                   << calcMaxNumElementsAllowed(mMask + 1));\n+        if (mInfoInc <= 2) {\n+            // need to be > 2 so that shift works (otherwise undefined behavior!)\n+            return false;\n+        }\n+        // we got space left, try to make info smaller\n+        mInfoInc = static_cast<uint8_t>(mInfoInc >> 1U);\n+\n+        // remove one bit of the hash, leaving more space for the distance info.\n+        // This is extremely fast because we can operate on 8 bytes at once.\n+        ++mInfoHashShift;\n+        auto const data = reinterpret_cast_no_cast_align_warning<uint64_t*>(mInfo);\n+        auto const numEntries = (mMask + 1) / 8;\n+\n+        for (size_t i = 0; i < numEntries; ++i) {\n+            data[i] = (data[i] >> 1U) & UINT64_C(0x7f7f7f7f7f7f7f7f);\n+        }\n+        mMaxNumElementsAllowed = calcMaxNumElementsAllowed(mMask + 1);\n+        return true;\n+    }\n+\n+    void increase_size() {\n+        // nothing allocated yet? just allocate InitialNumElements\n+        if (0 == mMask) {\n+            init_data(InitialNumElements);\n+            return;\n+        }\n+\n+        auto const maxNumElementsAllowed = calcMaxNumElementsAllowed(mMask + 1);\n+        if (mNumElements < maxNumElementsAllowed && try_increase_info()) {\n+            return;\n+        }\n+\n+        ROBIN_HOOD_LOG(\"mNumElements=\" << mNumElements << \", maxNumElementsAllowed=\"\n+                                       << maxNumElementsAllowed << \", load=\"\n+                                       << (static_cast<double>(mNumElements) * 100.0 /\n+                                           (static_cast<double>(mMask) + 1)));\n+        // it seems we have a really bad hash function! don't try to resize again\n+        if (mNumElements * 2 < calcMaxNumElementsAllowed(mMask + 1)) {\n+            throwOverflowError();\n+        }\n+\n+        rehashPowerOfTwo((mMask + 1) * 2);\n+    }\n+\n+    void destroy() {\n+        if (0 == mMask) {\n+            // don't deallocate!\n+            return;\n+        }\n+\n+        Destroyer<Self, IsFlatMap && std::is_trivially_destructible<Node>::value>{}\n+            .nodesDoNotDeallocate(*this);\n+        free(mKeyVals);\n+    }\n+\n+    void init() noexcept {\n+        mKeyVals = reinterpret_cast<Node*>(&mMask);\n+        mInfo = reinterpret_cast<uint8_t*>(&mMask);\n+        mNumElements = 0;\n+        mMask = 0;\n+        mMaxNumElementsAllowed = 0;\n+        mInfoInc = InitialInfoInc;\n+        mInfoHashShift = InitialInfoHashShift;\n+    }\n+\n+    // members are sorted so no padding occurs\n+    Node* mKeyVals = reinterpret_cast<Node*>(&mMask);    // 8 byte  8\n+    uint8_t* mInfo = reinterpret_cast<uint8_t*>(&mMask); // 8 byte 16\n+    size_t mNumElements = 0;                             // 8 byte 24\n+    size_t mMask = 0;                                    // 8 byte 32\n+    size_t mMaxNumElementsAllowed = 0;                   // 8 byte 40\n+    InfoType mInfoInc = InitialInfoInc;                  // 4 byte 44\n+    InfoType mInfoHashShift = InitialInfoHashShift;      // 4 byte 48\n+                                                         // 16 byte 56 if NodeAllocator\n+};\n+\n+} // namespace detail\n+\n+template <typename Key, typename T, typename Hash = hash<Key>,\n+          typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n+using unordered_flat_map = detail::unordered_map<true, MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n+\n+template <typename Key, typename T, typename Hash = hash<Key>,\n+          typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n+using unordered_node_map = detail::unordered_map<false, MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n+\n+template <typename Key, typename T, typename Hash = hash<Key>,\n+          typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n+using unordered_map =\n+    detail::unordered_map<sizeof(robin_hood::pair<Key, T>) <= sizeof(size_t) * 6 &&\n+                              std::is_nothrow_move_constructible<robin_hood::pair<Key, T>>::value &&\n+                              std::is_nothrow_move_assignable<robin_hood::pair<Key, T>>::value,\n+                          MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n+\n+} // namespace robin_hood\n+\n+#endif"
      },
      {
        "sha": "a522e3916546ec34096d4963dcf1ebb4ef116c8c",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f9882ce4a817c9f14aa7526165ab6e278de890e/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f9882ce4a817c9f14aa7526165ab6e278de890e/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=6f9882ce4a817c9f14aa7526165ab6e278de890e",
        "patch": "@@ -64,7 +64,7 @@ class CCoinsViewTest : public CCoinsView\n                     map_.erase(it->first);\n                 }\n             }\n-            mapCoins.erase(it++);\n+            it = mapCoins.erase(it);\n         }\n         if (!hashBlock.IsNull())\n             hashBestBlock_ = hashBlock;"
      },
      {
        "sha": "a023689ffad61b417ef94f4b0df6ab83a5aec864",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f9882ce4a817c9f14aa7526165ab6e278de890e/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f9882ce4a817c9f14aa7526165ab6e278de890e/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=6f9882ce4a817c9f14aa7526165ab6e278de890e",
        "patch": "@@ -114,8 +114,7 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n             changed++;\n         }\n         count++;\n-        CCoinsMap::iterator itOld = it++;\n-        mapCoins.erase(itOld);\n+        it = mapCoins.erase(it);\n         if (batch.SizeEstimate() > batch_size) {\n             LogPrint(BCLog::COINDB, \"Writing partial batch of %.2f MiB\\n\", batch.SizeEstimate() * (1.0 / 1048576.0));\n             db.WriteBatch(batch);"
      }
    ]
  },
  {
    "sha": "27f5bc74d2821d42ae7214c60336aa29556493dc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyN2Y1YmM3NGQyODIxZDQyYWU3MjE0YzYwMzM2YWEyOTU1NjQ5M2Rj",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-09-01T17:23:00Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-09-01T17:23:00Z"
      },
      "message": "[robinhood] remove custom hash",
      "tree": {
        "sha": "6ad62ae65b0c7a63ef87c09b772553a07c44567b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6ad62ae65b0c7a63ef87c09b772553a07c44567b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/27f5bc74d2821d42ae7214c60336aa29556493dc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/27f5bc74d2821d42ae7214c60336aa29556493dc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/27f5bc74d2821d42ae7214c60336aa29556493dc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/27f5bc74d2821d42ae7214c60336aa29556493dc/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6f9882ce4a817c9f14aa7526165ab6e278de890e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6f9882ce4a817c9f14aa7526165ab6e278de890e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6f9882ce4a817c9f14aa7526165ab6e278de890e"
      }
    ],
    "stats": {
      "total": 153,
      "additions": 4,
      "deletions": 149
    },
    "files": [
      {
        "sha": "c5fc34eb46594159fbe80e3b92419881b53c6b11",
        "filename": "src/robin_hood.h",
        "status": "modified",
        "additions": 4,
        "deletions": 149,
        "changes": 153,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27f5bc74d2821d42ae7214c60336aa29556493dc/src/robin_hood.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27f5bc74d2821d42ae7214c60336aa29556493dc/src/robin_hood.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/robin_hood.h?ref=27f5bc74d2821d42ae7214c60336aa29556493dc",
        "patch": "@@ -640,143 +640,6 @@ void swap(pair<A, B>& a, pair<A, B>& b) noexcept(\n     a.swap(b);\n }\n \n-// Hash an arbitrary amount of bytes. This is basically Murmur2 hash without caring about big\n-// endianness. TODO(martinus) add a fallback for very large strings?\n-static size_t hash_bytes(void const* ptr, size_t const len) noexcept {\n-    static constexpr uint64_t m = UINT64_C(0xc6a4a7935bd1e995);\n-    static constexpr uint64_t seed = UINT64_C(0xe17a1465);\n-    static constexpr unsigned int r = 47;\n-\n-    auto const data64 = static_cast<uint64_t const*>(ptr);\n-    uint64_t h = seed ^ (len * m);\n-\n-    size_t const n_blocks = len / 8;\n-    for (size_t i = 0; i < n_blocks; ++i) {\n-        auto k = detail::unaligned_load<uint64_t>(data64 + i);\n-\n-        k *= m;\n-        k ^= k >> r;\n-        k *= m;\n-\n-        h ^= k;\n-        h *= m;\n-    }\n-\n-    auto const data8 = reinterpret_cast<uint8_t const*>(data64 + n_blocks);\n-    switch (len & 7U) {\n-    case 7:\n-        h ^= static_cast<uint64_t>(data8[6]) << 48U;\n-        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n-    case 6:\n-        h ^= static_cast<uint64_t>(data8[5]) << 40U;\n-        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n-    case 5:\n-        h ^= static_cast<uint64_t>(data8[4]) << 32U;\n-        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n-    case 4:\n-        h ^= static_cast<uint64_t>(data8[3]) << 24U;\n-        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n-    case 3:\n-        h ^= static_cast<uint64_t>(data8[2]) << 16U;\n-        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n-    case 2:\n-        h ^= static_cast<uint64_t>(data8[1]) << 8U;\n-        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n-    case 1:\n-        h ^= static_cast<uint64_t>(data8[0]);\n-        h *= m;\n-        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n-    default:\n-        break;\n-    }\n-\n-    h ^= h >> r;\n-    h *= m;\n-    h ^= h >> r;\n-    return static_cast<size_t>(h);\n-}\n-\n-inline size_t hash_int(uint64_t obj) noexcept {\n-#if ROBIN_HOOD(HAS_UMUL128)\n-    // 167079903232 masksum, 120428523 ops best: 0xde5fb9d2630458e9\n-    static constexpr uint64_t k = UINT64_C(0xde5fb9d2630458e9);\n-    uint64_t h;\n-    uint64_t l = detail::umul128(obj, k, &h);\n-    return h + l;\n-#elif ROBIN_HOOD(BITNESS) == 32\n-    uint64_t const r = obj * UINT64_C(0xca4bcaa75ec3f625);\n-    auto h = static_cast<uint32_t>(r >> 32U);\n-    auto l = static_cast<uint32_t>(r);\n-    return h + l;\n-#else\n-    // murmurhash 3 finalizer\n-    uint64_t h = obj;\n-    h ^= h >> 33;\n-    h *= 0xff51afd7ed558ccd;\n-    h ^= h >> 33;\n-    h *= 0xc4ceb9fe1a85ec53;\n-    h ^= h >> 33;\n-    return static_cast<size_t>(h);\n-#endif\n-}\n-\n-// A thin wrapper around std::hash, performing an additional simple mixing step of the result.\n-template <typename T>\n-struct hash : public std::hash<T> {\n-    size_t operator()(T const& obj) const\n-        noexcept(noexcept(std::declval<std::hash<T>>().operator()(std::declval<T const&>()))) {\n-        // call base hash\n-        auto result = std::hash<T>::operator()(obj);\n-        // return mixed of that, to be save against identity has\n-        return hash_int(static_cast<uint64_t>(result));\n-    }\n-};\n-\n-template <>\n-struct hash<std::string> {\n-    size_t operator()(std::string const& str) const noexcept {\n-        return hash_bytes(str.data(), str.size());\n-    }\n-};\n-\n-template <class T>\n-struct hash<T*> {\n-    size_t operator()(T* ptr) const noexcept {\n-        return hash_int(reinterpret_cast<size_t>(ptr));\n-    }\n-};\n-\n-#define ROBIN_HOOD_HASH_INT(T)                           \\\n-    template <>                                          \\\n-    struct hash<T> {                                     \\\n-        size_t operator()(T obj) const noexcept {        \\\n-            return hash_int(static_cast<uint64_t>(obj)); \\\n-        }                                                \\\n-    }\n-\n-#if defined(__GNUC__) && !defined(__clang__)\n-#    pragma GCC diagnostic push\n-#    pragma GCC diagnostic ignored \"-Wuseless-cast\"\n-#endif\n-// see https://en.cppreference.com/w/cpp/utility/hash\n-ROBIN_HOOD_HASH_INT(bool);\n-ROBIN_HOOD_HASH_INT(char);\n-ROBIN_HOOD_HASH_INT(signed char);\n-ROBIN_HOOD_HASH_INT(unsigned char);\n-ROBIN_HOOD_HASH_INT(char16_t);\n-ROBIN_HOOD_HASH_INT(char32_t);\n-ROBIN_HOOD_HASH_INT(wchar_t);\n-ROBIN_HOOD_HASH_INT(short);\n-ROBIN_HOOD_HASH_INT(unsigned short);\n-ROBIN_HOOD_HASH_INT(int);\n-ROBIN_HOOD_HASH_INT(unsigned int);\n-ROBIN_HOOD_HASH_INT(long);\n-ROBIN_HOOD_HASH_INT(long long);\n-ROBIN_HOOD_HASH_INT(unsigned long);\n-ROBIN_HOOD_HASH_INT(unsigned long long);\n-#if defined(__GNUC__) && !defined(__clang__)\n-#    pragma GCC diagnostic pop\n-#endif\n namespace detail {\n \n // A highly optimized hashmap implementation, using the Robin Hood algorithm.\n@@ -1153,15 +1016,7 @@ class unordered_map\n     // The upper 1-5 bits need to be a reasonable good hash, to save comparisons.\n     template <typename HashKey>\n     void keyToIdx(HashKey&& key, size_t* idx, InfoType* info) const {\n-        // for a user-specified hash that is *not* robin_hood::hash, apply robin_hood::hash as an\n-        // additional mixing step. This serves as a bad hash prevention, if the given data is badly\n-        // mixed.\n-        using Mix =\n-            typename std::conditional<std::is_same<::robin_hood::hash<key_type>, hasher>::value,\n-                                      ::robin_hood::detail::identity_hash<size_t>,\n-                                      ::robin_hood::hash<size_t>>::type;\n-        *idx = Mix{}(Hash::operator()(key));\n-\n+        *idx = Hash::operator()(key);\n         *info = mInfoInc + static_cast<InfoType>(*idx >> mInfoHashShift);\n         *idx &= mMask;\n     }\n@@ -2016,15 +1871,15 @@ class unordered_map\n \n } // namespace detail\n \n-template <typename Key, typename T, typename Hash = hash<Key>,\n+template <typename Key, typename T, typename Hash,\n           typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n using unordered_flat_map = detail::unordered_map<true, MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n \n-template <typename Key, typename T, typename Hash = hash<Key>,\n+template <typename Key, typename T, typename Hash,\n           typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n using unordered_node_map = detail::unordered_map<false, MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n \n-template <typename Key, typename T, typename Hash = hash<Key>,\n+template <typename Key, typename T, typename Hash,\n           typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n using unordered_map =\n     detail::unordered_map<sizeof(robin_hood::pair<Key, T>) <= sizeof(size_t) * 6 &&"
      }
    ]
  },
  {
    "sha": "fa73a0f68ef7f9a0ec61edfb91cb9f72521776a2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTczYTBmNjhlZjdmOWEwZWM2MWVkZmI5MWNiOWY3MjUyMTc3NmEy",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-09-01T17:35:49Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-09-01T17:35:49Z"
      },
      "message": "[robinhood] remove inline DataNode (flatmap=true)",
      "tree": {
        "sha": "c22d81b3ddfbacc4f0649d6d87925a451e790f9d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c22d81b3ddfbacc4f0649d6d87925a451e790f9d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa73a0f68ef7f9a0ec61edfb91cb9f72521776a2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa73a0f68ef7f9a0ec61edfb91cb9f72521776a2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa73a0f68ef7f9a0ec61edfb91cb9f72521776a2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa73a0f68ef7f9a0ec61edfb91cb9f72521776a2/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "27f5bc74d2821d42ae7214c60336aa29556493dc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/27f5bc74d2821d42ae7214c60336aa29556493dc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/27f5bc74d2821d42ae7214c60336aa29556493dc"
      }
    ],
    "stats": {
      "total": 61,
      "additions": 3,
      "deletions": 58
    },
    "files": [
      {
        "sha": "eb09ff91a62c34f65108d1b039bde55e69dd41c4",
        "filename": "src/robin_hood.h",
        "status": "modified",
        "additions": 3,
        "deletions": 58,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa73a0f68ef7f9a0ec61edfb91cb9f72521776a2/src/robin_hood.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa73a0f68ef7f9a0ec61edfb91cb9f72521776a2/src/robin_hood.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/robin_hood.h?ref=fa73a0f68ef7f9a0ec61edfb91cb9f72521776a2",
        "patch": "@@ -703,6 +703,8 @@ class unordered_map\n     using DataPool = detail::NodeAllocator<value_type, 4, 16384, IsFlatMap>;\n \n     // type needs to be wider than uint8_t.\n+    //\n+    // TODO(jamesob): why? advertised as a byte?\n     using InfoType = uint32_t;\n \n     // DataNode ////////////////////////////////////////////////////////\n@@ -713,63 +715,6 @@ class unordered_map\n     template <typename M, bool>\n     class DataNode {};\n \n-    // Small: just allocate on the stack.\n-    template <typename M>\n-    class DataNode<M, true> final {\n-    public:\n-        template <typename... Args>\n-        explicit DataNode(M& ROBIN_HOOD_UNUSED(map) /*unused*/, Args&&... args) noexcept(\n-            noexcept(value_type(std::forward<Args>(args)...)))\n-            : mData(std::forward<Args>(args)...) {}\n-\n-        DataNode(M& ROBIN_HOOD_UNUSED(map) /*unused*/, DataNode<M, true>&& n) noexcept(\n-            std::is_nothrow_move_constructible<value_type>::value)\n-            : mData(std::move(n.mData)) {}\n-\n-        // doesn't do anything\n-        void destroy(M& ROBIN_HOOD_UNUSED(map) /*unused*/) noexcept {}\n-        void destroyDoNotDeallocate() noexcept {}\n-\n-        value_type const* operator->() const noexcept {\n-            return &mData;\n-        }\n-        value_type* operator->() noexcept {\n-            return &mData;\n-        }\n-\n-        const value_type& operator*() const noexcept {\n-            return mData;\n-        }\n-\n-        value_type& operator*() noexcept {\n-            return mData;\n-        }\n-\n-        ROBIN_HOOD(NODISCARD) typename value_type::first_type& getFirst() noexcept {\n-            return mData.first;\n-        }\n-\n-        ROBIN_HOOD(NODISCARD) typename value_type::first_type const& getFirst() const noexcept {\n-            return mData.first;\n-        }\n-\n-        ROBIN_HOOD(NODISCARD) typename value_type::second_type& getSecond() noexcept {\n-            return mData.second;\n-        }\n-\n-        ROBIN_HOOD(NODISCARD) typename value_type::second_type const& getSecond() const noexcept {\n-            return mData.second;\n-        }\n-\n-        void swap(DataNode<M, true>& o) noexcept(\n-            noexcept(std::declval<value_type>().swap(std::declval<value_type>()))) {\n-            mData.swap(o.mData);\n-        }\n-\n-    private:\n-        value_type mData;\n-    };\n-\n     // big object: allocate on heap.\n     template <typename M>\n     class DataNode<M, false> {\n@@ -834,7 +779,7 @@ class unordered_map\n         value_type* mData;\n     };\n \n-    using Node = DataNode<Self, IsFlatMap>;\n+    using Node = DataNode<Self, false>;\n \n     // Cloner //////////////////////////////////////////////////////////\n "
      }
    ]
  },
  {
    "sha": "7915fb73d35d6c21802db0c22e07bfbeafbde0fc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3OTE1ZmI3M2QzNWQ2YzIxODAyZGIwYzIyZTA3YmZiZWFmYmRlMGZj",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-09-01T17:42:28Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-09-01T17:42:28Z"
      },
      "message": "[robinhood] remove robin_hood::pair",
      "tree": {
        "sha": "97a63ea7c7ac5c52fab106c5ec2877c6f7a7b1b2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/97a63ea7c7ac5c52fab106c5ec2877c6f7a7b1b2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7915fb73d35d6c21802db0c22e07bfbeafbde0fc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7915fb73d35d6c21802db0c22e07bfbeafbde0fc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7915fb73d35d6c21802db0c22e07bfbeafbde0fc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7915fb73d35d6c21802db0c22e07bfbeafbde0fc/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fa73a0f68ef7f9a0ec61edfb91cb9f72521776a2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa73a0f68ef7f9a0ec61edfb91cb9f72521776a2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fa73a0f68ef7f9a0ec61edfb91cb9f72521776a2"
      }
    ],
    "stats": {
      "total": 110,
      "additions": 6,
      "deletions": 104
    },
    "files": [
      {
        "sha": "d1cb9834a02088b6a62548e39c1bae675e90a586",
        "filename": "src/memusage.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7915fb73d35d6c21802db0c22e07bfbeafbde0fc/src/memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7915fb73d35d6c21802db0c22e07bfbeafbde0fc/src/memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/memusage.h?ref=7915fb73d35d6c21802db0c22e07bfbeafbde0fc",
        "patch": "@@ -168,7 +168,7 @@ static inline size_t DynamicUsage(const std::unordered_map<X, Y, Z>& m)\n template<typename X, typename Y, typename Z>\n static inline size_t DynamicUsage(const robin_hood::unordered_node_map<X, Y, Z>& m)\n {\n-    return MallocUsage(sizeof(unordered_node<robin_hood::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * (m.mask() + 1));\n+    return MallocUsage(sizeof(unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * (m.mask() + 1));\n }\n \n }"
      },
      {
        "sha": "499efd5a573735c683f2cf5c1d5595cc87bb7d68",
        "filename": "src/robin_hood.h",
        "status": "modified",
        "additions": 5,
        "deletions": 103,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7915fb73d35d6c21802db0c22e07bfbeafbde0fc/src/robin_hood.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7915fb73d35d6c21802db0c22e07bfbeafbde0fc/src/robin_hood.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/robin_hood.h?ref=7915fb73d35d6c21802db0c22e07bfbeafbde0fc",
        "patch": "@@ -542,104 +542,6 @@ struct nothrow {\n \n struct is_transparent_tag {};\n \n-// A custom pair implementation is used in the map because std::pair is not is_trivially_copyable,\n-// which means it would  not be allowed to be used in std::memcpy. This struct is copyable, which is\n-// also tested.\n-template <typename T1, typename T2>\n-struct pair {\n-    using first_type = T1;\n-    using second_type = T2;\n-\n-    template <typename U1 = T1, typename U2 = T2,\n-              typename = typename std::enable_if<std::is_default_constructible<U1>::value &&\n-                                                 std::is_default_constructible<U2>::value>::type>\n-    constexpr pair() noexcept(noexcept(U1()) && noexcept(U2()))\n-        : first()\n-        , second() {}\n-\n-    // pair constructors are explicit so we don't accidentally call this ctor when we don't have to.\n-    explicit constexpr pair(std::pair<T1, T2> const& o) noexcept(\n-        noexcept(T1(std::declval<T1 const&>())) && noexcept(T2(std::declval<T2 const&>())))\n-        : first(o.first)\n-        , second(o.second) {}\n-\n-    // pair constructors are explicit so we don't accidentally call this ctor when we don't have to.\n-    explicit constexpr pair(std::pair<T1, T2>&& o) noexcept(\n-        noexcept(T1(std::move(std::declval<T1&&>()))) &&\n-        noexcept(T2(std::move(std::declval<T2&&>()))))\n-        : first(std::move(o.first))\n-        , second(std::move(o.second)) {}\n-\n-    constexpr pair(T1&& a, T2&& b) noexcept(noexcept(T1(std::move(std::declval<T1&&>()))) &&\n-                                            noexcept(T2(std::move(std::declval<T2&&>()))))\n-        : first(std::move(a))\n-        , second(std::move(b)) {}\n-\n-    template <typename U1, typename U2>\n-    constexpr pair(U1&& a, U2&& b) noexcept(noexcept(T1(std::forward<U1>(std::declval<U1&&>()))) &&\n-                                            noexcept(T2(std::forward<U2>(std::declval<U2&&>()))))\n-        : first(std::forward<U1>(a))\n-        , second(std::forward<U2>(b)) {}\n-\n-    template <typename... U1, typename... U2>\n-    constexpr pair(\n-        std::piecewise_construct_t /*unused*/, std::tuple<U1...> a,\n-        std::tuple<U2...> b) noexcept(noexcept(pair(std::declval<std::tuple<U1...>&>(),\n-                                                    std::declval<std::tuple<U2...>&>(),\n-                                                    ROBIN_HOOD_STD::index_sequence_for<U1...>(),\n-                                                    ROBIN_HOOD_STD::index_sequence_for<U2...>())))\n-        : pair(a, b, ROBIN_HOOD_STD::index_sequence_for<U1...>(),\n-               ROBIN_HOOD_STD::index_sequence_for<U2...>()) {}\n-\n-    // constructor called from the std::piecewise_construct_t ctor\n-    template <typename... U1, size_t... I1, typename... U2, size_t... I2>\n-    pair(std::tuple<U1...>& a, std::tuple<U2...>& b,\n-         ROBIN_HOOD_STD::index_sequence<I1...> /*unused*/,\n-         ROBIN_HOOD_STD::index_sequence<\n-             I2...> /*unused*/) noexcept(noexcept(T1(std::\n-                                                         forward<U1>(std::get<I1>(\n-                                                             std::declval<\n-                                                                 std::tuple<U1...>&>()))...)) &&\n-                                         noexcept(T2(std::forward<U2>(\n-                                             std::get<I2>(std::declval<std::tuple<U2...>&>()))...)))\n-        : first(std::forward<U1>(std::get<I1>(a))...)\n-        , second(std::forward<U2>(std::get<I2>(b))...) {\n-        // make visual studio compiler happy about warning about unused a & b.\n-        // Visual studio's pair implementation disables warning 4100.\n-        (void)a;\n-        (void)b;\n-    }\n-\n-    ROBIN_HOOD(NODISCARD) first_type& getFirst() noexcept {\n-        return first;\n-    }\n-    ROBIN_HOOD(NODISCARD) first_type const& getFirst() const noexcept {\n-        return first;\n-    }\n-    ROBIN_HOOD(NODISCARD) second_type& getSecond() noexcept {\n-        return second;\n-    }\n-    ROBIN_HOOD(NODISCARD) second_type const& getSecond() const noexcept {\n-        return second;\n-    }\n-\n-    void swap(pair<T1, T2>& o) noexcept((detail::swappable::nothrow<T1>::value) &&\n-                                        (detail::swappable::nothrow<T2>::value)) {\n-        using std::swap;\n-        swap(first, o.first);\n-        swap(second, o.second);\n-    }\n-\n-    T1 first;  // NOLINT(misc-non-private-member-variables-in-classes)\n-    T2 second; // NOLINT(misc-non-private-member-variables-in-classes)\n-};\n-\n-template <typename A, typename B>\n-void swap(pair<A, B>& a, pair<A, B>& b) noexcept(\n-    noexcept(std::declval<pair<A, B>&>().swap(std::declval<pair<A, B>&>()))) {\n-    a.swap(b);\n-}\n-\n namespace detail {\n \n // A highly optimized hashmap implementation, using the Robin Hood algorithm.\n@@ -675,13 +577,13 @@ class unordered_map\n     : public Hash,\n       public KeyEqual,\n       detail::NodeAllocator<\n-          robin_hood::pair<typename std::conditional<IsFlatMap, Key, Key const>::type, T>, 4, 16384,\n+          std::pair<typename std::conditional<IsFlatMap, Key, Key const>::type, T>, 4, 16384,\n           IsFlatMap> {\n public:\n     using key_type = Key;\n     using mapped_type = T;\n     using value_type =\n-        robin_hood::pair<typename std::conditional<IsFlatMap, Key, Key const>::type, T>;\n+        std::pair<typename std::conditional<IsFlatMap, Key, Key const>::type, T>;\n     using size_type = size_t;\n     using hasher = Hash;\n     using key_equal = KeyEqual;\n@@ -1827,9 +1729,9 @@ using unordered_node_map = detail::unordered_map<false, MaxLoadFactor100, Key, T\n template <typename Key, typename T, typename Hash,\n           typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n using unordered_map =\n-    detail::unordered_map<sizeof(robin_hood::pair<Key, T>) <= sizeof(size_t) * 6 &&\n-                              std::is_nothrow_move_constructible<robin_hood::pair<Key, T>>::value &&\n-                              std::is_nothrow_move_assignable<robin_hood::pair<Key, T>>::value,\n+    detail::unordered_map<sizeof(std::pair<Key, T>) <= sizeof(size_t) * 6 &&\n+                              std::is_nothrow_move_constructible<std::pair<Key, T>>::value &&\n+                              std::is_nothrow_move_assignable<std::pair<Key, T>>::value,\n                           MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n \n } // namespace robin_hood"
      }
    ]
  },
  {
    "sha": "25274b69e6174c2d5c338a0140e7a0367305325a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNTI3NGI2OWU2MTc0YzJkNWMzMzhhMDE0MGU3YTAzNjczMDUzMjVh",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-09-01T17:46:10Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-09-01T17:46:10Z"
      },
      "message": "[robinhood] remove Cloner and Destroyer for flatmaps",
      "tree": {
        "sha": "97bda11b585851fd100329a21ceb00110b3012b3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/97bda11b585851fd100329a21ceb00110b3012b3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/25274b69e6174c2d5c338a0140e7a0367305325a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25274b69e6174c2d5c338a0140e7a0367305325a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/25274b69e6174c2d5c338a0140e7a0367305325a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25274b69e6174c2d5c338a0140e7a0367305325a/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7915fb73d35d6c21802db0c22e07bfbeafbde0fc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7915fb73d35d6c21802db0c22e07bfbeafbde0fc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7915fb73d35d6c21802db0c22e07bfbeafbde0fc"
      }
    ],
    "stats": {
      "total": 27,
      "additions": 2,
      "deletions": 25
    },
    "files": [
      {
        "sha": "abd9a9c53a05e21ca514cfe1b6b6c9b642287d5a",
        "filename": "src/robin_hood.h",
        "status": "modified",
        "additions": 2,
        "deletions": 25,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/25274b69e6174c2d5c338a0140e7a0367305325a/src/robin_hood.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/25274b69e6174c2d5c338a0140e7a0367305325a/src/robin_hood.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/robin_hood.h?ref=25274b69e6174c2d5c338a0140e7a0367305325a",
        "patch": "@@ -688,18 +688,6 @@ class unordered_map\n     template <typename M, bool UseMemcpy>\n     struct Cloner;\n \n-    // fast path: Just copy data, without allocating anything.\n-    template <typename M>\n-    struct Cloner<M, true> {\n-        void operator()(M const& source, M& target) const {\n-            // std::memcpy(target.mKeyVals, source.mKeyVals,\n-            //             target.calcNumBytesTotal(target.mMask + 1));\n-            auto src = reinterpret_cast<char const*>(source.mKeyVals);\n-            auto tgt = reinterpret_cast<char*>(target.mKeyVals);\n-            std::copy(src, src + target.calcNumBytesTotal(target.mMask + 1), tgt);\n-        }\n-    };\n-\n     template <typename M>\n     struct Cloner<M, false> {\n         void operator()(M const& s, M& t) const {\n@@ -718,17 +706,6 @@ class unordered_map\n     template <typename M, bool IsFlatMapAndTrivial>\n     struct Destroyer {};\n \n-    template <typename M>\n-    struct Destroyer<M, true> {\n-        void nodes(M& m) const noexcept {\n-            m.mNumElements = 0;\n-        }\n-\n-        void nodesDoNotDeallocate(M& m) const noexcept {\n-            m.mNumElements = 0;\n-        }\n-    };\n-\n     template <typename M>\n     struct Destroyer<M, false> {\n         void nodes(M& m) const noexcept {\n@@ -947,7 +924,7 @@ class unordered_map\n     }\n \n     void cloneData(const unordered_map& o) {\n-        Cloner<unordered_map, IsFlatMap && ROBIN_HOOD_IS_TRIVIALLY_COPYABLE(Node)>()(o, *this);\n+        Cloner<unordered_map, false>()(o, *this);\n     }\n \n     // inserts a keyval that is guaranteed to be new, e.g. when the hashmap is resized.\n@@ -1127,7 +1104,7 @@ class unordered_map\n         }\n \n         // clean up old stuff\n-        Destroyer<Self, IsFlatMap && std::is_trivially_destructible<Node>::value>{}.nodes(*this);\n+        Destroyer<Self, false>{}.nodes(*this);\n \n         if (mMask != o.mMask) {\n             // no luck: we don't have the same array size allocated, so we need to realloc."
      }
    ]
  },
  {
    "sha": "8cc7434ec80cc4f40aab6ef77711f017c415a5cc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4Y2M3NDM0ZWM4MGNjNGY0MGFhYjZlZjc3NzExZjAxN2M0MTVhNWNj",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-09-01T17:54:10Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-09-01T17:54:10Z"
      },
      "message": "[robinhood] remove unnecessary constructors, operators",
      "tree": {
        "sha": "c87c498ac89c41b36c0dc740e3f353206cafeb0c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c87c498ac89c41b36c0dc740e3f353206cafeb0c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8cc7434ec80cc4f40aab6ef77711f017c415a5cc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8cc7434ec80cc4f40aab6ef77711f017c415a5cc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8cc7434ec80cc4f40aab6ef77711f017c415a5cc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8cc7434ec80cc4f40aab6ef77711f017c415a5cc/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "25274b69e6174c2d5c338a0140e7a0367305325a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25274b69e6174c2d5c338a0140e7a0367305325a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/25274b69e6174c2d5c338a0140e7a0367305325a"
      }
    ],
    "stats": {
      "total": 124,
      "additions": 0,
      "deletions": 124
    },
    "files": [
      {
        "sha": "f211093c74c5c23eb0509640e00bbfa8369f6ca7",
        "filename": "src/robin_hood.h",
        "status": "modified",
        "additions": 0,
        "deletions": 124,
        "changes": 124,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8cc7434ec80cc4f40aab6ef77711f017c415a5cc/src/robin_hood.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8cc7434ec80cc4f40aab6ef77711f017c415a5cc/src/robin_hood.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/robin_hood.h?ref=8cc7434ec80cc4f40aab6ef77711f017c415a5cc",
        "patch": "@@ -1009,130 +1009,6 @@ class unordered_map\n         insert(initlist.begin(), initlist.end());\n     }\n \n-    unordered_map(unordered_map&& o) noexcept\n-        : Hash(std::move(static_cast<Hash&>(o)))\n-        , KeyEqual(std::move(static_cast<KeyEqual&>(o)))\n-        , DataPool(std::move(static_cast<DataPool&>(o))) {\n-        ROBIN_HOOD_TRACE(this);\n-        if (o.mMask) {\n-            mKeyVals = std::move(o.mKeyVals);\n-            mInfo = std::move(o.mInfo);\n-            mNumElements = std::move(o.mNumElements);\n-            mMask = std::move(o.mMask);\n-            mMaxNumElementsAllowed = std::move(o.mMaxNumElementsAllowed);\n-            mInfoInc = std::move(o.mInfoInc);\n-            mInfoHashShift = std::move(o.mInfoHashShift);\n-            // set other's mask to 0 so its destructor won't do anything\n-            o.init();\n-        }\n-    }\n-\n-    unordered_map& operator=(unordered_map&& o) noexcept {\n-        ROBIN_HOOD_TRACE(this);\n-        if (&o != this) {\n-            if (o.mMask) {\n-                // only move stuff if the other map actually has some data\n-                destroy();\n-                mKeyVals = std::move(o.mKeyVals);\n-                mInfo = std::move(o.mInfo);\n-                mNumElements = std::move(o.mNumElements);\n-                mMask = std::move(o.mMask);\n-                mMaxNumElementsAllowed = std::move(o.mMaxNumElementsAllowed);\n-                mInfoInc = std::move(o.mInfoInc);\n-                mInfoHashShift = std::move(o.mInfoHashShift);\n-                Hash::operator=(std::move(static_cast<Hash&>(o)));\n-                KeyEqual::operator=(std::move(static_cast<KeyEqual&>(o)));\n-                DataPool::operator=(std::move(static_cast<DataPool&>(o)));\n-\n-                o.init();\n-\n-            } else {\n-                // nothing in the other map => just clear us.\n-                clear();\n-            }\n-        }\n-        return *this;\n-    }\n-\n-    unordered_map(const unordered_map& o)\n-        : Hash(static_cast<const Hash&>(o))\n-        , KeyEqual(static_cast<const KeyEqual&>(o))\n-        , DataPool(static_cast<const DataPool&>(o)) {\n-        ROBIN_HOOD_TRACE(this);\n-        if (!o.empty()) {\n-            // not empty: create an exact copy. it is also possible to just iterate through all\n-            // elements and insert them, but copying is probably faster.\n-\n-            mKeyVals = static_cast<Node*>(\n-                detail::assertNotNull<std::bad_alloc>(malloc(calcNumBytesTotal(o.mMask + 1))));\n-            // no need for calloc because clonData does memcpy\n-            mInfo = reinterpret_cast<uint8_t*>(mKeyVals + o.mMask + 1);\n-            mNumElements = o.mNumElements;\n-            mMask = o.mMask;\n-            mMaxNumElementsAllowed = o.mMaxNumElementsAllowed;\n-            mInfoInc = o.mInfoInc;\n-            mInfoHashShift = o.mInfoHashShift;\n-            cloneData(o);\n-        }\n-    }\n-\n-    // Creates a copy of the given map. Copy constructor of each entry is used.\n-    unordered_map& operator=(unordered_map const& o) {\n-        ROBIN_HOOD_TRACE(this);\n-        if (&o == this) {\n-            // prevent assigning of itself\n-            return *this;\n-        }\n-\n-        // we keep using the old allocator and not assign the new one, because we want to keep the\n-        // memory available. when it is the same size.\n-        if (o.empty()) {\n-            if (0 == mMask) {\n-                // nothing to do, we are empty too\n-                return *this;\n-            }\n-\n-            // not empty: destroy what we have there\n-            // clear also resets mInfo to 0, that's sometimes not necessary.\n-            destroy();\n-            init();\n-            Hash::operator=(static_cast<const Hash&>(o));\n-            KeyEqual::operator=(static_cast<const KeyEqual&>(o));\n-            DataPool::operator=(static_cast<DataPool const&>(o));\n-\n-            return *this;\n-        }\n-\n-        // clean up old stuff\n-        Destroyer<Self, false>{}.nodes(*this);\n-\n-        if (mMask != o.mMask) {\n-            // no luck: we don't have the same array size allocated, so we need to realloc.\n-            if (0 != mMask) {\n-                // only deallocate if we actually have data!\n-                free(mKeyVals);\n-            }\n-\n-            mKeyVals = static_cast<Node*>(\n-                detail::assertNotNull<std::bad_alloc>(malloc(calcNumBytesTotal(o.mMask + 1))));\n-\n-            // no need for calloc here because cloneData performs a memcpy.\n-            mInfo = reinterpret_cast<uint8_t*>(mKeyVals + o.mMask + 1);\n-            // sentinel is set in cloneData\n-        }\n-        Hash::operator=(static_cast<const Hash&>(o));\n-        KeyEqual::operator=(static_cast<const KeyEqual&>(o));\n-        DataPool::operator=(static_cast<DataPool const&>(o));\n-        mNumElements = o.mNumElements;\n-        mMask = o.mMask;\n-        mMaxNumElementsAllowed = o.mMaxNumElementsAllowed;\n-        mInfoInc = o.mInfoInc;\n-        mInfoHashShift = o.mInfoHashShift;\n-        cloneData(o);\n-\n-        return *this;\n-    }\n-\n     // Swaps everything between the two maps.\n     void swap(unordered_map& o) {\n         ROBIN_HOOD_TRACE(this);"
      }
    ]
  },
  {
    "sha": "cd43885b99aa20f794100c6ad803c4ee5612b969",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjZDQzODg1Yjk5YWEyMGY3OTQxMDBjNmFkODAzYzRlZTU2MTJiOTY5",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-09-01T18:10:32Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-09-01T18:10:32Z"
      },
      "message": "[robinhood] remove all references to IsFlatMap",
      "tree": {
        "sha": "162baabee386114fed7ad0a2fd0068938a7c23b4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/162baabee386114fed7ad0a2fd0068938a7c23b4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cd43885b99aa20f794100c6ad803c4ee5612b969",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cd43885b99aa20f794100c6ad803c4ee5612b969",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cd43885b99aa20f794100c6ad803c4ee5612b969",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cd43885b99aa20f794100c6ad803c4ee5612b969/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8cc7434ec80cc4f40aab6ef77711f017c415a5cc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8cc7434ec80cc4f40aab6ef77711f017c415a5cc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8cc7434ec80cc4f40aab6ef77711f017c415a5cc"
      }
    ],
    "stats": {
      "total": 52,
      "additions": 9,
      "deletions": 43
    },
    "files": [
      {
        "sha": "bab2ad8a2a243d6f1b580367082f80991da51ec0",
        "filename": "src/robin_hood.h",
        "status": "modified",
        "additions": 9,
        "deletions": 43,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cd43885b99aa20f794100c6ad803c4ee5612b969/src/robin_hood.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cd43885b99aa20f794100c6ad803c4ee5612b969/src/robin_hood.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/robin_hood.h?ref=cd43885b99aa20f794100c6ad803c4ee5612b969",
        "patch": "@@ -503,22 +503,6 @@ class BulkPoolAllocator {\n     T** mListForFree{nullptr};\n };\n \n-template <typename T, size_t MinSize, size_t MaxSize, bool IsFlatMap>\n-struct NodeAllocator;\n-\n-// dummy allocator that does nothing\n-template <typename T, size_t MinSize, size_t MaxSize>\n-struct NodeAllocator<T, MinSize, MaxSize, true> {\n-\n-    // we are not using the data, so just free it.\n-    void addOrFree(void* ptr, size_t ROBIN_HOOD_UNUSED(numBytes) /*unused*/) noexcept {\n-        free(ptr);\n-    }\n-};\n-\n-template <typename T, size_t MinSize, size_t MaxSize>\n-struct NodeAllocator<T, MinSize, MaxSize, false> : public BulkPoolAllocator<T, MinSize, MaxSize> {};\n-\n // dummy hash, unsed as mixer when robin_hood::hash is already used\n template <typename T>\n struct identity_hash {\n@@ -571,25 +555,21 @@ namespace detail {\n // According to STL, order of templates has effect on throughput. That's why I've moved the boolean\n // to the front.\n // https://www.reddit.com/r/cpp/comments/ahp6iu/compile_time_binary_size_reductions_and_cs_future/eeguck4/\n-template <bool IsFlatMap, size_t MaxLoadFactor100, typename Key, typename T, typename Hash,\n+template <size_t MaxLoadFactor100, typename Key, typename T, typename Hash,\n           typename KeyEqual>\n class unordered_map\n     : public Hash,\n       public KeyEqual,\n-      detail::NodeAllocator<\n-          std::pair<typename std::conditional<IsFlatMap, Key, Key const>::type, T>, 4, 16384,\n-          IsFlatMap> {\n+      detail::BulkPoolAllocator<std::pair<Key const, T>, 4, 16384> {\n public:\n     using key_type = Key;\n     using mapped_type = T;\n-    using value_type =\n-        std::pair<typename std::conditional<IsFlatMap, Key, Key const>::type, T>;\n+    using value_type = std::pair<Key const, T>;\n     using size_type = size_t;\n     using hasher = Hash;\n     using key_equal = KeyEqual;\n     using Self =\n-        unordered_map<IsFlatMap, MaxLoadFactor100, key_type, mapped_type, hasher, key_equal>;\n-    static constexpr bool is_flat_map = IsFlatMap;\n+        unordered_map<MaxLoadFactor100, key_type, mapped_type, hasher, key_equal>;\n \n private:\n     static_assert(MaxLoadFactor100 > 10 && MaxLoadFactor100 < 100,\n@@ -602,7 +582,7 @@ class unordered_map\n     static constexpr uint32_t InitialInfoNumBits = 5;\n     static constexpr uint8_t InitialInfoInc = 1U << InitialInfoNumBits;\n     static constexpr uint8_t InitialInfoHashShift = sizeof(size_t) * 8 - InitialInfoNumBits;\n-    using DataPool = detail::NodeAllocator<value_type, 4, 16384, IsFlatMap>;\n+    using DataPool = detail::BulkPoolAllocator<value_type, 4, 16384>;\n \n     // type needs to be wider than uint8_t.\n     //\n@@ -827,8 +807,7 @@ class unordered_map\n             } while (inc == static_cast<int>(sizeof(size_t)));\n         }\n \n-        friend class unordered_map<IsFlatMap, MaxLoadFactor100, key_type, mapped_type, hasher,\n-                                   key_equal>;\n+        friend class unordered_map<MaxLoadFactor100, key_type, mapped_type, hasher, key_equal>;\n         NodePtr mKeyVals{nullptr};\n         uint8_t const* mInfo{nullptr};\n     };\n@@ -1025,7 +1004,7 @@ class unordered_map\n             return;\n         }\n \n-        Destroyer<Self, IsFlatMap && std::is_trivially_destructible<Node>::value>{}.nodes(*this);\n+        Destroyer<Self, false>{}.nodes(*this);\n \n         // clear everything except the sentinel\n         // std::memset(mInfo, 0, sizeof(uint8_t) * (mMask + 1));\n@@ -1543,8 +1522,7 @@ class unordered_map\n             return;\n         }\n \n-        Destroyer<Self, IsFlatMap && std::is_trivially_destructible<Node>::value>{}\n-            .nodesDoNotDeallocate(*this);\n+        Destroyer<Self, false>{}.nodesDoNotDeallocate(*this);\n         free(mKeyVals);\n     }\n \n@@ -1573,19 +1551,7 @@ class unordered_map\n \n template <typename Key, typename T, typename Hash,\n           typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n-using unordered_flat_map = detail::unordered_map<true, MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n-\n-template <typename Key, typename T, typename Hash,\n-          typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n-using unordered_node_map = detail::unordered_map<false, MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n-\n-template <typename Key, typename T, typename Hash,\n-          typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n-using unordered_map =\n-    detail::unordered_map<sizeof(std::pair<Key, T>) <= sizeof(size_t) * 6 &&\n-                              std::is_nothrow_move_constructible<std::pair<Key, T>>::value &&\n-                              std::is_nothrow_move_assignable<std::pair<Key, T>>::value,\n-                          MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n+using unordered_node_map = detail::unordered_map< MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n \n } // namespace robin_hood\n "
      }
    ]
  },
  {
    "sha": "8739248c41f14bfd72aba9c0dc235b86ae7842bf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NzM5MjQ4YzQxZjE0YmZkNzJhYmE5YzBkYzIzNWI4NmFlNzg0MmJm",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-09-01T18:14:00Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-09-01T18:14:00Z"
      },
      "message": "[robinhood] remove integer sequence stuff",
      "tree": {
        "sha": "a15a84ced65404ce3951c57363e09ff7929fecf3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a15a84ced65404ce3951c57363e09ff7929fecf3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8739248c41f14bfd72aba9c0dc235b86ae7842bf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8739248c41f14bfd72aba9c0dc235b86ae7842bf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8739248c41f14bfd72aba9c0dc235b86ae7842bf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8739248c41f14bfd72aba9c0dc235b86ae7842bf/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cd43885b99aa20f794100c6ad803c4ee5612b969",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cd43885b99aa20f794100c6ad803c4ee5612b969",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cd43885b99aa20f794100c6ad803c4ee5612b969"
      }
    ],
    "stats": {
      "total": 60,
      "additions": 0,
      "deletions": 60
    },
    "files": [
      {
        "sha": "22c8a050ca7544d4659c142279751b34d54b4d75",
        "filename": "src/robin_hood.h",
        "status": "modified",
        "additions": 0,
        "deletions": 60,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8739248c41f14bfd72aba9c0dc235b86ae7842bf/src/robin_hood.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8739248c41f14bfd72aba9c0dc235b86ae7842bf/src/robin_hood.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/robin_hood.h?ref=8739248c41f14bfd72aba9c0dc235b86ae7842bf",
        "patch": "@@ -187,66 +187,6 @@ template <class T>\n struct alignment_of\n     : std::integral_constant<std::size_t, alignof(typename std::remove_all_extents<T>::type)> {};\n \n-template <class T, T... Ints>\n-class integer_sequence {\n-public:\n-    using value_type = T;\n-    static_assert(std::is_integral<value_type>::value, \"not integral type\");\n-    static constexpr std::size_t size() noexcept {\n-        return sizeof...(Ints);\n-    }\n-};\n-template <std::size_t... Inds>\n-using index_sequence = integer_sequence<std::size_t, Inds...>;\n-\n-namespace detail_ {\n-template <class T, T Begin, T End, bool>\n-struct IntSeqImpl {\n-    using TValue = T;\n-    static_assert(std::is_integral<TValue>::value, \"not integral type\");\n-    static_assert(Begin >= 0 && Begin < End, \"unexpected argument (Begin<0 || Begin<=End)\");\n-\n-    template <class, class>\n-    struct IntSeqCombiner;\n-\n-    template <TValue... Inds0, TValue... Inds1>\n-    struct IntSeqCombiner<integer_sequence<TValue, Inds0...>, integer_sequence<TValue, Inds1...>> {\n-        using TResult = integer_sequence<TValue, Inds0..., Inds1...>;\n-    };\n-\n-    using TResult =\n-        typename IntSeqCombiner<typename IntSeqImpl<TValue, Begin, Begin + (End - Begin) / 2,\n-                                                    (End - Begin) / 2 == 1>::TResult,\n-                                typename IntSeqImpl<TValue, Begin + (End - Begin) / 2, End,\n-                                                    (End - Begin + 1) / 2 == 1>::TResult>::TResult;\n-};\n-\n-template <class T, T Begin>\n-struct IntSeqImpl<T, Begin, Begin, false> {\n-    using TValue = T;\n-    static_assert(std::is_integral<TValue>::value, \"not integral type\");\n-    static_assert(Begin >= 0, \"unexpected argument (Begin<0)\");\n-    using TResult = integer_sequence<TValue>;\n-};\n-\n-template <class T, T Begin, T End>\n-struct IntSeqImpl<T, Begin, End, true> {\n-    using TValue = T;\n-    static_assert(std::is_integral<TValue>::value, \"not integral type\");\n-    static_assert(Begin >= 0, \"unexpected argument (Begin<0)\");\n-    using TResult = integer_sequence<TValue, Begin>;\n-};\n-} // namespace detail_\n-\n-template <class T, T N>\n-using make_integer_sequence = typename detail_::IntSeqImpl<T, 0, N, (N - 0) == 1>::TResult;\n-\n-template <std::size_t N>\n-using make_index_sequence = make_integer_sequence<std::size_t, N>;\n-\n-template <class... T>\n-using index_sequence_for = make_index_sequence<sizeof...(T)>;\n-\n } // namespace ROBIN_HOOD_STD\n \n #endif"
      }
    ]
  }
]