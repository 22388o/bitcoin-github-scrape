promag,2019-08-25 10:09:56,"> including a near-full IBD from the network, to see if these improvements hold.\n\nYap that would be interesting.\n\n> I'm also interested in benching this along with a similar change to `mapBlockIndex`\n\nI'd be surprised to see such improvements here.\n\n> If we decide to include this or another hashmap implementation, should we do a full fork inclusion a la leveldb or should we try to ",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-524617555,524617555,
DrahtBot,2019-08-25 12:07:33,"<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#16910](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/16910.html) (wallet: reduce loading time by using unorde",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-524624890,524624890,
practicalswift,2019-08-25 12:09:56,"@jamesob Interesting! Thanks for providing benchmarks!\n\nWhich implementation of `std::unordered_map` did you benchmark against?\n\nIt would be interesting to see this benchmarked against the three major implementations of `std::unordered_map` (`libstdc++`, `libc++` and Microsoft STL).",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-524625051,524625051,
jamesob,2019-08-25 14:46:26,"> Which implementation of std::unordered_map did you benchmark against?\n\nI've been benching on Ubuntu and Debian systems with `libstdc++` (x86_64, glibc6).",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-524635914,524635914,
fanquake,2019-08-26 02:58:01,"> I try swapping out std::unordered_map for a faster third-party implementation where it matters, see something like 15% speedup for initial block download coincident with a 19.3% reduction in memory usage.\n\nNice. This is the kind of PR I enjoy reading / reviewing / testing.\n\nI did a basic benchmark on my macOS machine: `time src/bitcoind -stopatheight=350000`.\n\n#16718 6f9882ce4a817c9f",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-524697360,524697360,
jamesob,2019-08-26 16:23:58,"Some additional context from further benchmarking:\n\n### Local tests\n\nI did a local IBD (not real network) comparison up to height 510,000. We see a speedup of roughly 17% coupled with memory savings of roughly 13.5%.\n\nGiven the vertical shift in real memory usage curve on the robinhood branch (pictured below), I suspect there's a problem with my implementation of the `DynamicUsage()` m",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-524927442,524927442,
jamesob,2019-08-27 03:19:06,"Consider my enthusiasm renewed because the latest ""real"" IBD runs came back showing a hard-to-believe 40% speedup. Sync to 550,000 on different machines but identical hardware. Still a 12% memory savings.\n\nObviously it's hard to gauge variance when syncing from the real network.\n\n### `2019-08-robinhood`\n\n![Selection_149](https://user-images.githubusercontent.com/73197/63738371-8a544800",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525119421,525119421,
JeremyRubin,2019-08-27 04:25:54,"Concept ack, NACK this implementation. From the docs:\n\n```\nDepends on good Hashing. For a really bad hash the performance will not only degrade like in std::unordered_map, the map will simply fail with an std::overflow_error. In practice, when using the standard robin_hood::hash, I have never seen this happening.\n```\n\nThere are some ways that we could maybe get some better performance ",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525131403,525131403,
jamesob,2019-08-27 16:00:41,"> the map will simply fail with an std::overflow_error\n\nThanks for the close look @JeremyRubin. This is exactly the kind of change I'd be really worried about introducing. The performance difference will have to be really compelling (and verified by a few people aside from myself) to consider using a non-`std` implementation for something as consensus-sensitive as `cacheCoins`.\n\nI wonder i",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525368573,525368573,
jamesob,2019-08-27 16:22:22,"Alternatively, we could look at forking `robin-hood-hashing` and removing all instances of [`throwOverflowError()`](https://github.com/martinus/robin-hood-hashing/blob/master/src/include/robin_hood.h#L1820-L1826) with something more conservative.",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525377566,525377566,
elichai,2019-08-27 16:43:23,"Concept ACK for replacing the hashmap, `std::map` is a disaster. (`std::unordered_map` is a little bit better but still really bad).",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525385497,525385497,
JeremyRubin,2019-08-27 17:26:46,"@jamesob maybe have a look at the experimental rust fork?\n\nYou could just wrap the rust hasmap (with at least rust v1.35 or use hashbrown crate). Rust's hashmap is based on swisstable.\n\nReplacing sensitive data structures with rust seems like a good use case given long term goals, and can be used for low resource nodes experimentally?",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525402401,525402401,
elichai,2019-08-27 17:34:57,"@jeremyrubin\nI just had a talk with him about this,\nPersonally I'd love to see rust inside of bitcoin, but I'm not sure a hashmap is the best first step as integrating rust and c++ requires a C ABI in between. \n\nI do hope I'll have time to test the C++ SwissTable implementation and compare benchmarks https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525405561,525405561,
jamesob,2019-08-27 17:43:10,"I agree with @elichai - I think adding Rust as a dependency for one of the most consensus-sensitive data structures is way too big a leap. A few extra thousand lines of heavily-scrutinized cpp is about the biggest risk I'm willing to take personally, and that's assuming a ton of review, testing, and maybe a gradual deployment process.",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525408692,525408692,
elichai,2019-08-27 19:56:52,"1. Would love a quick explanation on how to run all these benchmarks myself (so I can get both a control before changing and after).\n\n2. Why did you choose `unordered_node_map` and not `unordered_flat_map`?.\n\n3. Do you think it would be interesting in the future for other uses of `std::unordered_map` in the code? (and potentially even `std::map`)",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525458164,525458164,
jamesob,2019-08-27 20:13:11,"> Would love a quick explanation on how to run all these benchmarks myself (so I can get both a control before changing and after).\n\nYou can use [bitcoinperf](https://github.com/chaincodelabs/bitcoinperf) to perform the host-local comparative benchmarks I've posted above. I've committed an example file for this branch [here](https://github.com/chaincodelabs/bitcoinperf/blob/master/examples/rob",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525464014,525464014,
elichai,2019-08-27 20:18:31,"Sounds good :) Thanks! \nI'll try also to benchmark myself, curious the difference between `unordered_node_map` and  `unordered_flat_map` over unique pointers.",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525465933,525465933,
JeremyRubin,2019-08-27 22:25:55,"Ok I've had a chance to more tightly review the code here. I didn't want to say so earlier, because I wasn't sure, but I think it *should* be possible to modify the cuckoocache code minimally to support cacheCoins (store a key/value and (maybe) get rid of atomics for erasure).\n\nI can put together a PoC of that... there are some other benefits as CuckooCache is specifically a cache and not a ma",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525507057,525507057,
jamesob,2019-08-28 13:47:40,"Latest round of benchmarks are in from two dedicated bench machines with identical specs (Intel(R) Xeon(R) CPU E3-1220 v5 @ 3.00GHz, 8GB memory, SSD).\n\nFirst I reran the last test I reported above (`/usr/bin/time -v ./src/bitcoind -stopatheight=550000 -dbcache=5000`) to ensure I could recreate the results. To my surprise, they held (**40% speedup, 13% memory savings**). To ensure that the wide",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525753125,525753125,
jamesob,2019-08-28 13:57:04,"> I think it should be possible to modify the cuckoocache code minimally to support cacheCoins\n\n@JeremyRubin I'd be very eager to see your PoC for this. In principle I strongly agree that if we can modify existing consensus-supporting data structures and see similar performance benefits, that's the way to go. \n\n> CuckooCache is specifically a cache and not a map being used as a cache\n\n",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525757222,525757222,
Sjors,2019-08-28 16:20:33,"Concept ACK for improving  `std::unordered_map` behavior or swapping it for an alternative if the improvement is >10%. It's nice how this only changes 1 line in `coins.h`.\n\nI'm able to reproduce the memory gain, but the speed is actually worse for me, on a 2019 MacBook Pro with `-dbcache=10000`, no indexes and no wallets, syncing over LAN to a single node:\n* IBD before: 3:35 hours plus 11 mi",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525818499,525818499,
martinus,2019-08-28 16:22:09,"Hi all! I am the author of the the `robin_hood::unordered_map` variants, and just saw this PR by accident. Please ask away if you have any question about my implementation! \n\nI have also done extensive map benchmarks here, which might be interesting: https://github.com/martinus/map_benchmark\n\nI agree with @JeremyRubin that the `throwOverflowError()` is a potential problem, if there is a wa",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525819075,525819075,
elichai,2019-08-28 16:59:28,"@martinus would love to see some list of projects you know are depending and using your implementation :)\n\nI think if people would feel this is a stable and vetted implementation they would feel better about considering using it in consensus critical code.\nThanks :)",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525832792,525832792,
martinus,2019-08-28 17:41:51,"@elichai, we have been using the map in several core components in [Dynatrace's](https://www.dynatrace.com) proprietary monitoring platform for quite a while. That's a very well tested and widely deployed product on multiple platforms (I work at dynatrace so I might be biased..).\n\nI don't know much about other use cases. Here is a github query tough to find other uses of the map: https://githu",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525848503,525848503,
MarcoFalke,2019-08-28 17:51:33,"Are there any benchmarks on low cpu, low memory devices. Given that this slows down IBD for @Sjors  (https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525818499), I wouldn't be surprised if it also slowed down other architectures/configurations.",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525852488,525852488,
laanwj,2019-08-28 18:37:26,"The speed-ups are promising, it's surprising to me that this makes so much of a difference,\n\nBut to me it sounds quite risky, to be honest, to import a custom map implementation into consensus-critical code. Of course, we can never be sure, but likely these have much less testing than whatever tried-and-true map implementation comes with C++ libraries by default.\n\n(Importing rust code for ",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525870177,525870177,
TheBlueMatt,2019-08-28 18:56:43,"Right, pulling in Rust for something like this is way too early/aggressive. I'm curious if its possible to get similar speedups by taking a hatchet to robinhood so that we can cut it down to something thats more reviewable, since obviously thats the key criteria.",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525877289,525877289,
martinus,2019-08-28 18:59:11,"It would be very interesting where exactly the speedup is coming from. It might be possible to reproduce this speedup by staying with `std::unordered_map`. E.g. I see two possibilities for improvement:\n\n* robin_hood map requires less hashing and less key comparisons than std::unordered_map. It might be possible to save a lot of hashing & comparisons by simply adding the precalculated hash valu",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525878177,525878177,
jamesob,2019-08-28 19:03:37,"First `-reindex-chainstate` bench finished: ~~46.7%~~ 2.14x faster with 1173 MB less memory usage.\n\nmaster (a7be1cc92be4946c4f042bccd3a1b007657f3241):\n\n```\nuser@bench-ssd-4:~/bitcoin$ /usr/bin/time -v ./src/bitcoind -reindex-chainstate -stopatheight=550000 -printtoconsole=0 -dbcache=5000; git branch\n\n        Command being timed: ""./src/bitcoind -reindex-chainstate -stopatheight=55000",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525879711,525879711,
jamesob,2019-08-28 19:11:25,"My mistake - that's *2.14x* faster, not 46.7%.",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525882635,525882635,
martinus,2019-08-28 19:19:36,"> master ([a7be1cc](https://github.com/bitcoin/bitcoin/commit/a7be1cc92be4946c4f042bccd3a1b007657f3241)):\n> ```\n>         User time (seconds): 7735.97\n>         Major (requiring I/O) page faults: 15004449\n> ```\n> \n> 2019-08-robinhood:\n> ```\n>         User time (seconds): 5598.92\n>         Major (requiring I/O) page faults: 1684815\n> ```\n\nI find it a bit fishy that the major",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525885509,525885509,
MarcoFalke,2019-08-28 19:22:50,"> we could make its use opt-in via configure flag to allow some hardware-constrained installations to use it\n\nI disagree about a phased out deployment. Either the consensus code is safe to run, correct, and can be deployed to the whole network, or not. There is no in-between. The last thing you want to see happening is that all `arm` (or whatever ""hardware-constrained means) devices are off co",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525886639,525886639,
martinus,2019-08-30 07:26:43,"I've benchmarked `bitcoind -reindex-chainstate -stopatheight=550000 -printtoconsole=0 -dbcache=5000` on my machine (Intel i7-8700, g++ 9.1, libstdc++), and can confirm a significant speedup with @jamesob's changes. For accurate reproducability I have disabled frequency scaling and turbo boost for my cpu (with [sudo pyperf system tune](https://pyperf.readthedocs.io/en/latest/)). Runtime with `std::",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-526491374,526491374,
martinus,2019-08-30 17:21:11,"I have tried to use `boost::pool_allocator` and `boost::fast_pool_allocator` for the `std::unordered_map`, but performance was *much* slower than `std::allocator`.\n\nThen I adapted my [BulkPoolAllocator](https://github.com/martinus/robin-hood-hashing/blob/master/src/include/robin_hood.h#L338) to be usable for the `std::unordered_map`, and results are much better.\n\nBenchmark results for `bit",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-526681466,526681466,
JeremyRubin,2019-08-30 19:02:44,"I think we may also be able to eke out some additional performance by making the keys the sha256 salted hash of the COutpoint rather than the COutpoint itself, and instead of using siphash taking entropy from that salted hash (as done for cuckoocache).\n\n\nAt the expense of one extra sha256 on insert/find (and less siphash), we get to drop 4 of the key bytes and have cheaper hash re-evaluation",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-526713367,526713367,
jamesob,2019-09-03 14:19:56,"Thanks for running those benchmarks, @martinus. I also think we should try calling `cacheCoins.reserve(dbcache / avg_coinscacheentry_size)` somewhere during startup with both implementations to see how that affects things.\n\nOn the chance that we still want to consider using the `robin_hood` map, I've stripped about 500 lines out of `robinhood.h` (mostly relating to `unordered_flat_map` which I",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-527479906,527479906,
MarcoFalke,2019-09-03 14:27:13,Thanks for doing those additional benchmarks @jamesob. I think that confirms the finding by @Sjors that the sync is slowed down with a high dbcache in https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-525818499,https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-527483128,527483128,
jamesob,2019-09-03 15:16:02,"> I think that confirms the finding by @Sjors that the sync is slowed down with a high dbcache in #16718 (comment)\n\nNote though that I differ from Sjors' findings in that this branch was ~2x faster than master for dbcache=7000 (reindex-chainstate), whereas in his results this branch was slower than master for a large dbcache (10000) during IBD. \n\n\nI lightly suspect that @Sjors' slowness ",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-527504979,527504979,
martinus,2019-09-03 18:03:37,"In https://github.com/martinus/bitcoin/tree/2019-08-bulkpoolallocator I'm currently working on a PR where I've extracted (and completely rewrote...) the pool allocator so it is usable in std::unordered_map. Unfortunately the standard allocator API is trickier than I've expected, but I think I got it now. It's performance is still as advertised in https://github.com/bitcoin/bitcoin/pull/16718#issue",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-527571982,527571982,
luke-jr,2019-09-20 21:24:16,"Surprised nobody's pointed out that using `std::unordered_map` basically gives us an *unknown* implementation right now... which probably is best avoided in consensus code, when possible. The fact that we can get performance improvements too really suggests to me that switching to a *specific* implementation would be a good idea. So concept ACK.\n\nAgree with need for intense care and testing to",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-533713536,533713536,
ryanofsky,2019-10-21 19:51:36,"Status of this?\n\n- Does using std::unordered_map with custom allocator https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-527571982 still seem like it could be a good approach?\n\n- Are the code changes in this PR more or less complete, or is there more robinhood code streamlining to be done?\n\n- Are there still concerns about performance will smaller dbcaches and more constrained",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-544678963,544678963,
martinus,2019-10-23 06:32:42,"> Status of this?\n\nI think using a custom allocator from #16801 is a much safer choice than switching to a different map implementation.Writing a correct and fast hashmap is orders of magnitudes more difficult than a custom allocator. This PR was good though that it has highlighted what could be possible. Most of the performance benefit can be achieved with the custom allocator as well \n\nC",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-545290624,545290624,
jamesob,2019-11-14 22:30:08,"Some new (and stabilized) benchmarks here. Following the same methodology  [as in similar PRs](https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-551883348), we see a 6% difference in runtime with ~400MB less memory usage for a reindex up to 550,000 ([`bench/robinhood.1`](https://github.com/jamesob/bitcoin/commits/bench/robinhood.1) vs. [`bench/master.1`](https://github.com/jamesob/bitcoin",https://github.com/bitcoin/bitcoin/pull/16718#issuecomment-554111177,554111177,
martinus,2019-08-28 16:51:36,Be aware that there is a bug in robin_hood map https://github.com/martinus/robin-hood-hashing/issues/42 (as well as in tessil's map https://github.com/Tessil/robin-map/issues/20) where it is possible that entries are iterated over a second time before `end()` is reached.,https://github.com/bitcoin/bitcoin/pull/16718#discussion_r318687135,318687135,src/test/coins_tests.cpp
