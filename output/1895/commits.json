[
  {
    "sha": "8d5f461cb6d4bb954fef5c3deebe2b2a7bdbfe27",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZDVmNDYxY2I2ZDRiYjk1NGZlZjVjM2RlZWJlMmIyYTdiZGJmZTI3",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-10-08T19:18:04Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-10-08T21:25:17Z"
      },
      "message": "Handle incompatible BDB environments\n\nBefore, opening a -datadir that was created with a new\nversion of Berkeley DB would result in an un-caught DB_RUNRECOVERY\nexception.\n\nAfter these changes, the error is caught and the user is told\nthat there is a problem and is told how to try to recover from\nit.",
      "tree": {
        "sha": "a41c410e8fe04edd5e01d714979b1ef09b44cd42",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a41c410e8fe04edd5e01d714979b1ef09b44cd42"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8d5f461cb6d4bb954fef5c3deebe2b2a7bdbfe27",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8d5f461cb6d4bb954fef5c3deebe2b2a7bdbfe27",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8d5f461cb6d4bb954fef5c3deebe2b2a7bdbfe27",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8d5f461cb6d4bb954fef5c3deebe2b2a7bdbfe27/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "43de64949c96b6d708b7d8a82c3dba0f6ddf059e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/43de64949c96b6d708b7d8a82c3dba0f6ddf059e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/43de64949c96b6d708b7d8a82c3dba0f6ddf059e"
      }
    ],
    "stats": {
      "total": 34,
      "additions": 19,
      "deletions": 15
    },
    "files": [
      {
        "sha": "7ca9e349539a00db340a5c61d46ab8705756dd95",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 12,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d5f461cb6d4bb954fef5c3deebe2b2a7bdbfe27/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d5f461cb6d4bb954fef5c3deebe2b2a7bdbfe27/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=8d5f461cb6d4bb954fef5c3deebe2b2a7bdbfe27",
        "patch": "@@ -34,19 +34,14 @@ void CDBEnv::EnvShutdown()\n         return;\n \n     fDbEnvInit = false;\n-    try\n-    {\n-        dbenv.close(0);\n-    }\n-    catch (const DbException& e)\n-    {\n-        printf(\"EnvShutdown exception: %s (%d)\\n\", e.what(), e.get_errno());\n-    }\n+    int ret = dbenv.close(0);\n+    if (ret != 0)\n+        printf(\"EnvShutdown exception: %s (%d)\\n\", DbEnv::strerror(ret), ret);\n     if (!fMockDb)\n         DbEnv(0).remove(GetDataDir().string().c_str(), 0);\n }\n \n-CDBEnv::CDBEnv() : dbenv(0)\n+CDBEnv::CDBEnv() : dbenv(DB_CXX_NO_EXCEPTIONS)\n {\n }\n \n@@ -100,8 +95,8 @@ bool CDBEnv::Open(boost::filesystem::path pathEnv_)\n                      DB_RECOVER    |\n                      nEnvFlags,\n                      S_IRUSR | S_IWUSR);\n-    if (ret > 0)\n-        return error(\"CDB() : error %d opening database environment\", ret);\n+    if (ret != 0)\n+        return error(\"CDB() : error %s (%d) opening database environment\", DbEnv::strerror(ret), ret);\n \n     fDbEnvInit = true;\n     fMockDb = false;\n@@ -191,7 +186,7 @@ CDB::CDB(const char *pszFile, const char* pszMode) :\n                             nFlags,    // Flags\n                             0);\n \n-            if (ret > 0)\n+            if (ret != 0)\n             {\n                 delete pdb;\n                 pdb = NULL;"
      },
      {
        "sha": "d271893644891f10984910684d8e00020d8676ee",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 3,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d5f461cb6d4bb954fef5c3deebe2b2a7bdbfe27/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d5f461cb6d4bb954fef5c3deebe2b2a7bdbfe27/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=8d5f461cb6d4bb954fef5c3deebe2b2a7bdbfe27",
        "patch": "@@ -439,8 +439,9 @@ bool AppInit2()\n     FILE* file = fopen(pathLockFile.string().c_str(), \"a\"); // empty lock file; created if it doesn't exist.\n     if (file) fclose(file);\n     static boost::interprocess::file_lock lock(pathLockFile.string().c_str());\n+    const char* pszDataDir = GetDataDir().string().c_str();\n     if (!lock.try_lock())\n-        return InitError(strprintf(_(\"Cannot obtain a lock on data directory %s.  Bitcoin is probably already running.\"), GetDataDir().string().c_str()));\n+        return InitError(strprintf(_(\"Cannot obtain a lock on data directory %s.  Bitcoin is probably already running.\"), pszDataDir));\n \n #if !defined(WIN32) && !defined(QT_GUI)\n     if (fDaemon)\n@@ -472,7 +473,7 @@ bool AppInit2()\n     if (!fLogTimestamps)\n         printf(\"Startup time: %s\\n\", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n     printf(\"Default data directory %s\\n\", GetDefaultDataDir().string().c_str());\n-    printf(\"Used data directory %s\\n\", GetDataDir().string().c_str());\n+    printf(\"Used data directory %s\\n\", pszDataDir);\n     std::ostringstream strErrors;\n \n     if (fDaemon)\n@@ -588,6 +589,14 @@ bool AppInit2()\n \n     // ********************************************************* Step 6: load blockchain\n \n+    if (!bitdb.Open(GetDataDir()))\n+    {\n+        string msg = strprintf(_(\"Error initializing database environment %s!\"\n+                                 \" To recover, BACKUP THAT DIRECTORY, then remove\"\n+                                 \" everything from it except for wallet.dat.\"), pszDataDir);\n+        return InitError(msg);\n+    }\n+\n     if (GetBoolArg(\"-loadblockindextest\"))\n     {\n         CTxDB txdb(\"r\");\n@@ -600,7 +609,7 @@ bool AppInit2()\n     printf(\"Loading block index...\\n\");\n     nStart = GetTimeMillis();\n     if (!LoadBlockIndex())\n-        strErrors << _(\"Error loading blkindex.dat\") << \"\\n\";\n+        return InitError(_(\"Error loading blkindex.dat\"));\n \n     // as LoadBlockIndex can take several minutes, it's possible the user\n     // requested to kill bitcoin-qt during the last operation. If so, exit."
      }
    ]
  },
  {
    "sha": "eed1785f701be93ac2464e854c2a7de1f748ef84",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZWQxNzg1ZjcwMWJlOTNhYzI0NjRlODU0YzJhN2RlMWY3NDhlZjg0",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-09-18T18:30:47Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-10-08T21:46:45Z"
      },
      "message": "Handle corrupt wallets gracefully.\n\nCorrupt wallets used to cause a DB_RUNRECOVERY uncaught exception and a\ncrash. This commit does three things:\n\n1) Runs a BDB verify early in the startup process, and if there is a\nlow-level problem with the database:\n  + Moves the bad wallet.dat to wallet.timestamp.bak\n  + Runs a 'salvage' operation to get key/value pairs, and\n    writes them to a new wallet.dat\n  + Continues with startup.\n\n2) Much more tolerant of serialization errors. All errors in deserialization\nare reported by tolerated EXCEPT for errors related to reading keypairs\nor master key records-- those are reported and then shut down, so the user\ncan get help (or recover from a backup).\n\n3) Adds a new -salvagewallet option, which:\n + Moves the wallet.dat to wallet.timestamp.bak\n + extracts ONLY keypairs and master keys into a new wallet.dat\n + soft-sets -rescan, to recreate transaction history\n\nThis was tested by randomly corrupting testnet wallets using a little\npython script I wrote (https://gist.github.com/3812689)",
      "tree": {
        "sha": "012b0bae35dfc7f35c10d341e50dd31fb88c6cf1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/012b0bae35dfc7f35c10d341e50dd31fb88c6cf1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eed1785f701be93ac2464e854c2a7de1f748ef84",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eed1785f701be93ac2464e854c2a7de1f748ef84",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/eed1785f701be93ac2464e854c2a7de1f748ef84",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eed1785f701be93ac2464e854c2a7de1f748ef84/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8d5f461cb6d4bb954fef5c3deebe2b2a7bdbfe27",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8d5f461cb6d4bb954fef5c3deebe2b2a7bdbfe27",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8d5f461cb6d4bb954fef5c3deebe2b2a7bdbfe27"
      }
    ],
    "stats": {
      "total": 731,
      "additions": 518,
      "deletions": 213
    },
    "files": [
      {
        "sha": "9ad67892f1e83a001816e994004ffd0efd11715e",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 72,
        "deletions": 0,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eed1785f701be93ac2464e854c2a7de1f748ef84/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eed1785f701be93ac2464e854c2a7de1f748ef84/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=eed1785f701be93ac2464e854c2a7de1f748ef84",
        "patch": "@@ -136,6 +136,69 @@ void CDBEnv::MakeMock()\n     fMockDb = true;\n }\n \n+CDBEnv::VerifyResult CDBEnv::Verify(std::string strFile, bool (*recoverFunc)(CDBEnv& dbenv, std::string strFile))\n+{\n+    LOCK(cs_db);\n+    assert(mapFileUseCount.count(strFile) == 0);\n+\n+    Db db(&dbenv, 0);\n+    int result = db.verify(strFile.c_str(), NULL, NULL, 0);\n+    if (result == 0)\n+        return VERIFY_OK;\n+    else if (recoverFunc == NULL)\n+        return RECOVER_FAIL;\n+\n+    // Try to recover:\n+    bool fRecovered = (*recoverFunc)(*this, strFile);\n+    return (fRecovered ? RECOVER_OK : RECOVER_FAIL);\n+}\n+\n+bool CDBEnv::Salvage(std::string strFile, bool fAggressive,\n+                     std::vector<CDBEnv::KeyValPair >& vResult)\n+{\n+    LOCK(cs_db);\n+    assert(mapFileUseCount.count(strFile) == 0);\n+\n+    u_int32_t flags = DB_SALVAGE;\n+    if (fAggressive) flags |= DB_AGGRESSIVE;\n+\n+    stringstream strDump;\n+\n+    Db db(&dbenv, 0);\n+    int result = db.verify(strFile.c_str(), NULL, &strDump, flags);\n+    if (result != 0)\n+    {\n+        printf(\"ERROR: db salvage failed\\n\");\n+        return false;\n+    }\n+\n+    // Format of bdb dump is ascii lines:\n+    // header lines...\n+    // HEADER=END\n+    // hexadecimal key\n+    // hexadecimal value\n+    // ... repeated\n+    // DATA=END\n+\n+    string strLine;\n+    while (!strDump.eof() && strLine != \"HEADER=END\")\n+        getline(strDump, strLine); // Skip past header\n+\n+    std::string keyHex, valueHex;\n+    while (!strDump.eof() && keyHex != \"DATA=END\")\n+    {\n+        getline(strDump, keyHex);\n+        if (keyHex != \"DATA_END\")\n+        {\n+            getline(strDump, valueHex);\n+            vResult.push_back(make_pair(ParseHex(keyHex),ParseHex(valueHex)));\n+        }\n+    }\n+\n+    return (result == 0);\n+}\n+\n+\n void CDBEnv::CheckpointLSN(std::string strFile)\n {\n     dbenv.txn_checkpoint(0, 0, 0);\n@@ -257,6 +320,15 @@ void CDBEnv::CloseDb(const string& strFile)\n     }\n }\n \n+bool CDBEnv::RemoveDb(const string& strFile)\n+{\n+    this->CloseDb(strFile);\n+\n+    LOCK(cs_db);\n+    int rc = dbenv.dbremove(NULL, strFile.c_str(), NULL, DB_AUTO_COMMIT);\n+    return (rc == 0);\n+}\n+\n bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n {\n     while (!fShutdown)"
      },
      {
        "sha": "798913645f622f9217739c18a2156259418d9d56",
        "filename": "src/db.h",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eed1785f701be93ac2464e854c2a7de1f748ef84/src/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eed1785f701be93ac2464e854c2a7de1f748ef84/src/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.h?ref=eed1785f701be93ac2464e854c2a7de1f748ef84",
        "patch": "@@ -50,6 +50,25 @@ class CDBEnv\n     ~CDBEnv();\n     void MakeMock();\n     bool IsMock() { return fMockDb; };\n+\n+    /*\n+     * Verify that database file strFile is OK. If it is not,\n+     * call the callback to try to recover.\n+     * This must be called BEFORE strFile is opened.\n+     * Returns true if strFile is OK.\n+     */\n+    enum VerifyResult { VERIFY_OK, RECOVER_OK, RECOVER_FAIL };\n+    VerifyResult Verify(std::string strFile, bool (*recoverFunc)(CDBEnv& dbenv, std::string strFile));\n+    /*\n+     * Salvage data from a file that Verify says is bad.\n+     * fAggressive sets the DB_AGGRESSIVE flag (see berkeley DB->verify() method documentation).\n+     * Appends binary key/value pairs to vResult, returns true if successful.\n+     * NOTE: reads the entire database into memory, so cannot be used\n+     * for huge databases.\n+     */\n+    typedef std::pair<std::vector<unsigned char>, std::vector<unsigned char> > KeyValPair;\n+    bool Salvage(std::string strFile, bool fAggressive, std::vector<KeyValPair>& vResult);\n+\n     bool Open(boost::filesystem::path pathEnv_);\n     void Close();\n     void Flush(bool fShutdown);\n@@ -58,6 +77,7 @@ class CDBEnv\n     bool GetDetach() { return fDetachDB; }\n \n     void CloseDb(const std::string& strFile);\n+    bool RemoveDb(const std::string& strFile);\n \n     DbTxn *TxnBegin(int flags=DB_TXN_WRITE_NOSYNC)\n     {"
      },
      {
        "sha": "480d65422ccaa04b0dcdfc6b712ddb6d1dfa6f5f",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 18,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eed1785f701be93ac2464e854c2a7de1f748ef84/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eed1785f701be93ac2464e854c2a7de1f748ef84/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=eed1785f701be93ac2464e854c2a7de1f748ef84",
        "patch": "@@ -279,6 +279,7 @@ std::string HelpMessage()\n         \"  -upgradewallet         \" + _(\"Upgrade wallet to latest format\") + \"\\n\" +\n         \"  -keypool=<n>           \" + _(\"Set key pool size to <n> (default: 100)\") + \"\\n\" +\n         \"  -rescan                \" + _(\"Rescan the block chain for missing wallet transactions\") + \"\\n\" +\n+        \"  -salvagewallet         \" + _(\"Attempt to recover private keys from a corrupt wallet.dat\") + \"\\n\" +\n         \"  -checkblocks=<n>       \" + _(\"How many blocks to check at startup (default: 2500, 0 = all)\") + \"\\n\" +\n         \"  -checklevel=<n>        \" + _(\"How thorough the block verification is (0-6, default: 1)\") + \"\\n\" +\n         \"  -loadblock=<file>      \" + _(\"Imports blocks from external blk000?.dat file\") + \"\\n\" +\n@@ -379,6 +380,11 @@ bool AppInit2()\n         SoftSetBoolArg(\"-discover\", false);\n     }\n \n+    if (GetBoolArg(\"-salvagewallet\")) {\n+        // Rewrite just private keys: rescan to find transactions\n+        SoftSetBoolArg(\"-rescan\", true);\n+    }\n+\n     // ********************************************************* Step 3: parameter-to-internal-flags\n \n     fDebug = GetBoolArg(\"-debug\");\n@@ -434,12 +440,13 @@ bool AppInit2()\n \n     // ********************************************************* Step 4: application initialization: dir lock, daemonize, pidfile, debug log\n \n+    const char* pszDataDir = GetDataDir().string().c_str();\n+\n     // Make sure only a single Bitcoin process is using the data directory.\n     boost::filesystem::path pathLockFile = GetDataDir() / \".lock\";\n     FILE* file = fopen(pathLockFile.string().c_str(), \"a\"); // empty lock file; created if it doesn't exist.\n     if (file) fclose(file);\n     static boost::interprocess::file_lock lock(pathLockFile.string().c_str());\n-    const char* pszDataDir = GetDataDir().string().c_str();\n     if (!lock.try_lock())\n         return InitError(strprintf(_(\"Cannot obtain a lock on data directory %s.  Bitcoin is probably already running.\"), pszDataDir));\n \n@@ -481,7 +488,38 @@ bool AppInit2()\n \n     int64 nStart;\n \n-    // ********************************************************* Step 5: network initialization\n+    // ********************************************************* Step 5: verify database integrity\n+\n+    uiInterface.InitMessage(_(\"Verifying database integrity...\"));\n+\n+    if (!bitdb.Open(GetDataDir()))\n+    {\n+        string msg = strprintf(_(\"Error initializing database environment %s!\"\n+                                 \" To recover, BACKUP THAT DIRECTORY, then remove\"\n+                                 \" everything from it except for wallet.dat.\"), pszDataDir);\n+        return InitError(msg);\n+    }\n+\n+    if (GetBoolArg(\"-salvagewallet\"))\n+    {\n+        // Recover readable keypairs:\n+        if (!CWalletDB::Recover(bitdb, \"wallet.dat\", true))\n+            return false;\n+    }\n+\n+    CDBEnv::VerifyResult r = bitdb.Verify(\"wallet.dat\", CWalletDB::Recover);\n+    if (r == CDBEnv::RECOVER_OK)\n+    {\n+        string msg = strprintf(_(\"Warning: wallet.dat corrupt, data salvaged!\"\n+                                 \" Original wallet.dat saved as wallet.{timestamp}.bak in %s; if\"\n+                                 \" your balance or transactions are incorrect you should\"\n+                                 \" restore from a backup.\"), pszDataDir);\n+        uiInterface.ThreadSafeMessageBox(msg, _(\"Bitcoin\"), CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n+    }\n+    if (r == CDBEnv::RECOVER_FAIL)\n+        return InitError(_(\"wallet.dat corrupt, salvage failed\"));\n+\n+    // ********************************************************* Step 6: network initialization\n \n     int nSocksVersion = GetArg(\"-socks\", 5);\n \n@@ -587,15 +625,7 @@ bool AppInit2()\n     BOOST_FOREACH(string strDest, mapMultiArgs[\"-seednode\"])\n         AddOneShot(strDest);\n \n-    // ********************************************************* Step 6: load blockchain\n-\n-    if (!bitdb.Open(GetDataDir()))\n-    {\n-        string msg = strprintf(_(\"Error initializing database environment %s!\"\n-                                 \" To recover, BACKUP THAT DIRECTORY, then remove\"\n-                                 \" everything from it except for wallet.dat.\"), pszDataDir);\n-        return InitError(msg);\n-    }\n+    // ********************************************************* Step 7: load blockchain\n \n     if (GetBoolArg(\"-loadblockindextest\"))\n     {\n@@ -650,18 +680,24 @@ bool AppInit2()\n         return false;\n     }\n \n-    // ********************************************************* Step 7: load wallet\n+    // ********************************************************* Step 8: load wallet\n \n     uiInterface.InitMessage(_(\"Loading wallet...\"));\n     printf(\"Loading wallet...\\n\");\n     nStart = GetTimeMillis();\n     bool fFirstRun = true;\n     pwalletMain = new CWallet(\"wallet.dat\");\n-    int nLoadWalletRet = pwalletMain->LoadWallet(fFirstRun);\n+    DBErrors nLoadWalletRet = pwalletMain->LoadWallet(fFirstRun);\n     if (nLoadWalletRet != DB_LOAD_OK)\n     {\n         if (nLoadWalletRet == DB_CORRUPT)\n             strErrors << _(\"Error loading wallet.dat: Wallet corrupted\") << \"\\n\";\n+        else if (nLoadWalletRet == DB_NONCRITICAL_ERROR)\n+        {\n+            string msg(_(\"Warning: error reading wallet.dat! All keys read correctly, but transaction data\"\n+                         \" or address book entries might be missing or incorrect.\"));\n+            uiInterface.ThreadSafeMessageBox(msg, _(\"Bitcoin\"), CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n+        }\n         else if (nLoadWalletRet == DB_TOO_NEW)\n             strErrors << _(\"Error loading wallet.dat: Wallet requires newer version of Bitcoin\") << \"\\n\";\n         else if (nLoadWalletRet == DB_NEED_REWRITE)\n@@ -727,7 +763,7 @@ bool AppInit2()\n         printf(\" rescan      %15\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n     }\n \n-    // ********************************************************* Step 8: import blocks\n+    // ********************************************************* Step 9: import blocks\n \n     if (mapArgs.count(\"-loadblock\"))\n     {\n@@ -753,7 +789,7 @@ bool AppInit2()\n         }\n     }\n \n-    // ********************************************************* Step 9: load peers\n+    // ********************************************************* Step 10: load peers\n \n     uiInterface.InitMessage(_(\"Loading addresses...\"));\n     printf(\"Loading addresses...\\n\");\n@@ -768,7 +804,7 @@ bool AppInit2()\n     printf(\"Loaded %i addresses from peers.dat  %\"PRI64d\"ms\\n\",\n            addrman.size(), GetTimeMillis() - nStart);\n \n-    // ********************************************************* Step 10: start node\n+    // ********************************************************* Step 11: start node\n \n     if (!CheckDiskSpace())\n         return false;\n@@ -788,7 +824,7 @@ bool AppInit2()\n     if (fServer)\n         NewThread(ThreadRPCServer, NULL);\n \n-    // ********************************************************* Step 11: finished\n+    // ********************************************************* Step 12: finished\n \n     uiInterface.InitMessage(_(\"Done loading\"));\n     printf(\"Done loading\\n\");\n@@ -808,4 +844,3 @@ bool AppInit2()\n \n     return true;\n }\n-"
      },
      {
        "sha": "23f315203ecc068ab11dea59c9935849bcc0d539",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 10,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eed1785f701be93ac2464e854c2a7de1f748ef84/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eed1785f701be93ac2464e854c2a7de1f748ef84/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=eed1785f701be93ac2464e854c2a7de1f748ef84",
        "patch": "@@ -186,10 +186,24 @@ void CKey::MakeNewKey(bool fCompressed)\n bool CKey::SetPrivKey(const CPrivKey& vchPrivKey)\n {\n     const unsigned char* pbegin = &vchPrivKey[0];\n-    if (!d2i_ECPrivateKey(&pkey, &pbegin, vchPrivKey.size()))\n-        return false;\n-    fSet = true;\n-    return true;\n+    if (d2i_ECPrivateKey(&pkey, &pbegin, vchPrivKey.size()))\n+    {\n+        // In testing, d2i_ECPrivateKey can return true\n+        // but fill in pkey with a key that fails\n+        // EC_KEY_check_key, so:\n+        if (EC_KEY_check_key(pkey))\n+        {\n+            fSet = true;\n+            return true;\n+        }\n+    }\n+    // If vchPrivKey data is bad d2i_ECPrivateKey() can\n+    // leave pkey in a state where calling EC_KEY_free()\n+    // crashes. To avoid that, set pkey to NULL and\n+    // leak the memory (a leak is better than a crash)\n+    pkey = NULL;\n+    Reset();\n+    return false;\n }\n \n bool CKey::SetSecret(const CSecret& vchSecret, bool fCompressed)\n@@ -245,12 +259,16 @@ CPrivKey CKey::GetPrivKey() const\n bool CKey::SetPubKey(const CPubKey& vchPubKey)\n {\n     const unsigned char* pbegin = &vchPubKey.vchPubKey[0];\n-    if (!o2i_ECPublicKey(&pkey, &pbegin, vchPubKey.vchPubKey.size()))\n-        return false;\n-    fSet = true;\n-    if (vchPubKey.vchPubKey.size() == 33)\n-        SetCompressedPubKey();\n-    return true;\n+    if (o2i_ECPublicKey(&pkey, &pbegin, vchPubKey.vchPubKey.size()))\n+    {\n+        fSet = true;\n+        if (vchPubKey.vchPubKey.size() == 33)\n+            SetCompressedPubKey();\n+        return true;\n+    }\n+    pkey = NULL;\n+    Reset();\n+    return false;\n }\n \n CPubKey CKey::GetPubKey() const\n@@ -377,6 +395,9 @@ bool CKey::IsValid()\n     if (!fSet)\n         return false;\n \n+    if (!EC_KEY_check_key(pkey))\n+        return false;\n+\n     bool fCompr;\n     CSecret secret = GetSecret(fCompr);\n     CKey key2;"
      },
      {
        "sha": "1a6a1082b1d846c6634bf0a65a8a99a01bacb794",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eed1785f701be93ac2464e854c2a7de1f748ef84/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eed1785f701be93ac2464e854c2a7de1f748ef84/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=eed1785f701be93ac2464e854c2a7de1f748ef84",
        "patch": "@@ -335,7 +335,9 @@ void CWallet::WalletUpdateSpent(const CTransaction &tx)\n             if (mi != mapWallet.end())\n             {\n                 CWalletTx& wtx = (*mi).second;\n-                if (!wtx.IsSpent(txin.prevout.n) && IsMine(wtx.vout[txin.prevout.n]))\n+                if (txin.prevout.n >= wtx.vout.size())\n+                    printf(\"WalletUpdateSpent: bad wtx %s\\n\", wtx.GetHash().ToString().c_str());\n+                else if (!wtx.IsSpent(txin.prevout.n) && IsMine(wtx.vout[txin.prevout.n]))\n                 {\n                     printf(\"WalletUpdateSpent found spent coin %sbc %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n                     wtx.MarkSpent(txin.prevout.n);\n@@ -1371,12 +1373,12 @@ string CWallet::SendMoneyToDestination(const CTxDestination& address, int64 nVal\n \n \n \n-int CWallet::LoadWallet(bool& fFirstRunRet)\n+DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n {\n     if (!fFileBacked)\n         return DB_LOAD_OK;\n     fFirstRunRet = false;\n-    int nLoadWalletRet = CWalletDB(strWalletFile,\"cr+\").LoadWallet(this);\n+    DBErrors nLoadWalletRet = CWalletDB(strWalletFile,\"cr+\").LoadWallet(this);\n     if (nLoadWalletRet == DB_NEED_REWRITE)\n     {\n         if (CDB::Rewrite(strWalletFile, \"\\x04pool\"))"
      },
      {
        "sha": "c5f1243907d744db65d4a5ed2dde6385af3b4288",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eed1785f701be93ac2464e854c2a7de1f748ef84/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eed1785f701be93ac2464e854c2a7de1f748ef84/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=eed1785f701be93ac2464e854c2a7de1f748ef84",
        "patch": "@@ -16,11 +16,11 @@\n #include \"script.h\"\n #include \"ui_interface.h\"\n #include \"util.h\"\n+#include \"walletdb.h\"\n \n class CAccountingEntry;\n class CWalletTx;\n class CReserveKey;\n-class CWalletDB;\n class COutput;\n \n /** (client) version numbers for particular wallet features */\n@@ -256,7 +256,7 @@ class CWallet : public CCryptoKeyStore\n     }\n     void SetBestChain(const CBlockLocator& loc);\n \n-    int LoadWallet(bool& fFirstRunRet);\n+    DBErrors LoadWallet(bool& fFirstRunRet);\n \n     bool SetAddressBookName(const CTxDestination& address, const std::string& strName);\n "
      },
      {
        "sha": "e102df97201992fe21960bc3e83b490080ef4c3c",
        "filename": "src/walletdb.cpp",
        "status": "modified",
        "additions": 330,
        "deletions": 178,
        "changes": 508,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eed1785f701be93ac2464e854c2a7de1f748ef84/src/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eed1785f701be93ac2464e854c2a7de1f748ef84/src/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.cpp?ref=eed1785f701be93ac2464e854c2a7de1f748ef84",
        "patch": "@@ -108,7 +108,7 @@ void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountin\n }\n \n \n-int\n+DBErrors\n CWalletDB::ReorderTransactions(CWallet* pwallet)\n {\n     LOCK(pwallet->cs_wallet);\n@@ -181,16 +181,221 @@ CWalletDB::ReorderTransactions(CWallet* pwallet)\n }\n \n \n-int CWalletDB::LoadWallet(CWallet* pwallet)\n+bool\n+ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n+             int& nFileVersion, vector<uint256>& vWalletUpgrade,\n+             bool& fIsEncrypted,  bool& fAnyUnordered, string& strType, string& strErr)\n+{\n+    try {\n+        // Unserialize\n+        // Taking advantage of the fact that pair serialization\n+        // is just the two items serialized one after the other\n+        ssKey >> strType;\n+        if (strType == \"name\")\n+        {\n+            string strAddress;\n+            ssKey >> strAddress;\n+            ssValue >> pwallet->mapAddressBook[CBitcoinAddress(strAddress).Get()];\n+        }\n+        else if (strType == \"tx\")\n+        {\n+            uint256 hash;\n+            ssKey >> hash;\n+            CWalletTx& wtx = pwallet->mapWallet[hash];\n+            ssValue >> wtx;\n+            if (wtx.CheckTransaction() && (wtx.GetHash() == hash))\n+                wtx.BindWallet(pwallet);\n+            else\n+            {\n+                pwallet->mapWallet.erase(hash);\n+                return false;\n+            }\n+\n+            // Undo serialize changes in 31600\n+            if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n+            {\n+                if (!ssValue.empty())\n+                {\n+                    char fTmp;\n+                    char fUnused;\n+                    ssValue >> fTmp >> fUnused >> wtx.strFromAccount;\n+                    strErr = strprintf(\"LoadWallet() upgrading tx ver=%d %d '%s' %s\",\n+                                       wtx.fTimeReceivedIsTxTime, fTmp, wtx.strFromAccount.c_str(), hash.ToString().c_str());\n+                    wtx.fTimeReceivedIsTxTime = fTmp;\n+                }\n+                else\n+                {\n+                    strErr = strprintf(\"LoadWallet() repairing tx ver=%d %s\", wtx.fTimeReceivedIsTxTime, hash.ToString().c_str());\n+                    wtx.fTimeReceivedIsTxTime = 0;\n+                }\n+                vWalletUpgrade.push_back(hash);\n+            }\n+\n+            if (wtx.nOrderPos == -1)\n+                fAnyUnordered = true;\n+\n+            //// debug print\n+            //printf(\"LoadWallet  %s\\n\", wtx.GetHash().ToString().c_str());\n+            //printf(\" %12\"PRI64d\"  %s  %s  %s\\n\",\n+            //    wtx.vout[0].nValue,\n+            //    DateTimeStrFormat(\"%x %H:%M:%S\", wtx.GetBlockTime()).c_str(),\n+            //    wtx.hashBlock.ToString().substr(0,20).c_str(),\n+            //    wtx.mapValue[\"message\"].c_str());\n+        }\n+        else if (strType == \"acentry\")\n+        {\n+            string strAccount;\n+            ssKey >> strAccount;\n+            uint64 nNumber;\n+            ssKey >> nNumber;\n+            if (nNumber > nAccountingEntryNumber)\n+                nAccountingEntryNumber = nNumber;\n+\n+            if (!fAnyUnordered)\n+            {\n+                CAccountingEntry acentry;\n+                ssValue >> acentry;\n+                if (acentry.nOrderPos == -1)\n+                    fAnyUnordered = true;\n+            }\n+        }\n+        else if (strType == \"key\" || strType == \"wkey\")\n+        {\n+            vector<unsigned char> vchPubKey;\n+            ssKey >> vchPubKey;\n+            CKey key;\n+            if (strType == \"key\")\n+            {\n+                CPrivKey pkey;\n+                ssValue >> pkey;\n+                key.SetPubKey(vchPubKey);\n+                if (!key.SetPrivKey(pkey))\n+                {\n+                    strErr = \"Error reading wallet database: CPrivKey corrupt\";\n+                    return false;\n+                }\n+                if (key.GetPubKey() != vchPubKey)\n+                {\n+                    strErr = \"Error reading wallet database: CPrivKey pubkey inconsistency\";\n+                    return false;\n+                }\n+                if (!key.IsValid())\n+                {\n+                    strErr = \"Error reading wallet database: invalid CPrivKey\";\n+                    return false;\n+                }\n+            }\n+            else\n+            {\n+                CWalletKey wkey;\n+                ssValue >> wkey;\n+                key.SetPubKey(vchPubKey);\n+                if (!key.SetPrivKey(wkey.vchPrivKey))\n+                {\n+                    strErr = \"Error reading wallet database: CPrivKey corrupt\";\n+                    return false;\n+                }\n+                if (key.GetPubKey() != vchPubKey)\n+                {\n+                    strErr = \"Error reading wallet database: CWalletKey pubkey inconsistency\";\n+                    return false;\n+                }\n+                if (!key.IsValid())\n+                {\n+                    strErr = \"Error reading wallet database: invalid CWalletKey\";\n+                    return false;\n+                }\n+            }\n+            if (!pwallet->LoadKey(key))\n+            {\n+                strErr = \"Error reading wallet database: LoadKey failed\";\n+                return false;\n+            }\n+        }\n+        else if (strType == \"mkey\")\n+        {\n+            unsigned int nID;\n+            ssKey >> nID;\n+            CMasterKey kMasterKey;\n+            ssValue >> kMasterKey;\n+            if(pwallet->mapMasterKeys.count(nID) != 0)\n+            {\n+                strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n+                return false;\n+            }\n+            pwallet->mapMasterKeys[nID] = kMasterKey;\n+            if (pwallet->nMasterKeyMaxID < nID)\n+                pwallet->nMasterKeyMaxID = nID;\n+        }\n+        else if (strType == \"ckey\")\n+        {\n+            vector<unsigned char> vchPubKey;\n+            ssKey >> vchPubKey;\n+            vector<unsigned char> vchPrivKey;\n+            ssValue >> vchPrivKey;\n+            if (!pwallet->LoadCryptedKey(vchPubKey, vchPrivKey))\n+            {\n+                strErr = \"Error reading wallet database: LoadCryptedKey failed\";\n+                return false;\n+            }\n+            fIsEncrypted = true;\n+        }\n+        else if (strType == \"defaultkey\")\n+        {\n+            ssValue >> pwallet->vchDefaultKey;\n+        }\n+        else if (strType == \"pool\")\n+        {\n+            int64 nIndex;\n+            ssKey >> nIndex;\n+            pwallet->setKeyPool.insert(nIndex);\n+        }\n+        else if (strType == \"version\")\n+        {\n+            ssValue >> nFileVersion;\n+            if (nFileVersion == 10300)\n+                nFileVersion = 300;\n+        }\n+        else if (strType == \"cscript\")\n+        {\n+            uint160 hash;\n+            ssKey >> hash;\n+            CScript script;\n+            ssValue >> script;\n+            if (!pwallet->LoadCScript(script))\n+            {\n+                strErr = \"Error reading wallet database: LoadCScript failed\";\n+                return false;\n+            }\n+        }\n+        else if (strType == \"orderposnext\")\n+        {\n+            ssValue >> pwallet->nOrderPosNext;\n+        }\n+    } catch (...)\n+    {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+static bool IsKeyType(string strType)\n+{\n+    return (strType== \"key\" || strType == \"wkey\" ||\n+            strType == \"mkey\" || strType == \"ckey\");\n+}\n+\n+DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n {\n     pwallet->vchDefaultKey = CPubKey();\n     int nFileVersion = 0;\n     vector<uint256> vWalletUpgrade;\n     bool fIsEncrypted = false;\n     bool fAnyUnordered = false;\n+    bool fNoncriticalErrors = false;\n+    DBErrors result = DB_LOAD_OK;\n \n-    //// todo: shouldn't we catch exceptions and try to recover and continue?\n-    {\n+    try {\n         LOCK(pwallet->cs_wallet);\n         int nMinVersion = 0;\n         if (Read((string)\"minversion\", nMinVersion))\n@@ -222,189 +427,46 @@ int CWalletDB::LoadWallet(CWallet* pwallet)\n                 return DB_CORRUPT;\n             }\n \n-            // Unserialize\n-            // Taking advantage of the fact that pair serialization\n-            // is just the two items serialized one after the other\n-            string strType;\n-            ssKey >> strType;\n-            if (strType == \"name\")\n-            {\n-                string strAddress;\n-                ssKey >> strAddress;\n-                ssValue >> pwallet->mapAddressBook[CBitcoinAddress(strAddress).Get()];\n-            }\n-            else if (strType == \"tx\")\n-            {\n-                uint256 hash;\n-                ssKey >> hash;\n-                CWalletTx& wtx = pwallet->mapWallet[hash];\n-                ssValue >> wtx;\n-                wtx.BindWallet(pwallet);\n-\n-                if (wtx.GetHash() != hash)\n-                    printf(\"Error in wallet.dat, hash mismatch\\n\");\n-\n-                // Undo serialize changes in 31600\n-                if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n-                {\n-                    if (!ssValue.empty())\n-                    {\n-                        char fTmp;\n-                        char fUnused;\n-                        ssValue >> fTmp >> fUnused >> wtx.strFromAccount;\n-                        printf(\"LoadWallet() upgrading tx ver=%d %d '%s' %s\\n\", wtx.fTimeReceivedIsTxTime, fTmp, wtx.strFromAccount.c_str(), hash.ToString().c_str());\n-                        wtx.fTimeReceivedIsTxTime = fTmp;\n-                    }\n-                    else\n-                    {\n-                        printf(\"LoadWallet() repairing tx ver=%d %s\\n\", wtx.fTimeReceivedIsTxTime, hash.ToString().c_str());\n-                        wtx.fTimeReceivedIsTxTime = 0;\n-                    }\n-                    vWalletUpgrade.push_back(hash);\n-                }\n-\n-                if (wtx.nOrderPos == -1)\n-                    fAnyUnordered = true;\n-\n-                //// debug print\n-                //printf(\"LoadWallet  %s\\n\", wtx.GetHash().ToString().c_str());\n-                //printf(\" %12\"PRI64d\"  %s  %s  %s\\n\",\n-                //    wtx.vout[0].nValue,\n-                //    DateTimeStrFormat(\"%x %H:%M:%S\", wtx.GetBlockTime()).c_str(),\n-                //    wtx.hashBlock.ToString().substr(0,20).c_str(),\n-                //    wtx.mapValue[\"message\"].c_str());\n-            }\n-            else if (strType == \"acentry\")\n+            // Try to be tolerant of single corrupt records:\n+            string strType, strErr;\n+            if (!ReadKeyValue(pwallet, ssKey, ssValue, nFileVersion,\n+                              vWalletUpgrade, fIsEncrypted, fAnyUnordered, strType, strErr))\n             {\n-                string strAccount;\n-                ssKey >> strAccount;\n-                uint64 nNumber;\n-                ssKey >> nNumber;\n-                if (nNumber > nAccountingEntryNumber)\n-                    nAccountingEntryNumber = nNumber;\n-\n-                if (!fAnyUnordered)\n-                {\n-                    CAccountingEntry acentry;\n-                    ssValue >> acentry;\n-                    if (acentry.nOrderPos == -1)\n-                        fAnyUnordered = true;\n-                }\n-            }\n-            else if (strType == \"key\" || strType == \"wkey\")\n-            {\n-                vector<unsigned char> vchPubKey;\n-                ssKey >> vchPubKey;\n-                CKey key;\n-                if (strType == \"key\")\n-                {\n-                    CPrivKey pkey;\n-                    ssValue >> pkey;\n-                    key.SetPubKey(vchPubKey);\n-                    key.SetPrivKey(pkey);\n-                    if (key.GetPubKey() != vchPubKey)\n-                    {\n-                        printf(\"Error reading wallet database: CPrivKey pubkey inconsistency\\n\");\n-                        return DB_CORRUPT;\n-                    }\n-                    if (!key.IsValid())\n-                    {\n-                        printf(\"Error reading wallet database: invalid CPrivKey\\n\");\n-                        return DB_CORRUPT;\n-                    }\n-                }\n+                // losing keys is considered a catastrophic error, anything else\n+                // we assume the user can live with:\n+                if (IsKeyType(strType))\n+                    result = DB_CORRUPT;\n                 else\n                 {\n-                    CWalletKey wkey;\n-                    ssValue >> wkey;\n-                    key.SetPubKey(vchPubKey);\n-                    key.SetPrivKey(wkey.vchPrivKey);\n-                    if (key.GetPubKey() != vchPubKey)\n-                    {\n-                        printf(\"Error reading wallet database: CWalletKey pubkey inconsistency\\n\");\n-                        return DB_CORRUPT;\n-                    }\n-                    if (!key.IsValid())\n-                    {\n-                        printf(\"Error reading wallet database: invalid CWalletKey\\n\");\n-                        return DB_CORRUPT;\n-                    }\n-                }\n-                if (!pwallet->LoadKey(key))\n-                {\n-                    printf(\"Error reading wallet database: LoadKey failed\\n\");\n-                    return DB_CORRUPT;\n-                }\n-            }\n-            else if (strType == \"mkey\")\n-            {\n-                unsigned int nID;\n-                ssKey >> nID;\n-                CMasterKey kMasterKey;\n-                ssValue >> kMasterKey;\n-                if(pwallet->mapMasterKeys.count(nID) != 0)\n-                {\n-                    printf(\"Error reading wallet database: duplicate CMasterKey id %u\\n\", nID);\n-                    return DB_CORRUPT;\n-                }\n-                pwallet->mapMasterKeys[nID] = kMasterKey;\n-                if (pwallet->nMasterKeyMaxID < nID)\n-                    pwallet->nMasterKeyMaxID = nID;\n-            }\n-            else if (strType == \"ckey\")\n-            {\n-                vector<unsigned char> vchPubKey;\n-                ssKey >> vchPubKey;\n-                vector<unsigned char> vchPrivKey;\n-                ssValue >> vchPrivKey;\n-                if (!pwallet->LoadCryptedKey(vchPubKey, vchPrivKey))\n-                {\n-                    printf(\"Error reading wallet database: LoadCryptedKey failed\\n\");\n-                    return DB_CORRUPT;\n+                    // Leave other errors alone, if we try to fix them we might make things worse.\n+                    fNoncriticalErrors = true; // ... but do warn the user there is something wrong.\n+                    if (strType == \"tx\")\n+                        // Rescan if there is a bad transaction record:\n+                        SoftSetBoolArg(\"-rescan\", true);\n                 }\n-                fIsEncrypted = true;\n-            }\n-            else if (strType == \"defaultkey\")\n-            {\n-                ssValue >> pwallet->vchDefaultKey;\n-            }\n-            else if (strType == \"pool\")\n-            {\n-                int64 nIndex;\n-                ssKey >> nIndex;\n-                pwallet->setKeyPool.insert(nIndex);\n-            }\n-            else if (strType == \"version\")\n-            {\n-                ssValue >> nFileVersion;\n-                if (nFileVersion == 10300)\n-                    nFileVersion = 300;\n-            }\n-            else if (strType == \"cscript\")\n-            {\n-                uint160 hash;\n-                ssKey >> hash;\n-                CScript script;\n-                ssValue >> script;\n-                if (!pwallet->LoadCScript(script))\n-                {\n-                    printf(\"Error reading wallet database: LoadCScript failed\\n\");\n-                    return DB_CORRUPT;\n-                }\n-            }\n-            else if (strType == \"orderposnext\")\n-            {\n-                ssValue >> pwallet->nOrderPosNext;\n             }\n+            if (!strErr.empty())\n+                printf(\"%s\\n\", strErr.c_str());\n         }\n         pcursor->close();\n     }\n+    catch (...)\n+    {\n+        result = DB_CORRUPT;\n+    }\n \n-    BOOST_FOREACH(uint256 hash, vWalletUpgrade)\n-        WriteTx(hash, pwallet->mapWallet[hash]);\n+    if (fNoncriticalErrors && result == DB_LOAD_OK)\n+        result = DB_NONCRITICAL_ERROR;\n+\n+    // Any wallet corruption at all: skip any rewriting or\n+    // upgrading, we don't want to make it worse.\n+    if (result != DB_LOAD_OK)\n+        return result;\n \n     printf(\"nFileVersion = %d\\n\", nFileVersion);\n \n+    BOOST_FOREACH(uint256 hash, vWalletUpgrade)\n+        WriteTx(hash, pwallet->mapWallet[hash]);\n \n     // Rewrite encrypted wallets of versions 0.4.0 and 0.5.0rc:\n     if (fIsEncrypted && (nFileVersion == 40000 || nFileVersion == 50000))\n@@ -414,10 +476,9 @@ int CWalletDB::LoadWallet(CWallet* pwallet)\n         WriteVersion(CLIENT_VERSION);\n \n     if (fAnyUnordered)\n-        return ReorderTransactions(pwallet);\n+        result = ReorderTransactions(pwallet);\n \n-    // If you add anything else here... be sure to do it if ReorderTransactions returns DB_LOAD_OK too!\n-    return DB_LOAD_OK;\n+    return result;\n }\n \n void ThreadFlushWalletDB(void* parg)\n@@ -521,3 +582,94 @@ bool BackupWallet(const CWallet& wallet, const string& strDest)\n     }\n     return false;\n }\n+\n+//\n+// Try to (very carefully!) recover wallet.dat if there is a problem.\n+//\n+bool CWalletDB::Recover(CDBEnv& dbenv, std::string filename, bool fOnlyKeys)\n+{\n+    // Recovery procedure:\n+    // move wallet.dat to wallet.timestamp.bak\n+    // Call Salvage with fAggressive=true to\n+    // get as much data as possible.\n+    // Rewrite salvaged data to wallet.dat\n+    // Set -rescan so any missing transactions will be\n+    // found.\n+    int64 now = GetTime();\n+    std::string newFilename = strprintf(\"wallet.%\"PRI64d\".bak\", now);\n+\n+    int result = dbenv.dbenv.dbrename(NULL, filename.c_str(), NULL,\n+                                      newFilename.c_str(), DB_AUTO_COMMIT);\n+    if (result == 0)\n+        printf(\"Renamed %s to %s\\n\", filename.c_str(), newFilename.c_str());\n+    else\n+    {\n+        printf(\"Failed to rename %s to %s\\n\", filename.c_str(), newFilename.c_str());\n+        return false;\n+    }\n+\n+    std::vector<CDBEnv::KeyValPair> salvagedData;\n+    bool allOK = dbenv.Salvage(newFilename, true, salvagedData);\n+    if (salvagedData.empty())\n+    {\n+        printf(\"Salvage(aggressive) found no records in %s.\\n\", newFilename.c_str());\n+        return false;\n+    }\n+    printf(\"Salvage(aggressive) found %\"PRIszu\" records\\n\", salvagedData.size());\n+\n+    bool fSuccess = allOK;\n+    Db* pdbCopy = new Db(&dbenv.dbenv, 0);\n+    int ret = pdbCopy->open(NULL,                 // Txn pointer\n+                            filename.c_str(),   // Filename\n+                            \"main\",    // Logical db name\n+                            DB_BTREE,  // Database type\n+                            DB_CREATE,    // Flags\n+                            0);\n+    if (ret > 0)\n+    {\n+        printf(\"Cannot create database file %s\\n\", filename.c_str());\n+        return false;\n+    }\n+    CWallet dummyWallet;\n+    int nFileVersion = 0;\n+    vector<uint256> vWalletUpgrade;\n+    bool fIsEncrypted = false;\n+    bool fAnyUnordered = false;\n+\n+    DbTxn* ptxn = dbenv.TxnBegin();\n+    BOOST_FOREACH(CDBEnv::KeyValPair& row, salvagedData)\n+    {\n+        if (fOnlyKeys)\n+        {\n+            CDataStream ssKey(row.first, SER_DISK, CLIENT_VERSION);\n+            CDataStream ssValue(row.second, SER_DISK, CLIENT_VERSION);\n+            string strType, strErr;\n+            bool fReadOK = ReadKeyValue(&dummyWallet, ssKey, ssValue,\n+                                        nFileVersion, vWalletUpgrade,\n+                                        fIsEncrypted, fAnyUnordered,\n+                                        strType, strErr);\n+            if (!IsKeyType(strType))\n+                continue;\n+            if (!fReadOK)\n+            {\n+                printf(\"WARNING: CWalletDB::Recover skipping %s: %s\\n\", strType.c_str(), strErr.c_str());\n+                continue;\n+            }\n+        }\n+        Dbt datKey(&row.first[0], row.first.size());\n+        Dbt datValue(&row.second[0], row.second.size());\n+        int ret2 = pdbCopy->put(ptxn, &datKey, &datValue, DB_NOOVERWRITE);\n+        if (ret2 > 0)\n+            fSuccess = false;\n+    }\n+    ptxn->commit(0);\n+    pdbCopy->close(0);\n+    delete pdbCopy;\n+\n+    return fSuccess;\n+}\n+\n+bool CWalletDB::Recover(CDBEnv& dbenv, std::string filename)\n+{\n+    return CWalletDB::Recover(dbenv, filename, false);\n+}"
      },
      {
        "sha": "a3e779ab9d196d00c50eff2fa0a266a68d8bc114",
        "filename": "src/walletdb.h",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eed1785f701be93ac2464e854c2a7de1f748ef84/src/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eed1785f701be93ac2464e854c2a7de1f748ef84/src/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.h?ref=eed1785f701be93ac2464e854c2a7de1f748ef84",
        "patch": "@@ -17,6 +17,7 @@ enum DBErrors\n {\n     DB_LOAD_OK,\n     DB_CORRUPT,\n+    DB_NONCRITICAL_ERROR,\n     DB_TOO_NEW,\n     DB_LOAD_FAIL,\n     DB_NEED_REWRITE\n@@ -153,8 +154,10 @@ class CWalletDB : public CDB\n     int64 GetAccountCreditDebit(const std::string& strAccount);\n     void ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& acentries);\n \n-    int ReorderTransactions(CWallet*);\n-    int LoadWallet(CWallet* pwallet);\n+    DBErrors ReorderTransactions(CWallet*);\n+    DBErrors LoadWallet(CWallet* pwallet);\n+    static bool Recover(CDBEnv& dbenv, std::string filename, bool fOnlyKeys);\n+    static bool Recover(CDBEnv& dbenv, std::string filename);\n };\n \n #endif // BITCOIN_WALLETDB_H"
      }
    ]
  },
  {
    "sha": "d0b3e77a084ecffae35961994fc0964b37a79f04",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMGIzZTc3YTA4NGVjZmZhZTM1OTYxOTk0ZmMwOTY0YjM3YTc5ZjA0",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-10-05T23:26:54Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-10-08T21:46:46Z"
      },
      "message": "Don't try to verify a non-existent wallet.dat",
      "tree": {
        "sha": "73277d9f4ba2a55a0ee4a0fa8221279710362af5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/73277d9f4ba2a55a0ee4a0fa8221279710362af5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d0b3e77a084ecffae35961994fc0964b37a79f04",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0b3e77a084ecffae35961994fc0964b37a79f04",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d0b3e77a084ecffae35961994fc0964b37a79f04",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0b3e77a084ecffae35961994fc0964b37a79f04/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "eed1785f701be93ac2464e854c2a7de1f748ef84",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eed1785f701be93ac2464e854c2a7de1f748ef84",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/eed1785f701be93ac2464e854c2a7de1f748ef84"
      }
    ],
    "stats": {
      "total": 23,
      "additions": 13,
      "deletions": 10
    },
    "files": [
      {
        "sha": "2141e196a0e416e34ba9ba41a4f32290f550a405",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 10,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0b3e77a084ecffae35961994fc0964b37a79f04/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0b3e77a084ecffae35961994fc0964b37a79f04/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=d0b3e77a084ecffae35961994fc0964b37a79f04",
        "patch": "@@ -507,17 +507,20 @@ bool AppInit2()\n             return false;\n     }\n \n-    CDBEnv::VerifyResult r = bitdb.Verify(\"wallet.dat\", CWalletDB::Recover);\n-    if (r == CDBEnv::RECOVER_OK)\n+    if (filesystem::exists(GetDataDir() / \"wallet.dat\"))\n     {\n-        string msg = strprintf(_(\"Warning: wallet.dat corrupt, data salvaged!\"\n-                                 \" Original wallet.dat saved as wallet.{timestamp}.bak in %s; if\"\n-                                 \" your balance or transactions are incorrect you should\"\n-                                 \" restore from a backup.\"), pszDataDir);\n-        uiInterface.ThreadSafeMessageBox(msg, _(\"Bitcoin\"), CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n-    }\n-    if (r == CDBEnv::RECOVER_FAIL)\n-        return InitError(_(\"wallet.dat corrupt, salvage failed\"));\n+        CDBEnv::VerifyResult r = bitdb.Verify(\"wallet.dat\", CWalletDB::Recover);\n+        if (r == CDBEnv::RECOVER_OK)\n+        {\n+            string msg = strprintf(_(\"Warning: wallet.dat corrupt, data salvaged!\"\n+                                     \" Original wallet.dat saved as wallet.{timestamp}.bak in %s; if\"\n+                                     \" your balance or transactions are incorrect you should\"\n+                                     \" restore from a backup.\"), pszDataDir);\n+            uiInterface.ThreadSafeMessageBox(msg, _(\"Bitcoin\"), CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n+        }\n+        if (r == CDBEnv::RECOVER_FAIL)\n+            return InitError(_(\"wallet.dat corrupt, salvage failed\"));\n+    }\n \n     // ********************************************************* Step 6: network initialization\n "
      }
    ]
  }
]