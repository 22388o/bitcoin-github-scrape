gmaxwell,2014-11-26T00:34:46Z,@TheBlueMatt ping\n,https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-64496962,64496962,
sipa,2014-11-26T00:53:59Z,"I worry about the increased block access, and the resulting 100 extra blocks that can't be pruned.\n\nIsn't it easier to just allow immature spends in the mempool? Typically in a reorganization, after the disconnect, a reconnect follows that will make most of the removed transaction in the mempool valid again anyway.\n",https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-64498717,64498717,
TheBlueMatt,2014-11-26T09:26:06Z,"Yes, there are several ways to fix this, and this one was discussed a bit. However, I'd highly prefer to hit coinsdb for this as inputs to mempool txn are likely to be cached anyway, which is preferable to hitting disk for a second block. (this also has potentially significant implications for pruning, as you now need to keep 100 extra blocks for any given reorg depth).\n\nAlso, could you include ",https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-64536058,64536058,
TheBlueMatt,2014-11-26T09:27:05Z,"@sipa Yes, if it weren't for your invalidateblock/reconsiderblock RPC additions then we could just only run check() after reorgs instead of during and all would be OK.\n",https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-64536176,64536176,
gavinandresen,2014-11-26T10:57:13Z,"@sipa : a re-org happens on the main network on average once or twice a day. Extra block access is really NOT an issue.\n\nRE: not being able to prune to less than 100+plausible-re-org-depth: I'm OK with 120 being the minimum number of blocks a pruning node needs to keep. If we REALLY want to support pruning down lower, then storing the hash of the coinbase transactions in the block indices would ",https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-64546854,64546854,
sipa,2014-11-26T11:04:39Z,I'm worried about the extra block propagation latency of reorgs. Not about\nkilling people's disks.\n,https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-64547661,64547661,
sipa,2014-11-26T11:05:55Z,"And the requirement in the pruning code is already limited to 1 or 2 days,\nif I recall correctly. Whatever we are or were comfortable with, this adds\nanother 100 nonprunable blocks.\n",https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-64547807,64547807,
gavinandresen,2014-11-26T11:07:43Z,"Idea for if we decide to care about resurrecting coinbase spends that are invalidated during a re-org but become valid when it is finished:\n\nMove the coinbase spends to the orphan transaction list instead of dropping them. And add code when extending the tip to look for any ""now mature"" coinbase spends in mapOrphans, and move them to the mempool.\n\n(but I still don't think we need to care about",https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-64548017,64548017,
sipa,2014-11-26T16:05:04Z,"Well, I definitely prefer having a fix than not having one, and pruning isn't exactly a blocker right now.\n\nGiven that this also adds a test to detect the incorrect behaviour, I think we should merge it, and work on better solutions later.\n",https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-64667968,64667968,
sipa,2014-11-26T16:07:00Z,"Also, can you rebase on top of the new #5316?\n",https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-64668290,64668290,
TheBlueMatt,2014-11-27T01:25:05Z,"re: minimum block count for pruning: you really need to have enough blocks to make human-timescale-fixes possible (ie I'd say a week of blocks, at least, ie 1008 blocks), and while an extra 100 blocks isnt a huge deal to me either, going from 1000 to 1100 is not a trivial difference, though I'm not sure who it'd effect practically.\n\nAnyway, I'll try to find some time this week to figure out why ",https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-64734242,64734242,
gavinandresen,2014-11-28T16:40:59Z,"RE: requiring 100 MORE blocks when pruned:\n\nI must be missing something, I don't understand why this would be number pruned PLUS 100 more blocks, rather than just ""at least 100 most-recent blocks plus plausible re-org depth must be maintained"").\n\nCan @sipa or @TheBlueMatt explain why you're thinking this means pruning needs 100 more blocks than it would without this?\n",https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-64911803,64911803,
sipa,2014-11-28T16:45:26Z,"Say you want to be sure you can reorg 111 blocks back, so down to height-111. This code here will fail if it can't read block B-100 if B is being reorged, so to reorg down to height-111, you need to have block height-211 available. Thus, you can only prune up to block height-211 rather than height-111.\n",https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-64912199,64912199,
gavinandresen,2014-11-28T17:19:17Z,"@sipa: ok, misunderstanding was that anybody would think that a 100+ block re-org was plausible, or would want to plan for a multi-hundred-block re-org. We're saying the same thing, I just think it is silly to think that if a 100+ blockchain re-org happens having your mempool messed up will be an issue anybody cares about.\n",https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-64914998,64914998,
TheBlueMatt,2014-11-28T17:28:16Z,"A 100+ block reorg isnt the issue, but /any/ reorg will require an extra 100 blocks to complete. As mentioned above in this thread, with pruning, its important to maintain enough reorg-able blocks to allow for human-scale issues (ie when there's an issue, we need to be able to get miners to upgrade and ensure people will eventually reorg to the best chain, ala the bdb locks fork)...Even ignoring t",https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-64915665,64915665,
TheBlueMatt,2014-11-28T18:46:42Z,"There appears to be some misunderstanding here...I bring up the issue of hitting disk only as a way to say that I dont think #5267 is going to perform any worse than this in most cases, which it appears to at first glance, not because I'm necessarily concerned about relay times across nodes or anything like that (we have better solutions to that problem already). My point is more that I see #5267 ",https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-64920769,64920769,
gavinandresen,2014-12-02T19:23:52Z,"Fixed off-by-one error found by @TheBlueMatt, and now includes his ""Make CTxMemPool::check more thorough"" commit.\n\nAnd rebased.\n",https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-65288180,65288180,
sipa,2014-12-03T16:09:30Z,"utACK. I believe the code and solution here are correct, assuming the block 100 back can be correctly read.\n\nI would still prefer a solution that does not rely on that assumption, but that can be done later.\n",https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-65435503,65435503,
TheBlueMatt,2014-12-04T09:21:24Z,@sipa: HUH? Why should it be done later? Do you have any specific objections to #5267?\n,https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-65556547,65556547,
sipa,2014-12-04T11:23:35Z,@TheBlueMatt I have one objection against it: it isn't passing Travis. \n,https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-65618486,65618486,
gavinandresen,2014-12-04T14:58:47Z,ReadFromDisk(block-100) failure will now state.abort().\n\nAnd picked the push_front versus back nit pointed out by @TheBlueMatt .\n,https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-65643488,65643488,
laanwj,2014-12-04T15:32:30Z,Tested ACK (for 0.10) commithash cdc176bfc94dd7ff2ff5ad398d03b2b69f71abdb ([signature](https://dev.visucore.com/bitcoin/acks/5386))\n,https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-65649076,65649076,
laanwj,2014-12-11T14:27:01Z,"Merged #5267 instead, to have one fix in. If it turns out that this solution was better we can change it again.\n",https://github.com/bitcoin/bitcoin/pull/5368#issuecomment-66625524,66625524,
laanwj,2014-12-04T08:46:17Z,Isn't it a fatal error if this ReadBlockFromDisk fails?\n,https://github.com/bitcoin/bitcoin/pull/5368#discussion_r21291693,21291693,src/main.cpp
TheBlueMatt,2014-12-04T11:14:48Z,"To mimic the old behavior, you actually need to push_back here. Though, again, I dont think this code is even necessary.\n",https://github.com/bitcoin/bitcoin/pull/5368#discussion_r21298378,21298378,src/txmempool.cpp
gavinandresen,2014-12-04T14:42:16Z,"Very good question, the answer isn't obvious to me.\n\nreturn state.Abort() if block-100 couldn't be read would be trivial, but it seems a shame to get stuck on a bad fork if you can't read block-100 because your disk went bad.  Although I suppose if your disk is going bad you want to know sooner rather than later. \n\nA safe alternative would be to mempool.clear() if this read fails.\n",https://github.com/bitcoin/bitcoin/pull/5368#discussion_r21307336,21307336,src/main.cpp
laanwj,2014-12-04T14:53:28Z,"I think stopping the node (with a state.Abort) is the acceptable when expected information cannot be read from disk. It means something is wrong on a lower level than we can handle.\nOn the other hand you're right that the mempool is not ciritical, and clearing it would be enough to get past this with consistent state.\n",https://github.com/bitcoin/bitcoin/pull/5368#discussion_r21308048,21308048,src/main.cpp
