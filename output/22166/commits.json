[
  {
    "sha": "29e5dd1a5b9a1879e6c3c7e153b2e6f33a79e905",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyOWU1ZGQxYTViOWExODc5ZTZjM2M3ZTE1M2IyZTZmMzNhNzllOTA1",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-06-05T22:29:04Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-06-18T18:23:17Z"
      },
      "message": "consensus refactor: extract ComputeTapleafHash, ComputeTaprootMerkleRoot",
      "tree": {
        "sha": "8aaa158d145dc0f23b4316f85c9b86ca17eace12",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8aaa158d145dc0f23b4316f85c9b86ca17eace12"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/29e5dd1a5b9a1879e6c3c7e153b2e6f33a79e905",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/29e5dd1a5b9a1879e6c3c7e153b2e6f33a79e905",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/29e5dd1a5b9a1879e6c3c7e153b2e6f33a79e905",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/29e5dd1a5b9a1879e6c3c7e153b2e6f33a79e905/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0f47e01d7d491fd240f4b14302bf9edf4f05142c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0f47e01d7d491fd240f4b14302bf9edf4f05142c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0f47e01d7d491fd240f4b14302bf9edf4f05142c"
      }
    ],
    "stats": {
      "total": 38,
      "additions": 28,
      "deletions": 10
    },
    "files": [
      {
        "sha": "8cebbc5d1088bd1e96aeaa59162fe627b9ab2b88",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 10,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/29e5dd1a5b9a1879e6c3c7e153b2e6f33a79e905/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/29e5dd1a5b9a1879e6c3c7e153b2e6f33a79e905/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=29e5dd1a5b9a1879e6c3c7e153b2e6f33a79e905",
        "patch": "@@ -1847,16 +1847,14 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n     return true;\n }\n \n-static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script, uint256& tapleaf_hash)\n+uint256 ComputeTapleafHash(uint8_t leaf_version, const CScript& script)\n+{\n+    return (CHashWriter(HASHER_TAPLEAF) << leaf_version << script).GetSHA256();\n+}\n+\n+uint256 ComputeTaprootMerkleRoot(Span<const unsigned char> control, const uint256& tapleaf_hash)\n {\n     const int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\n-    //! The internal pubkey (x-only, so no Y coordinate parity).\n-    const XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};\n-    //! The output pubkey (taken from the scriptPubKey).\n-    const XOnlyPubKey q{uint256(program)};\n-    // Compute the tapleaf hash.\n-    tapleaf_hash = (CHashWriter(HASHER_TAPLEAF) << uint8_t(control[0] & TAPROOT_LEAF_MASK) << script).GetSHA256();\n-    // Compute the Merkle root from the leaf and the provided path.\n     uint256 k = tapleaf_hash;\n     for (int i = 0; i < path_len; ++i) {\n         CHashWriter ss_branch{HASHER_TAPBRANCH};\n@@ -1868,8 +1866,21 @@ static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, c\n         }\n         k = ss_branch.GetSHA256();\n     }\n+    return k;\n+}\n+\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const uint256& tapleaf_hash)\n+{\n+    assert(control.size() >= TAPROOT_CONTROL_BASE_SIZE);\n+    assert(program.size() >= uint256::size());\n+    //! The internal pubkey (x-only, so no Y coordinate parity).\n+    const XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};\n+    //! The output pubkey (taken from the scriptPubKey).\n+    const XOnlyPubKey q{uint256(program)};\n+    // Compute the Merkle root from the leaf and the provided path.\n+    const uint256 merkle_root = ComputeTaprootMerkleRoot(control, tapleaf_hash);\n     // Verify that the output pubkey matches the tweaked internal pubkey, after correcting for parity.\n-    return q.CheckTapTweak(p, k, control[0] & 1);\n+    return q.CheckTapTweak(p, merkle_root, control[0] & 1);\n }\n \n static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror, bool is_p2sh)\n@@ -1929,7 +1940,8 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n             if (control.size() < TAPROOT_CONTROL_BASE_SIZE || control.size() > TAPROOT_CONTROL_MAX_SIZE || ((control.size() - TAPROOT_CONTROL_BASE_SIZE) % TAPROOT_CONTROL_NODE_SIZE) != 0) {\n                 return set_error(serror, SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE);\n             }\n-            if (!VerifyTaprootCommitment(control, program, exec_script, execdata.m_tapleaf_hash)) {\n+            execdata.m_tapleaf_hash = ComputeTapleafHash(control[0] & TAPROOT_LEAF_MASK, exec_script);\n+            if (!VerifyTaprootCommitment(control, program, execdata.m_tapleaf_hash)) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n             }\n             execdata.m_tapleaf_hash_init = true;"
      },
      {
        "sha": "034c937b99a5062921adacd08e5c3bf0159266ab",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/29e5dd1a5b9a1879e6c3c7e153b2e6f33a79e905/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/29e5dd1a5b9a1879e6c3c7e153b2e6f33a79e905/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=29e5dd1a5b9a1879e6c3c7e153b2e6f33a79e905",
        "patch": "@@ -317,6 +317,12 @@ class DeferringSignatureChecker : public BaseSignatureChecker\n     }\n };\n \n+/** Compute the BIP341 tapleaf hash from leaf version & script. */\n+uint256 ComputeTapleafHash(uint8_t leaf_version, const CScript& script);\n+/** Compute the BIP341 taproot script tree Merkle root from control block and leaf hash.\n+ *  Requires control block to have valid length (33 + k*32, with k in {0,1,..,128}). */\n+uint256 ComputeTaprootMerkleRoot(Span<const unsigned char> control, const uint256& tapleaf_hash);\n+\n bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptExecutionData& execdata, ScriptError* error = nullptr);\n bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = nullptr);\n bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror = nullptr);"
      }
    ]
  },
  {
    "sha": "c7388e5ada394b7fe94d6263fb02e9dd28ab367e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNzM4OGU1YWRhMzk0YjdmZTk0ZDYyNjNmYjAyZTlkZDI4YWIzNjdl",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-06-06T07:05:02Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-06-18T18:23:17Z"
      },
      "message": "Report address as solvable based on inferred descriptor",
      "tree": {
        "sha": "6b370f464ef177ff7f9618d5b553df40201d1a29",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6b370f464ef177ff7f9618d5b553df40201d1a29"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c7388e5ada394b7fe94d6263fb02e9dd28ab367e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c7388e5ada394b7fe94d6263fb02e9dd28ab367e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c7388e5ada394b7fe94d6263fb02e9dd28ab367e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c7388e5ada394b7fe94d6263fb02e9dd28ab367e/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "29e5dd1a5b9a1879e6c3c7e153b2e6f33a79e905",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/29e5dd1a5b9a1879e6c3c7e153b2e6f33a79e905",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/29e5dd1a5b9a1879e6c3c7e153b2e6f33a79e905"
      }
    ],
    "stats": {
      "total": 15,
      "additions": 10,
      "deletions": 5
    },
    "files": [
      {
        "sha": "94915a1373c276aeb224232ef5dc759b933ed49c",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 5,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c7388e5ada394b7fe94d6263fb02e9dd28ab367e/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c7388e5ada394b7fe94d6263fb02e9dd28ab367e/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=c7388e5ada394b7fe94d6263fb02e9dd28ab367e",
        "patch": "@@ -3848,13 +3848,18 @@ RPCHelpMan getaddressinfo()\n     isminetype mine = pwallet->IsMine(dest);\n     ret.pushKV(\"ismine\", bool(mine & ISMINE_SPENDABLE));\n \n-    bool solvable = provider && IsSolvable(*provider, scriptPubKey);\n-    ret.pushKV(\"solvable\", solvable);\n-\n-    if (solvable) {\n-       ret.pushKV(\"desc\", InferDescriptor(scriptPubKey, *provider)->ToString());\n+    if (provider) {\n+        auto inferred = InferDescriptor(scriptPubKey, *provider);\n+        bool solvable = inferred->IsSolvable() || IsSolvable(*provider, scriptPubKey);\n+        ret.pushKV(\"solvable\", solvable);\n+        if (solvable) {\n+            ret.pushKV(\"desc\", inferred->ToString());\n+        }\n+    } else {\n+        ret.pushKV(\"solvable\", false);\n     }\n \n+\n     DescriptorScriptPubKeyMan* desc_spk_man = dynamic_cast<DescriptorScriptPubKeyMan*>(pwallet->GetScriptPubKeyMan(scriptPubKey));\n     if (desc_spk_man) {\n         std::string desc_str;"
      }
    ]
  },
  {
    "sha": "d637a9b397816e34652d0c4d383308e39770737a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNjM3YTliMzk3ODE2ZTM0NjUyZDBjNGQzODMzMDhlMzk3NzA3Mzdh",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-06-04T22:06:16Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-06-18T18:28:47Z"
      },
      "message": "Taproot descriptor inference",
      "tree": {
        "sha": "fde3fcc1ca404e53e353b8883c95c64a4fa1479b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fde3fcc1ca404e53e353b8883c95c64a4fa1479b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d637a9b397816e34652d0c4d383308e39770737a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d637a9b397816e34652d0c4d383308e39770737a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d637a9b397816e34652d0c4d383308e39770737a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d637a9b397816e34652d0c4d383308e39770737a/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c7388e5ada394b7fe94d6263fb02e9dd28ab367e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c7388e5ada394b7fe94d6263fb02e9dd28ab367e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c7388e5ada394b7fe94d6263fb02e9dd28ab367e"
      }
    ],
    "stats": {
      "total": 246,
      "additions": 237,
      "deletions": 9
    },
    "files": [
      {
        "sha": "be97a618f3e06a1bd3a976f2e69059aa9ee343f0",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 67,
        "deletions": 9,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d637a9b397816e34652d0c4d383308e39770737a/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d637a9b397816e34652d0c4d383308e39770737a/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=d637a9b397816e34652d0c4d383308e39770737a",
        "patch": "@@ -244,7 +244,7 @@ class ConstPubkeyProvider final : public PubkeyProvider\n     bool m_xonly;\n \n public:\n-    ConstPubkeyProvider(uint32_t exp_index, const CPubKey& pubkey, bool xonly = false) : PubkeyProvider(exp_index), m_pubkey(pubkey), m_xonly(xonly) {}\n+    ConstPubkeyProvider(uint32_t exp_index, const CPubKey& pubkey, bool xonly) : PubkeyProvider(exp_index), m_pubkey(pubkey), m_xonly(xonly) {}\n     bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& key, KeyOriginInfo& info, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) override\n     {\n         key = m_pubkey;\n@@ -931,7 +931,7 @@ std::unique_ptr<PubkeyProvider> ParsePubkeyInner(uint32_t key_exp_index, const S\n             CPubKey pubkey(data);\n             if (pubkey.IsFullyValid()) {\n                 if (permit_uncompressed || pubkey.IsCompressed()) {\n-                    return std::make_unique<ConstPubkeyProvider>(key_exp_index, pubkey);\n+                    return std::make_unique<ConstPubkeyProvider>(key_exp_index, pubkey, false);\n                 } else {\n                     error = \"Uncompressed keys are not allowed\";\n                     return nullptr;\n@@ -952,7 +952,7 @@ std::unique_ptr<PubkeyProvider> ParsePubkeyInner(uint32_t key_exp_index, const S\n             if (permit_uncompressed || key.IsCompressed()) {\n                 CPubKey pubkey = key.GetPubKey();\n                 out.keys.emplace(pubkey.GetID(), key);\n-                return std::make_unique<ConstPubkeyProvider>(key_exp_index, pubkey);\n+                return std::make_unique<ConstPubkeyProvider>(key_exp_index, pubkey, ctx == ParseScriptContext::P2TR);\n             } else {\n                 error = \"Uncompressed keys are not allowed\";\n                 return nullptr;\n@@ -1221,42 +1221,66 @@ std::unique_ptr<DescriptorImpl> ParseScript(uint32_t& key_exp_index, Span<const\n \n std::unique_ptr<PubkeyProvider> InferPubkey(const CPubKey& pubkey, ParseScriptContext, const SigningProvider& provider)\n {\n-    std::unique_ptr<PubkeyProvider> key_provider = std::make_unique<ConstPubkeyProvider>(0, pubkey);\n+    std::unique_ptr<PubkeyProvider> key_provider = std::make_unique<ConstPubkeyProvider>(0, pubkey, false);\n     KeyOriginInfo info;\n     if (provider.GetKeyOrigin(pubkey.GetID(), info)) {\n         return std::make_unique<OriginPubkeyProvider>(0, std::move(info), std::move(key_provider));\n     }\n     return key_provider;\n }\n \n+std::unique_ptr<PubkeyProvider> InferXOnlyPubkey(const XOnlyPubKey& xkey, ParseScriptContext ctx, const SigningProvider& provider)\n+{\n+    unsigned char full_key[CPubKey::COMPRESSED_SIZE] = {0x02};\n+    std::copy(xkey.begin(), xkey.end(), full_key + 1);\n+    CPubKey pubkey(full_key);\n+    std::unique_ptr<PubkeyProvider> key_provider = std::make_unique<ConstPubkeyProvider>(0, pubkey, true);\n+    KeyOriginInfo info;\n+    if (provider.GetKeyOrigin(pubkey.GetID(), info)) {\n+        return std::make_unique<OriginPubkeyProvider>(0, std::move(info), std::move(key_provider));\n+    } else {\n+        full_key[0] = 0x03;\n+        pubkey = CPubKey(full_key);\n+        if (provider.GetKeyOrigin(pubkey.GetID(), info)) {\n+            return std::make_unique<OriginPubkeyProvider>(0, std::move(info), std::move(key_provider));\n+        }\n+    }\n+    return key_provider;\n+}\n+\n std::unique_ptr<DescriptorImpl> InferScript(const CScript& script, ParseScriptContext ctx, const SigningProvider& provider)\n {\n+    if (ctx == ParseScriptContext::P2TR && script.size() == 34 && script[0] == 32 && script[33] == OP_CHECKSIG) {\n+        XOnlyPubKey key{Span<const unsigned char>{script.data() + 1, script.data() + 33}};\n+        return std::make_unique<PKDescriptor>(InferXOnlyPubkey(key, ctx, provider));\n+    }\n+\n     std::vector<std::vector<unsigned char>> data;\n     TxoutType txntype = Solver(script, data);\n \n-    if (txntype == TxoutType::PUBKEY) {\n+    if (txntype == TxoutType::PUBKEY && (ctx == ParseScriptContext::TOP || ctx == ParseScriptContext::P2SH || ctx == ParseScriptContext::P2WSH)) {\n         CPubKey pubkey(data[0]);\n         if (pubkey.IsValid()) {\n             return std::make_unique<PKDescriptor>(InferPubkey(pubkey, ctx, provider));\n         }\n     }\n-    if (txntype == TxoutType::PUBKEYHASH) {\n+    if (txntype == TxoutType::PUBKEYHASH && (ctx == ParseScriptContext::TOP || ctx == ParseScriptContext::P2SH || ctx == ParseScriptContext::P2WSH)) {\n         uint160 hash(data[0]);\n         CKeyID keyid(hash);\n         CPubKey pubkey;\n         if (provider.GetPubKey(keyid, pubkey)) {\n             return std::make_unique<PKHDescriptor>(InferPubkey(pubkey, ctx, provider));\n         }\n     }\n-    if (txntype == TxoutType::WITNESS_V0_KEYHASH && ctx != ParseScriptContext::P2WSH) {\n+    if (txntype == TxoutType::WITNESS_V0_KEYHASH && (ctx == ParseScriptContext::TOP || ctx == ParseScriptContext::P2SH)) {\n         uint160 hash(data[0]);\n         CKeyID keyid(hash);\n         CPubKey pubkey;\n         if (provider.GetPubKey(keyid, pubkey)) {\n             return std::make_unique<WPKHDescriptor>(InferPubkey(pubkey, ctx, provider));\n         }\n     }\n-    if (txntype == TxoutType::MULTISIG) {\n+    if (txntype == TxoutType::MULTISIG && (ctx == ParseScriptContext::TOP || ctx == ParseScriptContext::P2SH || ctx == ParseScriptContext::P2WSH)) {\n         std::vector<std::unique_ptr<PubkeyProvider>> providers;\n         for (size_t i = 1; i + 1 < data.size(); ++i) {\n             CPubKey pubkey(data[i]);\n@@ -1273,7 +1297,7 @@ std::unique_ptr<DescriptorImpl> InferScript(const CScript& script, ParseScriptCo\n             if (sub) return std::make_unique<SHDescriptor>(std::move(sub));\n         }\n     }\n-    if (txntype == TxoutType::WITNESS_V0_SCRIPTHASH && ctx != ParseScriptContext::P2WSH) {\n+    if (txntype == TxoutType::WITNESS_V0_SCRIPTHASH && (ctx == ParseScriptContext::TOP || ctx == ParseScriptContext::P2SH)) {\n         CScriptID scriptid;\n         CRIPEMD160().Write(data[0].data(), data[0].size()).Finalize(scriptid.begin());\n         CScript subscript;\n@@ -1282,6 +1306,40 @@ std::unique_ptr<DescriptorImpl> InferScript(const CScript& script, ParseScriptCo\n             if (sub) return std::make_unique<WSHDescriptor>(std::move(sub));\n         }\n     }\n+    if (txntype == TxoutType::WITNESS_V1_TAPROOT && ctx == ParseScriptContext::TOP) {\n+        // Extract x-only pubkey from output.\n+        XOnlyPubKey pubkey;\n+        std::copy(data[0].begin(), data[0].end(), pubkey.begin());\n+        // Request spending data.\n+        TaprootSpendData tap;\n+        if (provider.GetTaprootSpendData(pubkey, tap)) {\n+            // If found, convert it back to tree form.\n+            auto tree = InferTaprootTree(tap, pubkey);\n+            if (tree) {\n+                // If that works, try to infer subdescriptors for all leaves.\n+                bool ok = true;\n+                std::vector<std::unique_ptr<DescriptorImpl>> subscripts; //!< list of script subexpressions\n+                std::vector<int> depths; //!< depth in the tree of each subexpression (same length subscripts)\n+                for (const auto& [depth, script, leaf_ver] : *tree) {\n+                    std::unique_ptr<DescriptorImpl> subdesc;\n+                    if (leaf_ver == TAPROOT_LEAF_TAPSCRIPT) {\n+                        subdesc = InferScript(script, ParseScriptContext::P2TR, provider);\n+                    }\n+                    if (!subdesc) {\n+                        ok = false;\n+                        break;\n+                    } else {\n+                        subscripts.push_back(std::move(subdesc));\n+                        depths.push_back(depth);\n+                    }\n+                }\n+                if (ok) {\n+                    auto key = InferXOnlyPubkey(tap.internal_key, ParseScriptContext::P2TR, provider);\n+                    return std::make_unique<TRDescriptor>(std::move(key), std::move(subscripts), std::move(depths));\n+                }\n+            }\n+        }\n+    }\n \n     CTxDestination dest;\n     if (ExtractDestination(script, dest)) {"
      },
      {
        "sha": "b3dd5442fca3c6f986d9db290e7bb886285f9659",
        "filename": "src/script/standard.cpp",
        "status": "modified",
        "additions": 135,
        "deletions": 0,
        "changes": 135,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d637a9b397816e34652d0c4d383308e39770737a/src/script/standard.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d637a9b397816e34652d0c4d383308e39770737a/src/script/standard.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.cpp?ref=d637a9b397816e34652d0c4d383308e39770737a",
        "patch": "@@ -520,3 +520,138 @@ TaprootSpendData TaprootBuilder::GetSpendData() const\n     }\n     return spd;\n }\n+\n+std::optional<std::vector<std::tuple<int, CScript, int>>> InferTaprootTree(const TaprootSpendData& spenddata, const XOnlyPubKey& output)\n+{\n+    // Verify that the output matches the assumed Merkle root and internal key.\n+    auto tweak = spenddata.internal_key.CreateTapTweak(spenddata.merkle_root.IsNull() ? nullptr : &spenddata.merkle_root);\n+    if (!tweak || tweak->first != output) return std::nullopt;\n+    // If the Merkle root is 0, the tree is empty, and we're done.\n+    std::vector<std::tuple<int, CScript, int>> ret;\n+    if (spenddata.merkle_root.IsNull()) return ret;\n+\n+    /** Data structure to represent the nodes of the tree we're going to be build. */\n+    struct TreeNode {\n+        /** Hash of this none, if known; 0 otherwise. */\n+        uint256 hash;\n+        /** The left and right subtrees (note that their order is irrelevant). */\n+        std::unique_ptr<TreeNode> sub[2];\n+        /** If this is known to be a leaf node, a pointer to the (script, leaf_ver) pair.\n+         *  nullptr otherwise. */\n+        const std::pair<CScript, int>* leaf = nullptr;\n+        /** Whether or not this node has been explored (is known to be a leaf, or known to have children). */\n+        bool explored = false;\n+        /** Whether or not this node is an inner node (unknown until explored = true). */\n+        bool inner;\n+        /** Whether or not we have produced output for this subtree. */\n+        bool done = false;\n+    };\n+\n+    // Build tree from the provides branches.\n+    TreeNode root;\n+    root.hash = spenddata.merkle_root;\n+    for (const auto& [key, control_blocks] : spenddata.scripts) {\n+        const auto& [script, leaf_ver] = key;\n+        for (const auto& control : control_blocks) {\n+            // Skip script records with nonsensical leaf version.\n+            if (leaf_ver < 0 || leaf_ver >= 0x100 || leaf_ver & 1) continue;\n+            // Skip script records with invalid control block sizes.\n+            if (control.size() < TAPROOT_CONTROL_BASE_SIZE || control.size() > TAPROOT_CONTROL_MAX_SIZE ||\n+                ((control.size() - TAPROOT_CONTROL_BASE_SIZE) % TAPROOT_CONTROL_NODE_SIZE) != 0) continue;\n+            // Skip script records that don't match the control block.\n+            if ((control[0] & TAPROOT_LEAF_MASK) != leaf_ver) continue;\n+            // Skip script records that don't match the provided Merkle root.\n+            const uint256 leaf_hash = ComputeTapleafHash(leaf_ver, script);\n+            const uint256 merkle_root = ComputeTaprootMerkleRoot(control, leaf_hash);\n+            if (merkle_root != spenddata.merkle_root) continue;\n+\n+            TreeNode* node = &root;\n+            size_t levels = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\n+            for (size_t depth = 0; depth < levels; ++depth) {\n+                // Can't descend into a node which we already know is a leaf.\n+                if (node->explored && !node->inner) return std::nullopt;\n+\n+                // Extract partner hash from Merkle branch in control block.\n+                uint256 hash;\n+                std::copy(control.begin() + TAPROOT_CONTROL_BASE_SIZE + (levels - 1 - depth) * TAPROOT_CONTROL_NODE_SIZE,\n+                          control.begin() + TAPROOT_CONTROL_BASE_SIZE + (levels - depth) * TAPROOT_CONTROL_NODE_SIZE,\n+                          hash.begin());\n+\n+                if (node->sub[0]) {\n+                    // Descend into the existing left or right branch.\n+                    bool desc = false;\n+                    for (int i = 0; i < 2; ++i) {\n+                        if (node->sub[i]->hash == hash || (node->sub[i]->hash.IsNull() && node->sub[1-i]->hash != hash)) {\n+                            node->sub[i]->hash = hash;\n+                            node = &*node->sub[1-i];\n+                            desc = true;\n+                            break;\n+                        }\n+                    }\n+                    if (!desc) return std::nullopt; // This probably requires a hash collision to hit.\n+                } else {\n+                    // We're in an unexplored node. Create subtrees and descend.\n+                    node->explored = true;\n+                    node->inner = true;\n+                    node->sub[0] = std::make_unique<TreeNode>();\n+                    node->sub[1] = std::make_unique<TreeNode>();\n+                    node->sub[1]->hash = hash;\n+                    node = &*node->sub[0];\n+                }\n+            }\n+            // Cannot turn a known inner node into a leaf.\n+            if (node->sub[0]) return std::nullopt;\n+            node->explored = true;\n+            node->inner = false;\n+            node->leaf = &key;\n+            node->hash = leaf_hash;\n+        }\n+    }\n+\n+    // Recursive processing to turn the tree into flattened output. Use an explicit stack here to avoid\n+    // overflowing the call stack (the tree may be 128 levels deep).\n+    std::vector<TreeNode*> stack{&root};\n+    while (!stack.empty()) {\n+        TreeNode& node = *stack.back();\n+        if (!node.explored) {\n+            // Unexplored node, which means the tree is incomplete.\n+            return std::nullopt;\n+        } else if (!node.inner) {\n+            // Leaf node; produce output.\n+            ret.emplace_back(stack.size() - 1, node.leaf->first, node.leaf->second);\n+            node.done = true;\n+            stack.pop_back();\n+        } else if (node.sub[0]->done && !node.sub[1]->done && !node.sub[1]->explored && !node.sub[1]->hash.IsNull() &&\n+                   (CHashWriter{HASHER_TAPBRANCH} << node.sub[1]->hash << node.sub[1]->hash).GetSHA256() == node.hash) {\n+            // Whenever there are nodes with two identical subtrees under it, we run into a problem:\n+            // the control blocks for the leaves underneath those will be identical as well, and thus\n+            // they will all be matched to the same path in the tree. The result is that at the location\n+            // where the duplicate occurred, the left child will contain a normal tree that can be explored\n+            // and processed, but the right one will remain unexplored.\n+            //\n+            // This situation can be detected, by encountering an inner node with unexplored right subtree\n+            // with known hash, and H_TapBranch(hash, hash) is equal to the parent node (this node)'s hash.\n+            //\n+            // To deal with this, simply process the left tree a second time (set its done flag to false;\n+            // noting that the done flag of its children have already been set to false after processing\n+            // those). To avoid ending up in an infinite loop, set the done flag of the right (unexplored)\n+            // subtree to true.\n+            node.sub[0]->done = false;\n+            node.sub[1]->done = true;\n+        } else if (node.sub[0]->done && node.sub[1]->done) {\n+            // An internal node which we're finished with.\n+            node.sub[0]->done = false;\n+            node.sub[1]->done = false;\n+            node.done = true;\n+            stack.pop_back();\n+        } else if (!node.sub[0]->done) {\n+            // An internal node whose left branch hasn't been processed yet. Do so first.\n+            stack.push_back(&*node.sub[0]);\n+        } else if (!node.sub[1]->done) {\n+            // An internal node whose right branch hasn't been processed yet. Do so first.\n+            stack.push_back(&*node.sub[1]);\n+        }\n+    }\n+\n+    return ret;\n+}"
      },
      {
        "sha": "ac4e2f327623593dd3009cf7563b11198f16336e",
        "filename": "src/script/standard.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d637a9b397816e34652d0c4d383308e39770737a/src/script/standard.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d637a9b397816e34652d0c4d383308e39770737a/src/script/standard.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.h?ref=d637a9b397816e34652d0c4d383308e39770737a",
        "patch": "@@ -327,4 +327,12 @@ class TaprootBuilder\n     TaprootSpendData GetSpendData() const;\n };\n \n+/** Given a TaprootSpendData and the output key, reconstruct its script tree.\n+ *\n+ * If the output doesn't match the spenddata, or if the data in spenddata is incomplete,\n+ * std::nullopt is returned. Otherwise, a vector of (depth, script, leaf_ver) tuples is\n+ * returned, corresponding to a depth-first traversal of the script tree.\n+ */\n+std::optional<std::vector<std::tuple<int, CScript, int>>> InferTaprootTree(const TaprootSpendData& spenddata, const XOnlyPubKey& output);\n+\n #endif // BITCOIN_SCRIPT_STANDARD_H"
      },
      {
        "sha": "0eac814c52487d6866c148a5a65f23090b18c529",
        "filename": "test/functional/wallet_taproot.py",
        "status": "modified",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d637a9b397816e34652d0c4d383308e39770737a/test/functional/wallet_taproot.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d637a9b397816e34652d0c4d383308e39770737a/test/functional/wallet_taproot.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_taproot.py?ref=d637a9b397816e34652d0c4d383308e39770737a",
        "patch": "@@ -230,6 +230,12 @@ def do_test_addr(self, comment, pattern, privmap, treefn, keys):\n             if treefn is not None:\n                 addr_r = self.make_addr(treefn, keys, i)\n                 assert_equal(addr_g, addr_r)\n+            desc_a = self.addr_gen.getaddressinfo(addr_g)['desc']\n+            if desc.startswith(\"tr(\"):\n+                assert desc_a.startswith(\"tr(\")\n+            rederive = self.nodes[1].deriveaddresses(desc_a)\n+            assert_equal(len(rederive), 1)\n+            assert_equal(rederive[0], addr_g)\n \n         # tr descriptors cannot be imported when Taproot is not active\n         result = self.privs_tr_enabled.importdescriptors([{\"desc\": desc, \"timestamp\": \"now\"}])\n@@ -374,13 +380,34 @@ def run_test(self):\n             None,\n             2\n         )\n+        self.do_test(\n+            \"tr(XPRV,{XPUB,XPUB})\",\n+            \"tr($1/*,{pk($2/*),pk($2/*)})\",\n+            [True, False],\n+            lambda k1, k2: (key(k1), [pk(k2), pk(k2)]),\n+            2\n+        )\n+        self.do_test(\n+            \"tr(XPRV,{{XPUB,H},{H,XPUB}})\",\n+            \"tr($1/*,{{pk($2/*),pk($H)},{pk($H),pk($2/*)}})\",\n+            [True, False],\n+            lambda k1, k2: (key(k1), [[pk(k2), pk(H_POINT)], [pk(H_POINT), pk(k2)]]),\n+            2\n+        )\n         self.do_test(\n             \"tr(XPUB,{{H,{H,XPUB}},{H,{H,{H,XPRV}}}})\",\n             \"tr($1/*,{{pk($H),{pk($H),pk($2/*)}},{pk($H),{pk($H),{pk($H),pk($3/*)}}}})\",\n             [False, False, True],\n             lambda k1, k2, k3: (key(k1), [[pk(H_POINT), [pk(H_POINT), pk(k2)]], [pk(H_POINT), [pk(H_POINT), [pk(H_POINT), pk(k3)]]]]),\n             3\n         )\n+        self.do_test(\n+            \"tr(XPRV,{XPUB,{{XPUB,{H,H}},{{H,H},XPUB}}})\",\n+            \"tr($1/*,{pk($2/*),{{pk($2/*),{pk($H),pk($H)}},{{pk($H),pk($H)},pk($2/*)}}})\",\n+            [True, False],\n+            lambda k1, k2: (key(k1), [pk(k2), [[pk(k2), [pk(H_POINT), pk(H_POINT)]], [[pk(H_POINT), pk(H_POINT)], pk(k2)]]]),\n+            2\n+        )\n \n         self.log.info(\"Sending everything back...\")\n "
      }
    ]
  }
]