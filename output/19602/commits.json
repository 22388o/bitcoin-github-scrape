[
  {
    "sha": "005c2e26353602eec7aa20390126eb75ac82766a",
    "node_id": "C_kwDOABII59oAKDAwNWMyZTI2MzUzNjAyZWVjN2FhMjAzOTAxMjZlYjc1YWM4Mjc2NmE",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-07-06T19:54:15Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-11-09T20:09:54Z"
      },
      "message": "scriptpubkeyman: Add GetScriptPubKeys and implement in Legacy",
      "tree": {
        "sha": "ab6bd7bd5466668ecb6245a2a733a10943be6712",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ab6bd7bd5466668ecb6245a2a733a10943be6712"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/005c2e26353602eec7aa20390126eb75ac82766a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/005c2e26353602eec7aa20390126eb75ac82766a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/005c2e26353602eec7aa20390126eb75ac82766a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/005c2e26353602eec7aa20390126eb75ac82766a/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8ae4ba481ce8f7da173bef24432729c87a36cb70",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8ae4ba481ce8f7da173bef24432729c87a36cb70",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8ae4ba481ce8f7da173bef24432729c87a36cb70"
      }
    ],
    "stats": {
      "total": 104,
      "additions": 99,
      "deletions": 5
    },
    "files": [
      {
        "sha": "f7201f5051d3551fe17d43ec22385982f00ee6de",
        "filename": "src/wallet/scriptpubkeyman.cpp",
        "status": "modified",
        "additions": 56,
        "deletions": 3,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/005c2e26353602eec7aa20390126eb75ac82766a/src/wallet/scriptpubkeyman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/005c2e26353602eec7aa20390126eb75ac82766a/src/wallet/scriptpubkeyman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.cpp?ref=005c2e26353602eec7aa20390126eb75ac82766a",
        "patch": "@@ -1613,6 +1613,59 @@ std::set<CKeyID> LegacyScriptPubKeyMan::GetKeys() const\n     return set_address;\n }\n \n+const std::unordered_set<CScript, SaltedSipHasher> LegacyScriptPubKeyMan::GetScriptPubKeys() const\n+{\n+    LOCK(cs_KeyStore);\n+    std::unordered_set<CScript, SaltedSipHasher> spks;\n+\n+    // All keys have at least P2PK and P2PKH\n+    for (const auto& key_pair : mapKeys) {\n+        const CPubKey& pub = key_pair.second.GetPubKey();\n+        spks.insert(GetScriptForRawPubKey(pub));\n+        spks.insert(GetScriptForDestination(PKHash(pub)));\n+    }\n+    for (const auto& key_pair : mapCryptedKeys) {\n+        const CPubKey& pub = key_pair.second.first;\n+        spks.insert(GetScriptForRawPubKey(pub));\n+        spks.insert(GetScriptForDestination(PKHash(pub)));\n+    }\n+\n+    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    // The watchonly ones will be in setWatchOnly which we deal with later\n+    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n+    for (const auto& script_pair : mapScripts) {\n+        const CScript& script = script_pair.second;\n+        if (IsMine(script) == ISMINE_SPENDABLE) {\n+            // Add ScriptHash for scripts that are not already P2SH\n+            if (!script.IsPayToScriptHash()) {\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            }\n+            // For segwit scripts, we only consider them spendable if we have the segwit spk\n+            int wit_ver = -1;\n+            std::vector<unsigned char> witprog;\n+            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+                spks.insert(script);\n+            }\n+        } else {\n+            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n+            // So check the P2SH of a multisig to see if we should insert it\n+            std::vector<std::vector<unsigned char>> sols;\n+            TxoutType type = Solver(script, sols);\n+            if (type == TxoutType::MULTISIG) {\n+                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n+                if (IsMine(ms_spk) != ISMINE_NO) {\n+                    spks.insert(ms_spk);\n+                }\n+            }\n+        }\n+    }\n+\n+    // All watchonly scripts are raw\n+    spks.insert(setWatchOnly.begin(), setWatchOnly.end());\n+\n+    return spks;\n+}\n+\n bool DescriptorScriptPubKeyMan::GetNewDestination(const OutputType type, CTxDestination& dest, bilingual_str& error)\n {\n     // Returns true if this descriptor supports getting new addresses. Conditions where we may be unable to fetch them (e.g. locked) are caught later\n@@ -2246,14 +2299,14 @@ const WalletDescriptor DescriptorScriptPubKeyMan::GetWalletDescriptor() const\n     return m_wallet_descriptor;\n }\n \n-const std::vector<CScript> DescriptorScriptPubKeyMan::GetScriptPubKeys() const\n+const std::unordered_set<CScript, SaltedSipHasher> DescriptorScriptPubKeyMan::GetScriptPubKeys() const\n {\n     LOCK(cs_desc_man);\n-    std::vector<CScript> script_pub_keys;\n+    std::unordered_set<CScript, SaltedSipHasher> script_pub_keys;\n     script_pub_keys.reserve(m_map_script_pub_keys.size());\n \n     for (auto const& script_pub_key: m_map_script_pub_keys) {\n-        script_pub_keys.push_back(script_pub_key.first);\n+        script_pub_keys.insert(script_pub_key.first);\n     }\n     return script_pub_keys;\n }"
      },
      {
        "sha": "5e8c5a9b6b19f69982fe4a05a82ee868ced880b4",
        "filename": "src/wallet/scriptpubkeyman.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/005c2e26353602eec7aa20390126eb75ac82766a/src/wallet/scriptpubkeyman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/005c2e26353602eec7aa20390126eb75ac82766a/src/wallet/scriptpubkeyman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.h?ref=005c2e26353602eec7aa20390126eb75ac82766a",
        "patch": "@@ -227,6 +227,9 @@ class ScriptPubKeyMan\n \n     virtual uint256 GetID() const { return uint256(); }\n \n+    /** Returns a vector of all the scriptPubKeys that this ScriptPubKeyMan watches */\n+    virtual const std::unordered_set<CScript, SaltedSipHasher> GetScriptPubKeys() const { return {}; };\n+\n     /** Prepends the wallet name in logging output to ease debugging in multi-wallet use cases */\n     template<typename... Params>\n     void WalletLogPrintf(std::string fmt, Params... parameters) const {\n@@ -487,6 +490,7 @@ class LegacyScriptPubKeyMan : public ScriptPubKeyMan, public FillableSigningProv\n     const std::map<CKeyID, int64_t>& GetAllReserveKeys() const { return m_pool_key_to_index; }\n \n     std::set<CKeyID> GetKeys() const override;\n+    const std::unordered_set<CScript, SaltedSipHasher> GetScriptPubKeys() const override;\n };\n \n /** Wraps a LegacyScriptPubKeyMan so that it can be returned in a new unique_ptr. Does not provide privkeys */\n@@ -608,7 +612,7 @@ class DescriptorScriptPubKeyMan : public ScriptPubKeyMan\n     void WriteDescriptor();\n \n     const WalletDescriptor GetWalletDescriptor() const EXCLUSIVE_LOCKS_REQUIRED(cs_desc_man);\n-    const std::vector<CScript> GetScriptPubKeys() const;\n+    const std::unordered_set<CScript, SaltedSipHasher> GetScriptPubKeys() const override;\n \n     bool GetDescriptorString(std::string& out, const bool priv) const;\n "
      },
      {
        "sha": "4feccdeb15e2c16bb5917ad0e6f5cdc1619eadd4",
        "filename": "src/wallet/test/ismine_tests.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 0,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/005c2e26353602eec7aa20390126eb75ac82766a/src/wallet/test/ismine_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/005c2e26353602eec7aa20390126eb75ac82766a/src/wallet/test/ismine_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/ismine_tests.cpp?ref=005c2e26353602eec7aa20390126eb75ac82766a",
        "patch": "@@ -42,11 +42,13 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         // Keystore does not have key\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n \n         // Keystore has key\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 1);\n     }\n \n     // P2PK uncompressed\n@@ -59,11 +61,13 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         // Keystore does not have key\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n \n         // Keystore has key\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(uncompressedKey));\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 1);\n     }\n \n     // P2PKH compressed\n@@ -76,11 +80,13 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         // Keystore does not have key\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n \n         // Keystore has key\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 1);\n     }\n \n     // P2PKH uncompressed\n@@ -93,11 +99,13 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         // Keystore does not have key\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n \n         // Keystore has key\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(uncompressedKey));\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 1);\n     }\n \n     // P2SH\n@@ -112,16 +120,19 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         // Keystore does not have redeemScript or key\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n \n         // Keystore has redeemScript but no key\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(redeemScript));\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n \n         // Keystore has redeemScript and key\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 1);\n     }\n \n     // (P2PKH inside) P2SH inside P2SH (invalid)\n@@ -140,6 +151,7 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n     }\n \n     // (P2PKH inside) P2SH inside P2WSH (invalid)\n@@ -158,6 +170,7 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n     }\n \n     // P2WPKH inside P2WSH (invalid)\n@@ -174,6 +187,7 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n     }\n \n     // (P2PKH inside) P2WSH inside P2WSH (invalid)\n@@ -192,6 +206,7 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n     }\n \n     // P2WPKH compressed\n@@ -207,6 +222,7 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(scriptPubKey));\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 1);\n     }\n \n     // P2WPKH uncompressed\n@@ -221,11 +237,13 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         // Keystore has key, but no P2SH redeemScript\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n \n         // Keystore has key and P2SH redeemScript\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(scriptPubKey));\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n     }\n \n     // scriptPubKey multisig\n@@ -239,24 +257,28 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         // Keystore does not have any keys\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n \n         // Keystore has 1/2 keys\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(uncompressedKey));\n \n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n \n         // Keystore has 2/2 keys\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[1]));\n \n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n \n         // Keystore has 2/2 keys and the script\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(scriptPubKey));\n \n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n     }\n \n     // P2SH multisig\n@@ -273,11 +295,13 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         // Keystore has no redeemScript\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n \n         // Keystore has redeemScript\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(redeemScript));\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 1);\n     }\n \n     // P2WSH multisig with compressed keys\n@@ -294,16 +318,19 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         // Keystore has keys, but no witnessScript or P2SH redeemScript\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n \n         // Keystore has keys and witnessScript, but no P2SH redeemScript\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(witnessScript));\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n \n         // Keystore has keys, witnessScript, P2SH redeemScript\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(scriptPubKey));\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 1);\n     }\n \n     // P2WSH multisig with uncompressed key\n@@ -320,16 +347,19 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         // Keystore has keys, but no witnessScript or P2SH redeemScript\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n \n         // Keystore has keys and witnessScript, but no P2SH redeemScript\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(witnessScript));\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n \n         // Keystore has keys, witnessScript, P2SH redeemScript\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(scriptPubKey));\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n     }\n \n     // P2WSH multisig wrapped in P2SH\n@@ -345,18 +375,21 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         // Keystore has no witnessScript, P2SH redeemScript, or keys\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n \n         // Keystore has witnessScript and P2SH redeemScript, but no keys\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(redeemScript));\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(witnessScript));\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n \n         // Keystore has keys, witnessScript, P2SH redeemScript\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[1]));\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 1);\n     }\n \n     // OP_RETURN\n@@ -371,6 +404,7 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n \n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n     }\n \n     // witness unspendable\n@@ -385,6 +419,7 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n \n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n     }\n \n     // witness unknown\n@@ -399,6 +434,7 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n \n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n     }\n \n     // Nonstandard\n@@ -413,6 +449,7 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n \n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->GetScriptPubKeys().count(scriptPubKey) == 0);\n     }\n }\n "
      },
      {
        "sha": "8579942263183896f910dabd96a0ef743ef5db0b",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/005c2e26353602eec7aa20390126eb75ac82766a/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/005c2e26353602eec7aa20390126eb75ac82766a/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=005c2e26353602eec7aa20390126eb75ac82766a",
        "patch": "@@ -3325,7 +3325,7 @@ ScriptPubKeyMan* CWallet::AddWalletDescriptor(WalletDescriptor& desc, const Flat\n         }\n \n         CTxDestination dest;\n-        if (!internal && ExtractDestination(script_pub_keys.at(0), dest)) {\n+        if (!internal && ExtractDestination(*script_pub_keys.begin(), dest)) {\n             SetAddressBook(dest, label, \"receive\");\n         }\n     }"
      }
    ]
  },
  {
    "sha": "14a1d18f0ab2fd19ce691eee698fddbe78d28ee0",
    "node_id": "C_kwDOABII59oAKDE0YTFkMThmMGFiMmZkMTljZTY5MWVlZTY5OGZkZGJlNzhkMjhlZTA",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-07-13T18:32:24Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-11-09T20:31:52Z"
      },
      "message": "Implement LegacyScriptPubKeyMan::MigrateToDescriptor",
      "tree": {
        "sha": "c76e511e9c4bfd21bcf85aa611284653aa0ec68b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c76e511e9c4bfd21bcf85aa611284653aa0ec68b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/14a1d18f0ab2fd19ce691eee698fddbe78d28ee0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/14a1d18f0ab2fd19ce691eee698fddbe78d28ee0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/14a1d18f0ab2fd19ce691eee698fddbe78d28ee0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/14a1d18f0ab2fd19ce691eee698fddbe78d28ee0/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "005c2e26353602eec7aa20390126eb75ac82766a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/005c2e26353602eec7aa20390126eb75ac82766a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/005c2e26353602eec7aa20390126eb75ac82766a"
      }
    ],
    "stats": {
      "total": 251,
      "additions": 251,
      "deletions": 0
    },
    "files": [
      {
        "sha": "40e6dee88a9eafd1d9d36ec3fd92c1d95d8e8a73",
        "filename": "src/wallet/scriptpubkeyman.cpp",
        "status": "modified",
        "additions": 229,
        "deletions": 0,
        "changes": 229,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/14a1d18f0ab2fd19ce691eee698fddbe78d28ee0/src/wallet/scriptpubkeyman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/14a1d18f0ab2fd19ce691eee698fddbe78d28ee0/src/wallet/scriptpubkeyman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.cpp?ref=14a1d18f0ab2fd19ce691eee698fddbe78d28ee0",
        "patch": "@@ -1666,6 +1666,235 @@ const std::unordered_set<CScript, SaltedSipHasher> LegacyScriptPubKeyMan::GetScr\n     return spks;\n }\n \n+std::optional<MigrationData> LegacyScriptPubKeyMan::MigrateToDescriptor()\n+{\n+    LOCK(cs_KeyStore);\n+    if (m_storage.IsLocked()) {\n+        return std::nullopt;\n+    }\n+\n+    MigrationData out;\n+\n+    std::unordered_set<CScript, SaltedSipHasher> spks;\n+    auto spks_temp = GetScriptPubKeys();\n+    spks.insert(spks_temp.begin(), spks_temp.end());\n+\n+    // Get all key ids\n+    std::set<CKeyID> keyids;\n+    for (const auto& key_pair : mapKeys) {\n+        keyids.insert(key_pair.first);\n+    }\n+    for (const auto& key_pair : mapCryptedKeys) {\n+        keyids.insert(key_pair.first);\n+    }\n+\n+    // Get key metadata and figure out which keys don't have a seed\n+    // Note that we do not ignore the seeds themselves because they are considered IsMine!\n+    for (auto keyid_it = keyids.begin(); keyid_it != keyids.end();) {\n+        const CKeyID& keyid = *keyid_it;\n+        const auto& it = mapKeyMetadata.find(keyid);\n+        if (it != mapKeyMetadata.end()) {\n+            const CKeyMetadata& meta = it->second;\n+            if (meta.hdKeypath == \"s\" || meta.hdKeypath == \"m\") {\n+                keyid_it++;\n+                continue;\n+            }\n+            if (m_hd_chain.seed_id == meta.hd_seed_id || m_inactive_hd_chains.count(meta.hd_seed_id) > 0) {\n+                keyid_it = keyids.erase(keyid_it);\n+                continue;\n+            }\n+        }\n+        keyid_it++;\n+    }\n+\n+    // keyids is now all non-HD keys. Each key will have its own combo descriptor\n+    for (const CKeyID& keyid : keyids) {\n+        CKey key;\n+        if (!GetKey(keyid, key)) {\n+            assert(false);\n+        }\n+\n+        // Get birthdate from key meta\n+        uint64_t creation_time = 0;\n+        const auto& it = mapKeyMetadata.find(keyid);\n+        if (it != mapKeyMetadata.end()) {\n+            creation_time = it->second.nCreateTime;\n+        }\n+\n+        // Get the key origin\n+        // Maybe this doesn't matter because floating keys here shouldn't have origins\n+        KeyOriginInfo info;\n+        bool has_info = GetKeyOrigin(keyid, info);\n+        std::string origin_str = \"[\" + HexStr(info.fingerprint) + FormatHDKeypath(info.path) + \"]\";\n+\n+        // Construct the combo descriptor\n+        std::string desc_str = \"combo(\" + (has_info ? origin_str : \"\") + HexStr(key.GetPubKey()) + \")\";\n+        FlatSigningProvider keys;\n+        std::string error;\n+        std::unique_ptr<Descriptor> desc = Parse(desc_str, keys, error, false);\n+        WalletDescriptor w_desc(std::move(desc), creation_time, 0, 0, 0);\n+\n+        // Make the DescriptorScriptPubKeyMan and get the scriptPubKeys\n+        auto desc_spk_man = std::unique_ptr<DescriptorScriptPubKeyMan>(new DescriptorScriptPubKeyMan(m_storage, w_desc));\n+        desc_spk_man->AddDescriptorKey(key, key.GetPubKey());\n+        desc_spk_man->TopUp();\n+        auto desc_spks = desc_spk_man->GetScriptPubKeys();\n+\n+        // Remove the scriptPubKeys from our current set\n+        for (const CScript& spk : desc_spks) {\n+            size_t erased = spks.erase(spk);\n+            assert(erased == 1);\n+            assert(IsMine(spk) == ISMINE_SPENDABLE);\n+        }\n+\n+        out.desc_spkms.push_back(std::move(desc_spk_man));\n+    }\n+\n+    // Handle HD keys by using the CHDChains\n+    std::set<CHDChain> chains;\n+    chains.insert(m_hd_chain);\n+    for (const auto& chain_pair : m_inactive_hd_chains) {\n+        chains.insert(chain_pair.second);\n+    }\n+    for (const CHDChain& chain : chains) {\n+        for (int i = 0; i < 2; ++i) {\n+            // Skip if doing internal chain and split chain is not supported\n+            if (chain.seed_id.IsNull() || (i == 1 && !m_storage.CanSupportFeature(FEATURE_HD_SPLIT))) {\n+                continue;\n+            }\n+            // Get the master xprv\n+            CKey seed_key;\n+            if (!GetKey(chain.seed_id, seed_key)) {\n+                assert(false);\n+            }\n+            CExtKey master_key;\n+            master_key.SetSeed(seed_key);\n+\n+            // Make the combo descriptor\n+            std::string xpub = EncodeExtPubKey(master_key.Neuter());\n+            std::string desc_str = \"combo(\" + xpub + \"/0'/\" + ToString(i) + \"'/*')\";\n+            FlatSigningProvider keys;\n+            std::string error;\n+            std::unique_ptr<Descriptor> desc = Parse(desc_str, keys, error, false);\n+            uint32_t chain_counter = std::max((i == 1 ? chain.nInternalChainCounter : chain.nExternalChainCounter), (uint32_t)0);\n+            WalletDescriptor w_desc(std::move(desc), 0, 0, chain_counter, 0);\n+\n+            // Make the DescriptorScriptPubKeyMan and get the scriptPubKeys\n+            auto desc_spk_man = std::unique_ptr<DescriptorScriptPubKeyMan>(new DescriptorScriptPubKeyMan(m_storage, w_desc));\n+            desc_spk_man->AddDescriptorKey(master_key.key, master_key.key.GetPubKey());\n+            desc_spk_man->TopUp();\n+            auto desc_spks = desc_spk_man->GetScriptPubKeys();\n+\n+            // Remove the scriptPubKeys from our current set\n+            for (const CScript& spk : desc_spks) {\n+                size_t erased = spks.erase(spk);\n+                assert(erased == 1);\n+                assert(IsMine(spk) == ISMINE_SPENDABLE);\n+            }\n+\n+            out.desc_spkms.push_back(std::move(desc_spk_man));\n+        }\n+    }\n+\n+    // Handle the rest of the scriptPubKeys which must be imports and may not have all info\n+    for (auto it = spks.begin(); it != spks.end();) {\n+        const CScript& spk = *it;\n+        // InferDescriptor as that will get us all the solving info if it is there\n+        std::unique_ptr<Descriptor> desc = InferDescriptor(spk, *GetSolvingProvider(spk));\n+        // Get the private keys for this descriptor\n+        std::vector<CScript> scripts;\n+        FlatSigningProvider keys;\n+        if (!desc->Expand(0, DUMMY_SIGNING_PROVIDER, scripts, keys)) {\n+            assert(false);\n+        }\n+        std::set<CKeyID> privkeyids;\n+        for (const auto& key_orig_pair : keys.origins) {\n+            privkeyids.insert(key_orig_pair.first);\n+        }\n+\n+        std::vector<CScript> desc_spks;\n+\n+        // Make the descriptor string with private keys\n+        std::string desc_str;\n+        bool watchonly = !desc->ToPrivateString(*this, desc_str);\n+        if (watchonly && !m_storage.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n+            out.watch_descs.push_back(desc->ToString());\n+\n+            // Get the scriptPubKeys without writing this to the wallet\n+            FlatSigningProvider provider;\n+            desc->Expand(0, provider, desc_spks, provider);\n+        } else {\n+            // Make the DescriptorScriptPubKeyMan and get the scriptPubKeys\n+            WalletDescriptor w_desc(std::move(desc), 0, 0, 0, 0);\n+            auto desc_spk_man = std::unique_ptr<DescriptorScriptPubKeyMan>(new DescriptorScriptPubKeyMan(m_storage, w_desc));\n+            for (const auto& keyid : privkeyids) {\n+                CKey key;\n+                if (!GetKey(keyid, key)) {\n+                    continue;\n+                }\n+                desc_spk_man->AddDescriptorKey(key, key.GetPubKey());\n+            }\n+            desc_spk_man->TopUp();\n+            auto desc_spks_set = desc_spk_man->GetScriptPubKeys();\n+            desc_spks.insert(desc_spks.end(), desc_spks_set.begin(), desc_spks_set.end());\n+\n+            out.desc_spkms.push_back(std::move(desc_spk_man));\n+        }\n+\n+        // Remove the scriptPubKeys from our current set\n+        for (const CScript& desc_spk : desc_spks) {\n+            auto del_it = spks.find(desc_spk);\n+            assert(del_it != spks.end());\n+            assert(IsMine(desc_spk) != ISMINE_NO);\n+            it = spks.erase(del_it);\n+        }\n+    }\n+\n+    // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n+    // So we have to check if any of our scripts are a multisig and if so, add the P2SH\n+    for (const auto& script_pair : mapScripts) {\n+        const CScript script = script_pair.second;\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        if (type == TxoutType::MULTISIG) {\n+            CScript sh_spk = GetScriptForDestination(ScriptHash(script));\n+            CTxDestination witdest = WitnessV0ScriptHash(script);\n+            CScript witprog = GetScriptForDestination(witdest);\n+            CScript sh_wsh_spk = GetScriptForDestination(ScriptHash(witprog));\n+\n+            // We only want the multisigs that we have not already seen, i.e. they are not watchonly and not spendable\n+            // For P2SH, a multisig is not ISMINE_NO when:\n+            // * All keys are in the wallet\n+            // * The multisig itself is watch only\n+            // * The P2SH is watch only\n+            // For P2SH-P2WSH, if the script is in the wallet, then it will have the same conditions as P2SH.\n+            // For P2WSH, a multisig is not ISMINE_NO when, other than the P2SH conditions:\n+            // * The P2WSH script is in the wallet and it is being watched\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (HaveWatchOnly(sh_spk) || HaveWatchOnly(script) || HaveKeys(keys, *this) || (HaveCScript(CScriptID(witprog)) && HaveWatchOnly(witprog))) {\n+                // The above emulates IsMine for these 3 scriptPubKeys, so double check that by running IsMine\n+                assert(IsMine(sh_spk) != ISMINE_NO || IsMine(witprog) != ISMINE_NO || IsMine(sh_wsh_spk) != ISMINE_NO);\n+                continue;\n+            }\n+            assert(IsMine(sh_spk) == ISMINE_NO && IsMine(witprog) == ISMINE_NO && IsMine(sh_wsh_spk) == ISMINE_NO);\n+\n+            std::unique_ptr<Descriptor> sh_desc = InferDescriptor(sh_spk, *GetSolvingProvider(sh_spk));\n+            out.solvable_descs.push_back(sh_desc->ToString());\n+\n+            if (IsSolvable(*this, witprog)) {\n+                std::unique_ptr<Descriptor> wsh_desc = InferDescriptor(witprog, *GetSolvingProvider(witprog));\n+                out.solvable_descs.push_back(wsh_desc->ToString());\n+                std::unique_ptr<Descriptor> sh_wsh_desc = InferDescriptor(sh_wsh_spk, *GetSolvingProvider(sh_wsh_spk));\n+                out.solvable_descs.push_back(sh_wsh_desc->ToString());\n+            }\n+        }\n+    }\n+\n+    // Make sure that we have accounted for all scriptPubKeys\n+    assert(spks.size() == 0);\n+    return out;\n+}\n+\n bool DescriptorScriptPubKeyMan::GetNewDestination(const OutputType type, CTxDestination& dest, bilingual_str& error)\n {\n     // Returns true if this descriptor supports getting new addresses. Conditions where we may be unable to fetch them (e.g. locked) are caught later"
      },
      {
        "sha": "3bb237b64e93c60f23f1a864eee235a194cbf4fc",
        "filename": "src/wallet/scriptpubkeyman.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/14a1d18f0ab2fd19ce691eee698fddbe78d28ee0/src/wallet/scriptpubkeyman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/14a1d18f0ab2fd19ce691eee698fddbe78d28ee0/src/wallet/scriptpubkeyman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.h?ref=14a1d18f0ab2fd19ce691eee698fddbe78d28ee0",
        "patch": "@@ -250,6 +250,8 @@ static const std::unordered_set<OutputType> LEGACY_OUTPUT_TYPES {\n     OutputType::BECH32,\n };\n \n+class DescriptorScriptPubKeyMan;\n+\n class LegacyScriptPubKeyMan : public ScriptPubKeyMan, public FillableSigningProvider\n {\n private:\n@@ -491,6 +493,9 @@ class LegacyScriptPubKeyMan : public ScriptPubKeyMan, public FillableSigningProv\n \n     std::set<CKeyID> GetKeys() const override;\n     const std::unordered_set<CScript, SaltedSipHasher> GetScriptPubKeys() const override;\n+\n+    /** Get the DescriptScriptPubKeyMans that have the same scriptPubKeys as this LegacyScriptPubKeyMan */\n+    std::optional<MigrationData> MigrateToDescriptor();\n };\n \n /** Wraps a LegacyScriptPubKeyMan so that it can be returned in a new unique_ptr. Does not provide privkeys */"
      },
      {
        "sha": "e240f9fa570f3772003e55c3fa667867574a2c51",
        "filename": "src/wallet/walletdb.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/14a1d18f0ab2fd19ce691eee698fddbe78d28ee0/src/wallet/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/14a1d18f0ab2fd19ce691eee698fddbe78d28ee0/src/wallet/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.h?ref=14a1d18f0ab2fd19ce691eee698fddbe78d28ee0",
        "patch": "@@ -118,6 +118,10 @@ class CHDChain\n     {\n         return seed_id == chain.seed_id;\n     }\n+    bool operator<(const CHDChain& chain) const\n+    {\n+        return seed_id < chain.seed_id;\n+    }\n };\n \n class CKeyMetadata"
      },
      {
        "sha": "7fbf51f52d1b479b35a6c3a263b2f75fc12243ab",
        "filename": "src/wallet/walletutil.h",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/14a1d18f0ab2fd19ce691eee698fddbe78d28ee0/src/wallet/walletutil.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/14a1d18f0ab2fd19ce691eee698fddbe78d28ee0/src/wallet/walletutil.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletutil.h?ref=14a1d18f0ab2fd19ce691eee698fddbe78d28ee0",
        "patch": "@@ -104,4 +104,17 @@ class WalletDescriptor\n     WalletDescriptor(std::shared_ptr<Descriptor> descriptor, uint64_t creation_time, int32_t range_start, int32_t range_end, int32_t next_index) : descriptor(descriptor), creation_time(creation_time), range_start(range_start), range_end(range_end), next_index(next_index) {}\n };\n \n+class CWallet;\n+class DescriptorScriptPubKeyMan;\n+\n+/** struct containing information needed for migrating legacy wallets to descriptor wallets */\n+struct MigrationData\n+{\n+    std::vector<std::string> watch_descs;\n+    std::vector<std::string> solvable_descs;\n+    std::vector<std::unique_ptr<DescriptorScriptPubKeyMan>> desc_spkms;\n+    std::shared_ptr<CWallet> watchonly_wallet{nullptr};\n+    std::shared_ptr<CWallet> solvable_wallet{nullptr};\n+};\n+\n #endif // BITCOIN_WALLET_WALLETUTIL_H"
      }
    ]
  },
  {
    "sha": "cb5d9f83ae028e5ca1e22df5d24a16d8cd00ced7",
    "node_id": "C_kwDOABII59oAKGNiNWQ5ZjgzYWUwMjhlNWNhMWUyMmRmNWQyNGExNmQ4Y2QwMGNlZDc",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-07-13T19:40:31Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-11-09T20:31:52Z"
      },
      "message": "Implement LegacyScriptPubKeyMan::DeleteRecords",
      "tree": {
        "sha": "1861d1cb4a9b9559098bf03c1c959d126f3698c2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1861d1cb4a9b9559098bf03c1c959d126f3698c2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cb5d9f83ae028e5ca1e22df5d24a16d8cd00ced7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb5d9f83ae028e5ca1e22df5d24a16d8cd00ced7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cb5d9f83ae028e5ca1e22df5d24a16d8cd00ced7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb5d9f83ae028e5ca1e22df5d24a16d8cd00ced7/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "14a1d18f0ab2fd19ce691eee698fddbe78d28ee0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/14a1d18f0ab2fd19ce691eee698fddbe78d28ee0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/14a1d18f0ab2fd19ce691eee698fddbe78d28ee0"
      }
    ],
    "stats": {
      "total": 95,
      "additions": 95,
      "deletions": 0
    },
    "files": [
      {
        "sha": "1b73295d58ef8f34133282ae26e1a99c3ad79ea8",
        "filename": "src/wallet/scriptpubkeyman.cpp",
        "status": "modified",
        "additions": 63,
        "deletions": 0,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb5d9f83ae028e5ca1e22df5d24a16d8cd00ced7/src/wallet/scriptpubkeyman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb5d9f83ae028e5ca1e22df5d24a16d8cd00ced7/src/wallet/scriptpubkeyman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.cpp?ref=cb5d9f83ae028e5ca1e22df5d24a16d8cd00ced7",
        "patch": "@@ -1895,6 +1895,69 @@ std::optional<MigrationData> LegacyScriptPubKeyMan::MigrateToDescriptor()\n     return out;\n }\n \n+bool LegacyScriptPubKeyMan::DeleteRecords(bilingual_str& error)\n+{\n+    LOCK(cs_KeyStore);\n+    WalletBatch batch(m_storage.GetDatabase());\n+    // Remove the watchonly things\n+    for (const CScript& script : setWatchOnly) {\n+        if (!batch.EraseWatchOnly(script)) {\n+            error = strprintf(_(\"Error: Could not delete watch only script %s\"), HexStr(script));\n+            return false;\n+        }\n+    }\n+    // Remove private keys\n+    for (const auto& key_pair : mapKeys) {\n+        const CPubKey& pubkey = key_pair.second.GetPubKey();\n+        if (!batch.EraseKey(pubkey)) {\n+            error = strprintf(_(\"Error: Could not delete private key for %s\"), HexStr(pubkey));\n+            return false;\n+        }\n+    }\n+    for (const auto& key_pair : mapCryptedKeys) {\n+        const CPubKey& pubkey = key_pair.second.first;\n+        if (!batch.EraseCryptedKey(pubkey)) {\n+            error = strprintf(_(\"Error: Could not delete private key for %s\"), HexStr(pubkey));\n+            return false;\n+        }\n+    }\n+    // Remove keypool entries\n+    for (const int64_t entry : setExternalKeyPool) {\n+        if (!batch.ErasePool(entry)) {\n+            error = strprintf(_(\"Error: Could not delete keypool entry for index %d\"), entry);\n+            return false;\n+        }\n+    }\n+    for (const int64_t entry : setInternalKeyPool) {\n+        if (!batch.ErasePool(entry)) {\n+            error = strprintf(_(\"Error: Could not delete keypool entry for index %d\"), entry);\n+            return false;\n+        }\n+    }\n+    for (const int64_t entry : set_pre_split_keypool) {\n+        if (!batch.ErasePool(entry)) {\n+            error = strprintf(_(\"Error: Could not delete keypool entry for index %d\"), entry);\n+            return false;\n+        }\n+    }\n+    // Remove CScript entries\n+    for (const auto& script_pair : mapScripts) {\n+        if (!batch.EraseCScript(Hash160(script_pair.second))) {\n+            error = strprintf(_(\"Error: Could not delete script with ID %s\"), HexStr(script_pair.first));\n+            return false;\n+        }\n+    }\n+    // Remove HDChain if we have it\n+    if (!m_hd_chain.seed_id.IsNull()) {\n+        if (!batch.EraseHDChain()) {\n+            error = _(\"Error: Could not delete hd chain\");\n+            return false;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n bool DescriptorScriptPubKeyMan::GetNewDestination(const OutputType type, CTxDestination& dest, bilingual_str& error)\n {\n     // Returns true if this descriptor supports getting new addresses. Conditions where we may be unable to fetch them (e.g. locked) are caught later"
      },
      {
        "sha": "d696c593c349b963d44355dc7f0e625e92ec91a8",
        "filename": "src/wallet/scriptpubkeyman.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb5d9f83ae028e5ca1e22df5d24a16d8cd00ced7/src/wallet/scriptpubkeyman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb5d9f83ae028e5ca1e22df5d24a16d8cd00ced7/src/wallet/scriptpubkeyman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.h?ref=cb5d9f83ae028e5ca1e22df5d24a16d8cd00ced7",
        "patch": "@@ -496,6 +496,8 @@ class LegacyScriptPubKeyMan : public ScriptPubKeyMan, public FillableSigningProv\n \n     /** Get the DescriptScriptPubKeyMans that have the same scriptPubKeys as this LegacyScriptPubKeyMan */\n     std::optional<MigrationData> MigrateToDescriptor();\n+    /** Delete all the records of this LegacyScriptPubKeyMan from disk */\n+    bool DeleteRecords(bilingual_str& error);\n };\n \n /** Wraps a LegacyScriptPubKeyMan so that it can be returned in a new unique_ptr. Does not provide privkeys */"
      },
      {
        "sha": "41672d513a2013b56621ed0c20695bb1fde11097",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb5d9f83ae028e5ca1e22df5d24a16d8cd00ced7/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb5d9f83ae028e5ca1e22df5d24a16d8cd00ced7/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=cb5d9f83ae028e5ca1e22df5d24a16d8cd00ced7",
        "patch": "@@ -116,6 +116,14 @@ bool WalletBatch::WriteKey(const CPubKey& vchPubKey, const CPrivKey& vchPrivKey,\n     return WriteIC(std::make_pair(DBKeys::KEY, vchPubKey), std::make_pair(vchPrivKey, Hash(vchKey)), false);\n }\n \n+bool WalletBatch::EraseKey(const CPubKey& pubkey)\n+{\n+    if (!EraseIC(std::make_pair(DBKeys::KEYMETA, pubkey))) {\n+        return false;\n+    }\n+    return EraseIC(std::make_pair(DBKeys::KEY, pubkey));\n+}\n+\n bool WalletBatch::WriteCryptedKey(const CPubKey& vchPubKey,\n                                 const std::vector<unsigned char>& vchCryptedSecret,\n                                 const CKeyMetadata &keyMeta)\n@@ -142,6 +150,14 @@ bool WalletBatch::WriteCryptedKey(const CPubKey& vchPubKey,\n     return true;\n }\n \n+bool WalletBatch::EraseCryptedKey(const CPubKey& pubkey)\n+{\n+    if (!EraseIC(std::make_pair(DBKeys::KEYMETA, pubkey))) {\n+        return false;\n+    }\n+    return EraseIC(std::make_pair(DBKeys::CRYPTED_KEY, pubkey));\n+}\n+\n bool WalletBatch::WriteMasterKey(unsigned int nID, const CMasterKey& kMasterKey)\n {\n     return WriteIC(std::make_pair(DBKeys::MASTER_KEY, nID), kMasterKey, true);\n@@ -152,6 +168,11 @@ bool WalletBatch::WriteCScript(const uint160& hash, const CScript& redeemScript)\n     return WriteIC(std::make_pair(DBKeys::CSCRIPT, hash), redeemScript, false);\n }\n \n+bool WalletBatch::EraseCScript(const uint160& hash)\n+{\n+    return EraseIC(std::make_pair(DBKeys::CSCRIPT, hash));\n+}\n+\n bool WalletBatch::WriteWatchOnly(const CScript &dest, const CKeyMetadata& keyMeta)\n {\n     if (!WriteIC(std::make_pair(DBKeys::WATCHMETA, dest), keyMeta)) {\n@@ -1080,6 +1101,11 @@ bool WalletBatch::WriteHDChain(const CHDChain& chain)\n     return WriteIC(DBKeys::HDCHAIN, chain);\n }\n \n+bool WalletBatch::EraseHDChain()\n+{\n+    return EraseIC(DBKeys::HDCHAIN);\n+}\n+\n bool WalletBatch::WriteWalletFlags(const uint64_t flags)\n {\n     return WriteIC(DBKeys::FLAGS, flags);"
      },
      {
        "sha": "af1165b8a0921644cc679fe5e2a5b7203b3b2d6e",
        "filename": "src/wallet/walletdb.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb5d9f83ae028e5ca1e22df5d24a16d8cd00ced7/src/wallet/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb5d9f83ae028e5ca1e22df5d24a16d8cd00ced7/src/wallet/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.h?ref=cb5d9f83ae028e5ca1e22df5d24a16d8cd00ced7",
        "patch": "@@ -228,10 +228,13 @@ class WalletBatch\n \n     bool WriteKeyMetadata(const CKeyMetadata& meta, const CPubKey& pubkey, const bool overwrite);\n     bool WriteKey(const CPubKey& vchPubKey, const CPrivKey& vchPrivKey, const CKeyMetadata &keyMeta);\n+    bool EraseKey(const CPubKey& pubkey);\n     bool WriteCryptedKey(const CPubKey& vchPubKey, const std::vector<unsigned char>& vchCryptedSecret, const CKeyMetadata &keyMeta);\n+    bool EraseCryptedKey(const CPubKey& pubkey);\n     bool WriteMasterKey(unsigned int nID, const CMasterKey& kMasterKey);\n \n     bool WriteCScript(const uint160& hash, const CScript& redeemScript);\n+    bool EraseCScript(const uint160& hash);\n \n     bool WriteWatchOnly(const CScript &script, const CKeyMetadata &keymeta);\n     bool EraseWatchOnly(const CScript &script);\n@@ -274,6 +277,7 @@ class WalletBatch\n \n     //! write the hdchain model (external chain child index counter)\n     bool WriteHDChain(const CHDChain& chain);\n+    bool EraseHDChain();\n \n     bool WriteWalletFlags(const uint64_t flags);\n     //! Begin a new transaction"
      }
    ]
  },
  {
    "sha": "a8dc9266223fafecfdf30f41dd2f7c3779f35a62",
    "node_id": "C_kwDOABII59oAKGE4ZGM5MjY2MjIzZmFmZWNmZGYzMGY0MWRkMmY3YzM3NzlmMzVhNjI",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-07-13T20:38:39Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-11-09T20:31:52Z"
      },
      "message": "Implement MigrateLegacyToDescriptor",
      "tree": {
        "sha": "05c692bd15aa8c4ac7ba20392a8fee08dbfcad87",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/05c692bd15aa8c4ac7ba20392a8fee08dbfcad87"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a8dc9266223fafecfdf30f41dd2f7c3779f35a62",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a8dc9266223fafecfdf30f41dd2f7c3779f35a62",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a8dc9266223fafecfdf30f41dd2f7c3779f35a62",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a8dc9266223fafecfdf30f41dd2f7c3779f35a62/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cb5d9f83ae028e5ca1e22df5d24a16d8cd00ced7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb5d9f83ae028e5ca1e22df5d24a16d8cd00ced7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cb5d9f83ae028e5ca1e22df5d24a16d8cd00ced7"
      }
    ],
    "stats": {
      "total": 340,
      "additions": 339,
      "deletions": 1
    },
    "files": [
      {
        "sha": "8dd66a62789be40e74a1842eb04b3274276f4199",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 325,
        "deletions": 0,
        "changes": 325,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8dc9266223fafecfdf30f41dd2f7c3779f35a62/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8dc9266223fafecfdf30f41dd2f7c3779f35a62/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=a8dc9266223fafecfdf30f41dd2f7c3779f35a62",
        "patch": "@@ -3335,3 +3335,328 @@ ScriptPubKeyMan* CWallet::AddWalletDescriptor(WalletDescriptor& desc, const Flat\n \n     return spk_man;\n }\n+\n+bool CWallet::MigrateToSQLite(bilingual_str& error, std::vector<bilingual_str>& warnings)\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    WalletLogPrintf(\"Migrating wallet storage database from BerkeleyDB to SQLite.\\n\");\n+\n+    if (m_database->Format() == \"sqlite\") {\n+        error = _(\"Error: This wallet already uses SQLite\");\n+        return false;\n+    }\n+\n+    // Get all of the records for DB type migration\n+    std::unique_ptr<DatabaseBatch> batch = m_database->MakeBatch();\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> records;\n+    if (!batch->StartCursor()) {\n+        error = _(\"Error: Unable to begin reading all records in the database\");\n+        return false;\n+    }\n+    bool complete = false;\n+    while (true) {\n+        CDataStream ss_key(SER_DISK, CLIENT_VERSION);\n+        CDataStream ss_value(SER_DISK, CLIENT_VERSION);\n+        bool ret = batch->ReadAtCursor(ss_key, ss_value, complete);\n+        if (!ret) {\n+            break;\n+        }\n+        std::vector<unsigned char> key(ss_key.begin(), ss_key.end());\n+        std::vector<unsigned char> value(ss_value.begin(), ss_value.end());\n+        records[key] = value;\n+    }\n+    batch->CloseCursor();\n+    batch.reset();\n+    if (!complete) {\n+        error = _(\"Error: Unable to read all records in the database\");\n+        return false;\n+    }\n+\n+    // Make a backup of the DB\n+    std::string backup_path = strprintf(\"%s-%d.legacy.bak\", m_database->Filename(), GetTime());\n+    if (!BackupWallet(backup_path)) {\n+        error = _(\"Error: Unable to make a backup of your wallet\");\n+        return false;\n+    }\n+\n+    // Close this database and delete the file\n+    fs::path db_path = fs::PathFromString(m_database->Filename());\n+    fs::path db_dir = db_path.branch_path();\n+    std::string db_filename = db_path.leaf().string();\n+    m_database->Close();\n+    fs::remove(db_path);\n+\n+    // Make new DB\n+    DatabaseOptions opts;\n+    opts.require_create = true;\n+    opts.require_format = DatabaseFormat::SQLITE;\n+    DatabaseStatus db_status;\n+    std::unique_ptr<WalletDatabase> new_db = MakeDatabase(db_dir, opts, db_status, error);\n+    assert(new_db); // This is to prevent doing anything further with this wallet. The original file was deleted, but a backup exists.\n+    m_database.reset();\n+    m_database = std::move(new_db);\n+\n+    // Write existing records into the new DB\n+    batch = m_database->MakeBatch();\n+    batch->TxnBegin();\n+    for (const auto& kv_pair : records) {\n+        CDataStream ss_key(kv_pair.first, SER_DISK, CLIENT_VERSION);\n+        CDataStream ss_value(kv_pair.second, SER_DISK, CLIENT_VERSION);\n+        if (!batch->Write(ss_key, ss_value)) {\n+            batch->TxnAbort();\n+            m_database->Close();\n+            fs::remove(m_database->Filename());\n+            assert(false); // This is a critical error, the new db could not be written to. The original db exists as a backup, but we should not continue execution.\n+        }\n+    }\n+    batch->TxnCommit();\n+    return true;\n+}\n+\n+std::optional<MigrationData> CWallet::GetDescriptorsForLegacy(bilingual_str& error) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    LegacyScriptPubKeyMan* legacy_spkm = GetLegacyScriptPubKeyMan();\n+    if (!legacy_spkm) {\n+        error = _(\"Error: This wallet is already a descriptor wallet\");\n+        return std::nullopt;\n+    }\n+\n+    std::optional<MigrationData> res = legacy_spkm->MigrateToDescriptor();\n+    if (res == std::nullopt) {\n+        error = _(\"Error: Unable to produce descriptors for this legacy wallet. Make sure the wallet is unlocked first\");\n+        return std::nullopt;\n+    }\n+    return res;\n+}\n+\n+bool CWallet::ApplyMigrationData(MigrationData& data, bilingual_str& error, std::vector<bilingual_str>& warnings)\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    LegacyScriptPubKeyMan* legacy_spkm = GetLegacyScriptPubKeyMan();\n+    if (!legacy_spkm) {\n+        error = _(\"Error: This wallet is already a descriptor wallet\");\n+        return false;\n+    }\n+\n+    for (auto& desc_spkm : data.desc_spkms) {\n+        if (m_spk_managers.count(desc_spkm->GetID()) > 0) {\n+            error = _(\"Error: Duplicate descriptors created during migration. Your wallet may be corrupted.\");\n+            return false;\n+        }\n+        m_spk_managers[desc_spkm->GetID()] = std::move(desc_spkm);\n+    }\n+\n+    // Remove the LegacyScriptPubKeyMan from disk\n+    if (!legacy_spkm->DeleteRecords(error)) {\n+        return false;\n+    }\n+\n+    // Remove the LegacyScriptPubKeyMan from memory\n+    m_spk_managers.erase(legacy_spkm->GetID());\n+    m_external_spk_managers.clear();\n+    m_internal_spk_managers.clear();\n+\n+    // Setup new descriptors\n+    SetWalletFlag(WALLET_FLAG_DESCRIPTORS);\n+    if (!IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n+        SetupDescriptorScriptPubKeyMans();\n+    }\n+\n+    // Check if the transactions in the wallet are still ours. Either they belong here, or they belong in the watchonly wallet.\n+    std::vector<uint256> txids_to_delete;\n+    for (const auto& tx_pair : mapWallet) {\n+        if (!IsMine(*tx_pair.second.tx)) {\n+            // Check it is the watchonly wallet's\n+            // solvable_wallet doesn't need to be checked because transactions for those scripst weren't being watched for\n+            if (data.watchonly_wallet) {\n+                LOCK(data.watchonly_wallet->cs_wallet);\n+                if (data.watchonly_wallet->IsMine(*tx_pair.second.tx)) {\n+                    // Add to watchonly wallet\n+                    if (!data.watchonly_wallet->AddToWallet(tx_pair.second.tx, tx_pair.second.m_confirm)) {\n+                        error = _(\"Error: Could not add watchonly tx to watchonly wallet\");\n+                        return false;\n+                    }\n+                    // Mark as to remove from this wallet\n+                    txids_to_delete.push_back(tx_pair.first);\n+                    continue;\n+                }\n+            }\n+            // Both not ours and not in the watchonly wallet\n+            error = _(\"Error: Transaction in wallet cannot be identified to belong to migrated wallets\");\n+            return false;\n+        }\n+    }\n+    // Do the removes\n+    if (txids_to_delete.size() > 0) {\n+        std::vector<uint256> deleted_txids;\n+        if (ZapSelectTx(txids_to_delete, deleted_txids) != DBErrors::LOAD_OK) {\n+            error = _(\"Error: Could not delete watchonly transactions\");\n+            return false;\n+        }\n+        if (deleted_txids != txids_to_delete) {\n+            error = _(\"Error: Not all watchonly txs could be deleted\");\n+            return false;\n+        }\n+    }\n+\n+    // Check the address book data in the same way we did for transactions\n+    std::vector<CTxDestination> dests_to_delete;\n+    for (const auto& addr_pair : m_address_book) {\n+        if (!IsMine(addr_pair.first)) {\n+            // Check the address book data is the watchonly wallet's\n+            if (data.watchonly_wallet) {\n+                LOCK(data.watchonly_wallet->cs_wallet);\n+                if (data.watchonly_wallet->IsMine(addr_pair.first)) {\n+                    // Add to the watchonly. Preserve the labels, purpose, and change-ness\n+                    std::string label = addr_pair.second.GetLabel();\n+                    std::string purpose = addr_pair.second.purpose;\n+                    if (!purpose.empty()) {\n+                        data.watchonly_wallet->m_address_book[addr_pair.first].purpose = purpose;\n+                    }\n+                    if (!addr_pair.second.IsChange()) {\n+                        data.watchonly_wallet->m_address_book[addr_pair.first].SetLabel(label);\n+                    }\n+                    dests_to_delete.push_back(addr_pair.first);\n+                    continue;\n+                }\n+            }\n+            if (data.solvable_wallet) {\n+                LOCK(data.solvable_wallet->cs_wallet);\n+                if (data.solvable_wallet->IsMine(addr_pair.first)) {\n+                    // Add to the solvable. Preserve the labels, purpose, and change-ness\n+                    std::string label = addr_pair.second.GetLabel();\n+                    std::string purpose = addr_pair.second.purpose;\n+                    if (!purpose.empty()) {\n+                        data.solvable_wallet->m_address_book[addr_pair.first].purpose = purpose;\n+                    }\n+                    if (!addr_pair.second.IsChange()) {\n+                        data.solvable_wallet->m_address_book[addr_pair.first].SetLabel(label);\n+                    }\n+                    dests_to_delete.push_back(addr_pair.first);\n+                    continue;\n+                }\n+            }\n+            // Not ours, not in watchonly wallet, and not in solvable\n+            error = _(\"Error: Address book data in wallet cannot be identified to belong to migrated wallets\");\n+            return false;\n+        }\n+    }\n+    // Remove the things to delete\n+    if (dests_to_delete.size() > 0) {\n+        for (const auto& dest : dests_to_delete) {\n+            if (!DelAddressBook(dest)) {\n+                error = _(\"Error: Unable to remove watchonly address book data\");\n+                return false;\n+            }\n+        }\n+    }\n+\n+    WalletLogPrintf(\"Wallet migration complete.\\n\");\n+\n+    return true;\n+}\n+\n+bool MigrateLegacyToDescriptor(CWallet& wallet, WalletContext& context, bilingual_str& error, std::vector<bilingual_str>& warnings)\n+{\n+    LOCK(wallet.cs_wallet);\n+\n+    // First change to using SQLite\n+\n+    // Remove this wallet from the list of wallets while we mess with the database\n+    // This is a workaround to prevent MaybeCompactWalletDB from accessing m_database while we are deleting and changing it\n+    std::shared_ptr<CWallet> this_wallet{nullptr};\n+    {\n+        LOCK(context.wallets_mutex);\n+        std::vector<std::shared_ptr<CWallet>>::iterator i = std::find_if(context.wallets.begin(), context.wallets.end(), [&wallet](std::shared_ptr<CWallet> w) {\n+                return w.get() == &wallet;\n+            });\n+        assert(i != context.wallets.end());\n+        this_wallet = *i;\n+        context.wallets.erase(i);\n+    }\n+    // Now do the database stuff\n+    if (!wallet.MigrateToSQLite(error ,warnings)) return false;\n+    // Put the wallet back in vpwallets because we are now done with messing with m_database\n+    {\n+        LOCK(context.wallets_mutex);\n+        context.wallets.push_back(this_wallet);\n+    }\n+\n+    // Then get all of the descriptors from the legacy wallet\n+    std::optional<MigrationData> data = wallet.GetDescriptorsForLegacy(error);\n+    if (data == std::nullopt) return false;\n+\n+    // Create the watchonly and solvable wallets if necessary\n+    if (data->watch_descs.size() > 0 || data->solvable_descs.size() > 0) {\n+        DatabaseOptions options;\n+        options.require_existing = false;\n+        options.require_create = true;\n+\n+        // Make the wallets\n+        options.create_flags = WALLET_FLAG_DISABLE_PRIVATE_KEYS | WALLET_FLAG_BLANK_WALLET | WALLET_FLAG_DESCRIPTORS;\n+        if (wallet.IsWalletFlagSet(WALLET_FLAG_AVOID_REUSE)) {\n+            options.create_flags |= WALLET_FLAG_AVOID_REUSE;\n+        }\n+        if (wallet.IsWalletFlagSet(WALLET_FLAG_KEY_ORIGIN_METADATA)) {\n+            options.create_flags |= WALLET_FLAG_KEY_ORIGIN_METADATA;\n+        }\n+        if (data->watch_descs.size() > 0) {\n+            wallet.WalletLogPrintf(\"Making a new watchonly wallet containing the watched scripts\\n\");\n+\n+            DatabaseStatus status;\n+            data->watchonly_wallet = CreateWallet(context, wallet.GetName() + \"_watchonly\", std::nullopt, options, status, error, warnings);\n+            if (status != DatabaseStatus::SUCCESS) {\n+                error = _(\"Error: Failed to create new watchonly wallet\");\n+                return false;\n+            }\n+            LOCK(data->watchonly_wallet->cs_wallet);\n+\n+            // Parse the descriptors and add them to the new wallet\n+            for (const std::string& desc_str : data->watch_descs) {\n+                // Parse the descriptor\n+                FlatSigningProvider keys;\n+                std::string parse_err;\n+                std::unique_ptr<Descriptor> desc = Parse(desc_str, keys, parse_err, /* require_checksum */ true);\n+                assert(desc); // It shouldn't be possible to have the LegacyScriptPubKeyMan make an invalid descriptor\n+                assert(!desc->IsRange()); // It shouldn't be possible to have LegacyScriptPubKeyMan make a ranged watchonly descriptor\n+\n+                // Add to the wallet\n+                WalletDescriptor w_desc(std::move(desc), 0, 0, 0, 0);\n+                data->watchonly_wallet->AddWalletDescriptor(w_desc, keys, \"\", false);\n+            }\n+        }\n+        if (data->solvable_descs.size() > 0) {\n+            wallet.WalletLogPrintf(\"Making a new watchonly wallet containing the unwatched solvable scripts\\n\");\n+\n+            DatabaseStatus status;\n+            data->solvable_wallet = CreateWallet(context, wallet.GetName() + \"_solvables\", std::nullopt, options, status, error, warnings);\n+            if (status != DatabaseStatus::SUCCESS) {\n+                error = _(\"Error: Failed to create new watchonly wallet\");\n+                return false;\n+            }\n+            LOCK(data->solvable_wallet->cs_wallet);\n+\n+            // Parse the descriptors and add them to the new wallet\n+            for (const std::string& desc_str : data->solvable_descs) {\n+                // Parse the descriptor\n+                FlatSigningProvider keys;\n+                std::string parse_err;\n+                std::unique_ptr<Descriptor> desc = Parse(desc_str, keys, parse_err, /* require_checksum */ true);\n+                assert(desc); // It shouldn't be possible to have the LegacyScriptPubKeyMan make an invalid descriptor\n+                assert(!desc->IsRange()); // It shouldn't be possible to have LegacyScriptPubKeyMan make a ranged watchonly descriptor\n+\n+                // Add to the wallet\n+                WalletDescriptor w_desc(std::move(desc), 0, 0, 0, 0);\n+                data->solvable_wallet->AddWalletDescriptor(w_desc, keys, \"\", false);\n+            }\n+        }\n+    }\n+\n+    // Add the descriptors to wallet, remove LegacyScriptPubKeyMan, and cleanup txs and address book data\n+    wallet.ApplyMigrationData(*data, error, warnings);\n+    return true;\n+}"
      },
      {
        "sha": "5512b460fe3c6b29a3bc3399cd4e5f6d437cf6b1",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 14,
        "deletions": 1,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8dc9266223fafecfdf30f41dd2f7c3779f35a62/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8dc9266223fafecfdf30f41dd2f7c3779f35a62/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=a8dc9266223fafecfdf30f41dd2f7c3779f35a62",
        "patch": "@@ -305,7 +305,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     std::string m_name;\n \n     /** Internal database handle. */\n-    std::unique_ptr<WalletDatabase> const m_database;\n+    std::unique_ptr<WalletDatabase> m_database;\n \n     /**\n      * The following is used to keep track of how far behind the wallet is\n@@ -877,6 +877,16 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n \n     //! Add a descriptor to the wallet, return a ScriptPubKeyMan & associated output type\n     ScriptPubKeyMan* AddWalletDescriptor(WalletDescriptor& desc, const FlatSigningProvider& signing_provider, const std::string& label, bool internal) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+\n+    //! Migrate a BDB wallet to SQLite wallet\n+    bool MigrateToSQLite(bilingual_str& error, std::vector<bilingual_str>& warnings) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+\n+    //! Get all of the descriptors from a legacy wallet\n+    std::optional<MigrationData> GetDescriptorsForLegacy(bilingual_str& error) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+\n+    //! Adds the ScriptPubKeyMans given in MigrationData, removes LegacyScriptPubKeyMan, and moves tx and address book\n+    //! to their relevant wallets.\n+    bool ApplyMigrationData(MigrationData& data, bilingual_str& error, std::vector<bilingual_str>& warnings) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n };\n \n /**\n@@ -927,4 +937,7 @@ bool RemoveWalletSetting(interfaces::Chain& chain, const std::string& wallet_nam\n \n bool DummySignInput(const SigningProvider& provider, CTxIn &tx_in, const CTxOut &txout, bool use_max_sig);\n \n+//! Do all steps to migrate a legacy wallet to a descriptor wallet\n+bool MigrateLegacyToDescriptor(CWallet& wallet, WalletContext& context, bilingual_str& error, std::vector<bilingual_str>& warnings);\n+\n #endif // BITCOIN_WALLET_WALLET_H"
      }
    ]
  },
  {
    "sha": "be79f455b66b85b0530728429557784b481be0d7",
    "node_id": "C_kwDOABII59oAKGJlNzlmNDU1YjY2Yjg1YjA1MzA3Mjg0Mjk1NTc3ODRiNDgxYmUwZDc",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-07-13T20:38:57Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-11-09T20:31:52Z"
      },
      "message": "Add migratewallet RPC",
      "tree": {
        "sha": "3b45ebbb8414f0e5bc7b0d844ca2ba3c1ed79643",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3b45ebbb8414f0e5bc7b0d844ca2ba3c1ed79643"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/be79f455b66b85b0530728429557784b481be0d7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be79f455b66b85b0530728429557784b481be0d7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/be79f455b66b85b0530728429557784b481be0d7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be79f455b66b85b0530728429557784b481be0d7/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a8dc9266223fafecfdf30f41dd2f7c3779f35a62",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a8dc9266223fafecfdf30f41dd2f7c3779f35a62",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a8dc9266223fafecfdf30f41dd2f7c3779f35a62"
      }
    ],
    "stats": {
      "total": 32,
      "additions": 32,
      "deletions": 0
    },
    "files": [
      {
        "sha": "83ca542b6423151db93a29253c655b496491a048",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be79f455b66b85b0530728429557784b481be0d7/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be79f455b66b85b0530728429557784b481be0d7/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=be79f455b66b85b0530728429557784b481be0d7",
        "patch": "@@ -4839,6 +4839,37 @@ static RPCHelpMan walletdisplayaddress()\n }\n #endif // ENABLE_EXTERNAL_SIGNER\n \n+static RPCHelpMan migratewallet()\n+{\n+    return RPCHelpMan{\"migratewallet\",\n+        \"\\nMigrate the wallet to a descriptor wallet.\\n\"\n+        \"A new wallet backup will need to be made.\",\n+        {},\n+        RPCResult{RPCResult::Type::NONE, \"\", \"\"},\n+        RPCExamples{\n+            HelpExampleCli(\"migratewallet\", \"\")\n+            + HelpExampleRpc(\"migratewallet\", \"\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    if (!wallet) return NullUniValue;\n+    CWallet* const pwallet = wallet.get();\n+\n+    EnsureWalletIsUnlocked(*pwallet);\n+\n+    WalletContext& context = EnsureWalletContext(request.context);\n+\n+    bilingual_str error;\n+    std::vector<bilingual_str> warnings;\n+    if (!MigrateLegacyToDescriptor(*pwallet, context, error, warnings)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, error.original);\n+    }\n+    return NullUniValue;\n+},\n+    };\n+}\n+\n RPCHelpMan abortrescan();\n RPCHelpMan dumpprivkey();\n RPCHelpMan importprivkey();\n@@ -4924,6 +4955,7 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             &walletpassphrase,               },\n     { \"wallet\",             &walletpassphrasechange,         },\n     { \"wallet\",             &walletprocesspsbt,              },\n+    { \"wallet\",             &migratewallet,                  },\n };\n // clang-format on\n     return MakeSpan(commands);"
      }
    ]
  },
  {
    "sha": "57a2c0beccd0527e417156bbf50f22d4618e8f82",
    "node_id": "C_kwDOABII59oAKDU3YTJjMGJlY2NkMDUyN2U0MTcxNTZiYmY1MGYyMmQ0NjE4ZThmODI",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-07-27T19:19:17Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-11-09T20:31:52Z"
      },
      "message": "descriptors: addr() and raw() should return false for ToPrivateString\n\nThey don't have any private data and they can't be nseted so they\nshould return false for ToPrivateString.",
      "tree": {
        "sha": "6570019a741474c8a714124caacacf3c8097c00c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6570019a741474c8a714124caacacf3c8097c00c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/57a2c0beccd0527e417156bbf50f22d4618e8f82",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/57a2c0beccd0527e417156bbf50f22d4618e8f82",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/57a2c0beccd0527e417156bbf50f22d4618e8f82",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/57a2c0beccd0527e417156bbf50f22d4618e8f82/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "be79f455b66b85b0530728429557784b481be0d7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be79f455b66b85b0530728429557784b481be0d7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/be79f455b66b85b0530728429557784b481be0d7"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 3,
      "deletions": 1
    },
    "files": [
      {
        "sha": "a3a42e85414d44208dd2d6e18113a1e3cf42977d",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/57a2c0beccd0527e417156bbf50f22d4618e8f82/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/57a2c0beccd0527e417156bbf50f22d4618e8f82/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=57a2c0beccd0527e417156bbf50f22d4618e8f82",
        "patch": "@@ -590,7 +590,7 @@ class DescriptorImpl : public Descriptor\n         return AddChecksum(ret);\n     }\n \n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const final\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n     {\n         bool ret = ToStringHelper(&arg, out, StringType::PRIVATE);\n         out = AddChecksum(out);\n@@ -676,6 +676,7 @@ class AddressDescriptor final : public DescriptorImpl\n         return OutputTypeFromDestination(m_destination);\n     }\n     bool IsSingleType() const final { return true; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const final { return false; }\n };\n \n /** A parsed raw(H) descriptor. */\n@@ -696,6 +697,7 @@ class RawDescriptor final : public DescriptorImpl\n         return OutputTypeFromDestination(dest);\n     }\n     bool IsSingleType() const final { return true; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const final { return false; }\n };\n \n /** A parsed pk(P) descriptor. */"
      }
    ]
  },
  {
    "sha": "05d0543dd50e85c0bef89264d8e68b323cadefba",
    "node_id": "C_kwDOABII59oAKDA1ZDA1NDNkZDUwZTg1YzBiZWY4OTI2NGQ4ZTY4YjMyM2NhZGVmYmE",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-07-27T20:00:11Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-11-09T20:42:20Z"
      },
      "message": "Test migratewallet",
      "tree": {
        "sha": "b91e73ca1daf4c1342ae4b64618e942a641a740f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b91e73ca1daf4c1342ae4b64618e942a641a740f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/05d0543dd50e85c0bef89264d8e68b323cadefba",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05d0543dd50e85c0bef89264d8e68b323cadefba",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/05d0543dd50e85c0bef89264d8e68b323cadefba",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05d0543dd50e85c0bef89264d8e68b323cadefba/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "57a2c0beccd0527e417156bbf50f22d4618e8f82",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/57a2c0beccd0527e417156bbf50f22d4618e8f82",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/57a2c0beccd0527e417156bbf50f22d4618e8f82"
      }
    ],
    "stats": {
      "total": 288,
      "additions": 288,
      "deletions": 0
    },
    "files": [
      {
        "sha": "9c982270779f98ac38e91c7e122a95abb7b194a5",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/05d0543dd50e85c0bef89264d8e68b323cadefba/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/05d0543dd50e85c0bef89264d8e68b323cadefba/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=05d0543dd50e85c0bef89264d8e68b323cadefba",
        "patch": "@@ -312,6 +312,7 @@\n     'rpc_help.py',\n     'feature_help.py',\n     'feature_shutdown.py',\n+    'wallet_migration.py',\n     'p2p_ibd_txrelay.py',\n     'feature_blockfilterindex_prune.py'\n     # Don't append tests at the end to avoid merge conflicts"
      },
      {
        "sha": "b64403be7507440c085f4d5c8779b2ec148f1ec0",
        "filename": "test/functional/wallet_migration.py",
        "status": "added",
        "additions": 287,
        "deletions": 0,
        "changes": 287,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/05d0543dd50e85c0bef89264d8e68b323cadefba/test/functional/wallet_migration.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/05d0543dd50e85c0bef89264d8e68b323cadefba/test/functional/wallet_migration.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_migration.py?ref=05d0543dd50e85c0bef89264d8e68b323cadefba",
        "patch": "@@ -0,0 +1,287 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test Migrating a wallet from legacy to descriptor.\"\"\"\n+\n+import os\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMigrationTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.supports_cli = False\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def assert_is_sqlite(self, wallet_name):\n+        wallet_file_path = os.path.join(self.nodes[0].datadir, \"regtest/wallets\", wallet_name, self.wallet_data_filename)\n+        with open(wallet_file_path, 'rb') as f:\n+            file_magic = f.read(16)\n+            assert_equal(file_magic, b'SQLite format 3\\x00')\n+        assert_equal(self.nodes[0].get_wallet_rpc(wallet_name).getwalletinfo()[\"format\"], \"sqlite\")\n+\n+    def test_basic(self):\n+        default = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+\n+        self.log.info(\"Test migration of a basic keys only wallet without balance\")\n+        self.nodes[0].createwallet(wallet_name=\"basic0\")\n+        basic0 = self.nodes[0].get_wallet_rpc(\"basic0\")\n+        assert_equal(basic0.getwalletinfo()[\"descriptors\"], False)\n+\n+        addr = basic0.getnewaddress()\n+        change = basic0.getrawchangeaddress()\n+\n+        assert_equal(basic0.getaddressinfo(addr)[\"ismine\"], True)\n+        assert_equal(basic0.getaddressinfo(change)[\"ismine\"], True)\n+\n+        basic0.migratewallet()\n+        assert_equal(basic0.getwalletinfo()[\"descriptors\"], True)\n+        self.assert_is_sqlite(\"basic0\")\n+\n+        addr_info = basic0.getaddressinfo(addr)\n+        assert_equal(addr_info[\"ismine\"], True)\n+        assert_equal(basic0.getaddressinfo(change)[\"ismine\"], True)\n+        assert_equal(addr_info[\"hdkeypath\"], \"m/0'/0'/0'\")\n+\n+        addr_info = basic0.getaddressinfo(basic0.getnewaddress(\"\", \"bech32\"))\n+        assert_equal(addr_info[\"hdkeypath\"], \"m/84'/1'/0'/0/0\")\n+\n+        self.log.info(\"Test migration of a basic keys only wallet with a balance\")\n+        self.nodes[0].createwallet(wallet_name=\"basic1\")\n+        basic1 = self.nodes[0].get_wallet_rpc(\"basic1\")\n+        assert_equal(basic1.getwalletinfo()[\"descriptors\"], False)\n+\n+        for i in range(0, 10):\n+            default.sendtoaddress(basic1.getnewaddress(), 1)\n+\n+        self.generate(self.nodes[0], 1)\n+\n+        for i in range(0, 5):\n+            basic1.sendtoaddress(default.getnewaddress(), 0.5)\n+\n+        self.generate(self.nodes[0], 1)\n+        bal = basic1.getbalance()\n+        txs = basic1.listtransactions()\n+\n+        basic1.migratewallet()\n+        assert_equal(basic1.getwalletinfo()[\"descriptors\"], True)\n+        self.assert_is_sqlite(\"basic1\")\n+        assert_equal(basic1.getbalance(), bal)\n+        assert_equal(basic1.listtransactions(), txs)\n+\n+    def test_multisig(self):\n+        default = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+\n+        # Contrived case where all the multisig keys are in a single wallet\n+        self.log.info(\"Test migration of a wallet with all keys for a multisig\")\n+        self.nodes[0].createwallet(wallet_name=\"multisig0\")\n+        multisig0 = self.nodes[0].get_wallet_rpc(\"multisig0\")\n+        assert_equal(multisig0.getwalletinfo()[\"descriptors\"], False)\n+        addr1 = multisig0.getnewaddress()\n+        addr2 = multisig0.getnewaddress()\n+        addr3 = multisig0.getnewaddress()\n+\n+        ms_info = multisig0.addmultisigaddress(2, [addr1, addr2, addr3])\n+\n+        multisig0.migratewallet()\n+        assert_equal(multisig0.getwalletinfo()[\"descriptors\"], True)\n+        self.assert_is_sqlite(\"multisig0\")\n+        ms_addr_info = multisig0.getaddressinfo(ms_info[\"address\"])\n+        assert_equal(ms_addr_info[\"ismine\"], True)\n+        assert_equal(ms_addr_info[\"desc\"], ms_info[\"descriptor\"])\n+        assert_equal(\"multisig0_watchonly\" in self.nodes[0].listwallets(), False)\n+        assert_equal(\"multisig0_solvables\" in self.nodes[0].listwallets(), False)\n+\n+        pub1 = multisig0.getaddressinfo(addr1)[\"pubkey\"]\n+        pub2 = multisig0.getaddressinfo(addr2)[\"pubkey\"]\n+\n+        # Some keys in multisig do not belong to this wallet\n+        self.log.info(\"Test migration of a wallet that has some keys in a multisig\")\n+        self.nodes[0].createwallet(wallet_name=\"multisig1\")\n+        multisig1 = self.nodes[0].get_wallet_rpc(\"multisig1\")\n+        ms_info = multisig1.addmultisigaddress(2, [multisig1.getnewaddress(), pub1, pub2])\n+        ms_info2 = multisig1.addmultisigaddress(2, [multisig1.getnewaddress(), pub1, pub2])\n+        assert_equal(multisig1.getwalletinfo()[\"descriptors\"], False)\n+\n+        addr = ms_info[\"address\"]\n+        txid = default.sendtoaddress(addr, 10)\n+        multisig1.importaddress(addr)\n+        assert_equal(multisig1.getaddressinfo(ms_info[\"address\"])[\"ismine\"], False)\n+        assert_equal(multisig1.getaddressinfo(ms_info[\"address\"])[\"iswatchonly\"], True)\n+        assert_equal(multisig1.getaddressinfo(ms_info[\"address\"])[\"solvable\"], True)\n+        self.generate(self.nodes[0], 1)\n+        multisig1.gettransaction(txid)\n+        assert_equal(multisig1.getbalances()[\"watchonly\"][\"trusted\"], 10)\n+        assert_equal(multisig1.getaddressinfo(ms_info2[\"address\"])[\"ismine\"], False)\n+        assert_equal(multisig1.getaddressinfo(ms_info2[\"address\"])[\"iswatchonly\"], False)\n+        assert_equal(multisig1.getaddressinfo(ms_info2[\"address\"])[\"solvable\"], True)\n+\n+        # Migrating multisig1 should see the multisig is no longer part of multisig1\n+        # A new wallet multisig1_watchonly is created which has the multisig address\n+        # Transaction to multisig is in multisig1_watchonly and not multisig1\n+        multisig1.migratewallet()\n+        assert_equal(multisig1.getwalletinfo()[\"descriptors\"], True)\n+        self.assert_is_sqlite(\"multisig1\")\n+        assert_equal(multisig1.getaddressinfo(ms_info[\"address\"])[\"ismine\"], False)\n+        assert_equal(multisig1.getaddressinfo(ms_info[\"address\"])[\"iswatchonly\"], False)\n+        assert_equal(multisig1.getaddressinfo(ms_info[\"address\"])[\"solvable\"], False)\n+        assert_raises_rpc_error(-5, \"Invalid or non-wallet transaction id\", multisig1.gettransaction, txid)\n+        assert_equal(multisig1.getbalance(), 0)\n+        assert_equal(multisig1.listtransactions(), [])\n+\n+        assert_equal(\"multisig1_watchonly\" in self.nodes[0].listwallets(), True)\n+        ms1_watchonly = self.nodes[0].get_wallet_rpc(\"multisig1_watchonly\")\n+        ms1_wallet_info = ms1_watchonly.getwalletinfo()\n+        assert_equal(ms1_wallet_info['descriptors'], True)\n+        assert_equal(ms1_wallet_info['private_keys_enabled'], False)\n+        self.assert_is_sqlite(\"multisig1_watchonly\")\n+        assert_equal(ms1_watchonly.getaddressinfo(ms_info[\"address\"])[\"ismine\"], True)\n+        assert_equal(ms1_watchonly.getaddressinfo(ms_info[\"address\"])[\"solvable\"], True)\n+        assert_equal(ms1_watchonly.getaddressinfo(ms_info2[\"address\"])[\"ismine\"], False)\n+        assert_equal(ms1_watchonly.getaddressinfo(ms_info2[\"address\"])[\"solvable\"], False)\n+        ms1_watchonly.gettransaction(txid)\n+        assert_equal(ms1_watchonly.getbalance(), 10)\n+\n+        # Migrating multisig1 should see the second multisig is no longer part of multisig1\n+        # A new wallet multisig1_solvables is created which has the second address\n+        # This should have no transactions\n+        assert_equal(\"multisig1_solvables\" in self.nodes[0].listwallets(), True)\n+        ms1_solvable = self.nodes[0].get_wallet_rpc(\"multisig1_solvables\")\n+        ms1_wallet_info = ms1_solvable.getwalletinfo()\n+        assert_equal(ms1_wallet_info['descriptors'], True)\n+        assert_equal(ms1_wallet_info['private_keys_enabled'], False)\n+        self.assert_is_sqlite(\"multisig1_solvables\")\n+        assert_equal(ms1_solvable.getaddressinfo(ms_info[\"address\"])[\"ismine\"], False)\n+        assert_equal(ms1_solvable.getaddressinfo(ms_info[\"address\"])[\"solvable\"], False)\n+        assert_equal(ms1_solvable.getaddressinfo(ms_info2[\"address\"])[\"ismine\"], True)\n+        assert_equal(ms1_solvable.getaddressinfo(ms_info2[\"address\"])[\"solvable\"], True)\n+        assert_equal(ms1_solvable.getbalance(), 0)\n+        assert_equal(ms1_solvable.listtransactions(), [])\n+\n+\n+    def test_other_watchonly(self):\n+        default = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+\n+        # Wallet with an imported address. Should be the same thing as the multisig test\n+        self.log.info(\"Test migration of a wallet with watchonly imports\")\n+        self.nodes[0].createwallet(wallet_name=\"imports0\")\n+        imports0 = self.nodes[0].get_wallet_rpc(\"imports0\")\n+        assert_equal(imports0.getwalletinfo()[\"descriptors\"], False)\n+\n+        addr = default.getnewaddress()\n+        imports0.importaddress(addr)\n+        txid = default.sendtoaddress(addr, 10)\n+        self.generate(self.nodes[0], 1)\n+\n+        imports0.gettransaction(txid)\n+        bal = imports0.getbalance(include_watchonly=True)\n+\n+        txid2 = default.sendtoaddress(imports0.getnewaddress(), 10)\n+        self.generate(self.nodes[0], 1)\n+        assert_equal(len(imports0.listtransactions(include_watchonly=True)), 2)\n+\n+        imports0.migratewallet()\n+        assert_equal(imports0.getwalletinfo()[\"descriptors\"], True)\n+        self.assert_is_sqlite(\"imports0\")\n+        assert_raises_rpc_error(-5, \"Invalid or non-wallet transaction id\", imports0.gettransaction, txid)\n+        assert_equal(len(imports0.listtransactions(include_watchonly=True)), 1)\n+        imports0.gettransaction(txid2)\n+\n+        assert_equal(\"imports0_watchonly\" in self.nodes[0].listwallets(), True)\n+        watchonly = self.nodes[0].get_wallet_rpc(\"imports0_watchonly\")\n+        watchonly_info = watchonly.getwalletinfo()\n+        assert_equal(watchonly_info[\"descriptors\"], True)\n+        self.assert_is_sqlite(\"imports0_watchonly\")\n+        assert_equal(watchonly_info[\"private_keys_enabled\"], False)\n+        watchonly.gettransaction(txid)\n+        assert_equal(watchonly.getbalance(), bal)\n+        assert_raises_rpc_error(-5, \"Invalid or non-wallet transaction id\", watchonly.gettransaction, txid2)\n+\n+    def test_no_privkeys(self):\n+        default = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+\n+        # Migrating an actual watchonly wallet should not create a new watchonly wallet\n+        self.log.info(\"Test migration of a pure watchonly wallet\")\n+        self.nodes[0].createwallet(wallet_name=\"watchonly0\", disable_private_keys=True)\n+        watchonly0 = self.nodes[0].get_wallet_rpc(\"watchonly0\")\n+        info = watchonly0.getwalletinfo()\n+        assert_equal(info[\"descriptors\"], False)\n+        assert_equal(info[\"private_keys_enabled\"], False)\n+\n+        addr = default.getnewaddress()\n+        desc = default.getaddressinfo(addr)[\"desc\"]\n+        res = watchonly0.importmulti([\n+            {\n+                \"desc\": desc,\n+                \"watchonly\": True,\n+                \"timestamp\": \"now\",\n+            }])\n+        assert_equal(res[0]['success'], True)\n+        default.sendtoaddress(addr, 10)\n+        self.generate(self.nodes[0], 1)\n+\n+        watchonly0.migratewallet()\n+        assert_equal(\"watchonly0_watchonly\" in self.nodes[0].listwallets(), False)\n+        info = watchonly0.getwalletinfo()\n+        assert_equal(info[\"descriptors\"], True)\n+        assert_equal(info[\"private_keys_enabled\"], False)\n+        self.assert_is_sqlite(\"watchonly0\")\n+\n+        # Migrating a wallet with pubkeys added to the keypool\n+        self.log.info(\"Test migration of a pure watchonly wallet with pubkeys in keypool\")\n+        self.nodes[0].createwallet(wallet_name=\"watchonly1\", disable_private_keys=True)\n+        watchonly1 = self.nodes[0].get_wallet_rpc(\"watchonly1\")\n+        info = watchonly1.getwalletinfo()\n+        assert_equal(info[\"descriptors\"], False)\n+        assert_equal(info[\"private_keys_enabled\"], False)\n+\n+        addr1 = default.getnewaddress(address_type=\"bech32\")\n+        addr2 = default.getnewaddress(address_type=\"bech32\")\n+        desc1 = default.getaddressinfo(addr1)[\"desc\"]\n+        desc2 = default.getaddressinfo(addr2)[\"desc\"]\n+        res = watchonly1.importmulti([\n+            {\n+                \"desc\": desc1,\n+                \"keypool\": True,\n+                \"timestamp\": \"now\",\n+            },\n+            {\n+                \"desc\": desc2,\n+                \"keypool\": True,\n+                \"timestamp\": \"now\",\n+            }\n+        ])\n+        assert_equal(res[0][\"success\"], True)\n+        assert_equal(res[1][\"success\"], True)\n+        # Before migrating, we can fetch addr1 from the keypool\n+        assert_equal(watchonly1.getnewaddress(address_type=\"bech32\"), addr1)\n+\n+        watchonly1.migratewallet()\n+        info = watchonly1.getwalletinfo()\n+        assert_equal(info[\"descriptors\"], True)\n+        assert_equal(info[\"private_keys_enabled\"], False)\n+        self.assert_is_sqlite(\"watchonly1\")\n+        # After migrating, the \"keypool\" is empty\n+        assert_raises_rpc_error(-4, \"Error: This wallet has no available keys\", watchonly1.getnewaddress)\n+\n+    def run_test(self):\n+        self.generate(self.nodes[0], 101)\n+\n+        # TODO: Test the actual records in the wallet for these tests too. The behavior may be correct, but the data written may not be what we actually want\n+        self.test_basic()\n+        self.test_multisig()\n+        self.test_other_watchonly()\n+        self.test_no_privkeys()\n+\n+if __name__ == '__main__':\n+    WalletMigrationTest().main()"
      }
    ]
  }
]