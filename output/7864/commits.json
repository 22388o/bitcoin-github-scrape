[
  {
    "sha": "8bb36316416bc3584829a0ed94532a7077c2d4db",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YmIzNjMxNjQxNmJjMzU4NDgyOWEwZWQ5NDUzMmE3MDc3YzJkNGRi",
    "commit": {
      "author": {
        "name": "Ryan.K",
        "email": "ryankung@ieee.org",
        "date": "2016-04-12T09:44:11Z"
      },
      "committer": {
        "name": "Ryan.K",
        "email": "ryankung@ieee.org",
        "date": "2016-04-12T09:44:11Z"
      },
      "message": "for pep8",
      "tree": {
        "sha": "c7f01f69fceee6f3e5663d40b5f761563b12c64e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c7f01f69fceee6f3e5663d40b5f761563b12c64e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8bb36316416bc3584829a0ed94532a7077c2d4db",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8bb36316416bc3584829a0ed94532a7077c2d4db",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8bb36316416bc3584829a0ed94532a7077c2d4db",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8bb36316416bc3584829a0ed94532a7077c2d4db/comments",
    "author": {
      "login": "RyanKung",
      "id": 662346,
      "node_id": "MDQ6VXNlcjY2MjM0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/662346?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RyanKung",
      "html_url": "https://github.com/RyanKung",
      "followers_url": "https://api.github.com/users/RyanKung/followers",
      "following_url": "https://api.github.com/users/RyanKung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RyanKung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RyanKung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RyanKung/subscriptions",
      "organizations_url": "https://api.github.com/users/RyanKung/orgs",
      "repos_url": "https://api.github.com/users/RyanKung/repos",
      "events_url": "https://api.github.com/users/RyanKung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RyanKung/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "RyanKung",
      "id": 662346,
      "node_id": "MDQ6VXNlcjY2MjM0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/662346?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RyanKung",
      "html_url": "https://github.com/RyanKung",
      "followers_url": "https://api.github.com/users/RyanKung/followers",
      "following_url": "https://api.github.com/users/RyanKung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RyanKung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RyanKung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RyanKung/subscriptions",
      "organizations_url": "https://api.github.com/users/RyanKung/orgs",
      "repos_url": "https://api.github.com/users/RyanKung/repos",
      "events_url": "https://api.github.com/users/RyanKung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RyanKung/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "934f2b5e769368d1a2407d41d53cafd5d51e6b36",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/934f2b5e769368d1a2407d41d53cafd5d51e6b36",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/934f2b5e769368d1a2407d41d53cafd5d51e6b36"
      }
    ],
    "stats": {
      "total": 63,
      "additions": 31,
      "deletions": 32
    },
    "files": [
      {
        "sha": "0f1a02ee196e8e6c45a030df24e295bf4ac52770",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 31,
        "deletions": 32,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8bb36316416bc3584829a0ed94532a7077c2d4db/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8bb36316416bc3584829a0ed94532a7077c2d4db/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=8bb36316416bc3584829a0ed94532a7077c2d4db",
        "patch": "@@ -31,33 +31,33 @@\n \n from tests_config import *\n \n-#If imported values are not defined then set to zero (or disabled)\n+# If imported values are not defined then set to zero (or disabled)\n if 'ENABLE_WALLET' not in vars():\n-    ENABLE_WALLET=0\n+    ENABLE_WALLET = 0\n if 'ENABLE_BITCOIND' not in vars():\n-    ENABLE_BITCOIND=0\n+    ENABLE_BITCOIND = 0\n if 'ENABLE_UTILS' not in vars():\n-    ENABLE_UTILS=0\n+    ENABLE_UTILS = 0\n if 'ENABLE_ZMQ' not in vars():\n-    ENABLE_ZMQ=0\n-    \n+    ENABLE_ZMQ = 0\n+\n # python-zmq may not be installed. Handle this gracefully and with some helpful info\n if ENABLE_ZMQ:\n     try:\n         import zmq\n     except ImportError:\n-        print(\"WARNING: \\\"import zmq\\\" failed. Setting ENABLE_ZMQ=0. \" \\\n-            \"To run zmq tests, see dependency info in /qa/README.md.\")\n-        ENABLE_ZMQ=0\n+        print('''WARNING: \\\"import zmq\\\" failed. Setting ENABLE_ZMQ=0. \"\n+        To run zmq tests, see dependency info in /qa/README.md.''')\n+        ENABLE_ZMQ = 0\n \n-ENABLE_COVERAGE=0\n+ENABLE_COVERAGE = 0\n \n-#Create a set to store arguments and create the passOn string\n+# Create a set to store arguments and create the passOn string\n opts = set()\n passOn = \"\"\n p = re.compile(\"^--\")\n \n-bold = (\"\",\"\")\n+bold = (\"\", \"\")\n if (os.name == 'posix'):\n     bold = ('\\033[0m', '\\033[1m')\n \n@@ -69,19 +69,19 @@\n     else:\n         opts.add(arg)\n \n-#Set env vars\n+# Set env vars\n buildDir = BUILDDIR\n if \"BITCOIND\" not in os.environ:\n     os.environ[\"BITCOIND\"] = buildDir + '/src/bitcoind' + EXEEXT\n if \"BITCOINCLI\" not in os.environ:\n     os.environ[\"BITCOINCLI\"] = buildDir + '/src/bitcoin-cli' + EXEEXT\n \n-#Disable Windows tests by default\n+# Disable Windows tests by default\n if EXEEXT == \".exe\" and \"-win\" not in opts:\n-    print \"Win tests currently disabled.  Use -win option to enable\"\n+    print(\"Win tests currently disabled.  Use -win option to enable\")\n     sys.exit(0)\n \n-#Tests\n+# Tests\n testScripts = [\n     'bip68-112-113-p2p.py',\n     'wallet.py',\n@@ -132,18 +132,18 @@\n     'txn_clone.py --mineblock',\n     'forknotify.py',\n     'invalidateblock.py',\n-#    'rpcbind_test.py', #temporary, bug in libevent, see #6655\n+    # 'rpcbind_test.py', #temporary, bug in libevent, see #6655\n     'smartfees.py',\n     'maxblocksinflight.py',\n     'p2p-acceptblock.py',\n     'mempool_packages.py',\n     'maxuploadtarget.py',\n     'replace-by-fee.py',\n     'p2p-feefilter.py',\n-    'pruning.py', # leave pruning last as it takes a REALLY long time\n+    'pruning.py',  # leave pruning last as it takes a REALLY long time\n ]\n \n-#Enable ZMQ tests\n+# Enable ZMQ tests\n if ENABLE_ZMQ == 1:\n     testScripts.append('zmq_test.py')\n \n@@ -161,13 +161,13 @@ def runtests():\n         cov_flag = coverage.flag if coverage else ''\n         flags = \" --srcdir %s/src %s %s\" % (buildDir, cov_flag, passOn)\n \n-        #Run Tests\n+        # Run Tests\n         for i in range(len(testScripts)):\n-            if (len(opts) == 0\n-                    or (len(opts) == 1 and \"-win\" in opts )\n-                    or run_extended\n-                    or testScripts[i] in opts\n-                    or re.sub(\".py$\", \"\", testScripts[i]) in opts ):\n+            if (any(len(opts) == 0,\n+                    (len(opts) == 1 and \"-win\" in opts),\n+                    run_extended,\n+                    testScripts[i] in opts,\n+                    re.sub(\".py$\", \"\", testScripts[i]) in opts)):\n \n                 print(\"Running testscript %s%s%s ...\" % (bold[1], testScripts[i], bold[0]))\n                 time0 = time.time()\n@@ -183,12 +183,11 @@ def runtests():\n \n         # Run Extended Tests\n         for i in range(len(testScriptsExt)):\n-            if (run_extended or testScriptsExt[i] in opts\n-                    or re.sub(\".py$\", \"\", testScriptsExt[i]) in opts):\n-\n-                print(\n-                    \"Running 2nd level testscript \"\n-                    + \"%s%s%s ...\" % (bold[1], testScriptsExt[i], bold[0]))\n+            if (any(run_extended,\n+                    testScriptsExt[i] in opts,\n+                    re.sub(\".py$\", \"\", testScriptsExt[i]) in opts)):\n+                print(\"Running 2nd level testscript %s%s%s ...\" % (\n+                    bold[1], testScriptsExt[i], bold[0]))\n                 time0 = time.time()\n                 subprocess.check_call(\n                     rpcTestDir + testScriptsExt[i] + flags, shell=True)\n@@ -201,7 +200,7 @@ def runtests():\n             coverage.cleanup()\n \n     else:\n-        print \"No rpc tests to run. Wallet, utils, and bitcoind must all be enabled\"\n+        print(\"No rpc tests to run. Wallet, utils, and bitcoind must all be enabled\")\n \n \n class RPCCoverage(object):"
      }
    ]
  },
  {
    "sha": "c36197e8ff3605726911876598b26921d1b127c8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMzYxOTdlOGZmMzYwNTcyNjkxMTg3NjU5OGIyNjkyMWQxYjEyN2M4",
    "commit": {
      "author": {
        "name": "Ryan.K",
        "email": "ryankung@ieee.org",
        "date": "2016-04-12T11:23:06Z"
      },
      "committer": {
        "name": "Ryan.K",
        "email": "ryankung@ieee.org",
        "date": "2016-04-12T11:23:06Z"
      },
      "message": "code style reflact (pep8)",
      "tree": {
        "sha": "ae899d25ed77e9e391ee0aa42d7de4e6ca401852",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ae899d25ed77e9e391ee0aa42d7de4e6ca401852"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c36197e8ff3605726911876598b26921d1b127c8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c36197e8ff3605726911876598b26921d1b127c8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c36197e8ff3605726911876598b26921d1b127c8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c36197e8ff3605726911876598b26921d1b127c8/comments",
    "author": {
      "login": "RyanKung",
      "id": 662346,
      "node_id": "MDQ6VXNlcjY2MjM0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/662346?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RyanKung",
      "html_url": "https://github.com/RyanKung",
      "followers_url": "https://api.github.com/users/RyanKung/followers",
      "following_url": "https://api.github.com/users/RyanKung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RyanKung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RyanKung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RyanKung/subscriptions",
      "organizations_url": "https://api.github.com/users/RyanKung/orgs",
      "repos_url": "https://api.github.com/users/RyanKung/repos",
      "events_url": "https://api.github.com/users/RyanKung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RyanKung/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "RyanKung",
      "id": 662346,
      "node_id": "MDQ6VXNlcjY2MjM0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/662346?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RyanKung",
      "html_url": "https://github.com/RyanKung",
      "followers_url": "https://api.github.com/users/RyanKung/followers",
      "following_url": "https://api.github.com/users/RyanKung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RyanKung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RyanKung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RyanKung/subscriptions",
      "organizations_url": "https://api.github.com/users/RyanKung/orgs",
      "repos_url": "https://api.github.com/users/RyanKung/repos",
      "events_url": "https://api.github.com/users/RyanKung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RyanKung/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8bb36316416bc3584829a0ed94532a7077c2d4db",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8bb36316416bc3584829a0ed94532a7077c2d4db",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8bb36316416bc3584829a0ed94532a7077c2d4db"
      }
    ],
    "stats": {
      "total": 288,
      "additions": 152,
      "deletions": 136
    },
    "files": [
      {
        "sha": "71c596adc651191bd8adbbcc0e6bb6186c73670e",
        "filename": "qa/rpc-tests/abandonconflict.py",
        "status": "modified",
        "additions": 26,
        "deletions": 23,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c36197e8ff3605726911876598b26921d1b127c8/qa/rpc-tests/abandonconflict.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c36197e8ff3605726911876598b26921d1b127c8/qa/rpc-tests/abandonconflict.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/abandonconflict.py?ref=c36197e8ff3605726911876598b26921d1b127c8",
        "patch": "@@ -11,12 +11,13 @@\n except ImportError:\n     import urlparse\n \n+\n class AbandonConflictTest(BitcoinTestFramework):\n \n     def setup_network(self):\n         self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\",\"-logtimemicros\",\"-minrelaytxfee=0.00001\"]))\n-        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\",\"-logtimemicros\"]))\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-logtimemicros\", \"-minrelaytxfee=0.00001\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-logtimemicros\"]))\n         connect_nodes(self.nodes[0], 1)\n \n     def run_test(self):\n@@ -31,21 +32,21 @@ def run_test(self):\n \n         sync_blocks(self.nodes)\n         newbalance = self.nodes[0].getbalance()\n-        assert(balance - newbalance < Decimal(\"0.001\")) #no more than fees lost\n+        assert(balance - newbalance < Decimal(\"0.001\"))  # no more than fees lost\n         balance = newbalance\n \n         url = urlparse.urlparse(self.nodes[1].url)\n-        self.nodes[0].disconnectnode(url.hostname+\":\"+str(p2p_port(1)))\n+        self.nodes[0].disconnectnode(url.hostname + \":\" + str(p2p_port(1)))\n \n         # Identify the 10btc outputs\n         nA = next(i for i, vout in enumerate(self.nodes[0].getrawtransaction(txA, 1)[\"vout\"]) if vout[\"value\"] == Decimal(\"10\"))\n         nB = next(i for i, vout in enumerate(self.nodes[0].getrawtransaction(txB, 1)[\"vout\"]) if vout[\"value\"] == Decimal(\"10\"))\n         nC = next(i for i, vout in enumerate(self.nodes[0].getrawtransaction(txC, 1)[\"vout\"]) if vout[\"value\"] == Decimal(\"10\"))\n \n-        inputs =[]\n+        inputs = []\n         # spend 10btc outputs from txA and txB\n-        inputs.append({\"txid\":txA, \"vout\":nA})\n-        inputs.append({\"txid\":txB, \"vout\":nB})\n+        inputs.append({\"txid\": txA, \"vout\": nA})\n+        inputs.append({\"txid\": txB, \"vout\": nB})\n         outputs = {}\n \n         outputs[self.nodes[0].getnewaddress()] = Decimal(\"14.99998\")\n@@ -56,10 +57,10 @@ def run_test(self):\n         # Identify the 14.99998btc output\n         nAB = next(i for i, vout in enumerate(self.nodes[0].getrawtransaction(txAB1, 1)[\"vout\"]) if vout[\"value\"] == Decimal(\"14.99998\"))\n \n-        #Create a child tx spending AB1 and C\n+        # Create a child tx spending AB1 and C\n         inputs = []\n-        inputs.append({\"txid\":txAB1, \"vout\":nAB})\n-        inputs.append({\"txid\":txC, \"vout\":nC})\n+        inputs.append({\"txid\": txAB1, \"vout\": nAB})\n+        inputs.append({\"txid\": txC, \"vout\": nC})\n         outputs = {}\n         outputs[self.nodes[0].getnewaddress()] = Decimal(\"24.9996\")\n         signed2 = self.nodes[0].signrawtransaction(self.nodes[0].createrawtransaction(inputs, outputs))\n@@ -73,8 +74,9 @@ def run_test(self):\n         # Restart the node with a higher min relay fee so the parent tx is no longer in mempool\n         # TODO: redo with eviction\n         # Note had to make sure tx did not have AllowFree priority\n-        stop_node(self.nodes[0],0)\n-        self.nodes[0]=start_node(0, self.options.tmpdir, [\"-debug\",\"-logtimemicros\",\"-minrelaytxfee=0.0001\"])\n+        stop_node(self.nodes[0], 0)\n+        self.nodes[0] = start_node(0, self.options.tmpdir,\n+                                   [\"-debug\", \"-logtimemicros\", \"-minrelaytxfee=0.0001\"])\n \n         # Verify txs no longer in mempool\n         assert(len(self.nodes[0].getrawmempool()) == 0)\n@@ -88,7 +90,7 @@ def run_test(self):\n         unconfbalance = self.nodes[0].getunconfirmedbalance() + self.nodes[0].getbalance()\n         assert(unconfbalance == newbalance)\n         # Also shouldn't show up in listunspent\n-        assert(not txABC2 in [utxo[\"txid\"] for utxo in self.nodes[0].listunspent(0)])\n+        assert(txABC2 not in [utxo[\"txid\"] for utxo in self.nodes[0].listunspent(0)])\n         balance = newbalance\n \n         # Abandon original transaction and verify inputs are available again\n@@ -99,8 +101,8 @@ def run_test(self):\n         balance = newbalance\n \n         # Verify that even with a low min relay fee, the tx is not reaccepted from wallet on startup once abandoned\n-        stop_node(self.nodes[0],0)\n-        self.nodes[0]=start_node(0, self.options.tmpdir, [\"-debug\",\"-logtimemicros\",\"-minrelaytxfee=0.00001\"])\n+        stop_node(self.nodes[0], 0)\n+        self.nodes[0] = start_node(0, self.options.tmpdir, [\"-debug\", \"-logtimemicros\", \"-minrelaytxfee=0.00001\"])\n         assert(len(self.nodes[0].getrawmempool()) == 0)\n         assert(self.nodes[0].getbalance() == balance)\n \n@@ -119,17 +121,18 @@ def run_test(self):\n         balance = newbalance\n \n         # Remove using high relay fee again\n-        stop_node(self.nodes[0],0)\n-        self.nodes[0]=start_node(0, self.options.tmpdir, [\"-debug\",\"-logtimemicros\",\"-minrelaytxfee=0.0001\"])\n+        stop_node(self.nodes[0], 0)\n+        self.nodes[0] = start_node(0, self.options.tmpdir,\n+                                   [\"-debug\", \"-logtimemicros\", \"-minrelaytxfee=0.0001\"])\n         assert(len(self.nodes[0].getrawmempool()) == 0)\n         newbalance = self.nodes[0].getbalance()\n         assert(newbalance == balance - Decimal(\"24.9996\"))\n         balance = newbalance\n \n         # Create a double spend of AB1 by spending again from only A's 10 output\n         # Mine double spend from node 1\n-        inputs =[]\n-        inputs.append({\"txid\":txA, \"vout\":nA})\n+        inputs = []\n+        inputs.append({\"txid\": txA, \"vout\": nA})\n         outputs = {}\n         outputs[self.nodes[1].getnewaddress()] = Decimal(\"9.9999\")\n         tx = self.nodes[0].createrawtransaction(inputs, outputs)\n@@ -150,10 +153,10 @@ def run_test(self):\n         # Don't think C's should either\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n         newbalance = self.nodes[0].getbalance()\n-        #assert(newbalance == balance - Decimal(\"10\"))\n-        print \"If balance has not declined after invalidateblock then out of mempool wallet tx which is no longer\"\n-        print \"conflicted has not resumed causing its inputs to be seen as spent.  See Issue #7315\"\n-        print balance , \" -> \" , newbalance , \" ?\"\n+        # assert(newbalance == balance - Decimal(\"10\"))\n+        print(\"If balance has not declined after invalidateblock then out of mempool wallet tx which is no longer\")\n+        print(\"conflicted has not resumed causing its inputs to be seen as spent.  See Issue #7315\")\n+        print(balance , \" -> \" , newbalance , \" ?\")\n \n if __name__ == '__main__':\n     AbandonConflictTest().main()"
      },
      {
        "sha": "3286b39e6ac48406d16add0efd0bdae144796766",
        "filename": "qa/rpc-tests/bip65-cltv-p2p.py",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c36197e8ff3605726911876598b26921d1b127c8/qa/rpc-tests/bip65-cltv-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c36197e8ff3605726911876598b26921d1b127c8/qa/rpc-tests/bip65-cltv-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bip65-cltv-p2p.py?ref=c36197e8ff3605726911876598b26921d1b127c8",
        "patch": "@@ -14,6 +14,7 @@\n from io import BytesIO\n import time\n \n+\n def cltv_invalidate(tx):\n     '''Modify the signature in vin 0 of the tx to fail CLTV\n \n@@ -36,6 +37,7 @@ def cltv_invalidate(tx):\n Mine 1 old version block, see that the node rejects.\n '''\n \n+\n class BIP65Test(ComparisonTestFramework):\n \n     def __init__(self):\n@@ -50,13 +52,13 @@ def setup_network(self):\n     def run_test(self):\n         test = TestManager(self, self.options.tmpdir)\n         test.add_all_connections(self.nodes)\n-        NetworkThread().start() # Start up network handling in another thread\n+        NetworkThread().start()  # Start up network handling in another thread\n         test.run()\n \n     def create_transaction(self, node, coinbase, to_address, amount):\n         from_txid = node.getblock(coinbase)['tx'][0]\n-        inputs = [{ \"txid\" : from_txid, \"vout\" : 0}]\n-        outputs = { to_address : amount }\n+        inputs = [{\"txid\": from_txid, \"vout\": 0}]\n+        outputs = {to_address: amount}\n         rawtx = node.createrawtransaction(inputs, outputs)\n         signresult = node.signrawtransaction(rawtx)\n         tx = CTransaction()\n@@ -68,7 +70,7 @@ def get_tests(self):\n \n         self.coinbase_blocks = self.nodes[0].generate(2)\n         height = 3  # height of the next block to build\n-        self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+        self.tip = int(\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n         self.nodeaddress = self.nodes[0].getnewaddress()\n         self.last_block_time = int(time.time())\n \n@@ -103,7 +105,7 @@ def get_tests(self):\n         version 3 block.\n         '''\n         spendtx = self.create_transaction(self.nodes[0],\n-                self.coinbase_blocks[0], self.nodeaddress, 1.0)\n+                                          self.coinbase_blocks[0], self.nodeaddress, 1.0)\n         cltv_invalidate(spendtx)\n         spendtx.rehash()\n \n@@ -124,7 +126,7 @@ def get_tests(self):\n         block.\n         '''\n         spendtx = self.create_transaction(self.nodes[0],\n-                self.coinbase_blocks[1], self.nodeaddress, 1.0)\n+                                          self.coinbase_blocks[1], self.nodeaddress, 1.0)\n         cltv_invalidate(spendtx)\n         spendtx.rehash()\n "
      },
      {
        "sha": "831049423b15e13e70cb62632ece40a96eb5838b",
        "filename": "qa/rpc-tests/bip65-cltv.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c36197e8ff3605726911876598b26921d1b127c8/qa/rpc-tests/bip65-cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c36197e8ff3605726911876598b26921d1b127c8/qa/rpc-tests/bip65-cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bip65-cltv.py?ref=c36197e8ff3605726911876598b26921d1b127c8",
        "patch": "@@ -10,6 +10,7 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n \n+\n class BIP65Test(BitcoinTestFramework):\n \n     def setup_network(self):"
      },
      {
        "sha": "98f3a452b749cb5598940a30f0216b6ba495c107",
        "filename": "qa/rpc-tests/bip68-112-113-p2p.py",
        "status": "modified",
        "additions": 117,
        "deletions": 107,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c36197e8ff3605726911876598b26921d1b127c8/qa/rpc-tests/bip68-112-113-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c36197e8ff3605726911876598b26921d1b127c8/qa/rpc-tests/bip68-112-113-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bip68-112-113-p2p.py?ref=c36197e8ff3605726911876598b26921d1b127c8",
        "patch": "@@ -56,10 +56,10 @@\n '''\n \n base_relative_locktime = 10\n-seq_disable_flag = 1<<31\n-seq_random_high_bit = 1<<25\n-seq_type_flag = 1<<22\n-seq_random_low_bit = 1<<18\n+seq_disable_flag = 1 << 31\n+seq_random_high_bit = 1 << 25\n+seq_type_flag = 1 << 22\n+seq_random_low_bit = 1 << 18\n \n # b31,b25,b22,b18 represent the 31st, 25th, 22nd and 18th bits respectively in the nSequence field\n # relative_locktimes[b31][b25][b22][b18] is a base_relative_locktime with the indicated bits set if their indices are 1\n@@ -85,6 +85,7 @@\n         b25times.append(b22times)\n     relative_locktimes.append(b25times)\n \n+\n def all_rlt_txs(txarray):\n     txs = []\n     for b31 in xrange(2):\n@@ -94,6 +95,7 @@ def all_rlt_txs(txarray):\n                     txs.append(txarray[b31][b25][b22][b18])\n     return txs\n \n+\n class BIP68_112_113Test(ComparisonTestFramework):\n     def __init__(self):\n         self.num_nodes = 1\n@@ -107,16 +109,17 @@ def setup_network(self):\n     def run_test(self):\n         test = TestManager(self, self.options.tmpdir)\n         test.add_all_connections(self.nodes)\n-        NetworkThread().start() # Start up network handling in another thread\n+        NetworkThread().start()  # Start up network handling in another thread\n         test.run()\n \n     def send_generic_input_tx(self, node, coinbases):\n         amount = Decimal(\"49.99\")\n-        return node.sendrawtransaction(ToHex(self.sign_transaction(node, self.create_transaction(node, node.getblock(coinbases.pop())['tx'][0], self.nodeaddress, amount))))\n+        transaction = self.create_transaction(node, node.getblock(coinbases.pop())['tx'][0], self.nodeaddress, amount)\n+        return node.sendrawtransaction(ToHex(self.sign_transaction(node, transaction)))\n \n     def create_transaction(self, node, txid, to_address, amount):\n-        inputs = [{ \"txid\" : txid, \"vout\" : 0}]\n-        outputs = { to_address : amount }\n+        inputs = [{\"txid\": txid, \"vout\": 0}]\n+        outputs = {to_address: amount}\n         rawtx = node.createrawtransaction(inputs, outputs)\n         tx = CTransaction()\n         f = BytesIO(unhexlify(rawtx))\n@@ -131,7 +134,7 @@ def sign_transaction(self, node, unsignedtx):\n         tx.deserialize(f)\n         return tx\n \n-    def generate_blocks(self, number, version, test_blocks = []):\n+    def generate_blocks(self, number, version, test_blocks=[]):\n         for i in xrange(number):\n             block = self.create_test_block([], version)\n             test_blocks.append([block, True])\n@@ -140,7 +143,7 @@ def generate_blocks(self, number, version, test_blocks = []):\n             self.tipheight += 1\n         return test_blocks\n \n-    def create_test_block(self, txs, version = 536870912):\n+    def create_test_block(self, txs, version=536870912):\n         block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600)\n         block.nVersion = version\n         block.vtx.extend(txs)\n@@ -149,7 +152,7 @@ def create_test_block(self, txs, version = 536870912):\n         block.solve()\n         return block\n \n-    def create_bip68txs(self, bip68inputs, txversion, locktime_delta = 0):\n+    def create_bip68txs(self, bip68inputs, txversion, locktime_delta=0):\n         txs = []\n         assert(len(bip68inputs) >= 16)\n         i = 0\n@@ -160,7 +163,7 @@ def create_bip68txs(self, bip68inputs, txversion, locktime_delta = 0):\n                 for b22 in xrange(2):\n                     b18txs = []\n                     for b18 in xrange(2):\n-                        tx =  self.create_transaction(self.nodes[0], bip68inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n+                        tx = self.create_transaction(self.nodes[0], bip68inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n                         i += 1\n                         tx.nVersion = txversion\n                         tx.vin[0].nSequence = relative_locktimes[b31][b25][b22][b18] + locktime_delta\n@@ -177,7 +180,7 @@ def create_bip112special(self, input, txversion):\n         signtx.vin[0].scriptSig = CScript([-1, OP_NOP3, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n         return signtx\n \n-    def create_bip112txs(self, bip112inputs, varyOP_CSV, txversion, locktime_delta = 0):\n+    def create_bip112txs(self, bip112inputs, varyOP_CSV, txversion, locktime_delta=0):\n         txs = []\n         assert(len(bip112inputs) >= 16)\n         i = 0\n@@ -188,65 +191,67 @@ def create_bip112txs(self, bip112inputs, varyOP_CSV, txversion, locktime_delta =\n                 for b22 in xrange(2):\n                     b18txs = []\n                     for b18 in xrange(2):\n-                        tx =  self.create_transaction(self.nodes[0], bip112inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n+                        tx = self.create_transaction(self.nodes[0], bip112inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n                         i += 1\n-                        if (varyOP_CSV): # if varying OP_CSV, nSequence is fixed\n+                        if (varyOP_CSV):  # if varying OP_CSV, nSequence is fixed\n                             tx.vin[0].nSequence = base_relative_locktime + locktime_delta\n-                        else: # vary nSequence instead, OP_CSV is fixed\n+                        else:  # vary nSequence instead, OP_CSV is fixed\n                             tx.vin[0].nSequence = relative_locktimes[b31][b25][b22][b18] + locktime_delta\n                         tx.nVersion = txversion\n                         signtx = self.sign_transaction(self.nodes[0], tx)\n                         if (varyOP_CSV):\n-                            signtx.vin[0].scriptSig = CScript([relative_locktimes[b31][b25][b22][b18], OP_NOP3, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+                            signtx.vin[0].scriptSig = CScript(\n+                                [relative_locktimes[b31][b25][b22][b18], OP_NOP3, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n                         else:\n-                            signtx.vin[0].scriptSig = CScript([base_relative_locktime, OP_NOP3, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+                            signtx.vin[0].scriptSig = CScript(\n+                                [base_relative_locktime, OP_NOP3, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n                         b18txs.append(signtx)\n                     b22txs.append(b18txs)\n                 b25txs.append(b22txs)\n             txs.append(b25txs)\n         return txs\n \n     def get_tests(self):\n-        long_past_time = int(time.time()) - 600 * 1000 # enough to build up to 1000 blocks 10 minutes apart without worrying about getting into the future\n-        self.nodes[0].setmocktime(long_past_time - 100) # enough so that the generated blocks will still all be before long_past_time\n-        self.coinbase_blocks = self.nodes[0].generate(1 + 16 + 2*32 + 1) # 82 blocks generated for inputs\n-        self.nodes[0].setmocktime(0) # set time back to present so yielded blocks aren't in the future as we advance last_block_time\n-        self.tipheight = 82 # height of the next block to build\n+        long_past_time = int(time.time()) - 600 * 1000  # enough to build up to 1000 blocks 10 minutes apart without worrying about getting into the future\n+        self.nodes[0].setmocktime(long_past_time - 100)  # enough so that the generated blocks will still all be before long_past_time\n+        self.coinbase_blocks = self.nodes[0].generate(1 + 16 + 2 * 32 + 1)  # 82 blocks generated for inputs\n+        self.nodes[0].setmocktime(0)  # set time back to present so yielded blocks aren't in the future as we advance last_block_time\n+        self.tipheight = 82  # height of the next block to build\n         self.last_block_time = long_past_time\n-        self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+        self.tip = int(\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n         self.nodeaddress = self.nodes[0].getnewaddress()\n \n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'defined')\n         test_blocks = self.generate_blocks(61, 4)\n-        yield TestInstance(test_blocks, sync_every_block=False) # 1\n+        yield TestInstance(test_blocks, sync_every_block=False)  # 1\n         # Advanced from DEFINED to STARTED, height = 143\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'started')\n \n         # Fail to achieve LOCKED_IN 100 out of 144 signal bit 0\n         # using a variety of bits to simulate multiple parallel softforks\n-        test_blocks = self.generate_blocks(50, 536870913) # 0x20000001 (signalling ready)\n-        test_blocks = self.generate_blocks(20, 4, test_blocks) # 0x00000004 (signalling not)\n-        test_blocks = self.generate_blocks(50, 536871169, test_blocks) # 0x20000101 (signalling ready)\n-        test_blocks = self.generate_blocks(24, 536936448, test_blocks) # 0x20010000 (signalling not)\n-        yield TestInstance(test_blocks, sync_every_block=False) # 2\n+        test_blocks = self.generate_blocks(50, 536870913)  # 0x20000001 (signalling ready)\n+        test_blocks = self.generate_blocks(20, 4, test_blocks)  # 0x00000004 (signalling not)\n+        test_blocks = self.generate_blocks(50, 536871169, test_blocks)  # 0x20000101 (signalling ready)\n+        test_blocks = self.generate_blocks(24, 536936448, test_blocks)  # 0x20010000 (signalling not)\n+        yield TestInstance(test_blocks, sync_every_block=False)  # 2\n         # Failed to advance past STARTED, height = 287\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'started')\n \n         # 108 out of 144 signal bit 0 to achieve lock-in\n         # using a variety of bits to simulate multiple parallel softforks\n-        test_blocks = self.generate_blocks(58, 536870913) # 0x20000001 (signalling ready)\n-        test_blocks = self.generate_blocks(26, 4, test_blocks) # 0x00000004 (signalling not)\n-        test_blocks = self.generate_blocks(50, 536871169, test_blocks) # 0x20000101 (signalling ready)\n-        test_blocks = self.generate_blocks(10, 536936448, test_blocks) # 0x20010000 (signalling not)\n-        yield TestInstance(test_blocks, sync_every_block=False) # 3\n+        test_blocks = self.generate_blocks(58, 536870913)  # 0x20000001 (signalling ready)\n+        test_blocks = self.generate_blocks(26, 4, test_blocks)  # 0x00000004 (signalling not)\n+        test_blocks = self.generate_blocks(50, 536871169, test_blocks)  # 0x20000101 (signalling ready)\n+        test_blocks = self.generate_blocks(10, 536936448, test_blocks)  # 0x20010000 (signalling not)\n+        yield TestInstance(test_blocks, sync_every_block=False)  # 3\n         # Advanced from STARTED to LOCKED_IN, height = 431\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'locked_in')\n \n         # 140 more version 4 blocks\n         test_blocks = self.generate_blocks(140, 4)\n-        yield TestInstance(test_blocks, sync_every_block=False) # 4\n+        yield TestInstance(test_blocks, sync_every_block=False)  # 4\n \n-        ### Inputs at height = 572\n+        # Inputs at height = 572\n         # Put inputs for all tests in the chain at height 572 (tip now = 571) (time increases by 600s per block)\n         # Note we reuse inputs for v1 and v2 txs so must test these separately\n         # 16 normal inputs\n@@ -273,16 +278,16 @@ def get_tests(self):\n         bip113input = self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n \n         self.nodes[0].setmocktime(self.last_block_time + 600)\n-        inputblockhash = self.nodes[0].generate(1)[0] # 1 block generated for inputs to be in chain at height 572\n+        inputblockhash = self.nodes[0].generate(1)[0]  # 1 block generated for inputs to be in chain at height 572\n         self.nodes[0].setmocktime(0)\n         self.tip = int(\"0x\" + inputblockhash + \"L\", 0)\n         self.tipheight += 1\n         self.last_block_time += 600\n-        assert_equal(len(self.nodes[0].getblock(inputblockhash,True)[\"tx\"]), 82+1)\n+        assert_equal(len(self.nodes[0].getblock(inputblockhash, True)[\"tx\"]), 82 + 1)\n \n         # 2 more version 4 blocks\n         test_blocks = self.generate_blocks(2, 4)\n-        yield TestInstance(test_blocks, sync_every_block=False) # 5\n+        yield TestInstance(test_blocks, sync_every_block=False)  # 5\n         # Not yet advanced to ACTIVE, height = 574 (will activate for block 576, not 575)\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'locked_in')\n \n@@ -315,16 +320,17 @@ def get_tests(self):\n         bip112tx_special_v1 = self.create_bip112special(bip112specialinput, 1)\n         bip112tx_special_v2 = self.create_bip112special(bip112specialinput, 2)\n \n-\n-        ### TESTING ###\n-        ##################################\n-        ### Before Soft Forks Activate ###\n-        ##################################\n-        # All txs should pass\n-        ### Version 1 txs ###\n+        '''\n+        *** TESTING ***\n+        **********************************\n+        *** Before Soft Forks Activate ***\n+        **********************************\n+        * All txs should pass\n+        *** Version 1 txs ***\n+        '''\n         success_txs = []\n         # add BIP113 tx and -1 CSV tx\n-        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n         bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n         success_txs.append(bip113signed1)\n         success_txs.append(bip112tx_special_v1)\n@@ -336,13 +342,13 @@ def get_tests(self):\n         # try BIP 112 with seq=9 txs\n         success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v1))\n         success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_9_v1))\n-        yield TestInstance([[self.create_test_block(success_txs), True]]) # 6\n+        yield TestInstance([[self.create_test_block(success_txs), True]])  # 6\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n-        ### Version 2 txs ###\n+        # Version 2 txs\n         success_txs = []\n         # add BIP113 tx and -1 CSV tx\n-        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n         bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n         success_txs.append(bip113signed2)\n         success_txs.append(bip112tx_special_v2)\n@@ -354,104 +360,106 @@ def get_tests(self):\n         # try BIP 112 with seq=9 txs\n         success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v2))\n         success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_9_v2))\n-        yield TestInstance([[self.create_test_block(success_txs), True]]) # 7\n+        yield TestInstance([[self.create_test_block(success_txs), True]])  # 7\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n-\n         # 1 more version 4 block to get us to height 575 so the fork should now be active for the next block\n         test_blocks = self.generate_blocks(1, 4)\n-        yield TestInstance(test_blocks, sync_every_block=False) # 8\n+        yield TestInstance(test_blocks, sync_every_block=False)  # 8\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'active')\n \n-\n-        #################################\n-        ### After Soft Forks Activate ###\n-        #################################\n-        ### BIP 113 ###\n+        '''\n+        *********************************\n+        *** After Soft Forks Activate ***\n+        *********************************\n+        *** BIP 113 ***\n+        '''\n         # BIP 113 tests should now fail regardless of version number if nLockTime isn't satisfied by new rules\n-        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n         bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n-        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n         bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n         for bip113tx in [bip113signed1, bip113signed2]:\n-            yield TestInstance([[self.create_test_block([bip113tx]), False]]) # 9,10\n+            yield TestInstance([[self.create_test_block([bip113tx]), False]])  # 9,10\n         # BIP 113 tests should now pass if the locktime is < MTP\n-        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 - 1 # < MTP of prior block\n+        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 - 1  # < MTP of prior block\n         bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n-        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 - 1 # < MTP of prior block\n+        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 - 1  # < MTP of prior block\n         bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n         for bip113tx in [bip113signed1, bip113signed2]:\n-            yield TestInstance([[self.create_test_block([bip113tx]), True]]) # 11,12\n+            yield TestInstance([[self.create_test_block([bip113tx]), True]])  # 11,12\n             self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         # Next block height = 580 after 4 blocks of random version\n         test_blocks = self.generate_blocks(4, 1234)\n-        yield TestInstance(test_blocks, sync_every_block=False) # 13\n-\n-        ### BIP 68 ###\n-        ### Version 1 txs ###\n-        # All still pass\n+        yield TestInstance(test_blocks, sync_every_block=False)  # 13\n+        '''\n+        *** BIP 68 ***\n+        *** Version 1 txs ***\n+        * All still pass\n+        '''\n         success_txs = []\n         success_txs.extend(all_rlt_txs(bip68txs_v1))\n-        yield TestInstance([[self.create_test_block(success_txs), True]]) # 14\n+        yield TestInstance([[self.create_test_block(success_txs), True]])  # 14\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n-        ### Version 2 txs ###\n+        # Version 2 txs\n         bip68success_txs = []\n         # All txs with SEQUENCE_LOCKTIME_DISABLE_FLAG set pass\n         for b25 in xrange(2):\n             for b22 in xrange(2):\n                 for b18 in xrange(2):\n                     bip68success_txs.append(bip68txs_v2[1][b25][b22][b18])\n-        yield TestInstance([[self.create_test_block(bip68success_txs), True]]) # 15\n+        yield TestInstance([[self.create_test_block(bip68success_txs), True]])  # 15\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n         # All txs without flag fail as we are at delta height = 8 < 10 and delta time = 8 * 600 < 10 * 512\n         bip68timetxs = []\n         for b25 in xrange(2):\n             for b18 in xrange(2):\n                 bip68timetxs.append(bip68txs_v2[0][b25][1][b18])\n         for tx in bip68timetxs:\n-            yield TestInstance([[self.create_test_block([tx]), False]]) # 16 - 19\n+            yield TestInstance([[self.create_test_block([tx]), False]])  # 16 - 19\n         bip68heighttxs = []\n         for b25 in xrange(2):\n             for b18 in xrange(2):\n                 bip68heighttxs.append(bip68txs_v2[0][b25][0][b18])\n         for tx in bip68heighttxs:\n-            yield TestInstance([[self.create_test_block([tx]), False]]) # 20 - 23\n+            yield TestInstance([[self.create_test_block([tx]), False]])  # 20 - 23\n \n         # Advance one block to 581\n         test_blocks = self.generate_blocks(1, 1234)\n-        yield TestInstance(test_blocks, sync_every_block=False) # 24\n+        yield TestInstance(test_blocks, sync_every_block=False)  # 24\n \n         # Height txs should fail and time txs should now pass 9 * 600 > 10 * 512\n         bip68success_txs.extend(bip68timetxs)\n-        yield TestInstance([[self.create_test_block(bip68success_txs), True]]) # 25\n+        yield TestInstance([[self.create_test_block(bip68success_txs), True]])  # 25\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n         for tx in bip68heighttxs:\n-            yield TestInstance([[self.create_test_block([tx]), False]]) # 26 - 29\n+            yield TestInstance([[self.create_test_block([tx]), False]])  # 26 - 29\n \n         # Advance one block to 582\n         test_blocks = self.generate_blocks(1, 1234)\n-        yield TestInstance(test_blocks, sync_every_block=False) # 30\n+        yield TestInstance(test_blocks, sync_every_block=False)  # 30\n \n         # All BIP 68 txs should pass\n         bip68success_txs.extend(bip68heighttxs)\n-        yield TestInstance([[self.create_test_block(bip68success_txs), True]]) # 31\n+        yield TestInstance([[self.create_test_block(bip68success_txs), True]])  # 31\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n-\n-        ### BIP 112 ###\n-        ### Version 1 txs ###\n-        # -1 OP_CSV tx should fail\n-        yield TestInstance([[self.create_test_block([bip112tx_special_v1]), False]]) #32\n+        '''\n+        *** BIP 112 ***\n+        *** Version 1 txs ***\n+        * -1 OP_CSV tx should fail\n+        '''\n+        yield TestInstance([[self.create_test_block([bip112tx_special_v1]), False]])  # 32\n         # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in argument to OP_CSV, version 1 txs should still pass\n         success_txs = []\n         for b25 in xrange(2):\n             for b22 in xrange(2):\n                 for b18 in xrange(2):\n                     success_txs.append(bip112txs_vary_OP_CSV_v1[1][b25][b22][b18])\n                     success_txs.append(bip112txs_vary_OP_CSV_9_v1[1][b25][b22][b18])\n-        yield TestInstance([[self.create_test_block(success_txs), True]]) # 33\n+        yield TestInstance([[self.create_test_block(success_txs), True]])  # 33\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         # If SEQUENCE_LOCKTIME_DISABLE_FLAG is unset in argument to OP_CSV, version 1 txs should now fail\n@@ -465,60 +473,60 @@ def get_tests(self):\n                     fail_txs.append(bip112txs_vary_OP_CSV_9_v1[0][b25][b22][b18])\n \n         for tx in fail_txs:\n-            yield TestInstance([[self.create_test_block([tx]), False]]) # 34 - 81\n+            yield TestInstance([[self.create_test_block([tx]), False]])  # 34 - 81\n \n-        ### Version 2 txs ###\n+        # Version 2 txs\n         # -1 OP_CSV tx should fail\n-        yield TestInstance([[self.create_test_block([bip112tx_special_v2]), False]]) #82\n+        yield TestInstance([[self.create_test_block([bip112tx_special_v2]), False]])  # 82\n \n         # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in argument to OP_CSV, version 2 txs should pass (all sequence locks are met)\n         success_txs = []\n         for b25 in xrange(2):\n             for b22 in xrange(2):\n                 for b18 in xrange(2):\n-                    success_txs.append(bip112txs_vary_OP_CSV_v2[1][b25][b22][b18]) # 8/16 of vary_OP_CSV\n-                    success_txs.append(bip112txs_vary_OP_CSV_9_v2[1][b25][b22][b18]) # 8/16 of vary_OP_CSV_9\n+                    success_txs.append(bip112txs_vary_OP_CSV_v2[1][b25][b22][b18])  # 8/16 of vary_OP_CSV\n+                    success_txs.append(bip112txs_vary_OP_CSV_9_v2[1][b25][b22][b18])  # 8/16 of vary_OP_CSV_9\n \n-        yield TestInstance([[self.create_test_block(success_txs), True]]) # 83\n+        yield TestInstance([[self.create_test_block(success_txs), True]])  # 83\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n-        ## SEQUENCE_LOCKTIME_DISABLE_FLAG is unset in argument to OP_CSV for all remaining txs ##\n+        # SEQUENCE_LOCKTIME_DISABLE_FLAG is unset in argument to OP_CSV for all remaining txs ##\n         # All txs with nSequence 9 should fail either due to earlier mismatch or failing the CSV check\n         fail_txs = []\n-        fail_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v2)) # 16/16 of vary_nSequence_9\n+        fail_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v2))  # 16/16 of vary_nSequence_9\n         for b25 in xrange(2):\n             for b22 in xrange(2):\n                 for b18 in xrange(2):\n-                    fail_txs.append(bip112txs_vary_OP_CSV_9_v2[0][b25][b22][b18]) # 16/16 of vary_OP_CSV_9\n+                    fail_txs.append(bip112txs_vary_OP_CSV_9_v2[0][b25][b22][b18])  # 16/16 of vary_OP_CSV_9\n \n         for tx in fail_txs:\n-            yield TestInstance([[self.create_test_block([tx]), False]]) # 84 - 107\n+            yield TestInstance([[self.create_test_block([tx]), False]])  # 84 - 107\n \n         # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in nSequence, tx should fail\n         fail_txs = []\n         for b25 in xrange(2):\n             for b22 in xrange(2):\n                 for b18 in xrange(2):\n-                    fail_txs.append(bip112txs_vary_nSequence_v2[1][b25][b22][b18]) # 8/16 of vary_nSequence\n+                    fail_txs.append(bip112txs_vary_nSequence_v2[1][b25][b22][b18])  # 8/16 of vary_nSequence\n         for tx in fail_txs:\n-            yield TestInstance([[self.create_test_block([tx]), False]]) # 108-115\n+            yield TestInstance([[self.create_test_block([tx]), False]])  # 108-115\n \n         # If sequencelock types mismatch, tx should fail\n         fail_txs = []\n         for b25 in xrange(2):\n             for b18 in xrange(2):\n-                fail_txs.append(bip112txs_vary_nSequence_v2[0][b25][1][b18]) # 12/16 of vary_nSequence\n-                fail_txs.append(bip112txs_vary_OP_CSV_v2[0][b25][1][b18]) # 12/16 of vary_OP_CSV\n+                fail_txs.append(bip112txs_vary_nSequence_v2[0][b25][1][b18])  # 12/16 of vary_nSequence\n+                fail_txs.append(bip112txs_vary_OP_CSV_v2[0][b25][1][b18])  # 12/16 of vary_OP_CSV\n         for tx in fail_txs:\n-            yield TestInstance([[self.create_test_block([tx]), False]]) # 116-123\n+            yield TestInstance([[self.create_test_block([tx]), False]])  # 116-123\n \n         # Remaining txs should pass, just test masking works properly\n         success_txs = []\n         for b25 in xrange(2):\n             for b18 in xrange(2):\n-                success_txs.append(bip112txs_vary_nSequence_v2[0][b25][0][b18]) # 16/16 of vary_nSequence\n-                success_txs.append(bip112txs_vary_OP_CSV_v2[0][b25][0][b18]) # 16/16 of vary_OP_CSV\n-        yield TestInstance([[self.create_test_block(success_txs), True]]) # 124\n+                success_txs.append(bip112txs_vary_nSequence_v2[0][b25][0][b18])  # 16/16 of vary_nSequence\n+                success_txs.append(bip112txs_vary_OP_CSV_v2[0][b25][0][b18])  # 16/16 of vary_OP_CSV\n+        yield TestInstance([[self.create_test_block(success_txs), True]])  # 124\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         # Additional test, of checking that comparison of two time types works properly\n@@ -529,11 +537,13 @@ def get_tests(self):\n                 tx.vin[0].nSequence = base_relative_locktime | seq_type_flag\n                 signtx = self.sign_transaction(self.nodes[0], tx)\n                 time_txs.append(signtx)\n-        yield TestInstance([[self.create_test_block(time_txs), True]]) # 125\n+        yield TestInstance([[self.create_test_block(time_txs), True]])  # 125\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n-        ### Missing aspects of test\n-        ##  Testing empty stack fails\n+        '''\n+        *** Missing aspects of test\n+        **  Testing empty stack fails\n+        '''\n \n \n if __name__ == '__main__':"
      }
    ]
  }
]