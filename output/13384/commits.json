[
  {
    "sha": "fa35a022e929948ee13b76093ab5c9907f3c4209",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTM1YTAyMmU5Mjk5NDhlZTEzYjc2MDkzYWI1Yzk5MDdmM2M0MjA5",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-06-03T17:10:54Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-06-03T19:26:16Z"
      },
      "message": "qa: Remove polling loop from test_runner",
      "tree": {
        "sha": "2ba28f5a948a09af2c08e2afc89458d2135dbf5b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2ba28f5a948a09af2c08e2afc89458d2135dbf5b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa35a022e929948ee13b76093ab5c9907f3c4209",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGcBAABCgAGBQJbFEDYAAoJEM4rdWl+aaVIVGIMAJZ4NqacrWPSWGobOJji1z5t\nBi6tOymR10MsodYW21/BctNr7cpmRGbSFMScyYcLdOC5c+Wrf/qb123df8NDVx6q\ntJ8fGSHE45Ib+oVu/fUmgovS1WGH3zalmKVXRtoC9gNJ3O+cqQRGrISPJkzOuDxF\nLieQLEHJag19Oe08SeHiMHqj/wNQxN4RVp32w5mrpnKVvd6VkDuyb6mueEK2mZVo\npxllVtO4QiSeMhzR/qJ3IuGB/RMUSHckQDQDNWzdjj9FHWZ9lfgQ+xSKZlIC7mAV\ntG6x2nPID5I/PSbMHoEFHZQOd04Po0WcdYr8oYTxF0bkw1cjyEV6RiJFX0RUzvwT\n2SlEYqHPhlTbkNj7d7mNApSxPQ0P1KqHKjaKvhpOh6XDZ5+L1wyoIFMWRZitvexB\nA89MrKWNl3V9O8NIz7oxo4VLOa3YVPLcdFRFW0Dy0pI8raGVYi26x/p7Jn50wxNB\nsjpM1QZ2qrl+ejXz8kBjCI+KA7xhhwjEVQWzzQ7IFA==\n=Ejvr\n-----END PGP SIGNATURE-----",
        "payload": "tree 2ba28f5a948a09af2c08e2afc89458d2135dbf5b\nparent 472fe8a2ce9f08f0311e4a04eef996eba19ff985\nauthor MarcoFalke <falke.marco@gmail.com> 1528045854 -0400\ncommitter MarcoFalke <falke.marco@gmail.com> 1528053976 -0400\n\nqa: Remove polling loop from test_runner\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa35a022e929948ee13b76093ab5c9907f3c4209",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa35a022e929948ee13b76093ab5c9907f3c4209",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa35a022e929948ee13b76093ab5c9907f3c4209/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "472fe8a2ce9f08f0311e4a04eef996eba19ff985",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/472fe8a2ce9f08f0311e4a04eef996eba19ff985",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/472fe8a2ce9f08f0311e4a04eef996eba19ff985"
      }
    ],
    "stats": {
      "total": 104,
      "additions": 35,
      "deletions": 69
    },
    "files": [
      {
        "sha": "edc60fbf5fc95885c657cae8b77eaedbec41df1c",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 35,
        "deletions": 69,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa35a022e929948ee13b76093ab5c9907f3c4209/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa35a022e929948ee13b76093ab5c9907f3c4209/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=fa35a022e929948ee13b76093ab5c9907f3c4209",
        "patch": "@@ -16,12 +16,13 @@\n \n import argparse\n from collections import deque\n+from concurrent.futures import ThreadPoolExecutor, as_completed\n import configparser\n import datetime\n+import math\n import os\n import time\n import shutil\n-import signal\n import sys\n import subprocess\n import tempfile\n@@ -333,14 +334,16 @@ def run_tests(test_list, src_dir, build_dir, tmpdir, jobs=1, enable_coverage=Fal\n             raise\n \n     #Run Tests\n-    job_queue = TestHandler(jobs, tests_dir, tmpdir, test_list, flags)\n+    job_queue = TestHandler(jobs, tests_dir, tmpdir, test_list, flags).jobs\n     start_time = time.time()\n     test_results = []\n \n     max_len_name = len(max(test_list, key=len))\n \n-    for _ in range(len(test_list)):\n-        test_result, testdir, stdout, stderr = job_queue.get_next()\n+    for future in as_completed(job_queue):\n+        if future.cancelled():\n+            continue\n+        test_result, testdir, stdout, stderr = future.result()\n         test_results.append(test_result)\n \n         if test_result.status == \"Passed\":\n@@ -362,7 +365,9 @@ def run_tests(test_list, src_dir, build_dir, tmpdir, jobs=1, enable_coverage=Fal\n \n             if failfast:\n                 logging.debug(\"Early exiting after test failure\")\n-                break\n+                for f in job_queue:\n+                    f.cancel()\n+                logging.debug(\"Waiting for unfinished jobs ...\")\n \n     print_results(test_results, max_len_name, (int(time.time() - start_time)))\n \n@@ -378,10 +383,6 @@ def run_tests(test_list, src_dir, build_dir, tmpdir, jobs=1, enable_coverage=Fal\n \n     all_passed = all(map(lambda test_result: test_result.was_successful, test_results))\n \n-    # This will be a no-op unless failfast is True in which case there may be dangling\n-    # processes which need to be killed.\n-    job_queue.kill_and_join()\n-\n     sys.exit(not all_passed)\n \n def print_results(test_results, max_len_name, runtime):\n@@ -411,77 +412,42 @@ class TestHandler:\n     Trigger the test scripts passed in via the list.\n     \"\"\"\n \n+    @staticmethod\n+    def _run_test(name, proc_args, testdir, log_out, log_err):\n+        start_time = time.time()\n+        ret_code = subprocess.call(proc_args, universal_newlines=True, stdout=log_out, stderr=log_err, timeout=None if not os.getenv('TRAVIS') == 'true' else TRAVIS_TIMEOUT_DURATION)\n+        duration = int(math.ceil(time.time() - start_time))\n+        log_out.seek(0), log_err.seek(0)\n+        [stdout, stderr] = [log_file.read().decode('utf-8') for log_file in (log_out, log_err)]\n+        log_out.close(), log_err.close()\n+        if ret_code == TEST_EXIT_PASSED and stderr == \"\":\n+            status = \"Passed\"\n+        elif ret_code == TEST_EXIT_SKIPPED:\n+            status = \"Skipped\"\n+        else:\n+            status = \"Failed\"\n+\n+        return TestResult(name, status, duration), testdir, stdout, stderr\n+\n     def __init__(self, num_tests_parallel, tests_dir, tmpdir, test_list=None, flags=None):\n-        assert(num_tests_parallel >= 1)\n-        self.num_jobs = num_tests_parallel\n-        self.tests_dir = tests_dir\n-        self.tmpdir = tmpdir\n-        self.test_list = test_list\n-        self.flags = flags\n-        self.num_running = 0\n-        # In case there is a graveyard of zombie bitcoinds, we can apply a\n-        # pseudorandom offset to hopefully jump over them.\n-        # (625 is PORT_RANGE/MAX_NODES)\n-        self.portseed_offset = int(time.time() * 1000) % 625\n+        self.executor = ThreadPoolExecutor(max_workers=num_tests_parallel)\n         self.jobs = []\n \n-    def get_next(self):\n-        while self.num_running < self.num_jobs and self.test_list:\n-            # Add tests\n-            self.num_running += 1\n-            test = self.test_list.pop(0)\n-            portseed = len(self.test_list) + self.portseed_offset\n+        # Add tests\n+        for i, test in enumerate(test_list):\n+            portseed = i\n             portseed_arg = [\"--portseed={}\".format(portseed)]\n             log_stdout = tempfile.SpooledTemporaryFile(max_size=2**16)\n             log_stderr = tempfile.SpooledTemporaryFile(max_size=2**16)\n             test_argv = test.split()\n-            testdir = \"{}/{}_{}\".format(self.tmpdir, re.sub(\".py$\", \"\", test_argv[0]), portseed)\n+            testdir = \"{}/{}_{}\".format(tmpdir, re.sub(\".py$\", \"\", test_argv[0]), portseed)\n             tmpdir_arg = [\"--tmpdir={}\".format(testdir)]\n-            self.jobs.append((test,\n-                              time.time(),\n-                              subprocess.Popen([sys.executable, self.tests_dir + test_argv[0]] + test_argv[1:] + self.flags + portseed_arg + tmpdir_arg,\n-                                               universal_newlines=True,\n-                                               stdout=log_stdout,\n-                                               stderr=log_stderr),\n+            self.jobs.append(self.executor.submit(TestHandler._run_test,\n+                              test,\n+                              [sys.executable, tests_dir + test_argv[0]] + test_argv[1:] + flags + portseed_arg + tmpdir_arg,\n                               testdir,\n                               log_stdout,\n                               log_stderr))\n-        if not self.jobs:\n-            raise IndexError('pop from empty list')\n-        while True:\n-            # Return first proc that finishes\n-            time.sleep(.5)\n-            for job in self.jobs:\n-                (name, start_time, proc, testdir, log_out, log_err) = job\n-                if os.getenv('TRAVIS') == 'true' and int(time.time() - start_time) > TRAVIS_TIMEOUT_DURATION:\n-                    # In travis, timeout individual tests (to stop tests hanging and not providing useful output).\n-                    proc.send_signal(signal.SIGINT)\n-                if proc.poll() is not None:\n-                    log_out.seek(0), log_err.seek(0)\n-                    [stdout, stderr] = [log_file.read().decode('utf-8') for log_file in (log_out, log_err)]\n-                    log_out.close(), log_err.close()\n-                    if proc.returncode == TEST_EXIT_PASSED and stderr == \"\":\n-                        status = \"Passed\"\n-                    elif proc.returncode == TEST_EXIT_SKIPPED:\n-                        status = \"Skipped\"\n-                    else:\n-                        status = \"Failed\"\n-                    self.num_running -= 1\n-                    self.jobs.remove(job)\n-\n-                    return TestResult(name, status, int(time.time() - start_time)), testdir, stdout, stderr\n-            print('.', end='', flush=True)\n-\n-    def kill_and_join(self):\n-        \"\"\"Send SIGKILL to all jobs and block until all have ended.\"\"\"\n-        procs = [i[2] for i in self.jobs]\n-\n-        for proc in procs:\n-            proc.kill()\n-\n-        for proc in procs:\n-            proc.wait()\n-\n \n class TestResult():\n     def __init__(self, name, status, time):"
      }
    ]
  }
]