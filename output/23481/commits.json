[
  {
    "sha": "0e2fa164c88e2336e023c464d48cd368aa43b8c3",
    "node_id": "C_kwDOABII59oAKDBlMmZhMTY0Yzg4ZTIzMzZlMDIzYzQ2NGQ0OGNkMzY4YWE0M2I4YzM",
    "commit": {
      "author": {
        "name": "jlbrown5-ncat",
        "email": "60116362+jlbrown5-ncat@users.noreply.github.com",
        "date": "2021-11-10T01:20:12Z"
      },
      "committer": {
        "name": "jlbrown5-ncat",
        "email": "60116362+jlbrown5-ncat@users.noreply.github.com",
        "date": "2021-11-10T01:20:12Z"
      },
      "message": "Add Validator Files",
      "tree": {
        "sha": "ec1990651737ce37ae1518e2b802f5bc3591f2f3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ec1990651737ce37ae1518e2b802f5bc3591f2f3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0e2fa164c88e2336e023c464d48cd368aa43b8c3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e2fa164c88e2336e023c464d48cd368aa43b8c3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0e2fa164c88e2336e023c464d48cd368aa43b8c3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e2fa164c88e2336e023c464d48cd368aa43b8c3/comments",
    "author": {
      "login": "jlbrown5-ncat",
      "id": 60116362,
      "node_id": "MDQ6VXNlcjYwMTE2MzYy",
      "avatar_url": "https://avatars.githubusercontent.com/u/60116362?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jlbrown5-ncat",
      "html_url": "https://github.com/jlbrown5-ncat",
      "followers_url": "https://api.github.com/users/jlbrown5-ncat/followers",
      "following_url": "https://api.github.com/users/jlbrown5-ncat/following{/other_user}",
      "gists_url": "https://api.github.com/users/jlbrown5-ncat/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jlbrown5-ncat/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jlbrown5-ncat/subscriptions",
      "organizations_url": "https://api.github.com/users/jlbrown5-ncat/orgs",
      "repos_url": "https://api.github.com/users/jlbrown5-ncat/repos",
      "events_url": "https://api.github.com/users/jlbrown5-ncat/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jlbrown5-ncat/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jlbrown5-ncat",
      "id": 60116362,
      "node_id": "MDQ6VXNlcjYwMTE2MzYy",
      "avatar_url": "https://avatars.githubusercontent.com/u/60116362?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jlbrown5-ncat",
      "html_url": "https://github.com/jlbrown5-ncat",
      "followers_url": "https://api.github.com/users/jlbrown5-ncat/followers",
      "following_url": "https://api.github.com/users/jlbrown5-ncat/following{/other_user}",
      "gists_url": "https://api.github.com/users/jlbrown5-ncat/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jlbrown5-ncat/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jlbrown5-ncat/subscriptions",
      "organizations_url": "https://api.github.com/users/jlbrown5-ncat/orgs",
      "repos_url": "https://api.github.com/users/jlbrown5-ncat/repos",
      "events_url": "https://api.github.com/users/jlbrown5-ncat/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jlbrown5-ncat/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7efc628539573af4b4a76d93b853cc46e9e52eae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7efc628539573af4b4a76d93b853cc46e9e52eae",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7efc628539573af4b4a76d93b853cc46e9e52eae"
      }
    ],
    "stats": {
      "total": 3058495,
      "additions": 3058495,
      "deletions": 0
    },
    "files": [
      {
        "sha": "55ee2f918405ca9a5363c28ccd375829e64cbec7",
        "filename": "src/boost/accumulators/accumulators.hpp",
        "status": "added",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/accumulators.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/accumulators.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/accumulators.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,27 @@\n+///////////////////////////////////////////////////////////////////////////////\n+/// \\file accumulators.hpp\n+/// Includes all of the Accumulators Framework\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_ACCUMULATORS_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_ACCUMULATORS_HPP_EAN_28_10_2005\n+\n+#include <boost/accumulators/framework/accumulator_set.hpp>\n+#include <boost/accumulators/framework/accumulator_concept.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/framework/external.hpp>\n+#include <boost/accumulators/framework/features.hpp>\n+#include <boost/accumulators/framework/parameters/accumulator.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/parameters/weight.hpp>\n+#include <boost/accumulators/framework/parameters/weights.hpp>\n+#include <boost/accumulators/framework/accumulators/external_accumulator.hpp>\n+#include <boost/accumulators/framework/accumulators/droppable_accumulator.hpp>\n+#include <boost/accumulators/framework/accumulators/reference_accumulator.hpp>\n+#include <boost/accumulators/framework/accumulators/value_accumulator.hpp>\n+\n+#endif"
      },
      {
        "sha": "fabc4e8406c1c91dde5344b7127d1fc609a4d2ac",
        "filename": "src/boost/accumulators/accumulators_fwd.hpp",
        "status": "added",
        "additions": 232,
        "deletions": 0,
        "changes": 232,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/accumulators_fwd.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/accumulators_fwd.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/accumulators_fwd.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,232 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// accumulators_fwd.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_ACCUMULATORS_FWD_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_ACCUMULATORS_FWD_HPP_EAN_28_10_2005\n+\n+#include <boost/config.hpp>\n+#include <boost/core/enable_if.hpp>\n+#include <boost/parameter/is_argument_pack.hpp>\n+#include <boost/mpl/apply_fwd.hpp> // for mpl::na\n+#include <boost/mpl/limits/vector.hpp>\n+#include <boost/preprocessor/cat.hpp>\n+#include <boost/preprocessor/arithmetic/inc.hpp>\n+#include <boost/preprocessor/repetition/enum_params_with_a_default.hpp>\n+#include <boost/preprocessor/repetition/enum_trailing_params.hpp>\n+#include <boost/preprocessor/repetition/enum_trailing_binary_params.hpp>\n+#include <boost/preprocessor/repetition/repeat_from_to.hpp>\n+#include <boost/accumulators/numeric/functional_fwd.hpp>\n+\n+#ifndef BOOST_ACCUMULATORS_MAX_FEATURES\n+  /// The maximum number of accumulators that may be put in an accumulator_set.\n+  /// Defaults to BOOST_MPL_LIMIT_VECTOR_SIZE (which defaults to 20).\n+# define BOOST_ACCUMULATORS_MAX_FEATURES BOOST_MPL_LIMIT_VECTOR_SIZE\n+#endif\n+\n+#if BOOST_ACCUMULATORS_MAX_FEATURES > BOOST_MPL_LIMIT_VECTOR_SIZE\n+# error BOOST_ACCUMULATORS_MAX_FEATURES cannot be larger than BOOST_MPL_LIMIT_VECTOR_SIZE\n+#endif\n+\n+#ifndef BOOST_ACCUMULATORS_MAX_ARGS\n+  /// The maximum number of arguments that may be specified to an accumulator_set's\n+  /// accumulation function. Defaults to 15.\n+# define BOOST_ACCUMULATORS_MAX_ARGS 15\n+#endif\n+\n+#if BOOST_WORKAROUND(__GNUC__, == 3) \\\n+ || BOOST_WORKAROUND(__EDG_VERSION__, BOOST_TESTED_AT(306))\n+# define BOOST_ACCUMULATORS_BROKEN_CONST_OVERLOADS\n+#endif\n+\n+#ifdef BOOST_ACCUMULATORS_BROKEN_CONST_OVERLOADS\n+# include <boost/type_traits/is_const.hpp>\n+# define BOOST_ACCUMULATORS_PROTO_DISABLE_IF_IS_CONST(T)\\\n+    , typename boost::disable_if<boost::is_const<T> >::type * = 0\n+#else\n+# define BOOST_ACCUMULATORS_PROTO_DISABLE_IF_IS_CONST(T)\n+#endif\n+\n+#define BOOST_ACCUMULATORS_GCC_VERSION                                                              \\\n+  (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)\n+\n+namespace boost { namespace accumulators\n+{\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// Named parameters tags\n+//\n+namespace tag\n+{\n+    struct sample;\n+    struct weight;\n+    struct accumulator;\n+    struct weights;\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// User-level features\n+//\n+namespace tag\n+{\n+    template<typename ValueType, typename Tag>\n+    struct value;\n+\n+    template<typename Tag>\n+    struct value_tag;\n+\n+    template<typename Referent, typename Tag>\n+    struct reference;\n+\n+    template<typename Tag>\n+    struct reference_tag;\n+\n+    template<typename Type, typename Tag = void, typename AccumulatorSet = void>\n+    struct external;\n+\n+    template<typename Feature>\n+    struct droppable;\n+}\n+\n+template<typename Accumulator>\n+struct droppable_accumulator_base;\n+\n+template<typename Accumulator>\n+struct droppable_accumulator;\n+\n+template<typename Accumulator>\n+struct with_cached_result;\n+\n+template<typename Sample, typename Features, typename Weight = void>\n+struct accumulator_set;\n+\n+template<typename Feature>\n+struct extractor;\n+\n+template<typename Feature>\n+struct feature_of;\n+\n+template<typename Feature>\n+struct as_feature;\n+\n+template<typename Feature>\n+struct as_weighted_feature;\n+\n+template<BOOST_PP_ENUM_PARAMS_WITH_A_DEFAULT(BOOST_ACCUMULATORS_MAX_FEATURES, typename Feature, mpl::na)>\n+struct depends_on;\n+\n+template<BOOST_PP_ENUM_PARAMS_WITH_A_DEFAULT(BOOST_ACCUMULATORS_MAX_FEATURES, typename Feature, mpl::na)>\n+struct features;\n+\n+template<typename Feature, typename AccumulatorSet>\n+typename mpl::apply<AccumulatorSet, Feature>::type const &\n+find_accumulator(AccumulatorSet const &acc);\n+\n+template<typename Feature, typename AccumulatorSet>\n+typename mpl::apply<AccumulatorSet, Feature>::type::result_type\n+extract_result(AccumulatorSet const &acc);\n+\n+namespace detail\n+{\n+    struct _enabler\n+    {\n+    };\n+}\n+\n+// ... other overloads generated by Boost.Preprocessor:\n+\n+/// INTERNAL ONLY\n+///\n+#define BOOST_ACCUMULATORS_EXTRACT_RESULT_FWD(z, n, _)                      \\\n+    template<                                                               \\\n+        typename Feature                                                    \\\n+      , typename AccumulatorSet                                             \\\n+        BOOST_PP_ENUM_TRAILING_PARAMS_Z(z, n, typename A)                   \\\n+    >                                                                       \\\n+    typename mpl::apply<AccumulatorSet, Feature>::type::result_type         \\\n+    extract_result(                                                         \\\n+        AccumulatorSet const &acc                                           \\\n+        BOOST_PP_ENUM_TRAILING_BINARY_PARAMS_Z(z, n, A, const &a)           \\\n+      , typename boost::enable_if<                                          \\\n+            parameter::is_argument_pack<A0>                                 \\\n+          , detail::_enabler                                                \\\n+        >::type = detail::_enabler()                                        \\\n+    );                                                                      \\\n+    template<                                                               \\\n+        typename Feature                                                    \\\n+      , typename AccumulatorSet                                             \\\n+        BOOST_PP_ENUM_TRAILING_PARAMS_Z(z, n, typename A)                   \\\n+    >                                                                       \\\n+    typename mpl::apply<AccumulatorSet, Feature>::type::result_type         \\\n+    extract_result(                                                         \\\n+        AccumulatorSet const &acc                                           \\\n+        BOOST_PP_ENUM_TRAILING_BINARY_PARAMS_Z(z, n, A, const &a)           \\\n+      , typename boost::disable_if<                                         \\\n+            parameter::is_argument_pack<A0>                                 \\\n+          , detail::_enabler                                                \\\n+        >::type = detail::_enabler()                                        \\\n+    );\n+\n+/// INTERNAL ONLY\n+///\n+BOOST_PP_REPEAT_FROM_TO(\n+    1\n+  , BOOST_PP_INC(BOOST_ACCUMULATORS_MAX_ARGS)\n+  , BOOST_ACCUMULATORS_EXTRACT_RESULT_FWD\n+  , _\n+)\n+\n+#undef BOOST_ACCUMULATORS_EXTRACT_RESULT_FWD\n+\n+#ifdef BOOST_ACCUMULATORS_DOXYGEN_INVOKED\n+template<typename Feature, typename AccumulatorSet, typename A1, typename A2 ...>\n+typename mpl::apply<AccumulatorSet, Feature>::type::result_type\n+extract_result(AccumulatorSet const &acc, A1 const &a1, A2 const &a2 ...);\n+#endif\n+\n+namespace impl\n+{\n+    using namespace numeric::operators;\n+\n+    template<typename Accumulator, typename Tag>\n+    struct external_impl;\n+}\n+\n+namespace detail\n+{\n+    template<typename Accumulator>\n+    struct feature_tag;\n+\n+    template<typename Feature, typename Sample, typename Weight>\n+    struct to_accumulator;\n+\n+    struct accumulator_set_base;\n+\n+    template<typename T>\n+    struct is_accumulator_set;\n+\n+    inline void ignore_variable(void const *) {}\n+}\n+\n+}} // namespace boost::accumulators\n+\n+#define BOOST_ACCUMULATORS_IGNORE_GLOBAL(X)                             \\\n+    namespace detail                                                    \\\n+    {                                                                   \\\n+        struct BOOST_PP_CAT(ignore_, X)                                 \\\n+        {                                                               \\\n+            void ignore()                                               \\\n+            {                                                           \\\n+                boost::accumulators::detail::ignore_variable(&X);       \\\n+            }                                                           \\\n+        };                                                              \\\n+    }                                                                   \\\n+    /**/\n+\n+#include <boost/parameter/nested_keyword.hpp>\n+\n+#endif  // include guard\n+"
      },
      {
        "sha": "52c520d10747ac2daf6c7072905369f97c6d0774",
        "filename": "src/boost/accumulators/framework/accumulator_base.hpp",
        "status": "added",
        "additions": 65,
        "deletions": 0,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/accumulator_base.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/accumulator_base.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/framework/accumulator_base.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,65 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// accumulator_base.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_FRAMEWORK_ACCUMULATORS_BASE_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_FRAMEWORK_ACCUMULATORS_BASE_HPP_EAN_28_10_2005\n+\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/mpl/joint_view.hpp>\n+#include <boost/mpl/single_view.hpp>\n+#include <boost/mpl/fold.hpp>\n+#include <boost/mpl/contains.hpp>\n+#include <boost/mpl/empty_sequence.hpp>\n+#include <boost/accumulators/framework/accumulator_concept.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace detail\n+{\n+    typedef void void_;\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// dont_care\n+//\n+struct dont_care\n+{\n+    template<typename Args>\n+    dont_care(Args const &)\n+    {\n+    }\n+};\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// accumulator_base\n+//\n+struct accumulator_base\n+{\n+    // hidden if defined in derived classes\n+    detail::void_ operator ()(dont_care)\n+    {\n+    }\n+\n+    typedef mpl::false_ is_droppable;\n+\n+    detail::void_ add_ref(dont_care)\n+    {\n+    }\n+\n+    detail::void_ drop(dont_care)\n+    {\n+    }\n+\n+    detail::void_ on_drop(dont_care)\n+    {\n+    }\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "492357efbaa676aa19e6547436a208b53aaff838",
        "filename": "src/boost/accumulators/framework/accumulator_concept.hpp",
        "status": "added",
        "additions": 29,
        "deletions": 0,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/accumulator_concept.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/accumulator_concept.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/framework/accumulator_concept.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,29 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// accumulator_concept.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_FRAMEWORK_ACCUMULATOR_CONCEPT_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_FRAMEWORK_ACCUMULATOR_CONCEPT_HPP_EAN_28_10_2005\n+\n+#include <boost/concept_check.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+template<typename Stat>\n+struct accumulator_concept\n+{\n+    void constraints()\n+    {\n+        // TODO: define the stat concept\n+    }\n+\n+    Stat stat;\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "0b4f4ad3dcdce5f855698ec0fbe659a646643bac",
        "filename": "src/boost/accumulators/framework/accumulator_set.hpp",
        "status": "added",
        "additions": 544,
        "deletions": 0,
        "changes": 544,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/accumulator_set.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/accumulator_set.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/framework/accumulator_set.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,544 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// accumulator_set.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_FRAMEWORK_ACCUMULATOR_SET_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_FRAMEWORK_ACCUMULATOR_SET_HPP_EAN_28_10_2005\n+\n+#include <boost/version.hpp>\n+#include <boost/mpl/bool.hpp>\n+#include <boost/mpl/if.hpp>\n+#include <boost/mpl/apply.hpp>\n+#include <boost/mpl/assert.hpp>\n+#include <boost/mpl/protect.hpp>\n+#include <boost/mpl/identity.hpp>\n+#include <boost/mpl/is_sequence.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+#include <boost/type_traits/is_base_of.hpp>\n+#include <boost/type_traits/remove_const.hpp>\n+#include <boost/type_traits/remove_reference.hpp>\n+#include <boost/core/enable_if.hpp>\n+#include <boost/parameter/is_argument_pack.hpp>\n+#include <boost/preprocessor/repetition/repeat_from_to.hpp>\n+#include <boost/preprocessor/repetition/enum_params.hpp>\n+#include <boost/preprocessor/repetition/enum_binary_params.hpp>\n+#include <boost/preprocessor/repetition/enum_trailing_params.hpp>\n+#include <boost/accumulators/accumulators_fwd.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/framework/accumulator_concept.hpp>\n+#include <boost/accumulators/framework/parameters/accumulator.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/accumulators/external_accumulator.hpp>\n+#include <boost/accumulators/framework/accumulators/droppable_accumulator.hpp>\n+#include <boost/fusion/include/any.hpp>\n+#include <boost/fusion/include/find_if.hpp>\n+#include <boost/fusion/include/for_each.hpp>\n+#include <boost/fusion/include/filter_view.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace detail\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // accumulator_visitor\n+    //   wrap a boost::parameter argument pack in a Fusion extractor object\n+    template<typename Args>\n+    struct accumulator_visitor\n+    {\n+        explicit accumulator_visitor(Args const &a)\n+          : args(a)\n+        {\n+        }\n+\n+        template<typename Accumulator>\n+        void operator ()(Accumulator &accumulator) const\n+        {\n+            accumulator(this->args);\n+        }\n+\n+    private:\n+        accumulator_visitor &operator =(accumulator_visitor const &);\n+        Args const &args;\n+    };\n+\n+    template<typename Args>\n+    inline accumulator_visitor<Args> const make_accumulator_visitor(Args const &args)\n+    {\n+        return accumulator_visitor<Args>(args);\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // accumulator_set_base\n+    struct accumulator_set_base\n+    {\n+    };\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // is_accumulator_set\n+    template<typename T>\n+    struct is_accumulator_set\n+      : mpl::if_<\n+            boost::is_base_of<\n+                accumulator_set_base\n+              , typename boost::remove_const<\n+                    typename boost::remove_reference<T>::type\n+                >::type\n+            >\n+          , mpl::true_\n+          , mpl::false_\n+        >::type\n+    {\n+    };\n+\n+    // function object that serialize an accumulator\n+    template<typename Archive>\n+    struct serialize_accumulator\n+    {\n+        serialize_accumulator(Archive & _ar, const unsigned int _file_version) :\n+            ar(_ar), file_version(_file_version)\n+        {}\n+\n+        template<typename Accumulator>\n+        void operator ()(Accumulator &accumulator)\n+        {\n+            accumulator.serialize(ar, file_version);\n+        }\n+\n+    private:\n+        Archive& ar;\n+        const unsigned int file_version;\n+    };\n+\n+} // namespace detail\n+\n+#ifdef _MSC_VER\n+#pragma warning(push)\n+#pragma warning(disable: 4355) // warning C4355: 'this' : used in base member initializer list\n+#endif\n+\n+///////////////////////////////////////////////////////////////////////////////\n+/// \\brief A set of accumulators.\n+///\n+/// accumulator_set resolves the dependencies between features and ensures that\n+/// the accumulators in the set are updated in the proper order.\n+///\n+/// acccumulator_set provides a general mechanism to visit the accumulators\n+/// in the set in order, with or without a filter. You can also fetch a reference\n+/// to an accumulator that corresponds to a feature.\n+///\n+template<typename Sample, typename Features, typename Weight>\n+struct accumulator_set\n+  : detail::accumulator_set_base\n+{\n+    typedef Sample sample_type;     ///< The type of the samples that will be accumulated\n+    typedef Features features_type; ///< An MPL sequence of the features that should be accumulated.\n+    typedef Weight weight_type;     ///< The type of the weight parameter. Must be a scalar. Defaults to void.\n+\n+    /// INTERNAL ONLY\n+    ///\n+    typedef\n+        typename detail::make_accumulator_tuple<\n+            Features\n+          , Sample\n+          , Weight\n+        >::type\n+    accumulators_mpl_vector;\n+\n+    // generate a fusion::list of accumulators\n+    /// INTERNAL ONLY\n+    ///\n+    typedef\n+        typename detail::meta::make_acc_list<\n+            accumulators_mpl_vector\n+        >::type\n+    accumulators_type;\n+\n+    /// INTERNAL ONLY\n+    ///\n+    //BOOST_MPL_ASSERT((mpl::is_sequence<accumulators_type>));\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    /// default-construct all contained accumulators\n+    accumulator_set()\n+      : accumulators(\n+            detail::make_acc_list(\n+                accumulators_mpl_vector()\n+              , (boost::accumulators::accumulator = *this)\n+            )\n+        )\n+    {\n+        // Add-ref the Features that the user has specified\n+        this->template visit_if<detail::contains_feature_of_<Features> >(\n+            detail::make_add_ref_visitor(boost::accumulators::accumulator = *this)\n+        );\n+    }\n+\n+    /// \\overload\n+    ///\n+    /// \\param a1 Optional named parameter to be passed to all the accumulators\n+    template<typename A1>\n+    explicit accumulator_set(\n+        A1 const &a1\n+      , typename boost::enable_if<\n+            parameter::is_argument_pack<A1>\n+          , detail::_enabler\n+        >::type = detail::_enabler()\n+    ) : accumulators(\n+            detail::make_acc_list(\n+                accumulators_mpl_vector()\n+              , (boost::accumulators::accumulator = *this, a1)\n+            )\n+        )\n+    {\n+        // Add-ref the Features that the user has specified\n+        this->template visit_if<detail::contains_feature_of_<Features> >(\n+            detail::make_add_ref_visitor(boost::accumulators::accumulator = *this)\n+        );\n+    }\n+\n+    /// \\overload\n+    ///\n+    /// \\param a1 Optional sample parameter to be passed to all the accumulators\n+    template<typename A1>\n+    explicit accumulator_set(\n+        A1 const &a1\n+      , typename boost::disable_if<\n+            parameter::is_argument_pack<A1>\n+          , detail::_enabler\n+        >::type = detail::_enabler()\n+    ) : accumulators(\n+            detail::make_acc_list(\n+                accumulators_mpl_vector()\n+              , (\n+                    boost::accumulators::accumulator = *this\n+                  , boost::accumulators::sample = a1\n+                )\n+            )\n+        )\n+    {\n+        // Add-ref the Features that the user has specified\n+        this->template visit_if<detail::contains_feature_of_<Features> >(\n+            detail::make_add_ref_visitor(boost::accumulators::accumulator = *this)\n+        );\n+    }\n+\n+    // ... other overloads generated by Boost.Preprocessor:\n+\n+    /// INTERNAL ONLY\n+    ///\n+#define BOOST_ACCUMULATORS_ACCUMULATOR_SET_CTOR(z, n, _)                                \\\n+    template<BOOST_PP_ENUM_PARAMS_Z(z, n, typename A)>                                  \\\n+    accumulator_set(                                                                    \\\n+        BOOST_PP_ENUM_BINARY_PARAMS_Z(z, n, A, const &a)                                \\\n+      , typename boost::enable_if<                                                      \\\n+            parameter::is_argument_pack<A0>                                             \\\n+          , detail::_enabler                                                            \\\n+        >::type = detail::_enabler()                                                    \\\n+    ) : accumulators(                                                                   \\\n+            detail::make_acc_list(                                                      \\\n+                accumulators_mpl_vector()                                               \\\n+              , (                                                                       \\\n+                    boost::accumulators::accumulator = *this                            \\\n+                    BOOST_PP_ENUM_TRAILING_PARAMS_Z(z, n, a)                            \\\n+                )                                                                       \\\n+            )                                                                           \\\n+        )                                                                               \\\n+    {                                                                                   \\\n+        /* Add-ref the Features that the user has specified */                          \\\n+        this->template visit_if<detail::contains_feature_of_<Features> >(               \\\n+            detail::make_add_ref_visitor(boost::accumulators::accumulator = *this)      \\\n+        );                                                                              \\\n+    }                                                                                   \\\n+    template<BOOST_PP_ENUM_PARAMS_Z(z, n, typename A)>                                  \\\n+    accumulator_set(                                                                    \\\n+        BOOST_PP_ENUM_BINARY_PARAMS_Z(z, n, A, const &a)                                \\\n+      , typename boost::disable_if<                                                     \\\n+            parameter::is_argument_pack<A0>                                             \\\n+          , detail::_enabler                                                            \\\n+        >::type = detail::_enabler()                                                    \\\n+    ) : accumulators(                                                                   \\\n+            detail::make_acc_list(                                                      \\\n+                accumulators_mpl_vector()                                               \\\n+              , (                                                                       \\\n+                    boost::accumulators::accumulator = *this                            \\\n+                  , boost::accumulators::sample = BOOST_PP_ENUM_PARAMS_Z(z, n, a)       \\\n+                )                                                                       \\\n+            )                                                                           \\\n+        )                                                                               \\\n+    {                                                                                   \\\n+        /* Add-ref the Features that the user has specified */                          \\\n+        this->template visit_if<detail::contains_feature_of_<Features> >(               \\\n+            detail::make_add_ref_visitor(boost::accumulators::accumulator = *this)      \\\n+        );                                                                              \\\n+    }\n+\n+    /// INTERNAL ONLY\n+    ///\n+    BOOST_PP_REPEAT_FROM_TO(\n+        2\n+      , BOOST_PP_INC(BOOST_ACCUMULATORS_MAX_ARGS)\n+      , BOOST_ACCUMULATORS_ACCUMULATOR_SET_CTOR\n+      , _\n+    )\n+\n+    #ifdef BOOST_ACCUMULATORS_DOXYGEN_INVOKED\n+    /// \\overload\n+    ///\n+    template<typename A1, typename A2, ...>\n+    accumulator_set(A1 const &a1, A2 const &a2, ...);\n+    #endif\n+\n+    // ... other overloads generated by Boost.Preprocessor below ...\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    /// Visitation\n+    /// \\param func UnaryFunction which is invoked with each accumulator in turn.\n+    template<typename UnaryFunction>\n+    void visit(UnaryFunction const &func)\n+    {\n+        fusion::for_each(this->accumulators, func);\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    /// Conditional visitation\n+    /// \\param func UnaryFunction which is invoked with each accumulator in turn,\n+    ///     provided the accumulator satisfies the MPL predicate FilterPred.\n+    template<typename FilterPred, typename UnaryFunction>\n+    void visit_if(UnaryFunction const &func)\n+    {\n+        fusion::filter_view<accumulators_type, FilterPred> filtered_accs(this->accumulators);\n+        fusion::for_each(filtered_accs, func);\n+    }\n+    \n+    ///////////////////////////////////////////////////////////////////////////////\n+    /// The return type of the operator() overloads is void.\n+    typedef void result_type;\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    /// Accumulation\n+    /// \\param a1 Optional named parameter to be passed to all the accumulators\n+    void operator ()()\n+    {\n+        this->visit(\n+            detail::make_accumulator_visitor(\n+                boost::accumulators::accumulator = *this\n+            )\n+        );\n+    }\n+\n+    // ... other overloads generated by Boost.Preprocessor:\n+\n+    /// INTERNAL ONLY\n+    ///\n+#define BOOST_ACCUMULATORS_ACCUMULATOR_SET_FUN_OP(z, n, _)                              \\\n+    template<BOOST_PP_ENUM_PARAMS_Z(z, n, typename A)>                                  \\\n+    void operator ()(                                                                   \\\n+        BOOST_PP_ENUM_BINARY_PARAMS_Z(z, n, A, const &a)                                \\\n+      , typename boost::enable_if<                                                      \\\n+            parameter::is_argument_pack<A0>                                             \\\n+          , detail::_enabler                                                            \\\n+        >::type = detail::_enabler()                                                    \\\n+    )                                                                                   \\\n+    {                                                                                   \\\n+        this->visit(                                                                    \\\n+            detail::make_accumulator_visitor(                                           \\\n+                (                                                                       \\\n+                    boost::accumulators::accumulator = *this                            \\\n+                    BOOST_PP_ENUM_TRAILING_PARAMS_Z(z, n, a)                            \\\n+                )                                                                       \\\n+            )                                                                           \\\n+        );                                                                              \\\n+    }                                                                                   \\\n+    template<BOOST_PP_ENUM_PARAMS_Z(z, n, typename A)>                                  \\\n+    void operator ()(                                                                   \\\n+        BOOST_PP_ENUM_BINARY_PARAMS_Z(z, n, A, const &a)                                \\\n+      , typename boost::disable_if<                                                     \\\n+            parameter::is_argument_pack<A0>                                             \\\n+          , detail::_enabler                                                            \\\n+        >::type = detail::_enabler()                                                    \\\n+    )                                                                                   \\\n+    {                                                                                   \\\n+        this->visit(                                                                    \\\n+            detail::make_accumulator_visitor(                                           \\\n+                (                                                                       \\\n+                    boost::accumulators::accumulator = *this                            \\\n+                  , boost::accumulators::sample = BOOST_PP_ENUM_PARAMS_Z(z, n, a)       \\\n+                )                                                                       \\\n+            )                                                                           \\\n+        );                                                                              \\\n+    }\n+\n+    /// INTERNAL ONLY\n+    ///\n+    BOOST_PP_REPEAT_FROM_TO(\n+        1\n+      , BOOST_PP_INC(BOOST_ACCUMULATORS_MAX_ARGS)\n+      , BOOST_ACCUMULATORS_ACCUMULATOR_SET_FUN_OP\n+      , _\n+    )\n+\n+    #ifdef BOOST_ACCUMULATORS_DOXYGEN_INVOKED\n+    /// \\overload\n+    ///\n+    template<typename A1, typename A2, ...>\n+    void operator ()(A1 const &a1, A2 const &a2, ...);\n+    #endif\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    /// Extraction\n+    template<typename Feature>\n+    struct apply\n+      : fusion::result_of::value_of<\n+            typename fusion::result_of::find_if<\n+                accumulators_type\n+              , detail::matches_feature<Feature>\n+            >::type\n+        >\n+    {\n+    };\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    /// Extraction\n+    template<typename Feature>\n+    typename apply<Feature>::type &extract()\n+    {\n+        return *fusion::find_if<detail::matches_feature<Feature> >(this->accumulators);\n+    }\n+\n+    /// \\overload\n+    template<typename Feature>\n+    typename apply<Feature>::type const &extract() const\n+    {\n+        return *fusion::find_if<detail::matches_feature<Feature> >(this->accumulators);\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    /// Drop\n+    template<typename Feature>\n+    void drop()\n+    {\n+        // You can only drop the features that you have specified explicitly\n+        typedef typename apply<Feature>::type the_accumulator;\n+        BOOST_MPL_ASSERT((detail::contains_feature_of<Features, the_accumulator>));\n+\n+        typedef\n+            typename feature_of<typename as_feature<Feature>::type>::type\n+        the_feature;\n+\n+        (*fusion::find_if<detail::matches_feature<Feature> >(this->accumulators))\n+            .drop(boost::accumulators::accumulator = *this);\n+\n+        // Also drop accumulators that this feature depends on\n+        typedef typename the_feature::dependencies dependencies;\n+        this->template visit_if<detail::contains_feature_of_<dependencies> >(\n+            detail::make_drop_visitor(boost::accumulators::accumulator = *this)\n+        );\n+    }\n+\n+    // make the accumulator set serializeable\n+    template<class Archive>\n+    void serialize(Archive & ar, const unsigned int file_version)\n+    {\n+        detail::serialize_accumulator<Archive> serializer(ar, file_version);\n+        fusion::for_each(this->accumulators, serializer);\n+    }\n+\n+private:\n+\n+    accumulators_type accumulators;\n+};\n+\n+#ifdef _MSC_VER\n+#pragma warning(pop)\n+#endif\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// find_accumulator\n+//   find an accumulator in an accumulator_set corresponding to a feature\n+template<typename Feature, typename AccumulatorSet>\n+typename mpl::apply<AccumulatorSet, Feature>::type &\n+find_accumulator(AccumulatorSet &acc BOOST_ACCUMULATORS_PROTO_DISABLE_IF_IS_CONST(AccumulatorSet))\n+{\n+    return acc.template extract<Feature>();\n+}\n+\n+/// \\overload\n+template<typename Feature, typename AccumulatorSet>\n+typename mpl::apply<AccumulatorSet, Feature>::type const &\n+find_accumulator(AccumulatorSet const &acc)\n+{\n+    return acc.template extract<Feature>();\n+}\n+\n+template<typename Feature, typename AccumulatorSet>\n+typename mpl::apply<AccumulatorSet, Feature>::type::result_type\n+extract_result(AccumulatorSet const &acc)\n+{\n+    return find_accumulator<Feature>(acc).result(\n+        boost::accumulators::accumulator = acc\n+    );\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract_result\n+//   extract a result from an accumulator set\n+/// INTERNAL ONLY\n+///\n+#define BOOST_ACCUMULATORS_EXTRACT_RESULT_FUN(z, n, _)                      \\\n+    template<                                                               \\\n+        typename Feature                                                    \\\n+      , typename AccumulatorSet                                             \\\n+        BOOST_PP_ENUM_TRAILING_PARAMS_Z(z, n, typename A)                   \\\n+    >                                                                       \\\n+    typename mpl::apply<AccumulatorSet, Feature>::type::result_type         \\\n+    extract_result(                                                         \\\n+        AccumulatorSet const &acc                                           \\\n+        BOOST_PP_ENUM_TRAILING_BINARY_PARAMS_Z(z, n, A, const &a)           \\\n+      , typename boost::enable_if<                                          \\\n+            parameter::is_argument_pack<A0>                                 \\\n+          , detail::_enabler                                                \\\n+        >::type                                                             \\\n+    )                                                                       \\\n+    {                                                                       \\\n+        return find_accumulator<Feature>(acc).result(                       \\\n+            (                                                               \\\n+                boost::accumulators::accumulator = acc                      \\\n+                BOOST_PP_ENUM_TRAILING_PARAMS_Z(z, n, a)                    \\\n+            )                                                               \\\n+        );                                                                  \\\n+    }                                                                       \\\n+    template<                                                               \\\n+        typename Feature                                                    \\\n+      , typename AccumulatorSet                                             \\\n+        BOOST_PP_ENUM_TRAILING_PARAMS_Z(z, n, typename A)                   \\\n+    >                                                                       \\\n+    typename mpl::apply<AccumulatorSet, Feature>::type::result_type         \\\n+    extract_result(                                                         \\\n+        AccumulatorSet const &acc                                           \\\n+        BOOST_PP_ENUM_TRAILING_BINARY_PARAMS_Z(z, n, A, const &a)           \\\n+      , typename boost::disable_if<                                         \\\n+            parameter::is_argument_pack<A0>                                 \\\n+          , detail::_enabler                                                \\\n+        >::type                                                             \\\n+    )                                                                       \\\n+    {                                                                       \\\n+        return find_accumulator<Feature>(acc).result((                      \\\n+            boost::accumulators::accumulator = acc                          \\\n+          , boost::accumulators::sample = BOOST_PP_ENUM_PARAMS_Z(z, n, a)   \\\n+        ));                                                                 \\\n+    }\n+\n+BOOST_PP_REPEAT_FROM_TO(\n+    1\n+  , BOOST_PP_INC(BOOST_ACCUMULATORS_MAX_ARGS)\n+  , BOOST_ACCUMULATORS_EXTRACT_RESULT_FUN\n+  , _\n+)\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "0e882b5c35d10e283f78156fe7c411080816bb76",
        "filename": "src/boost/accumulators/framework/accumulators/droppable_accumulator.hpp",
        "status": "added",
        "additions": 328,
        "deletions": 0,
        "changes": 328,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/accumulators/droppable_accumulator.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/accumulators/droppable_accumulator.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/framework/accumulators/droppable_accumulator.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,328 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// droppable_accumulator.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_FRAMEWORK_ACCUMULATORS_DROPPABLE_ACCUMULATOR_HPP_EAN_13_12_2005\n+#define BOOST_ACCUMULATORS_FRAMEWORK_ACCUMULATORS_DROPPABLE_ACCUMULATOR_HPP_EAN_13_12_2005\n+\n+#include <new>\n+#include <boost/assert.hpp>\n+#include <boost/mpl/apply.hpp>\n+#include <boost/aligned_storage.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp> // for feature_of\n+#include <boost/accumulators/framework/parameters/accumulator.hpp> // for accumulator\n+\n+namespace boost { namespace accumulators\n+{\n+\n+    template<typename Accumulator>\n+    struct droppable_accumulator;\n+\n+    namespace detail\n+    {\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // add_ref_visitor\n+        //   a fusion function object for add_ref'ing accumulators\n+        template<typename Args>\n+        struct add_ref_visitor\n+        {\n+            explicit add_ref_visitor(Args const &args)\n+              : args_(args)\n+            {\n+            }\n+\n+            template<typename Accumulator>\n+            void operator ()(Accumulator &acc) const\n+            {\n+                typedef typename Accumulator::feature_tag::dependencies dependencies;\n+\n+                acc.add_ref(this->args_);\n+\n+                // Also add_ref accumulators that this feature depends on\n+                this->args_[accumulator].template\n+                    visit_if<detail::contains_feature_of_<dependencies> >(\n+                        *this\n+                );\n+            }\n+\n+        private:\n+            add_ref_visitor &operator =(add_ref_visitor const &);\n+            Args const &args_;\n+        };\n+\n+        template<typename Args>\n+        add_ref_visitor<Args> make_add_ref_visitor(Args const &args)\n+        {\n+            return add_ref_visitor<Args>(args);\n+        }\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // drop_visitor\n+        //   a fusion function object for dropping accumulators\n+        template<typename Args>\n+        struct drop_visitor\n+        {\n+            explicit drop_visitor(Args const &args)\n+              : args_(args)\n+            {\n+            }\n+\n+            template<typename Accumulator>\n+            void operator ()(Accumulator &acc) const\n+            {\n+                if(typename Accumulator::is_droppable())\n+                {\n+                    typedef typename Accumulator::feature_tag::dependencies dependencies;\n+\n+                    acc.drop(this->args_);\n+                    // Also drop accumulators that this feature depends on\n+                    this->args_[accumulator].template\n+                        visit_if<detail::contains_feature_of_<dependencies> >(\n+                            *this\n+                    );\n+                }\n+            }\n+\n+        private:\n+            drop_visitor &operator =(drop_visitor const &);\n+            Args const &args_;\n+        };\n+\n+        template<typename Args>\n+        drop_visitor<Args> make_drop_visitor(Args const &args)\n+        {\n+            return drop_visitor<Args>(args);\n+        }\n+    }\n+\n+    //////////////////////////////////////////////////////////////////////////\n+    // droppable_accumulator_base\n+    template<typename Accumulator>\n+    struct droppable_accumulator_base\n+      : Accumulator\n+    {\n+        typedef droppable_accumulator_base base;\n+        typedef mpl::true_ is_droppable;\n+        typedef typename Accumulator::result_type result_type;\n+\n+        template<typename Args>\n+        droppable_accumulator_base(Args const &args)\n+          : Accumulator(args)\n+          , ref_count_(0)\n+        {\n+        }\n+\n+        droppable_accumulator_base(droppable_accumulator_base const &that)\n+          : Accumulator(*static_cast<Accumulator const *>(&that))\n+          , ref_count_(that.ref_count_)\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            if(!this->is_dropped())\n+            {\n+                this->Accumulator::operator ()(args);\n+            }\n+        }\n+\n+        template<typename Args>\n+        void add_ref(Args const &)\n+        {\n+            ++this->ref_count_;\n+        }\n+\n+        template<typename Args>\n+        void drop(Args const &args)\n+        {\n+            BOOST_ASSERT(0 < this->ref_count_);\n+            if(1 == this->ref_count_)\n+            {\n+                static_cast<droppable_accumulator<Accumulator> *>(this)->on_drop(args);\n+            }\n+            --this->ref_count_;\n+        }\n+\n+        bool is_dropped() const\n+        {\n+            return 0 == this->ref_count_;\n+        }\n+\n+    private:\n+        int ref_count_;\n+    };\n+\n+    //////////////////////////////////////////////////////////////////////////\n+    // droppable_accumulator\n+    //   this can be specialized for any type that needs special handling\n+    template<typename Accumulator>\n+    struct droppable_accumulator\n+      : droppable_accumulator_base<Accumulator>\n+    {\n+        template<typename Args>\n+        droppable_accumulator(Args const &args)\n+          : droppable_accumulator::base(args)\n+        {\n+        }\n+\n+        droppable_accumulator(droppable_accumulator const &that)\n+          : droppable_accumulator::base(*static_cast<typename droppable_accumulator::base const *>(&that))\n+        {\n+        }\n+    };\n+\n+    //////////////////////////////////////////////////////////////////////////\n+    // with_cached_result\n+    template<typename Accumulator>\n+    struct with_cached_result\n+      : Accumulator\n+    {\n+        typedef typename Accumulator::result_type result_type;\n+\n+        template<typename Args>\n+        with_cached_result(Args const &args)\n+          : Accumulator(args)\n+          , cache()\n+        {\n+        }\n+\n+        with_cached_result(with_cached_result const &that)\n+          : Accumulator(*static_cast<Accumulator const *>(&that))\n+          , cache()\n+        {\n+            if(that.has_result())\n+            {\n+                this->set(that.get());\n+            }\n+        }\n+\n+        ~with_cached_result()\n+        {\n+            // Since this is a base class of droppable_accumulator_base,\n+            // this destructor is called before any of droppable_accumulator_base's\n+            // members get cleaned up, including is_dropped, so the following\n+            // call to has_result() is valid.\n+            if(this->has_result())\n+            {\n+                this->get().~result_type();\n+            }\n+        }\n+\n+        template<typename Args>\n+        void on_drop(Args const &args)\n+        {\n+            // cache the result at the point this calculation was dropped\n+            BOOST_ASSERT(!this->has_result());\n+            this->set(this->Accumulator::result(args));\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            return this->has_result() ? this->get() : this->Accumulator::result(args);\n+        }\n+\n+    private:\n+        with_cached_result &operator =(with_cached_result const &);\n+\n+        void set(result_type const &r)\n+        {\n+            ::new(this->cache.address()) result_type(r);\n+        }\n+\n+        result_type const &get() const\n+        {\n+            return *static_cast<result_type const *>(this->cache.address());\n+        }\n+\n+        bool has_result() const\n+        {\n+            typedef with_cached_result<Accumulator> this_type;\n+            typedef droppable_accumulator_base<this_type> derived_type;\n+            return static_cast<derived_type const *>(this)->is_dropped();\n+        }\n+\n+        aligned_storage<sizeof(result_type)> cache;\n+    };\n+\n+    namespace tag\n+    {\n+        template<typename Feature>\n+        struct as_droppable\n+        {\n+            typedef droppable<Feature> type;\n+        };\n+\n+        template<typename Feature>\n+        struct as_droppable<droppable<Feature> >\n+        {\n+            typedef droppable<Feature> type;\n+        };\n+\n+        //////////////////////////////////////////////////////////////////////////\n+        // droppable\n+        template<typename Feature>\n+        struct droppable\n+          : as_feature<Feature>::type\n+        {\n+            typedef typename as_feature<Feature>::type feature_type;\n+            typedef typename feature_type::dependencies tmp_dependencies_;\n+\n+            typedef\n+                typename mpl::transform<\n+                    typename feature_type::dependencies\n+                  , as_droppable<mpl::_1>\n+                >::type\n+            dependencies;\n+\n+            struct impl\n+            {\n+                template<typename Sample, typename Weight>\n+                struct apply\n+                {\n+                    typedef\n+                        droppable_accumulator<\n+                            typename mpl::apply2<typename feature_type::impl, Sample, Weight>::type\n+                        >\n+                    type;\n+                };\n+            };\n+        };\n+    }\n+\n+    // make droppable<tag::feature(modifier)> work\n+    template<typename Feature>\n+    struct as_feature<tag::droppable<Feature> >\n+    {\n+        typedef tag::droppable<typename as_feature<Feature>::type> type;\n+    };\n+\n+    // make droppable<tag::mean> work with non-void weights (should become\n+    // droppable<tag::weighted_mean>\n+    template<typename Feature>\n+    struct as_weighted_feature<tag::droppable<Feature> >\n+    {\n+        typedef tag::droppable<typename as_weighted_feature<Feature>::type> type;\n+    };\n+\n+    // for the purposes of feature-based dependency resolution,\n+    // droppable<Foo> provides the same feature as Foo\n+    template<typename Feature>\n+    struct feature_of<tag::droppable<Feature> >\n+      : feature_of<Feature>\n+    {\n+    };\n+\n+    // Note: Usually, the extractor is pulled into the accumulators namespace with\n+    // a using directive, not the tag. But the droppable<> feature doesn't have an\n+    // extractor, so we can put the droppable tag in the accumulators namespace\n+    // without fear of a name conflict.\n+    using tag::droppable;\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "eb6965c0ab85bc0101056e3a80e0319fc24b45de",
        "filename": "src/boost/accumulators/framework/accumulators/external_accumulator.hpp",
        "status": "added",
        "additions": 108,
        "deletions": 0,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/accumulators/external_accumulator.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/accumulators/external_accumulator.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/framework/accumulators/external_accumulator.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,108 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// external_accumulator.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_FRAMEWORK_ACCUMULATORS_EXTERNAL_ACCUMULATOR_HPP_EAN_01_12_2005\n+#define BOOST_ACCUMULATORS_FRAMEWORK_ACCUMULATORS_EXTERNAL_ACCUMULATOR_HPP_EAN_01_12_2005\n+\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp> // for feature_tag\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/accumulators/reference_accumulator.hpp>\n+\n+namespace boost { namespace accumulators { namespace impl\n+{\n+\n+    //////////////////////////////////////////////////////////////////////////\n+    // external_impl\n+    /// INTERNAL ONLY\n+    ///\n+    template<typename Accumulator, typename Tag>\n+    struct external_impl\n+      : accumulator_base\n+    {\n+        typedef typename Accumulator::result_type result_type;\n+        typedef typename detail::feature_tag<Accumulator>::type feature_tag;\n+\n+        external_impl(dont_care) {}\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            return this->extract_(args, args[parameter::keyword<Tag>::instance | 0]);\n+        }\n+\n+    private:\n+\n+        template<typename Args>\n+        static result_type extract_(Args const &args, int)\n+        {\n+            // No named parameter passed to the extractor. Maybe the external\n+            // feature is held by reference<>.\n+            extractor<feature_tag> extract;\n+            return extract(accumulators::reference_tag<Tag>(args));\n+        }\n+\n+        template<typename Args, typename AccumulatorSet>\n+        static result_type extract_(Args const &, AccumulatorSet const &acc)\n+        {\n+            // OK, a named parameter for this external feature was passed to the\n+            // extractor, so use that.\n+            extractor<feature_tag> extract;\n+            return extract(acc);\n+        }\n+    };\n+\n+} // namespace impl\n+\n+namespace tag\n+{\n+    //////////////////////////////////////////////////////////////////////////\n+    // external\n+    template<typename Feature, typename Tag, typename AccumulatorSet>\n+    struct external\n+      : depends_on<reference<AccumulatorSet, Tag> >\n+    {\n+        typedef\n+            accumulators::impl::external_impl<\n+                detail::to_accumulator<Feature, mpl::_1, mpl::_2>\n+              , Tag\n+            >\n+        impl;\n+    };\n+\n+    template<typename Feature, typename Tag>\n+    struct external<Feature, Tag, void>\n+      : depends_on<>\n+    {\n+        typedef\n+            accumulators::impl::external_impl<\n+                detail::to_accumulator<Feature, mpl::_1, mpl::_2>\n+              , Tag\n+            >\n+        impl;\n+    };\n+}\n+\n+// for the purposes of feature-based dependency resolution,\n+// external_accumulator<Feature, Tag> provides the same feature as Feature\n+template<typename Feature, typename Tag, typename AccumulatorSet>\n+struct feature_of<tag::external<Feature, Tag, AccumulatorSet> >\n+  : feature_of<Feature>\n+{\n+};\n+\n+// Note: Usually, the extractor is pulled into the accumulators namespace with\n+// a using directive, not the tag. But the external<> feature doesn't have an\n+// extractor, so we can put the external tag in the accumulators namespace\n+// without fear of a name conflict.\n+using tag::external;\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "e50a751dc51615d810bdeef8c00180df117989be",
        "filename": "src/boost/accumulators/framework/accumulators/reference_accumulator.hpp",
        "status": "added",
        "additions": 89,
        "deletions": 0,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/accumulators/reference_accumulator.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/accumulators/reference_accumulator.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/framework/accumulators/reference_accumulator.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,89 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// reference_accumulator.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_FRAMEWORK_ACCUMULATORS_REFERENCE_ACCUMULATOR_HPP_EAN_03_23_2006\n+#define BOOST_ACCUMULATORS_FRAMEWORK_ACCUMULATORS_REFERENCE_ACCUMULATOR_HPP_EAN_03_23_2006\n+\n+#include <boost/ref.hpp>\n+#include <boost/mpl/always.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp> // for feature_tag\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    //////////////////////////////////////////////////////////////////////////\n+    // reference_accumulator_impl\n+    //\n+    template<typename Referent, typename Tag>\n+    struct reference_accumulator_impl\n+      : accumulator_base\n+    {\n+        typedef Referent &result_type;\n+\n+        template<typename Args>\n+        reference_accumulator_impl(Args const &args)\n+          : ref(args[parameter::keyword<Tag>::instance])\n+        {\n+        }\n+\n+        result_type result(dont_care) const\n+        {\n+            return this->ref;\n+        }\n+\n+    private:\n+        reference_wrapper<Referent> ref;\n+    };\n+} // namespace impl\n+\n+namespace tag\n+{\n+    //////////////////////////////////////////////////////////////////////////\n+    // reference_tag\n+    template<typename Tag>\n+    struct reference_tag\n+    {\n+    };\n+\n+    //////////////////////////////////////////////////////////////////////////\n+    // reference\n+    template<typename Referent, typename Tag>\n+    struct reference\n+      : depends_on<>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef mpl::always<accumulators::impl::reference_accumulator_impl<Referent, Tag> > impl;\n+    };\n+}\n+\n+namespace extract\n+{\n+    BOOST_ACCUMULATORS_DEFINE_EXTRACTOR(tag, reference, (typename)(typename))\n+    BOOST_ACCUMULATORS_DEFINE_EXTRACTOR(tag, reference_tag, (typename))\n+}\n+\n+using extract::reference;\n+using extract::reference_tag;\n+\n+// Map all reference<V,T> features to reference_tag<T> so\n+// that references can be extracted using reference_tag<T>\n+// without specifying the referent type.\n+template<typename ValueType, typename Tag>\n+struct feature_of<tag::reference<ValueType, Tag> >\n+  : feature_of<tag::reference_tag<Tag> >\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "148549b08537093dbced907c546fd4613a109e63",
        "filename": "src/boost/accumulators/framework/accumulators/value_accumulator.hpp",
        "status": "added",
        "additions": 89,
        "deletions": 0,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/accumulators/value_accumulator.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/accumulators/value_accumulator.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/framework/accumulators/value_accumulator.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,89 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// value_accumulator.hpp\n+//\n+//  Copyright 2005 Eric Niebler, Daniel Egloff. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_FRAMEWORK_ACCUMULATORS_VALUE_ACCUMULATOR_HPP_EAN_03_23_2006\n+#define BOOST_ACCUMULATORS_FRAMEWORK_ACCUMULATORS_VALUE_ACCUMULATOR_HPP_EAN_03_23_2006\n+\n+#include <boost/mpl/always.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp> // for feature_tag\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+\n+    //////////////////////////////////////////////////////////////////////////\n+    // value_accumulator_impl\n+    template<typename ValueType, typename Tag>\n+    struct value_accumulator_impl\n+      : accumulator_base\n+    {\n+        typedef ValueType result_type;\n+\n+        template<typename Args>\n+        value_accumulator_impl(Args const &args)\n+          : val(args[parameter::keyword<Tag>::instance])\n+        {\n+        }\n+\n+        result_type result(dont_care) const\n+        {\n+            return this->val;\n+        }\n+\n+    private:\n+        ValueType val;\n+    };\n+\n+} // namespace impl\n+\n+namespace tag\n+{\n+    //////////////////////////////////////////////////////////////////////////\n+    // value_tag\n+    template<typename Tag>\n+    struct value_tag\n+    {\n+    };\n+\n+    //////////////////////////////////////////////////////////////////////////\n+    // value\n+    template<typename ValueType, typename Tag>\n+    struct value\n+      : depends_on<>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef mpl::always<accumulators::impl::value_accumulator_impl<ValueType, Tag> > impl;\n+    };\n+}\n+\n+namespace extract\n+{\n+    BOOST_ACCUMULATORS_DEFINE_EXTRACTOR(tag, value, (typename)(typename))\n+    BOOST_ACCUMULATORS_DEFINE_EXTRACTOR(tag, value_tag, (typename))\n+}\n+\n+using extract::value;\n+using extract::value_tag;\n+\n+// Map all value<V,T> features to value_tag<T> so\n+// that values can be extracted using value_tag<T>\n+// without specifying the value type.\n+template<typename ValueType, typename Tag>\n+struct feature_of<tag::value<ValueType, Tag> >\n+  : feature_of<tag::value_tag<Tag> >\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "dd2b637b5c075ac1ab20bf6579dcb9e34f6c64cc",
        "filename": "src/boost/accumulators/framework/depends_on.hpp",
        "status": "added",
        "additions": 455,
        "deletions": 0,
        "changes": 455,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/depends_on.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/depends_on.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/framework/depends_on.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,455 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// depends_on.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_FRAMEWORK_DEPENDS_ON_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_FRAMEWORK_DEPENDS_ON_HPP_EAN_28_10_2005\n+\n+#include <boost/version.hpp>\n+#include <boost/mpl/end.hpp>\n+#include <boost/mpl/map.hpp>\n+#include <boost/mpl/set.hpp>\n+#include <boost/mpl/copy.hpp>\n+#include <boost/mpl/fold.hpp>\n+#include <boost/mpl/size.hpp>\n+#include <boost/mpl/sort.hpp>\n+#include <boost/mpl/insert.hpp>\n+#include <boost/mpl/assert.hpp>\n+#include <boost/mpl/remove.hpp>\n+#include <boost/mpl/vector.hpp>\n+#include <boost/mpl/inherit.hpp>\n+#include <boost/mpl/identity.hpp>\n+#include <boost/mpl/equal_to.hpp>\n+#include <boost/mpl/contains.hpp>\n+#include <boost/mpl/transform.hpp>\n+#include <boost/mpl/is_sequence.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/mpl/insert_range.hpp>\n+#include <boost/mpl/back_inserter.hpp>\n+#include <boost/mpl/transform_view.hpp>\n+#include <boost/mpl/inherit_linearly.hpp>\n+#include <boost/type_traits/is_base_and_derived.hpp>\n+#include <boost/preprocessor/repetition/repeat.hpp>\n+#include <boost/preprocessor/repetition/enum_params.hpp>\n+#include <boost/preprocessor/facilities/intercept.hpp>\n+#include <boost/accumulators/accumulators_fwd.hpp>\n+#include <boost/fusion/include/next.hpp>\n+#include <boost/fusion/include/equal_to.hpp>\n+#include <boost/fusion/include/value_of.hpp>\n+#include <boost/fusion/include/mpl.hpp>\n+#include <boost/fusion/include/end.hpp>\n+#include <boost/fusion/include/begin.hpp>\n+#include <boost/fusion/include/cons.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+    ///////////////////////////////////////////////////////////////////////////\n+    // as_feature\n+    template<typename Feature>\n+    struct as_feature\n+    {\n+        typedef Feature type;\n+    };\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // weighted_feature\n+    template<typename Feature>\n+    struct as_weighted_feature\n+    {\n+        typedef Feature type;\n+    };\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // feature_of\n+    template<typename Feature>\n+    struct feature_of\n+    {\n+        typedef Feature type;\n+    };\n+\n+    namespace detail\n+    {\n+        ///////////////////////////////////////////////////////////////////////////\n+        // feature_tag\n+        template<typename Accumulator>\n+        struct feature_tag\n+        {\n+            typedef typename Accumulator::feature_tag type;\n+        };\n+\n+        template<typename Feature>\n+        struct undroppable\n+        {\n+            typedef Feature type;\n+        };\n+\n+        template<typename Feature>\n+        struct undroppable<tag::droppable<Feature> >\n+        {\n+            typedef Feature type;\n+        };\n+\n+        // For the purpose of determining whether one feature depends on another,\n+        // disregard whether the feature is droppable or not.\n+        template<typename A, typename B>\n+        struct is_dependent_on\n+          : is_base_and_derived<\n+                typename feature_of<typename undroppable<B>::type>::type\n+              , typename undroppable<A>::type\n+            >\n+        {};\n+\n+        template<typename Feature>\n+        struct dependencies_of\n+        {\n+            typedef typename Feature::dependencies type;\n+        };\n+\n+        // Should use mpl::insert_range, but doesn't seem to work with mpl sets\n+        template<typename Set, typename Range>\n+        struct set_insert_range\n+          : mpl::fold<\n+                Range\n+              , Set\n+              , mpl::insert<mpl::_1, mpl::_2>\n+            >\n+        {};\n+\n+        template<typename Features>\n+        struct collect_abstract_features\n+          : mpl::fold<\n+                Features\n+              , mpl::set0<>\n+              , set_insert_range<\n+                    mpl::insert<mpl::_1, feature_of<mpl::_2> >\n+                  , collect_abstract_features<dependencies_of<mpl::_2> >\n+                >\n+            >\n+        {};\n+\n+        template<typename Features>\n+        struct depends_on_base\n+          : mpl::inherit_linearly<\n+                typename mpl::sort<\n+                    typename mpl::copy<\n+                        typename collect_abstract_features<Features>::type\n+                      , mpl::back_inserter<mpl::vector0<> >\n+                    >::type\n+                  , is_dependent_on<mpl::_1, mpl::_2>\n+                >::type\n+                // Don't inherit multiply from a feature\n+              , mpl::if_<\n+                    is_dependent_on<mpl::_1, mpl::_2>\n+                  , mpl::_1\n+                  , mpl::inherit<mpl::_1, mpl::_2>\n+                >\n+            >::type\n+        {\n+        };\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// depends_on\n+    template<BOOST_PP_ENUM_PARAMS(BOOST_ACCUMULATORS_MAX_FEATURES, typename Feature)>\n+    struct depends_on\n+      : detail::depends_on_base<\n+            typename mpl::transform<\n+                mpl::vector<BOOST_PP_ENUM_PARAMS(BOOST_ACCUMULATORS_MAX_FEATURES, Feature)>\n+              , as_feature<mpl::_1>\n+            >::type\n+        >\n+    {\n+        typedef mpl::false_ is_weight_accumulator;\n+        typedef\n+            typename mpl::transform<\n+                mpl::vector<BOOST_PP_ENUM_PARAMS(BOOST_ACCUMULATORS_MAX_FEATURES, Feature)>\n+              , as_feature<mpl::_1>\n+            >::type\n+        dependencies;\n+    };\n+\n+    namespace detail\n+    {\n+        template<typename Feature>\n+        struct matches_feature\n+        {\n+            template<typename Accumulator>\n+            struct apply\n+              : is_same<\n+                    typename feature_of<typename as_feature<Feature>::type>::type\n+                  , typename feature_of<typename as_feature<typename feature_tag<Accumulator>::type>::type>::type\n+                >\n+            {};\n+        };\n+\n+        template<typename Features, typename Accumulator>\n+        struct contains_feature_of\n+        {\n+            typedef\n+                mpl::transform_view<Features, feature_of<as_feature<mpl::_> > >\n+            features_list;\n+\n+            typedef\n+                typename feature_of<typename feature_tag<Accumulator>::type>::type\n+            the_feature;\n+\n+            typedef\n+                typename mpl::contains<features_list, the_feature>::type\n+            type;\n+        };\n+\n+        // This is to work around a bug in early versions of Fusion which caused\n+        // a compile error if contains_feature_of<List, mpl::_> is used as a\n+        // predicate to fusion::find_if\n+        template<typename Features>\n+        struct contains_feature_of_\n+        {\n+            template<typename Accumulator>\n+            struct apply\n+              : contains_feature_of<Features, Accumulator>\n+            {};\n+        };\n+\n+        template<\n+            typename First\n+          , typename Last\n+          , bool is_empty = fusion::result_of::equal_to<First, Last>::value\n+        >\n+        struct build_acc_list;\n+\n+        template<typename First, typename Last>\n+        struct build_acc_list<First, Last, true>\n+        {\n+            typedef fusion::nil_ type;\n+\n+            template<typename Args>\n+            static fusion::nil_\n+            call(Args const &, First const&, Last const&)\n+            {\n+                return fusion::nil_();\n+            }\n+        };\n+\n+        template<typename First, typename Last>\n+        struct build_acc_list<First, Last, false>\n+        {\n+            typedef\n+                build_acc_list<typename fusion::result_of::next<First>::type, Last>\n+            next_build_acc_list;\n+\n+            typedef fusion::cons<\n+                typename fusion::result_of::value_of<First>::type\n+              , typename next_build_acc_list::type>\n+            type;\n+\n+            template<typename Args>\n+            static type\n+            call(Args const &args, First const& f, Last const& l)\n+            {\n+                return type(args, next_build_acc_list::call(args, fusion::next(f), l));\n+            }\n+        };\n+\n+        namespace meta\n+        {\n+            template<typename Sequence>\n+            struct make_acc_list\n+              : build_acc_list<\n+                    typename fusion::result_of::begin<Sequence>::type\n+                  , typename fusion::result_of::end<Sequence>::type\n+                >\n+            {};\n+        }\n+\n+        template<typename Sequence, typename Args>\n+        typename meta::make_acc_list<Sequence>::type\n+        make_acc_list(Sequence &seq, Args const &args)\n+        {\n+            return meta::make_acc_list<Sequence>::call(args, fusion::begin(seq), fusion::end(seq));\n+        }\n+\n+        template<typename Sequence, typename Args>\n+        typename meta::make_acc_list<Sequence>::type\n+        make_acc_list(Sequence const &seq, Args const &args)\n+        {\n+            return meta::make_acc_list<Sequence const>::call(args, fusion::begin(seq), fusion::end(seq));\n+        }\n+\n+        ///////////////////////////////////////////////////////////////////////////\n+        // checked_as_weighted_feature\n+        template<typename Feature>\n+        struct checked_as_weighted_feature\n+        {\n+            typedef typename as_feature<Feature>::type feature_type;\n+            typedef typename as_weighted_feature<feature_type>::type type;\n+            // weighted and non-weighted flavors should provide the same feature.\n+            BOOST_MPL_ASSERT((\n+                is_same<\n+                    typename feature_of<feature_type>::type\n+                  , typename feature_of<type>::type\n+                >\n+            ));\n+        };\n+\n+        ///////////////////////////////////////////////////////////////////////////\n+        // as_feature_list\n+        template<typename Features, typename Weight>\n+        struct as_feature_list\n+          : mpl::transform_view<Features, checked_as_weighted_feature<mpl::_1> >\n+        {\n+        };\n+\n+        template<typename Features>\n+        struct as_feature_list<Features, void>\n+          : mpl::transform_view<Features, as_feature<mpl::_1> >\n+        {\n+        };\n+\n+        ///////////////////////////////////////////////////////////////////////////\n+        // accumulator_wrapper\n+        template<typename Accumulator, typename Feature>\n+        struct accumulator_wrapper\n+          : Accumulator\n+        {\n+            typedef Feature feature_tag;\n+\n+            accumulator_wrapper(accumulator_wrapper const &that)\n+              : Accumulator(*static_cast<Accumulator const *>(&that))\n+            {\n+            }\n+\n+            template<typename Args>\n+            accumulator_wrapper(Args const &args)\n+              : Accumulator(args)\n+            {\n+            }\n+        };\n+\n+        ///////////////////////////////////////////////////////////////////////////\n+        // to_accumulator\n+        template<typename Feature, typename Sample, typename Weight>\n+        struct to_accumulator\n+        {\n+            typedef\n+                accumulator_wrapper<\n+                    typename mpl::apply2<typename Feature::impl, Sample, Weight>::type\n+                  , Feature\n+                >\n+            type;\n+        };\n+\n+        template<typename Feature, typename Sample, typename Weight, typename Tag, typename AccumulatorSet>\n+        struct to_accumulator<Feature, Sample, tag::external<Weight, Tag, AccumulatorSet> >\n+        {\n+            BOOST_MPL_ASSERT((is_same<Tag, void>));\n+            BOOST_MPL_ASSERT((is_same<AccumulatorSet, void>));\n+\n+            typedef\n+                accumulator_wrapper<\n+                    typename mpl::apply2<typename Feature::impl, Sample, Weight>::type\n+                  , Feature\n+                >\n+            accumulator_type;\n+\n+            typedef\n+                typename mpl::if_<\n+                    typename Feature::is_weight_accumulator\n+                  , accumulator_wrapper<impl::external_impl<accumulator_type, tag::weights>, Feature>\n+                  , accumulator_type\n+                >::type\n+            type;\n+        };\n+\n+        // BUGBUG work around an MPL bug wrt map insertion\n+        template<typename FeatureMap, typename Feature>\n+        struct insert_feature\n+          : mpl::eval_if<\n+                mpl::has_key<FeatureMap, typename feature_of<Feature>::type>\n+              , mpl::identity<FeatureMap>\n+              , mpl::insert<FeatureMap, mpl::pair<typename feature_of<Feature>::type, Feature> >\n+            >\n+        {\n+        };\n+\n+        template<typename FeatureMap, typename Feature, typename Weight>\n+        struct insert_dependencies\n+          : mpl::fold<\n+                as_feature_list<typename Feature::dependencies, Weight>\n+              , FeatureMap\n+              , insert_dependencies<\n+                    insert_feature<mpl::_1, mpl::_2>\n+                  , mpl::_2\n+                  , Weight\n+                >\n+            >\n+        {\n+        };\n+\n+        template<typename FeatureMap, typename Features, typename Weight>\n+        struct insert_sequence\n+          : mpl::fold< // BUGBUG should use insert_range, but doesn't seem to work for maps\n+                as_feature_list<Features, Weight>\n+              , FeatureMap\n+              , insert_feature<mpl::_1, mpl::_2>\n+            >\n+        {\n+        };\n+\n+        template<typename Features, typename Sample, typename Weight>\n+        struct make_accumulator_tuple\n+        {\n+            typedef\n+                typename mpl::fold<\n+                    as_feature_list<Features, Weight>\n+                  , mpl::map0<>\n+                  , mpl::if_<\n+                        mpl::is_sequence<mpl::_2>\n+                      , insert_sequence<mpl::_1, mpl::_2, Weight>\n+                      , insert_feature<mpl::_1, mpl::_2>\n+                    >\n+                >::type\n+            feature_map;\n+\n+            // for each element in the map, add its dependencies also\n+            typedef\n+                typename mpl::fold<\n+                    feature_map\n+                  , feature_map\n+                  , insert_dependencies<mpl::_1, mpl::second<mpl::_2>, Weight>\n+                >::type\n+            feature_map_with_dependencies;\n+\n+            // turn the map into a vector so we can sort it\n+            typedef\n+                typename mpl::insert_range<\n+                    mpl::vector<>\n+                  , mpl::end<mpl::vector<> >::type\n+                  , mpl::transform_view<feature_map_with_dependencies, mpl::second<mpl::_1> >\n+                >::type\n+            feature_vector_with_dependencies;\n+\n+            // sort the features according to which is derived from which\n+            typedef\n+                typename mpl::sort<\n+                    feature_vector_with_dependencies\n+                  , is_dependent_on<mpl::_2, mpl::_1>\n+                >::type\n+            sorted_feature_vector;\n+\n+            // From the vector of features, construct a vector of accumulators\n+            typedef\n+                typename mpl::transform<\n+                    sorted_feature_vector\n+                  , to_accumulator<mpl::_1, Sample, Weight>\n+                >::type\n+            type;\n+        };\n+\n+    } // namespace detail\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "dbd5d91693942f69f5520310fcdcd723ec80f284",
        "filename": "src/boost/accumulators/framework/external.hpp",
        "status": "added",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/external.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/external.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/framework/external.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,27 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// external.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_FRAMEWORK_EXTERNAL_HPP_EAN_01_12_2005\n+#define BOOST_ACCUMULATORS_FRAMEWORK_EXTERNAL_HPP_EAN_01_12_2005\n+\n+#include <boost/mpl/apply.hpp>\n+#include <boost/accumulators/framework/accumulators/external_accumulator.hpp>\n+\n+//namespace boost { namespace accumulators\n+//{\n+//\n+/////////////////////////////////////////////////////////////////////////////////\n+//// external\n+////\n+//template<typename Type>\n+//struct external\n+//{\n+//};\n+//\n+//}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "169794461c6f88440e07bcafaf46e85fdf6fb8fc",
        "filename": "src/boost/accumulators/framework/extractor.hpp",
        "status": "added",
        "additions": 248,
        "deletions": 0,
        "changes": 248,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/extractor.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/extractor.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/framework/extractor.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,248 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// extractor.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_FRAMEWORK_EXTRACTOR_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_FRAMEWORK_EXTRACTOR_HPP_EAN_28_10_2005\n+\n+#include <boost/preprocessor/cat.hpp>\n+#include <boost/preprocessor/tuple/rem.hpp>\n+#include <boost/preprocessor/array/size.hpp>\n+#include <boost/preprocessor/array/data.hpp>\n+#include <boost/preprocessor/array/elem.hpp>\n+#include <boost/preprocessor/seq/to_array.hpp>\n+#include <boost/preprocessor/seq/transform.hpp>\n+#include <boost/preprocessor/repetition/enum_params.hpp>\n+#include <boost/preprocessor/repetition/enum_trailing.hpp>\n+#include <boost/preprocessor/repetition/enum_trailing_params.hpp>\n+#include <boost/preprocessor/repetition/enum_trailing_binary_params.hpp>\n+#include <boost/preprocessor/repetition/repeat.hpp>\n+#include <boost/preprocessor/repetition/repeat_from_to.hpp>\n+#include <boost/parameter/binding.hpp>\n+#include <boost/mpl/bool.hpp>\n+#include <boost/mpl/if.hpp>\n+#include <boost/mpl/eval_if.hpp>\n+#include <boost/mpl/apply.hpp>\n+#include <boost/type_traits/remove_const.hpp>\n+#include <boost/type_traits/remove_reference.hpp>\n+#include <boost/accumulators/accumulators_fwd.hpp>\n+#include <boost/accumulators/framework/parameters/accumulator.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace detail\n+{\n+    template<typename AccumulatorSet, typename Feature>\n+    struct accumulator_set_result\n+    {\n+        typedef typename as_feature<Feature>::type feature_type;\n+        typedef typename mpl::apply<\n+            typename boost::remove_const<\n+                typename boost::remove_reference<AccumulatorSet>::type\n+            >::type\n+          , feature_type\n+        >::type::result_type type;\n+    };\n+\n+    template<typename Args, typename Feature>\n+    struct argument_pack_result\n+      : accumulator_set_result<\n+            typename boost::remove_reference<\n+                typename parameter::binding<\n+                    typename boost::remove_const<\n+                        typename boost::remove_reference<Args>::type\n+                    >::type\n+                  , tag::accumulator\n+                >::type\n+            >::type\n+          , Feature\n+        >\n+    {\n+    };\n+\n+    template<typename A, typename Feature>\n+    struct extractor_result\n+      : mpl::eval_if<\n+            detail::is_accumulator_set<A>\n+          , accumulator_set_result<A, Feature>\n+          , argument_pack_result<A, Feature>\n+        >\n+    {\n+    };\n+\n+    template<typename Feature, typename AccumulatorSet>\n+    typename extractor_result<AccumulatorSet, Feature>::type\n+    do_extract(AccumulatorSet const &acc, mpl::true_)\n+    {\n+        typedef typename as_feature<Feature>::type feature_type;\n+        return extract_result<feature_type>(acc);\n+    }\n+\n+    template<typename Feature, typename Args>\n+    typename extractor_result<Args, Feature>::type\n+    do_extract(Args const &args, mpl::false_)\n+    {\n+        typedef typename as_feature<Feature>::type feature_type;\n+        return find_accumulator<feature_type>(args[accumulator]).result(args);\n+    }\n+\n+} // namespace detail\n+\n+\n+///////////////////////////////////////////////////////////////////////////////\n+/// Extracts the result associated with Feature from the specified accumulator_set.\n+template<typename Feature>\n+struct extractor\n+{\n+    typedef extractor<Feature> this_type;\n+\n+    /// The result meta-function for determining the return type of the extractor\n+    template<typename F>\n+    struct result;\n+\n+    template<typename A1>\n+    struct result<this_type(A1)>\n+      : detail::extractor_result<A1, Feature>\n+    {\n+    };\n+\n+    /// Extract the result associated with Feature from the accumulator set\n+    /// \\param acc The accumulator set object from which to extract the result\n+    template<typename Arg1>\n+    typename detail::extractor_result<Arg1, Feature>::type\n+    operator ()(Arg1 const &arg1) const\n+    {\n+        // Arg1 could be an accumulator_set or an argument pack containing\n+        // an accumulator_set. Dispatch accordingly.\n+        return detail::do_extract<Feature>(arg1, detail::is_accumulator_set<Arg1>());\n+    }\n+\n+    /// \\overload\n+    ///\n+    /// \\param a1 Optional named parameter to be passed to the accumulator's result() function.\n+    template<typename AccumulatorSet, typename A1>\n+    typename detail::extractor_result<AccumulatorSet, Feature>::type\n+    operator ()(AccumulatorSet const &acc, A1 const &a1) const\n+    {\n+        BOOST_MPL_ASSERT((detail::is_accumulator_set<AccumulatorSet>));\n+        typedef typename as_feature<Feature>::type feature_type;\n+        return extract_result<feature_type>(acc, a1);\n+    }\n+\n+    // ... other overloads generated by Boost.Preprocessor:\n+\n+    /// INTERNAL ONLY\n+    ///\n+#define BOOST_ACCUMULATORS_EXTRACTOR_FUN_OP(z, n, _)                                    \\\n+    template<BOOST_PP_ENUM_PARAMS_Z(z, n, typename A)>                                  \\\n+    struct result<this_type(BOOST_PP_ENUM_PARAMS_Z(z, n, A))>                           \\\n+      : detail::extractor_result<A1, Feature>                                           \\\n+    {};                                                                                 \\\n+    template<                                                                           \\\n+        typename AccumulatorSet                                                         \\\n+        BOOST_PP_ENUM_TRAILING_PARAMS_Z(z, n, typename A)                               \\\n+    >                                                                                   \\\n+    typename detail::extractor_result<AccumulatorSet, Feature>::type                    \\\n+    operator ()(                                                                        \\\n+        AccumulatorSet const &acc                                                       \\\n+        BOOST_PP_ENUM_TRAILING_BINARY_PARAMS_Z(z, n, A, const &a)                       \\\n+    ) const                                                                             \\\n+    {                                                                                   \\\n+        BOOST_MPL_ASSERT((detail::is_accumulator_set<AccumulatorSet>));                 \\\n+        typedef typename as_feature<Feature>::type feature_type;                        \\\n+        return extract_result<feature_type>(acc BOOST_PP_ENUM_TRAILING_PARAMS_Z(z, n, a));\\\n+    }\n+\n+    BOOST_PP_REPEAT_FROM_TO(\n+        2\n+      , BOOST_PP_INC(BOOST_ACCUMULATORS_MAX_ARGS)\n+      , BOOST_ACCUMULATORS_EXTRACTOR_FUN_OP\n+      , _\n+    )\n+\n+#undef BOOST_ACCUMULATORS_EXTRACTOR_FUN_OP\n+\n+    #ifdef BOOST_ACCUMULATORS_DOXYGEN_INVOKED\n+    /// \\overload\n+    ///\n+    template<typename AccumulatorSet, typename A1, typename A2, ...>\n+    typename detail::extractor_result<AccumulatorSet, Feature>::type\n+    operator ()(AccumulatorSet const &acc, A1 const &a1, A2 const &a2, ...);\n+    #endif\n+};\n+\n+}} // namespace boost::accumulators\n+\n+/// INTERNAL ONLY\n+///\n+#define BOOST_ACCUMULATORS_ARRAY_REM(Array)                                                         \\\n+    BOOST_PP_TUPLE_REM_CTOR(BOOST_PP_ARRAY_SIZE(Array), BOOST_PP_ARRAY_DATA(Array))\n+\n+/// INTERNAL ONLY\n+///\n+#define BOOST_ACCUMULATORS_SEQ_REM(Seq)                                                             \\\n+    BOOST_ACCUMULATORS_ARRAY_REM(BOOST_PP_SEQ_TO_ARRAY(Seq))\n+\n+/// INTERNAL ONLY\n+///\n+#define BOOST_ACCUMULATORS_ARGS_OP(s, data, elem)                                                   \\\n+    T ## s\n+\n+/// INTERNAL ONLY\n+///\n+#define BOOST_ACCUMULATORS_PARAMS_OP(s, data, elem)                                                 \\\n+    elem T ## s\n+\n+/// INTERNAL ONLY\n+///\n+#define BOOST_ACCUMULATORS_MAKE_FEATURE(Tag, Feature, ParamsSeq)                                    \\\n+    Tag::Feature<                                                                                   \\\n+        BOOST_ACCUMULATORS_SEQ_REM(                                                                 \\\n+            BOOST_PP_SEQ_TRANSFORM(BOOST_ACCUMULATORS_ARGS_OP, ~, ParamsSeq)                        \\\n+        )                                                                                           \\\n+    >\n+\n+/// INTERNAL ONLY\n+///\n+#define BOOST_ACCUMULATORS_DEFINE_EXTRACTOR_FUN_IMPL(z, n, Tag, Feature, ParamsSeq)                 \\\n+    template<                                                                                       \\\n+        BOOST_ACCUMULATORS_SEQ_REM(                                                                 \\\n+            BOOST_PP_SEQ_TRANSFORM(BOOST_ACCUMULATORS_PARAMS_OP, ~, ParamsSeq)                      \\\n+        )                                                                                           \\\n+      , typename Arg1                                                                               \\\n+        BOOST_PP_ENUM_TRAILING_PARAMS_Z(z, n, typename A)                                           \\\n+    >                                                                                               \\\n+    typename boost::accumulators::detail::extractor_result<                                         \\\n+        Arg1                                                                                        \\\n+      , BOOST_ACCUMULATORS_MAKE_FEATURE(Tag, Feature, ParamsSeq)                                    \\\n+    >::type                                                                                         \\\n+    Feature(Arg1 const &arg1 BOOST_PP_ENUM_TRAILING_BINARY_PARAMS_Z(z, n, A, const &a) )            \\\n+    {                                                                                               \\\n+        typedef BOOST_ACCUMULATORS_MAKE_FEATURE(Tag, Feature, ParamsSeq) feature_type;              \\\n+        return boost::accumulators::extractor<feature_type>()(                                      \\\n+            arg1 BOOST_PP_ENUM_TRAILING_PARAMS_Z(z, n, a));                                         \\\n+    }\n+\n+/// INTERNAL ONLY\n+///\n+#define BOOST_ACCUMULATORS_DEFINE_EXTRACTOR_FUN(z, n, _)                                            \\\n+    BOOST_ACCUMULATORS_DEFINE_EXTRACTOR_FUN_IMPL(                                                   \\\n+        z                                                                                           \\\n+      , n                                                                                           \\\n+      , BOOST_PP_ARRAY_ELEM(0, _)                                                                   \\\n+      , BOOST_PP_ARRAY_ELEM(1, _)                                                                   \\\n+      , BOOST_PP_ARRAY_ELEM(2, _)                                                                   \\\n+    )\n+\n+#define BOOST_ACCUMULATORS_DEFINE_EXTRACTOR(Tag, Feature, ParamSeq)                                 \\\n+    BOOST_PP_REPEAT(                                                                                \\\n+        BOOST_PP_INC(BOOST_ACCUMULATORS_MAX_ARGS)                                                   \\\n+      , BOOST_ACCUMULATORS_DEFINE_EXTRACTOR_FUN                                                     \\\n+      , (3, (Tag, Feature, ParamSeq))                                                               \\\n+    )\n+\n+#endif"
      },
      {
        "sha": "21cae004daecffb9496dbf9fae3ccd748a3e469d",
        "filename": "src/boost/accumulators/framework/features.hpp",
        "status": "added",
        "additions": 29,
        "deletions": 0,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/features.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/features.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/framework/features.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,29 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// features.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_STATS_HPP_EAN_08_12_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_STATS_HPP_EAN_08_12_2005\n+\n+#include <boost/preprocessor/repetition/enum_params.hpp>\n+#include <boost/mpl/vector.hpp>\n+#include <boost/accumulators/accumulators_fwd.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// features\n+//\n+template<BOOST_PP_ENUM_PARAMS(BOOST_ACCUMULATORS_MAX_FEATURES, typename Feature)>\n+struct features\n+  : mpl::vector<BOOST_PP_ENUM_PARAMS(BOOST_ACCUMULATORS_MAX_FEATURES, Feature)>\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "675a3a392496132955790f1d6fbe2158bd9ddd20",
        "filename": "src/boost/accumulators/framework/parameters/accumulator.hpp",
        "status": "added",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/parameters/accumulator.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/parameters/accumulator.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/framework/parameters/accumulator.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,22 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// accumulator.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_FRAMEWORK_PARAMETERS_ACCUMULATOR_HPP_EAN_31_10_2005\n+#define BOOST_ACCUMULATORS_FRAMEWORK_PARAMETERS_ACCUMULATOR_HPP_EAN_31_10_2005\n+\n+#include <boost/parameter/name.hpp>\n+#include <boost/accumulators/accumulators_fwd.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+BOOST_PARAMETER_NAME((accumulator, tag) accumulator)\n+BOOST_ACCUMULATORS_IGNORE_GLOBAL(accumulator)\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "39afe2b170f6fdd7ba8a0dc2f26e7765bd90d5a8",
        "filename": "src/boost/accumulators/framework/parameters/sample.hpp",
        "status": "added",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/parameters/sample.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/parameters/sample.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/framework/parameters/sample.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,22 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// sample.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_FRAMEWORK_PARAMETERS_SAMPLE_HPP_EAN_31_10_2005\n+#define BOOST_ACCUMULATORS_FRAMEWORK_PARAMETERS_SAMPLE_HPP_EAN_31_10_2005\n+\n+#include <boost/parameter/name.hpp>\n+#include <boost/accumulators/accumulators_fwd.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+BOOST_PARAMETER_NAME((sample, tag) sample)\n+BOOST_ACCUMULATORS_IGNORE_GLOBAL(sample)\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "e9c26bfbd044dba16472fc49dc272e87d88a2526",
        "filename": "src/boost/accumulators/framework/parameters/weight.hpp",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/parameters/weight.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/parameters/weight.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/framework/parameters/weight.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,23 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// weight.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_FRAMEWORK_PARAMETERS_WEIGHT_HPP_EAN_31_10_2005\n+#define BOOST_ACCUMULATORS_FRAMEWORK_PARAMETERS_WEIGHT_HPP_EAN_31_10_2005\n+\n+#include <boost/parameter/name.hpp>\n+#include <boost/accumulators/accumulators_fwd.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+// The weight of a single sample\n+BOOST_PARAMETER_NAME((weight, tag) weight)\n+BOOST_ACCUMULATORS_IGNORE_GLOBAL(weight)\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "ab1948a86bd2477e517d335436e818f77fb45157",
        "filename": "src/boost/accumulators/framework/parameters/weights.hpp",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/parameters/weights.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/framework/parameters/weights.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/framework/parameters/weights.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,23 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// weights.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_FRAMEWORK_PARAMETERS_WEIGHTS_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_FRAMEWORK_PARAMETERS_WEIGHTS_HPP_EAN_28_10_2005\n+\n+#include <boost/parameter/name.hpp>\n+#include <boost/accumulators/accumulators_fwd.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+// The weight accumulator\n+BOOST_PARAMETER_NAME((weights, tag) weights)\n+BOOST_ACCUMULATORS_IGNORE_GLOBAL(weights)\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "282eb1ef3e945951dda2348d2440fc1676de4e26",
        "filename": "src/boost/accumulators/numeric/detail/function1.hpp",
        "status": "added",
        "additions": 75,
        "deletions": 0,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/detail/function1.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/detail/function1.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/numeric/detail/function1.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,75 @@\n+// Copyright David Abrahams 2006. Distributed under the Boost\n+// Software License, Version 1.0. (See accompanying\n+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+#ifndef BOOST_DETAIL_FUNCTION1_DWA200655_HPP\n+# define BOOST_DETAIL_FUNCTION1_DWA200655_HPP\n+\n+# include <boost/concept_check.hpp>\n+# include <boost/type_traits/remove_reference.hpp>\n+# include <boost/type_traits/add_const.hpp>\n+# include <boost/mpl/apply.hpp>\n+\n+namespace boost { namespace detail {\n+\n+// A utility for creating unary function objects that play nicely with\n+// boost::result_of and that handle the forwarding problem.\n+//\n+// mpl::apply<F, A0>::type is expected to be a stateless function\n+// object that accepts an argument of type A0&.  It is also expected\n+// to have a nested ::result_type identical to its return type.\n+template<typename F>\n+struct function1\n+{\n+    template<typename Signature>\n+    struct result\n+    {};\n+\n+    template<typename This, typename A0>\n+    struct result<This(A0)>\n+    {\n+        // How adding const to arguments handles rvalues.\n+        //\n+        // if A0 is     arg0 is       represents actual argument\n+        // --------     -------       --------------------------\n+        // T const &    T const       const T lvalue\n+        // T &          T             non-const T lvalue\n+        // T const      T const       const T rvalue\n+        // T            T const       non-const T rvalue\n+        typedef typename remove_reference<\n+            typename add_const< A0 >::type\n+        >::type arg0;\n+\n+        typedef typename mpl::apply1<F, arg0>::type impl;\n+        typedef typename impl::result_type type;\n+    };\n+\n+    // Handles mutable lvalues\n+    template<typename A0>\n+    typename result<function1(A0 &)>::type\n+    operator ()(A0 &a0) const\n+    {\n+        typedef typename result<function1(A0 &)>::impl impl;\n+        typedef typename result<function1(A0 &)>::type type;\n+        typedef A0 &arg0;\n+        BOOST_CONCEPT_ASSERT((UnaryFunction<impl, type, arg0>));\n+        //boost::function_requires<UnaryFunctionConcept<impl, type, arg0> >();\n+        return impl()(a0);\n+    }\n+\n+    // Handles const lvalues and all rvalues\n+    template<typename A0>\n+    typename result<function1(A0 const &)>::type\n+    operator ()(A0 const &a0) const\n+    {\n+        typedef typename result<function1(A0 const &)>::impl impl;\n+        typedef typename result<function1(A0 const &)>::type type;\n+        typedef A0 const &arg0;\n+        BOOST_CONCEPT_ASSERT((UnaryFunction<impl, type, arg0>));\n+        //boost::function_requires<UnaryFunctionConcept<impl, type, arg0> >();\n+        return impl()(a0);\n+    }\n+};\n+\n+}} // namespace boost::detail\n+\n+#endif // BOOST_DETAIL_FUNCTION1_DWA200655_HPP"
      },
      {
        "sha": "daf3c4d4e76c13370133fc3cd5f9ce321768e520",
        "filename": "src/boost/accumulators/numeric/detail/function2.hpp",
        "status": "added",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/detail/function2.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/detail/function2.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/numeric/detail/function2.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,10 @@\n+// Copyright David Abrahams 2006. Distributed under the Boost\n+// Software License, Version 1.0. (See accompanying\n+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+#ifndef BOOST_DETAIL_FUNCTION2_DWA200655_HPP\n+# define BOOST_DETAIL_FUNCTION2_DWA200655_HPP\n+\n+# define args (2)\n+# include <boost/accumulators/numeric/detail/function_n.hpp>\n+\n+#endif // BOOST_DETAIL_FUNCTION2_DWA200655_HPP"
      },
      {
        "sha": "175e4d5b3a81a5355a9f3ee66c0ea82e78079ba6",
        "filename": "src/boost/accumulators/numeric/detail/function3.hpp",
        "status": "added",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/detail/function3.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/detail/function3.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/numeric/detail/function3.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,10 @@\n+// Copyright David Abrahams 2006. Distributed under the Boost\n+// Software License, Version 1.0. (See accompanying\n+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+#ifndef BOOST_DETAIL_FUNCTION3_DWA2006514_HPP\n+# define BOOST_DETAIL_FUNCTION3_DWA2006514_HPP\n+\n+# define args (3)\n+# include <boost/accumulators/numeric/detail/function_n.hpp>\n+\n+#endif // BOOST_DETAIL_FUNCTION3_DWA2006514_HPP"
      },
      {
        "sha": "a0d710837e570adf86f2a3b686cb342b8770eb7b",
        "filename": "src/boost/accumulators/numeric/detail/function4.hpp",
        "status": "added",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/detail/function4.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/detail/function4.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/numeric/detail/function4.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,10 @@\n+// Copyright David Abrahams 2006. Distributed under the Boost\n+// Software License, Version 1.0. (See accompanying\n+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+#ifndef BOOST_DETAIL_FUNCTION4_DWA2006514_HPP\n+# define BOOST_DETAIL_FUNCTION4_DWA2006514_HPP\n+\n+# define args (4)\n+# include <boost/accumulators/numeric/detail/function_n.hpp>\n+\n+#endif // BOOST_DETAIL_FUNCTION4_DWA2006514_HPP"
      },
      {
        "sha": "47c42ed05b8eab1c090dda02ce9682323eb1dcca",
        "filename": "src/boost/accumulators/numeric/detail/function_n.hpp",
        "status": "added",
        "additions": 148,
        "deletions": 0,
        "changes": 148,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/detail/function_n.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/detail/function_n.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/numeric/detail/function_n.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,148 @@\n+// Copyright David Abrahams 2006. Distributed under the Boost\n+// Software License, Version 1.0. (See accompanying\n+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+//\n+// #include guards intentionally disabled.\n+// #ifndef BOOST_DETAIL_FUNCTION_N_DWA2006514_HPP\n+// # define BOOST_DETAIL_FUNCTION_N_DWA2006514_HPP\n+\n+#include <boost/mpl/void.hpp>\n+#include <boost/mpl/apply.hpp>\n+\n+#include <boost/preprocessor/control/if.hpp>\n+#include <boost/preprocessor/cat.hpp>\n+#include <boost/preprocessor/punctuation/comma_if.hpp>\n+#include <boost/preprocessor/repetition/enum_params.hpp>\n+#include <boost/preprocessor/repetition/enum_trailing_params.hpp>\n+#include <boost/preprocessor/repetition/repeat.hpp>\n+#include <boost/preprocessor/seq/fold_left.hpp>\n+#include <boost/preprocessor/seq/seq.hpp>\n+#include <boost/preprocessor/seq/for_each.hpp>\n+#include <boost/preprocessor/seq/for_each_i.hpp>\n+#include <boost/preprocessor/seq/for_each_product.hpp>\n+#include <boost/preprocessor/seq/size.hpp>\n+#include <boost/type_traits/add_const.hpp>\n+#include <boost/type_traits/remove_reference.hpp>\n+\n+namespace boost { namespace detail {\n+\n+# define BOOST_DETAIL_default_arg(z, n, _)                                      \\\n+    typedef mpl::void_ BOOST_PP_CAT(arg, n);\n+\n+# define BOOST_DETAIL_function_arg(z, n, _)                                     \\\n+    typedef typename remove_reference<                                          \\\n+        typename add_const< BOOST_PP_CAT(A, n) >::type                          \\\n+    >::type BOOST_PP_CAT(arg, n);\n+\n+#define BOOST_DETAIL_cat_arg_counts(s, state, n)                                \\\n+    BOOST_PP_IF(                                                                \\\n+        n                                                                       \\\n+      , BOOST_PP_CAT(state, BOOST_PP_CAT(_, n))                                 \\\n+      , state                                                                   \\\n+    )                                                                           \\\n+    /**/\n+\n+#define function_name                                                           \\\n+    BOOST_PP_SEQ_FOLD_LEFT(                                                     \\\n+        BOOST_DETAIL_cat_arg_counts                                             \\\n+      , BOOST_PP_CAT(function, BOOST_PP_SEQ_HEAD(args))                         \\\n+      , BOOST_PP_SEQ_TAIL(args)(0)                                              \\\n+    )                                                                           \\\n+    /**/\n+\n+template<typename F>\n+struct function_name\n+{\n+    BOOST_PP_REPEAT(\n+        BOOST_MPL_LIMIT_METAFUNCTION_ARITY\n+      , BOOST_DETAIL_default_arg\n+      , ~\n+    )\n+\n+    template<typename Signature>\n+    struct result {};\n+\n+#define BOOST_DETAIL_function_result(r, _, n)                                   \\\n+    template<typename This BOOST_PP_ENUM_TRAILING_PARAMS(n, typename A)>        \\\n+    struct result<This(BOOST_PP_ENUM_PARAMS(n, A))>                             \\\n+    {                                                                           \\\n+        BOOST_PP_REPEAT(n, BOOST_DETAIL_function_arg, ~)                        \\\n+        typedef                                                                 \\\n+            typename BOOST_PP_CAT(mpl::apply, BOOST_MPL_LIMIT_METAFUNCTION_ARITY)<\\\n+                F                                                               \\\n+                BOOST_PP_ENUM_TRAILING_PARAMS(                                  \\\n+                    BOOST_MPL_LIMIT_METAFUNCTION_ARITY                          \\\n+                  , arg                                                         \\\n+                )                                                               \\\n+            >::type                                                             \\\n+        impl;                                                                   \\\n+        typedef typename impl::result_type type;                                \\\n+    };                                                                          \\\n+    /**/\n+\n+    BOOST_PP_SEQ_FOR_EACH(BOOST_DETAIL_function_result, _, args)\n+\n+# define arg_type(r, _, i, is_const)                                            \\\n+    BOOST_PP_COMMA_IF(i) BOOST_PP_CAT(A, i) BOOST_PP_CAT(const_if, is_const) &\n+\n+# define result_(r, n, constness)                                               \\\n+    typename result<                                                            \\\n+        function_name(                                                          \\\n+            BOOST_PP_SEQ_FOR_EACH_I_R(r, arg_type, ~, constness)                \\\n+        )                                                                       \\\n+    >                                                                           \\\n+    /**/\n+\n+# define param(r, _, i, is_const) BOOST_PP_COMMA_IF(i)                          \\\n+    BOOST_PP_CAT(A, i) BOOST_PP_CAT(const_if, is_const) & BOOST_PP_CAT(x, i)\n+\n+# define param_list(r, n, constness)                                            \\\n+    BOOST_PP_SEQ_FOR_EACH_I_R(r, param, ~, constness)\n+\n+# define call_operator(r, constness)                                            \\\n+    template<BOOST_PP_ENUM_PARAMS(BOOST_PP_SEQ_SIZE(constness), typename A)>    \\\n+        result_(r, BOOST_PP_SEQ_SIZE(constness), constness)::type               \\\n+    operator ()( param_list(r, BOOST_PP_SEQ_SIZE(constness), constness) ) const \\\n+    {                                                                           \\\n+        typedef result_(r, BOOST_PP_SEQ_SIZE(constness), constness)::impl impl; \\\n+        return impl()(BOOST_PP_ENUM_PARAMS(BOOST_PP_SEQ_SIZE(constness), x));   \\\n+    }                                                                           \\\n+    /**/\n+\n+# define const_if0\n+# define const_if1 const\n+\n+# define bits(z, n, _) ((0)(1))\n+\n+# define gen_operator(r, _, n)                                                  \\\n+    BOOST_PP_SEQ_FOR_EACH_PRODUCT_R(                                            \\\n+        r                                                                       \\\n+      , call_operator                                                           \\\n+      , BOOST_PP_REPEAT(n, bits, ~)                                             \\\n+    )                                                                           \\\n+    /**/\n+\n+    BOOST_PP_SEQ_FOR_EACH(\n+        gen_operator\n+      , ~\n+      , args\n+    )\n+\n+# undef bits\n+# undef const_if1\n+# undef const_if0\n+# undef call_operator\n+# undef param_list\n+# undef param\n+# undef result_\n+# undef default_\n+# undef arg_type\n+# undef gen_operator\n+# undef function_name\n+\n+# undef args\n+};\n+\n+}} // namespace boost::detail\n+\n+//#endif // BOOST_DETAIL_FUNCTION_N_DWA2006514_HPP"
      },
      {
        "sha": "317d85fb24a290ab8d0c83dc51c18b88ee1bd450",
        "filename": "src/boost/accumulators/numeric/detail/pod_singleton.hpp",
        "status": "added",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/detail/pod_singleton.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/detail/pod_singleton.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/numeric/detail/pod_singleton.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,20 @@\n+// Copyright David Abrahams 2006. Distributed under the Boost\n+// Software License, Version 1.0. (See accompanying\n+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+#ifndef BOOST_DETAIL_POD_SINGLETON_DWA200655_HPP\n+# define BOOST_DETAIL_POD_SINGLETON_DWA200655_HPP\n+\n+namespace boost { namespace detail {\n+\n+template<typename T>\n+struct pod_singleton\n+{\n+    static T instance;\n+};\n+\n+template<typename T>\n+T pod_singleton<T>::instance;\n+\n+}} // namespace boost::detail\n+\n+#endif // BOOST_DETAIL_POD_SINGLETON_DWA200655_HPP"
      },
      {
        "sha": "858decc199a72ad7936fb6096ef640586521c111",
        "filename": "src/boost/accumulators/numeric/functional.hpp",
        "status": "added",
        "additions": 537,
        "deletions": 0,
        "changes": 537,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/functional.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/functional.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/numeric/functional.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,537 @@\n+///////////////////////////////////////////////////////////////////////////////\n+/// \\file functional.hpp\n+///\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_NUMERIC_FUNCTIONAL_HPP_EAN_08_12_2005\n+#define BOOST_NUMERIC_FUNCTIONAL_HPP_EAN_08_12_2005\n+\n+#include <limits>\n+#include <functional>\n+#include <boost/static_assert.hpp>\n+#include <boost/mpl/if.hpp>\n+#include <boost/mpl/and.hpp>\n+#include <boost/type_traits/remove_const.hpp>\n+#include <boost/type_traits/add_reference.hpp>\n+#include <boost/type_traits/is_empty.hpp>\n+#include <boost/type_traits/is_integral.hpp>\n+#include <boost/type_traits/is_floating_point.hpp>\n+#include <boost/utility/enable_if.hpp>\n+#include <boost/typeof/typeof.hpp>\n+#include <boost/accumulators/accumulators_fwd.hpp>\n+#include <boost/accumulators/numeric/functional_fwd.hpp>\n+#include <boost/accumulators/numeric/detail/function1.hpp>\n+#include <boost/accumulators/numeric/detail/function2.hpp>\n+#include <boost/accumulators/numeric/detail/pod_singleton.hpp>\n+\n+#ifdef BOOST_NUMERIC_FUNCTIONAL_STD_VECTOR_SUPPORT\n+# include <boost/accumulators/numeric/functional/vector.hpp>\n+#endif\n+\n+#ifdef BOOST_NUMERIC_FUNCTIONAL_STD_VALARRAY_SUPPORT\n+# include <boost/accumulators/numeric/functional/valarray.hpp>\n+#endif\n+\n+#ifdef BOOST_NUMERIC_FUNCTIONAL_STD_COMPLEX_SUPPORT\n+# include <boost/accumulators/numeric/functional/complex.hpp>\n+#endif\n+\n+/// INTERNAL ONLY\n+///\n+#define BOOST_NUMERIC_FUNCTIONAL_HPP_INCLUDED\n+\n+#ifdef BOOST_NUMERIC_FUNCTIONAL_DOXYGEN_INVOKED\n+// Hack to make Doxygen show the inheritance relationships\n+/// INTERNAL ONLY\n+///\n+namespace std\n+{\n+    /// INTERNAL ONLY\n+    ///\n+    template<class Arg, class Ret> struct unary_function {};\n+    /// INTERNAL ONLY\n+    ///\n+    template<class Left, class Right, class Ret> struct binary_function {};\n+}\n+#endif\n+\n+namespace boost { namespace numeric\n+{\n+    namespace functional\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        template<typename A0, typename A1>\n+        struct are_integral\n+          : mpl::and_<is_integral<A0>, is_integral<A1> >\n+        {};\n+\n+        template<typename Left, typename Right>\n+        struct left_ref\n+        {\n+            typedef Left &type;\n+        };\n+\n+        namespace detail\n+        {\n+            template<typename T>\n+            T &lvalue_of();\n+        }\n+    }\n+\n+    // TODO: handle complex weight, valarray, MTL vectors\n+\n+    /// INTERNAL ONLY\n+    ///\n+#define BOOST_NUMERIC_FUNCTIONAL_DEFINE_UNARY_OP(Name, Op)                                      \\\n+    namespace functional                                                                        \\\n+    {                                                                                           \\\n+        template<typename Arg>                                                                  \\\n+        struct result_of_ ## Name                                                               \\\n+        {                                                                                       \\\n+            BOOST_TYPEOF_NESTED_TYPEDEF_TPL(                                                    \\\n+                nested                                                                          \\\n+              , Op boost::numeric::functional::detail::lvalue_of<Arg>()                         \\\n+            )                                                                                   \\\n+            typedef typename nested::type type;                                                 \\\n+        };                                                                                      \\\n+        template<typename Arg, typename EnableIf>                                               \\\n+        struct Name ## _base                                                                    \\\n+        {                                                                                       \\\n+            typedef typename remove_const<Arg>::type argument_type;                             \\\n+            typedef typename result_of_ ## Name<Arg>::type result_type;                         \\\n+            typename result_of_ ## Name<Arg>::type operator ()(Arg &arg) const                  \\\n+            {                                                                                   \\\n+                return Op arg;                                                                  \\\n+            }                                                                                   \\\n+        };                                                                                      \\\n+        template<typename Arg, typename ArgTag>                                                 \\\n+        struct Name                                                                             \\\n+          : Name ## _base<Arg, void>                                                            \\\n+        {};                                                                                     \\\n+    }                                                                                           \\\n+    namespace op                                                                                \\\n+    {                                                                                           \\\n+        struct Name                                                                             \\\n+          : boost::detail::function1<functional::Name<_, functional::tag<_> > >                 \\\n+        {};                                                                                     \\\n+    }                                                                                           \\\n+    namespace                                                                                   \\\n+    {                                                                                           \\\n+        op::Name const &Name = boost::detail::pod_singleton<op::Name>::instance;                \\\n+    }                                                                                           \\\n+    /**/\n+\n+    /// INTERNAL ONLY\n+    ///\n+#define BOOST_NUMERIC_FUNCTIONAL_DEFINE_BINARY_OP(Name, Op, RetType)                            \\\n+    namespace functional                                                                        \\\n+    {                                                                                           \\\n+        template<typename Left, typename Right, typename EnableIf>                              \\\n+        struct result_of_ ## Name                                                               \\\n+        {                                                                                       \\\n+            RetType(Left, Op, Right)                                                            \\\n+        };                                                                                      \\\n+        template<typename Left, typename Right, typename EnableIf>                              \\\n+        struct Name ## _base                                                                    \\\n+        {                                                                                       \\\n+            typedef typename remove_const<Left>::type first_argument_type;                      \\\n+            typedef typename remove_const<Right>::type second_argument_type;                    \\\n+            typedef typename result_of_ ## Name<Left, Right>::type result_type;                 \\\n+            typename result_of_ ## Name<Left, Right>::type                                      \\\n+            operator ()(Left &left, Right &right) const                                         \\\n+            {                                                                                   \\\n+                return left Op right;                                                           \\\n+            }                                                                                   \\\n+        };                                                                                      \\\n+        template<typename Left, typename Right, typename LeftTag, typename RightTag>            \\\n+        struct Name                                                                             \\\n+          : Name ## _base<Left, Right, void>                                                    \\\n+        {};                                                                                     \\\n+    }                                                                                           \\\n+    namespace op                                                                                \\\n+    {                                                                                           \\\n+        struct Name                                                                             \\\n+          : boost::detail::function2<                                                           \\\n+                functional::Name<_1, _2, functional::tag<_1>, functional::tag<_2> >             \\\n+            >                                                                                   \\\n+        {};                                                                                     \\\n+    }                                                                                           \\\n+    namespace                                                                                   \\\n+    {                                                                                           \\\n+        op::Name const &Name = boost::detail::pod_singleton<op::Name>::instance;                \\\n+    }                                                                                           \\\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(Name)                                                      \\\n+    /**/\n+\n+    /// INTERNAL ONLY\n+    ///\n+#define BOOST_NUMERIC_FUNCTIONAL_DEDUCED(Left, Op, Right)                                       \\\n+    BOOST_TYPEOF_NESTED_TYPEDEF_TPL(                                                            \\\n+        nested                                                                                  \\\n+      , boost::numeric::functional::detail::lvalue_of<Left>() Op                                \\\n+        boost::numeric::functional::detail::lvalue_of<Right>()                                  \\\n+    )                                                                                           \\\n+    typedef typename nested::type type;                                                         \\\n+    /**/\n+\n+    /// INTERNAL ONLY\n+    ///\n+#define BOOST_NUMERIC_FUNCTIONAL_LEFT(Left, Op, Right)                                          \\\n+    typedef Left &type;                                                                         \\\n+    /**/\n+\n+    BOOST_NUMERIC_FUNCTIONAL_DEFINE_BINARY_OP(plus, +, BOOST_NUMERIC_FUNCTIONAL_DEDUCED)\n+    BOOST_NUMERIC_FUNCTIONAL_DEFINE_BINARY_OP(minus, -, BOOST_NUMERIC_FUNCTIONAL_DEDUCED)\n+    BOOST_NUMERIC_FUNCTIONAL_DEFINE_BINARY_OP(multiplies, *, BOOST_NUMERIC_FUNCTIONAL_DEDUCED)\n+    BOOST_NUMERIC_FUNCTIONAL_DEFINE_BINARY_OP(divides, /, BOOST_NUMERIC_FUNCTIONAL_DEDUCED)\n+    BOOST_NUMERIC_FUNCTIONAL_DEFINE_BINARY_OP(modulus, %, BOOST_NUMERIC_FUNCTIONAL_DEDUCED)\n+    BOOST_NUMERIC_FUNCTIONAL_DEFINE_BINARY_OP(greater, >, BOOST_NUMERIC_FUNCTIONAL_DEDUCED)\n+    BOOST_NUMERIC_FUNCTIONAL_DEFINE_BINARY_OP(greater_equal, >=, BOOST_NUMERIC_FUNCTIONAL_DEDUCED)\n+    BOOST_NUMERIC_FUNCTIONAL_DEFINE_BINARY_OP(less, <, BOOST_NUMERIC_FUNCTIONAL_DEDUCED)\n+    BOOST_NUMERIC_FUNCTIONAL_DEFINE_BINARY_OP(less_equal, <=, BOOST_NUMERIC_FUNCTIONAL_DEDUCED)\n+    BOOST_NUMERIC_FUNCTIONAL_DEFINE_BINARY_OP(equal_to, ==, BOOST_NUMERIC_FUNCTIONAL_DEDUCED)\n+    BOOST_NUMERIC_FUNCTIONAL_DEFINE_BINARY_OP(not_equal_to, !=, BOOST_NUMERIC_FUNCTIONAL_DEDUCED)\n+\n+    BOOST_NUMERIC_FUNCTIONAL_DEFINE_BINARY_OP(assign, =, BOOST_NUMERIC_FUNCTIONAL_LEFT)\n+    BOOST_NUMERIC_FUNCTIONAL_DEFINE_BINARY_OP(plus_assign, +=, BOOST_NUMERIC_FUNCTIONAL_LEFT)\n+    BOOST_NUMERIC_FUNCTIONAL_DEFINE_BINARY_OP(minus_assign, -=, BOOST_NUMERIC_FUNCTIONAL_LEFT)\n+    BOOST_NUMERIC_FUNCTIONAL_DEFINE_BINARY_OP(multiplies_assign, *=, BOOST_NUMERIC_FUNCTIONAL_LEFT)\n+    BOOST_NUMERIC_FUNCTIONAL_DEFINE_BINARY_OP(divides_assign, /=, BOOST_NUMERIC_FUNCTIONAL_LEFT)\n+    BOOST_NUMERIC_FUNCTIONAL_DEFINE_BINARY_OP(modulus_assign, %=, BOOST_NUMERIC_FUNCTIONAL_LEFT)\n+\n+    BOOST_NUMERIC_FUNCTIONAL_DEFINE_UNARY_OP(unary_plus, +)\n+    BOOST_NUMERIC_FUNCTIONAL_DEFINE_UNARY_OP(unary_minus, -)\n+    BOOST_NUMERIC_FUNCTIONAL_DEFINE_UNARY_OP(complement, ~)\n+    BOOST_NUMERIC_FUNCTIONAL_DEFINE_UNARY_OP(logical_not, !)\n+\n+#undef BOOST_NUMERIC_FUNCTIONAL_LEFT\n+#undef BOOST_NUMERIC_FUNCTIONAL_DEDUCED\n+#undef BOOST_NUMERIC_FUNCTIONAL_DEFINE_UNARY_OP\n+#undef BOOST_NUMERIC_FUNCTIONAL_DEFINE_BINARY_OP\n+\n+    namespace functional\n+    {\n+        template<typename Left, typename Right, typename EnableIf>\n+        struct min_assign_base\n+        {\n+            typedef Left first_argument_type;\n+            typedef Right second_argument_type;\n+            typedef void result_type;\n+\n+            void operator ()(Left &left, Right &right) const\n+            {\n+                if(numeric::less(right, left))\n+                {\n+                    left = right;\n+                }\n+            }\n+        };\n+\n+        template<typename Left, typename Right, typename EnableIf>\n+        struct max_assign_base\n+        {\n+            typedef Left first_argument_type;\n+            typedef Right second_argument_type;\n+            typedef void result_type;\n+\n+            void operator ()(Left &left, Right &right) const\n+            {\n+                if(numeric::greater(right, left))\n+                {\n+                    left = right;\n+                }\n+            }\n+        };\n+\n+        template<typename Left, typename Right, typename EnableIf>\n+        struct fdiv_base\n+          : functional::divides<Left, Right>\n+        {};\n+\n+        // partial specialization that promotes the arguments to double for\n+        // integral division.\n+        template<typename Left, typename Right>\n+        struct fdiv_base<Left, Right, typename enable_if<are_integral<Left, Right> >::type>\n+          : functional::divides<double const, double const>\n+        {};\n+\n+        template<typename To, typename From, typename EnableIf>\n+        struct promote_base\n+        {\n+            typedef From argument_type;\n+            typedef To result_type;\n+\n+            To operator ()(From &from) const\n+            {\n+                return from;\n+            }\n+        };\n+\n+        template<typename ToFrom>\n+        struct promote_base<ToFrom, ToFrom, void>\n+        {\n+            typedef ToFrom argument_type;\n+            typedef ToFrom result_type;\n+\n+            ToFrom &operator ()(ToFrom &tofrom)\n+            {\n+                return tofrom;\n+            }\n+        };\n+\n+        template<typename Arg, typename EnableIf>\n+        struct as_min_base\n+        {\n+            BOOST_STATIC_ASSERT(std::numeric_limits<typename remove_const<Arg>::type>::is_specialized);\n+\n+            typedef Arg argument_type;\n+            typedef typename remove_const<Arg>::type result_type;\n+\n+            typename remove_const<Arg>::type operator ()(Arg &) const\n+            {\n+                return (std::numeric_limits<typename remove_const<Arg>::type>::min)();\n+            }\n+        };\n+\n+        template<typename Arg>\n+        struct as_min_base<Arg, typename enable_if<is_floating_point<Arg> >::type>\n+        {\n+            BOOST_STATIC_ASSERT(std::numeric_limits<typename remove_const<Arg>::type>::is_specialized);\n+\n+            typedef Arg argument_type;\n+            typedef typename remove_const<Arg>::type result_type;\n+\n+            typename remove_const<Arg>::type operator ()(Arg &) const\n+            {\n+                return -(std::numeric_limits<typename remove_const<Arg>::type>::max)();\n+            }\n+        };\n+\n+        template<typename Arg, typename EnableIf>\n+        struct as_max_base\n+        {\n+            BOOST_STATIC_ASSERT(std::numeric_limits<typename remove_const<Arg>::type>::is_specialized);\n+\n+            typedef Arg argument_type;\n+            typedef typename remove_const<Arg>::type result_type;\n+\n+            typename remove_const<Arg>::type operator ()(Arg &) const\n+            {\n+                return (std::numeric_limits<typename remove_const<Arg>::type>::max)();\n+            }\n+        };\n+\n+        template<typename Arg, typename EnableIf>\n+        struct as_zero_base\n+        {\n+            typedef Arg argument_type;\n+            typedef typename remove_const<Arg>::type result_type;\n+\n+            typename remove_const<Arg>::type operator ()(Arg &) const\n+            {\n+                return numeric::zero<typename remove_const<Arg>::type>::value;\n+            }\n+        };\n+\n+        template<typename Arg, typename EnableIf>\n+        struct as_one_base\n+        {\n+            typedef Arg argument_type;\n+            typedef typename remove_const<Arg>::type result_type;\n+\n+            typename remove_const<Arg>::type operator ()(Arg &) const\n+            {\n+                return numeric::one<typename remove_const<Arg>::type>::value;\n+            }\n+        };\n+\n+        template<typename To, typename From, typename ToTag, typename FromTag>\n+        struct promote\n+          : promote_base<To, From, void>\n+        {};\n+\n+        template<typename Left, typename Right, typename LeftTag, typename RightTag>\n+        struct min_assign\n+          : min_assign_base<Left, Right, void>\n+        {};\n+\n+        template<typename Left, typename Right, typename LeftTag, typename RightTag>\n+        struct max_assign\n+          : max_assign_base<Left, Right, void>\n+        {};\n+\n+        template<typename Left, typename Right, typename LeftTag, typename RightTag>\n+        struct fdiv\n+          : fdiv_base<Left, Right, void>\n+        {};\n+\n+        /// INTERNAL ONLY \n+        /// For back-compat only. Use fdiv.\n+        template<typename Left, typename Right, typename LeftTag, typename RightTag>\n+        struct average\n+          : fdiv<Left, Right, LeftTag, RightTag>\n+        {};\n+\n+        template<typename Arg, typename Tag>\n+        struct as_min\n+          : as_min_base<Arg, void>\n+        {};\n+\n+        template<typename Arg, typename Tag>\n+        struct as_max\n+          : as_max_base<Arg, void>\n+        {};\n+\n+        template<typename Arg, typename Tag>\n+        struct as_zero\n+          : as_zero_base<Arg, void>\n+        {};\n+\n+        template<typename Arg, typename Tag>\n+        struct as_one\n+          : as_one_base<Arg, void>\n+        {};\n+    }\n+\n+    namespace op\n+    {\n+        template<typename To>\n+        struct promote\n+          : boost::detail::function1<functional::promote<To, _, typename functional::tag<To>::type, functional::tag<_> > >\n+        {};\n+\n+        struct min_assign\n+          : boost::detail::function2<functional::min_assign<_1, _2, functional::tag<_1>, functional::tag<_2> > >\n+        {};\n+\n+        struct max_assign\n+          : boost::detail::function2<functional::max_assign<_1, _2, functional::tag<_1>, functional::tag<_2> > >\n+        {};\n+\n+        struct fdiv\n+          : boost::detail::function2<functional::fdiv<_1, _2, functional::tag<_1>, functional::tag<_2> > >\n+        {};\n+\n+        /// INTERNAL ONLY\n+        struct average\n+          : boost::detail::function2<functional::fdiv<_1, _2, functional::tag<_1>, functional::tag<_2> > >\n+        {};\n+\n+        struct as_min\n+          : boost::detail::function1<functional::as_min<_, functional::tag<_> > >\n+        {};\n+\n+        struct as_max\n+          : boost::detail::function1<functional::as_max<_, functional::tag<_> > >\n+        {};\n+\n+        struct as_zero\n+          : boost::detail::function1<functional::as_zero<_, functional::tag<_> > >\n+        {};\n+\n+        struct as_one\n+          : boost::detail::function1<functional::as_one<_, functional::tag<_> > >\n+        {};\n+    }\n+\n+    namespace\n+    {\n+        op::min_assign const &min_assign = boost::detail::pod_singleton<op::min_assign>::instance;\n+        op::max_assign const &max_assign = boost::detail::pod_singleton<op::max_assign>::instance;\n+        op::fdiv const &fdiv = boost::detail::pod_singleton<op::fdiv>::instance;\n+        op::fdiv const &average = boost::detail::pod_singleton<op::fdiv>::instance; ///< INTERNAL ONLY\n+        op::as_min const &as_min = boost::detail::pod_singleton<op::as_min>::instance;\n+        op::as_max const &as_max = boost::detail::pod_singleton<op::as_max>::instance;\n+        op::as_zero const &as_zero = boost::detail::pod_singleton<op::as_zero>::instance;\n+        op::as_one const &as_one = boost::detail::pod_singleton<op::as_one>::instance;\n+\n+        BOOST_ACCUMULATORS_IGNORE_GLOBAL(min_assign)\n+        BOOST_ACCUMULATORS_IGNORE_GLOBAL(max_assign)\n+        BOOST_ACCUMULATORS_IGNORE_GLOBAL(fdiv)\n+        BOOST_ACCUMULATORS_IGNORE_GLOBAL(average)\n+        BOOST_ACCUMULATORS_IGNORE_GLOBAL(as_min)\n+        BOOST_ACCUMULATORS_IGNORE_GLOBAL(as_max)\n+        BOOST_ACCUMULATORS_IGNORE_GLOBAL(as_zero)\n+        BOOST_ACCUMULATORS_IGNORE_GLOBAL(as_one)\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // promote\n+    template<typename To, typename From>\n+    typename lazy_disable_if<is_const<From>, mpl::if_<is_same<To, From>, To &, To> >::type\n+    promote(From &from)\n+    {\n+        return functional::promote<To, From>()(from);\n+    }\n+\n+    template<typename To, typename From>\n+    typename mpl::if_<is_same<To const, From const>, To const &, To const>::type\n+    promote(From const &from)\n+    {\n+        return functional::promote<To const, From const>()(from);\n+    }\n+\n+    template<typename T>\n+    struct default_\n+    {\n+        typedef default_ type;\n+        typedef T value_type;\n+        static T const value;\n+\n+        operator T const & () const\n+        {\n+            return default_::value;\n+        }\n+    };\n+\n+    template<typename T>\n+    T const default_<T>::value = T();\n+\n+    template<typename T>\n+    struct one\n+    {\n+        typedef one type;\n+        typedef T value_type;\n+        static T const value;\n+\n+        operator T const & () const\n+        {\n+            return one::value;\n+        }\n+    };\n+\n+    template<typename T>\n+    T const one<T>::value = T(1);\n+\n+    template<typename T>\n+    struct zero\n+    {\n+        typedef zero type;\n+        typedef T value_type;\n+        static T const value;\n+\n+        operator T const & () const\n+        {\n+            return zero::value;\n+        }\n+    };\n+\n+    template<typename T>\n+    T const zero<T>::value = T();\n+\n+    template<typename T>\n+    struct one_or_default\n+      : mpl::if_<is_empty<T>, default_<T>, one<T> >::type\n+    {};\n+\n+    template<typename T>\n+    struct zero_or_default\n+      : mpl::if_<is_empty<T>, default_<T>, zero<T> >::type\n+    {};\n+\n+}} // namespace boost::numeric\n+\n+#endif"
      },
      {
        "sha": "ea8c0332400d9088b6fea2383c6189a18c84bbb5",
        "filename": "src/boost/accumulators/numeric/functional/complex.hpp",
        "status": "added",
        "additions": 82,
        "deletions": 0,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/functional/complex.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/functional/complex.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/numeric/functional/complex.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,82 @@\n+///////////////////////////////////////////////////////////////////////////////\n+/// \\file complex.hpp\n+///\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_NUMERIC_FUNCTIONAL_COMPLEX_HPP_EAN_01_17_2006\n+#define BOOST_NUMERIC_FUNCTIONAL_COMPLEX_HPP_EAN_01_17_2006\n+\n+#ifdef BOOST_NUMERIC_FUNCTIONAL_HPP_INCLUDED\n+# error Include this file before boost/accumulators/numeric/functional.hpp\n+#endif\n+\n+#include <complex>\n+#include <boost/mpl/or.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+#include <boost/utility/enable_if.hpp>\n+#include <boost/typeof/std/complex.hpp>\n+#include <boost/accumulators/numeric/functional_fwd.hpp>\n+\n+namespace boost { namespace numeric { namespace operators\n+{\n+    // So that the stats compile when Sample type is std::complex\n+    template<typename T, typename U>\n+    typename\n+        disable_if<\n+            mpl::or_<is_same<T, U>, is_same<std::complex<T>, U> >\n+          , std::complex<T>\n+        >::type\n+    operator *(std::complex<T> ri, U const &u)\n+    {\n+        // BUGBUG promote result to typeof(T()*u) ?\n+        return ri *= static_cast<T>(u);\n+    }\n+\n+    template<typename T, typename U>\n+    typename\n+        disable_if<\n+            mpl::or_<is_same<T, U>, is_same<std::complex<T>, U> >\n+          , std::complex<T>\n+        >::type\n+    operator /(std::complex<T> ri, U const &u)\n+    {\n+        // BUGBUG promote result to typeof(T()*u) ?\n+        return ri /= static_cast<T>(u);\n+    }\n+\n+}}} // namespace boost::numeric::operators\n+\n+namespace boost { namespace numeric\n+{\n+    namespace detail\n+    {\n+        template<typename T>\n+        struct one_complex\n+        {\n+            static std::complex<T> const value;\n+        };\n+\n+        template<typename T>\n+        std::complex<T> const one_complex<T>::value\n+          = std::complex<T>(numeric::one<T>::value, numeric::one<T>::value);\n+    }\n+\n+    /// INTERNAL ONLY\n+    ///\n+    template<typename T>\n+    struct one<std::complex<T> >\n+      : detail::one_complex<T>\n+    {\n+        typedef one type;\n+        typedef std::complex<T> value_type;\n+        operator value_type const & () const\n+        {\n+            return detail::one_complex<T>::value;\n+        }\n+    };\n+\n+}} // namespace boost::numeric\n+\n+#endif"
      },
      {
        "sha": "1996c75845fa0bfe9a47c73351cd83944de314e4",
        "filename": "src/boost/accumulators/numeric/functional/valarray.hpp",
        "status": "added",
        "additions": 362,
        "deletions": 0,
        "changes": 362,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/functional/valarray.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/functional/valarray.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/numeric/functional/valarray.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,362 @@\n+///////////////////////////////////////////////////////////////////////////////\n+/// \\file valarray.hpp\n+///\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_NUMERIC_FUNCTIONAL_VALARRAY_HPP_EAN_12_12_2005\n+#define BOOST_NUMERIC_FUNCTIONAL_VALARRAY_HPP_EAN_12_12_2005\n+\n+#ifdef BOOST_NUMERIC_FUNCTIONAL_HPP_INCLUDED\n+# error Include this file before boost/accumulators/numeric/functional.hpp\n+#endif\n+\n+#include <valarray>\n+#include <functional>\n+#include <boost/assert.hpp>\n+#include <boost/mpl/and.hpp>\n+#include <boost/mpl/not.hpp>\n+#include <boost/mpl/assert.hpp>\n+#include <boost/utility/enable_if.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+#include <boost/type_traits/is_scalar.hpp>\n+#include <boost/type_traits/remove_const.hpp>\n+#include <boost/typeof/std/valarray.hpp>\n+#include <boost/accumulators/numeric/functional_fwd.hpp>\n+\n+namespace boost { namespace numeric\n+{\n+    namespace operators\n+    {\n+        namespace acc_detail\n+        {\n+            template<typename Fun>\n+            struct make_valarray\n+            {\n+                typedef std::valarray<typename Fun::result_type> type;\n+            };\n+        }\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // Handle valarray<Left> / Right where Right is a scalar and Right != Left.\n+        template<typename Left, typename Right>\n+        typename lazy_enable_if<\n+            mpl::and_<is_scalar<Right>, mpl::not_<is_same<Left, Right> > >\n+          , acc_detail::make_valarray<functional::divides<Left, Right> >\n+        >::type\n+        operator /(std::valarray<Left> const &left, Right const &right)\n+        {\n+            typedef typename functional::divides<Left, Right>::result_type value_type;\n+            std::valarray<value_type> result(left.size());\n+            for(std::size_t i = 0, size = result.size(); i != size; ++i)\n+            {\n+                result[i] = numeric::divides(left[i], right);\n+            }\n+            return result;\n+        }\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // Handle valarray<Left> * Right where Right is a scalar and Right != Left.\n+        template<typename Left, typename Right>\n+        typename lazy_enable_if<\n+            mpl::and_<is_scalar<Right>, mpl::not_<is_same<Left, Right> > >\n+          , acc_detail::make_valarray<functional::multiplies<Left, Right> >\n+        >::type\n+        operator *(std::valarray<Left> const &left, Right const &right)\n+        {\n+            typedef typename functional::multiplies<Left, Right>::result_type value_type;\n+            std::valarray<value_type> result(left.size());\n+            for(std::size_t i = 0, size = result.size(); i != size; ++i)\n+            {\n+                result[i] = numeric::multiplies(left[i], right);\n+            }\n+            return result;\n+        }\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // Handle valarray<Left> + valarray<Right> where Right != Left.\n+        template<typename Left, typename Right>\n+        typename lazy_disable_if<\n+            is_same<Left, Right>\n+          , acc_detail::make_valarray<functional::plus<Left, Right> >\n+        >::type\n+        operator +(std::valarray<Left> const &left, std::valarray<Right> const &right)\n+        {\n+            typedef typename functional::plus<Left, Right>::result_type value_type;\n+            std::valarray<value_type> result(left.size());\n+            for(std::size_t i = 0, size = result.size(); i != size; ++i)\n+            {\n+                result[i] = numeric::plus(left[i], right[i]);\n+            }\n+            return result;\n+        }\n+    }\n+\n+    namespace functional\n+    {\n+        struct std_valarray_tag;\n+\n+        template<typename T>\n+        struct tag<std::valarray<T> >\n+        {\n+            typedef std_valarray_tag type;\n+        };\n+\n+    #ifdef __GLIBCXX__\n+        template<typename T, typename U>\n+        struct tag<std::_Expr<T, U> >\n+        {\n+            typedef std_valarray_tag type;\n+        };\n+    #endif\n+\n+        /// INTERNAL ONLY\n+        ///\n+        // This is necessary because the GCC stdlib uses expression templates, and\n+        // typeof(som-valarray-expression) is not an instance of std::valarray\n+    #define BOOST_NUMERIC_FUNCTIONAL_DEFINE_VALARRAY_BIN_OP(Name, Op)                   \\\n+        template<typename Left, typename Right>                                         \\\n+        struct Name<Left, Right, std_valarray_tag, std_valarray_tag>                    \\\n+        {                                                                               \\\n+            typedef Left first_argument_type;                                           \\\n+            typedef Right second_argument_type;                                         \\\n+            typedef typename Left::value_type left_value_type;                          \\\n+            typedef typename Right::value_type right_value_type;                        \\\n+            typedef                                                                     \\\n+                std::valarray<                                                          \\\n+                    typename Name<left_value_type, right_value_type>::result_type       \\\n+                >                                                                       \\\n+            result_type;                                                                \\\n+            result_type                                                                 \\\n+            operator ()(Left &left, Right &right) const                                 \\\n+            {                                                                           \\\n+                return numeric::promote<std::valarray<left_value_type> >(left)          \\\n+                    Op numeric::promote<std::valarray<right_value_type> >(right);       \\\n+            }                                                                           \\\n+        };                                                                              \\\n+        template<typename Left, typename Right>                                         \\\n+        struct Name<Left, Right, std_valarray_tag, void>                                \\\n+        {                                                                               \\\n+            typedef Left first_argument_type;                                           \\\n+            typedef Right second_argument_type;                                         \\\n+            typedef typename Left::value_type left_value_type;                          \\\n+            typedef                                                                     \\\n+                std::valarray<                                                          \\\n+                    typename Name<left_value_type, Right>::result_type                  \\\n+                >                                                                       \\\n+            result_type;                                                                \\\n+            result_type                                                                 \\\n+            operator ()(Left &left, Right &right) const                                 \\\n+            {                                                                           \\\n+                return numeric::promote<std::valarray<left_value_type> >(left) Op right;\\\n+            }                                                                           \\\n+        };                                                                              \\\n+        template<typename Left, typename Right>                                         \\\n+        struct Name<Left, Right, void, std_valarray_tag>                                \\\n+        {                                                                               \\\n+            typedef Left first_argument_type;                                           \\\n+            typedef Right second_argument_type;                                         \\\n+            typedef typename Right::value_type right_value_type;                        \\\n+            typedef                                                                     \\\n+                std::valarray<                                                          \\\n+                    typename Name<Left, right_value_type>::result_type                  \\\n+                >                                                                       \\\n+            result_type;                                                                \\\n+            result_type                                                                 \\\n+            operator ()(Left &left, Right &right) const                                 \\\n+            {                                                                           \\\n+                return left Op numeric::promote<std::valarray<right_value_type> >(right);\\\n+            }                                                                           \\\n+        };\n+\n+        BOOST_NUMERIC_FUNCTIONAL_DEFINE_VALARRAY_BIN_OP(plus, +)\n+        BOOST_NUMERIC_FUNCTIONAL_DEFINE_VALARRAY_BIN_OP(minus, -)\n+        BOOST_NUMERIC_FUNCTIONAL_DEFINE_VALARRAY_BIN_OP(multiplies, *)\n+        BOOST_NUMERIC_FUNCTIONAL_DEFINE_VALARRAY_BIN_OP(divides, /)\n+        BOOST_NUMERIC_FUNCTIONAL_DEFINE_VALARRAY_BIN_OP(modulus, %)\n+\n+    #undef BOOST_NUMERIC_FUNCTIONAL_DEFINE_VALARRAY_BIN_OP\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // element-wise min of std::valarray\n+        template<typename Left, typename Right>\n+        struct min_assign<Left, Right, std_valarray_tag, std_valarray_tag>\n+        {\n+            typedef Left first_argument_type;\n+            typedef Right second_argument_type;\n+            typedef void result_type;\n+\n+            void operator ()(Left &left, Right &right) const\n+            {\n+                BOOST_ASSERT(left.size() == right.size());\n+                for(std::size_t i = 0, size = left.size(); i != size; ++i)\n+                {\n+                    if(numeric::less(right[i], left[i]))\n+                    {\n+                        left[i] = right[i];\n+                    }\n+                }\n+            }\n+        };\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // element-wise max of std::valarray\n+        template<typename Left, typename Right>\n+        struct max_assign<Left, Right, std_valarray_tag, std_valarray_tag>\n+        {\n+            typedef Left first_argument_type;\n+            typedef Right second_argument_type;\n+            typedef void result_type;\n+\n+            void operator ()(Left &left, Right &right) const\n+            {\n+                BOOST_ASSERT(left.size() == right.size());\n+                for(std::size_t i = 0, size = left.size(); i != size; ++i)\n+                {\n+                    if(numeric::greater(right[i], left[i]))\n+                    {\n+                        left[i] = right[i];\n+                    }\n+                }\n+            }\n+        };\n+\n+        // partial specialization of numeric::fdiv<> for std::valarray.\n+        template<typename Left, typename Right, typename RightTag>\n+        struct fdiv<Left, Right, std_valarray_tag, RightTag>\n+          : mpl::if_<\n+                are_integral<typename Left::value_type, Right>\n+              , divides<Left, double const>\n+              , divides<Left, Right>\n+            >::type\n+        {};\n+\n+        // promote\n+        template<typename To, typename From>\n+        struct promote<To, From, std_valarray_tag, std_valarray_tag>\n+        {\n+            typedef From argument_type;\n+            typedef To result_type;\n+\n+            To operator ()(From &arr) const\n+            {\n+                typename remove_const<To>::type res(arr.size());\n+                for(std::size_t i = 0, size = arr.size(); i != size; ++i)\n+                {\n+                    res[i] = numeric::promote<typename To::value_type>(arr[i]);\n+                }\n+                return res;\n+            }\n+        };\n+\n+        template<typename ToFrom>\n+        struct promote<ToFrom, ToFrom, std_valarray_tag, std_valarray_tag>\n+        {\n+            typedef ToFrom argument_type;\n+            typedef ToFrom result_type;\n+\n+            ToFrom &operator ()(ToFrom &tofrom) const\n+            {\n+                return tofrom;\n+            }\n+        };\n+\n+        // for \"promoting\" a std::valarray<bool> to a bool, useful for\n+        // comparing 2 valarrays for equality:\n+        //   if(numeric::promote<bool>(a == b))\n+        template<typename From>\n+        struct promote<bool, From, void, std_valarray_tag>\n+        {\n+            typedef From argument_type;\n+            typedef bool result_type;\n+\n+            bool operator ()(From &arr) const\n+            {\n+                BOOST_MPL_ASSERT((is_same<bool, typename From::value_type>));\n+                for(std::size_t i = 0, size = arr.size(); i != size; ++i)\n+                {\n+                    if(!arr[i])\n+                    {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        };\n+\n+        template<typename From>\n+        struct promote<bool const, From, void, std_valarray_tag>\n+          : promote<bool, From, void, std_valarray_tag>\n+        {};\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // functional::as_min\n+        template<typename T>\n+        struct as_min<T, std_valarray_tag>\n+        {\n+            typedef T argument_type;\n+            typedef typename remove_const<T>::type result_type;\n+\n+            typename remove_const<T>::type operator ()(T &arr) const\n+            {\n+                return 0 == arr.size()\n+                  ? T()\n+                  : T(numeric::as_min(arr[0]), arr.size());\n+            }\n+        };\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // functional::as_max\n+        template<typename T>\n+        struct as_max<T, std_valarray_tag>\n+        {\n+            typedef T argument_type;\n+            typedef typename remove_const<T>::type result_type;\n+\n+            typename remove_const<T>::type operator ()(T &arr) const\n+            {\n+                return 0 == arr.size()\n+                  ? T()\n+                  : T(numeric::as_max(arr[0]), arr.size());\n+            }\n+        };\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // functional::as_zero\n+        template<typename T>\n+        struct as_zero<T, std_valarray_tag>\n+        {\n+            typedef T argument_type;\n+            typedef typename remove_const<T>::type result_type;\n+\n+            typename remove_const<T>::type operator ()(T &arr) const\n+            {\n+                return 0 == arr.size()\n+                  ? T()\n+                  : T(numeric::as_zero(arr[0]), arr.size());\n+            }\n+        };\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // functional::as_one\n+        template<typename T>\n+        struct as_one<T, std_valarray_tag>\n+        {\n+            typedef T argument_type;\n+            typedef typename remove_const<T>::type result_type;\n+\n+            typename remove_const<T>::type operator ()(T &arr) const\n+            {\n+                return 0 == arr.size()\n+                  ? T()\n+                  : T(numeric::as_one(arr[0]), arr.size());\n+            }\n+        };\n+\n+    } // namespace functional\n+\n+}} // namespace boost::numeric\n+\n+#endif\n+"
      },
      {
        "sha": "4c2fbd8ada7e5ddd405fbf1ad3941d1a5b5ec30e",
        "filename": "src/boost/accumulators/numeric/functional/vector.hpp",
        "status": "added",
        "additions": 347,
        "deletions": 0,
        "changes": 347,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/functional/vector.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/functional/vector.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/numeric/functional/vector.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,347 @@\n+///////////////////////////////////////////////////////////////////////////////\n+/// \\file vector.hpp\n+///\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_NUMERIC_FUNCTIONAL_VECTOR_HPP_EAN_12_12_2005\n+#define BOOST_NUMERIC_FUNCTIONAL_VECTOR_HPP_EAN_12_12_2005\n+\n+#ifdef BOOST_NUMERIC_FUNCTIONAL_HPP_INCLUDED\n+# error Include this file before boost/accumulators/numeric/functional.hpp\n+#endif\n+\n+#include <vector>\n+#include <functional>\n+#include <boost/assert.hpp>\n+#include <boost/mpl/and.hpp>\n+#include <boost/mpl/not.hpp>\n+#include <boost/utility/enable_if.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+#include <boost/type_traits/is_scalar.hpp>\n+#include <boost/type_traits/remove_const.hpp>\n+#include <boost/typeof/std/vector.hpp>\n+#include <boost/accumulators/numeric/functional_fwd.hpp>\n+\n+namespace boost { namespace numeric\n+{\n+    namespace operators\n+    {\n+        namespace acc_detail\n+        {\n+            template<typename Fun>\n+            struct make_vector\n+            {\n+                typedef std::vector<typename Fun::result_type> type;\n+            };\n+        }\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // Handle vector<Left> / Right where Right is a scalar.\n+        template<typename Left, typename Right>\n+        typename lazy_enable_if<\n+            is_scalar<Right>\n+          , acc_detail::make_vector<functional::divides<Left, Right> >\n+        >::type\n+        operator /(std::vector<Left> const &left, Right const &right)\n+        {\n+            typedef typename functional::divides<Left, Right>::result_type value_type;\n+            std::vector<value_type> result(left.size());\n+            for(std::size_t i = 0, size = result.size(); i != size; ++i)\n+            {\n+                result[i] = numeric::divides(left[i], right);\n+            }\n+            return result;\n+        }\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // Handle vector<Left> / vector<Right>.\n+        template<typename Left, typename Right>\n+        std::vector<typename functional::divides<Left, Right>::result_type>\n+        operator /(std::vector<Left> const &left, std::vector<Right> const &right)\n+        {\n+            typedef typename functional::divides<Left, Right>::result_type value_type;\n+            std::vector<value_type> result(left.size());\n+            for(std::size_t i = 0, size = result.size(); i != size; ++i)\n+            {\n+                result[i] = numeric::divides(left[i], right[i]);\n+            }\n+            return result;\n+        }\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // Handle vector<Left> * Right where Right is a scalar.\n+        template<typename Left, typename Right>\n+        typename lazy_enable_if<\n+            is_scalar<Right>\n+          , acc_detail::make_vector<functional::multiplies<Left, Right> >\n+        >::type\n+        operator *(std::vector<Left> const &left, Right const &right)\n+        {\n+            typedef typename functional::multiplies<Left, Right>::result_type value_type;\n+            std::vector<value_type> result(left.size());\n+            for(std::size_t i = 0, size = result.size(); i != size; ++i)\n+            {\n+                result[i] = numeric::multiplies(left[i], right);\n+            }\n+            return result;\n+        }\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // Handle Left * vector<Right> where Left is a scalar.\n+        template<typename Left, typename Right>\n+        typename lazy_enable_if<\n+            is_scalar<Left>\n+          , acc_detail::make_vector<functional::multiplies<Left, Right> >\n+        >::type\n+        operator *(Left const &left, std::vector<Right> const &right)\n+        {\n+            typedef typename functional::multiplies<Left, Right>::result_type value_type;\n+            std::vector<value_type> result(right.size());\n+            for(std::size_t i = 0, size = result.size(); i != size; ++i)\n+            {\n+                result[i] = numeric::multiplies(left, right[i]);\n+            }\n+            return result;\n+        }\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // Handle vector<Left> * vector<Right>\n+        template<typename Left, typename Right>\n+        std::vector<typename functional::multiplies<Left, Right>::result_type>\n+        operator *(std::vector<Left> const &left, std::vector<Right> const &right)\n+        {\n+            typedef typename functional::multiplies<Left, Right>::result_type value_type;\n+            std::vector<value_type> result(left.size());\n+            for(std::size_t i = 0, size = result.size(); i != size; ++i)\n+            {\n+                result[i] = numeric::multiplies(left[i], right[i]);\n+            }\n+            return result;\n+        }\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // Handle vector<Left> + vector<Right>\n+        template<typename Left, typename Right>\n+        std::vector<typename functional::plus<Left, Right>::result_type>\n+        operator +(std::vector<Left> const &left, std::vector<Right> const &right)\n+        {\n+            typedef typename functional::plus<Left, Right>::result_type value_type;\n+            std::vector<value_type> result(left.size());\n+            for(std::size_t i = 0, size = result.size(); i != size; ++i)\n+            {\n+                result[i] = numeric::plus(left[i], right[i]);\n+            }\n+            return result;\n+        }\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // Handle vector<Left> - vector<Right>\n+        template<typename Left, typename Right>\n+        std::vector<typename functional::minus<Left, Right>::result_type>\n+        operator -(std::vector<Left> const &left, std::vector<Right> const &right)\n+        {\n+            typedef typename functional::minus<Left, Right>::result_type value_type;\n+            std::vector<value_type> result(left.size());\n+            for(std::size_t i = 0, size = result.size(); i != size; ++i)\n+            {\n+                result[i] = numeric::minus(left[i], right[i]);\n+            }\n+            return result;\n+        }\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // Handle vector<Left> += vector<Left>\n+        template<typename Left>\n+        std::vector<Left> &\n+        operator +=(std::vector<Left> &left, std::vector<Left> const &right)\n+        {\n+            BOOST_ASSERT(left.size() == right.size());\n+            for(std::size_t i = 0, size = left.size(); i != size; ++i)\n+            {\n+                numeric::plus_assign(left[i], right[i]);\n+            }\n+            return left;\n+        }\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // Handle -vector<Arg>\n+        template<typename Arg>\n+        std::vector<typename functional::unary_minus<Arg>::result_type>\n+        operator -(std::vector<Arg> const &arg)\n+        {\n+            typedef typename functional::unary_minus<Arg>::result_type value_type;\n+            std::vector<value_type> result(arg.size());\n+            for(std::size_t i = 0, size = result.size(); i != size; ++i)\n+            {\n+                result[i] = numeric::unary_minus(arg[i]);\n+            }\n+            return result;\n+        }\n+    }\n+\n+    namespace functional\n+    {\n+        struct std_vector_tag;\n+\n+        template<typename T, typename Al>\n+        struct tag<std::vector<T, Al> >\n+        {\n+            typedef std_vector_tag type;\n+        };\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // element-wise min of std::vector\n+        template<typename Left, typename Right>\n+        struct min_assign<Left, Right, std_vector_tag, std_vector_tag>\n+        {\n+            typedef Left first_argument_type;\n+            typedef Right second_argument_type;\n+            typedef void result_type;\n+\n+            void operator ()(Left &left, Right &right) const\n+            {\n+                BOOST_ASSERT(left.size() == right.size());\n+                for(std::size_t i = 0, size = left.size(); i != size; ++i)\n+                {\n+                    if(numeric::less(right[i], left[i]))\n+                    {\n+                        left[i] = right[i];\n+                    }\n+                }\n+            }\n+        };\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // element-wise max of std::vector\n+        template<typename Left, typename Right>\n+        struct max_assign<Left, Right, std_vector_tag, std_vector_tag>\n+        {\n+            typedef Left first_argument_type;\n+            typedef Right second_argument_type;\n+            typedef void result_type;\n+\n+            void operator ()(Left &left, Right &right) const\n+            {\n+                BOOST_ASSERT(left.size() == right.size());\n+                for(std::size_t i = 0, size = left.size(); i != size; ++i)\n+                {\n+                    if(numeric::greater(right[i], left[i]))\n+                    {\n+                        left[i] = right[i];\n+                    }\n+                }\n+            }\n+        };\n+\n+        // partial specialization for std::vector.\n+        template<typename Left, typename Right>\n+        struct fdiv<Left, Right, std_vector_tag, void>\n+          : mpl::if_<\n+                are_integral<typename Left::value_type, Right>\n+              , divides<Left, double const>\n+              , divides<Left, Right>\n+            >::type\n+        {};\n+\n+        // promote\n+        template<typename To, typename From>\n+        struct promote<To, From, std_vector_tag, std_vector_tag>\n+        {\n+            typedef From argument_type;\n+            typedef To result_type;\n+\n+            To operator ()(From &arr) const\n+            {\n+                typename remove_const<To>::type res(arr.size());\n+                for(std::size_t i = 0, size = arr.size(); i != size; ++i)\n+                {\n+                    res[i] = numeric::promote<typename To::value_type>(arr[i]);\n+                }\n+                return res;\n+            }\n+        };\n+\n+        template<typename ToFrom>\n+        struct promote<ToFrom, ToFrom, std_vector_tag, std_vector_tag>\n+        {\n+            typedef ToFrom argument_type;\n+            typedef ToFrom result_type;\n+\n+            ToFrom &operator ()(ToFrom &tofrom) const\n+            {\n+                return tofrom;\n+            }\n+        };\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // functional::as_min\n+        template<typename T>\n+        struct as_min<T, std_vector_tag>\n+        {\n+            typedef T argument_type;\n+            typedef typename remove_const<T>::type result_type;\n+\n+            typename remove_const<T>::type operator ()(T &arr) const\n+            {\n+                return 0 == arr.size()\n+                  ? T()\n+                  : T(arr.size(), numeric::as_min(arr[0]));\n+            }\n+        };\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // functional::as_max\n+        template<typename T>\n+        struct as_max<T, std_vector_tag>\n+        {\n+            typedef T argument_type;\n+            typedef typename remove_const<T>::type result_type;\n+\n+            typename remove_const<T>::type operator ()(T &arr) const\n+            {\n+                return 0 == arr.size()\n+                  ? T()\n+                  : T(arr.size(), numeric::as_max(arr[0]));\n+            }\n+        };\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // functional::as_zero\n+        template<typename T>\n+        struct as_zero<T, std_vector_tag>\n+        {\n+            typedef T argument_type;\n+            typedef typename remove_const<T>::type result_type;\n+\n+            typename remove_const<T>::type operator ()(T &arr) const\n+            {\n+                return 0 == arr.size()\n+                  ? T()\n+                  : T(arr.size(), numeric::as_zero(arr[0]));\n+            }\n+        };\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // functional::as_one\n+        template<typename T>\n+        struct as_one<T, std_vector_tag>\n+        {\n+            typedef T argument_type;\n+            typedef typename remove_const<T>::type result_type;\n+\n+            typename remove_const<T>::type operator ()(T &arr) const\n+            {\n+                return 0 == arr.size()\n+                  ? T()\n+                  : T(arr.size(), numeric::as_one(arr[0]));\n+            }\n+        };\n+\n+    } // namespace functional\n+\n+}} // namespace boost::numeric\n+\n+#endif\n+"
      },
      {
        "sha": "501f654b298100c0cca2d0520fea954b9beb599c",
        "filename": "src/boost/accumulators/numeric/functional_fwd.hpp",
        "status": "added",
        "additions": 221,
        "deletions": 0,
        "changes": 221,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/functional_fwd.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/numeric/functional_fwd.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/numeric/functional_fwd.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,221 @@\n+///////////////////////////////////////////////////////////////////////////////\n+/// \\file functional_fwd.hpp\n+///\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_NUMERIC_FUNCTIONAL_FWD_HPP_EAN_08_12_2005\n+#define BOOST_NUMERIC_FUNCTIONAL_FWD_HPP_EAN_08_12_2005\n+\n+#include <boost/mpl/if.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/utility/enable_if.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+#include <boost/type_traits/is_const.hpp>\n+\n+namespace boost { namespace numeric\n+{\n+    // For using directives -- this namespace may be re-opened elsewhere\n+    namespace operators\n+    {}\n+\n+    namespace op\n+    {\n+        using mpl::_;\n+        using mpl::_1;\n+        using mpl::_2;\n+    }\n+\n+    namespace functional\n+    {\n+        using namespace operators;\n+\n+        template<typename T>\n+        struct tag\n+        {\n+            typedef void type;\n+        };\n+\n+        template<typename T>\n+        struct tag<T const>\n+          : tag<T>\n+        {};\n+\n+        template<typename T>\n+        struct tag<T volatile>\n+          : tag<T>\n+        {};\n+\n+        template<typename T>\n+        struct tag<T const volatile>\n+          : tag<T>\n+        {};\n+\n+        template<typename T>\n+        struct static_;\n+\n+        template<typename A0, typename A1>\n+        struct are_integral;\n+    }\n+\n+    /// INTERNAL ONLY\n+    ///\n+#define BOOST_NUMERIC_FUNCTIONAL_DECLARE_UNARY_OP(Name, Op)                                     \\\n+    namespace functional                                                                        \\\n+    {                                                                                           \\\n+        template<typename Arg, typename EnableIf = void>                                        \\\n+        struct Name ## _base;                                                                   \\\n+        template<typename Arg, typename ArgTag = typename tag<Arg>::type>                       \\\n+        struct Name;                                                                            \\\n+    }                                                                                           \\\n+    namespace op                                                                                \\\n+    {                                                                                           \\\n+        struct Name;                                                                            \\\n+    }                                                                                           \\\n+    namespace                                                                                   \\\n+    {                                                                                           \\\n+        extern op::Name const &Name;                                                            \\\n+    }\n+\n+    /// INTERNAL ONLY\n+    ///\n+#define BOOST_NUMERIC_FUNCTIONAL_DECLARE_BINARY_OP(Name)                                        \\\n+    namespace functional                                                                        \\\n+    {                                                                                           \\\n+        template<typename Left, typename Right, typename EnableIf = void>                       \\\n+        struct result_of_ ## Name;                                                              \\\n+        template<typename Left, typename Right, typename EnableIf = void>                       \\\n+        struct Name ## _base;                                                                   \\\n+        template<                                                                               \\\n+            typename Left                                                                       \\\n+          , typename Right                                                                      \\\n+          , typename LeftTag = typename tag<Left>::type                                         \\\n+          , typename RightTag = typename tag<Right>::type                                       \\\n+        >                                                                                       \\\n+        struct Name;                                                                            \\\n+    }                                                                                           \\\n+    namespace op                                                                                \\\n+    {                                                                                           \\\n+        struct Name;                                                                            \\\n+    }                                                                                           \\\n+    namespace                                                                                   \\\n+    {                                                                                           \\\n+        extern op::Name const &Name;                                                            \\\n+    }\n+\n+    BOOST_NUMERIC_FUNCTIONAL_DECLARE_BINARY_OP(plus)\n+    BOOST_NUMERIC_FUNCTIONAL_DECLARE_BINARY_OP(minus)\n+    BOOST_NUMERIC_FUNCTIONAL_DECLARE_BINARY_OP(multiplies)\n+    BOOST_NUMERIC_FUNCTIONAL_DECLARE_BINARY_OP(divides)\n+    BOOST_NUMERIC_FUNCTIONAL_DECLARE_BINARY_OP(modulus)\n+    BOOST_NUMERIC_FUNCTIONAL_DECLARE_BINARY_OP(greater)\n+    BOOST_NUMERIC_FUNCTIONAL_DECLARE_BINARY_OP(greater_equal)\n+    BOOST_NUMERIC_FUNCTIONAL_DECLARE_BINARY_OP(less)\n+    BOOST_NUMERIC_FUNCTIONAL_DECLARE_BINARY_OP(less_equal)\n+    BOOST_NUMERIC_FUNCTIONAL_DECLARE_BINARY_OP(equal_to)\n+    BOOST_NUMERIC_FUNCTIONAL_DECLARE_BINARY_OP(not_equal_to)\n+\n+    BOOST_NUMERIC_FUNCTIONAL_DECLARE_BINARY_OP(assign)\n+    BOOST_NUMERIC_FUNCTIONAL_DECLARE_BINARY_OP(plus_assign)\n+    BOOST_NUMERIC_FUNCTIONAL_DECLARE_BINARY_OP(minus_assign)\n+    BOOST_NUMERIC_FUNCTIONAL_DECLARE_BINARY_OP(multiplies_assign)\n+    BOOST_NUMERIC_FUNCTIONAL_DECLARE_BINARY_OP(divides_assign)\n+    BOOST_NUMERIC_FUNCTIONAL_DECLARE_BINARY_OP(modulus_assign)\n+\n+    BOOST_NUMERIC_FUNCTIONAL_DECLARE_UNARY_OP(unary_plus, +)\n+    BOOST_NUMERIC_FUNCTIONAL_DECLARE_UNARY_OP(unary_minus, -)\n+    BOOST_NUMERIC_FUNCTIONAL_DECLARE_UNARY_OP(complement, ~)\n+    BOOST_NUMERIC_FUNCTIONAL_DECLARE_UNARY_OP(logical_not, !)\n+\n+#undef BOOST_NUMERIC_FUNCTIONAL_DECLARE_UNARY_OP\n+#undef BOOST_NUMERIC_FUNCTIONAL_DECLARE_BINARY_OP\n+\n+\n+    namespace functional\n+    {\n+        template<typename To, typename From, typename EnableIf = void>\n+        struct promote_base;\n+        template<typename Left, typename Right, typename EnableIf = void>\n+        struct min_assign_base;\n+        template<typename Left, typename Right, typename EnableIf = void>\n+        struct max_assign_base;\n+        template<typename Left, typename Right, typename EnableIf = void>\n+        struct fdiv_base;\n+        template<typename Arg, typename EnableIf = void>\n+        struct as_min_base;\n+        template<typename Arg, typename EnableIf = void>\n+        struct as_max_base;\n+        template<typename Arg, typename EnableIf = void>\n+        struct as_zero_base;\n+        template<typename Arg, typename EnableIf = void>\n+        struct as_one_base;\n+\n+        template<typename To, typename From, typename ToTag = typename tag<To>::type, typename FromTag = typename tag<From>::type>\n+        struct promote;\n+        template<typename Left, typename Right, typename LeftTag = typename tag<Left>::type, typename RightTag = typename tag<Right>::type>\n+        struct min_assign;\n+        template<typename Left, typename Right, typename LeftTag = typename tag<Left>::type, typename RightTag = typename tag<Right>::type>\n+        struct max_assign;\n+        template<typename Left, typename Right, typename LeftTag = typename tag<Left>::type, typename RightTag = typename tag<Right>::type>\n+        struct fdiv;\n+        template<typename Arg, typename Tag = typename tag<Arg>::type>\n+        struct as_min;\n+        template<typename Arg, typename Tag = typename tag<Arg>::type>\n+        struct as_max;\n+        template<typename Arg, typename Tag = typename tag<Arg>::type>\n+        struct as_zero;\n+        template<typename Arg, typename Tag = typename tag<Arg>::type>\n+        struct as_one;\n+    }\n+\n+    namespace op\n+    {\n+        template<typename To>\n+        struct promote;\n+        struct min_assign;\n+        struct max_assign;\n+        struct fdiv;\n+        struct as_min;\n+        struct as_max;\n+        struct as_zero;\n+        struct as_one;\n+    }\n+\n+    namespace\n+    {\n+        extern op::min_assign const &min_assign;\n+        extern op::max_assign const &max_assign;\n+        extern op::fdiv const &fdiv;\n+        extern op::as_min const &as_min;\n+        extern op::as_max const &as_max;\n+        extern op::as_zero const &as_zero;\n+        extern op::as_one const &as_one;\n+    }\n+\n+    template<typename To, typename From>\n+    typename lazy_disable_if<is_const<From>, mpl::if_<is_same<To, From>, To &, To> >::type\n+    promote(From &from);\n+\n+    template<typename To, typename From>\n+    typename mpl::if_<is_same<To const, From const>, To const &, To const>::type\n+    promote(From const &from);\n+\n+    template<typename T>\n+    struct default_;\n+\n+    template<typename T>\n+    struct one;\n+\n+    template<typename T>\n+    struct zero;\n+\n+    template<typename T>\n+    struct one_or_default;\n+\n+    template<typename T>\n+    struct zero_or_default;\n+\n+}} // namespace boost::numeric\n+\n+#endif"
      },
      {
        "sha": "01786079a8f647042bc49a7292fe853e2c9d7bed",
        "filename": "src/boost/accumulators/statistics.hpp",
        "status": "added",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,61 @@\n+///////////////////////////////////////////////////////////////////////////////\n+/// \\file statistics.hpp\n+/// Includes all of the Statistical Accumulators Library\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_HPP_EAN_01_17_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_HPP_EAN_01_17_2006\n+\n+#include <boost/accumulators/statistics/count.hpp>\n+#include <boost/accumulators/statistics/covariance.hpp>\n+#include <boost/accumulators/statistics/density.hpp>\n+#include <boost/accumulators/statistics/error_of.hpp>\n+#include <boost/accumulators/statistics/error_of_mean.hpp>\n+#include <boost/accumulators/statistics/extended_p_square.hpp>\n+#include <boost/accumulators/statistics/extended_p_square_quantile.hpp>\n+#include <boost/accumulators/statistics/kurtosis.hpp>\n+#include <boost/accumulators/statistics/max.hpp>\n+#include <boost/accumulators/statistics/mean.hpp>\n+#include <boost/accumulators/statistics/median.hpp>\n+#include <boost/accumulators/statistics/min.hpp>\n+#include <boost/accumulators/statistics/moment.hpp>\n+#include <boost/accumulators/statistics/peaks_over_threshold.hpp>\n+#include <boost/accumulators/statistics/pot_tail_mean.hpp>\n+#include <boost/accumulators/statistics/pot_quantile.hpp>\n+#include <boost/accumulators/statistics/p_square_cumul_dist.hpp>\n+#include <boost/accumulators/statistics/p_square_quantile.hpp>\n+#include <boost/accumulators/statistics/skewness.hpp>\n+#include <boost/accumulators/statistics/stats.hpp>\n+#include <boost/accumulators/statistics/sum.hpp>\n+#include <boost/accumulators/statistics/sum_kahan.hpp>\n+#include <boost/accumulators/statistics/tail.hpp>\n+#include <boost/accumulators/statistics/tail_quantile.hpp>\n+#include <boost/accumulators/statistics/tail_mean.hpp>\n+#include <boost/accumulators/statistics/tail_variate.hpp>\n+#include <boost/accumulators/statistics/tail_variate_means.hpp>\n+#include <boost/accumulators/statistics/variance.hpp>\n+#include <boost/accumulators/statistics/weighted_covariance.hpp>\n+#include <boost/accumulators/statistics/weighted_density.hpp>\n+#include <boost/accumulators/statistics/weighted_kurtosis.hpp>\n+#include <boost/accumulators/statistics/weighted_extended_p_square.hpp>\n+#include <boost/accumulators/statistics/weighted_mean.hpp>\n+#include <boost/accumulators/statistics/weighted_median.hpp>\n+#include <boost/accumulators/statistics/weighted_moment.hpp>\n+#include <boost/accumulators/statistics/weighted_peaks_over_threshold.hpp>\n+#include <boost/accumulators/statistics/weighted_p_square_cumul_dist.hpp>\n+#include <boost/accumulators/statistics/weighted_p_square_quantile.hpp>\n+#include <boost/accumulators/statistics/weighted_skewness.hpp>\n+#include <boost/accumulators/statistics/weighted_sum.hpp>\n+#include <boost/accumulators/statistics/weighted_sum_kahan.hpp>\n+#include <boost/accumulators/statistics/weighted_tail_quantile.hpp>\n+#include <boost/accumulators/statistics/weighted_tail_mean.hpp>\n+#include <boost/accumulators/statistics/weighted_tail_variate_means.hpp>\n+#include <boost/accumulators/statistics/weighted_variance.hpp>\n+#include <boost/accumulators/statistics/with_error.hpp>\n+#include <boost/accumulators/statistics/parameters/quantile_probability.hpp>\n+#include <boost/accumulators/statistics/variates/covariate.hpp>\n+\n+#endif"
      },
      {
        "sha": "b83435a30ec2b052ba195b241bb212e8103282c3",
        "filename": "src/boost/accumulators/statistics/count.hpp",
        "status": "added",
        "additions": 87,
        "deletions": 0,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/count.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/count.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/count.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,87 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// count.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_COUNT_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_COUNT_HPP_EAN_28_10_2005\n+\n+#include <boost/mpl/always.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // count_impl\n+    struct count_impl\n+      : accumulator_base\n+    {\n+        // for boost::result_of\n+        typedef std::size_t result_type;\n+\n+        count_impl(dont_care)\n+          : cnt(0)\n+        {\n+        }\n+\n+        void operator ()(dont_care)\n+        {\n+            ++this->cnt;\n+        }\n+\n+        result_type result(dont_care) const\n+        {\n+            return this->cnt;\n+        }\n+\n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & cnt;\n+        }\n+\n+    private:\n+        std::size_t cnt;\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::count\n+//\n+namespace tag\n+{\n+    struct count\n+      : depends_on<>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef mpl::always<accumulators::impl::count_impl> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::count\n+//\n+namespace extract\n+{\n+    extractor<tag::count> const count = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(count)\n+}\n+\n+using extract::count;\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "d80a85eda774dfc3f6deb8d7b80bd00d76a8b7cb",
        "filename": "src/boost/accumulators/statistics/covariance.hpp",
        "status": "added",
        "additions": 219,
        "deletions": 0,
        "changes": 219,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/covariance.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/covariance.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/covariance.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,219 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// covariance.hpp\n+//\n+//  Copyright 2006 Daniel Egloff, Olivier Gygi. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_COVARIANCE_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_COVARIANCE_HPP_DE_01_01_2006\n+\n+#include <vector>\n+#include <limits>\n+#include <numeric>\n+#include <functional>\n+#include <complex>\n+#include <boost/mpl/assert.hpp>\n+#include <boost/mpl/bool.hpp>\n+#include <boost/range.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/numeric/ublas/io.hpp>\n+#include <boost/numeric/ublas/matrix.hpp>\n+#include <boost/type_traits/is_scalar.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+#include <boost/accumulators/statistics/mean.hpp>\n+\n+namespace boost { namespace numeric\n+{\n+    namespace functional\n+    {\n+        struct std_vector_tag;\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // functional::outer_product\n+        template<typename Left, typename Right, typename EnableIf = void>\n+        struct outer_product_base\n+          : functional::multiplies<Left, Right>\n+        {};\n+\n+        template<typename Left, typename Right, typename LeftTag = typename tag<Left>::type, typename RightTag = typename tag<Right>::type>\n+        struct outer_product\n+          : outer_product_base<Left, Right, void>\n+        {};\n+\n+        template<typename Left, typename Right>\n+        struct outer_product<Left, Right, std_vector_tag, std_vector_tag>\n+        {\n+            typedef Left first_argument_type;\n+            typedef Right second_argument_type;\n+            typedef\n+                ublas::matrix<\n+                    typename functional::multiplies<\n+                        typename Left::value_type\n+                      , typename Right::value_type\n+                    >::result_type\n+                >\n+            result_type;\n+\n+            result_type\n+            operator ()(Left & left, Right & right) const\n+            {\n+                std::size_t left_size = left.size();\n+                std::size_t right_size = right.size();\n+                result_type result(left_size, right_size);\n+                for (std::size_t i = 0; i < left_size; ++i)\n+                    for (std::size_t j = 0; j < right_size; ++j)\n+                        result(i,j) = numeric::multiplies(left[i], right[j]);\n+                return result;\n+            }\n+        };\n+    }\n+\n+    namespace op\n+    {\n+        struct outer_product\n+          : boost::detail::function2<functional::outer_product<_1, _2, functional::tag<_1>, functional::tag<_2> > >\n+        {};\n+    }\n+\n+    namespace\n+    {\n+        op::outer_product const &outer_product = boost::detail::pod_singleton<op::outer_product>::instance;\n+    }\n+\n+}}\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // covariance_impl\n+    //\n+    /**\n+        @brief Covariance Estimator\n+\n+        An iterative Monte Carlo estimator for the covariance \\f$\\mathrm{Cov}(X,X')\\f$, where \\f$X\\f$ is a sample\n+        and \\f$X'\\f$ is a variate, is given by:\n+\n+        \\f[\n+            \\hat{c}_n = \\frac{n-1}{n} \\hat{c}_{n-1} + \\frac{1}{n-1}(X_n - \\hat{\\mu}_n)(X_n' - \\hat{\\mu}_n'),\\quad n\\ge2,\\quad\\hat{c}_1 = 0,\n+        \\f]\n+\n+        \\f$\\hat{\\mu}_n\\f$ and \\f$\\hat{\\mu}_n'\\f$ being the means of the samples and variates.\n+    */\n+    template<typename Sample, typename VariateType, typename VariateTag>\n+    struct covariance_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type sample_type;\n+        typedef typename numeric::functional::fdiv<VariateType, std::size_t>::result_type variate_type;\n+        // for boost::result_of\n+        typedef typename numeric::functional::outer_product<sample_type, variate_type>::result_type result_type;\n+\n+        template<typename Args>\n+        covariance_impl(Args const &args)\n+          : cov_(\n+                numeric::outer_product(\n+                    numeric::fdiv(args[sample | Sample()], (std::size_t)1)\n+                  , numeric::fdiv(args[parameter::keyword<VariateTag>::get() | VariateType()], (std::size_t)1)\n+                )\n+            )\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            std::size_t cnt = count(args);\n+\n+            if (cnt > 1)\n+            {\n+                extractor<tag::mean_of_variates<VariateType, VariateTag> > const some_mean_of_variates = {};\n+\n+                this->cov_ = this->cov_*(cnt-1.)/cnt\n+                           + numeric::outer_product(\n+                                 some_mean_of_variates(args) - args[parameter::keyword<VariateTag>::get()]\n+                               , mean(args) - args[sample]\n+                             ) / (cnt-1.);\n+            }\n+        }\n+\n+        result_type result(dont_care) const\n+        {\n+            return this->cov_;\n+        }\n+\n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & cov_;\n+        }\n+\n+    private:\n+        result_type cov_;\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::covariance\n+//\n+namespace tag\n+{\n+    template<typename VariateType, typename VariateTag>\n+    struct covariance\n+      : depends_on<count, mean, mean_of_variates<VariateType, VariateTag> >\n+    {\n+        typedef accumulators::impl::covariance_impl<mpl::_1, VariateType, VariateTag> impl;\n+    };\n+\n+    struct abstract_covariance\n+      : depends_on<>\n+    {\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::covariance\n+//\n+namespace extract\n+{\n+    extractor<tag::abstract_covariance> const covariance = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(covariance)\n+}\n+\n+using extract::covariance;\n+\n+template<typename VariateType, typename VariateTag>\n+struct feature_of<tag::covariance<VariateType, VariateTag> >\n+  : feature_of<tag::abstract_covariance>\n+{\n+};\n+\n+// So that covariance can be automatically substituted with\n+// weighted_covariance when the weight parameter is non-void.\n+template<typename VariateType, typename VariateTag>\n+struct as_weighted_feature<tag::covariance<VariateType, VariateTag> >\n+{\n+    typedef tag::weighted_covariance<VariateType, VariateTag> type;\n+};\n+\n+template<typename VariateType, typename VariateTag>\n+struct feature_of<tag::weighted_covariance<VariateType, VariateTag> >\n+  : feature_of<tag::covariance<VariateType, VariateTag> >\n+{};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "32b48060fcb7f23e9b58cd5caa078ab53694fdcc",
        "filename": "src/boost/accumulators/statistics/density.hpp",
        "status": "added",
        "additions": 266,
        "deletions": 0,
        "changes": 266,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/density.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/density.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/density.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,266 @@\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// density.hpp\n+//\n+//  Copyright 2006 Daniel Egloff, Olivier Gygi. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_DENSITY_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_DENSITY_HPP_DE_01_01_2006\n+\n+#include <vector>\n+#include <limits>\n+#include <functional>\n+#include <boost/range.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/accumulators_fwd.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+#include <boost/accumulators/statistics/max.hpp>\n+#include <boost/accumulators/statistics/min.hpp>\n+#include <boost/serialization/vector.hpp>\n+#include <boost/serialization/utility.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// cache_size and num_bins named parameters\n+//\n+BOOST_PARAMETER_NESTED_KEYWORD(tag, density_cache_size, cache_size)\n+BOOST_PARAMETER_NESTED_KEYWORD(tag, density_num_bins, num_bins)\n+\n+BOOST_ACCUMULATORS_IGNORE_GLOBAL(density_cache_size)\n+BOOST_ACCUMULATORS_IGNORE_GLOBAL(density_num_bins)\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // density_impl\n+    //  density histogram\n+    /**\n+        @brief Histogram density estimator\n+\n+        The histogram density estimator returns a histogram of the sample distribution. The positions and sizes of the bins\n+        are determined using a specifiable number of cached samples (cache_size). The range between the minimum and the\n+        maximum of the cached samples is subdivided into a specifiable number of bins (num_bins) of same size. Additionally,\n+        an under- and an overflow bin is added to capture future under- and overflow samples. Once the bins are determined,\n+        the cached samples and all subsequent samples are added to the correct bins. At the end, a range of std::pair is\n+        return, where each pair contains the position of the bin (lower bound) and the samples count (normalized with the\n+        total number of samples).\n+\n+        @param  density_cache_size Number of first samples used to determine min and max.\n+        @param  density_num_bins Number of bins (two additional bins collect under- and overflow samples).\n+    */\n+    template<typename Sample>\n+    struct density_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type float_type;\n+        typedef std::vector<std::pair<float_type, float_type> > histogram_type;\n+        typedef std::vector<float_type> array_type;\n+        // for boost::result_of\n+        typedef iterator_range<typename histogram_type::iterator> result_type;\n+\n+        template<typename Args>\n+        density_impl(Args const &args)\n+            : cache_size(args[density_cache_size])\n+            , cache(cache_size)\n+            , num_bins(args[density_num_bins])\n+            , samples_in_bin(num_bins + 2, 0.)\n+            , bin_positions(num_bins + 2)\n+            , histogram(\n+                num_bins + 2\n+              , std::make_pair(\n+                    numeric::fdiv(args[sample | Sample()],(std::size_t)1)\n+                  , numeric::fdiv(args[sample | Sample()],(std::size_t)1)\n+                )\n+              )\n+            , is_dirty(true)\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            this->is_dirty = true;\n+\n+            std::size_t cnt = count(args);\n+\n+            // Fill up cache with cache_size first samples\n+            if (cnt <= this->cache_size)\n+            {\n+                this->cache[cnt - 1] = args[sample];\n+            }\n+\n+            // Once cache_size samples have been accumulated, create num_bins bins of same size between\n+            // the minimum and maximum of the cached samples as well as under and overflow bins.\n+            // Store their lower bounds (bin_positions) and fill the bins with the cached samples (samples_in_bin).\n+            if (cnt == this->cache_size)\n+            {\n+                float_type minimum = numeric::fdiv((min)(args), (std::size_t)1);\n+                float_type maximum = numeric::fdiv((max)(args), (std::size_t)1);\n+                float_type bin_size = numeric::fdiv(maximum - minimum, this->num_bins );\n+\n+                // determine bin positions (their lower bounds)\n+                for (std::size_t i = 0; i < this->num_bins + 2; ++i)\n+                {\n+                    this->bin_positions[i] = minimum + (i - 1.) * bin_size;\n+                }\n+\n+                for (typename array_type::const_iterator iter = this->cache.begin(); iter != this->cache.end(); ++iter)\n+                {\n+                    if (*iter < this->bin_positions[1])\n+                    {\n+                        ++(this->samples_in_bin[0]);\n+                    }\n+                    else if (*iter >= this->bin_positions[this->num_bins + 1])\n+                    {\n+                        ++(this->samples_in_bin[this->num_bins + 1]);\n+                    }\n+                    else\n+                    {\n+                        typename array_type::iterator it = std::upper_bound(\n+                            this->bin_positions.begin()\n+                          , this->bin_positions.end()\n+                          , *iter\n+                        );\n+\n+                        std::size_t d = std::distance(this->bin_positions.begin(), it);\n+                        ++(this->samples_in_bin[d - 1]);\n+                    }\n+                }\n+            }\n+            // Add each subsequent sample to the correct bin\n+            else if (cnt > this->cache_size)\n+            {\n+                if (args[sample] < this->bin_positions[1])\n+                {\n+                    ++(this->samples_in_bin[0]);\n+                }\n+                else if (args[sample] >= this->bin_positions[this->num_bins + 1])\n+                {\n+                    ++(this->samples_in_bin[this->num_bins + 1]);\n+                }\n+                else\n+                {\n+                    typename array_type::iterator it = std::upper_bound(\n+                        this->bin_positions.begin()\n+                      , this->bin_positions.end()\n+                      , args[sample]\n+                    );\n+\n+                    std::size_t d = std::distance(this->bin_positions.begin(), it);\n+                    ++(this->samples_in_bin[d - 1]);\n+                }\n+            }\n+        }\n+\n+        /**\n+            @pre The number of samples must meet or exceed the cache size\n+        */\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            if (this->is_dirty)\n+            {\n+                this->is_dirty = false;\n+\n+                // creates a vector of std::pair where each pair i holds\n+                // the values bin_positions[i] (x-axis of histogram) and\n+                // samples_in_bin[i] / cnt (y-axis of histogram).\n+\n+                for (std::size_t i = 0; i < this->num_bins + 2; ++i)\n+                {\n+                    this->histogram[i] = std::make_pair(this->bin_positions[i], numeric::fdiv(this->samples_in_bin[i], count(args)));\n+                }\n+            }\n+            // returns a range of pairs\n+            return make_iterator_range(this->histogram);\n+        }\n+\n+        // make this accumulator serializeable\n+        // TODO split to save/load and check on parameters provided in ctor\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        {\n+            ar & cache_size;\n+            ar & cache;\n+            ar & num_bins;\n+            ar & samples_in_bin;\n+            ar & bin_positions;\n+            ar & histogram;\n+            ar & is_dirty; \n+        }\n+\n+    private:\n+        std::size_t            cache_size;      // number of cached samples\n+        array_type             cache;           // cache to store the first cache_size samples\n+        std::size_t            num_bins;        // number of bins\n+        array_type             samples_in_bin;  // number of samples in each bin\n+        array_type             bin_positions;   // lower bounds of bins\n+        mutable histogram_type histogram;       // histogram\n+        mutable bool is_dirty;\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::density\n+//\n+namespace tag\n+{\n+    struct density\n+      : depends_on<count, min, max>\n+      , density_cache_size\n+      , density_num_bins\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::density_impl<mpl::_1> impl;\n+\n+        #ifdef BOOST_ACCUMULATORS_DOXYGEN_INVOKED\n+        /// tag::density::cache_size named parameter\n+        /// tag::density::num_bins named parameter\n+        static boost::parameter::keyword<density_cache_size> const cache_size;\n+        static boost::parameter::keyword<density_num_bins> const num_bins;\n+        #endif\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::density\n+//\n+namespace extract\n+{\n+    extractor<tag::density> const density = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(density)\n+}\n+\n+using extract::density;\n+\n+// So that density can be automatically substituted\n+// with weighted_density when the weight parameter is non-void.\n+template<>\n+struct as_weighted_feature<tag::density>\n+{\n+    typedef tag::weighted_density type;\n+};\n+\n+template<>\n+struct feature_of<tag::weighted_density>\n+  : feature_of<tag::density>\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "a29da02f579c5bf337a76d9646543b8259dd7b37",
        "filename": "src/boost/accumulators/statistics/error_of.hpp",
        "status": "added",
        "additions": 99,
        "deletions": 0,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/error_of.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/error_of.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/error_of.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,99 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// error_of.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_ERROR_OF_HPP_EAN_29_11_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_ERROR_OF_HPP_EAN_29_11_2005\n+\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    /// INTERNAL ONLY\n+    ///\n+    template<typename Feature>\n+    struct this_feature_has_no_error_calculation\n+      : mpl::false_\n+    {\n+    };\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // error_of_impl\n+    /// INTERNAL ONLY\n+    ///\n+    template<typename Sample, typename Feature>\n+    struct error_of_impl\n+      : accumulator_base\n+    {\n+        // TODO: specialize this on the specific features that have errors we're\n+        // interested in.\n+        BOOST_MPL_ASSERT((this_feature_has_no_error_calculation<Feature>));\n+\n+        // for boost::result_of\n+        typedef int result_type;\n+\n+        error_of_impl(dont_care)\n+        {\n+        }\n+\n+        result_type result(dont_care) const\n+        {\n+            return 0;\n+        }\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::error_of\n+//\n+namespace tag\n+{\n+    template<typename Feature>\n+    struct error_of\n+      : depends_on<Feature>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::error_of_impl<mpl::_1, Feature> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::error_of\n+//\n+namespace extract\n+{\n+    BOOST_ACCUMULATORS_DEFINE_EXTRACTOR(tag, error_of, (typename))\n+}\n+\n+using extract::error_of;\n+\n+// make tag::error_of<tag::feature(modifier)> work\n+template<typename Feature>\n+struct as_feature<tag::error_of<Feature> >\n+{\n+    typedef tag::error_of<typename as_feature<Feature>::type> type;\n+};\n+\n+// make error_of<tag::mean> work with non-void weights (should become\n+// error_of<tag::weighted_mean>\n+template<typename Feature>\n+struct as_weighted_feature<tag::error_of<Feature> >\n+{\n+    typedef tag::error_of<typename as_weighted_feature<Feature>::type> type;\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "7cd923d5f4a34e82683b82132dcdf6d22baae3cc",
        "filename": "src/boost/accumulators/statistics/error_of_mean.hpp",
        "status": "added",
        "additions": 73,
        "deletions": 0,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/error_of_mean.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/error_of_mean.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/error_of_mean.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,73 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// error_of.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_ERROR_OF_MEAN_HPP_EAN_27_03_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_ERROR_OF_MEAN_HPP_EAN_27_03_2006\n+\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/error_of.hpp>\n+#include <boost/accumulators/statistics/variance.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // error_of_mean_impl\n+    template<typename Sample, typename Variance>\n+    struct error_of_mean_impl\n+      : accumulator_base\n+    {\n+        // for boost::result_of\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type result_type;\n+\n+        error_of_mean_impl(dont_care) {}\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            using namespace std;\n+            extractor<Variance> const variance = {};\n+            return sqrt(numeric::fdiv(variance(args), count(args) - 1));\n+        }\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::error_of\n+//\n+namespace tag\n+{\n+    template<>\n+    struct error_of<mean>\n+      : depends_on<lazy_variance, count>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::error_of_mean_impl<mpl::_1, lazy_variance> impl;\n+    };\n+\n+    template<>\n+    struct error_of<immediate_mean>\n+      : depends_on<variance, count>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::error_of_mean_impl<mpl::_1, variance> impl;\n+    };\n+}\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "6990050e4fa894e67a00c7f9e128fea07bea810c",
        "filename": "src/boost/accumulators/statistics/extended_p_square.hpp",
        "status": "added",
        "additions": 309,
        "deletions": 0,
        "changes": 309,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/extended_p_square.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/extended_p_square.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/extended_p_square.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,309 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// extended_p_square.hpp\n+//\n+//  Copyright 2005 Daniel Egloff. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_EXTENDED_SINGLE_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_EXTENDED_SINGLE_HPP_DE_01_01_2006\n+\n+#include <vector>\n+#include <functional>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+#include <boost/range/iterator_range.hpp>\n+#include <boost/iterator/transform_iterator.hpp>\n+#include <boost/iterator/counting_iterator.hpp>\n+#include <boost/iterator/permutation_iterator.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/accumulators_fwd.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+#include <boost/accumulators/statistics/times2_iterator.hpp>\n+#include <boost/serialization/vector.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+///////////////////////////////////////////////////////////////////////////////\n+// probabilities named parameter\n+//\n+BOOST_PARAMETER_NESTED_KEYWORD(tag, extended_p_square_probabilities, probabilities)\n+\n+BOOST_ACCUMULATORS_IGNORE_GLOBAL(extended_p_square_probabilities)\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // extended_p_square_impl\n+    //  multiple quantile estimation\n+    /**\n+        @brief Multiple quantile estimation with the extended \\f$P^2\\f$ algorithm\n+\n+        Extended \\f$P^2\\f$ algorithm for estimation of several quantiles without storing samples.\n+        Assume that \\f$m\\f$ quantiles \\f$\\xi_{p_1}, \\ldots, \\xi_{p_m}\\f$ are to be estimated.\n+        Instead of storing the whole sample cumulative distribution, the algorithm maintains only\n+        \\f$m+2\\f$ principal markers and \\f$m+1\\f$ middle markers, whose positions are updated\n+        with each sample and whose heights are adjusted (if necessary) using a piecewise-parablic\n+        formula. The heights of these central markers are the current estimates of the quantiles\n+        and returned as an iterator range.\n+\n+        For further details, see\n+\n+        K. E. E. Raatikainen, Simultaneous estimation of several quantiles, Simulation, Volume 49,\n+        Number 4 (October), 1986, p. 159-164.\n+\n+        The extended \\f$ P^2 \\f$ algorithm generalizes the \\f$ P^2 \\f$ algorithm of\n+\n+        R. Jain and I. Chlamtac, The P^2 algorithm for dynamic calculation of quantiles and\n+        histograms without storing observations, Communications of the ACM,\n+        Volume 28 (October), Number 10, 1985, p. 1076-1085.\n+\n+        @param extended_p_square_probabilities A vector of quantile probabilities.\n+    */\n+    template<typename Sample>\n+    struct extended_p_square_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type float_type;\n+        typedef std::vector<float_type> array_type;\n+        // for boost::result_of\n+        typedef iterator_range<\n+            detail::lvalue_index_iterator<\n+                permutation_iterator<\n+                    typename array_type::const_iterator\n+                  , detail::times2_iterator\n+                >\n+            >\n+        > result_type;\n+\n+        template<typename Args>\n+        extended_p_square_impl(Args const &args)\n+          : probabilities(\n+                boost::begin(args[extended_p_square_probabilities])\n+              , boost::end(args[extended_p_square_probabilities])\n+            )\n+          , heights(2 * probabilities.size() + 3)\n+          , actual_positions(heights.size())\n+          , desired_positions(heights.size())\n+          , positions_increments(heights.size())\n+        {\n+            std::size_t num_quantiles = this->probabilities.size();\n+            std::size_t num_markers = this->heights.size();\n+\n+            for(std::size_t i = 0; i < num_markers; ++i)\n+            {\n+                this->actual_positions[i] = i + 1;\n+            }\n+\n+            this->positions_increments[0] = 0.;\n+            this->positions_increments[num_markers - 1] = 1.;\n+\n+            for(std::size_t i = 0; i < num_quantiles; ++i)\n+            {\n+                this->positions_increments[2 * i + 2] = probabilities[i];\n+            }\n+\n+            for(std::size_t i = 0; i <= num_quantiles; ++i)\n+            {\n+                this->positions_increments[2 * i + 1] =\n+                    0.5 * (this->positions_increments[2 * i] + this->positions_increments[2 * i + 2]);\n+            }\n+\n+            for(std::size_t i = 0; i < num_markers; ++i)\n+            {\n+                this->desired_positions[i] = 1. + 2. * (num_quantiles + 1.) * this->positions_increments[i];\n+            }\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            std::size_t cnt = count(args);\n+\n+            // m+2 principal markers and m+1 middle markers\n+            std::size_t num_markers = 2 * this->probabilities.size() + 3;\n+\n+            // first accumulate num_markers samples\n+            if(cnt <= num_markers)\n+            {\n+                this->heights[cnt - 1] = args[sample];\n+\n+                // complete the initialization of heights by sorting\n+                if(cnt == num_markers)\n+                {\n+                    std::sort(this->heights.begin(), this->heights.end());\n+                }\n+            }\n+            else\n+            {\n+                std::size_t sample_cell = 1;\n+\n+                // find cell k = sample_cell such that heights[k-1] <= sample < heights[k]\n+                if(args[sample] < this->heights[0])\n+                {\n+                    this->heights[0] = args[sample];\n+                    sample_cell = 1;\n+                }\n+                else if(args[sample] >= this->heights[num_markers - 1])\n+                {\n+                    this->heights[num_markers - 1] = args[sample];\n+                    sample_cell = num_markers - 1;\n+                }\n+                else\n+                {\n+                    typedef typename array_type::iterator iterator;\n+                    iterator it = std::upper_bound(\n+                        this->heights.begin()\n+                      , this->heights.end()\n+                      , args[sample]\n+                    );\n+\n+                    sample_cell = std::distance(this->heights.begin(), it);\n+                }\n+\n+                // update actual positions of all markers above sample_cell index\n+                for(std::size_t i = sample_cell; i < num_markers; ++i)\n+                {\n+                    ++this->actual_positions[i];\n+                }\n+\n+                // update desired positions of all markers\n+                for(std::size_t i = 0; i < num_markers; ++i)\n+                {\n+                    this->desired_positions[i] += this->positions_increments[i];\n+                }\n+\n+                // adjust heights and actual positions of markers 1 to num_markers-2 if necessary\n+                for(std::size_t i = 1; i <= num_markers - 2; ++i)\n+                {\n+                    // offset to desired position\n+                    float_type d = this->desired_positions[i] - this->actual_positions[i];\n+\n+                    // offset to next position\n+                    float_type dp = this->actual_positions[i+1] - this->actual_positions[i];\n+\n+                    // offset to previous position\n+                    float_type dm = this->actual_positions[i-1] - this->actual_positions[i];\n+\n+                    // height ds\n+                    float_type hp = (this->heights[i+1] - this->heights[i]) / dp;\n+                    float_type hm = (this->heights[i-1] - this->heights[i]) / dm;\n+\n+                    if((d >= 1 && dp > 1) || (d <= -1 && dm < -1))\n+                    {\n+                        short sign_d = static_cast<short>(d / std::abs(d));\n+\n+                        float_type h = this->heights[i] + sign_d / (dp - dm) * ((sign_d - dm)*hp\n+                                     + (dp - sign_d) * hm);\n+\n+                        // try adjusting heights[i] using p-squared formula\n+                        if(this->heights[i - 1] < h && h < this->heights[i + 1])\n+                        {\n+                            this->heights[i] = h;\n+                        }\n+                        else\n+                        {\n+                            // use linear formula\n+                            if(d > 0)\n+                            {\n+                                this->heights[i] += hp;\n+                            }\n+                            if(d < 0)\n+                            {\n+                                this->heights[i] -= hm;\n+                            }\n+                        }\n+                        this->actual_positions[i] += sign_d;\n+                    }\n+                }\n+            }\n+        }\n+\n+        result_type result(dont_care) const\n+        {\n+            // for i in [1,probabilities.size()], return heights[i * 2]\n+            detail::times2_iterator idx_begin = detail::make_times2_iterator(1);\n+            detail::times2_iterator idx_end = detail::make_times2_iterator(this->probabilities.size() + 1);\n+\n+            return result_type(\n+                make_permutation_iterator(this->heights.begin(), idx_begin)\n+              , make_permutation_iterator(this->heights.begin(), idx_end)\n+            );\n+        }\n+\n+    public:\n+        // make this accumulator serializeable\n+        // TODO: do we need to split to load/save and verify that the parameters did not change?\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & probabilities;\n+            ar & heights;\n+            ar & actual_positions;\n+            ar & desired_positions;\n+            ar & positions_increments;\n+        }\n+\n+    private:\n+        array_type probabilities;         // the quantile probabilities\n+        array_type heights;               // q_i\n+        array_type actual_positions;      // n_i\n+        array_type desired_positions;     // d_i\n+        array_type positions_increments;  // f_i\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::extended_p_square\n+//\n+namespace tag\n+{\n+    struct extended_p_square\n+      : depends_on<count>\n+      , extended_p_square_probabilities\n+    {\n+        typedef accumulators::impl::extended_p_square_impl<mpl::_1> impl;\n+\n+        #ifdef BOOST_ACCUMULATORS_DOXYGEN_INVOKED\n+        /// tag::extended_p_square::probabilities named parameter\n+        static boost::parameter::keyword<tag::probabilities> const probabilities;\n+        #endif\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::extended_p_square\n+//\n+namespace extract\n+{\n+    extractor<tag::extended_p_square> const extended_p_square = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(extended_p_square)\n+}\n+\n+using extract::extended_p_square;\n+\n+// So that extended_p_square can be automatically substituted with\n+// weighted_extended_p_square when the weight parameter is non-void\n+template<>\n+struct as_weighted_feature<tag::extended_p_square>\n+{\n+    typedef tag::weighted_extended_p_square type;\n+};\n+\n+template<>\n+struct feature_of<tag::weighted_extended_p_square>\n+  : feature_of<tag::extended_p_square>\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "f57304cd04e5a4c13f0ecd2640a0723d2b1f8721",
        "filename": "src/boost/accumulators/statistics/extended_p_square_quantile.hpp",
        "status": "added",
        "additions": 331,
        "deletions": 0,
        "changes": 331,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/extended_p_square_quantile.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/extended_p_square_quantile.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/extended_p_square_quantile.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,331 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// extended_p_square_quantile.hpp\n+//\n+//  Copyright 2005 Daniel Egloff. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_EXTENDED_SINGLE_QUANTILE_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_EXTENDED_SINGLE_QUANTILE_HPP_DE_01_01_2006\n+\n+#include <vector>\n+#include <functional>\n+#include <boost/throw_exception.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+#include <boost/range/iterator_range.hpp>\n+#include <boost/iterator/transform_iterator.hpp>\n+#include <boost/iterator/counting_iterator.hpp>\n+#include <boost/iterator/permutation_iterator.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+#include <boost/accumulators/statistics/parameters/quantile_probability.hpp>\n+#include <boost/accumulators/statistics/extended_p_square.hpp>\n+#include <boost/accumulators/statistics/weighted_extended_p_square.hpp>\n+#include <boost/accumulators/statistics/times2_iterator.hpp>\n+\n+#ifdef _MSC_VER\n+# pragma warning(push)\n+# pragma warning(disable: 4127) // conditional expression is constant\n+#endif\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // extended_p_square_quantile_impl\n+    //  single quantile estimation\n+    /**\n+        @brief Quantile estimation using the extended \\f$P^2\\f$ algorithm for weighted and unweighted samples\n+\n+        Uses the quantile estimates calculated by the extended \\f$P^2\\f$ algorithm to compute\n+        intermediate quantile estimates by means of quadratic interpolation.\n+\n+        @param quantile_probability The probability of the quantile to be estimated.\n+    */\n+    template<typename Sample, typename Impl1, typename Impl2> // Impl1: weighted/unweighted // Impl2: linear/quadratic\n+    struct extended_p_square_quantile_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type float_type;\n+        typedef std::vector<float_type> array_type;\n+        typedef iterator_range<\n+            detail::lvalue_index_iterator<\n+                permutation_iterator<\n+                    typename array_type::const_iterator\n+                  , detail::times2_iterator\n+                >\n+            >\n+        > range_type;\n+        // for boost::result_of\n+        typedef float_type result_type;\n+\n+        template<typename Args>\n+        extended_p_square_quantile_impl(Args const &args)\n+          : probabilities(\n+                boost::begin(args[extended_p_square_probabilities])\n+              , boost::end(args[extended_p_square_probabilities])\n+            )\n+        {\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            typedef\n+                typename mpl::if_<\n+                    is_same<Impl1, weighted>\n+                  , tag::weighted_extended_p_square\n+                  , tag::extended_p_square\n+                >::type\n+            extended_p_square_tag;\n+\n+            extractor<extended_p_square_tag> const some_extended_p_square = {};\n+\n+            array_type heights(some_extended_p_square(args).size());\n+            std::copy(some_extended_p_square(args).begin(), some_extended_p_square(args).end(), heights.begin());\n+\n+            this->probability = args[quantile_probability];\n+\n+            typename array_type::const_iterator iter_probs = std::lower_bound(this->probabilities.begin(), this->probabilities.end(), this->probability);\n+            std::size_t dist = std::distance(this->probabilities.begin(), iter_probs);\n+            typename array_type::const_iterator iter_heights = heights.begin() + dist;\n+\n+            // If this->probability is not in a valid range return NaN or throw exception\n+            if (this->probability < *this->probabilities.begin() || this->probability > *(this->probabilities.end() - 1))\n+            {\n+                if (std::numeric_limits<result_type>::has_quiet_NaN)\n+                {\n+                    return std::numeric_limits<result_type>::quiet_NaN();\n+                }\n+                else\n+                {\n+                    std::ostringstream msg;\n+                    msg << \"probability = \" << this->probability << \" is not in valid range (\";\n+                    msg << *this->probabilities.begin() << \", \" << *(this->probabilities.end() - 1) << \")\";\n+                    boost::throw_exception(std::runtime_error(msg.str()));\n+                    return Sample(0);\n+                }\n+\n+            }\n+\n+            if (*iter_probs == this->probability)\n+            {\n+                return heights[dist];\n+            }\n+            else\n+            {\n+                result_type res;\n+\n+                if (is_same<Impl2, linear>::value)\n+                {\n+                    /////////////////////////////////////////////////////////////////////////////////\n+                    // LINEAR INTERPOLATION\n+                    //\n+                    float_type p1 = *iter_probs;\n+                    float_type p0 = *(iter_probs - 1);\n+                    float_type h1 = *iter_heights;\n+                    float_type h0 = *(iter_heights - 1);\n+\n+                    float_type a = numeric::fdiv(h1 - h0, p1 - p0);\n+                    float_type b = h1 - p1 * a;\n+\n+                    res = a * this->probability + b;\n+                }\n+                else\n+                {\n+                    /////////////////////////////////////////////////////////////////////////////////\n+                    // QUADRATIC INTERPOLATION\n+                    //\n+                    float_type p0, p1, p2;\n+                    float_type h0, h1, h2;\n+\n+                    if ( (dist == 1 || *iter_probs - this->probability <= this->probability - *(iter_probs - 1) ) && dist != this->probabilities.size() - 1 )\n+                    {\n+                        p0 = *(iter_probs - 1);\n+                        p1 = *iter_probs;\n+                        p2 = *(iter_probs + 1);\n+                        h0 = *(iter_heights - 1);\n+                        h1 = *iter_heights;\n+                        h2 = *(iter_heights + 1);\n+                    }\n+                    else\n+                    {\n+                        p0 = *(iter_probs - 2);\n+                        p1 = *(iter_probs - 1);\n+                        p2 = *iter_probs;\n+                        h0 = *(iter_heights - 2);\n+                        h1 = *(iter_heights - 1);\n+                        h2 = *iter_heights;\n+                    }\n+\n+                    float_type hp21 = numeric::fdiv(h2 - h1, p2 - p1);\n+                    float_type hp10 = numeric::fdiv(h1 - h0, p1 - p0);\n+                    float_type p21  = numeric::fdiv(p2 * p2 - p1 * p1, p2 - p1);\n+                    float_type p10  = numeric::fdiv(p1 * p1 - p0 * p0, p1 - p0);\n+\n+                    float_type a = numeric::fdiv(hp21 - hp10, p21 - p10);\n+                    float_type b = hp21 - a * p21;\n+                    float_type c = h2 - a * p2 * p2 - b * p2;\n+\n+                    res = a * this->probability * this-> probability + b * this->probability + c;\n+                }\n+\n+                return res;\n+            }\n+\n+        }\n+\n+    public:\n+        // make this accumulator serializeable\n+        // TODO: do we need to split to load/save and verify that the parameters did not change?\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & probabilities;\n+            ar & probability;\n+        }\n+\n+    private:\n+\n+        array_type probabilities;\n+        mutable float_type probability;\n+\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::extended_p_square_quantile\n+//\n+namespace tag\n+{\n+    struct extended_p_square_quantile\n+      : depends_on<extended_p_square>\n+    {\n+        typedef accumulators::impl::extended_p_square_quantile_impl<mpl::_1, unweighted, linear> impl;\n+    };\n+    struct extended_p_square_quantile_quadratic\n+      : depends_on<extended_p_square>\n+    {\n+        typedef accumulators::impl::extended_p_square_quantile_impl<mpl::_1, unweighted, quadratic> impl;\n+    };\n+    struct weighted_extended_p_square_quantile\n+      : depends_on<weighted_extended_p_square>\n+    {\n+        typedef accumulators::impl::extended_p_square_quantile_impl<mpl::_1, weighted, linear> impl;\n+    };\n+    struct weighted_extended_p_square_quantile_quadratic\n+      : depends_on<weighted_extended_p_square>\n+    {\n+        typedef accumulators::impl::extended_p_square_quantile_impl<mpl::_1, weighted, quadratic> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::extended_p_square_quantile\n+// extract::weighted_extended_p_square_quantile\n+//\n+namespace extract\n+{\n+    extractor<tag::extended_p_square_quantile> const extended_p_square_quantile = {};\n+    extractor<tag::extended_p_square_quantile_quadratic> const extended_p_square_quantile_quadratic = {};\n+    extractor<tag::weighted_extended_p_square_quantile> const weighted_extended_p_square_quantile = {};\n+    extractor<tag::weighted_extended_p_square_quantile_quadratic> const weighted_extended_p_square_quantile_quadratic = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(extended_p_square_quantile)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(extended_p_square_quantile_quadratic)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(weighted_extended_p_square_quantile)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(weighted_extended_p_square_quantile_quadratic)\n+}\n+\n+using extract::extended_p_square_quantile;\n+using extract::extended_p_square_quantile_quadratic;\n+using extract::weighted_extended_p_square_quantile;\n+using extract::weighted_extended_p_square_quantile_quadratic;\n+\n+// extended_p_square_quantile(linear) -> extended_p_square_quantile\n+template<>\n+struct as_feature<tag::extended_p_square_quantile(linear)>\n+{\n+    typedef tag::extended_p_square_quantile type;\n+};\n+\n+// extended_p_square_quantile(quadratic) -> extended_p_square_quantile_quadratic\n+template<>\n+struct as_feature<tag::extended_p_square_quantile(quadratic)>\n+{\n+    typedef tag::extended_p_square_quantile_quadratic type;\n+};\n+\n+// weighted_extended_p_square_quantile(linear) -> weighted_extended_p_square_quantile\n+template<>\n+struct as_feature<tag::weighted_extended_p_square_quantile(linear)>\n+{\n+    typedef tag::weighted_extended_p_square_quantile type;\n+};\n+\n+// weighted_extended_p_square_quantile(quadratic) -> weighted_extended_p_square_quantile_quadratic\n+template<>\n+struct as_feature<tag::weighted_extended_p_square_quantile(quadratic)>\n+{\n+    typedef tag::weighted_extended_p_square_quantile_quadratic type;\n+};\n+\n+// for the purposes of feature-based dependency resolution,\n+// extended_p_square_quantile and weighted_extended_p_square_quantile\n+// provide the same feature as quantile\n+template<>\n+struct feature_of<tag::extended_p_square_quantile>\n+  : feature_of<tag::quantile>\n+{\n+};\n+template<>\n+struct feature_of<tag::extended_p_square_quantile_quadratic>\n+  : feature_of<tag::quantile>\n+{\n+};\n+// So that extended_p_square_quantile can be automatically substituted with\n+// weighted_extended_p_square_quantile when the weight parameter is non-void\n+template<>\n+struct as_weighted_feature<tag::extended_p_square_quantile>\n+{\n+    typedef tag::weighted_extended_p_square_quantile type;\n+};\n+\n+template<>\n+struct feature_of<tag::weighted_extended_p_square_quantile>\n+  : feature_of<tag::extended_p_square_quantile>\n+{\n+};\n+\n+// So that extended_p_square_quantile_quadratic can be automatically substituted with\n+// weighted_extended_p_square_quantile_quadratic when the weight parameter is non-void\n+template<>\n+struct as_weighted_feature<tag::extended_p_square_quantile_quadratic>\n+{\n+    typedef tag::weighted_extended_p_square_quantile_quadratic type;\n+};\n+template<>\n+struct feature_of<tag::weighted_extended_p_square_quantile_quadratic>\n+  : feature_of<tag::extended_p_square_quantile_quadratic>\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#ifdef _MSC_VER\n+# pragma warning(pop)\n+#endif\n+\n+#endif"
      },
      {
        "sha": "9ff9ecdccb5e4796d814b409e0593dd2972dd9fd",
        "filename": "src/boost/accumulators/statistics/kurtosis.hpp",
        "status": "added",
        "additions": 116,
        "deletions": 0,
        "changes": 116,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/kurtosis.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/kurtosis.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/kurtosis.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,116 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// kurtosis.hpp\n+//\n+//  Copyright 2006 Olivier Gygi, Daniel Egloff. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_KURTOSIS_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_KURTOSIS_HPP_EAN_28_10_2005\n+\n+#include <limits>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics/mean.hpp>\n+#include <boost/accumulators/statistics/moment.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // kurtosis_impl\n+    /**\n+        @brief Kurtosis estimation\n+\n+        The kurtosis of a sample distribution is defined as the ratio of the 4th central moment and the square of the 2nd central\n+        moment (the variance) of the samples, minus 3. The term \\f$ -3 \\f$ is added in order to ensure that the normal distribution\n+        has zero kurtosis. The kurtosis can also be expressed by the simple moments:\n+\n+        \\f[\n+            \\hat{g}_2 =\n+                \\frac\n+                {\\widehat{m}_n^{(4)}-4\\widehat{m}_n^{(3)}\\hat{\\mu}_n+6\\widehat{m}_n^{(2)}\\hat{\\mu}_n^2-3\\hat{\\mu}_n^4}\n+                {\\left(\\widehat{m}_n^{(2)} - \\hat{\\mu}_n^{2}\\right)^2} - 3,\n+        \\f]\n+\n+        where \\f$ \\widehat{m}_n^{(i)} \\f$ are the \\f$ i \\f$-th moment and \\f$ \\hat{\\mu}_n \\f$ the mean (first moment) of the\n+        \\f$ n \\f$ samples.\n+    */\n+    template<typename Sample>\n+    struct kurtosis_impl\n+      : accumulator_base\n+    {\n+        // for boost::result_of\n+        typedef typename numeric::functional::fdiv<Sample, Sample>::result_type result_type;\n+\n+        kurtosis_impl(dont_care) {}\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            return numeric::fdiv(\n+                        accumulators::moment<4>(args)\n+                        - 4. * accumulators::moment<3>(args) * mean(args)\n+                        + 6. * accumulators::moment<2>(args) * mean(args) * mean(args)\n+                        - 3. * mean(args) * mean(args) * mean(args) * mean(args)\n+                      , ( accumulators::moment<2>(args) - mean(args) * mean(args) )\n+                        * ( accumulators::moment<2>(args) - mean(args) * mean(args) )\n+                    ) - 3.;\n+        }\n+        \n+        // serialization is done by accumulators it depends on\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version) {}\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::kurtosis\n+//\n+namespace tag\n+{\n+    struct kurtosis\n+      : depends_on<mean, moment<2>, moment<3>, moment<4> >\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::kurtosis_impl<mpl::_1> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::kurtosis\n+//\n+namespace extract\n+{\n+    extractor<tag::kurtosis> const kurtosis = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(kurtosis)\n+}\n+\n+using extract::kurtosis;\n+\n+// So that kurtosis can be automatically substituted with\n+// weighted_kurtosis when the weight parameter is non-void\n+template<>\n+struct as_weighted_feature<tag::kurtosis>\n+{\n+    typedef tag::weighted_kurtosis type;\n+};\n+\n+template<>\n+struct feature_of<tag::weighted_kurtosis>\n+  : feature_of<tag::kurtosis>\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "15033e6daa239ea32f1fd9b106bfa1b258864374",
        "filename": "src/boost/accumulators/statistics/max.hpp",
        "status": "added",
        "additions": 92,
        "deletions": 0,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/max.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/max.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/max.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,92 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// max.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_MAX_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_MAX_HPP_EAN_28_10_2005\n+\n+#include <limits>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // max_impl\n+    template<typename Sample>\n+    struct max_impl\n+      : accumulator_base\n+    {\n+        // for boost::result_of\n+        typedef Sample result_type;\n+\n+        template<typename Args>\n+        max_impl(Args const &args)\n+          : max_(numeric::as_min(args[sample | Sample()]))\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            numeric::max_assign(this->max_, args[sample]);\n+        }\n+\n+        result_type result(dont_care) const\n+        {\n+            return this->max_;\n+        }\n+\n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & max_;\n+        }\n+\n+    private:\n+        Sample max_;\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::max\n+//\n+namespace tag\n+{\n+    struct max\n+      : depends_on<>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::max_impl<mpl::_1> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::max\n+//\n+namespace extract\n+{\n+    extractor<tag::max> const max = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(max)\n+}\n+\n+using extract::max;\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "c6df176b78db36d1e70583649962c2d71a486276",
        "filename": "src/boost/accumulators/statistics/mean.hpp",
        "status": "added",
        "additions": 308,
        "deletions": 0,
        "changes": 308,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/mean.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/mean.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/mean.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,308 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// mean.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_MEAN_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_MEAN_HPP_EAN_28_10_2005\n+\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+#include <boost/accumulators/statistics/sum.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // mean_impl\n+    //      lazy, by default\n+    template<typename Sample, typename SumFeature>\n+    struct mean_impl\n+      : accumulator_base\n+    {\n+        // for boost::result_of\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type result_type;\n+\n+        mean_impl(dont_care) {}\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            extractor<SumFeature> sum;\n+            return numeric::fdiv(sum(args), count(args));\n+        }\n+\n+        // serialization is done by accumulators it depends on\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version) {}\n+    };\n+\n+    template<typename Sample, typename Tag>\n+    struct immediate_mean_impl\n+      : accumulator_base\n+    {\n+        // for boost::result_of\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type result_type;\n+\n+        template<typename Args>\n+        immediate_mean_impl(Args const &args)\n+          : mean(numeric::fdiv(args[sample | Sample()], numeric::one<std::size_t>::value))\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            std::size_t cnt = count(args);\n+            this->mean = numeric::fdiv(\n+                (this->mean * (cnt - 1)) + args[parameter::keyword<Tag>::get()]\n+              , cnt\n+            );\n+        }\n+\n+        result_type result(dont_care) const\n+        {\n+            return this->mean;\n+        }\n+\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & mean;\n+        }\n+\n+    private:\n+        result_type mean;\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::mean\n+// tag::immediate_mean\n+// tag::mean_of_weights\n+// tag::immediate_mean_of_weights\n+// tag::mean_of_variates\n+// tag::immediate_mean_of_variates\n+//\n+namespace tag\n+{\n+    struct mean\n+      : depends_on<count, sum>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::mean_impl<mpl::_1, sum> impl;\n+    };\n+    struct immediate_mean\n+      : depends_on<count>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::immediate_mean_impl<mpl::_1, tag::sample> impl;\n+    };\n+    struct mean_of_weights\n+      : depends_on<count, sum_of_weights>\n+    {\n+        typedef mpl::true_ is_weight_accumulator;\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::mean_impl<mpl::_2, sum_of_weights> impl;\n+    };\n+    struct immediate_mean_of_weights\n+      : depends_on<count>\n+    {\n+        typedef mpl::true_ is_weight_accumulator;\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::immediate_mean_impl<mpl::_2, tag::weight> impl;\n+    };\n+    template<typename VariateType, typename VariateTag>\n+    struct mean_of_variates\n+      : depends_on<count, sum_of_variates<VariateType, VariateTag> >\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef mpl::always<accumulators::impl::mean_impl<VariateType, sum_of_variates<VariateType, VariateTag> > > impl;\n+    };\n+    template<typename VariateType, typename VariateTag>\n+    struct immediate_mean_of_variates\n+      : depends_on<count>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef mpl::always<accumulators::impl::immediate_mean_impl<VariateType, VariateTag> > impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::mean\n+// extract::mean_of_weights\n+// extract::mean_of_variates\n+//\n+namespace extract\n+{\n+    extractor<tag::mean> const mean = {};\n+    extractor<tag::mean_of_weights> const mean_of_weights = {};\n+    BOOST_ACCUMULATORS_DEFINE_EXTRACTOR(tag, mean_of_variates, (typename)(typename))\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(mean)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(mean_of_weights)\n+}\n+\n+using extract::mean;\n+using extract::mean_of_weights;\n+using extract::mean_of_variates;\n+\n+// mean(lazy) -> mean\n+template<>\n+struct as_feature<tag::mean(lazy)>\n+{\n+    typedef tag::mean type;\n+};\n+\n+// mean(immediate) -> immediate_mean\n+template<>\n+struct as_feature<tag::mean(immediate)>\n+{\n+    typedef tag::immediate_mean type;\n+};\n+\n+// mean_of_weights(lazy) -> mean_of_weights\n+template<>\n+struct as_feature<tag::mean_of_weights(lazy)>\n+{\n+    typedef tag::mean_of_weights type;\n+};\n+\n+// mean_of_weights(immediate) -> immediate_mean_of_weights\n+template<>\n+struct as_feature<tag::mean_of_weights(immediate)>\n+{\n+    typedef tag::immediate_mean_of_weights type;\n+};\n+\n+// mean_of_variates<VariateType, VariateTag>(lazy) -> mean_of_variates<VariateType, VariateTag>\n+template<typename VariateType, typename VariateTag>\n+struct as_feature<tag::mean_of_variates<VariateType, VariateTag>(lazy)>\n+{\n+    typedef tag::mean_of_variates<VariateType, VariateTag> type;\n+};\n+\n+// mean_of_variates<VariateType, VariateTag>(immediate) -> immediate_mean_of_variates<VariateType, VariateTag>\n+template<typename VariateType, typename VariateTag>\n+struct as_feature<tag::mean_of_variates<VariateType, VariateTag>(immediate)>\n+{\n+    typedef tag::immediate_mean_of_variates<VariateType, VariateTag> type;\n+};\n+\n+// for the purposes of feature-based dependency resolution,\n+// immediate_mean provides the same feature as mean\n+template<>\n+struct feature_of<tag::immediate_mean>\n+  : feature_of<tag::mean>\n+{\n+};\n+\n+// for the purposes of feature-based dependency resolution,\n+// immediate_mean provides the same feature as mean\n+template<>\n+struct feature_of<tag::immediate_mean_of_weights>\n+  : feature_of<tag::mean_of_weights>\n+{\n+};\n+\n+// for the purposes of feature-based dependency resolution,\n+// immediate_mean provides the same feature as mean\n+template<typename VariateType, typename VariateTag>\n+struct feature_of<tag::immediate_mean_of_variates<VariateType, VariateTag> >\n+  : feature_of<tag::mean_of_variates<VariateType, VariateTag> >\n+{\n+};\n+\n+// So that mean can be automatically substituted with\n+// weighted_mean when the weight parameter is non-void.\n+template<>\n+struct as_weighted_feature<tag::mean>\n+{\n+    typedef tag::weighted_mean type;\n+};\n+\n+template<>\n+struct feature_of<tag::weighted_mean>\n+  : feature_of<tag::mean>\n+{};\n+\n+// So that immediate_mean can be automatically substituted with\n+// immediate_weighted_mean when the weight parameter is non-void.\n+template<>\n+struct as_weighted_feature<tag::immediate_mean>\n+{\n+    typedef tag::immediate_weighted_mean type;\n+};\n+\n+template<>\n+struct feature_of<tag::immediate_weighted_mean>\n+  : feature_of<tag::immediate_mean>\n+{};\n+\n+// So that mean_of_weights<> can be automatically substituted with\n+// weighted_mean_of_variates<> when the weight parameter is non-void.\n+template<typename VariateType, typename VariateTag>\n+struct as_weighted_feature<tag::mean_of_variates<VariateType, VariateTag> >\n+{\n+    typedef tag::weighted_mean_of_variates<VariateType, VariateTag> type;\n+};\n+\n+template<typename VariateType, typename VariateTag>\n+struct feature_of<tag::weighted_mean_of_variates<VariateType, VariateTag> >\n+  : feature_of<tag::mean_of_variates<VariateType, VariateTag> >\n+{\n+};\n+\n+// So that immediate_mean_of_weights<> can be automatically substituted with\n+// immediate_weighted_mean_of_variates<> when the weight parameter is non-void.\n+template<typename VariateType, typename VariateTag>\n+struct as_weighted_feature<tag::immediate_mean_of_variates<VariateType, VariateTag> >\n+{\n+    typedef tag::immediate_weighted_mean_of_variates<VariateType, VariateTag> type;\n+};\n+\n+template<typename VariateType, typename VariateTag>\n+struct feature_of<tag::immediate_weighted_mean_of_variates<VariateType, VariateTag> >\n+  : feature_of<tag::immediate_mean_of_variates<VariateType, VariateTag> >\n+{\n+};\n+\n+////////////////////////////////////////////////////////////////////////////\n+//// droppable_accumulator<mean_impl>\n+////  need to specialize droppable lazy mean to cache the result at the\n+////  point the accumulator is dropped.\n+///// INTERNAL ONLY\n+/////\n+//template<typename Sample, typename SumFeature>\n+//struct droppable_accumulator<impl::mean_impl<Sample, SumFeature> >\n+//  : droppable_accumulator_base<\n+//        with_cached_result<impl::mean_impl<Sample, SumFeature> >\n+//    >\n+//{\n+//    template<typename Args>\n+//    droppable_accumulator(Args const &args)\n+//      : droppable_accumulator::base(args)\n+//    {\n+//    }\n+//};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "4d4118d8b4092afec3b14d16a7515cc53287a591",
        "filename": "src/boost/accumulators/statistics/median.hpp",
        "status": "added",
        "additions": 324,
        "deletions": 0,
        "changes": 324,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/median.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/median.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/median.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,324 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// median.hpp\n+//\n+//  Copyright 2006 Eric Niebler, Olivier Gygi. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_MEDIAN_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_MEDIAN_HPP_EAN_28_10_2005\n+\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/range/iterator_range.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+#include <boost/accumulators/statistics/p_square_quantile.hpp>\n+#include <boost/accumulators/statistics/density.hpp>\n+#include <boost/accumulators/statistics/p_square_cumul_dist.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // median_impl\n+    //\n+    /**\n+        @brief Median estimation based on the \\f$P^2\\f$ quantile estimator\n+\n+        The \\f$P^2\\f$ algorithm is invoked with a quantile probability of 0.5.\n+    */\n+    template<typename Sample>\n+    struct median_impl\n+      : accumulator_base\n+    {\n+        // for boost::result_of\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type result_type;\n+\n+        median_impl(dont_care) {}\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            return p_square_quantile_for_median(args);\n+        }\n+        \n+        // serialization is done by accumulators it depends on\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version) {}\n+    };\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // with_density_median_impl\n+    //\n+    /**\n+        @brief Median estimation based on the density estimator\n+\n+        The algorithm determines the bin in which the \\f$0.5*cnt\\f$-th sample lies, \\f$cnt\\f$ being\n+        the total number of samples. It returns the approximate horizontal position of this sample,\n+        based on a linear interpolation inside the bin.\n+    */\n+    template<typename Sample>\n+    struct with_density_median_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type float_type;\n+        typedef std::vector<std::pair<float_type, float_type> > histogram_type;\n+        typedef iterator_range<typename histogram_type::iterator> range_type;\n+        // for boost::result_of\n+        typedef float_type result_type;\n+\n+        template<typename Args>\n+        with_density_median_impl(Args const &args)\n+          : sum(numeric::fdiv(args[sample | Sample()], (std::size_t)1))\n+          , is_dirty(true)\n+        {\n+        }\n+\n+        void operator ()(dont_care)\n+        {\n+            this->is_dirty = true;\n+        }\n+\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            if (this->is_dirty)\n+            {\n+                this->is_dirty = false;\n+\n+                std::size_t cnt = count(args);\n+                range_type histogram = density(args);\n+                typename range_type::iterator it = histogram.begin();\n+                while (this->sum < 0.5 * cnt)\n+                {\n+                    this->sum += it->second * cnt;\n+                    ++it;\n+                }\n+                --it;\n+                float_type over = numeric::fdiv(this->sum - 0.5 * cnt, it->second * cnt);\n+                this->median = it->first * over + (it + 1)->first * (1. - over);\n+            }\n+\n+            return this->median;\n+        }\n+\n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & sum;\n+            ar & is_dirty;\n+            ar & median;\n+        }\n+\n+\n+    private:\n+        mutable float_type sum;\n+        mutable bool is_dirty;\n+        mutable float_type median;\n+    };\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // with_p_square_cumulative_distribution_median_impl\n+    //\n+    /**\n+        @brief Median estimation based on the \\f$P^2\\f$ cumulative distribution estimator\n+\n+        The algorithm determines the first (leftmost) bin with a height exceeding 0.5. It\n+        returns the approximate horizontal position of where the cumulative distribution\n+        equals 0.5, based on a linear interpolation inside the bin.\n+    */\n+    template<typename Sample>\n+    struct with_p_square_cumulative_distribution_median_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type float_type;\n+        typedef std::vector<std::pair<float_type, float_type> > histogram_type;\n+        typedef iterator_range<typename histogram_type::iterator> range_type;\n+        // for boost::result_of\n+        typedef float_type result_type;\n+\n+        with_p_square_cumulative_distribution_median_impl(dont_care)\n+          : is_dirty(true)\n+        {\n+        }\n+\n+        void operator ()(dont_care)\n+        {\n+            this->is_dirty = true;\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            if (this->is_dirty)\n+            {\n+                this->is_dirty = false;\n+\n+                range_type histogram = p_square_cumulative_distribution(args);\n+                typename range_type::iterator it = histogram.begin();\n+                while (it->second < 0.5)\n+                {\n+                    ++it;\n+                }\n+                float_type over = numeric::fdiv(it->second - 0.5, it->second - (it - 1)->second);\n+                this->median = it->first * over + (it + 1)->first * ( 1. - over );\n+            }\n+\n+            return this->median;\n+        }\n+        \n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & is_dirty;\n+            ar & median;\n+        }\n+\n+    private:\n+\n+        mutable bool is_dirty;\n+        mutable float_type median;\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::median\n+// tag::with_densisty_median\n+// tag::with_p_square_cumulative_distribution_median\n+//\n+namespace tag\n+{\n+    struct median\n+      : depends_on<p_square_quantile_for_median>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::median_impl<mpl::_1> impl;\n+    };\n+    struct with_density_median\n+      : depends_on<count, density>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::with_density_median_impl<mpl::_1> impl;\n+    };\n+    struct with_p_square_cumulative_distribution_median\n+      : depends_on<p_square_cumulative_distribution>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::with_p_square_cumulative_distribution_median_impl<mpl::_1> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::median\n+// extract::with_density_median\n+// extract::with_p_square_cumulative_distribution_median\n+//\n+namespace extract\n+{\n+    extractor<tag::median> const median = {};\n+    extractor<tag::with_density_median> const with_density_median = {};\n+    extractor<tag::with_p_square_cumulative_distribution_median> const with_p_square_cumulative_distribution_median = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(median)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(with_density_median)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(with_p_square_cumulative_distribution_median)\n+}\n+\n+using extract::median;\n+using extract::with_density_median;\n+using extract::with_p_square_cumulative_distribution_median;\n+\n+// median(with_p_square_quantile) -> median\n+template<>\n+struct as_feature<tag::median(with_p_square_quantile)>\n+{\n+    typedef tag::median type;\n+};\n+\n+// median(with_density) -> with_density_median\n+template<>\n+struct as_feature<tag::median(with_density)>\n+{\n+    typedef tag::with_density_median type;\n+};\n+\n+// median(with_p_square_cumulative_distribution) -> with_p_square_cumulative_distribution_median\n+template<>\n+struct as_feature<tag::median(with_p_square_cumulative_distribution)>\n+{\n+    typedef tag::with_p_square_cumulative_distribution_median type;\n+};\n+\n+// for the purposes of feature-based dependency resolution,\n+// with_density_median and with_p_square_cumulative_distribution_median\n+// provide the same feature as median\n+template<>\n+struct feature_of<tag::with_density_median>\n+  : feature_of<tag::median>\n+{\n+};\n+\n+template<>\n+struct feature_of<tag::with_p_square_cumulative_distribution_median>\n+  : feature_of<tag::median>\n+{\n+};\n+\n+// So that median can be automatically substituted with\n+// weighted_median when the weight parameter is non-void.\n+template<>\n+struct as_weighted_feature<tag::median>\n+{\n+    typedef tag::weighted_median type;\n+};\n+\n+template<>\n+struct feature_of<tag::weighted_median>\n+  : feature_of<tag::median>\n+{\n+};\n+\n+// So that with_density_median can be automatically substituted with\n+// with_density_weighted_median when the weight parameter is non-void.\n+template<>\n+struct as_weighted_feature<tag::with_density_median>\n+{\n+    typedef tag::with_density_weighted_median type;\n+};\n+\n+template<>\n+struct feature_of<tag::with_density_weighted_median>\n+  : feature_of<tag::with_density_median>\n+{\n+};\n+\n+// So that with_p_square_cumulative_distribution_median can be automatically substituted with\n+// with_p_square_cumulative_distribution_weighted_median when the weight parameter is non-void.\n+template<>\n+struct as_weighted_feature<tag::with_p_square_cumulative_distribution_median>\n+{\n+    typedef tag::with_p_square_cumulative_distribution_weighted_median type;\n+};\n+\n+template<>\n+struct feature_of<tag::with_p_square_cumulative_distribution_weighted_median>\n+  : feature_of<tag::with_p_square_cumulative_distribution_median>\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "bf30b79e340bab4a9ee718aff86d404c7c5b3c92",
        "filename": "src/boost/accumulators/statistics/min.hpp",
        "status": "added",
        "additions": 92,
        "deletions": 0,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/min.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/min.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/min.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,92 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// min.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_MIN_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_MIN_HPP_EAN_28_10_2005\n+\n+#include <limits>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // min_impl\n+    template<typename Sample>\n+    struct min_impl\n+      : accumulator_base\n+    {\n+        // for boost::result_of\n+        typedef Sample result_type;\n+\n+        template<typename Args>\n+        min_impl(Args const &args)\n+          : min_(numeric::as_max(args[sample | Sample()]))\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            numeric::min_assign(this->min_, args[sample]);\n+        }\n+\n+        result_type result(dont_care) const\n+        {\n+            return this->min_;\n+        }\n+\n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & min_;\n+        }\n+\n+    private:\n+        Sample min_;\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::min\n+//\n+namespace tag\n+{\n+    struct min\n+      : depends_on<>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::min_impl<mpl::_1> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::min\n+//\n+namespace extract\n+{\n+    extractor<tag::min> const min = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(min)\n+}\n+\n+using extract::min;\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "9ba1e4caaf432a767bc6906fd0ff244203043485",
        "filename": "src/boost/accumulators/statistics/moment.hpp",
        "status": "added",
        "additions": 132,
        "deletions": 0,
        "changes": 132,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/moment.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/moment.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/moment.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,132 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// moment.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_MOMENT_HPP_EAN_15_11_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_MOMENT_HPP_EAN_15_11_2005\n+\n+#include <boost/config/no_tr1/cmath.hpp>\n+#include <boost/mpl/int.hpp>\n+#include <boost/mpl/assert.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+\n+namespace boost { namespace numeric\n+{\n+    /// INTERNAL ONLY\n+    ///\n+    template<typename T>\n+    T const &pow(T const &x, mpl::int_<1>)\n+    {\n+        return x;\n+    }\n+\n+    /// INTERNAL ONLY\n+    ///\n+    template<typename T, int N>\n+    T pow(T const &x, mpl::int_<N>)\n+    {\n+        using namespace operators;\n+        T y = numeric::pow(x, mpl::int_<N/2>());\n+        T z = y * y;\n+        return (N % 2) ? (z * x) : z;\n+    }\n+}}\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // moment_impl\n+    template<typename N, typename Sample>\n+    struct moment_impl\n+      : accumulator_base // TODO: also depends_on sum of powers\n+    {\n+        BOOST_MPL_ASSERT_RELATION(N::value, >, 0);\n+        // for boost::result_of\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type result_type;\n+\n+        template<typename Args>\n+        moment_impl(Args const &args)\n+          : sum(args[sample | Sample()])\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            this->sum += numeric::pow(args[sample], N());\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            return numeric::fdiv(this->sum, count(args));\n+        }\n+\n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & sum;\n+        }\n+\n+    private:\n+        Sample sum;\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::moment\n+//\n+namespace tag\n+{\n+    template<int N>\n+    struct moment\n+      : depends_on<count>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::moment_impl<mpl::int_<N>, mpl::_1> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::moment\n+//\n+namespace extract\n+{\n+    BOOST_ACCUMULATORS_DEFINE_EXTRACTOR(tag, moment, (int))\n+}\n+\n+using extract::moment;\n+\n+// So that moment<N> can be automatically substituted with\n+// weighted_moment<N> when the weight parameter is non-void\n+template<int N>\n+struct as_weighted_feature<tag::moment<N> >\n+{\n+    typedef tag::weighted_moment<N> type;\n+};\n+\n+template<int N>\n+struct feature_of<tag::weighted_moment<N> >\n+  : feature_of<tag::moment<N> >\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "daa66f9bd1745f388025a3909203a510e1215faf",
        "filename": "src/boost/accumulators/statistics/p_square_cumul_dist.hpp",
        "status": "added",
        "additions": 279,
        "deletions": 0,
        "changes": 279,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/p_square_cumul_dist.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/p_square_cumul_dist.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/p_square_cumul_dist.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,279 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// p_square_cumulative_distribution.hpp\n+//\n+//  Copyright 2005 Daniel Egloff, Olivier Gygi. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_P_SQUARE_CUMUL_DIST_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_P_SQUARE_CUMUL_DIST_HPP_DE_01_01_2006\n+\n+#include <vector>\n+#include <functional>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/range.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/accumulators_fwd.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+#include <boost/serialization/vector.hpp>\n+#include <boost/serialization/utility.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+///////////////////////////////////////////////////////////////////////////////\n+// num_cells named parameter\n+//\n+BOOST_PARAMETER_NESTED_KEYWORD(tag, p_square_cumulative_distribution_num_cells, num_cells)\n+\n+BOOST_ACCUMULATORS_IGNORE_GLOBAL(p_square_cumulative_distribution_num_cells)\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // p_square_cumulative_distribution_impl\n+    //  cumulative_distribution calculation (as histogram)\n+    /**\n+        @brief Histogram calculation of the cumulative distribution with the \\f$P^2\\f$ algorithm\n+\n+        A histogram of the sample cumulative distribution is computed dynamically without storing samples\n+        based on the \\f$ P^2 \\f$ algorithm. The returned histogram has a specifiable amount (num_cells)\n+        equiprobable (and not equal-sized) cells.\n+\n+        For further details, see\n+\n+        R. Jain and I. Chlamtac, The P^2 algorithm for dynamic calculation of quantiles and\n+        histograms without storing observations, Communications of the ACM,\n+        Volume 28 (October), Number 10, 1985, p. 1076-1085.\n+\n+        @param p_square_cumulative_distribution_num_cells.\n+    */\n+    template<typename Sample>\n+    struct p_square_cumulative_distribution_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type float_type;\n+        typedef std::vector<float_type> array_type;\n+        typedef std::vector<std::pair<float_type, float_type> > histogram_type;\n+        // for boost::result_of\n+        typedef iterator_range<typename histogram_type::iterator> result_type;\n+\n+        template<typename Args>\n+        p_square_cumulative_distribution_impl(Args const &args)\n+          : num_cells(args[p_square_cumulative_distribution_num_cells])\n+          , heights(num_cells + 1)\n+          , actual_positions(num_cells + 1)\n+          , desired_positions(num_cells + 1)\n+          , positions_increments(num_cells + 1)\n+          , histogram(num_cells + 1)\n+          , is_dirty(true)\n+        {\n+            std::size_t b = this->num_cells;\n+\n+            for (std::size_t i = 0; i < b + 1; ++i)\n+            {\n+                this->actual_positions[i] = i + 1.;\n+                this->desired_positions[i] = i + 1.;\n+                this->positions_increments[i] = numeric::fdiv(i, b);\n+            }\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            this->is_dirty = true;\n+\n+            std::size_t cnt = count(args);\n+            std::size_t sample_cell = 1; // k\n+            std::size_t b = this->num_cells;\n+\n+            // accumulate num_cells + 1 first samples\n+            if (cnt <= b + 1)\n+            {\n+                this->heights[cnt - 1] = args[sample];\n+\n+                // complete the initialization of heights by sorting\n+                if (cnt == b + 1)\n+                {\n+                    std::sort(this->heights.begin(), this->heights.end());\n+                }\n+            }\n+            else\n+            {\n+                // find cell k such that heights[k-1] <= args[sample] < heights[k] and adjust extreme values\n+                if (args[sample] < this->heights[0])\n+                {\n+                    this->heights[0] = args[sample];\n+                    sample_cell = 1;\n+                }\n+                else if (this->heights[b] <= args[sample])\n+                {\n+                    this->heights[b] = args[sample];\n+                    sample_cell = b;\n+                }\n+                else\n+                {\n+                    typename array_type::iterator it;\n+                    it = std::upper_bound(\n+                        this->heights.begin()\n+                      , this->heights.end()\n+                      , args[sample]\n+                    );\n+\n+                    sample_cell = std::distance(this->heights.begin(), it);\n+                }\n+\n+                // increment positions of markers above sample_cell\n+                for (std::size_t i = sample_cell; i < b + 1; ++i)\n+                {\n+                    ++this->actual_positions[i];\n+                }\n+\n+                // update desired position of markers 2 to num_cells + 1\n+                // (desired position of first marker is always 1)\n+                for (std::size_t i = 1; i < b + 1; ++i)\n+                {\n+                    this->desired_positions[i] += this->positions_increments[i];\n+                }\n+\n+                // adjust heights of markers 2 to num_cells if necessary\n+                for (std::size_t i = 1; i < b; ++i)\n+                {\n+                    // offset to desire position\n+                    float_type d = this->desired_positions[i] - this->actual_positions[i];\n+\n+                    // offset to next position\n+                    float_type dp = this->actual_positions[i + 1] - this->actual_positions[i];\n+\n+                    // offset to previous position\n+                    float_type dm = this->actual_positions[i - 1] - this->actual_positions[i];\n+\n+                    // height ds\n+                    float_type hp = (this->heights[i + 1] - this->heights[i]) / dp;\n+                    float_type hm = (this->heights[i - 1] - this->heights[i]) / dm;\n+\n+                    if ( ( d >= 1. && dp > 1. ) || ( d <= -1. && dm < -1. ) )\n+                    {\n+                        short sign_d = static_cast<short>(d / std::abs(d));\n+\n+                        // try adjusting heights[i] using p-squared formula\n+                        float_type h = this->heights[i] + sign_d / (dp - dm) * ( (sign_d - dm) * hp + (dp - sign_d) * hm );\n+\n+                        if ( this->heights[i - 1] < h && h < this->heights[i + 1] )\n+                        {\n+                            this->heights[i] = h;\n+                        }\n+                        else\n+                        {\n+                            // use linear formula\n+                            if (d>0)\n+                            {\n+                                this->heights[i] += hp;\n+                            }\n+                            if (d<0)\n+                            {\n+                                this->heights[i] -= hm;\n+                            }\n+                        }\n+                        this->actual_positions[i] += sign_d;\n+                    }\n+                }\n+            }\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            if (this->is_dirty)\n+            {\n+                this->is_dirty = false;\n+\n+                // creates a vector of std::pair where each pair i holds\n+                // the values heights[i] (x-axis of histogram) and\n+                // actual_positions[i] / cnt (y-axis of histogram)\n+\n+                std::size_t cnt = count(args);\n+\n+                for (std::size_t i = 0; i < this->histogram.size(); ++i)\n+                {\n+                    this->histogram[i] = std::make_pair(this->heights[i], numeric::fdiv(this->actual_positions[i], cnt));\n+                }\n+            }\n+            //return histogram;\n+            return make_iterator_range(this->histogram);\n+        }\n+    \n+        // make this accumulator serializeable\n+        // TODO split to save/load and check on parameters provided in ctor\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        {\n+            ar & num_cells;\n+            ar & heights;\n+            ar & actual_positions;\n+            ar & desired_positions;\n+            ar & positions_increments;\n+            ar & histogram;\n+            ar & is_dirty; \n+        }\n+\n+    private:\n+        std::size_t num_cells;            // number of cells b\n+        array_type  heights;              // q_i\n+        array_type  actual_positions;     // n_i\n+        array_type  desired_positions;    // n'_i\n+        array_type  positions_increments; // dn'_i\n+        mutable histogram_type histogram; // histogram\n+        mutable bool is_dirty;\n+    };\n+\n+} // namespace detail\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::p_square_cumulative_distribution\n+//\n+namespace tag\n+{\n+    struct p_square_cumulative_distribution\n+      : depends_on<count>\n+      , p_square_cumulative_distribution_num_cells\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::p_square_cumulative_distribution_impl<mpl::_1> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::p_square_cumulative_distribution\n+//\n+namespace extract\n+{\n+    extractor<tag::p_square_cumulative_distribution> const p_square_cumulative_distribution = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(p_square_cumulative_distribution)\n+}\n+\n+using extract::p_square_cumulative_distribution;\n+\n+// So that p_square_cumulative_distribution can be automatically substituted with\n+// weighted_p_square_cumulative_distribution when the weight parameter is non-void\n+template<>\n+struct as_weighted_feature<tag::p_square_cumulative_distribution>\n+{\n+    typedef tag::weighted_p_square_cumulative_distribution type;\n+};\n+\n+template<>\n+struct feature_of<tag::weighted_p_square_cumulative_distribution>\n+  : feature_of<tag::p_square_cumulative_distribution>\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "cd471304546741d88a724a3c8079f18aba1c408a",
        "filename": "src/boost/accumulators/statistics/p_square_cumulative_distribution.hpp",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/p_square_cumulative_distribution.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/p_square_cumulative_distribution.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/p_square_cumulative_distribution.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,19 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// p_square_cumulative_distribution.hpp\n+//\n+//  Copyright 2012 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_P_SQUARE_CUMULATIVE_DISTRIBUTION_HPP_03_19_2012\n+#define BOOST_ACCUMULATORS_STATISTICS_P_SQUARE_CUMULATIVE_DISTRIBUTION_HPP_03_19_2012\n+\n+#if defined(_MSC_VER) || defined(__BORLANDC__) && !defined(__clang__) || defined(__DMC__)\n+#  pragma message (\"Warning: This header is deprecated. Please use: boost/accumulators/statistics/p_square_cumul_dist.hpp\")\n+#elif defined(__GNUC__) || defined(__HP_aCC) || defined(__SUNPRO_CC) || defined(__IBMCPP__) || defined(__BORLANDC__)\n+#  warning \"This header is deprecated. Please use: boost/accumulators/statistics/p_square_cumul_dist.hpp\"\n+#endif\n+\n+#include <boost/accumulators/statistics/p_square_cumul_dist.hpp>\n+\n+#endif"
      },
      {
        "sha": "d87c1b3dbe11e9e813be6e824cdea002194dbbe5",
        "filename": "src/boost/accumulators/statistics/p_square_quantile.hpp",
        "status": "added",
        "additions": 271,
        "deletions": 0,
        "changes": 271,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/p_square_quantile.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/p_square_quantile.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/p_square_quantile.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,271 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// p_square_quantile.hpp\n+//\n+//  Copyright 2005 Daniel Egloff. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_P_SQUARE_QUANTILE_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_P_SQUARE_QUANTILE_HPP_DE_01_01_2006\n+\n+#include <cmath>\n+#include <functional>\n+#include <boost/array.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+#include <boost/accumulators/statistics/parameters/quantile_probability.hpp>\n+#include <boost/serialization/boost_array.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // p_square_quantile_impl\n+    //  single quantile estimation\n+    /**\n+        @brief Single quantile estimation with the \\f$P^2\\f$ algorithm\n+\n+        The \\f$P^2\\f$ algorithm estimates a quantile dynamically without storing samples. Instead of\n+        storing the whole sample cumulative distribution, only five points (markers) are stored. The heights\n+        of these markers are the minimum and the maximum of the samples and the current estimates of the\n+        \\f$(p/2)\\f$-, \\f$p\\f$- and \\f$(1+p)/2\\f$-quantiles. Their positions are equal to the number\n+        of samples that are smaller or equal to the markers. Each time a new samples is recorded, the\n+        positions of the markers are updated and if necessary their heights are adjusted using a piecewise-\n+        parabolic formula.\n+\n+        For further details, see\n+\n+        R. Jain and I. Chlamtac, The P^2 algorithm for dynamic calculation of quantiles and\n+        histograms without storing observations, Communications of the ACM,\n+        Volume 28 (October), Number 10, 1985, p. 1076-1085.\n+\n+        @param quantile_probability\n+    */\n+    template<typename Sample, typename Impl>\n+    struct p_square_quantile_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type float_type;\n+        typedef array<float_type, 5> array_type;\n+        // for boost::result_of\n+        typedef float_type result_type;\n+\n+        template<typename Args>\n+        p_square_quantile_impl(Args const &args)\n+          : p(is_same<Impl, for_median>::value ? float_type(0.5) : args[quantile_probability | float_type(0.5)])\n+          , heights()\n+          , actual_positions()\n+          , desired_positions()\n+          , positions_increments()\n+        {\n+            for(std::size_t i = 0; i < 5; ++i)\n+            {\n+                this->actual_positions[i] = i + float_type(1.);\n+            }\n+\n+            this->desired_positions[0] = float_type(1.);\n+            this->desired_positions[1] = float_type(1.) + float_type(2.) * this->p;\n+            this->desired_positions[2] = float_type(1.) + float_type(4.) * this->p;\n+            this->desired_positions[3] = float_type(3.) + float_type(2.) * this->p;\n+            this->desired_positions[4] = float_type(5.);\n+\n+\n+            this->positions_increments[0] = float_type(0.);\n+            this->positions_increments[1] = this->p / float_type(2.);\n+            this->positions_increments[2] = this->p;\n+            this->positions_increments[3] = (float_type(1.) + this->p) / float_type(2.);\n+            this->positions_increments[4] = float_type(1.);\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            std::size_t cnt = count(args);\n+\n+            // accumulate 5 first samples\n+            if(cnt <= 5)\n+            {\n+                this->heights[cnt - 1] = args[sample];\n+\n+                // complete the initialization of heights by sorting\n+                if(cnt == 5)\n+                {\n+                    std::sort(this->heights.begin(), this->heights.end());\n+                }\n+            }\n+            else\n+            {\n+                std::size_t sample_cell = 1; // k\n+\n+                // find cell k such that heights[k-1] <= args[sample] < heights[k] and adjust extreme values\n+                if (args[sample] < this->heights[0])\n+                {\n+                    this->heights[0] = args[sample];\n+                    sample_cell = 1;\n+                }\n+                else if (this->heights[4] <= args[sample])\n+                {\n+                    this->heights[4] = args[sample];\n+                    sample_cell = 4;\n+                }\n+                else\n+                {\n+                    typedef typename array_type::iterator iterator;\n+                    iterator it = std::upper_bound(\n+                        this->heights.begin()\n+                      , this->heights.end()\n+                      , args[sample]\n+                    );\n+\n+                    sample_cell = std::distance(this->heights.begin(), it);\n+                }\n+\n+                // update positions of markers above sample_cell\n+                for(std::size_t i = sample_cell; i < 5; ++i)\n+                {\n+                    ++this->actual_positions[i];\n+                }\n+\n+                // update desired positions of all markers\n+                for(std::size_t i = 0; i < 5; ++i)\n+                {\n+                    this->desired_positions[i] += this->positions_increments[i];\n+                }\n+\n+                // adjust heights and actual positions of markers 1 to 3 if necessary\n+                for(std::size_t i = 1; i <= 3; ++i)\n+                {\n+                    // offset to desired positions\n+                    float_type d = this->desired_positions[i] - this->actual_positions[i];\n+\n+                    // offset to next position\n+                    float_type dp = this->actual_positions[i + 1] - this->actual_positions[i];\n+\n+                    // offset to previous position\n+                    float_type dm = this->actual_positions[i - 1] - this->actual_positions[i];\n+\n+                    // height ds\n+                    float_type hp = (this->heights[i + 1] - this->heights[i]) / dp;\n+                    float_type hm = (this->heights[i - 1] - this->heights[i]) / dm;\n+\n+                    if((d >= float_type(1.) && dp > float_type(1.)) || (d <= float_type(-1.) && dm < float_type(-1.)))\n+                    {\n+                        short sign_d = static_cast<short>(d / std::abs(d));\n+\n+                        // try adjusting heights[i] using p-squared formula\n+                        float_type h = this->heights[i] + sign_d / (dp - dm) * ((sign_d - dm) * hp\n+                                     + (dp - sign_d) * hm);\n+\n+                        if(this->heights[i - 1] < h && h < this->heights[i + 1])\n+                        {\n+                            this->heights[i] = h;\n+                        }\n+                        else\n+                        {\n+                            // use linear formula\n+                            if(d > float_type(0))\n+                            {\n+                                this->heights[i] += hp;\n+                            }\n+                            if(d < float_type(0))\n+                            {\n+                                this->heights[i] -= hm;\n+                            }\n+                        }\n+                        this->actual_positions[i] += sign_d;\n+                    }\n+                }\n+            }\n+        }\n+\n+        result_type result(dont_care) const\n+        {\n+            return this->heights[2];\n+        }\n+\n+        // make this accumulator serializeable\n+        // TODO: do we need to split to load/save and verify that P did not change?\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & p;\n+            ar & heights;\n+            ar & actual_positions;\n+            ar & desired_positions;\n+            ar & positions_increments;\n+        }\n+\n+    private:\n+        float_type p;                    // the quantile probability p\n+        array_type heights;              // q_i\n+        array_type actual_positions;     // n_i\n+        array_type desired_positions;    // n'_i\n+        array_type positions_increments; // dn'_i\n+    };\n+\n+} // namespace detail\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::p_square_quantile\n+//\n+namespace tag\n+{\n+    struct p_square_quantile\n+      : depends_on<count>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::p_square_quantile_impl<mpl::_1, regular> impl;\n+    };\n+    struct p_square_quantile_for_median\n+      : depends_on<count>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::p_square_quantile_impl<mpl::_1, for_median> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::p_square_quantile\n+// extract::p_square_quantile_for_median\n+//\n+namespace extract\n+{\n+    extractor<tag::p_square_quantile> const p_square_quantile = {};\n+    extractor<tag::p_square_quantile_for_median> const p_square_quantile_for_median = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(p_square_quantile)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(p_square_quantile_for_median)\n+}\n+\n+using extract::p_square_quantile;\n+using extract::p_square_quantile_for_median;\n+\n+// So that p_square_quantile can be automatically substituted with\n+// weighted_p_square_quantile when the weight parameter is non-void\n+template<>\n+struct as_weighted_feature<tag::p_square_quantile>\n+{\n+    typedef tag::weighted_p_square_quantile type;\n+};\n+\n+template<>\n+struct feature_of<tag::weighted_p_square_quantile>\n+  : feature_of<tag::p_square_quantile>\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "e8792642ec43c520790e3e1417d139baf992a13b",
        "filename": "src/boost/accumulators/statistics/parameters/quantile_probability.hpp",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/parameters/quantile_probability.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/parameters/quantile_probability.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/parameters/quantile_probability.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,23 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// quantile_probability.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_PARAMETERS_QUANTILE_PROBABILITY_HPP_EAN_03_11_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_PARAMETERS_QUANTILE_PROBABILITY_HPP_EAN_03_11_2005\n+\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/accumulators/accumulators_fwd.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+BOOST_PARAMETER_KEYWORD(tag, quantile_probability)\n+\n+BOOST_ACCUMULATORS_IGNORE_GLOBAL(quantile_probability)\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "de73c658aa6ee9db37474284aab1f2296e45e9a1",
        "filename": "src/boost/accumulators/statistics/peaks_over_threshold.hpp",
        "status": "added",
        "additions": 434,
        "deletions": 0,
        "changes": 434,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/peaks_over_threshold.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/peaks_over_threshold.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/peaks_over_threshold.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,434 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// peaks_over_threshold.hpp\n+//\n+//  Copyright 2006 Daniel Egloff, Olivier Gygi. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_PEAKS_OVER_THRESHOLD_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_PEAKS_OVER_THRESHOLD_HPP_DE_01_01_2006\n+\n+#include <vector>\n+#include <limits>\n+#include <numeric>\n+#include <functional>\n+#include <boost/config/no_tr1/cmath.hpp> // pow\n+#include <sstream> // stringstream\n+#include <stdexcept> // runtime_error\n+#include <boost/throw_exception.hpp>\n+#include <boost/range.hpp>\n+#include <boost/mpl/if.hpp>\n+#include <boost/mpl/int.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/tuple/tuple.hpp>\n+#include <boost/accumulators/accumulators_fwd.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/parameters/quantile_probability.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+#include <boost/accumulators/statistics/tail.hpp>\n+\n+#ifdef _MSC_VER\n+# pragma warning(push)\n+# pragma warning(disable: 4127) // conditional expression is constant\n+#endif\n+\n+namespace boost { namespace accumulators\n+{\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// threshold_probability and threshold named parameters\n+//\n+BOOST_PARAMETER_NESTED_KEYWORD(tag, pot_threshold_value, threshold_value)\n+BOOST_PARAMETER_NESTED_KEYWORD(tag, pot_threshold_probability, threshold_probability)\n+\n+BOOST_ACCUMULATORS_IGNORE_GLOBAL(pot_threshold_value)\n+BOOST_ACCUMULATORS_IGNORE_GLOBAL(pot_threshold_probability)\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // peaks_over_threshold_impl\n+    //  works with an explicit threshold value and does not depend on order statistics\n+    /**\n+        @brief Peaks over Threshold Method for Quantile and Tail Mean Estimation\n+\n+        According to the theorem of Pickands-Balkema-de Haan, the distribution function \\f$F_u(x)\\f$ of\n+        the excesses \\f$x\\f$ over some sufficiently high threshold \\f$u\\f$ of a distribution function \\f$F(x)\\f$\n+        may be approximated by a generalized Pareto distribution\n+        \\f[\n+            G_{\\xi,\\beta}(x) =\n+            \\left\\{\n+            \\begin{array}{ll}\n+                \\beta^{-1}\\left(1+\\frac{\\xi x}{\\beta}\\right)^{-1/\\xi-1} & \\textrm{if }\\xi\\neq0\\\\\n+                \\beta^{-1}\\exp\\left(-\\frac{x}{\\beta}\\right) & \\textrm{if }\\xi=0,\n+            \\end{array}\n+            \\right.\n+        \\f]\n+        with suitable parameters \\f$\\xi\\f$ and \\f$\\beta\\f$ that can be estimated, e.g., with the method of moments, cf.\n+        Hosking and Wallis (1987),\n+        \\f[\n+            \\begin{array}{lll}\n+            \\hat{\\xi} & = & \\frac{1}{2}\\left[1-\\frac{(\\hat{\\mu}-u)^2}{\\hat{\\sigma}^2}\\right]\\\\\n+            \\hat{\\beta} & = & \\frac{\\hat{\\mu}-u}{2}\\left[\\frac{(\\hat{\\mu}-u)^2}{\\hat{\\sigma}^2}+1\\right],\n+            \\end{array}\n+        \\f]\n+        \\f$\\hat{\\mu}\\f$ and \\f$\\hat{\\sigma}^2\\f$ being the empirical mean and variance of the samples over\n+        the threshold \\f$u\\f$. Equivalently, the distribution function\n+        \\f$F_u(x-u)\\f$ of the exceedances \\f$x-u\\f$ can be approximated by\n+        \\f$G_{\\xi,\\beta}(x-u)=G_{\\xi,\\beta,u}(x)\\f$. Since for \\f$x\\geq u\\f$ the distribution function \\f$F(x)\\f$\n+        can be written as\n+        \\f[\n+            F(x) = [1 - \\P(X \\leq u)]F_u(x - u) + \\P(X \\leq u)\n+        \\f]\n+        and the probability \\f$\\P(X \\leq u)\\f$ can be approximated by the empirical distribution function\n+        \\f$F_n(u)\\f$ evaluated at \\f$u\\f$, an estimator of \\f$F(x)\\f$ is given by\n+        \\f[\n+            \\widehat{F}(x) = [1 - F_n(u)]G_{\\xi,\\beta,u}(x) + F_n(u).\n+        \\f]\n+        It can be shown that \\f$\\widehat{F}(x)\\f$ is a generalized\n+        Pareto distribution \\f$G_{\\xi,\\bar{\\beta},\\bar{u}}(x)\\f$ with \\f$\\bar{\\beta}=\\beta[1-F_n(u)]^{\\xi}\\f$\n+        and \\f$\\bar{u}=u-\\bar{\\beta}\\left\\{[1-F_n(u)]^{-\\xi}-1\\right\\}/\\xi\\f$. By inverting \\f$\\widehat{F}(x)\\f$,\n+        one obtains an estimator for the \\f$\\alpha\\f$-quantile,\n+        \\f[\n+            \\hat{q}_{\\alpha} = \\bar{u} + \\frac{\\bar{\\beta}}{\\xi}\\left[(1-\\alpha)^{-\\xi}-1\\right],\n+        \\f]\n+        and similarly an estimator for the (coherent) tail mean,\n+        \\f[\n+            \\widehat{CTM}_{\\alpha} = \\hat{q}_{\\alpha} - \\frac{\\bar{\\beta}}{\\xi-1}(1-\\alpha)^{-\\xi},\n+        \\f]\n+        cf. McNeil and Frey (2000).\n+\n+        Note that in case extreme values of the left tail are fitted, the distribution is mirrored with respect to the\n+        \\f$y\\f$ axis such that the left tail can be treated as a right tail. The computed fit parameters thus define\n+        the Pareto distribution that fits the mirrored left tail. When quantities like a quantile or a tail mean are\n+        computed using the fit parameters obtained from the mirrored data, the result is mirrored back, yielding the\n+        correct result.\n+\n+        For further details, see\n+\n+        J. R. M. Hosking and J. R. Wallis, Parameter and quantile estimation for the generalized Pareto distribution,\n+        Technometrics, Volume 29, 1987, p. 339-349\n+\n+        A. J. McNeil and R. Frey, Estimation of Tail-Related Risk Measures for Heteroscedastic Financial Time Series:\n+        an Extreme Value Approach, Journal of Empirical Finance, Volume 7, 2000, p. 271-300\n+\n+        @param quantile_probability\n+        @param pot_threshold_value\n+    */\n+    template<typename Sample, typename LeftRight>\n+    struct peaks_over_threshold_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type float_type;\n+        // for boost::result_of\n+        typedef boost::tuple<float_type, float_type, float_type> result_type;\n+        // for left tail fitting, mirror the extreme values\n+        typedef mpl::int_<is_same<LeftRight, left>::value ? -1 : 1> sign;\n+\n+        template<typename Args>\n+        peaks_over_threshold_impl(Args const &args)\n+          : Nu_(0)\n+          , mu_(sign::value * numeric::fdiv(args[sample | Sample()], (std::size_t)1))\n+          , sigma2_(numeric::fdiv(args[sample | Sample()], (std::size_t)1))\n+          , threshold_(sign::value * args[pot_threshold_value])\n+          , fit_parameters_(boost::make_tuple(0., 0., 0.))\n+          , is_dirty_(true)\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            this->is_dirty_ = true;\n+\n+            if (sign::value * args[sample] > this->threshold_)\n+            {\n+                this->mu_ += args[sample];\n+                this->sigma2_ += args[sample] * args[sample];\n+                ++this->Nu_;\n+            }\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            if (this->is_dirty_)\n+            {\n+                this->is_dirty_ = false;\n+\n+                std::size_t cnt = count(args);\n+\n+                this->mu_ = sign::value * numeric::fdiv(this->mu_, this->Nu_);\n+                this->sigma2_ = numeric::fdiv(this->sigma2_, this->Nu_);\n+                this->sigma2_ -= this->mu_ * this->mu_;\n+\n+                float_type threshold_probability = numeric::fdiv(cnt - this->Nu_, cnt);\n+\n+                float_type tmp = numeric::fdiv(( this->mu_ - this->threshold_ )*( this->mu_ - this->threshold_ ), this->sigma2_);\n+                float_type xi_hat = 0.5 * ( 1. - tmp );\n+                float_type beta_hat = 0.5 * ( this->mu_ - this->threshold_ ) * ( 1. + tmp );\n+                float_type beta_bar = beta_hat * std::pow(1. - threshold_probability, xi_hat);\n+                float_type u_bar = this->threshold_ - beta_bar * ( std::pow(1. - threshold_probability, -xi_hat) - 1.)/xi_hat;\n+                this->fit_parameters_ = boost::make_tuple(u_bar, beta_bar, xi_hat);\n+            }\n+\n+            return this->fit_parameters_;\n+        }\n+\n+        // make this accumulator serializeable\n+        // TODO: do we need to split to load/save and verify that threshold did not change?\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & Nu_;\n+            ar & mu_;\n+            ar & sigma2_;\n+            ar & threshold_;\n+            ar & get<0>(fit_parameters_);\n+            ar & get<1>(fit_parameters_);\n+            ar & get<2>(fit_parameters_);\n+            ar & is_dirty_;\n+        }\n+\n+    private:\n+        std::size_t Nu_;                     // number of samples larger than threshold\n+        mutable float_type mu_;              // mean of Nu_ largest samples\n+        mutable float_type sigma2_;          // variance of Nu_ largest samples\n+        float_type threshold_;\n+        mutable result_type fit_parameters_; // boost::tuple that stores fit parameters\n+        mutable bool is_dirty_;\n+    };\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // peaks_over_threshold_prob_impl\n+    //  determines threshold from a given threshold probability using order statistics\n+    /**\n+        @brief Peaks over Threshold Method for Quantile and Tail Mean Estimation\n+\n+        @sa peaks_over_threshold_impl\n+\n+        @param quantile_probability\n+        @param pot_threshold_probability\n+    */\n+    template<typename Sample, typename LeftRight>\n+    struct peaks_over_threshold_prob_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type float_type;\n+        // for boost::result_of\n+        typedef boost::tuple<float_type, float_type, float_type> result_type;\n+        // for left tail fitting, mirror the extreme values\n+        typedef mpl::int_<is_same<LeftRight, left>::value ? -1 : 1> sign;\n+\n+        template<typename Args>\n+        peaks_over_threshold_prob_impl(Args const &args)\n+          : mu_(sign::value * numeric::fdiv(args[sample | Sample()], (std::size_t)1))\n+          , sigma2_(numeric::fdiv(args[sample | Sample()], (std::size_t)1))\n+          , threshold_probability_(args[pot_threshold_probability])\n+          , fit_parameters_(boost::make_tuple(0., 0., 0.))\n+          , is_dirty_(true)\n+        {\n+        }\n+\n+        void operator ()(dont_care)\n+        {\n+            this->is_dirty_ = true;\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            if (this->is_dirty_)\n+            {\n+                this->is_dirty_ = false;\n+\n+                std::size_t cnt = count(args);\n+\n+                // the n'th cached sample provides an approximate threshold value u\n+                std::size_t n = static_cast<std::size_t>(\n+                    std::ceil(\n+                        cnt * ( ( is_same<LeftRight, left>::value ) ? this->threshold_probability_ : 1. - this->threshold_probability_ )\n+                    )\n+                );\n+\n+                // If n is in a valid range, return result, otherwise return NaN or throw exception\n+                if ( n >= static_cast<std::size_t>(tail(args).size()))\n+                {\n+                    if (std::numeric_limits<float_type>::has_quiet_NaN)\n+                    {\n+                        return boost::make_tuple(\n+                            std::numeric_limits<float_type>::quiet_NaN()\n+                          , std::numeric_limits<float_type>::quiet_NaN()\n+                          , std::numeric_limits<float_type>::quiet_NaN()\n+                        );\n+                    }\n+                    else\n+                    {\n+                        std::ostringstream msg;\n+                        msg << \"index n = \" << n << \" is not in valid range [0, \" << tail(args).size() << \")\";\n+                        boost::throw_exception(std::runtime_error(msg.str()));\n+                        return boost::make_tuple(Sample(0), Sample(0), Sample(0));\n+                    }\n+                }\n+                else\n+                {\n+                    float_type u = *(tail(args).begin() + n - 1) * sign::value;\n+\n+                    // compute mean and variance of samples above/under threshold value u\n+                    for (std::size_t i = 0; i < n; ++i)\n+                    {\n+                        mu_ += *(tail(args).begin() + i);\n+                        sigma2_ += *(tail(args).begin() + i) * (*(tail(args).begin() + i));\n+                    }\n+\n+                    this->mu_ = sign::value * numeric::fdiv(this->mu_, n);\n+                    this->sigma2_ = numeric::fdiv(this->sigma2_, n);\n+                    this->sigma2_ -= this->mu_ * this->mu_;\n+\n+                    if (is_same<LeftRight, left>::value)\n+                        this->threshold_probability_ = 1. - this->threshold_probability_;\n+\n+                    float_type tmp = numeric::fdiv(( this->mu_ - u )*( this->mu_ - u ), this->sigma2_);\n+                    float_type xi_hat = 0.5 * ( 1. - tmp );\n+                    float_type beta_hat = 0.5 * ( this->mu_ - u ) * ( 1. + tmp );\n+                    float_type beta_bar = beta_hat * std::pow(1. - threshold_probability_, xi_hat);\n+                    float_type u_bar = u - beta_bar * ( std::pow(1. - threshold_probability_, -xi_hat) - 1.)/xi_hat;\n+                    this->fit_parameters_ = boost::make_tuple(u_bar, beta_bar, xi_hat);\n+                }\n+            }\n+\n+            return this->fit_parameters_;\n+        }\n+\n+        // make this accumulator serializeable\n+        // TODO: do we need to split to load/save and verify that threshold did not change?\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & mu_;\n+            ar & sigma2_;\n+            ar & threshold_probability_;\n+            ar & get<0>(fit_parameters_);\n+            ar & get<1>(fit_parameters_);\n+            ar & get<2>(fit_parameters_);\n+            ar & is_dirty_;\n+        }\n+\n+    private:\n+        mutable float_type mu_;                     // mean of samples above threshold u\n+        mutable float_type sigma2_;                 // variance of samples above threshold u\n+        mutable float_type threshold_probability_;\n+        mutable result_type fit_parameters_;        // boost::tuple that stores fit parameters\n+        mutable bool is_dirty_;\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::peaks_over_threshold\n+//\n+namespace tag\n+{\n+    template<typename LeftRight>\n+    struct peaks_over_threshold\n+      : depends_on<count>\n+      , pot_threshold_value\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::peaks_over_threshold_impl<mpl::_1, LeftRight> impl;\n+    };\n+\n+    template<typename LeftRight>\n+    struct peaks_over_threshold_prob\n+      : depends_on<count, tail<LeftRight> >\n+      , pot_threshold_probability\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::peaks_over_threshold_prob_impl<mpl::_1, LeftRight> impl;\n+    };\n+\n+    struct abstract_peaks_over_threshold\n+      : depends_on<>\n+    {\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::peaks_over_threshold\n+//\n+namespace extract\n+{\n+    extractor<tag::abstract_peaks_over_threshold> const peaks_over_threshold = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(peaks_over_threshold)\n+}\n+\n+using extract::peaks_over_threshold;\n+\n+// peaks_over_threshold<LeftRight>(with_threshold_value) -> peaks_over_threshold<LeftRight>\n+template<typename LeftRight>\n+struct as_feature<tag::peaks_over_threshold<LeftRight>(with_threshold_value)>\n+{\n+    typedef tag::peaks_over_threshold<LeftRight> type;\n+};\n+\n+// peaks_over_threshold<LeftRight>(with_threshold_probability) -> peaks_over_threshold_prob<LeftRight>\n+template<typename LeftRight>\n+struct as_feature<tag::peaks_over_threshold<LeftRight>(with_threshold_probability)>\n+{\n+    typedef tag::peaks_over_threshold_prob<LeftRight> type;\n+};\n+\n+template<typename LeftRight>\n+struct feature_of<tag::peaks_over_threshold<LeftRight> >\n+  : feature_of<tag::abstract_peaks_over_threshold>\n+{\n+};\n+\n+template<typename LeftRight>\n+struct feature_of<tag::peaks_over_threshold_prob<LeftRight> >\n+  : feature_of<tag::abstract_peaks_over_threshold>\n+{\n+};\n+\n+// So that peaks_over_threshold can be automatically substituted\n+// with weighted_peaks_over_threshold when the weight parameter is non-void.\n+template<typename LeftRight>\n+struct as_weighted_feature<tag::peaks_over_threshold<LeftRight> >\n+{\n+    typedef tag::weighted_peaks_over_threshold<LeftRight> type;\n+};\n+\n+template<typename LeftRight>\n+struct feature_of<tag::weighted_peaks_over_threshold<LeftRight> >\n+  : feature_of<tag::peaks_over_threshold<LeftRight> >\n+{};\n+\n+// So that peaks_over_threshold_prob can be automatically substituted\n+// with weighted_peaks_over_threshold_prob when the weight parameter is non-void.\n+template<typename LeftRight>\n+struct as_weighted_feature<tag::peaks_over_threshold_prob<LeftRight> >\n+{\n+    typedef tag::weighted_peaks_over_threshold_prob<LeftRight> type;\n+};\n+\n+template<typename LeftRight>\n+struct feature_of<tag::weighted_peaks_over_threshold_prob<LeftRight> >\n+  : feature_of<tag::peaks_over_threshold_prob<LeftRight> >\n+{};\n+\n+}} // namespace boost::accumulators\n+\n+#ifdef _MSC_VER\n+# pragma warning(pop)\n+#endif\n+\n+#endif"
      },
      {
        "sha": "ecd49f2cb2fb3044a349e2b8ae80de91308f8eb2",
        "filename": "src/boost/accumulators/statistics/pot_quantile.hpp",
        "status": "added",
        "additions": 212,
        "deletions": 0,
        "changes": 212,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/pot_quantile.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/pot_quantile.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/pot_quantile.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,212 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// pot_quantile.hpp\n+//\n+//  Copyright 2006 Daniel Egloff, Olivier Gygi. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_POT_QUANTILE_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_POT_QUANTILE_HPP_DE_01_01_2006\n+\n+#include <vector>\n+#include <limits>\n+#include <numeric>\n+#include <functional>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/tuple/tuple.hpp>\n+#include <boost/mpl/if.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/tail.hpp>\n+#include <boost/accumulators/statistics/peaks_over_threshold.hpp>\n+#include <boost/accumulators/statistics/weighted_peaks_over_threshold.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // pot_quantile_impl\n+    //\n+    /**\n+        @brief Quantile Estimation based on Peaks over Threshold Method (for both left and right tails)\n+\n+        Computes an estimate\n+        \\f[\n+            \\hat{q}_{\\alpha} = \\bar{u} + \\frac{\\bar{\\beta}}{\\xi}\\left[(1-\\alpha)^{-\\xi}-1\\right]\n+        \\f]\n+        for a right or left extreme quantile, \\f$\\bar[u]\\f$, \\f$\\bar{\\beta}\\f$ and \\f$\\xi\\f$ being the parameters of the\n+        generalized Pareto distribution that approximates the right tail of the distribution (or the mirrored left tail,\n+        in case the left tail is used). In the latter case, the result is mirrored back, yielding the correct result.\n+    */\n+    template<typename Sample, typename Impl, typename LeftRight>\n+    struct pot_quantile_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type float_type;\n+        // for boost::result_of\n+        typedef float_type result_type;\n+\n+        pot_quantile_impl(dont_care)\n+          : sign_((is_same<LeftRight, left>::value) ? -1 : 1)\n+        {\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            typedef\n+                typename mpl::if_<\n+                    is_same<Impl, weighted>\n+                  , tag::weighted_peaks_over_threshold<LeftRight>\n+                  , tag::peaks_over_threshold<LeftRight>\n+                >::type\n+            peaks_over_threshold_tag;\n+\n+            extractor<peaks_over_threshold_tag> const some_peaks_over_threshold = {};\n+\n+            float_type u_bar    = some_peaks_over_threshold(args).template get<0>();\n+            float_type beta_bar = some_peaks_over_threshold(args).template get<1>();\n+            float_type xi_hat   = some_peaks_over_threshold(args).template get<2>();\n+\n+            return this->sign_ * (u_bar + beta_bar/xi_hat * ( std::pow(\n+                    is_same<LeftRight, left>::value ? args[quantile_probability] : 1. - args[quantile_probability]\n+                , -xi_hat\n+              ) - 1.));\n+        }\n+    \n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & sign_;\n+        }\n+\n+    private:\n+        short sign_; // if the fit parameters from the mirrored left tail extreme values are used, mirror back the result\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::pot_quantile<>\n+// tag::pot_quantile_prob<>\n+// tag::weighted_pot_quantile<>\n+// tag::weighted_pot_quantile_prob<>\n+//\n+namespace tag\n+{\n+    template<typename LeftRight>\n+    struct pot_quantile\n+      : depends_on<peaks_over_threshold<LeftRight> >\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::pot_quantile_impl<mpl::_1, unweighted, LeftRight> impl;\n+    };\n+    template<typename LeftRight>\n+    struct pot_quantile_prob\n+      : depends_on<peaks_over_threshold_prob<LeftRight> >\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::pot_quantile_impl<mpl::_1, unweighted, LeftRight> impl;\n+    };\n+    template<typename LeftRight>\n+    struct weighted_pot_quantile\n+      : depends_on<weighted_peaks_over_threshold<LeftRight> >\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::pot_quantile_impl<mpl::_1, weighted, LeftRight> impl;\n+    };\n+    template<typename LeftRight>\n+    struct weighted_pot_quantile_prob\n+      : depends_on<weighted_peaks_over_threshold_prob<LeftRight> >\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::pot_quantile_impl<mpl::_1, weighted, LeftRight> impl;\n+    };\n+}\n+\n+// pot_quantile<LeftRight>(with_threshold_value) -> pot_quantile<LeftRight>\n+template<typename LeftRight>\n+struct as_feature<tag::pot_quantile<LeftRight>(with_threshold_value)>\n+{\n+    typedef tag::pot_quantile<LeftRight> type;\n+};\n+\n+// pot_quantile<LeftRight>(with_threshold_probability) -> pot_quantile_prob<LeftRight>\n+template<typename LeftRight>\n+struct as_feature<tag::pot_quantile<LeftRight>(with_threshold_probability)>\n+{\n+    typedef tag::pot_quantile_prob<LeftRight> type;\n+};\n+\n+// weighted_pot_quantile<LeftRight>(with_threshold_value) -> weighted_pot_quantile<LeftRight>\n+template<typename LeftRight>\n+struct as_feature<tag::weighted_pot_quantile<LeftRight>(with_threshold_value)>\n+{\n+    typedef tag::weighted_pot_quantile<LeftRight> type;\n+};\n+\n+// weighted_pot_quantile<LeftRight>(with_threshold_probability) -> weighted_pot_quantile_prob<LeftRight>\n+template<typename LeftRight>\n+struct as_feature<tag::weighted_pot_quantile<LeftRight>(with_threshold_probability)>\n+{\n+    typedef tag::weighted_pot_quantile_prob<LeftRight> type;\n+};\n+\n+// for the purposes of feature-based dependency resolution,\n+// pot_quantile<LeftRight> and pot_quantile_prob<LeftRight> provide\n+// the same feature as quantile\n+template<typename LeftRight>\n+struct feature_of<tag::pot_quantile<LeftRight> >\n+  : feature_of<tag::quantile>\n+{\n+};\n+\n+template<typename LeftRight>\n+struct feature_of<tag::pot_quantile_prob<LeftRight> >\n+  : feature_of<tag::quantile>\n+{\n+};\n+\n+// So that pot_quantile can be automatically substituted\n+// with weighted_pot_quantile when the weight parameter is non-void.\n+template<typename LeftRight>\n+struct as_weighted_feature<tag::pot_quantile<LeftRight> >\n+{\n+    typedef tag::weighted_pot_quantile<LeftRight> type;\n+};\n+\n+template<typename LeftRight>\n+struct feature_of<tag::weighted_pot_quantile<LeftRight> >\n+  : feature_of<tag::pot_quantile<LeftRight> >\n+{\n+};\n+\n+// So that pot_quantile_prob can be automatically substituted\n+// with weighted_pot_quantile_prob when the weight parameter is non-void.\n+template<typename LeftRight>\n+struct as_weighted_feature<tag::pot_quantile_prob<LeftRight> >\n+{\n+    typedef tag::weighted_pot_quantile_prob<LeftRight> type;\n+};\n+\n+template<typename LeftRight>\n+struct feature_of<tag::weighted_pot_quantile_prob<LeftRight> >\n+  : feature_of<tag::pot_quantile_prob<LeftRight> >\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "96f4dc1f27f995656b256e050537cdccf70d4c62",
        "filename": "src/boost/accumulators/statistics/pot_tail_mean.hpp",
        "status": "added",
        "additions": 219,
        "deletions": 0,
        "changes": 219,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/pot_tail_mean.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/pot_tail_mean.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/pot_tail_mean.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,219 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// pot_tail_mean.hpp\n+//\n+//  Copyright 2006 Daniel Egloff, Olivier Gygi. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_POT_TAIL_MEAN_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_POT_TAIL_MEAN_HPP_DE_01_01_2006\n+\n+#include <vector>\n+#include <limits>\n+#include <numeric>\n+#include <functional>\n+#include <boost/range.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/tuple/tuple.hpp>\n+#include <boost/mpl/if.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/peaks_over_threshold.hpp>\n+#include <boost/accumulators/statistics/weighted_peaks_over_threshold.hpp>\n+#include <boost/accumulators/statistics/pot_quantile.hpp>\n+#include <boost/accumulators/statistics/tail_mean.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // pot_tail_mean_impl\n+    //\n+    /**\n+        @brief Estimation of the (coherent) tail mean based on the peaks over threshold method (for both left and right tails)\n+\n+        Computes an estimate for the (coherent) tail mean\n+        \\f[\n+            \\widehat{CTM}_{\\alpha} = \\hat{q}_{\\alpha} - \\frac{\\bar{\\beta}}{\\xi-1}(1-\\alpha)^{-\\xi},\n+        \\f]\n+        where \\f$\\bar[u]\\f$, \\f$\\bar{\\beta}\\f$ and \\f$\\xi\\f$ are the parameters of the\n+        generalized Pareto distribution that approximates the right tail of the distribution (or the\n+        mirrored left tail, in case the left tail is used). In the latter case, the result is mirrored\n+        back, yielding the correct result.\n+    */\n+    template<typename Sample, typename Impl, typename LeftRight>\n+    struct pot_tail_mean_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type float_type;\n+        // for boost::result_of\n+        typedef float_type result_type;\n+\n+        pot_tail_mean_impl(dont_care)\n+          : sign_((is_same<LeftRight, left>::value) ? -1 : 1)\n+        {\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            typedef\n+                typename mpl::if_<\n+                    is_same<Impl, weighted>\n+                  , tag::weighted_peaks_over_threshold<LeftRight>\n+                  , tag::peaks_over_threshold<LeftRight>\n+                >::type\n+            peaks_over_threshold_tag;\n+\n+            typedef\n+                typename mpl::if_<\n+                    is_same<Impl, weighted>\n+                  , tag::weighted_pot_quantile<LeftRight>\n+                  , tag::pot_quantile<LeftRight>\n+                >::type\n+            pot_quantile_tag;\n+\n+            extractor<peaks_over_threshold_tag> const some_peaks_over_threshold = {};\n+            extractor<pot_quantile_tag> const some_pot_quantile = {};\n+\n+            float_type beta_bar = some_peaks_over_threshold(args).template get<1>();\n+            float_type xi_hat   = some_peaks_over_threshold(args).template get<2>();\n+\n+            return some_pot_quantile(args) - this->sign_ * beta_bar/( xi_hat - 1. ) * std::pow(\n+                is_same<LeftRight, left>::value ? args[quantile_probability] : 1. - args[quantile_probability]\n+              , -xi_hat);\n+        }\n+    \n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & sign_;\n+        }\n+\n+    private:\n+        short sign_; // if the fit parameters from the mirrored left tail extreme values are used, mirror back the result\n+    };\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::pot_tail_mean\n+// tag::pot_tail_mean_prob\n+//\n+namespace tag\n+{\n+    template<typename LeftRight>\n+    struct pot_tail_mean\n+      : depends_on<peaks_over_threshold<LeftRight>, pot_quantile<LeftRight> >\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::pot_tail_mean_impl<mpl::_1, unweighted, LeftRight> impl;\n+    };\n+    template<typename LeftRight>\n+    struct pot_tail_mean_prob\n+      : depends_on<peaks_over_threshold_prob<LeftRight>, pot_quantile_prob<LeftRight> >\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::pot_tail_mean_impl<mpl::_1, unweighted, LeftRight> impl;\n+    };\n+    template<typename LeftRight>\n+    struct weighted_pot_tail_mean\n+      : depends_on<weighted_peaks_over_threshold<LeftRight>, weighted_pot_quantile<LeftRight> >\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::pot_tail_mean_impl<mpl::_1, weighted, LeftRight> impl;\n+    };\n+    template<typename LeftRight>\n+    struct weighted_pot_tail_mean_prob\n+      : depends_on<weighted_peaks_over_threshold_prob<LeftRight>, weighted_pot_quantile_prob<LeftRight> >\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::pot_tail_mean_impl<mpl::_1, weighted, LeftRight> impl;\n+    };\n+}\n+\n+// pot_tail_mean<LeftRight>(with_threshold_value) -> pot_tail_mean<LeftRight>\n+template<typename LeftRight>\n+struct as_feature<tag::pot_tail_mean<LeftRight>(with_threshold_value)>\n+{\n+    typedef tag::pot_tail_mean<LeftRight> type;\n+};\n+\n+// pot_tail_mean<LeftRight>(with_threshold_probability) -> pot_tail_mean_prob<LeftRight>\n+template<typename LeftRight>\n+struct as_feature<tag::pot_tail_mean<LeftRight>(with_threshold_probability)>\n+{\n+    typedef tag::pot_tail_mean_prob<LeftRight> type;\n+};\n+\n+// weighted_pot_tail_mean<LeftRight>(with_threshold_value) -> weighted_pot_tail_mean<LeftRight>\n+template<typename LeftRight>\n+struct as_feature<tag::weighted_pot_tail_mean<LeftRight>(with_threshold_value)>\n+{\n+    typedef tag::weighted_pot_tail_mean<LeftRight> type;\n+};\n+\n+// weighted_pot_tail_mean<LeftRight>(with_threshold_probability) -> weighted_pot_tail_mean_prob<LeftRight>\n+template<typename LeftRight>\n+struct as_feature<tag::weighted_pot_tail_mean<LeftRight>(with_threshold_probability)>\n+{\n+    typedef tag::weighted_pot_tail_mean_prob<LeftRight> type;\n+};\n+\n+// for the purposes of feature-based dependency resolution,\n+// pot_tail_mean<LeftRight> and pot_tail_mean_prob<LeftRight> provide\n+// the same feature as tail_mean\n+template<typename LeftRight>\n+struct feature_of<tag::pot_tail_mean<LeftRight> >\n+  : feature_of<tag::tail_mean>\n+{\n+};\n+\n+template<typename LeftRight>\n+struct feature_of<tag::pot_tail_mean_prob<LeftRight> >\n+  : feature_of<tag::tail_mean>\n+{\n+};\n+\n+// So that pot_tail_mean can be automatically substituted\n+// with weighted_pot_tail_mean when the weight parameter is non-void.\n+template<typename LeftRight>\n+struct as_weighted_feature<tag::pot_tail_mean<LeftRight> >\n+{\n+    typedef tag::weighted_pot_tail_mean<LeftRight> type;\n+};\n+\n+template<typename LeftRight>\n+struct feature_of<tag::weighted_pot_tail_mean<LeftRight> >\n+  : feature_of<tag::pot_tail_mean<LeftRight> >\n+{\n+};\n+\n+// So that pot_tail_mean_prob can be automatically substituted\n+// with weighted_pot_tail_mean_prob when the weight parameter is non-void.\n+template<typename LeftRight>\n+struct as_weighted_feature<tag::pot_tail_mean_prob<LeftRight> >\n+{\n+    typedef tag::weighted_pot_tail_mean_prob<LeftRight> type;\n+};\n+\n+template<typename LeftRight>\n+struct feature_of<tag::weighted_pot_tail_mean_prob<LeftRight> >\n+  : feature_of<tag::pot_tail_mean_prob<LeftRight> >\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "803f1b7754fb0f500eb7d3432e955454fa23bc68",
        "filename": "src/boost/accumulators/statistics/rolling_count.hpp",
        "status": "added",
        "additions": 84,
        "deletions": 0,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/rolling_count.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/rolling_count.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/rolling_count.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,84 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// rolling_count.hpp\n+//\n+// Copyright 2008 Eric Niebler. Distributed under the Boost\n+// Software License, Version 1.0. (See accompanying file\n+// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_ROLLING_COUNT_HPP_EAN_26_12_2008\n+#define BOOST_ACCUMULATORS_STATISTICS_ROLLING_COUNT_HPP_EAN_26_12_2008\n+\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/rolling_window.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // rolling_count_impl\n+    //    returns the count of elements in the rolling window\n+    template<typename Sample>\n+    struct rolling_count_impl\n+      : accumulator_base\n+    {\n+        typedef std::size_t result_type;\n+\n+        rolling_count_impl(dont_care)\n+        {}\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            return static_cast<std::size_t>(rolling_window_plus1(args).size()) - is_rolling_window_plus1_full(args);\n+        }\n+        \n+        // serialization is done by accumulators it depends on\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version) {}\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::rolling_count\n+//\n+namespace tag\n+{\n+    struct rolling_count\n+      : depends_on< rolling_window_plus1 >\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::rolling_count_impl< mpl::_1 > impl;\n+\n+        #ifdef BOOST_ACCUMULATORS_DOXYGEN_INVOKED\n+        /// tag::rolling_window::window_size named parameter\n+        static boost::parameter::keyword<tag::rolling_window_size> const window_size;\n+        #endif\n+    };\n+} // namespace tag\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::rolling_count\n+//\n+namespace extract\n+{\n+    extractor<tag::rolling_count> const rolling_count = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(rolling_count)\n+}\n+\n+using extract::rolling_count;\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "bd5494c3e196ab2007f4602eb9be8fc2702114f1",
        "filename": "src/boost/accumulators/statistics/rolling_mean.hpp",
        "status": "added",
        "additions": 196,
        "deletions": 0,
        "changes": 196,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/rolling_mean.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/rolling_mean.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/rolling_mean.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,196 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// rolling_mean.hpp\n+// Copyright (C) 2008 Eric Niebler.\n+// Copyright (C) 2012 Pieter Bastiaan Ober (Integricom).\n+// Distributed under the Boost Software License, Version 1.0.\n+// (See accompanying file LICENSE_1_0.txt or copy at\n+// http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_ROLLING_MEAN_HPP_EAN_26_12_2008\n+#define BOOST_ACCUMULATORS_STATISTICS_ROLLING_MEAN_HPP_EAN_26_12_2008\n+\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/rolling_sum.hpp>\n+#include <boost/accumulators/statistics/rolling_count.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+   namespace impl\n+   {\n+      ///////////////////////////////////////////////////////////////////////////////\n+      // lazy_rolling_mean_impl\n+      //    returns the mean over the rolling window and is calculated only\n+      //    when the result is requested\n+      template<typename Sample>\n+      struct lazy_rolling_mean_impl\n+         : accumulator_base\n+      {\n+         // for boost::result_of\n+         typedef typename numeric::functional::fdiv<Sample, std::size_t, void, void>::result_type result_type;\n+\n+         lazy_rolling_mean_impl(dont_care)\n+         {\n+         }\n+\n+         template<typename Args>\n+         result_type result(Args const &args) const\n+         {\n+            return numeric::fdiv(rolling_sum(args), rolling_count(args));\n+         }\n+        \n+         // serialization is done by accumulators it depends on\n+         template<class Archive>\n+         void serialize(Archive & ar, const unsigned int file_version) {}\n+      };\n+\n+      ///////////////////////////////////////////////////////////////////////////////\n+      // immediate_rolling_mean_impl\n+      //     The non-lazy version computes the rolling mean recursively when a new\n+      //     sample is added\n+      template<typename Sample>\n+      struct immediate_rolling_mean_impl\n+         : accumulator_base\n+      {\n+         // for boost::result_of\n+         typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type result_type;\n+\n+         template<typename Args>\n+         immediate_rolling_mean_impl(Args const &args)\n+            : mean_(numeric::fdiv(args[sample | Sample()],numeric::one<std::size_t>::value))\n+         {\n+         }\n+\n+         template<typename Args>\n+         void operator()(Args const &args)\n+         {\n+            if(is_rolling_window_plus1_full(args))\n+            {\n+               if (rolling_window_plus1(args).front() > args[sample])\n+                  mean_ -= numeric::fdiv(rolling_window_plus1(args).front()-args[sample],rolling_count(args));\n+               else if (rolling_window_plus1(args).front() < args[sample])\n+                  mean_ += numeric::fdiv(args[sample]-rolling_window_plus1(args).front(),rolling_count(args));\n+            }\n+            else\n+            {\n+               result_type prev_mean = mean_;\n+               if (prev_mean > args[sample])\n+                   mean_ -= numeric::fdiv(prev_mean-args[sample],rolling_count(args));\n+               else if (prev_mean < args[sample])\n+                   mean_ += numeric::fdiv(args[sample]-prev_mean,rolling_count(args));\n+            }\n+         }\n+\n+         template<typename Args>\n+         result_type result(Args const &) const\n+         {\n+            return mean_;\n+         }\n+        \n+         // make this accumulator serializeable\n+         template<class Archive>\n+         void serialize(Archive & ar, const unsigned int file_version)\n+         { \n+            ar & mean_;\n+         }\n+\n+      private:\n+\n+         result_type mean_;\n+      };\n+   } // namespace impl\n+\n+   ///////////////////////////////////////////////////////////////////////////////\n+   // tag::lazy_rolling_mean\n+   // tag::immediate_rolling_mean\n+   // tag::rolling_mean\n+   //\n+   namespace tag\n+   {\n+      struct lazy_rolling_mean\n+         : depends_on< rolling_sum, rolling_count >\n+      {\n+         /// INTERNAL ONLY\n+         ///\n+         typedef accumulators::impl::lazy_rolling_mean_impl< mpl::_1 > impl;\n+\n+#ifdef BOOST_ACCUMULATORS_DOXYGEN_INVOKED\n+         /// tag::rolling_window::window_size named parameter\n+         static boost::parameter::keyword<tag::rolling_window_size> const window_size;\n+#endif\n+      };\n+\n+      struct immediate_rolling_mean\n+         : depends_on< rolling_window_plus1, rolling_count>\n+      {\n+         /// INTERNAL ONLY\n+         ///\n+         typedef accumulators::impl::immediate_rolling_mean_impl< mpl::_1> impl;\n+\n+#ifdef BOOST_ACCUMULATORS_DOXYGEN_INVOKED\n+         /// tag::rolling_window::window_size named parameter\n+         static boost::parameter::keyword<tag::rolling_window_size> const window_size;\n+#endif\n+      };\n+\n+      // make immediate_rolling_mean the default implementation\n+      struct rolling_mean : immediate_rolling_mean {};\n+   } // namespace tag\n+\n+   ///////////////////////////////////////////////////////////////////////////////\n+   // extract::lazy_rolling_mean\n+   // extract::immediate_rolling_mean\n+   // extract::rolling_mean\n+   //\n+   namespace extract\n+   {\n+      extractor<tag::lazy_rolling_mean> const lazy_rolling_mean = {};\n+      extractor<tag::immediate_rolling_mean> const immediate_rolling_mean = {};\n+      extractor<tag::rolling_mean> const rolling_mean = {};\n+\n+      BOOST_ACCUMULATORS_IGNORE_GLOBAL(lazy_rolling_mean)\n+         BOOST_ACCUMULATORS_IGNORE_GLOBAL(immediate_rolling_mean)\n+         BOOST_ACCUMULATORS_IGNORE_GLOBAL(rolling_mean)\n+   }\n+\n+   using extract::lazy_rolling_mean;\n+   using extract::immediate_rolling_mean;\n+   using extract::rolling_mean;\n+\n+   // rolling_mean(lazy) -> lazy_rolling_mean\n+   template<>\n+   struct as_feature<tag::rolling_mean(lazy)>\n+   {\n+      typedef tag::lazy_rolling_mean type;\n+   };\n+\n+   // rolling_mean(immediate) -> immediate_rolling_mean\n+   template<>\n+   struct as_feature<tag::rolling_mean(immediate)>\n+   {\n+      typedef tag::immediate_rolling_mean type;\n+   };\n+\n+   // for the purposes of feature-based dependency resolution,\n+   // immediate_rolling_mean provides the same feature as rolling_mean\n+   template<>\n+   struct feature_of<tag::immediate_rolling_mean>\n+      : feature_of<tag::rolling_mean>\n+   {\n+   };\n+\n+   // for the purposes of feature-based dependency resolution,\n+   // lazy_rolling_mean provides the same feature as rolling_mean\n+   template<>\n+   struct feature_of<tag::lazy_rolling_mean>\n+      : feature_of<tag::rolling_mean>\n+   {\n+   };\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "28ea5b580a50bd3bb6f6007a252f8fb5dd0d2319",
        "filename": "src/boost/accumulators/statistics/rolling_moment.hpp",
        "status": "added",
        "additions": 120,
        "deletions": 0,
        "changes": 120,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/rolling_moment.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/rolling_moment.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/rolling_moment.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,120 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// rolling_moment.hpp\n+// Copyright 2005 Eric Niebler.\n+// Copyright (C) 2014 Pieter Bastiaan Ober (Integricom).\n+// Distributed under the Boost Software License, Version 1.0.\n+// (See accompanying file LICENSE_1_0.txt or copy at\n+// http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_ROLLING_MOMENT_HPP_EAN_27_11_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_ROLLING_MOMENT_HPP_EAN_27_11_2005\n+\n+#include <boost/config/no_tr1/cmath.hpp>\n+#include <boost/mpl/int.hpp>\n+#include <boost/mpl/assert.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/moment.hpp>\n+#include <boost/accumulators/statistics/rolling_count.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // rolling_moment_impl\n+    template<typename N, typename Sample>\n+    struct rolling_moment_impl\n+      : accumulator_base\n+    {\n+        BOOST_MPL_ASSERT_RELATION(N::value, >, 0);\n+        // for boost::result_of\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t,void,void>::result_type result_type;\n+\n+        template<typename Args>\n+        rolling_moment_impl(Args const &args)\n+          : sum_(args[sample | Sample()])\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            if(is_rolling_window_plus1_full(args))\n+            {\n+                this->sum_ -= numeric::pow(rolling_window_plus1(args).front(), N());\n+            }\n+            this->sum_ += numeric::pow(args[sample], N());\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            return numeric::fdiv(this->sum_, rolling_count(args));\n+        }\n+\n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & sum_;\n+        }\n+\n+    private:\n+        result_type sum_;\n+    };\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::rolling_moment\n+//\n+namespace tag\n+{\n+    template<int N>\n+    struct rolling_moment\n+      : depends_on< rolling_window_plus1, rolling_count>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::rolling_moment_impl<mpl::int_<N>, mpl::_1> impl;\n+\n+        #ifdef BOOST_ACCUMULATORS_DOXYGEN_INVOKED\n+        /// tag::rolling_window::window_size named parameter\n+        static boost::parameter::keyword<tag::rolling_window_size> const window_size;\n+        #endif\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::rolling_moment\n+//\n+namespace extract\n+{\n+    BOOST_ACCUMULATORS_DEFINE_EXTRACTOR(tag, rolling_moment, (int))\n+}\n+\n+using extract::rolling_moment;\n+\n+// There is no weighted_rolling_moment (yet)...\n+//\n+//// So that rolling_moment<N> can be automatically substituted with\n+//// weighted_rolling_moment<N> when the weight parameter is non-void\n+//template<int N>\n+//struct as_weighted_feature<tag::rolling_moment<N> >\n+//{\n+//    typedef tag::weighted_rolling_moment<N> type;\n+//};\n+//\n+//template<int N>\n+//struct feature_of<tag::weighted_rolling_moment<N> >\n+//  : feature_of<tag::rolling_moment<N> >\n+//{\n+//};\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "c5114606557da15cfb7aae5f2922e0c909f2b17c",
        "filename": "src/boost/accumulators/statistics/rolling_sum.hpp",
        "status": "added",
        "additions": 98,
        "deletions": 0,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/rolling_sum.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/rolling_sum.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/rolling_sum.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,98 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// rolling_sum.hpp\n+//\n+// Copyright 2008 Eric Niebler. Distributed under the Boost\n+// Software License, Version 1.0. (See accompanying file\n+// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_ROLLING_SUM_HPP_EAN_26_12_2008\n+#define BOOST_ACCUMULATORS_STATISTICS_ROLLING_SUM_HPP_EAN_26_12_2008\n+\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/rolling_window.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // rolling_sum_impl\n+    //    returns the sum of the samples in the rolling window\n+    template<typename Sample>\n+    struct rolling_sum_impl\n+      : accumulator_base\n+    {\n+        typedef Sample result_type;\n+\n+        template<typename Args>\n+        rolling_sum_impl(Args const &args)\n+          : sum_(args[sample | Sample()])\n+        {}\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            if(is_rolling_window_plus1_full(args))\n+            {\n+                this->sum_ -= rolling_window_plus1(args).front();\n+            }\n+            this->sum_ += args[sample];\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const & /*args*/) const\n+        {\n+            return this->sum_;\n+        }\n+\n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & sum_;\n+        }\n+\n+    private:\n+        Sample sum_;\n+    };\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::rolling_sum\n+//\n+namespace tag\n+{\n+    struct rolling_sum\n+      : depends_on< rolling_window_plus1 >\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::rolling_sum_impl< mpl::_1 > impl;\n+\n+        #ifdef BOOST_ACCUMULATORS_DOXYGEN_INVOKED\n+        /// tag::rolling_window::window_size named parameter\n+        static boost::parameter::keyword<tag::rolling_window_size> const window_size;\n+        #endif\n+    };\n+} // namespace tag\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::rolling_sum\n+//\n+namespace extract\n+{\n+    extractor<tag::rolling_sum> const rolling_sum = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(rolling_sum)\n+}\n+\n+using extract::rolling_sum;\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "249d5c1996d58fbcfc38c2388e3c21057af1bcec",
        "filename": "src/boost/accumulators/statistics/rolling_variance.hpp",
        "status": "added",
        "additions": 259,
        "deletions": 0,
        "changes": 259,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/rolling_variance.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/rolling_variance.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/rolling_variance.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,259 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// rolling_variance.hpp\n+// Copyright (C) 2005 Eric Niebler\n+// Copyright (C) 2014 Pieter Bastiaan Ober (Integricom).\n+// Distributed under the Boost Software License, Version 1.0.\n+// (See accompanying file LICENSE_1_0.txt or copy at\n+// http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_ROLLING_VARIANCE_HPP_EAN_15_11_2011\n+#define BOOST_ACCUMULATORS_STATISTICS_ROLLING_VARIANCE_HPP_EAN_15_11_2011\n+\n+#include <boost/accumulators/accumulators.hpp>\n+#include <boost/accumulators/statistics/stats.hpp>\n+\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/rolling_mean.hpp>\n+#include <boost/accumulators/statistics/rolling_moment.hpp>\n+\n+#include <boost/type_traits/is_arithmetic.hpp>\n+#include <boost/utility/enable_if.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+namespace impl\n+{\n+    //! Immediate (lazy) calculation of the rolling variance.\n+    /*!\n+    Calculation of sample variance \\f$\\sigma_n^2\\f$ is done as follows, see also\n+    http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance.\n+    For a rolling window of size \\f$N\\f$, when \\f$n <= N\\f$, the variance is computed according to the formula\n+    \\f[\n+    \\sigma_n^2 = \\frac{1}{n-1} \\sum_{i = 1}^n (x_i - \\mu_n)^2.\n+    \\f]\n+    When \\f$n > N\\f$, the sample variance over the window becomes:\n+    \\f[\n+    \\sigma_n^2 = \\frac{1}{N-1} \\sum_{i = n-N+1}^n (x_i - \\mu_n)^2.\n+    \\f]\n+    */\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // lazy_rolling_variance_impl\n+    //\n+    template<typename Sample>\n+    struct lazy_rolling_variance_impl\n+        : accumulator_base\n+    {\n+        // for boost::result_of\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t,void,void>::result_type result_type;\n+\n+        lazy_rolling_variance_impl(dont_care) {}\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            result_type mean = rolling_mean(args);\n+            size_t nr_samples = rolling_count(args);\n+            if (nr_samples < 2) return result_type();\n+            return nr_samples*(rolling_moment<2>(args) - mean*mean)/(nr_samples-1);\n+        }\n+        \n+        // serialization is done by accumulators it depends on\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version) {}\n+    };\n+\n+    //! Iterative calculation of the rolling variance.\n+    /*!\n+    Iterative calculation of sample variance \\f$\\sigma_n^2\\f$ is done as follows, see also\n+    http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance.\n+    For a rolling window of size \\f$N\\f$, for the first \\f$N\\f$ samples, the variance is computed according to the formula\n+    \\f[\n+    \\sigma_n^2 = \\frac{1}{n-1} \\sum_{i = 1}^n (x_i - \\mu_n)^2 = \\frac{1}{n-1}M_{2,n},\n+    \\f]\n+    where the sum of squares \\f$M_{2,n}\\f$ can be recursively computed as:\n+    \\f[\n+    M_{2,n} = \\sum_{i = 1}^n (x_i - \\mu_n)^2 = M_{2,n-1} + (x_n - \\mu_n)(x_n - \\mu_{n-1}),\n+    \\f]\n+    and the estimate of the sample mean as:\n+    \\f[\n+    \\mu_n = \\frac{1}{n} \\sum_{i = 1}^n x_i = \\mu_{n-1} + \\frac{1}{n}(x_n - \\mu_{n-1}).\n+    \\f]\n+    For further samples, when the rolling window is fully filled with data, one has to take into account that the oldest\n+    sample \\f$x_{n-N}\\f$ is dropped from the window. The sample variance over the window now becomes:\n+    \\f[\n+    \\sigma_n^2 = \\frac{1}{N-1} \\sum_{i = n-N+1}^n (x_i - \\mu_n)^2 = \\frac{1}{n-1}M_{2,n},\n+    \\f]\n+    where the sum of squares \\f$M_{2,n}\\f$ now equals:\n+    \\f[\n+    M_{2,n} = \\sum_{i = n-N+1}^n (x_i - \\mu_n)^2 = M_{2,n-1} + (x_n - \\mu_n)(x_n - \\mu_{n-1}) - (x_{n-N} - \\mu_n)(x_{n-N} - \\mu_{n-1}),\n+    \\f]\n+    and the estimated mean is:\n+    \\f[\n+    \\mu_n = \\frac{1}{N} \\sum_{i = n-N+1}^n x_i = \\mu_{n-1} + \\frac{1}{n}(x_n - x_{n-N}).\n+    \\f]\n+\n+    Note that the sample variance is not defined for \\f$n <= 1\\f$.\n+\n+    */\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // immediate_rolling_variance_impl\n+    //\n+    template<typename Sample>\n+    struct immediate_rolling_variance_impl\n+        : accumulator_base\n+    {\n+        // for boost::result_of\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type result_type;\n+\n+        template<typename Args>\n+        immediate_rolling_variance_impl(Args const &args)\n+            : previous_mean_(numeric::fdiv(args[sample | Sample()], numeric::one<std::size_t>::value))\n+            , sum_of_squares_(numeric::fdiv(args[sample | Sample()], numeric::one<std::size_t>::value))\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator()(Args const &args)\n+        {\n+            Sample added_sample = args[sample];\n+\n+            result_type mean = immediate_rolling_mean(args);\n+            sum_of_squares_ += (added_sample-mean)*(added_sample-previous_mean_);\n+\n+            if(is_rolling_window_plus1_full(args))\n+            {\n+                Sample removed_sample = rolling_window_plus1(args).front();\n+                sum_of_squares_ -= (removed_sample-mean)*(removed_sample-previous_mean_);\n+                prevent_underflow(sum_of_squares_);\n+            }\n+            previous_mean_ = mean;\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            size_t nr_samples = rolling_count(args);\n+            if (nr_samples < 2) return result_type();\n+            return numeric::fdiv(sum_of_squares_,(nr_samples-1));\n+        }\n+        \n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & previous_mean_;\n+            ar & sum_of_squares_;\n+        }\n+\n+    private:\n+\n+        result_type previous_mean_;\n+        result_type sum_of_squares_;\n+\n+        template<typename T>\n+        void prevent_underflow(T &non_negative_number,typename boost::enable_if<boost::is_arithmetic<T>,T>::type* = 0)\n+        {\n+            if (non_negative_number < T(0)) non_negative_number = T(0);\n+        }\n+        template<typename T>\n+        void prevent_underflow(T &non_arithmetic_quantity,typename boost::disable_if<boost::is_arithmetic<T>,T>::type* = 0)\n+        {\n+        }\n+    };\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag:: lazy_rolling_variance\n+// tag:: immediate_rolling_variance\n+// tag:: rolling_variance\n+//\n+namespace tag\n+{\n+    struct lazy_rolling_variance\n+        : depends_on< rolling_count, rolling_mean, rolling_moment<2> >\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::lazy_rolling_variance_impl< mpl::_1 > impl;\n+\n+        #ifdef BOOST_ACCUMULATORS_DOXYGEN_INVOKED\n+        /// tag::rolling_window::window_size named parameter\n+        static boost::parameter::keyword<tag::rolling_window_size> const window_size;\n+        #endif\n+    };\n+\n+    struct immediate_rolling_variance\n+        : depends_on< rolling_window_plus1, rolling_count, immediate_rolling_mean>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::immediate_rolling_variance_impl< mpl::_1> impl;\n+\n+        #ifdef BOOST_ACCUMULATORS_DOXYGEN_INVOKED\n+        /// tag::rolling_window::window_size named parameter\n+        static boost::parameter::keyword<tag::rolling_window_size> const window_size;\n+        #endif\n+    };\n+\n+    // make immediate_rolling_variance the default implementation\n+    struct rolling_variance : immediate_rolling_variance {};\n+} // namespace tag\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::lazy_rolling_variance\n+// extract::immediate_rolling_variance\n+// extract::rolling_variance\n+//\n+namespace extract\n+{\n+    extractor<tag::lazy_rolling_variance> const lazy_rolling_variance = {};\n+    extractor<tag::immediate_rolling_variance> const immediate_rolling_variance = {};\n+    extractor<tag::rolling_variance> const rolling_variance = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(lazy_rolling_variance)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(immediate_rolling_variance)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(rolling_variance)\n+}\n+\n+using extract::lazy_rolling_variance;\n+using extract::immediate_rolling_variance;\n+using extract::rolling_variance;\n+\n+// rolling_variance(lazy) -> lazy_rolling_variance\n+template<>\n+struct as_feature<tag::rolling_variance(lazy)>\n+{\n+    typedef tag::lazy_rolling_variance type;\n+};\n+\n+// rolling_variance(immediate) -> immediate_rolling_variance\n+template<>\n+struct as_feature<tag::rolling_variance(immediate)>\n+{\n+    typedef tag::immediate_rolling_variance type;\n+};\n+\n+// for the purposes of feature-based dependency resolution,\n+// lazy_rolling_variance provides the same feature as rolling_variance\n+template<>\n+struct feature_of<tag::lazy_rolling_variance>\n+    : feature_of<tag::rolling_variance>\n+{\n+};\n+\n+// for the purposes of feature-based dependency resolution,\n+// immediate_rolling_variance provides the same feature as rolling_variance\n+template<>\n+struct feature_of<tag::immediate_rolling_variance>\n+  : feature_of<tag::rolling_variance>\n+{\n+};\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "a43ecdfdac1fd95b24e4b390dd27bb4c2d1c92cd",
        "filename": "src/boost/accumulators/statistics/rolling_window.hpp",
        "status": "added",
        "additions": 221,
        "deletions": 0,
        "changes": 221,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/rolling_window.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/rolling_window.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/rolling_window.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,221 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// rolling_window.hpp\n+//\n+// Copyright 2008 Eric Niebler. Distributed under the Boost\n+// Software License, Version 1.0. (See accompanying file\n+// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_ROLLING_WINDOW_HPP_EAN_26_12_2008\n+#define BOOST_ACCUMULATORS_STATISTICS_ROLLING_WINDOW_HPP_EAN_26_12_2008\n+\n+#include <cstddef>\n+#include <boost/version.hpp>\n+#include <boost/assert.hpp>\n+#include <boost/circular_buffer.hpp>\n+#include <boost/range/iterator_range.hpp>\n+#include <boost/accumulators/accumulators_fwd.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/parameters/accumulator.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/serialization/split_free.hpp>\n+\n+namespace boost { namespace serialization {\n+\n+// implement serialization for boost::circular_buffer\n+template <class Archive, class T>\n+void save(Archive& ar, const circular_buffer<T>& b, const unsigned int /* version */)\n+{\n+    typename circular_buffer<T>::size_type size = b.size();\n+    ar << b.capacity();\n+    ar << size;\n+    const typename circular_buffer<T>::const_array_range one = b.array_one();\n+    const typename circular_buffer<T>::const_array_range two = b.array_two();\n+    ar.save_binary(one.first, one.second*sizeof(T));\n+    ar.save_binary(two.first, two.second*sizeof(T));\n+}\n+\n+template <class Archive, class T>\n+void load(Archive& ar, circular_buffer<T>& b, const unsigned int /* version */)\n+{\n+    typename circular_buffer<T>::capacity_type capacity;\n+    typename circular_buffer<T>::size_type size;\n+    ar >> capacity;\n+    b.set_capacity(capacity);\n+    ar >> size;\n+    b.clear();\n+    const typename circular_buffer<T>::pointer buff = new T[size*sizeof(T)];\n+    ar.load_binary(buff, size*sizeof(T));\n+    b.insert(b.begin(), buff, buff+size);\n+    delete[] buff;\n+}\n+\n+template<class Archive, class T>\n+inline void serialize(Archive & ar, circular_buffer<T>& b, const unsigned int version)\n+{\n+    split_free(ar, b, version);\n+}\n+\n+} } // end namespace boost::serialization\n+\n+namespace boost { namespace accumulators\n+{\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::rolling_window::size named parameter\n+BOOST_PARAMETER_NESTED_KEYWORD(tag, rolling_window_size, window_size)\n+\n+BOOST_ACCUMULATORS_IGNORE_GLOBAL(rolling_window_size)\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // rolling_window_plus1_impl\n+    //    stores the latest N+1 samples, where N is specified at construction time\n+    //    with the rolling_window_size named parameter\n+    template<typename Sample>\n+    struct rolling_window_plus1_impl\n+      : accumulator_base\n+    {\n+        typedef typename circular_buffer<Sample>::const_iterator const_iterator;\n+        typedef iterator_range<const_iterator> result_type;\n+\n+        template<typename Args>\n+        rolling_window_plus1_impl(Args const & args)\n+          : buffer_(args[rolling_window_size] + 1)\n+        {}\n+\n+        #if BOOST_VERSION < 103600\n+        // Before Boost 1.36, copying a circular buffer didn't copy\n+        // it's capacity, and we need that behavior.\n+        rolling_window_plus1_impl(rolling_window_plus1_impl const &that)\n+          : buffer_(that.buffer_)\n+        {\n+            this->buffer_.set_capacity(that.buffer_.capacity());\n+        }\n+\n+        rolling_window_plus1_impl &operator =(rolling_window_plus1_impl const &that)\n+        {\n+            this->buffer_ = that.buffer_;\n+            this->buffer_.set_capacity(that.buffer_.capacity());\n+        }\n+        #endif\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            this->buffer_.push_back(args[sample]);\n+        }\n+\n+        bool full() const\n+        {\n+            return this->buffer_.full();\n+        }\n+\n+        // The result of a shifted rolling window is the range including\n+        // everything except the most recently added element.\n+        result_type result(dont_care) const\n+        {\n+            return result_type(this->buffer_.begin(), this->buffer_.end());\n+        }\n+\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int version)\n+        {\n+            ar & buffer_;\n+        }\n+\n+    private:\n+        circular_buffer<Sample> buffer_;\n+    };\n+\n+    template<typename Args>\n+    bool is_rolling_window_plus1_full(Args const &args)\n+    {\n+        return find_accumulator<tag::rolling_window_plus1>(args[accumulator]).full();\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // rolling_window_impl\n+    //    stores the latest N samples, where N is specified at construction type\n+    //    with the rolling_window_size named parameter\n+    template<typename Sample>\n+    struct rolling_window_impl\n+      : accumulator_base\n+    {\n+        typedef typename circular_buffer<Sample>::const_iterator const_iterator;\n+        typedef iterator_range<const_iterator> result_type;\n+\n+        rolling_window_impl(dont_care)\n+        {}\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            return rolling_window_plus1(args).advance_begin(is_rolling_window_plus1_full(args));\n+        }\n+        \n+        // serialization is done by accumulators it depends on\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version) {}\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::rolling_window_plus1\n+// tag::rolling_window\n+//\n+namespace tag\n+{\n+    struct rolling_window_plus1\n+      : depends_on<>\n+      , tag::rolling_window_size\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::rolling_window_plus1_impl< mpl::_1 > impl;\n+\n+        #ifdef BOOST_ACCUMULATORS_DOXYGEN_INVOKED\n+        /// tag::rolling_window::size named parameter\n+        static boost::parameter::keyword<tag::rolling_window_size> const window_size;\n+        #endif\n+    };\n+\n+    struct rolling_window\n+      : depends_on< rolling_window_plus1 >\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::rolling_window_impl< mpl::_1 > impl;\n+\n+        #ifdef BOOST_ACCUMULATORS_DOXYGEN_INVOKED\n+        /// tag::rolling_window::size named parameter\n+        static boost::parameter::keyword<tag::rolling_window_size> const window_size;\n+        #endif\n+    };\n+\n+} // namespace tag\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::rolling_window_plus1\n+// extract::rolling_window\n+//\n+namespace extract\n+{\n+    extractor<tag::rolling_window_plus1> const rolling_window_plus1 = {};\n+    extractor<tag::rolling_window> const rolling_window = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(rolling_window_plus1)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(rolling_window)\n+}\n+\n+using extract::rolling_window_plus1;\n+using extract::rolling_window;\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "9c9c376a8a33bb6ac0105284b581f3feaa87134e",
        "filename": "src/boost/accumulators/statistics/skewness.hpp",
        "status": "added",
        "additions": 118,
        "deletions": 0,
        "changes": 118,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/skewness.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/skewness.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/skewness.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,118 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// skewness.hpp\n+//\n+//  Copyright 2006 Olivier Gygi, Daniel Egloff. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_SKEWNESS_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_SKEWNESS_HPP_EAN_28_10_2005\n+\n+#include <limits>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/moment.hpp>\n+#include <boost/accumulators/statistics/mean.hpp>\n+\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // skewness_impl\n+    /**\n+        @brief Skewness estimation\n+\n+        The skewness of a sample distribution is defined as the ratio of the 3rd central moment and the \\f$ 3/2 \\f$-th power\n+        of the 2nd central moment (the variance) of the samples 3. The skewness can also be expressed by the simple moments:\n+\n+        \\f[\n+            \\hat{g}_1 =\n+                \\frac\n+                {\\widehat{m}_n^{(3)}-3\\widehat{m}_n^{(2)}\\hat{\\mu}_n+2\\hat{\\mu}_n^3}\n+                {\\left(\\widehat{m}_n^{(2)} - \\hat{\\mu}_n^{2}\\right)^{3/2}}\n+        \\f]\n+\n+        where \\f$ \\widehat{m}_n^{(i)} \\f$ are the \\f$ i \\f$-th moment and \\f$ \\hat{\\mu}_n \\f$ the mean (first moment) of the\n+        \\f$ n \\f$ samples.\n+    */\n+    template<typename Sample>\n+    struct skewness_impl\n+      : accumulator_base\n+    {\n+        // for boost::result_of\n+        typedef typename numeric::functional::fdiv<Sample, Sample>::result_type result_type;\n+\n+        skewness_impl(dont_care)\n+        {\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            return numeric::fdiv(\n+                        accumulators::moment<3>(args)\n+                        - 3. * accumulators::moment<2>(args) * mean(args)\n+                        + 2. * mean(args) * mean(args) * mean(args)\n+                      , ( accumulators::moment<2>(args) - mean(args) * mean(args) )\n+                        * std::sqrt( accumulators::moment<2>(args) - mean(args) * mean(args) )\n+                   );\n+        }\n+        \n+        // serialization is done by accumulators it depends on\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version) {}\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::skewness\n+//\n+namespace tag\n+{\n+    struct skewness\n+      : depends_on<mean, moment<2>, moment<3> >\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::skewness_impl<mpl::_1> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::skewness\n+//\n+namespace extract\n+{\n+    extractor<tag::skewness> const skewness = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(skewness)\n+}\n+\n+using extract::skewness;\n+\n+// So that skewness can be automatically substituted with\n+// weighted_skewness when the weight parameter is non-void\n+template<>\n+struct as_weighted_feature<tag::skewness>\n+{\n+    typedef tag::weighted_skewness type;\n+};\n+\n+template<>\n+struct feature_of<tag::weighted_skewness>\n+  : feature_of<tag::skewness>\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "22c4ede0273c1085f402b4e50701bbec3581cc0e",
        "filename": "src/boost/accumulators/statistics/stats.hpp",
        "status": "added",
        "additions": 29,
        "deletions": 0,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/stats.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/stats.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/stats.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,29 @@\n+///////////////////////////////////////////////////////////////////////////////\n+/// \\file stats.hpp\n+/// Contains the stats<> template.\n+///\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_STATS_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_STATS_HPP_EAN_28_10_2005\n+\n+#include <boost/preprocessor/repetition/enum_params.hpp>\n+#include <boost/mpl/vector.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+///////////////////////////////////////////////////////////////////////////////\n+/// An MPL sequence of statistics.\n+template<BOOST_PP_ENUM_PARAMS(BOOST_ACCUMULATORS_MAX_FEATURES, typename Stat)>\n+struct stats\n+  : mpl::vector<BOOST_PP_ENUM_PARAMS(BOOST_ACCUMULATORS_MAX_FEATURES, Stat)>\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "7e507ccc26bdaf70805d3dd5421b46497f5868c1",
        "filename": "src/boost/accumulators/statistics/sum.hpp",
        "status": "added",
        "additions": 146,
        "deletions": 0,
        "changes": 146,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/sum.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/sum.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/sum.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,146 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// sum.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_SUM_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_SUM_HPP_EAN_28_10_2005\n+\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/parameters/weight.hpp>\n+#include <boost/accumulators/framework/accumulators/external_accumulator.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // sum_impl\n+    template<typename Sample, typename Tag>\n+    struct sum_impl\n+      : accumulator_base\n+    {\n+        // for boost::result_of\n+        typedef Sample result_type;\n+\n+        template<typename Args>\n+        sum_impl(Args const &args)\n+          : sum(args[parameter::keyword<Tag>::get() | Sample()])\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            // what about overflow?\n+            this->sum += args[parameter::keyword<Tag>::get()];\n+        }\n+\n+        result_type result(dont_care) const\n+        {\n+            return this->sum;\n+        }\n+\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & sum;\n+        }\n+\n+    private:\n+        Sample sum;\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::sum\n+// tag::sum_of_weights\n+// tag::sum_of_variates\n+//\n+namespace tag\n+{\n+    struct sum\n+      : depends_on<>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::sum_impl<mpl::_1, tag::sample> impl;\n+    };\n+\n+    struct sum_of_weights\n+      : depends_on<>\n+    {\n+        typedef mpl::true_ is_weight_accumulator;\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::sum_impl<mpl::_2, tag::weight> impl;\n+    };\n+\n+    template<typename VariateType, typename VariateTag>\n+    struct sum_of_variates\n+      : depends_on<>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef mpl::always<accumulators::impl::sum_impl<VariateType, VariateTag> > impl;\n+    };\n+\n+    struct abstract_sum_of_variates\n+      : depends_on<>\n+    {\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::sum\n+// extract::sum_of_weights\n+// extract::sum_of_variates\n+//\n+namespace extract\n+{\n+    extractor<tag::sum> const sum = {};\n+    extractor<tag::sum_of_weights> const sum_of_weights = {};\n+    extractor<tag::abstract_sum_of_variates> const sum_of_variates = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(sum)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(sum_of_weights)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(sum_of_variates)\n+}\n+\n+using extract::sum;\n+using extract::sum_of_weights;\n+using extract::sum_of_variates;\n+\n+// So that mean can be automatically substituted with\n+// weighted_mean when the weight parameter is non-void.\n+template<>\n+struct as_weighted_feature<tag::sum>\n+{\n+    typedef tag::weighted_sum type;\n+};\n+\n+template<>\n+struct feature_of<tag::weighted_sum>\n+  : feature_of<tag::sum>\n+{};\n+\n+template<typename VariateType, typename VariateTag>\n+struct feature_of<tag::sum_of_variates<VariateType, VariateTag> >\n+  : feature_of<tag::abstract_sum_of_variates>\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "b5e909223850be35e21e017bd67b2aadd00bac55",
        "filename": "src/boost/accumulators/statistics/sum_kahan.hpp",
        "status": "added",
        "additions": 196,
        "deletions": 0,
        "changes": 196,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/sum_kahan.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/sum_kahan.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/sum_kahan.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,196 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// sum_kahan.hpp\n+//\n+//  Copyright 2010 Gaetano Mendola, 2011 Simon West. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_SUM_KAHAN_HPP_EAN_26_07_2010\n+#define BOOST_ACCUMULATORS_STATISTICS_SUM_KAHAN_HPP_EAN_26_07_2010\n+\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/sum.hpp>\n+#include <boost/accumulators/statistics/weighted_sum_kahan.hpp>\n+#include <boost/numeric/conversion/cast.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+\n+#if _MSC_VER > 1400\n+# pragma float_control(push)\n+# pragma float_control(precise, on)\n+#endif\n+\n+template<typename Sample, typename Tag>\n+struct sum_kahan_impl\n+  : accumulator_base\n+{\n+    typedef Sample result_type;\n+\n+    ////////////////////////////////////////////////////////////////////////////\n+    // sum_kahan_impl\n+    /**\n+        @brief Kahan summation algorithm\n+\n+        The Kahan summation algorithm reduces the numerical error obtained with standard\n+        sequential sum.\n+\n+    */\n+    template<typename Args>\n+    sum_kahan_impl(Args const & args)\n+      : sum(args[parameter::keyword<Tag>::get() | Sample()]),\n+        compensation(boost::numeric_cast<Sample>(0.0))\n+    {\n+    }\n+\n+    template<typename Args>\n+    void \n+#if BOOST_ACCUMULATORS_GCC_VERSION > 40305\n+    __attribute__((__optimize__(\"no-associative-math\")))\n+#endif\n+    operator ()(Args const & args)\n+    {\n+        const Sample myTmp1 = args[parameter::keyword<Tag>::get()] - this->compensation;\n+        const Sample myTmp2 = this->sum + myTmp1;\n+        this->compensation = (myTmp2 - this->sum) - myTmp1;\n+        this->sum = myTmp2;\n+    }\n+\n+    result_type result(dont_care) const\n+    {\n+      return this->sum;\n+    }\n+\n+    // make this accumulator serializeable\n+    template<class Archive>\n+    void serialize(Archive & ar, const unsigned int file_version)\n+    { \n+        ar & sum;\n+        ar & compensation;\n+    }\n+\n+private:\n+    Sample sum;\n+    Sample compensation;\n+};\n+\n+#if _MSC_VER > 1400\n+# pragma float_control(pop)\n+#endif\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::sum_kahan\n+// tag::sum_of_weights_kahan\n+// tag::sum_of_variates_kahan\n+//\n+namespace tag\n+{\n+\n+    struct sum_kahan\n+      : depends_on<>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef impl::sum_kahan_impl< mpl::_1, tag::sample > impl;\n+    };\n+\n+    struct sum_of_weights_kahan\n+      : depends_on<>\n+    {\n+        typedef mpl::true_ is_weight_accumulator;\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::sum_kahan_impl<mpl::_2, tag::weight> impl;\n+    };\n+\n+    template<typename VariateType, typename VariateTag>\n+    struct sum_of_variates_kahan\n+      : depends_on<>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef mpl::always<accumulators::impl::sum_kahan_impl<VariateType, VariateTag> > impl;\n+    };\n+\n+} // namespace tag\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::sum_kahan\n+// extract::sum_of_weights_kahan\n+// extract::sum_of_variates_kahan\n+//\n+namespace extract\n+{\n+    extractor<tag::sum_kahan> const sum_kahan = {};\n+    extractor<tag::sum_of_weights_kahan> const sum_of_weights_kahan = {};\n+    extractor<tag::abstract_sum_of_variates> const sum_of_variates_kahan = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(sum_kahan)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(sum_of_weights_kahan)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(sum_of_variates_kahan)\n+} // namespace extract\n+\n+using extract::sum_kahan;\n+using extract::sum_of_weights_kahan;\n+using extract::sum_of_variates_kahan;\n+\n+// sum(kahan) -> sum_kahan\n+template<>\n+struct as_feature<tag::sum(kahan)>\n+{\n+    typedef tag::sum_kahan type;\n+};\n+\n+// sum_of_weights(kahan) -> sum_of_weights_kahan\n+template<>\n+struct as_feature<tag::sum_of_weights(kahan)>\n+{\n+    typedef tag::sum_of_weights_kahan type;\n+};\n+\n+// So that sum_kahan can be automatically substituted with\n+// weighted_sum_kahan when the weight parameter is non-void.\n+template<>\n+struct as_weighted_feature<tag::sum_kahan>\n+{\n+    typedef tag::weighted_sum_kahan type;\n+};\n+\n+template<>\n+struct feature_of<tag::weighted_sum_kahan>\n+  : feature_of<tag::sum>\n+{};\n+\n+// for the purposes of feature-based dependency resolution,\n+// sum_kahan provides the same feature as sum\n+template<>\n+struct feature_of<tag::sum_kahan>\n+  : feature_of<tag::sum>\n+{\n+};\n+\n+// for the purposes of feature-based dependency resolution,\n+// sum_of_weights_kahan provides the same feature as sum_of_weights\n+template<>\n+struct feature_of<tag::sum_of_weights_kahan>\n+  : feature_of<tag::sum_of_weights>\n+{\n+};\n+\n+template<typename VariateType, typename VariateTag>\n+struct feature_of<tag::sum_of_variates_kahan<VariateType, VariateTag> >\n+  : feature_of<tag::abstract_sum_of_variates>\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif\n+"
      },
      {
        "sha": "154a30cc26e06f16e2670d8fd24274fddf022ae6",
        "filename": "src/boost/accumulators/statistics/tail.hpp",
        "status": "added",
        "additions": 352,
        "deletions": 0,
        "changes": 352,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/tail.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/tail.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/tail.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,352 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// tail.hpp\n+//\n+//  Copyright 2005 Eric Niebler, Michael Gauckler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_TAIL_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_TAIL_HPP_EAN_28_10_2005\n+\n+#include <vector>\n+#include <functional>\n+#include <boost/assert.hpp>\n+#include <boost/range.hpp>\n+#include <boost/mpl/if.hpp>\n+#include <boost/mpl/or.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/iterator/reverse_iterator.hpp>\n+#include <boost/iterator/permutation_iterator.hpp>\n+#include <boost/accumulators/accumulators_fwd.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+///////////////////////////////////////////////////////////////////////////////\n+// cache_size named parameters\n+BOOST_PARAMETER_NESTED_KEYWORD(tag, right_tail_cache_size, cache_size)\n+BOOST_PARAMETER_NESTED_KEYWORD(tag, left_tail_cache_size, cache_size)\n+\n+BOOST_ACCUMULATORS_IGNORE_GLOBAL(right_tail_cache_size)\n+BOOST_ACCUMULATORS_IGNORE_GLOBAL(left_tail_cache_size)\n+\n+namespace detail\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // tail_range\n+    /// INTERNAL ONLY\n+    ///\n+    template<typename ElementIterator, typename IndexIterator>\n+    struct tail_range\n+    {\n+        typedef boost::iterator_range<\n+            boost::reverse_iterator<boost::permutation_iterator<ElementIterator, IndexIterator> >\n+        > type;\n+    };\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // make_tail_range\n+    /// INTERNAL ONLY\n+    ///\n+    template<typename ElementIterator, typename IndexIterator>\n+    typename tail_range<ElementIterator, IndexIterator>::type\n+    make_tail_range(ElementIterator elem_begin, IndexIterator index_begin, IndexIterator index_end)\n+    {\n+        return boost::make_iterator_range(\n+            boost::make_reverse_iterator(\n+                boost::make_permutation_iterator(elem_begin, index_end)\n+            )\n+          , boost::make_reverse_iterator(\n+                boost::make_permutation_iterator(elem_begin, index_begin)\n+            )\n+        );\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // stat_assign_visitor\n+    /// INTERNAL ONLY\n+    ///\n+    template<typename Args>\n+    struct stat_assign_visitor\n+    {\n+        stat_assign_visitor(Args const &a, std::size_t i)\n+          : args(a)\n+          , index(i)\n+        {\n+        }\n+\n+        template<typename Stat>\n+        void operator ()(Stat &stat) const\n+        {\n+            stat.assign(this->args, this->index);\n+        }\n+\n+    private:\n+        stat_assign_visitor &operator =(stat_assign_visitor const &);\n+        Args const &args;\n+        std::size_t index;\n+    };\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // stat_assign\n+    /// INTERNAL ONLY\n+    ///\n+    template<typename Args>\n+    inline stat_assign_visitor<Args> const stat_assign(Args const &args, std::size_t index)\n+    {\n+        return stat_assign_visitor<Args>(args, index);\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // is_tail_variate_feature\n+    /// INTERNAL ONLY\n+    ///\n+    template<typename Stat, typename LeftRight>\n+    struct is_tail_variate_feature\n+      : mpl::false_\n+    {\n+    };\n+\n+    /// INTERNAL ONLY\n+    ///\n+    template<typename VariateType, typename VariateTag, typename LeftRight>\n+    struct is_tail_variate_feature<tag::tail_variate<VariateType, VariateTag, LeftRight>, LeftRight>\n+      : mpl::true_\n+    {\n+    };\n+\n+    /// INTERNAL ONLY\n+    ///\n+    template<typename LeftRight>\n+    struct is_tail_variate_feature<tag::tail_weights<LeftRight>, LeftRight>\n+      : mpl::true_\n+    {\n+    };\n+\n+} // namespace detail\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // tail_impl\n+    template<typename Sample, typename LeftRight>\n+    struct tail_impl\n+      : accumulator_base\n+    {\n+        // LeftRight must be either right or left\n+        BOOST_MPL_ASSERT((\n+            mpl::or_<is_same<LeftRight, right>, is_same<LeftRight, left> >\n+        ));\n+\n+        typedef\n+            typename mpl::if_<\n+                is_same<LeftRight, right>\n+              , numeric::functional::greater<Sample const, Sample const>\n+              , numeric::functional::less<Sample const, Sample const>\n+            >::type\n+        predicate_type;\n+\n+        // for boost::result_of\n+        typedef typename detail::tail_range<\n+            typename std::vector<Sample>::const_iterator\n+          , std::vector<std::size_t>::iterator\n+        >::type result_type;\n+\n+        template<typename Args>\n+        tail_impl(Args const &args)\n+          : is_sorted(false)\n+          , indices()\n+          , samples(args[tag::tail<LeftRight>::cache_size], args[sample | Sample()])\n+        {\n+            this->indices.reserve(this->samples.size());\n+        }\n+\n+        tail_impl(tail_impl const &that)\n+          : is_sorted(that.is_sorted)\n+          , indices(that.indices)\n+          , samples(that.samples)\n+        {\n+            this->indices.reserve(this->samples.size());\n+        }\n+\n+        // This just stores the heap and the samples.\n+        // In operator()() below, if we are adding a new sample\n+        // to the sample cache, we force all the\n+        // tail_variates to update also. (It's not\n+        // good enough to wait for the accumulator_set to do it\n+        // for us because then information about whether a sample\n+        // was stored and where is lost, and would need to be\n+        // queried at runtime, which would be slow.) This is\n+        // implemented as a filtered visitation over the stats,\n+        // which we can access because args[accumulator] gives us\n+        // all the stats.\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            if(this->indices.size() < this->samples.size())\n+            {\n+                this->indices.push_back(this->indices.size());\n+                this->assign(args, this->indices.back());\n+            }\n+            else if(predicate_type()(args[sample], this->samples[this->indices[0]]))\n+            {\n+                std::pop_heap(this->indices.begin(), this->indices.end(), indirect_cmp(this->samples));\n+                this->assign(args, this->indices.back());\n+            }\n+        }\n+\n+        result_type result(dont_care) const\n+        {\n+            if(!this->is_sorted)\n+            {\n+                // Must use the same predicate here as in push_heap/pop_heap above.\n+                std::sort_heap(this->indices.begin(), this->indices.end(), indirect_cmp(this->samples));\n+                // sort_heap puts elements in reverse order. Calling std::reverse\n+                // turns the sorted sequence back into a valid heap.\n+                std::reverse(this->indices.begin(), this->indices.end());\n+                this->is_sorted = true;\n+            }\n+\n+            return detail::make_tail_range(\n+                this->samples.begin()\n+              , this->indices.begin()\n+              , this->indices.end()\n+            );\n+        }\n+\n+    private:\n+\n+        struct is_tail_variate\n+        {\n+            template<typename T>\n+            struct apply\n+              : detail::is_tail_variate_feature<\n+                    typename detail::feature_tag<T>::type\n+                  , LeftRight\n+                >\n+            {};\n+        };\n+\n+        template<typename Args>\n+        void assign(Args const &args, std::size_t index)\n+        {\n+            BOOST_ASSERT(index < this->samples.size());\n+            this->samples[index] = args[sample];\n+            std::push_heap(this->indices.begin(), this->indices.end(), indirect_cmp(this->samples));\n+            this->is_sorted = false;\n+            // Tell the tail variates to store their values also\n+            args[accumulator].template visit_if<is_tail_variate>(detail::stat_assign(args, index));\n+        }\n+\n+        ///////////////////////////////////////////////////////////////////////////////\n+        //\n+        struct indirect_cmp\n+        {\n+            typedef std::size_t first_argument_type;\n+            typedef std::size_t second_argument_type;\n+            typedef bool result_type;\n+\n+            indirect_cmp(std::vector<Sample> const &s)\n+              : samples(s)\n+            {\n+            }\n+\n+            bool operator ()(std::size_t left, std::size_t right) const\n+            {\n+                return predicate_type()(this->samples[left], this->samples[right]);\n+            }\n+\n+        private:\n+            indirect_cmp &operator =(indirect_cmp const &);\n+            std::vector<Sample> const &samples;\n+        };\n+\n+    public:\n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & is_sorted;\n+            ar & indices;\n+            ar & samples;\n+        }\n+\n+    private:\n+        mutable bool is_sorted;\n+        mutable std::vector<std::size_t> indices;\n+        std::vector<Sample> samples;\n+    };\n+\n+} // namespace impl\n+\n+// TODO The templatized tag::tail below should inherit from the correct named parameter.\n+// The following lines provide a workaround, but there must be a better way of doing this.\n+template<typename T>\n+struct tail_cache_size_named_arg\n+{\n+};\n+template<>\n+struct tail_cache_size_named_arg<left>\n+  : tag::left_tail_cache_size\n+{\n+};\n+template<>\n+struct tail_cache_size_named_arg<right>\n+  : tag::right_tail_cache_size\n+{\n+};\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::tail<>\n+//\n+namespace tag\n+{\n+    template<typename LeftRight>\n+    struct tail\n+      : depends_on<>\n+      , tail_cache_size_named_arg<LeftRight>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::tail_impl<mpl::_1, LeftRight> impl;\n+\n+        #ifdef BOOST_ACCUMULATORS_DOXYGEN_INVOKED\n+        /// tag::tail<LeftRight>::cache_size named parameter\n+        static boost::parameter::keyword<tail_cache_size_named_arg<LeftRight> > const cache_size;\n+        #endif\n+    };\n+\n+    struct abstract_tail\n+      : depends_on<>\n+    {\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::tail\n+//\n+namespace extract\n+{\n+    extractor<tag::abstract_tail> const tail = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(tail)\n+}\n+\n+using extract::tail;\n+\n+template<typename LeftRight>\n+struct feature_of<tag::tail<LeftRight> >\n+  : feature_of<tag::abstract_tail>\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "f56606d14e64333fcfafad058302d332b117ae6f",
        "filename": "src/boost/accumulators/statistics/tail_mean.hpp",
        "status": "added",
        "additions": 254,
        "deletions": 0,
        "changes": 254,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/tail_mean.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/tail_mean.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/tail_mean.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,254 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// tail_mean.hpp\n+//\n+//  Copyright 2006 Daniel Egloff, Olivier Gygi. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_TAIL_MEAN_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_TAIL_MEAN_HPP_DE_01_01_2006\n+\n+#include <numeric>\n+#include <vector>\n+#include <limits>\n+#include <functional>\n+#include <sstream>\n+#include <stdexcept>\n+#include <boost/throw_exception.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+#include <boost/accumulators/statistics/tail.hpp>\n+#include <boost/accumulators/statistics/tail_quantile.hpp>\n+#include <boost/accumulators/statistics/parameters/quantile_probability.hpp>\n+\n+#ifdef _MSC_VER\n+# pragma warning(push)\n+# pragma warning(disable: 4127) // conditional expression is constant\n+#endif\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // coherent_tail_mean_impl\n+    //\n+    /**\n+        @brief Estimation of the coherent tail mean based on order statistics (for both left and right tails)\n+\n+        The coherent tail mean \\f$\\widehat{CTM}_{n,\\alpha}(X)\\f$ is equal to the non-coherent tail mean \\f$\\widehat{NCTM}_{n,\\alpha}(X)\\f$\n+        plus a correction term that ensures coherence in case of non-continuous distributions.\n+\n+        \\f[\n+            \\widehat{CTM}_{n,\\alpha}^{\\mathrm{right}}(X) = \\widehat{NCTM}_{n,\\alpha}^{\\mathrm{right}}(X) +\n+            \\frac{1}{\\lceil n(1-\\alpha)\\rceil}\\hat{q}_{n,\\alpha}(X)\\left(1 - \\alpha - \\frac{1}{n}\\lceil n(1-\\alpha)\\rceil \\right)\n+        \\f]\n+\n+        \\f[\n+            \\widehat{CTM}_{n,\\alpha}^{\\mathrm{left}}(X) = \\widehat{NCTM}_{n,\\alpha}^{\\mathrm{left}}(X) +\n+            \\frac{1}{\\lceil n\\alpha\\rceil}\\hat{q}_{n,\\alpha}(X)\\left(\\alpha - \\frac{1}{n}\\lceil n\\alpha\\rceil \\right)\n+        \\f]\n+    */\n+    template<typename Sample, typename LeftRight>\n+    struct coherent_tail_mean_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type float_type;\n+        // for boost::result_of\n+        typedef float_type result_type;\n+\n+        coherent_tail_mean_impl(dont_care) {}\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            std::size_t cnt = count(args);\n+\n+            std::size_t n = static_cast<std::size_t>(\n+                std::ceil(\n+                    cnt * ( ( is_same<LeftRight, left>::value ) ? args[quantile_probability] : 1. - args[quantile_probability] )\n+                )\n+            );\n+\n+            extractor<tag::non_coherent_tail_mean<LeftRight> > const some_non_coherent_tail_mean = {};\n+\n+            return some_non_coherent_tail_mean(args)\n+                 + numeric::fdiv(quantile(args), n)\n+                 * (\n+                     ( is_same<LeftRight, left>::value ) ? args[quantile_probability] : 1. - args[quantile_probability]\n+                     - numeric::fdiv(n, count(args))\n+                   );\n+        }\n+        \n+        // serialization is done by accumulators it depends on\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version) {}\n+    };\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // non_coherent_tail_mean_impl\n+    //\n+    /**\n+        @brief Estimation of the (non-coherent) tail mean based on order statistics (for both left and right tails)\n+\n+        An estimation of the non-coherent tail mean \\f$\\widehat{NCTM}_{n,\\alpha}(X)\\f$ is given by the mean of the\n+        \\f$\\lceil n\\alpha\\rceil\\f$ smallest samples (left tail) or the mean of the  \\f$\\lceil n(1-\\alpha)\\rceil\\f$\n+        largest samples (right tail), \\f$n\\f$ being the total number of samples and \\f$\\alpha\\f$ the quantile level:\n+\n+        \\f[\n+            \\widehat{NCTM}_{n,\\alpha}^{\\mathrm{right}}(X) = \\frac{1}{\\lceil n(1-\\alpha)\\rceil} \\sum_{i=\\lceil \\alpha n \\rceil}^n X_{i:n}\n+        \\f]\n+\n+        \\f[\n+            \\widehat{NCTM}_{n,\\alpha}^{\\mathrm{left}}(X) = \\frac{1}{\\lceil n\\alpha\\rceil} \\sum_{i=1}^{\\lceil \\alpha n \\rceil} X_{i:n}\n+        \\f]\n+\n+        It thus requires the caching of at least the \\f$\\lceil n\\alpha\\rceil\\f$ smallest or the \\f$\\lceil n(1-\\alpha)\\rceil\\f$\n+        largest samples.\n+\n+        @param quantile_probability\n+    */\n+    template<typename Sample, typename LeftRight>\n+    struct non_coherent_tail_mean_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type float_type;\n+        // for boost::result_of\n+        typedef float_type result_type;\n+\n+        non_coherent_tail_mean_impl(dont_care) {}\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            std::size_t cnt = count(args);\n+\n+            std::size_t n = static_cast<std::size_t>(\n+                std::ceil(\n+                    cnt * ( ( is_same<LeftRight, left>::value ) ? args[quantile_probability] : 1. - args[quantile_probability] )\n+                )\n+            );\n+\n+            // If n is in a valid range, return result, otherwise return NaN or throw exception\n+            if (n <= static_cast<std::size_t>(tail(args).size()))\n+                return numeric::fdiv(\n+                    std::accumulate(\n+                        tail(args).begin()\n+                      , tail(args).begin() + n\n+                      , Sample(0)\n+                    )\n+                  , n\n+                );\n+            else\n+            {\n+                if (std::numeric_limits<result_type>::has_quiet_NaN)\n+                {\n+                    return std::numeric_limits<result_type>::quiet_NaN();\n+                }\n+                else\n+                {\n+                    std::ostringstream msg;\n+                    msg << \"index n = \" << n << \" is not in valid range [0, \" << tail(args).size() << \")\";\n+                    boost::throw_exception(std::runtime_error(msg.str()));\n+                    return Sample(0);\n+                }\n+            }\n+        }\n+        \n+        // serialization is done by accumulators it depends on\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version) {}\n+    };\n+\n+} // namespace impl\n+\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::coherent_tail_mean<>\n+// tag::non_coherent_tail_mean<>\n+//\n+namespace tag\n+{\n+    template<typename LeftRight>\n+    struct coherent_tail_mean\n+      : depends_on<count, quantile, non_coherent_tail_mean<LeftRight> >\n+    {\n+        typedef accumulators::impl::coherent_tail_mean_impl<mpl::_1, LeftRight> impl;\n+    };\n+\n+    template<typename LeftRight>\n+    struct non_coherent_tail_mean\n+      : depends_on<count, tail<LeftRight> >\n+    {\n+        typedef accumulators::impl::non_coherent_tail_mean_impl<mpl::_1, LeftRight> impl;\n+    };\n+\n+    struct abstract_non_coherent_tail_mean\n+      : depends_on<>\n+    {\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::non_coherent_tail_mean;\n+// extract::coherent_tail_mean;\n+//\n+namespace extract\n+{\n+    extractor<tag::abstract_non_coherent_tail_mean> const non_coherent_tail_mean = {};\n+    extractor<tag::tail_mean> const coherent_tail_mean = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(non_coherent_tail_mean)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(coherent_tail_mean)\n+}\n+\n+using extract::non_coherent_tail_mean;\n+using extract::coherent_tail_mean;\n+\n+// for the purposes of feature-based dependency resolution,\n+// coherent_tail_mean<LeftRight> provides the same feature as tail_mean\n+template<typename LeftRight>\n+struct feature_of<tag::coherent_tail_mean<LeftRight> >\n+  : feature_of<tag::tail_mean>\n+{\n+};\n+\n+template<typename LeftRight>\n+struct feature_of<tag::non_coherent_tail_mean<LeftRight> >\n+  : feature_of<tag::abstract_non_coherent_tail_mean>\n+{\n+};\n+\n+// So that non_coherent_tail_mean can be automatically substituted\n+// with weighted_non_coherent_tail_mean when the weight parameter is non-void.\n+template<typename LeftRight>\n+struct as_weighted_feature<tag::non_coherent_tail_mean<LeftRight> >\n+{\n+    typedef tag::non_coherent_weighted_tail_mean<LeftRight> type;\n+};\n+\n+template<typename LeftRight>\n+struct feature_of<tag::non_coherent_weighted_tail_mean<LeftRight> >\n+  : feature_of<tag::non_coherent_tail_mean<LeftRight> >\n+{};\n+\n+// NOTE that non_coherent_tail_mean cannot be feature-grouped with tail_mean,\n+// which is the base feature for coherent tail means, since (at least for\n+// non-continuous distributions) non_coherent_tail_mean is a different measure!\n+\n+}} // namespace boost::accumulators\n+\n+#ifdef _MSC_VER\n+# pragma warning(pop)\n+#endif\n+\n+#endif"
      },
      {
        "sha": "ed1f6e6dff3634ce11172d7e9982d1da408a77b2",
        "filename": "src/boost/accumulators/statistics/tail_quantile.hpp",
        "status": "added",
        "additions": 162,
        "deletions": 0,
        "changes": 162,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/tail_quantile.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/tail_quantile.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/tail_quantile.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,162 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// tail_quantile.hpp\n+//\n+//  Copyright 2006 Daniel Egloff, Olivier Gygi. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_TAIL_QUANTILE_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_TAIL_QUANTILE_HPP_DE_01_01_2006\n+\n+#include <vector>\n+#include <limits>\n+#include <functional>\n+#include <sstream>\n+#include <stdexcept>\n+#include <boost/config/no_tr1/cmath.hpp>             // For ceil\n+#include <boost/throw_exception.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/mpl/if.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/tail.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+#include <boost/accumulators/statistics/parameters/quantile_probability.hpp>\n+\n+#ifdef _MSC_VER\n+# pragma warning(push)\n+# pragma warning(disable: 4127) // conditional expression is constant\n+#endif\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // tail_quantile_impl\n+    //  Tail quantile estimation based on order statistics\n+    /**\n+        @brief Tail quantile estimation based on order statistics (for both left and right tails)\n+\n+        The estimation of a tail quantile \\f$\\hat{q}\\f$ with level \\f$\\alpha\\f$ based on order statistics requires the\n+        caching of at least the \\f$\\lceil n\\alpha\\rceil\\f$ smallest or the \\f$\\lceil n(1-\\alpha)\\rceil\\f$ largest samples,\n+        \\f$n\\f$ being the total number of samples. The largest of the \\f$\\lceil n\\alpha\\rceil\\f$ smallest samples or the\n+        smallest of the \\f$\\lceil n(1-\\alpha)\\rceil\\f$ largest samples provides an estimate for the quantile:\n+\n+        \\f[\n+            \\hat{q}_{n,\\alpha} = X_{\\lceil \\alpha n \\rceil:n}\n+        \\f]\n+\n+        @param quantile_probability\n+    */\n+    template<typename Sample, typename LeftRight>\n+    struct tail_quantile_impl\n+      : accumulator_base\n+    {\n+        // for boost::result_of\n+        typedef Sample result_type;\n+\n+        tail_quantile_impl(dont_care) {}\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            std::size_t cnt = count(args);\n+\n+            std::size_t n = static_cast<std::size_t>(\n+                std::ceil(\n+                    cnt * ( ( is_same<LeftRight, left>::value ) ? args[quantile_probability] : 1. - args[quantile_probability] )\n+                )\n+            );\n+\n+            // If n is in a valid range, return result, otherwise return NaN or throw exception\n+            if ( n < static_cast<std::size_t>(tail(args).size()))\n+            {\n+               // Note that the cached samples of the left are sorted in ascending order,\n+               // whereas the samples of the right tail are sorted in descending order\n+               return *(boost::begin(tail(args)) + n - 1);\n+            }\n+            else\n+            {\n+                if (std::numeric_limits<result_type>::has_quiet_NaN)\n+                {\n+                    return std::numeric_limits<result_type>::quiet_NaN();\n+                }\n+                else\n+                {\n+                    std::ostringstream msg;\n+                    msg << \"index n = \" << n << \" is not in valid range [0, \" << tail(args).size() << \")\";\n+                    boost::throw_exception(std::runtime_error(msg.str()));\n+                    return Sample(0);\n+                }\n+            }\n+        }\n+        \n+        // serialization is done by accumulators it depends on\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version) {}\n+    };\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::tail_quantile<>\n+//\n+namespace tag\n+{\n+    template<typename LeftRight>\n+    struct tail_quantile\n+      : depends_on<count, tail<LeftRight> >\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::tail_quantile_impl<mpl::_1, LeftRight> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::tail_quantile\n+//\n+namespace extract\n+{\n+    extractor<tag::quantile> const tail_quantile = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(tail_quantile)\n+}\n+\n+using extract::tail_quantile;\n+\n+// for the purposes of feature-based dependency resolution,\n+// tail_quantile<LeftRight> provide the same feature as quantile\n+template<typename LeftRight>\n+struct feature_of<tag::tail_quantile<LeftRight> >\n+  : feature_of<tag::quantile>\n+{\n+};\n+\n+// So that tail_quantile can be automatically substituted with\n+// weighted_tail_quantile when the weight parameter is non-void.\n+template<typename LeftRight>\n+struct as_weighted_feature<tag::tail_quantile<LeftRight> >\n+{\n+    typedef tag::weighted_tail_quantile<LeftRight> type;\n+};\n+\n+template<typename LeftRight>\n+struct feature_of<tag::weighted_tail_quantile<LeftRight> >\n+  : feature_of<tag::tail_quantile<LeftRight> >\n+{};\n+\n+}} // namespace boost::accumulators\n+\n+#ifdef _MSC_VER\n+# pragma warning(pop)\n+#endif\n+\n+#endif"
      },
      {
        "sha": "6885ece15f3937bd85114b4716f36f0b5714d391",
        "filename": "src/boost/accumulators/statistics/tail_variate.hpp",
        "status": "added",
        "additions": 150,
        "deletions": 0,
        "changes": 150,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/tail_variate.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/tail_variate.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/tail_variate.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,150 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// tail_variate.hpp\n+//\n+//  Copyright 2005 Eric Niebler, Michael Gauckler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_STAT_STATISTICS_TAIL_VARIATE_HPP_EAN_28_10_2005\n+#define BOOST_STAT_STATISTICS_TAIL_VARIATE_HPP_EAN_28_10_2005\n+\n+#include <boost/range.hpp>\n+#include <boost/mpl/always.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/iterator/reverse_iterator.hpp>\n+#include <boost/iterator/permutation_iterator.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/tail.hpp>\n+#include <boost/serialization/vector.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // tail_variate_impl\n+    template<typename VariateType, typename VariateTag, typename LeftRight>\n+    struct tail_variate_impl\n+      : accumulator_base\n+    {\n+        // for boost::result_of\n+        typedef\n+            typename detail::tail_range<\n+                typename std::vector<VariateType>::const_iterator\n+              , std::vector<std::size_t>::iterator\n+            >::type\n+        result_type;\n+\n+        template<typename Args>\n+        tail_variate_impl(Args const &args)\n+          : variates(args[tag::tail<LeftRight>::cache_size], args[parameter::keyword<VariateTag>::get() | VariateType()])\n+        {\n+        }\n+\n+        template<typename Args>\n+        void assign(Args const &args, std::size_t index)\n+        {\n+            this->variates[index] = args[parameter::keyword<VariateTag>::get()];\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            // getting the order result causes the indices vector to be sorted.\n+            extractor<tag::tail<LeftRight> > const some_tail = {};\n+            return this->do_result(some_tail(args));\n+        }\n+\n+    private:\n+        template<typename TailRng>\n+        result_type do_result(TailRng const &rng) const\n+        {\n+            return detail::make_tail_range(\n+                this->variates.begin()\n+              , rng.end().base().base()   // the index iterator\n+              , rng.begin().base().base() // (begin and end reversed because these are reverse iterators)\n+            );\n+        }\n+\n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & variates;\n+        }\n+\n+    private:\n+        std::vector<VariateType> variates;\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::tail_variate<>\n+//\n+namespace tag\n+{\n+    template<typename VariateType, typename VariateTag, typename LeftRight>\n+    struct tail_variate\n+      : depends_on<tail<LeftRight> >\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef mpl::always<accumulators::impl::tail_variate_impl<VariateType, VariateTag, LeftRight> > impl;\n+    };\n+\n+    struct abstract_tail_variate\n+      : depends_on<>\n+    {\n+    };\n+\n+    template<typename LeftRight>\n+    struct tail_weights\n+      : depends_on<tail<LeftRight> >\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::tail_variate_impl<mpl::_2, tag::weight, LeftRight> impl;\n+    };\n+\n+    struct abstract_tail_weights\n+      : depends_on<>\n+    {\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::tail_variate\n+// extract::tail_weights\n+//\n+namespace extract\n+{\n+    extractor<tag::abstract_tail_variate> const tail_variate = {};\n+    extractor<tag::abstract_tail_weights> const tail_weights = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(tail_variate)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(tail_weights)\n+}\n+\n+using extract::tail_variate;\n+using extract::tail_weights;\n+\n+template<typename VariateType, typename VariateTag, typename LeftRight>\n+struct feature_of<tag::tail_variate<VariateType, VariateTag, LeftRight> >\n+  : feature_of<tag::abstract_tail_variate>\n+{\n+};\n+\n+template<typename LeftRight>\n+struct feature_of<tag::tail_weights<LeftRight> >\n+{\n+    typedef tag::abstract_tail_weights type;\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "efe9f7c37e0947a67713845c3a53902398ccbd9e",
        "filename": "src/boost/accumulators/statistics/tail_variate_means.hpp",
        "status": "added",
        "additions": 270,
        "deletions": 0,
        "changes": 270,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/tail_variate_means.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/tail_variate_means.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/tail_variate_means.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,270 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// tail_variate_means.hpp\n+//\n+//  Copyright 2006 Daniel Egloff, Olivier Gygi. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_TAIL_VARIATE_MEANS_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_TAIL_VARIATE_MEANS_HPP_DE_01_01_2006\n+\n+#include <numeric>\n+#include <vector>\n+#include <limits>\n+#include <functional>\n+#include <sstream>\n+#include <stdexcept>\n+#include <boost/throw_exception.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/tail.hpp>\n+#include <boost/accumulators/statistics/tail_variate.hpp>\n+#include <boost/accumulators/statistics/tail_mean.hpp>\n+#include <boost/accumulators/statistics/parameters/quantile_probability.hpp>\n+#include <boost/serialization/vector.hpp>\n+\n+#ifdef _MSC_VER\n+# pragma warning(push)\n+# pragma warning(disable: 4127) // conditional expression is constant\n+#endif\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    /**\n+        @brief Estimation of the absolute and relative tail variate means (for both left and right tails)\n+\n+        For all \\f$j\\f$-th variates associated to the \\f$\\lceil n(1-\\alpha)\\rceil\\f$ largest samples (or the\n+        \\f$\\lceil n(1-\\alpha)\\rceil\\f$ smallest samples in case of the left tail), the absolute tail means\n+        \\f$\\widehat{ATM}_{n,\\alpha}(X, j)\\f$ are computed and returned as an iterator range. Alternatively,\n+        the relative tail means \\f$\\widehat{RTM}_{n,\\alpha}(X, j)\\f$ are returned, which are the absolute\n+        tail means normalized with the (non-coherent) sample tail mean \\f$\\widehat{NCTM}_{n,\\alpha}(X)\\f$.\n+\n+        \\f[\n+            \\widehat{ATM}_{n,\\alpha}^{\\mathrm{right}}(X, j) =\n+                \\frac{1}{\\lceil n(1-\\alpha) \\rceil}\n+                \\sum_{i=\\lceil \\alpha n \\rceil}^n \\xi_{j,i}\n+        \\f]\n+\n+        \\f[\n+            \\widehat{ATM}_{n,\\alpha}^{\\mathrm{left}}(X, j) =\n+                \\frac{1}{\\lceil n\\alpha \\rceil}\n+                \\sum_{i=1}^{\\lceil n\\alpha \\rceil} \\xi_{j,i}\n+        \\f]\n+\n+        \\f[\n+            \\widehat{RTM}_{n,\\alpha}^{\\mathrm{right}}(X, j) =\n+                \\frac{\\sum_{i=\\lceil n\\alpha \\rceil}^n \\xi_{j,i}}\n+            {\\lceil n(1-\\alpha)\\rceil\\widehat{NCTM}_{n,\\alpha}^{\\mathrm{right}}(X)}\n+        \\f]\n+\n+        \\f[\n+            \\widehat{RTM}_{n,\\alpha}^{\\mathrm{left}}(X, j) =\n+                \\frac{\\sum_{i=1}^{\\lceil n\\alpha \\rceil} \\xi_{j,i}}\n+            {\\lceil n\\alpha\\rceil\\widehat{NCTM}_{n,\\alpha}^{\\mathrm{left}}(X)}\n+        \\f]\n+    */\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // tail_variate_means_impl\n+    //  by default: absolute tail_variate_means\n+    template<typename Sample, typename Impl, typename LeftRight, typename VariateTag>\n+    struct tail_variate_means_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type float_type;\n+        typedef std::vector<float_type> array_type;\n+        // for boost::result_of\n+        typedef iterator_range<typename array_type::iterator> result_type;\n+\n+        tail_variate_means_impl(dont_care) {}\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            std::size_t cnt = count(args);\n+\n+            std::size_t n = static_cast<std::size_t>(\n+                std::ceil(\n+                    cnt * ( ( is_same<LeftRight, left>::value ) ? args[quantile_probability] : 1. - args[quantile_probability] )\n+                )\n+            );\n+\n+            std::size_t num_variates = tail_variate(args).begin()->size();\n+\n+            this->tail_means_.clear();\n+            this->tail_means_.resize(num_variates, Sample(0));\n+\n+            // If n is in a valid range, return result, otherwise return NaN or throw exception\n+            if (n < static_cast<std::size_t>(tail(args).size()))\n+            {\n+                this->tail_means_ = std::accumulate(\n+                    tail_variate(args).begin()\n+                  , tail_variate(args).begin() + n\n+                  , this->tail_means_\n+                  , numeric::plus\n+                );\n+\n+                float_type factor = n * ( (is_same<Impl, relative>::value) ? non_coherent_tail_mean(args) : 1. );\n+\n+                std::transform(\n+                    this->tail_means_.begin()\n+                  , this->tail_means_.end()\n+                  , this->tail_means_.begin()\n+#ifdef BOOST_NO_CXX98_BINDERS\n+                  , std::bind(std::divides<float_type>(), std::placeholders::_1, factor)\n+#else\n+                  , std::bind2nd(std::divides<float_type>(), factor)\n+#endif\n+                );\n+            }\n+            else\n+            {\n+                if (std::numeric_limits<float_type>::has_quiet_NaN)\n+                {\n+                    std::fill(\n+                        this->tail_means_.begin()\n+                      , this->tail_means_.end()\n+                      , std::numeric_limits<float_type>::quiet_NaN()\n+                    );\n+                }\n+                else\n+                {\n+                    std::ostringstream msg;\n+                    msg << \"index n = \" << n << \" is not in valid range [0, \" << tail(args).size() << \")\";\n+                    boost::throw_exception(std::runtime_error(msg.str()));\n+                }\n+            }\n+            return make_iterator_range(this->tail_means_);\n+        }\n+\n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & tail_means_;\n+        }\n+\n+    private:\n+\n+        mutable array_type tail_means_;\n+\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::absolute_tail_variate_means\n+// tag::relative_tail_variate_means\n+//\n+namespace tag\n+{\n+    template<typename LeftRight, typename VariateType, typename VariateTag>\n+    struct absolute_tail_variate_means\n+      : depends_on<count, non_coherent_tail_mean<LeftRight>, tail_variate<VariateType, VariateTag, LeftRight> >\n+    {\n+        typedef accumulators::impl::tail_variate_means_impl<mpl::_1, absolute, LeftRight, VariateTag> impl;\n+    };\n+    template<typename LeftRight, typename VariateType, typename VariateTag>\n+    struct relative_tail_variate_means\n+      : depends_on<count, non_coherent_tail_mean<LeftRight>, tail_variate<VariateType, VariateTag, LeftRight> >\n+    {\n+        typedef accumulators::impl::tail_variate_means_impl<mpl::_1, relative, LeftRight, VariateTag> impl;\n+    };\n+    struct abstract_absolute_tail_variate_means\n+      : depends_on<>\n+    {\n+    };\n+    struct abstract_relative_tail_variate_means\n+      : depends_on<>\n+    {\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::tail_variate_means\n+// extract::relative_tail_variate_means\n+//\n+namespace extract\n+{\n+    extractor<tag::abstract_absolute_tail_variate_means> const tail_variate_means = {};\n+    extractor<tag::abstract_relative_tail_variate_means> const relative_tail_variate_means = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(tail_variate_means)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(relative_tail_variate_means)\n+}\n+\n+using extract::tail_variate_means;\n+using extract::relative_tail_variate_means;\n+\n+// tail_variate_means<LeftRight, VariateType, VariateTag>(absolute) -> absolute_tail_variate_means<LeftRight, VariateType, VariateTag>\n+template<typename LeftRight, typename VariateType, typename VariateTag>\n+struct as_feature<tag::tail_variate_means<LeftRight, VariateType, VariateTag>(absolute)>\n+{\n+    typedef tag::absolute_tail_variate_means<LeftRight, VariateType, VariateTag> type;\n+};\n+\n+// tail_variate_means<LeftRight, VariateType, VariateTag>(relative) ->relative_tail_variate_means<LeftRight, VariateType, VariateTag>\n+template<typename LeftRight, typename VariateType, typename VariateTag>\n+struct as_feature<tag::tail_variate_means<LeftRight, VariateType, VariateTag>(relative)>\n+{\n+    typedef tag::relative_tail_variate_means<LeftRight, VariateType, VariateTag> type;\n+};\n+\n+// Provides non-templatized extractor\n+template<typename LeftRight, typename VariateType, typename VariateTag>\n+struct feature_of<tag::absolute_tail_variate_means<LeftRight, VariateType, VariateTag> >\n+  : feature_of<tag::abstract_absolute_tail_variate_means>\n+{\n+};\n+\n+// Provides non-templatized extractor\n+template<typename LeftRight, typename VariateType, typename VariateTag>\n+struct feature_of<tag::relative_tail_variate_means<LeftRight, VariateType, VariateTag> >\n+  : feature_of<tag::abstract_relative_tail_variate_means>\n+{\n+};\n+\n+// So that absolute_tail_means can be automatically substituted\n+// with absolute_weighted_tail_means when the weight parameter is non-void.\n+template<typename LeftRight, typename VariateType, typename VariateTag>\n+struct as_weighted_feature<tag::absolute_tail_variate_means<LeftRight, VariateType, VariateTag> >\n+{\n+    typedef tag::absolute_weighted_tail_variate_means<LeftRight, VariateType, VariateTag> type;\n+};\n+\n+template<typename LeftRight, typename VariateType, typename VariateTag>\n+struct feature_of<tag::absolute_weighted_tail_variate_means<LeftRight, VariateType, VariateTag> >\n+  : feature_of<tag::absolute_tail_variate_means<LeftRight, VariateType, VariateTag> >\n+{\n+};\n+\n+// So that relative_tail_means can be automatically substituted\n+// with relative_weighted_tail_means when the weight parameter is non-void.\n+template<typename LeftRight, typename VariateType, typename VariateTag>\n+struct as_weighted_feature<tag::relative_tail_variate_means<LeftRight, VariateType, VariateTag> >\n+{\n+    typedef tag::relative_weighted_tail_variate_means<LeftRight, VariateType, VariateTag> type;\n+};\n+\n+template<typename LeftRight, typename VariateType, typename VariateTag>\n+struct feature_of<tag::relative_weighted_tail_variate_means<LeftRight, VariateType, VariateTag> >\n+  : feature_of<tag::relative_tail_variate_means<LeftRight, VariateType, VariateTag> >\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#ifdef _MSC_VER\n+# pragma warning(pop)\n+#endif\n+\n+#endif"
      },
      {
        "sha": "dbd81af7cf9570ea3458f54add40f920dce32d63",
        "filename": "src/boost/accumulators/statistics/times2_iterator.hpp",
        "status": "added",
        "additions": 70,
        "deletions": 0,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/times2_iterator.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/times2_iterator.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/times2_iterator.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,70 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// times2_iterator.hpp\n+//\n+//  Copyright 2006 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_TIMES2_ITERATOR_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_TIMES2_ITERATOR_HPP_DE_01_01_2006\n+\n+#include <functional>\n+#include <boost/detail/workaround.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+#include <boost/range/iterator_range.hpp>\n+#include <boost/iterator/transform_iterator.hpp>\n+#include <boost/iterator/counting_iterator.hpp>\n+#include <boost/iterator/permutation_iterator.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace detail\n+{\n+    typedef transform_iterator<\n+#ifdef BOOST_NO_CXX98_BINDERS\n+        decltype(std::bind(std::multiplies<std::size_t>(), 2, std::placeholders::_1))\n+#else\n+        std::binder1st<std::multiplies<std::size_t> >\n+#endif\n+      , counting_iterator<std::size_t>\n+    > times2_iterator;\n+\n+    inline times2_iterator make_times2_iterator(std::size_t i)\n+    {\n+        return make_transform_iterator(\n+            make_counting_iterator(i)\n+#ifdef BOOST_NO_CXX98_BINDERS\n+          , std::bind(std::multiplies<std::size_t>(), 2, std::placeholders::_1)\n+#else\n+          , std::bind1st(std::multiplies<std::size_t>(), 2)\n+#endif\n+        );\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // lvalue_index_iterator\n+    template<typename Base>\n+    struct lvalue_index_iterator\n+      : Base\n+    {\n+        lvalue_index_iterator()\n+          : Base()\n+        {}\n+\n+        lvalue_index_iterator(Base base)\n+          : Base(base)\n+        {\n+        }\n+\n+        typename Base::reference operator [](typename Base::difference_type n) const\n+        {\n+            return *(*this + n);\n+        }\n+    };\n+} // namespace detail\n+\n+}}\n+\n+#endif"
      },
      {
        "sha": "9db858d2fb02770a9ea892ed365c126aacdc4e7b",
        "filename": "src/boost/accumulators/statistics/variance.hpp",
        "status": "added",
        "additions": 247,
        "deletions": 0,
        "changes": 247,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/variance.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/variance.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/variance.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,247 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// variance.hpp\n+//\n+//  Copyright 2005 Daniel Egloff, Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_VARIANCE_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_VARIANCE_HPP_EAN_28_10_2005\n+\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+#include <boost/accumulators/statistics/sum.hpp>\n+#include <boost/accumulators/statistics/mean.hpp>\n+#include <boost/accumulators/statistics/moment.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    //! Lazy calculation of variance.\n+    /*!\n+        Default sample variance implementation based on the second moment \\f$ M_n^{(2)} \\f$ moment<2>, mean and count.\n+        \\f[\n+            \\sigma_n^2 = M_n^{(2)} - \\mu_n^2.\n+        \\f]\n+        where\n+        \\f[\n+            \\mu_n = \\frac{1}{n} \\sum_{i = 1}^n x_i.\n+        \\f]\n+        is the estimate of the sample mean and \\f$n\\f$ is the number of samples.\n+    */\n+    template<typename Sample, typename MeanFeature>\n+    struct lazy_variance_impl\n+      : accumulator_base\n+    {\n+        // for boost::result_of\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type result_type;\n+\n+        lazy_variance_impl(dont_care) {}\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            extractor<MeanFeature> mean;\n+            result_type tmp = mean(args);\n+            return accumulators::moment<2>(args) - tmp * tmp;\n+        }\n+        \n+        // serialization is done by accumulators it depends on\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version) {}\n+    };\n+\n+    //! Iterative calculation of variance.\n+    /*!\n+        Iterative calculation of sample variance \\f$\\sigma_n^2\\f$ according to the formula\n+        \\f[\n+            \\sigma_n^2 = \\frac{1}{n} \\sum_{i = 1}^n (x_i - \\mu_n)^2 = \\frac{n-1}{n} \\sigma_{n-1}^2 + \\frac{1}{n-1}(x_n - \\mu_n)^2.\n+        \\f]\n+        where\n+        \\f[\n+            \\mu_n = \\frac{1}{n} \\sum_{i = 1}^n x_i.\n+        \\f]\n+        is the estimate of the sample mean and \\f$n\\f$ is the number of samples.\n+\n+        Note that the sample variance is not defined for \\f$n <= 1\\f$.\n+\n+        A simplification can be obtained by the approximate recursion\n+        \\f[\n+            \\sigma_n^2 \\approx \\frac{n-1}{n} \\sigma_{n-1}^2 + \\frac{1}{n}(x_n - \\mu_n)^2.\n+        \\f]\n+        because the difference\n+        \\f[\n+            \\left(\\frac{1}{n-1} - \\frac{1}{n}\\right)(x_n - \\mu_n)^2 = \\frac{1}{n(n-1)}(x_n - \\mu_n)^2.\n+        \\f]\n+        converges to zero as \\f$n \\rightarrow \\infty\\f$. However, for small \\f$ n \\f$ the difference\n+        can be non-negligible.\n+    */\n+    template<typename Sample, typename MeanFeature, typename Tag>\n+    struct variance_impl\n+      : accumulator_base\n+    {\n+        // for boost::result_of\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type result_type;\n+\n+        template<typename Args>\n+        variance_impl(Args const &args)\n+          : variance(numeric::fdiv(args[sample | Sample()], numeric::one<std::size_t>::value))\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            std::size_t cnt = count(args);\n+\n+            if(cnt > 1)\n+            {\n+                extractor<MeanFeature> mean;\n+                result_type tmp = args[parameter::keyword<Tag>::get()] - mean(args);\n+                this->variance =\n+                    numeric::fdiv(this->variance * (cnt - 1), cnt)\n+                  + numeric::fdiv(tmp * tmp, cnt - 1);\n+            }\n+        }\n+\n+        result_type result(dont_care) const\n+        {\n+            return this->variance;\n+        }\n+\n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & variance;\n+        }\n+\n+    private:\n+        result_type variance;\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::variance\n+// tag::immediate_variance\n+//\n+namespace tag\n+{\n+    struct lazy_variance\n+      : depends_on<moment<2>, mean>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::lazy_variance_impl<mpl::_1, mean> impl;\n+    };\n+\n+    struct variance\n+      : depends_on<count, immediate_mean>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::variance_impl<mpl::_1, mean, sample> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::lazy_variance\n+// extract::variance\n+//\n+namespace extract\n+{\n+    extractor<tag::lazy_variance> const lazy_variance = {};\n+    extractor<tag::variance> const variance = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(lazy_variance)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(variance)\n+}\n+\n+using extract::lazy_variance;\n+using extract::variance;\n+\n+// variance(lazy) -> lazy_variance\n+template<>\n+struct as_feature<tag::variance(lazy)>\n+{\n+    typedef tag::lazy_variance type;\n+};\n+\n+// variance(immediate) -> variance\n+template<>\n+struct as_feature<tag::variance(immediate)>\n+{\n+    typedef tag::variance type;\n+};\n+\n+// for the purposes of feature-based dependency resolution,\n+// immediate_variance provides the same feature as variance\n+template<>\n+struct feature_of<tag::lazy_variance>\n+  : feature_of<tag::variance>\n+{\n+};\n+\n+// So that variance can be automatically substituted with\n+// weighted_variance when the weight parameter is non-void.\n+template<>\n+struct as_weighted_feature<tag::variance>\n+{\n+    typedef tag::weighted_variance type;\n+};\n+\n+// for the purposes of feature-based dependency resolution,\n+// weighted_variance provides the same feature as variance\n+template<>\n+struct feature_of<tag::weighted_variance>\n+  : feature_of<tag::variance>\n+{\n+};\n+\n+// So that immediate_variance can be automatically substituted with\n+// immediate_weighted_variance when the weight parameter is non-void.\n+template<>\n+struct as_weighted_feature<tag::lazy_variance>\n+{\n+    typedef tag::lazy_weighted_variance type;\n+};\n+\n+// for the purposes of feature-based dependency resolution,\n+// immediate_weighted_variance provides the same feature as immediate_variance\n+template<>\n+struct feature_of<tag::lazy_weighted_variance>\n+  : feature_of<tag::lazy_variance>\n+{\n+};\n+\n+////////////////////////////////////////////////////////////////////////////\n+//// droppable_accumulator<variance_impl>\n+////  need to specialize droppable lazy variance to cache the result at the\n+////  point the accumulator is dropped.\n+///// INTERNAL ONLY\n+/////\n+//template<typename Sample, typename MeanFeature>\n+//struct droppable_accumulator<impl::variance_impl<Sample, MeanFeature> >\n+//  : droppable_accumulator_base<\n+//        with_cached_result<impl::variance_impl<Sample, MeanFeature> >\n+//    >\n+//{\n+//    template<typename Args>\n+//    droppable_accumulator(Args const &args)\n+//      : droppable_accumulator::base(args)\n+//    {\n+//    }\n+//};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "aba113a4a316c5b4784ee12d8550e9a9998d0570",
        "filename": "src/boost/accumulators/statistics/variates/covariate.hpp",
        "status": "added",
        "additions": 25,
        "deletions": 0,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/variates/covariate.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/variates/covariate.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/variates/covariate.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,25 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// weight.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_VARIATES_COVARIATE_HPP_EAN_03_11_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_VARIATES_COVARIATE_HPP_EAN_03_11_2005\n+\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/accumulators/accumulators_fwd.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+BOOST_PARAMETER_KEYWORD(tag, covariate1)\n+BOOST_PARAMETER_KEYWORD(tag, covariate2)\n+\n+BOOST_ACCUMULATORS_IGNORE_GLOBAL(covariate1)\n+BOOST_ACCUMULATORS_IGNORE_GLOBAL(covariate2)\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "e423a225a99871738f44d59f20c0b646f400b22e",
        "filename": "src/boost/accumulators/statistics/weighted_covariance.hpp",
        "status": "added",
        "additions": 140,
        "deletions": 0,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_covariance.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_covariance.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/weighted_covariance.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,140 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// weighted_covariance.hpp\n+//\n+//  Copyright 2006 Daniel Egloff, Olivier Gygi. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_COVARIANCE_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_COVARIANCE_HPP_DE_01_01_2006\n+\n+#include <vector>\n+#include <limits>\n+#include <numeric>\n+#include <functional>\n+#include <complex>\n+#include <boost/mpl/assert.hpp>\n+#include <boost/mpl/bool.hpp>\n+#include <boost/range.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/numeric/ublas/io.hpp>\n+#include <boost/numeric/ublas/matrix.hpp>\n+#include <boost/type_traits/is_scalar.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+#include <boost/accumulators/statistics/covariance.hpp> // for numeric::outer_product() and type traits\n+#include <boost/accumulators/statistics/weighted_mean.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // weighted_covariance_impl\n+    //\n+    /**\n+        @brief Weighted Covariance Estimator\n+\n+        An iterative Monte Carlo estimator for the weighted covariance \\f$\\mathrm{Cov}(X,X')\\f$, where \\f$X\\f$ is a sample\n+        and \\f$X'\\f$ a variate, is given by:\n+\n+        \\f[\n+            \\hat{c}_n = \\frac{\\bar{w}_n-w_n}{\\bar{w}_n} \\hat{c}_{n-1} + \\frac{w_n}{\\bar{w}_n-w_n}(X_n - \\hat{\\mu}_n)(X_n' - \\hat{\\mu}_n'),\n+            \\quad n\\ge2,\\quad\\hat{c}_1 = 0,\n+        \\f]\n+\n+        \\f$\\hat{\\mu}_n\\f$ and \\f$\\hat{\\mu}_n'\\f$ being the weighted means of the samples and variates and\n+        \\f$\\bar{w}_n\\f$ the sum of the \\f$n\\f$ first weights \\f$w_i\\f$.\n+    */\n+    template<typename Sample, typename Weight, typename VariateType, typename VariateTag>\n+    struct weighted_covariance_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::multiplies<Weight, typename numeric::functional::fdiv<Sample, std::size_t>::result_type>::result_type weighted_sample_type;\n+        typedef typename numeric::functional::multiplies<Weight, typename numeric::functional::fdiv<VariateType, std::size_t>::result_type>::result_type weighted_variate_type;\n+        // for boost::result_of\n+        typedef typename numeric::functional::outer_product<weighted_sample_type, weighted_variate_type>::result_type result_type;\n+\n+        template<typename Args>\n+        weighted_covariance_impl(Args const &args)\n+          : cov_(\n+                numeric::outer_product(\n+                    numeric::fdiv(args[sample | Sample()], (std::size_t)1)\n+                      * numeric::one<Weight>::value\n+                  , numeric::fdiv(args[parameter::keyword<VariateTag>::get() | VariateType()], (std::size_t)1)\n+                      * numeric::one<Weight>::value\n+                )\n+            )\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            std::size_t cnt = count(args);\n+\n+            if (cnt > 1)\n+            {\n+                extractor<tag::weighted_mean_of_variates<VariateType, VariateTag> > const some_weighted_mean_of_variates = {};\n+\n+                this->cov_ = this->cov_ * (sum_of_weights(args) - args[weight]) / sum_of_weights(args)\n+                           + numeric::outer_product(\n+                                 some_weighted_mean_of_variates(args) - args[parameter::keyword<VariateTag>::get()]\n+                               , weighted_mean(args) - args[sample]\n+                             ) * args[weight] / (sum_of_weights(args) - args[weight]);\n+            }\n+        }\n+\n+        result_type result(dont_care) const\n+        {\n+            return this->cov_;\n+        }\n+\n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & cov_;\n+        }\n+\n+    private:\n+        result_type cov_;\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::weighted_covariance\n+//\n+namespace tag\n+{\n+    template<typename VariateType, typename VariateTag>\n+    struct weighted_covariance\n+      : depends_on<count, sum_of_weights, weighted_mean, weighted_mean_of_variates<VariateType, VariateTag> >\n+    {\n+        typedef accumulators::impl::weighted_covariance_impl<mpl::_1, mpl::_2, VariateType, VariateTag> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::weighted_covariance\n+//\n+namespace extract\n+{\n+    extractor<tag::abstract_covariance> const weighted_covariance = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(weighted_covariance)\n+}\n+\n+using extract::weighted_covariance;\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "6b5a0ee015ad7098b18bbb83738f77a354874271",
        "filename": "src/boost/accumulators/statistics/weighted_density.hpp",
        "status": "added",
        "additions": 237,
        "deletions": 0,
        "changes": 237,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_density.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_density.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/weighted_density.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,237 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// weighted_density.hpp\n+//\n+//  Copyright 2006 Daniel Egloff, Olivier Gygi. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_DENSITY_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_DENSITY_HPP_DE_01_01_2006\n+\n+#include <vector>\n+#include <limits>\n+#include <functional>\n+#include <boost/range.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/sum.hpp>\n+#include <boost/accumulators/statistics/max.hpp>\n+#include <boost/accumulators/statistics/min.hpp>\n+#include <boost/accumulators/statistics/density.hpp> // for named parameters density_cache_size and density_num_bins\n+#include <boost/serialization/vector.hpp>\n+#include <boost/serialization/utility.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // weighted_density_impl\n+    //  density histogram for weighted samples\n+    /**\n+        @brief Histogram density estimator for weighted samples\n+\n+        The histogram density estimator returns a histogram of the sample distribution. The positions and sizes of the bins\n+        are determined using a specifiable number of cached samples (cache_size). The range between the minimum and the\n+        maximum of the cached samples is subdivided into a specifiable number of bins (num_bins) of same size. Additionally,\n+        an under- and an overflow bin is added to capture future under- and overflow samples. Once the bins are determined,\n+        the cached samples and all subsequent samples are added to the correct bins. At the end, a range of std::pair is\n+        returned, where each pair contains the position of the bin (lower bound) and the sum of the weights (normalized with the\n+        sum of all weights).\n+\n+        @param density_cache_size Number of first samples used to determine min and max.\n+        @param density_num_bins Number of bins (two additional bins collect under- and overflow samples).\n+    */\n+    template<typename Sample, typename Weight>\n+    struct weighted_density_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::fdiv<Weight, std::size_t>::result_type float_type;\n+        typedef std::vector<std::pair<float_type, float_type> > histogram_type;\n+        typedef std::vector<float_type> array_type;\n+        // for boost::result_of\n+        typedef iterator_range<typename histogram_type::iterator> result_type;\n+\n+        template<typename Args>\n+        weighted_density_impl(Args const &args)\n+            : cache_size(args[density_cache_size])\n+            , cache(cache_size)\n+            , num_bins(args[density_num_bins])\n+            , samples_in_bin(num_bins + 2, 0.)\n+            , bin_positions(num_bins + 2)\n+            , histogram(\n+                num_bins + 2\n+              , std::make_pair(\n+                    numeric::fdiv(args[sample | Sample()],(std::size_t)1)\n+                  , numeric::fdiv(args[sample | Sample()],(std::size_t)1)\n+                )\n+              )\n+            , is_dirty(true)\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            this->is_dirty = true;\n+\n+            std::size_t cnt = count(args);\n+\n+            // Fill up cache with cache_size first samples\n+            if (cnt <= this->cache_size)\n+            {\n+                this->cache[cnt - 1] = std::make_pair(args[sample], args[weight]);\n+            }\n+\n+            // Once cache_size samples have been accumulated, create num_bins bins of same size between\n+            // the minimum and maximum of the cached samples as well as an under- and an overflow bin.\n+            // Store their lower bounds (bin_positions) and fill the bins with the cached samples (samples_in_bin).\n+            if (cnt == this->cache_size)\n+            {\n+                float_type minimum = numeric::fdiv((min)(args),(std::size_t)1);\n+                float_type maximum = numeric::fdiv((max)(args),(std::size_t)1);\n+                float_type bin_size = numeric::fdiv(maximum - minimum, this->num_bins);\n+\n+                // determine bin positions (their lower bounds)\n+                for (std::size_t i = 0; i < this->num_bins + 2; ++i)\n+                {\n+                    this->bin_positions[i] = minimum + (i - 1.) * bin_size;\n+                }\n+\n+                for (typename histogram_type::const_iterator iter = this->cache.begin(); iter != this->cache.end(); ++iter)\n+                {\n+                    if (iter->first < this->bin_positions[1])\n+                    {\n+                        this->samples_in_bin[0] += iter->second;\n+                    }\n+                    else if (iter->first >= this->bin_positions[this->num_bins + 1])\n+                    {\n+                        this->samples_in_bin[this->num_bins + 1] += iter->second;\n+                    }\n+                    else\n+                    {\n+                        typename array_type::iterator it = std::upper_bound(\n+                            this->bin_positions.begin()\n+                          , this->bin_positions.end()\n+                          , iter->first\n+                        );\n+\n+                        std::size_t d = std::distance(this->bin_positions.begin(), it);\n+                        this->samples_in_bin[d - 1] += iter->second;\n+                    }\n+                }\n+            }\n+            // Add each subsequent sample to the correct bin\n+            else if (cnt > this->cache_size)\n+            {\n+                if (args[sample] < this->bin_positions[1])\n+                {\n+                    this->samples_in_bin[0] += args[weight];\n+                }\n+                else if (args[sample] >= this->bin_positions[this->num_bins + 1])\n+                {\n+                    this->samples_in_bin[this->num_bins + 1] += args[weight];\n+                }\n+                else\n+                {\n+                    typename array_type::iterator it = std::upper_bound(\n+                        this->bin_positions.begin()\n+                      , this->bin_positions.end()\n+                      , args[sample]\n+                    );\n+\n+                    std::size_t d = std::distance(this->bin_positions.begin(), it);\n+                    this->samples_in_bin[d - 1] += args[weight];\n+                }\n+            }\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            if (this->is_dirty)\n+            {\n+                this->is_dirty = false;\n+\n+                // creates a vector of std::pair where each pair i holds\n+                // the values bin_positions[i] (x-axis of histogram) and\n+                // samples_in_bin[i] / cnt (y-axis of histogram).\n+\n+                for (std::size_t i = 0; i < this->num_bins + 2; ++i)\n+                {\n+                    this->histogram[i] = std::make_pair(this->bin_positions[i], numeric::fdiv(this->samples_in_bin[i], sum_of_weights(args)));\n+                }\n+            }\n+\n+            // returns a range of pairs\n+            return make_iterator_range(this->histogram);\n+        }\n+\n+        // make this accumulator serializeable\n+        // TODO split to save/load and check on parameters provided in ctor\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        {\n+            ar & cache_size;\n+            ar & cache;\n+            ar & num_bins;\n+            ar & samples_in_bin;\n+            ar & bin_positions;\n+            ar & histogram;\n+            ar & is_dirty; \n+        }\n+\n+    private:\n+        std::size_t            cache_size;      // number of cached samples\n+        histogram_type         cache;           // cache to store the first cache_size samples with their weights as std::pair\n+        std::size_t            num_bins;        // number of bins\n+        array_type             samples_in_bin;  // number of samples in each bin\n+        array_type             bin_positions;   // lower bounds of bins\n+        mutable histogram_type histogram;       // histogram\n+        mutable bool is_dirty;\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::weighted_density\n+//\n+namespace tag\n+{\n+    struct weighted_density\n+      : depends_on<count, sum_of_weights, min, max>\n+      , density_cache_size\n+      , density_num_bins\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::weighted_density_impl<mpl::_1, mpl::_2> impl;\n+\n+        #ifdef BOOST_ACCUMULATORS_DOXYGEN_INVOKED\n+        static boost::parameter::keyword<density_cache_size> const cache_size;\n+        static boost::parameter::keyword<density_num_bins> const num_bins;\n+        #endif\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::weighted_density\n+//\n+namespace extract\n+{\n+    extractor<tag::density> const weighted_density = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(weighted_density)\n+}\n+\n+using extract::weighted_density;\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "f88e9b9ee8b35f10150a39b6d26b5a3737c7322b",
        "filename": "src/boost/accumulators/statistics/weighted_extended_p_square.hpp",
        "status": "added",
        "additions": 302,
        "deletions": 0,
        "changes": 302,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_extended_p_square.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_extended_p_square.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/weighted_extended_p_square.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,302 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// weighted_extended_p_square.hpp\n+//\n+//  Copyright 2005 Daniel Egloff. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_EXTENDED_P_SQUARE_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_EXTENDED_P_SQUARE_HPP_DE_01_01_2006\n+\n+#include <vector>\n+#include <functional>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+#include <boost/range/iterator_range.hpp>\n+#include <boost/iterator/transform_iterator.hpp>\n+#include <boost/iterator/counting_iterator.hpp>\n+#include <boost/iterator/permutation_iterator.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+#include <boost/accumulators/statistics/sum.hpp>\n+#include <boost/accumulators/statistics/times2_iterator.hpp>\n+#include <boost/accumulators/statistics/extended_p_square.hpp>\n+#include <boost/serialization/vector.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // weighted_extended_p_square_impl\n+    //  multiple quantile estimation with weighted samples\n+    /**\n+        @brief Multiple quantile estimation with the extended \\f$P^2\\f$ algorithm for weighted samples\n+\n+        This version of the extended \\f$P^2\\f$ algorithm extends the extended \\f$P^2\\f$ algorithm to\n+        support weighted samples. The extended \\f$P^2\\f$ algorithm dynamically estimates several\n+        quantiles without storing samples. Assume that \\f$m\\f$ quantiles\n+        \\f$\\xi_{p_1}, \\ldots, \\xi_{p_m}\\f$ are to be estimated. Instead of storing the whole sample\n+        cumulative distribution, the algorithm maintains only \\f$m+2\\f$ principal markers and\n+        \\f$m+1\\f$ middle markers, whose positions are updated with each sample and whose heights\n+        are adjusted (if necessary) using a piecewise-parablic formula. The heights of the principal\n+        markers are the current estimates of the quantiles and are returned as an iterator range.\n+\n+        For further details, see\n+\n+        K. E. E. Raatikainen, Simultaneous estimation of several quantiles, Simulation, Volume 49,\n+        Number 4 (October), 1986, p. 159-164.\n+\n+        The extended \\f$ P^2 \\f$ algorithm generalizes the \\f$ P^2 \\f$ algorithm of\n+\n+        R. Jain and I. Chlamtac, The P^2 algorithm for dynamic calculation of quantiles and\n+        histograms without storing observations, Communications of the ACM,\n+        Volume 28 (October), Number 10, 1985, p. 1076-1085.\n+\n+        @param extended_p_square_probabilities A vector of quantile probabilities.\n+    */\n+    template<typename Sample, typename Weight>\n+    struct weighted_extended_p_square_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::multiplies<Sample, Weight>::result_type weighted_sample;\n+        typedef typename numeric::functional::fdiv<weighted_sample, std::size_t>::result_type float_type;\n+        typedef std::vector<float_type> array_type;\n+        // for boost::result_of\n+        typedef iterator_range<\n+            detail::lvalue_index_iterator<\n+                permutation_iterator<\n+                    typename array_type::const_iterator\n+                  , detail::times2_iterator\n+                >\n+            >\n+        > result_type;\n+\n+        template<typename Args>\n+        weighted_extended_p_square_impl(Args const &args)\n+          : probabilities(\n+                boost::begin(args[extended_p_square_probabilities])\n+              , boost::end(args[extended_p_square_probabilities])\n+            )\n+          , heights(2 * probabilities.size() + 3)\n+          , actual_positions(heights.size())\n+          , desired_positions(heights.size())\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            std::size_t cnt = count(args);\n+            std::size_t sample_cell = 1; // k\n+            std::size_t num_quantiles = this->probabilities.size();\n+\n+            // m+2 principal markers and m+1 middle markers\n+            std::size_t num_markers = 2 * num_quantiles + 3;\n+\n+            // first accumulate num_markers samples\n+            if(cnt <= num_markers)\n+            {\n+                this->heights[cnt - 1] = args[sample];\n+                this->actual_positions[cnt - 1] = args[weight];\n+\n+                // complete the initialization of heights (and actual_positions) by sorting\n+                if(cnt == num_markers)\n+                {\n+                    // TODO: we need to sort the initial samples (in heights) in ascending order and\n+                    // sort their weights (in actual_positions) the same way. The following lines do\n+                    // it, but there must be a better and more efficient way of doing this.\n+                    typename array_type::iterator it_begin, it_end, it_min;\n+\n+                    it_begin = this->heights.begin();\n+                    it_end   = this->heights.end();\n+\n+                    std::size_t pos = 0;\n+\n+                    while (it_begin != it_end)\n+                    {\n+                        it_min = std::min_element(it_begin, it_end);\n+                        std::size_t d = std::distance(it_begin, it_min);\n+                        std::swap(*it_begin, *it_min);\n+                        std::swap(this->actual_positions[pos], this->actual_positions[pos + d]);\n+                        ++it_begin;\n+                        ++pos;\n+                    }\n+\n+                    // calculate correct initial actual positions\n+                    for (std::size_t i = 1; i < num_markers; ++i)\n+                    {\n+                        actual_positions[i] += actual_positions[i - 1];\n+                    }\n+                }\n+            }\n+            else\n+            {\n+                if(args[sample] < this->heights[0])\n+                {\n+                    this->heights[0] = args[sample];\n+                    this->actual_positions[0] = args[weight];\n+                    sample_cell = 1;\n+                }\n+                else if(args[sample] >= this->heights[num_markers - 1])\n+                {\n+                    this->heights[num_markers - 1] = args[sample];\n+                    sample_cell = num_markers - 1;\n+                }\n+                else\n+                {\n+                    // find cell k = sample_cell such that heights[k-1] <= sample < heights[k]\n+\n+                    typedef typename array_type::iterator iterator;\n+                    iterator it = std::upper_bound(\n+                        this->heights.begin()\n+                      , this->heights.end()\n+                      , args[sample]\n+                    );\n+\n+                    sample_cell = std::distance(this->heights.begin(), it);\n+                }\n+\n+                // update actual position of all markers above sample_cell\n+                for(std::size_t i = sample_cell; i < num_markers; ++i)\n+                {\n+                    this->actual_positions[i] += args[weight];\n+                }\n+\n+                // compute desired positions\n+                {\n+                    this->desired_positions[0] = this->actual_positions[0];\n+                    this->desired_positions[num_markers - 1] = sum_of_weights(args);\n+                    this->desired_positions[1] = (sum_of_weights(args) - this->actual_positions[0]) * probabilities[0]\n+                                              / 2. + this->actual_positions[0];\n+                    this->desired_positions[num_markers - 2] = (sum_of_weights(args) - this->actual_positions[0])\n+                                                            * (probabilities[num_quantiles - 1] + 1.)\n+                                                            / 2. + this->actual_positions[0];\n+\n+                    for (std::size_t i = 0; i < num_quantiles; ++i)\n+                    {\n+                        this->desired_positions[2 * i + 2] = (sum_of_weights(args) - this->actual_positions[0])\n+                                                          * probabilities[i] + this->actual_positions[0];\n+                    }\n+\n+                    for (std::size_t i = 1; i < num_quantiles; ++i)\n+                    {\n+                        this->desired_positions[2 * i + 1] = (sum_of_weights(args) - this->actual_positions[0])\n+                                                      * (probabilities[i - 1] + probabilities[i])\n+                                                      / 2. + this->actual_positions[0];\n+                    }\n+                }\n+\n+                // adjust heights and actual_positions of markers 1 to num_markers - 2 if necessary\n+                for (std::size_t i = 1; i <= num_markers - 2; ++i)\n+                {\n+                    // offset to desired position\n+                    float_type d = this->desired_positions[i] - this->actual_positions[i];\n+\n+                    // offset to next position\n+                    float_type dp = this->actual_positions[i + 1] - this->actual_positions[i];\n+\n+                    // offset to previous position\n+                    float_type dm = this->actual_positions[i - 1] - this->actual_positions[i];\n+\n+                    // height ds\n+                    float_type hp = (this->heights[i + 1] - this->heights[i]) / dp;\n+                    float_type hm = (this->heights[i - 1] - this->heights[i]) / dm;\n+\n+                    if((d >= 1 && dp > 1) || (d <= -1 && dm < -1))\n+                    {\n+                        short sign_d = static_cast<short>(d / std::abs(d));\n+\n+                        float_type h = this->heights[i] + sign_d / (dp - dm) * ((sign_d - dm)*hp + (dp - sign_d) * hm);\n+\n+                        // try adjusting heights[i] using p-squared formula\n+                        if(this->heights[i - 1] < h && h < this->heights[i + 1])\n+                        {\n+                            this->heights[i] = h;\n+                        }\n+                        else\n+                        {\n+                            // use linear formula\n+                            if(d > 0)\n+                            {\n+                                this->heights[i] += hp;\n+                            }\n+                            if(d < 0)\n+                            {\n+                                this->heights[i] -= hm;\n+                            }\n+                        }\n+                        this->actual_positions[i] += sign_d;\n+                    }\n+                }\n+            }\n+        }\n+\n+        result_type result(dont_care) const\n+        {\n+            // for i in [1,probabilities.size()], return heights[i * 2]\n+            detail::times2_iterator idx_begin = detail::make_times2_iterator(1);\n+            detail::times2_iterator idx_end = detail::make_times2_iterator(this->probabilities.size() + 1);\n+\n+            return result_type(\n+                make_permutation_iterator(this->heights.begin(), idx_begin)\n+              , make_permutation_iterator(this->heights.begin(), idx_end)\n+            );\n+        }\n+\n+        // make this accumulator serializeable\n+        // TODO: do we need to split to load/save and verify that the parameters did not change?\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & probabilities;\n+            ar & heights;\n+            ar & actual_positions;\n+            ar & desired_positions;\n+        }\n+\n+    private:\n+        array_type probabilities;         // the quantile probabilities\n+        array_type heights;               // q_i\n+        array_type actual_positions;      // n_i\n+        array_type desired_positions;     // d_i\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::weighted_extended_p_square\n+//\n+namespace tag\n+{\n+    struct weighted_extended_p_square\n+      : depends_on<count, sum_of_weights>\n+      , extended_p_square_probabilities\n+    {\n+        typedef accumulators::impl::weighted_extended_p_square_impl<mpl::_1, mpl::_2> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::weighted_extended_p_square\n+//\n+namespace extract\n+{\n+    extractor<tag::weighted_extended_p_square> const weighted_extended_p_square = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(weighted_extended_p_square)\n+}\n+\n+using extract::weighted_extended_p_square;\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "3fd4ed7b411568d471cc369e41c71423a64e752c",
        "filename": "src/boost/accumulators/statistics/weighted_kurtosis.hpp",
        "status": "added",
        "additions": 105,
        "deletions": 0,
        "changes": 105,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_kurtosis.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_kurtosis.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/weighted_kurtosis.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,105 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// weighted_kurtosis.hpp\n+//\n+//  Copyright 2006 Olivier Gygi, Daniel Egloff. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_KURTOSIS_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_KURTOSIS_HPP_EAN_28_10_2005\n+\n+#include <limits>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/weighted_moment.hpp>\n+#include <boost/accumulators/statistics/weighted_mean.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // weighted_kurtosis_impl\n+    /**\n+        @brief Kurtosis estimation for weighted samples\n+\n+        The kurtosis of a sample distribution is defined as the ratio of the 4th central moment and the square of the 2nd central\n+        moment (the variance) of the samples, minus 3. The term \\f$ -3 \\f$ is added in order to ensure that the normal distribution\n+        has zero kurtosis. The kurtosis can also be expressed by the simple moments:\n+\n+        \\f[\n+            \\hat{g}_2 =\n+                \\frac\n+                {\\widehat{m}_n^{(4)}-4\\widehat{m}_n^{(3)}\\hat{\\mu}_n+6\\widehat{m}_n^{(2)}\\hat{\\mu}_n^2-3\\hat{\\mu}_n^4}\n+                {\\left(\\widehat{m}_n^{(2)} - \\hat{\\mu}_n^{2}\\right)^2} - 3,\n+        \\f]\n+\n+        where \\f$ \\widehat{m}_n^{(i)} \\f$ are the \\f$ i \\f$-th moment and \\f$ \\hat{\\mu}_n \\f$ the mean (first moment) of the\n+        \\f$ n \\f$ samples.\n+\n+        The kurtosis estimator for weighted samples is formally identical to the estimator for unweighted samples, except that\n+        the weighted counterparts of all measures it depends on are to be taken.\n+    */\n+    template<typename Sample, typename Weight>\n+    struct weighted_kurtosis_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::multiplies<Sample, Weight>::result_type weighted_sample;\n+        // for boost::result_of\n+        typedef typename numeric::functional::fdiv<weighted_sample, weighted_sample>::result_type result_type;\n+\n+        weighted_kurtosis_impl(dont_care)\n+        {\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            return numeric::fdiv(\n+                        accumulators::weighted_moment<4>(args)\n+                        - 4. * accumulators::weighted_moment<3>(args) * weighted_mean(args)\n+                        + 6. * accumulators::weighted_moment<2>(args) * weighted_mean(args) * weighted_mean(args)\n+                        - 3. * weighted_mean(args) * weighted_mean(args) * weighted_mean(args) * weighted_mean(args)\n+                      , ( accumulators::weighted_moment<2>(args) - weighted_mean(args) * weighted_mean(args) )\n+                        * ( accumulators::weighted_moment<2>(args) - weighted_mean(args) * weighted_mean(args) )\n+                   ) - 3.;\n+        }\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::weighted_kurtosis\n+//\n+namespace tag\n+{\n+    struct weighted_kurtosis\n+      : depends_on<weighted_mean, weighted_moment<2>, weighted_moment<3>, weighted_moment<4> >\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::weighted_kurtosis_impl<mpl::_1, mpl::_2> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::weighted_kurtosis\n+//\n+namespace extract\n+{\n+    extractor<tag::weighted_kurtosis> const weighted_kurtosis = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(weighted_kurtosis)\n+}\n+\n+using extract::weighted_kurtosis;\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "1ddce8dd57a8e220a33a97655001b0f6abff68ba",
        "filename": "src/boost/accumulators/statistics/weighted_mean.hpp",
        "status": "added",
        "additions": 196,
        "deletions": 0,
        "changes": 196,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_mean.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_mean.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/weighted_mean.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,196 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// weighted_mean.hpp\n+//\n+//  Copyright 2006 Eric Niebler, Olivier Gygi. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_MEAN_HPP_EAN_03_11_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_MEAN_HPP_EAN_03_11_2005\n+\n+#include <boost/mpl/assert.hpp>\n+#include <boost/mpl/eval_if.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/weights.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/sum.hpp>\n+#include <boost/accumulators/statistics/mean.hpp>\n+#include <boost/accumulators/statistics/weighted_sum.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // weighted_mean_impl\n+    //      lazy, by default\n+    template<typename Sample, typename Weight, typename Tag>\n+    struct weighted_mean_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::multiplies<Sample, Weight>::result_type weighted_sample;\n+        // for boost::result_of\n+        typedef typename numeric::functional::fdiv<weighted_sample, Weight>::result_type result_type;\n+\n+        weighted_mean_impl(dont_care) {}\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            typedef\n+                typename mpl::if_<\n+                    is_same<Tag, tag::sample>\n+                  , tag::weighted_sum\n+                  , tag::weighted_sum_of_variates<Sample, Tag>\n+                >::type\n+            weighted_sum_tag;\n+\n+            extractor<weighted_sum_tag> const some_weighted_sum = {};\n+\n+            return numeric::fdiv(some_weighted_sum(args), sum_of_weights(args));\n+        }\n+    };\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // immediate_weighted_mean_impl\n+    //      immediate\n+    template<typename Sample, typename Weight, typename Tag>\n+    struct immediate_weighted_mean_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::multiplies<Sample, Weight>::result_type weighted_sample;\n+        // for boost::result_of\n+        typedef typename numeric::functional::fdiv<weighted_sample, Weight>::result_type result_type;\n+\n+        template<typename Args>\n+        immediate_weighted_mean_impl(Args const &args)\n+          : mean(\n+                numeric::fdiv(\n+                    args[parameter::keyword<Tag>::get() | Sample()]\n+                      * numeric::one<Weight>::value\n+                  , numeric::one<Weight>::value\n+                )\n+            )\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            // Matthias:\n+            //  need to pass the argument pack since the weight might be an external\n+            //  accumulator set passed as a named parameter\n+            Weight w_sum = sum_of_weights(args);\n+            Weight w = args[weight];\n+            weighted_sample const &s = args[parameter::keyword<Tag>::get()] * w;\n+            this->mean = numeric::fdiv(this->mean * (w_sum - w) + s, w_sum);\n+        }\n+\n+        result_type result(dont_care) const\n+        {\n+            return this->mean;\n+        }\n+\n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & mean;\n+        }\n+\n+    private:\n+        result_type mean;\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::weighted_mean\n+// tag::immediate_weighted_mean\n+//\n+namespace tag\n+{\n+    struct weighted_mean\n+      : depends_on<sum_of_weights, weighted_sum>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::weighted_mean_impl<mpl::_1, mpl::_2, tag::sample> impl;\n+    };\n+    struct immediate_weighted_mean\n+      : depends_on<sum_of_weights>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::immediate_weighted_mean_impl<mpl::_1, mpl::_2, tag::sample> impl;\n+    };\n+    template<typename VariateType, typename VariateTag>\n+    struct weighted_mean_of_variates\n+      : depends_on<sum_of_weights, weighted_sum_of_variates<VariateType, VariateTag> >\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::weighted_mean_impl<VariateType, mpl::_2, VariateTag> impl;\n+    };\n+    template<typename VariateType, typename VariateTag>\n+    struct immediate_weighted_mean_of_variates\n+      : depends_on<sum_of_weights>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::immediate_weighted_mean_impl<VariateType, mpl::_2, VariateTag> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::weighted_mean\n+// extract::weighted_mean_of_variates\n+//\n+namespace extract\n+{\n+    extractor<tag::mean> const weighted_mean = {};\n+    BOOST_ACCUMULATORS_DEFINE_EXTRACTOR(tag, weighted_mean_of_variates, (typename)(typename))\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(weighted_mean)\n+}\n+\n+using extract::weighted_mean;\n+using extract::weighted_mean_of_variates;\n+\n+// weighted_mean(lazy) -> weighted_mean\n+template<>\n+struct as_feature<tag::weighted_mean(lazy)>\n+{\n+    typedef tag::weighted_mean type;\n+};\n+\n+// weighted_mean(immediate) -> immediate_weighted_mean\n+template<>\n+struct as_feature<tag::weighted_mean(immediate)>\n+{\n+    typedef tag::immediate_weighted_mean type;\n+};\n+\n+// weighted_mean_of_variates<VariateType, VariateTag>(lazy) -> weighted_mean_of_variates<VariateType, VariateTag>\n+template<typename VariateType, typename VariateTag>\n+struct as_feature<tag::weighted_mean_of_variates<VariateType, VariateTag>(lazy)>\n+{\n+    typedef tag::weighted_mean_of_variates<VariateType, VariateTag> type;\n+};\n+\n+// weighted_mean_of_variates<VariateType, VariateTag>(immediate) -> immediate_weighted_mean_of_variates<VariateType, VariateTag>\n+template<typename VariateType, typename VariateTag>\n+struct as_feature<tag::weighted_mean_of_variates<VariateType, VariateTag>(immediate)>\n+{\n+    typedef tag::immediate_weighted_mean_of_variates<VariateType, VariateTag> type;\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "22224a877ae40448124e1cb83006c767ce806047",
        "filename": "src/boost/accumulators/statistics/weighted_median.hpp",
        "status": "added",
        "additions": 255,
        "deletions": 0,
        "changes": 255,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_median.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_median.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/weighted_median.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,255 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// weighted_median.hpp\n+//\n+//  Copyright 2006 Eric Niebler, Olivier Gygi. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_MEDIAN_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_MEDIAN_HPP_EAN_28_10_2005\n+\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/range/iterator_range.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+#include <boost/accumulators/statistics/median.hpp>\n+#include <boost/accumulators/statistics/weighted_p_square_quantile.hpp>\n+#include <boost/accumulators/statistics/weighted_density.hpp>\n+#include <boost/accumulators/statistics/weighted_p_square_cumul_dist.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // weighted_median_impl\n+    //\n+    /**\n+        @brief Median estimation for weighted samples based on the \\f$P^2\\f$ quantile estimator\n+\n+        The \\f$P^2\\f$ algorithm for weighted samples is invoked with a quantile probability of 0.5.\n+    */\n+    template<typename Sample>\n+    struct weighted_median_impl\n+      : accumulator_base\n+    {\n+        // for boost::result_of\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type result_type;\n+\n+        weighted_median_impl(dont_care) {}\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            return weighted_p_square_quantile_for_median(args);\n+        }\n+    };\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // with_density_weighted_median_impl\n+    //\n+    /**\n+        @brief Median estimation for weighted samples based on the density estimator\n+\n+        The algorithm determines the bin in which the \\f$0.5*cnt\\f$-th sample lies, \\f$cnt\\f$ being\n+        the total number of samples. It returns the approximate horizontal position of this sample,\n+        based on a linear interpolation inside the bin.\n+    */\n+    template<typename Sample>\n+    struct with_density_weighted_median_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::fdiv<Sample, std::size_t>::result_type float_type;\n+        typedef std::vector<std::pair<float_type, float_type> > histogram_type;\n+        typedef iterator_range<typename histogram_type::iterator> range_type;\n+        // for boost::result_of\n+        typedef float_type result_type;\n+\n+        template<typename Args>\n+        with_density_weighted_median_impl(Args const &args)\n+          : sum(numeric::fdiv(args[sample | Sample()], (std::size_t)1))\n+          , is_dirty(true)\n+        {\n+        }\n+\n+        void operator ()(dont_care)\n+        {\n+            this->is_dirty = true;\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            if (this->is_dirty)\n+            {\n+                this->is_dirty = false;\n+\n+                std::size_t cnt = count(args);\n+                range_type histogram = weighted_density(args);\n+                typename range_type::iterator it = histogram.begin();\n+                while (this->sum < 0.5 * cnt)\n+                {\n+                    this->sum += it->second * cnt;\n+                    ++it;\n+                }\n+                --it;\n+                float_type over = numeric::fdiv(this->sum - 0.5 * cnt, it->second * cnt);\n+                this->median = it->first * over + (it + 1)->first * ( 1. - over );\n+            }\n+\n+            return this->median;\n+        }\n+\n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & sum;\n+            ar & is_dirty;\n+            ar & median;\n+        }\n+\n+    private:\n+        mutable float_type sum;\n+        mutable bool is_dirty;\n+        mutable float_type median;\n+    };\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // with_p_square_cumulative_distribution_weighted_median_impl\n+    //\n+    /**\n+        @brief Median estimation for weighted samples based on the \\f$P^2\\f$ cumulative distribution estimator\n+\n+        The algorithm determines the first (leftmost) bin with a height exceeding 0.5. It\n+        returns the approximate horizontal position of where the cumulative distribution\n+        equals 0.5, based on a linear interpolation inside the bin.\n+    */\n+    template<typename Sample, typename Weight>\n+    struct with_p_square_cumulative_distribution_weighted_median_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::multiplies<Sample, Weight>::result_type weighted_sample;\n+        typedef typename numeric::functional::fdiv<weighted_sample, std::size_t>::result_type float_type;\n+        typedef std::vector<std::pair<float_type, float_type> > histogram_type;\n+        typedef iterator_range<typename histogram_type::iterator> range_type;\n+        // for boost::result_of\n+        typedef float_type result_type;\n+\n+        with_p_square_cumulative_distribution_weighted_median_impl(dont_care)\n+          : is_dirty(true)\n+        {\n+        }\n+\n+        void operator ()(dont_care)\n+        {\n+            this->is_dirty = true;\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            if (this->is_dirty)\n+            {\n+                this->is_dirty = false;\n+\n+                range_type histogram = weighted_p_square_cumulative_distribution(args);\n+                typename range_type::iterator it = histogram.begin();\n+                while (it->second < 0.5)\n+                {\n+                    ++it;\n+                }\n+                float_type over = numeric::fdiv(it->second - 0.5, it->second - (it - 1)->second);\n+                this->median = it->first * over + (it + 1)->first * ( 1. - over );\n+            }\n+\n+            return this->median;\n+        }\n+        \n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & is_dirty;\n+            ar & median;\n+        }\n+\n+    private:\n+        mutable bool is_dirty;\n+        mutable float_type median;\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::weighted_median\n+// tag::with_density_weighted_median\n+// tag::with_p_square_cumulative_distribution_weighted_median\n+//\n+namespace tag\n+{\n+    struct weighted_median\n+      : depends_on<weighted_p_square_quantile_for_median>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::weighted_median_impl<mpl::_1> impl;\n+    };\n+    struct with_density_weighted_median\n+      : depends_on<count, weighted_density>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::with_density_weighted_median_impl<mpl::_1> impl;\n+    };\n+    struct with_p_square_cumulative_distribution_weighted_median\n+      : depends_on<weighted_p_square_cumulative_distribution>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::with_p_square_cumulative_distribution_weighted_median_impl<mpl::_1, mpl::_2> impl;\n+    };\n+\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::weighted_median\n+//\n+namespace extract\n+{\n+    extractor<tag::median> const weighted_median = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(weighted_median)\n+}\n+\n+using extract::weighted_median;\n+// weighted_median(with_p_square_quantile) -> weighted_median\n+template<>\n+struct as_feature<tag::weighted_median(with_p_square_quantile)>\n+{\n+    typedef tag::weighted_median type;\n+};\n+\n+// weighted_median(with_density) -> with_density_weighted_median\n+template<>\n+struct as_feature<tag::weighted_median(with_density)>\n+{\n+    typedef tag::with_density_weighted_median type;\n+};\n+\n+// weighted_median(with_p_square_cumulative_distribution) -> with_p_square_cumulative_distribution_weighted_median\n+template<>\n+struct as_feature<tag::weighted_median(with_p_square_cumulative_distribution)>\n+{\n+    typedef tag::with_p_square_cumulative_distribution_weighted_median type;\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "5b6129066a371544caa9c92a396074b1418beba1",
        "filename": "src/boost/accumulators/statistics/weighted_moment.hpp",
        "status": "added",
        "additions": 103,
        "deletions": 0,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_moment.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_moment.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/weighted_moment.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,103 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// weighted_moment.hpp\n+//\n+//  Copyright 2006, Eric Niebler, Olivier Gygi. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_MOMENT_HPP_EAN_15_11_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_MOMENT_HPP_EAN_15_11_2005\n+\n+#include <boost/config/no_tr1/cmath.hpp>\n+#include <boost/mpl/int.hpp>\n+#include <boost/mpl/assert.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/preprocessor/arithmetic/inc.hpp>\n+#include <boost/preprocessor/repetition/repeat_from_to.hpp>\n+#include <boost/preprocessor/repetition/enum_trailing_params.hpp>\n+#include <boost/preprocessor/repetition/enum_trailing_binary_params.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+#include <boost/accumulators/statistics/moment.hpp> // for pow()\n+#include <boost/accumulators/statistics/sum.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // weighted_moment_impl\n+    template<typename N, typename Sample, typename Weight>\n+    struct weighted_moment_impl\n+      : accumulator_base // TODO: also depends_on sum of powers\n+    {\n+        BOOST_MPL_ASSERT_RELATION(N::value, >, 0);\n+        typedef typename numeric::functional::multiplies<Sample, Weight>::result_type weighted_sample;\n+        // for boost::result_of\n+        typedef typename numeric::functional::fdiv<weighted_sample, Weight>::result_type result_type;\n+\n+        template<typename Args>\n+        weighted_moment_impl(Args const &args)\n+          : sum(args[sample | Sample()] * numeric::one<Weight>::value)\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            this->sum += args[weight] * numeric::pow(args[sample], N());\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            return numeric::fdiv(this->sum, sum_of_weights(args));\n+        }\n+\n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        { \n+            ar & sum;\n+        }\n+\n+    private:\n+        weighted_sample sum;\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::weighted_moment\n+//\n+namespace tag\n+{\n+    template<int N>\n+    struct weighted_moment\n+      : depends_on<count, sum_of_weights>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::weighted_moment_impl<mpl::int_<N>, mpl::_1, mpl::_2> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::weighted_moment\n+//\n+namespace extract\n+{\n+    BOOST_ACCUMULATORS_DEFINE_EXTRACTOR(tag, weighted_moment, (int))\n+}\n+\n+using extract::weighted_moment;\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "f8a44d605b66ef7f8919dfb3d209c0c4c01e5d67",
        "filename": "src/boost/accumulators/statistics/weighted_p_square_cumul_dist.hpp",
        "status": "added",
        "additions": 275,
        "deletions": 0,
        "changes": 275,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_p_square_cumul_dist.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_p_square_cumul_dist.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/weighted_p_square_cumul_dist.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,275 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// weighted_p_square_cumul_dist.hpp\n+//\n+//  Copyright 2006 Daniel Egloff, Olivier Gygi. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_P_SQUARE_CUMUL_DIST_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_P_SQUARE_CUMUL_DIST_HPP_DE_01_01_2006\n+\n+#include <vector>\n+#include <functional>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/range.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+#include <boost/accumulators/statistics/sum.hpp>\n+#include <boost/accumulators/statistics/p_square_cumul_dist.hpp> // for named parameter p_square_cumulative_distribution_num_cells\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // weighted_p_square_cumulative_distribution_impl\n+    //  cumulative distribution calculation (as histogram)\n+    /**\n+        @brief Histogram calculation of the cumulative distribution with the \\f$P^2\\f$ algorithm for weighted samples\n+\n+        A histogram of the sample cumulative distribution is computed dynamically without storing samples\n+        based on the \\f$ P^2 \\f$ algorithm for weighted samples. The returned histogram has a specifiable\n+        amount (num_cells) equiprobable (and not equal-sized) cells.\n+\n+        Note that applying importance sampling results in regions to be more and other regions to be less\n+        accurately estimated than without importance sampling, i.e., with unweighted samples.\n+\n+        For further details, see\n+\n+        R. Jain and I. Chlamtac, The P^2 algorithm for dynamic calculation of quantiles and\n+        histograms without storing observations, Communications of the ACM,\n+        Volume 28 (October), Number 10, 1985, p. 1076-1085.\n+\n+        @param p_square_cumulative_distribution_num_cells\n+    */\n+    template<typename Sample, typename Weight>\n+    struct weighted_p_square_cumulative_distribution_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::multiplies<Sample, Weight>::result_type weighted_sample;\n+        typedef typename numeric::functional::fdiv<weighted_sample, std::size_t>::result_type float_type;\n+        typedef std::vector<std::pair<float_type, float_type> > histogram_type;\n+        typedef std::vector<float_type> array_type;\n+        // for boost::result_of\n+        typedef iterator_range<typename histogram_type::iterator> result_type;\n+\n+        template<typename Args>\n+        weighted_p_square_cumulative_distribution_impl(Args const &args)\n+          : num_cells(args[p_square_cumulative_distribution_num_cells])\n+          , heights(num_cells + 1)\n+          , actual_positions(num_cells + 1)\n+          , desired_positions(num_cells + 1)\n+          , histogram(num_cells + 1)\n+          , is_dirty(true)\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            this->is_dirty = true;\n+\n+            std::size_t cnt = count(args);\n+            std::size_t sample_cell = 1; // k\n+            std::size_t b = this->num_cells;\n+\n+            // accumulate num_cells + 1 first samples\n+            if (cnt <= b + 1)\n+            {\n+                this->heights[cnt - 1] = args[sample];\n+                this->actual_positions[cnt - 1] = args[weight];\n+\n+                // complete the initialization of heights by sorting\n+                if (cnt == b + 1)\n+                {\n+                    //std::sort(this->heights.begin(), this->heights.end());\n+\n+                    // TODO: we need to sort the initial samples (in heights) in ascending order and\n+                    // sort their weights (in actual_positions) the same way. The following lines do\n+                    // it, but there must be a better and more efficient way of doing this.\n+                    typename array_type::iterator it_begin, it_end, it_min;\n+\n+                    it_begin = this->heights.begin();\n+                    it_end   = this->heights.end();\n+\n+                    std::size_t pos = 0;\n+\n+                    while (it_begin != it_end)\n+                    {\n+                        it_min = std::min_element(it_begin, it_end);\n+                        std::size_t d = std::distance(it_begin, it_min);\n+                        std::swap(*it_begin, *it_min);\n+                        std::swap(this->actual_positions[pos], this->actual_positions[pos + d]);\n+                        ++it_begin;\n+                        ++pos;\n+                    }\n+\n+                    // calculate correct initial actual positions\n+                    for (std::size_t i = 1; i < b; ++i)\n+                    {\n+                        this->actual_positions[i] += this->actual_positions[i - 1];\n+                    }\n+                }\n+            }\n+            else\n+            {\n+                // find cell k such that heights[k-1] <= args[sample] < heights[k] and adjust extreme values\n+                if (args[sample] < this->heights[0])\n+                {\n+                    this->heights[0] = args[sample];\n+                    this->actual_positions[0] = args[weight];\n+                    sample_cell = 1;\n+                }\n+                else if (this->heights[b] <= args[sample])\n+                {\n+                    this->heights[b] = args[sample];\n+                    sample_cell = b;\n+                }\n+                else\n+                {\n+                    typename array_type::iterator it;\n+                    it = std::upper_bound(\n+                        this->heights.begin()\n+                      , this->heights.end()\n+                      , args[sample]\n+                    );\n+\n+                    sample_cell = std::distance(this->heights.begin(), it);\n+                }\n+\n+                // increment positions of markers above sample_cell\n+                for (std::size_t i = sample_cell; i < b + 1; ++i)\n+                {\n+                    this->actual_positions[i] += args[weight];\n+                }\n+\n+                // determine desired marker positions\n+                for (std::size_t i = 1; i < b + 1; ++i)\n+                {\n+                    this->desired_positions[i] = this->actual_positions[0]\n+                                               + numeric::fdiv((i-1) * (sum_of_weights(args) - this->actual_positions[0]), b);\n+                }\n+\n+                // adjust heights of markers 2 to num_cells if necessary\n+                for (std::size_t i = 1; i < b; ++i)\n+                {\n+                    // offset to desire position\n+                    float_type d = this->desired_positions[i] - this->actual_positions[i];\n+\n+                    // offset to next position\n+                    float_type dp = this->actual_positions[i + 1] - this->actual_positions[i];\n+\n+                    // offset to previous position\n+                    float_type dm = this->actual_positions[i - 1] - this->actual_positions[i];\n+\n+                    // height ds\n+                    float_type hp = (this->heights[i + 1] - this->heights[i]) / dp;\n+                    float_type hm = (this->heights[i - 1] - this->heights[i]) / dm;\n+\n+                    if ( ( d >= 1. && dp > 1. ) || ( d <= -1. && dm < -1. ) )\n+                    {\n+                        short sign_d = static_cast<short>(d / std::abs(d));\n+\n+                        // try adjusting heights[i] using p-squared formula\n+                        float_type h = this->heights[i] + sign_d / (dp - dm) * ( (sign_d - dm) * hp + (dp - sign_d) * hm );\n+\n+                        if ( this->heights[i - 1] < h && h < this->heights[i + 1] )\n+                        {\n+                            this->heights[i] = h;\n+                        }\n+                        else\n+                        {\n+                            // use linear formula\n+                            if (d>0)\n+                            {\n+                                this->heights[i] += hp;\n+                            }\n+                            if (d<0)\n+                            {\n+                                this->heights[i] -= hm;\n+                            }\n+                        }\n+                        this->actual_positions[i] += sign_d;\n+                    }\n+                }\n+            }\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            if (this->is_dirty)\n+            {\n+                this->is_dirty = false;\n+\n+                // creates a vector of std::pair where each pair i holds\n+                // the values heights[i] (x-axis of histogram) and\n+                // actual_positions[i] / sum_of_weights (y-axis of histogram)\n+\n+                for (std::size_t i = 0; i < this->histogram.size(); ++i)\n+                {\n+                    this->histogram[i] = std::make_pair(this->heights[i], numeric::fdiv(this->actual_positions[i], sum_of_weights(args)));\n+                }\n+            }\n+\n+            return make_iterator_range(this->histogram);\n+        }\n+\n+        // make this accumulator serializeable\n+        // TODO split to save/load and check on parameters provided in ctor\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        {\n+            ar & num_cells;\n+            ar & heights;\n+            ar & actual_positions;\n+            ar & desired_positions;\n+            ar & histogram;\n+            ar & is_dirty; \n+        }\n+\n+    private:\n+        std::size_t num_cells;            // number of cells b\n+        array_type  heights;              // q_i\n+        array_type  actual_positions;     // n_i\n+        array_type  desired_positions;    // n'_i\n+        mutable histogram_type histogram; // histogram\n+        mutable bool is_dirty;\n+    };\n+\n+} // namespace detail\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::weighted_p_square_cumulative_distribution\n+//\n+namespace tag\n+{\n+    struct weighted_p_square_cumulative_distribution\n+      : depends_on<count, sum_of_weights>\n+      , p_square_cumulative_distribution_num_cells\n+    {\n+        typedef accumulators::impl::weighted_p_square_cumulative_distribution_impl<mpl::_1, mpl::_2> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::weighted_p_square_cumulative_distribution\n+//\n+namespace extract\n+{\n+    extractor<tag::weighted_p_square_cumulative_distribution> const weighted_p_square_cumulative_distribution = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(weighted_p_square_cumulative_distribution)\n+}\n+\n+using extract::weighted_p_square_cumulative_distribution;\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "11580371c1ded5d78f4b700ba1aff82e7602cd16",
        "filename": "src/boost/accumulators/statistics/weighted_p_square_cumulative_distribution.hpp",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_p_square_cumulative_distribution.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_p_square_cumulative_distribution.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/weighted_p_square_cumulative_distribution.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,19 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// weighted_p_square_cumulative_distribution.hpp\n+//\n+//  Copyright 2012 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_P_SQUARE_CUMULATIVE_DISTRIBUTION_HPP_03_19_2012\n+#define BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_P_SQUARE_CUMULATIVE_DISTRIBUTION_HPP_03_19_2012\n+\n+#if defined(_MSC_VER) || defined(__BORLANDC__) && !defined(__clang__) || defined(__DMC__)\n+#  pragma message (\"Warning: This header is deprecated. Please use: boost/accumulators/statistics/weighted_p_square_cumul_dist.hpp\")\n+#elif defined(__GNUC__) || defined(__HP_aCC) || defined(__SUNPRO_CC) || defined(__IBMCPP__) || defined(__BORLANDC__)\n+#  warning \"This header is deprecated. Please use: boost/accumulators/statistics/weighted_p_square_cumul_dist.hpp\"\n+#endif\n+\n+#include <boost/accumulators/statistics/weighted_p_square_cumul_dist.hpp>\n+\n+#endif"
      },
      {
        "sha": "fecd993911a934c55ad9188e76f9562dcdace85c",
        "filename": "src/boost/accumulators/statistics/weighted_p_square_quantile.hpp",
        "status": "added",
        "additions": 266,
        "deletions": 0,
        "changes": 266,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_p_square_quantile.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_p_square_quantile.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/weighted_p_square_quantile.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,266 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// weighted_p_square_quantile.hpp\n+//\n+//  Copyright 2005 Daniel Egloff. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_P_SQUARE_QUANTILE_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_P_SQUARE_QUANTILE_HPP_DE_01_01_2006\n+\n+#include <cmath>\n+#include <functional>\n+#include <boost/array.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+#include <boost/accumulators/statistics/sum.hpp>\n+#include <boost/accumulators/statistics/parameters/quantile_probability.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl {\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // weighted_p_square_quantile_impl\n+    //  single quantile estimation with weighted samples\n+    /**\n+        @brief Single quantile estimation with the \\f$P^2\\f$ algorithm for weighted samples\n+\n+        This version of the \\f$P^2\\f$ algorithm extends the \\f$P^2\\f$ algorithm to support weighted samples.\n+        The \\f$P^2\\f$ algorithm estimates a quantile dynamically without storing samples. Instead of\n+        storing the whole sample cumulative distribution, only five points (markers) are stored. The heights\n+        of these markers are the minimum and the maximum of the samples and the current estimates of the\n+        \\f$(p/2)\\f$-, \\f$p\\f$ - and \\f$(1+p)/2\\f$ -quantiles. Their positions are equal to the number\n+        of samples that are smaller or equal to the markers. Each time a new sample is added, the\n+        positions of the markers are updated and if necessary their heights are adjusted using a piecewise-\n+        parabolic formula.\n+\n+        For further details, see\n+\n+        R. Jain and I. Chlamtac, The P^2 algorithm for dynamic calculation of quantiles and\n+        histograms without storing observations, Communications of the ACM,\n+        Volume 28 (October), Number 10, 1985, p. 1076-1085.\n+\n+        @param quantile_probability\n+    */\n+    template<typename Sample, typename Weight, typename Impl>\n+    struct weighted_p_square_quantile_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::multiplies<Sample, Weight>::result_type weighted_sample;\n+        typedef typename numeric::functional::fdiv<weighted_sample, std::size_t>::result_type float_type;\n+        typedef array<float_type, 5> array_type;\n+        // for boost::result_of\n+        typedef float_type result_type;\n+\n+        template<typename Args>\n+        weighted_p_square_quantile_impl(Args const &args)\n+          : p(is_same<Impl, for_median>::value ? 0.5 : args[quantile_probability | 0.5])\n+          , heights()\n+          , actual_positions()\n+          , desired_positions()\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            std::size_t cnt = count(args);\n+\n+            // accumulate 5 first samples\n+            if (cnt <= 5)\n+            {\n+                this->heights[cnt - 1] = args[sample];\n+\n+                // In this initialization phase, actual_positions stores the weights of the\n+                // initial samples that are needed at the end of the initialization phase to\n+                // compute the correct initial positions of the markers.\n+                this->actual_positions[cnt - 1] = args[weight];\n+\n+                // complete the initialization of heights and actual_positions by sorting\n+                if (cnt == 5)\n+                {\n+                    // TODO: we need to sort the initial samples (in heights) in ascending order and\n+                    // sort their weights (in actual_positions) the same way. The following lines do\n+                    // it, but there must be a better and more efficient way of doing this.\n+                    typename array_type::iterator it_begin, it_end, it_min;\n+\n+                    it_begin = this->heights.begin();\n+                    it_end   = this->heights.end();\n+\n+                    std::size_t pos = 0;\n+\n+                    while (it_begin != it_end)\n+                    {\n+                        it_min = std::min_element(it_begin, it_end);\n+                        std::size_t d = std::distance(it_begin, it_min);\n+                        std::swap(*it_begin, *it_min);\n+                        std::swap(this->actual_positions[pos], this->actual_positions[pos + d]);\n+                        ++it_begin;\n+                        ++pos;\n+                    }\n+\n+                    // calculate correct initial actual positions\n+                    for (std::size_t i = 1; i < 5; ++i)\n+                    {\n+                        this->actual_positions[i] += this->actual_positions[i - 1];\n+                    }\n+                }\n+            }\n+            else\n+            {\n+                std::size_t sample_cell = 1; // k\n+\n+                // find cell k such that heights[k-1] <= args[sample] < heights[k] and adjust extreme values\n+                if (args[sample] < this->heights[0])\n+                {\n+                    this->heights[0] = args[sample];\n+                    this->actual_positions[0] = args[weight];\n+                    sample_cell = 1;\n+                }\n+                else if (this->heights[4] <= args[sample])\n+                {\n+                    this->heights[4] = args[sample];\n+                    sample_cell = 4;\n+                }\n+                else\n+                {\n+                    typedef typename array_type::iterator iterator;\n+                    iterator it = std::upper_bound(\n+                        this->heights.begin()\n+                      , this->heights.end()\n+                      , args[sample]\n+                    );\n+\n+                    sample_cell = std::distance(this->heights.begin(), it);\n+                }\n+\n+                // increment positions of markers above sample_cell\n+                for (std::size_t i = sample_cell; i < 5; ++i)\n+                {\n+                    this->actual_positions[i] += args[weight];\n+                }\n+\n+                // update desired positions for all markers\n+                this->desired_positions[0] = this->actual_positions[0];\n+                this->desired_positions[1] = (sum_of_weights(args) - this->actual_positions[0])\n+                                           * this->p/2. + this->actual_positions[0];\n+                this->desired_positions[2] = (sum_of_weights(args) - this->actual_positions[0])\n+                                           * this->p + this->actual_positions[0];\n+                this->desired_positions[3] = (sum_of_weights(args) - this->actual_positions[0])\n+                                           * (1. + this->p)/2. + this->actual_positions[0];\n+                this->desired_positions[4] = sum_of_weights(args);\n+\n+                // adjust height and actual positions of markers 1 to 3 if necessary\n+                for (std::size_t i = 1; i <= 3; ++i)\n+                {\n+                    // offset to desired positions\n+                    float_type d = this->desired_positions[i] - this->actual_positions[i];\n+\n+                    // offset to next position\n+                    float_type dp = this->actual_positions[i + 1] - this->actual_positions[i];\n+\n+                    // offset to previous position\n+                    float_type dm = this->actual_positions[i - 1] - this->actual_positions[i];\n+\n+                    // height ds\n+                    float_type hp = (this->heights[i + 1] - this->heights[i]) / dp;\n+                    float_type hm = (this->heights[i - 1] - this->heights[i]) / dm;\n+\n+                    if ( ( d >= 1. && dp > 1. ) || ( d <= -1. && dm < -1. ) )\n+                    {\n+                        short sign_d = static_cast<short>(d / std::abs(d));\n+\n+                        // try adjusting heights[i] using p-squared formula\n+                        float_type h = this->heights[i] + sign_d / (dp - dm) * ( (sign_d - dm) * hp + (dp - sign_d) * hm );\n+\n+                        if ( this->heights[i - 1] < h && h < this->heights[i + 1] )\n+                        {\n+                            this->heights[i] = h;\n+                        }\n+                        else\n+                        {\n+                            // use linear formula\n+                            if (d>0)\n+                            {\n+                                this->heights[i] += hp;\n+                            }\n+                            if (d<0)\n+                            {\n+                                this->heights[i] -= hm;\n+                            }\n+                        }\n+                        this->actual_positions[i] += sign_d;\n+                    }\n+                }\n+            }\n+        }\n+\n+        result_type result(dont_care) const\n+        {\n+            return this->heights[2];\n+        }\n+\n+        // make this accumulator serializeable\n+        // TODO split to save/load and check on parameters provided in ctor\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        {\n+            ar & p;\n+            ar & heights;\n+            ar & actual_positions;\n+            ar & desired_positions;\n+        }\n+\n+    private:\n+        float_type p;                    // the quantile probability p\n+        array_type heights;              // q_i\n+        array_type actual_positions;     // n_i\n+        array_type desired_positions;    // n'_i\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::weighted_p_square_quantile\n+//\n+namespace tag\n+{\n+    struct weighted_p_square_quantile\n+      : depends_on<count, sum_of_weights>\n+    {\n+        typedef accumulators::impl::weighted_p_square_quantile_impl<mpl::_1, mpl::_2, regular> impl;\n+    };\n+    struct weighted_p_square_quantile_for_median\n+      : depends_on<count, sum_of_weights>\n+    {\n+        typedef accumulators::impl::weighted_p_square_quantile_impl<mpl::_1, mpl::_2, for_median> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::weighted_p_square_quantile\n+// extract::weighted_p_square_quantile_for_median\n+//\n+namespace extract\n+{\n+    extractor<tag::weighted_p_square_quantile> const weighted_p_square_quantile = {};\n+    extractor<tag::weighted_p_square_quantile_for_median> const weighted_p_square_quantile_for_median = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(weighted_p_square_quantile)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(weighted_p_square_quantile_for_median)\n+}\n+\n+using extract::weighted_p_square_quantile;\n+using extract::weighted_p_square_quantile_for_median;\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "f3dc327b9eb82aef5ebc3ec26c69e2ef4b4ee069",
        "filename": "src/boost/accumulators/statistics/weighted_peaks_over_threshold.hpp",
        "status": "added",
        "additions": 302,
        "deletions": 0,
        "changes": 302,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_peaks_over_threshold.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_peaks_over_threshold.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/weighted_peaks_over_threshold.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,302 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// weighted_peaks_over_threshold.hpp\n+//\n+//  Copyright 2006 Daniel Egloff, Olivier Gygi. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_PEAKS_OVER_THRESHOLD_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_PEAKS_OVER_THRESHOLD_HPP_DE_01_01_2006\n+\n+#include <vector>\n+#include <limits>\n+#include <numeric>\n+#include <functional>\n+#include <boost/throw_exception.hpp>\n+#include <boost/range.hpp>\n+#include <boost/mpl/if.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/tuple/tuple.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/parameters/quantile_probability.hpp>\n+#include <boost/accumulators/statistics/peaks_over_threshold.hpp> // for named parameters pot_threshold_value and pot_threshold_probability\n+#include <boost/accumulators/statistics/sum.hpp>\n+#include <boost/accumulators/statistics/tail_variate.hpp>\n+\n+#ifdef _MSC_VER\n+# pragma warning(push)\n+# pragma warning(disable: 4127) // conditional expression is constant\n+#endif\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // weighted_peaks_over_threshold_impl\n+    //  works with an explicit threshold value and does not depend on order statistics of weighted samples\n+    /**\n+        @brief Weighted Peaks over Threshold Method for Weighted Quantile and Weighted Tail Mean Estimation\n+\n+        @sa peaks_over_threshold_impl\n+\n+        @param quantile_probability\n+        @param pot_threshold_value\n+    */\n+    template<typename Sample, typename Weight, typename LeftRight>\n+    struct weighted_peaks_over_threshold_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::multiplies<Weight, Sample>::result_type weighted_sample;\n+        typedef typename numeric::functional::fdiv<weighted_sample, std::size_t>::result_type float_type;\n+        // for boost::result_of\n+        typedef boost::tuple<float_type, float_type, float_type> result_type;\n+\n+        template<typename Args>\n+        weighted_peaks_over_threshold_impl(Args const &args)\n+          : sign_((is_same<LeftRight, left>::value) ? -1 : 1)\n+          , mu_(sign_ * numeric::fdiv(args[sample | Sample()], (std::size_t)1))\n+          , sigma2_(numeric::fdiv(args[sample | Sample()], (std::size_t)1))\n+          , w_sum_(numeric::fdiv(args[weight | Weight()], (std::size_t)1))\n+          , threshold_(sign_ * args[pot_threshold_value])\n+          , fit_parameters_(boost::make_tuple(0., 0., 0.))\n+          , is_dirty_(true)\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            this->is_dirty_ = true;\n+\n+            if (this->sign_ * args[sample] > this->threshold_)\n+            {\n+                this->mu_ += args[weight] * args[sample];\n+                this->sigma2_ += args[weight] * args[sample] * args[sample];\n+                this->w_sum_ += args[weight];\n+            }\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            if (this->is_dirty_)\n+            {\n+                this->is_dirty_ = false;\n+\n+                this->mu_ = this->sign_ * numeric::fdiv(this->mu_, this->w_sum_);\n+                this->sigma2_ = numeric::fdiv(this->sigma2_, this->w_sum_);\n+                this->sigma2_ -= this->mu_ * this->mu_;\n+\n+                float_type threshold_probability = numeric::fdiv(sum_of_weights(args) - this->w_sum_, sum_of_weights(args));\n+\n+                float_type tmp = numeric::fdiv(( this->mu_ - this->threshold_ )*( this->mu_ - this->threshold_ ), this->sigma2_);\n+                float_type xi_hat = 0.5 * ( 1. - tmp );\n+                float_type beta_hat = 0.5 * ( this->mu_ - this->threshold_ ) * ( 1. + tmp );\n+                float_type beta_bar = beta_hat * std::pow(1. - threshold_probability, xi_hat);\n+                float_type u_bar = this->threshold_ - beta_bar * ( std::pow(1. - threshold_probability, -xi_hat) - 1.)/xi_hat;\n+                this->fit_parameters_ = boost::make_tuple(u_bar, beta_bar, xi_hat);\n+            }\n+\n+            return this->fit_parameters_;\n+        }\n+\n+        // make this accumulator serializeable\n+        // TODO: do we need to split to load/save and verify that threshold did not change?\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        {\n+            ar & sign_;\n+            ar & mu_;\n+            ar & sigma2_;\n+            ar & threshold_;\n+            ar & fit_parameters_;\n+            ar & is_dirty_;\n+        }\n+\n+    private:\n+        short sign_;                         // for left tail fitting, mirror the extreme values\n+        mutable float_type mu_;              // mean of samples above threshold\n+        mutable float_type sigma2_;          // variance of samples above threshold\n+        mutable float_type w_sum_;           // sum of weights of samples above threshold\n+        float_type threshold_;\n+        mutable result_type fit_parameters_; // boost::tuple that stores fit parameters\n+        mutable bool is_dirty_;\n+    };\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // weighted_peaks_over_threshold_prob_impl\n+    //  determines threshold from a given threshold probability using order statistics\n+    /**\n+        @brief Peaks over Threshold Method for Quantile and Tail Mean Estimation\n+\n+        @sa weighted_peaks_over_threshold_impl\n+\n+        @param quantile_probability\n+        @param pot_threshold_probability\n+    */\n+    template<typename Sample, typename Weight, typename LeftRight>\n+    struct weighted_peaks_over_threshold_prob_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::multiplies<Weight, Sample>::result_type weighted_sample;\n+        typedef typename numeric::functional::fdiv<weighted_sample, std::size_t>::result_type float_type;\n+        // for boost::result_of\n+        typedef boost::tuple<float_type, float_type, float_type> result_type;\n+\n+        template<typename Args>\n+        weighted_peaks_over_threshold_prob_impl(Args const &args)\n+          : sign_((is_same<LeftRight, left>::value) ? -1 : 1)\n+          , mu_(sign_ * numeric::fdiv(args[sample | Sample()], (std::size_t)1))\n+          , sigma2_(numeric::fdiv(args[sample | Sample()], (std::size_t)1))\n+          , threshold_probability_(args[pot_threshold_probability])\n+          , fit_parameters_(boost::make_tuple(0., 0., 0.))\n+          , is_dirty_(true)\n+        {\n+        }\n+\n+        void operator ()(dont_care)\n+        {\n+            this->is_dirty_ = true;\n+        }\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            if (this->is_dirty_)\n+            {\n+                this->is_dirty_ = false;\n+\n+                float_type threshold = sum_of_weights(args)\n+                             * ( ( is_same<LeftRight, left>::value ) ? this->threshold_probability_ : 1. - this->threshold_probability_ );\n+\n+                std::size_t n = 0;\n+                Weight sum = Weight(0);\n+\n+                while (sum < threshold)\n+                {\n+                    if (n < static_cast<std::size_t>(tail_weights(args).size()))\n+                    {\n+                        mu_ += *(tail_weights(args).begin() + n) * *(tail(args).begin() + n);\n+                        sigma2_ += *(tail_weights(args).begin() + n) * *(tail(args).begin() + n) * (*(tail(args).begin() + n));\n+                        sum += *(tail_weights(args).begin() + n);\n+                        n++;\n+                    }\n+                    else\n+                    {\n+                        if (std::numeric_limits<float_type>::has_quiet_NaN)\n+                        {\n+                            return boost::make_tuple(\n+                                std::numeric_limits<float_type>::quiet_NaN()\n+                              , std::numeric_limits<float_type>::quiet_NaN()\n+                              , std::numeric_limits<float_type>::quiet_NaN()\n+                            );\n+                        }\n+                        else\n+                        {\n+                            std::ostringstream msg;\n+                            msg << \"index n = \" << n << \" is not in valid range [0, \" << tail(args).size() << \")\";\n+                            boost::throw_exception(std::runtime_error(msg.str()));\n+                            return boost::make_tuple(Sample(0), Sample(0), Sample(0));\n+                        }\n+                    }\n+                }\n+\n+                float_type u = *(tail(args).begin() + n - 1) * this->sign_;\n+\n+\n+                this->mu_ = this->sign_ * numeric::fdiv(this->mu_, sum);\n+                this->sigma2_ = numeric::fdiv(this->sigma2_, sum);\n+                this->sigma2_ -= this->mu_ * this->mu_;\n+\n+                if (is_same<LeftRight, left>::value)\n+                    this->threshold_probability_ = 1. - this->threshold_probability_;\n+\n+                float_type tmp = numeric::fdiv(( this->mu_ - u )*( this->mu_ - u ), this->sigma2_);\n+                float_type xi_hat = 0.5 * ( 1. - tmp );\n+                float_type beta_hat = 0.5 * ( this->mu_ - u ) * ( 1. + tmp );\n+                float_type beta_bar = beta_hat * std::pow(1. - threshold_probability_, xi_hat);\n+                float_type u_bar = u - beta_bar * ( std::pow(1. - threshold_probability_, -xi_hat) - 1.)/xi_hat;\n+                this->fit_parameters_ = boost::make_tuple(u_bar, beta_bar, xi_hat);\n+\n+            }\n+\n+            return this->fit_parameters_;\n+        }\n+\n+    private:\n+        short sign_;                                // for left tail fitting, mirror the extreme values\n+        mutable float_type mu_;                     // mean of samples above threshold u\n+        mutable float_type sigma2_;                 // variance of samples above threshold u\n+        mutable float_type threshold_probability_;\n+        mutable result_type fit_parameters_;        // boost::tuple that stores fit parameters\n+        mutable bool is_dirty_;\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::weighted_peaks_over_threshold\n+//\n+namespace tag\n+{\n+    template<typename LeftRight>\n+    struct weighted_peaks_over_threshold\n+      : depends_on<sum_of_weights>\n+      , pot_threshold_value\n+    {\n+        /// INTERNAL ONLY\n+        typedef accumulators::impl::weighted_peaks_over_threshold_impl<mpl::_1, mpl::_2, LeftRight> impl;\n+    };\n+\n+    template<typename LeftRight>\n+    struct weighted_peaks_over_threshold_prob\n+      : depends_on<sum_of_weights, tail_weights<LeftRight> >\n+      , pot_threshold_probability\n+    {\n+        /// INTERNAL ONLY\n+        typedef accumulators::impl::weighted_peaks_over_threshold_prob_impl<mpl::_1, mpl::_2, LeftRight> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::weighted_peaks_over_threshold\n+//\n+namespace extract\n+{\n+    extractor<tag::abstract_peaks_over_threshold> const weighted_peaks_over_threshold = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(weighted_peaks_over_threshold)\n+}\n+\n+using extract::weighted_peaks_over_threshold;\n+\n+// weighted_peaks_over_threshold<LeftRight>(with_threshold_value) -> weighted_peaks_over_threshold<LeftRight>\n+template<typename LeftRight>\n+struct as_feature<tag::weighted_peaks_over_threshold<LeftRight>(with_threshold_value)>\n+{\n+    typedef tag::weighted_peaks_over_threshold<LeftRight> type;\n+};\n+\n+// weighted_peaks_over_threshold<LeftRight>(with_threshold_probability) -> weighted_peaks_over_threshold_prob<LeftRight>\n+template<typename LeftRight>\n+struct as_feature<tag::weighted_peaks_over_threshold<LeftRight>(with_threshold_probability)>\n+{\n+    typedef tag::weighted_peaks_over_threshold_prob<LeftRight> type;\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#ifdef _MSC_VER\n+# pragma warning(pop)\n+#endif\n+\n+#endif"
      },
      {
        "sha": "a3ac3876f554fd0e3cb1ea2b8be58d30ed036862",
        "filename": "src/boost/accumulators/statistics/weighted_skewness.hpp",
        "status": "added",
        "additions": 101,
        "deletions": 0,
        "changes": 101,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_skewness.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_skewness.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/weighted_skewness.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,101 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// weighted_skewness.hpp\n+//\n+//  Copyright 2006 Olivier Gygi, Daniel Egloff. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_SKEWNESS_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_SKEWNESS_HPP_EAN_28_10_2005\n+\n+#include <limits>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/weighted_moment.hpp>\n+#include <boost/accumulators/statistics/weighted_mean.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // weighted_skewness_impl\n+    /**\n+        @brief Skewness estimation for weighted samples\n+\n+        The skewness of a sample distribution is defined as the ratio of the 3rd central moment and the \\f$ 3/2 \\f$-th power $\n+        of the 2nd central moment (the variance) of the samples. The skewness can also be expressed by the simple moments:\n+\n+        \\f[\n+            \\hat{g}_1 =\n+                \\frac\n+                {\\widehat{m}_n^{(3)}-3\\widehat{m}_n^{(2)}\\hat{\\mu}_n+2\\hat{\\mu}_n^3}\n+                {\\left(\\widehat{m}_n^{(2)} - \\hat{\\mu}_n^{2}\\right)^{3/2}}\n+        \\f]\n+\n+        where \\f$ \\widehat{m}_n^{(i)} \\f$ are the \\f$ i \\f$-th moment and \\f$ \\hat{\\mu}_n \\f$ the mean (first moment) of the\n+        \\f$ n \\f$ samples.\n+\n+        The skewness estimator for weighted samples is formally identical to the estimator for unweighted samples, except that\n+        the weighted counterparts of all measures it depends on are to be taken.\n+    */\n+    template<typename Sample, typename Weight>\n+    struct weighted_skewness_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::multiplies<Sample, Weight>::result_type weighted_sample;\n+        // for boost::result_of\n+        typedef typename numeric::functional::fdiv<weighted_sample, weighted_sample>::result_type result_type;\n+\n+        weighted_skewness_impl(dont_care) {}\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            return numeric::fdiv(\n+                        accumulators::weighted_moment<3>(args)\n+                        - 3. * accumulators::weighted_moment<2>(args) * weighted_mean(args)\n+                        + 2. * weighted_mean(args) * weighted_mean(args) * weighted_mean(args)\n+                      , ( accumulators::weighted_moment<2>(args) - weighted_mean(args) * weighted_mean(args) )\n+                      * std::sqrt( accumulators::weighted_moment<2>(args) - weighted_mean(args) * weighted_mean(args) )\n+                   );\n+        }\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::weighted_skewness\n+//\n+namespace tag\n+{\n+    struct weighted_skewness\n+      : depends_on<weighted_mean, weighted_moment<2>, weighted_moment<3> >\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::weighted_skewness_impl<mpl::_1, mpl::_2> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::weighted_skewness\n+//\n+namespace extract\n+{\n+    extractor<tag::weighted_skewness> const weighted_skewness = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(weighted_skewness)\n+}\n+\n+using extract::weighted_skewness;\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "41091f8766f8308e2b660d3a700a58518f679368",
        "filename": "src/boost/accumulators/statistics/weighted_sum.hpp",
        "status": "added",
        "additions": 123,
        "deletions": 0,
        "changes": 123,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_sum.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_sum.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/weighted_sum.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,123 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// weighted_sum.hpp\n+//\n+//  Copyright 2006 Eric Niebler, Olivier Gygi. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_SUM_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_SUM_HPP_EAN_28_10_2005\n+\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/parameters/weight.hpp>\n+#include <boost/accumulators/framework/accumulators/external_accumulator.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // weighted_sum_impl\n+    template<typename Sample, typename Weight, typename Tag>\n+    struct weighted_sum_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::multiplies<Sample, Weight>::result_type weighted_sample;\n+\n+        // for boost::result_of\n+        typedef weighted_sample result_type;\n+\n+        template<typename Args>\n+        weighted_sum_impl(Args const &args)\n+          : weighted_sum_(\n+                args[parameter::keyword<Tag>::get() | Sample()]\n+                  * numeric::one<Weight>::value\n+            )\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            // what about overflow?\n+            this->weighted_sum_ += args[parameter::keyword<Tag>::get()] * args[weight];\n+        }\n+\n+        result_type result(dont_care) const\n+        {\n+            return this->weighted_sum_;\n+        }\n+\n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        {\n+            ar & weighted_sum_;\n+        }\n+\n+    private:\n+\n+        weighted_sample weighted_sum_;\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::weighted_sum\n+//\n+namespace tag\n+{\n+    struct weighted_sum\n+      : depends_on<>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::weighted_sum_impl<mpl::_1, mpl::_2, tag::sample> impl;\n+    };\n+\n+    template<typename VariateType, typename VariateTag>\n+    struct weighted_sum_of_variates\n+      : depends_on<>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::weighted_sum_impl<VariateType, mpl::_2, VariateTag> impl;\n+    };\n+\n+    struct abstract_weighted_sum_of_variates\n+      : depends_on<>\n+    {\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::weighted_sum\n+//\n+namespace extract\n+{\n+    extractor<tag::weighted_sum> const weighted_sum = {};\n+    extractor<tag::abstract_weighted_sum_of_variates> const weighted_sum_of_variates = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(weighted_sum)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(weighted_sum_of_variates)\n+}\n+\n+using extract::weighted_sum;\n+using extract::weighted_sum_of_variates;\n+\n+template<typename VariateType, typename VariateTag>\n+struct feature_of<tag::weighted_sum_of_variates<VariateType, VariateTag> >\n+  : feature_of<tag::abstract_weighted_sum_of_variates>\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "5ee5250d690c1188f972cb4362e31617321cdddd",
        "filename": "src/boost/accumulators/statistics/weighted_sum_kahan.hpp",
        "status": "added",
        "additions": 146,
        "deletions": 0,
        "changes": 146,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_sum_kahan.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_sum_kahan.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/weighted_sum_kahan.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,146 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// weighted_sum_kahan.hpp\n+//\n+//  Copyright 2011 Simon West. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_SUM_KAHAN_HPP_EAN_11_05_2011\n+#define BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_SUM_KAHAN_HPP_EAN_11_05_2011\n+\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/parameters/weight.hpp>\n+#include <boost/accumulators/framework/accumulators/external_accumulator.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/weighted_sum.hpp>\n+#include <boost/numeric/conversion/cast.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+#if _MSC_VER > 1400\n+# pragma float_control(push)\n+# pragma float_control(precise, on)\n+#endif\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // weighted_sum_kahan_impl\n+    template<typename Sample, typename Weight, typename Tag>\n+    struct weighted_sum_kahan_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::multiplies<Sample, Weight>::result_type weighted_sample;\n+\n+        // for boost::result_of\n+        typedef weighted_sample result_type;\n+\n+        template<typename Args>\n+        weighted_sum_kahan_impl(Args const &args)\n+          : weighted_sum_(\n+                args[parameter::keyword<Tag>::get() | Sample()] * numeric::one<Weight>::value),\n+                compensation(boost::numeric_cast<weighted_sample>(0.0))\n+        {\n+        }\n+\n+        template<typename Args>\n+        void \n+#if BOOST_ACCUMULATORS_GCC_VERSION > 40305\n+        __attribute__((__optimize__(\"no-associative-math\")))\n+#endif\n+        operator ()(Args const &args)\n+        {\n+            const weighted_sample myTmp1 = args[parameter::keyword<Tag>::get()] * args[weight] - this->compensation;\n+            const weighted_sample myTmp2 = this->weighted_sum_ + myTmp1;\n+            this->compensation = (myTmp2 - this->weighted_sum_) - myTmp1;\n+            this->weighted_sum_ = myTmp2;\n+\n+        }\n+\n+        result_type result(dont_care) const\n+        {\n+            return this->weighted_sum_;\n+        }\n+\n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        {\n+            ar & weighted_sum_;\n+            ar & compensation;\n+        }\n+\n+    private:\n+        weighted_sample weighted_sum_;\n+        weighted_sample compensation;\n+    };\n+\n+#if _MSC_VER > 1400\n+# pragma float_control(pop)\n+#endif\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::weighted_sum_kahan\n+// tag::weighted_sum_of_variates_kahan\n+//\n+namespace tag\n+{\n+    struct weighted_sum_kahan\n+      : depends_on<>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::weighted_sum_kahan_impl<mpl::_1, mpl::_2, tag::sample> impl;\n+    };\n+\n+    template<typename VariateType, typename VariateTag>\n+    struct weighted_sum_of_variates_kahan\n+      : depends_on<>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::weighted_sum_kahan_impl<VariateType, mpl::_2, VariateTag> impl;\n+    };\n+\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::weighted_sum_kahan\n+// extract::weighted_sum_of_variates_kahan\n+//\n+namespace extract\n+{\n+    extractor<tag::weighted_sum_kahan> const weighted_sum_kahan = {};\n+    extractor<tag::abstract_weighted_sum_of_variates> const weighted_sum_of_variates_kahan = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(weighted_sum_kahan)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(weighted_sum_of_variates_kahan)\n+}\n+\n+using extract::weighted_sum_kahan;\n+using extract::weighted_sum_of_variates_kahan;\n+\n+// weighted_sum(kahan) -> weighted_sum_kahan\n+template<>\n+struct as_feature<tag::weighted_sum(kahan)>\n+{\n+    typedef tag::weighted_sum_kahan type;\n+};\n+\n+template<typename VariateType, typename VariateTag>\n+struct feature_of<tag::weighted_sum_of_variates_kahan<VariateType, VariateTag> >\n+  : feature_of<tag::abstract_weighted_sum_of_variates>\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "bae8530674ebbdc34352a7c0c37ac2bfb1ef4d4a",
        "filename": "src/boost/accumulators/statistics/weighted_tail_mean.hpp",
        "status": "added",
        "additions": 169,
        "deletions": 0,
        "changes": 169,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_tail_mean.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_tail_mean.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/weighted_tail_mean.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,169 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// weighted_tail_mean.hpp\n+//\n+//  Copyright 2006 Daniel Egloff, Olivier Gygi. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_TAIL_MEAN_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_TAIL_MEAN_HPP_DE_01_01_2006\n+\n+#include <numeric>\n+#include <vector>\n+#include <limits>\n+#include <functional>\n+#include <sstream>\n+#include <stdexcept>\n+#include <boost/throw_exception.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/tail.hpp>\n+#include <boost/accumulators/statistics/tail_mean.hpp>\n+#include <boost/accumulators/statistics/parameters/quantile_probability.hpp>\n+\n+#ifdef _MSC_VER\n+# pragma warning(push)\n+# pragma warning(disable: 4127) // conditional expression is constant\n+#endif\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // coherent_weighted_tail_mean_impl\n+    //\n+    // TODO\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // non_coherent_weighted_tail_mean_impl\n+    //\n+    /**\n+        @brief Estimation of the (non-coherent) weighted tail mean based on order statistics (for both left and right tails)\n+\n+\n+\n+        An estimation of the non-coherent, weighted tail mean \\f$\\widehat{NCTM}_{n,\\alpha}(X)\\f$ is given by the weighted mean\n+        of the\n+\n+        \\f[\n+            \\lambda = \\inf\\left\\{ l \\left| \\frac{1}{\\bar{w}_n}\\sum_{i=1}^{l} w_i \\geq \\alpha \\right. \\right\\}\n+        \\f]\n+\n+        smallest samples (left tail) or the weighted mean of the\n+\n+        \\f[\n+            n + 1 - \\rho = n + 1 - \\sup\\left\\{ r \\left| \\frac{1}{\\bar{w}_n}\\sum_{i=r}^{n} w_i \\geq (1 - \\alpha) \\right. \\right\\}\n+        \\f]\n+\n+        largest samples (right tail) above a quantile \\f$\\hat{q}_{\\alpha}\\f$ of level \\f$\\alpha\\f$, \\f$n\\f$ being the total number of sample\n+        and \\f$\\bar{w}_n\\f$ the sum of all \\f$n\\f$ weights:\n+\n+        \\f[\n+            \\widehat{NCTM}_{n,\\alpha}^{\\mathrm{left}}(X) = \\frac{\\sum_{i=1}^{\\lambda} w_i X_{i:n}}{\\sum_{i=1}^{\\lambda} w_i},\n+        \\f]\n+\n+        \\f[\n+            \\widehat{NCTM}_{n,\\alpha}^{\\mathrm{right}}(X) = \\frac{\\sum_{i=\\rho}^n w_i X_{i:n}}{\\sum_{i=\\rho}^n w_i}.\n+        \\f]\n+\n+        @param quantile_probability\n+    */\n+    template<typename Sample, typename Weight, typename LeftRight>\n+    struct non_coherent_weighted_tail_mean_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::multiplies<Sample, Weight>::result_type weighted_sample;\n+        typedef typename numeric::functional::fdiv<Weight, std::size_t>::result_type float_type;\n+        // for boost::result_of\n+        typedef typename numeric::functional::fdiv<weighted_sample, std::size_t>::result_type result_type;\n+\n+        non_coherent_weighted_tail_mean_impl(dont_care) {}\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            float_type threshold = sum_of_weights(args)\n+                             * ( ( is_same<LeftRight, left>::value ) ? args[quantile_probability] : 1. - args[quantile_probability] );\n+\n+            std::size_t n = 0;\n+            Weight sum = Weight(0);\n+\n+            while (sum < threshold)\n+            {\n+                if (n < static_cast<std::size_t>(tail_weights(args).size()))\n+                {\n+                    sum += *(tail_weights(args).begin() + n);\n+                    n++;\n+                }\n+                else\n+                {\n+                    if (std::numeric_limits<result_type>::has_quiet_NaN)\n+                    {\n+                        return std::numeric_limits<result_type>::quiet_NaN();\n+                    }\n+                    else\n+                    {\n+                        std::ostringstream msg;\n+                        msg << \"index n = \" << n << \" is not in valid range [0, \" << tail(args).size() << \")\";\n+                        boost::throw_exception(std::runtime_error(msg.str()));\n+                        return result_type(0);\n+                    }\n+                }\n+            }\n+\n+            return numeric::fdiv(\n+                std::inner_product(\n+                    tail(args).begin()\n+                  , tail(args).begin() + n\n+                  , tail_weights(args).begin()\n+                  , weighted_sample(0)\n+                )\n+              , sum\n+            );\n+        }\n+    };\n+\n+} // namespace impl\n+\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::non_coherent_weighted_tail_mean<>\n+//\n+namespace tag\n+{\n+    template<typename LeftRight>\n+    struct non_coherent_weighted_tail_mean\n+      : depends_on<sum_of_weights, tail_weights<LeftRight> >\n+    {\n+        typedef accumulators::impl::non_coherent_weighted_tail_mean_impl<mpl::_1, mpl::_2, LeftRight> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::non_coherent_weighted_tail_mean;\n+//\n+namespace extract\n+{\n+    extractor<tag::abstract_non_coherent_tail_mean> const non_coherent_weighted_tail_mean = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(non_coherent_weighted_tail_mean)\n+}\n+\n+using extract::non_coherent_weighted_tail_mean;\n+\n+}} // namespace boost::accumulators\n+\n+#ifdef _MSC_VER\n+# pragma warning(pop)\n+#endif\n+\n+#endif"
      },
      {
        "sha": "b143457dd0fb71b2dae99d01e9b3983eeb0c1330",
        "filename": "src/boost/accumulators/statistics/weighted_tail_quantile.hpp",
        "status": "added",
        "additions": 146,
        "deletions": 0,
        "changes": 146,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_tail_quantile.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_tail_quantile.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/weighted_tail_quantile.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,146 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// weighted_tail_quantile.hpp\n+//\n+//  Copyright 2006 Daniel Egloff, Olivier Gygi. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_TAIL_QUANTILE_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_TAIL_QUANTILE_HPP_DE_01_01_2006\n+\n+#include <vector>\n+#include <limits>\n+#include <functional>\n+#include <sstream>\n+#include <stdexcept>\n+#include <boost/throw_exception.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/mpl/if.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/tail.hpp>\n+#include <boost/accumulators/statistics/tail_quantile.hpp>\n+#include <boost/accumulators/statistics/parameters/quantile_probability.hpp>\n+\n+#ifdef _MSC_VER\n+# pragma warning(push)\n+# pragma warning(disable: 4127) // conditional expression is constant\n+#endif\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // weighted_tail_quantile_impl\n+    //  Tail quantile estimation based on order statistics of weighted samples\n+    /**\n+        @brief Tail quantile estimation based on order statistics of weighted samples (for both left and right tails)\n+\n+        An estimator \\f$\\hat{q}\\f$ of tail quantiles with level \\f$\\alpha\\f$ based on order statistics\n+        \\f$X_{1:n} \\leq X_{2:n} \\leq\\dots\\leq X_{n:n}\\f$ of weighted samples are given by \\f$X_{\\lambda:n}\\f$ (left tail)\n+        and \\f$X_{\\rho:n}\\f$ (right tail), where\n+\n+            \\f[\n+                \\lambda = \\inf\\left\\{ l \\left| \\frac{1}{\\bar{w}_n}\\sum_{i=1}^{l} w_i \\geq \\alpha \\right. \\right\\}\n+            \\f]\n+\n+        and\n+\n+            \\f[\n+                \\rho = \\sup\\left\\{ r \\left| \\frac{1}{\\bar{w}_n}\\sum_{i=r}^{n} w_i \\geq (1 - \\alpha) \\right. \\right\\},\n+            \\f]\n+\n+        \\f$n\\f$ being the number of samples and \\f$\\bar{w}_n\\f$ the sum of all weights.\n+\n+        @param quantile_probability\n+    */\n+    template<typename Sample, typename Weight, typename LeftRight>\n+    struct weighted_tail_quantile_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::fdiv<Weight, std::size_t>::result_type float_type;\n+        // for boost::result_of\n+        typedef Sample result_type;\n+\n+        weighted_tail_quantile_impl(dont_care) {}\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            float_type threshold = sum_of_weights(args)\n+                             * ( ( is_same<LeftRight, left>::value ) ? args[quantile_probability] : 1. - args[quantile_probability] );\n+\n+            std::size_t n = 0;\n+            Weight sum = Weight(0);\n+\n+            while (sum < threshold)\n+            {\n+                if (n < static_cast<std::size_t>(tail_weights(args).size()))\n+                {\n+                    sum += *(tail_weights(args).begin() + n);\n+                    n++;\n+                }\n+                else\n+                {\n+                    if (std::numeric_limits<result_type>::has_quiet_NaN)\n+                    {\n+                        return std::numeric_limits<result_type>::quiet_NaN();\n+                    }\n+                    else\n+                    {\n+                        std::ostringstream msg;\n+                        msg << \"index n = \" << n << \" is not in valid range [0, \" << tail(args).size() << \")\";\n+                        boost::throw_exception(std::runtime_error(msg.str()));\n+                        return Sample(0);\n+                    }\n+                }\n+            }\n+\n+            // Note that the cached samples of the left are sorted in ascending order,\n+            // whereas the samples of the right tail are sorted in descending order\n+            return *(boost::begin(tail(args)) + n - 1);\n+        }\n+    };\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::weighted_tail_quantile<>\n+//\n+namespace tag\n+{\n+    template<typename LeftRight>\n+    struct weighted_tail_quantile\n+      : depends_on<sum_of_weights, tail_weights<LeftRight> >\n+    {\n+        /// INTERNAL ONLY\n+        typedef accumulators::impl::weighted_tail_quantile_impl<mpl::_1, mpl::_2, LeftRight> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::weighted_tail_quantile\n+//\n+namespace extract\n+{\n+    extractor<tag::quantile> const weighted_tail_quantile = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(weighted_tail_quantile)\n+}\n+\n+using extract::weighted_tail_quantile;\n+\n+}} // namespace boost::accumulators\n+\n+#ifdef _MSC_VER\n+# pragma warning(pop)\n+#endif\n+\n+#endif"
      },
      {
        "sha": "f096a93b525b80f66fc1318e7ca8c0ac53a12e43",
        "filename": "src/boost/accumulators/statistics/weighted_tail_variate_means.hpp",
        "status": "added",
        "additions": 253,
        "deletions": 0,
        "changes": 253,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_tail_variate_means.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_tail_variate_means.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/weighted_tail_variate_means.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,253 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// weighted_tail_variate_means.hpp\n+//\n+//  Copyright 2006 Daniel Egloff, Olivier Gygi. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_TAIL_VARIATE_MEANS_HPP_DE_01_01_2006\n+#define BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_TAIL_VARIATE_MEANS_HPP_DE_01_01_2006\n+\n+#include <numeric>\n+#include <vector>\n+#include <limits>\n+#include <functional>\n+#include <sstream>\n+#include <stdexcept>\n+#include <boost/throw_exception.hpp>\n+#include <boost/parameter/keyword.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/tail.hpp>\n+#include <boost/accumulators/statistics/tail_variate.hpp>\n+#include <boost/accumulators/statistics/tail_variate_means.hpp>\n+#include <boost/accumulators/statistics/weighted_tail_mean.hpp>\n+#include <boost/accumulators/statistics/parameters/quantile_probability.hpp>\n+\n+#ifdef _MSC_VER\n+# pragma warning(push)\n+# pragma warning(disable: 4127) // conditional expression is constant\n+#endif\n+\n+namespace boost\n+{\n+    // for _BinaryOperatrion2 in std::inner_product below\n+    // multiplies two values and promotes the result to double\n+    namespace numeric { namespace functional\n+    {\n+        ///////////////////////////////////////////////////////////////////////////////\n+        // numeric::functional::multiply_and_promote_to_double\n+        template<typename T, typename U>\n+        struct multiply_and_promote_to_double\n+          : multiplies<T, double const>\n+        {\n+        };\n+    }}\n+}\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    /**\n+        @brief Estimation of the absolute and relative weighted tail variate means (for both left and right tails)\n+\n+        For all \\f$j\\f$-th variates associated to the\n+\n+        \\f[\n+            \\lambda = \\inf\\left\\{ l \\left| \\frac{1}{\\bar{w}_n}\\sum_{i=1}^{l} w_i \\geq \\alpha \\right. \\right\\}\n+        \\f]\n+\n+        smallest samples (left tail) or the weighted mean of the\n+\n+        \\f[\n+            n + 1 - \\rho = n + 1 - \\sup\\left\\{ r \\left| \\frac{1}{\\bar{w}_n}\\sum_{i=r}^{n} w_i \\geq (1 - \\alpha) \\right. \\right\\}\n+        \\f]\n+\n+        largest samples (right tail), the absolute weighted tail means \\f$\\widehat{ATM}_{n,\\alpha}(X, j)\\f$\n+        are computed and returned as an iterator range. Alternatively, the relative weighted tail means\n+        \\f$\\widehat{RTM}_{n,\\alpha}(X, j)\\f$ are returned, which are the absolute weighted tail means\n+        normalized with the weighted (non-coherent) sample tail mean \\f$\\widehat{NCTM}_{n,\\alpha}(X)\\f$.\n+\n+        \\f[\n+            \\widehat{ATM}_{n,\\alpha}^{\\mathrm{right}}(X, j) =\n+                \\frac{1}{\\sum_{i=\\rho}^n w_i}\n+                \\sum_{i=\\rho}^n w_i \\xi_{j,i}\n+        \\f]\n+\n+        \\f[\n+            \\widehat{ATM}_{n,\\alpha}^{\\mathrm{left}}(X, j) =\n+                \\frac{1}{\\sum_{i=1}^{\\lambda}}\n+                \\sum_{i=1}^{\\lambda} w_i \\xi_{j,i}\n+        \\f]\n+\n+        \\f[\n+            \\widehat{RTM}_{n,\\alpha}^{\\mathrm{right}}(X, j) =\n+                \\frac{\\sum_{i=\\rho}^n w_i \\xi_{j,i}}\n+            {\\sum_{i=\\rho}^n w_i \\widehat{NCTM}_{n,\\alpha}^{\\mathrm{right}}(X)}\n+        \\f]\n+\n+        \\f[\n+            \\widehat{RTM}_{n,\\alpha}^{\\mathrm{left}}(X, j) =\n+                \\frac{\\sum_{i=1}^{\\lambda} w_i \\xi_{j,i}}\n+            {\\sum_{i=1}^{\\lambda} w_i \\widehat{NCTM}_{n,\\alpha}^{\\mathrm{left}}(X)}\n+        \\f]\n+    */\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // weighted_tail_variate_means_impl\n+    //  by default: absolute weighted_tail_variate_means\n+    template<typename Sample, typename Weight, typename Impl, typename LeftRight, typename VariateType>\n+    struct weighted_tail_variate_means_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::fdiv<Weight, Weight>::result_type float_type;\n+        typedef typename numeric::functional::fdiv<typename numeric::functional::multiplies<VariateType, Weight>::result_type, Weight>::result_type array_type;\n+        // for boost::result_of\n+        typedef iterator_range<typename array_type::iterator> result_type;\n+\n+        weighted_tail_variate_means_impl(dont_care) {}\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            float_type threshold = sum_of_weights(args)\n+                             * ( ( is_same<LeftRight, left>::value ) ? args[quantile_probability] : 1. - args[quantile_probability] );\n+\n+            std::size_t n = 0;\n+            Weight sum = Weight(0);\n+\n+            while (sum < threshold)\n+            {\n+                if (n < static_cast<std::size_t>(tail_weights(args).size()))\n+                {\n+                    sum += *(tail_weights(args).begin() + n);\n+                    n++;\n+                }\n+                else\n+                {\n+                    if (std::numeric_limits<float_type>::has_quiet_NaN)\n+                    {\n+                        std::fill(\n+                            this->tail_means_.begin()\n+                          , this->tail_means_.end()\n+                          , std::numeric_limits<float_type>::quiet_NaN()\n+                        );\n+                    }\n+                    else\n+                    {\n+                        std::ostringstream msg;\n+                        msg << \"index n = \" << n << \" is not in valid range [0, \" << tail(args).size() << \")\";\n+                        boost::throw_exception(std::runtime_error(msg.str()));\n+                    }\n+                }\n+            }\n+\n+            std::size_t num_variates = tail_variate(args).begin()->size();\n+\n+            this->tail_means_.clear();\n+            this->tail_means_.resize(num_variates, Sample(0));\n+\n+            this->tail_means_ = std::inner_product(\n+                tail_variate(args).begin()\n+              , tail_variate(args).begin() + n\n+              , tail_weights(args).begin()\n+              , this->tail_means_\n+              , numeric::functional::plus<array_type const, array_type const>()\n+              , numeric::functional::multiply_and_promote_to_double<VariateType const, Weight const>()\n+            );\n+\n+            float_type factor = sum * ( (is_same<Impl, relative>::value) ? non_coherent_weighted_tail_mean(args) : 1. );\n+\n+            std::transform(\n+                this->tail_means_.begin()\n+              , this->tail_means_.end()\n+              , this->tail_means_.begin()\n+#ifdef BOOST_NO_CXX98_BINDERS\n+              , std::bind(numeric::functional::divides<typename array_type::value_type const, float_type const>(), std::placeholders::_1, factor)\n+#else\n+              , std::bind2nd(numeric::functional::divides<typename array_type::value_type const, float_type const>(), factor)\n+#endif\n+            );\n+\n+            return make_iterator_range(this->tail_means_);\n+        }\n+\n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        {\n+            ar & tail_means_;\n+        }\n+\n+    private:\n+\n+        mutable array_type tail_means_;\n+\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::absolute_weighted_tail_variate_means\n+// tag::relative_weighted_tail_variate_means\n+//\n+namespace tag\n+{\n+    template<typename LeftRight, typename VariateType, typename VariateTag>\n+    struct absolute_weighted_tail_variate_means\n+      : depends_on<non_coherent_weighted_tail_mean<LeftRight>, tail_variate<VariateType, VariateTag, LeftRight>, tail_weights<LeftRight> >\n+    {\n+        typedef accumulators::impl::weighted_tail_variate_means_impl<mpl::_1, mpl::_2, absolute, LeftRight, VariateType> impl;\n+    };\n+    template<typename LeftRight, typename VariateType, typename VariateTag>\n+    struct relative_weighted_tail_variate_means\n+      : depends_on<non_coherent_weighted_tail_mean<LeftRight>, tail_variate<VariateType, VariateTag, LeftRight>, tail_weights<LeftRight> >\n+    {\n+        typedef accumulators::impl::weighted_tail_variate_means_impl<mpl::_1, mpl::_2, relative, LeftRight, VariateType> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::weighted_tail_variate_means\n+// extract::relative_weighted_tail_variate_means\n+//\n+namespace extract\n+{\n+    extractor<tag::abstract_absolute_tail_variate_means> const weighted_tail_variate_means = {};\n+    extractor<tag::abstract_relative_tail_variate_means> const relative_weighted_tail_variate_means = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(weighted_tail_variate_means)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(relative_weighted_tail_variate_means)\n+}\n+\n+using extract::weighted_tail_variate_means;\n+using extract::relative_weighted_tail_variate_means;\n+\n+// weighted_tail_variate_means<LeftRight, VariateType, VariateTag>(absolute) -> absolute_weighted_tail_variate_means<LeftRight, VariateType, VariateTag>\n+template<typename LeftRight, typename VariateType, typename VariateTag>\n+struct as_feature<tag::weighted_tail_variate_means<LeftRight, VariateType, VariateTag>(absolute)>\n+{\n+    typedef tag::absolute_weighted_tail_variate_means<LeftRight, VariateType, VariateTag> type;\n+};\n+\n+// weighted_tail_variate_means<LeftRight, VariateType, VariateTag>(relative) -> relative_weighted_tail_variate_means<LeftRight, VariateType, VariateTag>\n+template<typename LeftRight, typename VariateType, typename VariateTag>\n+struct as_feature<tag::weighted_tail_variate_means<LeftRight, VariateType, VariateTag>(relative)>\n+{\n+    typedef tag::relative_weighted_tail_variate_means<LeftRight, VariateType, VariateTag> type;\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#ifdef _MSC_VER\n+# pragma warning(pop)\n+#endif\n+\n+#endif"
      },
      {
        "sha": "f7d2b6e5f708f2b2986acb97cb6a57535bd1e298",
        "filename": "src/boost/accumulators/statistics/weighted_variance.hpp",
        "status": "added",
        "additions": 193,
        "deletions": 0,
        "changes": 193,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_variance.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/weighted_variance.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/weighted_variance.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,193 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// weighted_variance.hpp\n+//\n+//  Copyright 2005 Daniel Egloff, Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_VARIANCE_HPP_EAN_28_10_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_WEIGHTED_VARIANCE_HPP_EAN_28_10_2005\n+\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/framework/accumulator_base.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+#include <boost/accumulators/numeric/functional.hpp>\n+#include <boost/accumulators/framework/parameters/sample.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/count.hpp>\n+#include <boost/accumulators/statistics/variance.hpp>\n+#include <boost/accumulators/statistics/weighted_sum.hpp>\n+#include <boost/accumulators/statistics/weighted_mean.hpp>\n+#include <boost/accumulators/statistics/weighted_moment.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace impl\n+{\n+    //! Lazy calculation of variance of weighted samples.\n+    /*!\n+        The default implementation of the variance of weighted samples is based on the second moment\n+        \\f$\\widehat{m}_n^{(2)}\\f$ (weighted_moment<2>) and the mean\\f$ \\hat{\\mu}_n\\f$ (weighted_mean):\n+        \\f[\n+            \\hat{\\sigma}_n^2 = \\widehat{m}_n^{(2)}-\\hat{\\mu}_n^2,\n+        \\f]\n+        where \\f$n\\f$ is the number of samples.\n+    */\n+    template<typename Sample, typename Weight, typename MeanFeature>\n+    struct lazy_weighted_variance_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::multiplies<Sample, Weight>::result_type weighted_sample;\n+        // for boost::result_of\n+        typedef typename numeric::functional::fdiv<weighted_sample, Weight>::result_type result_type;\n+\n+        lazy_weighted_variance_impl(dont_care) {}\n+\n+        template<typename Args>\n+        result_type result(Args const &args) const\n+        {\n+            extractor<MeanFeature> const some_mean = {};\n+            result_type tmp = some_mean(args);\n+            return accumulators::weighted_moment<2>(args) - tmp * tmp;\n+        }\n+    };\n+\n+    //! Iterative calculation of variance of weighted samples.\n+    /*!\n+        Iterative calculation of variance of weighted samples:\n+        \\f[\n+            \\hat{\\sigma}_n^2 =\n+                \\frac{\\bar{w}_n - w_n}{\\bar{w}_n}\\hat{\\sigma}_{n - 1}^2\n+              + \\frac{w_n}{\\bar{w}_n - w_n}\\left(X_n - \\hat{\\mu}_n\\right)^2\n+            ,\\quad n\\ge2,\\quad\\hat{\\sigma}_0^2 = 0.\n+        \\f]\n+        where \\f$\\bar{w}_n\\f$ is the sum of the \\f$n\\f$ weights \\f$w_i\\f$ and \\f$\\hat{\\mu}_n\\f$\n+        the estimate of the mean of the weighted samples. Note that the sample variance is not defined for\n+        \\f$n <= 1\\f$.\n+    */\n+    template<typename Sample, typename Weight, typename MeanFeature, typename Tag>\n+    struct weighted_variance_impl\n+      : accumulator_base\n+    {\n+        typedef typename numeric::functional::multiplies<Sample, Weight>::result_type weighted_sample;\n+        // for boost::result_of\n+        typedef typename numeric::functional::fdiv<weighted_sample, Weight>::result_type result_type;\n+\n+        template<typename Args>\n+        weighted_variance_impl(Args const &args)\n+          : weighted_variance(numeric::fdiv(args[sample | Sample()], numeric::one<Weight>::value))\n+        {\n+        }\n+\n+        template<typename Args>\n+        void operator ()(Args const &args)\n+        {\n+            std::size_t cnt = count(args);\n+\n+            if(cnt > 1)\n+            {\n+                extractor<MeanFeature> const some_mean = {};\n+\n+                result_type tmp = args[parameter::keyword<Tag>::get()] - some_mean(args);\n+\n+                this->weighted_variance =\n+                    numeric::fdiv(this->weighted_variance * (sum_of_weights(args) - args[weight]), sum_of_weights(args))\n+                  + numeric::fdiv(tmp * tmp * args[weight], sum_of_weights(args) - args[weight] );\n+            }\n+        }\n+\n+        result_type result(dont_care) const\n+        {\n+            return this->weighted_variance;\n+        }\n+\n+        // make this accumulator serializeable\n+        template<class Archive>\n+        void serialize(Archive & ar, const unsigned int file_version)\n+        {\n+            ar & weighted_variance;\n+        }\n+\n+    private:\n+        result_type weighted_variance;\n+    };\n+\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// tag::weighted_variance\n+// tag::immediate_weighted_variance\n+//\n+namespace tag\n+{\n+    struct lazy_weighted_variance\n+      : depends_on<weighted_moment<2>, weighted_mean>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::lazy_weighted_variance_impl<mpl::_1, mpl::_2, weighted_mean> impl;\n+    };\n+\n+    struct weighted_variance\n+      : depends_on<count, immediate_weighted_mean>\n+    {\n+        /// INTERNAL ONLY\n+        ///\n+        typedef accumulators::impl::weighted_variance_impl<mpl::_1, mpl::_2, immediate_weighted_mean, sample> impl;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// extract::weighted_variance\n+// extract::immediate_weighted_variance\n+//\n+namespace extract\n+{\n+    extractor<tag::lazy_weighted_variance> const lazy_weighted_variance = {};\n+    extractor<tag::weighted_variance> const weighted_variance = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(lazy_weighted_variance)\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(weighted_variance)\n+}\n+\n+using extract::lazy_weighted_variance;\n+using extract::weighted_variance;\n+\n+// weighted_variance(lazy) -> lazy_weighted_variance\n+template<>\n+struct as_feature<tag::weighted_variance(lazy)>\n+{\n+    typedef tag::lazy_weighted_variance type;\n+};\n+\n+// weighted_variance(immediate) -> weighted_variance\n+template<>\n+struct as_feature<tag::weighted_variance(immediate)>\n+{\n+    typedef tag::weighted_variance type;\n+};\n+\n+////////////////////////////////////////////////////////////////////////////\n+//// droppable_accumulator<weighted_variance_impl>\n+////  need to specialize droppable lazy weighted_variance to cache the result at the\n+////  point the accumulator is dropped.\n+///// INTERNAL ONLY\n+/////\n+//template<typename Sample, typename Weight, typename MeanFeature>\n+//struct droppable_accumulator<impl::weighted_variance_impl<Sample, Weight, MeanFeature> >\n+//  : droppable_accumulator_base<\n+//        with_cached_result<impl::weighted_variance_impl<Sample, Weight, MeanFeature> >\n+//    >\n+//{\n+//    template<typename Args>\n+//    droppable_accumulator(Args const &args)\n+//      : droppable_accumulator::base(args)\n+//    {\n+//    }\n+//};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "adafc8e0d810ff3103b44292ab8a5f8c7fbe5bb4",
        "filename": "src/boost/accumulators/statistics/with_error.hpp",
        "status": "added",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/with_error.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics/with_error.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics/with_error.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,44 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// with_error.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_WITH_ERROR_HPP_EAN_01_11_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_WITH_ERROR_HPP_EAN_01_11_2005\n+\n+#include <boost/preprocessor/repetition/enum_params.hpp>\n+#include <boost/mpl/vector.hpp>\n+#include <boost/mpl/transform_view.hpp>\n+#include <boost/mpl/placeholders.hpp>\n+#include <boost/accumulators/statistics_fwd.hpp>\n+#include <boost/accumulators/statistics/error_of.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+namespace detail\n+{\n+    template<typename Feature>\n+    struct error_of_tag\n+    {\n+        typedef tag::error_of<Feature> type;\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// with_error\n+//\n+template<BOOST_PP_ENUM_PARAMS(BOOST_ACCUMULATORS_MAX_FEATURES, typename Feature)>\n+struct with_error\n+  : mpl::transform_view<\n+        mpl::vector<BOOST_PP_ENUM_PARAMS(BOOST_ACCUMULATORS_MAX_FEATURES, Feature)>\n+      , detail::error_of_tag<mpl::_1>\n+    >\n+{\n+};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "61904f30b36c1d40905241ffe38c7ab0a56857e2",
        "filename": "src/boost/accumulators/statistics_fwd.hpp",
        "status": "added",
        "additions": 432,
        "deletions": 0,
        "changes": 432,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics_fwd.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/accumulators/statistics_fwd.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/accumulators/statistics_fwd.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,432 @@\n+///////////////////////////////////////////////////////////////////////////////\n+// statistics_fwd.hpp\n+//\n+//  Copyright 2005 Eric Niebler. Distributed under the Boost\n+//  Software License, Version 1.0. (See accompanying file\n+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+#ifndef BOOST_ACCUMULATORS_STATISTICS_STATISTICS_FWD_HPP_EAN_23_11_2005\n+#define BOOST_ACCUMULATORS_STATISTICS_STATISTICS_FWD_HPP_EAN_23_11_2005\n+\n+#include <boost/mpl/apply_fwd.hpp> // for mpl::na\n+#include <boost/mpl/print.hpp>\n+#include <boost/preprocessor/repetition/enum_params_with_a_default.hpp>\n+#include <boost/accumulators/accumulators_fwd.hpp>\n+#include <boost/accumulators/framework/depends_on.hpp>\n+#include <boost/accumulators/framework/extractor.hpp>\n+\n+namespace boost { namespace accumulators\n+{\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// base struct and base extractor for quantiles\n+namespace tag\n+{\n+    struct quantile\n+      : depends_on<>\n+    {\n+        typedef mpl::print<class ____MISSING_SPECIFIC_QUANTILE_FEATURE_IN_ACCUMULATOR_SET____ > impl;\n+    };\n+}\n+namespace extract\n+{\n+    extractor<tag::quantile> const quantile = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(quantile)\n+}\n+using extract::quantile;\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// base struct and base extractor for *coherent* tail means\n+namespace tag\n+{\n+    struct tail_mean\n+      : depends_on<>\n+    {\n+        typedef mpl::print<class ____MISSING_SPECIFIC_TAIL_MEAN_FEATURE_IN_ACCUMULATOR_SET____ > impl;\n+    };\n+}\n+namespace extract\n+{\n+    extractor<tag::tail_mean> const tail_mean = {};\n+\n+    BOOST_ACCUMULATORS_IGNORE_GLOBAL(tail_mean)\n+}\n+using extract::tail_mean;\n+\n+namespace tag\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // Variates tags\n+    struct weights;\n+    struct covariate1;\n+    struct covariate2;\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // Statistic tags\n+    struct count;\n+    template<typename VariateType, typename VariateTag>\n+    struct covariance;\n+    struct density;\n+    template<typename Feature>\n+    struct error_of;\n+    struct extended_p_square;\n+    struct extended_p_square_quantile;\n+    struct extended_p_square_quantile_quadratic;\n+    struct kurtosis;\n+    struct max;\n+    struct mean;\n+    struct immediate_mean;\n+    struct mean_of_weights;\n+    struct immediate_mean_of_weights;\n+    template<typename VariateType, typename VariateTag>\n+    struct mean_of_variates;\n+    template<typename VariateType, typename VariateTag>\n+    struct immediate_mean_of_variates;\n+    struct median;\n+    struct with_density_median;\n+    struct with_p_square_cumulative_distribution_median;\n+    struct min;\n+    template<int N>\n+    struct moment;\n+    template<typename LeftRight>\n+    struct peaks_over_threshold;\n+    template<typename LeftRight>\n+    struct peaks_over_threshold_prob;\n+    template<typename LeftRight>\n+    struct pot_tail_mean;\n+    template<typename LeftRight>\n+    struct pot_tail_mean_prob;\n+    template<typename LeftRight>\n+    struct pot_quantile;\n+    template<typename LeftRight>\n+    struct pot_quantile_prob;\n+    struct p_square_cumulative_distribution;\n+    struct p_square_quantile;\n+    struct p_square_quantile_for_median;\n+    struct skewness;\n+    struct sum;\n+    struct sum_of_weights;\n+    template<typename VariateType, typename VariateTag>\n+    struct sum_of_variates;\n+    struct sum_kahan;\n+    struct sum_of_weights_kahan;\n+    template<typename VariateType, typename VariateTag>\n+    struct sum_of_variates_kahan;\n+    template<typename LeftRight>\n+    struct tail;\n+    template<typename LeftRight>\n+    struct coherent_tail_mean;\n+    template<typename LeftRight>\n+    struct non_coherent_tail_mean;\n+    template<typename LeftRight>\n+    struct tail_quantile;\n+    template<typename VariateType, typename VariateTag, typename LeftRight>\n+    struct tail_variate;\n+    template<typename LeftRight>\n+    struct tail_weights;\n+    template<typename VariateType, typename VariateTag, typename LeftRight>\n+    struct right_tail_variate;\n+    template<typename VariateType, typename VariateTag, typename LeftRight>\n+    struct left_tail_variate;\n+    template<typename LeftRight, typename VariateType, typename VariateTag>\n+    struct tail_variate_means;\n+    template<typename LeftRight, typename VariateType, typename VariateTag>\n+    struct absolute_tail_variate_means;\n+    template<typename LeftRight, typename VariateType, typename VariateTag>\n+    struct relative_tail_variate_means;\n+    struct lazy_variance;\n+    struct variance;\n+    template<typename VariateType, typename VariateTag>\n+    struct weighted_covariance;\n+    struct weighted_density;\n+    struct weighted_kurtosis;\n+    struct weighted_mean;\n+    struct immediate_weighted_mean;\n+    template<typename VariateType, typename VariateTag>\n+    struct weighted_mean_of_variates;\n+    template<typename VariateType, typename VariateTag>\n+    struct immediate_weighted_mean_of_variates;\n+    struct weighted_median;\n+    struct with_density_weighted_median;\n+    struct with_p_square_cumulative_distribution_weighted_median;\n+    struct weighted_extended_p_square;\n+    struct weighted_extended_p_square_quantile;\n+    struct weighted_extended_p_square_quantile_quadratic;\n+    template<int N>\n+    struct weighted_moment;\n+    template<typename LeftRight>\n+    struct weighted_peaks_over_threshold;\n+    template<typename LeftRight>\n+    struct weighted_peaks_over_threshold_prob;\n+    template<typename LeftRight>\n+    struct weighted_pot_quantile;\n+    template<typename LeftRight>\n+    struct weighted_pot_quantile_prob;\n+    template<typename LeftRight>\n+    struct weighted_pot_tail_mean;\n+    template<typename LeftRight>\n+    struct weighted_pot_tail_mean_prob;\n+    struct weighted_p_square_cumulative_distribution;\n+    struct weighted_p_square_quantile;\n+    struct weighted_p_square_quantile_for_median;\n+    struct weighted_skewness;\n+    template<typename LeftRight>\n+    struct weighted_tail_quantile;\n+    template<typename LeftRight>\n+    struct non_coherent_weighted_tail_mean;\n+    template<typename LeftRight>\n+    struct weighted_tail_quantile;\n+    template<typename LeftRight, typename VariateType, typename VariateTag>\n+    struct weighted_tail_variate_means;\n+    template<typename LeftRight, typename VariateType, typename VariateTag>\n+    struct absolute_weighted_tail_variate_means;\n+    template<typename LeftRight, typename VariateType, typename VariateTag>\n+    struct relative_weighted_tail_variate_means;\n+    struct lazy_weighted_variance;\n+    struct weighted_variance;\n+    struct weighted_sum;\n+    template<typename VariateType, typename VariateTag>\n+    struct weighted_sum_of_variates;\n+    struct rolling_window_plus1;\n+    struct rolling_window;\n+    struct rolling_sum;\n+    struct rolling_count;\n+    struct rolling_mean;\n+} // namespace tag\n+\n+namespace impl\n+{\n+    ///////////////////////////////////////////////////////////////////////////////\n+    // Statistics impls\n+    struct count_impl;\n+\n+    template<typename Sample, typename VariateType, typename VariateTag>\n+    struct covariance_impl;\n+\n+    template<typename Sample>\n+    struct density_impl;\n+\n+    template<typename Sample, typename Feature>\n+    struct error_of_impl;\n+\n+    template<typename Sample, typename Variance>\n+    struct error_of_mean_impl;\n+\n+    template<typename Sample>\n+    struct extended_p_square_impl;\n+\n+    template<typename Sample, typename Impl1, typename Impl2>\n+    struct extended_p_square_quantile_impl;\n+\n+    template<typename Sample>\n+    struct kurtosis_impl;\n+\n+    template<typename Sample>\n+    struct max_impl;\n+\n+    template<typename Sample>\n+    struct median_impl;\n+\n+    template<typename Sample>\n+    struct with_density_median_impl;\n+\n+    template<typename Sample>\n+    struct with_p_square_cumulative_distribution_median_impl;\n+\n+    template<typename Sample>\n+    struct min_impl;\n+\n+    template<typename Sample, typename SumFeature = tag::sum>\n+    struct mean_impl;\n+\n+    template<typename Sample, typename Tag = tag::sample>\n+    struct immediate_mean_impl;\n+\n+    template<typename N, typename Sample>\n+    struct moment_impl;\n+\n+    template<typename Sample, typename LeftRight>\n+    struct peaks_over_threshold_prob_impl;\n+\n+    template<typename Sample, typename Impl, typename LeftRight>\n+    struct pot_quantile_impl;\n+\n+    template<typename Sample, typename Impl, typename LeftRight>\n+    struct pot_tail_mean_impl;\n+\n+    template<typename Sample>\n+    struct p_square_cumulative_distribution_impl;\n+\n+    template<typename Sample, typename Impl>\n+    struct p_square_quantile_impl;\n+\n+    template<typename Sample>\n+    struct skewness_impl;\n+\n+    template<typename Sample, typename Tag = tag::sample>\n+    struct sum_impl;\n+\n+    template<typename Sample, typename Tag>\n+    struct sum_kahan_impl;\n+\n+    template<typename Sample, typename LeftRight>\n+    struct tail_impl;\n+\n+    template<typename Sample, typename LeftRight>\n+    struct coherent_tail_mean_impl;\n+\n+    template<typename Sample, typename LeftRight>\n+    struct non_coherent_tail_mean_impl;\n+\n+    template<typename Sample, typename LeftRight>\n+    struct tail_quantile_impl;\n+\n+    template<typename VariateType, typename VariateTag, typename LeftRight>\n+    struct tail_variate_impl;\n+\n+    template<typename Sample, typename Impl, typename LeftRight, typename VariateTag>\n+    struct tail_variate_means_impl;\n+\n+    template<typename Sample, typename MeanFeature>\n+    struct lazy_variance_impl;\n+\n+    template<typename Sample, typename MeanFeature, typename Tag>\n+    struct variance_impl;\n+\n+    template<typename Sample, typename Weight, typename VariateType, typename VariateTag>\n+    struct weighted_covariance_impl;\n+\n+    template<typename Sample, typename Weight>\n+    struct weighted_density_impl;\n+\n+    template<typename Sample, typename Weight>\n+    struct weighted_kurtosis_impl;\n+\n+    template<typename Sample>\n+    struct weighted_median_impl;\n+\n+    template<typename Sample>\n+    struct with_density_weighted_median_impl;\n+\n+    template<typename Sample, typename Weight>\n+    struct with_p_square_cumulative_distribution_weighted_median_impl;\n+\n+    template<typename Sample, typename Weight, typename Tag>\n+    struct weighted_mean_impl;\n+\n+    template<typename Sample, typename Weight, typename Tag>\n+    struct immediate_weighted_mean_impl;\n+\n+    template<typename Sample, typename Weight, typename LeftRight>\n+    struct weighted_peaks_over_threshold_impl;\n+\n+    template<typename Sample, typename Weight, typename LeftRight>\n+    struct weighted_peaks_over_threshold_prob_impl;\n+\n+    template<typename Sample, typename Weight>\n+    struct with_p_square_cumulative_distribution_weighted_median_impl;\n+\n+    template<typename Sample, typename Weight>\n+    struct weighted_extended_p_square_impl;\n+\n+    template<typename N, typename Sample, typename Weight>\n+    struct weighted_moment_impl;\n+\n+    template<typename Sample, typename Weight>\n+    struct weighted_p_square_cumulative_distribution_impl;\n+\n+    template<typename Sample, typename Weight, typename Impl>\n+    struct weighted_p_square_quantile_impl;\n+\n+    template<typename Sample, typename Weight>\n+    struct weighted_skewness_impl;\n+\n+    template<typename Sample, typename Weight, typename Tag>\n+    struct weighted_sum_impl;\n+\n+    template<typename Sample, typename Weight, typename Tag>\n+    struct weighted_sum_kahan_impl;\n+\n+    template<typename Sample, typename Weight, typename LeftRight>\n+    struct non_coherent_weighted_tail_mean_impl;\n+\n+    template<typename Sample, typename Weight, typename LeftRight>\n+    struct weighted_tail_quantile_impl;\n+\n+    template<typename Sample, typename Weight, typename Impl, typename LeftRight, typename VariateType>\n+    struct weighted_tail_variate_means_impl;\n+\n+    template<typename Sample, typename Weight, typename MeanFeature>\n+    struct lazy_weighted_variance_impl;\n+\n+    template<typename Sample, typename Weight, typename MeanFeature, typename Tag>\n+    struct weighted_variance_impl;\n+\n+    template<typename Sample>\n+    struct rolling_window_plus1_impl;\n+\n+    template<typename Sample>\n+    struct rolling_window_impl;\n+\n+    template<typename Sample>\n+    struct rolling_sum_impl;\n+\n+    template<typename Sample>\n+    struct rolling_count_impl;\n+\n+    template<typename Sample>\n+    struct rolling_mean_impl;\n+} // namespace impl\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// stats\n+//      A more descriptive name for an MPL sequence of statistics.\n+template<BOOST_PP_ENUM_PARAMS_WITH_A_DEFAULT(BOOST_ACCUMULATORS_MAX_FEATURES, typename Feature, mpl::na)>\n+struct stats;\n+\n+template<BOOST_PP_ENUM_PARAMS_WITH_A_DEFAULT(BOOST_ACCUMULATORS_MAX_FEATURES, typename Feature, mpl::na)>\n+struct with_error;\n+\n+// modifiers for the mean and variance stats\n+struct lazy {};\n+struct immediate {};\n+\n+// modifiers for the variance stat\n+// struct fast {};\n+// struct accurate {};\n+\n+// modifiers for order\n+struct right {};\n+struct left {};\n+// typedef right default_order_tag_type;\n+\n+// modifiers for the tail_variate_means stat\n+struct absolute {};\n+struct relative {};\n+\n+// modifiers for median and weighted_median stats\n+struct with_density {};\n+struct with_p_square_cumulative_distribution {};\n+struct with_p_square_quantile {};\n+\n+// modifiers for peaks_over_threshold stat\n+struct with_threshold_value {};\n+struct with_threshold_probability {};\n+\n+// modifiers for extended_p_square_quantile and weighted_extended_p_square_quantile stats\n+struct weighted {};\n+struct unweighted {};\n+struct linear {};\n+struct quadratic {};\n+\n+// modifiers for p_square_quantile\n+struct regular {};\n+struct for_median {};\n+\n+// modifier for sum_kahan, sum_of_weights_kahan, sum_of_variates_kahan, weighted_sum_kahan\n+struct kahan {};\n+\n+}} // namespace boost::accumulators\n+\n+#endif"
      },
      {
        "sha": "76753cd67413682a3fc404c279ec84bed32ad615",
        "filename": "src/boost/algorithm/algorithm.hpp",
        "status": "added",
        "additions": 89,
        "deletions": 0,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/algorithm.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/algorithm.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/algorithm.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,89 @@\n+/* \n+   Copyright (c) Marshall Clow 2014.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+ Revision history:\n+    2 Dec 2014 mtc First version; power\n+   \n+*/\n+\n+/// \\file algorithm.hpp\n+/// \\brief Misc Algorithms\n+/// \\author Marshall Clow\n+///\n+\n+#ifndef BOOST_ALGORITHM_HPP\n+#define BOOST_ALGORITHM_HPP\n+\n+#include <functional> // for plus and multiplies\n+\n+#include <boost/config.hpp>\n+#include <boost/utility/enable_if.hpp> // for boost::disable_if\n+#include <boost/type_traits/is_integral.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+template <typename T>\n+BOOST_CXX14_CONSTEXPR T identity_operation ( std::multiplies<T> ) { return T(1); }\n+\n+template <typename T>\n+BOOST_CXX14_CONSTEXPR T identity_operation ( std::plus<T> ) { return T(0); }\n+\n+\n+/// \\fn power ( T x, Integer n )\n+/// \\return the value \"x\" raised to the power \"n\"\n+/// \n+/// \\param x     The value to be exponentiated\n+/// \\param n     The exponent (must be >= 0)\n+///\n+//  \\remark Taken from Knuth, The Art of Computer Programming, Volume 2:\n+//  Seminumerical Algorithms, Section 4.6.3\n+template <typename T, typename Integer>\n+BOOST_CXX14_CONSTEXPR typename boost::enable_if<boost::is_integral<Integer>, T>::type\n+power (T x, Integer n) {\n+    T y = 1; // Should be \"T y{1};\" \n+    if (n == 0) return y;\n+    while (true) {\n+        if (n % 2 == 1) {\n+            y = x * y;\n+            if (n == 1)\n+                return y;\n+            }\n+        n = n / 2;\n+        x = x * x;\n+        }\n+    return y;\n+    }\n+\n+/// \\fn power ( T x, Integer n, Operation op )\n+/// \\return the value \"x\" raised to the power \"n\"\n+/// using the operation \"op\".\n+/// \n+/// \\param x     The value to be exponentiated\n+/// \\param n     The exponent (must be >= 0)\n+/// \\param op    The operation used\n+///\n+//  \\remark Taken from Knuth, The Art of Computer Programming, Volume 2:\n+//  Seminumerical Algorithms, Section 4.6.3\n+template <typename T, typename Integer, typename Operation>\n+BOOST_CXX14_CONSTEXPR typename boost::enable_if<boost::is_integral<Integer>, T>::type\n+power (T x, Integer n, Operation op) {\n+    T y = identity_operation(op);\n+    if (n == 0) return y;\n+    while (true) {\n+        if (n % 2 == 1) {\n+            y = op(x, y);\n+            if (n == 1)\n+                return y;\n+            }\n+        n = n / 2;\n+        x = op(x, x);\n+        }\n+    return y;\n+    }\n+\n+}}\n+\n+#endif // BOOST_ALGORITHM_HPP"
      },
      {
        "sha": "124c31efe3c75e1271dcc9b2ea6d92b6fea495b5",
        "filename": "src/boost/algorithm/apply_permutation.hpp",
        "status": "added",
        "additions": 126,
        "deletions": 0,
        "changes": 126,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/apply_permutation.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/apply_permutation.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/apply_permutation.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,126 @@\n+/*\n+  Copyright (c) Alexander Zaitsev <zamazan4ik@gmail.com>, 2017\n+\n+  Distributed under the Boost Software License, Version 1.0. (See\n+  accompanying file LICENSE_1_0.txt or copy at\n+  http://www.boost.org/LICENSE_1_0.txt)\n+\n+  See http://www.boost.org/ for latest version.\n+\n+\n+  Based on https://blogs.msdn.microsoft.com/oldnewthing/20170104-00/?p=95115\n+*/\n+\n+/// \\file  apply_permutation.hpp\n+/// \\brief Apply permutation to a sequence.\n+/// \\author Alexander Zaitsev\n+\n+#ifndef BOOST_ALGORITHM_APPLY_PERMUTATION_HPP\n+#define BOOST_ALGORITHM_APPLY_PERMUTATION_HPP\n+\n+#include <algorithm>\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+\n+namespace boost { namespace algorithm\n+{\n+\n+/// \\fn apply_permutation ( RandomAccessIterator1 item_begin, RandomAccessIterator1 item_end, RandomAccessIterator2 ind_begin )\n+/// \\brief Reorder item sequence with index sequence order\n+///\n+/// \\param item_begin    The start of the item sequence\n+/// \\param item_end\t\t One past the end of the item sequence\n+/// \\param ind_begin     The start of the index sequence.\n+///\n+/// \\note Item sequence size should be equal to index size. Otherwise behavior is undefined.\n+///       Complexity: O(N).\n+template<typename RandomAccessIterator1, typename RandomAccessIterator2>\n+void\n+apply_permutation(RandomAccessIterator1 item_begin, RandomAccessIterator1 item_end,\n+                  RandomAccessIterator2 ind_begin, RandomAccessIterator2 ind_end)\n+{\n+    typedef typename std::iterator_traits<RandomAccessIterator1>::difference_type Diff;\n+    typedef typename std::iterator_traits<RandomAccessIterator2>::difference_type Index;\n+    using std::swap;\n+    Diff size = std::distance(item_begin, item_end);\n+    for (Diff i = 0; i < size; i++)\n+    {\n+        Diff current = i;\n+        while (i != ind_begin[current])\n+        {\n+            Index next = ind_begin[current];\n+            swap(item_begin[current], item_begin[next]);\n+            ind_begin[current] = current;\n+            current = next;\n+        }\n+        ind_begin[current] = current;\n+    }\n+}\n+\n+/// \\fn apply_reverse_permutation ( RandomAccessIterator1 item_begin, RandomAccessIterator1 item_end, RandomAccessIterator2 ind_begin )\n+/// \\brief Reorder item sequence with index sequence order\n+///\n+/// \\param item_begin    The start of the item sequence\n+/// \\param item_end\t\t One past the end of the item sequence\n+/// \\param ind_begin     The start of the index sequence.\n+///\n+/// \\note Item sequence size should be equal to index size. Otherwise behavior is undefined.\n+///       Complexity: O(N).\n+template<typename RandomAccessIterator1, typename RandomAccessIterator2>\n+void\n+apply_reverse_permutation(\n+        RandomAccessIterator1 item_begin,\n+        RandomAccessIterator1 item_end,\n+        RandomAccessIterator2 ind_begin,\n+        RandomAccessIterator2 ind_end)\n+{\n+    typedef typename std::iterator_traits<RandomAccessIterator2>::difference_type Diff;\n+    using std::swap;\n+    Diff length = std::distance(item_begin, item_end);\n+    for (Diff i = 0; i < length; i++)\n+    {\n+        while (i != ind_begin[i])\n+        {\n+            Diff next = ind_begin[i];\n+            swap(item_begin[i], item_begin[next]);\n+            swap(ind_begin[i], ind_begin[next]);\n+        }\n+    }\n+}\n+\n+/// \\fn apply_permutation ( Range1 item_range, Range2 ind_range )\n+/// \\brief Reorder item sequence with index sequence order\n+///\n+/// \\param item_range    The item sequence\n+/// \\param ind_range     The index sequence\n+///\n+/// \\note Item sequence size should be equal to index size. Otherwise behavior is undefined.\n+///       Complexity: O(N).\n+template<typename Range1, typename Range2>\n+void\n+apply_permutation(Range1& item_range, Range2& ind_range)\n+{\n+    apply_permutation(boost::begin(item_range), boost::end(item_range),\n+                      boost::begin(ind_range), boost::end(ind_range));\n+}\n+\n+/// \\fn apply_reverse_permutation ( Range1 item_range, Range2 ind_range )\n+/// \\brief Reorder item sequence with index sequence order\n+///\n+/// \\param item_range    The item sequence\n+/// \\param ind_range     The index sequence\n+///\n+/// \\note Item sequence size should be equal to index size. Otherwise behavior is undefined.\n+///       Complexity: O(N).\n+template<typename Range1, typename Range2>\n+void\n+apply_reverse_permutation(Range1& item_range, Range2& ind_range)\n+{\n+    apply_reverse_permutation(boost::begin(item_range), boost::end(item_range),\n+                              boost::begin(ind_range), boost::end(ind_range));\n+}\n+\n+}}\n+#endif //BOOST_ALGORITHM_APPLY_PERMUTATION_HPP"
      },
      {
        "sha": "82a99bde0d37a0ae068faca79f554a0d6103e7a1",
        "filename": "src/boost/algorithm/clamp.hpp",
        "status": "added",
        "additions": 176,
        "deletions": 0,
        "changes": 176,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/clamp.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/clamp.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/clamp.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,176 @@\n+/* \n+   Copyright (c) Marshall Clow 2008-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+ Revision history:\n+   27 June 2009 mtc First version\n+   23 Oct  2010 mtc Added predicate version\n+   \n+*/\n+\n+/// \\file clamp.hpp\n+/// \\brief Clamp algorithm\n+/// \\author Marshall Clow\n+///\n+/// Suggested by olafvdspek in https://svn.boost.org/trac/boost/ticket/3215\n+\n+#ifndef BOOST_ALGORITHM_CLAMP_HPP\n+#define BOOST_ALGORITHM_CLAMP_HPP\n+\n+#include <functional>       //  For std::less\n+#include <iterator>         //  For std::iterator_traits\n+#include <cassert>\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+#include <boost/mpl/identity.hpp>      // for identity\n+#include <boost/utility/enable_if.hpp> // for boost::disable_if\n+\n+namespace boost { namespace algorithm {\n+\n+/// \\fn clamp ( T const& val, \n+///               typename boost::mpl::identity<T>::type const & lo, \n+///               typename boost::mpl::identity<T>::type const & hi, Pred p )\n+/// \\return the value \"val\" brought into the range [ lo, hi ]\n+///     using the comparison predicate p.\n+///     If p ( val, lo ) return lo.\n+///     If p ( hi, val ) return hi.\n+///     Otherwise, return the original value.\n+/// \n+/// \\param val   The value to be clamped\n+/// \\param lo    The lower bound of the range to be clamped to\n+/// \\param hi    The upper bound of the range to be clamped to\n+/// \\param p     A predicate to use to compare the values.\n+///                 p ( a, b ) returns a boolean.\n+///\n+  template<typename T, typename Pred> \n+  BOOST_CXX14_CONSTEXPR T const & clamp ( T const& val, \n+    typename boost::mpl::identity<T>::type const & lo, \n+    typename boost::mpl::identity<T>::type const & hi, Pred p )\n+  {\n+//    assert ( !p ( hi, lo ));    // Can't assert p ( lo, hi ) b/c they might be equal\n+    return p ( val, lo ) ? lo : p ( hi, val ) ? hi : val;\n+  } \n+\n+\n+/// \\fn clamp ( T const& val, \n+///               typename boost::mpl::identity<T>::type const & lo, \n+///               typename boost::mpl::identity<T>::type const & hi )\n+/// \\return the value \"val\" brought into the range [ lo, hi ].\n+///     If the value is less than lo, return lo.\n+///     If the value is greater than \"hi\", return hi.\n+///     Otherwise, return the original value.\n+///\n+/// \\param val   The value to be clamped\n+/// \\param lo    The lower bound of the range to be clamped to\n+/// \\param hi    The upper bound of the range to be clamped to\n+///\n+  template<typename T> \n+  BOOST_CXX14_CONSTEXPR T const& clamp ( const T& val, \n+    typename boost::mpl::identity<T>::type const & lo, \n+    typename boost::mpl::identity<T>::type const & hi )\n+  {\n+    return boost::algorithm::clamp ( val, lo, hi, std::less<T>());\n+  } \n+\n+/// \\fn clamp_range ( InputIterator first, InputIterator last, OutputIterator out, \n+///       std::iterator_traits<InputIterator>::value_type const & lo, \n+///       std::iterator_traits<InputIterator>::value_type const & hi )\n+/// \\return clamp the sequence of values [first, last) into [ lo, hi ]\n+/// \n+/// \\param first The start of the range of values\n+/// \\param last  One past the end of the range of input values\n+/// \\param out   An output iterator to write the clamped values into\n+/// \\param lo    The lower bound of the range to be clamped to\n+/// \\param hi    The upper bound of the range to be clamped to\n+///\n+  template<typename InputIterator, typename OutputIterator> \n+  BOOST_CXX14_CONSTEXPR OutputIterator clamp_range ( InputIterator first, InputIterator last, OutputIterator out,\n+    typename std::iterator_traits<InputIterator>::value_type const & lo, \n+    typename std::iterator_traits<InputIterator>::value_type const & hi )\n+  {\n+  // this could also be written with bind and std::transform\n+    while ( first != last )\n+        *out++ = boost::algorithm::clamp ( *first++, lo, hi );\n+    return out;\n+  } \n+\n+/// \\fn clamp_range ( const Range &r, OutputIterator out, \n+///       typename std::iterator_traits<typename boost::range_iterator<const Range>::type>::value_type const & lo,\n+///       typename std::iterator_traits<typename boost::range_iterator<const Range>::type>::value_type const & hi )\n+/// \\return clamp the sequence of values [first, last) into [ lo, hi ]\n+/// \n+/// \\param r     The range of values to be clamped\n+/// \\param out   An output iterator to write the clamped values into\n+/// \\param lo    The lower bound of the range to be clamped to\n+/// \\param hi    The upper bound of the range to be clamped to\n+///\n+  template<typename Range, typename OutputIterator> \n+  BOOST_CXX14_CONSTEXPR typename boost::disable_if_c<boost::is_same<Range, OutputIterator>::value, OutputIterator>::type\n+  clamp_range ( const Range &r, OutputIterator out,\n+    typename std::iterator_traits<typename boost::range_iterator<const Range>::type>::value_type const & lo, \n+    typename std::iterator_traits<typename boost::range_iterator<const Range>::type>::value_type const & hi )\n+  {\n+    return boost::algorithm::clamp_range ( boost::begin ( r ), boost::end ( r ), out, lo, hi );\n+  } \n+\n+\n+/// \\fn clamp_range ( InputIterator first, InputIterator last, OutputIterator out, \n+///       std::iterator_traits<InputIterator>::value_type const & lo, \n+///       std::iterator_traits<InputIterator>::value_type const & hi, Pred p )\n+/// \\return clamp the sequence of values [first, last) into [ lo, hi ]\n+///     using the comparison predicate p.\n+/// \n+/// \\param first The start of the range of values\n+/// \\param last  One past the end of the range of input values\n+/// \\param out   An output iterator to write the clamped values into\n+/// \\param lo    The lower bound of the range to be clamped to\n+/// \\param hi    The upper bound of the range to be clamped to\n+/// \\param p     A predicate to use to compare the values.\n+///                 p ( a, b ) returns a boolean.\n+\n+///\n+  template<typename InputIterator, typename OutputIterator, typename Pred> \n+  BOOST_CXX14_CONSTEXPR OutputIterator clamp_range ( InputIterator first, InputIterator last, OutputIterator out,\n+    typename std::iterator_traits<InputIterator>::value_type const & lo, \n+    typename std::iterator_traits<InputIterator>::value_type const & hi, Pred p )\n+  {\n+  // this could also be written with bind and std::transform\n+    while ( first != last )\n+        *out++ = boost::algorithm::clamp ( *first++, lo, hi, p );\n+    return out;\n+  } \n+\n+/// \\fn clamp_range ( const Range &r, OutputIterator out, \n+///       typename std::iterator_traits<typename boost::range_iterator<const Range>::type>::value_type const & lo,\n+///       typename std::iterator_traits<typename boost::range_iterator<const Range>::type>::value_type const & hi,\n+///       Pred p )\n+/// \\return clamp the sequence of values [first, last) into [ lo, hi ]\n+///     using the comparison predicate p.\n+/// \n+/// \\param r     The range of values to be clamped\n+/// \\param out   An output iterator to write the clamped values into\n+/// \\param lo    The lower bound of the range to be clamped to\n+/// \\param hi    The upper bound of the range to be clamped to\n+/// \\param p     A predicate to use to compare the values.\n+///                 p ( a, b ) returns a boolean.\n+//\n+//  Disable this template if the first two parameters are the same type;\n+//  In that case, the user will get the two iterator version.\n+  template<typename Range, typename OutputIterator, typename Pred> \n+  BOOST_CXX14_CONSTEXPR typename boost::disable_if_c<boost::is_same<Range, OutputIterator>::value, OutputIterator>::type\n+  clamp_range ( const Range &r, OutputIterator out,\n+    typename std::iterator_traits<typename boost::range_iterator<const Range>::type>::value_type const & lo, \n+    typename std::iterator_traits<typename boost::range_iterator<const Range>::type>::value_type const & hi,\n+    Pred p )\n+  {\n+    return boost::algorithm::clamp_range ( boost::begin ( r ), boost::end ( r ), out, lo, hi, p );\n+  } \n+\n+\n+}}\n+\n+#endif // BOOST_ALGORITHM_CLAMP_HPP"
      },
      {
        "sha": "f7ee311b28e7f4648e25ec2d5de59f26314ab7f5",
        "filename": "src/boost/algorithm/cxx11/all_of.hpp",
        "status": "added",
        "additions": 84,
        "deletions": 0,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/all_of.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/all_of.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx11/all_of.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,84 @@\n+/* \n+   Copyright (c) Marshall Clow 2008-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file  all_of.hpp\n+/// \\brief Test ranges to see if all elements match a value or predicate.\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_ALL_OF_HPP\n+#define BOOST_ALGORITHM_ALL_OF_HPP\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+/// \\fn all_of ( InputIterator first, InputIterator last, Predicate p )\n+/// \\return true if all elements in [first, last) satisfy the predicate 'p'\n+/// \\note returns true on an empty range\n+/// \n+/// \\param first The start of the input sequence\n+/// \\param last  One past the end of the input sequence\n+/// \\param p     A predicate for testing the elements of the sequence\n+///\n+/// \\note           This function is part of the C++2011 standard library.\n+template<typename InputIterator, typename Predicate> \n+BOOST_CXX14_CONSTEXPR bool all_of ( InputIterator first, InputIterator last, Predicate p )\n+{\n+    for ( ; first != last; ++first )\n+        if ( !p(*first)) \n+            return false;\n+    return true; \n+} \n+\n+/// \\fn all_of ( const Range &r, Predicate p )\n+/// \\return true if all elements in the range satisfy the predicate 'p'\n+/// \\note returns true on an empty range\n+/// \n+/// \\param r    The input range\n+/// \\param p    A predicate for testing the elements of the range\n+///\n+template<typename Range, typename Predicate> \n+BOOST_CXX14_CONSTEXPR bool all_of ( const Range &r, Predicate p )\n+{\n+    return boost::algorithm::all_of ( boost::begin (r), boost::end (r), p );\n+} \n+\n+/// \\fn all_of_equal ( InputIterator first, InputIterator last, const T &val )\n+/// \\return true if all elements in [first, last) are equal to 'val'\n+/// \\note returns true on an empty range\n+/// \n+/// \\param first The start of the input sequence\n+/// \\param last  One past the end of the input sequence\n+/// \\param val   A value to compare against\n+///\n+template<typename InputIterator, typename T> \n+BOOST_CXX14_CONSTEXPR bool all_of_equal ( InputIterator first, InputIterator last, const T &val )\n+{\n+    for ( ; first != last; ++first )\n+    if ( val != *first ) \n+        return false;\n+    return true; \n+} \n+\n+/// \\fn all_of_equal ( const Range &r, const T &val )\n+/// \\return true if all elements in the range are equal to 'val'\n+/// \\note returns true on an empty range\n+/// \n+/// \\param r    The input range\n+/// \\param val  A value to compare against\n+///\n+template<typename Range, typename T> \n+BOOST_CXX14_CONSTEXPR bool all_of_equal ( const Range &r, const T &val ) \n+{\n+    return boost::algorithm::all_of_equal ( boost::begin (r), boost::end (r), val );\n+} \n+\n+}} // namespace boost and algorithm\n+\n+#endif // BOOST_ALGORITHM_ALL_OF_HPP"
      },
      {
        "sha": "51dfba1936b581b96df9c6ae4f78fa1b521e30be",
        "filename": "src/boost/algorithm/cxx11/any_of.hpp",
        "status": "added",
        "additions": 85,
        "deletions": 0,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/any_of.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/any_of.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx11/any_of.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,85 @@\n+/* \n+   Copyright (c) Marshall Clow 2008-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+    For more information, see http://www.boost.org\n+*/\n+\n+/// \\file\n+/// \\brief Test ranges to see if any elements match a value or predicate.\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_ANY_OF_HPP\n+#define BOOST_ALGORITHM_ANY_OF_HPP\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+/// \\fn any_of ( InputIterator first, InputIterator last, Predicate p )\n+/// \\return true if any of the elements in [first, last) satisfy the predicate\n+/// \\note returns false on an empty range\n+/// \n+/// \\param first The start of the input sequence\n+/// \\param last  One past the end of the input sequence\n+/// \\param p     A predicate for testing the elements of the sequence\n+///\n+template<typename InputIterator, typename Predicate> \n+BOOST_CXX14_CONSTEXPR bool any_of ( InputIterator first, InputIterator last, Predicate p ) \n+{\n+    for ( ; first != last; ++first )\n+        if ( p(*first)) \n+            return true;\n+    return false; \n+} \n+\n+/// \\fn any_of ( const Range &r, Predicate p )\n+/// \\return true if any elements in the range satisfy the predicate 'p'\n+/// \\note returns false on an empty range\n+/// \n+/// \\param r    The input range\n+/// \\param p    A predicate for testing the elements of the range\n+///\n+template<typename Range, typename Predicate> \n+BOOST_CXX14_CONSTEXPR bool any_of ( const Range &r, Predicate p )\n+{\n+    return boost::algorithm::any_of (boost::begin (r), boost::end (r), p);\n+} \n+\n+/// \\fn any_of_equal ( InputIterator first, InputIterator last, const V &val )\n+/// \\return true if any of the elements in [first, last) are equal to 'val'\n+/// \\note returns false on an empty range\n+/// \n+/// \\param first The start of the input sequence\n+/// \\param last  One past the end of the input sequence\n+/// \\param val   A value to compare against\n+///\n+template<typename InputIterator, typename V> \n+BOOST_CXX14_CONSTEXPR bool any_of_equal ( InputIterator first, InputIterator last, const V &val ) \n+{\n+    for ( ; first != last; ++first )\n+        if ( val == *first )\n+            return true;\n+    return false; \n+} \n+\n+/// \\fn any_of_equal ( const Range &r, const V &val )\n+/// \\return true if any of the elements in the range are equal to 'val'\n+/// \\note returns false on an empty range\n+/// \n+/// \\param r     The input range\n+/// \\param val   A value to compare against\n+///\n+template<typename Range, typename V> \n+BOOST_CXX14_CONSTEXPR bool any_of_equal ( const Range &r, const V &val ) \n+{\n+    return boost::algorithm::any_of_equal (boost::begin (r), boost::end (r), val);\n+}\n+\n+}} // namespace boost and algorithm\n+\n+#endif // BOOST_ALGORITHM_ANY_OF_HPP"
      },
      {
        "sha": "d3914bf20e9c7c77da831c5bb1209cf27487c1df",
        "filename": "src/boost/algorithm/cxx11/copy_if.hpp",
        "status": "added",
        "additions": 131,
        "deletions": 0,
        "changes": 131,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/copy_if.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/copy_if.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx11/copy_if.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,131 @@\n+/* \n+   Copyright (c) Marshall Clow 2008-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file  copy_if.hpp\n+/// \\brief Copy a subset of a sequence to a new sequence\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_COPY_IF_HPP\n+#define BOOST_ALGORITHM_COPY_IF_HPP\n+\n+#include <utility>    // for std::pair, std::make_pair\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+/// \\fn copy_if ( InputIterator first, InputIterator last, OutputIterator result, Predicate p )\n+/// \\brief Copies all the elements from the input range that satisfy the\n+/// predicate to the output range.\n+/// \\return The updated output iterator\n+/// \n+/// \\param first    The start of the input sequence\n+/// \\param last     One past the end of the input sequence\n+/// \\param result   An output iterator to write the results into\n+/// \\param p        A predicate for testing the elements of the range\n+/// \\note           This function is part of the C++2011 standard library.\n+template<typename InputIterator, typename OutputIterator, typename Predicate> \n+BOOST_CXX14_CONSTEXPR OutputIterator copy_if ( InputIterator first, InputIterator last, OutputIterator result, Predicate p )\n+{\n+    for ( ; first != last; ++first )\n+        if (p(*first))\n+            *result++ = *first;\n+    return result;\n+}\n+\n+/// \\fn copy_if ( const Range &r, OutputIterator result, Predicate p )\n+/// \\brief Copies all the elements from the input range that satisfy the\n+/// predicate to the output range.\n+/// \\return The updated output iterator\n+/// \n+/// \\param r        The input range\n+/// \\param result   An output iterator to write the results into\n+/// \\param p        A predicate for testing the elements of the range\n+///\n+template<typename Range, typename OutputIterator, typename Predicate>\n+BOOST_CXX14_CONSTEXPR OutputIterator copy_if ( const Range &r, OutputIterator result, Predicate p )\n+{\n+    return boost::algorithm::copy_if (boost::begin (r), boost::end(r), result, p);\n+}\n+\n+\n+/// \\fn copy_while ( InputIterator first, InputIterator last, OutputIterator result, Predicate p )\n+/// \\brief Copies all the elements at the start of the input range that\n+///     satisfy the predicate to the output range.\n+/// \\return The updated input and output iterators\n+/// \n+/// \\param first    The start of the input sequence\n+/// \\param last     One past the end of the input sequence\n+/// \\param result   An output iterator to write the results into\n+/// \\param p        A predicate for testing the elements of the range\n+///\n+template<typename InputIterator, typename OutputIterator, typename Predicate> \n+BOOST_CXX14_CONSTEXPR std::pair<InputIterator, OutputIterator>\n+copy_while ( InputIterator first, InputIterator last, OutputIterator result, Predicate p )\n+{\n+    for ( ; first != last && p(*first); ++first )\n+        *result++ = *first;\n+    return std::make_pair(first, result);\n+}\n+\n+/// \\fn copy_while ( const Range &r, OutputIterator result, Predicate p )\n+/// \\brief Copies all the elements at the start of the input range that\n+///     satisfy the predicate to the output range.\n+/// \\return The updated input and output iterators\n+/// \n+/// \\param r        The input range\n+/// \\param result   An output iterator to write the results into\n+/// \\param p        A predicate for testing the elements of the range\n+///\n+template<typename Range, typename OutputIterator, typename Predicate>\n+BOOST_CXX14_CONSTEXPR std::pair<typename boost::range_iterator<const Range>::type, OutputIterator> \n+copy_while ( const Range &r, OutputIterator result, Predicate p )\n+{\n+    return boost::algorithm::copy_while (boost::begin (r), boost::end(r), result, p);\n+}\n+\n+\n+/// \\fn copy_until ( InputIterator first, InputIterator last, OutputIterator result, Predicate p )\n+/// \\brief Copies all the elements at the start of the input range that do not\n+///     satisfy the predicate to the output range.\n+/// \\return The updated output iterator\n+/// \n+/// \\param first    The start of the input sequence\n+/// \\param last     One past the end of the input sequence\n+/// \\param result   An output iterator to write the results into\n+/// \\param p        A predicate for testing the elements of the range\n+///\n+template<typename InputIterator, typename OutputIterator, typename Predicate> \n+BOOST_CXX14_CONSTEXPR std::pair<InputIterator, OutputIterator>\n+copy_until ( InputIterator first, InputIterator last, OutputIterator result, Predicate p )\n+{\n+    for ( ; first != last && !p(*first); ++first )\n+        *result++ = *first;\n+    return std::make_pair(first, result);\n+}\n+\n+/// \\fn copy_until ( const Range &r, OutputIterator result, Predicate p )\n+/// \\brief Copies all the elements at the start of the input range that do not\n+///     satisfy the predicate to the output range.\n+/// \\return The updated output iterator\n+/// \n+/// \\param r        The input range\n+/// \\param result   An output iterator to write the results into\n+/// \\param p        A predicate for testing the elements of the range\n+///\n+template<typename Range, typename OutputIterator, typename Predicate>\n+BOOST_CXX14_CONSTEXPR std::pair<typename boost::range_iterator<const Range>::type, OutputIterator> \n+copy_until ( const Range &r, OutputIterator result, Predicate p )\n+{\n+    return boost::algorithm::copy_until (boost::begin (r), boost::end(r), result, p);\n+}\n+\n+}} // namespace boost and algorithm\n+\n+#endif  // BOOST_ALGORITHM_COPY_IF_HPP"
      },
      {
        "sha": "a0130fabe0ac299dfb39f997b928dcfeb5bad13d",
        "filename": "src/boost/algorithm/cxx11/copy_n.hpp",
        "status": "added",
        "additions": 37,
        "deletions": 0,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/copy_n.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/copy_n.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx11/copy_n.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,37 @@\n+/* \n+   Copyright (c) Marshall Clow 2011-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file  copy_n.hpp\n+/// \\brief Copy n items from one sequence to another\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_COPY_N_HPP\n+#define BOOST_ALGORITHM_COPY_N_HPP\n+\n+#include <boost/config.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+/// \\fn copy_n ( InputIterator first, Size n, OutputIterator result )\n+/// \\brief Copies exactly n (n > 0) elements from the range starting at first to\n+///     the range starting at result.\n+/// \\return         The updated output iterator\n+/// \n+/// \\param first    The start of the input sequence\n+/// \\param n        The number of elements to copy\n+/// \\param result   An output iterator to write the results into\n+/// \\note           This function is part of the C++2011 standard library.\n+template <typename InputIterator, typename Size, typename OutputIterator>\n+BOOST_CXX14_CONSTEXPR OutputIterator copy_n ( InputIterator first, Size n, OutputIterator result )\n+{\n+    for ( ; n > 0; --n, ++first, ++result )\n+        *result = *first;\n+    return result;\n+}\n+}} // namespace boost and algorithm\n+\n+#endif  // BOOST_ALGORITHM_COPY_IF_HPP"
      },
      {
        "sha": "cc81d2975006768f5a65d2b67b739220bb9f98de",
        "filename": "src/boost/algorithm/cxx11/find_if_not.hpp",
        "status": "added",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/find_if_not.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/find_if_not.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx11/find_if_not.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,52 @@\n+/* \n+   Copyright (c) Marshall Clow 2011-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file  find_if_not.hpp\n+/// \\brief Find the first element in a sequence that does not satisfy a predicate.\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_FIND_IF_NOT_HPP\n+#define BOOST_ALGORITHM_FIND_IF_NOT_HPP\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+/// \\fn find_if_not(InputIterator first, InputIterator last, Predicate p)\n+/// \\brief Finds the first element in the sequence that does not satisfy the predicate.\n+/// \\return         The iterator pointing to the desired element.\n+/// \n+/// \\param first    The start of the input sequence\n+/// \\param last     One past the end of the input sequence\n+/// \\param p        A predicate for testing the elements of the range\n+/// \\note           This function is part of the C++2011 standard library.\n+template<typename InputIterator, typename Predicate> \n+BOOST_CXX14_CONSTEXPR InputIterator find_if_not ( InputIterator first, InputIterator last, Predicate p )\n+{\n+    for ( ; first != last; ++first )\n+        if ( !p(*first))\n+            break;\n+    return first;\n+}\n+\n+/// \\fn find_if_not ( const Range &r, Predicate p )\n+/// \\brief Finds the first element in the sequence that does not satisfy the predicate.\n+/// \\return         The iterator pointing to the desired element.\n+/// \n+/// \\param r        The input range\n+/// \\param p        A predicate for testing the elements of the range\n+///\n+template<typename Range, typename Predicate>\n+BOOST_CXX14_CONSTEXPR typename boost::range_iterator<const Range>::type find_if_not ( const Range &r, Predicate p )\n+{\n+    return boost::algorithm::find_if_not (boost::begin (r), boost::end(r), p);\n+}\n+\n+}}\n+#endif  // BOOST_ALGORITHM_FIND_IF_NOT_HPP"
      },
      {
        "sha": "e8b2b62ff43fff71a4bbb2a23a182dc86182400e",
        "filename": "src/boost/algorithm/cxx11/iota.hpp",
        "status": "added",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/iota.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/iota.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx11/iota.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,66 @@\n+/* \n+   Copyright (c) Marshall Clow 2008-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file  iota.hpp\n+/// \\brief Generate an increasing series\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_IOTA_HPP\n+#define BOOST_ALGORITHM_IOTA_HPP\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+/// \\fn iota ( ForwardIterator first, ForwardIterator last, T value )\n+/// \\brief Generates an increasing sequence of values, and stores them in [first, last)\n+/// \n+/// \\param first    The start of the input sequence\n+/// \\param last     One past the end of the input sequence\n+/// \\param value    The initial value of the sequence to be generated\n+/// \\note           This function is part of the C++2011 standard library.\n+template <typename ForwardIterator, typename T>\n+BOOST_CXX14_CONSTEXPR void iota ( ForwardIterator first, ForwardIterator last, T value )\n+{\n+    for ( ; first != last; ++first, ++value )\n+        *first = value;\n+}\n+\n+/// \\fn iota ( Range &r, T value )\n+/// \\brief Generates an increasing sequence of values, and stores them in the input Range.\n+/// \n+/// \\param r        The input range\n+/// \\param value    The initial value of the sequence to be generated\n+///\n+template <typename Range, typename T>\n+BOOST_CXX14_CONSTEXPR void iota ( Range &r, T value )\n+{\n+    boost::algorithm::iota (boost::begin(r), boost::end(r), value);\n+}\n+\n+\n+/// \\fn iota_n ( OutputIterator out, T value, std::size_t n )\n+/// \\brief Generates an increasing sequence of values, and stores them in the input Range.\n+/// \n+/// \\param out      An output iterator to write the results into\n+/// \\param value    The initial value of the sequence to be generated\n+/// \\param n        The number of items to write\n+///\n+template <typename OutputIterator, typename T>\n+BOOST_CXX14_CONSTEXPR OutputIterator iota_n ( OutputIterator out, T value, std::size_t n )\n+{\n+    for ( ; n > 0; --n, ++value )\n+        *out++ = value;\n+\n+    return out;\n+}\n+\n+}}\n+\n+#endif  // BOOST_ALGORITHM_IOTA_HPP"
      },
      {
        "sha": "47abc2c8d1009e760366b5ac23e23b89caf74900",
        "filename": "src/boost/algorithm/cxx11/is_partitioned.hpp",
        "status": "added",
        "additions": 59,
        "deletions": 0,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/is_partitioned.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/is_partitioned.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx11/is_partitioned.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,59 @@\n+/* \n+   Copyright (c) Marshall Clow 2011-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file  is_partitioned.hpp\n+/// \\brief Tell if a sequence is partitioned\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_IS_PARTITIONED_HPP\n+#define BOOST_ALGORITHM_IS_PARTITIONED_HPP\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+/// \\fn is_partitioned ( InputIterator first, InputIterator last, UnaryPredicate p )\n+/// \\brief Tests to see if a sequence is partitioned according to a predicate. \n+///\t   In other words, all the items in the sequence that satisfy the predicate are at the beginning of the sequence.\n+/// \n+/// \\param first    The start of the input sequence\n+/// \\param last     One past the end of the input sequence\n+/// \\param p        The predicate to test the values with\n+/// \\note           This function is part of the C++2011 standard library.\n+template <typename InputIterator, typename UnaryPredicate>\n+BOOST_CXX14_CONSTEXPR bool is_partitioned ( InputIterator first, InputIterator last, UnaryPredicate p )\n+{\n+//  Run through the part that satisfy the predicate\n+    for ( ; first != last; ++first )\n+        if ( !p (*first))\n+            break;\n+//  Now the part that does not satisfy the predicate\n+    for ( ; first != last; ++first )\n+        if ( p (*first))\n+            return false;\n+    return true;\n+}\n+\n+/// \\fn is_partitioned ( const Range &r, UnaryPredicate p )\n+/// \\brief Tests to see if a sequence is partitioned according to a predicate. \n+///\t   In other words, all the items in the sequence that satisfy the predicate are at the beginning of the sequence.\n+/// \n+/// \\param r        The input range\n+/// \\param p        The predicate to test the values with\n+///\n+template <typename Range, typename UnaryPredicate>\n+BOOST_CXX14_CONSTEXPR bool is_partitioned ( const Range &r, UnaryPredicate p )\n+{\n+    return boost::algorithm::is_partitioned (boost::begin(r), boost::end(r), p);\n+}\n+\n+\n+}}\n+\n+#endif  // BOOST_ALGORITHM_IS_PARTITIONED_HPP"
      },
      {
        "sha": "31eac939daa442cd578880b37a37e11a1961e41a",
        "filename": "src/boost/algorithm/cxx11/is_permutation.hpp",
        "status": "added",
        "additions": 186,
        "deletions": 0,
        "changes": 186,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/is_permutation.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/is_permutation.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx11/is_permutation.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,186 @@\n+/*\n+   Copyright (c) Marshall Clow 2011-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file  is_permutation.hpp\n+/// \\brief Is a sequence a permutation of another sequence\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_IS_PERMUTATION11_HPP\n+#define BOOST_ALGORITHM_IS_PERMUTATION11_HPP\n+\n+#include <algorithm>    // for std::find_if, count_if, mismatch\n+#include <utility>      // for std::pair\n+#include <functional>   // for std::equal_to\n+#include <iterator>\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+#include <boost/utility/enable_if.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+/// \\cond DOXYGEN_HIDE\n+namespace detail {\n+    template <typename Predicate, typename Iterator>\n+    struct value_predicate {\n+        value_predicate ( Predicate p, Iterator it ) : p_ ( p ), it_ ( it ) {}\n+\n+        template <typename T1>\n+        bool operator () ( const T1 &t1 ) const { return p_ ( *it_, t1 ); }\n+    private:\n+        Predicate p_;\n+        Iterator it_;\n+        };\n+        \n+//  Preconditions:\n+//  1. The sequences are the same length\n+//  2. Any common elements on the front have been removed (not necessary for correctness, just for performance)\n+    template< class ForwardIterator1, class ForwardIterator2, class BinaryPredicate >\n+    bool is_permutation_inner ( ForwardIterator1 first1, ForwardIterator1 last1,\n+                                ForwardIterator2 first2, ForwardIterator2 last2,\n+                                BinaryPredicate p ) {\n+        //  for each unique value in the sequence [first1,last1), count how many times\n+        //  it occurs, and make sure it occurs the same number of times in [first2, last2)\n+            for ( ForwardIterator1 iter = first1; iter != last1; ++iter ) {\n+                value_predicate<BinaryPredicate, ForwardIterator1> pred ( p, iter );\n+\n+            /*  For each value we haven't seen yet... */\n+                if ( std::find_if ( first1, iter, pred ) == iter ) {\n+                    std::size_t dest_count = std::count_if ( first2, last2, pred );\n+                    if ( dest_count == 0 || dest_count != (std::size_t) std::count_if ( iter, last1, pred ))\n+                        return false;\n+                    }\n+                }\n+\n+        return true;\n+        }                      \n+\n+    template< class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n+    bool is_permutation_tag ( ForwardIterator1 first1, ForwardIterator1 last1, \n+                          ForwardIterator2 first2, ForwardIterator2 last2, \n+                          BinaryPredicate p,\n+                          std::forward_iterator_tag, std::forward_iterator_tag ) {\n+\n+    //  Skip the common prefix (if any)\n+        while ( first1 != last1 && first2 != last2 && p ( *first1, *first2 )) {\n+            ++first1;\n+            ++first2;\n+            }\n+        if ( first1 != last1 && first2 != last2 )\n+            return boost::algorithm::detail::is_permutation_inner ( first1, last1, first2, last2,\n+                std::equal_to<typename std::iterator_traits<ForwardIterator1>::value_type> ());\n+        return first1 == last1 && first2 == last2;\n+        }\n+\n+    template <class RandomAccessIterator1, class RandomAccessIterator2, class BinaryPredicate>\n+    bool is_permutation_tag ( RandomAccessIterator1 first1, RandomAccessIterator1 last1, \n+                          RandomAccessIterator2 first2, RandomAccessIterator2 last2, \n+                          BinaryPredicate p,\n+                          std::random_access_iterator_tag, std::random_access_iterator_tag ) {\n+    //  Cheap check\n+        if ( std::distance ( first1, last1 ) != std::distance ( first2, last2 ))\n+            return false;\n+    //  Skip the common prefix (if any)\n+        while ( first1 != last1 && first2 != last2 && p ( *first1, *first2 )) {\n+            ++first1;\n+            ++first2;\n+            }\n+\n+        if ( first1 != last1 && first2 != last2 )\n+            return is_permutation_inner (first1, last1, first2, last2, p);\n+        return first1 == last1 && first2 == last2;\n+        }\n+\n+}\n+/// \\endcond\n+\n+/// \\fn is_permutation ( ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 first2, BinaryPredicate p )\n+/// \\brief Tests to see if the sequence [first,last) is a permutation of the sequence starting at first2\n+///\n+/// \\param first1   The start of the input sequence\n+/// \\param last1    One past the end of the input sequence\n+/// \\param first2   The start of the second sequence\n+/// \\param p        The predicate to compare elements with\n+///\n+/// \\note           This function is part of the C++2011 standard library.\n+template< class ForwardIterator1, class ForwardIterator2, class BinaryPredicate >\n+bool is_permutation ( ForwardIterator1 first1, ForwardIterator1 last1,\n+                      ForwardIterator2 first2, BinaryPredicate p )\n+{\n+//  Skip the common prefix (if any)\n+    std::pair<ForwardIterator1, ForwardIterator2> eq = std::mismatch (first1, last1, first2, p);\n+    first1 = eq.first;\n+    first2 = eq.second;\n+    if ( first1 != last1 ) {\n+    //  Create last2\n+        ForwardIterator2 last2 = first2;\n+        std::advance ( last2, std::distance (first1, last1));\n+        return boost::algorithm::detail::is_permutation_inner ( first1, last1, first2, last2, p );\n+        }\n+\n+    return true;\n+}\n+\n+/// \\fn is_permutation ( ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 first2 )\n+/// \\brief Tests to see if the sequence [first,last) is a permutation of the sequence starting at first2\n+///\n+/// \\param first1   The start of the input sequence\n+/// \\param last2    One past the end of the input sequence\n+/// \\param first2   The start of the second sequence\n+/// \\note           This function is part of the C++2011 standard library.\n+template< class ForwardIterator1, class ForwardIterator2 >\n+bool is_permutation ( ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2 )\n+{\n+//  How should I deal with the idea that ForwardIterator1::value_type\n+//  and ForwardIterator2::value_type could be different? Define my own comparison predicate?\n+//  Skip the common prefix (if any)\n+    std::pair<ForwardIterator1, ForwardIterator2> eq = std::mismatch (first1, last1, first2 );\n+    first1 = eq.first;\n+    first2 = eq.second;\n+    if ( first1 != last1 ) {\n+    //  Create last2\n+        ForwardIterator2 last2 = first2;\n+        std::advance ( last2, std::distance (first1, last1));\n+        return boost::algorithm::detail::is_permutation_inner ( first1, last1, first2, last2,\n+            std::equal_to<typename std::iterator_traits<ForwardIterator1>::value_type> ());\n+        }\n+    return true;\n+}\n+\n+\n+/// \\fn is_permutation ( const Range &r, ForwardIterator first2 )\n+/// \\brief Tests to see if the sequence [first,last) is a permutation of the sequence starting at first2\n+///\n+/// \\param r        The input range\n+/// \\param first2   The start of the second sequence\n+template <typename Range, typename ForwardIterator>\n+bool is_permutation ( const Range &r, ForwardIterator first2 )\n+{\n+    return boost::algorithm::is_permutation (boost::begin (r), boost::end (r), first2 );\n+}\n+\n+/// \\fn is_permutation ( const Range &r, ForwardIterator first2, BinaryPredicate pred )\n+/// \\brief Tests to see if the sequence [first,last) is a permutation of the sequence starting at first2\n+///\n+/// \\param r        The input range\n+/// \\param first2   The start of the second sequence\n+/// \\param pred     The predicate to compare elements with\n+///\n+//  Disable this template when the first two parameters are the same type\n+//  That way the non-range version will be chosen.\n+template <typename Range, typename ForwardIterator, typename BinaryPredicate>\n+typename boost::disable_if_c<boost::is_same<Range, ForwardIterator>::value, bool>::type\n+is_permutation ( const Range &r, ForwardIterator first2, BinaryPredicate pred )\n+{\n+    return boost::algorithm::is_permutation (boost::begin (r), boost::end (r), first2, pred );\n+}\n+\n+}}\n+\n+#endif  // BOOST_ALGORITHM_IS_PERMUTATION11_HPP"
      },
      {
        "sha": "0aa8122363f095e5633902d30ee73a99a5d095ac",
        "filename": "src/boost/algorithm/cxx11/is_sorted.hpp",
        "status": "added",
        "additions": 281,
        "deletions": 0,
        "changes": 281,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/is_sorted.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/is_sorted.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx11/is_sorted.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,281 @@\n+//  Copyright (c) 2010 Nuovation System Designs, LLC\n+//    Grant Erickson <gerickson@nuovations.com>\n+//\n+//  Reworked somewhat by Marshall Clow; August 2010\n+//  \n+//  Distributed under the Boost Software License, Version 1.0. (See\n+//  accompanying file LICENSE_1_0.txt or copy at\n+//  http://www.boost.org/LICENSE_1_0.txt)\n+//\n+//  See http://www.boost.org/ for latest version.\n+//\n+\n+#ifndef BOOST_ALGORITHM_ORDERED_HPP\n+#define BOOST_ALGORITHM_ORDERED_HPP\n+\n+#include <functional>\n+#include <iterator>\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+\n+#include <boost/utility/enable_if.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+#include <boost/mpl/identity.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+/// \\fn is_sorted_until ( ForwardIterator first, ForwardIterator last, Pred p )\n+/// \\return the point in the sequence [first, last) where the elements are unordered\n+///     (according to the comparison predicate 'p').\n+/// \n+/// \\param first The start of the sequence to be tested.\n+/// \\param last  One past the end of the sequence\n+/// \\param p     A binary predicate that returns true if two elements are ordered.\n+///\n+    template <typename ForwardIterator, typename Pred>\n+    BOOST_CXX14_CONSTEXPR ForwardIterator is_sorted_until ( ForwardIterator first, ForwardIterator last, Pred p )\n+    {\n+        if ( first == last ) return last;  // the empty sequence is ordered\n+        ForwardIterator next = first;\n+        while ( ++next != last )\n+        {\n+            if ( p ( *next, *first ))\n+                return next;\n+            first = next;\n+        }\n+        return last;    \n+    }\n+\n+/// \\fn is_sorted_until ( ForwardIterator first, ForwardIterator last )\n+/// \\return the point in the sequence [first, last) where the elements are unordered\n+/// \n+/// \\param first The start of the sequence to be tested.\n+/// \\param last  One past the end of the sequence\n+///\n+    template <typename ForwardIterator>\n+    BOOST_CXX14_CONSTEXPR ForwardIterator is_sorted_until ( ForwardIterator first, ForwardIterator last )\n+    {\n+        typedef typename std::iterator_traits<ForwardIterator>::value_type value_type;\n+        return boost::algorithm::is_sorted_until ( first, last, std::less<value_type>());\n+    }\n+\n+\n+/// \\fn is_sorted ( ForwardIterator first, ForwardIterator last, Pred p )\n+/// \\return whether or not the entire sequence is sorted\n+/// \n+/// \\param first The start of the sequence to be tested.\n+/// \\param last  One past the end of the sequence\n+/// \\param p     A binary predicate that returns true if two elements are ordered.\n+///\n+    template <typename ForwardIterator, typename Pred>\n+    BOOST_CXX14_CONSTEXPR bool is_sorted ( ForwardIterator first, ForwardIterator last, Pred p )\n+    {\n+        return boost::algorithm::is_sorted_until (first, last, p) == last;\n+    }\n+\n+/// \\fn is_sorted ( ForwardIterator first, ForwardIterator last )\n+/// \\return whether or not the entire sequence is sorted\n+/// \n+/// \\param first The start of the sequence to be tested.\n+/// \\param last  One past the end of the sequence\n+///\n+    template <typename ForwardIterator>\n+    BOOST_CXX14_CONSTEXPR bool is_sorted ( ForwardIterator first, ForwardIterator last )\n+    {\n+        return boost::algorithm::is_sorted_until (first, last) == last;\n+    }\n+\n+///\n+/// -- Range based versions of the C++11 functions\n+///\n+\n+/// \\fn is_sorted_until ( const R &range, Pred p )\n+/// \\return the point in the range R where the elements are unordered\n+///     (according to the comparison predicate 'p').\n+/// \n+/// \\param range The range to be tested.\n+/// \\param p     A binary predicate that returns true if two elements are ordered.\n+///\n+    template <typename R, typename Pred>\n+    BOOST_CXX14_CONSTEXPR typename boost::lazy_disable_if_c<\n+        boost::is_same<R, Pred>::value, \n+        typename boost::range_iterator<const R> \n+    >::type is_sorted_until ( const R &range, Pred p )\n+    {\n+        return boost::algorithm::is_sorted_until ( boost::begin ( range ), boost::end ( range ), p );\n+    }\n+\n+\n+/// \\fn is_sorted_until ( const R &range )\n+/// \\return the point in the range R where the elements are unordered\n+/// \n+/// \\param range The range to be tested.\n+///\n+    template <typename R>\n+    BOOST_CXX14_CONSTEXPR typename boost::range_iterator<const R>::type is_sorted_until ( const R &range )\n+    {\n+        return boost::algorithm::is_sorted_until ( boost::begin ( range ), boost::end ( range ));\n+    }\n+\n+/// \\fn is_sorted ( const R &range, Pred p )\n+/// \\return whether or not the entire range R is sorted\n+///     (according to the comparison predicate 'p').\n+/// \n+/// \\param range The range to be tested.\n+/// \\param p     A binary predicate that returns true if two elements are ordered.\n+///\n+    template <typename R, typename Pred>\n+    BOOST_CXX14_CONSTEXPR typename boost::lazy_disable_if_c< boost::is_same<R, Pred>::value, boost::mpl::identity<bool> >::type\n+    is_sorted ( const R &range, Pred p )\n+    {\n+        return boost::algorithm::is_sorted ( boost::begin ( range ), boost::end ( range ), p );\n+    }\n+\n+\n+/// \\fn is_sorted ( const R &range )\n+/// \\return whether or not the entire range R is sorted\n+/// \n+/// \\param range The range to be tested.\n+///\n+    template <typename R>\n+    BOOST_CXX14_CONSTEXPR bool is_sorted ( const R &range )\n+    {\n+        return boost::algorithm::is_sorted ( boost::begin ( range ), boost::end ( range ));\n+    }\n+\n+\n+///\n+/// -- Range based versions of the C++11 functions\n+///\n+\n+/// \\fn is_increasing ( ForwardIterator first, ForwardIterator last )\n+/// \\return true if the entire sequence is increasing; i.e, each item is greater than or  \n+///     equal to the previous one.\n+/// \n+/// \\param first The start of the sequence to be tested.\n+/// \\param last  One past the end of the sequence\n+///\n+/// \\note This function will return true for sequences that contain items that compare\n+///     equal. If that is not what you intended, you should use is_strictly_increasing instead.\n+    template <typename ForwardIterator>\n+    BOOST_CXX14_CONSTEXPR bool is_increasing ( ForwardIterator first, ForwardIterator last )\n+    {\n+        typedef typename std::iterator_traits<ForwardIterator>::value_type value_type;\n+        return boost::algorithm::is_sorted (first, last, std::less<value_type>());\n+    }\n+\n+\n+/// \\fn is_increasing ( const R &range )\n+/// \\return true if the entire sequence is increasing; i.e, each item is greater than or  \n+///     equal to the previous one.\n+/// \n+/// \\param range The range to be tested.\n+///\n+/// \\note This function will return true for sequences that contain items that compare\n+///     equal. If that is not what you intended, you should use is_strictly_increasing instead.\n+    template <typename R>\n+    BOOST_CXX14_CONSTEXPR bool is_increasing ( const R &range )\n+    {\n+        return is_increasing ( boost::begin ( range ), boost::end ( range ));\n+    }\n+\n+\n+\n+/// \\fn is_decreasing ( ForwardIterator first, ForwardIterator last )\n+/// \\return true if the entire sequence is decreasing; i.e, each item is less than \n+///     or equal to the previous one.\n+/// \n+/// \\param first The start of the sequence to be tested.\n+/// \\param last  One past the end of the sequence\n+///\n+/// \\note This function will return true for sequences that contain items that compare\n+///     equal. If that is not what you intended, you should use is_strictly_decreasing instead.\n+    template <typename ForwardIterator>\n+    BOOST_CXX14_CONSTEXPR bool is_decreasing ( ForwardIterator first, ForwardIterator last )\n+    {\n+        typedef typename std::iterator_traits<ForwardIterator>::value_type value_type;\n+        return boost::algorithm::is_sorted (first, last, std::greater<value_type>());\n+    }\n+\n+/// \\fn is_decreasing ( const R &range )\n+/// \\return true if the entire sequence is decreasing; i.e, each item is less than \n+///     or equal to the previous one.\n+/// \n+/// \\param range The range to be tested.\n+///\n+/// \\note This function will return true for sequences that contain items that compare\n+///     equal. If that is not what you intended, you should use is_strictly_decreasing instead.\n+    template <typename R>\n+    BOOST_CXX14_CONSTEXPR bool is_decreasing ( const R &range )\n+    {\n+        return is_decreasing ( boost::begin ( range ), boost::end ( range ));\n+    }\n+\n+\n+\n+/// \\fn is_strictly_increasing ( ForwardIterator first, ForwardIterator last )\n+/// \\return true if the entire sequence is strictly increasing; i.e, each item is greater\n+///     than the previous one\n+/// \n+/// \\param first The start of the sequence to be tested.\n+/// \\param last  One past the end of the sequence\n+///\n+/// \\note This function will return false for sequences that contain items that compare\n+///     equal. If that is not what you intended, you should use is_increasing instead.\n+    template <typename ForwardIterator>\n+    BOOST_CXX14_CONSTEXPR bool is_strictly_increasing ( ForwardIterator first, ForwardIterator last )\n+    {\n+        typedef typename std::iterator_traits<ForwardIterator>::value_type value_type;\n+        return boost::algorithm::is_sorted (first, last, std::less_equal<value_type>());\n+    }\n+\n+/// \\fn is_strictly_increasing ( const R &range )\n+/// \\return true if the entire sequence is strictly increasing; i.e, each item is greater\n+///     than the previous one\n+/// \n+/// \\param range The range to be tested.\n+///\n+/// \\note This function will return false for sequences that contain items that compare\n+///     equal. If that is not what you intended, you should use is_increasing instead.\n+    template <typename R>\n+    BOOST_CXX14_CONSTEXPR bool is_strictly_increasing ( const R &range )\n+    {\n+        return is_strictly_increasing ( boost::begin ( range ), boost::end ( range ));\n+    }\n+\n+\n+/// \\fn is_strictly_decreasing ( ForwardIterator first, ForwardIterator last )\n+/// \\return true if the entire sequence is strictly decreasing; i.e, each item is less than\n+///     the previous one\n+/// \n+/// \\param first The start of the sequence to be tested.\n+/// \\param last  One past the end of the sequence\n+///\n+/// \\note This function will return false for sequences that contain items that compare\n+///     equal. If that is not what you intended, you should use is_decreasing instead.\n+    template <typename ForwardIterator>\n+    BOOST_CXX14_CONSTEXPR bool is_strictly_decreasing ( ForwardIterator first, ForwardIterator last )\n+    {\n+        typedef typename std::iterator_traits<ForwardIterator>::value_type value_type;\n+        return boost::algorithm::is_sorted (first, last, std::greater_equal<value_type>());\n+    }\n+\n+/// \\fn is_strictly_decreasing ( const R &range )\n+/// \\return true if the entire sequence is strictly decreasing; i.e, each item is less than\n+///     the previous one\n+/// \n+/// \\param range The range to be tested.\n+///\n+/// \\note This function will return false for sequences that contain items that compare\n+///     equal. If that is not what you intended, you should use is_decreasing instead.\n+    template <typename R>\n+    BOOST_CXX14_CONSTEXPR bool is_strictly_decreasing ( const R &range )\n+    {\n+        return is_strictly_decreasing ( boost::begin ( range ), boost::end ( range ));\n+    }\n+\n+}} // namespace boost\n+\n+#endif  // BOOST_ALGORITHM_ORDERED_HPP"
      },
      {
        "sha": "715c9ab01ec0e356f8ba45b4542892289bb05173",
        "filename": "src/boost/algorithm/cxx11/none_of.hpp",
        "status": "added",
        "additions": 83,
        "deletions": 0,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/none_of.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/none_of.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx11/none_of.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,83 @@\n+/* \n+   Copyright (c) Marshall Clow 2008-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file  none_of.hpp\n+/// \\brief Test ranges to see if no elements match a value or predicate.\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_NONE_OF_HPP\n+#define BOOST_ALGORITHM_NONE_OF_HPP\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+/// \\fn none_of ( InputIterator first, InputIterator last, Predicate p )\n+/// \\return true if none of the elements in [first, last) satisfy the predicate 'p'\n+/// \\note returns true on an empty range\n+/// \n+/// \\param first The start of the input sequence\n+/// \\param last  One past the end of the input sequence\n+/// \\param p     A predicate for testing the elements of the sequence\n+///\n+template<typename InputIterator, typename Predicate> \n+BOOST_CXX14_CONSTEXPR bool none_of ( InputIterator first, InputIterator last, Predicate p )\n+{\n+    for ( ; first != last; ++first )\n+        if ( p(*first)) \n+            return false;\n+    return true;\n+} \n+\n+/// \\fn none_of ( const Range &r, Predicate p )\n+/// \\return true if none of the elements in the range satisfy the predicate 'p'\n+/// \\note returns true on an empty range\n+/// \n+/// \\param r     The input range\n+/// \\param p     A predicate for testing the elements of the range\n+///\n+template<typename Range, typename Predicate> \n+BOOST_CXX14_CONSTEXPR bool none_of ( const Range &r, Predicate p )\n+{\n+    return boost::algorithm::none_of (boost::begin (r), boost::end (r), p );\n+} \n+\n+/// \\fn none_of_equal ( InputIterator first, InputIterator last, const V &val )\n+/// \\return true if none of the elements in [first, last) are equal to 'val'\n+/// \\note returns true on an empty range\n+/// \n+/// \\param first The start of the input sequence\n+/// \\param last  One past the end of the input sequence\n+/// \\param val   A value to compare against\n+///\n+template<typename InputIterator, typename V> \n+BOOST_CXX14_CONSTEXPR bool none_of_equal ( InputIterator first, InputIterator last, const V &val ) \n+{\n+    for ( ; first != last; ++first )\n+        if ( val == *first )\n+            return false;\n+    return true; \n+} \n+\n+/// \\fn none_of_equal ( const Range &r, const V &val )\n+/// \\return true if none of the elements in the range are equal to 'val'\n+/// \\note returns true on an empty range\n+/// \n+/// \\param r     The input range\n+/// \\param val   A value to compare against\n+///\n+template<typename Range, typename V> \n+BOOST_CXX14_CONSTEXPR bool none_of_equal ( const Range &r, const V & val ) \n+{\n+    return boost::algorithm::none_of_equal (boost::begin (r), boost::end (r), val);\n+} \n+\n+}} // namespace boost and algorithm\n+\n+#endif // BOOST_ALGORITHM_NONE_OF_HPP"
      },
      {
        "sha": "52f77b675999d40f43848e70f63c3027513d5682",
        "filename": "src/boost/algorithm/cxx11/one_of.hpp",
        "status": "added",
        "additions": 91,
        "deletions": 0,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/one_of.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/one_of.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx11/one_of.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,91 @@\n+/* \n+   Copyright (c) Marshall Clow 2008-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file one_of.hpp\n+/// \\brief Test ranges to see if only one element matches a value or predicate.\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_ONE_OF_HPP\n+#define BOOST_ALGORITHM_ONE_OF_HPP\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+\n+#include <boost/algorithm/cxx11/none_of.hpp>\n+\n+\n+namespace boost { namespace algorithm {\n+\n+/// \\fn one_of ( InputIterator first, InputIterator last, Predicate p )\n+/// \\return true if the predicate 'p' is true for exactly one item in [first, last).\n+/// \n+/// \\param first The start of the input sequence\n+/// \\param last  One past the end of the input sequence\n+/// \\param p     A predicate for testing the elements of the sequence\n+///\n+template<typename InputIterator, typename Predicate> \n+BOOST_CXX14_CONSTEXPR bool one_of ( InputIterator first, InputIterator last, Predicate p )\n+{\n+//  find_if\n+    for (; first != last; ++first)\n+        if (p(*first))\n+            break;\n+\n+    if (first == last)\n+        return false;    // Didn't occur at all\n+    return boost::algorithm::none_of (++first, last, p);\n+}\n+\n+/// \\fn one_of ( const Range &r, Predicate p )\n+/// \\return true if the predicate 'p' is true for exactly one item in the range.\n+/// \n+/// \\param r    The input range\n+/// \\param p    A predicate for testing the elements of the range\n+///\n+template<typename Range, typename Predicate> \n+BOOST_CXX14_CONSTEXPR bool one_of ( const Range &r, Predicate p )\n+{\n+    return boost::algorithm::one_of ( boost::begin (r), boost::end (r), p );\n+}\n+\n+\n+/// \\fn one_of_equal ( InputIterator first, InputIterator last, const V &val )\n+/// \\return true if the value 'val' exists only once in [first, last).\n+/// \n+/// \\param first    The start of the input sequence\n+/// \\param last     One past the end of the input sequence\n+/// \\param val      A value to compare against\n+///\n+template<typename InputIterator, typename V> \n+BOOST_CXX14_CONSTEXPR bool one_of_equal ( InputIterator first, InputIterator last, const V &val )\n+{\n+//  find\n+    for (; first != last; ++first)\n+        if (*first == val)\n+            break;\n+\n+    if (first == last)\n+        return false;                    // Didn't occur at all\n+    return boost::algorithm::none_of_equal (++first, last, val);\n+}\n+\n+/// \\fn one_of_equal ( const Range &r, const V &val )\n+/// \\return true if the value 'val' exists only once in the range.\n+/// \n+/// \\param r    The input range\n+/// \\param val  A value to compare against\n+///\n+template<typename Range, typename V> \n+BOOST_CXX14_CONSTEXPR bool one_of_equal ( const Range &r, const V &val )\n+{\n+    return boost::algorithm::one_of_equal ( boost::begin (r), boost::end (r), val );\n+} \n+\n+}} // namespace boost and algorithm\n+\n+#endif // BOOST_ALGORITHM_ALL_HPP"
      },
      {
        "sha": "635b1e7390e4f891a3a985fd12909e5bfd1829a9",
        "filename": "src/boost/algorithm/cxx11/partition_copy.hpp",
        "status": "added",
        "additions": 71,
        "deletions": 0,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/partition_copy.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/partition_copy.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx11/partition_copy.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,71 @@\n+/* \n+   Copyright (c) Marshall Clow 2011-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file  partition_copy.hpp\n+/// \\brief Copy a subset of a sequence to a new sequence\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_PARTITION_COPY_HPP\n+#define BOOST_ALGORITHM_PARTITION_COPY_HPP\n+\n+#include <utility>  // for std::pair\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+/// \\fn partition_copy ( InputIterator first, InputIterator last,\n+///     OutputIterator1 out_true, OutputIterator2 out_false, UnaryPredicate p )\n+/// \\brief Copies the elements that satisfy the predicate p from the range [first, last) \n+///     to the range beginning at d_first_true, and\n+///     copies the elements that do not satisfy p to the range beginning at d_first_false.\n+///\n+/// \n+/// \\param first     The start of the input sequence\n+/// \\param last      One past the end of the input sequence\n+/// \\param out_true  An output iterator to write the elements that satisfy the predicate into\n+/// \\param out_false An output iterator to write the elements that do not satisfy the predicate into\n+/// \\param p         A predicate for dividing the elements of the input sequence.\n+///\n+/// \\note            This function is part of the C++2011 standard library.\n+template <typename InputIterator, \n+        typename OutputIterator1, typename OutputIterator2, typename UnaryPredicate>\n+BOOST_CXX14_CONSTEXPR std::pair<OutputIterator1, OutputIterator2>\n+partition_copy ( InputIterator first, InputIterator last,\n+        OutputIterator1 out_true, OutputIterator2 out_false, UnaryPredicate p )\n+{\n+    for ( ; first != last; ++first )\n+        if ( p (*first))\n+            *out_true++ = *first;\n+        else\n+            *out_false++ = *first;\n+    return std::pair<OutputIterator1, OutputIterator2> ( out_true, out_false );\n+}\n+\n+/// \\fn partition_copy ( const Range &r, \n+///     OutputIterator1 out_true, OutputIterator2 out_false, UnaryPredicate p )\n+/// \n+/// \\param r         The input range\n+/// \\param out_true  An output iterator to write the elements that satisfy the predicate into\n+/// \\param out_false An output iterator to write the elements that do not satisfy the predicate into\n+/// \\param p         A predicate for dividing the elements of the input sequence.\n+///\n+template <typename Range, typename OutputIterator1, typename OutputIterator2, \n+            typename UnaryPredicate>\n+BOOST_CXX14_CONSTEXPR std::pair<OutputIterator1, OutputIterator2>\n+partition_copy ( const Range &r, OutputIterator1 out_true, OutputIterator2 out_false, \n+                                UnaryPredicate p )\n+{\n+    return boost::algorithm::partition_copy \n+                      (boost::begin(r), boost::end(r), out_true, out_false, p );\n+}\n+\n+}} // namespace boost and algorithm\n+\n+#endif  // BOOST_ALGORITHM_PARTITION_COPY_HPP"
      },
      {
        "sha": "aa184acbf41e7abdbedae7d056a5949b65f9f4eb",
        "filename": "src/boost/algorithm/cxx11/partition_point.hpp",
        "status": "added",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/partition_point.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx11/partition_point.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx11/partition_point.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,66 @@\n+/* \n+   Copyright (c) Marshall Clow 2011-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file  partition_point.hpp\n+/// \\brief Find the partition point in a sequence\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_PARTITION_POINT_HPP\n+#define BOOST_ALGORITHM_PARTITION_POINT_HPP\n+\n+#include <iterator>    // for std::distance, advance\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+/// \\fn partition_point ( ForwardIterator first, ForwardIterator last, Predicate p )\n+/// \\brief Given a partitioned range, returns the partition point, i.e, the first element \n+///     that does not satisfy p\n+/// \n+/// \\param first    The start of the input sequence\n+/// \\param last     One past the end of the input sequence\n+/// \\param p        The predicate to test the values with\n+/// \\note           This function is part of the C++2011 standard library.\n+template <typename ForwardIterator, typename Predicate>\n+ForwardIterator partition_point ( ForwardIterator first, ForwardIterator last, Predicate p )\n+{\n+    std::size_t dist = std::distance ( first, last );\n+    while ( first != last ) {\n+        std::size_t d2 = dist / 2;\n+        ForwardIterator ret_val = first;\n+        std::advance (ret_val, d2);\n+        if (p (*ret_val)) {\n+            first = ++ret_val;\n+            dist -= d2 + 1;\n+            }\n+        else {\n+            last = ret_val;\n+            dist = d2;\n+            }\n+        }\n+    return first;\n+}\n+\n+/// \\fn partition_point ( Range &r, Predicate p )\n+/// \\brief Given a partitioned range, returns the partition point\n+/// \n+/// \\param r        The input range\n+/// \\param p        The predicate to test the values with\n+///\n+template <typename Range, typename Predicate>\n+typename boost::range_iterator<Range>::type partition_point ( Range &r, Predicate p )\n+{\n+    return boost::algorithm::partition_point (boost::begin(r), boost::end(r), p);\n+}\n+\n+\n+}}\n+\n+#endif  // BOOST_ALGORITHM_PARTITION_POINT_HPP"
      },
      {
        "sha": "a1501baf9a41b7892c25ef616756dcd3dcca87a4",
        "filename": "src/boost/algorithm/cxx14/equal.hpp",
        "status": "added",
        "additions": 106,
        "deletions": 0,
        "changes": 106,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx14/equal.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx14/equal.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx14/equal.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,106 @@\n+/* \n+   Copyright (c) Marshall Clow 2008-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file  equal.hpp\n+/// \\brief Test ranges to if they are equal\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_EQUAL_HPP\n+#define BOOST_ALGORITHM_EQUAL_HPP\n+\n+#include <iterator>\n+\n+#include <boost/config.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+namespace detail {\n+\n+    template <class T1, class T2>\n+    struct eq {\n+        BOOST_CONSTEXPR bool operator () ( const T1& v1, const T2& v2 ) const { return v1 == v2 ;}\n+        };\n+    \n+    template <class RandomAccessIterator1, class RandomAccessIterator2, class BinaryPredicate>\n+    BOOST_CXX14_CONSTEXPR\n+    bool equal ( RandomAccessIterator1 first1, RandomAccessIterator1 last1, \n+                 RandomAccessIterator2 first2, RandomAccessIterator2 last2, BinaryPredicate pred,\n+                 std::random_access_iterator_tag, std::random_access_iterator_tag )\n+    {\n+    //  Random-access iterators let is check the sizes in constant time\n+        if ( std::distance ( first1, last1 ) != std::distance ( first2, last2 ))\n+            return false;\n+\n+    //  std::equal\n+        for (; first1 != last1; ++first1, ++first2)\n+            if (!pred(*first1, *first2))\n+                return false;\n+        return true;\n+    }\n+\n+    template <class InputIterator1, class InputIterator2, class BinaryPredicate>\n+    BOOST_CXX14_CONSTEXPR\n+    bool equal ( InputIterator1 first1, InputIterator1 last1, \n+                 InputIterator2 first2, InputIterator2 last2, BinaryPredicate pred,\n+                 std::input_iterator_tag, std::input_iterator_tag )\n+    {\n+    for (; first1 != last1 && first2 != last2; ++first1, ++first2 )\n+        if ( !pred(*first1, *first2 ))\n+            return false;\n+\n+    return first1 == last1 && first2 == last2;\n+    }\n+}\n+\n+/// \\fn equal ( InputIterator1 first1, InputIterator1 last1, \n+///             InputIterator2 first2, InputIterator2 last2,\n+///             BinaryPredicate pred )\n+/// \\return true if all elements in the two ranges are equal\n+/// \n+/// \\param first1    The start of the first range.\n+/// \\param last1     One past the end of the first range.\n+/// \\param first2    The start of the second range.\n+/// \\param last2     One past the end of the second range.\n+/// \\param pred      A predicate for comparing the elements of the ranges\n+template <class InputIterator1, class InputIterator2, class BinaryPredicate>\n+BOOST_CXX14_CONSTEXPR\n+bool equal ( InputIterator1 first1, InputIterator1 last1, \n+             InputIterator2 first2, InputIterator2 last2, BinaryPredicate pred )\n+{\n+    return boost::algorithm::detail::equal ( \n+        first1, last1, first2, last2, pred,\n+        typename std::iterator_traits<InputIterator1>::iterator_category (),\n+        typename std::iterator_traits<InputIterator2>::iterator_category ());\n+}\n+\n+/// \\fn equal ( InputIterator1 first1, InputIterator1 last1, \n+///             InputIterator2 first2, InputIterator2 last2 )\n+/// \\return true if all elements in the two ranges are equal\n+/// \n+/// \\param first1    The start of the first range.\n+/// \\param last1     One past the end of the first range.\n+/// \\param first2    The start of the second range.\n+/// \\param last2     One past the end of the second range.\n+template <class InputIterator1, class InputIterator2>\n+BOOST_CXX14_CONSTEXPR\n+bool equal ( InputIterator1 first1, InputIterator1 last1, \n+             InputIterator2 first2, InputIterator2 last2 )\n+{\n+    return boost::algorithm::detail::equal (\n+        first1, last1, first2, last2,\n+        boost::algorithm::detail::eq<\n+            typename std::iterator_traits<InputIterator1>::value_type,\n+            typename std::iterator_traits<InputIterator2>::value_type> (),\n+        typename std::iterator_traits<InputIterator1>::iterator_category (),\n+        typename std::iterator_traits<InputIterator2>::iterator_category ());\n+}\n+\n+//  There are already range-based versions of these.\n+\n+}} // namespace boost and algorithm\n+\n+#endif // BOOST_ALGORITHM_EQUAL_HPP"
      },
      {
        "sha": "e889347db0974d6d1a677cabd33e8b48e3cf10f0",
        "filename": "src/boost/algorithm/cxx14/is_permutation.hpp",
        "status": "added",
        "additions": 80,
        "deletions": 0,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx14/is_permutation.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx14/is_permutation.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx14/is_permutation.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,80 @@\n+/*\n+   Copyright (c) Marshall Clow 2014.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file  is_permutation.hpp\n+/// \\brief Is a sequence a permutation of another sequence (four iterator versions)\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_IS_PERMUTATION14_HPP\n+#define BOOST_ALGORITHM_IS_PERMUTATION14_HPP\n+\n+#include <utility>      // for std::pair\n+#include <functional>   // for std::equal_to\n+#include <iterator>\n+\n+#include <boost/config.hpp>\n+#include <boost/algorithm/cxx11/is_permutation.hpp>\n+#include <boost/algorithm/cxx14/mismatch.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+/// \\fn is_permutation ( ForwardIterator1 first, ForwardIterator1 last, \n+///                      ForwardIterator2 first2, ForwardIterator2 last2 )\n+/// \\brief Tests to see if the sequence [first,last) is a permutation of the sequence starting at first2\n+///\n+/// \\param first1   The start of the input sequence\n+/// \\param last2    One past the end of the input sequence\n+/// \\param first2   The start of the second sequence\n+/// \\param last1    One past the end of the second sequence\n+/// \\note           This function is part of the C++2014 standard library.\n+template< class ForwardIterator1, class ForwardIterator2 >\n+bool is_permutation ( ForwardIterator1 first1, ForwardIterator1 last1, \n+                      ForwardIterator2 first2, ForwardIterator2 last2 )\n+{\n+//  How should I deal with the idea that ForwardIterator1::value_type\n+//  and ForwardIterator2::value_type could be different? Define my own comparison predicate?\n+    std::pair<ForwardIterator1, ForwardIterator2> eq = boost::algorithm::mismatch\n+        ( first1, last1, first2, last2 );\n+    if ( eq.first == last1 && eq.second == last2)\n+        return true;\n+    return boost::algorithm::detail::is_permutation_tag (\n+        eq.first, last1, eq.second, last2, \n+        std::equal_to<typename std::iterator_traits<ForwardIterator1>::value_type> (),\n+        typename std::iterator_traits<ForwardIterator1>::iterator_category (),\n+        typename std::iterator_traits<ForwardIterator2>::iterator_category ());\n+}\n+\n+/// \\fn is_permutation ( ForwardIterator1 first, ForwardIterator1 last, \n+///                      ForwardIterator2 first2, ForwardIterator2 last2, \n+///                      BinaryPredicate p )\n+/// \\brief Tests to see if the sequence [first,last) is a permutation of the sequence starting at first2\n+///\n+/// \\param first1   The start of the input sequence\n+/// \\param last1    One past the end of the input sequence\n+/// \\param first2   The start of the second sequence\n+/// \\param last2    One past the end of the second sequence\n+/// \\param pred     The predicate to compare elements with\n+///\n+/// \\note           This function is part of the C++2014 standard library.\n+template< class ForwardIterator1, class ForwardIterator2, class BinaryPredicate >\n+bool is_permutation ( ForwardIterator1 first1, ForwardIterator1 last1,\n+                      ForwardIterator2 first2, ForwardIterator2 last2, \n+                      BinaryPredicate pred )\n+{\n+    std::pair<ForwardIterator1, ForwardIterator2> eq = boost::algorithm::mismatch\n+        ( first1, last1, first2, last2, pred );\n+    if ( eq.first == last1 && eq.second == last2)\n+        return true;\n+    return boost::algorithm::detail::is_permutation_tag (\n+        first1, last1, first2, last2, pred, \n+        typename std::iterator_traits<ForwardIterator1>::iterator_category (),\n+        typename std::iterator_traits<ForwardIterator2>::iterator_category ());\n+}\n+\n+}}\n+\n+#endif  // BOOST_ALGORITHM_IS_PERMUTATION14_HPP"
      },
      {
        "sha": "a1fafe80dfac1b1417f97892581f03719903dc80",
        "filename": "src/boost/algorithm/cxx14/mismatch.hpp",
        "status": "added",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx14/mismatch.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx14/mismatch.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx14/mismatch.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,66 @@\n+/* \n+   Copyright (c) Marshall Clow 2008-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file  mismatch.hpp\n+/// \\brief Find the first mismatched element in a sequence\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_MISMATCH_HPP\n+#define BOOST_ALGORITHM_MISMATCH_HPP\n+\n+#include <utility>      // for std::pair\n+\n+#include <boost/config.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+/// \\fn mismatch ( InputIterator1 first1, InputIterator1 last1, \n+///                InputIterator2 first2, InputIterator2 last2,\n+///                BinaryPredicate pred )\n+/// \\return a pair of iterators pointing to the first elements in the sequence that do not match\n+/// \n+/// \\param first1    The start of the first range.\n+/// \\param last1     One past the end of the first range.\n+/// \\param first2    The start of the second range.\n+/// \\param last2     One past the end of the second range.\n+/// \\param pred      A predicate for comparing the elements of the ranges\n+template <class InputIterator1, class InputIterator2, class BinaryPredicate>\n+BOOST_CXX14_CONSTEXPR std::pair<InputIterator1, InputIterator2> mismatch (\n+                    InputIterator1 first1, InputIterator1 last1,\n+                    InputIterator2 first2, InputIterator2 last2,\n+                    BinaryPredicate pred )\n+{\n+    for (; first1 != last1 && first2 != last2; ++first1, ++first2)\n+        if ( !pred ( *first1, *first2 ))\n+            break;\n+    return std::pair<InputIterator1, InputIterator2>(first1, first2);\n+}\n+\n+/// \\fn mismatch ( InputIterator1 first1, InputIterator1 last1, \n+///                InputIterator2 first2, InputIterator2 last2 )\n+/// \\return a pair of iterators pointing to the first elements in the sequence that do not match\n+/// \n+/// \\param first1    The start of the first range.\n+/// \\param last1     One past the end of the first range.\n+/// \\param first2    The start of the second range.\n+/// \\param last2     One past the end of the second range.\n+template <class InputIterator1, class InputIterator2>\n+BOOST_CXX14_CONSTEXPR std::pair<InputIterator1, InputIterator2> mismatch (\n+                    InputIterator1 first1, InputIterator1 last1,\n+                    InputIterator2 first2, InputIterator2 last2 )\n+{\n+    for (; first1 != last1 && first2 != last2; ++first1, ++first2)\n+        if ( *first1 != *first2 )\n+            break;\n+    return std::pair<InputIterator1, InputIterator2>(first1, first2);\n+}\n+\n+//  There are already range-based versions of these.\n+\n+}} // namespace boost and algorithm\n+\n+#endif // BOOST_ALGORITHM_MISMATCH_HPP"
      },
      {
        "sha": "9dbfbe966e2fc36b3a231716537fc92e2e43971f",
        "filename": "src/boost/algorithm/cxx17/exclusive_scan.hpp",
        "status": "added",
        "additions": 53,
        "deletions": 0,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx17/exclusive_scan.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx17/exclusive_scan.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx17/exclusive_scan.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,53 @@\n+/*\n+   Copyright (c) Marshall Clow 2017.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file  exclusive_scan.hpp\n+/// \\brief ???\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_EXCLUSIVE_SCAN_HPP\n+#define BOOST_ALGORITHM_EXCLUSIVE_SCAN_HPP\n+\n+#include <functional>     // for std::plus\n+#include <iterator>       // for std::iterator_traits\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+#include <boost/range/value_type.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+template<class InputIterator, class OutputIterator, class T, class BinaryOperation>\n+OutputIterator exclusive_scan(InputIterator first, InputIterator last,\n+                              OutputIterator result, T init, BinaryOperation bOp)\n+{\n+    if (first != last)\n+    {\n+        T saved = init;\n+        do\n+        {\n+            init = bOp(init, *first);\n+            *result = saved;\n+            saved = init;\n+            ++result;\n+        } while (++first != last);\n+    }\n+    return result;\n+}\n+\n+template<class InputIterator, class OutputIterator, class T>\n+OutputIterator exclusive_scan(InputIterator first, InputIterator last,\n+                              OutputIterator result, T init)\n+{\n+\ttypedef typename std::iterator_traits<InputIterator>::value_type VT;\n+    return boost::algorithm::exclusive_scan(first, last, result, init, std::plus<VT>());\n+}\n+\n+}} // namespace boost and algorithm\n+\n+#endif // BOOST_ALGORITHM_EXCLUSIVE_SCAN_HPP"
      },
      {
        "sha": "59abb448d7c64fbc2e5f07dca7cd8388c480933b",
        "filename": "src/boost/algorithm/cxx17/for_each_n.hpp",
        "status": "added",
        "additions": 39,
        "deletions": 0,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx17/for_each_n.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx17/for_each_n.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx17/for_each_n.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,39 @@\n+/*\n+   Copyright (c) Marshall Clow 2017.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file  for_each_n.hpp\n+/// \\brief Apply a functor to the elements of a sequence\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_FOR_EACH_N_HPP\n+#define BOOST_ALGORITHM_FOR_EACH_N_HPP\n+\n+#include <utility>      // for std::pair\n+\n+#include <boost/config.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+/// \\fn for_each_n(InputIterator first, Size n, Function f);\n+/// \\return first + n\n+///\n+/// \\param first    The start of the first range.\n+/// \\param n        One past the end of the first range.\n+/// \\param f        A functor to apply to the elements of the sequence\n+/// \\note           If f returns a result, the result is ignored.\n+template<class InputIterator, class Size, class Function>\n+InputIterator for_each_n(InputIterator first, Size n, Function f)\n+{\n+    for ( ; n > 0; --n, ++first )\n+        f(*first);\n+\n+    return first;\n+}\n+\n+}} // namespace boost and algorithm\n+\n+#endif // BOOST_ALGORITHM_FOR_EACH_N_HPP"
      },
      {
        "sha": "fcc9bc2dae66b6bcd0f8d452f7c054c4cc7e2127",
        "filename": "src/boost/algorithm/cxx17/inclusive_scan.hpp",
        "status": "added",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx17/inclusive_scan.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx17/inclusive_scan.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx17/inclusive_scan.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,61 @@\n+/*\n+   Copyright (c) Marshall Clow 2017.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file  transform_reduce.hpp\n+/// \\brief Combine the (transformed) elements of a sequence (or two) into a single value.\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_INCLUSIVE_SCAN_HPP\n+#define BOOST_ALGORITHM_INCLUSIVE_SCAN_HPP\n+\n+#include <functional>     // for std::plus\n+#include <iterator>       // for std::iterator_traits\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+#include <boost/range/value_type.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+template<class InputIterator, class OutputIterator, class T, class BinaryOperation>\n+OutputIterator inclusive_scan(InputIterator first, InputIterator last,\n+                              OutputIterator result, BinaryOperation bOp, T init)\n+{\n+    for (; first != last; ++first, (void) ++result) {\n+        init = bOp(init, *first);\n+        *result = init;\n+        }\n+    return result;\n+}\n+\n+\n+template<class InputIterator, class OutputIterator, class BinaryOperation>\n+OutputIterator inclusive_scan(InputIterator first, InputIterator last,\n+                              OutputIterator result, BinaryOperation bOp)\n+{\n+    if (first != last) {\n+        typename std::iterator_traits<InputIterator>::value_type init = *first;\n+        *result++ = init;\n+        if (++first != last)\n+            return boost::algorithm::inclusive_scan(first, last, result, bOp, init);\n+        }\n+\n+    return result;\n+}\n+\n+template<class InputIterator, class OutputIterator>\n+OutputIterator inclusive_scan(InputIterator first, InputIterator last,\n+                   OutputIterator result)\n+{\n+    typedef typename std::iterator_traits<InputIterator>::value_type VT;\n+    return boost::algorithm::inclusive_scan(first, last, result, std::plus<VT>());\n+}\n+\n+}} // namespace boost and algorithm\n+\n+#endif // BOOST_ALGORITHM_INCLUSIVE_SCAN_HPP"
      },
      {
        "sha": "35f217cf196a75d6ac6bc525cad97e39dd52f6c6",
        "filename": "src/boost/algorithm/cxx17/reduce.hpp",
        "status": "added",
        "additions": 73,
        "deletions": 0,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx17/reduce.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx17/reduce.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx17/reduce.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,73 @@\n+/*\n+   Copyright (c) Marshall Clow 2017.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file  reduce.hpp\n+/// \\brief Combine the elements of a sequence into a single value\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_REDUCE_HPP\n+#define BOOST_ALGORITHM_REDUCE_HPP\n+\n+#include <functional>     // for std::plus\n+#include <iterator>       // for std::iterator_traits\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+#include <boost/range/value_type.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+template<class InputIterator, class T, class BinaryOperation>\n+T reduce(InputIterator first, InputIterator last, T init, BinaryOperation bOp)\n+{\n+    ;\n+    for (; first != last; ++first)\n+        init = bOp(init, *first);\n+    return init;\n+}\n+\n+template<class InputIterator, class T>\n+T reduce(InputIterator first, InputIterator last, T init)\n+{\n+\ttypedef typename std::iterator_traits<InputIterator>::value_type VT;\n+    return boost::algorithm::reduce(first, last, init, std::plus<VT>());\n+}\n+\n+template<class InputIterator>\n+typename std::iterator_traits<InputIterator>::value_type\n+reduce(InputIterator first, InputIterator last)\n+{\n+    return boost::algorithm::reduce(first, last,\n+       typename std::iterator_traits<InputIterator>::value_type());\n+}\n+\n+template<class Range>\n+typename boost::range_value<Range>::type\n+reduce(const Range &r)\n+{\n+    return boost::algorithm::reduce(boost::begin(r), boost::end(r));\n+}\n+\n+//\tNot sure that this won't be ambiguous (1)\n+template<class Range, class T>\n+T reduce(const Range &r, T init)\n+{\n+    return boost::algorithm::reduce(boost::begin (r), boost::end (r), init);\n+}\n+\n+\n+//\tNot sure that this won't be ambiguous (2)\n+template<class Range, class T, class BinaryOperation>\n+T reduce(const Range &r, T init, BinaryOperation bOp)\n+{\n+    return boost::algorithm::reduce(boost::begin(r), boost::end(r), init, bOp);\n+}\n+\n+}} // namespace boost and algorithm\n+\n+#endif // BOOST_ALGORITHM_REDUCE_HPP"
      },
      {
        "sha": "68318a59a76124d315e083d3236c7a420ba6aaed",
        "filename": "src/boost/algorithm/cxx17/transform_exclusive_scan.hpp",
        "status": "added",
        "additions": 47,
        "deletions": 0,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx17/transform_exclusive_scan.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx17/transform_exclusive_scan.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx17/transform_exclusive_scan.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,47 @@\n+/*\n+   Copyright (c) Marshall Clow 2017.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file  transform_exclusive_scan.hpp\n+/// \\brief ????\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_TRANSFORM_EXCLUSIVE_SCAN_HPP\n+#define BOOST_ALGORITHM_TRANSFORM_EXCLUSIVE_SCAN_HPP\n+\n+#include <functional>     // for std::plus\n+#include <iterator>       // for std::iterator_traits\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+#include <boost/range/value_type.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+template<class InputIterator, class OutputIterator, class T,\n+         class BinaryOperation, class UnaryOperation>\n+OutputIterator transform_exclusive_scan(InputIterator first, InputIterator last,\n+                                        OutputIterator result, T init,\n+                                        BinaryOperation bOp, UnaryOperation uOp)\n+{\n+    if (first != last)\n+    {\n+        T saved = init;\n+        do\n+        {\n+            init = bOp(init, uOp(*first));\n+            *result = saved;\n+            saved = init;\n+            ++result;\n+        } while (++first != last);\n+    }\n+    return result;\n+}\n+\n+}} // namespace boost and algorithm\n+\n+#endif // BOOST_ALGORITHM_TRANSFORM_EXCLUSIVE_SCAN_HPP"
      },
      {
        "sha": "31607703ed13078e95be72ce741d3e1646cb6fb0",
        "filename": "src/boost/algorithm/cxx17/transform_inclusive_scan.hpp",
        "status": "added",
        "additions": 60,
        "deletions": 0,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx17/transform_inclusive_scan.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx17/transform_inclusive_scan.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx17/transform_inclusive_scan.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,60 @@\n+/*\n+   Copyright (c) Marshall Clow 2017.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file  transform_reduce.hpp\n+/// \\brief Combine the (transformed) elements of a sequence (or two) into a single value.\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_TRANSFORM_REDUCE_HPP\n+#define BOOST_ALGORITHM_TRANSFORM_REDUCE_HPP\n+\n+#include <functional>     // for std::plus\n+#include <iterator>       // for std::iterator_traits\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+#include <boost/range/value_type.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+template<class InputIterator, class OutputIterator,\n+         class BinaryOperation, class UnaryOperation, class T>\n+OutputIterator transform_inclusive_scan(InputIterator first, InputIterator last,\n+                                        OutputIterator result,\n+                                        BinaryOperation bOp, UnaryOperation uOp,\n+                                        T init)\n+{\n+    for (; first != last; ++first, (void) ++result) {\n+        init = bOp(init, uOp(*first));\n+        *result = init;\n+        }\n+\n+    return result;\n+}\n+\n+template<class InputIterator, class OutputIterator,\n+         class BinaryOperation, class UnaryOperation>\n+OutputIterator transform_inclusive_scan(InputIterator first, InputIterator last,\n+                                        OutputIterator result,\n+                                        BinaryOperation bOp, UnaryOperation uOp)\n+{\n+    if (first != last) {\n+        typename std::iterator_traits<InputIterator>::value_type init = uOp(*first);\n+        *result++ = init;\n+        if (++first != last)\n+            return boost::algorithm::transform_inclusive_scan\n+                                              (first, last, result, bOp, uOp, init);\n+        }\n+\n+    return result;\n+}\n+\n+\n+}} // namespace boost and algorithm\n+\n+#endif // BOOST_ALGORITHM_TRANSFORM_REDUCE_HPP"
      },
      {
        "sha": "1bef5d1ab0378c6ec60cff3a7c08dc96d925704a",
        "filename": "src/boost/algorithm/cxx17/transform_reduce.hpp",
        "status": "added",
        "additions": 56,
        "deletions": 0,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx17/transform_reduce.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/cxx17/transform_reduce.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/cxx17/transform_reduce.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,56 @@\n+/*\n+   Copyright (c) Marshall Clow 2017.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file  transform_reduce.hpp\n+/// \\brief Combine the (transformed) elements of a sequence (or two) into a single value.\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_TRANSFORM_REDUCE_HPP\n+#define BOOST_ALGORITHM_TRANSFORM_REDUCE_HPP\n+\n+#include <functional>     // for std::plus\n+#include <iterator>       // for std::iterator_traits\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+#include <boost/range/value_type.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+template<class InputIterator1, class InputIterator2, class T,\n+         class BinaryOperation1, class BinaryOperation2>\n+T transform_reduce(InputIterator1 first1, InputIterator1 last1,\n+                   InputIterator2 first2, T init,\n+                 BinaryOperation1 bOp1, BinaryOperation2 bOp2)\n+{\n+    for (; first1 != last1; ++first1, (void) ++first2)\n+        init = bOp1(init, bOp2(*first1, *first2));\n+    return init;\n+}\n+\n+template<class InputIterator, class T,\n+         class BinaryOperation, class UnaryOperation>\n+T transform_reduce(InputIterator first, InputIterator last,\n+                   T init, BinaryOperation bOp, UnaryOperation uOp)\n+{\n+    for (; first != last; ++first)\n+        init = bOp(init, uOp(*first));\n+    return init;\n+}\n+\n+template<class InputIterator1, class InputIterator2, class T>\n+T transform_reduce(InputIterator1 first1, InputIterator1 last1,\n+                   InputIterator2 first2, T init)\n+{\n+    return boost::algorithm::transform_reduce(first1, last1, first2, init,\n+                            std::plus<T>(), std::multiplies<T>());\n+}\n+\n+}} // namespace boost and algorithm\n+\n+#endif // BOOST_ALGORITHM_TRANSFORM_REDUCE_HPP"
      },
      {
        "sha": "5903203499d172f0f7883b3e5a7c381d058bb45f",
        "filename": "src/boost/algorithm/find_backward.hpp",
        "status": "added",
        "additions": 96,
        "deletions": 0,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/find_backward.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/find_backward.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/find_backward.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,96 @@\n+/*\n+   Copyright (c) T. Zachary Laine 2018.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+#ifndef BOOST_ALGORITHM_FIND_BACKWARD_HPP\n+#define BOOST_ALGORITHM_FIND_BACKWARD_HPP\n+\n+#include <utility>\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+template<typename BidiIter, typename T>\n+BOOST_CXX14_CONSTEXPR\n+BidiIter find_backward(BidiIter first, BidiIter last, const T & x)\n+{\n+    BidiIter it = last;\n+    while (it != first) {\n+        if (*--it == x)\n+            return it;\n+    }\n+    return last;\n+}\n+\n+template<typename Range, typename T>\n+BOOST_CXX14_CONSTEXPR\n+typename boost::range_iterator<Range>::type find_backward(Range & range, const T & x)\n+{\n+    return ::boost::algorithm::find_backward(boost::begin(range), boost::end(range), x);\n+}\n+\n+template<typename BidiIter, typename T>\n+BOOST_CXX14_CONSTEXPR\n+BidiIter find_not_backward(BidiIter first, BidiIter last, const T & x)\n+{\n+    BidiIter it = last;\n+    while (it != first) {\n+        if (*--it != x)\n+            return it;\n+    }\n+    return last;\n+}\n+\n+template<typename Range, typename T>\n+BOOST_CXX14_CONSTEXPR\n+typename boost::range_iterator<Range>::type find_not_backward(Range & range, const T & x)\n+{\n+    return ::boost::algorithm::find_not_backward(boost::begin(range), boost::end(range), x);\n+}\n+\n+template<typename BidiIter, typename Pred>\n+BOOST_CXX14_CONSTEXPR\n+BidiIter find_if_backward(BidiIter first, BidiIter last, Pred p)\n+{\n+    BidiIter it = last;\n+    while (it != first) {\n+        if (p(*--it))\n+            return it;\n+    }\n+    return last;\n+}\n+\n+template<typename Range, typename Pred>\n+BOOST_CXX14_CONSTEXPR\n+typename boost::range_iterator<Range>::type find_if_backward(Range & range, Pred p)\n+{\n+    return ::boost::algorithm::find_if_backward(boost::begin(range), boost::end(range), p);\n+}\n+\n+template<typename BidiIter, typename Pred>\n+BOOST_CXX14_CONSTEXPR\n+BidiIter find_if_not_backward(BidiIter first, BidiIter last, Pred p)\n+{\n+    BidiIter it = last;\n+    while (it != first) {\n+        if (!p(*--it))\n+            return it;\n+    }\n+    return last;\n+}\n+\n+template<typename Range, typename Pred>\n+BOOST_CXX14_CONSTEXPR\n+typename boost::range_iterator<Range>::type find_if_not_backward(Range & range, Pred p)\n+{\n+    return ::boost::algorithm::find_if_not_backward(boost::begin(range), boost::end(range), p);\n+}\n+\n+}} // namespace boost and algorithm\n+\n+#endif // BOOST_ALGORITHM_FIND_BACKWARD_HPP"
      },
      {
        "sha": "cc9dc214f2442696bfa30221b4f7f3c1a0515587",
        "filename": "src/boost/algorithm/find_not.hpp",
        "status": "added",
        "additions": 38,
        "deletions": 0,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/find_not.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/find_not.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/find_not.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,38 @@\n+/*\n+   Copyright (c) T. Zachary Laine 2018.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+#ifndef BOOST_ALGORITHM_FIND_NOT_HPP\n+#define BOOST_ALGORITHM_FIND_NOT_HPP\n+\n+#include <utility>\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+template<typename InputIter, typename Sentinel, typename T>        \n+BOOST_CXX14_CONSTEXPR\n+InputIter find_not(InputIter first, Sentinel last, const T & x)\n+{\n+    for (; first != last; ++first) {\n+        if (*first != x)\n+            break;\n+    }\n+    return first;\n+}\n+\n+template<typename Range, typename T>\n+BOOST_CXX14_CONSTEXPR\n+typename boost::range_iterator<Range>::type find_not(Range & r, const T & x)\n+{\n+    return ::boost::algorithm::find_not(boost::begin(r), boost::end(r), x);\n+}\n+\n+}} // namespace boost and algorithm\n+\n+#endif // BOOST_ALGORITHM_FIND_NOT_HPP"
      },
      {
        "sha": "e777f8bd162d4e7f95e1b2c5eadb18f7bff25e0f",
        "filename": "src/boost/algorithm/gather.hpp",
        "status": "added",
        "additions": 126,
        "deletions": 0,
        "changes": 126,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/gather.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/gather.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/gather.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,126 @@\n+/* \n+    Copyright 2008 Adobe Systems Incorporated\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+ Revision history:\n+   January 2008 mtc Version for Adobe Source Library\n+   January 2013 mtc Version for Boost.Algorithm\n+\n+*/\n+\n+/**************************************************************************************************/\n+\n+/*!\n+\\author Marshall Clow\n+\\date    January 2008\n+*/\n+\n+#ifndef BOOST_ALGORITHM_GATHER_HPP\n+#define BOOST_ALGORITHM_GATHER_HPP\n+\n+#include <algorithm>                // for std::stable_partition\n+#include <functional>\n+#include <utility>                  // for std::make_pair\n+\n+#include <boost/config.hpp>\n+#include <boost/bind/bind.hpp>      // for boost::bind\n+#include <boost/range/begin.hpp>    // for boost::begin(range)\n+#include <boost/range/end.hpp>      // for boost::end(range)\n+\n+\n+/**************************************************************************************************/\n+/*!\n+    \\defgroup gather gather\n+    \\ingroup mutating_algorithm\n+\n+    \\c gather() takes a collection of elements defined by a pair of iterators and moves\n+    the ones satisfying a predicate to them to a position (called the pivot) within\n+    the sequence. The algorithm is stable. The result is a pair of iterators that\n+    contains the items that satisfy the predicate.\n+\n+    Given an sequence containing:\n+    <pre>\n+    0 1 2 3 4 5 6 7 8 9\n+    </pre>\n+\n+    a call to gather ( arr, arr + 10, arr + 4, IsEven ()) will result in:\n+\n+    <pre>\n+    1 3 0 2 4 6 8 5 7 9\n+        |---|-----|\n+      first |  second\n+          pivot\n+    </pre>\n+\n+\n+    The problem is broken down into two basic steps, namely, moving the items before the pivot\n+    and then moving the items from the pivot to the end. These \"moves\" are done with calls to\n+    stable_partition.\n+\n+    \\par Storage Requirements:\n+\n+    The algorithm uses stable_partition, which will attempt to allocate temporary memory,\n+    but will work in-situ if there is none available.\n+\n+    \\par Time Complexity:\n+\n+    If there is sufficient memory available, the run time is linear in <code>N</code>.\n+    If there is not any memory available, then the run time is <code>O(N log N)</code>.\n+*/\n+\n+/**************************************************************************************************/\n+\n+namespace boost { namespace algorithm {\n+\n+/**************************************************************************************************/\n+\n+/*!\n+    \\ingroup gather\n+    \\brief iterator-based gather implementation\n+*/\n+\n+template <\n+    typename BidirectionalIterator,  // models BidirectionalIterator\n+    typename Pred>                   // models UnaryPredicate\n+std::pair<BidirectionalIterator, BidirectionalIterator> gather \n+        ( BidirectionalIterator first, BidirectionalIterator last, BidirectionalIterator pivot, Pred pred )\n+{\n+//  The first call partitions everything up to (but not including) the pivot element,\n+//  while the second call partitions the rest of the sequence.\n+    using namespace boost::placeholders;\n+    return std::make_pair (\n+        std::stable_partition ( first, pivot, !boost::bind<bool> ( pred, _1 )),\n+        std::stable_partition ( pivot, last,   boost::bind<bool> ( pred, _1 )));\n+}\n+\n+/**************************************************************************************************/\n+\n+/*!\n+    \\ingroup gather\n+    \\brief range-based gather implementation\n+*/\n+\n+template <\n+    typename BidirectionalRange,    //\n+    typename Pred>                  // Pred models UnaryPredicate\n+std::pair<\n+    typename boost::range_iterator<const BidirectionalRange>::type,\n+    typename boost::range_iterator<const BidirectionalRange>::type>\n+gather (\n+    const BidirectionalRange &range,\n+    typename boost::range_iterator<const BidirectionalRange>::type pivot,\n+    Pred pred )\n+{\n+    return boost::algorithm::gather ( boost::begin ( range ), boost::end ( range ), pivot, pred );\n+}\n+\n+/**************************************************************************************************/\n+\n+}}  // namespace\n+\n+/**************************************************************************************************/\n+\n+#endif\n+"
      },
      {
        "sha": "446a5b12aa28ca6000483a63a8ccaca8e77324c9",
        "filename": "src/boost/algorithm/hex.hpp",
        "status": "added",
        "additions": 326,
        "deletions": 0,
        "changes": 326,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/hex.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/hex.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/hex.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,326 @@\n+/*\n+   Copyright (c) Marshall Clow 2011-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+   Thanks to Nevin for his comments/help.\n+*/\n+\n+/*\n+    General problem - turn a sequence of integral types into a sequence of hexadecimal characters.\n+    - and back.\n+*/\n+\n+/// \\file  hex.hpp\n+/// \\brief Convert sequence of integral types into a sequence of hexadecimal\n+///     characters and back. Based on the MySQL functions HEX and UNHEX\n+/// \\author Marshall Clow\n+\n+#ifndef BOOST_ALGORITHM_HEXHPP\n+#define BOOST_ALGORITHM_HEXHPP\n+\n+#include <iterator>     // for std::iterator_traits\n+#include <stdexcept>\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+#include <boost/exception/exception.hpp>\n+#include <boost/exception/info.hpp>\n+#include <boost/throw_exception.hpp>\n+\n+#include <boost/utility/enable_if.hpp>\n+#include <boost/type_traits/is_integral.hpp>\n+\n+\n+namespace boost { namespace algorithm {\n+\n+/*!\n+    \\struct hex_decode_error\n+    \\brief  Base exception class for all hex decoding errors\n+*/ /*!\n+    \\struct non_hex_input\n+    \\brief  Thrown when a non-hex value (0-9, A-F) encountered when decoding.\n+                Contains the offending character\n+*/ /*!\n+    \\struct not_enough_input\n+    \\brief  Thrown when the input sequence unexpectedly ends\n+\n+*/\n+struct hex_decode_error : virtual boost::exception, virtual std::exception {};\n+struct not_enough_input : virtual hex_decode_error {};\n+struct non_hex_input    : virtual hex_decode_error {};\n+typedef boost::error_info<struct bad_char_,char> bad_char;\n+\n+namespace detail {\n+/// \\cond DOXYGEN_HIDE\n+\n+    template <typename T, typename OutputIterator>\n+    OutputIterator encode_one ( T val, OutputIterator out, const char * hexDigits ) {\n+        const std::size_t num_hex_digits =  2 * sizeof ( T );\n+        char res [ num_hex_digits ];\n+        char  *p = res + num_hex_digits;\n+        for ( std::size_t i = 0; i < num_hex_digits; ++i, val >>= 4 )\n+            *--p = hexDigits [ val & 0x0F ];\n+        return std::copy ( res, res + num_hex_digits, out );\n+        }\n+\n+    template <typename T>\n+    unsigned char hex_char_to_int ( T val ) {\n+        char c = static_cast<char> ( val );\n+        unsigned retval = 0;\n+        if      ( c >= '0' && c <= '9' ) retval = c - '0';\n+        else if ( c >= 'A' && c <= 'F' ) retval = c - 'A' + 10;\n+        else if ( c >= 'a' && c <= 'f' ) retval = c - 'a' + 10;\n+        else BOOST_THROW_EXCEPTION (non_hex_input() << bad_char (c));\n+        return static_cast<char>(retval);\n+        }\n+\n+//  My own iterator_traits class.\n+//  It is here so that I can \"reach inside\" some kinds of output iterators\n+//      and get the type to write.\n+    template <typename Iterator>\n+    struct hex_iterator_traits {\n+        typedef typename std::iterator_traits<Iterator>::value_type value_type;\n+    };\n+\n+    template<typename Container>\n+    struct hex_iterator_traits< std::back_insert_iterator<Container> > {\n+        typedef typename Container::value_type value_type;\n+    };\n+\n+    template<typename Container>\n+    struct hex_iterator_traits< std::front_insert_iterator<Container> > {\n+        typedef typename Container::value_type value_type;\n+    };\n+\n+    template<typename Container>\n+    struct hex_iterator_traits< std::insert_iterator<Container> > {\n+        typedef typename Container::value_type value_type;\n+    };\n+\n+//  ostream_iterators have three template parameters.\n+//  The first one is the output type, the second one is the character type of\n+//  the underlying stream, the third is the character traits.\n+//      We only care about the first one.\n+    template<typename T, typename charType, typename traits>\n+    struct hex_iterator_traits< std::ostream_iterator<T, charType, traits> > {\n+        typedef T value_type;\n+    };\n+\n+    template <typename Iterator>\n+    bool iter_end ( Iterator current, Iterator last ) { return current == last; }\n+\n+    template <typename T>\n+    bool ptr_end ( const T* ptr, const T* /*end*/ ) { return *ptr == '\\0'; }\n+\n+//  What can we assume here about the inputs?\n+//      is std::iterator_traits<InputIterator>::value_type always 'char' ?\n+//  Could it be wchar_t, say? Does it matter?\n+//      We are assuming ASCII for the values - but what about the storage?\n+    template <typename InputIterator, typename OutputIterator, typename EndPred>\n+    typename boost::enable_if<boost::is_integral<typename hex_iterator_traits<OutputIterator>::value_type>, OutputIterator>::type\n+    decode_one ( InputIterator &first, InputIterator last, OutputIterator out, EndPred pred ) {\n+        typedef typename hex_iterator_traits<OutputIterator>::value_type T;\n+        T res (0);\n+\n+    //  Need to make sure that we get can read that many chars here.\n+        for ( std::size_t i = 0; i < 2 * sizeof ( T ); ++i, ++first ) {\n+            if ( pred ( first, last ))\n+                BOOST_THROW_EXCEPTION (not_enough_input ());\n+            res = ( 16 * res ) + hex_char_to_int (*first);\n+            }\n+\n+        *out = res;\n+        return ++out;\n+        }\n+/// \\endcond\n+    }\n+\n+\n+/// \\fn hex ( InputIterator first, InputIterator last, OutputIterator out )\n+/// \\brief   Converts a sequence of integral types into a hexadecimal sequence of characters.\n+///\n+/// \\param first    The start of the input sequence\n+/// \\param last     One past the end of the input sequence\n+/// \\param out      An output iterator to the results into\n+/// \\return         The updated output iterator\n+/// \\note           Based on the MySQL function of the same name\n+template <typename InputIterator, typename OutputIterator>\n+typename boost::enable_if<boost::is_integral<typename detail::hex_iterator_traits<InputIterator>::value_type>, OutputIterator>::type\n+hex ( InputIterator first, InputIterator last, OutputIterator out ) {\n+    for ( ; first != last; ++first )\n+        out = detail::encode_one ( *first, out, \"0123456789ABCDEF\" );\n+    return out;\n+    }\n+\n+\n+/// \\fn hex_lower ( InputIterator first, InputIterator last, OutputIterator out )\n+/// \\brief   Converts a sequence of integral types into a lower case hexadecimal sequence of characters.\n+///\n+/// \\param first    The start of the input sequence\n+/// \\param last     One past the end of the input sequence\n+/// \\param out      An output iterator to the results into\n+/// \\return         The updated output iterator\n+/// \\note           Based on the MySQL function of the same name\n+template <typename InputIterator, typename OutputIterator>\n+typename boost::enable_if<boost::is_integral<typename detail::hex_iterator_traits<InputIterator>::value_type>, OutputIterator>::type\n+hex_lower ( InputIterator first, InputIterator last, OutputIterator out ) {\n+    for ( ; first != last; ++first )\n+        out = detail::encode_one ( *first, out, \"0123456789abcdef\" );\n+    return out;\n+    }\n+\n+\n+/// \\fn hex ( const T *ptr, OutputIterator out )\n+/// \\brief   Converts a sequence of integral types into a hexadecimal sequence of characters.\n+///\n+/// \\param ptr      A pointer to a 0-terminated sequence of data.\n+/// \\param out      An output iterator to the results into\n+/// \\return         The updated output iterator\n+/// \\note           Based on the MySQL function of the same name\n+template <typename T, typename OutputIterator>\n+typename boost::enable_if<boost::is_integral<T>, OutputIterator>::type\n+hex ( const T *ptr, OutputIterator out ) {\n+    while ( *ptr )\n+        out = detail::encode_one ( *ptr++, out, \"0123456789ABCDEF\" );\n+    return out;\n+    }\n+\n+\n+/// \\fn hex_lower ( const T *ptr, OutputIterator out )\n+/// \\brief   Converts a sequence of integral types into a lower case hexadecimal sequence of characters.\n+///\n+/// \\param ptr      A pointer to a 0-terminated sequence of data.\n+/// \\param out      An output iterator to the results into\n+/// \\return         The updated output iterator\n+/// \\note           Based on the MySQL function of the same name\n+template <typename T, typename OutputIterator>\n+typename boost::enable_if<boost::is_integral<T>, OutputIterator>::type\n+hex_lower ( const T *ptr, OutputIterator out ) {\n+    while ( *ptr )\n+        out = detail::encode_one ( *ptr++, out, \"0123456789abcdef\" );\n+    return out;\n+    }\n+\n+\n+/// \\fn hex ( const Range &r, OutputIterator out )\n+/// \\brief   Converts a sequence of integral types into a hexadecimal sequence of characters.\n+///\n+/// \\param r        The input range\n+/// \\param out      An output iterator to the results into\n+/// \\return         The updated output iterator\n+/// \\note           Based on the MySQL function of the same name\n+template <typename Range, typename OutputIterator>\n+typename boost::enable_if<boost::is_integral<typename detail::hex_iterator_traits<typename Range::iterator>::value_type>, OutputIterator>::type\n+hex ( const Range &r, OutputIterator out ) {\n+    return hex (boost::begin(r), boost::end(r), out);\n+}\n+\n+\n+/// \\fn hex_lower ( const Range &r, OutputIterator out )\n+/// \\brief   Converts a sequence of integral types into a lower case hexadecimal sequence of characters.\n+///\n+/// \\param r        The input range\n+/// \\param out      An output iterator to the results into\n+/// \\return         The updated output iterator\n+/// \\note           Based on the MySQL function of the same name\n+template <typename Range, typename OutputIterator>\n+typename boost::enable_if<boost::is_integral<typename detail::hex_iterator_traits<typename Range::iterator>::value_type>, OutputIterator>::type\n+hex_lower ( const Range &r, OutputIterator out ) {\n+    return hex_lower (boost::begin(r), boost::end(r), out);\n+}\n+\n+\n+/// \\fn unhex ( InputIterator first, InputIterator last, OutputIterator out )\n+/// \\brief   Converts a sequence of hexadecimal characters into a sequence of integers.\n+///\n+/// \\param first    The start of the input sequence\n+/// \\param last     One past the end of the input sequence\n+/// \\param out      An output iterator to the results into\n+/// \\return         The updated output iterator\n+/// \\note           Based on the MySQL function of the same name\n+template <typename InputIterator, typename OutputIterator>\n+OutputIterator unhex ( InputIterator first, InputIterator last, OutputIterator out ) {\n+    while ( first != last )\n+        out = detail::decode_one ( first, last, out, detail::iter_end<InputIterator> );\n+    return out;\n+    }\n+\n+\n+/// \\fn unhex ( const T *ptr, OutputIterator out )\n+/// \\brief   Converts a sequence of hexadecimal characters into a sequence of integers.\n+///\n+/// \\param ptr      A pointer to a null-terminated input sequence.\n+/// \\param out      An output iterator to the results into\n+/// \\return         The updated output iterator\n+/// \\note           Based on the MySQL function of the same name\n+template <typename T, typename OutputIterator>\n+OutputIterator unhex ( const T *ptr, OutputIterator out ) {\n+//  If we run into the terminator while decoding, we will throw a\n+//      malformed input exception. It would be nicer to throw a 'Not enough input'\n+//      exception - but how much extra work would that require?\n+    while ( *ptr )\n+        out = detail::decode_one ( ptr, (const T *) NULL, out, detail::ptr_end<T> );\n+    return out;\n+    }\n+\n+\n+/// \\fn OutputIterator unhex ( const Range &r, OutputIterator out )\n+/// \\brief   Converts a sequence of hexadecimal characters into a sequence of integers.\n+///\n+/// \\param r        The input range\n+/// \\param out      An output iterator to the results into\n+/// \\return         The updated output iterator\n+/// \\note           Based on the MySQL function of the same name\n+template <typename Range, typename OutputIterator>\n+OutputIterator unhex ( const Range &r, OutputIterator out ) {\n+    return unhex (boost::begin(r), boost::end(r), out);\n+    }\n+\n+\n+/// \\fn String hex ( const String &input )\n+/// \\brief   Converts a sequence of integral types into a hexadecimal sequence of characters.\n+///\n+/// \\param input    A container to be converted\n+/// \\return         A container with the encoded text\n+template<typename String>\n+String hex ( const String &input ) {\n+    String output;\n+    output.reserve (input.size () * (2 * sizeof (typename String::value_type)));\n+    (void) hex (input, std::back_inserter (output));\n+    return output;\n+    }\n+\n+\n+/// \\fn String hex_lower ( const String &input )\n+/// \\brief   Converts a sequence of integral types into a lower case hexadecimal sequence of characters.\n+///\n+/// \\param input    A container to be converted\n+/// \\return         A container with the encoded text\n+template<typename String>\n+String hex_lower ( const String &input ) {\n+    String output;\n+    output.reserve (input.size () * (2 * sizeof (typename String::value_type)));\n+    (void) hex_lower (input, std::back_inserter (output));\n+    return output;\n+    }\n+\n+\n+/// \\fn String unhex ( const String &input )\n+/// \\brief   Converts a sequence of hexadecimal characters into a sequence of characters.\n+///\n+/// \\param input    A container to be converted\n+/// \\return         A container with the decoded text\n+template<typename String>\n+String unhex ( const String &input ) {\n+    String output;\n+    output.reserve (input.size () / (2 * sizeof (typename String::value_type)));\n+    (void) unhex (input, std::back_inserter (output));\n+    return output;\n+    }\n+\n+}}\n+\n+#endif // BOOST_ALGORITHM_HEXHPP"
      },
      {
        "sha": "8e1df1811b3b8a1e5c375a2a41dbf8d0fcb8619f",
        "filename": "src/boost/algorithm/is_palindrome.hpp",
        "status": "added",
        "additions": 141,
        "deletions": 0,
        "changes": 141,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/is_palindrome.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/is_palindrome.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/is_palindrome.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,141 @@\n+/*\n+  Copyright (c) Alexander Zaitsev <zamazan4ik@gmail.com>, 2016\n+\n+  Distributed under the Boost Software License, Version 1.0. (See\n+  accompanying file LICENSE_1_0.txt or copy at\n+  http://www.boost.org/LICENSE_1_0.txt)\n+\n+  See http://www.boost.org/ for latest version.\n+*/\n+\n+/// \\file  is_palindrome.hpp\n+/// \\brief Checks the input sequence on palindrome.\n+/// \\author Alexander Zaitsev\n+\n+#ifndef BOOST_ALGORITHM_IS_PALINDROME_HPP\n+#define BOOST_ALGORITHM_IS_PALINDROME_HPP\n+\n+#include <iterator>\n+#include <functional>\n+#include <cstring>\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+\n+namespace boost {  namespace algorithm {\n+\n+/// \\fn is_palindrome ( BidirectionalIterator begin, BidirectionalIterator end, Predicate p )\n+/// \\return true if the entire sequence is palindrome\n+///\n+/// \\param begin    The start of the input sequence\n+/// \\param end\t\tOne past the end of the input sequence\n+/// \\param p        A predicate used to compare the values.\n+///\n+/// \\note This function will return true for empty sequences and for palindromes.\n+///     For other sequences function will return false.\n+///     Complexity: O(N).\n+template <typename BidirectionalIterator, typename Predicate>\n+bool is_palindrome(BidirectionalIterator begin, BidirectionalIterator end, Predicate p)\n+{\n+    if(begin == end)\n+    {\n+        return true;\n+    }\n+\n+    --end;\n+    while(begin != end)\n+    {\n+        if(!p(*begin, *end))\n+        {\n+            return false;\n+        }\n+        ++begin;\n+        if(begin == end)\n+        {\n+            break;\n+        }\n+        --end;\n+    }\n+    return true;\n+}\n+\n+/// \\fn is_palindrome ( BidirectionalIterator begin, BidirectionalIterator end )\n+/// \\return true if the entire sequence is palindrome\n+///\n+/// \\param begin    The start of the input sequence\n+/// \\param end\t    One past the end of the input sequence\n+///\n+/// \\note This function will return true for empty sequences and for palindromes.\n+///     For other sequences function will return false.\n+///     Complexity: O(N).\n+template <typename BidirectionalIterator>\n+bool is_palindrome(BidirectionalIterator begin, BidirectionalIterator end)\n+{\n+    return is_palindrome(begin, end,\n+                         std::equal_to<typename std::iterator_traits<BidirectionalIterator>::value_type> ());\n+}\n+\n+/// \\fn is_palindrome ( const R& range )\n+/// \\return true if the entire sequence is palindrome\n+///\n+/// \\param range The range to be tested.\n+///\n+/// \\note This function will return true for empty sequences and for palindromes.\n+///     For other sequences function will return false.\n+///     Complexity: O(N).\n+template <typename R>\n+bool is_palindrome(const R& range)\n+{\n+    return is_palindrome(boost::begin(range), boost::end(range));\n+}\n+\n+/// \\fn is_palindrome ( const R& range, Predicate p )\n+/// \\return true if the entire sequence is palindrome\n+///\n+/// \\param range The range to be tested.\n+/// \\param p     A predicate used to compare the values.\n+///\n+/// \\note This function will return true for empty sequences and for palindromes.\n+///     For other sequences function will return false.\n+///     Complexity: O(N).\n+template <typename R, typename Predicate>\n+bool is_palindrome(const R& range, Predicate p)\n+{\n+    return is_palindrome(boost::begin(range), boost::end(range), p);\n+}\n+\n+/// \\fn is_palindrome ( const char* str )\n+/// \\return true if the entire sequence is palindrome\n+///\n+/// \\param str C-string to be tested.\n+///\n+/// \\note This function will return true for empty sequences and for palindromes.\n+///     For other sequences function will return false.\n+///     Complexity: O(N).\n+bool is_palindrome(const char* str)\n+{\n+    if(!str)\n+\t    return true;\n+    return is_palindrome(str, str + strlen(str));\n+}\n+\n+/// \\fn is_palindrome ( const char* str, Predicate p )\n+/// \\return true if the entire sequence is palindrome\n+///\n+/// \\param str C-string to be tested.\n+/// \\param p   A predicate used to compare the values.\n+///\n+/// \\note This function will return true for empty sequences and for palindromes.\n+///     For other sequences function will return false.\n+///     Complexity: O(N).\n+template<typename Predicate>\n+bool is_palindrome(const char* str, Predicate p)\n+{\n+    if(!str)\n+\t    return true;\n+    return is_palindrome(str, str + strlen(str), p);\n+}\n+}}\n+\n+#endif // BOOST_ALGORITHM_IS_PALINDROME_HPP"
      },
      {
        "sha": "bf3ac6722fe9b2e631dacbd825a48ea2852780d4",
        "filename": "src/boost/algorithm/is_partitioned_until.hpp",
        "status": "added",
        "additions": 64,
        "deletions": 0,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/is_partitioned_until.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/is_partitioned_until.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/is_partitioned_until.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,64 @@\n+/*\n+   Copyright (c) Alexander Zaitsev <zamazan4ik@gmail.by>, 2017.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+*/\n+\n+/// \\file  is_partitioned_until.hpp\n+/// \\brief Tell if a sequence is partitioned\n+/// \\author Alexander Zaitsev\n+\n+#ifndef BOOST_ALGORITHM_IS_PARTITIONED_UNTIL_HPP\n+#define BOOST_ALGORITHM_IS_PARTITIONED_UNTIL_HPP\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+/// \\fn is_partitioned_until ( InputIterator first, InputIterator last, UnaryPredicate p )\n+/// \\brief Tests to see if a sequence is partitioned according to a predicate. \n+///\t   In other words, all the items in the sequence that satisfy the predicate are at the beginning of the sequence.\n+///\n+/// \\param first    The start of the input sequence\n+/// \\param last     One past the end of the input sequence\n+/// \\param p        The predicate to test the values with\n+///\n+/// \\note Returns the first iterator 'it' in the sequence [first, last) for which is_partitioned(first, it, p) is false.\n+///     Returns last if the entire sequence is partitioned.\n+///     Complexity: O(N).\n+template <typename InputIterator, typename UnaryPredicate>\n+InputIterator is_partitioned_until ( InputIterator first, InputIterator last, UnaryPredicate p )\n+{\n+//  Run through the part that satisfy the predicate\n+    for ( ; first != last; ++first )\n+        if ( !p (*first))\n+            break;\n+//  Now the part that does not satisfy the predicate\n+    for ( ; first != last; ++first )\n+        if ( p (*first))\n+            return first;\n+    return last;\n+}\n+\n+/// \\fn is_partitioned_until ( const Range &r, UnaryPredicate p )\n+/// \\brief Tests to see if a sequence is partitioned according to a predicate. \n+///\t   In other words, all the items in the sequence that satisfy the predicate are at the beginning of the sequence.\n+///\n+/// \\param r        The input range\n+/// \\param p        The predicate to test the values with\n+///\n+/// \\note Returns the first iterator 'it' in the sequence [first, last) for which is_partitioned(first, it, p) is false.\n+///     Returns last if the entire sequence is partitioned.\n+///     Complexity: O(N).\n+template <typename Range, typename UnaryPredicate>\n+typename boost::range_iterator<const Range>::type is_partitioned_until ( const Range &r, UnaryPredicate p )\n+{\n+    return boost::algorithm::is_partitioned_until (boost::begin(r), boost::end(r), p);\n+}\n+\n+}}\n+\n+#endif  // BOOST_ALGORITHM_IS_PARTITIONED_UNTIL_HPP"
      },
      {
        "sha": "c1aadb290d09624e40b14ae31a6cbc5717b46f6b",
        "filename": "src/boost/algorithm/minmax.hpp",
        "status": "added",
        "additions": 48,
        "deletions": 0,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/minmax.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/minmax.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/minmax.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,48 @@\n+//  (C) Copyright Herve Bronnimann 2004.\n+//\n+// Distributed under the Boost Software License, Version 1.0. (See accompanying\n+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+/*\n+ Revision history:\n+   1 July 2004\n+      Split the code into two headers to lessen dependence on\n+      Boost.tuple. (Herve)\n+   26 June 2004\n+      Added the code for the boost minmax library. (Herve)\n+*/\n+\n+#ifndef BOOST_ALGORITHM_MINMAX_HPP\n+#define BOOST_ALGORITHM_MINMAX_HPP\n+\n+/* PROPOSED STANDARD EXTENSIONS:\n+ *\n+ * minmax(a, b)\n+ * Effect: (b<a) ? std::make_pair(b,a) : std::make_pair(a,b);\n+ *\n+ * minmax(a, b, comp)\n+ * Effect: comp(b,a) ? std::make_pair(b,a) : std::make_pair(a,b);\n+ *\n+ */\n+\n+#include <boost/config.hpp>\n+#include <boost/tuple/tuple.hpp> // for using pairs with boost::cref\n+#include <boost/ref.hpp>\n+\n+namespace boost {\n+\n+  template <typename T>\n+  tuple< T const&, T const& >\n+  minmax(T const& a, T const& b) {\n+    return (b<a) ? make_tuple(cref(b),cref(a)) : make_tuple(cref(a),cref(b));\n+  }\n+\n+  template <typename T, class BinaryPredicate>\n+  tuple< T const&, T const& >\n+  minmax(T const& a, T const& b, BinaryPredicate comp) {\n+    return comp(b,a) ? make_tuple(cref(b),cref(a)) : make_tuple(cref(a),cref(b));\n+  }\n+\n+} // namespace boost\n+\n+#endif // BOOST_ALGORITHM_MINMAX_HPP"
      },
      {
        "sha": "651a552fe1686bb86fd78b5fb78ae9aedd553e7c",
        "filename": "src/boost/algorithm/minmax_element.hpp",
        "status": "added",
        "additions": 555,
        "deletions": 0,
        "changes": 555,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/minmax_element.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/minmax_element.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/minmax_element.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,555 @@\n+//  (C) Copyright Herve Bronnimann 2004.\n+//\n+// Distributed under the Boost Software License, Version 1.0. (See accompanying\n+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+/*\n+ Revision history:\n+   1 July 2004\n+      Split the code into two headers to lessen dependence on\n+      Boost.tuple. (Herve)\n+   26 June 2004\n+      Added the code for the boost minmax library. (Herve)\n+*/\n+\n+#ifndef BOOST_ALGORITHM_MINMAX_ELEMENT_HPP\n+#define BOOST_ALGORITHM_MINMAX_ELEMENT_HPP\n+\n+/* PROPOSED STANDARD EXTENSIONS:\n+ *\n+ * minmax_element(first, last)\n+ * Effect: std::make_pair( std::min_element(first, last),\n+ *                         std::max_element(first, last) );\n+ *\n+ * minmax_element(first, last, comp)\n+ * Effect: std::make_pair( std::min_element(first, last, comp),\n+ *                         std::max_element(first, last, comp) );\n+ */\n+\n+#include <utility> // for std::pair and std::make_pair\n+\n+#include <boost/config.hpp>\n+\n+namespace boost {\n+\n+  namespace detail {  // for obtaining a uniform version of minmax_element\n+    // that compiles with VC++ 6.0 -- avoid the iterator_traits by\n+    // having comparison object over iterator, not over dereferenced value\n+\n+    template <typename Iterator>\n+    struct less_over_iter {\n+      bool operator()(Iterator const& it1,\n+                      Iterator const& it2) const { return *it1 < *it2; }\n+    };\n+\n+    template <typename Iterator, class BinaryPredicate>\n+    struct binary_pred_over_iter {\n+      explicit binary_pred_over_iter(BinaryPredicate const& p ) : m_p( p ) {}\n+      bool operator()(Iterator const& it1,\n+                      Iterator const& it2) const { return m_p(*it1, *it2); }\n+    private:\n+      BinaryPredicate m_p;\n+    };\n+\n+    // common base for the two minmax_element overloads\n+\n+    template <typename ForwardIter, class Compare >\n+    std::pair<ForwardIter,ForwardIter>\n+    basic_minmax_element(ForwardIter first, ForwardIter last, Compare comp)\n+    {\n+      if (first == last)\n+        return std::make_pair(last,last);\n+\n+      ForwardIter min_result = first;\n+      ForwardIter max_result = first;\n+\n+      // if only one element\n+      ForwardIter second = first; ++second;\n+      if (second == last)\n+        return std::make_pair(min_result, max_result);\n+\n+      // treat first pair separately (only one comparison for first two elements)\n+      ForwardIter potential_min_result = last;\n+      if (comp(first, second))\n+        max_result = second;\n+      else {\n+        min_result = second;\n+        potential_min_result = first;\n+      }\n+\n+      // then each element by pairs, with at most 3 comparisons per pair\n+      first = ++second; if (first != last) ++second;\n+      while (second != last) {\n+        if (comp(first, second)) {\n+          if (comp(first, min_result)) {\n+            min_result = first;\n+            potential_min_result = last;\n+          }\n+          if (comp(max_result, second))\n+            max_result = second;\n+        } else {\n+          if (comp(second, min_result)) {\n+            min_result = second;\n+            potential_min_result = first;\n+          }\n+          if (comp(max_result, first))\n+            max_result = first;\n+        }\n+        first = ++second;\n+        if (first != last) ++second;\n+      }\n+\n+      // if odd number of elements, treat last element\n+      if (first != last) { // odd number of elements\n+        if (comp(first, min_result)) {\n+          min_result = first;\n+          potential_min_result = last;\n+          }\n+        else if (comp(max_result, first))\n+          max_result = first;\n+      }\n+\n+      // resolve min_result being incorrect with one extra comparison\n+      // (in which case potential_min_result is necessarily the correct result)\n+      if (potential_min_result != last\n+        && !comp(min_result, potential_min_result))\n+        min_result = potential_min_result;\n+\n+      return std::make_pair(min_result,max_result);\n+    }\n+\n+  } // namespace detail\n+\n+  template <typename ForwardIter>\n+  std::pair<ForwardIter,ForwardIter>\n+  minmax_element(ForwardIter first, ForwardIter last)\n+  {\n+    return detail::basic_minmax_element(first, last,\n+             detail::less_over_iter<ForwardIter>() );\n+  }\n+\n+  template <typename ForwardIter, class BinaryPredicate>\n+  std::pair<ForwardIter,ForwardIter>\n+  minmax_element(ForwardIter first, ForwardIter last, BinaryPredicate comp)\n+  {\n+    return detail::basic_minmax_element(first, last,\n+             detail::binary_pred_over_iter<ForwardIter,BinaryPredicate>(comp) );\n+  }\n+\n+}\n+\n+/* PROPOSED BOOST EXTENSIONS\n+ * In the description below, [rfirst,rlast) denotes the reversed range\n+ * of [first,last). Even though the iterator type of first and last may\n+ * be only a Forward Iterator, it is possible to explain the semantics\n+ * by assuming that it is a Bidirectional Iterator. In the sequel,\n+ * reverse(ForwardIterator&) returns the reverse_iterator adaptor.\n+ * This is not how the functions would be implemented!\n+ *\n+ * first_min_element(first, last)\n+ * Effect: std::min_element(first, last);\n+ *\n+ * first_min_element(first, last, comp)\n+ * Effect: std::min_element(first, last, comp);\n+ *\n+ * last_min_element(first, last)\n+ * Effect: reverse( std::min_element(reverse(last), reverse(first)) );\n+ *\n+ * last_min_element(first, last, comp)\n+ * Effect: reverse( std::min_element(reverse(last), reverse(first), comp) );\n+ *\n+ * first_max_element(first, last)\n+ * Effect: std::max_element(first, last);\n+ *\n+ * first_max_element(first, last, comp)\n+ * Effect: max_element(first, last);\n+ *\n+ * last_max_element(first, last)\n+ * Effect: reverse( std::max_element(reverse(last), reverse(first)) );\n+ *\n+ * last_max_element(first, last, comp)\n+ * Effect: reverse( std::max_element(reverse(last), reverse(first), comp) );\n+ *\n+ * first_min_first_max_element(first, last)\n+ * Effect: std::make_pair( first_min_element(first, last),\n+ *                         first_max_element(first, last) );\n+ *\n+ * first_min_first_max_element(first, last, comp)\n+ * Effect: std::make_pair( first_min_element(first, last, comp),\n+ *                         first_max_element(first, last, comp) );\n+ *\n+ * first_min_last_max_element(first, last)\n+ * Effect: std::make_pair( first_min_element(first, last),\n+ *                         last_max_element(first, last) );\n+ *\n+ * first_min_last_max_element(first, last, comp)\n+ * Effect: std::make_pair( first_min_element(first, last, comp),\n+ *                         last_max_element(first, last, comp) );\n+ *\n+ * last_min_first_max_element(first, last)\n+ * Effect: std::make_pair( last_min_element(first, last),\n+ *                         first_max_element(first, last) );\n+ *\n+ * last_min_first_max_element(first, last, comp)\n+ * Effect: std::make_pair( last_min_element(first, last, comp),\n+ *                         first_max_element(first, last, comp) );\n+ *\n+ * last_min_last_max_element(first, last)\n+ * Effect: std::make_pair( last_min_element(first, last),\n+ *                         last_max_element(first, last) );\n+ *\n+ * last_min_last_max_element(first, last, comp)\n+ * Effect: std::make_pair( last_min_element(first, last, comp),\n+ *                         last_max_element(first, last, comp) );\n+ */\n+\n+namespace boost {\n+\n+  // Min_element and max_element variants\n+\n+  namespace detail {  // common base for the overloads\n+\n+  template <typename ForwardIter, class BinaryPredicate>\n+  ForwardIter\n+  basic_first_min_element(ForwardIter first, ForwardIter last,\n+                          BinaryPredicate comp)\n+  {\n+    if (first == last) return last;\n+    ForwardIter min_result = first;\n+    while (++first != last)\n+      if (comp(first, min_result))\n+        min_result = first;\n+    return min_result;\n+  }\n+\n+  template <typename ForwardIter, class BinaryPredicate>\n+  ForwardIter\n+  basic_last_min_element(ForwardIter first, ForwardIter last,\n+                         BinaryPredicate comp)\n+  {\n+    if (first == last) return last;\n+    ForwardIter min_result = first;\n+    while (++first != last)\n+      if (!comp(min_result, first))\n+        min_result = first;\n+    return min_result;\n+  }\n+\n+  template <typename ForwardIter, class BinaryPredicate>\n+  ForwardIter\n+  basic_first_max_element(ForwardIter first, ForwardIter last,\n+                          BinaryPredicate comp)\n+  {\n+    if (first == last) return last;\n+    ForwardIter max_result = first;\n+    while (++first != last)\n+      if (comp(max_result, first))\n+        max_result = first;\n+    return max_result;\n+  }\n+\n+  template <typename ForwardIter, class BinaryPredicate>\n+  ForwardIter\n+  basic_last_max_element(ForwardIter first, ForwardIter last,\n+                         BinaryPredicate comp)\n+  {\n+    if (first == last) return last;\n+    ForwardIter max_result = first;\n+    while (++first != last)\n+      if (!comp(first, max_result))\n+        max_result = first;\n+    return max_result;\n+  }\n+\n+  } // namespace detail\n+\n+  template <typename ForwardIter>\n+  ForwardIter\n+  first_min_element(ForwardIter first, ForwardIter last)\n+  {\n+    return detail::basic_first_min_element(first, last,\n+             detail::less_over_iter<ForwardIter>() );\n+  }\n+\n+  template <typename ForwardIter, class BinaryPredicate>\n+  ForwardIter\n+  first_min_element(ForwardIter first, ForwardIter last, BinaryPredicate comp)\n+  {\n+    return detail::basic_first_min_element(first, last,\n+             detail::binary_pred_over_iter<ForwardIter,BinaryPredicate>(comp) );\n+  }\n+\n+  template <typename ForwardIter>\n+  ForwardIter\n+  last_min_element(ForwardIter first, ForwardIter last)\n+  {\n+    return detail::basic_last_min_element(first, last,\n+             detail::less_over_iter<ForwardIter>() );\n+  }\n+\n+  template <typename ForwardIter, class BinaryPredicate>\n+  ForwardIter\n+  last_min_element(ForwardIter first, ForwardIter last, BinaryPredicate comp)\n+  {\n+    return detail::basic_last_min_element(first, last,\n+             detail::binary_pred_over_iter<ForwardIter,BinaryPredicate>(comp) );\n+  }\n+\n+  template <typename ForwardIter>\n+  ForwardIter\n+  first_max_element(ForwardIter first, ForwardIter last)\n+  {\n+    return detail::basic_first_max_element(first, last,\n+             detail::less_over_iter<ForwardIter>() );\n+  }\n+\n+  template <typename ForwardIter, class BinaryPredicate>\n+  ForwardIter\n+  first_max_element(ForwardIter first, ForwardIter last, BinaryPredicate comp)\n+  {\n+    return detail::basic_first_max_element(first, last,\n+             detail::binary_pred_over_iter<ForwardIter,BinaryPredicate>(comp) );\n+  }\n+\n+  template <typename ForwardIter>\n+  ForwardIter\n+  last_max_element(ForwardIter first, ForwardIter last)\n+  {\n+    return detail::basic_last_max_element(first, last,\n+             detail::less_over_iter<ForwardIter>() );\n+  }\n+\n+  template <typename ForwardIter, class BinaryPredicate>\n+  ForwardIter\n+  last_max_element(ForwardIter first, ForwardIter last, BinaryPredicate comp)\n+  {\n+    return detail::basic_last_max_element(first, last,\n+             detail::binary_pred_over_iter<ForwardIter,BinaryPredicate>(comp) );\n+  }\n+\n+\n+  // Minmax_element variants -- comments removed\n+\n+  namespace detail {\n+\n+  template <typename ForwardIter, class BinaryPredicate>\n+  std::pair<ForwardIter,ForwardIter>\n+  basic_first_min_last_max_element(ForwardIter first, ForwardIter last,\n+                                   BinaryPredicate comp)\n+  {\n+    if (first == last)\n+      return std::make_pair(last,last);\n+\n+    ForwardIter min_result = first;\n+    ForwardIter max_result = first;\n+\n+    ForwardIter second = ++first;\n+    if (second == last)\n+      return std::make_pair(min_result, max_result);\n+\n+    if (comp(second, min_result))\n+      min_result = second;\n+    else\n+      max_result = second;\n+\n+    first = ++second; if (first != last) ++second;\n+    while (second != last) {\n+      if (!comp(second, first)) {\n+        if (comp(first, min_result))\n+                 min_result = first;\n+        if (!comp(second, max_result))\n+          max_result = second;\n+      } else {\n+        if (comp(second, min_result))\n+          min_result = second;\n+        if (!comp(first, max_result))\n+              max_result = first;\n+      }\n+      first = ++second; if (first != last) ++second;\n+    }\n+\n+    if (first != last) {\n+      if (comp(first, min_result))\n+         min_result = first;\n+      else if (!comp(first, max_result))\n+               max_result = first;\n+    }\n+\n+    return std::make_pair(min_result, max_result);\n+  }\n+\n+  template <typename ForwardIter, class BinaryPredicate>\n+  std::pair<ForwardIter,ForwardIter>\n+  basic_last_min_first_max_element(ForwardIter first, ForwardIter last,\n+                                   BinaryPredicate comp)\n+  {\n+    if (first == last) return std::make_pair(last,last);\n+\n+    ForwardIter min_result = first;\n+    ForwardIter max_result = first;\n+\n+    ForwardIter second = ++first;\n+    if (second == last)\n+      return std::make_pair(min_result, max_result);\n+\n+    if (comp(max_result, second))\n+      max_result = second;\n+    else\n+      min_result = second;\n+\n+    first = ++second; if (first != last) ++second;\n+    while (second != last)  {\n+      if (comp(first, second)) {\n+        if (!comp(min_result, first))\n+          min_result = first;\n+        if (comp(max_result, second))\n+          max_result = second;\n+      } else {\n+        if (!comp(min_result, second))\n+          min_result = second;\n+        if (comp(max_result, first))\n+          max_result = first;\n+      }\n+      first = ++second; if (first != last) ++second;\n+    }\n+\n+    if (first != last) {\n+      if (!comp(min_result, first))\n+        min_result = first;\n+      else if (comp(max_result, first))\n+        max_result = first;\n+    }\n+\n+    return std::make_pair(min_result, max_result);\n+  }\n+\n+  template <typename ForwardIter, class BinaryPredicate>\n+  std::pair<ForwardIter,ForwardIter>\n+  basic_last_min_last_max_element(ForwardIter first, ForwardIter last,\n+                                  BinaryPredicate comp)\n+  {\n+    if (first == last) return std::make_pair(last,last);\n+\n+    ForwardIter min_result = first;\n+    ForwardIter max_result = first;\n+\n+    ForwardIter second = first; ++second;\n+    if (second == last)\n+      return std::make_pair(min_result,max_result);\n+\n+    ForwardIter potential_max_result = last;\n+    if (comp(first, second))\n+      max_result = second;\n+    else {\n+      min_result = second;\n+      potential_max_result = second;\n+    }\n+\n+    first = ++second; if (first != last) ++second;\n+    while (second != last) {\n+      if (comp(first, second)) {\n+        if (!comp(min_result, first))\n+          min_result = first;\n+        if (!comp(second, max_result)) {\n+          max_result = second;\n+          potential_max_result = last;\n+        }\n+      } else {\n+        if (!comp(min_result, second))\n+          min_result = second;\n+        if (!comp(first, max_result)) {\n+          max_result = first;\n+          potential_max_result = second;\n+        }\n+      }\n+      first = ++second;\n+      if (first != last) ++second;\n+    }\n+\n+    if (first != last) {\n+      if (!comp(min_result, first))\n+        min_result = first;\n+      if (!comp(first, max_result)) {\n+        max_result = first;\n+               potential_max_result = last;\n+      }\n+    }\n+\n+    if (potential_max_result != last\n+        && !comp(potential_max_result, max_result))\n+      max_result = potential_max_result;\n+\n+    return std::make_pair(min_result,max_result);\n+  }\n+\n+  } // namespace detail\n+\n+  template <typename ForwardIter>\n+  inline std::pair<ForwardIter,ForwardIter>\n+  first_min_first_max_element(ForwardIter first, ForwardIter last)\n+  {\n+    return minmax_element(first, last);\n+  }\n+\n+  template <typename ForwardIter, class BinaryPredicate>\n+  inline std::pair<ForwardIter,ForwardIter>\n+  first_min_first_max_element(ForwardIter first, ForwardIter last,\n+                              BinaryPredicate comp)\n+  {\n+    return minmax_element(first, last, comp);\n+  }\n+\n+  template <typename ForwardIter>\n+  std::pair<ForwardIter,ForwardIter>\n+  first_min_last_max_element(ForwardIter first, ForwardIter last)\n+  {\n+    return detail::basic_first_min_last_max_element(first, last,\n+             detail::less_over_iter<ForwardIter>() );\n+  }\n+\n+  template <typename ForwardIter, class BinaryPredicate>\n+  inline std::pair<ForwardIter,ForwardIter>\n+  first_min_last_max_element(ForwardIter first, ForwardIter last,\n+                              BinaryPredicate comp)\n+  {\n+    return detail::basic_first_min_last_max_element(first, last,\n+             detail::binary_pred_over_iter<ForwardIter,BinaryPredicate>(comp) );\n+  }\n+\n+  template <typename ForwardIter>\n+  std::pair<ForwardIter,ForwardIter>\n+  last_min_first_max_element(ForwardIter first, ForwardIter last)\n+  {\n+    return detail::basic_last_min_first_max_element(first, last,\n+             detail::less_over_iter<ForwardIter>() );\n+  }\n+\n+  template <typename ForwardIter, class BinaryPredicate>\n+  inline std::pair<ForwardIter,ForwardIter>\n+  last_min_first_max_element(ForwardIter first, ForwardIter last,\n+                              BinaryPredicate comp)\n+  {\n+    return detail::basic_last_min_first_max_element(first, last,\n+             detail::binary_pred_over_iter<ForwardIter,BinaryPredicate>(comp) );\n+  }\n+\n+  template <typename ForwardIter>\n+  std::pair<ForwardIter,ForwardIter>\n+  last_min_last_max_element(ForwardIter first, ForwardIter last)\n+  {\n+    return detail::basic_last_min_last_max_element(first, last,\n+             detail::less_over_iter<ForwardIter>() );\n+  }\n+\n+  template <typename ForwardIter, class BinaryPredicate>\n+  inline std::pair<ForwardIter,ForwardIter>\n+  last_min_last_max_element(ForwardIter first, ForwardIter last,\n+                              BinaryPredicate comp)\n+  {\n+    return detail::basic_last_min_last_max_element(first, last,\n+             detail::binary_pred_over_iter<ForwardIter,BinaryPredicate>(comp) );\n+  }\n+\n+} // namespace boost\n+\n+#endif // BOOST_ALGORITHM_MINMAX_ELEMENT_HPP"
      },
      {
        "sha": "4bf76575e755fb23531b7828bb808b9df4a1de46",
        "filename": "src/boost/algorithm/searching/boyer_moore.hpp",
        "status": "added",
        "additions": 273,
        "deletions": 0,
        "changes": 273,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/searching/boyer_moore.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/searching/boyer_moore.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/searching/boyer_moore.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,273 @@\n+/* \n+   Copyright (c) Marshall Clow 2010-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+    For more information, see http://www.boost.org\n+*/\n+\n+#ifndef BOOST_ALGORITHM_BOYER_MOORE_SEARCH_HPP\n+#define BOOST_ALGORITHM_BOYER_MOORE_SEARCH_HPP\n+\n+#include <iterator>     // for std::iterator_traits\n+\n+#include <boost/config.hpp>\n+#include <boost/assert.hpp>\n+#include <boost/static_assert.hpp>\n+\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+\n+#include <boost/utility/enable_if.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+\n+#include <boost/algorithm/searching/detail/bm_traits.hpp>\n+#include <boost/algorithm/searching/detail/debugging.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+/*\n+    A templated version of the boyer-moore searching algorithm.\n+    \n+References:\n+    http://www.cs.utexas.edu/users/moore/best-ideas/string-searching/\n+    http://www.cs.utexas.edu/~moore/publications/fstrpos.pdf\n+    \n+Explanations:\n+    http://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm\n+    http://www.movsd.com/bm.htm\n+    http://www.cs.ucdavis.edu/~gusfield/cs224f09/bnotes.pdf\n+\n+The Boyer-Moore search algorithm uses two tables, a \"bad character\" table\n+to tell how far to skip ahead when it hits a character that is not in the pattern,\n+and a \"good character\" table to tell how far to skip ahead when it hits a\n+mismatch on a character that _is_ in the pattern.\n+\n+Requirements:\n+        * Random access iterators\n+        * The two iterator types (patIter and corpusIter) must \n+            \"point to\" the same underlying type and be comparable.\n+        * Additional requirements may be imposed but the skip table, such as:\n+        ** Numeric type (array-based skip table)\n+        ** Hashable type (map-based skip table)\n+*/\n+\n+    template <typename patIter, typename traits = detail::BM_traits<patIter> >\n+    class boyer_moore {\n+        typedef typename std::iterator_traits<patIter>::difference_type difference_type;\n+    public:\n+        boyer_moore ( patIter first, patIter last ) \n+                : pat_first ( first ), pat_last ( last ),\n+                  k_pattern_length ( std::distance ( pat_first, pat_last )),\n+                  skip_ ( k_pattern_length, -1 ),\n+                  suffix_ ( k_pattern_length + 1 )\n+            {\n+            this->build_skip_table   ( first, last );\n+            this->build_suffix_table ( first, last );\n+            }\n+            \n+        ~boyer_moore () {}\n+        \n+        /// \\fn operator ( corpusIter corpus_first, corpusIter corpus_last )\n+        /// \\brief Searches the corpus for the pattern that was passed into the constructor\n+        /// \n+        /// \\param corpus_first The start of the data to search (Random Access Iterator)\n+        /// \\param corpus_last  One past the end of the data to search\n+        ///\n+        template <typename corpusIter>\n+        std::pair<corpusIter, corpusIter>\n+        operator () ( corpusIter corpus_first, corpusIter corpus_last ) const {\n+            BOOST_STATIC_ASSERT (( boost::is_same<\n+                                    typename std::iterator_traits<patIter>::value_type, \n+                                    typename std::iterator_traits<corpusIter>::value_type>::value ));\n+\n+            if ( corpus_first == corpus_last ) return std::make_pair(corpus_last, corpus_last);   // if nothing to search, we didn't find it!\n+            if (    pat_first ==    pat_last ) return std::make_pair(corpus_first, corpus_first); // empty pattern matches at start\n+\n+            const difference_type k_corpus_length  = std::distance ( corpus_first, corpus_last );\n+        //  If the pattern is larger than the corpus, we can't find it!\n+            if ( k_corpus_length < k_pattern_length ) \n+                return std::make_pair(corpus_last, corpus_last);\n+\n+        //  Do the search \n+            return this->do_search ( corpus_first, corpus_last );\n+            }\n+            \n+        template <typename Range>\n+        std::pair<typename boost::range_iterator<Range>::type, typename boost::range_iterator<Range>::type>\n+        operator () ( Range &r ) const {\n+            return (*this) (boost::begin(r), boost::end(r));\n+            }\n+\n+    private:\n+/// \\cond DOXYGEN_HIDE\n+        patIter pat_first, pat_last;\n+        const difference_type k_pattern_length;\n+        typename traits::skip_table_t skip_;\n+        std::vector <difference_type> suffix_;\n+\n+        /// \\fn operator ( corpusIter corpus_first, corpusIter corpus_last, Pred p )\n+        /// \\brief Searches the corpus for the pattern that was passed into the constructor\n+        /// \n+        /// \\param corpus_first The start of the data to search (Random Access Iterator)\n+        /// \\param corpus_last  One past the end of the data to search\n+        /// \\param p            A predicate used for the search comparisons.\n+        ///\n+        template <typename corpusIter>\n+        std::pair<corpusIter, corpusIter>\n+        do_search ( corpusIter corpus_first, corpusIter corpus_last ) const {\n+        /*  ---- Do the matching ---- */\n+            corpusIter curPos = corpus_first;\n+            const corpusIter lastPos = corpus_last - k_pattern_length;\n+            difference_type j, k, m;\n+\n+            while ( curPos <= lastPos ) {\n+        /*  while ( std::distance ( curPos, corpus_last ) >= k_pattern_length ) { */\n+            //  Do we match right where we are?\n+                j = k_pattern_length;\n+                while ( pat_first [j-1] == curPos [j-1] ) {\n+                    j--;\n+                //  We matched - we're done!\n+                    if ( j == 0 )\n+                        return std::make_pair(curPos, curPos + k_pattern_length);\n+                    }\n+                \n+            //  Since we didn't match, figure out how far to skip forward\n+                k = skip_ [ curPos [ j - 1 ]];\n+                m = j - k - 1;\n+                if ( k < j && m > suffix_ [ j ] )\n+                    curPos += m;\n+                else\n+                    curPos += suffix_ [ j ];\n+                }\n+        \n+            return std::make_pair(corpus_last, corpus_last);     // We didn't find anything\n+            }\n+\n+\n+        void build_skip_table ( patIter first, patIter last ) {\n+            for ( std::size_t i = 0; first != last; ++first, ++i )\n+                skip_.insert ( *first, i );\n+            }\n+        \n+\n+        template<typename Iter, typename Container>\n+        void compute_bm_prefix ( Iter first, Iter last, Container &prefix ) {\n+            const std::size_t count = std::distance ( first, last );\n+            BOOST_ASSERT ( count > 0 );\n+            BOOST_ASSERT ( prefix.size () == count );\n+                            \n+            prefix[0] = 0;\n+            std::size_t k = 0;\n+            for ( std::size_t i = 1; i < count; ++i ) {\n+                BOOST_ASSERT ( k < count );\n+                while ( k > 0 && ( first[k] != first[i] )) {\n+                    BOOST_ASSERT ( k < count );\n+                    k = prefix [ k - 1 ];\n+                    }\n+                    \n+                if ( first[k] == first[i] )\n+                    k++;\n+                prefix [ i ] = k;\n+                }\n+            }\n+\n+        void build_suffix_table ( patIter first, patIter last ) {\n+            const std::size_t count = (std::size_t) std::distance ( first, last );\n+            \n+            if ( count > 0 ) {  // empty pattern\n+                std::vector<typename std::iterator_traits<patIter>::value_type> reversed(count);\n+                (void) std::reverse_copy ( first, last, reversed.begin ());\n+                \n+                std::vector<difference_type> prefix (count);\n+                compute_bm_prefix ( first, last, prefix );\n+        \n+                std::vector<difference_type> prefix_reversed (count);\n+                compute_bm_prefix ( reversed.begin (), reversed.end (), prefix_reversed );\n+                \n+                for ( std::size_t i = 0; i <= count; i++ )\n+                    suffix_[i] = count - prefix [count-1];\n+         \n+                for ( std::size_t i = 0; i < count; i++ ) {\n+                    const std::size_t     j = count - prefix_reversed[i];\n+                    const difference_type k = i -     prefix_reversed[i] + 1;\n+         \n+                    if (suffix_[j] > k)\n+                        suffix_[j] = k;\n+                    }\n+                }\n+            }\n+/// \\endcond\n+        };\n+\n+\n+/*  Two ranges as inputs gives us four possibilities; with 2,3,3,4 parameters\n+    Use a bit of TMP to disambiguate the 3-argument templates */\n+\n+/// \\fn boyer_moore_search ( corpusIter corpus_first, corpusIter corpus_last, \n+///       patIter pat_first, patIter pat_last )\n+/// \\brief Searches the corpus for the pattern.\n+/// \n+/// \\param corpus_first The start of the data to search (Random Access Iterator)\n+/// \\param corpus_last  One past the end of the data to search\n+/// \\param pat_first    The start of the pattern to search for (Random Access Iterator)\n+/// \\param pat_last     One past the end of the data to search for\n+///\n+    template <typename patIter, typename corpusIter>\n+    std::pair<corpusIter, corpusIter> boyer_moore_search ( \n+                  corpusIter corpus_first, corpusIter corpus_last, \n+                  patIter pat_first, patIter pat_last )\n+    {\n+        boyer_moore<patIter> bm ( pat_first, pat_last );\n+        return bm ( corpus_first, corpus_last );\n+    }\n+\n+    template <typename PatternRange, typename corpusIter>\n+    std::pair<corpusIter, corpusIter> boyer_moore_search ( \n+        corpusIter corpus_first, corpusIter corpus_last, const PatternRange &pattern )\n+    {\n+        typedef typename boost::range_iterator<const PatternRange>::type pattern_iterator;\n+        boyer_moore<pattern_iterator> bm ( boost::begin(pattern), boost::end (pattern));\n+        return bm ( corpus_first, corpus_last );\n+    }\n+    \n+    template <typename patIter, typename CorpusRange>\n+    typename boost::disable_if_c<\n+        boost::is_same<CorpusRange, patIter>::value, \n+        std::pair<typename boost::range_iterator<CorpusRange>::type, typename boost::range_iterator<CorpusRange>::type> >\n+    ::type\n+    boyer_moore_search ( CorpusRange &corpus, patIter pat_first, patIter pat_last )\n+    {\n+        boyer_moore<patIter> bm ( pat_first, pat_last );\n+        return bm (boost::begin (corpus), boost::end (corpus));\n+    }\n+    \n+    template <typename PatternRange, typename CorpusRange>\n+    std::pair<typename boost::range_iterator<CorpusRange>::type, typename boost::range_iterator<CorpusRange>::type>\n+    boyer_moore_search ( CorpusRange &corpus, const PatternRange &pattern )\n+    {\n+        typedef typename boost::range_iterator<const PatternRange>::type pattern_iterator;\n+        boyer_moore<pattern_iterator> bm ( boost::begin(pattern), boost::end (pattern));\n+        return bm (boost::begin (corpus), boost::end (corpus));\n+    }\n+\n+\n+    //  Creator functions -- take a pattern range, return an object\n+    template <typename Range>\n+    boost::algorithm::boyer_moore<typename boost::range_iterator<const Range>::type>\n+    make_boyer_moore ( const Range &r ) {\n+        return boost::algorithm::boyer_moore\n+            <typename boost::range_iterator<const Range>::type> (boost::begin(r), boost::end(r));\n+        }\n+    \n+    template <typename Range>\n+    boost::algorithm::boyer_moore<typename boost::range_iterator<Range>::type>\n+    make_boyer_moore ( Range &r ) {\n+        return boost::algorithm::boyer_moore\n+            <typename boost::range_iterator<Range>::type> (boost::begin(r), boost::end(r));\n+        }\n+\n+}}\n+\n+#endif  //  BOOST_ALGORITHM_BOYER_MOORE_SEARCH_HPP"
      },
      {
        "sha": "dd354cc543f0c8025d9f2e097d1e52096b85d2f3",
        "filename": "src/boost/algorithm/searching/boyer_moore_horspool.hpp",
        "status": "added",
        "additions": 203,
        "deletions": 0,
        "changes": 203,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/searching/boyer_moore_horspool.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/searching/boyer_moore_horspool.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/searching/boyer_moore_horspool.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,203 @@\n+/* \n+   Copyright (c) Marshall Clow 2010-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+    For more information, see http://www.boost.org\n+*/\n+\n+#ifndef BOOST_ALGORITHM_BOYER_MOORE_HORSPOOOL_SEARCH_HPP\n+#define BOOST_ALGORITHM_BOYER_MOORE_HORSPOOOL_SEARCH_HPP\n+\n+#include <iterator>     // for std::iterator_traits\n+\n+#include <boost/config.hpp>\n+#include <boost/assert.hpp>\n+#include <boost/static_assert.hpp>\n+\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+\n+#include <boost/utility/enable_if.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+\n+#include <boost/algorithm/searching/detail/bm_traits.hpp>\n+#include <boost/algorithm/searching/detail/debugging.hpp>\n+\n+// #define  BOOST_ALGORITHM_BOYER_MOORE_HORSPOOL_DEBUG_HPP\n+\n+namespace boost { namespace algorithm {\n+\n+/*\n+    A templated version of the boyer-moore-horspool searching algorithm.\n+    \n+    Requirements:\n+        * Random access iterators\n+        * The two iterator types (patIter and corpusIter) must \n+            \"point to\" the same underlying type.\n+        * Additional requirements may be imposed buy the skip table, such as:\n+        ** Numeric type (array-based skip table)\n+        ** Hashable type (map-based skip table)\n+\n+http://www-igm.univ-mlv.fr/%7Elecroq/string/node18.html\n+\n+*/\n+\n+    template <typename patIter, typename traits = detail::BM_traits<patIter> >\n+    class boyer_moore_horspool {\n+        typedef typename std::iterator_traits<patIter>::difference_type difference_type;\n+    public:\n+        boyer_moore_horspool ( patIter first, patIter last ) \n+                : pat_first ( first ), pat_last ( last ),\n+                  k_pattern_length ( std::distance ( pat_first, pat_last )),\n+                  skip_ ( k_pattern_length, k_pattern_length ) {\n+                  \n+        //  Build the skip table\n+            std::size_t i = 0;\n+            if ( first != last )    // empty pattern?\n+                for ( patIter iter = first; iter != last-1; ++iter, ++i )\n+                    skip_.insert ( *iter, k_pattern_length - 1 - i );\n+#ifdef BOOST_ALGORITHM_BOYER_MOORE_HORSPOOL_DEBUG_HPP\n+            skip_.PrintSkipTable ();\n+#endif\n+            }\n+            \n+        ~boyer_moore_horspool () {}\n+        \n+        /// \\fn operator ( corpusIter corpus_first, corpusIter corpus_last)\n+        /// \\brief Searches the corpus for the pattern that was passed into the constructor\n+        /// \n+        /// \\param corpus_first The start of the data to search (Random Access Iterator)\n+        /// \\param corpus_last  One past the end of the data to search\n+        ///\n+        template <typename corpusIter>\n+        std::pair<corpusIter, corpusIter>\n+        operator () ( corpusIter corpus_first, corpusIter corpus_last ) const {\n+            BOOST_STATIC_ASSERT (( boost::is_same<\n+                typename std::iterator_traits<patIter>::value_type, \n+                typename std::iterator_traits<corpusIter>::value_type>::value ));\n+\n+            if ( corpus_first == corpus_last ) return std::make_pair(corpus_last, corpus_last);   // if nothing to search, we didn't find it!\n+            if (    pat_first ==    pat_last ) return std::make_pair(corpus_first, corpus_first); // empty pattern matches at start\n+\n+            const difference_type k_corpus_length  = std::distance ( corpus_first, corpus_last );\n+        //  If the pattern is larger than the corpus, we can't find it!\n+            if ( k_corpus_length < k_pattern_length )\n+                return std::make_pair(corpus_last, corpus_last);\n+    \n+        //  Do the search \n+            return this->do_search ( corpus_first, corpus_last );\n+            }\n+            \n+        template <typename Range>\n+        std::pair<typename boost::range_iterator<Range>::type, typename boost::range_iterator<Range>::type>\n+        operator () ( Range &r ) const {\n+            return (*this) (boost::begin(r), boost::end(r));\n+            }\n+\n+    private:\n+/// \\cond DOXYGEN_HIDE\n+        patIter pat_first, pat_last;\n+        const difference_type k_pattern_length;\n+        typename traits::skip_table_t skip_;\n+\n+        /// \\fn do_search ( corpusIter corpus_first, corpusIter corpus_last )\n+        /// \\brief Searches the corpus for the pattern that was passed into the constructor\n+        /// \n+        /// \\param corpus_first The start of the data to search (Random Access Iterator)\n+        /// \\param corpus_last  One past the end of the data to search\n+        /// \\param k_corpus_length The length of the corpus to search\n+        ///\n+        template <typename corpusIter>\n+        std::pair<corpusIter, corpusIter>\n+        do_search ( corpusIter corpus_first, corpusIter corpus_last ) const {\n+            corpusIter curPos = corpus_first;\n+            const corpusIter lastPos = corpus_last - k_pattern_length;\n+            while ( curPos <= lastPos ) {\n+            //  Do we match right where we are?\n+                std::size_t j = k_pattern_length - 1;\n+                while ( pat_first [j] == curPos [j] ) {\n+                //  We matched - we're done!\n+                    if ( j == 0 )\n+                        return std::make_pair(curPos, curPos + k_pattern_length);\n+                    j--;\n+                    }\n+        \n+                curPos += skip_ [ curPos [ k_pattern_length - 1 ]];\n+                }\n+            \n+            return std::make_pair(corpus_last, corpus_last);\n+            }\n+// \\endcond\n+        };\n+\n+/*  Two ranges as inputs gives us four possibilities; with 2,3,3,4 parameters\n+    Use a bit of TMP to disambiguate the 3-argument templates */\n+\n+/// \\fn boyer_moore_horspool_search ( corpusIter corpus_first, corpusIter corpus_last, \n+///       patIter pat_first, patIter pat_last )\n+/// \\brief Searches the corpus for the pattern.\n+/// \n+/// \\param corpus_first The start of the data to search (Random Access Iterator)\n+/// \\param corpus_last  One past the end of the data to search\n+/// \\param pat_first    The start of the pattern to search for (Random Access Iterator)\n+/// \\param pat_last     One past the end of the data to search for\n+///\n+    template <typename patIter, typename corpusIter>\n+    std::pair<corpusIter, corpusIter> boyer_moore_horspool_search ( \n+                  corpusIter corpus_first, corpusIter corpus_last, \n+                  patIter pat_first, patIter pat_last )\n+    {\n+        boyer_moore_horspool<patIter> bmh ( pat_first, pat_last );\n+        return bmh ( corpus_first, corpus_last );\n+    }\n+\n+    template <typename PatternRange, typename corpusIter>\n+    std::pair<corpusIter, corpusIter> boyer_moore_horspool_search ( \n+        corpusIter corpus_first, corpusIter corpus_last, const PatternRange &pattern )\n+    {\n+        typedef typename boost::range_iterator<const PatternRange>::type pattern_iterator;\n+        boyer_moore_horspool<pattern_iterator> bmh ( boost::begin(pattern), boost::end (pattern));\n+        return bmh ( corpus_first, corpus_last );\n+    }\n+    \n+    template <typename patIter, typename CorpusRange>\n+    typename boost::disable_if_c<\n+        boost::is_same<CorpusRange, patIter>::value, \n+        std::pair<typename boost::range_iterator<CorpusRange>::type, typename boost::range_iterator<CorpusRange>::type> >\n+    ::type\n+    boyer_moore_horspool_search ( CorpusRange &corpus, patIter pat_first, patIter pat_last )\n+    {\n+        boyer_moore_horspool<patIter> bmh ( pat_first, pat_last );\n+        return bm (boost::begin (corpus), boost::end (corpus));\n+    }\n+    \n+    template <typename PatternRange, typename CorpusRange>\n+    std::pair<typename boost::range_iterator<CorpusRange>::type, typename boost::range_iterator<CorpusRange>::type>\n+    boyer_moore_horspool_search ( CorpusRange &corpus, const PatternRange &pattern )\n+    {\n+        typedef typename boost::range_iterator<const PatternRange>::type pattern_iterator;\n+        boyer_moore_horspool<pattern_iterator> bmh ( boost::begin(pattern), boost::end (pattern));\n+        return bmh (boost::begin (corpus), boost::end (corpus));\n+    }\n+\n+\n+    //  Creator functions -- take a pattern range, return an object\n+    template <typename Range>\n+    boost::algorithm::boyer_moore_horspool<typename boost::range_iterator<const Range>::type>\n+    make_boyer_moore_horspool ( const Range &r ) {\n+        return boost::algorithm::boyer_moore_horspool\n+            <typename boost::range_iterator<const Range>::type> (boost::begin(r), boost::end(r));\n+        }\n+    \n+    template <typename Range>\n+    boost::algorithm::boyer_moore_horspool<typename boost::range_iterator<Range>::type>\n+    make_boyer_moore_horspool ( Range &r ) {\n+        return boost::algorithm::boyer_moore_horspool\n+            <typename boost::range_iterator<Range>::type> (boost::begin(r), boost::end(r));\n+        }\n+\n+}}\n+\n+#endif  //  BOOST_ALGORITHM_BOYER_MOORE_HORSPOOOL_SEARCH_HPP"
      },
      {
        "sha": "12143636be0f88bc05e0d10c8e84138d71ab6221",
        "filename": "src/boost/algorithm/searching/detail/bm_traits.hpp",
        "status": "added",
        "additions": 113,
        "deletions": 0,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/searching/detail/bm_traits.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/searching/detail/bm_traits.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/searching/detail/bm_traits.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,113 @@\n+/* \n+   Copyright (c) Marshall Clow 2010-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+    For more information, see http://www.boost.org\n+*/\n+\n+#ifndef BOOST_ALGORITHM_SEARCH_DETAIL_BM_TRAITS_HPP\n+#define BOOST_ALGORITHM_SEARCH_DETAIL_BM_TRAITS_HPP\n+\n+#include <climits>      // for CHAR_BIT\n+#include <vector>\n+#include <iterator>     // for std::iterator_traits\n+\n+#include <boost/type_traits/make_unsigned.hpp>\n+#include <boost/type_traits/is_integral.hpp>\n+#include <boost/type_traits/remove_pointer.hpp>\n+#include <boost/type_traits/remove_const.hpp>\n+\n+#include <boost/array.hpp>\n+#ifdef BOOST_NO_CXX11_HDR_UNORDERED_MAP\n+#include <boost/unordered_map.hpp>\n+#else\n+#include <unordered_map>\n+#endif\n+\n+#include <boost/algorithm/searching/detail/debugging.hpp>\n+\n+namespace boost { namespace algorithm { namespace detail {\n+\n+//\n+//  Default implementations of the skip tables for B-M and B-M-H\n+//\n+    template<typename key_type, typename value_type, bool /*useArray*/> class skip_table;\n+\n+//  General case for data searching other than bytes; use a map\n+    template<typename key_type, typename value_type>\n+    class skip_table<key_type, value_type, false> {\n+    private:\n+#ifdef BOOST_NO_CXX11_HDR_UNORDERED_MAP\n+        typedef boost::unordered_map<key_type, value_type> skip_map;\n+#else\n+        typedef std::unordered_map<key_type, value_type> skip_map;\n+#endif\n+        const value_type k_default_value;\n+        skip_map skip_;\n+        \n+    public:\n+        skip_table ( std::size_t patSize, value_type default_value ) \n+            : k_default_value ( default_value ), skip_ ( patSize ) {}\n+        \n+        void insert ( key_type key, value_type val ) {\n+            skip_ [ key ] = val;    // Would skip_.insert (val) be better here?\n+            }\n+\n+        value_type operator [] ( key_type key ) const {\n+            typename skip_map::const_iterator it = skip_.find ( key );\n+            return it == skip_.end () ? k_default_value : it->second;\n+            }\n+            \n+        void PrintSkipTable () const {\n+            std::cout << \"BM(H) Skip Table <unordered_map>:\" << std::endl;\n+            for ( typename skip_map::const_iterator it = skip_.begin (); it != skip_.end (); ++it )\n+                if ( it->second != k_default_value )\n+                    std::cout << \"  \" << it->first << \": \" << it->second << std::endl;\n+            std::cout << std::endl;\n+            }\n+        };\n+        \n+    \n+//  Special case small numeric values; use an array\n+    template<typename key_type, typename value_type>\n+    class skip_table<key_type, value_type, true> {\n+    private:\n+        typedef typename boost::make_unsigned<key_type>::type unsigned_key_type;\n+        typedef boost::array<value_type, 1U << (CHAR_BIT * sizeof(key_type))> skip_map;\n+        skip_map skip_;\n+        const value_type k_default_value;\n+    public:\n+        skip_table ( std::size_t /*patSize*/, value_type default_value ) : k_default_value ( default_value ) {\n+            std::fill_n ( skip_.begin(), skip_.size(), default_value );\n+            }\n+        \n+        void insert ( key_type key, value_type val ) {\n+            skip_ [ static_cast<unsigned_key_type> ( key ) ] = val;\n+            }\n+\n+        value_type operator [] ( key_type key ) const {\n+            return skip_ [ static_cast<unsigned_key_type> ( key ) ];\n+            }\n+\n+        void PrintSkipTable () const {\n+            std::cout << \"BM(H) Skip Table <boost:array>:\" << std::endl;\n+            for ( typename skip_map::const_iterator it = skip_.begin (); it != skip_.end (); ++it )\n+                if ( *it != k_default_value )\n+                    std::cout << \"  \" << std::distance (skip_.begin (), it) << \": \" << *it << std::endl;\n+            std::cout << std::endl;\n+            }\n+        };\n+\n+    template<typename Iterator>\n+    struct BM_traits {\n+        typedef typename std::iterator_traits<Iterator>::difference_type value_type;\n+        typedef typename std::iterator_traits<Iterator>::value_type key_type;\n+        typedef boost::algorithm::detail::skip_table<key_type, value_type, \n+                boost::is_integral<key_type>::value && (sizeof(key_type)==1)> skip_table_t;\n+        };\n+\n+}}} // namespaces\n+\n+#endif  //  BOOST_ALGORITHM_SEARCH_DETAIL_BM_TRAITS_HPP"
      },
      {
        "sha": "3996e0f503c129397e451dfed6db6d6e6cf44494",
        "filename": "src/boost/algorithm/searching/detail/debugging.hpp",
        "status": "added",
        "additions": 30,
        "deletions": 0,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/searching/detail/debugging.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/searching/detail/debugging.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/searching/detail/debugging.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,30 @@\n+/* \n+   Copyright (c) Marshall Clow 2010-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+    For more information, see http://www.boost.org\n+*/\n+\n+#ifndef BOOST_ALGORITHM_SEARCH_DETAIL_DEBUG_HPP\n+#define BOOST_ALGORITHM_SEARCH_DETAIL_DEBUG_HPP\n+\n+#include <iostream>\n+/// \\cond DOXYGEN_HIDE\n+\n+namespace boost { namespace algorithm { namespace detail {\n+\n+//  Debugging support\n+    template <typename Iter>\n+    void PrintTable ( Iter first, Iter last ) {\n+        std::cout << std::distance ( first, last ) << \": { \";\n+        for ( Iter iter = first; iter != last; ++iter )\n+            std::cout << *iter << \" \";\n+        std::cout << \"}\" << std::endl;\n+        }\n+    \n+}}}\n+/// \\endcond\n+\n+#endif  //  BOOST_ALGORITHM_SEARCH_DETAIL_DEBUG_HPP"
      },
      {
        "sha": "7c1541cc425f791f0818c9713c90ad10337ff777",
        "filename": "src/boost/algorithm/searching/knuth_morris_pratt.hpp",
        "status": "added",
        "additions": 264,
        "deletions": 0,
        "changes": 264,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/searching/knuth_morris_pratt.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/searching/knuth_morris_pratt.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/searching/knuth_morris_pratt.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,264 @@\n+/* \n+   Copyright (c) Marshall Clow 2010-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+    For more information, see http://www.boost.org\n+*/\n+\n+#ifndef BOOST_ALGORITHM_KNUTH_MORRIS_PRATT_SEARCH_HPP\n+#define BOOST_ALGORITHM_KNUTH_MORRIS_PRATT_SEARCH_HPP\n+\n+#include <vector>\n+#include <iterator>     // for std::iterator_traits\n+\n+#include <boost/config.hpp>\n+#include <boost/assert.hpp>\n+#include <boost/static_assert.hpp>\n+\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+\n+#include <boost/utility/enable_if.hpp>\n+#include <boost/type_traits/is_same.hpp>\n+\n+#include <boost/algorithm/searching/detail/debugging.hpp>\n+\n+// #define  BOOST_ALGORITHM_KNUTH_MORRIS_PRATT_DEBUG\n+\n+namespace boost { namespace algorithm {\n+\n+// #define  NEW_KMP\n+\n+/*\n+    A templated version of the Knuth-Morris-Pratt searching algorithm.\n+    \n+    Requirements:\n+        * Random-access iterators\n+        * The two iterator types (I1 and I2) must \"point to\" the same underlying type.\n+\n+    http://en.wikipedia.org/wiki/Knuth-Morris-Pratt_algorithm\n+    http://www.inf.fh-flensburg.de/lang/algorithmen/pattern/kmpen.htm\n+*/\n+\n+    template <typename patIter>\n+    class knuth_morris_pratt {\n+        typedef typename std::iterator_traits<patIter>::difference_type difference_type;\n+    public:\n+        knuth_morris_pratt ( patIter first, patIter last ) \n+                : pat_first ( first ), pat_last ( last ), \n+                  k_pattern_length ( std::distance ( pat_first, pat_last )),\n+                  skip_ ( k_pattern_length + 1 ) {\n+#ifdef NEW_KMP\n+            preKmp ( pat_first, pat_last );\n+#else\n+            init_skip_table ( pat_first, pat_last );\n+#endif\n+#ifdef BOOST_ALGORITHM_KNUTH_MORRIS_PRATT_DEBUG\n+            detail::PrintTable ( skip_.begin (), skip_.end ());\n+#endif\n+            }\n+            \n+        ~knuth_morris_pratt () {}\n+        \n+        /// \\fn operator ( corpusIter corpus_first, corpusIter corpus_last, Pred p )\n+        /// \\brief Searches the corpus for the pattern that was passed into the constructor\n+        /// \n+        /// \\param corpus_first The start of the data to search (Random Access Iterator)\n+        /// \\param corpus_last  One past the end of the data to search\n+        /// \\param p            A predicate used for the search comparisons.\n+        ///\n+        template <typename corpusIter>\n+        std::pair<corpusIter, corpusIter>\n+        operator () ( corpusIter corpus_first, corpusIter corpus_last ) const {\n+            BOOST_STATIC_ASSERT (( boost::is_same<\n+                typename std::iterator_traits<patIter>::value_type, \n+                typename std::iterator_traits<corpusIter>::value_type>::value ));\n+\n+            if ( corpus_first == corpus_last ) return std::make_pair(corpus_last, corpus_last);   // if nothing to search, we didn't find it!\n+            if (    pat_first ==    pat_last ) return std::make_pair(corpus_first, corpus_first); // empty pattern matches at start\n+\n+            const difference_type k_corpus_length = std::distance ( corpus_first, corpus_last );\n+        //  If the pattern is larger than the corpus, we can't find it!\n+            if ( k_corpus_length < k_pattern_length ) \n+                return std::make_pair(corpus_last, corpus_last);\n+\n+            return do_search ( corpus_first, corpus_last, k_corpus_length );\n+            }\n+    \n+        template <typename Range>\n+        std::pair<typename boost::range_iterator<Range>::type, typename boost::range_iterator<Range>::type>\n+        operator () ( Range &r ) const {\n+            return (*this) (boost::begin(r), boost::end(r));\n+            }\n+\n+    private:\n+/// \\cond DOXYGEN_HIDE\n+        patIter pat_first, pat_last;\n+        const difference_type k_pattern_length;\n+        std::vector <difference_type> skip_;\n+\n+        /// \\fn operator ( corpusIter corpus_first, corpusIter corpus_last, Pred p )\n+        /// \\brief Searches the corpus for the pattern that was passed into the constructor\n+        /// \n+        /// \\param corpus_first The start of the data to search (Random Access Iterator)\n+        /// \\param corpus_last  One past the end of the data to search\n+        /// \\param p            A predicate used for the search comparisons.\n+        ///\n+        template <typename corpusIter>\n+        std::pair<corpusIter, corpusIter>\n+        do_search ( corpusIter corpus_first, corpusIter corpus_last, \n+                                                difference_type k_corpus_length ) const {\n+            difference_type match_start = 0;  // position in the corpus that we're matching\n+            \n+#ifdef NEW_KMP\n+            int patternIdx = 0;\n+            while ( match_start < k_corpus_length ) {\n+                while ( patternIdx > -1 && pat_first[patternIdx] != corpus_first [match_start] )\n+                    patternIdx = skip_ [patternIdx]; //<--- Shifting the pattern on mismatch\n+\n+                patternIdx++;\n+                match_start++; //<--- corpus is always increased by 1\n+\n+                if ( patternIdx >= (int) k_pattern_length )\n+                    return corpus_first + match_start - patternIdx;\n+                }\n+            \n+#else\n+//  At this point, we know:\n+//          k_pattern_length <= k_corpus_length\n+//          for all elements of skip, it holds -1 .. k_pattern_length\n+//      \n+//          In the loop, we have the following invariants\n+//              idx is in the range 0 .. k_pattern_length\n+//              match_start is in the range 0 .. k_corpus_length - k_pattern_length + 1\n+\n+            const difference_type last_match = k_corpus_length - k_pattern_length;\n+            difference_type idx = 0;          // position in the pattern we're comparing\n+\n+            while ( match_start <= last_match ) {\n+                while ( pat_first [ idx ] == corpus_first [ match_start + idx ] ) {\n+                    if ( ++idx == k_pattern_length )\n+                        return std::make_pair(corpus_first + match_start, corpus_first + match_start + k_pattern_length);\n+                    }\n+            //  Figure out where to start searching again\n+           //   assert ( idx - skip_ [ idx ] > 0 ); // we're always moving forward\n+                match_start += idx - skip_ [ idx ];\n+                idx = skip_ [ idx ] >= 0 ? skip_ [ idx ] : 0;\n+           //   assert ( idx >= 0 && idx < k_pattern_length );\n+                }\n+#endif\n+                \n+        //  We didn't find anything\n+            return std::make_pair(corpus_last, corpus_last);\n+            }\n+    \n+\n+        void preKmp ( patIter first, patIter last ) {\n+           const difference_type count = std::distance ( first, last );\n+        \n+           difference_type i, j;\n+        \n+           i = 0;\n+           j = skip_[0] = -1;\n+           while (i < count) {\n+              while (j > -1 && first[i] != first[j])\n+                 j = skip_[j];\n+              i++;\n+              j++;\n+              if (first[i] == first[j])\n+                 skip_[i] = skip_[j];\n+              else\n+                 skip_[i] = j;\n+           }\n+        }\n+\n+\n+        void init_skip_table ( patIter first, patIter last ) {\n+            const difference_type count = std::distance ( first, last );\n+    \n+            difference_type j;\n+            skip_ [ 0 ] = -1;\n+            for ( int i = 1; i <= count; ++i ) {\n+                j = skip_ [ i - 1 ];\n+                while ( j >= 0 ) {\n+                    if ( first [ j ] == first [ i - 1 ] )\n+                        break;\n+                    j = skip_ [ j ];\n+                    }\n+                skip_ [ i ] = j + 1;\n+                }\n+            }\n+// \\endcond\n+        };\n+\n+\n+/*  Two ranges as inputs gives us four possibilities; with 2,3,3,4 parameters\n+    Use a bit of TMP to disambiguate the 3-argument templates */\n+\n+/// \\fn knuth_morris_pratt_search ( corpusIter corpus_first, corpusIter corpus_last, \n+///       patIter pat_first, patIter pat_last )\n+/// \\brief Searches the corpus for the pattern.\n+/// \n+/// \\param corpus_first The start of the data to search (Random Access Iterator)\n+/// \\param corpus_last  One past the end of the data to search\n+/// \\param pat_first    The start of the pattern to search for (Random Access Iterator)\n+/// \\param pat_last     One past the end of the data to search for\n+///\n+    template <typename patIter, typename corpusIter>\n+    std::pair<corpusIter, corpusIter> knuth_morris_pratt_search ( \n+                  corpusIter corpus_first, corpusIter corpus_last, \n+                  patIter pat_first, patIter pat_last )\n+    {\n+        knuth_morris_pratt<patIter> kmp ( pat_first, pat_last );\n+        return kmp ( corpus_first, corpus_last );\n+    }\n+\n+    template <typename PatternRange, typename corpusIter>\n+    std::pair<corpusIter, corpusIter> knuth_morris_pratt_search ( \n+        corpusIter corpus_first, corpusIter corpus_last, const PatternRange &pattern )\n+    {\n+        typedef typename boost::range_iterator<const PatternRange>::type pattern_iterator;\n+        knuth_morris_pratt<pattern_iterator> kmp ( boost::begin(pattern), boost::end (pattern));\n+        return kmp ( corpus_first, corpus_last );\n+    }\n+    \n+    template <typename patIter, typename CorpusRange>\n+    typename boost::disable_if_c<\n+        boost::is_same<CorpusRange, patIter>::value, \n+        std::pair<typename boost::range_iterator<CorpusRange>::type, typename boost::range_iterator<CorpusRange>::type> >\n+    ::type\n+    knuth_morris_pratt_search ( CorpusRange &corpus, patIter pat_first, patIter pat_last )\n+    {\n+        knuth_morris_pratt<patIter> kmp ( pat_first, pat_last );\n+        return kmp (boost::begin (corpus), boost::end (corpus));\n+    }\n+    \n+    template <typename PatternRange, typename CorpusRange>\n+    std::pair<typename boost::range_iterator<CorpusRange>::type, typename boost::range_iterator<CorpusRange>::type>\n+    knuth_morris_pratt_search ( CorpusRange &corpus, const PatternRange &pattern )\n+    {\n+        typedef typename boost::range_iterator<const PatternRange>::type pattern_iterator;\n+        knuth_morris_pratt<pattern_iterator> kmp ( boost::begin(pattern), boost::end (pattern));\n+        return kmp (boost::begin (corpus), boost::end (corpus));\n+    }\n+\n+\n+    //  Creator functions -- take a pattern range, return an object\n+    template <typename Range>\n+    boost::algorithm::knuth_morris_pratt<typename boost::range_iterator<const Range>::type>\n+    make_knuth_morris_pratt ( const Range &r ) {\n+        return boost::algorithm::knuth_morris_pratt\n+            <typename boost::range_iterator<const Range>::type> (boost::begin(r), boost::end(r));\n+        }\n+    \n+    template <typename Range>\n+    boost::algorithm::knuth_morris_pratt<typename boost::range_iterator<Range>::type>\n+    make_knuth_morris_pratt ( Range &r ) {\n+        return boost::algorithm::knuth_morris_pratt\n+            <typename boost::range_iterator<Range>::type> (boost::begin(r), boost::end(r));\n+        }\n+}}\n+\n+#endif  // BOOST_ALGORITHM_KNUTH_MORRIS_PRATT_SEARCH_HPP"
      },
      {
        "sha": "700dd6dc89f218f8546a52ae2d49f7661d695e9b",
        "filename": "src/boost/algorithm/sort_subrange.hpp",
        "status": "added",
        "additions": 110,
        "deletions": 0,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/sort_subrange.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/sort_subrange.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/sort_subrange.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,110 @@\n+/* \n+   Copyright (c) Marshall Clow 2008-2012.\n+\n+   Distributed under the Boost Software License, Version 1.0. (See accompanying\n+   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+\n+ Revision history:\n+   28 Sep 2015 mtc First version\n+   \n+*/\n+\n+/// \\file sort_subrange.hpp\n+/// \\brief Sort a subrange\n+/// \\author Marshall Clow\n+///\n+/// Suggested by Sean Parent in his CppCon 2015 keynote\n+\n+#ifndef BOOST_ALGORITHM_SORT_SUBRANGE_HPP\n+#define BOOST_ALGORITHM_SORT_SUBRANGE_HPP\n+\n+#include <functional>       // For std::less\n+#include <iterator>         // For std::iterator_traits\n+#include <algorithm>        // For nth_element and partial_sort\n+\n+#include <boost/config.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+\n+namespace boost { namespace algorithm {\n+\n+/// \\fn sort_subrange ( T const& val, \n+///               Iterator first,     Iterator last, \n+///               Iterator sub_first, Iterator sub_last, \n+///               Pred p )\n+/// \\brief Sort the subrange [sub_first, sub_last) that is inside\n+///     the range [first, last) as if you had sorted the entire range.\n+/// \n+/// \\param first       The start of the larger range\n+/// \\param last        The end of the larger range\n+/// \\param sub_first   The start of the sub range\n+/// \\param sub_last    The end of the sub range\n+/// \\param p           A predicate to use to compare the values.\n+///                        p ( a, b ) returns a boolean.\n+///\n+  template<typename Iterator, typename Pred> \n+  void sort_subrange (\n+  \tIterator first,     Iterator last, \n+  \tIterator sub_first, Iterator sub_last,\n+  \tPred p)\n+  {\n+  \tif (sub_first == sub_last) return; // the empty sub-range is already sorted.\n+  \t\n+  \tif (sub_first != first) { // sub-range is at the start, don't need to partition\n+  \t\t(void) std::nth_element(first, sub_first, last, p);\n+  \t\t++sub_first;\n+  \t\t}\n+  \tstd::partial_sort(sub_first, sub_last, last, p);\n+  }\n+\n+\n+\n+  template<typename Iterator> \n+  void sort_subrange (Iterator first, Iterator last, Iterator sub_first, Iterator sub_last)\n+  {\n+  \ttypedef typename std::iterator_traits<Iterator>::value_type value_type;\n+  \treturn sort_subrange(first, last, sub_first, sub_last, std::less<value_type>());\n+  }\n+\n+/// range versions?\n+\n+\n+/// \\fn partition_subrange ( T const& val, \n+///               Iterator first,     Iterator last, \n+///               Iterator sub_first, Iterator sub_last, \n+///               Pred p )\n+/// \\brief Gather the elements of the subrange [sub_first, sub_last) that is \n+///     inside the range [first, last) as if you had sorted the entire range.\n+/// \n+/// \\param first       The start of the larger range\n+/// \\param last        The end of the larger range\n+/// \\param sub_first   The start of the sub range\n+/// \\param sub_last    The end of the sub range\n+/// \\param p           A predicate to use to compare the values.\n+///                        p ( a, b ) returns a boolean.\n+///\n+  template<typename Iterator, typename Pred> \n+  void partition_subrange (\n+  \tIterator first,     Iterator last, \n+  \tIterator sub_first, Iterator sub_last,\n+  \tPred p)\n+  {\n+  \tif (sub_first != first) {\n+  \t\t(void) std::nth_element(first, sub_first, last, p);\n+  \t\t++sub_first;\n+  \t\t}\n+  \t\n+  \tif (sub_last != last)\n+  \t\t(void) std::nth_element(sub_first, sub_last, last, p);\n+  }\n+\n+  template<typename Iterator> \n+  void partition_subrange (Iterator first, Iterator last, Iterator sub_first, Iterator sub_last)\n+  {\n+  \ttypedef typename std::iterator_traits<Iterator>::value_type value_type;\n+  \treturn partition_subrange(first, last, sub_first, sub_last, std::less<value_type>());\n+  }\n+\n+}}\n+\n+#endif // BOOST_ALGORITHM_SORT_SUBRANGE_HPP"
      },
      {
        "sha": "0771517396465dc1b2d98beb3222159aca9a636a",
        "filename": "src/boost/algorithm/string.hpp",
        "status": "added",
        "additions": 31,
        "deletions": 0,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,31 @@\n+//  Boost string_algo library string_algo.hpp header file  ---------------------------//\n+\n+//  Copyright Pavol Droba 2002-2004.\n+//\n+// Distributed under the Boost Software License, Version 1.0.\n+//    (See accompanying file LICENSE_1_0.txt or copy at\n+//          http://www.boost.org/LICENSE_1_0.txt)\n+\n+//  See http://www.boost.org/ for updates, documentation, and revision history.\n+\n+#ifndef BOOST_STRING_ALGO_HPP\n+#define BOOST_STRING_ALGO_HPP\n+\n+/*! \\file\n+    Cumulative include for string_algo library\n+*/\n+\n+#include <boost/algorithm/string/std_containers_traits.hpp>\n+#include <boost/algorithm/string/trim.hpp>\n+#include <boost/algorithm/string/case_conv.hpp>\n+#include <boost/algorithm/string/predicate.hpp>\n+#include <boost/algorithm/string/find.hpp>\n+#include <boost/algorithm/string/split.hpp>\n+#include <boost/algorithm/string/join.hpp>\n+#include <boost/algorithm/string/replace.hpp>\n+#include <boost/algorithm/string/erase.hpp>\n+#include <boost/algorithm/string/classification.hpp>\n+#include <boost/algorithm/string/find_iterator.hpp>\n+\n+\n+#endif  // BOOST_STRING_ALGO_HPP"
      },
      {
        "sha": "683340b8ec8d7d039dfc1cbfbbf63a6aadc8a448",
        "filename": "src/boost/algorithm/string/case_conv.hpp",
        "status": "added",
        "additions": 176,
        "deletions": 0,
        "changes": 176,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/case_conv.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/case_conv.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/case_conv.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3",
        "patch": "@@ -0,0 +1,176 @@\n+//  Boost string_algo library case_conv.hpp header file  ---------------------------//\n+\n+//  Copyright Pavol Droba 2002-2003.\n+//\n+// Distributed under the Boost Software License, Version 1.0.\n+//    (See accompanying file LICENSE_1_0.txt or copy at\n+//          http://www.boost.org/LICENSE_1_0.txt)\n+\n+//  See http://www.boost.org/ for updates, documentation, and revision history.\n+\n+#ifndef BOOST_STRING_CASE_CONV_HPP\n+#define BOOST_STRING_CASE_CONV_HPP\n+\n+#include <boost/algorithm/string/config.hpp>\n+#include <algorithm>\n+#include <locale>\n+#include <boost/iterator/transform_iterator.hpp>\n+\n+#include <boost/range/as_literal.hpp>\n+#include <boost/range/begin.hpp>\n+#include <boost/range/end.hpp>\n+#include <boost/range/value_type.hpp>\n+\n+#include <boost/algorithm/string/detail/case_conv.hpp>\n+\n+/*! \\file\n+    Defines sequence case-conversion algorithms.\n+    Algorithms convert each element in the input sequence to the\n+    desired case using provided locales.\n+*/\n+\n+namespace boost {\n+    namespace algorithm {\n+\n+//  to_lower  -----------------------------------------------//\n+\n+        //! Convert to lower case\n+        /*!\n+            Each element of the input sequence is converted to lower\n+            case. The result is a copy of the input converted to lower case.\n+            It is returned as a sequence or copied to the output iterator.\n+\n+            \\param Output An output iterator to which the result will be copied\n+            \\param Input An input range\n+            \\param Loc A locale used for conversion\n+            \\return \n+                An output iterator pointing just after the last inserted character or\n+                a copy of the input\n+\n+            \\note The second variant of this function provides the strong exception-safety guarantee\n+                \n+        */\n+        template<typename OutputIteratorT, typename RangeT>\n+        inline OutputIteratorT \n+        to_lower_copy(\n+            OutputIteratorT Output,\n+            const RangeT& Input,\n+            const std::locale& Loc=std::locale())\n+        {\n+            return ::boost::algorithm::detail::transform_range_copy( \n+               Output,\n+               ::boost::as_literal(Input),\n+               ::boost::algorithm::detail::to_lowerF<\n+                    typename range_value<RangeT>::type >(Loc));\n+        }\n+\n+        //! Convert to lower case\n+        /*!\n+            \\overload\n+        */\n+        template<typename SequenceT>\n+        inline SequenceT to_lower_copy( \n+            const SequenceT& Input, \n+            const std::locale& Loc=std::locale())\n+        {\n+            return ::boost::algorithm::detail::transform_range_copy<SequenceT>(\n+                Input,\n+                ::boost::algorithm::detail::to_lowerF<\n+                    typename range_value<SequenceT>::type >(Loc));\n+        }\n+\n+        //! Convert to lower case\n+        /*!\n+            Each element of the input sequence is converted to lower\n+            case. The input sequence is modified in-place.\n+\n+            \\param Input A range\n+            \\param Loc a locale used for conversion\n+        */\n+        template<typename WritableRangeT>\n+        inline void to_lower( \n+            WritableRangeT& Input, \n+            const std::locale& Loc=std::locale())\n+        {\n+            ::boost::algorithm::detail::transform_range(\n+                ::boost::as_literal(Input),\n+                ::boost::algorithm::detail::to_lowerF<\n+                    typename range_value<WritableRangeT>::type >(Loc));\n+        }\n+        \n+//  to_upper  -----------------------------------------------//\n+\n+        //! Convert to upper case\n+        /*!\n+            Each element of the input sequence is converted to upper\n+            case. The result is a copy of the input converted to upper case.\n+            It is returned as a sequence or copied to the output iterator\n+\n+            \\param Output An output iterator to which the result will be copied\n+            \\param Input An input range\n+            \\param Loc A locale used for conversion\n+            \\return \n+                An output iterator pointing just after the last inserted character or\n+                a copy of the input\n+\n+            \\note The second variant of this function provides the strong exception-safety guarantee\n+        */\n+        template<typename OutputIteratorT, typename RangeT>\n+        inline OutputIteratorT \n+        to_upper_copy(\n+            OutputIteratorT Output,\n+            const RangeT& Input,\n+            const std::locale& Loc=std::locale())\n+        {\n+            return ::boost::algorithm::detail::transform_range_copy( \n+               Output,\n+               ::boost::as_literal(Input),\n+               ::boost::algorithm::detail::to_upperF<\n+                    typename range_value<RangeT>::type >(Loc));\n+        }\n+\n+        //! Convert to upper case\n+        /*!\n+            \\overload\n+        */\n+        template<typename SequenceT>\n+        inline SequenceT to_upper_copy( \n+            const SequenceT& Input, \n+            const std::locale& Loc=std::locale())\n+        {\n+            return ::boost::algorithm::detail::transform_range_copy<SequenceT>(\n+                Input,\n+                ::boost::algorithm::detail::to_upperF<\n+                    typename range_value<SequenceT>::type >(Loc));\n+        }\n+\n+        //! Convert to upper case\n+        /*!\n+            Each element of the input sequence is converted to upper\n+            case. The input sequence is modified in-place.\n+\n+            \\param Input An input range\n+            \\param Loc a locale used for conversion\n+        */\n+        template<typename WritableRangeT>\n+        inline void to_upper( \n+            WritableRangeT& Input, \n+            const std::locale& Loc=std::locale())\n+        {\n+            ::boost::algorithm::detail::transform_range(\n+                ::boost::as_literal(Input),\n+                ::boost::algorithm::detail::to_upperF<\n+                    typename range_value<WritableRangeT>::type >(Loc));\n+        }\n+\n+    } // namespace algorithm\n+\n+    // pull names to the boost namespace\n+    using algorithm::to_lower;\n+    using algorithm::to_lower_copy;\n+    using algorithm::to_upper;\n+    using algorithm::to_upper_copy;\n+\n+} // namespace boost\n+\n+#endif  // BOOST_STRING_CASE_CONV_HPP"
      },
      {
        "sha": "ca43602d47207d960ac8ab23152f64c823afc298",
        "filename": "src/boost/algorithm/string/classification.hpp",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/classification.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/classification.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/classification.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "dc34007cf04ce18e4f2a827f29b194a7060115c9",
        "filename": "src/boost/algorithm/string/compare.hpp",
        "status": "added",
        "additions": 199,
        "deletions": 0,
        "changes": 199,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/compare.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/compare.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/compare.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "17e8349596bd3602426ceaa770ee1f338f46f5b4",
        "filename": "src/boost/algorithm/string/concept.hpp",
        "status": "added",
        "additions": 83,
        "deletions": 0,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/concept.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/concept.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/concept.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "559750ac8aaaabf98b236e90cb9d77472f1f5808",
        "filename": "src/boost/algorithm/string/config.hpp",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/config.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/config.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/config.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "6ed70effcae6aa143c0fd4e9f30674ee7e524bf4",
        "filename": "src/boost/algorithm/string/constants.hpp",
        "status": "added",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/constants.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/constants.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/constants.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "188602a1d0e64fa7cc780024e5089c13858f2181",
        "filename": "src/boost/algorithm/string/detail/case_conv.hpp",
        "status": "added",
        "additions": 130,
        "deletions": 0,
        "changes": 130,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/case_conv.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/case_conv.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/detail/case_conv.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "30a37c698eeff1223eb804513590f02a4b8d3fec",
        "filename": "src/boost/algorithm/string/detail/classification.hpp",
        "status": "added",
        "additions": 355,
        "deletions": 0,
        "changes": 355,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/classification.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/classification.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/detail/classification.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "b39875024cf85d41334fcc922a6945a8d20939c5",
        "filename": "src/boost/algorithm/string/detail/find_format.hpp",
        "status": "added",
        "additions": 204,
        "deletions": 0,
        "changes": 204,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/find_format.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/find_format.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/detail/find_format.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "311fa26fff76ade7f370f6b6b36fab87e0ade51e",
        "filename": "src/boost/algorithm/string/detail/find_format_all.hpp",
        "status": "added",
        "additions": 275,
        "deletions": 0,
        "changes": 275,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/find_format_all.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/find_format_all.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/detail/find_format_all.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "b9f4a88d912459d488f17743a77e55cdbfc42387",
        "filename": "src/boost/algorithm/string/detail/find_format_store.hpp",
        "status": "added",
        "additions": 89,
        "deletions": 0,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/find_format_store.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/find_format_store.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/detail/find_format_store.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "4f90a98fc02ef7096be267b04e137af34dcba820",
        "filename": "src/boost/algorithm/string/detail/find_iterator.hpp",
        "status": "added",
        "additions": 87,
        "deletions": 0,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/find_iterator.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/find_iterator.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/detail/find_iterator.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "8e70240dec1b0fbf22a3756ebc50594d72b9b1e8",
        "filename": "src/boost/algorithm/string/detail/finder.hpp",
        "status": "added",
        "additions": 639,
        "deletions": 0,
        "changes": 639,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/finder.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/finder.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/detail/finder.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "9cb01cfaf136b617d0f3b55765d13e35d589076a",
        "filename": "src/boost/algorithm/string/detail/finder_regex.hpp",
        "status": "added",
        "additions": 122,
        "deletions": 0,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/finder_regex.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/finder_regex.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/detail/finder_regex.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "f4c6728b34401d02c012d1b6b5991633c438c4fc",
        "filename": "src/boost/algorithm/string/detail/formatter.hpp",
        "status": "added",
        "additions": 119,
        "deletions": 0,
        "changes": 119,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/formatter.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/formatter.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/detail/formatter.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "5f26407bed8e09d84350f8788913aa3708164376",
        "filename": "src/boost/algorithm/string/detail/formatter_regex.hpp",
        "status": "added",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/formatter_regex.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/formatter_regex.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/detail/formatter_regex.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "5acf3cc6633015b207fb499943fccc06b79145b9",
        "filename": "src/boost/algorithm/string/detail/predicate.hpp",
        "status": "added",
        "additions": 77,
        "deletions": 0,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/predicate.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/predicate.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/detail/predicate.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "db35e4c53be8518a683a1f8c637b1ba2154c7436",
        "filename": "src/boost/algorithm/string/detail/replace_storage.hpp",
        "status": "added",
        "additions": 159,
        "deletions": 0,
        "changes": 159,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/replace_storage.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/replace_storage.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/detail/replace_storage.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "dc47409115f65dd292cb051f3fcfd31a1b446d7f",
        "filename": "src/boost/algorithm/string/detail/sequence.hpp",
        "status": "added",
        "additions": 200,
        "deletions": 0,
        "changes": 200,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/sequence.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/sequence.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/detail/sequence.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "3bb4ef2034e83f3eb4a52222d2963a275ea955d1",
        "filename": "src/boost/algorithm/string/detail/trim.hpp",
        "status": "added",
        "additions": 95,
        "deletions": 0,
        "changes": 95,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/trim.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/trim.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/detail/trim.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "7844b6723cc6154a50a3ffa232cf00f95288e0bd",
        "filename": "src/boost/algorithm/string/detail/util.hpp",
        "status": "added",
        "additions": 107,
        "deletions": 0,
        "changes": 107,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/util.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/detail/util.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/detail/util.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "6883790978323a742bb995206ea9de562f0587d2",
        "filename": "src/boost/algorithm/string/erase.hpp",
        "status": "added",
        "additions": 844,
        "deletions": 0,
        "changes": 844,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/erase.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/erase.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/erase.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "f2c2926b5097b2d2070a0e8b8a5a50a2a2518ff3",
        "filename": "src/boost/algorithm/string/find.hpp",
        "status": "added",
        "additions": 334,
        "deletions": 0,
        "changes": 334,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/find.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/find.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/find.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "4d9315cb17ed6d4892e6fa63c2a09c9cec2b1ce2",
        "filename": "src/boost/algorithm/string/find_format.hpp",
        "status": "added",
        "additions": 286,
        "deletions": 0,
        "changes": 286,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/find_format.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/find_format.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/find_format.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "5a52d92e41b683de2616f4ffbce0515f83f32272",
        "filename": "src/boost/algorithm/string/find_iterator.hpp",
        "status": "added",
        "additions": 388,
        "deletions": 0,
        "changes": 388,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/find_iterator.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/find_iterator.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/find_iterator.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "61f6e4155bca163f8155d7bb02df26ab942c2a97",
        "filename": "src/boost/algorithm/string/finder.hpp",
        "status": "added",
        "additions": 266,
        "deletions": 0,
        "changes": 266,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/finder.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/finder.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/finder.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "0e08ae7b3910b400a611fcf72f96aac20ada9112",
        "filename": "src/boost/algorithm/string/formatter.hpp",
        "status": "added",
        "additions": 119,
        "deletions": 0,
        "changes": 119,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/formatter.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/formatter.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/formatter.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "d76a819896e8cdc735203efca6621f6c31fde68d",
        "filename": "src/boost/algorithm/string/iter_find.hpp",
        "status": "added",
        "additions": 201,
        "deletions": 0,
        "changes": 201,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/iter_find.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/iter_find.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/iter_find.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "b871eb44f6941c25b6f00e70b3d26ec2d28bd3f1",
        "filename": "src/boost/algorithm/string/join.hpp",
        "status": "added",
        "additions": 145,
        "deletions": 0,
        "changes": 145,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/join.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/join.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/join.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "d7c86e8a5a75fe4a79a2a575b65daeee5339bd9e",
        "filename": "src/boost/algorithm/string/predicate.hpp",
        "status": "added",
        "additions": 476,
        "deletions": 0,
        "changes": 476,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/predicate.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/predicate.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/predicate.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "a9753fc2ae61e7d813dbd4528cdddb8c5a55542e",
        "filename": "src/boost/algorithm/string/predicate_facade.hpp",
        "status": "added",
        "additions": 42,
        "deletions": 0,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/predicate_facade.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/predicate_facade.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/predicate_facade.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "a6c7c60ae8dbafbdb8cd7ccb6a671b5ba79f9e49",
        "filename": "src/boost/algorithm/string/regex.hpp",
        "status": "added",
        "additions": 646,
        "deletions": 0,
        "changes": 646,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/regex.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/regex.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/regex.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "409afc2ba0c4ba9192b181e11ad29a0c1a77738e",
        "filename": "src/boost/algorithm/string/regex_find_format.hpp",
        "status": "added",
        "additions": 90,
        "deletions": 0,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/regex_find_format.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/regex_find_format.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/regex_find_format.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "2adb031c59ab07f350527fbcb207dfb5572602de",
        "filename": "src/boost/algorithm/string/replace.hpp",
        "status": "added",
        "additions": 926,
        "deletions": 0,
        "changes": 926,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/replace.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/replace.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/replace.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "be151f8d3d2d52355c017d370ef6926d94b757d5",
        "filename": "src/boost/algorithm/string/sequence_traits.hpp",
        "status": "added",
        "additions": 120,
        "deletions": 0,
        "changes": 120,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/sequence_traits.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/sequence_traits.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/sequence_traits.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "e0b30fb35349eeb4aea4cebe7b529afbff648a9a",
        "filename": "src/boost/algorithm/string/split.hpp",
        "status": "added",
        "additions": 175,
        "deletions": 0,
        "changes": 175,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/split.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/split.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/split.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "a3cf7bb18c5ad2de738819ed775fe4686dd21a3e",
        "filename": "src/boost/algorithm/string/std/list_traits.hpp",
        "status": "added",
        "additions": 68,
        "deletions": 0,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/std/list_traits.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/std/list_traits.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/std/list_traits.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "637059a550457c1cad592c126bd772654a19874e",
        "filename": "src/boost/algorithm/string/std/rope_traits.hpp",
        "status": "added",
        "additions": 81,
        "deletions": 0,
        "changes": 81,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/std/rope_traits.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/std/rope_traits.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/std/rope_traits.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "c30b93c73ad229d27504221fdb71b9d7db589913",
        "filename": "src/boost/algorithm/string/std/slist_traits.hpp",
        "status": "added",
        "additions": 69,
        "deletions": 0,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/std/slist_traits.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/std/slist_traits.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/std/slist_traits.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "c9408307d330cd5ce99df7b43fc816ca893da769",
        "filename": "src/boost/algorithm/string/std/string_traits.hpp",
        "status": "added",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/std/string_traits.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/std/string_traits.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/std/string_traits.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "3f02246fda5a5bae02c75cbb2ca0220bb4a99866",
        "filename": "src/boost/algorithm/string/std_containers_traits.hpp",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/std_containers_traits.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/std_containers_traits.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/std_containers_traits.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "e740d57d933a8fa51af1c6b1d1e0702b5cd90aca",
        "filename": "src/boost/algorithm/string/trim.hpp",
        "status": "added",
        "additions": 398,
        "deletions": 0,
        "changes": 398,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/trim.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/trim.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/trim.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "a616f7f33ea9f8443c748b9915fef6e19d7f3308",
        "filename": "src/boost/algorithm/string/trim_all.hpp",
        "status": "added",
        "additions": 217,
        "deletions": 0,
        "changes": 217,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/trim_all.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/trim_all.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/trim_all.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "b76cc6c155cc940d94142787b7b5ca24f3b37898",
        "filename": "src/boost/algorithm/string/yes_no_type.hpp",
        "status": "added",
        "additions": 33,
        "deletions": 0,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/yes_no_type.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string/yes_no_type.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string/yes_no_type.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "791aa18481c8dc6a3d8083a6b4855ecf4a68a9e5",
        "filename": "src/boost/algorithm/string_regex.hpp",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string_regex.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/algorithm/string_regex.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/algorithm/string_regex.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "45fe36bbcc38bec96985459f181c33e9c061b8f7",
        "filename": "src/boost/align.hpp",
        "status": "added",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "92f0c616b2adf942befc8d532beee324264f7d5b",
        "filename": "src/boost/align/align.hpp",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/align.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/align.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/align.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "932598c0fa13c9052a0246d70f5d5a576ee38568",
        "filename": "src/boost/align/align_down.hpp",
        "status": "added",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/align_down.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/align_down.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/align_down.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "84e1a3cb58752861241ac5bcee1737533ef2bd13",
        "filename": "src/boost/align/align_up.hpp",
        "status": "added",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/align_up.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/align_up.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/align_up.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "1d81a133728dd3bc05af7eadc56f2da5b65e6a80",
        "filename": "src/boost/align/aligned_alloc.hpp",
        "status": "added",
        "additions": 47,
        "deletions": 0,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/aligned_alloc.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/aligned_alloc.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/aligned_alloc.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "193cd4e696b07a405633004b2a91ffcac690e85d",
        "filename": "src/boost/align/aligned_allocator.hpp",
        "status": "added",
        "additions": 140,
        "deletions": 0,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/aligned_allocator.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/aligned_allocator.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/aligned_allocator.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "d352742ed4759867a717ce40128a35ff805c6aab",
        "filename": "src/boost/align/aligned_allocator_adaptor.hpp",
        "status": "added",
        "additions": 170,
        "deletions": 0,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/aligned_allocator_adaptor.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/aligned_allocator_adaptor.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/aligned_allocator_adaptor.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "f762cd1c3aba96232071886a7d29ae5a4f06acb1",
        "filename": "src/boost/align/aligned_allocator_adaptor_forward.hpp",
        "status": "added",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/aligned_allocator_adaptor_forward.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/aligned_allocator_adaptor_forward.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/aligned_allocator_adaptor_forward.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "23add71aaac9743cb2914b9f0c0c3fc2315a9725",
        "filename": "src/boost/align/aligned_allocator_forward.hpp",
        "status": "added",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/aligned_allocator_forward.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/aligned_allocator_forward.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/aligned_allocator_forward.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "385bd557af9bff46faae23ea6923271b6a3ab250",
        "filename": "src/boost/align/aligned_delete.hpp",
        "status": "added",
        "additions": 31,
        "deletions": 0,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/aligned_delete.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/aligned_delete.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/aligned_delete.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "d5b766d7f0a2d9d102a05260d1ffec3f3e42f228",
        "filename": "src/boost/align/aligned_delete_forward.hpp",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/aligned_delete_forward.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/aligned_delete_forward.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/aligned_delete_forward.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "b7c50f1a2ebf455ad15d79e503b5972bfbbe3aa6",
        "filename": "src/boost/align/alignment_of.hpp",
        "status": "added",
        "additions": 54,
        "deletions": 0,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/alignment_of.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/alignment_of.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/alignment_of.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "31db15f23c6e46a829274bbcb9c10166248df6b0",
        "filename": "src/boost/align/alignment_of_forward.hpp",
        "status": "added",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/alignment_of_forward.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/alignment_of_forward.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/alignment_of_forward.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "22e5103654e49d9ffe9814ba6401fb5f6d7026bc",
        "filename": "src/boost/align/assume_aligned.hpp",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/assume_aligned.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/assume_aligned.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/assume_aligned.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "9cb7cde589283fabd121dd306fc45a4efe1b0d2b",
        "filename": "src/boost/align/detail/add_reference.hpp",
        "status": "added",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/add_reference.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/add_reference.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/add_reference.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "77b327a22295909c8c339565318d8c546716f991",
        "filename": "src/boost/align/detail/align.hpp",
        "status": "added",
        "additions": 38,
        "deletions": 0,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/align.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/align.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/align.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "637541ab4088570ef35242b2c0710ea47b4ad1f9",
        "filename": "src/boost/align/detail/align_cxx11.hpp",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/align_cxx11.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/align_cxx11.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/align_cxx11.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "de3c80d06d39d2a373c74cdf5c1fbc5686e2d74a",
        "filename": "src/boost/align/detail/align_down.hpp",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/align_down.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/align_down.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/align_down.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "ac11f8964fb6717331932a7221cd89b1af7ed3c1",
        "filename": "src/boost/align/detail/align_up.hpp",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/align_up.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/align_up.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/align_up.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "d27a54990900d5c59be14b9d250663f9759a5b83",
        "filename": "src/boost/align/detail/aligned_alloc.hpp",
        "status": "added",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/aligned_alloc.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/aligned_alloc.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/aligned_alloc.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "4119fbd9bcef0f4d97fb80f052309faf4030fad9",
        "filename": "src/boost/align/detail/aligned_alloc_android.hpp",
        "status": "added",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/aligned_alloc_android.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/aligned_alloc_android.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/aligned_alloc_android.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "76366fa5c1074173c7a252242dfffadcbfbe579a",
        "filename": "src/boost/align/detail/aligned_alloc_macos.hpp",
        "status": "added",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/aligned_alloc_macos.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/aligned_alloc_macos.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/aligned_alloc_macos.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "36be3d5f1d1974a7107442c4b65380c1a91b5b88",
        "filename": "src/boost/align/detail/aligned_alloc_mingw.hpp",
        "status": "added",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/aligned_alloc_mingw.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/aligned_alloc_mingw.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/aligned_alloc_mingw.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "45c57c9915127ce50b0204979bb7c77799122804",
        "filename": "src/boost/align/detail/aligned_alloc_msvc.hpp",
        "status": "added",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/aligned_alloc_msvc.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/aligned_alloc_msvc.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/aligned_alloc_msvc.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "a97da65d5a4fe7c43aeec83573bc84d2fc3b392f",
        "filename": "src/boost/align/detail/aligned_alloc_new.hpp",
        "status": "added",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/aligned_alloc_new.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/aligned_alloc_new.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/aligned_alloc_new.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "78fc842d205ae2f92dc5a4203a83115cf6b6060e",
        "filename": "src/boost/align/detail/aligned_alloc_posix.hpp",
        "status": "added",
        "additions": 41,
        "deletions": 0,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/aligned_alloc_posix.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/aligned_alloc_posix.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/aligned_alloc_posix.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "0948b40e392251d47343727d39dca199ded0ad90",
        "filename": "src/boost/align/detail/aligned_alloc_sunos.hpp",
        "status": "added",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/aligned_alloc_sunos.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/aligned_alloc_sunos.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/aligned_alloc_sunos.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "b6fc3dcdcf7588d0dfa4b9815cdc401daafb4a6b",
        "filename": "src/boost/align/detail/alignment_of.hpp",
        "status": "added",
        "additions": 31,
        "deletions": 0,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/alignment_of.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/alignment_of.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/alignment_of.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "95773e5ea31019b22ddbd0f0f25e3c84f15d4c09",
        "filename": "src/boost/align/detail/alignment_of_clang.hpp",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/alignment_of_clang.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/alignment_of_clang.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/alignment_of_clang.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "ea6f90424236365752da6485c3d3a59f7c65fb7e",
        "filename": "src/boost/align/detail/alignment_of_codegear.hpp",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/alignment_of_codegear.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/alignment_of_codegear.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/alignment_of_codegear.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "05c7429385ccb097bf04dcbb537af52c3889fe51",
        "filename": "src/boost/align/detail/alignment_of_cxx11.hpp",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/alignment_of_cxx11.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/alignment_of_cxx11.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/alignment_of_cxx11.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "66a63a50b12f97159165a7ac2f97316fe8136d34",
        "filename": "src/boost/align/detail/alignment_of_gcc.hpp",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/alignment_of_gcc.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/alignment_of_gcc.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/alignment_of_gcc.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "440b840db4536cd67982c09eff2bc5e7ef0dce21",
        "filename": "src/boost/align/detail/alignment_of_msvc.hpp",
        "status": "added",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/alignment_of_msvc.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/alignment_of_msvc.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/alignment_of_msvc.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "d218d8c64ede549bb9e9d84c5626cca875abea02",
        "filename": "src/boost/align/detail/assume_aligned.hpp",
        "status": "added",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/assume_aligned.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/assume_aligned.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/assume_aligned.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "4c7159fa28e50845cb5d5f8f7852f72b6eaf911a",
        "filename": "src/boost/align/detail/assume_aligned_clang.hpp",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/assume_aligned_clang.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/assume_aligned_clang.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/assume_aligned_clang.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "117344447aed3b85948f68d21f921c79c258bb8a",
        "filename": "src/boost/align/detail/assume_aligned_gcc.hpp",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/assume_aligned_gcc.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/assume_aligned_gcc.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/assume_aligned_gcc.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "6792ce005ce36463cf2634656765cd1aeeb97291",
        "filename": "src/boost/align/detail/assume_aligned_intel.hpp",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/assume_aligned_intel.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/assume_aligned_intel.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/assume_aligned_intel.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "75ac7e12429975eec5ddc757b9cf7c04fd248fc2",
        "filename": "src/boost/align/detail/assume_aligned_msvc.hpp",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/assume_aligned_msvc.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/assume_aligned_msvc.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/assume_aligned_msvc.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "5b2b732da0a2ce47081813c69776e88d6f42c5dd",
        "filename": "src/boost/align/detail/element_type.hpp",
        "status": "added",
        "additions": 91,
        "deletions": 0,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/element_type.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/element_type.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/element_type.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "a1e0b467aba88acb38fd58067c4dfeca0ec43a21",
        "filename": "src/boost/align/detail/integral_constant.hpp",
        "status": "added",
        "additions": 53,
        "deletions": 0,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/integral_constant.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/integral_constant.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/integral_constant.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "27de0bd521d534bbc10b7c5991506b581bbf9b72",
        "filename": "src/boost/align/detail/is_aligned.hpp",
        "status": "added",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/is_aligned.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/is_aligned.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/is_aligned.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "542fbe46942373050ff657fdf5801c302cf8541b",
        "filename": "src/boost/align/detail/is_alignment.hpp",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/is_alignment.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/is_alignment.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/is_alignment.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "0ded62857ee16c7af100ff5bdc2d13ac6c1baecd",
        "filename": "src/boost/align/detail/is_alignment_constant.hpp",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/is_alignment_constant.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/is_alignment_constant.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/is_alignment_constant.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "9c09fec9c96e11740c1b0b68e6e49f86d1458c47",
        "filename": "src/boost/align/detail/max_align.hpp",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/max_align.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/max_align.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/max_align.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "9fdd30e118701ebf390cc0095547a997aaadb801",
        "filename": "src/boost/align/detail/max_objects.hpp",
        "status": "added",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/max_objects.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/max_objects.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/max_objects.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "22cefdbec552a0684c7b60dd78fb4de3810531d4",
        "filename": "src/boost/align/detail/max_size.hpp",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/max_size.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/max_size.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/max_size.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "5b478fdaf06de69bd8886f3c6aee6f8affb64405",
        "filename": "src/boost/align/detail/min_size.hpp",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/min_size.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/min_size.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/min_size.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "122610182bf08f3c38a73cc22602e59c5a19c114",
        "filename": "src/boost/align/detail/not_pointer.hpp",
        "status": "added",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/not_pointer.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/not_pointer.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/not_pointer.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "e81f2aa48e5a2f29cd30f23d21ebf6bd71ba895c",
        "filename": "src/boost/align/detail/throw_exception.hpp",
        "status": "added",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/throw_exception.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/detail/throw_exception.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/detail/throw_exception.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "a661d580f5cc25602551299d50a11690a13edb23",
        "filename": "src/boost/align/is_aligned.hpp",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/is_aligned.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/align/is_aligned.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/align/is_aligned.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "f400fa9e753f24758abfdf754483a277393f4d68",
        "filename": "src/boost/aligned_storage.hpp",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/aligned_storage.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/aligned_storage.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/aligned_storage.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "a4e598f4e35c361d1d62f18b6f2bab601667aead",
        "filename": "src/boost/any.hpp",
        "status": "added",
        "additions": 344,
        "deletions": 0,
        "changes": 344,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/any.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/any.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/any.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "f33e1ed851b6653934e32fe84dc7978cfe0aac36",
        "filename": "src/boost/any/bad_any_cast.hpp",
        "status": "added",
        "additions": 43,
        "deletions": 0,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/any/bad_any_cast.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/any/bad_any_cast.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/any/bad_any_cast.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "d5a77ef614a28b21e6b52fdaa143f81041e905d2",
        "filename": "src/boost/any/basic_any.hpp",
        "status": "added",
        "additions": 480,
        "deletions": 0,
        "changes": 480,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/any/basic_any.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/any/basic_any.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/any/basic_any.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "78846d64b77d2e27e1aedb86b22c9cffc9d2c017",
        "filename": "src/boost/any/fwd.hpp",
        "status": "added",
        "additions": 40,
        "deletions": 0,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/any/fwd.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/any/fwd.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/any/fwd.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "dd9181c3c1f0ca4e65a5bf15a94f7890ad5d1895",
        "filename": "src/boost/archive/archive_exception.hpp",
        "status": "added",
        "additions": 100,
        "deletions": 0,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/archive_exception.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/archive_exception.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/archive_exception.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "381a1275063dbdfe77df8a00f04f9b517029ecc4",
        "filename": "src/boost/archive/basic_archive.hpp",
        "status": "added",
        "additions": 274,
        "deletions": 0,
        "changes": 274,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_archive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_archive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/basic_archive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "2ec90ce08d987589dd6ae5b03cf51b0b95cdec5b",
        "filename": "src/boost/archive/basic_binary_iarchive.hpp",
        "status": "added",
        "additions": 217,
        "deletions": 0,
        "changes": 217,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_binary_iarchive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_binary_iarchive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/basic_binary_iarchive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "a2902407272d2bac5a4b4f8f17c283f8b270df2e",
        "filename": "src/boost/archive/basic_binary_iprimitive.hpp",
        "status": "added",
        "additions": 197,
        "deletions": 0,
        "changes": 197,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_binary_iprimitive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_binary_iprimitive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/basic_binary_iprimitive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "61bd8faac077916dbfaaedc8ff132df6473b8797",
        "filename": "src/boost/archive/basic_binary_oarchive.hpp",
        "status": "added",
        "additions": 185,
        "deletions": 0,
        "changes": 185,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_binary_oarchive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_binary_oarchive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/basic_binary_oarchive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "6c5e8e5e960f1bac529a8239d6c3a2d9eef222bd",
        "filename": "src/boost/archive/basic_binary_oprimitive.hpp",
        "status": "added",
        "additions": 187,
        "deletions": 0,
        "changes": 187,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_binary_oprimitive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_binary_oprimitive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/basic_binary_oprimitive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "5cd4b36f081c17f5ea0ec31a7bacf38cc8a8ed79",
        "filename": "src/boost/archive/basic_streambuf_locale_saver.hpp",
        "status": "added",
        "additions": 108,
        "deletions": 0,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_streambuf_locale_saver.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_streambuf_locale_saver.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/basic_streambuf_locale_saver.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "d58540d8897dc79adc862c5c3a0288117d389ebb",
        "filename": "src/boost/archive/basic_text_iarchive.hpp",
        "status": "added",
        "additions": 96,
        "deletions": 0,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_text_iarchive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_text_iarchive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/basic_text_iarchive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "606f59f580c31e6e6d158c71a982f1d2a4473fc6",
        "filename": "src/boost/archive/basic_text_iprimitive.hpp",
        "status": "added",
        "additions": 142,
        "deletions": 0,
        "changes": 142,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_text_iprimitive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_text_iprimitive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/basic_text_iprimitive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "37ce33d73d29c7511086fb5ac5dd139f865b01a6",
        "filename": "src/boost/archive/basic_text_oarchive.hpp",
        "status": "added",
        "additions": 119,
        "deletions": 0,
        "changes": 119,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_text_oarchive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_text_oarchive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/basic_text_oarchive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "adc0e896ff59d0e942a0f515fce14e74336960ae",
        "filename": "src/boost/archive/basic_text_oprimitive.hpp",
        "status": "added",
        "additions": 210,
        "deletions": 0,
        "changes": 210,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_text_oprimitive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_text_oprimitive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/basic_text_oprimitive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "546610fa08c42ec9bb8412a9b47abeebaa7cd38f",
        "filename": "src/boost/archive/basic_xml_archive.hpp",
        "status": "added",
        "additions": 67,
        "deletions": 0,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_xml_archive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_xml_archive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/basic_xml_archive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "84c1532f6234f5500ac83586af486e9c08cdad74",
        "filename": "src/boost/archive/basic_xml_iarchive.hpp",
        "status": "added",
        "additions": 119,
        "deletions": 0,
        "changes": 119,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_xml_iarchive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_xml_iarchive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/basic_xml_iarchive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "b2b19cade390d7baeef6d530aab28d3b2c4184f7",
        "filename": "src/boost/archive/basic_xml_oarchive.hpp",
        "status": "added",
        "additions": 138,
        "deletions": 0,
        "changes": 138,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_xml_oarchive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/basic_xml_oarchive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/basic_xml_oarchive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "5052631a38125705b35118b529d70a3c4d16de2d",
        "filename": "src/boost/archive/binary_iarchive.hpp",
        "status": "added",
        "additions": 68,
        "deletions": 0,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/binary_iarchive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/binary_iarchive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/binary_iarchive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "8e97ad12bede134239391625a4a95ae99e449073",
        "filename": "src/boost/archive/binary_iarchive_impl.hpp",
        "status": "added",
        "additions": 101,
        "deletions": 0,
        "changes": 101,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/binary_iarchive_impl.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/binary_iarchive_impl.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/binary_iarchive_impl.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "ba775d5c6b722f7b80895bc7f185609931927bf2",
        "filename": "src/boost/archive/binary_oarchive.hpp",
        "status": "added",
        "additions": 68,
        "deletions": 0,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/binary_oarchive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/binary_oarchive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/binary_oarchive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "d83871122f90f0a3b42e1eac11b2c7d42cbf67c4",
        "filename": "src/boost/archive/binary_oarchive_impl.hpp",
        "status": "added",
        "additions": 102,
        "deletions": 0,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/binary_oarchive_impl.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/binary_oarchive_impl.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/binary_oarchive_impl.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "45a2af56f8768414225afa7b3f7792c103798173",
        "filename": "src/boost/archive/binary_wiarchive.hpp",
        "status": "added",
        "additions": 56,
        "deletions": 0,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/binary_wiarchive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/binary_wiarchive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/binary_wiarchive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "6735ceba6cff4e74839f7166f1c03f09d75e6f2b",
        "filename": "src/boost/archive/binary_woarchive.hpp",
        "status": "added",
        "additions": 59,
        "deletions": 0,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/binary_woarchive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/binary_woarchive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/binary_woarchive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "3905d43ad3b295639170b5026a33d04bf951824a",
        "filename": "src/boost/archive/codecvt_null.hpp",
        "status": "added",
        "additions": 116,
        "deletions": 0,
        "changes": 116,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/codecvt_null.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/codecvt_null.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/codecvt_null.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "b45253b5320b4f3a585fc9bb47b19788ddd6319e",
        "filename": "src/boost/archive/detail/abi_prefix.hpp",
        "status": "added",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/abi_prefix.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/abi_prefix.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/abi_prefix.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "f3307c92e7eec33fbc8b18698fc90334704cba3e",
        "filename": "src/boost/archive/detail/abi_suffix.hpp",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/abi_suffix.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/abi_suffix.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/abi_suffix.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "1e94e258a76ed11bac681af4660bddb20b63eca6",
        "filename": "src/boost/archive/detail/archive_serializer_map.hpp",
        "status": "added",
        "additions": 54,
        "deletions": 0,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/archive_serializer_map.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/archive_serializer_map.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/archive_serializer_map.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "fefd3ab2fb6fd2e4be420120214ea0217d8e00dc",
        "filename": "src/boost/archive/detail/auto_link_archive.hpp",
        "status": "added",
        "additions": 48,
        "deletions": 0,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/auto_link_archive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/auto_link_archive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/auto_link_archive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "4f506864dcf8a0b70857c8d328dbafedf60d2982",
        "filename": "src/boost/archive/detail/auto_link_warchive.hpp",
        "status": "added",
        "additions": 47,
        "deletions": 0,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/auto_link_warchive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/auto_link_warchive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/auto_link_warchive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "a3eb9342f6ab7e6900d43fc01cc7e33d580ccb30",
        "filename": "src/boost/archive/detail/basic_iarchive.hpp",
        "status": "added",
        "additions": 105,
        "deletions": 0,
        "changes": 105,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/basic_iarchive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/basic_iarchive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/basic_iarchive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "98c9c4745ce4e1d597878d6da9b886b9d42a52ff",
        "filename": "src/boost/archive/detail/basic_iserializer.hpp",
        "status": "added",
        "additions": 91,
        "deletions": 0,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/basic_iserializer.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/basic_iserializer.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/basic_iserializer.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "36e80d10b55e138f67fbb1b17101bde58af06c30",
        "filename": "src/boost/archive/detail/basic_oarchive.hpp",
        "status": "added",
        "additions": 94,
        "deletions": 0,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/basic_oarchive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/basic_oarchive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/basic_oarchive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "b3f956776f6f7e72f024f398f6d8acde60789244",
        "filename": "src/boost/archive/detail/basic_oserializer.hpp",
        "status": "added",
        "additions": 89,
        "deletions": 0,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/basic_oserializer.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/basic_oserializer.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/basic_oserializer.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "be805a42ae2594c33e5d081181eaf2ac31fe4818",
        "filename": "src/boost/archive/detail/basic_pointer_iserializer.hpp",
        "status": "added",
        "additions": 70,
        "deletions": 0,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/basic_pointer_iserializer.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/basic_pointer_iserializer.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/basic_pointer_iserializer.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "86376568a0474eade06164e219b2958d0a6e163b",
        "filename": "src/boost/archive/detail/basic_pointer_oserializer.hpp",
        "status": "added",
        "additions": 68,
        "deletions": 0,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/basic_pointer_oserializer.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/basic_pointer_oserializer.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/basic_pointer_oserializer.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "9c2535bf3254a2fe90e65fdc653b686d00403352",
        "filename": "src/boost/archive/detail/basic_serializer.hpp",
        "status": "added",
        "additions": 77,
        "deletions": 0,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/basic_serializer.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/basic_serializer.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/basic_serializer.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "78c6a52d31c2eb48c9600397722dfbf454d02eb4",
        "filename": "src/boost/archive/detail/basic_serializer_map.hpp",
        "status": "added",
        "additions": 69,
        "deletions": 0,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/basic_serializer_map.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/basic_serializer_map.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/basic_serializer_map.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "5bf0a48bb858a6eb3fc47360c1f5c39428d38a28",
        "filename": "src/boost/archive/detail/check.hpp",
        "status": "added",
        "additions": 171,
        "deletions": 0,
        "changes": 171,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/check.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/check.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/check.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "2935e3101e1686c635e59082ef86e57ec67a3592",
        "filename": "src/boost/archive/detail/common_iarchive.hpp",
        "status": "added",
        "additions": 88,
        "deletions": 0,
        "changes": 88,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/common_iarchive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/common_iarchive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/common_iarchive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "fde6066026dfb5886949dfcc12bb7afc1d56ae67",
        "filename": "src/boost/archive/detail/common_oarchive.hpp",
        "status": "added",
        "additions": 89,
        "deletions": 0,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/common_oarchive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/common_oarchive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/common_oarchive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "70555c31fa0baed3440676f76d50f7a5a39d5ddb",
        "filename": "src/boost/archive/detail/decl.hpp",
        "status": "added",
        "additions": 57,
        "deletions": 0,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/decl.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/decl.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/decl.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "edb4125e3088ec4c24855705028fa7ca8e8123ac",
        "filename": "src/boost/archive/detail/helper_collection.hpp",
        "status": "added",
        "additions": 99,
        "deletions": 0,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/helper_collection.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/helper_collection.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/helper_collection.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "5024a4d480591979bf5cfa45f497468732f4878f",
        "filename": "src/boost/archive/detail/interface_iarchive.hpp",
        "status": "added",
        "additions": 85,
        "deletions": 0,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/interface_iarchive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/interface_iarchive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/interface_iarchive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "44b47e61983b0725ed1bd61b439f05f37bad6918",
        "filename": "src/boost/archive/detail/interface_oarchive.hpp",
        "status": "added",
        "additions": 87,
        "deletions": 0,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/interface_oarchive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/interface_oarchive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/interface_oarchive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "b1a9d438bc7cf90f709592365aa40e5c80d4dba1",
        "filename": "src/boost/archive/detail/iserializer.hpp",
        "status": "added",
        "additions": 632,
        "deletions": 0,
        "changes": 632,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/iserializer.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/iserializer.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/iserializer.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "f6a77edfcea409d0cba5059f61c8fafc9fcdef24",
        "filename": "src/boost/archive/detail/oserializer.hpp",
        "status": "added",
        "additions": 547,
        "deletions": 0,
        "changes": 547,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/oserializer.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/oserializer.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/oserializer.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "381c50eba0f11768bc10ab698cd36b601cef8d22",
        "filename": "src/boost/archive/detail/polymorphic_iarchive_route.hpp",
        "status": "added",
        "additions": 218,
        "deletions": 0,
        "changes": 218,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/polymorphic_iarchive_route.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/polymorphic_iarchive_route.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/polymorphic_iarchive_route.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "be67742db466347dce520ccda8768a264516f5d8",
        "filename": "src/boost/archive/detail/polymorphic_oarchive_route.hpp",
        "status": "added",
        "additions": 209,
        "deletions": 0,
        "changes": 209,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/polymorphic_oarchive_route.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/polymorphic_oarchive_route.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/polymorphic_oarchive_route.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "ebc24c05d4672fafdb06a07092c74bf775bd2770",
        "filename": "src/boost/archive/detail/register_archive.hpp",
        "status": "added",
        "additions": 91,
        "deletions": 0,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/register_archive.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/register_archive.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/register_archive.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "5c78548486c069422ccc6a55ff9051e4ae8ee411",
        "filename": "src/boost/archive/detail/utf8_codecvt_facet.hpp",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/utf8_codecvt_facet.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/detail/utf8_codecvt_facet.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/detail/utf8_codecvt_facet.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "97efcea1346e56794b86e523065354e5060d1266",
        "filename": "src/boost/archive/dinkumware.hpp",
        "status": "added",
        "additions": 222,
        "deletions": 0,
        "changes": 222,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/dinkumware.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/dinkumware.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/dinkumware.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "98e058ddeca10d59c456b454ddcad5c3e2a6d746",
        "filename": "src/boost/archive/impl/archive_serializer_map.ipp",
        "status": "added",
        "additions": 75,
        "deletions": 0,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/archive_serializer_map.ipp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/archive_serializer_map.ipp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/impl/archive_serializer_map.ipp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "1755250e5910c1f4e5e51bbfc24a019ef253b69a",
        "filename": "src/boost/archive/impl/basic_binary_iarchive.ipp",
        "status": "added",
        "additions": 134,
        "deletions": 0,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_binary_iarchive.ipp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_binary_iarchive.ipp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/impl/basic_binary_iarchive.ipp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "e2d051080e73d845365f36a75dea771fa9783a02",
        "filename": "src/boost/archive/impl/basic_binary_iprimitive.ipp",
        "status": "added",
        "additions": 173,
        "deletions": 0,
        "changes": 173,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_binary_iprimitive.ipp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_binary_iprimitive.ipp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/impl/basic_binary_iprimitive.ipp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "b83ac619c62c3680e6e90aa18be39f6f8b7cbdc9",
        "filename": "src/boost/archive/impl/basic_binary_oarchive.ipp",
        "status": "added",
        "additions": 42,
        "deletions": 0,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_binary_oarchive.ipp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_binary_oarchive.ipp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/impl/basic_binary_oarchive.ipp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "7b042173a48e94e8185640ed01afda719dbaddb2",
        "filename": "src/boost/archive/impl/basic_binary_oprimitive.ipp",
        "status": "added",
        "additions": 126,
        "deletions": 0,
        "changes": 126,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_binary_oprimitive.ipp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_binary_oprimitive.ipp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/impl/basic_binary_oprimitive.ipp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "3e2def9520554f0d784441ce44cedde7e9fa151c",
        "filename": "src/boost/archive/impl/basic_text_iarchive.ipp",
        "status": "added",
        "additions": 76,
        "deletions": 0,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_text_iarchive.ipp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_text_iarchive.ipp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/impl/basic_text_iarchive.ipp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "cad9c3f8fa48abd89f2d1b433623db5e43f27e01",
        "filename": "src/boost/archive/impl/basic_text_iprimitive.ipp",
        "status": "added",
        "additions": 138,
        "deletions": 0,
        "changes": 138,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_text_iprimitive.ipp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_text_iprimitive.ipp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/impl/basic_text_iprimitive.ipp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "50084ca0a011ee372a8341242e4a19b84409306f",
        "filename": "src/boost/archive/impl/basic_text_oarchive.ipp",
        "status": "added",
        "additions": 62,
        "deletions": 0,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_text_oarchive.ipp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_text_oarchive.ipp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/impl/basic_text_oarchive.ipp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "98a8879ba3a4a76e851636b07c37cc68adf7e677",
        "filename": "src/boost/archive/impl/basic_text_oprimitive.ipp",
        "status": "added",
        "additions": 117,
        "deletions": 0,
        "changes": 117,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_text_oprimitive.ipp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_text_oprimitive.ipp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/impl/basic_text_oprimitive.ipp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "8f70e3d2cffb8fa44c96a947a36b10b845f9aba1",
        "filename": "src/boost/archive/impl/basic_xml_grammar.hpp",
        "status": "added",
        "additions": 173,
        "deletions": 0,
        "changes": 173,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_xml_grammar.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_xml_grammar.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/impl/basic_xml_grammar.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "f7490530e2f0f73e2a8aaaf5df0ed3f8545d004e",
        "filename": "src/boost/archive/impl/basic_xml_iarchive.ipp",
        "status": "added",
        "additions": 114,
        "deletions": 0,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_xml_iarchive.ipp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_xml_iarchive.ipp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/impl/basic_xml_iarchive.ipp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "3184413f3824a92dbeff09762233e9e71038c263",
        "filename": "src/boost/archive/impl/basic_xml_oarchive.ipp",
        "status": "added",
        "additions": 272,
        "deletions": 0,
        "changes": 272,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_xml_oarchive.ipp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/basic_xml_oarchive.ipp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/impl/basic_xml_oarchive.ipp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "a3a80c04de15666220cb8ad848ac9c8f1802c809",
        "filename": "src/boost/archive/impl/text_iarchive_impl.ipp",
        "status": "added",
        "additions": 121,
        "deletions": 0,
        "changes": 121,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/text_iarchive_impl.ipp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/text_iarchive_impl.ipp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/impl/text_iarchive_impl.ipp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "26fbc23adb0e0ef77756ac5604f8c75b8ca59665",
        "filename": "src/boost/archive/impl/text_oarchive_impl.ipp",
        "status": "added",
        "additions": 116,
        "deletions": 0,
        "changes": 116,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/text_oarchive_impl.ipp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/text_oarchive_impl.ipp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/impl/text_oarchive_impl.ipp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "e421fa558da07c9d4d8bba07d49790760e673a4b",
        "filename": "src/boost/archive/impl/text_wiarchive_impl.ipp",
        "status": "added",
        "additions": 116,
        "deletions": 0,
        "changes": 116,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/text_wiarchive_impl.ipp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/text_wiarchive_impl.ipp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/impl/text_wiarchive_impl.ipp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "2b6d427cd3a281b5b7afddabe3a5d638799188b7",
        "filename": "src/boost/archive/impl/text_woarchive_impl.ipp",
        "status": "added",
        "additions": 85,
        "deletions": 0,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/text_woarchive_impl.ipp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/text_woarchive_impl.ipp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/impl/text_woarchive_impl.ipp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "b0847d4a1bc57a0a5e6aac7ce407d595a3a2cf43",
        "filename": "src/boost/archive/impl/xml_iarchive_impl.ipp",
        "status": "added",
        "additions": 196,
        "deletions": 0,
        "changes": 196,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/xml_iarchive_impl.ipp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/xml_iarchive_impl.ipp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/impl/xml_iarchive_impl.ipp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "0f4ccbbf9852ca34e2f1a1065446705a875d0abd",
        "filename": "src/boost/archive/impl/xml_oarchive_impl.ipp",
        "status": "added",
        "additions": 139,
        "deletions": 0,
        "changes": 139,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/xml_oarchive_impl.ipp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/xml_oarchive_impl.ipp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/impl/xml_oarchive_impl.ipp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "198dfafb981fa601d46854f88f63884b71d287a7",
        "filename": "src/boost/archive/impl/xml_wiarchive_impl.ipp",
        "status": "added",
        "additions": 187,
        "deletions": 0,
        "changes": 187,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/xml_wiarchive_impl.ipp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/xml_wiarchive_impl.ipp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/impl/xml_wiarchive_impl.ipp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "dabaf23062c37e9f69f9eed0e9ab56ef2771338c",
        "filename": "src/boost/archive/impl/xml_woarchive_impl.ipp",
        "status": "added",
        "additions": 169,
        "deletions": 0,
        "changes": 169,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/xml_woarchive_impl.ipp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/impl/xml_woarchive_impl.ipp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/impl/xml_woarchive_impl.ipp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "4aa8151c3a661fe91bb54fa0152b10ff38cce31d",
        "filename": "src/boost/archive/iterators/base64_exception.hpp",
        "status": "added",
        "additions": 68,
        "deletions": 0,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/iterators/base64_exception.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/iterators/base64_exception.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/iterators/base64_exception.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "bd0b38fa575ea1e69a3fb5a2c07e70a24063bee3",
        "filename": "src/boost/archive/iterators/base64_from_binary.hpp",
        "status": "added",
        "additions": 109,
        "deletions": 0,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/iterators/base64_from_binary.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/iterators/base64_from_binary.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/iterators/base64_from_binary.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "5aeccb3aabd78e5de233e81c7357adc982a6439f",
        "filename": "src/boost/archive/iterators/binary_from_base64.hpp",
        "status": "added",
        "additions": 118,
        "deletions": 0,
        "changes": 118,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/iterators/binary_from_base64.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/iterators/binary_from_base64.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/iterators/binary_from_base64.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      },
      {
        "sha": "0c69458dab23ad2f5f9137969b01565c53d3948a",
        "filename": "src/boost/archive/iterators/dataflow.hpp",
        "status": "added",
        "additions": 102,
        "deletions": 0,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/iterators/dataflow.hpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2fa164c88e2336e023c464d48cd368aa43b8c3/src/boost/archive/iterators/dataflow.hpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/boost/archive/iterators/dataflow.hpp?ref=0e2fa164c88e2336e023c464d48cd368aa43b8c3"
      }
    ]
  }
]