[
  {
    "sha": "02de6a6bcda8bef4c35eb6c5135529fdf51f0f88",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMmRlNmE2YmNkYThiZWY0YzM1ZWI2YzUxMzU1MjlmZGY1MWYwZjg4",
    "commit": {
      "author": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2018-01-11T23:32:32Z"
      },
      "committer": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2018-03-06T19:21:15Z"
      },
      "message": "Assert cs_main is held when accessing mapBlockIndex",
      "tree": {
        "sha": "8a754d97456d3689349c4f4a74b13cdfb583f7c3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8a754d97456d3689349c4f4a74b13cdfb583f7c3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/02de6a6bcda8bef4c35eb6c5135529fdf51f0f88",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/02de6a6bcda8bef4c35eb6c5135529fdf51f0f88",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/02de6a6bcda8bef4c35eb6c5135529fdf51f0f88",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/02de6a6bcda8bef4c35eb6c5135529fdf51f0f88/comments",
    "author": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "765a3ebb026826f3f4765f5bbc9ed77ee23d67ba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/765a3ebb026826f3f4765f5bbc9ed77ee23d67ba",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/765a3ebb026826f3f4765f5bbc9ed77ee23d67ba"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 8,
      "deletions": 0
    },
    "files": [
      {
        "sha": "18412d9e94c4ba00d42f8470cf7f73299767eaf8",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/02de6a6bcda8bef4c35eb6c5135529fdf51f0f88/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/02de6a6bcda8bef4c35eb6c5135529fdf51f0f88/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=02de6a6bcda8bef4c35eb6c5135529fdf51f0f88",
        "patch": "@@ -260,6 +260,8 @@ namespace {\n \n CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator)\n {\n+    AssertLockHeld(cs_main);\n+\n     // Find the first block the caller has in the main chain\n     for (const uint256& hash : locator.vHave) {\n         BlockMap::iterator mi = mapBlockIndex.find(hash);\n@@ -2774,6 +2776,8 @@ bool ResetBlockFailureFlags(CBlockIndex *pindex) {\n \n CBlockIndex* CChainState::AddToBlockIndex(const CBlockHeader& block)\n {\n+    AssertLockHeld(cs_main);\n+\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n     BlockMap::iterator it = mapBlockIndex.find(hash);\n@@ -3654,6 +3658,8 @@ fs::path GetBlockPosFilename(const CDiskBlockPos &pos, const char *prefix)\n \n CBlockIndex * CChainState::InsertBlockIndex(const uint256& hash)\n {\n+    AssertLockHeld(cs_main);\n+\n     if (hash.IsNull())\n         return nullptr;\n \n@@ -3781,6 +3787,8 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams)\n \n bool LoadChainTip(const CChainParams& chainparams)\n {\n+    AssertLockHeld(cs_main);\n+\n     if (chainActive.Tip() && chainActive.Tip()->GetBlockHash() == pcoinsTip->GetBestBlock()) return true;\n \n     if (pcoinsTip->GetBestBlock().IsNull() && mapBlockIndex.size() == 1) {"
      }
    ]
  },
  {
    "sha": "c651df8b32d82695b497c969bfc9f2b1374081a8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNjUxZGY4YjMyZDgyNjk1YjQ5N2M5NjliZmM5ZjJiMTM3NDA4MWE4",
    "commit": {
      "author": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2018-01-11T23:34:47Z"
      },
      "committer": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2018-03-06T19:21:15Z"
      },
      "message": "Lock cs_main while loading block index in AppInitMain",
      "tree": {
        "sha": "5a401c99f243d6cfc84af803444c2fdd4e0e576a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5a401c99f243d6cfc84af803444c2fdd4e0e576a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c651df8b32d82695b497c969bfc9f2b1374081a8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c651df8b32d82695b497c969bfc9f2b1374081a8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c651df8b32d82695b497c969bfc9f2b1374081a8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c651df8b32d82695b497c969bfc9f2b1374081a8/comments",
    "author": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "02de6a6bcda8bef4c35eb6c5135529fdf51f0f88",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/02de6a6bcda8bef4c35eb6c5135529fdf51f0f88",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/02de6a6bcda8bef4c35eb6c5135529fdf51f0f88"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 9,
      "deletions": 10
    },
    "files": [
      {
        "sha": "fdc2917dcf5df73074665fc5894b7f78ca151104",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 10,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c651df8b32d82695b497c969bfc9f2b1374081a8/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c651df8b32d82695b497c969bfc9f2b1374081a8/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=c651df8b32d82695b497c969bfc9f2b1374081a8",
        "patch": "@@ -1424,6 +1424,8 @@ bool AppInitMain()\n \n         uiInterface.InitMessage(_(\"Loading block index...\"));\n \n+        LOCK(cs_main);\n+\n         nStart = GetTimeMillis();\n         do {\n             try {\n@@ -1532,16 +1534,13 @@ bool AppInitMain()\n                             MIN_BLOCKS_TO_KEEP);\n                     }\n \n-                    {\n-                        LOCK(cs_main);\n-                        CBlockIndex* tip = chainActive.Tip();\n-                        RPCNotifyBlockChange(true, tip);\n-                        if (tip && tip->nTime > GetAdjustedTime() + 2 * 60 * 60) {\n-                            strLoadError = _(\"The block database contains a block which appears to be from the future. \"\n-                                    \"This may be due to your computer's date and time being set incorrectly. \"\n-                                    \"Only rebuild the block database if you are sure that your computer's date and time are correct\");\n-                            break;\n-                        }\n+                    CBlockIndex* tip = chainActive.Tip();\n+                    RPCNotifyBlockChange(true, tip);\n+                    if (tip && tip->nTime > GetAdjustedTime() + 2 * 60 * 60) {\n+                        strLoadError = _(\"The block database contains a block which appears to be from the future. \"\n+                                \"This may be due to your computer's date and time being set incorrectly. \"\n+                                \"Only rebuild the block database if you are sure that your computer's date and time are correct\");\n+                        break;\n                     }\n \n                     if (!CVerifyDB().VerifyDB(chainparams, pcoinsdbview.get(), gArgs.GetArg(\"-checklevel\", DEFAULT_CHECKLEVEL),"
      }
    ]
  },
  {
    "sha": "f814a3e8fa0d99c3d95ae7866c707617a1dd3d4e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmODE0YTNlOGZhMGQ5OWMzZDk1YWU3ODY2YzcwNzYxN2ExZGQzZDRl",
    "commit": {
      "author": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2018-01-11T23:40:43Z"
      },
      "committer": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2018-03-06T19:21:15Z"
      },
      "message": "Fix cs_main lock in LoadExternalBlockFile\n\nWhen accessing mapBlockIndex cs_main must be held.",
      "tree": {
        "sha": "067dcb86e75103e4ef6ced38fbf78d379ab145e4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/067dcb86e75103e4ef6ced38fbf78d379ab145e4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f814a3e8fa0d99c3d95ae7866c707617a1dd3d4e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f814a3e8fa0d99c3d95ae7866c707617a1dd3d4e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f814a3e8fa0d99c3d95ae7866c707617a1dd3d4e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f814a3e8fa0d99c3d95ae7866c707617a1dd3d4e/comments",
    "author": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c651df8b32d82695b497c969bfc9f2b1374081a8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c651df8b32d82695b497c969bfc9f2b1374081a8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c651df8b32d82695b497c969bfc9f2b1374081a8"
      }
    ],
    "stats": {
      "total": 38,
      "additions": 20,
      "deletions": 18
    },
    "files": [
      {
        "sha": "5ccbb49ac3cfdc34052c062a1ceac031510bef23",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 18,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f814a3e8fa0d99c3d95ae7866c707617a1dd3d4e/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f814a3e8fa0d99c3d95ae7866c707617a1dd3d4e/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=f814a3e8fa0d99c3d95ae7866c707617a1dd3d4e",
        "patch": "@@ -4252,26 +4252,28 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n                 blkdat >> block;\n                 nRewind = blkdat.GetPos();\n \n-                // detect out of order blocks, and store them for later\n                 uint256 hash = block.GetHash();\n-                if (hash != chainparams.GetConsensus().hashGenesisBlock && mapBlockIndex.find(block.hashPrevBlock) == mapBlockIndex.end()) {\n-                    LogPrint(BCLog::REINDEX, \"%s: Out of order block %s, parent %s not known\\n\", __func__, hash.ToString(),\n-                            block.hashPrevBlock.ToString());\n-                    if (dbp)\n-                        mapBlocksUnknownParent.insert(std::make_pair(block.hashPrevBlock, *dbp));\n-                    continue;\n-                }\n-\n-                // process in case the block isn't known yet\n-                if (mapBlockIndex.count(hash) == 0 || (mapBlockIndex[hash]->nStatus & BLOCK_HAVE_DATA) == 0) {\n+                {\n                     LOCK(cs_main);\n-                    CValidationState state;\n-                    if (g_chainstate.AcceptBlock(pblock, state, chainparams, nullptr, true, dbp, nullptr))\n-                        nLoaded++;\n-                    if (state.IsError())\n-                        break;\n-                } else if (hash != chainparams.GetConsensus().hashGenesisBlock && mapBlockIndex[hash]->nHeight % 1000 == 0) {\n-                    LogPrint(BCLog::REINDEX, \"Block Import: already had block %s at height %d\\n\", hash.ToString(), mapBlockIndex[hash]->nHeight);\n+                    // detect out of order blocks, and store them for later\n+                    if (hash != chainparams.GetConsensus().hashGenesisBlock && mapBlockIndex.find(block.hashPrevBlock) == mapBlockIndex.end()) {\n+                        LogPrint(BCLog::REINDEX, \"%s: Out of order block %s, parent %s not known\\n\", __func__, hash.ToString(),\n+                                block.hashPrevBlock.ToString());\n+                        if (dbp)\n+                            mapBlocksUnknownParent.insert(std::make_pair(block.hashPrevBlock, *dbp));\n+                        continue;\n+                    }\n+\n+                    // process in case the block isn't known yet\n+                    if (mapBlockIndex.count(hash) == 0 || (mapBlockIndex[hash]->nStatus & BLOCK_HAVE_DATA) == 0) {\n+                        CValidationState state;\n+                        if (g_chainstate.AcceptBlock(pblock, state, chainparams, nullptr, true, dbp, nullptr))\n+                            nLoaded++;\n+                        if (state.IsError())\n+                            break;\n+                    } else if (hash != chainparams.GetConsensus().hashGenesisBlock && mapBlockIndex[hash]->nHeight % 1000 == 0) {\n+                        LogPrint(BCLog::REINDEX, \"Block Import: already had block %s at height %d\\n\", hash.ToString(), mapBlockIndex[hash]->nHeight);\n+                    }\n                 }\n \n                 // Activate the genesis block so normal node progress can continue"
      }
    ]
  },
  {
    "sha": "43a32b739551b5a6cac8102afd52e2b9efc81726",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0M2EzMmI3Mzk1NTFiNWE2Y2FjODEwMmFmZDUyZTJiOWVmYzgxNzI2",
    "commit": {
      "author": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2018-01-12T00:56:27Z"
      },
      "committer": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2018-03-06T19:21:16Z"
      },
      "message": "Add missing cs_lock in CreateWalletFromFile",
      "tree": {
        "sha": "26448f1027b0c25aaa9e59051b4f01e8b600f32b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/26448f1027b0c25aaa9e59051b4f01e8b600f32b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/43a32b739551b5a6cac8102afd52e2b9efc81726",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/43a32b739551b5a6cac8102afd52e2b9efc81726",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/43a32b739551b5a6cac8102afd52e2b9efc81726",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/43a32b739551b5a6cac8102afd52e2b9efc81726/comments",
    "author": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f814a3e8fa0d99c3d95ae7866c707617a1dd3d4e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f814a3e8fa0d99c3d95ae7866c707617a1dd3d4e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f814a3e8fa0d99c3d95ae7866c707617a1dd3d4e"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 2,
      "deletions": 0
    },
    "files": [
      {
        "sha": "78abd7700224689073cc965fd5b6ab2b453d11e0",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43a32b739551b5a6cac8102afd52e2b9efc81726/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43a32b739551b5a6cac8102afd52e2b9efc81726/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=43a32b739551b5a6cac8102afd52e2b9efc81726",
        "patch": "@@ -4017,6 +4017,8 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n     // Try to top up keypool. No-op if the wallet is locked.\n     walletInstance->TopUpKeyPool();\n \n+    LOCK(cs_main);\n+\n     CBlockIndex *pindexRescan = chainActive.Genesis();\n     if (!gArgs.GetBoolArg(\"-rescan\", false))\n     {"
      }
    ]
  },
  {
    "sha": "92fabcd443322dcfdf2b3477515fae79e8647d86",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MmZhYmNkNDQzMzIyZGNmZGYyYjM0Nzc1MTVmYWU3OWU4NjQ3ZDg2",
    "commit": {
      "author": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2018-01-12T00:23:09Z"
      },
      "committer": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2018-03-06T19:52:19Z"
      },
      "message": "Add LookupBlockIndex function",
      "tree": {
        "sha": "5511c22adffa3eaccb75afdd2ec53c81550ff7d3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5511c22adffa3eaccb75afdd2ec53c81550ff7d3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/92fabcd443322dcfdf2b3477515fae79e8647d86",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/92fabcd443322dcfdf2b3477515fae79e8647d86",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/92fabcd443322dcfdf2b3477515fae79e8647d86",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/92fabcd443322dcfdf2b3477515fae79e8647d86/comments",
    "author": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "43a32b739551b5a6cac8102afd52e2b9efc81726",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/43a32b739551b5a6cac8102afd52e2b9efc81726",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/43a32b739551b5a6cac8102afd52e2b9efc81726"
      }
    ],
    "stats": {
      "total": 272,
      "additions": 139,
      "deletions": 133
    },
    "files": [
      {
        "sha": "816d854db34467bd9289cbdbeb8378e1c193f18c",
        "filename": "src/checkpoints.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92fabcd443322dcfdf2b3477515fae79e8647d86/src/checkpoints.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92fabcd443322dcfdf2b3477515fae79e8647d86/src/checkpoints.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkpoints.cpp?ref=92fabcd443322dcfdf2b3477515fae79e8647d86",
        "patch": "@@ -21,9 +21,10 @@ namespace Checkpoints {\n         for (const MapCheckpoints::value_type& i : reverse_iterate(checkpoints))\n         {\n             const uint256& hash = i.second;\n-            BlockMap::const_iterator t = mapBlockIndex.find(hash);\n-            if (t != mapBlockIndex.end())\n-                return t->second;\n+            CBlockIndex* pindex = LookupBlockIndex(hash);\n+            if (pindex) {\n+                return pindex;\n+            }\n         }\n         return nullptr;\n     }"
      },
      {
        "sha": "564b48639318b2fd59dc9d9de04234a141946cb1",
        "filename": "src/checkpoints.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92fabcd443322dcfdf2b3477515fae79e8647d86/src/checkpoints.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92fabcd443322dcfdf2b3477515fae79e8647d86/src/checkpoints.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkpoints.h?ref=92fabcd443322dcfdf2b3477515fae79e8647d86",
        "patch": "@@ -19,7 +19,7 @@ struct CCheckpointData;\n namespace Checkpoints\n {\n \n-//! Returns last CBlockIndex* in mapBlockIndex that is a checkpoint\n+//! Returns last CBlockIndex* that is a checkpoint\n CBlockIndex* GetLastCheckpoint(const CCheckpointData& data);\n \n } //namespace Checkpoints"
      },
      {
        "sha": "269cd5c7fadd35419d29141cae324e9fb0413898",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92fabcd443322dcfdf2b3477515fae79e8647d86/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92fabcd443322dcfdf2b3477515fae79e8647d86/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=92fabcd443322dcfdf2b3477515fae79e8647d86",
        "patch": "@@ -1459,8 +1459,9 @@ bool AppInitMain()\n \n                 // If the loaded chain has a wrong genesis, bail out immediately\n                 // (we're likely using a testnet datadir, or the other way around).\n-                if (!mapBlockIndex.empty() && mapBlockIndex.count(chainparams.GetConsensus().hashGenesisBlock) == 0)\n+                if (!mapBlockIndex.empty() && !LookupBlockIndex(chainparams.GetConsensus().hashGenesisBlock)) {\n                     return InitError(_(\"Incorrect or no genesis block found. Wrong datadir for network?\"));\n+                }\n \n                 // Check for changed -txindex state\n                 if (fTxIndex != gArgs.GetBoolArg(\"-txindex\", DEFAULT_TXINDEX)) {"
      },
      {
        "sha": "96c330db038925438e764c0aa9cd0c11f3015b80",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 42,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92fabcd443322dcfdf2b3477515fae79e8647d86/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92fabcd443322dcfdf2b3477515fae79e8647d86/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=92fabcd443322dcfdf2b3477515fae79e8647d86",
        "patch": "@@ -374,10 +374,11 @@ void ProcessBlockAvailability(NodeId nodeid) {\n     assert(state != nullptr);\n \n     if (!state->hashLastUnknownBlock.IsNull()) {\n-        BlockMap::iterator itOld = mapBlockIndex.find(state->hashLastUnknownBlock);\n-        if (itOld != mapBlockIndex.end() && itOld->second->nChainWork > 0) {\n-            if (state->pindexBestKnownBlock == nullptr || itOld->second->nChainWork >= state->pindexBestKnownBlock->nChainWork)\n-                state->pindexBestKnownBlock = itOld->second;\n+        const CBlockIndex* pindex = LookupBlockIndex(state->hashLastUnknownBlock);\n+        if (pindex && pindex->nChainWork > 0) {\n+            if (state->pindexBestKnownBlock == nullptr || pindex->nChainWork >= state->pindexBestKnownBlock->nChainWork) {\n+                state->pindexBestKnownBlock = pindex;\n+            }\n             state->hashLastUnknownBlock.SetNull();\n         }\n     }\n@@ -390,11 +391,12 @@ void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n \n     ProcessBlockAvailability(nodeid);\n \n-    BlockMap::iterator it = mapBlockIndex.find(hash);\n-    if (it != mapBlockIndex.end() && it->second->nChainWork > 0) {\n+    const CBlockIndex* pindex = LookupBlockIndex(hash);\n+    if (pindex && pindex->nChainWork > 0) {\n         // An actually better block was announced.\n-        if (state->pindexBestKnownBlock == nullptr || it->second->nChainWork >= state->pindexBestKnownBlock->nChainWork)\n-            state->pindexBestKnownBlock = it->second;\n+        if (state->pindexBestKnownBlock == nullptr || pindex->nChainWork >= state->pindexBestKnownBlock->nChainWork) {\n+            state->pindexBestKnownBlock = pindex;\n+        }\n     } else {\n         // An unknown block was announced; just assume that the latest one is the best one.\n         state->hashLastUnknownBlock = hash;\n@@ -989,7 +991,7 @@ bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n         }\n     case MSG_BLOCK:\n     case MSG_WITNESS_BLOCK:\n-        return mapBlockIndex.count(inv.hash);\n+        return LookupBlockIndex(inv.hash) != nullptr;\n     }\n     // Don't know what it is, just say we already got one\n     return true;\n@@ -1056,11 +1058,10 @@ void static ProcessGetBlockData(CNode* pfrom, const Consensus::Params& consensus\n     bool need_activate_chain = false;\n     {\n         LOCK(cs_main);\n-        BlockMap::iterator mi = mapBlockIndex.find(inv.hash);\n-        if (mi != mapBlockIndex.end())\n-        {\n-            if (mi->second->nChainTx && !mi->second->IsValid(BLOCK_VALID_SCRIPTS) &&\n-                    mi->second->IsValid(BLOCK_VALID_TREE)) {\n+        const CBlockIndex* pindex = LookupBlockIndex(inv.hash);\n+        if (pindex) {\n+            if (pindex->nChainTx && !pindex->IsValid(BLOCK_VALID_SCRIPTS) &&\n+                    pindex->IsValid(BLOCK_VALID_TREE)) {\n                 // If we have the block and all of its parents, but have not yet validated it,\n                 // we might be in the middle of connecting it (ie in the unlock of cs_main\n                 // before ActivateBestChain but after AcceptBlock).\n@@ -1076,17 +1077,17 @@ void static ProcessGetBlockData(CNode* pfrom, const Consensus::Params& consensus\n     }\n \n     LOCK(cs_main);\n-    BlockMap::iterator mi = mapBlockIndex.find(inv.hash);\n-    if (mi != mapBlockIndex.end()) {\n-        send = BlockRequestAllowed(mi->second, consensusParams);\n+    const CBlockIndex* pindex = LookupBlockIndex(inv.hash);\n+    if (pindex) {\n+        send = BlockRequestAllowed(pindex, consensusParams);\n         if (!send) {\n             LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block that isn't in the main chain\\n\", __func__, pfrom->GetId());\n         }\n     }\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n     // disconnect node in case we have reached the outbound limit for serving historical blocks\n     // never disconnect whitelisted nodes\n-    if (send && connman->OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n+    if (send && connman->OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n     {\n         LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n \n@@ -1096,7 +1097,7 @@ void static ProcessGetBlockData(CNode* pfrom, const Consensus::Params& consensus\n     }\n     // Avoid leaking prune-height by never sending blocks below the NODE_NETWORK_LIMITED threshold\n     if (send && !pfrom->fWhitelisted && (\n-            (((pfrom->GetLocalServices() & NODE_NETWORK_LIMITED) == NODE_NETWORK_LIMITED) && ((pfrom->GetLocalServices() & NODE_NETWORK) != NODE_NETWORK) && (chainActive.Tip()->nHeight - mi->second->nHeight > (int)NODE_NETWORK_LIMITED_MIN_BLOCKS + 2 /* add two blocks buffer extension for possible races */) )\n+            (((pfrom->GetLocalServices() & NODE_NETWORK_LIMITED) == NODE_NETWORK_LIMITED) && ((pfrom->GetLocalServices() & NODE_NETWORK) != NODE_NETWORK) && (chainActive.Tip()->nHeight - pindex->nHeight > (int)NODE_NETWORK_LIMITED_MIN_BLOCKS + 2 /* add two blocks buffer extension for possible races */) )\n        )) {\n         LogPrint(BCLog::NET, \"Ignore block request below NODE_NETWORK_LIMITED threshold from peer=%d\\n\", pfrom->GetId());\n \n@@ -1106,15 +1107,15 @@ void static ProcessGetBlockData(CNode* pfrom, const Consensus::Params& consensus\n     }\n     // Pruned nodes may have deleted the block, so check whether\n     // it's available before trying to send.\n-    if (send && (mi->second->nStatus & BLOCK_HAVE_DATA))\n+    if (send && (pindex->nStatus & BLOCK_HAVE_DATA))\n     {\n         std::shared_ptr<const CBlock> pblock;\n-        if (a_recent_block && a_recent_block->GetHash() == (*mi).second->GetBlockHash()) {\n+        if (a_recent_block && a_recent_block->GetHash() == pindex->GetBlockHash()) {\n             pblock = a_recent_block;\n         } else {\n             // Send block from disk\n             std::shared_ptr<CBlock> pblockRead = std::make_shared<CBlock>();\n-            if (!ReadBlockFromDisk(*pblockRead, (*mi).second, consensusParams))\n+            if (!ReadBlockFromDisk(*pblockRead, pindex, consensusParams))\n                 assert(!\"cannot load block from disk\");\n             pblock = pblockRead;\n         }\n@@ -1156,8 +1157,8 @@ void static ProcessGetBlockData(CNode* pfrom, const Consensus::Params& consensus\n             // instead we respond with the full, non-compact block.\n             bool fPeerWantsWitness = State(pfrom->GetId())->fWantsCmpctWitness;\n             int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n-            if (CanDirectFetch(consensusParams) && mi->second->nHeight >= chainActive.Height() - MAX_CMPCTBLOCK_DEPTH) {\n-                if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == mi->second->GetBlockHash()) {\n+            if (CanDirectFetch(consensusParams) && pindex->nHeight >= chainActive.Height() - MAX_CMPCTBLOCK_DEPTH) {\n+                if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == pindex->GetBlockHash()) {\n                     connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n                 } else {\n                     CBlockHeaderAndShortTxIDs cmpctblock(*pblock, fPeerWantsWitness);\n@@ -1297,7 +1298,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n         //   don't connect before giving DoS points\n         // - Once a headers message is received that is valid and does connect,\n         //   nUnconnectingHeaders gets reset back to 0.\n-        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end() && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n+        if (!LookupBlockIndex(headers[0].hashPrevBlock) && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n             nodestate->nUnconnectingHeaders++;\n             connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n             LogPrint(BCLog::NET, \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n@@ -1327,7 +1328,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n \n         // If we don't have the last header, then they'll have given us\n         // something new (if these headers are valid).\n-        if (mapBlockIndex.find(hashLastBlock) == mapBlockIndex.end()) {\n+        if (!LookupBlockIndex(hashLastBlock)) {\n             received_new_header = true;\n         }\n     }\n@@ -1343,7 +1344,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n             } else {\n                 LogPrint(BCLog::NET, \"peer=%d: invalid header received\\n\", pfrom->GetId());\n             }\n-            if (punish_duplicate_invalid && mapBlockIndex.find(first_invalid_header.GetHash()) != mapBlockIndex.end()) {\n+            if (punish_duplicate_invalid && LookupBlockIndex(first_invalid_header.GetHash())) {\n                 // Goal: don't allow outbound peers to use up our outbound\n                 // connection slots if they are on incompatible chains.\n                 //\n@@ -2024,13 +2025,13 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         LOCK(cs_main);\n \n-        BlockMap::iterator it = mapBlockIndex.find(req.blockhash);\n-        if (it == mapBlockIndex.end() || !(it->second->nStatus & BLOCK_HAVE_DATA)) {\n+        const CBlockIndex* pindex = LookupBlockIndex(req.blockhash);\n+        if (!pindex || !(pindex->nStatus & BLOCK_HAVE_DATA)) {\n             LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block we don't have\", pfrom->GetId());\n             return true;\n         }\n \n-        if (it->second->nHeight < chainActive.Height() - MAX_BLOCKTXN_DEPTH) {\n+        if (pindex->nHeight < chainActive.Height() - MAX_BLOCKTXN_DEPTH) {\n             // If an older block is requested (should never happen in practice,\n             // but can happen in tests) send a block response instead of a\n             // blocktxn response. Sending a full block response instead of a\n@@ -2048,7 +2049,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n \n         CBlock block;\n-        bool ret = ReadBlockFromDisk(block, it->second, chainparams.GetConsensus());\n+        bool ret = ReadBlockFromDisk(block, pindex, chainparams.GetConsensus());\n         assert(ret);\n \n         SendBlockTransactions(block, req, pfrom, connman);\n@@ -2072,10 +2073,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (locator.IsNull())\n         {\n             // If locator is null, return the hashStop block\n-            BlockMap::iterator mi = mapBlockIndex.find(hashStop);\n-            if (mi == mapBlockIndex.end())\n+            pindex = LookupBlockIndex(hashStop);\n+            if (!pindex) {\n                 return true;\n-            pindex = (*mi).second;\n+            }\n \n             if (!BlockRequestAllowed(pindex, chainparams.GetConsensus())) {\n                 LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block header that isn't in the main chain\\n\", __func__, pfrom->GetId());\n@@ -2314,14 +2315,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         {\n         LOCK(cs_main);\n \n-        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+        if (!LookupBlockIndex(cmpctblock.header.hashPrevBlock)) {\n             // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n             if (!IsInitialBlockDownload())\n                 connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n             return true;\n         }\n \n-        if (mapBlockIndex.find(cmpctblock.header.GetHash()) == mapBlockIndex.end()) {\n+        if (!LookupBlockIndex(cmpctblock.header.GetHash())) {\n             received_new_header = true;\n         }\n         }\n@@ -3303,9 +3304,8 @@ bool PeerLogicValidation::SendMessages(CNode* pto, std::atomic<bool>& interruptM\n                 // then send all headers past that one.  If we come across any\n                 // headers that aren't on chainActive, give up.\n                 for (const uint256 &hash : pto->vBlockHashesToAnnounce) {\n-                    BlockMap::iterator mi = mapBlockIndex.find(hash);\n-                    assert(mi != mapBlockIndex.end());\n-                    const CBlockIndex *pindex = mi->second;\n+                    const CBlockIndex* pindex = LookupBlockIndex(hash);\n+                    assert(pindex);\n                     if (chainActive[pindex->nHeight] != pindex) {\n                         // Bail out if we reorged away from this block\n                         fRevertToInv = true;\n@@ -3396,9 +3396,8 @@ bool PeerLogicValidation::SendMessages(CNode* pto, std::atomic<bool>& interruptM\n                 // in the past.\n                 if (!pto->vBlockHashesToAnnounce.empty()) {\n                     const uint256 &hashToAnnounce = pto->vBlockHashesToAnnounce.back();\n-                    BlockMap::iterator mi = mapBlockIndex.find(hashToAnnounce);\n-                    assert(mi != mapBlockIndex.end());\n-                    const CBlockIndex *pindex = mi->second;\n+                    const CBlockIndex* pindex = LookupBlockIndex(hashToAnnounce);\n+                    assert(pindex);\n \n                     // Warn if we're announcing a block that is not on the main chain.\n                     // This should be very rare and could be optimized out."
      },
      {
        "sha": "869f5da64873cfb48f4a8a44f0527c8e11f8253d",
        "filename": "src/qt/transactionrecord.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92fabcd443322dcfdf2b3477515fae79e8647d86/src/qt/transactionrecord.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92fabcd443322dcfdf2b3477515fae79e8647d86/src/qt/transactionrecord.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.cpp?ref=92fabcd443322dcfdf2b3477515fae79e8647d86",
        "patch": "@@ -167,10 +167,7 @@ void TransactionRecord::updateStatus(const CWalletTx &wtx)\n     // Determine transaction status\n \n     // Find the block the tx is in\n-    CBlockIndex* pindex = nullptr;\n-    BlockMap::iterator mi = mapBlockIndex.find(wtx.hashBlock);\n-    if (mi != mapBlockIndex.end())\n-        pindex = (*mi).second;\n+    const CBlockIndex* pindex = LookupBlockIndex(wtx.hashBlock);\n \n     // Sort order, unrecorded transactions sort to the top\n     status.sortKey = strprintf(\"%010d-%01d-%010u-%03d\","
      },
      {
        "sha": "f47b40343b1390b107d9fd06c2247e48e8492270",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92fabcd443322dcfdf2b3477515fae79e8647d86/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92fabcd443322dcfdf2b3477515fae79e8647d86/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=92fabcd443322dcfdf2b3477515fae79e8647d86",
        "patch": "@@ -147,8 +147,7 @@ static bool rest_headers(HTTPRequest* req,\n     headers.reserve(count);\n     {\n         LOCK(cs_main);\n-        BlockMap::const_iterator it = mapBlockIndex.find(hash);\n-        const CBlockIndex *pindex = (it != mapBlockIndex.end()) ? it->second : nullptr;\n+        const CBlockIndex* pindex = LookupBlockIndex(hash);\n         while (pindex != nullptr && chainActive.Contains(pindex)) {\n             headers.push_back(pindex);\n             if (headers.size() == (unsigned long)count)\n@@ -212,10 +211,11 @@ static bool rest_block(HTTPRequest* req,\n     CBlockIndex* pblockindex = nullptr;\n     {\n         LOCK(cs_main);\n-        if (mapBlockIndex.count(hash) == 0)\n+        pblockindex = LookupBlockIndex(hash);\n+        if (!pblockindex) {\n             return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not found\");\n+        }\n \n-        pblockindex = mapBlockIndex[hash];\n         if (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0)\n             return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not available (pruned data)\");\n "
      },
      {
        "sha": "8fb69f53510c2e322552c73f56029befe41c1b1b",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 19,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92fabcd443322dcfdf2b3477515fae79e8647d86/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92fabcd443322dcfdf2b3477515fae79e8647d86/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=92fabcd443322dcfdf2b3477515fae79e8647d86",
        "patch": "@@ -697,10 +697,10 @@ UniValue getblockheader(const JSONRPCRequest& request)\n     if (!request.params[1].isNull())\n         fVerbose = request.params[1].get_bool();\n \n-    if (mapBlockIndex.count(hash) == 0)\n+    const CBlockIndex* pblockindex = LookupBlockIndex(hash);\n+    if (!pblockindex) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n-\n-    CBlockIndex* pblockindex = mapBlockIndex[hash];\n+    }\n \n     if (!fVerbose)\n     {\n@@ -776,12 +776,12 @@ UniValue getblock(const JSONRPCRequest& request)\n             verbosity = request.params[1].get_bool() ? 1 : 0;\n     }\n \n-    if (mapBlockIndex.count(hash) == 0)\n+    const CBlockIndex* pblockindex = LookupBlockIndex(hash);\n+    if (!pblockindex) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n+    }\n \n     CBlock block;\n-    CBlockIndex* pblockindex = mapBlockIndex[hash];\n-\n     if (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0)\n         throw JSONRPCError(RPC_MISC_ERROR, \"Block not available (pruned data)\");\n \n@@ -846,7 +846,7 @@ static bool GetUTXOStats(CCoinsView *view, CCoinsStats &stats)\n     stats.hashBlock = pcursor->GetBestBlock();\n     {\n         LOCK(cs_main);\n-        stats.nHeight = mapBlockIndex.find(stats.hashBlock)->second->nHeight;\n+        stats.nHeight = LookupBlockIndex(stats.hashBlock)->nHeight;\n     }\n     ss << stats.hashBlock;\n     uint256 prevkey;\n@@ -1029,8 +1029,7 @@ UniValue gettxout(const JSONRPCRequest& request)\n         }\n     }\n \n-    BlockMap::iterator it = mapBlockIndex.find(pcoinsTip->GetBestBlock());\n-    CBlockIndex *pindex = it->second;\n+    const CBlockIndex* pindex = LookupBlockIndex(pcoinsTip->GetBestBlock());\n     ret.pushKV(\"bestblock\", pindex->GetBlockHash().GetHex());\n     if (coin.nHeight == MEMPOOL_HEIGHT) {\n         ret.pushKV(\"confirmations\", 0);\n@@ -1424,10 +1423,10 @@ UniValue preciousblock(const JSONRPCRequest& request)\n \n     {\n         LOCK(cs_main);\n-        if (mapBlockIndex.count(hash) == 0)\n+        pblockindex = LookupBlockIndex(hash);\n+        if (!pblockindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n-\n-        pblockindex = mapBlockIndex[hash];\n+        }\n     }\n \n     CValidationState state;\n@@ -1460,10 +1459,11 @@ UniValue invalidateblock(const JSONRPCRequest& request)\n \n     {\n         LOCK(cs_main);\n-        if (mapBlockIndex.count(hash) == 0)\n+        CBlockIndex* pblockindex = LookupBlockIndex(hash);\n+        if (!pblockindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n+        }\n \n-        CBlockIndex* pblockindex = mapBlockIndex[hash];\n         InvalidateBlock(state, Params(), pblockindex);\n     }\n \n@@ -1498,10 +1498,11 @@ UniValue reconsiderblock(const JSONRPCRequest& request)\n \n     {\n         LOCK(cs_main);\n-        if (mapBlockIndex.count(hash) == 0)\n+        CBlockIndex* pblockindex = LookupBlockIndex(hash);\n+        if (!pblockindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n+        }\n \n-        CBlockIndex* pblockindex = mapBlockIndex[hash];\n         ResetBlockFailureFlags(pblockindex);\n     }\n \n@@ -1548,11 +1549,10 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     } else {\n         uint256 hash = uint256S(request.params[1].get_str());\n         LOCK(cs_main);\n-        auto it = mapBlockIndex.find(hash);\n-        if (it == mapBlockIndex.end()) {\n+        pindex = LookupBlockIndex(hash);\n+        if (!pindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         }\n-        pindex = it->second;\n         if (!chainActive.Contains(pindex)) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Block is not in main chain\");\n         }"
      },
      {
        "sha": "d8f3c40ba426889bf43335532073523dc7ae7687",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 9,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92fabcd443322dcfdf2b3477515fae79e8647d86/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92fabcd443322dcfdf2b3477515fae79e8647d86/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=92fabcd443322dcfdf2b3477515fae79e8647d86",
        "patch": "@@ -396,9 +396,8 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n                 throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Block decode failed\");\n \n             uint256 hash = block.GetHash();\n-            BlockMap::iterator mi = mapBlockIndex.find(hash);\n-            if (mi != mapBlockIndex.end()) {\n-                CBlockIndex *pindex = mi->second;\n+            const CBlockIndex* pindex = LookupBlockIndex(hash);\n+            if (pindex) {\n                 if (pindex->IsValid(BLOCK_VALID_SCRIPTS))\n                     return \"duplicate\";\n                 if (pindex->nStatus & BLOCK_FAILED_MASK)\n@@ -727,9 +726,8 @@ UniValue submitblock(const JSONRPCRequest& request)\n     bool fBlockPresent = false;\n     {\n         LOCK(cs_main);\n-        BlockMap::iterator mi = mapBlockIndex.find(hash);\n-        if (mi != mapBlockIndex.end()) {\n-            CBlockIndex *pindex = mi->second;\n+        const CBlockIndex* pindex = LookupBlockIndex(hash);\n+        if (pindex) {\n             if (pindex->IsValid(BLOCK_VALID_SCRIPTS)) {\n                 return \"duplicate\";\n             }\n@@ -743,9 +741,9 @@ UniValue submitblock(const JSONRPCRequest& request)\n \n     {\n         LOCK(cs_main);\n-        BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n-        if (mi != mapBlockIndex.end()) {\n-            UpdateUncommittedBlockStructures(block, mi->second, Params().GetConsensus());\n+        const CBlockIndex* pindex = LookupBlockIndex(block.hashPrevBlock);\n+        if (pindex) {\n+            UpdateUncommittedBlockStructures(block, pindex, Params().GetConsensus());\n         }\n     }\n "
      },
      {
        "sha": "38ec464ee4760267bd69ff26be8e70bba800fb25",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 11,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92fabcd443322dcfdf2b3477515fae79e8647d86/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92fabcd443322dcfdf2b3477515fae79e8647d86/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=92fabcd443322dcfdf2b3477515fae79e8647d86",
        "patch": "@@ -48,9 +48,8 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n \n     if (!hashBlock.IsNull()) {\n         entry.pushKV(\"blockhash\", hashBlock.GetHex());\n-        BlockMap::iterator mi = mapBlockIndex.find(hashBlock);\n-        if (mi != mapBlockIndex.end() && (*mi).second) {\n-            CBlockIndex* pindex = (*mi).second;\n+        CBlockIndex* pindex = LookupBlockIndex(hashBlock);\n+        if (pindex) {\n             if (chainActive.Contains(pindex)) {\n                 entry.pushKV(\"confirmations\", 1 + chainActive.Height() - pindex->nHeight);\n                 entry.pushKV(\"time\", pindex->GetBlockTime());\n@@ -160,11 +159,10 @@ UniValue getrawtransaction(const JSONRPCRequest& request)\n \n     if (!request.params[2].isNull()) {\n         uint256 blockhash = ParseHashV(request.params[2], \"parameter 3\");\n-        BlockMap::iterator it = mapBlockIndex.find(blockhash);\n-        if (it == mapBlockIndex.end()) {\n+        blockindex = LookupBlockIndex(blockhash);\n+        if (!blockindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block hash not found\");\n         }\n-        blockindex = it->second;\n         in_active_chain = chainActive.Contains(blockindex);\n     }\n \n@@ -238,9 +236,10 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n     if (!request.params[1].isNull())\n     {\n         hashBlock = uint256S(request.params[1].get_str());\n-        if (!mapBlockIndex.count(hashBlock))\n+        pblockindex = LookupBlockIndex(hashBlock);\n+        if (!pblockindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n-        pblockindex = mapBlockIndex[hashBlock];\n+        }\n     } else {\n         // Loop through txids and try to find which block they're in. Exit loop once a block is found.\n         for (const auto& tx : setTxids) {\n@@ -257,9 +256,10 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n         CTransactionRef tx;\n         if (!GetTransaction(oneTxid, tx, Params().GetConsensus(), hashBlock, false) || hashBlock.IsNull())\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction not yet in block\");\n-        if (!mapBlockIndex.count(hashBlock))\n+        pblockindex = LookupBlockIndex(hashBlock);\n+        if (!pblockindex) {\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Transaction index corrupt\");\n-        pblockindex = mapBlockIndex[hashBlock];\n+        }\n     }\n \n     CBlock block;\n@@ -306,8 +306,10 @@ UniValue verifytxoutproof(const JSONRPCRequest& request)\n \n     LOCK(cs_main);\n \n-    if (!mapBlockIndex.count(merkleBlock.header.GetHash()) || !chainActive.Contains(mapBlockIndex[merkleBlock.header.GetHash()]))\n+    const CBlockIndex* pindex = LookupBlockIndex(merkleBlock.header.GetHash());\n+    if (!pindex || !chainActive.Contains(pindex)) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found in chain\");\n+    }\n \n     for (const uint256& hash : vMatch)\n         res.push_back(hash.GetHex());"
      },
      {
        "sha": "491f311b97e10b00430c721f87960075141ffa38",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 18,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92fabcd443322dcfdf2b3477515fae79e8647d86/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92fabcd443322dcfdf2b3477515fae79e8647d86/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=92fabcd443322dcfdf2b3477515fae79e8647d86",
        "patch": "@@ -264,10 +264,8 @@ CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& loc\n \n     // Find the first block the caller has in the main chain\n     for (const uint256& hash : locator.vHave) {\n-        BlockMap::iterator mi = mapBlockIndex.find(hash);\n-        if (mi != mapBlockIndex.end())\n-        {\n-            CBlockIndex* pindex = (*mi).second;\n+        CBlockIndex* pindex = LookupBlockIndex(hash);\n+        if (pindex) {\n             if (chain.Contains(pindex))\n                 return pindex;\n             if (pindex->GetAncestor(chain.Height()) == chain.Tip()) {\n@@ -1319,7 +1317,7 @@ bool CScriptCheck::operator()() {\n int GetSpendHeight(const CCoinsViewCache& inputs)\n {\n     LOCK(cs_main);\n-    CBlockIndex* pindexPrev = mapBlockIndex.find(inputs.GetBestBlock())->second;\n+    CBlockIndex* pindexPrev = LookupBlockIndex(inputs.GetBestBlock());\n     return pindexPrev->nHeight + 1;\n }\n \n@@ -3224,7 +3222,6 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n     BlockMap::iterator miSelf = mapBlockIndex.find(hash);\n     CBlockIndex *pindex = nullptr;\n     if (hash != chainparams.GetConsensus().hashGenesisBlock) {\n-\n         if (miSelf != mapBlockIndex.end()) {\n             // Block header is already known.\n             pindex = miSelf->second;\n@@ -3802,10 +3799,11 @@ bool LoadChainTip(const CChainParams& chainparams)\n     }\n \n     // Load pointer to end of best chain\n-    BlockMap::iterator it = mapBlockIndex.find(pcoinsTip->GetBestBlock());\n-    if (it == mapBlockIndex.end())\n+    CBlockIndex* pindex = LookupBlockIndex(pcoinsTip->GetBestBlock());\n+    if (!pindex) {\n         return false;\n-    chainActive.SetTip(it->second);\n+    }\n+    chainActive.SetTip(pindex);\n \n     g_chainstate.PruneBlockIndexCandidates();\n \n@@ -4256,7 +4254,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n                 {\n                     LOCK(cs_main);\n                     // detect out of order blocks, and store them for later\n-                    if (hash != chainparams.GetConsensus().hashGenesisBlock && mapBlockIndex.find(block.hashPrevBlock) == mapBlockIndex.end()) {\n+                    if (hash != chainparams.GetConsensus().hashGenesisBlock && !LookupBlockIndex(block.hashPrevBlock)) {\n                         LogPrint(BCLog::REINDEX, \"%s: Out of order block %s, parent %s not known\\n\", __func__, hash.ToString(),\n                                 block.hashPrevBlock.ToString());\n                         if (dbp)\n@@ -4265,14 +4263,17 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n                     }\n \n                     // process in case the block isn't known yet\n-                    if (mapBlockIndex.count(hash) == 0 || (mapBlockIndex[hash]->nStatus & BLOCK_HAVE_DATA) == 0) {\n-                        CValidationState state;\n-                        if (g_chainstate.AcceptBlock(pblock, state, chainparams, nullptr, true, dbp, nullptr))\n-                            nLoaded++;\n-                        if (state.IsError())\n-                            break;\n-                    } else if (hash != chainparams.GetConsensus().hashGenesisBlock && mapBlockIndex[hash]->nHeight % 1000 == 0) {\n-                        LogPrint(BCLog::REINDEX, \"Block Import: already had block %s at height %d\\n\", hash.ToString(), mapBlockIndex[hash]->nHeight);\n+                    CBlockIndex* pindex = LookupBlockIndex(hash);\n+                    if (!pindex || (pindex->nStatus & BLOCK_HAVE_DATA) == 0) {\n+                      CValidationState state;\n+                      if (g_chainstate.AcceptBlock(pblock, state, chainparams, nullptr, true, dbp, nullptr)) {\n+                          nLoaded++;\n+                      }\n+                      if (state.IsError()) {\n+                          break;\n+                      }\n+                    } else if (hash != chainparams.GetConsensus().hashGenesisBlock && pindex->nHeight % 1000 == 0) {\n+                      LogPrint(BCLog::REINDEX, \"Block Import: already had block %s at height %d\\n\", hash.ToString(), pindex->nHeight);\n                     }\n                 }\n "
      },
      {
        "sha": "e780f453b27d105ae746d2f0838ec1e33e06a512",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92fabcd443322dcfdf2b3477515fae79e8647d86/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92fabcd443322dcfdf2b3477515fae79e8647d86/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=92fabcd443322dcfdf2b3477515fae79e8647d86",
        "patch": "@@ -428,6 +428,13 @@ class CVerifyDB {\n /** Replay blocks that aren't fully applied to the database. */\n bool ReplayBlocks(const CChainParams& params, CCoinsView* view);\n \n+inline CBlockIndex* LookupBlockIndex(const uint256& hash)\n+{\n+    AssertLockHeld(cs_main);\n+    BlockMap::const_iterator it = mapBlockIndex.find(hash);\n+    return it == mapBlockIndex.end() ? nullptr : it->second;\n+}\n+\n /** Find the last common block between the parameter chain and a locator. */\n CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator);\n "
      },
      {
        "sha": "d62f94d8cfb458012cca2fca5ed92ec446ed203e",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92fabcd443322dcfdf2b3477515fae79e8647d86/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92fabcd443322dcfdf2b3477515fae79e8647d86/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=92fabcd443322dcfdf2b3477515fae79e8647d86",
        "patch": "@@ -359,9 +359,10 @@ UniValue importprunedfunds(const JSONRPCRequest& request)\n     if (merkleBlock.txn.ExtractMatches(vMatch, vIndex) == merkleBlock.header.hashMerkleRoot) {\n \n         LOCK(cs_main);\n-\n-        if (!mapBlockIndex.count(merkleBlock.header.GetHash()) || !chainActive.Contains(mapBlockIndex[merkleBlock.header.GetHash()]))\n+        const CBlockIndex* pindex = LookupBlockIndex(merkleBlock.header.GetHash());\n+        if (!pindex || !chainActive.Contains(pindex)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found in chain\");\n+        }\n \n         std::vector<uint256>::const_iterator it;\n         if ((it = std::find(vMatch.begin(), vMatch.end(), hashTx))==vMatch.end()) {"
      },
      {
        "sha": "f7d025cb401cffee24761f56b181541f1a62b773",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92fabcd443322dcfdf2b3477515fae79e8647d86/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92fabcd443322dcfdf2b3477515fae79e8647d86/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=92fabcd443322dcfdf2b3477515fae79e8647d86",
        "patch": "@@ -95,7 +95,7 @@ void WalletTxToJSON(const CWalletTx& wtx, UniValue& entry)\n     {\n         entry.pushKV(\"blockhash\", wtx.hashBlock.GetHex());\n         entry.pushKV(\"blockindex\", wtx.nIndex);\n-        entry.pushKV(\"blocktime\", mapBlockIndex[wtx.hashBlock]->GetBlockTime());\n+        entry.pushKV(\"blocktime\", LookupBlockIndex(wtx.hashBlock)->GetBlockTime());\n     } else {\n         entry.pushKV(\"trusted\", wtx.IsTrusted());\n     }\n@@ -2014,11 +2014,10 @@ UniValue listsinceblock(const JSONRPCRequest& request)\n         uint256 blockId;\n \n         blockId.SetHex(request.params[0].get_str());\n-        BlockMap::iterator it = mapBlockIndex.find(blockId);\n-        if (it == mapBlockIndex.end()) {\n+        paltindex = pindex = LookupBlockIndex(blockId);\n+        if (!pindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         }\n-        paltindex = pindex = it->second;\n         if (chainActive[pindex->nHeight] != pindex) {\n             // the block being asked for is a part of a deactivated chain;\n             // we don't want to depend on its perceived height in the block"
      },
      {
        "sha": "6c3312bd16f3a8bd127d2df4d1994ce1715d42c8",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92fabcd443322dcfdf2b3477515fae79e8647d86/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92fabcd443322dcfdf2b3477515fae79e8647d86/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=92fabcd443322dcfdf2b3477515fae79e8647d86",
        "patch": "@@ -1148,11 +1148,9 @@ void CWallet::MarkConflicted(const uint256& hashBlock, const uint256& hashTx)\n     LOCK2(cs_main, cs_wallet);\n \n     int conflictconfirms = 0;\n-    if (mapBlockIndex.count(hashBlock)) {\n-        CBlockIndex* pindex = mapBlockIndex[hashBlock];\n-        if (chainActive.Contains(pindex)) {\n-            conflictconfirms = -(chainActive.Height() - pindex->nHeight + 1);\n-        }\n+    CBlockIndex* pindex = LookupBlockIndex(hashBlock);\n+    if (pindex && chainActive.Contains(pindex)) {\n+        conflictconfirms = -(chainActive.Height() - pindex->nHeight + 1);\n     }\n     // If number of conflict confirms cannot be determined, this means\n     // that the block is still unknown or not yet part of the main chain,\n@@ -3768,18 +3766,18 @@ void CWallet::GetKeyBirthTimes(std::map<CTxDestination, int64_t> &mapKeyBirth) c\n     for (const auto& entry : mapWallet) {\n         // iterate over all wallet transactions...\n         const CWalletTx &wtx = entry.second;\n-        BlockMap::const_iterator blit = mapBlockIndex.find(wtx.hashBlock);\n-        if (blit != mapBlockIndex.end() && chainActive.Contains(blit->second)) {\n+        CBlockIndex* pindex = LookupBlockIndex(wtx.hashBlock);\n+        if (pindex && chainActive.Contains(pindex)) {\n             // ... which are already in a block\n-            int nHeight = blit->second->nHeight;\n+            int nHeight = pindex->nHeight;\n             for (const CTxOut &txout : wtx.tx->vout) {\n                 // iterate over all their outputs\n                 CAffectedKeysVisitor(*this, vAffected).Process(txout.scriptPubKey);\n                 for (const CKeyID &keyid : vAffected) {\n                     // ... and all their affected keys\n                     std::map<CKeyID, CBlockIndex*>::iterator rit = mapKeyFirstBlock.find(keyid);\n                     if (rit != mapKeyFirstBlock.end() && nHeight < rit->second->nHeight)\n-                        rit->second = blit->second;\n+                        rit->second = pindex;\n                 }\n                 vAffected.clear();\n             }\n@@ -3816,7 +3814,12 @@ unsigned int CWallet::ComputeTimeSmart(const CWalletTx& wtx) const\n {\n     unsigned int nTimeSmart = wtx.nTimeReceived;\n     if (!wtx.hashUnset()) {\n-        if (mapBlockIndex.count(wtx.hashBlock)) {\n+        const CBlockIndex* pindex = nullptr;\n+        {\n+            LOCK(cs_main);\n+            pindex = LookupBlockIndex(wtx.hashBlock);\n+        }\n+        if (pindex) {\n             int64_t latestNow = wtx.nTimeReceived;\n             int64_t latestEntry = 0;\n \n@@ -3847,7 +3850,7 @@ unsigned int CWallet::ComputeTimeSmart(const CWalletTx& wtx) const\n                 }\n             }\n \n-            int64_t blocktime = mapBlockIndex[wtx.hashBlock]->GetBlockTime();\n+            int64_t blocktime = pindex->GetBlockTime();\n             nTimeSmart = std::max(latestEntry, std::min(blocktime, latestNow));\n         } else {\n             LogPrintf(\"%s: found %s in block %s not in index\\n\", __func__, wtx.GetHash().ToString(), wtx.hashBlock.ToString());\n@@ -4162,10 +4165,7 @@ int CMerkleTx::GetDepthInMainChain(const CBlockIndex* &pindexRet) const\n     AssertLockHeld(cs_main);\n \n     // Find the block it claims to be in\n-    BlockMap::iterator mi = mapBlockIndex.find(hashBlock);\n-    if (mi == mapBlockIndex.end())\n-        return 0;\n-    CBlockIndex* pindex = (*mi).second;\n+    CBlockIndex* pindex = LookupBlockIndex(hashBlock);\n     if (!pindex || !chainActive.Contains(pindex))\n         return 0;\n "
      }
    ]
  }
]