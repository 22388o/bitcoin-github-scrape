[
  {
    "sha": "a6a5bb7c204130dd4f3ced74446798eb67ea6472",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNmE1YmI3YzIwNDEzMGRkNGYzY2VkNzQ0NDY3OThlYjY3ZWE2NDcy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2011-05-02T13:34:42Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2011-05-10T21:49:30Z"
      },
      "message": "Support for name lookups in -connect and -addnode\n\n* A new option -dns is introduced that enables name lookups in\n  -connect and -addnode, which is not enabled by default,\n  as it may be considered a security issue.\n* A Lookup function is added that supports retrieving one or\n  more addresses based on a host name\n* CAddress constructors (optionally) support name lookups.\n* The different places in the source code that did name lookups\n  are refactored to use NameLookup or CAddress instead (dns seeding,\n  irc server lookup, getexternalip, ...).\n* Removed ToStringLog() from CAddress, and switched to ToString(),\n  since it was empty.",
      "tree": {
        "sha": "83d8c791956b4027fa9c63c05b670527c8755ab8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/83d8c791956b4027fa9c63c05b670527c8755ab8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a6a5bb7c204130dd4f3ced74446798eb67ea6472",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a6a5bb7c204130dd4f3ced74446798eb67ea6472",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a6a5bb7c204130dd4f3ced74446798eb67ea6472",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a6a5bb7c204130dd4f3ced74446798eb67ea6472/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "04a667b0767a6c3fff8d24be784ccaec9edf712b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/04a667b0767a6c3fff8d24be784ccaec9edf712b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/04a667b0767a6c3fff8d24be784ccaec9edf712b"
      }
    ],
    "stats": {
      "total": 262,
      "additions": 148,
      "deletions": 114
    },
    "files": [
      {
        "sha": "7e846753446f26220330455eea88ebf88d986d65",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a6a5bb7c204130dd4f3ced74446798eb67ea6472/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a6a5bb7c204130dd4f3ced74446798eb67ea6472/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=a6a5bb7c204130dd4f3ced74446798eb67ea6472",
        "patch": "@@ -158,6 +158,7 @@ bool AppInit2(int argc, char* argv[])\n             \"  -min             \\t\\t  \" + _(\"Start minimized\\n\") +\n             \"  -datadir=<dir>   \\t\\t  \" + _(\"Specify data directory\\n\") +\n             \"  -proxy=<ip:port> \\t  \"   + _(\"Connect through socks4 proxy\\n\") +\n+            \"  -dns             \\t  \"   + _(\"Allow DNS lookups for addnode and connect\\n\") +\n             \"  -addnode=<ip>    \\t  \"   + _(\"Add a node to connect to\\n\") +\n             \"  -connect=<ip>    \\t\\t  \" + _(\"Connect only to the specified node\\n\") +\n             \"  -nolisten        \\t  \"   + _(\"Don't accept connections from outside\\n\") +\n@@ -208,6 +209,7 @@ bool AppInit2(int argc, char* argv[])\n     }\n \n     fDebug = GetBoolArg(\"-debug\");\n+    fAllowDNS = GetBoolArg(\"-dns\");\n \n #ifndef __WXMSW__\n     fDaemon = GetBoolArg(\"-daemon\");\n@@ -458,7 +460,7 @@ bool AppInit2(int argc, char* argv[])\n     {\n         foreach(string strAddr, mapMultiArgs[\"-addnode\"])\n         {\n-            CAddress addr(strAddr, NODE_NETWORK);\n+            CAddress addr(strAddr, fAllowDNS);\n             addr.nTime = 0; // so it won't relay unless successfully connected\n             if (addr.IsValid())\n                 AddAddress(addr);"
      },
      {
        "sha": "4e398892453a81eb4c56a6865cc69d3cd4851505",
        "filename": "src/irc.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 24,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a6a5bb7c204130dd4f3ced74446798eb67ea6472/src/irc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a6a5bb7c204130dd4f3ced74446798eb67ea6472/src/irc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/irc.cpp?ref=a6a5bb7c204130dd4f3ced74446798eb67ea6472",
        "patch": "@@ -41,7 +41,7 @@ bool DecodeAddress(string str, CAddress& addr)\n         return false;\n     memcpy(&tmp, &vch[0], sizeof(tmp));\n \n-    addr = CAddress(tmp.ip, tmp.port, NODE_NETWORK);\n+    addr = CAddress(tmp.ip, ntohs(tmp.port), NODE_NETWORK);\n     return true;\n }\n \n@@ -215,25 +215,15 @@ bool GetIPFromIRC(SOCKET hSocket, string strMyName, unsigned int& ipRet)\n         return false;\n     string strHost = str.substr(str.rfind(\"@\")+1);\n \n-    unsigned int a=0, b=0, c=0, d=0;\n-    if (sscanf(strHost.c_str(), \"%u.%u.%u.%u\", &a, &b, &c, &d) == 4 &&\n-        inet_addr(strHost.c_str()) != INADDR_NONE)\n-    {\n-        printf(\"GetIPFromIRC() userhost is IP %s\\n\", strHost.c_str());\n-        ipRet = CAddress(strHost).ip;\n-    }\n-    else\n-    {\n-        // Hybrid IRC used by lfnet always returns IP when you userhost yourself,\n-        // but in case another IRC is ever used this should work.\n-        printf(\"GetIPFromIRC() got userhost %s\\n\", strHost.c_str());\n-        if (fUseProxy)\n-            return false;\n-        struct hostent* phostent = gethostbyname(strHost.c_str());\n-        if (!phostent || !phostent->h_addr_list || !phostent->h_addr_list[0])\n-            return false;\n-        ipRet = *(u_long*)phostent->h_addr_list[0];\n-    }\n+    // Hybrid IRC used by lfnet always returns IP when you userhost yourself,\n+    // but in case another IRC is ever used this should work.\n+    printf(\"GetIPFromIRC() got userhost %s\\n\", strHost.c_str());\n+    if (fUseProxy)\n+        return false;\n+    CAddress addr(strHost, 0, true);\n+    if (!addr.IsValid())\n+        return false;\n+    ipRet = addr.ip;\n \n     return true;\n }\n@@ -276,9 +266,9 @@ void ThreadIRCSeed2(void* parg)\n         if (!fTOR)\n         {\n             //struct hostent* phostent = gethostbyname(\"chat.freenode.net\");\n-            struct hostent* phostent = gethostbyname(\"irc.lfnet.org\");\n-            if (phostent && phostent->h_addr_list && phostent->h_addr_list[0])\n-                addrConnect = CAddress(*(u_long*)phostent->h_addr_list[0], htons(6667));\n+            CAddress addrIRC(\"irc.lfnet.org:6667\", 0, true);\n+            if (addrIRC.IsValid())\n+                addrConnect = addrIRC;\n         }\n \n         SOCKET hSocket;\n@@ -390,7 +380,7 @@ void ThreadIRCSeed2(void* parg)\n                 {\n                     addr.nTime = GetAdjustedTime();\n                     if (AddAddress(addr, 51 * 60))\n-                        printf(\"IRC got new address\\n\");\n+                        printf(\"IRC got new address: %s\\n\", addr.ToString().c_str());\n                     nGotIRCAddresses++;\n                 }\n                 else"
      },
      {
        "sha": "b7cf973d41823debfb927ddffb9b53b11a6defcc",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 109,
        "deletions": 49,
        "changes": 158,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a6a5bb7c204130dd4f3ced74446798eb67ea6472/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a6a5bb7c204130dd4f3ced74446798eb67ea6472/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=a6a5bb7c204130dd4f3ced74446798eb67ea6472",
        "patch": "@@ -29,8 +29,9 @@ bool OpenNetworkConnection(const CAddress& addrConnect);\n // Global state variables\n //\n bool fClient = false;\n+bool fAllowDNS = false;\n uint64 nLocalServices = (fClient ? 0 : NODE_NETWORK);\n-CAddress addrLocalHost(0, 0, nLocalServices);\n+CAddress addrLocalHost(\"0.0.0.0\", 0, false, nLocalServices);\n CNode* pnodeLocalHost = NULL;\n uint64 nLocalHostNonce = 0;\n array<int, 10> vnThreadsRunning;\n@@ -47,7 +48,7 @@ map<CInv, int64> mapAlreadyAskedFor;\n \n // Settings\n int fUseProxy = false;\n-CAddress addrProxy(\"127.0.0.1:9050\");\n+CAddress addrProxy(\"127.0.0.1\",9050);\n \n \n \n@@ -92,7 +93,7 @@ bool ConnectSocket(const CAddress& addrConnect, SOCKET& hSocketRet)\n \n     if (fProxy)\n     {\n-        printf(\"proxy connecting %s\\n\", addrConnect.ToStringLog().c_str());\n+        printf(\"proxy connecting %s\\n\", addrConnect.ToString().c_str());\n         char pszSocks4IP[] = \"\\4\\1\\0\\0\\0\\0\\0\\0user\";\n         memcpy(pszSocks4IP + 2, &addrConnect.port, 2);\n         memcpy(pszSocks4IP + 4, &addrConnect.ip, 4);\n@@ -118,14 +119,81 @@ bool ConnectSocket(const CAddress& addrConnect, SOCKET& hSocketRet)\n                 printf(\"ERROR: Proxy returned error %d\\n\", pchRet[1]);\n             return false;\n         }\n-        printf(\"proxy connected %s\\n\", addrConnect.ToStringLog().c_str());\n+        printf(\"proxy connected %s\\n\", addrConnect.ToString().c_str());\n     }\n \n     hSocketRet = hSocket;\n     return true;\n }\n \n+// portDefault is in host order\n+bool Lookup(const char *pszName, vector<CAddress>& vaddr, int nServices, int nMaxSolutions, bool fAllowLookup, int portDefault, bool fAllowPort)\n+{\n+    vaddr.clear();\n+    int port = portDefault;\n+    char psz[256];\n+    char *pszHost = psz;\n+    strlcpy(psz, pszName, sizeof(psz));\n+    if (fAllowPort)\n+    {\n+        char* pszColon = strrchr(psz+1,':');\n+        char *pszPortEnd = NULL;\n+        int portParsed = pszColon ? strtoul(pszColon+1, &pszPortEnd, 10) : 0;\n+        if (pszColon && pszPortEnd && pszPortEnd[0] == 0)\n+        {\n+            if (psz[0] == '[' && pszColon[-1] == ']')\n+            {\n+                // Future: enable IPv6 colon-notation inside []\n+                pszHost = psz+1;\n+                pszColon[-1] = 0;\n+            }\n+            else\n+                pszColon[0] = 0;\n+            port = portParsed;\n+            if (port < 0 || port > USHRT_MAX)\n+                port = USHRT_MAX;\n+        }\n+    }\n+\n+    struct in_addr addrIP;\n+    if (inet_aton(pszHost, &addrIP))\n+    {\n+        // valid IP address passed\n+        vaddr.push_back(CAddress(addrIP.s_addr, port, nServices));\n+        return true;\n+    }\n+\n+    if (!fAllowLookup)\n+        return false;\n+\n+    struct hostent* phostent = gethostbyname(pszHost);\n+    if (!phostent)\n+        return false;\n+\n+    if (phostent->h_addrtype != AF_INET)\n+        return false;\n \n+    char** ppAddr = phostent->h_addr_list;\n+    while (*ppAddr != NULL && vaddr.size() != nMaxSolutions)\n+    {\n+        CAddress addr(((struct in_addr*)ppAddr[0])->s_addr, port, nServices);\n+        if (addr.IsValid())\n+            vaddr.push_back(addr);\n+        ppAddr++;\n+    }\n+\n+    return (vaddr.size() > 0);\n+}\n+\n+// portDefault is in host order\n+bool Lookup(const char *pszName, CAddress& addr, int nServices, bool fAllowLookup, int portDefault, bool fAllowPort)\n+{\n+    vector<CAddress> vaddr;\n+    bool fRet = Lookup(pszName, vaddr, nServices, 1, fAllowLookup, portDefault, fAllowPort);\n+    if (fRet)\n+        addr = vaddr[0];\n+    return fRet;\n+}\n \n bool GetMyExternalIP2(const CAddress& addrConnect, const char* pszGet, const char* pszKeyword, unsigned int& ipRet)\n {\n@@ -161,7 +229,7 @@ bool GetMyExternalIP2(const CAddress& addrConnect, const char* pszGet, const cha\n             strLine = strLine.substr(strspn(strLine.c_str(), \" \\t\\n\\r\"));\n             while (strLine.size() > 0 && isspace(strLine[strLine.size()-1]))\n                 strLine.resize(strLine.size()-1);\n-            CAddress addr(strLine.c_str());\n+            CAddress addr(strLine,0,true);\n             printf(\"GetMyExternalIP() received [%s] %s\\n\", strLine.c_str(), addr.ToString().c_str());\n             if (addr.ip == 0 || addr.ip == INADDR_NONE || !addr.IsRoutable())\n                 return false;\n@@ -192,13 +260,13 @@ bool GetMyExternalIP(unsigned int& ipRet)\n         //  <?php echo $_SERVER[\"REMOTE_ADDR\"]; ?>\n         if (nHost == 1)\n         {\n-            addrConnect = CAddress(\"91.198.22.70:80\"); // checkip.dyndns.org\n+            addrConnect = CAddress(\"91.198.22.70\",80); // checkip.dyndns.org\n \n             if (nLookup == 1)\n             {\n-                struct hostent* phostent = gethostbyname(\"checkip.dyndns.org\");\n-                if (phostent && phostent->h_addr_list && phostent->h_addr_list[0])\n-                    addrConnect = CAddress(*(u_long*)phostent->h_addr_list[0], htons(80));\n+                CAddress addrIP(\"checkip.dyndns.org\", 80, true);\n+                if (addrIP.IsValid())\n+                    addrConnect = addrIP;\n             }\n \n             pszGet = \"GET / HTTP/1.1\\r\\n\"\n@@ -211,13 +279,13 @@ bool GetMyExternalIP(unsigned int& ipRet)\n         }\n         else if (nHost == 2)\n         {\n-            addrConnect = CAddress(\"74.208.43.192:80\"); // www.showmyip.com\n+            addrConnect = CAddress(\"74.208.43.192\", 80); // www.showmyip.com\n \n             if (nLookup == 1)\n             {\n-                struct hostent* phostent = gethostbyname(\"www.showmyip.com\");\n-                if (phostent && phostent->h_addr_list && phostent->h_addr_list[0])\n-                    addrConnect = CAddress(*(u_long*)phostent->h_addr_list[0], htons(80));\n+                CAddress addrIP(\"www.showmyip.com\", 80, true);\n+                if (addrIP.IsValid())\n+                    addrConnect = addrIP;\n             }\n \n             pszGet = \"GET /simple/ HTTP/1.1\\r\\n\"\n@@ -283,7 +351,7 @@ bool AddAddress(CAddress addr, int64 nTimePenalty)\n         if (it == mapAddresses.end())\n         {\n             // New address\n-            printf(\"AddAddress(%s)\\n\", addr.ToStringLog().c_str());\n+            printf(\"AddAddress(%s)\\n\", addr.ToString().c_str());\n             mapAddresses.insert(make_pair(addr.GetKey(), addr));\n             CAddrDB().WriteAddress(addr);\n             return true;\n@@ -479,7 +547,7 @@ CNode* ConnectNode(CAddress addrConnect, int64 nTimeout)\n \n     /// debug print\n     printf(\"trying connection %s lastseen=%.1fhrs lasttry=%.1fhrs\\n\",\n-        addrConnect.ToStringLog().c_str(),\n+        addrConnect.ToString().c_str(),\n         (double)(addrConnect.nTime - GetAdjustedTime())/3600.0,\n         (double)(addrConnect.nLastTry - GetAdjustedTime())/3600.0);\n \n@@ -491,7 +559,7 @@ CNode* ConnectNode(CAddress addrConnect, int64 nTimeout)\n     if (ConnectSocket(addrConnect, hSocket))\n     {\n         /// debug print\n-        printf(\"connected %s\\n\", addrConnect.ToStringLog().c_str());\n+        printf(\"connected %s\\n\", addrConnect.ToString().c_str());\n \n         // Set to nonblocking\n #ifdef __WXMSW__\n@@ -528,7 +596,7 @@ void CNode::CloseSocketDisconnect()\n     {\n         if (fDebug)\n             printf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n-        printf(\"disconnecting node %s\\n\", addr.ToStringLog().c_str());\n+        printf(\"disconnecting node %s\\n\", addr.ToString().c_str());\n         closesocket(hSocket);\n         hSocket = INVALID_SOCKET;\n     }\n@@ -715,7 +783,7 @@ void ThreadSocketHandler2(void* parg)\n             }\n             else\n             {\n-                printf(\"accepted connection %s\\n\", addr.ToStringLog().c_str());\n+                printf(\"accepted connection %s\\n\", addr.ToString().c_str());\n                 CNode* pnode = new CNode(hSocket, addr, true);\n                 pnode->AddRef();\n                 CRITICAL_BLOCK(cs_vNodes)\n@@ -892,7 +960,7 @@ void ThreadMapPort2(void* parg)\n     printf(\"ThreadMapPort started\\n\");\n \n     char port[6];\n-    sprintf(port, \"%d\", ntohs(GetDefaultPort()));\n+    sprintf(port, \"%d\", GetDefaultPort());\n \n     const char * rootdescurl = 0;\n     const char * multicastif = 0;\n@@ -984,17 +1052,17 @@ void DNSAddressSeed()\n     printf(\"Loading addresses from DNS seeds (could take a while)\\n\");\n \n     for (int seed_idx = 0; seed_idx < ARRAYLEN(strDNSSeed); seed_idx++) {\n-        struct hostent* phostent = gethostbyname(strDNSSeed[seed_idx]);\n-        if (!phostent)\n-            continue;\n-\n-        for (int host = 0; phostent->h_addr_list[host] != NULL; host++) {\n-            CAddress addr(*(unsigned int*)phostent->h_addr_list[host],\n-                          GetDefaultPort(), NODE_NETWORK);\n-            addr.nTime = 0;\n-            if (addr.IsValid() && addr.GetByte(3) != 127) {\n-                AddAddress(addr);\n-                found++;\n+        vector<CAddress> vaddr;\n+        if (Lookup(strDNSSeed[seed_idx], vaddr, NODE_NETWORK, true))\n+        {\n+            foreach (CAddress& addr, vaddr)\n+            {\n+                if (addr.GetByte(3) != 127)\n+                {\n+                    addr.nTime = 0;\n+                    AddAddress(addr);\n+                    found++;\n+                }\n             }\n         }\n     }\n@@ -1080,7 +1148,7 @@ void ThreadOpenConnections2(void* parg)\n         {\n             foreach(string strAddr, mapMultiArgs[\"-connect\"])\n             {\n-                CAddress addr(strAddr, NODE_NETWORK);\n+                CAddress addr(strAddr, fAllowDNS);\n                 if (addr.IsValid())\n                     OpenNetworkConnection(addr);\n                 for (int i = 0; i < 10 && i < nLoop; i++)\n@@ -1098,7 +1166,7 @@ void ThreadOpenConnections2(void* parg)\n     {\n         foreach(string strAddr, mapMultiArgs[\"-addnode\"])\n         {\n-            CAddress addr(strAddr, NODE_NETWORK);\n+            CAddress addr(strAddr, fAllowDNS);\n             if (addr.IsValid())\n             {\n                 OpenNetworkConnection(addr);\n@@ -1209,7 +1277,7 @@ void ThreadOpenConnections2(void* parg)\n \n                 // Randomize the order in a deterministic way, putting the standard port first\n                 int64 nRandomizer = (uint64)(nStart * 4951 + addr.nLastTry * 9567851 + addr.ip * 7789) % (2 * 60 * 60);\n-                if (addr.port != GetDefaultPort())\n+                if (addr.port != htons(GetDefaultPort()))\n                     nRandomizer += 2 * 60 * 60;\n \n                 // Last seen  Base retry frequency\n@@ -1369,7 +1437,7 @@ bool BindListenPort(string& strError)\n {\n     strError = \"\";\n     int nOne = 1;\n-    addrLocalHost.port = GetDefaultPort();\n+    addrLocalHost.port = htons(GetDefaultPort());\n \n #ifdef __WXMSW__\n     // Initialize Windows Sockets\n@@ -1421,7 +1489,7 @@ bool BindListenPort(string& strError)\n     memset(&sockaddr, 0, sizeof(sockaddr));\n     sockaddr.sin_family = AF_INET;\n     sockaddr.sin_addr.s_addr = INADDR_ANY; // bind to all IPs on this computer\n-    sockaddr.sin_port = GetDefaultPort();\n+    sockaddr.sin_port = htons(GetDefaultPort());\n     if (::bind(hListenSocket, (struct sockaddr*)&sockaddr, sizeof(sockaddr)) == SOCKET_ERROR)\n     {\n         int nErr = WSAGetLastError();\n@@ -1448,29 +1516,21 @@ bool BindListenPort(string& strError)\n void StartNode(void* parg)\n {\n     if (pnodeLocalHost == NULL)\n-        pnodeLocalHost = new CNode(INVALID_SOCKET, CAddress(\"127.0.0.1\", nLocalServices));\n+        pnodeLocalHost = new CNode(INVALID_SOCKET, CAddress(\"127.0.0.1\", 0, false, nLocalServices));\n \n #ifdef __WXMSW__\n     // Get local host ip\n     char pszHostName[1000] = \"\";\n     if (gethostname(pszHostName, sizeof(pszHostName)) != SOCKET_ERROR)\n     {\n-        struct hostent* phostent = gethostbyname(pszHostName);\n-        if (phostent)\n-        {\n-            // Take the first IP that isn't loopback 127.x.x.x\n-            for (int i = 0; phostent->h_addr_list[i] != NULL; i++)\n-                printf(\"host ip %d: %s\\n\", i, CAddress(*(unsigned int*)phostent->h_addr_list[i]).ToStringIP().c_str());\n-            for (int i = 0; phostent->h_addr_list[i] != NULL; i++)\n-            {\n-                CAddress addr(*(unsigned int*)phostent->h_addr_list[i], GetDefaultPort(), nLocalServices);\n-                if (addr.IsValid() && addr.GetByte(3) != 127)\n+        vector<CAddress> vaddr;\n+        if (NameLookup(pszHostName, vaddr, nLocalServices))\n+            foreach (const CAddress &addr, vaddr)\n+                if (addr.GetByte(3) != 127)\n                 {\n                     addrLocalHost = addr;\n                     break;\n                 }\n-            }\n-        }\n     }\n #else\n     // Get local host ip\n@@ -1491,7 +1551,7 @@ void StartNode(void* parg)\n                     printf(\"ipv4 %s: %s\\n\", ifa->ifa_name, pszIP);\n \n                 // Take the first IP that isn't loopback 127.x.x.x\n-                CAddress addr(*(unsigned int*)&s4->sin_addr, GetDefaultPort(), nLocalServices);\n+                CAddress addr(*(unsigned int*)&s4->sin_addr, 0, nLocalServices);\n                 if (addr.IsValid() && addr.GetByte(3) != 127)\n                 {\n                     addrLocalHost = addr;"
      },
      {
        "sha": "ea12b983e4faaa8104eb9ce61b8de9e7338a5bb7",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 22,
        "deletions": 40,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a6a5bb7c204130dd4f3ced74446798eb67ea6472/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a6a5bb7c204130dd4f3ced74446798eb67ea6472/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=a6a5bb7c204130dd4f3ced74446798eb67ea6472",
        "patch": "@@ -12,7 +12,7 @@ extern int nBestHeight;\n \n \n \n-inline unsigned short GetDefaultPort() { return fTestNet ? htons(18333) : htons(8333); }\n+inline unsigned short GetDefaultPort() { return fTestNet ? 18333 : 8333; }\n static const unsigned int PUBLISH_HOPS = 5;\n enum\n {\n@@ -23,6 +23,8 @@ enum\n \n \n bool ConnectSocket(const CAddress& addrConnect, SOCKET& hSocketRet);\n+bool Lookup(const char *pszName, vector<CAddress>& vaddr, int nServices, int nMaxSolutions, bool fAllowLookup = false, int portDefault = 0, bool fAllowPort = false);\n+bool Lookup(const char *pszName, CAddress& addr, int nServices, bool fAllowLookup = false, int portDefault = 0, bool fAllowPort = false);\n bool GetMyExternalIP(unsigned int& ipRet);\n bool AddAddress(CAddress addr, int64 nTimePenalty=0);\n void AddressCurrentlyConnected(const CAddress& addr);\n@@ -156,7 +158,7 @@ class CAddress\n     {\n         Init();\n         ip = ipIn;\n-        port = (portIn == 0 ? GetDefaultPort() : portIn);\n+        port = htons(portIn == 0 ? GetDefaultPort() : portIn);\n         nServices = nServicesIn;\n     }\n \n@@ -168,54 +170,38 @@ class CAddress\n         nServices = nServicesIn;\n     }\n \n-    explicit CAddress(const char* pszIn, uint64 nServicesIn=NODE_NETWORK)\n+    explicit CAddress(const char* pszIn, int portIn, bool fNameLookup = false, uint64 nServicesIn=NODE_NETWORK)\n     {\n         Init();\n-        SetAddress(pszIn);\n-        nServices = nServicesIn;\n+        Lookup(pszIn, *this, nServicesIn, fNameLookup, portIn);\n     }\n \n-    explicit CAddress(string strIn, uint64 nServicesIn=NODE_NETWORK)\n+    explicit CAddress(const char* pszIn, bool fNameLookup = false, uint64 nServicesIn=NODE_NETWORK)\n     {\n         Init();\n-        SetAddress(strIn.c_str());\n-        nServices = nServicesIn;\n+        Lookup(pszIn, *this, nServicesIn, fNameLookup, 0, true);\n     }\n \n-    void Init()\n+    explicit CAddress(string strIn, int portIn, bool fNameLookup = false, uint64 nServicesIn=NODE_NETWORK)\n     {\n-        nServices = NODE_NETWORK;\n-        memcpy(pchReserved, pchIPv4, sizeof(pchReserved));\n-        ip = INADDR_NONE;\n-        port = GetDefaultPort();\n-        nTime = 100000000;\n-        nLastTry = 0;\n+        Init();\n+        Lookup(strIn.c_str(), *this, nServicesIn, fNameLookup, portIn);\n     }\n \n-    bool SetAddress(const char* pszIn)\n+    explicit CAddress(string strIn, bool fNameLookup = false, uint64 nServicesIn=NODE_NETWORK)\n     {\n-        ip = INADDR_NONE;\n-        port = GetDefaultPort();\n-        char psz[100];\n-        strlcpy(psz, pszIn, sizeof(psz));\n-        unsigned int a=0, b=0, c=0, d=0, e=0;\n-        if (sscanf(psz, \"%u.%u.%u.%u:%u\", &a, &b, &c, &d, &e) < 4)\n-            return false;\n-        char* pszPort = strchr(psz, ':');\n-        if (pszPort)\n-        {\n-            *pszPort++ = '\\0';\n-            port = htons(atoi(pszPort));\n-            if (atoi(pszPort) < 0 || atoi(pszPort) > USHRT_MAX)\n-                port = htons(USHRT_MAX);\n-        }\n-        ip = inet_addr(psz);\n-        return IsValid();\n+        Init();\n+        Lookup(strIn.c_str(), *this, nServicesIn, fNameLookup, 0, true);\n     }\n \n-    bool SetAddress(string strIn)\n+    void Init()\n     {\n-        return SetAddress(strIn.c_str());\n+        nServices = NODE_NETWORK;\n+        memcpy(pchReserved, pchIPv4, sizeof(pchReserved));\n+        ip = INADDR_NONE;\n+        port = htons(GetDefaultPort());\n+        nTime = 100000000;\n+        nLastTry = 0;\n     }\n \n     IMPLEMENT_SERIALIZE\n@@ -330,11 +316,6 @@ class CAddress\n         return strprintf(\"%u\", ntohs(port));\n     }\n \n-    string ToStringLog() const\n-    {\n-        return \"\";\n-    }\n-\n     string ToString() const\n     {\n         return strprintf(\"%u.%u.%u.%u:%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0), ntohs(port));\n@@ -460,6 +441,7 @@ class CRequestTracker\n \n \n extern bool fClient;\n+extern bool fAllowDNS;\n extern uint64 nLocalServices;\n extern CAddress addrLocalHost;\n extern CNode* pnodeLocalHost;"
      }
    ]
  }
]