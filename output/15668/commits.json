[
  {
    "sha": "1e2203b51b1496e05d4a14b95b18cc4996ca87cb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZTIyMDNiNTFiMTQ5NmUwNWQ0YTE0Yjk1YjE4Y2M0OTk2Y2E4N2Ni",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-03-25T22:26:12Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-03-26T15:27:52Z"
      },
      "message": "p2p: Slightly more private tx relay",
      "tree": {
        "sha": "ee479c56be1a8058492332faf63388db130ed29a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ee479c56be1a8058492332faf63388db130ed29a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1e2203b51b1496e05d4a14b95b18cc4996ca87cb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1e2203b51b1496e05d4a14b95b18cc4996ca87cb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1e2203b51b1496e05d4a14b95b18cc4996ca87cb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1e2203b51b1496e05d4a14b95b18cc4996ca87cb/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7b13c646457980f44599412f243694fa682a1abf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7b13c646457980f44599412f243694fa682a1abf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7b13c646457980f44599412f243694fa682a1abf"
      }
    ],
    "stats": {
      "total": 156,
      "additions": 128,
      "deletions": 28
    },
    "files": [
      {
        "sha": "a86689dc9e0059dcdac62acdcdb9394773702bc6",
        "filename": "src/interfaces/chain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e2203b51b1496e05d4a14b95b18cc4996ca87cb/src/interfaces/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e2203b51b1496e05d4a14b95b18cc4996ca87cb/src/interfaces/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.cpp?ref=1e2203b51b1496e05d4a14b95b18cc4996ca87cb",
        "patch": "@@ -306,10 +306,9 @@ class ChainImpl : public Chain\n         auto it = ::mempool.GetIter(txid);\n         return it && (*it)->GetCountWithDescendants() > 1;\n     }\n-    void relayTransaction(const uint256& txid) override\n+    void relayTransaction(const bool initial, const uint256& txid) override\n     {\n-        CInv inv(MSG_TX, txid);\n-        g_connman->ForEachNode([&inv](CNode* node) { node->PushInventory(inv); });\n+        g_connman->RelayTransaction(initial, txid, ::mempool);\n     }\n     void getTransactionAncestry(const uint256& txid, size_t& ancestors, size_t& descendants) override\n     {"
      },
      {
        "sha": "7088278a3c28191316c52347e8d1cfd2c73eb859",
        "filename": "src/interfaces/chain.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e2203b51b1496e05d4a14b95b18cc4996ca87cb/src/interfaces/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e2203b51b1496e05d4a14b95b18cc4996ca87cb/src/interfaces/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.h?ref=1e2203b51b1496e05d4a14b95b18cc4996ca87cb",
        "patch": "@@ -185,7 +185,7 @@ class Chain\n     virtual bool hasDescendantsInMempool(const uint256& txid) = 0;\n \n     //! Relay transaction.\n-    virtual void relayTransaction(const uint256& txid) = 0;\n+    virtual void relayTransaction(bool initial, const uint256& txid) = 0;\n \n     //! Calculate mempool ancestor and descendant counts for the given transaction.\n     virtual void getTransactionAncestry(const uint256& txid, size_t& ancestors, size_t& descendants) = 0;"
      },
      {
        "sha": "576a775f15a9db1f473c584605150fb9a9c45e47",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 40,
        "deletions": 1,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e2203b51b1496e05d4a14b95b18cc4996ca87cb/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e2203b51b1496e05d4a14b95b18cc4996ca87cb/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=1e2203b51b1496e05d4a14b95b18cc4996ca87cb",
        "patch": "@@ -15,9 +15,10 @@\n #include <consensus/consensus.h>\n #include <crypto/common.h>\n #include <crypto/sha256.h>\n-#include <primitives/transaction.h>\n #include <netbase.h>\n+#include <primitives/transaction.h>\n #include <scheduler.h>\n+#include <txmempool.h>\n #include <ui_interface.h>\n #include <util/strencodings.h>\n \n@@ -2610,6 +2611,44 @@ int CConnman::GetBestHeight() const\n     return nBestHeight.load(std::memory_order_acquire);\n }\n \n+void CConnman::RelayTransaction(bool initial, const uint256& txid, const CTxMemPool& tx_pool) const\n+{\n+    if (initial) {\n+        const auto& it = tx_pool.GetIter(txid);\n+        if (!it) return;\n+        const CFeeRate tx_fee_rate{(*it)->GetFee(), (*it)->GetTxSize()};\n+        std::vector<CNode*> candidates;\n+        g_connman->ForEachNode([&tx_fee_rate, &candidates](CNode* node) {\n+            // Exclude nodes that will drop this tx on the floor\n+            if (!node->fRelayTxes) return;\n+            if (node->fSendMempool) return;\n+            if (node->fClient) return;\n+            if (!node->minFeeFilter) return;\n+            if (tx_fee_rate.GetFeePerK() < node->minFeeFilter) return;\n+            if (node->IsEphemeral()) return;\n+            if (!(node->nServices & NODE_WITNESS)) return;\n+            if (!node->nLastTXTime) return;\n+\n+            // Exclude inbound nodes\n+            if (node->fInbound) return;\n+\n+            candidates.push_back(node);\n+        });\n+\n+        std::sort(candidates.begin(), candidates.end(), [](const CNode* a, const CNode* b) { return a->nLastTXTime > b->nLastTXTime; });\n+        // Pick the better half of all candidates\n+        for (int remove = candidates.size() / 2; remove > 0; --remove) {\n+            candidates.pop_back();\n+        }\n+        for (CNode* node : candidates) {\n+            node->PushInventoryOneHopTx(txid);\n+        }\n+    } else {\n+        const CInv inv(MSG_TX, txid);\n+        ForEachNode([&inv](CNode* node) { node->PushInventory(inv); });\n+    }\n+}\n+\n unsigned int CConnman::GetReceiveFloodSize() const { return nReceiveFloodSize; }\n \n CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress& addrBindIn, const std::string& addrNameIn, bool fInboundIn)"
      },
      {
        "sha": "a999a730a19ee30332ef8b6f23f8d87ae4756e09",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 29,
        "deletions": 2,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e2203b51b1496e05d4a14b95b18cc4996ca87cb/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e2203b51b1496e05d4a14b95b18cc4996ca87cb/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=1e2203b51b1496e05d4a14b95b18cc4996ca87cb",
        "patch": "@@ -38,6 +38,12 @@\n class CScheduler;\n class CNode;\n class BanMan;\n+class CTxMemPool;\n+class CTransaction;\n+\n+using CTransactionRef = std::shared_ptr<const CTransaction>;\n+\n+using MapRelay = std::map<uint256, CTransactionRef>;\n \n /** Time between pings automatically sent out for latency probing and keepalive (in seconds). */\n static const int PING_INTERVAL = 2 * 60;\n@@ -299,6 +305,9 @@ class CConnman\n     void SetBestHeight(int height);\n     int GetBestHeight() const;\n \n+    /** Announce transaction to all peers */\n+    void RelayTransaction(bool initial, const uint256& txid, const CTxMemPool& tx_pool) const;\n+\n     /** Get a unique deterministic randomizer. */\n     CSipHasher GetDeterministicRandomizer(uint64_t id) const;\n \n@@ -700,15 +709,18 @@ class CNode\n     int64_t nNextLocalAddrSend GUARDED_BY(cs_sendProcessing){0};\n \n     // inventory based relay\n+    RecursiveMutex cs_inventory;\n     CRollingBloomFilter filterInventoryKnown GUARDED_BY(cs_inventory);\n     // Set of transaction ids we still have to announce.\n     // They are sorted by the mempool before relay, so the order is not important.\n     std::set<uint256> setInventoryTxToSend;\n+    /** Set of one-hop transactions to relay to this peer */\n+    std::set<uint256> m_set_one_hop_tx_to_send GUARDED_BY(cs_inventory);\n+    MapRelay m_map_one_hop_tx_to_send;\n     // List of block ids we still have announce.\n     // There is no final sorting before sending, as they are always sent immediately\n     // and in the order requested.\n     std::vector<uint256> vInventoryBlockToSend GUARDED_BY(cs_inventory);\n-    CCriticalSection cs_inventory;\n     int64_t nNextInvSend{0};\n     // Used for headers announcements - unfiltered blocks to relay\n     std::vector<uint256> vBlockHashesToAnnounce GUARDED_BY(cs_inventory);\n@@ -807,7 +819,14 @@ class CNode\n         nRefCount--;\n     }\n \n-\n+    /** If this peer is not yet connected or soon to be disconnected */\n+    bool IsEphemeral() const\n+    {\n+        return !fSuccessfullyConnected &&\n+               fDisconnect &&\n+               fOneShot &&\n+               fFeeler;\n+    }\n \n     void AddAddressKnown(const CAddress& _addr)\n     {\n@@ -837,6 +856,14 @@ class CNode\n         }\n     }\n \n+    void PushInventoryOneHopTx(const uint256& txid)\n+    {\n+        LOCK(cs_inventory);\n+        if (!filterInventoryKnown.contains(txid)) {\n+            m_set_one_hop_tx_to_send.insert(txid);\n+        }\n+    }\n+\n     void PushInventory(const CInv& inv)\n     {\n         LOCK(cs_inventory);"
      },
      {
        "sha": "02769dab6cac0240f096316801bc26cf02ad0d71",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 13,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e2203b51b1496e05d4a14b95b18cc4996ca87cb/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e2203b51b1496e05d4a14b95b18cc4996ca87cb/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=1e2203b51b1496e05d4a14b95b18cc4996ca87cb",
        "patch": "@@ -170,10 +170,11 @@ namespace {\n     std::atomic<int64_t> g_last_tip_update(0);\n \n     /** Relay map */\n-    typedef std::map<uint256, CTransactionRef> MapRelay;\n     MapRelay mapRelay GUARDED_BY(cs_main);\n     /** Expiration-time ordered list of (expire time, relay map entry) pairs. */\n     std::deque<std::pair<int64_t, MapRelay::iterator>> vRelayExpiration GUARDED_BY(cs_main);\n+    /** Expiration-time ordered list of (expire time, node id, node relay map entry) tuples. */\n+    std::deque<std::tuple<int64_t, NodeId, MapRelay::iterator>> g_relay_expiration_next_hop GUARDED_BY(cs_main);\n \n     std::atomic<int64_t> nTimeBestReceived(0); // Used only to inform the wallet of when we last received a block\n \n@@ -1426,11 +1427,15 @@ void static ProcessGetData(CNode* pfrom, const CChainParams& chainparams, CConnm\n \n             // Send stream from relay memory\n             bool push = false;\n-            auto mi = mapRelay.find(inv.hash);\n+            MapRelay::const_iterator mi;\n             int nSendFlags = (inv.type == MSG_TX ? SERIALIZE_TRANSACTION_NO_WITNESS : 0);\n-            if (mi != mapRelay.end()) {\n+            if ((mi = mapRelay.find(inv.hash)) != mapRelay.end()) {\n                 connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *mi->second));\n                 push = true;\n+            } else if ((mi = pfrom->m_map_one_hop_tx_to_send.find(inv.hash)) != pfrom->m_map_one_hop_tx_to_send.end()) {\n+                connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *mi->second));\n+                pfrom->m_map_one_hop_tx_to_send.erase(mi);\n+                push = true;\n             } else if (pfrom->timeLastMempoolReq) {\n                 auto txinfo = mempool.info(inv.hash);\n                 // To protect privacy, do not answer getdata using the mempool when\n@@ -3418,11 +3423,11 @@ class CompareInvMempoolOrder\n         mp = _mempool;\n     }\n \n-    bool operator()(std::set<uint256>::iterator a, std::set<uint256>::iterator b)\n+    bool operator()(std::pair<bool, std::set<uint256>::iterator> a, std::pair<bool, std::set<uint256>::iterator> b) const\n     {\n         /* As std::make_heap produces a max-heap, we want the entries with the\n          * fewest ancestors/highest fee to sort later. */\n-        return mp->CompareDepthAndScore(*b, *a);\n+        return mp->CompareDepthAndScore(*(b.second), *(a.second));\n     }\n };\n }\n@@ -3754,10 +3759,13 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n             // Determine transactions to relay\n             if (fSendTrickle) {\n                 // Produce a vector with all candidates for sending\n-                std::vector<std::set<uint256>::iterator> vInvTx;\n-                vInvTx.reserve(pto->setInventoryTxToSend.size());\n-                for (std::set<uint256>::iterator it = pto->setInventoryTxToSend.begin(); it != pto->setInventoryTxToSend.end(); it++) {\n-                    vInvTx.push_back(it);\n+                std::vector<std::pair</* type (last_hop) */ bool, std::set<uint256>::iterator>> vInvTx;\n+                vInvTx.reserve(pto->setInventoryTxToSend.size() + pto->m_set_one_hop_tx_to_send.size());\n+                for (auto it = pto->setInventoryTxToSend.begin(); it != pto->setInventoryTxToSend.end(); ++it) {\n+                    vInvTx.emplace_back(false, it);\n+                }\n+                for (auto it = pto->m_set_one_hop_tx_to_send.begin(); it != pto->m_set_one_hop_tx_to_send.end(); ++it) {\n+                    vInvTx.emplace_back(true, it);\n                 }\n                 CAmount filterrate = 0;\n                 {\n@@ -3775,11 +3783,12 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                 while (!vInvTx.empty() && nRelayedTransactions < INVENTORY_BROADCAST_MAX) {\n                     // Fetch the top element from the heap\n                     std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n-                    std::set<uint256>::iterator it = vInvTx.back();\n+                    auto tx_inv = vInvTx.back();\n                     vInvTx.pop_back();\n-                    uint256 hash = *it;\n+                    const uint256& hash = *(tx_inv.second);\n+                    const bool tx_last_hop = tx_inv.first;\n                     // Remove it from the to-be-sent set\n-                    pto->setInventoryTxToSend.erase(it);\n+                    tx_last_hop ? pto->m_set_one_hop_tx_to_send.erase(tx_inv.second) : pto->setInventoryTxToSend.erase(tx_inv.second);\n                     // Check if not in the filter already\n                     if (pto->filterInventoryKnown.contains(hash)) {\n                         continue;\n@@ -3804,11 +3813,37 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                             vRelayExpiration.pop_front();\n                         }\n \n+                        // Expire old one-hop relay messages\n+                        std::set<uint256> expired_one_hop_txs;\n+                        while (!g_relay_expiration_next_hop.empty() && std::get<0>(g_relay_expiration_next_hop.front()) < nNow) {\n+                            NodeId id;\n+                            MapRelay::const_iterator it;\n+                            std::tie(std::ignore, id, it) = g_relay_expiration_next_hop.front();\n+                            connman->ForNode(id, [&it, &expired_one_hop_txs](CNode* node) {\n+                                expired_one_hop_txs.emplace(it->first);\n+                                node->m_map_one_hop_tx_to_send.erase(it);\n+                                return /* ignored */ true;\n+                            });\n+                            g_relay_expiration_next_hop.pop_front();\n+                        }\n+\n+                        for (const auto& txid : expired_one_hop_txs) {\n+                            g_connman->RelayTransaction(/* initial */ false, txid, ::mempool);\n+                        }\n+                    }\n+\n+                    if (tx_last_hop) {\n+                        auto ret = pto->m_map_one_hop_tx_to_send.emplace(hash, std::move(txinfo.tx));\n+                        if (ret.second) {\n+                            g_relay_expiration_next_hop.emplace_back(nNow + 20 * 1000000, pto->GetId(), ret.first);\n+                        }\n+                    } else {\n                         auto ret = mapRelay.insert(std::make_pair(hash, std::move(txinfo.tx)));\n                         if (ret.second) {\n-                            vRelayExpiration.push_back(std::make_pair(nNow + 15 * 60 * 1000000, ret.first));\n+                            vRelayExpiration.emplace_back(nNow + 15 * 60 * 1000000, ret.first);\n                         }\n                     }\n+\n                     if (vInv.size() == MAX_INV_SZ) {\n                         connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                         vInv.clear();"
      },
      {
        "sha": "3efbb2c1350f6a49c209a38c7179dc32569927e8",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e2203b51b1496e05d4a14b95b18cc4996ca87cb/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e2203b51b1496e05d4a14b95b18cc4996ca87cb/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=1e2203b51b1496e05d4a14b95b18cc4996ca87cb",
        "patch": "@@ -1892,7 +1892,7 @@ void CWallet::ReacceptWalletTransactions()\n     }\n }\n \n-bool CWalletTx::RelayWalletTransaction(interfaces::Chain::Lock& locked_chain)\n+bool CWalletTx::RelayWalletTransaction(const bool initial, interfaces::Chain::Lock& locked_chain)\n {\n     assert(pwallet->GetBroadcastTransactions());\n     if (!IsCoinBase() && !isAbandoned() && GetDepthInMainChain(locked_chain) == 0)\n@@ -1902,7 +1902,7 @@ bool CWalletTx::RelayWalletTransaction(interfaces::Chain::Lock& locked_chain)\n         if (InMempool() || AcceptToMemoryPool(locked_chain, state)) {\n             pwallet->WalletLogPrintf(\"Relaying wtx %s\\n\", GetHash().ToString());\n             if (pwallet->chain().p2pEnabled()) {\n-                pwallet->chain().relayTransaction(GetHash());\n+                pwallet->chain().relayTransaction(initial, GetHash());\n                 return true;\n             }\n         }\n@@ -2131,7 +2131,7 @@ std::vector<uint256> CWallet::ResendWalletTransactionsBefore(interfaces::Chain::\n     for (const std::pair<const unsigned int, CWalletTx*>& item : mapSorted)\n     {\n         CWalletTx& wtx = *item.second;\n-        if (wtx.RelayWalletTransaction(locked_chain)) {\n+        if (wtx.RelayWalletTransaction(/* initial */ false, locked_chain)) {\n             result.push_back(wtx.GetHash());\n         }\n     }\n@@ -3182,11 +3182,11 @@ bool CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::ve\n         if (fBroadcastTransactions)\n         {\n             // Broadcast\n-            if (!wtx.AcceptToMemoryPool(*locked_chain, state)) {\n+            if (wtx.AcceptToMemoryPool(*locked_chain, state)) {\n+                wtx.RelayWalletTransaction(/* initial */ true, *locked_chain);\n+            } else {\n                 WalletLogPrintf(\"CommitTransaction(): Transaction cannot be broadcast immediately, %s\\n\", FormatStateMessage(state));\n                 // TODO: if we expect the failure to be long term or permanent, instead delete wtx from the wallet and return failure.\n-            } else {\n-                wtx.RelayWalletTransaction(*locked_chain);\n             }\n         }\n     }"
      },
      {
        "sha": "2a09b42cb7feedb87c445d361c9514455f5d7844",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e2203b51b1496e05d4a14b95b18cc4996ca87cb/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e2203b51b1496e05d4a14b95b18cc4996ca87cb/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=1e2203b51b1496e05d4a14b95b18cc4996ca87cb",
        "patch": "@@ -535,8 +535,8 @@ class CWalletTx : public CMerkleTx\n \n     int64_t GetTxTime() const;\n \n-    // RelayWalletTransaction may only be called if fBroadcastTransactions!\n-    bool RelayWalletTransaction(interfaces::Chain::Lock& locked_chain);\n+    // may only be called if fBroadcastTransactions!\n+    bool RelayWalletTransaction(bool initial, interfaces::Chain::Lock& locked_chain);\n \n     /** Pass this transaction to the mempool. Fails if absolute fee exceeds absurd fee. */\n     bool AcceptToMemoryPool(interfaces::Chain::Lock& locked_chain, CValidationState& state);"
      }
    ]
  }
]