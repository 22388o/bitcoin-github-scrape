[
  {
    "sha": "dc2dfbab6a0f75070fc3b962da4eb2967e9659df",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYzJkZmJhYjZhMGY3NTA3MGZjM2I5NjJkYTRlYjI5NjdlOTY1OWRm",
    "commit": {
      "author": {
        "name": "Bobby Groff",
        "email": "bgroff@lavabit.com",
        "date": "2011-06-29T16:41:19Z"
      },
      "committer": {
        "name": "Bobby Groff",
        "email": "bgroff@lavabit.com",
        "date": "2011-06-29T16:41:19Z"
      },
      "message": "Add scriptPubKey enforced sendescrow and redeemescrow API calls",
      "tree": {
        "sha": "954e078a8c9ee55052c5e634d08df10cd1c3945a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/954e078a8c9ee55052c5e634d08df10cd1c3945a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dc2dfbab6a0f75070fc3b962da4eb2967e9659df",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dc2dfbab6a0f75070fc3b962da4eb2967e9659df",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dc2dfbab6a0f75070fc3b962da4eb2967e9659df",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dc2dfbab6a0f75070fc3b962da4eb2967e9659df/comments",
    "author": {
      "login": "groffer",
      "id": 845963,
      "node_id": "MDQ6VXNlcjg0NTk2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/845963?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/groffer",
      "html_url": "https://github.com/groffer",
      "followers_url": "https://api.github.com/users/groffer/followers",
      "following_url": "https://api.github.com/users/groffer/following{/other_user}",
      "gists_url": "https://api.github.com/users/groffer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/groffer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/groffer/subscriptions",
      "organizations_url": "https://api.github.com/users/groffer/orgs",
      "repos_url": "https://api.github.com/users/groffer/repos",
      "events_url": "https://api.github.com/users/groffer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/groffer/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "groffer",
      "id": 845963,
      "node_id": "MDQ6VXNlcjg0NTk2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/845963?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/groffer",
      "html_url": "https://github.com/groffer",
      "followers_url": "https://api.github.com/users/groffer/followers",
      "following_url": "https://api.github.com/users/groffer/following{/other_user}",
      "gists_url": "https://api.github.com/users/groffer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/groffer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/groffer/subscriptions",
      "organizations_url": "https://api.github.com/users/groffer/orgs",
      "repos_url": "https://api.github.com/users/groffer/repos",
      "events_url": "https://api.github.com/users/groffer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/groffer/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3a3eabb57ae41dd2162ca8230423abf4a90ef644",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3a3eabb57ae41dd2162ca8230423abf4a90ef644",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3a3eabb57ae41dd2162ca8230423abf4a90ef644"
      }
    ],
    "stats": {
      "total": 491,
      "additions": 490,
      "deletions": 1
    },
    "files": [
      {
        "sha": "30a0b2a20eeb415f0499f286ec4f3b1d98eb5e6f",
        "filename": "doc/README_escrow.txt",
        "status": "added",
        "additions": 48,
        "deletions": 0,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dc2dfbab6a0f75070fc3b962da4eb2967e9659df/doc/README_escrow.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dc2dfbab6a0f75070fc3b962da4eb2967e9659df/doc/README_escrow.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README_escrow.txt?ref=dc2dfbab6a0f75070fc3b962da4eb2967e9659df",
        "patch": "@@ -0,0 +1,48 @@\n+Bitcoin Escrow\n+\n+Bitcoin \"escrow\" are coins that are under the control of multiple\n+parties.  The initial implementation allows n parties to vote, with\n+k good signatures needed (k <= n).\n+\n+This eliminates single points of failure and reduces the trust required\n+in many transaction use cases.\n+\n+Use Cases\n+---------\n+\n+Escrow: send money to an escrow coin with three parties - sender,\n+receiver and escrow observer.  Require 2 signatures.  If sender and\n+receiver agree, they can send the coin back to sender, or to receiver.\n+If they disagree, the escrow observer can break the tie by signing with\n+the sender or with the receiver.\n+\n+Immediate payment: send money from sender to a coin with two parties -\n+sender and payment observer.  The payment observer will only agree to a\n+single spend of the money, which prevents double spending.  Of course,\n+the receiver has to trust the observer.  For protection against observer\n+failure, additional observers can be added.  TBD: requires escrow change\n+for leftover funds\n+\n+Secured funds: to increase security of funds, require 2 out of 3\n+parties to sign for disbursement.  This reduces the chance that funds\n+will be stolen because more than one party must be compromised for a\n+successful theft.  This is also useful for storage at third parties\n+such as exchanges, to reduce the chance of mass theft.  Instead of the\n+exchange having full control of the funds, funds can be stored requiring\n+signatures from 2 out of: account holder, exchange, third party observer.\n+TBD: requires escrow change for leftover funds\n+\n+API Calls\n+---------\n+\n+sendescrow <escrowaddrs> <amount> [comment] [comment-to]\n+    <escrowaddrs> is of the form <n>,<addr>,<addr...>\n+    where <n> of the addresses must sign to redeem the escrow\n+    <amount> is a real and is rounded to the nearest 0.00000001\n+\n+redeemescrow <inputtx> <addr> [<txhex>]\n+    where <inputtx> is the escrow transaction ID\n+    <addr> is the destination bitcoin address\n+    <txhex> is a partially signed transaction\n+    the output is either ['partial', <txhex>] if more signatures are needed\n+    or ['complete', <txid>] if the transaction was broadcast"
      },
      {
        "sha": "389fb05bdfcff241b91ee2a44bda05b50a258097",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 361,
        "deletions": 0,
        "changes": 361,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dc2dfbab6a0f75070fc3b962da4eb2967e9659df/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dc2dfbab6a0f75070fc3b962da4eb2967e9659df/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=dc2dfbab6a0f75070fc3b962da4eb2967e9659df",
        "patch": "@@ -8,6 +8,7 @@\n #include \"cryptopp/sha.h\"\n #include <boost/filesystem.hpp>\n #include <boost/filesystem/fstream.hpp>\n+#include <boost/algorithm/string.hpp>\n \n using namespace std;\n using namespace boost;\n@@ -3112,3 +3113,363 @@ void GenerateBitcoins(bool fGenerate, CWallet* pwallet)\n         }\n     }\n }\n+\n+// Extract addresses that vote and number of required votes in an escrow transaction\n+// from the scriptPubKey\n+bool ExtractEscrowAddresses(const CScript& scriptPubKey, vector<uint160>& addresses, int& nVotes)\n+{\n+    extern CBigNum CastToBigNum(const vector<unsigned char>& vch);\n+\n+    opcodetype opcode;\n+    vector<unsigned char> vch;\n+\n+    CScript::const_iterator pc1 = scriptPubKey.begin();\n+\n+    if (!scriptPubKey.GetOp(pc1, opcode, vch))\n+        return false;\n+\n+    if (opcode >= OP_1 && opcode <= OP_16)\n+        nVotes = (int)opcode - (int)(OP_1 - 1);\n+    else\n+    {\n+        try\n+        {\n+            nVotes = CastToBigNum(vch).getint();\n+        }\n+        catch (...)\n+        {\n+            return false;\n+        }\n+    }\n+\n+    if (!scriptPubKey.GetOp(pc1, opcode, vch))\n+        return false;\n+    if (opcode != OP_TOALTSTACK)\n+        return false;\n+\n+    if (!scriptPubKey.GetOp(pc1, opcode, vch))\n+        return false;\n+    if (opcode != OP_0)\n+        return false;\n+\n+    if (!scriptPubKey.GetOp(pc1, opcode, vch))\n+        return false;\n+    if (opcode != OP_TOALTSTACK)\n+        return false;\n+\n+    while (scriptPubKey.GetOp(pc1, opcode, vch))\n+    {\n+        if (opcode == OP_HASH160)\n+        {\n+            if (!scriptPubKey.GetOp(pc1, opcode, vch))\n+                return false;\n+            if (vch.size() != sizeof(uint160))\n+                continue;\n+            addresses.push_back(uint160(vch));\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+// true iff scriptPubKey contains an escrow transaction\n+// TBD: do we need tighther checking of script?\n+bool IsEscrowScript(const CScript& scriptPubKey)\n+{\n+    int nVotes;\n+    vector<uint160> addresses;\n+\n+    return ExtractEscrowAddresses(scriptPubKey, addresses, nVotes);\n+}\n+\n+// Get a UI rendition of the scriptPubKey if it is an escrow transaction\n+bool ExtractEscrowAddress(const CScript& scriptPubKey, string& address)\n+{\n+    address = \"\";\n+    int nVotes;\n+    vector<uint160> addresses;\n+\n+    if (!ExtractEscrowAddresses(scriptPubKey, addresses, nVotes))\n+        return false;\n+\n+    address = strprintf(\"escrow(%d\", nVotes);\n+\n+    BOOST_FOREACH(uint160 hash, addresses)\n+    {\n+        address += \",\" +  Hash160ToAddress(hash);\n+    }\n+\n+    address += \")\";\n+    if (nVotes > addresses.size() || nVotes < 1)\n+        return false;\n+}\n+\n+// Tweak CommitTransaction to allow spending from a transaction that is not\n+// in our wallet.  The original sendtoescrow might have been done by someone else.\n+bool CWallet::CommitTransactionWithForeignInput(CWalletTx& wtxNew, uint256 hashInputTx, CReserveKey& reservekey)\n+{\n+    CRITICAL_BLOCK(cs_main)\n+    {\n+        printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n+        CRITICAL_BLOCK(cs_mapWallet)\n+        {\n+            // This is only to keep the database open to defeat the auto-flush for the\n+            // duration of this scope.  This is the only place where this optimization\n+            // maybe makes sense; please don't do it anywhere else.\n+            CWalletDB walletdb(\"r\");\n+\n+            // Take key pair from key pool so it won't be used again\n+            reservekey.KeepKey();\n+\n+            // Add tx to wallet, because if it has change it's also ours,\n+            // otherwise just for transaction history.\n+            AddToWallet(wtxNew);\n+\n+            // Mark old coins as spent\n+            set<CWalletTx*> setCoins;\n+            BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n+            {\n+                // Skip marking as spent if this is the escrow send tx\n+                if (txin.prevout.hash == hashInputTx)\n+                    continue;\n+                CWalletTx &pcoin = mapWallet[txin.prevout.hash];\n+                pcoin.MarkSpent(txin.prevout.n);\n+                pcoin.WriteToDisk();\n+                vWalletUpdated.push_back(pcoin.GetHash());\n+            }\n+        }\n+\n+        // Track how many getdata requests our transaction gets\n+        CRITICAL_BLOCK(cs_mapRequestCount)\n+            mapRequestCount[wtxNew.GetHash()] = 0;\n+\n+        // Broadcast\n+        if (!wtxNew.AcceptToMemoryPool())\n+        {\n+            // This must not fail. The transaction has already been signed and recorded.\n+            printf(\"CommitTransaction() : Error: Transaction not valid\");\n+            return false;\n+        }\n+        wtxNew.RelayWalletTransaction();\n+    }\n+    MainFrameRepaint();\n+    return true;\n+}\n+\n+// Redeem money from an escrow coin\n+// \n+// strAddress - the address to send to\n+// hashInputTx - the escrow coin\n+// strPartialTx - optional, a partially signed (by the counterparties) tx in hex\n+// wtxNew - the tx we are constructing\n+//\n+pair<string,string> CWallet::SendMoneyFromEscrow(string strAddress, uint256 hashInputTx, string strPartialTx, CWalletTx& wtxNew, bool fAskFee)\n+{\n+    CReserveKey reservekey(this);\n+\n+    // Find the escrow coin\n+    CTxDB txdb(\"r\");\n+    CTxIndex txindex;\n+    if (!txdb.ReadTxIndex(hashInputTx, txindex))\n+        return make_pair(\"error\", _(\"Input tx not found\"));\n+    CTransaction txInput;\n+    if (!txInput.ReadFromDisk(txindex.pos))\n+        return make_pair(\"error\", _(\"Input tx not found\"));\n+\n+    int nVotes;\n+    vector<uint160> addresses;\n+\n+    CScript scriptPubKey;\n+    int64 nValue;\n+    int nOut = 0;\n+\n+    // Find the escrow output.  Normally there will be an escrow output and\n+    // a change output.\n+    BOOST_FOREACH(const CTxOut& out, txInput.vout)\n+    {\n+        if (ExtractEscrowAddresses(out.scriptPubKey, addresses, nVotes))\n+        {\n+            scriptPubKey = out.scriptPubKey;\n+            nValue = out.nValue;\n+            break;\n+        }\n+        nOut++;\n+    }\n+\n+    if (addresses.size() == 0)\n+    {\n+        return make_pair(\"error\", _(\"Could not decode input transaction\"));\n+    }\n+\n+    // Handle keys in reverse order due to script being stack based\n+    reverse(addresses.begin(), addresses.end());\n+\n+    CScript scriptOut;\n+    if (!scriptOut.SetBitcoinAddress(strAddress))\n+        return make_pair(\"error\", _(\"Invalid bitcoin address\"));\n+\n+    if (strPartialTx.size() == 0)\n+    {\n+        // If no partial tx, create an empty one\n+        wtxNew.vin.clear();\n+        wtxNew.vout.clear();\n+        wtxNew.vin.push_back(CTxIn(txInput.GetHash(), nOut));\n+        // Parse bitcoin address\n+        wtxNew.vout.push_back(CTxOut(nValue - nTransactionFee, scriptOut));\n+    }\n+    else\n+    {\n+        // If we have a partial tx, make sure it has the expected output\n+        vector<unsigned char> vchPartial = ParseHex(strPartialTx);\n+        CDataStream ss(vchPartial);\n+        ss >> wtxNew;\n+        if (wtxNew.vout.size() != 1 || wtxNew.vout[0].scriptPubKey != scriptOut)\n+            return make_pair(\"error\", _(\"Partial tx not going to the address you specified\"));\n+    }\n+\n+    // Get the hash that we have to sign\n+    extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+    uint256 hash = SignatureHash(scriptPubKey, wtxNew, 0, SIGHASH_ALL);\n+\n+    // Iterate over the old script and construct a new script\n+    CScript scriptSigOld = wtxNew.vin[0].scriptSig;\n+    CScript::const_iterator pcOld = scriptSigOld.begin();\n+\n+    CScript scriptSigNew;\n+\n+    // Sign everything that we can sign\n+    CRITICAL_BLOCK(cs_mapKeys)\n+    {\n+        BOOST_FOREACH(const uint160& address, addresses)\n+        {\n+            string currentAddress = Hash160ToAddress(address);\n+            opcodetype opcode;\n+            vector<unsigned char> vch;\n+\n+            map<uint160, vector<unsigned char> >::iterator mi = mapPubKeys.find(address);\n+            if (mi == mapPubKeys.end())\n+            {\n+                // We can't sign this input, copy old signature or create placeholders\n+                if (pcOld == scriptSigOld.end())\n+                {\n+                    // Push two placeholders for key and sig\n+                    scriptSigNew << vch;\n+                    scriptSigNew << vch;\n+                }\n+                else\n+                {\n+                    if (!scriptSigOld.GetOp(pcOld, opcode, vch))\n+                        throw runtime_error(\"expected an opcode - 1\");\n+                    scriptSigNew << vch;\n+                    if (!scriptSigOld.GetOp(pcOld, opcode, vch))\n+                        throw runtime_error(\"expected an opcode - 2\");\n+                    scriptSigNew << vch;\n+                }\n+                continue;\n+            }\n+\n+            // Found the key - sign this input\n+            const vector<unsigned char>& vchPubKey = (*mi).second;\n+            if (!mapKeys.count(vchPubKey))\n+                return make_pair(\"error\", _(\"failed to sign with one of our keys\"));\n+\n+            vector<unsigned char> vchSig;\n+\n+            if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig))\n+                return make_pair(\"error\", _(\"failed to sign with one of our keys\"));\n+            vchSig.push_back((unsigned char)SIGHASH_ALL);\n+            scriptSigNew << vchSig;\n+            scriptSigNew << vchPubKey;\n+            if (pcOld != scriptSigOld.end())\n+            {\n+                // Skip old placeholders\n+                if (!scriptSigOld.GetOp(pcOld, opcode, vch))\n+                    throw runtime_error(\"expected an opcode - 3\");\n+                if (!scriptSigOld.GetOp(pcOld, opcode, vch))\n+                    throw runtime_error(\"expected an opcode - 4\");\n+            }\n+        }\n+    }\n+\n+    // Use the new scriptSig\n+    wtxNew.vin[0].scriptSig = scriptSigNew;\n+\n+    // Check if it verifies.  If we had to push any placeholders for signatures, it\n+    // will not, and we have to ask the user to have the counterparties sign.\n+    extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+    if (VerifyScript(scriptSigNew, scriptPubKey, wtxNew, 0, 0))\n+    {\n+        // It verifies - we are done and can commit\n+        if (!CommitTransactionWithForeignInput(wtxNew, hashInputTx, reservekey))\n+            return make_pair(\"error\", _(\"Error: The transaction was rejected.  This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\"));\n+\n+        return make_pair(\"complete\", wtxNew.GetHash().GetHex());\n+    }\n+\n+    // It does verify - serialize and convert to hex\n+    CDataStream ss;\n+    ss.reserve(10000);\n+    ss << wtxNew;\n+\n+    return make_pair(\"partial\", HexStr(ss.begin(), ss.end()));\n+}\n+\n+// Send money to escrow\n+// requires cs_main lock\n+string CWallet::SendMoneyToEscrow(string strAddresses, int64 nValue, CWalletTx& wtxNew, bool fAskFee)\n+{\n+    // Check amount\n+    if (nValue <= 0)\n+        return _(\"Invalid amount\");\n+    if (nValue + nTransactionFee > GetBalance())\n+        return _(\"Insufficient funds\");\n+\n+    std::vector<std::string> strs;\n+    boost::split(strs, strAddresses, boost::is_any_of(\",\"));\n+    cout << strs.size() << \"\\n\";\n+    if (strs.size() < 2)\n+        return _(\"Invalid escrow address format\");\n+\n+    int nVotes = atoi(strs[0].c_str());\n+    strs.erase(strs.begin());\n+    if (nVotes < 1 || nVotes > strs.size())\n+        return _(\"Invalid escrow address format\");\n+\n+    CScript scriptPubKey;\n+\n+    // Create the first part of the script - push the required number of votes\n+    // and the running number of votes on the ALT stack\n+    scriptPubKey << nVotes;\n+    scriptPubKey << OP_TOALTSTACK;\n+    scriptPubKey << OP_0; // Start votes at zero\n+    scriptPubKey << OP_TOALTSTACK;\n+\n+    BOOST_FOREACH(string strAddress, strs)\n+    {\n+        // For each address, check it and increment running votes\n+        uint160 hash160;\n+        if (!AddressToHash160(strAddress, hash160))\n+            return _(\"Invalid bitcoin address\");\n+\n+        // ... sig pkey\n+        scriptPubKey\n+            << OP_TUCK  // ... pkey sig pkey\n+            << OP_CHECKSIG // ... pkey success?\n+            << OP_SWAP // ... success? pkey\n+            << OP_HASH160 // ... success? pkeyhash\n+            << hash160\n+            << OP_EQUAL // ... success? hashequals?\n+            << OP_BOOLAND // ... count success?\n+            << OP_FROMALTSTACK // ... count success?\n+            << OP_ADD // ... count\n+            << OP_TOALTSTACK; // ...\n+    }\n+\n+    // pop from ALT stack and compare\n+    scriptPubKey << OP_FROMALTSTACK; // count\n+    scriptPubKey << OP_FROMALTSTACK; // count nvotes\n+    scriptPubKey << OP_GREATERTHANOREQUAL; // count >= nvotes\n+\n+    // The rest is the same as a regular send\n+    return SendMoney(scriptPubKey, nValue, wtxNew, fAskFee);\n+}"
      },
      {
        "sha": "548984c051954040c7dac8549afe956cd9b9cb4a",
        "filename": "src/rpc.cpp",
        "status": "modified",
        "additions": 73,
        "deletions": 0,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dc2dfbab6a0f75070fc3b962da4eb2967e9659df/src/rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dc2dfbab6a0f75070fc3b962da4eb2967e9659df/src/rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc.cpp?ref=dc2dfbab6a0f75070fc3b962da4eb2967e9659df",
        "patch": "@@ -532,6 +532,76 @@ Value sendtoaddress(const Array& params, bool fHelp)\n     return wtx.GetHash().GetHex();\n }\n \n+Value sendescrow(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 2 || params.size() > 4)\n+        throw runtime_error(\n+            \"sendescrow <escrowaddrs> <amount> [comment] [comment-to]\\n\"\n+            \"<escrowaddrs> is of the form <n>,<addr>,<addr...>\\n\"\n+            \"where <n> of the addresses must sign to redeem the escrow\\n\"\n+            \"<amount> is a real and is rounded to the nearest 0.00000001\"\n+            );\n+\n+    string strAddress = params[0].get_str();\n+\n+    // Amount\n+    int64 nAmount = AmountFromValue(params[1]);\n+\n+    // Wallet comments\n+    CWalletTx wtx;\n+    if (params.size() > 2 && params[2].type() != null_type && !params[2].get_str().empty())\n+        wtx.mapValue[\"comment\"] = params[2].get_str();\n+    if (params.size() > 3 && params[3].type() != null_type && !params[3].get_str().empty())\n+        wtx.mapValue[\"to\"]      = params[3].get_str();\n+\n+    CRITICAL_BLOCK(cs_main)\n+    {\n+        string strError = pwalletMain->SendMoneyToEscrow(strAddress, nAmount, wtx);\n+        if (strError != \"\")\n+            throw JSONRPCError(-4, strError);\n+    }\n+\n+    return wtx.GetHash().GetHex();\n+}\n+\n+Value redeemescrow(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+            \"redeemescrow <inputtx> <addr> [<txhex>]\\n\"\n+            \"where <inputtx> is the escrow transaction ID\\n\"\n+            \"<addr> is the destination bitcoin address\\n\"\n+            \"<txhex> is a partially signed transaction\\n\"\n+            \"the output is either ['partial', <txhex>] if more signatures are needed\\n\"\n+            \"or ['complete', <txid>] if the transaction was broadcast\\n\"\n+            );\n+\n+    string strInputTx = params[0].get_str();\n+    string strAddress = params[1].get_str();\n+    string strPartialTx;\n+\n+    if (params.size() == 3)\n+    {\n+        strPartialTx = params[2].get_str();\n+    }\n+\n+    uint256 nInputTx;\n+    nInputTx.SetHex(strInputTx);\n+\n+    CWalletTx wtx;\n+\n+    CRITICAL_BLOCK(cs_main)\n+    {\n+        pair<string,string> result = pwalletMain->SendMoneyFromEscrow(strAddress, nInputTx, strPartialTx, wtx);\n+        if (result.first == \"error\")\n+            throw JSONRPCError(-4, result.second);\n+        Array ret;\n+        ret.push_back(result.first);\n+        ret.push_back(result.second);\n+        return ret;\n+    }\n+}\n+\n \n Value getreceivedbyaddress(const Array& params, bool fHelp)\n {\n@@ -1465,6 +1535,8 @@ pair<string, rpcfn_type> pCallTable[] =\n     make_pair(\"getwork\",               &getwork),\n     make_pair(\"listaccounts\",          &listaccounts),\n     make_pair(\"settxfee\",              &settxfee),\n+    make_pair(\"sendescrow\",            &sendescrow),\n+    make_pair(\"redeemescrow\",          &redeemescrow),\n };\n map<string, rpcfn_type> mapCallTable(pCallTable, pCallTable + sizeof(pCallTable)/sizeof(pCallTable[0]));\n \n@@ -2098,6 +2170,7 @@ int CommandLineRPC(int argc, char *argv[])\n         if (strMethod == \"setgenerate\"            && n > 0) ConvertTo<bool>(params[0]);\n         if (strMethod == \"setgenerate\"            && n > 1) ConvertTo<boost::int64_t>(params[1]);\n         if (strMethod == \"sendtoaddress\"          && n > 1) ConvertTo<double>(params[1]);\n+        if (strMethod == \"sendescrow\"             && n > 1) ConvertTo<double>(params[1]);\n         if (strMethod == \"settxfee\"               && n > 0) ConvertTo<double>(params[0]);\n         if (strMethod == \"getamountreceived\"      && n > 1) ConvertTo<boost::int64_t>(params[1]); // deprecated\n         if (strMethod == \"getreceivedbyaddress\"   && n > 1) ConvertTo<boost::int64_t>(params[1]);"
      },
      {
        "sha": "74588ab6dc11cfb1629cdb77a570489a297ea75a",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dc2dfbab6a0f75070fc3b962da4eb2967e9659df/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dc2dfbab6a0f75070fc3b962da4eb2967e9659df/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=dc2dfbab6a0f75070fc3b962da4eb2967e9659df",
        "patch": "@@ -1082,8 +1082,9 @@ bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash\n \n bool IsStandard(const CScript& scriptPubKey)\n {\n+    extern bool IsEscrowScript(const CScript& scriptPubKey);\n     vector<pair<opcodetype, valtype> > vSolution;\n-    return Solver(scriptPubKey, vSolution);\n+    return Solver(scriptPubKey, vSolution) || IsEscrowScript(scriptPubKey);\n }\n \n "
      },
      {
        "sha": "ff6ec9240b5475083593efccb83ff125c43b7123",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dc2dfbab6a0f75070fc3b962da4eb2967e9659df/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dc2dfbab6a0f75070fc3b962da4eb2967e9659df/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=dc2dfbab6a0f75070fc3b962da4eb2967e9659df",
        "patch": "@@ -272,10 +272,13 @@ void CWalletTx::GetAmounts(int64& nGeneratedImmature, int64& nGeneratedMature, l\n         string address;\n         uint160 hash160;\n         vector<unsigned char> vchPubKey;\n+        extern bool ExtractEscrowAddress(const CScript& scriptPubKey, string& address);\n         if (ExtractHash160(txout.scriptPubKey, hash160))\n             address = Hash160ToAddress(hash160);\n         else if (ExtractPubKey(txout.scriptPubKey, NULL, vchPubKey))\n             address = PubKeyToAddress(vchPubKey);\n+        else if (ExtractEscrowAddress(txout.scriptPubKey, address))\n+        \t;\n         else\n         {\n             printf(\"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\","
      },
      {
        "sha": "87547c6e2f755a30a4ce321b524703301b52b2f4",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dc2dfbab6a0f75070fc3b962da4eb2967e9659df/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dc2dfbab6a0f75070fc3b962da4eb2967e9659df/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=dc2dfbab6a0f75070fc3b962da4eb2967e9659df",
        "patch": "@@ -60,9 +60,12 @@ class CWallet : public CKeyStore\n     bool CreateTransaction(const std::vector<std::pair<CScript, int64> >& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet);\n     bool CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet);\n     bool CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey);\n+    bool CommitTransactionWithForeignInput(CWalletTx& wtxNew, uint256 hashInputTx, CReserveKey& reservekey);\n     bool BroadcastTransaction(CWalletTx& wtxNew);\n     std::string SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, bool fAskFee=false);\n     std::string SendMoneyToBitcoinAddress(std::string strAddress, int64 nValue, CWalletTx& wtxNew, bool fAskFee=false);\n+    std::pair<std::string, std::string> SendMoneyFromEscrow(std::string strAddress, uint256 hashInputTx, std::string strPartialTx, CWalletTx& wtxNew, bool fAskFee=false);\n+    std::string SendMoneyToEscrow(std::string strAddresses, int64 nValue, CWalletTx& wtxNew, bool fAskFee=false);\n \n     void ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool);\n     void KeepKey(int64 nIndex);"
      }
    ]
  },
  {
    "sha": "77f429dfaabd9a077662d2c66df72fa47addeff5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3N2Y0MjlkZmFhYmQ5YTA3NzY2MmQyYzY2ZGY3MmZhNDdhZGRlZmY1",
    "commit": {
      "author": {
        "name": "Bobby Groff",
        "email": "bgroff@lavabit.com",
        "date": "2011-06-29T04:46:43Z"
      },
      "committer": {
        "name": "Bobby Groff",
        "email": "bgroff@lavabit.com",
        "date": "2011-06-30T01:37:18Z"
      },
      "message": "Rename escrow to multisign, use CHECKMULTISIG, add tests",
      "tree": {
        "sha": "cc3e68d603c441295cf11585cf3390d578403c63",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cc3e68d603c441295cf11585cf3390d578403c63"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/77f429dfaabd9a077662d2c66df72fa47addeff5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/77f429dfaabd9a077662d2c66df72fa47addeff5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/77f429dfaabd9a077662d2c66df72fa47addeff5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/77f429dfaabd9a077662d2c66df72fa47addeff5/comments",
    "author": {
      "login": "groffer",
      "id": 845963,
      "node_id": "MDQ6VXNlcjg0NTk2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/845963?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/groffer",
      "html_url": "https://github.com/groffer",
      "followers_url": "https://api.github.com/users/groffer/followers",
      "following_url": "https://api.github.com/users/groffer/following{/other_user}",
      "gists_url": "https://api.github.com/users/groffer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/groffer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/groffer/subscriptions",
      "organizations_url": "https://api.github.com/users/groffer/orgs",
      "repos_url": "https://api.github.com/users/groffer/repos",
      "events_url": "https://api.github.com/users/groffer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/groffer/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "groffer",
      "id": 845963,
      "node_id": "MDQ6VXNlcjg0NTk2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/845963?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/groffer",
      "html_url": "https://github.com/groffer",
      "followers_url": "https://api.github.com/users/groffer/followers",
      "following_url": "https://api.github.com/users/groffer/following{/other_user}",
      "gists_url": "https://api.github.com/users/groffer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/groffer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/groffer/subscriptions",
      "organizations_url": "https://api.github.com/users/groffer/orgs",
      "repos_url": "https://api.github.com/users/groffer/repos",
      "events_url": "https://api.github.com/users/groffer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/groffer/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dc2dfbab6a0f75070fc3b962da4eb2967e9659df",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dc2dfbab6a0f75070fc3b962da4eb2967e9659df",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dc2dfbab6a0f75070fc3b962da4eb2967e9659df"
      }
    ],
    "stats": {
      "total": 1048,
      "additions": 665,
      "deletions": 383
    },
    "files": [
      {
        "sha": "9fd408322a744118b808d9eddcc07be6b9393b06",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77f429dfaabd9a077662d2c66df72fa47addeff5/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77f429dfaabd9a077662d2c66df72fa47addeff5/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=77f429dfaabd9a077662d2c66df72fa47addeff5",
        "patch": "@@ -80,6 +80,7 @@ void HandleSIGTERM(int)\n // Start\n //\n #ifndef GUI\n+#ifndef NOMAIN\n int main(int argc, char* argv[])\n {\n     bool fRet = false;\n@@ -91,6 +92,7 @@ int main(int argc, char* argv[])\n     return 1;\n }\n #endif\n+#endif\n \n bool AppInit(int argc, char* argv[])\n {"
      },
      {
        "sha": "3b6787e59280cbb21d2013bb15920a2e0c05e0f8",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 360,
        "changes": 360,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77f429dfaabd9a077662d2c66df72fa47addeff5/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77f429dfaabd9a077662d2c66df72fa47addeff5/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=77f429dfaabd9a077662d2c66df72fa47addeff5",
        "patch": "@@ -8,7 +8,6 @@\n #include \"cryptopp/sha.h\"\n #include <boost/filesystem.hpp>\n #include <boost/filesystem/fstream.hpp>\n-#include <boost/algorithm/string.hpp>\n \n using namespace std;\n using namespace boost;\n@@ -3114,362 +3113,3 @@ void GenerateBitcoins(bool fGenerate, CWallet* pwallet)\n     }\n }\n \n-// Extract addresses that vote and number of required votes in an escrow transaction\n-// from the scriptPubKey\n-bool ExtractEscrowAddresses(const CScript& scriptPubKey, vector<uint160>& addresses, int& nVotes)\n-{\n-    extern CBigNum CastToBigNum(const vector<unsigned char>& vch);\n-\n-    opcodetype opcode;\n-    vector<unsigned char> vch;\n-\n-    CScript::const_iterator pc1 = scriptPubKey.begin();\n-\n-    if (!scriptPubKey.GetOp(pc1, opcode, vch))\n-        return false;\n-\n-    if (opcode >= OP_1 && opcode <= OP_16)\n-        nVotes = (int)opcode - (int)(OP_1 - 1);\n-    else\n-    {\n-        try\n-        {\n-            nVotes = CastToBigNum(vch).getint();\n-        }\n-        catch (...)\n-        {\n-            return false;\n-        }\n-    }\n-\n-    if (!scriptPubKey.GetOp(pc1, opcode, vch))\n-        return false;\n-    if (opcode != OP_TOALTSTACK)\n-        return false;\n-\n-    if (!scriptPubKey.GetOp(pc1, opcode, vch))\n-        return false;\n-    if (opcode != OP_0)\n-        return false;\n-\n-    if (!scriptPubKey.GetOp(pc1, opcode, vch))\n-        return false;\n-    if (opcode != OP_TOALTSTACK)\n-        return false;\n-\n-    while (scriptPubKey.GetOp(pc1, opcode, vch))\n-    {\n-        if (opcode == OP_HASH160)\n-        {\n-            if (!scriptPubKey.GetOp(pc1, opcode, vch))\n-                return false;\n-            if (vch.size() != sizeof(uint160))\n-                continue;\n-            addresses.push_back(uint160(vch));\n-        }\n-    }\n-\n-    return true;\n-}\n-\n-// true iff scriptPubKey contains an escrow transaction\n-// TBD: do we need tighther checking of script?\n-bool IsEscrowScript(const CScript& scriptPubKey)\n-{\n-    int nVotes;\n-    vector<uint160> addresses;\n-\n-    return ExtractEscrowAddresses(scriptPubKey, addresses, nVotes);\n-}\n-\n-// Get a UI rendition of the scriptPubKey if it is an escrow transaction\n-bool ExtractEscrowAddress(const CScript& scriptPubKey, string& address)\n-{\n-    address = \"\";\n-    int nVotes;\n-    vector<uint160> addresses;\n-\n-    if (!ExtractEscrowAddresses(scriptPubKey, addresses, nVotes))\n-        return false;\n-\n-    address = strprintf(\"escrow(%d\", nVotes);\n-\n-    BOOST_FOREACH(uint160 hash, addresses)\n-    {\n-        address += \",\" +  Hash160ToAddress(hash);\n-    }\n-\n-    address += \")\";\n-    if (nVotes > addresses.size() || nVotes < 1)\n-        return false;\n-}\n-\n-// Tweak CommitTransaction to allow spending from a transaction that is not\n-// in our wallet.  The original sendtoescrow might have been done by someone else.\n-bool CWallet::CommitTransactionWithForeignInput(CWalletTx& wtxNew, uint256 hashInputTx, CReserveKey& reservekey)\n-{\n-    CRITICAL_BLOCK(cs_main)\n-    {\n-        printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n-        CRITICAL_BLOCK(cs_mapWallet)\n-        {\n-            // This is only to keep the database open to defeat the auto-flush for the\n-            // duration of this scope.  This is the only place where this optimization\n-            // maybe makes sense; please don't do it anywhere else.\n-            CWalletDB walletdb(\"r\");\n-\n-            // Take key pair from key pool so it won't be used again\n-            reservekey.KeepKey();\n-\n-            // Add tx to wallet, because if it has change it's also ours,\n-            // otherwise just for transaction history.\n-            AddToWallet(wtxNew);\n-\n-            // Mark old coins as spent\n-            set<CWalletTx*> setCoins;\n-            BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n-            {\n-                // Skip marking as spent if this is the escrow send tx\n-                if (txin.prevout.hash == hashInputTx)\n-                    continue;\n-                CWalletTx &pcoin = mapWallet[txin.prevout.hash];\n-                pcoin.MarkSpent(txin.prevout.n);\n-                pcoin.WriteToDisk();\n-                vWalletUpdated.push_back(pcoin.GetHash());\n-            }\n-        }\n-\n-        // Track how many getdata requests our transaction gets\n-        CRITICAL_BLOCK(cs_mapRequestCount)\n-            mapRequestCount[wtxNew.GetHash()] = 0;\n-\n-        // Broadcast\n-        if (!wtxNew.AcceptToMemoryPool())\n-        {\n-            // This must not fail. The transaction has already been signed and recorded.\n-            printf(\"CommitTransaction() : Error: Transaction not valid\");\n-            return false;\n-        }\n-        wtxNew.RelayWalletTransaction();\n-    }\n-    MainFrameRepaint();\n-    return true;\n-}\n-\n-// Redeem money from an escrow coin\n-// \n-// strAddress - the address to send to\n-// hashInputTx - the escrow coin\n-// strPartialTx - optional, a partially signed (by the counterparties) tx in hex\n-// wtxNew - the tx we are constructing\n-//\n-pair<string,string> CWallet::SendMoneyFromEscrow(string strAddress, uint256 hashInputTx, string strPartialTx, CWalletTx& wtxNew, bool fAskFee)\n-{\n-    CReserveKey reservekey(this);\n-\n-    // Find the escrow coin\n-    CTxDB txdb(\"r\");\n-    CTxIndex txindex;\n-    if (!txdb.ReadTxIndex(hashInputTx, txindex))\n-        return make_pair(\"error\", _(\"Input tx not found\"));\n-    CTransaction txInput;\n-    if (!txInput.ReadFromDisk(txindex.pos))\n-        return make_pair(\"error\", _(\"Input tx not found\"));\n-\n-    int nVotes;\n-    vector<uint160> addresses;\n-\n-    CScript scriptPubKey;\n-    int64 nValue;\n-    int nOut = 0;\n-\n-    // Find the escrow output.  Normally there will be an escrow output and\n-    // a change output.\n-    BOOST_FOREACH(const CTxOut& out, txInput.vout)\n-    {\n-        if (ExtractEscrowAddresses(out.scriptPubKey, addresses, nVotes))\n-        {\n-            scriptPubKey = out.scriptPubKey;\n-            nValue = out.nValue;\n-            break;\n-        }\n-        nOut++;\n-    }\n-\n-    if (addresses.size() == 0)\n-    {\n-        return make_pair(\"error\", _(\"Could not decode input transaction\"));\n-    }\n-\n-    // Handle keys in reverse order due to script being stack based\n-    reverse(addresses.begin(), addresses.end());\n-\n-    CScript scriptOut;\n-    if (!scriptOut.SetBitcoinAddress(strAddress))\n-        return make_pair(\"error\", _(\"Invalid bitcoin address\"));\n-\n-    if (strPartialTx.size() == 0)\n-    {\n-        // If no partial tx, create an empty one\n-        wtxNew.vin.clear();\n-        wtxNew.vout.clear();\n-        wtxNew.vin.push_back(CTxIn(txInput.GetHash(), nOut));\n-        // Parse bitcoin address\n-        wtxNew.vout.push_back(CTxOut(nValue - nTransactionFee, scriptOut));\n-    }\n-    else\n-    {\n-        // If we have a partial tx, make sure it has the expected output\n-        vector<unsigned char> vchPartial = ParseHex(strPartialTx);\n-        CDataStream ss(vchPartial);\n-        ss >> wtxNew;\n-        if (wtxNew.vout.size() != 1 || wtxNew.vout[0].scriptPubKey != scriptOut)\n-            return make_pair(\"error\", _(\"Partial tx not going to the address you specified\"));\n-    }\n-\n-    // Get the hash that we have to sign\n-    extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n-    uint256 hash = SignatureHash(scriptPubKey, wtxNew, 0, SIGHASH_ALL);\n-\n-    // Iterate over the old script and construct a new script\n-    CScript scriptSigOld = wtxNew.vin[0].scriptSig;\n-    CScript::const_iterator pcOld = scriptSigOld.begin();\n-\n-    CScript scriptSigNew;\n-\n-    // Sign everything that we can sign\n-    CRITICAL_BLOCK(cs_mapKeys)\n-    {\n-        BOOST_FOREACH(const uint160& address, addresses)\n-        {\n-            string currentAddress = Hash160ToAddress(address);\n-            opcodetype opcode;\n-            vector<unsigned char> vch;\n-\n-            map<uint160, vector<unsigned char> >::iterator mi = mapPubKeys.find(address);\n-            if (mi == mapPubKeys.end())\n-            {\n-                // We can't sign this input, copy old signature or create placeholders\n-                if (pcOld == scriptSigOld.end())\n-                {\n-                    // Push two placeholders for key and sig\n-                    scriptSigNew << vch;\n-                    scriptSigNew << vch;\n-                }\n-                else\n-                {\n-                    if (!scriptSigOld.GetOp(pcOld, opcode, vch))\n-                        throw runtime_error(\"expected an opcode - 1\");\n-                    scriptSigNew << vch;\n-                    if (!scriptSigOld.GetOp(pcOld, opcode, vch))\n-                        throw runtime_error(\"expected an opcode - 2\");\n-                    scriptSigNew << vch;\n-                }\n-                continue;\n-            }\n-\n-            // Found the key - sign this input\n-            const vector<unsigned char>& vchPubKey = (*mi).second;\n-            if (!mapKeys.count(vchPubKey))\n-                return make_pair(\"error\", _(\"failed to sign with one of our keys\"));\n-\n-            vector<unsigned char> vchSig;\n-\n-            if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig))\n-                return make_pair(\"error\", _(\"failed to sign with one of our keys\"));\n-            vchSig.push_back((unsigned char)SIGHASH_ALL);\n-            scriptSigNew << vchSig;\n-            scriptSigNew << vchPubKey;\n-            if (pcOld != scriptSigOld.end())\n-            {\n-                // Skip old placeholders\n-                if (!scriptSigOld.GetOp(pcOld, opcode, vch))\n-                    throw runtime_error(\"expected an opcode - 3\");\n-                if (!scriptSigOld.GetOp(pcOld, opcode, vch))\n-                    throw runtime_error(\"expected an opcode - 4\");\n-            }\n-        }\n-    }\n-\n-    // Use the new scriptSig\n-    wtxNew.vin[0].scriptSig = scriptSigNew;\n-\n-    // Check if it verifies.  If we had to push any placeholders for signatures, it\n-    // will not, and we have to ask the user to have the counterparties sign.\n-    extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int nHashType);\n-    if (VerifyScript(scriptSigNew, scriptPubKey, wtxNew, 0, 0))\n-    {\n-        // It verifies - we are done and can commit\n-        if (!CommitTransactionWithForeignInput(wtxNew, hashInputTx, reservekey))\n-            return make_pair(\"error\", _(\"Error: The transaction was rejected.  This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\"));\n-\n-        return make_pair(\"complete\", wtxNew.GetHash().GetHex());\n-    }\n-\n-    // It does verify - serialize and convert to hex\n-    CDataStream ss;\n-    ss.reserve(10000);\n-    ss << wtxNew;\n-\n-    return make_pair(\"partial\", HexStr(ss.begin(), ss.end()));\n-}\n-\n-// Send money to escrow\n-// requires cs_main lock\n-string CWallet::SendMoneyToEscrow(string strAddresses, int64 nValue, CWalletTx& wtxNew, bool fAskFee)\n-{\n-    // Check amount\n-    if (nValue <= 0)\n-        return _(\"Invalid amount\");\n-    if (nValue + nTransactionFee > GetBalance())\n-        return _(\"Insufficient funds\");\n-\n-    std::vector<std::string> strs;\n-    boost::split(strs, strAddresses, boost::is_any_of(\",\"));\n-    cout << strs.size() << \"\\n\";\n-    if (strs.size() < 2)\n-        return _(\"Invalid escrow address format\");\n-\n-    int nVotes = atoi(strs[0].c_str());\n-    strs.erase(strs.begin());\n-    if (nVotes < 1 || nVotes > strs.size())\n-        return _(\"Invalid escrow address format\");\n-\n-    CScript scriptPubKey;\n-\n-    // Create the first part of the script - push the required number of votes\n-    // and the running number of votes on the ALT stack\n-    scriptPubKey << nVotes;\n-    scriptPubKey << OP_TOALTSTACK;\n-    scriptPubKey << OP_0; // Start votes at zero\n-    scriptPubKey << OP_TOALTSTACK;\n-\n-    BOOST_FOREACH(string strAddress, strs)\n-    {\n-        // For each address, check it and increment running votes\n-        uint160 hash160;\n-        if (!AddressToHash160(strAddress, hash160))\n-            return _(\"Invalid bitcoin address\");\n-\n-        // ... sig pkey\n-        scriptPubKey\n-            << OP_TUCK  // ... pkey sig pkey\n-            << OP_CHECKSIG // ... pkey success?\n-            << OP_SWAP // ... success? pkey\n-            << OP_HASH160 // ... success? pkeyhash\n-            << hash160\n-            << OP_EQUAL // ... success? hashequals?\n-            << OP_BOOLAND // ... count success?\n-            << OP_FROMALTSTACK // ... count success?\n-            << OP_ADD // ... count\n-            << OP_TOALTSTACK; // ...\n-    }\n-\n-    // pop from ALT stack and compare\n-    scriptPubKey << OP_FROMALTSTACK; // count\n-    scriptPubKey << OP_FROMALTSTACK; // count nvotes\n-    scriptPubKey << OP_GREATERTHANOREQUAL; // count >= nvotes\n-\n-    // The rest is the same as a regular send\n-    return SendMoney(scriptPubKey, nValue, wtxNew, fAskFee);\n-}"
      },
      {
        "sha": "70fe604da4a55c72dca23701410f24d42c8d83f6",
        "filename": "src/makefile.unix",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77f429dfaabd9a077662d2c66df72fa47addeff5/src/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77f429dfaabd9a077662d2c66df72fa47addeff5/src/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.unix?ref=77f429dfaabd9a077662d2c66df72fa47addeff5",
        "patch": "@@ -51,7 +51,6 @@ OBJS= \\\n     obj/main.o \\\n     obj/wallet.o \\\n     obj/rpc.o \\\n-    obj/init.o \\\n     cryptopp/obj/sha.o \\\n     cryptopp/obj/cpu.o\n \n@@ -65,20 +64,25 @@ obj/%.o: %.cpp $(HEADERS)\n cryptopp/obj/%.o: cryptopp/%.cpp\n \t$(CXX) -c $(CXXFLAGS) -O3 -o $@ $<\n \n-bitcoin: $(OBJS) obj/ui.o obj/uibase.o\n+bitcoin: $(OBJS) obj/init.o obj/ui.o obj/uibase.o\n \t$(CXX) $(CXXFLAGS) -o $@ $^ $(WXLIBS) $(LIBS)\n \n \n obj/nogui/%.o: %.cpp $(HEADERS)\n \t$(CXX) -c $(CXXFLAGS) -o $@ $<\n \n-bitcoind: $(OBJS:obj/%=obj/nogui/%)\n+obj/init-nomain.o: init.cpp $(HEADERS)\n+\t$(CXX) -c $(CXXFLAGS) -DNOMAIN -o $@ $<\n+\n+bitcoind: $(OBJS:obj/%=obj/nogui/%) obj/nogui/init.o\n \t$(CXX) $(CXXFLAGS) -o $@ $^ $(LIBS)\n \n obj/test/%.o: test/%.cpp $(HEADERS)\n \t$(CXX) -c $(CFLAGS) -o $@ $<\n \n-test_bitcoin: obj/test/test_bitcoin.o\n+obj/nogui/test/test_bitcoin.o: test/wallet_tests.cpp\n+\n+test_bitcoin: obj/nogui/test/test_bitcoin.o $(OBJS:obj/%=obj/nogui/%) obj/init-nomain.o\n \t$(CXX) $(CFLAGS) -o $@ $(LIBPATHS) $^ $(LIBS) -lboost_unit_test_framework\n \n clean:"
      },
      {
        "sha": "d6b7ef32c8478a48c3994dcadc86837f4371184d",
        "filename": "src/obj/nogui/test/.gitignore",
        "status": "added",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77f429dfaabd9a077662d2c66df72fa47addeff5/src/obj/nogui/test/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77f429dfaabd9a077662d2c66df72fa47addeff5/src/obj/nogui/test/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/obj/nogui/test/.gitignore?ref=77f429dfaabd9a077662d2c66df72fa47addeff5",
        "patch": "@@ -0,0 +1,2 @@\n+*\n+!.gitignore"
      },
      {
        "sha": "0fbfa71ca84d40f5b8672f3758f9edd1a79ab1a4",
        "filename": "src/rpc.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77f429dfaabd9a077662d2c66df72fa47addeff5/src/rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77f429dfaabd9a077662d2c66df72fa47addeff5/src/rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc.cpp?ref=77f429dfaabd9a077662d2c66df72fa47addeff5",
        "patch": "@@ -532,13 +532,13 @@ Value sendtoaddress(const Array& params, bool fHelp)\n     return wtx.GetHash().GetHex();\n }\n \n-Value sendescrow(const Array& params, bool fHelp)\n+Value sendmultisign(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 2 || params.size() > 4)\n         throw runtime_error(\n-            \"sendescrow <escrowaddrs> <amount> [comment] [comment-to]\\n\"\n-            \"<escrowaddrs> is of the form <n>,<addr>,<addr...>\\n\"\n-            \"where <n> of the addresses must sign to redeem the escrow\\n\"\n+            \"sendmultisign <multisignaddrs> <amount> [comment] [comment-to]\\n\"\n+            \"<multisignaddrs> is of the form <n>,<addr>,<addr...>\\n\"\n+            \"where <n> of the addresses must sign to redeem the multisign\\n\"\n             \"<amount> is a real and is rounded to the nearest 0.00000001\"\n             );\n \n@@ -556,20 +556,20 @@ Value sendescrow(const Array& params, bool fHelp)\n \n     CRITICAL_BLOCK(cs_main)\n     {\n-        string strError = pwalletMain->SendMoneyToEscrow(strAddress, nAmount, wtx);\n+        string strError = pwalletMain->SendMoneyToMultisign(strAddress, nAmount, wtx);\n         if (strError != \"\")\n             throw JSONRPCError(-4, strError);\n     }\n \n     return wtx.GetHash().GetHex();\n }\n \n-Value redeemescrow(const Array& params, bool fHelp)\n+Value redeemmultisign(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 2 || params.size() > 3)\n         throw runtime_error(\n-            \"redeemescrow <inputtx> <addr> [<txhex>]\\n\"\n-            \"where <inputtx> is the escrow transaction ID\\n\"\n+            \"redeemmultisign <inputtx> <addr> [<txhex>]\\n\"\n+            \"where <inputtx> is the multisign transaction ID\\n\"\n             \"<addr> is the destination bitcoin address\\n\"\n             \"<txhex> is a partially signed transaction\\n\"\n             \"the output is either ['partial', <txhex>] if more signatures are needed\\n\"\n@@ -592,7 +592,7 @@ Value redeemescrow(const Array& params, bool fHelp)\n \n     CRITICAL_BLOCK(cs_main)\n     {\n-        pair<string,string> result = pwalletMain->SendMoneyFromEscrow(strAddress, nInputTx, strPartialTx, wtx);\n+        pair<string,string> result = pwalletMain->SendMoneyFromMultisign(strAddress, nInputTx, strPartialTx, wtx);\n         if (result.first == \"error\")\n             throw JSONRPCError(-4, result.second);\n         Array ret;\n@@ -1535,8 +1535,8 @@ pair<string, rpcfn_type> pCallTable[] =\n     make_pair(\"getwork\",               &getwork),\n     make_pair(\"listaccounts\",          &listaccounts),\n     make_pair(\"settxfee\",              &settxfee),\n-    make_pair(\"sendescrow\",            &sendescrow),\n-    make_pair(\"redeemescrow\",          &redeemescrow),\n+    make_pair(\"sendmultisign\",         &sendmultisign),\n+    make_pair(\"redeemmultisign\",       &redeemmultisign),\n };\n map<string, rpcfn_type> mapCallTable(pCallTable, pCallTable + sizeof(pCallTable)/sizeof(pCallTable[0]));\n \n@@ -2170,7 +2170,7 @@ int CommandLineRPC(int argc, char *argv[])\n         if (strMethod == \"setgenerate\"            && n > 0) ConvertTo<bool>(params[0]);\n         if (strMethod == \"setgenerate\"            && n > 1) ConvertTo<boost::int64_t>(params[1]);\n         if (strMethod == \"sendtoaddress\"          && n > 1) ConvertTo<double>(params[1]);\n-        if (strMethod == \"sendescrow\"             && n > 1) ConvertTo<double>(params[1]);\n+        if (strMethod == \"sendmultisign\"             && n > 1) ConvertTo<double>(params[1]);\n         if (strMethod == \"settxfee\"               && n > 0) ConvertTo<double>(params[0]);\n         if (strMethod == \"getamountreceived\"      && n > 1) ConvertTo<boost::int64_t>(params[1]); // deprecated\n         if (strMethod == \"getreceivedbyaddress\"   && n > 1) ConvertTo<boost::int64_t>(params[1]);"
      },
      {
        "sha": "83ee6b9688db27f5c6a2730e74c62fd6d55c38f8",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77f429dfaabd9a077662d2c66df72fa47addeff5/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77f429dfaabd9a077662d2c66df72fa47addeff5/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=77f429dfaabd9a077662d2c66df72fa47addeff5",
        "patch": "@@ -1082,9 +1082,9 @@ bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash\n \n bool IsStandard(const CScript& scriptPubKey)\n {\n-    extern bool IsEscrowScript(const CScript& scriptPubKey);\n+    extern bool IsMultisignScript(const CScript& scriptPubKey);\n     vector<pair<opcodetype, valtype> > vSolution;\n-    return Solver(scriptPubKey, vSolution) || IsEscrowScript(scriptPubKey);\n+    return Solver(scriptPubKey, vSolution) || IsMultisignScript(scriptPubKey);\n }\n \n "
      },
      {
        "sha": "0eb16ccd052c14a564c6154e9362c201cebb1304",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77f429dfaabd9a077662d2c66df72fa47addeff5/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77f429dfaabd9a077662d2c66df72fa47addeff5/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=77f429dfaabd9a077662d2c66df72fa47addeff5",
        "patch": "@@ -1,6 +1,10 @@\n-#define BOOST_TEST_MODULE uint160\n+#define BOOST_TEST_DYN_LINK\n+#define BOOST_TEST_MODULE bitcoin\n+\n #include <boost/test/unit_test.hpp>\n \n #include \"uint160_tests.cpp\"\n #include \"uint256_tests.cpp\"\n \n+#include \"wallet_tests.cpp\"\n+"
      },
      {
        "sha": "15630054c1a7755ae0f2384d19b08f96c90cd798",
        "filename": "src/test/wallet_tests.cpp",
        "status": "added",
        "additions": 180,
        "deletions": 0,
        "changes": 180,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77f429dfaabd9a077662d2c66df72fa47addeff5/src/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77f429dfaabd9a077662d2c66df72fa47addeff5/src/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/wallet_tests.cpp?ref=77f429dfaabd9a077662d2c66df72fa47addeff5",
        "patch": "@@ -0,0 +1,180 @@\n+#include \"../headers.h\"\n+\n+using namespace std;\n+extern string MakeMultisignScript(string strAddresses, CScript& scriptPubKey);\n+extern bool IsMultisignScript(const CScript& scriptPubKey);\n+extern bool ExtractMultisignAddress(const CScript& scriptPubKey, string& address);\n+\n+static void ShutdownAtExit() {\n+    static bool fDidShutdown = false;\n+    if (!fDidShutdown)\n+        DBFlush(true);\n+    fDidShutdown = true;\n+}\n+\n+struct WalletFixture\n+{\n+    CWallet* wallet;\n+    CWallet* wallet2;\n+    CWallet* wallet3;\n+    string strAddress1;\n+    string strAddress2;\n+    string strAddress3;\n+    string strAddressOut;\n+    string strMultisignAddress;\n+    string strMultisignAddress2;\n+    string strMultisignAddress2of3;\n+\n+    WalletFixture()\n+    {\n+        fTestNet = true;\n+        bool fFirst = true;\n+\n+        wallet = new CWallet(\"test_wallet1.dat\");\n+        wallet->LoadWallet(fFirst);\n+        wallet2 = new CWallet(\"test_wallet2.dat\");\n+        wallet2->LoadWallet(fFirst);\n+        wallet3 = new CWallet(\"test_wallet3.dat\");\n+        wallet3->LoadWallet(fFirst);\n+        strAddress1 = PubKeyToAddress(wallet->GetKeyFromKeyPool());\n+        //cout << \"a1:\" << strAddress1 << \"\\n\";\n+        strAddressOut = PubKeyToAddress(wallet->GetKeyFromKeyPool());\n+        strAddress2 = PubKeyToAddress(wallet2->GetKeyFromKeyPool());\n+        strAddress3 = PubKeyToAddress(wallet3->GetKeyFromKeyPool());\n+        //cout << \"a2:\" << strAddress2 << \"\\n\";\n+        strMultisignAddress = string(\"1,\") + strAddress1 + \",\" + strAddress2;\n+        strMultisignAddress2 = string(\"2,\") + strAddress1 + \",\" + strAddress2;\n+        strMultisignAddress2of3 = string(\"2,\") + strAddress1 + \",\" + strAddress2 + \",\" + strAddress3;\n+    }\n+\n+    ~WalletFixture()\n+    {\n+        delete wallet;\n+        delete wallet2;\n+        delete wallet3;\n+        atexit(ShutdownAtExit);\n+    }\n+};\n+\n+BOOST_FIXTURE_TEST_SUITE(wallet_tests, WalletFixture);\n+\n+BOOST_AUTO_TEST_CASE(keys)\n+{\n+    vector<unsigned char> vchPubKey = wallet->GetKeyFromKeyPool();\n+    BOOST_CHECK(wallet->mapKeys.count(vchPubKey));\n+}\n+\n+BOOST_AUTO_TEST_CASE(multisign_address_format)\n+{\n+    CScript script;\n+    fTestNet = true;\n+    BOOST_CHECK(MakeMultisignScript(\"1\", script) == _(\"Invalid multisign address format\"));\n+    BOOST_CHECK(MakeMultisignScript(string(\"2,\") + strAddress1, script) == _(\"Invalid multisign address format\"));\n+    BOOST_CHECK(MakeMultisignScript(string(\"0,\") + strAddress1, script) == _(\"Invalid multisign address format\"));\n+    BOOST_CHECK(MakeMultisignScript(strMultisignAddress, script) == \"\");\n+    BOOST_CHECK(MakeMultisignScript(strMultisignAddress2, script) == \"\");\n+    BOOST_CHECK(MakeMultisignScript(string(\"2,\") + strAddress1 + \",v\" + strAddress2, script) == \"Invalid bitcoin address\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(multisign_script)\n+{\n+    CScript script;\n+    string address;\n+    BOOST_CHECK(!IsMultisignScript(script));\n+    BOOST_CHECK(!ExtractMultisignAddress(script, address));\n+\n+    BOOST_CHECK(MakeMultisignScript(strMultisignAddress, script) == \"\");\n+    BOOST_CHECK(IsMultisignScript(script));\n+\n+    BOOST_CHECK(ExtractMultisignAddress(script, address));\n+    BOOST_CHECK(address == string(\"multisign(\") + strMultisignAddress + \")\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(multisign_redeem)\n+{\n+    CScript script;\n+    BOOST_CHECK(MakeMultisignScript(strMultisignAddress, script) == \"\");\n+    CWalletTx wtxSend;\n+    wtxSend.vout.push_back(CTxOut(int64(COIN), script));\n+    uint256 hashSend = wtxSend.GetHash();\n+\n+    CWalletTx wtxRedeem;\n+    pair<string,string> res;\n+    res = wallet->SendMoneyFromMultisignTx(\"aaaaaaa\", wtxSend, \"\", wtxRedeem, false);\n+\n+    BOOST_CHECK(res == make_pair(string(\"error\"), string(_(\"Invalid bitcoin address\"))));\n+\n+    res = wallet->SendMoneyFromMultisignTx(strAddressOut, wtxSend, \"\", wtxRedeem, false);\n+    BOOST_CHECK(res.first == \"verified\");\n+\n+    res = wallet2->SendMoneyFromMultisignTx(strAddressOut, wtxSend, \"\", wtxRedeem, false);\n+    BOOST_CHECK(res.first == \"verified\");\n+\n+    res = wallet3->SendMoneyFromMultisignTx(strAddressOut, wtxSend, \"\", wtxRedeem, false);\n+    BOOST_CHECK(res.first == \"partial\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(multisign_redeem2)\n+{\n+    CScript script;\n+    BOOST_CHECK(MakeMultisignScript(strMultisignAddress2, script) == \"\");\n+    CWalletTx wtxSend;\n+    wtxSend.vout.push_back(CTxOut(int64(COIN), script));\n+    uint256 hashSend = wtxSend.GetHash();\n+\n+    CWalletTx wtxRedeem;\n+    pair<string,string> res;\n+\n+    res = wallet->SendMoneyFromMultisignTx(strAddressOut, wtxSend, \"\", wtxRedeem, false);\n+    BOOST_CHECK(res.first == \"partial\");\n+\n+    res = wallet2->SendMoneyFromMultisignTx(strAddressOut, wtxSend, res.second, wtxRedeem, false);\n+    BOOST_CHECK(res.first == \"verified\");\n+\n+    wtxRedeem = CWalletTx();\n+\n+    res = wallet2->SendMoneyFromMultisignTx(strAddressOut, wtxSend, \"\", wtxRedeem, false);\n+    BOOST_CHECK(res.first == \"partial\");\n+\n+    res = wallet->SendMoneyFromMultisignTx(strAddressOut, wtxSend, res.second, wtxRedeem, false);\n+    BOOST_CHECK(res.first == \"verified\");\n+\n+    wtxRedeem = CWalletTx();\n+    res = wallet3->SendMoneyFromMultisignTx(strAddressOut, wtxSend, \"\", wtxRedeem, false);\n+    BOOST_CHECK(res.first == \"partial\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(multisign_redeem2of3)\n+{\n+    CScript script;\n+    BOOST_CHECK(MakeMultisignScript(strMultisignAddress2of3, script) == \"\");\n+    CWalletTx wtxSend;\n+    wtxSend.vout.push_back(CTxOut(int64(COIN), script));\n+    uint256 hashSend = wtxSend.GetHash();\n+\n+    CWalletTx wtxRedeem;\n+    pair<string,string> res;\n+\n+    res = wallet->SendMoneyFromMultisignTx(strAddressOut, wtxSend, \"\", wtxRedeem, false);\n+    BOOST_CHECK(res.first == \"partial\");\n+\n+    res = wallet2->SendMoneyFromMultisignTx(strAddressOut, wtxSend, res.second, wtxRedeem, false);\n+    BOOST_CHECK(res.first == \"verified\");\n+\n+    wtxRedeem = CWalletTx();\n+\n+    res = wallet2->SendMoneyFromMultisignTx(strAddressOut, wtxSend, \"\", wtxRedeem, false);\n+    BOOST_CHECK(res.first == \"partial\");\n+\n+    res = wallet->SendMoneyFromMultisignTx(strAddressOut, wtxSend, res.second, wtxRedeem, false);\n+    BOOST_CHECK(res.first == \"verified\");\n+\n+    wtxRedeem = CWalletTx();\n+    res = wallet3->SendMoneyFromMultisignTx(strAddressOut, wtxSend, \"\", wtxRedeem, false);\n+    BOOST_CHECK(res.first == \"partial\");\n+\n+    res = wallet->SendMoneyFromMultisignTx(strAddressOut, wtxSend, res.second, wtxRedeem, false);\n+    BOOST_CHECK(res.first == \"verified\");\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "c4bf17628ef963f570b65f2b09839409c84f0c0a",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 451,
        "deletions": 2,
        "changes": 453,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77f429dfaabd9a077662d2c66df72fa47addeff5/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77f429dfaabd9a077662d2c66df72fa47addeff5/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=77f429dfaabd9a077662d2c66df72fa47addeff5",
        "patch": "@@ -5,6 +5,7 @@\n #include \"headers.h\"\n #include \"db.h\"\n #include \"cryptopp/sha.h\"\n+#include <boost/algorithm/string.hpp>\n \n using namespace std;\n \n@@ -272,12 +273,12 @@ void CWalletTx::GetAmounts(int64& nGeneratedImmature, int64& nGeneratedMature, l\n         string address;\n         uint160 hash160;\n         vector<unsigned char> vchPubKey;\n-        extern bool ExtractEscrowAddress(const CScript& scriptPubKey, string& address);\n+        extern bool ExtractMultisignAddress(const CScript& scriptPubKey, string& address);\n         if (ExtractHash160(txout.scriptPubKey, hash160))\n             address = Hash160ToAddress(hash160);\n         else if (ExtractPubKey(txout.scriptPubKey, NULL, vchPubKey))\n             address = PubKeyToAddress(vchPubKey);\n-        else if (ExtractEscrowAddress(txout.scriptPubKey, address))\n+        else if (ExtractMultisignAddress(txout.scriptPubKey, address))\n         \t;\n         else\n         {\n@@ -1118,3 +1119,451 @@ void CReserveKey::ReturnKey()\n     nIndex = -1;\n     vchPubKey.clear();\n }\n+\n+// Extract addresses that vote and number of required votes in an multisign transaction\n+// from the scriptPubKey\n+bool ExtractMultisignAddresses(const CScript& scriptPubKey, vector<uint160>& addresses, int& nVotes)\n+{\n+    extern CBigNum CastToBigNum(const vector<unsigned char>& vch);\n+\n+    opcodetype opcode;\n+    vector<unsigned char> vch;\n+\n+    CScript::const_iterator pc1 = scriptPubKey.begin();\n+\n+    // size\n+    if (!scriptPubKey.GetOp(pc1, opcode, vch))\n+        return false;\n+\n+    if (!scriptPubKey.GetOp(pc1, opcode, vch) || opcode != OP_ROLL)\n+        return false;\n+\n+    if (!scriptPubKey.GetOp(pc1, opcode, vch) || opcode != OP_DUP)\n+        return false;\n+\n+    // nVotes\n+    if (!scriptPubKey.GetOp(pc1, opcode, vch))\n+        return false;\n+\n+    if (opcode >= OP_1 && opcode <= OP_16)\n+        nVotes = (int)opcode - (int)(OP_1 - 1);\n+    else\n+    {\n+        try\n+        {\n+            nVotes = CastToBigNum(vch).getint();\n+        }\n+        catch (...)\n+        {\n+            return false;\n+        }\n+    }\n+\n+    if (!scriptPubKey.GetOp(pc1, opcode, vch) ||\n+            opcode != OP_GREATERTHANOREQUAL)\n+        return false;\n+\n+    while (scriptPubKey.GetOp(pc1, opcode, vch))\n+    {\n+        if (opcode == OP_HASH160)\n+        {\n+            if (!scriptPubKey.GetOp(pc1, opcode, vch))\n+                return false;\n+            if (vch.size() != sizeof(uint160))\n+                continue;\n+            addresses.push_back(uint160(vch));\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+// true iff scriptPubKey contains an multisign transaction\n+// TBD: do we need tighther checking of script?\n+bool IsMultisignScript(const CScript& scriptPubKey)\n+{\n+    int nVotes;\n+    vector<uint160> addresses;\n+\n+    return ExtractMultisignAddresses(scriptPubKey, addresses, nVotes);\n+}\n+\n+// Get a UI rendition of the scriptPubKey if it is an multisign transaction\n+bool ExtractMultisignAddress(const CScript& scriptPubKey, string& address)\n+{\n+    address = \"\";\n+    int nVotes;\n+    vector<uint160> addresses;\n+\n+    if (!ExtractMultisignAddresses(scriptPubKey, addresses, nVotes))\n+        return false;\n+\n+    address = strprintf(\"multisign(%d\", nVotes);\n+\n+    BOOST_FOREACH(uint160 hash, addresses)\n+    {\n+        address += \",\" +  Hash160ToAddress(hash);\n+    }\n+\n+    address += \")\";\n+    if (nVotes > addresses.size() || nVotes < 1)\n+        return false;\n+    return true;\n+}\n+\n+// Tweak CommitTransaction to allow spending from a transaction that is not\n+// in our wallet.  The original sendtomultisign might have been done by someone else.\n+bool CWallet::CommitTransactionWithForeignInput(CWalletTx& wtxNew, uint256 hashInputTx, CReserveKey& reservekey)\n+{\n+    CRITICAL_BLOCK(cs_main)\n+    {\n+        printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n+        CRITICAL_BLOCK(cs_mapWallet)\n+        {\n+            // This is only to keep the database open to defeat the auto-flush for the\n+            // duration of this scope.  This is the only place where this optimization\n+            // maybe makes sense; please don't do it anywhere else.\n+            CWalletDB walletdb(\"r\");\n+\n+            // Take key pair from key pool so it won't be used again\n+            reservekey.KeepKey();\n+\n+            // Add tx to wallet, because if it has change it's also ours,\n+            // otherwise just for transaction history.\n+            AddToWallet(wtxNew);\n+\n+            // Mark old coins as spent\n+            set<CWalletTx*> setCoins;\n+            BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n+            {\n+                // Skip marking as spent if this is the multisign send tx\n+                if (txin.prevout.hash == hashInputTx)\n+                    continue;\n+                CWalletTx &pcoin = mapWallet[txin.prevout.hash];\n+                pcoin.MarkSpent(txin.prevout.n);\n+                pcoin.WriteToDisk();\n+                vWalletUpdated.push_back(pcoin.GetHash());\n+            }\n+        }\n+\n+        // Track how many getdata requests our transaction gets\n+        CRITICAL_BLOCK(cs_mapRequestCount)\n+            mapRequestCount[wtxNew.GetHash()] = 0;\n+\n+        // Broadcast\n+        if (!wtxNew.AcceptToMemoryPool())\n+        {\n+            // This must not fail. The transaction has already been signed and recorded.\n+            printf(\"CommitTransaction() : Error: Transaction not valid\");\n+            return false;\n+        }\n+        wtxNew.RelayWalletTransaction();\n+    }\n+    MainFrameRepaint();\n+    return true;\n+}\n+\n+// Redeem money from a multisign coin\n+// \n+// strAddress - the address to send to\n+// hashInputTx - the multisign coin\n+// strPartialTx - optional, a partially signed (by the counterparties) tx in hex\n+// wtxNew - the tx we are constructing\n+//\n+pair<string,string> CWallet::SendMoneyFromMultisignTx(string strAddress, CTransaction txInput, string strPartialTx, CWalletTx& wtxNew, bool fSubmit, bool fAskFee)\n+{\n+    CReserveKey reservekey(this);\n+\n+    int nVotes;\n+    vector<uint160> addresses;\n+\n+    CScript scriptPubKey;\n+    int64 nValue;\n+    int nOut = 0;\n+\n+    // Find the multisign output.  Normally there will be an multisign output and\n+    // a change output.\n+    BOOST_FOREACH(const CTxOut& out, txInput.vout)\n+    {\n+        if (ExtractMultisignAddresses(out.scriptPubKey, addresses, nVotes))\n+        {\n+            scriptPubKey = out.scriptPubKey;\n+            nValue = out.nValue;\n+            break;\n+        }\n+        nOut++;\n+    }\n+\n+    if (addresses.size() == 0)\n+    {\n+        return make_pair(\"error\", _(\"Could not decode input transaction\"));\n+    }\n+\n+    // Handle keys in reverse order due to script being stack based\n+    //reverse(addresses.begin(), addresses.end());\n+\n+    CScript scriptOut;\n+    if (!scriptOut.SetBitcoinAddress(strAddress))\n+        return make_pair(\"error\", _(\"Invalid bitcoin address\"));\n+\n+    if (strPartialTx.size() == 0)\n+    {\n+        // If no partial tx, create an empty one\n+        wtxNew.vin.clear();\n+        wtxNew.vout.clear();\n+        wtxNew.vin.push_back(CTxIn(txInput.GetHash(), nOut));\n+        // Parse bitcoin address\n+        wtxNew.vout.push_back(CTxOut(nValue - nTransactionFee, scriptOut));\n+    }\n+    else\n+    {\n+        // If we have a partial tx, make sure it has the expected output\n+        vector<unsigned char> vchPartial = ParseHex(strPartialTx);\n+        CDataStream ss(vchPartial);\n+        ss >> wtxNew;\n+        if (wtxNew.vout.size() != 1 || wtxNew.vout[0].scriptPubKey != scriptOut)\n+            return make_pair(\"error\", _(\"Partial tx not going to the address you specified\"));\n+    }\n+\n+    // Get the hash that we have to sign\n+    extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+    uint256 hash = SignatureHash(scriptPubKey, wtxNew, 0, SIGHASH_ALL);\n+\n+    // Iterate over the old script and construct a new script\n+    CScript scriptSigOld = wtxNew.vin[0].scriptSig;\n+    CScript::const_iterator pcOld = scriptSigOld.begin();\n+\n+    vector<vector<unsigned char> > vvchKeys;\n+    vector<vector<unsigned char> > vvchSigs;\n+\n+    opcodetype opcode;\n+\n+    if (scriptSigOld.size() == 0)\n+    {\n+        vector<unsigned char> vch;\n+\n+        // Fill with empty keys and sigs for placeholding\n+        for (int i = 0 ; i < addresses.size() ; i++)\n+        {\n+            vvchKeys.push_back(vch);\n+            vvchSigs.push_back(vch);\n+        }\n+    }\n+    else\n+    {\n+        vector<unsigned char> vch;\n+\n+        if (!scriptSigOld.GetOp(pcOld, opcode, vch) || opcode != OP_0)\n+            throw runtime_error(\"bad multisign script - 0\");\n+\n+        // Go over the sigs\n+        while (true)\n+        {\n+            if (!scriptSigOld.GetOp(pcOld, opcode, vch))\n+                throw runtime_error(\"bad multisign script - 1\");\n+            if (opcode >= OP_1 && opcode <= OP_16)\n+                break;\n+            vvchSigs.push_back(vch);\n+        }\n+\n+        // This includes placeholders empty sigs\n+        if (vvchSigs.size() != addresses.size())\n+        {\n+            throw runtime_error(\"bad multisign script - 2\");\n+        }\n+\n+        while (scriptSigOld.GetOp(pcOld, opcode, vch))\n+        {\n+            vvchKeys.push_back(vch);\n+        }\n+\n+        if (vvchKeys.size() != addresses.size())\n+        {\n+            throw runtime_error(\"bad multisign script - 2\");\n+        }\n+    }\n+\n+    CScript scriptSigNew;\n+    CScript scriptSigNewWithPlaceholders;\n+\n+    // Work around bug in OP_MULTISIGVERIFY - one too many items popped off stack\n+    scriptSigNew << OP_0;\n+    scriptSigNewWithPlaceholders << OP_0;\n+\n+    // Number of non-placeholder sigs\n+    int nSigs = 0;\n+\n+    // Sign everything that we can sign\n+    CRITICAL_BLOCK(cs_mapKeys)\n+    {\n+        int ikey = 0;\n+\n+        BOOST_FOREACH(const uint160& address, addresses)\n+        {\n+            string currentAddress = Hash160ToAddress(address);\n+\n+            map<uint160, vector<unsigned char> >::iterator mi = mapPubKeys.find(address);\n+            if (mi == mapPubKeys.end() || !mapKeys.count((*mi).second))\n+            {\n+                // We can't sign this input\n+                scriptSigNewWithPlaceholders << vvchSigs[ikey];\n+                if (vvchSigs[ikey].size())\n+                {\n+                    scriptSigNew << vvchSigs[ikey];\n+                    nSigs++;\n+                }\n+            }\n+            else\n+            {\n+                // Found the key - sign this input\n+                const vector<unsigned char>& vchPubKey = (*mi).second;\n+\n+                // Fill in pubkey\n+                vvchKeys[ikey] = vchPubKey;\n+\n+                vector<unsigned char> vchSig;\n+\n+                if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig))\n+                    return make_pair(\"error\", _(\"failed to sign with one of our keys\"));\n+                vchSig.push_back((unsigned char)SIGHASH_ALL);\n+                scriptSigNewWithPlaceholders << vchSig;\n+                scriptSigNew << vchSig;\n+                nSigs++;\n+            }\n+\n+            ikey++;\n+        }\n+    }\n+\n+    scriptSigNew << nSigs;\n+    scriptSigNewWithPlaceholders << nSigs;\n+\n+    BOOST_FOREACH(const vector<unsigned char>& vchPubKey, vvchKeys)\n+    {\n+        scriptSigNew << vchPubKey;\n+        scriptSigNewWithPlaceholders << vchPubKey;\n+    }\n+\n+    // Use the new scriptSig\n+    wtxNew.vin[0].scriptSig = scriptSigNew;\n+\n+    // Check if it verifies.  If we had to push any placeholders for signatures, it\n+    // will not, and we have to ask the user to have the counterparties sign.\n+    extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+\n+    if (VerifyScript(scriptSigNew, scriptPubKey, wtxNew, 0, 0))\n+    {\n+        if (fSubmit)\n+        {\n+            // It verifies - we are done and can commit\n+            if (!CommitTransactionWithForeignInput(wtxNew, txInput.GetHash(), reservekey))\n+                return make_pair(\"error\", _(\"Error: The transaction was rejected.  This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\"));\n+\n+            return make_pair(\"complete\", wtxNew.GetHash().GetHex());\n+        }\n+        else\n+        {\n+            // If we were asked not to submit, serialize without placeholders\n+            CDataStream ss;\n+            ss.reserve(10000);\n+            ss << wtxNew;\n+\n+            return make_pair(\"verified\", HexStr(ss.begin(), ss.end()));\n+        }\n+    }\n+\n+    // It does not verify - serialize and convert to hex for other party signature\n+    wtxNew.vin[0].scriptSig = scriptSigNewWithPlaceholders;\n+\n+    CDataStream ss;\n+    ss.reserve(10000);\n+    ss << wtxNew;\n+\n+    return make_pair(\"partial\", HexStr(ss.begin(), ss.end()));\n+}\n+\n+pair<string,string> CWallet::SendMoneyFromMultisign(string strAddress, uint256 hashInputTx, string strPartialTx, CWalletTx& wtxNew, bool fSubmit, bool fAskFee)\n+{\n+    // Find the multisign coin\n+    CTxDB txdb(\"r\");\n+    CTxIndex txindex;\n+    if (!txdb.ReadTxIndex(hashInputTx, txindex))\n+        return make_pair(\"error\", _(\"Input tx not found\"));\n+    CTransaction txInput;\n+    if (!txInput.ReadFromDisk(txindex.pos))\n+        return make_pair(\"error\", _(\"Input tx not found\"));\n+\n+    return SendMoneyFromMultisignTx(strAddress, txInput, strPartialTx, wtxNew, fSubmit, fAskFee);\n+}\n+\n+string MakeMultisignScript(string strAddresses, CScript& scriptPubKey)\n+{\n+    std::vector<std::string> strs;\n+    boost::split(strs, strAddresses, boost::is_any_of(\",\"));\n+    if (strs.size() < 2)\n+        return _(\"Invalid multisign address format\");\n+\n+    int nVotes = atoi(strs[0].c_str());\n+    strs.erase(strs.begin());\n+    if (nVotes < 1 || nVotes > strs.size())\n+        return _(\"Invalid multisign address format\");\n+\n+    // sig1 sig2 ... nsig pub1 pub2 ...\n+    // Check all the pubkeys.  Each must match the respective hash160\n+    // or be zero.\n+\n+    scriptPubKey\n+        << strs.size()\n+        << OP_ROLL // pub1 pub2 ... nsig\n+        << OP_DUP\n+        << nVotes\n+        << OP_GREATERTHANOREQUAL\n+        << OP_VERIFY;\n+\n+    BOOST_FOREACH(string strAddress, strs)\n+    {\n+        // For each address, check it and increment running votes\n+        uint160 hash160;\n+        if (!AddressToHash160(strAddress, hash160))\n+            return _(\"Invalid bitcoin address\");\n+\n+        // ... sig pkey\n+        scriptPubKey     // ... pub_i-1\n+            << strs.size()\n+            << OP_ROLL   // ... pub_i\n+            << OP_SIZE   // ... pub_i non-empty?\n+            << OP_NOT    // ... pub_i empty?\n+            << OP_OVER   // ... pub_i empty? pub_i \n+            << OP_HASH160\n+            << hash160\n+            << OP_EQUAL  // ... pub_i empty? hashequals?\n+            << OP_BOOLOR // ... pub_i success?\n+            << OP_VERIFY;\n+    }\n+\n+    // sig1 sig2 ... nsig pub1 pub2 ...\n+    scriptPubKey << strs.size();\n+    scriptPubKey << OP_CHECKMULTISIG;\n+\n+    return \"\";\n+}\n+\n+// Send money to multisign\n+// requires cs_main lock\n+string CWallet::SendMoneyToMultisign(string strAddresses, int64 nValue, CWalletTx& wtxNew, bool fAskFee)\n+{\n+    // Check amount\n+    if (nValue <= 0)\n+        return _(\"Invalid amount\");\n+    if (nValue + nTransactionFee > GetBalance())\n+        return _(\"Insufficient funds\");\n+\n+    CScript scriptPubKey;\n+    string strResult = MakeMultisignScript(strAddresses, scriptPubKey);\n+    if (strResult != \"\")\n+        return strResult;\n+\n+    // The rest is the same as a regular send\n+    return SendMoney(scriptPubKey, nValue, wtxNew, fAskFee);\n+}\n+"
      },
      {
        "sha": "93989cb7c60b764e9291ccfc4080f3b5ea29be59",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77f429dfaabd9a077662d2c66df72fa47addeff5/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77f429dfaabd9a077662d2c66df72fa47addeff5/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=77f429dfaabd9a077662d2c66df72fa47addeff5",
        "patch": "@@ -64,8 +64,9 @@ class CWallet : public CKeyStore\n     bool BroadcastTransaction(CWalletTx& wtxNew);\n     std::string SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, bool fAskFee=false);\n     std::string SendMoneyToBitcoinAddress(std::string strAddress, int64 nValue, CWalletTx& wtxNew, bool fAskFee=false);\n-    std::pair<std::string, std::string> SendMoneyFromEscrow(std::string strAddress, uint256 hashInputTx, std::string strPartialTx, CWalletTx& wtxNew, bool fAskFee=false);\n-    std::string SendMoneyToEscrow(std::string strAddresses, int64 nValue, CWalletTx& wtxNew, bool fAskFee=false);\n+    std::pair<std::string, std::string> SendMoneyFromMultisign(std::string strAddress, uint256 hashInputTx, std::string strPartialTx, CWalletTx& wtxNew, bool fSubmit=true, bool fAskFee=false);\n+    std::pair<std::string, std::string> SendMoneyFromMultisignTx(std::string strAddress, CTransaction txInput, std::string strPartialTx, CWalletTx& wtxNew, bool fSubmit=true, bool fAskFee=false);\n+    std::string SendMoneyToMultisign(std::string strAddresses, int64 nValue, CWalletTx& wtxNew, bool fAskFee=false);\n \n     void ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool);\n     void KeepKey(int64 nIndex);"
      }
    ]
  },
  {
    "sha": "9e5f0a887d2a4c0063b7ce521af00b6afd64de75",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZTVmMGE4ODdkMmE0YzAwNjNiN2NlNTIxYWYwMGI2YWZkNjRkZTc1",
    "commit": {
      "author": {
        "name": "Bobby Groff",
        "email": "bgroff@lavabit.com",
        "date": "2011-07-03T01:10:46Z"
      },
      "committer": {
        "name": "Bobby Groff",
        "email": "bgroff@lavabit.com",
        "date": "2011-07-03T01:10:46Z"
      },
      "message": "multisign change output for leftover funds",
      "tree": {
        "sha": "3cab272574267a7f416dd60d15f3468987418248",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3cab272574267a7f416dd60d15f3468987418248"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9e5f0a887d2a4c0063b7ce521af00b6afd64de75",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e5f0a887d2a4c0063b7ce521af00b6afd64de75",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9e5f0a887d2a4c0063b7ce521af00b6afd64de75",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e5f0a887d2a4c0063b7ce521af00b6afd64de75/comments",
    "author": {
      "login": "groffer",
      "id": 845963,
      "node_id": "MDQ6VXNlcjg0NTk2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/845963?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/groffer",
      "html_url": "https://github.com/groffer",
      "followers_url": "https://api.github.com/users/groffer/followers",
      "following_url": "https://api.github.com/users/groffer/following{/other_user}",
      "gists_url": "https://api.github.com/users/groffer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/groffer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/groffer/subscriptions",
      "organizations_url": "https://api.github.com/users/groffer/orgs",
      "repos_url": "https://api.github.com/users/groffer/repos",
      "events_url": "https://api.github.com/users/groffer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/groffer/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "groffer",
      "id": 845963,
      "node_id": "MDQ6VXNlcjg0NTk2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/845963?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/groffer",
      "html_url": "https://github.com/groffer",
      "followers_url": "https://api.github.com/users/groffer/followers",
      "following_url": "https://api.github.com/users/groffer/following{/other_user}",
      "gists_url": "https://api.github.com/users/groffer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/groffer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/groffer/subscriptions",
      "organizations_url": "https://api.github.com/users/groffer/orgs",
      "repos_url": "https://api.github.com/users/groffer/repos",
      "events_url": "https://api.github.com/users/groffer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/groffer/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "77f429dfaabd9a077662d2c66df72fa47addeff5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/77f429dfaabd9a077662d2c66df72fa47addeff5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/77f429dfaabd9a077662d2c66df72fa47addeff5"
      }
    ],
    "stats": {
      "total": 162,
      "additions": 128,
      "deletions": 34
    },
    "files": [
      {
        "sha": "ee03c645e59a49ddb2122c559bc3a11faf506e4c",
        "filename": "src/rpc.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 7,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5f0a887d2a4c0063b7ce521af00b6afd64de75/src/rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5f0a887d2a4c0063b7ce521af00b6afd64de75/src/rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc.cpp?ref=9e5f0a887d2a4c0063b7ce521af00b6afd64de75",
        "patch": "@@ -536,8 +536,8 @@ Value sendmultisign(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 2 || params.size() > 4)\n         throw runtime_error(\n-            \"sendmultisign <multisignaddrs> <amount> [comment] [comment-to]\\n\"\n-            \"<multisignaddrs> is of the form <n>,<addr>,<addr...>\\n\"\n+            \"sendmultisign <multisignaddr> <amount> [comment] [comment-to]\\n\"\n+            \"<multisignaddr> is of the form <n>,<addr>,<addr...>\\n\"\n             \"where <n> of the addresses must sign to redeem the multisign\\n\"\n             \"<amount> is a real and is rounded to the nearest 0.00000001\"\n             );\n@@ -566,9 +566,9 @@ Value sendmultisign(const Array& params, bool fHelp)\n \n Value redeemmultisign(const Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() < 2 || params.size() > 3)\n+    if (fHelp || params.size() < 3 || params.size() > 4)\n         throw runtime_error(\n-            \"redeemmultisign <inputtx> <addr> [<txhex>]\\n\"\n+            \"redeemmultisign <inputtx> <addr> <amount> [<txhex>]\\n\"\n             \"where <inputtx> is the multisign transaction ID\\n\"\n             \"<addr> is the destination bitcoin address\\n\"\n             \"<txhex> is a partially signed transaction\\n\"\n@@ -578,11 +578,15 @@ Value redeemmultisign(const Array& params, bool fHelp)\n \n     string strInputTx = params[0].get_str();\n     string strAddress = params[1].get_str();\n+\n+    // Amount\n+    int64 nAmount = AmountFromValue(params[2]);\n+\n     string strPartialTx;\n \n-    if (params.size() == 3)\n+    if (params.size() == 4)\n     {\n-        strPartialTx = params[2].get_str();\n+        strPartialTx = params[3].get_str();\n     }\n \n     uint256 nInputTx;\n@@ -592,7 +596,7 @@ Value redeemmultisign(const Array& params, bool fHelp)\n \n     CRITICAL_BLOCK(cs_main)\n     {\n-        pair<string,string> result = pwalletMain->SendMoneyFromMultisign(strAddress, nInputTx, strPartialTx, wtx);\n+        pair<string,string> result = pwalletMain->SendMoneyFromMultisign(strAddress, nInputTx, nAmount, strPartialTx, wtx);\n         if (result.first == \"error\")\n             throw JSONRPCError(-4, result.second);\n         Array ret;"
      },
      {
        "sha": "b56948e1b93bbf689956a1b16eb4f84ad0370199",
        "filename": "src/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 85,
        "deletions": 18,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5f0a887d2a4c0063b7ce521af00b6afd64de75/src/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5f0a887d2a4c0063b7ce521af00b6afd64de75/src/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/wallet_tests.cpp?ref=9e5f0a887d2a4c0063b7ce521af00b6afd64de75",
        "patch": "@@ -28,6 +28,7 @@ struct WalletFixture\n     WalletFixture()\n     {\n         fTestNet = true;\n+        nTransactionFee = 0;\n         bool fFirst = true;\n \n         wallet = new CWallet(\"test_wallet1.dat\");\n@@ -90,27 +91,38 @@ BOOST_AUTO_TEST_CASE(multisign_script)\n     BOOST_CHECK(address == string(\"multisign(\") + strMultisignAddress + \")\");\n }\n \n+#define SENDMS(wallet, value, partial) res = wallet->SendMoneyFromMultisignTx(strAddressOut, wtxSend, value, partial, wtxRedeem, false)\n+\n BOOST_AUTO_TEST_CASE(multisign_redeem)\n {\n     CScript script;\n     BOOST_CHECK(MakeMultisignScript(strMultisignAddress, script) == \"\");\n     CWalletTx wtxSend;\n-    wtxSend.vout.push_back(CTxOut(int64(COIN), script));\n+    wtxSend.vout.push_back(CTxOut(COIN, script));\n     uint256 hashSend = wtxSend.GetHash();\n \n     CWalletTx wtxRedeem;\n     pair<string,string> res;\n-    res = wallet->SendMoneyFromMultisignTx(\"aaaaaaa\", wtxSend, \"\", wtxRedeem, false);\n+    res = wallet->SendMoneyFromMultisignTx(\"aaaaaaa\", wtxSend, COIN, \"\", wtxRedeem, false);\n \n     BOOST_CHECK(res == make_pair(string(\"error\"), string(_(\"Invalid bitcoin address\"))));\n \n-    res = wallet->SendMoneyFromMultisignTx(strAddressOut, wtxSend, \"\", wtxRedeem, false);\n+    SENDMS(wallet, COIN, \"\");\n     BOOST_CHECK(res.first == \"verified\");\n \n-    res = wallet2->SendMoneyFromMultisignTx(strAddressOut, wtxSend, \"\", wtxRedeem, false);\n+    SENDMS(wallet2, COIN, \"\");\n     BOOST_CHECK(res.first == \"verified\");\n \n-    res = wallet3->SendMoneyFromMultisignTx(strAddressOut, wtxSend, \"\", wtxRedeem, false);\n+// Deserialize and check the outputs\n+    CScript scriptOut;\n+    scriptOut.SetBitcoinAddress(strAddressOut);\n+    CDataStream ss(ParseHex(res.second));\n+    ss >> wtxRedeem;\n+    BOOST_CHECK(wtxRedeem.vout.size() == 1);\n+    BOOST_CHECK(wtxRedeem.vout[0].nValue == COIN);\n+    BOOST_CHECK(wtxRedeem.vout[0].scriptPubKey == scriptOut);\n+\n+    SENDMS(wallet3, COIN, \"\");\n     BOOST_CHECK(res.first == \"partial\");\n }\n \n@@ -119,28 +131,29 @@ BOOST_AUTO_TEST_CASE(multisign_redeem2)\n     CScript script;\n     BOOST_CHECK(MakeMultisignScript(strMultisignAddress2, script) == \"\");\n     CWalletTx wtxSend;\n-    wtxSend.vout.push_back(CTxOut(int64(COIN), script));\n+    wtxSend.vout.push_back(CTxOut(COIN, script));\n     uint256 hashSend = wtxSend.GetHash();\n \n     CWalletTx wtxRedeem;\n     pair<string,string> res;\n \n-    res = wallet->SendMoneyFromMultisignTx(strAddressOut, wtxSend, \"\", wtxRedeem, false);\n+    SENDMS(wallet, COIN, \"\");\n     BOOST_CHECK(res.first == \"partial\");\n \n-    res = wallet2->SendMoneyFromMultisignTx(strAddressOut, wtxSend, res.second, wtxRedeem, false);\n+    SENDMS(wallet2, COIN, res.second);\n     BOOST_CHECK(res.first == \"verified\");\n \n     wtxRedeem = CWalletTx();\n \n-    res = wallet2->SendMoneyFromMultisignTx(strAddressOut, wtxSend, \"\", wtxRedeem, false);\n+    SENDMS(wallet2, COIN, \"\");\n     BOOST_CHECK(res.first == \"partial\");\n \n-    res = wallet->SendMoneyFromMultisignTx(strAddressOut, wtxSend, res.second, wtxRedeem, false);\n+    SENDMS(wallet, COIN, res.second);\n     BOOST_CHECK(res.first == \"verified\");\n \n     wtxRedeem = CWalletTx();\n-    res = wallet3->SendMoneyFromMultisignTx(strAddressOut, wtxSend, \"\", wtxRedeem, false);\n+    SENDMS(wallet, COIN, \"\");\n+    SENDMS(wallet3, COIN, res.second);\n     BOOST_CHECK(res.first == \"partial\");\n }\n \n@@ -149,32 +162,86 @@ BOOST_AUTO_TEST_CASE(multisign_redeem2of3)\n     CScript script;\n     BOOST_CHECK(MakeMultisignScript(strMultisignAddress2of3, script) == \"\");\n     CWalletTx wtxSend;\n-    wtxSend.vout.push_back(CTxOut(int64(COIN), script));\n+    wtxSend.vout.push_back(CTxOut(COIN, script));\n     uint256 hashSend = wtxSend.GetHash();\n \n     CWalletTx wtxRedeem;\n     pair<string,string> res;\n \n-    res = wallet->SendMoneyFromMultisignTx(strAddressOut, wtxSend, \"\", wtxRedeem, false);\n+    SENDMS(wallet, COIN, \"\");\n+    BOOST_CHECK(res.first == \"partial\");\n+\n+    SENDMS(wallet2, COIN, res.second);\n+    BOOST_CHECK(res.first == \"verified\");\n+\n+    wtxRedeem = CWalletTx();\n+\n+    SENDMS(wallet2, COIN, \"\");\n     BOOST_CHECK(res.first == \"partial\");\n \n-    res = wallet2->SendMoneyFromMultisignTx(strAddressOut, wtxSend, res.second, wtxRedeem, false);\n+    SENDMS(wallet, COIN, res.second);\n     BOOST_CHECK(res.first == \"verified\");\n \n     wtxRedeem = CWalletTx();\n \n-    res = wallet2->SendMoneyFromMultisignTx(strAddressOut, wtxSend, \"\", wtxRedeem, false);\n+    SENDMS(wallet3, COIN, \"\");\n     BOOST_CHECK(res.first == \"partial\");\n \n-    res = wallet->SendMoneyFromMultisignTx(strAddressOut, wtxSend, res.second, wtxRedeem, false);\n+    SENDMS(wallet, COIN, res.second);\n     BOOST_CHECK(res.first == \"verified\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(multisign_redeem_change)\n+{\n+    // Test with change and transaction fee\n+    nTransactionFee = 100;\n+\n+    CScript script;\n+    BOOST_CHECK(MakeMultisignScript(strMultisignAddress2, script) == \"\");\n+    CWalletTx wtxSend;\n+    wtxSend.vout.push_back(CTxOut(COIN + 100, script));\n+    uint256 hashSend = wtxSend.GetHash();\n+\n+    CWalletTx wtxRedeem;\n+    pair<string,string> res;\n+\n+    // Insufficient funds\n+    SENDMS(wallet, COIN + 1, \"\");\n+    BOOST_CHECK(res.first == \"error\");\n+\n+    // Change mismatches\n+    SENDMS(wallet, COIN, \"\");\n+    BOOST_CHECK(res.first == \"partial\");\n+\n+    SENDMS(wallet2, COIN - 1, res.second);\n+    BOOST_CHECK(res.first == \"error\");\n \n     wtxRedeem = CWalletTx();\n-    res = wallet3->SendMoneyFromMultisignTx(strAddressOut, wtxSend, \"\", wtxRedeem, false);\n+    SENDMS(wallet, COIN - 1, \"\");\n     BOOST_CHECK(res.first == \"partial\");\n \n-    res = wallet->SendMoneyFromMultisignTx(strAddressOut, wtxSend, res.second, wtxRedeem, false);\n+    SENDMS(wallet2, COIN, res.second);\n+    BOOST_CHECK(res.first == \"error\");\n+\n+    // Correct\n+    wtxRedeem = CWalletTx();\n+    SENDMS(wallet, COIN - 1, \"\");\n+    SENDMS(wallet2, COIN - 1, res.second);\n     BOOST_CHECK(res.first == \"verified\");\n+\n+    wtxRedeem = CWalletTx();\n+\n+// Deserialize and check the outputs\n+    CScript scriptOut;\n+    scriptOut.SetBitcoinAddress(strAddressOut);\n+    CDataStream ss(ParseHex(res.second));\n+    ss >> wtxRedeem;\n+    BOOST_CHECK(wtxRedeem.vout.size() == 2);\n+    cout << wtxRedeem.vout[0].nValue << \"\\n\";\n+    BOOST_CHECK(wtxRedeem.vout[0].nValue == COIN - 1);\n+    BOOST_CHECK(wtxRedeem.vout[0].scriptPubKey == scriptOut);\n+    BOOST_CHECK(wtxRedeem.vout[1].nValue == 1);\n+    BOOST_CHECK(wtxRedeem.vout[1].scriptPubKey == script);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "8044f749e31374ca604abdb10bf1983933890db3",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 7,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5f0a887d2a4c0063b7ce521af00b6afd64de75/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5f0a887d2a4c0063b7ce521af00b6afd64de75/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=9e5f0a887d2a4c0063b7ce521af00b6afd64de75",
        "patch": "@@ -1270,7 +1270,7 @@ bool CWallet::CommitTransactionWithForeignInput(CWalletTx& wtxNew, uint256 hashI\n // strPartialTx - optional, a partially signed (by the counterparties) tx in hex\n // wtxNew - the tx we are constructing\n //\n-pair<string,string> CWallet::SendMoneyFromMultisignTx(string strAddress, CTransaction txInput, string strPartialTx, CWalletTx& wtxNew, bool fSubmit, bool fAskFee)\n+pair<string,string> CWallet::SendMoneyFromMultisignTx(string strAddress, CTransaction txInput, int64 nAmount, string strPartialTx, CWalletTx& wtxNew, bool fSubmit, bool fAskFee)\n {\n     CReserveKey reservekey(this);\n \n@@ -1306,23 +1306,46 @@ pair<string,string> CWallet::SendMoneyFromMultisignTx(string strAddress, CTransa\n     if (!scriptOut.SetBitcoinAddress(strAddress))\n         return make_pair(\"error\", _(\"Invalid bitcoin address\"));\n \n+    if (nValue - nTransactionFee < nAmount)\n+        return make_pair(\"error\", _(\"Insufficient funds in input transaction for output and fee\"));\n+\n+    bool fChange = nValue > nAmount + nTransactionFee;\n+    CTxOut outChange = CTxOut(nValue - nAmount - nTransactionFee, scriptPubKey);\n+    CTxOut outMain = CTxOut(nAmount, scriptOut);\n+\n     if (strPartialTx.size() == 0)\n     {\n         // If no partial tx, create an empty one\n         wtxNew.vin.clear();\n         wtxNew.vout.clear();\n         wtxNew.vin.push_back(CTxIn(txInput.GetHash(), nOut));\n-        // Parse bitcoin address\n-        wtxNew.vout.push_back(CTxOut(nValue - nTransactionFee, scriptOut));\n+        wtxNew.vout.push_back(outMain);\n+        // Change is last by convention\n+        if (fChange)\n+            wtxNew.vout.push_back(outChange);\n     }\n     else\n     {\n         // If we have a partial tx, make sure it has the expected output\n         vector<unsigned char> vchPartial = ParseHex(strPartialTx);\n         CDataStream ss(vchPartial);\n         ss >> wtxNew;\n-        if (wtxNew.vout.size() != 1 || wtxNew.vout[0].scriptPubKey != scriptOut)\n-            return make_pair(\"error\", _(\"Partial tx not going to the address you specified\"));\n+        if (fChange)\n+        {\n+            // Have change\n+            if (wtxNew.vout.size() != 2)\n+                return make_pair(\"error\", _(\"Partial tx did not have exactly one change output\"));\n+            if (wtxNew.vout[1] != outChange)\n+                return make_pair(\"error\", _(\"Partial tx has different change output\"));\n+        }\n+        else {\n+            // No change\n+            if (wtxNew.vout.size() != 1)\n+                return make_pair(\"error\", _(\"Partial tx has unnecessary change output\"));\n+        }\n+\n+        if (wtxNew.vout[0] != outMain)\n+            return make_pair(\"error\", _(\"Partial tx doesn't have the same output\"));\n     }\n \n     // Get the hash that we have to sign\n@@ -1482,7 +1505,7 @@ pair<string,string> CWallet::SendMoneyFromMultisignTx(string strAddress, CTransa\n     return make_pair(\"partial\", HexStr(ss.begin(), ss.end()));\n }\n \n-pair<string,string> CWallet::SendMoneyFromMultisign(string strAddress, uint256 hashInputTx, string strPartialTx, CWalletTx& wtxNew, bool fSubmit, bool fAskFee)\n+pair<string,string> CWallet::SendMoneyFromMultisign(string strAddress, uint256 hashInputTx, int64 nAmount, string strPartialTx, CWalletTx& wtxNew, bool fSubmit, bool fAskFee)\n {\n     // Find the multisign coin\n     CTxDB txdb(\"r\");\n@@ -1493,7 +1516,7 @@ pair<string,string> CWallet::SendMoneyFromMultisign(string strAddress, uint256 h\n     if (!txInput.ReadFromDisk(txindex.pos))\n         return make_pair(\"error\", _(\"Input tx not found\"));\n \n-    return SendMoneyFromMultisignTx(strAddress, txInput, strPartialTx, wtxNew, fSubmit, fAskFee);\n+    return SendMoneyFromMultisignTx(strAddress, txInput, nAmount, strPartialTx, wtxNew, fSubmit, fAskFee);\n }\n \n string MakeMultisignScript(string strAddresses, CScript& scriptPubKey)"
      },
      {
        "sha": "915b46b5e2f386356e24de77181722eabd79e7af",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5f0a887d2a4c0063b7ce521af00b6afd64de75/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5f0a887d2a4c0063b7ce521af00b6afd64de75/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=9e5f0a887d2a4c0063b7ce521af00b6afd64de75",
        "patch": "@@ -64,8 +64,8 @@ class CWallet : public CKeyStore\n     bool BroadcastTransaction(CWalletTx& wtxNew);\n     std::string SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, bool fAskFee=false);\n     std::string SendMoneyToBitcoinAddress(std::string strAddress, int64 nValue, CWalletTx& wtxNew, bool fAskFee=false);\n-    std::pair<std::string, std::string> SendMoneyFromMultisign(std::string strAddress, uint256 hashInputTx, std::string strPartialTx, CWalletTx& wtxNew, bool fSubmit=true, bool fAskFee=false);\n-    std::pair<std::string, std::string> SendMoneyFromMultisignTx(std::string strAddress, CTransaction txInput, std::string strPartialTx, CWalletTx& wtxNew, bool fSubmit=true, bool fAskFee=false);\n+    std::pair<std::string, std::string> SendMoneyFromMultisign(std::string strAddress, uint256 hashInputTx, int64 nAmount, std::string strPartialTx, CWalletTx& wtxNew, bool fSubmit=true, bool fAskFee=false);\n+    std::pair<std::string, std::string> SendMoneyFromMultisignTx(std::string strAddress, CTransaction txInput, int64 nAmount, std::string strPartialTx, CWalletTx& wtxNew, bool fSubmit=true, bool fAskFee=false);\n     std::string SendMoneyToMultisign(std::string strAddresses, int64 nValue, CWalletTx& wtxNew, bool fAskFee=false);\n \n     void ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool);"
      }
    ]
  },
  {
    "sha": "00321e8901f61256abb467f18438447d60de8724",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMDMyMWU4OTAxZjYxMjU2YWJiNDY3ZjE4NDM4NDQ3ZDYwZGU4NzI0",
    "commit": {
      "author": {
        "name": "Bobby Groff",
        "email": "bgroff@lavabit.com",
        "date": "2011-07-03T21:49:55Z"
      },
      "committer": {
        "name": "Bobby Groff",
        "email": "bgroff@lavabit.com",
        "date": "2011-07-03T21:49:55Z"
      },
      "message": "multisign - decrease CHECKMULTISIG GetSigOpCount weight, cleanup",
      "tree": {
        "sha": "0fe8fd642ca29048dbf7c84d5fc5dd5b1db812fa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0fe8fd642ca29048dbf7c84d5fc5dd5b1db812fa"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/00321e8901f61256abb467f18438447d60de8724",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00321e8901f61256abb467f18438447d60de8724",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/00321e8901f61256abb467f18438447d60de8724",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00321e8901f61256abb467f18438447d60de8724/comments",
    "author": {
      "login": "groffer",
      "id": 845963,
      "node_id": "MDQ6VXNlcjg0NTk2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/845963?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/groffer",
      "html_url": "https://github.com/groffer",
      "followers_url": "https://api.github.com/users/groffer/followers",
      "following_url": "https://api.github.com/users/groffer/following{/other_user}",
      "gists_url": "https://api.github.com/users/groffer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/groffer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/groffer/subscriptions",
      "organizations_url": "https://api.github.com/users/groffer/orgs",
      "repos_url": "https://api.github.com/users/groffer/repos",
      "events_url": "https://api.github.com/users/groffer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/groffer/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "groffer",
      "id": 845963,
      "node_id": "MDQ6VXNlcjg0NTk2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/845963?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/groffer",
      "html_url": "https://github.com/groffer",
      "followers_url": "https://api.github.com/users/groffer/followers",
      "following_url": "https://api.github.com/users/groffer/following{/other_user}",
      "gists_url": "https://api.github.com/users/groffer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/groffer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/groffer/subscriptions",
      "organizations_url": "https://api.github.com/users/groffer/orgs",
      "repos_url": "https://api.github.com/users/groffer/repos",
      "events_url": "https://api.github.com/users/groffer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/groffer/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9e5f0a887d2a4c0063b7ce521af00b6afd64de75",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e5f0a887d2a4c0063b7ce521af00b6afd64de75",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9e5f0a887d2a4c0063b7ce521af00b6afd64de75"
      }
    ],
    "stats": {
      "total": 10,
      "additions": 7,
      "deletions": 3
    },
    "files": [
      {
        "sha": "e5a0ab175fc7af47eb05d3e7ec1a95e9ab5d0a3a",
        "filename": "src/rpc.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00321e8901f61256abb467f18438447d60de8724/src/rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00321e8901f61256abb467f18438447d60de8724/src/rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc.cpp?ref=00321e8901f61256abb467f18438447d60de8724",
        "patch": "@@ -2174,7 +2174,8 @@ int CommandLineRPC(int argc, char *argv[])\n         if (strMethod == \"setgenerate\"            && n > 0) ConvertTo<bool>(params[0]);\n         if (strMethod == \"setgenerate\"            && n > 1) ConvertTo<boost::int64_t>(params[1]);\n         if (strMethod == \"sendtoaddress\"          && n > 1) ConvertTo<double>(params[1]);\n-        if (strMethod == \"sendmultisign\"             && n > 1) ConvertTo<double>(params[1]);\n+        if (strMethod == \"sendmultisign\"          && n > 1) ConvertTo<double>(params[1]);\n+        if (strMethod == \"redeemmultisign\"        && n > 2) ConvertTo<double>(params[2]);\n         if (strMethod == \"settxfee\"               && n > 0) ConvertTo<double>(params[0]);\n         if (strMethod == \"getamountreceived\"      && n > 1) ConvertTo<boost::int64_t>(params[1]); // deprecated\n         if (strMethod == \"getreceivedbyaddress\"   && n > 1) ConvertTo<boost::int64_t>(params[1]);"
      },
      {
        "sha": "93f3e1d696492fe2747270a82317a7c09caeff82",
        "filename": "src/script.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00321e8901f61256abb467f18438447d60de8724/src/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00321e8901f61256abb467f18438447d60de8724/src/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.h?ref=00321e8901f61256abb467f18438447d60de8724",
        "patch": "@@ -599,7 +599,7 @@ class CScript : public std::vector<unsigned char>\n             if (opcode == OP_CHECKSIG || opcode == OP_CHECKSIGVERIFY)\n                 n++;\n             else if (opcode == OP_CHECKMULTISIG || opcode == OP_CHECKMULTISIGVERIFY)\n-                n += 20;\n+                n += 5;\n         }\n         return n;\n     }"
      },
      {
        "sha": "82f81f7c6cef587f8675db60b0129db91c562462",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00321e8901f61256abb467f18438447d60de8724/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00321e8901f61256abb467f18438447d60de8724/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=00321e8901f61256abb467f18438447d60de8724",
        "patch": "@@ -1223,7 +1223,7 @@ bool CWallet::CommitTransactionWithForeignInput(CWalletTx& wtxNew, uint256 hashI\n             // This is only to keep the database open to defeat the auto-flush for the\n             // duration of this scope.  This is the only place where this optimization\n             // maybe makes sense; please don't do it anywhere else.\n-            CWalletDB walletdb(\"r\");\n+            CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,\"r\") : NULL;\n \n             // Take key pair from key pool so it won't be used again\n             reservekey.KeepKey();\n@@ -1244,6 +1244,9 @@ bool CWallet::CommitTransactionWithForeignInput(CWalletTx& wtxNew, uint256 hashI\n                 pcoin.WriteToDisk();\n                 vWalletUpdated.push_back(pcoin.GetHash());\n             }\n+\n+            if (fFileBacked)\n+                delete pwalletdb;\n         }\n \n         // Track how many getdata requests our transaction gets"
      }
    ]
  },
  {
    "sha": "d260515fba3ee09841701e854eeba7f419c006d6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMjYwNTE1ZmJhM2VlMDk4NDE3MDFlODU0ZWViYTdmNDE5YzAwNmQ2",
    "commit": {
      "author": {
        "name": "Bobby Groff",
        "email": "bgroff@lavabit.com",
        "date": "2011-07-03T23:36:52Z"
      },
      "committer": {
        "name": "Bobby Groff",
        "email": "bgroff@lavabit.com",
        "date": "2011-07-03T23:47:23Z"
      },
      "message": "multisign - add padding so that default testnet clients relay",
      "tree": {
        "sha": "709d6f06377a9bd4f36f247ea706bc3e0d1b6a56",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/709d6f06377a9bd4f36f247ea706bc3e0d1b6a56"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d260515fba3ee09841701e854eeba7f419c006d6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d260515fba3ee09841701e854eeba7f419c006d6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d260515fba3ee09841701e854eeba7f419c006d6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d260515fba3ee09841701e854eeba7f419c006d6/comments",
    "author": {
      "login": "groffer",
      "id": 845963,
      "node_id": "MDQ6VXNlcjg0NTk2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/845963?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/groffer",
      "html_url": "https://github.com/groffer",
      "followers_url": "https://api.github.com/users/groffer/followers",
      "following_url": "https://api.github.com/users/groffer/following{/other_user}",
      "gists_url": "https://api.github.com/users/groffer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/groffer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/groffer/subscriptions",
      "organizations_url": "https://api.github.com/users/groffer/orgs",
      "repos_url": "https://api.github.com/users/groffer/repos",
      "events_url": "https://api.github.com/users/groffer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/groffer/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "groffer",
      "id": 845963,
      "node_id": "MDQ6VXNlcjg0NTk2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/845963?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/groffer",
      "html_url": "https://github.com/groffer",
      "followers_url": "https://api.github.com/users/groffer/followers",
      "following_url": "https://api.github.com/users/groffer/following{/other_user}",
      "gists_url": "https://api.github.com/users/groffer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/groffer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/groffer/subscriptions",
      "organizations_url": "https://api.github.com/users/groffer/orgs",
      "repos_url": "https://api.github.com/users/groffer/repos",
      "events_url": "https://api.github.com/users/groffer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/groffer/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "00321e8901f61256abb467f18438447d60de8724",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00321e8901f61256abb467f18438447d60de8724",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/00321e8901f61256abb467f18438447d60de8724"
      }
    ],
    "stats": {
      "total": 24,
      "additions": 24,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f33bf8fb5583cd61d1f672ceff98a57c1314c1af",
        "filename": "src/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d260515fba3ee09841701e854eeba7f419c006d6/src/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d260515fba3ee09841701e854eeba7f419c006d6/src/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/wallet_tests.cpp?ref=d260515fba3ee09841701e854eeba7f419c006d6",
        "patch": "@@ -70,10 +70,15 @@ BOOST_AUTO_TEST_CASE(multisign_address_format)\n     CScript script;\n     fTestNet = true;\n     BOOST_CHECK(MakeMultisignScript(\"1\", script) == _(\"Invalid multisign address format\"));\n+    script = CScript();\n     BOOST_CHECK(MakeMultisignScript(string(\"2,\") + strAddress1, script) == _(\"Invalid multisign address format\"));\n+    script = CScript();\n     BOOST_CHECK(MakeMultisignScript(string(\"0,\") + strAddress1, script) == _(\"Invalid multisign address format\"));\n+    script = CScript();\n     BOOST_CHECK(MakeMultisignScript(strMultisignAddress, script) == \"\");\n+    script = CScript();\n     BOOST_CHECK(MakeMultisignScript(strMultisignAddress2, script) == \"\");\n+    script = CScript();\n     BOOST_CHECK(MakeMultisignScript(string(\"2,\") + strAddress1 + \",v\" + strAddress2, script) == \"Invalid bitcoin address\");\n }\n "
      },
      {
        "sha": "192b461d52f1f3c56344d9c2d1c19fbc63a71c0d",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d260515fba3ee09841701e854eeba7f419c006d6/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d260515fba3ee09841701e854eeba7f419c006d6/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=d260515fba3ee09841701e854eeba7f419c006d6",
        "patch": "@@ -1571,6 +1571,25 @@ string MakeMultisignScript(string strAddresses, CScript& scriptPubKey)\n     scriptPubKey << strs.size();\n     scriptPubKey << OP_CHECKMULTISIG;\n \n+    // Pad with enough to get around GetSigOpCount check\n+    int nPadding = 37*10 - scriptPubKey.size();\n+\n+    // Max argument size is 520\n+    while (nPadding > 520)\n+    {\n+        vector<unsigned char> padding(520, 0);\n+        scriptPubKey << padding;\n+        scriptPubKey << OP_DROP;\n+        nPadding -= 520;\n+    }\n+\n+    if (nPadding > 0)\n+    {\n+        vector<unsigned char> padding(nPadding, 0);\n+        scriptPubKey << padding;\n+        scriptPubKey << OP_DROP;\n+    }\n+\n     return \"\";\n }\n "
      }
    ]
  },
  {
    "sha": "db47c86abecdee76bf000bbc93c7722599d6e15e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYjQ3Yzg2YWJlY2RlZTc2YmYwMDBiYmM5M2M3NzIyNTk5ZDZlMTVl",
    "commit": {
      "author": {
        "name": "Bobby Groff",
        "email": "bgroff@lavabit.com",
        "date": "2011-07-04T07:36:16Z"
      },
      "committer": {
        "name": "Bobby Groff",
        "email": "bgroff@lavabit.com",
        "date": "2011-07-04T07:36:16Z"
      },
      "message": "multisign - update doc",
      "tree": {
        "sha": "2a25e120f571bd0fd691b11c26c0bcaf5f4d2476",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2a25e120f571bd0fd691b11c26c0bcaf5f4d2476"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/db47c86abecdee76bf000bbc93c7722599d6e15e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db47c86abecdee76bf000bbc93c7722599d6e15e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/db47c86abecdee76bf000bbc93c7722599d6e15e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db47c86abecdee76bf000bbc93c7722599d6e15e/comments",
    "author": {
      "login": "groffer",
      "id": 845963,
      "node_id": "MDQ6VXNlcjg0NTk2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/845963?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/groffer",
      "html_url": "https://github.com/groffer",
      "followers_url": "https://api.github.com/users/groffer/followers",
      "following_url": "https://api.github.com/users/groffer/following{/other_user}",
      "gists_url": "https://api.github.com/users/groffer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/groffer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/groffer/subscriptions",
      "organizations_url": "https://api.github.com/users/groffer/orgs",
      "repos_url": "https://api.github.com/users/groffer/repos",
      "events_url": "https://api.github.com/users/groffer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/groffer/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "groffer",
      "id": 845963,
      "node_id": "MDQ6VXNlcjg0NTk2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/845963?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/groffer",
      "html_url": "https://github.com/groffer",
      "followers_url": "https://api.github.com/users/groffer/followers",
      "following_url": "https://api.github.com/users/groffer/following{/other_user}",
      "gists_url": "https://api.github.com/users/groffer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/groffer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/groffer/subscriptions",
      "organizations_url": "https://api.github.com/users/groffer/orgs",
      "repos_url": "https://api.github.com/users/groffer/repos",
      "events_url": "https://api.github.com/users/groffer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/groffer/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d260515fba3ee09841701e854eeba7f419c006d6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d260515fba3ee09841701e854eeba7f419c006d6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d260515fba3ee09841701e854eeba7f419c006d6"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 14,
      "deletions": 15
    },
    "files": [
      {
        "sha": "7cb859dc0cbe9ef2e37f8c2e5e0382810b1673e1",
        "filename": "doc/README_escrow.txt",
        "status": "modified",
        "additions": 14,
        "deletions": 15,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db47c86abecdee76bf000bbc93c7722599d6e15e/doc/README_escrow.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db47c86abecdee76bf000bbc93c7722599d6e15e/doc/README_escrow.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README_escrow.txt?ref=db47c86abecdee76bf000bbc93c7722599d6e15e",
        "patch": "@@ -1,6 +1,6 @@\n-Bitcoin Escrow\n+Bitcoin Multisign a.k.a \"Escrow\"\n \n-Bitcoin \"escrow\" are coins that are under the control of multiple\n+Bitcoin multisign are coins that are under the control of multiple\n parties.  The initial implementation allows n parties to vote, with\n k good signatures needed (k <= n).\n \n@@ -10,39 +10,38 @@ in many transaction use cases.\n Use Cases\n ---------\n \n-Escrow: send money to an escrow coin with three parties - sender,\n-receiver and escrow observer.  Require 2 signatures.  If sender and\n+\"Escrow\": send money to a multisign coin with three parties - sender,\n+receiver and an observer.  Require 2 signatures.  If sender and\n receiver agree, they can send the coin back to sender, or to receiver.\n-If they disagree, the escrow observer can break the tie by signing with\n+If they disagree, the observer can break the tie by signing with\n the sender or with the receiver.\n \n Immediate payment: send money from sender to a coin with two parties -\n sender and payment observer.  The payment observer will only agree to a\n single spend of the money, which prevents double spending.  Of course,\n the receiver has to trust the observer.  For protection against observer\n-failure, additional observers can be added.  TBD: requires escrow change\n-for leftover funds\n+failure, additional observers can be added.\n \n Secured funds: to increase security of funds, require 2 out of 3\n-parties to sign for disbursement.  This reduces the chance that funds\n+parties to sign for disbursement.  This reduces the probability that funds\n will be stolen because more than one party must be compromised for a\n successful theft.  This is also useful for storage at third parties\n-such as exchanges, to reduce the chance of mass theft.  Instead of the\n+such as exchanges, to reduce the probability of mass theft.  Instead of the\n exchange having full control of the funds, funds can be stored requiring\n signatures from 2 out of: account holder, exchange, third party observer.\n-TBD: requires escrow change for leftover funds\n \n API Calls\n ---------\n \n-sendescrow <escrowaddrs> <amount> [comment] [comment-to]\n-    <escrowaddrs> is of the form <n>,<addr>,<addr...>\n-    where <n> of the addresses must sign to redeem the escrow\n+sendmultisign <multisignaddr> <amount> [comment] [comment-to]\n+    <multisignaddr> is of the form <n>,<addr>,<addr...>\n+    where <n> of the addresses must sign to redeem the multisign\n     <amount> is a real and is rounded to the nearest 0.00000001\n \n-redeemescrow <inputtx> <addr> [<txhex>]\n-    where <inputtx> is the escrow transaction ID\n+redeemmultisign <inputtx> <addr> <amount> [<txhex>]\n+    where <inputtx> is the multisign transaction ID\n     <addr> is the destination bitcoin address\n     <txhex> is a partially signed transaction\n+    <amount> is a real and is rounded to the nearest 0.00000001\n     the output is either ['partial', <txhex>] if more signatures are needed\n     or ['complete', <txid>] if the transaction was broadcast"
      }
    ]
  },
  {
    "sha": "b2f936692ef7ad836b3a0c1d5b9894a767118bb3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMmY5MzY2OTJlZjdhZDgzNmIzYTBjMWQ1Yjk4OTRhNzY3MTE4YmIz",
    "commit": {
      "author": {
        "name": "Bobby Groff",
        "email": "bgroff@lavabit.com",
        "date": "2011-08-03T01:20:52Z"
      },
      "committer": {
        "name": "Bobby Groff",
        "email": "bgroff@lavabit.com",
        "date": "2011-08-03T01:20:52Z"
      },
      "message": "multisign - return list of signers on redeem, more tests",
      "tree": {
        "sha": "fdc3db89ef86d44be11937334591f61c1cd15e57",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fdc3db89ef86d44be11937334591f61c1cd15e57"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b2f936692ef7ad836b3a0c1d5b9894a767118bb3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b2f936692ef7ad836b3a0c1d5b9894a767118bb3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b2f936692ef7ad836b3a0c1d5b9894a767118bb3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b2f936692ef7ad836b3a0c1d5b9894a767118bb3/comments",
    "author": {
      "login": "groffer",
      "id": 845963,
      "node_id": "MDQ6VXNlcjg0NTk2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/845963?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/groffer",
      "html_url": "https://github.com/groffer",
      "followers_url": "https://api.github.com/users/groffer/followers",
      "following_url": "https://api.github.com/users/groffer/following{/other_user}",
      "gists_url": "https://api.github.com/users/groffer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/groffer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/groffer/subscriptions",
      "organizations_url": "https://api.github.com/users/groffer/orgs",
      "repos_url": "https://api.github.com/users/groffer/repos",
      "events_url": "https://api.github.com/users/groffer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/groffer/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "groffer",
      "id": 845963,
      "node_id": "MDQ6VXNlcjg0NTk2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/845963?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/groffer",
      "html_url": "https://github.com/groffer",
      "followers_url": "https://api.github.com/users/groffer/followers",
      "following_url": "https://api.github.com/users/groffer/following{/other_user}",
      "gists_url": "https://api.github.com/users/groffer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/groffer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/groffer/subscriptions",
      "organizations_url": "https://api.github.com/users/groffer/orgs",
      "repos_url": "https://api.github.com/users/groffer/repos",
      "events_url": "https://api.github.com/users/groffer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/groffer/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "db47c86abecdee76bf000bbc93c7722599d6e15e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db47c86abecdee76bf000bbc93c7722599d6e15e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/db47c86abecdee76bf000bbc93c7722599d6e15e"
      }
    ],
    "stats": {
      "total": 327,
      "additions": 243,
      "deletions": 84
    },
    "files": [
      {
        "sha": "798d8689cc2bbde3a583c22f8e396aad59bd041d",
        "filename": "src/makefile.unix",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2f936692ef7ad836b3a0c1d5b9894a767118bb3/src/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2f936692ef7ad836b3a0c1d5b9894a767118bb3/src/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.unix?ref=b2f936692ef7ad836b3a0c1d5b9894a767118bb3",
        "patch": "@@ -80,7 +80,7 @@ bitcoind: $(OBJS:obj/%=obj/nogui/%) obj/nogui/init.o\n obj/test/%.o: test/%.cpp $(HEADERS)\n \t$(CXX) -c $(CFLAGS) -o $@ $<\n \n-obj/nogui/test/test_bitcoin.o: test/wallet_tests.cpp\n+obj/nogui/test/test_bitcoin.o: test/wallet_tests.cpp test/script_tests.cpp\n \n test_bitcoin: obj/nogui/test/test_bitcoin.o $(OBJS:obj/%=obj/nogui/%) obj/init-nomain.o\n \t$(CXX) $(CFLAGS) -o $@ $(LIBPATHS) $^ $(LIBS) -lboost_unit_test_framework"
      },
      {
        "sha": "3d0ff4aee9ebd068b994995443929c44ff3af5bd",
        "filename": "src/rpc.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 4,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2f936692ef7ad836b3a0c1d5b9894a767118bb3/src/rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2f936692ef7ad836b3a0c1d5b9894a767118bb3/src/rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc.cpp?ref=b2f936692ef7ad836b3a0c1d5b9894a767118bb3",
        "patch": "@@ -596,12 +596,20 @@ Value redeemmultisign(const Array& params, bool fHelp)\n \n     CRITICAL_BLOCK(cs_main)\n     {\n-        pair<string,string> result = pwalletMain->SendMoneyFromMultisign(strAddress, nInputTx, nAmount, strPartialTx, wtx);\n+        vector<uint160> vSigners;\n+        pair<string,string> result = pwalletMain->SendMoneyFromMultisign(strAddress, nInputTx, nAmount, strPartialTx, wtx, vSigners);\n         if (result.first == \"error\")\n             throw JSONRPCError(-4, result.second);\n-        Array ret;\n-        ret.push_back(result.first);\n-        ret.push_back(result.second);\n+        Object ret;\n+        ret.push_back(Pair(\"result\", result.first));\n+        ret.push_back(Pair(\"tx\", result.second));\n+        Array signers;\n+        BOOST_FOREACH(uint160& signer, vSigners)\n+        {\n+            string address = Hash160ToAddress(signer);\n+            signers.push_back(address);\n+        }\n+        ret.push_back(Pair(\"signers\", signers));\n         return ret;\n     }\n }"
      },
      {
        "sha": "cd753197020aac819e488113cefafbedf116a130",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 57,
        "deletions": 30,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2f936692ef7ad836b3a0c1d5b9894a767118bb3/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2f936692ef7ad836b3a0c1d5b9894a767118bb3/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=b2f936692ef7ad836b3a0c1d5b9894a767118bb3",
        "patch": "@@ -960,6 +960,57 @@ bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CSc\n \n \n \n+bool PartialSolver(const CScript& script1, CScript::const_iterator& pc1, const CScript& scriptTemplate, vector<pair<opcodetype, valtype> >& vSolutionRet)\n+{\n+    opcodetype opcode1, opcode2;\n+    vector<unsigned char> vch1, vch2;\n+    CScript::const_iterator pc2 = scriptTemplate.begin();\n+\n+    loop\n+    {\n+        // Reached end of template - match\n+        if (pc2 == scriptTemplate.end())\n+            return true;\n+\n+        // Reached end of script but not of template - no match\n+        if (pc1 == script1.end())\n+            return false;\n+\n+        if (!script1.GetOp(pc1, opcode1, vch1))\n+            return false;\n+        if (!scriptTemplate.GetOp(pc2, opcode2, vch2))\n+            return false;\n+        if (opcode2 == OP_PUBKEY)\n+        {\n+            if (vch1.size() < 33 || vch1.size() > 120)\n+                return false;\n+            vSolutionRet.push_back(make_pair(opcode2, vch1));\n+        }\n+        else if (opcode2 == OP_PUBKEYHASH)\n+        {\n+            if (vch1.size() != sizeof(uint160))\n+                return false;\n+            vSolutionRet.push_back(make_pair(opcode2, vch1));\n+        }\n+        else if (opcode2 == OP_NUMBER)\n+        {\n+            if (opcode1 >= OP_1 && opcode1 <= OP_16)\n+            {\n+                CBigNum bn((int)opcode1 - (int)(OP_1 - 1));\n+                vSolutionRet.push_back(make_pair(opcode2, bn.getvch()));\n+            }\n+            else\n+            {\n+                vSolutionRet.push_back(make_pair(opcode2, vch1));\n+            }\n+        }\n+        else if (opcode1 != opcode2 || vch1 != vch2)\n+        {\n+            return false;\n+        }\n+    }\n+}\n+\n \n bool Solver(const CScript& scriptPubKey, vector<pair<opcodetype, valtype> >& vSolutionRet)\n {\n@@ -979,40 +1030,16 @@ bool Solver(const CScript& scriptPubKey, vector<pair<opcodetype, valtype> >& vSo\n     BOOST_FOREACH(const CScript& script2, vTemplates)\n     {\n         vSolutionRet.clear();\n-        opcodetype opcode1, opcode2;\n-        vector<unsigned char> vch1, vch2;\n \n         // Compare\n         CScript::const_iterator pc1 = script1.begin();\n-        CScript::const_iterator pc2 = script2.begin();\n-        loop\n+        if (!PartialSolver(script1, pc1, script2, vSolutionRet))\n+            continue;\n+        if (pc1 == script1.end())\n         {\n-            if (pc1 == script1.end() && pc2 == script2.end())\n-            {\n-                // Found a match\n-                reverse(vSolutionRet.begin(), vSolutionRet.end());\n-                return true;\n-            }\n-            if (!script1.GetOp(pc1, opcode1, vch1))\n-                break;\n-            if (!script2.GetOp(pc2, opcode2, vch2))\n-                break;\n-            if (opcode2 == OP_PUBKEY)\n-            {\n-                if (vch1.size() < 33 || vch1.size() > 120)\n-                    break;\n-                vSolutionRet.push_back(make_pair(opcode2, vch1));\n-            }\n-            else if (opcode2 == OP_PUBKEYHASH)\n-            {\n-                if (vch1.size() != sizeof(uint160))\n-                    break;\n-                vSolutionRet.push_back(make_pair(opcode2, vch1));\n-            }\n-            else if (opcode1 != opcode2 || vch1 != vch2)\n-            {\n-                break;\n-            }\n+            // Found a match\n+            reverse(vSolutionRet.begin(), vSolutionRet.end());\n+            return true;\n         }\n     }\n "
      },
      {
        "sha": "7c48f4f10caa24492f7b354f71a4d47d280c7fe2",
        "filename": "src/script.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2f936692ef7ad836b3a0c1d5b9894a767118bb3/src/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2f936692ef7ad836b3a0c1d5b9894a767118bb3/src/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.h?ref=b2f936692ef7ad836b3a0c1d5b9894a767118bb3",
        "patch": "@@ -159,6 +159,7 @@ enum opcodetype\n \n \n     // template matching params\n+    OP_NUMBER = 0xfc,\n     OP_PUBKEYHASH = 0xfd,\n     OP_PUBKEY = 0xfe,\n "
      },
      {
        "sha": "52aea72183e4d15228de2285b684c7a39a45d61b",
        "filename": "src/test/script_tests.cpp",
        "status": "added",
        "additions": 100,
        "deletions": 0,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2f936692ef7ad836b3a0c1d5b9894a767118bb3/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2f936692ef7ad836b3a0c1d5b9894a767118bb3/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=b2f936692ef7ad836b3a0c1d5b9894a767118bb3",
        "patch": "@@ -0,0 +1,100 @@\n+#include \"../headers.h\"\n+\n+using namespace std;\n+typedef vector<unsigned char> valtype;\n+extern bool Solver(const CScript& scriptPubKey, vector<pair<opcodetype, valtype> >& vSolutionRet);\n+extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+extern bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+\n+BOOST_AUTO_TEST_SUITE(script_tests)\n+\n+BOOST_AUTO_TEST_CASE(Solver_standard)\n+{\n+    vector<pair<opcodetype, valtype> > vSolution;\n+\n+    CKey key;\n+    key.MakeNewKey();\n+\n+    CScript script;\n+    script << key.GetPubKey() << OP_CHECKSIG;\n+\n+    BOOST_CHECK(Solver(script, vSolution));\n+    BOOST_CHECK(vSolution.size() == 1);\n+    BOOST_CHECK(vSolution[0].first == OP_PUBKEY);\n+    BOOST_CHECK(vSolution[0].second == key.GetPubKey());\n+\n+    uint160 hash160 = Hash160(key.GetPubKey());\n+    valtype vchHash(hash160.begin(), hash160.end());\n+    script = CScript() << OP_DUP << OP_HASH160 << hash160 << OP_EQUALVERIFY << OP_CHECKSIG;\n+\n+    BOOST_CHECK(Solver(script, vSolution));\n+    BOOST_CHECK(vSolution.size() == 1);\n+    BOOST_CHECK(vSolution[0].first == OP_PUBKEYHASH);\n+    BOOST_CHECK(vSolution[0].second == vchHash);\n+}\n+\n+BOOST_AUTO_TEST_CASE(solver_other)\n+{\n+    vector<pair<opcodetype, valtype> > vSolution;\n+\n+    CKey key;\n+    key.MakeNewKey();\n+\n+    CScript script;\n+    script << key.GetPubKey();\n+    BOOST_CHECK(!Solver(script, vSolution));\n+\n+    script = CScript();\n+    script << key.GetPubKey() << OP_0;\n+    BOOST_CHECK(!Solver(script, vSolution));\n+\n+    script = CScript();\n+    script << key.GetPubKey() << OP_CHECKSIG << OP_0;\n+    BOOST_CHECK(!Solver(script, vSolution));\n+}\n+\n+// TODO other SIGHASH variants\n+BOOST_AUTO_TEST_CASE(verifyScript)\n+{\n+    CKey key;\n+    key.MakeNewKey();\n+\n+    CScript scriptPubKey = CScript() << key.GetPubKey() << OP_CHECKSIG;\n+\n+    CTransaction txFrom;\n+    txFrom.vout.resize(1);\n+    txFrom.vout[0].scriptPubKey = scriptPubKey;\n+\n+    CTransaction txTo;\n+    txTo.vin.resize(2);\n+    txTo.vout.resize(1);\n+    txTo.vout[0].nValue = 1;\n+    txTo.vin[0].prevout.n = 0;\n+    txTo.vin[0].prevout.hash = txFrom.GetHash();\n+\n+    uint256 hash = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_ALL);\n+\n+    vector<unsigned char> vchSig;\n+    BOOST_CHECK(CKey::Sign(key.GetPrivKey(), hash, vchSig));\n+    vchSig.push_back((unsigned char)SIGHASH_ALL);\n+    CScript scriptSig = CScript() << vchSig;\n+\n+    BOOST_CHECK(VerifyScript(scriptSig, scriptPubKey, txTo, 0, 0));\n+\n+    // Should fail if output is changed\n+    txTo.vout[0].nValue = 2;\n+    BOOST_CHECK(!VerifyScript(scriptSig, scriptPubKey, txTo, 0, 0));\n+\n+    txTo.vout[0].nValue = 1;\n+\n+    // Should succeed since other input scriptPubKey is not hashed\n+    txTo.vin[1].scriptSig << OP_1;\n+    BOOST_CHECK(VerifyScript(scriptSig, scriptPubKey, txTo, 0, 0));\n+\n+    txTo.vin[0].scriptSig = scriptSig;\n+\n+    BOOST_CHECK(VerifySignature(txFrom, txTo, 0, SIGHASH_ALL));\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "6c0e50ac5ac95db7fd1c028763e22ac0c4a285ac",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2f936692ef7ad836b3a0c1d5b9894a767118bb3/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2f936692ef7ad836b3a0c1d5b9894a767118bb3/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=b2f936692ef7ad836b3a0c1d5b9894a767118bb3",
        "patch": "@@ -3,8 +3,10 @@\n \n #include <boost/test/unit_test.hpp>\n \n-#include \"uint160_tests.cpp\"\n-#include \"uint256_tests.cpp\"\n+#include \"script_tests.cpp\"\n \n #include \"wallet_tests.cpp\"\n \n+#include \"uint160_tests.cpp\"\n+#include \"uint256_tests.cpp\"\n+"
      },
      {
        "sha": "bc1ca9e5c43281aef41ecdb9bdb1841bc9f341ea",
        "filename": "src/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2f936692ef7ad836b3a0c1d5b9894a767118bb3/src/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2f936692ef7ad836b3a0c1d5b9894a767118bb3/src/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/wallet_tests.cpp?ref=b2f936692ef7ad836b3a0c1d5b9894a767118bb3",
        "patch": "@@ -96,7 +96,7 @@ BOOST_AUTO_TEST_CASE(multisign_script)\n     BOOST_CHECK(address == string(\"multisign(\") + strMultisignAddress + \")\");\n }\n \n-#define SENDMS(wallet, value, partial) res = wallet->SendMoneyFromMultisignTx(strAddressOut, wtxSend, value, partial, wtxRedeem, false)\n+#define SENDMS(wallet, value, partial) res = wallet->SendMoneyFromMultisignTx(strAddressOut, wtxSend, value, partial, wtxRedeem, vSigners, false)\n \n BOOST_AUTO_TEST_CASE(multisign_redeem)\n {\n@@ -107,8 +107,9 @@ BOOST_AUTO_TEST_CASE(multisign_redeem)\n     uint256 hashSend = wtxSend.GetHash();\n \n     CWalletTx wtxRedeem;\n+    vector<uint160> vSigners;\n     pair<string,string> res;\n-    res = wallet->SendMoneyFromMultisignTx(\"aaaaaaa\", wtxSend, COIN, \"\", wtxRedeem, false);\n+    res = wallet->SendMoneyFromMultisignTx(\"aaaaaaa\", wtxSend, COIN, \"\", wtxRedeem, vSigners, false);\n \n     BOOST_CHECK(res == make_pair(string(\"error\"), string(_(\"Invalid bitcoin address\"))));\n \n@@ -140,6 +141,7 @@ BOOST_AUTO_TEST_CASE(multisign_redeem2)\n     uint256 hashSend = wtxSend.GetHash();\n \n     CWalletTx wtxRedeem;\n+    vector<uint160> vSigners;\n     pair<string,string> res;\n \n     SENDMS(wallet, COIN, \"\");\n@@ -171,6 +173,7 @@ BOOST_AUTO_TEST_CASE(multisign_redeem2of3)\n     uint256 hashSend = wtxSend.GetHash();\n \n     CWalletTx wtxRedeem;\n+    vector<uint160> vSigners;\n     pair<string,string> res;\n \n     SENDMS(wallet, COIN, \"\");\n@@ -208,6 +211,7 @@ BOOST_AUTO_TEST_CASE(multisign_redeem_change)\n     uint256 hashSend = wtxSend.GetHash();\n \n     CWalletTx wtxRedeem;\n+    vector<uint160> vSigners;\n     pair<string,string> res;\n \n     // Insufficient funds\n@@ -242,7 +246,6 @@ BOOST_AUTO_TEST_CASE(multisign_redeem_change)\n     CDataStream ss(ParseHex(res.second));\n     ss >> wtxRedeem;\n     BOOST_CHECK(wtxRedeem.vout.size() == 2);\n-    cout << wtxRedeem.vout[0].nValue << \"\\n\";\n     BOOST_CHECK(wtxRedeem.vout[0].nValue == COIN - 1);\n     BOOST_CHECK(wtxRedeem.vout[0].scriptPubKey == scriptOut);\n     BOOST_CHECK(wtxRedeem.vout[1].nValue == 1);"
      },
      {
        "sha": "e64eabdcce2604d5b1234c083844e6334a02ee3a",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 60,
        "deletions": 42,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2f936692ef7ad836b3a0c1d5b9894a767118bb3/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2f936692ef7ad836b3a0c1d5b9894a767118bb3/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=b2f936692ef7ad836b3a0c1d5b9894a767118bb3",
        "patch": "@@ -1125,54 +1125,70 @@ void CReserveKey::ReturnKey()\n bool ExtractMultisignAddresses(const CScript& scriptPubKey, vector<uint160>& addresses, int& nVotes)\n {\n     extern CBigNum CastToBigNum(const vector<unsigned char>& vch);\n+    extern bool PartialSolver(const CScript& script1, CScript::const_iterator& pc1, const CScript& scriptTemplate, vector<pair<opcodetype, vector<unsigned char> > >& vSolutionRet);\n \n-    opcodetype opcode;\n-    vector<unsigned char> vch;\n-\n-    CScript::const_iterator pc1 = scriptPubKey.begin();\n-\n-    // size\n-    if (!scriptPubKey.GetOp(pc1, opcode, vch))\n-        return false;\n+    // Each multisign script has a preamble, a repeated segment for each signature and\n+    // a postamble\n+    static CScript templatePre;\n+    static CScript templateEach;\n+    static CScript templatePost;\n \n-    if (!scriptPubKey.GetOp(pc1, opcode, vch) || opcode != OP_ROLL)\n-        return false;\n-\n-    if (!scriptPubKey.GetOp(pc1, opcode, vch) || opcode != OP_DUP)\n-        return false;\n+    if (templatePre.empty())\n+    {\n+        templatePre << OP_NUMBER << OP_ROLL << OP_DUP << OP_NUMBER << OP_GREATERTHANOREQUAL << OP_VERIFY;\n+        templateEach << OP_NUMBER << OP_ROLL << OP_SIZE << OP_NOT << OP_OVER << OP_HASH160 << OP_PUBKEYHASH << OP_EQUAL << OP_BOOLOR << OP_VERIFY;\n+        templatePost << OP_NUMBER << OP_CHECKMULTISIG;\n+    }\n \n-    // nVotes\n-    if (!scriptPubKey.GetOp(pc1, opcode, vch))\n-        return false;\n+    CScript::const_iterator pc1 = scriptPubKey.begin();\n \n-    if (opcode >= OP_1 && opcode <= OP_16)\n-        nVotes = (int)opcode - (int)(OP_1 - 1);\n-    else\n+    try\n     {\n-        try\n+        vector<pair<opcodetype, vector<unsigned char> > > vSolution;\n+        if (!PartialSolver(scriptPubKey, pc1, templatePre, vSolution))\n+            return false;\n+        if (vSolution.size() != 2)\n+            return false;\n+        int size = CastToBigNum(vSolution[0].second).getint();\n+        nVotes = CastToBigNum(vSolution[1].second).getint();\n+\n+        for (int i = 0 ; i < size ; i++)\n         {\n-            nVotes = CastToBigNum(vch).getint();\n+            vSolution.clear();\n+            if (!PartialSolver(scriptPubKey, pc1, templateEach, vSolution))\n+                return false;\n+            if (vSolution.size() != 2)\n+                return false;\n+            if (size != CastToBigNum(vSolution[0].second).getint())\n+                return false;\n+            addresses.push_back(uint160(vSolution[1].second));\n         }\n-        catch (...)\n-        {\n+\n+        vSolution.clear();\n+        if (!PartialSolver(scriptPubKey, pc1, templatePost, vSolution))\n+            return false;\n+        if (vSolution.size() != 1)\n+            return false;\n+        if (size != CastToBigNum(vSolution[0].second).getint())\n             return false;\n-        }\n     }\n-\n-    if (!scriptPubKey.GetOp(pc1, opcode, vch) ||\n-            opcode != OP_GREATERTHANOREQUAL)\n+    catch (std::runtime_error& e)\n+    {\n+        // CastToBigNum can throw\n         return false;\n+    }\n \n-    while (scriptPubKey.GetOp(pc1, opcode, vch))\n+    // Everything else must be padding\n+    while (pc1 != scriptPubKey.end())\n     {\n-        if (opcode == OP_HASH160)\n-        {\n-            if (!scriptPubKey.GetOp(pc1, opcode, vch))\n-                return false;\n-            if (vch.size() != sizeof(uint160))\n-                continue;\n-            addresses.push_back(uint160(vch));\n-        }\n+        vector<unsigned char> vch;\n+        opcodetype opcode;\n+        if (!scriptPubKey.GetOp(pc1, opcode, vch))\n+            return false;\n+        if (vch.size() == 0) // Must be immediate operand\n+            return false;\n+        if (!scriptPubKey.GetOp(pc1, opcode, vch) || opcode != OP_DROP)\n+            return false;\n     }\n \n     return true;\n@@ -1273,12 +1289,13 @@ bool CWallet::CommitTransactionWithForeignInput(CWalletTx& wtxNew, uint256 hashI\n // strPartialTx - optional, a partially signed (by the counterparties) tx in hex\n // wtxNew - the tx we are constructing\n //\n-pair<string,string> CWallet::SendMoneyFromMultisignTx(string strAddress, CTransaction txInput, int64 nAmount, string strPartialTx, CWalletTx& wtxNew, bool fSubmit, bool fAskFee)\n+pair<string,string> CWallet::SendMoneyFromMultisignTx(string strAddress, CTransaction txInput, int64 nAmount, string strPartialTx, CWalletTx& wtxNew, vector<uint160>& vSigners, bool fSubmit, bool fAskFee)\n {\n     CReserveKey reservekey(this);\n \n     int nVotes;\n     vector<uint160> addresses;\n+    vSigners.clear();\n \n     CScript scriptPubKey;\n     int64 nValue;\n@@ -1405,7 +1422,7 @@ pair<string,string> CWallet::SendMoneyFromMultisignTx(string strAddress, CTransa\n \n         if (vvchKeys.size() != addresses.size())\n         {\n-            throw runtime_error(\"bad multisign script - 2\");\n+            throw runtime_error(\"bad multisign script - 3\");\n         }\n     }\n \n@@ -1426,16 +1443,16 @@ pair<string,string> CWallet::SendMoneyFromMultisignTx(string strAddress, CTransa\n \n         BOOST_FOREACH(const uint160& address, addresses)\n         {\n-            string currentAddress = Hash160ToAddress(address);\n-\n             map<uint160, vector<unsigned char> >::iterator mi = mapPubKeys.find(address);\n             if (mi == mapPubKeys.end() || !mapKeys.count((*mi).second))\n             {\n                 // We can't sign this input\n                 scriptSigNewWithPlaceholders << vvchSigs[ikey];\n                 if (vvchSigs[ikey].size())\n                 {\n+                    // Already signed by someone else\n                     scriptSigNew << vvchSigs[ikey];\n+                    vSigners.push_back(address);\n                     nSigs++;\n                 }\n             }\n@@ -1454,6 +1471,7 @@ pair<string,string> CWallet::SendMoneyFromMultisignTx(string strAddress, CTransa\n                 vchSig.push_back((unsigned char)SIGHASH_ALL);\n                 scriptSigNewWithPlaceholders << vchSig;\n                 scriptSigNew << vchSig;\n+                vSigners.push_back(address);\n                 nSigs++;\n             }\n \n@@ -1508,7 +1526,7 @@ pair<string,string> CWallet::SendMoneyFromMultisignTx(string strAddress, CTransa\n     return make_pair(\"partial\", HexStr(ss.begin(), ss.end()));\n }\n \n-pair<string,string> CWallet::SendMoneyFromMultisign(string strAddress, uint256 hashInputTx, int64 nAmount, string strPartialTx, CWalletTx& wtxNew, bool fSubmit, bool fAskFee)\n+pair<string,string> CWallet::SendMoneyFromMultisign(string strAddress, uint256 hashInputTx, int64 nAmount, string strPartialTx, CWalletTx& wtxNew, vector<uint160>& vSigners, bool fSubmit, bool fAskFee)\n {\n     // Find the multisign coin\n     CTxDB txdb(\"r\");\n@@ -1519,7 +1537,7 @@ pair<string,string> CWallet::SendMoneyFromMultisign(string strAddress, uint256 h\n     if (!txInput.ReadFromDisk(txindex.pos))\n         return make_pair(\"error\", _(\"Input tx not found\"));\n \n-    return SendMoneyFromMultisignTx(strAddress, txInput, nAmount, strPartialTx, wtxNew, fSubmit, fAskFee);\n+    return SendMoneyFromMultisignTx(strAddress, txInput, nAmount, strPartialTx, wtxNew, vSigners, fSubmit, fAskFee);\n }\n \n string MakeMultisignScript(string strAddresses, CScript& scriptPubKey)"
      },
      {
        "sha": "2e978451fa765a7a9312f096167548ebce4e397c",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2f936692ef7ad836b3a0c1d5b9894a767118bb3/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2f936692ef7ad836b3a0c1d5b9894a767118bb3/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=b2f936692ef7ad836b3a0c1d5b9894a767118bb3",
        "patch": "@@ -64,8 +64,8 @@ class CWallet : public CKeyStore\n     bool BroadcastTransaction(CWalletTx& wtxNew);\n     std::string SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, bool fAskFee=false);\n     std::string SendMoneyToBitcoinAddress(std::string strAddress, int64 nValue, CWalletTx& wtxNew, bool fAskFee=false);\n-    std::pair<std::string, std::string> SendMoneyFromMultisign(std::string strAddress, uint256 hashInputTx, int64 nAmount, std::string strPartialTx, CWalletTx& wtxNew, bool fSubmit=true, bool fAskFee=false);\n-    std::pair<std::string, std::string> SendMoneyFromMultisignTx(std::string strAddress, CTransaction txInput, int64 nAmount, std::string strPartialTx, CWalletTx& wtxNew, bool fSubmit=true, bool fAskFee=false);\n+    std::pair<std::string, std::string> SendMoneyFromMultisign(std::string strAddress, uint256 hashInputTx, int64 nAmount, std::string strPartialTx, CWalletTx& wtxNew, std::vector<uint160>& vSigners, bool fSubmit=true, bool fAskFee=false);\n+    std::pair<std::string, std::string> SendMoneyFromMultisignTx(std::string strAddress, CTransaction txInput, int64 nAmount, std::string strPartialTx, CWalletTx& wtxNew, std::vector<uint160>& vSigners, bool fSubmit=true, bool fAskFee=false);\n     std::string SendMoneyToMultisign(std::string strAddresses, int64 nValue, CWalletTx& wtxNew, bool fAskFee=false);\n \n     void ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool);"
      }
    ]
  }
]