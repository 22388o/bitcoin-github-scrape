ken2812221,2018-10-14T11:04:35Z,Concept ACK,https://github.com/bitcoin/bitcoin/pull/14479#issuecomment-429617346,429617346,
fanquake,2018-10-14T11:26:53Z,"Please combine this into #14475 or vice-versa, as they are similar changes, in the same file and look like they share some of the same code?",https://github.com/bitcoin/bitcoin/pull/14479#issuecomment-429618624,429618624,
practicalswift,2018-10-14T11:35:25Z,@fanquake Good point! Now updated to make non-overlapping. Thanks! :-),https://github.com/bitcoin/bitcoin/pull/14479#issuecomment-429619107,429619107,
gmaxwell,2018-10-14T18:23:18Z,"This 'serialization' is pretty severely unportable.\n\nCasting through a union its a almost universally used idiom, and in some cases the only way to deserialize without either violating aliasing or demolishing performance with superfluous copies. (And in C it's unambiguously not undefined behaviour, making be somewhat dubious of the claim that it is in C++)  Here, I doubt the performance matter",https://github.com/bitcoin/bitcoin/pull/14479#issuecomment-429649599,429649599,
sipa,2018-10-14T20:13:12Z,"utACK\n\n@gmaxwell I'm pretty sure the generated code is identical or of similar performance with this change. Perhaps someone needs to look at the generated code, but the very similar constructions on https://github.com/bitcoin/bitcoin/blob/v0.17.0/src/crypto/common.h#L17L54 compile to essentially no-ops.  \n\nAs far as UB goes, https://en.cppreference.com/w/cpp/language/union claims ""The det",https://github.com/bitcoin/bitcoin/pull/14479#issuecomment-429658465,429658465,
practicalswift,2018-10-14T20:14:39Z,"@gmaxwell \n\n> (And in C it's unambiguously not undefined behaviour, making be somewhat dubious of the claim that it is in C++)\n\nThe C++ Core Guidelines – with editors Bjarne Stroustrup and Herb Sutter – [has this to say](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c183-dont-use-a-union-for-type-punning): ""It is undefined behavior to read a union member with a different typ",https://github.com/bitcoin/bitcoin/pull/14479#issuecomment-429658568,429658568,
gmaxwell,2018-10-15T01:46:37Z,NAK. Eliminate the float serialization and just remove this code.  This is always going to be non-portable (e.g. can't move data between different architectures without it being silently corrupted),https://github.com/bitcoin/bitcoin/pull/14479#issuecomment-429684230,429684230,
sipa,2018-10-15T02:01:29Z,"@practicalswift In case it isn't clear, I think @gmaxwell means we could get rid of the float-to-int conversion functions, and directly write the bytes of the float (which would be less code, and work when transferring a data direction between an little endian and big endian system which the current code does not)",https://github.com/bitcoin/bitcoin/pull/14479#issuecomment-429686111,429686111,
practicalswift,2018-10-15T09:37:48Z,"@gmaxwell @sipa Yes, getting rid of this code would be nice. As I understand it the suggestion is to change from:\n\n```\nser_writedata{32,64}(s, ser_{float,double}_to_uint{32,64}(a));\n```\n\nTo:\n\n```\nser_writedata{32,64}(s, a);\n```\n\nIs that correct?\n\nThat change would mean that we change the file format of `fee_estimates.dat`, right? Perhaps that is not a problem?",https://github.com/bitcoin/bitcoin/pull/14479#issuecomment-429775729,429775729,
sipa,2018-10-15T10:40:23Z,"No, you'd need to add a ser_writedata_float and ser_writedata_double, mimicking the existing integer write functions, which write the data directly.\n\nThat shouldn't break anything, as right now that is essentially what is happening already, except the data is first being reinterpreted as an integer, and then written as an integer.\n\nThe issue is that on big-endian systems, the float data is rei",https://github.com/bitcoin/bitcoin/pull/14479#issuecomment-429798920,429798920,
practicalswift,2018-10-15T11:07:14Z,"@sipa Oh, yes of course. I misunderstood the suggestion and didn't look at the signature of `ser_writedata{32,64}(…)` before responding. Thanks for the clarification. Rounding them is obviously not what we want :-)",https://github.com/bitcoin/bitcoin/pull/14479#issuecomment-429807710,429807710,
sipa,2018-10-15T12:27:27Z,"Sigh, no.\n\nThe whole point is not to have the byte swap operations in there.\n\nDrop the htole32 etc.",https://github.com/bitcoin/bitcoin/pull/14479#issuecomment-429833457,429833457,
practicalswift,2018-10-15T12:45:20Z,"@sipa Please review d928115718d3b3df69f7188c7344ab814523a1d7 :-)\n\nLet me know if it looks good and I'll squash.",https://github.com/bitcoin/bitcoin/pull/14479#issuecomment-429839036,429839036,
sipa,2018-10-15T20:09:52Z,"utACK.\n\nWould be nice if someone with a big endian system could test that the resulting fee_estimates.dat files are actually portable across systems.",https://github.com/bitcoin/bitcoin/pull/14479#issuecomment-429995370,429995370,
practicalswift,2018-10-17T10:52:03Z,"Reverted to the initial version (2aafe7c60f6e84cea4bbb2ed16c2c6b59a0eb4b3, see https://github.com/bitcoin/bitcoin/pull/14479#discussion_r225802065).\n\nPlease re-review :-)",https://github.com/bitcoin/bitcoin/pull/14479#issuecomment-430582280,430582280,
practicalswift,2018-11-14T07:09:10Z,@sipa What would be the best way to move forward with this PR?,https://github.com/bitcoin/bitcoin/pull/14479#issuecomment-438560660,438560660,
MarcoFalke,2019-02-11T23:20:42Z,Adding the static_asserts could still be done without any other changes?,https://github.com/bitcoin/bitcoin/pull/14479#issuecomment-462534878,462534878,
donaloconnor,2018-10-16T19:23:25Z,Will this not read a corrupted value on files saved (before this change) on big endian systems (ie: previously saved using little endian but now interpreted using big endian?) - I'm not overly familiar with the code so maybe it's okay - but just something that jumps out.,https://github.com/bitcoin/bitcoin/pull/14479#discussion_r225676552,225676552,src/serialize.h
sipa,2018-10-16T19:42:57Z,"@donaloconnor Floating point number serialization in memory is specified by IEEE 754, IIRC, and not subject to the endianness under which integers are encoded.",https://github.com/bitcoin/bitcoin/pull/14479#discussion_r225682173,225682173,src/serialize.h
donaloconnor,2018-10-16T21:57:24Z,@sipa - I was under the impression that endianess is not specified in IEEE 754 - but subject to it as it's implementation dependant. This is probably not an issue in practice as BE archs are pretty rare now. My point was that the byte ordering might be switched when loading the file on a BE float arch. I've read that even some systems have half endianess where integer are LE while 754 are BE. Anyw,https://github.com/bitcoin/bitcoin/pull/14479#discussion_r225722007,225722007,src/serialize.h
sipa,2018-10-16T22:01:26Z,"Ah, that's good to know in any case. If true, that means this PR really worsens things!",https://github.com/bitcoin/bitcoin/pull/14479#discussion_r225723001,225723001,src/serialize.h
practicalswift,2018-10-16T22:17:23Z,@sipa Should I revert to the version I originally submitted that solves the UB part and the UB part only? :-),https://github.com/bitcoin/bitcoin/pull/14479#discussion_r225726637,225726637,src/serialize.h
sipa,2018-10-17T07:10:38Z,"@practicalswift Yes, that makes sense. I wasn't aware that IEEE encoding was still subject to BE/LE serialization.\n\nIdeally we actually test this on some BE hardware, though...",https://github.com/bitcoin/bitcoin/pull/14479#discussion_r225802065,225802065,src/serialize.h
