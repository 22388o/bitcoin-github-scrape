[
  {
    "sha": "bd89534957f5660402e0cc2567d5c24f48e8dbb0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZDg5NTM0OTU3ZjU2NjA0MDJlMGNjMjU2N2Q1YzI0ZjQ4ZThkYmIw",
    "commit": {
      "author": {
        "name": "Chris Moore",
        "email": "dooglus@gmail.com",
        "date": "2012-04-12T23:22:15Z"
      },
      "committer": {
        "name": "Chris Moore",
        "email": "dooglus@gmail.com",
        "date": "2012-04-12T23:22:15Z"
      },
      "message": "Refactor coin selection to aid unit testing.\nAdd unit test for coin selection.\nFix coin selection to only include change when it's necessary.\nAdd 'coin control' tab to allow selection of coins to use when sending and display linked addresses.",
      "tree": {
        "sha": "c032351f1cf5ec6b4677c7be5ed105970ff3b87b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c032351f1cf5ec6b4677c7be5ed105970ff3b87b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bd89534957f5660402e0cc2567d5c24f48e8dbb0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd89534957f5660402e0cc2567d5c24f48e8dbb0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bd89534957f5660402e0cc2567d5c24f48e8dbb0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd89534957f5660402e0cc2567d5c24f48e8dbb0/comments",
    "author": {
      "login": "dooglus",
      "id": 573356,
      "node_id": "MDQ6VXNlcjU3MzM1Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dooglus",
      "html_url": "https://github.com/dooglus",
      "followers_url": "https://api.github.com/users/dooglus/followers",
      "following_url": "https://api.github.com/users/dooglus/following{/other_user}",
      "gists_url": "https://api.github.com/users/dooglus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dooglus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dooglus/subscriptions",
      "organizations_url": "https://api.github.com/users/dooglus/orgs",
      "repos_url": "https://api.github.com/users/dooglus/repos",
      "events_url": "https://api.github.com/users/dooglus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dooglus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dooglus",
      "id": 573356,
      "node_id": "MDQ6VXNlcjU3MzM1Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dooglus",
      "html_url": "https://github.com/dooglus",
      "followers_url": "https://api.github.com/users/dooglus/followers",
      "following_url": "https://api.github.com/users/dooglus/following{/other_user}",
      "gists_url": "https://api.github.com/users/dooglus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dooglus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dooglus/subscriptions",
      "organizations_url": "https://api.github.com/users/dooglus/orgs",
      "repos_url": "https://api.github.com/users/dooglus/repos",
      "events_url": "https://api.github.com/users/dooglus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dooglus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b7dc02381f0afe3ee3a542d06a44a64b2cde3812",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7dc02381f0afe3ee3a542d06a44a64b2cde3812",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b7dc02381f0afe3ee3a542d06a44a64b2cde3812"
      }
    ],
    "stats": {
      "total": 1071,
      "additions": 963,
      "deletions": 108
    },
    "files": [
      {
        "sha": "730c0132469c9016cbaffb7a08c9c27f8a9465c6",
        "filename": "bitcoin-qt.pro",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd89534957f5660402e0cc2567d5c24f48e8dbb0/bitcoin-qt.pro",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd89534957f5660402e0cc2567d5c24f48e8dbb0/bitcoin-qt.pro",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bitcoin-qt.pro?ref=bd89534957f5660402e0cc2567d5c24f48e8dbb0",
        "patch": "@@ -100,6 +100,7 @@ HEADERS += src/qt/bitcoingui.h \\\n     src/qt/addresstablemodel.h \\\n     src/qt/optionsdialog.h \\\n     src/qt/sendcoinsdialog.h \\\n+    src/qt/coincontrolpage.h \\\n     src/qt/addressbookpage.h \\\n     src/qt/messagepage.h \\\n     src/qt/aboutdialog.h \\\n@@ -166,6 +167,7 @@ SOURCES += src/qt/bitcoin.cpp src/qt/bitcoingui.cpp \\\n     src/qt/addresstablemodel.cpp \\\n     src/qt/optionsdialog.cpp \\\n     src/qt/sendcoinsdialog.cpp \\\n+    src/qt/coincontrolpage.cpp \\\n     src/qt/addressbookpage.cpp \\\n     src/qt/messagepage.cpp \\\n     src/qt/aboutdialog.cpp \\"
      },
      {
        "sha": "04e7cbb26915625dbd0d5c5a13831481159b04cc",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 67,
        "deletions": 22,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=bd89534957f5660402e0cc2567d5c24f48e8dbb0",
        "patch": "@@ -543,38 +543,82 @@ Value settxfee(const Array& params, bool fHelp)\n \n Value sendtoaddress(const Array& params, bool fHelp)\n {\n-    if (pwalletMain->IsCrypted() && (fHelp || params.size() < 2 || params.size() > 4))\n+    string crypt_usage = pwalletMain->IsCrypted() ? \"\\nrequires wallet passphrase to be set with walletpassphrase first\" : \"\";\n+\n+    if (fHelp || params.size() < 2 || params.size() > 4)\n         throw runtime_error(\n-            \"sendtoaddress <bitcoinaddress> <amount> [comment] [comment-to]\\n\"\n-            \"<amount> is a real and is rounded to the nearest 0.00000001\\n\"\n-            \"requires wallet passphrase to be set with walletpassphrase first\");\n-    if (!pwalletMain->IsCrypted() && (fHelp || params.size() < 2 || params.size() > 4))\n+            \"sendtoaddress <bitcoinaddress>[:<sendfromaddress1>[,<sendfromaddress2>[,...]]] <amount> [comment] [comment-to]\\n\"\n+            \"<amount> is a real and is rounded to the nearest 0.00000001\" + crypt_usage);\n+\n+    string strAddress = params[0].get_str();\n+    vector<string> splitAddresses;\n+    boost::split(splitAddresses, strAddress, boost::is_any_of(\":\"));\n+\n+    if (splitAddresses.size() > 2)\n         throw runtime_error(\n-            \"sendtoaddress <bitcoinaddress> <amount> [comment] [comment-to]\\n\"\n-            \"<amount> is a real and is rounded to the nearest 0.00000001\");\n+            \"sendtoaddress <bitcoinaddress>[:<sendfromaddress1>[,<sendfromaddress2>[,...]]] <amount> [comment] [comment-to]\\n\"\n+            \"<amount> is a real and is rounded to the nearest 0.00000001\" + crypt_usage);\n \n-    CBitcoinAddress address(params[0].get_str());\n+    strAddress = splitAddresses[0];\n+    if (splitAddresses.size() == 2)\n+        pwalletMain->setSendFromAddressRestriction(splitAddresses[1]);\n+\n+    CBitcoinAddress address(strAddress);\n     if (!address.IsValid())\n         throw JSONRPCError(-5, \"Invalid bitcoin address\");\n \n-    // Amount\n-    int64 nAmount = AmountFromValue(params[1]);\n-\n-    // Wallet comments\n-    CWalletTx wtx;\n-    if (params.size() > 2 && params[2].type() != null_type && !params[2].get_str().empty())\n-        wtx.mapValue[\"comment\"] = params[2].get_str();\n-    if (params.size() > 3 && params[3].type() != null_type && !params[3].get_str().empty())\n-        wtx.mapValue[\"to\"]      = params[3].get_str();\n-\n     if (pwalletMain->IsLocked())\n         throw JSONRPCError(-13, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n \n-    string strError = pwalletMain->SendMoneyToBitcoinAddress(address, nAmount, wtx);\n-    if (strError != \"\")\n-        throw JSONRPCError(-4, strError);\n+    try\n+    {\n+        // Amount\n+        int64 nAmount = AmountFromValue(params[1]);\n+        // Wallet comments\n+        CWalletTx wtx;\n+        if (params.size() > 2 && params[2].type() != null_type && !params[2].get_str().empty())\n+            wtx.mapValue[\"comment\"] = params[2].get_str();\n+        if (params.size() > 3 && params[3].type() != null_type && !params[3].get_str().empty())\n+            wtx.mapValue[\"to\"]      = params[3].get_str();\n+\n+        string strError = pwalletMain->SendMoneyToBitcoinAddress(strAddress, nAmount, wtx);\n+        if (strError != \"\")\n+            throw JSONRPCError(-4, strError);\n+\n+        pwalletMain->clearSendFromAddressRestriction();\n+\n+        return wtx.GetHash().GetHex();\n+    } catch (...) {\n+      pwalletMain->clearSendFromAddressRestriction();\n+      throw;\n+    }\n+}\n \n-    return wtx.GetHash().GetHex();\n+Value listaddressgroupings(const Array& params, bool fHelp)\n+{\n+    if (fHelp)\n+        throw runtime_error(\"listaddressgroupings\");\n+\n+    Array jsonGroupings;\n+    map<string, int64> balances = pwalletMain->GetAddressBalances();\n+    BOOST_FOREACH(set<string> grouping, pwalletMain->GetAddressGroupings())\n+    {\n+        Array jsonGrouping;\n+        BOOST_FOREACH(string address, grouping)\n+        {\n+            Array addressInfo;\n+            addressInfo.push_back(address);\n+            addressInfo.push_back(ValueFromAmount(balances[address]));\n+            {\n+                LOCK(pwalletMain->cs_wallet);\n+                if (pwalletMain->mapAddressBook.find(CBitcoinAddress(address)) != pwalletMain->mapAddressBook.end())\n+                    addressInfo.push_back(pwalletMain->mapAddressBook.find(CBitcoinAddress(address))->second);\n+            }\n+            jsonGrouping.push_back(addressInfo);\n+        }\n+        jsonGroupings.push_back(jsonGrouping);\n+    }\n+    return jsonGroupings;\n }\n \n Value signmessage(const Array& params, bool fHelp)\n@@ -2034,6 +2078,7 @@ pair<string, rpcfn_type> pCallTable[] =\n     make_pair(\"getblockhash\",           &getblockhash),\n     make_pair(\"gettransaction\",         &gettransaction),\n     make_pair(\"listtransactions\",       &listtransactions),\n+    make_pair(\"listaddressgroupings\",   &listaddressgroupings),\n     make_pair(\"signmessage\",            &signmessage),\n     make_pair(\"verifymessage\",          &verifymessage),\n     make_pair(\"getwork\",                &getwork),"
      },
      {
        "sha": "9b2a00de2ef231a0bb22c419a66fa75cdf8f32a6",
        "filename": "src/headers.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/headers.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/headers.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/headers.h?ref=bd89534957f5660402e0cc2567d5c24f48e8dbb0",
        "patch": "@@ -53,6 +53,9 @@\n #include <deque>\n #include <map>\n \n+#include <boost/algorithm/string.hpp>\n+#include <boost/lambda/lambda.hpp>\n+\n #ifdef WIN32\n #include <windows.h>\n #include <winsock2.h>"
      },
      {
        "sha": "af9fe4fb6537f3dad44f75173c31db03f2c581e5",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 40,
        "deletions": 0,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=bd89534957f5660402e0cc2567d5c24f48e8dbb0",
        "patch": "@@ -23,6 +23,7 @@\n #include \"guiconstants.h\"\n #include \"askpassphrasedialog.h\"\n #include \"notificator.h\"\n+#include \"coincontrolpage.h\"\n #include \"guiutil.h\"\n \n #ifdef Q_WS_MAC\n@@ -50,6 +51,7 @@\n #include <QFileDialog>\n #include <QDesktopServices>\n #include <QTimer>\n+#include <QTableWidget>\n \n #include <QDragEnterEvent>\n #include <QUrl>\n@@ -104,6 +106,8 @@ BitcoinGUI::BitcoinGUI(QWidget *parent):\n \n     sendCoinsPage = new SendCoinsDialog(this);\n \n+    coinControlPage = new CoinControlPage(this);\n+    coinControlPage->setFont(GUIUtil::bitcoinAddressFont());\n     messagePage = new MessagePage(this);\n \n     centralWidget = new QStackedWidget(this);\n@@ -112,6 +116,7 @@ BitcoinGUI::BitcoinGUI(QWidget *parent):\n     centralWidget->addWidget(addressBookPage);\n     centralWidget->addWidget(receiveCoinsPage);\n     centralWidget->addWidget(sendCoinsPage);\n+    centralWidget->addWidget(coinControlPage);\n #ifdef FIRST_CLASS_MESSAGING\n     centralWidget->addWidget(messagePage);\n #endif\n@@ -207,6 +212,12 @@ void BitcoinGUI::createActions()\n     sendCoinsAction->setShortcut(QKeySequence(Qt::ALT + Qt::Key_2));\n     tabGroup->addAction(sendCoinsAction);\n \n+    coinControlAction = new QAction(QIcon(\":/icons/history\"), tr(\"&Coin Control\"), this);\n+    coinControlAction->setToolTip(tr(\"See address linkages\"));\n+    coinControlAction->setCheckable(true);\n+    coinControlAction->setShortcut(QKeySequence(Qt::ALT + Qt::Key_6));\n+    tabGroup->addAction(coinControlAction);\n+\n     messageAction = new QAction(QIcon(\":/icons/edit\"), tr(\"Sign &message\"), this);\n     messageAction->setToolTip(tr(\"Prove you control an address\"));\n #ifdef FIRST_CLASS_MESSAGING\n@@ -226,6 +237,7 @@ void BitcoinGUI::createActions()\n     connect(sendCoinsAction, SIGNAL(triggered()), this, SLOT(gotoSendCoinsPage()));\n     connect(messageAction, SIGNAL(triggered()), this, SLOT(showNormalIfMinimized()));\n     connect(messageAction, SIGNAL(triggered()), this, SLOT(gotoMessagePage()));\n+    connect(coinControlAction, SIGNAL(triggered()), this, SLOT(gotoCoinControlPage()));\n \n     quitAction = new QAction(QIcon(\":/icons/quit\"), tr(\"E&xit\"), this);\n     quitAction->setToolTip(tr(\"Quit application\"));\n@@ -305,6 +317,7 @@ void BitcoinGUI::createToolBars()\n #ifdef FIRST_CLASS_MESSAGING\n     toolbar->addAction(messageAction);\n #endif\n+    toolbar->addAction(coinControlAction);\n \n     QToolBar *toolbar2 = addToolBar(tr(\"Actions toolbar\"));\n     toolbar2->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);\n@@ -370,9 +383,17 @@ void BitcoinGUI::setWalletModel(WalletModel *walletModel)\n \n         // Ask for passphrase if needed\n         connect(walletModel, SIGNAL(requireUnlock()), this, SLOT(unlockWallet()));\n+\n+        connect(walletModel->getOptionsModel(), SIGNAL(coinControlFeaturesChanged(bool)), this, SLOT(toggleCoinControlTab(bool)));\n+        toggleCoinControlTab(walletModel->getOptionsModel()->getCoinControlFeatures());\n     }\n }\n \n+void BitcoinGUI::toggleCoinControlTab(bool show)\n+{\n+    coinControlAction->setVisible(show);\n+}\n+\n void BitcoinGUI::createTrayIcon()\n {\n     QMenu *trayIconMenu;\n@@ -709,13 +730,32 @@ void BitcoinGUI::gotoReceiveCoinsPage()\n \n void BitcoinGUI::gotoSendCoinsPage()\n {\n+    if (!coinControlPage->selectedAddresses().empty())\n+    {\n+        sendCoinsPage->setSendFromAddress(coinControlPage->selectedAddresses());\n+        coinControlPage->clearSelection();\n+    }\n+\n+    show();  // TODOcoderrr: still need this?\n+\n     sendCoinsAction->setChecked(true);\n     centralWidget->setCurrentWidget(sendCoinsPage);\n \n     exportAction->setEnabled(false);\n     disconnect(exportAction, SIGNAL(triggered()), 0, 0);\n }\n \n+void BitcoinGUI::gotoCoinControlPage()\n+{\n+    show();\n+    coinControlAction->setChecked(true);\n+    centralWidget->setCurrentWidget(coinControlPage);\n+    coinControlPage->UpdateTable();\n+\n+    exportAction->setEnabled(false);\n+    disconnect(exportAction, SIGNAL(triggered()), 0, 0);\n+}\n+\n void BitcoinGUI::gotoMessagePage()\n {\n #ifdef FIRST_CLASS_MESSAGING"
      },
      {
        "sha": "4ad91fc74bd878996c9e37ab24f016b18110e349",
        "filename": "src/qt/bitcoingui.h",
        "status": "modified",
        "additions": 9,
        "deletions": 2,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/bitcoingui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/bitcoingui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.h?ref=bd89534957f5660402e0cc2567d5c24f48e8dbb0",
        "patch": "@@ -12,6 +12,7 @@ class OverviewPage;\n class AddressBookPage;\n class SendCoinsDialog;\n class MessagePage;\n+class CoinControlPage;\n class Notificator;\n \n QT_BEGIN_NAMESPACE\n@@ -64,6 +65,7 @@ class BitcoinGUI : public QMainWindow\n     AddressBookPage *receiveCoinsPage;\n     SendCoinsDialog *sendCoinsPage;\n     MessagePage *messagePage;\n+    CoinControlPage *coinControlPage;\n \n     QLabel *labelEncryptionIcon;\n     QLabel *labelConnectionsIcon;\n@@ -87,6 +89,7 @@ class BitcoinGUI : public QMainWindow\n     QAction *backupWalletAction;\n     QAction *changePassphraseAction;\n     QAction *aboutQtAction;\n+    QAction *coinControlAction;\n \n     QSystemTrayIcon *trayIcon;\n     Notificator *notificator;\n@@ -104,6 +107,9 @@ class BitcoinGUI : public QMainWindow\n     void createTrayIcon();\n \n public slots:\n+    /** Switch to send coins page */\n+    void gotoSendCoinsPage();\n+\n     /** Set number of connections shown in the UI */\n     void setNumConnections(int count);\n     /** Set number of blocks shown in the UI */\n@@ -139,8 +145,8 @@ private slots:\n     void gotoAddressBookPage();\n     /** Switch to receive coins page */\n     void gotoReceiveCoinsPage();\n-    /** Switch to send coins page */\n-    void gotoSendCoinsPage();\n+    /** Switch to coin control page */\n+    void gotoCoinControlPage();\n \n     /** Show configuration dialog */\n     void optionsClicked();\n@@ -166,6 +172,7 @@ private slots:\n \n     /** Show window if hidden, unminimize when minimized */\n     void showNormalIfMinimized();\n+    void toggleCoinControlTab(bool);\n     /** Hide window if visible, show if hidden */\n     void toggleHidden();\n };"
      },
      {
        "sha": "d28ec1160ae727606f8356b5a919f29c5f2baa96",
        "filename": "src/qt/coincontrolpage.cpp",
        "status": "added",
        "additions": 137,
        "deletions": 0,
        "changes": 137,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/coincontrolpage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/coincontrolpage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontrolpage.cpp?ref=bd89534957f5660402e0cc2567d5c24f48e8dbb0",
        "patch": "@@ -0,0 +1,137 @@\n+#include \"bitcoingui.h\"\n+#include \"sendcoinsdialog.h\"\n+#include \"ui_sendcoinsdialog.h\"\n+#include \"walletmodel.h\"\n+#include \"bitcoinunits.h\"\n+#include \"addressbookpage.h\"\n+#include \"coincontrolpage.h\"\n+#include \"optionsmodel.h\"\n+#include \"sendcoinsentry.h\"\n+#include \"guiutil.h\"\n+#include \"askpassphrasedialog.h\"\n+\n+\n+#include \"headers.h\"\n+#include \"db.h\"\n+#include \"net.h\"\n+#include \"init.h\"\n+\n+#include <QApplication>\n+#include <QMessageBox>\n+#include <QLocale>\n+#include <QTextDocument>\n+#include <QTableWidget>\n+\n+using namespace std;\n+\n+CoinControlPage::CoinControlPage(QWidget *parent) :\n+    QWidget(parent)\n+{\n+    gui = (BitcoinGUI *)parent;\n+\n+    QHBoxLayout *hlayout = new QHBoxLayout(this);\n+\n+    QStringList headers;\n+    headers << \"Address\" << \"Label\" << \"Balance\" << \"Group Balance\";\n+    table = new QTableWidget(this);\n+    table->setColumnCount(4);\n+    table->setHorizontalHeaderLabels(headers);\n+    table->verticalHeader()->setVisible(false);\n+    table->setEditTriggers(QAbstractItemView::NoEditTriggers);\n+    table->horizontalHeader()->setResizeMode(QHeaderView::ResizeToContents);\n+    table->setSelectionBehavior(QAbstractItemView::SelectRows);\n+    \n+    connect(table, SIGNAL(itemDoubleClicked(QTableWidgetItem *)), this, SLOT(sendFromSelectedAddress(QTableWidgetItem *)));\n+\n+    hlayout->addWidget(table);\n+}\n+\n+std::string CoinControlPage::selectedAddresses()\n+{\n+    std::string addresses;\n+    BOOST_FOREACH(QTableWidgetItem *i, table->selectedItems())\n+    {\n+        if (i->column() != 0)\n+            continue;\n+\n+        std::string text = ((QString)i->text()).toStdString();\n+        if (CBitcoinAddress(text).IsValid())\n+            addresses += text + \";\";\n+    }\n+\n+    if (addresses.size() > 0)\n+        addresses.resize(addresses.size()-1);\n+\n+    return addresses;\n+}\n+\n+void CoinControlPage::clearSelection()\n+{\n+    table->clearSelection();\n+}\n+\n+void CoinControlPage::sendFromSelectedAddress(QTableWidgetItem *item)\n+{\n+    if (selectedAddresses().size() == 0)\n+        return;\n+\n+    gui->gotoSendCoinsPage();\n+}\n+\n+void CoinControlPage::UpdateTable()\n+{\n+    map<string, int64> balances = pwalletMain->GetAddressBalances();\n+    set< set<string> > groupings = pwalletMain->GetAddressGroupings();\n+    vector< PAIRTYPE(int64, set<string>) > nonZeroGroupings;\n+\n+    BOOST_FOREACH(set<string> addresses, groupings)\n+    {\n+        int64 balance = 0;\n+        BOOST_FOREACH(string address, addresses)\n+            balance += balances[address];\n+        if (balance > 0)\n+            nonZeroGroupings.push_back(make_pair(balance, addresses));\n+    }\n+    sort(nonZeroGroupings.begin(), nonZeroGroupings.end());\n+\n+    table->setRowCount(0);\n+\n+    bool first = true;\n+    BOOST_FOREACH(PAIRTYPE(int64, set<string>) grouping, nonZeroGroupings)\n+    {\n+        int64 group_balance = grouping.first;\n+        set<string> addresses = grouping.second;\n+        if (first)\n+            first = false;\n+        else\n+            table->insertRow(0);\n+\n+        vector<string> sortedAddresses(addresses.begin(), addresses.end());\n+        sort(sortedAddresses.begin(), sortedAddresses.end(), boost::lambda::var(balances)[boost::lambda::_1] < boost::lambda::var(balances)[boost::lambda::_2]);\n+\n+        int remaining = addresses.size();\n+        BOOST_FOREACH(string address, sortedAddresses)\n+        {\n+            int64 balance = balances[address];\n+            remaining--;\n+\n+            table->insertRow(0);\n+            table->setItem(0, 0, new QTableWidgetItem(QString::fromStdString(address)));\n+\n+            {\n+                LOCK(pwalletMain->cs_wallet);\n+                if (pwalletMain->mapAddressBook.find(CBitcoinAddress(address)) != pwalletMain->mapAddressBook.end())\n+                    table->setItem(0, 1, new QTableWidgetItem(QString::fromStdString(pwalletMain->mapAddressBook.find(CBitcoinAddress(address))->second)));\n+            }\n+\n+            if (balance > 0)\n+            {\n+                table->setItem(0, 2, new QTableWidgetItem(QString::fromStdString(strprintf(\"%\"PRI64d\".%08\"PRI64d, balance/COIN, balance%COIN))));\n+                if (!remaining)\n+                    table->setItem(0, 3, new QTableWidgetItem(QString::fromStdString(strprintf(\"%\"PRI64d\".%08\"PRI64d, group_balance/COIN, group_balance%COIN))));\n+            }\n+            else\n+                table->setItem(0, 2, new QTableWidgetItem(QString::fromStdString(\"-\")));\n+        }\n+    }\n+}"
      },
      {
        "sha": "bdd786984ccbd9479360d5d69bdf0a6a553edde8",
        "filename": "src/qt/coincontrolpage.h",
        "status": "added",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/coincontrolpage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/coincontrolpage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontrolpage.h?ref=bd89534957f5660402e0cc2567d5c24f48e8dbb0",
        "patch": "@@ -0,0 +1,27 @@\n+#ifndef COINCONTROLPAGE_H\n+#define COINCONTROLPAGE_H\n+\n+class BitcoinGUI;\n+\n+#include <QWidget>\n+#include <QTableWidget>\n+\n+class CoinControlPage : public QWidget\n+{\n+    Q_OBJECT\n+\n+public:\n+    CoinControlPage(QWidget *parent);\n+    void UpdateTable();\n+    std::string selectedAddresses();\n+    void clearSelection();\n+\n+private:\n+    QTableWidget *table;\n+    BitcoinGUI *gui;\n+\n+private slots:\n+    void sendFromSelectedAddress(QTableWidgetItem *item);\n+};\n+\n+#endif"
      },
      {
        "sha": "dede6375cd906098b8dc0a91fe3fe71895be07d7",
        "filename": "src/qt/forms/sendcoinsdialog.ui",
        "status": "modified",
        "additions": 28,
        "deletions": 1,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/forms/sendcoinsdialog.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/forms/sendcoinsdialog.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/sendcoinsdialog.ui?ref=bd89534957f5660402e0cc2567d5c24f48e8dbb0",
        "patch": "@@ -25,7 +25,7 @@\n         <x>0</x>\n         <y>0</y>\n         <width>666</width>\n-        <height>165</height>\n+        <height>122</height>\n        </rect>\n       </property>\n       <layout class=\"QVBoxLayout\" name=\"verticalLayout_2\">\n@@ -56,6 +56,33 @@\n      </widget>\n     </widget>\n    </item>\n+   <item>\n+    <layout class=\"QHBoxLayout\" name=\"sendFromLayout\">\n+     <property name=\"topMargin\">\n+      <number>0</number>\n+     </property>\n+     <item>\n+      <widget class=\"QLabel\" name=\"labelSendFrom\">\n+       <property name=\"text\">\n+        <string>Send From:</string>\n+       </property>\n+      </widget>\n+     </item>\n+     <item>\n+      <widget class=\"QLineEdit\" name=\"sendFrom\">\n+       <property name=\"inputMask\">\n+        <string/>\n+       </property>\n+       <property name=\"text\">\n+        <string/>\n+       </property>\n+       <property name=\"placeholderText\">\n+        <string>Restrict client to only send from these Bitcoin addresses</string>\n+       </property>\n+      </widget>\n+     </item>\n+    </layout>\n+   </item>\n    <item>\n     <layout class=\"QHBoxLayout\" name=\"horizontalLayout\">\n      <item>"
      },
      {
        "sha": "2a98e560fab05bb7cbd2ec6c143a0089eb569fe5",
        "filename": "src/qt/optionsdialog.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/optionsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/optionsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsdialog.cpp?ref=bd89534957f5660402e0cc2567d5c24f48e8dbb0",
        "patch": "@@ -58,6 +58,7 @@ class DisplayOptionsPage : public QWidget\n private:\n     QValueComboBox *unit;\n     QCheckBox *display_addresses;\n+    QCheckBox *coin_control_features;\n signals:\n \n public slots:\n@@ -279,6 +280,9 @@ DisplayOptionsPage::DisplayOptionsPage(QWidget *parent):\n     display_addresses = new QCheckBox(tr(\"Display addresses in transaction list\"), this);\n     layout->addWidget(display_addresses);\n \n+    coin_control_features = new QCheckBox(tr(\"Display coin control features\"), this);\n+    layout->addWidget(coin_control_features);\n+\n     layout->addStretch();\n \n     setLayout(layout);\n@@ -288,4 +292,5 @@ void DisplayOptionsPage::setMapper(MonitoredDataMapper *mapper)\n {\n     mapper->addMapping(unit, OptionsModel::DisplayUnit);\n     mapper->addMapping(display_addresses, OptionsModel::DisplayAddresses);\n+    mapper->addMapping(coin_control_features, OptionsModel::CoinControlFeatures);\n }"
      },
      {
        "sha": "d4ceedc6da9498e9627a1e51e44c6e6a3526b362",
        "filename": "src/qt/optionsmodel.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 1,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/optionsmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/optionsmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsmodel.cpp?ref=bd89534957f5660402e0cc2567d5c24f48e8dbb0",
        "patch": "@@ -21,6 +21,7 @@ void OptionsModel::Init()\n     fMinimizeToTray = settings.value(\"fMinimizeToTray\", false).toBool();\n     fMinimizeOnClose = settings.value(\"fMinimizeOnClose\", false).toBool();\n     nTransactionFee = settings.value(\"nTransactionFee\").toLongLong();\n+    bCoinControlFeatures = settings.value(\"bCoinControlFeatures\", false).toBool();\n \n     // These are shared with core bitcoin; we want\n     // command-line options to override the GUI settings:\n@@ -54,7 +55,7 @@ bool OptionsModel::Upgrade()\n         }\n     }\n     QList<QString> boolOptions;\n-    boolOptions << \"bDisplayAddresses\" << \"fMinimizeToTray\" << \"fMinimizeOnClose\" << \"fUseProxy\" << \"fUseUPnP\";\n+    boolOptions << \"bDisplayAddresses\" << \"bCoinControlFeatures\" << \"fMinimizeToTray\" << \"fMinimizeOnClose\" << \"fUseProxy\" << \"fUseUPnP\";\n     foreach(QString key, boolOptions)\n     {\n         bool value = false;\n@@ -121,6 +122,8 @@ QVariant OptionsModel::data(const QModelIndex & index, int role) const\n             return QVariant(nDisplayUnit);\n         case DisplayAddresses:\n             return QVariant(bDisplayAddresses);\n+        case CoinControlFeatures:\n+            return QVariant(bCoinControlFeatures);\n         default:\n             return QVariant();\n         }\n@@ -202,6 +205,11 @@ bool OptionsModel::setData(const QModelIndex & index, const QVariant & value, in\n             bDisplayAddresses = value.toBool();\n             settings.setValue(\"bDisplayAddresses\", bDisplayAddresses);\n             }\n+        case CoinControlFeatures: {\n+            bCoinControlFeatures = value.toBool();\n+            settings.setValue(\"bCoinControlFeatures\", bCoinControlFeatures);\n+            emit coinControlFeaturesChanged(bCoinControlFeatures);\n+            }\n         default:\n             break;\n         }\n@@ -235,3 +243,8 @@ bool OptionsModel::getDisplayAddresses()\n {\n     return bDisplayAddresses;\n }\n+\n+bool OptionsModel::getCoinControlFeatures()\n+{\n+    return bCoinControlFeatures;\n+}"
      },
      {
        "sha": "7a749f441eed3eb657efaada96385e7a243ed572",
        "filename": "src/qt/optionsmodel.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/optionsmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/optionsmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsmodel.h?ref=bd89534957f5660402e0cc2567d5c24f48e8dbb0",
        "patch": "@@ -26,6 +26,7 @@ class OptionsModel : public QAbstractListModel\n         Fee, // qint64\n         DisplayUnit, // BitcoinUnits::Unit\n         DisplayAddresses, // bool\n+        CoinControlFeatures, // bool\n         OptionIDRowCount\n     };\n \n@@ -44,13 +45,16 @@ class OptionsModel : public QAbstractListModel\n     bool getMinimizeOnClose();\n     int getDisplayUnit();\n     bool getDisplayAddresses();\n+    bool getCoinControlFeatures();\n private:\n     int nDisplayUnit;\n     bool bDisplayAddresses;\n     bool fMinimizeToTray;\n     bool fMinimizeOnClose;\n+    bool bCoinControlFeatures;\n signals:\n     void displayUnitChanged(int unit);\n+    void coinControlFeaturesChanged(bool);\n \n public slots:\n "
      },
      {
        "sha": "b3a28bc82eea3db86d1d7947ee45c01aa4ad9f52",
        "filename": "src/qt/sendcoinsdialog.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/sendcoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/sendcoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.cpp?ref=bd89534957f5660402e0cc2567d5c24f48e8dbb0",
        "patch": "@@ -32,6 +32,13 @@ SendCoinsDialog::SendCoinsDialog(QWidget *parent) :\n     connect(ui->clearButton, SIGNAL(clicked()), this, SLOT(clear()));\n \n     fNewRecipientAllowed = true;\n+\n+    ui->sendFrom->setFont(GUIUtil::bitcoinAddressFont());\n+}\n+\n+void SendCoinsDialog::setSendFromAddress(std::string address)\n+{\n+    ui->sendFrom->setText(QString::fromStdString(address));\n }\n \n void SendCoinsDialog::setModel(WalletModel *model)\n@@ -50,6 +57,8 @@ void SendCoinsDialog::setModel(WalletModel *model)\n     {\n         setBalance(model->getBalance(), model->getUnconfirmedBalance());\n         connect(model, SIGNAL(balanceChanged(qint64, qint64)), this, SLOT(setBalance(qint64, qint64)));\n+        connect(model->getOptionsModel(), SIGNAL(coinControlFeaturesChanged(bool)), this, SLOT(toggleSendFrom(bool)));\n+        toggleSendFrom(model->getOptionsModel()->getCoinControlFeatures());\n     }\n }\n \n@@ -58,6 +67,14 @@ SendCoinsDialog::~SendCoinsDialog()\n     delete ui;\n }\n \n+void SendCoinsDialog::toggleSendFrom(bool show)\n+{\n+    ui->labelSendFrom->setVisible(show);\n+    ui->sendFrom->setVisible(show);\n+    if (!show)\n+        ui->sendFrom->clear();\n+}\n+\n void SendCoinsDialog::on_sendButton_clicked()\n {\n     QList<SendCoinsRecipient> recipients;\n@@ -115,6 +132,7 @@ void SendCoinsDialog::on_sendButton_clicked()\n         return;\n     }\n \n+    model->setSendFromAddressRestriction(((QString)ui->sendFrom->text()).toStdString());\n     WalletModel::SendCoinsReturn sendstatus = model->sendCoins(recipients);\n     switch(sendstatus.status)\n     {\n@@ -172,6 +190,7 @@ void SendCoinsDialog::clear()\n \n     updateRemoveEnabled();\n \n+    ui->sendFrom->clear();\n     ui->sendButton->setDefault(true);\n }\n "
      },
      {
        "sha": "2501ac9dc733560f87ceab3214086b8e45dc7075",
        "filename": "src/qt/sendcoinsdialog.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/sendcoinsdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/sendcoinsdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.h?ref=bd89534957f5660402e0cc2567d5c24f48e8dbb0",
        "patch": "@@ -2,10 +2,12 @@\n #define SENDCOINSDIALOG_H\n \n #include <QDialog>\n+#include <QLineEdit>\n \n namespace Ui {\n     class SendCoinsDialog;\n }\n+class CWallet;\n class WalletModel;\n class SendCoinsEntry;\n class SendCoinsRecipient;\n@@ -30,6 +32,7 @@ class SendCoinsDialog : public QDialog\n     QWidget *setupTabChain(QWidget *prev);\n \n     void pasteEntry(const SendCoinsRecipient &rv);\n+    void setSendFromAddress(std::string address);\n     void handleURI(const QString &uri);\n \n public slots:\n@@ -47,6 +50,7 @@ public slots:\n \n private slots:\n     void on_sendButton_clicked();\n+    void toggleSendFrom(bool);\n \n     void removeEntry(SendCoinsEntry* entry);\n };"
      },
      {
        "sha": "0fd4b039c089063a892dc71fb0b8205ff101d088",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=bd89534957f5660402e0cc2567d5c24f48e8dbb0",
        "patch": "@@ -235,6 +235,11 @@ bool WalletModel::changePassphrase(const SecureString &oldPass, const SecureStri\n     return retval;\n }\n \n+void WalletModel::setSendFromAddressRestriction(std::string addresses)\n+{\n+    wallet->setSendFromAddressRestriction(addresses);\n+}\n+\n bool WalletModel::backupWallet(const QString &filename)\n {\n     return BackupWallet(*wallet, filename.toLocal8Bit().data());"
      },
      {
        "sha": "014c27b7a06b2207d2d46e64c7f8d706f7bc6272",
        "filename": "src/qt/walletmodel.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/walletmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/qt/walletmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.h?ref=bd89534957f5660402e0cc2567d5c24f48e8dbb0",
        "patch": "@@ -81,6 +81,9 @@ class WalletModel : public QObject\n     // Wallet backup\n     bool backupWallet(const QString &filename);\n \n+    // Only allow client to send from specific address(es)\n+    void setSendFromAddressRestriction(std::string addresses);\n+\n     // RAI object for unlocking wallet, returned by requestUnlock()\n     class UnlockContext\n     {"
      },
      {
        "sha": "9b77b284e6b0cfdee9f99909f0127974c94faa26",
        "filename": "src/test/wallet_tests.cpp",
        "status": "added",
        "additions": 295,
        "deletions": 0,
        "changes": 295,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/wallet_tests.cpp?ref=bd89534957f5660402e0cc2567d5c24f48e8dbb0",
        "patch": "@@ -0,0 +1,295 @@\n+#include <boost/test/unit_test.hpp>\n+\n+#include \"main.h\"\n+#include \"wallet.h\"\n+\n+// how many times to run all the tests to have a chance to catch errors that only show up with particular random shuffles\n+#define RUN_TESTS 100\n+\n+// some tests fail 1% of the time due to bad luck.\n+// we repeat those tests this many times and only complain if all iterations of the test fail\n+#define RANDOM_REPEATS 5\n+\n+using namespace std;\n+\n+typedef set<pair<const CWalletTx*,unsigned int> > CoinSet;\n+\n+BOOST_AUTO_TEST_SUITE(wallet_tests)\n+\n+static CWallet wallet;\n+static vector<COutput> vCoins;\n+\n+static void add_coin(int64 nValue, int nAge = 6*24, bool fIsFromMe = false, int nInput=0)\n+{\n+    static int i;\n+    CTransaction* tx = new CTransaction;\n+    tx->nLockTime = i++;        // so all transactions get different hashes\n+    tx->vout.resize(nInput+1);\n+    tx->vout[nInput].nValue = nValue;\n+    CWalletTx* wtx = new CWalletTx(&wallet, *tx);\n+    delete tx;\n+    if (fIsFromMe)\n+    {\n+        // IsFromMe() returns (GetDebit() > 0), and GetDebit() is 0 if vin.empty(),\n+        // so stop vin being empty, and cache a non-zero Debit to fake out IsFromMe()\n+        wtx->vin.resize(1);\n+        wtx->fDebitCached = true;\n+        wtx->nDebitCached = 1;\n+    }\n+    COutput output(wtx, nInput, nAge);\n+    vCoins.push_back(output);\n+}\n+\n+static void empty_wallet(void)\n+{\n+    BOOST_FOREACH(COutput output, vCoins)\n+        delete output.tx;\n+    vCoins.clear();\n+}\n+\n+static bool equal_sets(CoinSet a, CoinSet b)\n+{\n+    pair<CoinSet::iterator, CoinSet::iterator> ret = mismatch(a.begin(), a.end(), b.begin());\n+    return ret.first == a.end() && ret.second == b.end();\n+}\n+\n+BOOST_AUTO_TEST_CASE(coin_selection_tests)\n+{\n+    static CoinSet setCoinsRet, setCoinsRet2;\n+    static int64 nValueRet;\n+\n+    // test multiple times to allow for differences in the shuffle order\n+    for (int i = 0; i < RUN_TESTS; i++)\n+    {\n+        empty_wallet();\n+\n+        // with an empty wallet we can't even pay one cent\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf( 1 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+\n+        add_coin(1*CENT, 4);        // add a new 1 cent coin\n+\n+        // with a new 1 cent coin, we still can't find a mature 1 cent\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf( 1 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+\n+        // but we can find a new 1 cent\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n+\n+        add_coin(2*CENT);           // add a mature 2 cent coin\n+\n+        // we can't make 3 cents of mature coins\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf( 3 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+\n+        // we can make 3 cents of new  coins\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 3 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 3 * CENT);\n+\n+        add_coin(5*CENT);           // add a mature 5 cent coin,\n+        add_coin(10*CENT, 3, true); // a new 10 cent coin sent from one of our own addresses\n+        add_coin(20*CENT);          // and a mature 20 cent coin\n+\n+        // now we have new: 1+10=11 (of which 10 was self-sent), and mature: 2+5+20=27.  total = 38\n+\n+        // we can't make 38 cents only if we disallow new coins:\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf(38 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+        // we can't even make 37 cents if we don't allow new coins even if they're from us\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf(38 * CENT, 6, 6, vCoins, setCoinsRet, nValueRet));\n+        // but we can make 37 cents if we accept new coins from ourself\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(37 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 37 * CENT);\n+        // and we can make 38 cents if we accept all new coins\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(38 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 38 * CENT);\n+\n+        // try making 34 cents from 1,2,5,10,20 - we can't do it exactly\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(34 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_GT(nValueRet, 34 * CENT);         // but should get more than 34 cents\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3);     // the best should be 20+10+5.  it's incredibly unlikely the 1 or 2 got included (but possible)\n+\n+        // when we try making 7 cents, the smaller coins (1,2,5) are enough.  We should see just 2+5\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 7 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 7 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2);\n+\n+        // when we try making 8 cents, the smaller coins (1,2,5) are exactly enough.\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 8 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(nValueRet == 8 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3);\n+\n+        // when we try making 9 cents, no subset of smaller coins is enough, and we get the next bigger coin (10)\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 9 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 10 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1);\n+\n+        // now clear out the wallet and start again to test chosing between subsets of smaller coins and the next biggest coin\n+        empty_wallet();\n+\n+        add_coin( 6*CENT);\n+        add_coin( 7*CENT);\n+        add_coin( 8*CENT);\n+        add_coin(20*CENT);\n+        add_coin(30*CENT); // now we have 6+7+8+20+30 = 71 cents total\n+\n+        // check that we have 71 and not 72\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(71 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf(72 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+\n+        // now try making 16 cents.  the best smaller coins can do is 6+7+8 = 21; not as good at the next biggest coin, 20\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(16 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 20 * CENT); // we should get 20 in one coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1);\n+\n+        add_coin( 5*CENT); // now we have 5+6+7+8+20+30 = 75 cents total\n+\n+        // now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, better than the next biggest coin, 20\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(16 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT); // we should get 18 in 3 coins\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3);\n+\n+        add_coin( 18*CENT); // now we have 5+6+7+8+18+20+30\n+\n+        // and now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, the same as the next biggest coin, 18\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(16 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT);  // we should get 18 in 1 coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1); // because in the event of a tie, the biggest coin wins\n+\n+        // now try making 11 cents.  we should get 5+6\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(11 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 11 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2);\n+\n+        // check that the smallest bigger coin is used\n+        add_coin( 1*COIN);\n+        add_coin( 2*COIN);\n+        add_coin( 3*COIN);\n+        add_coin( 4*COIN); // now we have 5+6+7+8+18+20+30+100+200+300+400 = 1094 cents\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(95 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * COIN);  // we should get 1 bitcoin in 1 coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1);\n+\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(195 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 2 * COIN);  // we should get 2 bitcoins in 1 coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1);\n+\n+        // empty the wallet and start again, now with fractions of a cent, to test sub-cent change avoidance\n+        empty_wallet();\n+        add_coin(0.1*CENT);\n+        add_coin(0.2*CENT);\n+        add_coin(0.3*CENT);\n+        add_coin(0.4*CENT);\n+        add_coin(0.5*CENT);\n+\n+        // try making 1 cent from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 = 1.5 cents\n+        // we'll get sub-cent change whatever happens, so can expect 1.0 exactly\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n+\n+        // but if we add a bigger coin, making it possible to avoid sub-cent change, things change:\n+        add_coin(1111*CENT);\n+\n+        // try making 1 cent from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 1111 = 1112.5 cents\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT); // we should get the exact amount\n+\n+        // if we add more sub-cent coins:\n+        add_coin(0.6*CENT);\n+        add_coin(0.7*CENT);\n+\n+        // and try again to make 1.0 cents, we can still make 1.0 cents\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT); // we should get the exact amount\n+\n+        // run the 'mtgox' test (see http://blockexplorer.com/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)\n+        // they tried to consolidate 10 50k coins into one 500k coin, and ended up with 50k in change\n+        empty_wallet();\n+        for (int i = 0; i < 20; i++)\n+            add_coin(50000 * COIN);\n+\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(500000 * COIN, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 500000 * COIN); // we should get the exact amount\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 10); // in ten coins\n+\n+        // if there's not enough in the smaller coins to make at least 1 cent change (0.5+0.6+0.7 < 1.0+1.0),\n+        // we need to try finding an exact subset anyway\n+\n+        // sometimes it will fail, and so we use the next biggest coin:\n+        empty_wallet();\n+        add_coin(0.5 * CENT);\n+        add_coin(0.6 * CENT);\n+        add_coin(0.7 * CENT);\n+        add_coin(1111 * CENT);\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1111 * CENT); // we get the bigger coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1);\n+\n+        // but sometimes it's possible, and we use an exact subset (0.4 + 0.6 = 1.0)\n+        empty_wallet();\n+        add_coin(0.4 * CENT);\n+        add_coin(0.6 * CENT);\n+        add_coin(0.8 * CENT);\n+        add_coin(1111 * CENT);\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);   // we should get the exact amount\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2); // in two coins 0.4+0.6\n+\n+        // test avoiding sub-cent change\n+        empty_wallet();\n+        add_coin(0.0005 * COIN);\n+        add_coin(0.01 * COIN);\n+        add_coin(1 * COIN);\n+\n+        // trying to make 1.0001 from these three coins\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1.0001 * COIN, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1.0105 * COIN);   // we should get all coins\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3);\n+\n+        // but if we try to make 0.999, we should take the bigger of the two small coins to avoid sub-cent change\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(0.999 * COIN, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1.01 * COIN);   // we should get 1 + 0.01\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2);\n+\n+        // test randomness\n+        {\n+            empty_wallet();\n+            for (int i2 = 0; i2 < 100; i2++)\n+                add_coin(COIN);\n+\n+            // picking 50 from 100 coins doesn't depend on the shuffle,\n+            // but does depend on randomness in the stochastic approximation code\n+            BOOST_CHECK(wallet.SelectCoinsMinConf(50 * COIN, 1, 6, vCoins, setCoinsRet , nValueRet));\n+            BOOST_CHECK(wallet.SelectCoinsMinConf(50 * COIN, 1, 6, vCoins, setCoinsRet2, nValueRet));\n+            BOOST_CHECK(!equal_sets(setCoinsRet, setCoinsRet2));\n+\n+            int fails = 0;\n+            for (int i = 0; i < RANDOM_REPEATS; i++)\n+            {\n+                // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n+                // run the test RANDOM_REPEATS times and only complain if all of them fail\n+                BOOST_CHECK(wallet.SelectCoinsMinConf(COIN, 1, 6, vCoins, setCoinsRet , nValueRet));\n+                BOOST_CHECK(wallet.SelectCoinsMinConf(COIN, 1, 6, vCoins, setCoinsRet2, nValueRet));\n+                if (equal_sets(setCoinsRet, setCoinsRet2))\n+                    fails++;\n+            }\n+            BOOST_CHECK_NE(fails, RANDOM_REPEATS);\n+\n+            // add 75 cents in small change.  not enough to make 90 cents,\n+            // then try making 90 cents.  there are multiple competing \"smallest bigger\" coins,\n+            // one of which should be picked at random\n+            add_coin( 5*CENT); add_coin(10*CENT); add_coin(15*CENT); add_coin(20*CENT); add_coin(25*CENT);\n+\n+            fails = 0;\n+            for (int i = 0; i < RANDOM_REPEATS; i++)\n+            {\n+                // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n+                // run the test RANDOM_REPEATS times and only complain if all of them fail\n+                BOOST_CHECK(wallet.SelectCoinsMinConf(90*CENT, 1, 6, vCoins, setCoinsRet , nValueRet));\n+                BOOST_CHECK(wallet.SelectCoinsMinConf(90*CENT, 1, 6, vCoins, setCoinsRet2, nValueRet));\n+                if (equal_sets(setCoinsRet, setCoinsRet2))\n+                    fails++;\n+            }\n+            BOOST_CHECK_NE(fails, RANDOM_REPEATS);\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "15798601432532ce7b21a3ce076cf256c11f54ae",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 253,
        "deletions": 81,
        "changes": 334,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=bd89534957f5660402e0cc2567d5c24f48e8dbb0",
        "patch": "@@ -15,6 +15,34 @@ using namespace std;\n // mapWallet\n //\n \n+struct CompareValueOnly\n+{\n+    bool operator()(const pair<int64, pair<const CWalletTx*, unsigned int> >& t1,\n+                    const pair<int64, pair<const CWalletTx*, unsigned int> >& t2) const\n+    { \n+        return t1.first < t2.first; \n+    }\n+};\n+\n+void CWallet::setSendFromAddressRestriction(string addresses)\n+{\n+    boost::trim(addresses);\n+    if (addresses.empty())\n+        this->sendFromAddressRestriction.clear();\n+    else\n+        boost::split(sendFromAddressRestriction, addresses, boost::is_any_of(\";,\"));\n+}\n+\n+void CWallet::setSendFromAddressRestriction(set<string> addresses)\n+{\n+    sendFromAddressRestriction = addresses;\n+}\n+\n+void CWallet::clearSendFromAddressRestriction()\n+{\n+    sendFromAddressRestriction.clear();\n+}\n+\n std::vector<unsigned char> CWallet::GenerateNewKey()\n {\n     bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n@@ -868,106 +896,49 @@ int64 CWallet::GetUnconfirmedBalance() const\n     return nTotal;\n }\n \n-bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const\n+// populate vCoins with vector of spendable COutputs\n+void CWallet::AvailableCoins(vector<COutput>& vCoins) const\n {\n-    setCoinsRet.clear();\n-    nValueRet = 0;\n-\n-    // List of values less than target\n-    pair<int64, pair<const CWalletTx*,unsigned int> > coinLowestLarger;\n-    coinLowestLarger.first = std::numeric_limits<int64>::max();\n-    coinLowestLarger.second.first = NULL;\n-    vector<pair<int64, pair<const CWalletTx*,unsigned int> > > vValue;\n-    int64 nTotalLower = 0;\n+    vCoins.clear();\n \n     {\n-       LOCK(cs_wallet);\n-       vector<const CWalletTx*> vCoins;\n-       vCoins.reserve(mapWallet.size());\n-       for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n-           vCoins.push_back(&(*it).second);\n-       random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n-\n-       BOOST_FOREACH(const CWalletTx* pcoin, vCoins)\n-       {\n+        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        {\n+            const CWalletTx* pcoin = &(*it).second;\n+\n             if (!pcoin->IsFinal() || !pcoin->IsConfirmed())\n                 continue;\n \n             if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n                 continue;\n \n-            int nDepth = pcoin->GetDepthInMainChain();\n-            if (nDepth < (pcoin->IsFromMe() ? nConfMine : nConfTheirs))\n-                continue;\n-\n             for (int i = 0; i < pcoin->vout.size(); i++)\n             {\n-                if (pcoin->IsSpent(i) || !IsMine(pcoin->vout[i]))\n+                if (!this->sendFromAddressRestriction.empty() && !this->sendFromAddressRestriction.count(((CWalletTx *)pcoin)->GetAddressOfTxOut(i)))\n                     continue;\n \n-                int64 n = pcoin->vout[i].nValue;\n-\n-                if (n <= 0)\n-                    continue;\n-\n-                pair<int64,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin,i));\n-\n-                if (n == nTargetValue)\n-                {\n-                    setCoinsRet.insert(coin.second);\n-                    nValueRet += coin.first;\n-                    return true;\n-                }\n-                else if (n < nTargetValue + CENT)\n-                {\n-                    vValue.push_back(coin);\n-                    nTotalLower += n;\n-                }\n-                else if (n < coinLowestLarger.first)\n-                {\n-                    coinLowestLarger = coin;\n-                }\n+                if (!(pcoin->IsSpent(i)) && IsMine(pcoin->vout[i]) && pcoin->vout[i].nValue > 0)\n+                    vCoins.push_back(COutput(pcoin, i, pcoin->GetDepthInMainChain()));\n             }\n         }\n     }\n+}\n \n-    if (nTotalLower == nTargetValue || nTotalLower == nTargetValue + CENT)\n-    {\n-        for (int i = 0; i < vValue.size(); ++i)\n-        {\n-            setCoinsRet.insert(vValue[i].second);\n-            nValueRet += vValue[i].first;\n-        }\n-        return true;\n-    }\n-\n-    if (nTotalLower < nTargetValue + (coinLowestLarger.second.first ? CENT : 0))\n-    {\n-        if (coinLowestLarger.second.first == NULL)\n-            return false;\n-        setCoinsRet.insert(coinLowestLarger.second);\n-        nValueRet += coinLowestLarger.first;\n-        return true;\n-    }\n-\n-    if (nTotalLower >= nTargetValue + CENT)\n-        nTargetValue += CENT;\n-\n-    // Solve subset sum by stochastic approximation\n-    sort(vValue.rbegin(), vValue.rend());\n+static void ApproximateBestSubset(vector<pair<int64, pair<const CWalletTx*,unsigned int> > >vValue, int64 nTotalLower, int64 nTargetValue,\n+                                  vector<char>& vfBest, int64& nBest, int iterations = 1000)\n+{\n     vector<char> vfIncluded;\n-    vector<char> vfBest(vValue.size(), true);\n-    int64 nBest = nTotalLower;\n \n-    for (int nRep = 0; nRep < 1000 && nBest != nTargetValue; nRep++)\n+    vfBest.assign(vValue.size(), true);\n+    nBest = nTotalLower;\n+\n+    for (int nRep = 0; nRep < iterations && nBest != nTargetValue; nRep++)\n     {\n         vfIncluded.assign(vValue.size(), false);\n         int64 nTotal = 0;\n         bool fReachedTarget = false;\n         for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n-        {\n             for (int i = 0; i < vValue.size(); i++)\n-            {\n                 if (nPass == 0 ? rand() % 2 : !vfIncluded[i])\n                 {\n                     nTotal += vValue[i].first;\n@@ -984,12 +955,85 @@ bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfThe\n                         vfIncluded[i] = false;\n                     }\n                 }\n-            }\n+    }\n+}\n+\n+bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, vector<COutput> vCoins,\n+                                 set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const\n+{\n+    setCoinsRet.clear();\n+    nValueRet = 0;\n+\n+    // List of values less than target\n+    pair<int64, pair<const CWalletTx*,unsigned int> > coinLowestLarger;\n+    coinLowestLarger.first = std::numeric_limits<int64>::max();\n+    coinLowestLarger.second.first = NULL;\n+    vector<pair<int64, pair<const CWalletTx*,unsigned int> > > vValue;\n+    int64 nTotalLower = 0;\n+\n+    random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n+\n+    BOOST_FOREACH(COutput output, vCoins)\n+    {\n+        const CWalletTx *pcoin = output.tx;\n+\n+        if (output.nDepth < (pcoin->IsFromMe() ? nConfMine : nConfTheirs))\n+            continue;\n+\n+        int i = output.i;\n+        int64 n = pcoin->vout[i].nValue;\n+\n+        pair<int64,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n+\n+        if (n == nTargetValue)\n+        {\n+            setCoinsRet.insert(coin.second);\n+            nValueRet += coin.first;\n+            return true;\n+        }\n+        else if (n < nTargetValue + CENT)\n+        {\n+            vValue.push_back(coin);\n+            nTotalLower += n;\n+        }\n+        else if (n < coinLowestLarger.first)\n+        {\n+            coinLowestLarger = coin;\n+        }\n+    }\n+\n+    if (nTotalLower == nTargetValue)\n+    {\n+        for (int i = 0; i < vValue.size(); ++i)\n+        {\n+            setCoinsRet.insert(vValue[i].second);\n+            nValueRet += vValue[i].first;\n         }\n+        return true;\n     }\n \n-    // If the next larger is still closer, return it\n-    if (coinLowestLarger.second.first && coinLowestLarger.first - nTargetValue <= nBest - nTargetValue)\n+    if (nTotalLower < nTargetValue)\n+    {\n+        if (coinLowestLarger.second.first == NULL)\n+            return false;\n+        setCoinsRet.insert(coinLowestLarger.second);\n+        nValueRet += coinLowestLarger.first;\n+        return true;\n+    }\n+\n+    // Solve subset sum by stochastic approximation\n+    sort(vValue.rbegin(), vValue.rend(), CompareValueOnly());\n+    vector<char> vfBest;\n+    int64 nBest;\n+\n+    ApproximateBestSubset(vValue, nTotalLower, nTargetValue, vfBest, nBest, 1000);\n+    if (nBest != nTargetValue && nTotalLower >= nTargetValue + CENT)\n+        ApproximateBestSubset(vValue, nTotalLower, nTargetValue + CENT, vfBest, nBest, 1000);\n+\n+    // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n+    //                                   or the next bigger coin is closer), return the bigger coin\n+    if (coinLowestLarger.second.first &&\n+        ((nBest != nTargetValue && nBest < nTargetValue + CENT) || coinLowestLarger.first <= nBest))\n     {\n         setCoinsRet.insert(coinLowestLarger.second);\n         nValueRet += coinLowestLarger.first;\n@@ -1002,22 +1046,27 @@ bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfThe\n                 nValueRet += vValue[i].first;\n             }\n \n+#ifdef DEBUG\n         //// debug print\n         printf(\"SelectCoins() best subset: \");\n         for (int i = 0; i < vValue.size(); i++)\n             if (vfBest[i])\n                 printf(\"%s \", FormatMoney(vValue[i].first).c_str());\n         printf(\"total %s\\n\", FormatMoney(nBest).c_str());\n+#endif\n     }\n \n     return true;\n }\n \n bool CWallet::SelectCoins(int64 nTargetValue, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const\n {\n-    return (SelectCoinsMinConf(nTargetValue, 1, 6, setCoinsRet, nValueRet) ||\n-            SelectCoinsMinConf(nTargetValue, 1, 1, setCoinsRet, nValueRet) ||\n-            SelectCoinsMinConf(nTargetValue, 0, 1, setCoinsRet, nValueRet));\n+    vector<COutput> vCoins;\n+    AvailableCoins(vCoins);\n+\n+    return (SelectCoinsMinConf(nTargetValue, 1, 6, vCoins, setCoinsRet, nValueRet) ||\n+            SelectCoinsMinConf(nTargetValue, 1, 1, vCoins, setCoinsRet, nValueRet) ||\n+            SelectCoinsMinConf(nTargetValue, 0, 1, vCoins, setCoinsRet, nValueRet));\n }\n \n \n@@ -1496,6 +1545,129 @@ int64 CWallet::GetOldestKeyPoolTime()\n     return keypool.nTime;\n }\n \n+std::map<std::string, int64> CWallet::GetAddressBalances()\n+{\n+    map<string, int64> balances;\n+\n+    {\n+        LOCK(cs_wallet);\n+        BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n+        {\n+            CWalletTx *pcoin = &walletEntry.second;\n+\n+            if (!pcoin->IsFinal() || !pcoin->IsConfirmed())\n+                continue;\n+\n+            if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n+                continue;\n+\n+            int nDepth = pcoin->GetDepthInMainChain();\n+            if (nDepth < (pcoin->IsFromMe() ? 0 : 1))\n+                continue;\n+\n+            for (int i = 0; i < pcoin->vout.size(); i++)\n+            {\n+                if (!IsMine(pcoin->vout[i]))\n+                    continue;\n+\n+                int64 n = pcoin->IsSpent(i) ? 0 : pcoin->vout[i].nValue;\n+\n+                string addr = pcoin->GetAddressOfTxOut(i);\n+                if (!balances.count(addr))\n+                    balances[addr] = 0;\n+                balances[addr] += n;\n+            }\n+        }\n+    }\n+\n+    return balances;\n+}\n+\n+set< set<string> > CWallet::GetAddressGroupings()\n+{\n+    set< set<string> > groupings;\n+    set<string> grouping;\n+\n+    BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n+    {\n+        CWalletTx *pcoin = &walletEntry.second;\n+\n+        if (!pcoin->IsFinal() || !pcoin->IsConfirmed())\n+            continue;\n+\n+        if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n+            continue;\n+\n+        int nDepth = pcoin->GetDepthInMainChain();\n+        if (nDepth < (pcoin->IsFromMe() ? 0 : 1))\n+            continue;\n+\n+        if (pcoin->vin.size() > 0 && IsMine(pcoin->vin[0]))\n+        {\n+            // group all input addresses with each other\n+            BOOST_FOREACH(CTxIn txin, pcoin->vin)\n+                grouping.insert(mapWallet[txin.prevout.hash].GetAddressOfTxOut(txin.prevout.n));\n+\n+            // group change with input addresses\n+            BOOST_FOREACH(CTxOut txout, pcoin->vout)\n+                if (IsChange(txout))\n+                {\n+                    CWalletTx tx = mapWallet[pcoin->vin[0].prevout.hash];\n+                    string addr = tx.GetAddressOfTxOut(pcoin->vin[0].prevout.n);\n+                    CBitcoinAddress txoutAddr;\n+                    ExtractAddress(txout.scriptPubKey, txoutAddr);\n+                    grouping.insert(txoutAddr.ToString());\n+                }\n+            groupings.insert(grouping);\n+            grouping.clear();\n+        }\n+\n+        // group lone addrs by themselves\n+        for (int i = 0; i < pcoin->vout.size(); i++)\n+            if (IsMine(pcoin->vout[i]))\n+            {\n+                grouping.insert(pcoin->GetAddressOfTxOut(i));\n+                groupings.insert(grouping);\n+                grouping.clear();\n+            }\n+    }\n+\n+    set< set<string>* > uniqueGroupings; // a set of pointers to groups of addresses\n+    map< string, set<string>* > setmap;  // map addresses to the unique group containing it\n+    BOOST_FOREACH(set<string> grouping, groupings)\n+    {\n+        // make a set of all the groups hit by this new group\n+        set< set<string>* > hits;\n+        map< string, set<string>* >::iterator it;\n+        BOOST_FOREACH(string address, grouping)\n+            if ((it = setmap.find(address)) != setmap.end())\n+                hits.insert((*it).second);\n+\n+        // merge all hit groups into a new single group and delete old groups\n+        set<string>* merged = new set<string>(grouping);\n+        BOOST_FOREACH(set<string>* hit, hits)\n+        {\n+            merged->insert(hit->begin(), hit->end());\n+            uniqueGroupings.erase(hit);\n+            delete hit;\n+        }\n+        uniqueGroupings.insert(merged);\n+\n+        // update setmap\n+        BOOST_FOREACH(string element, *merged)\n+            setmap[element] = merged;\n+    }\n+\n+    set< set<string> > ret;\n+    BOOST_FOREACH(set<string>* uniqueGrouping, uniqueGroupings)\n+    {\n+        ret.insert(*uniqueGrouping);\n+        delete uniqueGrouping;\n+    }\n+\n+    return ret;\n+}\n+\n vector<unsigned char> CReserveKey::GetReservedKey()\n {\n     if (nIndex == -1)"
      },
      {
        "sha": "614480110b47815db402a4faa0495a57d2b4d4ef",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 48,
        "deletions": 1,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd89534957f5660402e0cc2567d5c24f48e8dbb0/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=bd89534957f5660402e0cc2567d5c24f48e8dbb0",
        "patch": "@@ -13,6 +13,7 @@\n class CWalletTx;\n class CReserveKey;\n class CWalletDB;\n+class COutput;\n \n /** (client) version numbers for particular wallet features */\n enum WalletFeature\n@@ -31,7 +32,7 @@ enum WalletFeature\n class CWallet : public CCryptoKeyStore\n {\n private:\n-    bool SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const;\n+    void AvailableCoins(std::vector<COutput>& vCoins) const;\n     bool SelectCoins(int64 nTargetValue, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const;\n \n     CWalletDB *pwalletdbEncryption;\n@@ -82,9 +83,17 @@ class CWallet : public CCryptoKeyStore\n \n     std::vector<unsigned char> vchDefaultKey;\n \n+    std::set<std::string> sendFromAddressRestriction;\n+\n+    void setSendFromAddressRestriction(std::string addresses);\n+    void setSendFromAddressRestriction(std::set<std::string> addresses);\n+    void clearSendFromAddressRestriction();\n+\n     // check whether we are allowed to upgrade (or already support) to the named feature\n     bool CanSupportFeature(enum WalletFeature wf) { return nWalletMaxVersion >= wf; }\n \n+    bool SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, std::vector<COutput> vCoins, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const;\n+\n     // keystore implementation\n     // Generate a new key\n     std::vector<unsigned char> GenerateNewKey();\n@@ -133,6 +142,9 @@ class CWallet : public CCryptoKeyStore\n     int64 GetOldestKeyPoolTime();\n     void GetAllReserveAddresses(std::set<CBitcoinAddress>& setAddress);\n \n+    std::set< std::set<std::string> > GetAddressGroupings();\n+    std::map<std::string, int64> GetAddressBalances();\n+\n     bool IsMine(const CTxIn& txin) const;\n     int64 GetDebit(const CTxIn& txin) const;\n     bool IsMine(const CTxOut& txout) const\n@@ -566,6 +578,13 @@ class CWalletTx : public CMerkleTx\n         return true;\n     }\n \n+    std::string GetAddressOfTxOut(int n)\n+    {\n+        CBitcoinAddress addr;\n+        ExtractAddress(vout[n].scriptPubKey, addr);\n+        return addr.ToString();\n+    }\n+\n     bool WriteToDisk();\n \n     int64 GetTxTime() const;\n@@ -581,6 +600,34 @@ class CWalletTx : public CMerkleTx\n };\n \n \n+\n+\n+class COutput\n+{\n+public:\n+    const CWalletTx *tx;\n+    int i;\n+    int nDepth;\n+\n+    COutput(const CWalletTx *txIn, int iIn, int nDepthIn)\n+    {\n+        tx = txIn; i = iIn; nDepth = nDepthIn;\n+    }\n+\n+    std::string ToString() const\n+    {\n+        return strprintf(\"COutput(%s, %d, %d) [%s]\", tx->GetHash().ToString().substr(0,10).c_str(), i, nDepth, FormatMoney(tx->vout[i].nValue).c_str());\n+    }\n+\n+    void print() const\n+    {\n+        printf(\"%s\\n\", ToString().c_str());\n+    }\n+};\n+\n+\n+\n+\n /** Private key that includes an expiration date in case it never gets used. */\n class CWalletKey\n {"
      }
    ]
  }
]